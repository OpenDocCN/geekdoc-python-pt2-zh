- en: '**B**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Overview of Python Topics**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The aim of this appendix is twofold: to provide a quick refresher on some Python
    topics that weren’t thoroughly introduced in the chapters and to introduce topics
    that will help you write better Python programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**if __name__ == ''__main__''**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Throughout the book, we’ve used the following block of code, where `func()`
    is a function we’ve defined in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This block of code ensures that the statements within the block are executed
    only when the program is run on its own.
  prefs: []
  type: TYPE_NORMAL
- en: When a program runs, the special variable `__name__` is set to `__main__` automatically,
    so the `if` condition evaluates to `True` and the function `func()` is called.
    However, `__name__` is set differently when you import the program into another
    program (see “[Reusing Code](app02.html#app02lev1sec07)” on [page 235](app02.html#page_235)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick demonstration. Consider the following program, which we’ll call
    *factorial.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The program defines a function, `fact()`, that calculates the factorial of
    the integer passed to it. When you run it, it prints `__main__`, which corresponds
    to the `print` statement at ➊, because `__name__` is automatically set to `__main__`.
    Then, it asks an integer to be entered, calculates the factorial, and prints it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, say you need to calculate the factorial in another program. Instead of
    writing the function again, you decide to reuse this function by importing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that both the programs must be in the same directory. When you run this
    program, you’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When your program is imported by another program, the value of the variable
    `__main__` is set to that program’s filename, without the extension. In this case,
    the value of `__name__` is `factorial` instead of `__main__`. Because the condition
    `__name__ == '__main__'` now evaluates to `False`, the program doesn’t ask for
    the user’s input anymore. Remove the condition to see for yourself what happens!
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, it’s good practice to use `if __name__ == '__main__'` in your
    programs so that the statements you want executed when your program is run as
    a standalone are also *not* executed when your program is imported into another
    program.
  prefs: []
  type: TYPE_NORMAL
- en: '**List Comprehensions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we have a list of integers and we want to create a new list containing
    the squares of the elements of the original list. Here’s one way that we could
    do this that’s already familiar to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used a code pattern that we’ve used in various programs throughout
    the book. We create an empty list, `x_square`, and then successively append to
    it as we calculate the square. We can do this in a more efficient way using *list
    comprehensions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The statement at ➌ is referred to as a *list comprehension* in Python. It consists
    of an expression—here, `n**2`—followed by a `for` loop, `for n in x`. Note that
    it basically allows us to combine the two statements at ➊ and ➋ into one to create
    a new list in one statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, consider one of the programs we wrote in “[Drawing the
    Trajectory](ch02.html#ch02lev3sec05)” on [page 51](ch02.html#page_51) to draw
    the trajectory of a body in projectile motion. In these programs, we have the
    following block of code to calculate the *x*- and *y*-coordinates of the body
    at each time instant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using list comprehension, you can rewrite the block of code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code is more compact now, as you didn’t have to create the empty lists,
    write a `for` loop, and append to the lists. List comprehension lets you do this
    in a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add conditionals to a list comprehension in order to selectively
    choose which list items are evaluated in the expression. Consider, once again,
    the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this list comprehension, we use the `if` condition to explicitly tell Python
    to evaluate the expression `n**2` only on the even list items of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dictionary Data Structure**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We first used a Python dictionary in [Chapter 4](ch04.html#ch04) while implementing
    the `subs()` method in SymPy. Let’s explore Python dictionaries in more detail.
    Consider a simple dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a dictionary with two keys—`'key1'` and `'key2'`—with values
    `5` and `20`, respectively. Only strings, numbers, and tuples can be keys in a
    Python dictionary. These data types are referred to as *immutable* data types—once
    created, they can’t be changed—so a list can’t be a key because we can add and
    remove elements from a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know that to retrieve the value corresponding to `''key1''` in the
    dictionary, we need to specify it as `d[''key1'']`. This is one of the most common
    use cases of a dictionary. A related use case is checking whether the dictionary
    contains a certain key, `''x''`. We can check that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we create a dictionary, we can add a new key-value pair to it, similar
    to how we can append elements to a list. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet checks whether the key `'x'` already exists in the dictionary,
    `d`. If it does, it prints the value corresponding to it; otherwise, it adds the
    key to the dictionary with `1` as the corresponding value. Similar to Python’s
    behavior with sets, Python can’t guarantee a particular order of the key-value
    pairs in a dictionary. The key-value pairs can be in any order, irrespective of
    the order of insertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides specifying the key as an index to the dictionary, we can also use the
    `get()` method to retrieve the value corresponding to the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you specify a nonexistent key to the `get()` method, `None` is returned.
    On the other hand, if you do so while using the index style of retrieving, you’ll
    get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get()` method also lets you set a default value for nonexistent keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s no key `''y''` in the dictionary `d`, so `0` is returned. If there
    is a key, however, the value is returned instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keys()` and `values()` methods each return a list-like data structure
    of all the keys and values, respectively, in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To iterate over the key and value pairs in a dictionary, use the `items()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This method returns a *view* of tuples, and each tuple is a key-value pair.
    We can use the following code snippet to print them nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Views are more memory efficient than lists, and they don’t let you add or remove
    items.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple Return Values**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the programs we’ve written so far, most of the functions return a single
    value, but functions sometimes return multiple values. We saw an example of such
    a function in “[Measuring the Dispersion](ch03.html#ch03lev1sec04)” on [page 71](ch03.html#page_71),
    where in the program to find the range, we returned three numbers from the `find_range()`
    function. Here’s another example of the approach we took there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `components()` function accepts a velocity, `u`, and an angle, `theta`,
    in radians as parameters, and it calculates the `x` and `y` components and returns
    them. To return the calculated components, we simply list the corresponding Python
    labels in the return statement separated by a comma. This creates and returns
    a tuple consisting of the items `x` and `y`. In the calling code, we receive the
    multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `components()` function returns a tuple, we can retrieve the returned
    values using tuple indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This has advantages because we don’t have to know all the different values being
    returned. For one, you don’t have to write `x,y,z = myfunc1()` when the function
    returns three values or `a,x,y,z = myfunc1()` when the function returns four values,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In either of the preceding cases, the code calling the `components()` function
    must know which of the return values correspond to which component of the velocity,
    as there’s no way to know that from the values themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'A user-friendly approach is to return a dictionary object instead, as we saw
    in the case of SymPy’s `solve()` function when used with the `dict=True` keyword
    argument. Here’s how we can rewrite the preceding components function to return
    a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we return a dictionary with the keys `''x''` and `''y''` referring to
    the `x` and `y` components and their corresponding numerical values. With this
    new function definition, we don’t need to worry about the order of the returned
    values. We just use the key `''x''` to retrieve the `x` component and the key
    `''y''` to retrieve the `y` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach eliminates the need to use indices to refer to a specific returned
    value. The following code rewrites the program to find the range (see “[Measuring
    the Dispersion](ch03.html#ch03lev1sec04)” on [page 71](ch03.html#page_71)) so
    that the results are returned as a dictionary instead of a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `find_range()` function now returns a dictionary with the keys `lowest`,
    `highest`, and `range` and with the lowest number, highest number, and the range
    as their corresponding values. At ➊, we simply use the corresponding key to retrieve
    the corresponding value.
  prefs: []
  type: TYPE_NORMAL
- en: If we were just interested in the range of a group of numbers and we didn’t
    care about the lowest and highest numbers, we’d just use `result['range']` and
    not worry about what other values were returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception Handling**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html#ch01), we learned that trying to convert a string
    such as `''1.1''` to an integer using the `int()` function results in a `ValueError`
    exception. But with a `try...except` block, we can print a user-friendly error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When any statement in the `try` block raises an exception, the type of exception
    raised is matched with the one specified by the `except` statement. If there’s
    a match, the program resumes in the `except` block. If the exception doesn’t match,
    the program execution halts and displays the exception. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code block attempts a division by 0, which results in a `ZeroDivisionError`
    exception. Although the division is carried out in a `try...except` block, the
    exception type is incorrectly specified, and the exception isn’t handled correctly.
    The correct way to handle this exception is to specify `ZeroDivisionError` as
    the exception type.
  prefs: []
  type: TYPE_NORMAL
- en: '***Specifying Multiple Exception Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also specify multiple exception types. Consider the function `reciprocal()`,
    which returns the reciprocal of the number passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We defined the function `reciprocal()`, which prints the reciprocal of the user’s
    input. We know that if the function is called with 0, it’ll cause a `ZeroDivisionError`
    exception. If you pass a string, however, it’ll cause a `TypeError` exception.
    The function considers both these cases as invalid input and specifies both `ZeroDivisionError`
    and `TypeError` in the `except` statement as a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try calling the function with a valid input—that is, a nonzero number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we call the function with 0 as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `0` argument raises the `ZeroDivisionError` exception, which is in the tuple
    of exception types specified to the `except` statement, so the code prints an
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s enter a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we entered an invalid number, which raises the `TypeError` exception.
    This exception is also in the tuple of specified exceptions, so the code prints
    an error message. If you want to give a more specific error message, we can just
    specify multiple `except` statements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In addition to `TypeError`, `ValueError`, and `ZeroDivisionError`, there are
    a number of other built-in exception types. The Python documentation at *[https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions](https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions)*
    lists the builtin exceptions for Python 3.4.
  prefs: []
  type: TYPE_NORMAL
- en: '***The else Block***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `else` block is used to specify which statements to execute when there’s
    no exception. Consider an example from the program we wrote to draw the trajectory
    of a projectile (see “[Drawing the Trajectory](ch02.html#ch02lev3sec05)” on [page
    51](ch02.html#page_51)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the input for `u` or `theta` couldn’t be converted to a floating point number,
    it doesn’t make sense for the program to call the `draw_trajectory()` and `plt.show()`
    functions. Instead, we specify these two statements in the `else` block at ➊.
    Using `try...except...else` will let you manage different types of errors during
    runtime and take appropriate action when there is an error or when there is none:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. If there’s an exception and there’s an `except` statement corresponding
    to the exception type raised, the execution is transferred to the corresponding
    `except` block.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. If there’s no exception, the execution is transferred to the `else` block.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading Files in Python**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Opening a file is the first step to reading data from it. Let’s start with
    a quick example. Consider a file that consists of a collection of numbers with
    one number per line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to write a function that reads the file and returns a list of those
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the function `read_data()` and create an empty list to store
    all of the numbers. At ➊, we use the `open()` function to open the file whose
    location has been specified via the argument path. An example of the path would
    be */home/username/mydata.txt* on Linux, *C:\mydata.txt* on Microsoft Windows,
    or */Users/Username/mydata.txt* on OS X. The `open()` function returns a file
    object, which we use the label `f` to refer to. We can go over each line of the
    file using a `for` loop at ➋. Because each line is returned as a string, we convert
    it into a number and append it to the list `numbers`. The loop stops executing
    once all the lines have been read, and we close the file using the `close()` method.
    Finally, we return the `numbers` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is similar to how we read the numbers from a file in [Chapter 3](ch03.html#ch03),
    although we didn’t have to close the file explicitly because we used a different
    approach there. Using the approach we took in [Chapter 3](ch03.html#ch03), we
    would rewrite the preceding function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The key statement here is at ➊. It’s similar to writing `f = open(path)` but
    only partially. Besides opening the file and assigning the file object returned
    by `open()` to `f`, it also sets up a new *context* with all the statements in
    that block—in this case, all the statements before the `return` statement. When
    all the statements in the body have been executed, the file is automatically closed.
    That is, when the execution reaches the statement at ➋, the file is closed without
    needing an explicit call to the `close()` method. This method also means that
    if there are any exceptions while working with the file, it’ll still be closed
    before the program exits. This is the preferred approach to working with files.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reading All the Lines at Once***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of reading the lines one by one to build a list, we can use the `readlines()`
    method to read all the lines into a list at once. This results in a more compact
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We read all the lines of the file into a list using the `readlines()` method
    at ➊. Then, we convert each of the items in the list into a floating point number
    using the `float()` function and list comprehension. Finally, we return the list
    `numbers`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Specifying the Filename as Input***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `read_data()` function takes the file path as an argument. If your program
    allows you to specify the filename as an input, this function should work for
    any file as long as the file contains data we expect to read. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve added this code to the end of the `read_data()` function and run
    it, it’ll ask you to input the path to the file. Then, it’ll print the numbers
    it reads from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the path of the file /home/amit/work/mydata.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[100.0,60.0,70.0,900.0,100.0,200.0,500.0,500.0,503.0,600.0,1000.0,1200.0]'
  prefs: []
  type: TYPE_NORMAL
- en: '***Handling Errors When Reading Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a couple of things that can go wrong when reading files: (1) the
    file can’t be read, or (2) the data in the file isn’t in the expected format.
    Here’s an example of what happens when a file can’t be read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Because I entered a file path that doesn’t exist, the `FileNotFoundError` exception
    is raised when we try to open the file. We can make the program display a user-friendly
    error message by modifying our `read_data()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you specify a nonexistent file path, you’ll get an error message
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The second source of errors can be that the data in the file isn’t what your
    program expects to read. For example, consider a file that has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The third line in this file isn’t convertible to a floating point number because
    it has the letter `o` in it instead of the number `0`, and the fourth line consists
    of `1/5`, a fraction in string form, which `float()` can’t handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you supply this data file to the earlier program, it’ll produce the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The third line in the file is `3o`, not the number `30`, so when we attempt
    to convert it into a floating point number, the result is `ValueError`. There
    are two approaches you can take when such data is present in a file. The first
    is to report the error and exit the program. The modified `read_data()` function
    would appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We insert another `try...except` block in the function starting at ➊, and we
    convert the line into a floating point number at ➋. If the program raises the
    `ValueError` exception, we print an error message with the offending line and
    exit out of the `for` loop using `break` at ➌. The program then stops reading
    the file. The returned list, `numbers`, contains all the data that was successfully
    read before encountering the bad data. If there’s no error, we append the floating
    point number to the `numbers` list at ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when you supply the file *bad_data.txt* to the program, it’ll read only
    the first two lines, display the error message, and exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Returning partial data may not be desirable, so we could just replace the break
    statement at ➌ with `return` and no data would be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach is to ignore the error and continue with the rest of the
    file. Here’s a modified `read_data()` function that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The only change here is that instead of breaking out of the `for` loop, we
    just continue with the next iteration using the `continue` statement at ➊. The
    output from the program is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The specific application where you’re reading the file will determine which
    of the above approaches you want to take to handle bad data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reusing Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this book, we’ve used classes and functions that were either part
    of the Python standard library or available after installing third-party packages,
    such as matplotlib and SymPy. Now we’ll look at a quick example of how we can
    import our own programs into other programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the function `find_corr_x_y()` that we wrote in “[Calculating the
    Correlation Between Two Data Sets](ch03.html#ch03lev1sec05)” on [page 75](ch03.html#page_75).
    We’ll create a separate file, *correlation.py*, which has only the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the *.py* file extension, a Python file is referred to as a module.
    This is usually reserved for files that define classes and functions that’ll be
    used in other programs. The following program imports the `find_corr_x_y()` function
    from the correlation module we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This program finds the correlation between the high school math grades and college
    admission scores of students we considered in [Table 3-3](ch03.html#ch3tab3) on
    [page 80](ch03.html#page_80). We import the `find_corr_x_y()` function from the
    correlation module, create the lists representing the two sets of grades, and
    call the `find_corr_x_y()` function with the two lists as arguments. When you
    run the program, it’ll print the correlation coefficient. Note that the two files
    must be in the same directory—this is strictly to keep things simple.
  prefs: []
  type: TYPE_NORMAL
