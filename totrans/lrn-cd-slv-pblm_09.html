<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_237"/><span class="big">9</span><br/>DESIGNING ALGORITHMS WITH COMPLETE SEARCH</h2>&#13;&#13;
<div class="imagec"><img src="Images/common.jpg" alt="image" width="150" height="150"/></div>&#13;&#13;
<p class="noindents">An <em>algorithm</em> is a sequence of steps that solves a problem. For each problem in this book, we solved it by writing an algorithm in the form of Python code. We’ll focus in this chapter on designing algorithms. When faced with a new problem, sometimes it’s hard to know what to do to solve it. What algorithm should we write? Fortunately, we don’t need to start from scratch each time. Computer scientists and programmers have identified several general types of algorithms, and it’s likely that at least one of them can be used to solve our problem.</p>&#13;&#13;
<p class="indent">One type of algorithm is called a <em>complete search</em> algorithm; it involves trying all candidate solutions and choosing the best one. For example, if the problem asks us to find a maximum, we try all solutions and choose the largest; if the problem asks us to find a minimum, we try all solutions and choose the smallest. Complete-search algorithms are also known as <em>brute-force</em> algorithms, but I’ll avoid that term. It’s true that the computer is <span epub:type="pagebreak" id="page_238"/>powering its way through, checking solution after solution, but there’s nothing brute force about what we’re doing as algorithm designers.</p>&#13;&#13;
<p class="indent">We used a complete-search algorithm to solve Village Neighborhood in <a href="ch05.xhtml#ch05">Chapter 5</a>. We were asked to find the smallest size of the neighborhoods, and we did that by looking at each neighborhood and remembering the size of the smallest one. In this chapter, we’ll use complete-search algorithms to solve other problems. We’ll see that it can take considerable ingenuity to determine what exactly to search.</p>&#13;&#13;
<p class="indent">We’ll solve two problems using complete search: determining which lifeguard to fire and identifying the minimum cost to meet ski training camp requirements. Then we’ll see a third problem, counting triples of cows that meet given observations, that requires we go a little further.</p>&#13;&#13;
<h3 class="h3a" id="ch09lev1sec1"><span class="h3aa">Problem #21: Lifeguards</span></h3>&#13;&#13;
<p class="noindent">In this problem, we’ll need to determine which lifeguard to fire that leaves us with the maximum schedule coverage of a pool. We’ll try separately firing each one and observing the results—that’s a complete-search algorithm!</p>&#13;&#13;
<p class="indent">This is USACO 2018 January Bronze Contest problem Lifeguards.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec1">The Challenge</h4>&#13;&#13;
<p class="noindent">Farmer John has purchased a swimming pool for his cows. The pool is open from time 0 to time 1000.</p>&#13;&#13;
<p class="indent">Farmer John hires <em>n</em> lifeguards to monitor the pool. Each lifeguard monitors the pool for a given interval of time. For example, a lifeguard might start at time 2 and end at time 7. I’ll denote such an interval as 2–7. The number of units of time covered by an interval is the ending time minus the starting time. For example, the lifeguard whose time interval is 2–7 covers 7 – 2 = 5 units of time. Those time units are from time 2 to 3, 3 to 4, 4 to 5, 5 to 6, and 6 to 7.</p>&#13;&#13;
<p class="indent">Unfortunately, Farmer John only has enough money to pay for <em>n</em> – 1 lifeguards, not <em>n</em> lifeguards, so he must fire one lifeguard.</p>&#13;&#13;
<p class="indent">Determine the maximum number of units of time that can still be covered after firing one lifeguard.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec2">Input</h4>&#13;&#13;
<p class="noindent">Read input from the file named <em>lifeguards.in</em>.</p>&#13;&#13;
<p class="indent">The input consists of the following lines:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">A line containing <em>n</em>, the number of lifeguards who were hired. <em>n</em> is between 1 and 100.</li>&#13;&#13;
<li class="noindent"><em>n</em> lines, one per lifeguard. Each line gives the time when the lifeguard starts, a space, and the time when the lifeguard ends. The start and end times are all integers between 0 and 1,000 and are all distinct.</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch09lev2sec3"><span epub:type="pagebreak" id="page_239"/>Output</h4>&#13;&#13;
<p class="noindent">Write output to the file named <em>lifeguards.out</em>.</p>&#13;&#13;
<p class="indent">Output the maximum number of units of time that can be covered by <em>n</em> – 1 of the lifeguards.</p>&#13;&#13;
<p class="indent">The time limit for solving each test case is four seconds.</p>&#13;&#13;
<h3 class="h3" id="ch09lev1sec2">Exploring a Test Case</h3>&#13;&#13;
<p class="noindent">Let’s explore a test case to help justify why a complete-search algorithm makes sense for this problem. Here’s the test case:</p>&#13;&#13;
<pre>4<br/>&#13;&#13;
5 8<br/>&#13;&#13;
10 15<br/>&#13;&#13;
17 25<br/>&#13;&#13;
9 20</pre>&#13;&#13;
<p class="indent">One simple rule you might try to use to solve this problem is to fire the lifeguard with the shortest time interval. That makes some intuitive sense, because it seems as though that lifeguard contributes the least to covering the pool.</p>&#13;&#13;
<p class="indent">Does this rule give us a correct algorithm? Let’s see. It tells us to fire the 5–8 lifeguard, since that lifeguard has the shortest time interval. That leaves us with the three lifeguards whose time intervals are 10–15, 17–25, and 9–20. These three remaining lifeguards cover exactly the interval 9–25, which consists of 25 – 9 = 16 units of time. Is 16 the correct answer?</p>&#13;&#13;
<p class="indent">Unfortunately, no. It turns out that what we should have done is fire the 10–15 lifeguard. If we do that, then we’re left with the three lifeguards whose time intervals are 5–8, 17–25, and 9–20. These three remaining lifeguards cover the intervals 5–8 and 9–25. (Careful: they don’t cover the unit of time from 8 to 9.) The first of these intervals covers 8 – 5 = 3 units of time, and the second covers 25 – 9 = 16 units of time, for a total of 19 units of time.</p>&#13;&#13;
<p class="indent">The correct answer is 19, not 16. Firing the lifeguard with the shortest time interval didn’t work.</p>&#13;&#13;
<p class="indent">It’s not easy to come up with a simple rule that always works to solve this problem. We don’t need to worry, though: with a complete-search algorithm, we dodge this requirement entirely.</p>&#13;&#13;
<p class="indent">Here’s what our complete-search algorithm will do to solve our test case:</p>&#13;&#13;
<ol>&#13;&#13;
<li class="noindent">First, it will ignore the first lifeguard and determine the number of units of time that the three remaining lifeguards cover. It will obtain an answer of 16. It will remember 16 as the score to beat.</li>&#13;&#13;
<li class="noindent">Next, it will ignore the second lifeguard and determine the number of units of time that the three remaining lifeguards cover. It will obtain an answer of 19. Since 19 is greater than 16, it will remember 19 as the score to beat.</li>&#13;&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_240"/>Next, it will ignore the third lifeguard and determine the number of units of time that the three remaining lifeguards cover. It will obtain an answer of 14. The score to beat is still 19.</li>&#13;&#13;
<li class="noindent">Finally, it will ignore the fourth lifeguard and determine the number of units of time that the three remaining lifeguards cover. It will obtain an answer of 16. The score to beat is still 19.</li>&#13;&#13;
</ol>&#13;&#13;
<p class="indent">Having considered the ramifications of firing each lifeguard, the algorithm concludes that 19 is the correct answer. There can be no better answer than this, because we tried every option! We performed a complete search of the possible solutions.</p>&#13;&#13;
<h3 class="h3" id="ch09lev1sec3">Solving the Problem</h3>&#13;&#13;
<p class="noindent">To use complete search, it’s often helpful to begin by writing a function that solves the problem for a particular candidate solution. We can then call that function many times, once for each candidate solution.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec4">Firing One Lifeguard</h4>&#13;&#13;
<p class="noindent">Let’s write a function to determine the number of time units that are covered when one particular lifeguard is fired. <a href="ch09.xhtml#ch09ex01">Listing 9-1</a> shows the code.</p>&#13;&#13;
<pre>def num_covered(intervals, fired):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    intervals is a list of lifeguard intervals;<br/>&#13;&#13;
    each interval is a [start, end] list.<br/>&#13;&#13;
    fired is the index of the lifeguard to fire.<br/>&#13;&#13;
<br/>&#13;&#13;
    Return the number of time units covered by all lifeguards<br/>&#13;&#13;
    except the one fired.<br/>&#13;&#13;
    """<br/>&#13;&#13;
 <span class="ent">❶</span> covered = set()<br/>&#13;&#13;
    for i in range(len(intervals)):<br/>&#13;&#13;
        if i != fired:<br/>&#13;&#13;
            interval = intervals[i]<br/>&#13;&#13;
         <span class="ent">❷</span> for j in range(interval[0], interval[1]):<br/>&#13;&#13;
             <span class="ent">❸</span> covered.add(j)<br/>&#13;&#13;
    return len(covered)</pre>&#13;&#13;
<p class="ex-caption" id="ch09ex01"><em>Listing 9-1: Solving when one particular lifeguard is fired</em></p>&#13;&#13;
<p class="indent">The first parameter is a list of lifeguard time intervals; the second is the index of the lifeguard to fire. Enter the code into the Python shell. Here are two sample calls of the function:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 0)</span><br/>&#13;&#13;
16<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_241"/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 1)</span><br/>&#13;&#13;
19</pre>&#13;&#13;
<p class="indent">These calls confirm that we can cover 16 units of time if we fire lifeguard 0 and can cover 19 units of time if we fire lifeguard 1.</p>&#13;&#13;
<p class="indent">Now let’s understand how the function operates. We begin by creating a set that will hold the units of time that are covered <span class="ent">❶</span>. Whenever a unit of time is covered, the code will add the start of that unit of time to the set. For example, if the unit of time from 0 to 1 is covered, then the code will add <code>0</code> to the set; if the unit of time from 4 to 5 is covered, it will add <code>4</code> to the set.</p>&#13;&#13;
<p class="indent">We loop through the lifeguard time intervals. If a lifeguard isn’t fired, then we loop through this lifeguard’s time interval <span class="ent">❷</span> to consider each unit of covered time. We add each of these time units to the set <span class="ent">❸</span>, as promised. Recall that sets don’t retain duplicate values; we don’t have to worry if we try to add the same unit of time multiple times. We’ve gone through all of the nonfired lifeguards and added to the set all units of time that are covered. We therefore simply return the number of values in the set.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec5">The Main Program</h4>&#13;&#13;
<p class="noindent">The main part of our program is in <a href="ch09.xhtml#ch09ex02">Listing 9-2</a>. It uses the <code>num_covered</code> function to determine the number of units of time that are covered when separately firing each lifeguard. Be sure to enter our <code>num_covered</code> function (<a href="ch09.xhtml#ch09ex01">Listing 9-1</a>) before this code for a complete solution to the problem.</p>&#13;&#13;
<pre>input_file = open('lifeguards.in', 'r')<br/>&#13;&#13;
output_file = open('lifeguards.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
n = int(input_file.readline())<br/>&#13;&#13;
<br/>&#13;&#13;
intervals = []<br/>&#13;&#13;
<br/>&#13;&#13;
for i in range(n):<br/>&#13;&#13;
 <span class="ent">❶</span> interval = input_file.readline().split()<br/>&#13;&#13;
    interval[0] = int(interval[0])<br/>&#13;&#13;
    interval[1] = int(interval[1])<br/>&#13;&#13;
    intervals.append(interval)<br/>&#13;&#13;
<br/>&#13;&#13;
   max_covered = 0<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❷</span> for fired in range(n):<br/>&#13;&#13;
    <span class="ent">❸</span> result = num_covered(intervals, fired)<br/>&#13;&#13;
       if result &gt; max_covered:<br/>&#13;&#13;
          max_covered = result<br/>&#13;&#13;
<br/>&#13;&#13;
   output_file.write(str(max_covered) + '\n')<br/>&#13;&#13;
<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_242"/>   input_file.close()<br/>&#13;&#13;
   output_file.close()</pre>&#13;&#13;
<p class="ex-caption" id="ch09ex02"><em>Listing 9-2: Main program</em></p>&#13;&#13;
<p class="indent">We’re working with files here, not standard input and standard output.</p>&#13;&#13;
<p class="indent">The program begins by reading the number of lifeguards and then uses a range <code>for</code> loop to read each lifeguard’s time interval. We read each time interval from the input <span class="ent">❶</span>, convert each of its components to an integer, and append it as a two-value list to our list of intervals.</p>&#13;&#13;
<p class="indent">We use the <code>max_covered</code> variable to track the maximum number of time units that can be covered.</p>&#13;&#13;
<p class="indent">Now we separately fire each lifeguard using a range <code>for</code> loop <span class="ent">❷</span>. We call <code>num_covered</code> <span class="ent">❸</span> to determine the number of time units that are covered given the firing of one lifeguard. We update <code>max_covered</code> whenever we’re able to cover a greater number of time units.</p>&#13;&#13;
<p class="indent">When that loop completes, we’ll have checked the number of units of time that can be covered by firing each lifeguard, and we’ll have remembered the maximum. We output this maximum to solve the problem.</p>&#13;&#13;
<p class="indent">Feel free to submit our code to the USACO judge. For Python code, this judge uses a time limit per test case of four seconds, but our solution shouldn’t come close to that limit. For example, I just ran the code here, and each test case finished in no more than 130 milliseconds.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec6">Efficiency of Our Program</h4>&#13;&#13;
<p class="noindent">The reason our code is so fast is because there are so few lifeguards—only at most 100 of them. If there were a large number of lifeguards, then our code would no longer solve the problem within the time limit. We’d be fine if there were a few hundred lifeguards. We might squeak through if we had as many as 3,000 or 4,000 lifeguards. Any more than that, though, and our code would be too slow. We probably couldn’t make it in time with 5,000 lifeguards, for example. We’d need to design a new algorithm, likely one that uses something faster than complete search.</p>&#13;&#13;
<p class="indent">You might think that 5,000 is a huge number of lifeguards and that it’s okay that our algorithm can’t go that high. But it’s not! Think back to the Email Addresses problem in <a href="ch08.xhtml#ch08">Chapter 8</a>. There, we had to contend with up to 100,000 email addresses. And think back to the Cities and States problem in the same chapter. There, we had to contend with up to 200,000 cities. By comparison, 5,000 is not a lot of lifeguards.</p>&#13;&#13;
<p class="indent">A complete-search solution often works fine for a small amount of input. Large test cases are often where complete-search solutions break down.</p>&#13;&#13;
<p class="indent">The reason that our complete-search solution for Lifeguards doesn’t work well with large test cases is because it does a lot of repeated work. Imagine that we’re solving a test case with 5,000 lifeguards. We’ll fire lifeguard <code>0</code> and call <code>num_covered</code> to determine the number of units of time covered by the remaining lifeguards. Then, we’ll fire lifeguard <code>1</code> and call <code>num_covered</code> again. Now, what <code>num_covered</code> does this time is similar to what it <span epub:type="pagebreak" id="page_243"/>did on the previous call. After all, things haven’t changed much. The only change is that lifeguard 0 is back and lifeguard 1 is fired. The other 4,998 lifeguards are the same as they were! But <code>num_covered</code> doesn’t know that. It grinds through all of the lifeguards again. That same thing happens when we fire lifeguard 2, then lifeguard 3, and so on. Each time, <code>num_covered</code> does all of its work from scratch, without learning anything about what it did previously.</p>&#13;&#13;
<p class="indent">Remember that, while useful, complete-search algorithms do have limitations. Given a new problem that we want to solve, a complete-search algorithm is a useful starting point, even if it ultimately turns out to be too inefficient. That’s because the act of designing that algorithm may deepen our appreciation of the problem and lead to new ideas for solving it.</p>&#13;&#13;
<p class="indent">In the next section, we’ll see another problem where we’ll be able to use complete search.</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">Is the following version of <code>num_covered</code> correct?</p>&#13;&#13;
<pre>def num_covered(intervals, fired):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    intervals is a list of lifeguard intervals;<br/>&#13;&#13;
    each interval is a [start, end] list.<br/>&#13;&#13;
    fired is the index of the lifeguard to fire.<br/>&#13;&#13;
<br/>&#13;&#13;
    Return the number of time units covered by all lifeguards<br/>&#13;&#13;
    except the one fired.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    covered = set()<br/>&#13;&#13;
    intervals.pop(fired)<br/>&#13;&#13;
    for interval in intervals:<br/>&#13;&#13;
        for j in range(interval[0], interval[1]):<br/>&#13;&#13;
            covered.add(j)<br/>&#13;&#13;
    return len(covered)</pre>&#13;&#13;
<p class="alphat">A. Yes</p>&#13;&#13;
<p class="alpha">B. No</p>&#13;&#13;
<p class="sb-noindent1">Answer: B. This function removes the fired lifeguard from the list of lifeguards. That’s not allowed, because the docstring doesn’t say anything about the function modifying the list. With this version of the function, our program will fail many test cases because lifeguard information is lost over time. For example, when we test firing lifeguard 0, lifeguard 0 is removed from the list. When we later test firing lifeguard 1, lifeguard 0 is unfortunately still gone! If you want to use a version of the function where the fired lifeguard is removed from the list, you need to work with a copy of the list rather than the original.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3a" id="ch09lev1sec4"><span epub:type="pagebreak" id="page_244"/><span class="h3aa">Problem #22: Ski Hills</span></h3>&#13;&#13;
<p class="noindent">Sometimes, the problem description makes it clear what we should search through in a complete-search solution. For example, in Lifeguards, we were asked to fire one lifeguard, so it made sense to try firing each one. Other times, we’ll have to be more creative to determine what to search through. As you read this next problem, think about what you would search in a complete-search solution.</p>&#13;&#13;
<p class="indent">This is USACO 2014 January Bronze Contest problem Ski Course Design.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec7">The Challenge</h4>&#13;&#13;
<p class="noindent">Farmer John has <em>n</em> hills on his farm, each with a height between 0 and 100. He would like to register his farm as a ski training camp.</p>&#13;&#13;
<p class="indent">A farm can be registered as a ski training camp only if the difference in height between the highest and lowest hills is 17 or less. Farmer John may therefore need to increase the heights of some of his hills and decrease the heights of others. He is able to change the heights only by integer amounts.</p>&#13;&#13;
<p class="indent">The cost of changing a hill’s height by <em>x</em> units is <em>x</em><sup>2</sup>. For example, changing a hill from height 1 to height 4 costs (4 – 1)<sup>2</sup> = 9.</p>&#13;&#13;
<p class="indent">Determine the minimum amount that Farmer John will need to pay to change the heights of hills so that he can register his farm as a ski training camp.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec8">Input</h4>&#13;&#13;
<p class="noindent">Read input from the file named <em>skidesign.in</em>.</p>&#13;&#13;
<p class="indent">The input consists of the following lines:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">A line containing integer <em>n</em>, the number of hills on the farm. <em>n</em> is between 1 and 1,000.</li>&#13;&#13;
<li class="noindent"><em>n</em> lines, each of which gives the height of a hill. Each height is an integer between 0 and 100.</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch09lev2sec9">Output</h4>&#13;&#13;
<p class="noindent">Write output to the file named <em>skidesign.out</em>.</p>&#13;&#13;
<p class="indent">Output the minimum amount that Farmer John will need to pay to change the heights of hills.</p>&#13;&#13;
<p class="indent">The time limit for solving each test case is four seconds.</p>&#13;&#13;
<h3 class="h3" id="ch09lev1sec5">Exploring a Test Case</h3>&#13;&#13;
<p class="noindent">Let’s see if we can apply what we learned from Lifeguards to this problem. To solve Lifeguards, we separately fired each lifeguard to figure out the lifeguard that we should fire. To solve Ski Hills, perhaps there’s something <span epub:type="pagebreak" id="page_245"/>analogous that we can do with each hill? For example, perhaps we can use each hill’s height as the low end in an allowed height range?</p>&#13;&#13;
<p class="indent">We’ll give this a try using the following test case:</p>&#13;&#13;
<pre>4<br/>&#13;&#13;
23<br/>&#13;&#13;
40<br/>&#13;&#13;
16<br/>&#13;&#13;
2</pre>&#13;&#13;
<p class="indent">The smallest height of these four hills is 2, and the biggest height is 40. The difference between 40 and 2 is 38, greater than 17. Farmer John is going to have to pay to fix these hills!</p>&#13;&#13;
<p class="indent">The first hill is height 23. If we use 23 as the low end of the range, then the high end is 23 + 17 = 40. We need to calculate the cost to bring all hills into the range 23–40. There are two hills that are out of this range, the ones of heights 16 and 2. Bringing them up to height 23 costs (23 – 16)<sup>2</sup> + (23 – 2)<sup>2</sup> = 490. A cost of 490 is the cost to beat.</p>&#13;&#13;
<p class="indent">The second hill is height 40. The high end of this range is 40 + 17 = 57, so we’re looking to get all hills into the range 40–57. The other three hills are out of this range, so each of them contributes to the total cost. That total is (40 – 23)<sup>2</sup> + (40 – 16)<sup>2</sup> + (40 – 2)<sup>2</sup> = 2,309. This is greater than 490, our current minimum cost, so 490 is still the cost to beat. (Remember that in this problem we’re trying to <em>minimize</em> Farmer John’s cost, whereas in Lifeguards we were trying to <em>maximize</em> coverage.)</p>&#13;&#13;
<p class="indent">The third hill is height 16, which gives us the range 16–33. There are two hills that are out of this range, the ones of heights 40 and 2. The total cost for this range is therefore (40 – 33)<sup>2</sup> + (16 – 2)<sup>2</sup> = 245. The new cost to beat is 245!</p>&#13;&#13;
<p class="indent">The fourth hill is height 2, which gives us the range 2–19. If you calculate the cost for this range, you should obtain a cost of 457.</p>&#13;&#13;
<p class="indent">The minimum cost we obtained using that algorithm is 245. Is 245 the answer? Are we done?</p>&#13;&#13;
<p class="indent">No and no! It turns out that the minimum cost is 221. There are two ranges that give us this minimum cost: 12–29 and 13–30. There is no hill whose height is 12. Similarly, there is no hill whose height is 13. We therefore can’t use hill heights as the possible low ends of ranges.</p>&#13;&#13;
<p class="indent">Think about what a correct complete-search algorithm could look like, one that’s guaranteed not to miss any ranges.</p>&#13;&#13;
<p class="indent">Here’s a plan that’s guaranteed to get us the correct answer. We start by calculating the cost for range 0–17. Then we calculate the cost for range 1–18. Then 2–19. Then 3–20. Then 4–21, and so on. We test every possible range, one by one, and remember the minimum cost that we obtain. The ranges we test have nothing to do with the heights of the hills. Since we’re testing every possible range, there’s no way we’ll miss finding the best one.</p>&#13;&#13;
<p class="indent">Which ranges should we test? How high should we go? Should we test the range 50–67? Yes. How about the range 71–88? Yes again. How about 115–132? No! Not that one.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_246"/>The final range that we’ll check is 100–117. The reason has to do with the guarantee from the problem description that the height of any hill is at most 100.</p>&#13;&#13;
<p class="indent">Suppose we figure out the cost for range 101–118. Without even knowing the heights of the hills, we know for sure that none of the hills is in this range. The maximum height of a hill, after all, is 100, and our range starts at 101. Now slide our range from 101–118 down to 100–117. This 100–117 range costs less than the 101–118 range! That’s because 100 is closer to the hills than 101 is. For example, consider a hill of height 80. This hill would cost us 21<sup>2</sup> = 441 to raise it to height 101, but only 20<sup>2</sup> = 400 to raise it to height 100. This shows that 101–118 cannot be the best range to use. There’s no point trying it.</p>&#13;&#13;
<p class="indent">Similar logic explains why it’s pointless to try any higher range such as 102–119, 103–120, and so on. We can always slide these ranges down to make them cost less.</p>&#13;&#13;
<p class="indent">In summary, we are going to test exactly 101 ranges: 0–17, 1–18, 2–19, and so on, all the way up to 100–117. We’ll remember the cost of the best one. Let’s do this!</p>&#13;&#13;
<h3 class="h3" id="ch09lev1sec6">Solving the Problem</h3>&#13;&#13;
<p class="noindent">We’ll take the solution in two steps, just as we did when solving Lifeguards. We’ll start with a function to determine the cost of a single range. Then we’ll write a main program to call this function once for each range.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec10">Determining the Cost of One Range</h4>&#13;&#13;
<p class="noindent"><a href="ch09.xhtml#ch09ex03">Listing 9-3</a> gives the code for the function that determines the cost of a given range.</p>&#13;&#13;
<pre>MAX_DIFFERENCE = 17<br/>&#13;&#13;
MAX_HEIGHT = 100<br/>&#13;&#13;
<br/>&#13;&#13;
<br/>&#13;&#13;
def cost_for_range(heights, low, high):<br/>&#13;&#13;
    """<br/>&#13;&#13;
    heights is a list of hill heights.<br/>&#13;&#13;
    low is an integer giving the low end of the range.<br/>&#13;&#13;
    high is an integer giving the high end of a range.<br/>&#13;&#13;
<br/>&#13;&#13;
    Return the cost of changing all heights of hills to be<br/>&#13;&#13;
    between low and high.<br/>&#13;&#13;
    """<br/>&#13;&#13;
    cost = 0<br/>&#13;&#13;
 <span class="ent">❶</span> for height in heights:<br/>&#13;&#13;
     <span class="ent">❷</span> if height &lt; low:<br/>&#13;&#13;
         <span class="ent">❸</span> cost = cost + (low - height) ** 2<br/>&#13;&#13;
     <span class="ent">❹</span> elif height &gt; high:<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_247"/>         <span class="ent">❺</span> cost = cost + (height - high) ** 2<br/>&#13;&#13;
    return cost</pre>&#13;&#13;
<p class="ex-caption" id="ch09ex03"><em>Listing 9-3: Solving for one particular range</em></p>&#13;&#13;
<p class="indent">I’ve included two constants that we’ll use later. The <code>MAX_DIFFERENCE</code> constant records the maximum difference allowed between the heights of the highest and lowest hills. The <code>MAX_HEIGHT</code> constant records the maximum height of a hill.</p>&#13;&#13;
<p class="indent">Now let’s turn to the <code>cost_for_range</code> function. It takes a list of hill heights and a desired range specified by its low end and high end. It returns the cost of changing hill heights so that all hills are in the desired range. I encourage you to enter the code for the function into the Python shell so that you can try it before continuing.</p>&#13;&#13;
<p class="indent">The function loops through the height of each hill <span class="ent">❶</span>, adding up the cost to bring that hill into the desired range. There are two cases we need to account for. First, the height of the current hill might be out of range by being less than <code>low</code> <span class="ent">❷</span>. The expression <code>low - height</code> gives us the amount of height that we need to add to this hill, and we square that result to get the cost <span class="ent">❸</span>. Second, the height of the current hill might be out of range by being greater than <code>high</code> <span class="ent">❹</span>. The expression <code>height - high</code> gives us the amount of height that we need to subtract from this hill, and we square that result to get the cost <span class="ent">❺</span>. Notice that we don’t do anything if the height is already in the low-high range. Once we’ve gone through all of the heights, we return the total cost.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec11">The Main Program</h4>&#13;&#13;
<p class="noindent">The main part of our program is in <a href="ch09.xhtml#ch09ex04">Listing 9-4</a>. It uses the <code>cost_for_range</code> function to determine the cost for each range. Be sure to enter our <code>cost_for_range</code> function (<a href="ch09.xhtml#ch09ex03">Listing 9-3</a>) before this code for a complete solution to the problem.</p>&#13;&#13;
<pre>   input_file = open('skidesign.in', 'r')<br/>&#13;&#13;
   output_file = open('skidesign.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
   n = int(input_file.readline())<br/>&#13;&#13;
<br/>&#13;&#13;
   heights = []<br/>&#13;&#13;
<br/>&#13;&#13;
   for i in range(n):<br/>&#13;&#13;
       heights.append(int(input_file.readline()))<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❶</span> min_cost = cost_for_range(heights, 0, MAX_DIFFERENCE)<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❷</span> for low in range(1, MAX_HEIGHT + 1):<br/>&#13;&#13;
       result = cost_for_range(heights, low, low + MAX_DIFFERENCE)<br/>&#13;&#13;
       if result &lt; min_cost:<br/>&#13;&#13;
           min_cost = result<br/>&#13;&#13;
<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_248"/>   output_file.write(str(min_cost) + '\n')<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file.close()<br/>&#13;&#13;
   output_file.close()</pre>&#13;&#13;
<p class="ex-caption" id="ch09ex04"><em>Listing 9-4: Main program</em></p>&#13;&#13;
<p class="indent">We start by reading the number of hills and then read each height into the <code>heights</code> list.</p>&#13;&#13;
<p class="indent">We use the <code>min_cost</code> variable to remember the minimum cost that we’ve discovered so far. We set <code>min_cost</code> to the cost for range 0–17 <span class="ent">❶</span>. Then, in a range <code>for</code> loop <span class="ent">❷</span>, we try every other range cost, updating <code>min_cost</code> every time we find a smaller cost. When we’re done with this loop, we output the minimum cost that we found.</p>&#13;&#13;
<p class="indent">It’s time to submit our code to the judge. Our complete-search solution should solve the problem well under the time limit.</p>&#13;&#13;
<p class="indent">In the next problem, we’ll see an example where a straight complete-search solution is not efficient enough.</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">Here’s a proposed change to the code in <a href="ch09.xhtml#ch09ex04">Listing 9-4</a>. Take this line:</p>&#13;&#13;
<pre>for low in range(1, MAX_HEIGHT + 1):</pre>&#13;&#13;
<p class="sidebarp">And change it to the following:</p>&#13;&#13;
<pre>for low in range(1, MAX_HEIGHT - MAX_DIFFERENCE + 1):</pre>&#13;&#13;
<p class="sidebarp">Is the code still correct?</p>&#13;&#13;
<p class="alphat">A. Yes</p>&#13;&#13;
<p class="alpha">B. No</p>&#13;&#13;
<p class="sb-noindent1">Answer: A. The last range that the code now checks is 83–100, so we have to argue that the ranges we no longer check—84–101, 85–102, and so on—don’t matter.</p>&#13;&#13;
<p class="sidebarp">Consider the range 84–101. If we can argue that the range 83–100 is at least as good as 84–101, then we would have no reason to check range 84–101.</p>&#13;&#13;
<p class="sidebarp">The range 84–101 includes height 101. But that’s pointless: the highest hill has height 100, so height 101 may as well not even be there. We can remove 101 without making the range worse. If we remove it, we’re left with the range 84–100. Aha—but 100–84 is only 16, and we’re allowed to have a difference <span epub:type="pagebreak" id="page_249"/>of 17. So we can extend the range by one on the left, giving us a range of 83–100. Surely, making the range bigger like this can’t make the range any worse. It might even make the range better, since it’s now one unit closer to any hill whose height is 83 or less.</p>&#13;&#13;
<p class="sidebarp">We started with range 84–101 and showed that range 83–100 is at least as good. We can make this same argument for range 85–102, 86–103, and so on. There’s no point going any higher than 83–100!</p>&#13;&#13;
</div>&#13;&#13;
<p class="indent">Before continuing, you might like to try solving exercises 1 and 2 from “Chapter Exercises” on <a href="ch09.xhtml#ch09lev1sec14">page 263</a>.</p>&#13;&#13;
<h3 class="h3a" id="ch09lev1sec7"><span class="h3aa">Problem #23: Cow Baseball</span></h3>&#13;&#13;
<p class="noindent">To end this chapter, I’ve chosen a problem where we’ll need to bump up our algorithm design skills beyond complete search. As you read the problem, notice that there’s not all that much input. That generally signals the effectiveness of a complete-search algorithm. But not this time, because of the amount of searching that such an algorithm has to do through this input. The difficulty boils down to having too many nested loops. Why do the nested loops bite us here? What can we do about it? Read on!</p>&#13;&#13;
<p class="indent">This is USACO 2013 December Bronze Contest problem Cow Baseball.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec12">The Challenge</h4>&#13;&#13;
<p class="noindent">Farmer John has <em>n</em> cows. They are standing in a row, each at a distinct integer position. They are having fun throwing a baseball around.</p>&#13;&#13;
<p class="indent">Farmer John is watching the antics. He observes that cow <em>x</em> throws the ball to some cow <em>y</em> to its right, and then that cow <em>y</em> throws the ball to some cow <em>z</em> to its right. He also knows that the distance of the second throw is at least the distance of the first throw and at most twice the distance of the first throw. (For example, if the first throw is distance 5, then the second throw is at least distance 5 and at most distance 10.)</p>&#13;&#13;
<p class="indent">Determine the number of (<em>x</em>, <em>y</em>, <em>z</em>) triples of cows that satisfy Farmer John’s observations.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec13">Input</h4>&#13;&#13;
<p class="noindent">Read input from the file named <em>baseball.in</em>.</p>&#13;&#13;
<p class="indent">The input consists of the following lines:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">A line containing <em>n</em>, the number of cows. <em>n</em> is between 3 and 1,000.</li>&#13;&#13;
<li class="noindent"><em>n</em> lines, each of which gives the position of a cow. All positions are unique, and each is between 1 and 100,000,000.</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch09lev2sec14"><span epub:type="pagebreak" id="page_250"/>Output</h4>&#13;&#13;
<p class="noindent">Write output to the file named <em>baseball.out</em>.</p>&#13;&#13;
<p class="indent">Output the number of triples of cows that satisfy Farmer John’s observations.</p>&#13;&#13;
<p class="indent">The time limit for solving each test case is four seconds.</p>&#13;&#13;
<h3 class="h3" id="ch09lev1sec8">Using Three Nested Loops</h3>&#13;&#13;
<p class="noindent">We can use three nested loops to consider all possible triples. We’ll start by looking at the code and then discuss its efficiency.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec15">The Code</h4>&#13;&#13;
<p class="noindent">In “Nesting” in <a href="ch03.xhtml#ch03">Chapter 3</a>, we learned that we can loop through all pairs of values using two nested loops. Doing so looks like this:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">lst = [1, 9]</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for num1 in lst:</span><br/>&#13;&#13;
...     <span class="codestrong1">for num2 in lst:</span><br/>&#13;&#13;
...         <span class="codestrong1">print(num1, num2)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
1 1<br/>&#13;&#13;
1 9<br/>&#13;&#13;
9 1<br/>&#13;&#13;
9 9</pre>&#13;&#13;
<p class="indent">We can similarly loop through all triples of values using three nested loops, like this:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for num1 in lst:</span><br/>&#13;&#13;
...     <span class="codestrong1">for num2 in lst:</span><br/>&#13;&#13;
...         <span class="codestrong1">for num3 in lst:</span><br/>&#13;&#13;
...             <span class="codestrong1">print(num1, num2, num3)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
1 1 1<br/>&#13;&#13;
1 1 9<br/>&#13;&#13;
1 9 1<br/>&#13;&#13;
1 9 9<br/>&#13;&#13;
9 1 1<br/>&#13;&#13;
9 1 9<br/>&#13;&#13;
9 9 1<br/>&#13;&#13;
9 9 9</pre>&#13;&#13;
<p class="indent">Using three nested loops like this gives us a starting point for solving the Cow Baseball problem. For each triple, we can check whether it matches Farmer John’s observations. See <a href="ch09.xhtml#ch09ex05">Listing 9-5</a> for the code.</p>&#13;&#13;
<pre><span epub:type="pagebreak" id="page_251"/>   input_file = open('baseball.in', 'r')<br/>&#13;&#13;
   output_file = open('baseball.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
   n = int(input_file.readline())<br/>&#13;&#13;
<br/>&#13;&#13;
   positions = []<br/>&#13;&#13;
<br/>&#13;&#13;
   for i in range(n):<br/>&#13;&#13;
    <span class="ent">❶</span> positions.append(int(input_file.readline()))<br/>&#13;&#13;
<br/>&#13;&#13;
   total = 0<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❷</span> for position1 in positions:<br/>&#13;&#13;
    <span class="ent">❸</span> for position2 in positions:<br/>&#13;&#13;
           first_two_diff = position2 - position1<br/>&#13;&#13;
        <span class="ent">❹</span> if first_two_diff &gt; 0:<br/>&#13;&#13;
               low = position2 + first_two_diff<br/>&#13;&#13;
               high = position2 + first_two_diff * 2<br/>&#13;&#13;
<br/>&#13;&#13;
            <span class="ent">❺</span> for position3 in positions:<br/>&#13;&#13;
                   if position3 &gt;= low and position3 &lt;= high:<br/>&#13;&#13;
                       total = total + 1<br/>&#13;&#13;
<br/>&#13;&#13;
   output_file.write(str(total) + '\n')<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file.close()<br/>&#13;&#13;
   output_file.close()</pre>&#13;&#13;
<p class="ex-caption" id="ch09ex05"><em>Listing 9-5: Using three nested</em> <span class="codeitalic">for</span> <em>loops</em></p>&#13;&#13;
<p class="indent">We read all of the cow positions into the <code>positions</code> list <span class="ent">❶</span>. We then loop over all positions in the list using a <code>for</code> loop <span class="ent">❷</span>. For each of these positions, we loop through all positions in the list using a nested <code>for</code> loop <span class="ent">❸</span>. At this point, <code>position1</code> and <code>position2</code> refer to two positions from the list. We need a third nested loop, yes, but not yet. We first need to calculate the difference between <code>position1</code> and <code>position2</code> because that tells us the range of <code>position3</code>s that we’ll be looking for.</p>&#13;&#13;
<p class="indent">We require from the problem description that <code>position2</code> be on the right of <code>position1</code>. If it is <span class="ent">❹</span>, then we calculate the low end and high end of the range for <code>position3</code> and store them using <code>low</code> and <code>high</code>, respectively. For example, if <code>position1</code> is 1 and <code>position2</code> is 6, then we’ll calculate 6 + 5 = 11 for <code>low</code> and 6 + 5 * 2 = 16 for <code>high</code>. Then we loop through the list with a third nested <code>for</code> loop <span class="ent">❺</span>, looking for positions that are between <code>low</code> and <code>high</code>. For each such <code>position3</code>, we increase our total by <code>1</code>.</p>&#13;&#13;
<p class="indent">Following the three nested loops, we have calculated the total number of triples. We finish up by outputting that number to the output file.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_252"/>Let’s try our program on a small test case to make sure nothing weird is happening. Here it is:</p>&#13;&#13;
<pre>7<br/>&#13;&#13;
16<br/>&#13;&#13;
14<br/>&#13;&#13;
23<br/>&#13;&#13;
18<br/>&#13;&#13;
1<br/>&#13;&#13;
6<br/>&#13;&#13;
11</pre>&#13;&#13;
<p class="indent">The correct answer for this test case is 11. The 11 satisfying triples are as follows:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">14, 16, 18</li>&#13;&#13;
<li class="noindent">14, 18, 23</li>&#13;&#13;
<li class="noindent">1, 6, 16</li>&#13;&#13;
<li class="noindent">1, 6, 14</li>&#13;&#13;
<li class="noindent">1, 6, 11</li>&#13;&#13;
<li class="noindent">1, 11, 23</li>&#13;&#13;
<li class="noindent">6, 14, 23</li>&#13;&#13;
<li class="noindent">6, 11, 16</li>&#13;&#13;
<li class="noindent">6, 11, 18</li>&#13;&#13;
<li class="noindent">11, 16, 23</li>&#13;&#13;
<li class="noindent">11, 14, 18</li>&#13;&#13;
</ul>&#13;&#13;
<p class="indent">Good news: our program outputs <code>11</code> for this test case! It does so because it eventually finds each satisfying triple. For example, at some point, <code>position1</code> will be <code>14</code>, <code>position2</code> will be <code>16</code>, and <code>position3</code> will be <code>18</code>. That triple satisfies the distance requirements, so our program will count it in our total. Don’t be worried about what will happen, later, when <code>position1</code> is <code>18</code>, <code>position2</code> is <code>16</code>, and <code>position3</code> is <code>14</code>. We definitely don’t want to count that one, because these throws are not going to the right. We’re fine, though: the <code>if</code> statement <span class="ent">❹</span> prevents these triples from being processed.</p>&#13;&#13;
<p class="indent">Our program is correct. But as you’ll see if you submit it to the judge, it is not efficient enough. For this problem, and many competitive programming problems, the first few test cases are small—just a few cows, a few lifeguards, or a few ski hills. Our program should be able to solve those in time. The remaining test cases test our program closer and closer to the limit of acceptable input. Our program does not solve those in time. It’s too slow.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec16">Efficiency of Our Program</h4>&#13;&#13;
<p class="noindent">To understand why our program is so slow, it helps to think about the number of triples that it must go through. Think back to the test case we just <span epub:type="pagebreak" id="page_253"/>studied, which had seven cows. How many triples will our program check? Well, for the first cow, there are seven choices: 16, 14, 23, and so on. There are also seven choices for the second cow, and seven choices for the third cow. Multiplying these together, we see that our program checks 7 * 7 * 7 = 343 triples.</p>&#13;&#13;
<p class="indent">What if we had eight cows instead of seven? Then our program would check 8 * 8 * 8 = 512 triples.</p>&#13;&#13;
<p class="indent">We can give an expression for the number of triples that works for any number of cows. Let’s use <em>n</em> for the number of cows; it could be 7, 8, 50, 1,000, and so on, depending on the test case. Then we can say that the number of triples our program checks is <em>n</em> * <em>n</em> * <em>n</em>, or <em>n</em><sup>3</sup>.</p>&#13;&#13;
<p class="indent">We can substitute any number of cows for <em>n</em> to determine the number of triples that we check. For example, we can verify that the number of triples for seven cows is 7<sup>3</sup> = 343 and that the number of triples for eight cows is 8<sup>3</sup> = 512. These numbers—343 and 512—are tiny. It would take any computer no more than a few milliseconds to check those many triples. As a conservative guide, you can think of a Python program as being able to check or do about 5,000,000 things per second. The time limit for this problem is four seconds per test case, so we’ll be able to check about 20,000,000 triples.</p>&#13;&#13;
<p class="indent">Let’s substitute larger numbers for <em>n</em> and see what happens. For 50 cows, we have 50<sup>3</sup> = 125,000 triples. No big deal: checking 125,000 things is easy for today’s computers. For 100 cows, we have 100<sup>3</sup> = 1,000,000 triples. Again, no problem. We can check a million things in less than a second. For 200 cows, we have 200<sup>3</sup> = 8,000,000 triples. We’re still OK for four seconds, but I hope you’re starting to get a little worried. The number of triples is shooting up pretty quickly here, and we’re only at 200 cows. Remember that we need to be able to support up to 1,000 cows.</p>&#13;&#13;
<p class="indent">For 400 cows, we have 400<sup>3</sup> = 64,000,000 triples. That’s too many for us to process in four seconds. To add insult to injury, let’s try 1,000 cows, the maximum we’ll ever get. For 1,000 cows, we have 1,000<sup>3</sup> = 1,000,000,000 triples. That’s one billion. Nope. There’s no way we’re ever going to be able to check that many triples in four seconds. We’ll need to make our program more efficient.</p>&#13;&#13;
<h3 class="h3" id="ch09lev1sec9">Sorting First</h3>&#13;&#13;
<p class="noindent">Sorting is helpful here. Let’s look at how to use sorting and then discuss the efficiency of our resulting solution.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec17">The Code</h4>&#13;&#13;
<p class="noindent">Our cow positions can come in any order—there’s certainly no guarantee from the problem description that they’re sorted. Unfortunately, this leads our program to check many triples that have no chance of satisfying the requirements. For example, checking the triple 18, 16, 14 is pointless, because the numbers aren’t in increasing order. If we sorted the cow positions at the outset, then we could avoid ever checking these out-of-order triples.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_254"/>There’s another benefit to sorting. Suppose that <code>position1</code> refers to some cow position and <code>position2</code> refers to another. For this pair of positions, we know the smallest value of <code>position3</code> and largest value of <code>position3</code> that we care about. We can use the fact that the positions are sorted to cut down on the number of values that we need to check for this range. Before continuing, think about why this is the case. How can we use the fact that the positions are sorted to look at fewer values?</p>&#13;&#13;
<p class="indent">When you’re ready, see <a href="ch09.xhtml#ch09ex06">Listing 9-6</a> for our code that uses sorting.</p>&#13;&#13;
<pre>   input_file = open('baseball.in', 'r')<br/>&#13;&#13;
   output_file = open('baseball.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
   n = int(input_file.readline())<br/>&#13;&#13;
<br/>&#13;&#13;
   positions = []<br/>&#13;&#13;
<br/>&#13;&#13;
   for i in range(n):<br/>&#13;&#13;
       positions.append(int(input_file.readline()))<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❶</span> positions.sort()<br/>&#13;&#13;
<br/>&#13;&#13;
   total = 0<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❷</span> for i in range(n):<br/>&#13;&#13;
    <span class="ent">❸</span> for j in range(i + 1, n):<br/>&#13;&#13;
           first_two_diff = positions[j] - positions[i]<br/>&#13;&#13;
           low = positions[j] + first_two_diff<br/>&#13;&#13;
           high = positions[j] + first_two_diff * 2<br/>&#13;&#13;
<br/>&#13;&#13;
           left = j + 1<br/>&#13;&#13;
        <span class="ent">❹</span> while left &lt; n and positions[left] &lt; low:<br/>&#13;&#13;
               left = left + 1<br/>&#13;&#13;
<br/>&#13;&#13;
           right = left<br/>&#13;&#13;
        <span class="ent">❺</span> while right &lt; n and positions[right] &lt;= high:<br/>&#13;&#13;
               right = right + 1<br/>&#13;&#13;
<br/>&#13;&#13;
        <span class="ent">❻</span> total = total + right - left<br/>&#13;&#13;
<br/>&#13;&#13;
   output_file.write(str(total) + '\n')<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file.close()<br/>&#13;&#13;
   output_file.close()</pre>&#13;&#13;
<p class="ex-caption" id="ch09ex06"><em>Listing 9-6: Using sorting</em></p>&#13;&#13;
<p class="indent">Before we start looking for triples, we sort the positions <span class="ent">❶</span>.</p>&#13;&#13;
<p class="indent">Our first loop goes through all positions using the loop variable <code>i</code> <span class="ent">❷</span>. It’s a range <code>for</code> loop this time, not a <code>for</code> loop, so that we can keep track of <span epub:type="pagebreak" id="page_255"/>which index we’re at. That’s useful because we can use the value of <code>i + 1</code> as the starting index for our second loop <span class="ent">❸</span>. The second loop will now never waste time looking at positions that are to the left of the first position.</p>&#13;&#13;
<p class="indent">We next calculate the low and high ends of the range of values for our third position.</p>&#13;&#13;
<p class="indent">Rather than increase <code>total</code> by 1 each time we find a suitable third position, we can instead find the left and right borders of suitable positions and then increase <code>total</code> in one shot. We can only do it this way because the list of positions is sorted. We find each of the borders using a <code>while</code> loop. The first <code>while</code> loop finds the left border <span class="ent">❹</span>. It keeps going as long as the positions are less than <code>low</code>. When it’s done, <code>left</code> will be the leftmost index whose position is greater than or equal to <code>low</code>. The second <code>while</code> loop finds the right border <span class="ent">❺</span>. It keeps going as long as the positions are less than or equal to <code>high</code>. When it’s done, <code>right</code> is the rightmost index whose position is greater than <code>high</code>. Each of the positions from <code>left</code> up to but not including <code>right</code> can serve as the third position in a triple involving the positions at indices <code>i</code> and <code>j</code>. We add <code>right - left</code> to <code>total</code> to account for these positions <span class="ent">❻</span>.</p>&#13;&#13;
<p class="indent">The two <code>while</code> loops in this program are quite tricky. Let’s make sure we know exactly what they’re doing by working through an example. We’ll use the following list of positions; they’re the same as those we used in the previous section, but sorted:</p>&#13;&#13;
<pre>[1, 6, 11, 14, 16, 18, 23]</pre>&#13;&#13;
<p class="indent">Suppose that <code>i</code> is <code>1</code> and <code>j</code> is <code>2</code> so that the two positions in prospective triples are <code>6</code> and <code>11</code>. For the third position, we’re therefore looking for positions greater than or equal to <code>16</code> and less than or equal to <code>21</code>. The first <code>while</code> loop will set <code>left</code> to <code>4</code>, the leftmost index whose position is greater than or equal to <code>16</code>. The second <code>while</code> loop will set <code>right</code> to <code>6</code>, the leftmost index whose position is greater than <code>21</code>. Subtracting <code>left</code> from <code>right</code>, we obtain 6 – 4 = 2, which means that there are two triples involving positions <code>6</code> and <code>11</code>. Before continuing, I encourage you to convince yourself that these <code>while</code> loops work just fine in “special” cases, such as when there are no suitable third positions or when there is one suitable third position.</p>&#13;&#13;
<p class="indent">We’ve made strong progress in this section. Our code here is certainly more efficient than the code we gave in <a href="ch09.xhtml#ch09ex05">Listing 9-5</a>. However, it still isn’t efficient enough. If you submit to the judge, you’ll see that it doesn’t get much further than we got last time. It still times out on most of the test cases.</p>&#13;&#13;
<h4 class="h4" id="ch09lev2sec18">Efficiency of Our Program</h4>&#13;&#13;
<p class="noindent">The problem with our program is that finding the third position can still take a long time. Those <code>while</code> loops still have some inefficiency. I can demonstrate this with a new list of positions, namely, the positions from 1 to 32.</p>&#13;&#13;
<pre>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,<br/>&#13;&#13;
 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]</pre>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_256"/>Let’s focus on when <code>i</code> is <code>0</code> and <code>j</code> is <code>7</code>; these are the positions <code>1</code> and <code>8</code>. For the third position, we’re looking for positions that are greater than or equal to 15 and less than or equal to 22. To find the <code>15</code>, the first <code>while</code> loop scans to the right, one position at a time. It scans the <code>9</code>, then the <code>10</code>, then the <code>11</code>, then the <code>12</code>, then the <code>13</code>, then the <code>14</code>, and finally the <code>15</code>. Then the second <code>while</code> loop takes over, doing a similarly large amount of scanning, one position at a time, all the way until it finds the <code>23</code>.</p>&#13;&#13;
<p class="indent">Each <code>while</code> loop implements what’s known as a <em>linear search</em>. A linear search is a technique that searches through a collection one value at a time. It’s a lot of work, scanning through all those values! And there are many other values of <code>i</code> and <code>j</code> that lead to a similar amount of work. For example, try tracing what happens when <code>i</code> is <code>0</code> and <code>j</code> is <code>8</code>, or when <code>i</code> is <code>1</code> and <code>j</code> is <code>11</code>.</p>&#13;&#13;
<p class="indent">How can we improve on this? How can we avoid scanning through a huge chunk of the list, looking for the appropriate <code>left</code> and <code>right</code> indices?</p>&#13;&#13;
<p class="indent">Suppose I give you a book with a thousand sorted integers, one integer per line. I ask you to find me the first integer that’s greater or equal to 300. Are you going to look through the numbers one by one? Are you going to look at the 1, then the 3, then the 4, then the 7? Still a long way to go—will you look at the 8, then the 12, then the 17? Probably not! It’d be much faster if you just flipped to the middle of the book. Maybe you find number 450 there. Since 450 is greater than 300, now you know that the number is in the first half of the book. It can’t be in the second half, because those numbers are even bigger than 450. You’ve reduced your work by half by checking only one number! You can now repeat this process on the first half of the book, flipping halfway between the beginning and middle of the book. You might find the number 200 there. Now you know that the 300 is on a later page, somewhere in the second quarter of the book. You can repeat this process until you find 300—and it won’t take long at all. This technique—repeatedly dividing the problem in half—is known as <em>binary search</em>. It’s shockingly fast. It blows away the linear search technique of searching one by one. Python has a binary search function that will put the finishing touches on Cow Baseball. That function, though, is inside of something called a <em>module</em>; we’ll need to discuss them first.</p>&#13;&#13;
<h3 class="h3" id="ch09lev1sec10">Python Modules</h3>&#13;&#13;
<p class="noindent">A <em>module</em> is a self-contained collection of Python code. A module generally contains several functions that we can call.</p>&#13;&#13;
<p class="indent">Python comes with a variety of modules that we can use to add functionality to our programs. There are modules for working with random numbers, dates and times, statistics, emails, web pages, audio files, and much more. It would take a separate book to cover them all! There are even modules that you can download should Python not come with the module that you need.</p>&#13;&#13;
<p class="indent">I’ll focus in this section on one module—the <code>random</code> module. We’ll use it to learn what we need to know about modules. Then we’ll be all set for the binary search module in the next section.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_257"/>Have you ever wondered how people make computer games where things happen at random? Maybe it’s a game where you draw cards, where you roll dice, or where enemies spawn unpredictably. The key is the use of random numbers. Python gives us access to random-number generation through its <code>random</code> module.</p>&#13;&#13;
<p class="indent">Before we can use what’s in a module, we must <em>import</em> it. One way to do this is to import the entire module using the <code>import</code> keyword, like this:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import random</span></pre>&#13;&#13;
<p class="indent">What’s in there? To find out, you can use <code>dir(random)</code>:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">dir(random)</span><br/>&#13;&#13;
[<span class="codeitalic1">stuff to ignore</span><br/>&#13;&#13;
'betavariate', 'choice', 'choices', 'expovariate',<br/>&#13;&#13;
'gammavariate', 'gauss', 'getrandbits', 'getstate',<br/>&#13;&#13;
'lognormvariate', 'normalvariate', 'paretovariate',<br/>&#13;&#13;
'randint', 'random', 'randrange', 'sample', 'seed',<br/>&#13;&#13;
'setstate', 'shuffle', 'triangular', 'uniform',<br/>&#13;&#13;
'vonmisesvariate', 'weibullvariate']</pre>&#13;&#13;
<p class="indent">One function that’s offered by the <code>random</code> module is <code>randint</code>. We pass it the low and high ends of a range, and Python gives us a random integer in the range (including both endpoints).</p>&#13;&#13;
<p class="indent">We can’t just call it like a regular function, though. If we try, we get an error:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">randint(2, 10)</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
NameError: name 'randint' is not defined</pre>&#13;&#13;
<p class="indent">We need to tell Python that the <code>randint</code> function is housed in the <code>random</code> module. To do that, we prefix <code>randint</code> with the name of the module and a dot, like this:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">random.randint(2, 10)</span><br/>&#13;&#13;
7<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">random.randint(2, 10)</span><br/>&#13;&#13;
10<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">random.randint(2, 10)</span><br/>&#13;&#13;
6</pre>&#13;&#13;
<p class="indent">To get help on the <code>randint</code> function, you can type <code>help(random.randint)</code>:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">help(random.randint)</span><br/>&#13;&#13;
Help on method randint in module random:<br/>&#13;&#13;
<br/>&#13;&#13;
randint(a, b) method of random.Random instance<br/>&#13;&#13;
    Return random integer in range [a, b], including both end points.</pre>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_258"/>Another useful function in the <code>random</code> module is <code>choice</code>. We pass it a sequence, and it returns one of its values at random:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">random.choice(['win', 'lose'])</span><br/>&#13;&#13;
'lose'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">random.choice(['win', 'lose'])</span><br/>&#13;&#13;
'lose'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">random.choice(['win', 'lose'])</span><br/>&#13;&#13;
'win'</pre>&#13;&#13;
<p class="indent">If we frequently use a small number of functions from a module, it can be tedious to type the module name and a dot each time. There’s another way to import these functions that lets us call them like any other nonmodule function. Here’s how we can import only the <code>randint</code> function:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from random import randint</span></pre>&#13;&#13;
<p class="indent">Now we can call <code>randint</code> without the <code>random.</code> in front:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">randint(2, 10)</span><br/>&#13;&#13;
10</pre>&#13;&#13;
<p class="indent">If we need <code>randint</code> and <code>choice</code>, we can import them both:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from random import randint, choice</span></pre>&#13;&#13;
<p class="indent">We won’t do so in this book, but we can create our own modules containing whatever functions we like. For example, if we designed a few Python functions related to playing a game, we could place them all in a file named <em>game_functions.py</em>. We could then import that module using <code>import game_functions</code> and then access the functions within.</p>&#13;&#13;
<p class="indent">The Python programs we’ve written in this book are not designed to be imported as modules. The reason is that they all read input as soon as they start running. A module shouldn’t do that. Rather, a module should wait for its functions to be called before it does anything. The <code>random</code> module is an example of a well-behaved module: it only starts giving us random things when we ask for them.</p>&#13;&#13;
<h3 class="h3" id="ch09lev1sec11">The bisect Module</h3>&#13;&#13;
<p class="noindent">Now we’re ready to play around with binary search. In <a href="ch09.xhtml#ch09ex06">Listing 9-6</a>, we had two <code>while</code> loops. They’re slow, so we want to get rid of them. To do that, we’re going to replace each one with a call to a binary search function: <code>bisect_left</code> for the first <code>while</code> loop and <code>bisect_right</code> for the second.</p>&#13;&#13;
<p class="indent">Both of these functions are in the <code>bisect</code> module. Let’s import them:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from bisect import bisect_left, bisect_right</span></pre>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_259"/>Let’s first discuss <code>bisect_left</code>. We call it by providing a list sorted from smallest to largest and a value <code>x</code>. It returns to us the index of the leftmost value in the list that’s greater than or equal to <code>x</code>.</p>&#13;&#13;
<p class="indent">If the value is in the list, we get the index of its leftmost occurrence:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">bisect_left([10, 50, 80, 80, 100], 10)</span><br/>&#13;&#13;
0<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_left([10, 50, 80, 80, 100], 80)</span><br/>&#13;&#13;
2</pre>&#13;&#13;
<p class="indent">If the value isn’t in the list, then we get the index of the first value that’s greater:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">bisect_left([10, 50, 80, 80, 100], 15)</span><br/>&#13;&#13;
1<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_left([10, 50, 80, 80, 100], 81)</span><br/>&#13;&#13;
4</pre>&#13;&#13;
<p class="indent">If we search for something that’s greater than every value in the list, we get the list’s length:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">bisect_left([10, 50, 80, 80, 100], 986)</span><br/>&#13;&#13;
5</pre>&#13;&#13;
<p class="indent">Let’s use <code>bisect_left</code> on our list of seven positions from “Sorting First” earlier in this chapter. We’ll find the index of the leftmost position that’s greater than or equal to 16:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">positions = [1, 6, 11, 14, 16, 18, 23]</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_left(positions, 16)</span><br/>&#13;&#13;
4</pre>&#13;&#13;
<p class="indent">Perfect: that’s exactly what we need to replace the first <code>while</code> loop in <a href="ch09.xhtml#ch09ex06">Listing 9-6</a>.</p>&#13;&#13;
<p class="indent">To replace the second <code>while</code> loop, we’ll use <code>bisect_right</code> rather than <code>bisect_left</code>. We call <code>bisect_right</code> just as we called <code>bisect_left</code> : with a sorted list and a value <code>x</code>. Rather than returning the index of the leftmost value in the list that’s <em>greater than or equal to</em> <code>x</code>, it returns the index of the leftmost value that’s <em>greater than</em> <code>x</code>.</p>&#13;&#13;
<p class="indent">Let’s compare <code>bisect_left</code> and <code>bisect_right</code>. For a value that’s in the list, <code>bisect_right</code> returns an index greater than that returned by <code>bisect_left</code>:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">bisect_left([10, 50, 80, 80, 100], 10)</span><br/>&#13;&#13;
0<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_right([10, 50, 80, 80, 100], 10)</span><br/>&#13;&#13;
1<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_left([10, 50, 80, 80, 100], 80)</span><br/>&#13;&#13;
2<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_260"/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_right([10, 50, 80, 80, 100], 80)</span><br/>&#13;&#13;
4</pre>&#13;&#13;
<p class="indent">For a value that isn’t in the list, <code>bisect_left</code> and <code>bisect_right</code> return the same index:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">bisect_left([10, 50, 80, 80, 100], 15)</span><br/>&#13;&#13;
1<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_right([10, 50, 80, 80, 100], 15)</span><br/>&#13;&#13;
1<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_left([10, 50, 80, 80, 100], 81)</span><br/>&#13;&#13;
4<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_right([10, 50, 80, 80, 100], 81)</span><br/>&#13;&#13;
4<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_left([10, 50, 80, 80, 100], 986)</span><br/>&#13;&#13;
5<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_right([10, 50, 80, 80, 100], 986)</span><br/>&#13;&#13;
5</pre>&#13;&#13;
<p class="indent">Let’s use <code>bisect_right</code> on our list of seven positions from “Sorting First” earlier in this chapter. We’ll find the index of the leftmost position that’s greater than 21:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">positions = [1, 6, 11, 14, 16, 18, 23]</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">bisect_right(positions, 21)</span><br/>&#13;&#13;
6</pre>&#13;&#13;
<p class="indent">There we go: that’s what we can use to replace the second <code>while</code> loop in <a href="ch09.xhtml#ch09ex06">Listing 9-6</a>.</p>&#13;&#13;
<p class="indent">The stunning speed of binary search is hard to appreciate using these tiny examples. Time to get real. We’ll search one million times for the rightmost value in a list of length <code>1000000</code>. Don’t look away when you run this code. You might miss it.</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">lst = list(range(1, 1000001))</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for i in range(1000000):</span><br/>&#13;&#13;
...     <span class="codestrong1">where = bisect_left(lst, 1000000)</span><br/>&#13;&#13;
...</pre>&#13;&#13;
<p class="indent">On my computer, that takes about a second. You might be wondering what would happen if you replaced the binary search with a call to the list <code>index</code> method. If you try it, you’ll literally wait hours for the code to run. That’s because <code>index</code>, like the <code>in</code> operator, does a linear search through the list. (See “Efficiency of Searching a List” in <a href="ch08.xhtml#ch08">Chapter 8</a> for more on this.) It has no guarantee that the list is sorted, so it can’t perform a blazing-fast binary search. It has to go through the values one by one, comparing each of them to the value we’re searching for. If you have a sorted list and you want to find values in it, binary search is unstoppable.</p>&#13;&#13;
<h3 class="h3" id="ch09lev1sec12"><span epub:type="pagebreak" id="page_261"/>Solving the Problem</h3>&#13;&#13;
<p class="noindent">We’re ready to solve Cow Baseball using binary search. See <a href="ch09.xhtml#ch09ex07">Listing 9-7</a> for the code.</p>&#13;&#13;
<pre><span class="ent">❶</span> from bisect import bisect_left, bisect_right<br/>&#13;&#13;
<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file = open('baseball.in', 'r')<br/>&#13;&#13;
   output_file = open('baseball.out', 'w')<br/>&#13;&#13;
<br/>&#13;&#13;
   n = int(input_file.readline())<br/>&#13;&#13;
<br/>&#13;&#13;
   positions = []<br/>&#13;&#13;
<br/>&#13;&#13;
   for i in range(n):<br/>&#13;&#13;
       positions.append(int(input_file.readline()))<br/>&#13;&#13;
<br/>&#13;&#13;
   positions.sort()<br/>&#13;&#13;
<br/>&#13;&#13;
   total = 0<br/>&#13;&#13;
<br/>&#13;&#13;
   for i in range(n):<br/>&#13;&#13;
       for j in range(i + 1, n):<br/>&#13;&#13;
           first_two_diff = positions[j] - positions[i]<br/>&#13;&#13;
           low = positions[j] + first_two_diff<br/>&#13;&#13;
           high = positions[j] + first_two_diff * 2<br/>&#13;&#13;
        <span class="ent">❷</span> left = bisect_left(positions, low)<br/>&#13;&#13;
        <span class="ent">❸</span> right = bisect_right(positions, high)<br/>&#13;&#13;
           total = total + right - left<br/>&#13;&#13;
<br/>&#13;&#13;
   output_file.write(str(total) + '\n')<br/>&#13;&#13;
<br/>&#13;&#13;
   input_file.close()<br/>&#13;&#13;
   output_file.close()</pre>&#13;&#13;
<p class="ex-caption" id="ch09ex07"><em>Listing 9-7: Using binary search</em></p>&#13;&#13;
<p class="indent">To begin, we import the <code>bisect_left</code> and <code>bisect_right</code> functions from the <code>bisect</code> module so that we can call them <span class="ent">❶</span>. The only other difference compared to <a href="ch09.xhtml#ch09ex06">Listing 9-6</a> is that we now use <code>bisect_left</code> <span class="ent">❷</span> and <code>bisect_right</code> <span class="ent">❸</span> instead of the <code>while</code> loops.</p>&#13;&#13;
<p class="indent">If you submit our code to the judge now, you should pass all test cases within the time limit.</p>&#13;&#13;
<p class="indent">The arc that we followed in this section is typical of that required to solve hard problems. We might start with a complete-search solution that is correct but, alas, is also too slow, not meeting the judge’s time limits. We then make improvements, leading us away from complete search and toward a more refined approach.</p>&#13;&#13;
<span epub:type="pagebreak" id="page_262"/>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">Suppose we start with <a href="ch09.xhtml#ch09ex07">Listing 9-7</a> and use <code>bisect_left</code> in place of <code>bisect_right</code>. That is, we take this line:</p>&#13;&#13;
<pre>        right = bisect_right(positions, high)</pre>&#13;&#13;
<p class="sidebarp">And we change it to the following:</p>&#13;&#13;
<pre>        right = bisect_left(positions, high)</pre>&#13;&#13;
<p class="sidebarp">Does the program still produce the correct answers?</p>&#13;&#13;
<p class="alphat">A. It always produces the correct answer, just as before.</p>&#13;&#13;
<p class="alpha">B. It sometimes produces the correct answer; it depends on the test case.</p>&#13;&#13;
<p class="alpha">C. It never produces the correct answer.</p>&#13;&#13;
<p class="sb-noindent1">Answer: B. There are test cases for which the modified code does produce the correct answer. Here’s one:</p>&#13;&#13;
<pre>3<br/>&#13;&#13;
2<br/>&#13;&#13;
4<br/>&#13;&#13;
9</pre>&#13;&#13;
<p class="sidebarp">The correct answer is 0, and that’s what our program produces.</p>&#13;&#13;
<p class="sidebarp">Be careful, though, because there are other test cases for which the modified code produces the wrong answer. Here’s one:</p>&#13;&#13;
<pre>3<br/>&#13;&#13;
2<br/>&#13;&#13;
4<br/>&#13;&#13;
8</pre>&#13;&#13;
<p class="sidebarp">The correct answer is 1, but our program produces <code>0</code>. When <code>i</code> is <code>0</code> and <code>j</code> is <code>1</code>, the program is supposed to set <code>left</code> to <code>2</code> and set <code>right</code> to <code>3</code>. Unfortunately, using <code>bisect_left</code> causes <code>right</code> to be set to <code>2</code>, because the position at index 2 is the leftmost position that’s greater than or equal to <code>8</code>.</p>&#13;&#13;
<p class="sidebarp">Given this counterexample, you might be surprised to know that there <em>is</em> a way to use <code>bisect_left</code> rather than <code>bisect_right</code>. To do it, we need to alter what we search for in the call to <code>bisect_left</code>. If you’re curious, give it a try!</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch09lev1sec13"><span epub:type="pagebreak" id="page_263"/>Summary</h3>&#13;&#13;
<p class="noindent">In this chapter, we learned about complete-search algorithms, algorithms that search through all options to find the best one. To determine the lifeguard that we should fire, we try firing each lifeguard and choose the best one. To determine the minimum cost to fix ski hills, we try all valid ranges and choose the best one. To determine the number of relevant triples of cows, we check each triple and add the ones that meet the requirements.</p>&#13;&#13;
<p class="indent">Sometimes, complete-search algorithms are efficient enough as they are. We solved the Lifeguards and Ski Hills problems with unadorned complete-search code. Other times, however, we’ll need to make our complete-search algorithm more efficient. We did that when solving Cow Baseball by replacing complete-search <code>while</code> loops by much faster binary searches.</p>&#13;&#13;
<p class="indent">How do programmers and computer scientists discuss efficiency? How do you know whether an algorithm is going to be efficient enough? And can you avoid implementing algorithms that are simply too slow? <a href="ch10.xhtml#ch10">Chapter 10</a> awaits.</p>&#13;&#13;
<h3 class="h3" id="ch09lev1sec14">Chapter Exercises</h3>&#13;&#13;
<p class="noindent">Here are some exercises for you to try. For each, use complete search. If your solution is not efficient enough, think about how you can make it more efficient while still producing the right answer.</p>&#13;&#13;
<p class="indent">For each exercise, double-check the judge that the problem comes from: some are on the DMOJ judge, while others are on the USACO judge.</p>&#13;&#13;
<ol>&#13;&#13;
<li class="noindent">USACO 2019 January Bronze Contest problem Shell Game</li>&#13;&#13;
<li class="noindent">USACO 2016 US Open Bronze Contest problem Diamond Collector</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>coci20c1p1</code>, Patkice</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>ccc09j2</code>, Old Fishin’ Hole</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>ecoo16r1p2</code>, Spindie</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>cco96p2</code>, SafeBreaker</li>&#13;&#13;
<li class="noindent">USACO 2019 December Bronze Contest problem Where Am I</li>&#13;&#13;
<li class="noindent">USACO 2016 January Bronze Contest problem Angry Cows</li>&#13;&#13;
<li class="noindent">USACO 2016 December Silver Contest problem Counting Haybales</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>crci06p3</code>, Firefly</li></ol>&#13;&#13;
<h3 class="h3" id="ch09lev1sec15">Notes</h3>&#13;&#13;
<p class="noindent">Lifeguards is originally from the USACO 2018 January Bronze Contest. Ski Hills is originally from the USACO 2014 January Bronze Contest. Cow Baseball is originally from the USACO 2013 December Bronze Contest.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_264"/>There are other types of algorithms beyond complete search, such as <em>greedy algorithms</em> and <em>dynamic-programming algorithms</em>. If a problem cannot be solved by complete search, then it’s worth thinking through whether it can be solved using one of these other types.</p>&#13;&#13;
<p class="indent">If you’re interested in learning more about these and other algorithms topics using Python, I recommend <em>Python Algorithms</em>, 2nd edition by Magnus Lie Hetland (Apress, 2014).</p>&#13;&#13;
<p class="indent">I’ve also written a book about algorithm design: <em>Algorithmic Thinking: A Problem-Based Introduction</em> (No Starch Press, 2021). It follows the same problem-based format as this book; as a result, its style and pacing will be familiar to you. However, it uses the C programming language, not the Python programming language, so to make the most of it, you’ll want to learn some C beforehand.</p>&#13;&#13;
<p class="indent">In this chapter, we called preexisting Python functions to perform binary searches. If we like, we can write our own binary-search code instead of relying on those functions. The idea of dividing a list in half until we find the value that we want is intuitive, but the code to implement this is surprisingly tricky. Equally surprising is the vast range of problems that can be solved using variations of binary search. My book mentioned earlier, <em>Algorithmic Thinking</em>, contains an entire chapter on binary search and what it can do.</p>&#13;&#13;
</div></body></html>