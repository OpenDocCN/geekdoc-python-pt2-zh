<html><head></head><body>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_1" title="1"/>1</span><br/>
<span class="ChapterTitle">Information in Memory</span></h1>
</header>
<figure class="opener">
<img alt="" height="99" src="image_fi/book_art/chapterart.png" width="98"/>
</figure>
<p class="ChapterIntro">Any remotely interesting computer program needs to be able to store and access data from memory. This data might be the text in a document, the information on a web page, or the details of every variety of coffee we’ve ever sampled stored within a database. In each case, the data is fundamental to the program performing its intended function. </p>
<p>These examples only represent the data that users see and think about. The program must also track numerous pieces of data behind the scenes, such as how many times we have passed through a loop, the current location of our character in a game, or the current system time. Without this data, a program can’t represent changes to its internal state.</p>
<p>In this chapter, we examine the very basics of storing data in memory. We’ll look at how the simplest data structures—plain old variables, composite data structures, and arrays—store their data. We’ll also introduce the book’s pseudocode conventions. For readers who have experience programming, this chapter’s key concepts might already be familiar. Even so, they’re a critical starting point for our journey and worth a review since they provide the foundations to build more powerful and exciting data structures. </p>
<h2 id="h1-502604c01-0001"><span epub:type="pagebreak" id="Page_2" title="2"/>Variables </h2>
<p class="BodyFirst">Individual pieces of data are often stored in <em>variables</em>, which are essentially names representing the location (or <em>address</em>) of a piece of data in the computer’s memory<em>.</em> Readers with even a passing exposure to programming will already be familiar with variables: they are a foundational concept in computer science, necessary for even the simplest programs. Variables enable programs to track information that changes throughout the course of the program. Need to count how many times you have passed through a <code>FOR</code> loop? Track the player’s score in a game? Count how many spelling errors you’ve made while writing an introductory chapter about variables? Use a variable. </p>
<p>Without variables, a programmer can’t track, evaluate, or update the program’s internal state. When you create a variable, the system allocates and assigns it a location behind the scenes. You are then free to write data to that location using a variable name of your choice and look it up using the same name. As long as you know the variable’s name, you don’t need to know the memory location of the data. We can visualize the computer’s memory as a long column of bins. Each variable occupies one or more contiguous bins, depending on the size of the variable, as shown in <a href="#figure1-1" id="figureanchor1-1">Figure 1-1</a> for three variables: <code>Level</code>, <code>Score</code>, and <code>AveScore</code>. In this illustration, the average score (<code>AveScore</code>) is a floating-point number (a number with a decimal) that uses two bins of memory.</p>
<figure>
<img alt="A diagram showing that the level variable with value 20 occupies one bin, the score variable with value 109 occupies one bin, and the average score variable stores with value 100 point 111111 occupies two bins." class="" height="296" src="image_fi/502604c01/f01001.png" width="186"/>
<figcaption><p><a id="figure1-1">Figure 1-1</a>: Computer memory depicted as a column of bins</p></figcaption>
</figure>
<p>In some ways, variables are like the little paper labels on file folders, like the ones in <a href="#figure1-2" id="figureanchor1-2">Figure 1-2</a>: once we have attached the label, we don’t need to remember the folders’ order or exactly how we stored them. We just look up the folder by its label—but this means that it’s important to use informative names. The author’s own filing cabinet is crammed full of overloaded folders with names such as <em>Stuff</em>, <em>Misc</em>, <em>Important</em>, and <em>Other Stuff</em>, making it difficult to know what is stored inside. Likewise, vague variable names make it hard to guess what values they represent. </p>
<span epub:type="pagebreak" id="Page_3" title="3"/><figure>
<img alt="Files with their label tabs sticking up so the files can be easily found. From front to back, labels say Level, Top Score, Score, and Other Stuff." class="" height="104" src="image_fi/502604c01/f01002.png" width="287"/>
<figcaption><p><a id="figure1-2">Figure 1-2</a>: Variables, like the labels on file folders, provide a convenient way to find and access your stored values. </p></figcaption>
</figure>
<p>In many programming languages, variables have an associated type that denotes exactly what type of data they store, such as integers, “floats” for floating-point values, or Booleans for true or false values. These types tell the program how much memory the variable occupies and how to use it. A Boolean variable, for example, stores a limited range of values and often requires only a small amount of memory. A double-precision floating-point number might store a much larger and more precise number and so would use multiple bins. The syntax of defining types, and even whether types need to be explicitly defined, varies among programming languages.</p>
<p>Throughout this book, we will use the language-independent <var>&lt;type&gt;: &lt;name&gt; </var>pseudocode format to specify our variables in examples. For example:</p>
<pre><code>Integer: coffee_count = 5
Float: percentage_words_spelled_correctly = 21.0
Boolean: had_enough_coffee = False</code></pre>
<p>Sometimes a variable will be of the general type <code>Type</code> to indicate that it could take on a range of types depending on the implementation. We’ll operate on the variables using syntax typical of most programming languages, including the use of <code>=</code> for assignment:</p>
<pre><code>coffee_count = coffee_count + 1</code></pre>
<p>For numeric types, including integers and floats, we’ll use standard arithmetic operations, such as <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. For Boolean data types, we’ll use Boolean operations, such as <code>AND</code>, <code>OR</code>, and <code>NOT</code>. The syntax you’ll need to use in your programs will vary depending on your programming language (and is a common focal point in fights over the relative merits of different languages). </p>
<h2 id="h1-502604c01-0002">Composite Data Structures</h2>
<p class="BodyFirst">Many programming languages provide the ability to create <em>composite data structures</em>, such as a<em> </em>struct or an object, which gather multiple individual variables into a single group. Composite data structures provide an easy <span epub:type="pagebreak" id="Page_4" title="4"/>way to gather related pieces of data and pass them around together. For example, we might define a <code>CoffeeRecord</code> to track some information about the kinds of coffees we have sampled:</p>
<pre><code>CoffeeRecord {
    String: Name
    String: Brand
    Integer: Rating
    Float: Cost_Per_Pound
    Boolean: Is_Dark_Roast
    String: Other_Notes
}</code></pre>
<p>Instead of maintaining six individual variables to track a coffee’s properties, we store all of that information in a single composite data structure, <code>CoffeeRecord</code>. Of course, a true coffee connoisseur would likely track a few hundred additional properties, as well as exact information about the date, time, location, and weather conditions related to the coffee consumption. Coffee is, after all, a complex subject and deserves thorough documentation. Each additional property further underscores the importance of using a composite data structure: the alternative of passing around hundreds of related variables not only is tedious but also increases the probability that the programmer will make a mistake, such as passing variables to a function in the wrong order.</p>
<p>Business cards provide a real-world example of composite data structures. Each individual card is a packet of data containing multiple pieces of information such as your name, phone number, and email address. Bundling this information into a single card increases the efficiency of tracking it and passing it around. Imagine the mess and confusion of handing a colleague five different scraps of paper, each containing a single datapoint. </p>
<p>In many programming languages, including Java and Python, data composites can take the form of <em>objects</em>, which contain both the data and functions for operating on their own data. The object’s functions use special syntax to access that object’s data, such as the <code>self</code> reference in Python. An object can also provide different visibility rules that specify whether its internal data is publicly accessible outside the object’s own functions or only privately accessible. </p>
<p>In an attempt to be general, we will treat composite data structures in their most general form: as a collection of data. While example code snippets in this book and elsewhere may implement the composite data structures as objects, the algorithms can be adapted to use non-object representations as well. In code that uses composite data structures or objects, we use the syntax of <var>composite.field</var> to indicate accessing a particular field of a composite data structure. For example, using the following:</p>
<pre><code>latest_record.name = "Sublime Blend"</code></pre>
<p class="BodyContinued">we set the <code>name</code> field of the record <code>latest_record</code> in our coffee log to have the value <code>Sublime Blend</code>. </p>
<h2 id="h1-502604c01-0003"><span epub:type="pagebreak" id="Page_5" title="5"/>Arrays</h2>
<p class="BodyFirst">An <em>array</em> is generally used to store multiple related values. For example, we might want to track the amount of coffee consumed daily over a year. We could brute-force the storage by creating 365 individual variables, such as <code>AmountDay1</code>, <code>AmountDay2</code>, <code>AmountDay3</code>, and so forth, but this is tedious to type and doesn’t allow us to use any structure for the data. <code>AmountDay2</code> is only a textual tag, so the program doesn’t know that <code>AmountDay1</code> stores information for the day before and <code>AmountDay3</code> for the day after; only the programmer knows this. </p>
<p>Arrays provide a simple mechanism for storing multiple values in adjacent and indexable bins. An array is effectively a row of variables—a contiguous block of equal-sized bins in the computer’s memory, as in <a href="#figure1-3" id="figureanchor1-3">Figure 1-3</a>. Like individual variables, arrays occupy a chunk of memory and can sit adjacent to arbitrary other information. Each of the array’s bins can store a value of the given type, such as a number, a character, pointer, or even other (fixed-size) data structures. </p>
<figure>
<img alt="A column of 12 bins. An array occupies the middle 5 bins. The 4 bins below and the 3 bins above the array are labeled Other Stuff." class="" height="376" src="image_fi/502604c01/f01003.png" width="222"/>
<figcaption><p><a id="figure1-3">Figure 1-3</a>: Arrays as bins in the computer’s memory</p></figcaption>
</figure>
<p>Arrays appear throughout our real-world daily lives as well. The row of lockers lining a high school hallway, for example, is a physical array for storing students’ coats and books. We can access any individual storage container by just opening the corresponding locker.</p>
<p>The structure of an array allows you to access any value, also known as an <em>element</em>, within the array by specifying its location, or <em>index</em>. The bins occupy adjacent locations in the computer’s memory, so we can access individual bins by computing their offset from the first element and reading the memory in that location. This requires just a single addition and memory lookup regardless of which bin we access. This structure makes arrays especially convenient for storing items that have an ordered relationship, such as our daily coffee intake tracker.</p>
<p><span epub:type="pagebreak" id="Page_6" title="6"/>Formally, we reference the value at index <code>i</code> of array <code>A</code> as <code>A[i]</code>. In our locker example, the index would be the number displayed on the front of the locker. Most programming languages use <em>zero-indexed arrays</em>, which means the first value of the array resides at index 0, the second at index 1, and so forth, as shown in <a href="#figure1-4" id="figureanchor1-4">Figure 1-4</a>.</p>
<figure>
<img alt="A diagram showing a series of values stored in nine bins. Below the values are their index values. The first index value on the left is zero. The index values increase by 1 and end with 8 on the right." class="" height="86" src="image_fi/502604c01/f01004.png" width="525"/>
<figcaption><p><a id="figure1-4">Figure 1-4</a>: A zero-indexed array</p></figcaption>
</figure>
<p>We will use zero-indexed arrays throughout this book, to stick to general computing convention. <a href="#figure1-5" id="figureanchor1-5">Figure 1-5</a> represents how zero-indexed arrays appear in the computer’s memory, where the white spaces are the elements of the array.</p>
<figure>
<img alt=" A column of 12 bins. An array occupies the middle 5 bins. These 5 bins are labeled A zero through A 4." class="" height="376" src="image_fi/502604c01/f01005.png" width="227"/>
<figcaption><p><a id="figure1-5">Figure 1-5</a>: A zero-indexed array arranged in computer memory </p></figcaption>
</figure>
<p>Zero-indexing conveniently allows us to compute an element’s location in memory as an offset from where the array starts in memory. The location of the <em>i</em>th item in the array can be computed by:</p>
<p class="Equation"><em>Location</em>(<em>item </em>i) = <em>Location</em>(<em>start of array</em>) + <em>Size of each element</em> × i </p>
<p class="BodyContinued">The location of the element at index zero is the start of the array. For example, the fifth element of the example array <code>A</code> in <a href="#figure1-5">Figure 1-5</a> would be <code>A[4]</code>, and, going by the values indexed in <a href="#figure1-4">Figure 1-4</a>, contain the value 9.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	It’s possible to start an index at 1, too, and some programming languages do use that convention. The equation for a bin’s address in a one-indexed array would be <em>Location(start of array)</em> + <em>S</em><em>ize</em> <em>of</em> <em>each</em> <em>element</em> <em>×</em><em> (</em>i<em> −</em><em>1)</em>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" id="Page_7" title="7"/>In most programming languages, we get and set values in an array using a combination of the array’s name and the index. For example, we might set the value of the bin with index 5 equal to 16:</p>
<pre><code>A[5] = 16</code></pre>
<p>For our coffee-tracking example, we could define an array <code>Amount</code> to store the number of cups consumed in a day and store the corresponding counts in <code>Amount[0]</code> through <code>Amount[364]</code>. The single array allows us to access 365 distinct values, in order, through a single variable name. We have transitioned from a series of similarly named, but independent, variables to a mathematical offset of a single location. To understand the power of this, consider our school lockers. Naming individual lockers “Jeremy’s Locker” or “Locker for the third student with a last name starting with K” would make them nearly impossible to find quickly. Rather than simply accessing a specific index, students would have to check a large number of lockers, comparing textual tags until they found the correct match. With array indexing, the students can just use its offset to determine where the locker is and access it directly.</p>
<p>Although we often visualize and discuss arrays as the whole data structure, it is important to remember that each bin behaves like an individual variable. When we want to make a global change to the array, such as shifting the elements forward one position, we need to apply the change individually to each bin as shown in <a href="#figure1-6" id="figureanchor1-6">Figure 1-6</a>.</p>
<figure>
<img alt="A diagram showing 8 bins. Arrows indicate that the values in the bins are all shifting to the left by 1 bin." class="" height="74" src="image_fi/502604c01/f01006.png" width="418"/>
<figcaption><p><a id="figure1-6">Figure 1-6</a>: Shifting elements in an array forward, bin by bin</p></figcaption>
</figure>
<p>Arrays aren’t like books on a bookshelf. We can’t shove the entire collection over at once to make room for the newest edition of <em>Coffee Lover’s Guide to the Best Free-Trade Coffees</em>. Arrays are more like a row of storefronts. We can’t just squeeze a new coffee shop between our favorite neighborhood bookseller and barbershop. To make space, we’d need to shift the storefronts down one by one, by emptying each store and moving its contents into the adjacent building. </p>
<p>In fact, we have to juggle values simply to swap two values in an array. To swap the values at some indices <code>i</code> and <code>j</code>, for instance, we need to first assign one of them to a temporary variable:</p>
<pre><code>Temp = A[i]
A[i] = A[j]
A[j] = Temp</code></pre>
<p class="BodyContinued">Otherwise, we would overwrite the value in one of the bins and the two bins would end up with the same value. Similarly, if we are swapping the locations of the coffee shop and bookseller, we first need to move the contents of the bookstore into an empty third location in order to make space for <span epub:type="pagebreak" id="Page_8" title="8"/>the contents of the coffee shop. Only after we’ve moved the coffee shop can we move the bookstore’s contents from the temporary third location into the coffee shop’s former location.  </p>
<h3 id="h2-502604c01-0001">Insertion Sort</h3>
<p class="BodyFirst">The best way to understand the impact an array’s structure has on how it can be used is to examine it in the context of an actual algorithm. <em>Insertion sort</em> is an algorithm to sort the values in an array. It works on any type of value that can be ordered. We could sort integers, strings, or even the coffees in our pantry by expiration date.</p>
<p>Insertion sort works by sorting a subset of the array and expanding this sorted range until the entire array is in order. The algorithm iterates through each element in the unsorted array and moves it down into the correct location of the sorted section. At the start of iteration <code>i</code>, the items in bins 0 through <code>i</code> − 1 are all in sorted order. The algorithm then takes the item at index <code>i</code>, finds the correct location in the sorted prefix, and inserts it, shifting the necessary items down to make room. The sorted prefix has now grown by one—bins 0 through <code>i</code> are in sorted order. We can start at <code>i</code> = 1 by declaring the first element to be our initial sorted prefix.</p>
<p>Say we want to sort our coffee collection in order of freshness—after all, it would be tragic to leave a bag of premium coffee languishing at the back of the pantry until it was stale. We need to move the earliest best-by dates to the left side of the shelf where they can be readily accessible. </p>
<p>We begin our coffee insertion sort by proclaiming a single bag at the front to be <em>sorted</em> and using this range as our sorted prefix. We then look at the second bag on the shelf and compare dates to determine whether it should go before the first one. After we swap the order, or determine that a swap isn’t necessary, we can confidently proclaim that the first two elements are sorted. We have a subset that’s fully sorted. We then progress to the third bag and determine where it should sit relative to the first two, perhaps making a few swaps in the process. This process continues down the shelf until we’ve achieved perfect coffee organization.</p>
<p>We can implement insertion sort with a pair of nested loops, as shown in <a href="#listing1-1" id="listinganchor1-1">Listing 1-1</a>.</p>
<pre><code>InsertionSort(array: A):
    Integer: N = length(A)
    Integer: i = 1
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> WHILE i &lt; N:
        Type: current = A[i]
        Integer: j = i - 1  
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> WHILE j &gt;= 0 AND A[j] &gt; current:
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = current
        i = i + 1</code></pre>
<p class="CodeListingCaption"><a id="listing1-1">Listing 1-1</a>: Implementing insertion sort with nested loops</p>
<p><span epub:type="pagebreak" id="Page_9" title="9"/>The outer loop with iterator <code>i</code> starts at the first unsorted element, <code>i = 1</code> and progresses through each value in the unsorted range <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The inner loop with iterator <code>j</code> shifts the current value down into the sorted prefix <span aria-label="annotation2" class="CodeAnnotation">❷</span>. At each step, we check the position within the sorted prefix by comparing the <code>current</code> value to the preceding location in the prefix, index <code>j</code>. If the element at <code>j</code> is larger, the two values are in the wrong order and must be swapped. Since we are storing the current value in a separate variable <code>current</code>, we copy the data from the preceding bin directly. There is no need to do a full swap. The inner loop continues until it shifts the current value to the front of the array or it finds a preceding value that is smaller, which indicates the current value is in the correct location of the sorted prefix. We only need to write the current value at the end of the loop when it is in the correct location. The outer loop then proceeds to the next unsorted value.</p>
<p>We can visualize the behavior of the algorithm as shown in <a href="#figure1-7" id="figureanchor1-7">Figure 1-7</a>. Each row shows the state of the array at the beginning of the iteration. The shaded box represents the current item being shifted into position, and the arrows represent the corresponding shifts.</p>
<figure>
<img alt="A diagram showing 8 bins through 8 iterations. At the start, the value at the zero index is 61 and is assumed to be sorted. The second value  is 82, which is left where it is. The third value is 67, which is swapped with 82. The fourth value is 4, which is moved to index zero; the three preceding values are shifted one place forward to make room. And so forth until all eight values are in order from least to greatest." class="" height="722" src="image_fi/502604c01/f01007.png" width="360"/>
<figcaption><p><a id="figure1-7">Figure 1-7</a>: Visualization of an insertion sort algorithm</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_10" title="10"/>Insertion sort isn’t particularly efficient. When inserting elements into the array, we could end up shifting around significant portions of the array. In the worst case, the cost of the algorithm scales proportionally with the square of the number of items—for every item in the list, we shift all the items in front of it. If we double the size of the array, we increase the worst-case cost by a factor of four. While this may not be a huge cost in our coffee pantry, where we are likely to keep only a small number of coffees that we can consume before they go stale, the quadratic cost of the algorithm skyrockets in many applications.</p>
<p>Yet insertion sort provides an important insight into how arrays function. Within this simple algorithm we illustrate several attributes of the array, including the power of being able to access items by their index, the ability to swap values when inserting new elements, and the valuable ability to iterate over entries. </p>
<h2 id="h1-502604c01-0004">Strings</h2>
<p class="BodyFirst"><em>Strings</em> are ordered lists of characters that can often be thought of as a special kind of arrays. Each bin in the string holds a single character, be that a letter, number, symbol, space, or one of a limited set of special indicators. A special character is often used to indicate the end of the string, as represented by the <code>/</code> in the last bin in <a href="#figure1-8" id="figureanchor1-8">Figure 1-8</a>. Characters in strings can often be accessed directly using their index.</p>
<figure>
<img alt="A diagram showing 13 characters, indexed zero to 12.  The characters spell Hello World, exclamation mark, and the last character is a slash." class="" height="68" src="image_fi/502604c01/f01008.png" width="543"/>
<figcaption><p><a id="figure1-8">Figure 1-8</a>: A string spelling “Hello world!”</p></figcaption>
</figure>
<p>In some programming languages, strings are directly implemented as simple arrays of characters. In others, strings may be objects, and the string class serves as a wrapper around an array or other data structure holding the characters. The wrapper class for a string provides additional functionality, such as the ability to dynamically resize the string or search for a substring. In either case, it is useful to think about how the general array-like structure impacts operations on the string. When we display a string on the computer screen, we are effectively iterating through each of its characters and displaying them one at a time.</p>
<p>The common test of equality is more interesting to consider. Unlike integers, which can be directly compared with a single operation, strings must be compared by iterating through each character. The program compares it individually to its counterpart and returns whether it finds a mismatch.</p>
<p><a href="#listing1-2" id="listinganchor1-2">Listing 1-2</a> shows the algorithm for checking the equality of two strings. The algorithm starts by comparing the strings’ size. If they are not the same length, the algorithm stops there. If they are the same length, the algorithm iterates through each position and compares the respective letters of each string. We can terminate the loop as soon as we find a single <span epub:type="pagebreak" id="Page_11" title="11"/>mismatch. Only if we make it all the way to the end of the strings without a mismatch can we declare the strings equal.</p>
<pre><code>StringEqual(String: str1, String: str2):
    IF length(str1) != length(str2):
        return False
    Integer: N = length(str1)
    Integer: i = 0
    WHILE i &lt; N AND str1[i] == str2[i]:
        i = i + 1
    return i == N</code></pre>
<p class="CodeListingCaption"><a id="listing1-2">Listing 1-2</a>: The algorithm for checking the equality of two strings</p>
<p><a href="#figure1-9" id="figureanchor1-9">Figure 1-9</a> demonstrates how this algorithm operates on two strings. The equality sign indicates which pairs of characters matched when compared. The X represents the first mismatched pair, where the test terminates.</p>
<figure>
<img alt="Two strings, Hello world and Hello friend. Equal signs show the first 6 characters are the same. An X in position 7 shows the W and F are different." class="" height="126" src="image_fi/502604c01/f01009.png" width="543"/>
<figcaption><p><a id="figure1-9">Figure 1-9</a>: A comparison of two strings</p></figcaption>
</figure>
<p>The worst-case computational cost of string comparison grows proportionally with the length of the strings. While the work required to compare two small strings can be negligible, the same operation on two long strings can be time-consuming. For comparison, imagine the tedium of scanning through two editions of the same book, letter by letter, looking for each difference in the arrangement of text from one book to the next. In the best case, we find a mismatch early. In the worst case, we need to examine the majority of the book. </p>
<p>Many programming languages, such as Python, provide a string class that allows direct comparisons, so we never need to implement the comparison code in <a href="#listing1-2">Listing 1-2</a> directly. Still, underneath the simple comparison function lies a loop that iterates over all the letters. Without understanding this vital detail, it is possible to vastly underestimate the cost of string comparisons. </p>
<h2 id="h1-502604c01-0005">Why This Matters</h2>
<p class="BodyFirst">Variables and arrays are staples of introductory programming classes and thus might seem less than exciting, but they are important to examine because they provide the very foundations for computer programming and data structures. These concepts also provide the baseline against which to evaluate dynamic data structures and their impact on algorithms. In later chapters, we will see how dynamic data structures can offer different tradeoffs among efficiency, flexibility, and complexity.</p>
</section>
</div></body></html>