- en: '**9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: THE CONTAINER DATA TYPES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器数据类型**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: According to *Merriam-Webster*, *data* is plural in form. If you’re working
    with data, you’re working with *collections* of things such as the names of students
    in a class or the luminosity of stars in the galaxy. You’re going to need somewhere
    to hold all of these collections. That’s where the container data types like tuples,
    lists, sets, and dictionaries come in handy. Each one serves a special purpose
    and comes with special abilities. Together, they’ll help you to keep your rats,
    genes, soil samples, and temperature measurements organized and under control.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*梅里亚姆-韦伯斯特*词典，*数据*是复数形式。如果你在处理数据，那么你实际上是在处理*集合*，例如班级中的学生姓名或星系中恒星的光度。你需要某个地方来存储所有这些集合。这就是像元组、列表、集合和字典等容器数据类型派上用场的地方。它们每种都有特定的用途和功能。它们将帮助你将老鼠、基因、土壤样本和温度测量等内容保持有序和受控。
- en: In this chapter, we’ll explore the built-in data structures listed in [Table
    9-1](ch09.xhtml#ch09tab1), along with some of their main characteristics. Remember,
    *mutability* refers to whether something can be changed (mutated) after it’s created.
    Immutable objects must be copied to a new object for their values to be altered,
    appended, or removed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨[表 9-1](ch09.xhtml#ch09tab1)中列出的内建数据结构，并介绍它们的一些主要特性。记住，*可变性*指的是对象创建后是否可以被修改（变异）。不可变对象必须被复制到新对象中，才能改变其值、追加或移除内容。
- en: '**Table 9-1:** Container Data Types'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** 容器数据类型'
- en: '| **Category** | **Data type** | **Mutability** | **Features** | **Examples**
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **数据类型** | **可变性** | **特点** | **示例** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Sequence type | Tuple | Immutable | Fast, efficient, and unchangeable | `(2,
    5,` `''``Pluto``''``, 4.56)` |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 序列类型 | 元组 | 不可变 | 快速、高效且不可更改 | `(2, 5,` `''``Pluto``''``, 4.56)` |'
- en: '| Sequence type | List | Mutable | Flexible with many built-in functions |
    `[2, 5,` `''``Pluto``''``, 4.56]` |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 序列类型 | 列表 | 可变 | 灵活，拥有许多内建函数 | `[2, 5,` `''``Pluto``''``, 4.56]` |'
- en: '| Set type | Set | Mutable | No duplicate elements, fast searches | `{2, 5,`
    `''``Pluto``''``, 4.56}` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 集合类型 | 集合 | 可变 | 无重复元素，快速查找 | `{2, 5,` `''``Pluto``''``, 4.56}` |'
- en: '| Set type | Frozenset | Immutable | No duplicate elements, fast searches |
    `frozenset({2, 5,` `''``Pluto``''``, 4.56})` |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 集合类型 | 冻结集合 | 不可变 | 无重复元素，快速查找 | `frozenset({2, 5,` `''``Pluto``''``, 4.56})`
    |'
- en: '| Mapping type | Dictionary | Mutable | Maps unique keys to values | `{``''``key``''``:`
    `''``value``''``}` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 映射类型 | 字典 | 可变 | 将唯一的键映射到值 | `{``''``key``''``:` `''``value``''``}` |'
- en: Let’s begin by looking at the simplest of these, the tuple.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的元组开始。
- en: '**Tuples**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**元组**'
- en: 'A *tuple* (pronounced *TOO-pul*) is a fixed-length, iterable, immutable, ordered
    sequence of values. These values are typically referred to as *items* or *elements*.
    Here is an example of a tuple where each name represents an item:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组*（发音为*TOO-pul*）是一个固定长度、可迭代、不可变、有序的值序列。这些值通常被称为*项*或*元素*。以下是一个元组的例子，其中每个名字代表一个项：'
- en: ('`K. L. Putney`', '`M. B. Clark`', '`S. B. Vaughan`')
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ('`K. L. Putney`', '`M. B. Clark`', '`S. B. Vaughan`')
- en: '**NOTE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*An iterable is a collection of items that you can loop through, such as strings,
    tuples, lists, and sets. A sequence is a positionally ordered collection of items
    that acts as a single storage unit.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*可迭代对象是可以循环遍历的项集合，例如字符串、元组、列表和集合。序列是一个按位置排序的项集合，作为单一存储单元。*'
- en: Tuples are a lot like strings, but whereas strings can contain only characters,
    tuples are heterogeneous and can hold any type of value, including mixtures of
    different types. You can even make tuples of tuples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与字符串非常相似，但字符串只能包含字符，而元组是异质的，可以包含任何类型的值，包括不同类型的混合体。你甚至可以创建元组的元组。
- en: Tuples are less commonly used than the *list* data type, and they have fewer
    methods that work on them. But like the old saying goes, “horses for courses.”
    There are times when tuples are preferable to other container types.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的使用频率低于*列表*数据类型，而且对它们有效的方法较少。但正如古话所说，“马有马路，车有车道。”在某些情况下，元组比其他容器类型更为适用。
- en: For example, because they’re immutable, tuples make good places to store objects
    like passwords. When you use a tuple, other programmers will understand that you
    don’t want those values to change. Tuples are also more memory efficient than
    lists due to their immutability, and tuple operations are smaller in size, making
    them slightly faster when working with many elements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于元组是不可变的，它们非常适合存储像密码这样的对象。当你使用元组时，其他程序员会理解你不希望这些值发生变化。由于元组的不可变性，它们比列表更加节省内存，元组的操作也较小，因此在处理大量元素时，元组的速度稍微更快。
- en: '***Creating Tuples***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建元组***'
- en: 'Tuples consist of a sequence of comma-separated values enclosed by parentheses.
    But Python is smart, and just as it can recognize different data types such as
    floats and integers by context, you can break the rules when creating a tuple
    and leave off the parentheses:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 元组由一系列用逗号分隔的值组成，这些值被括号包围。但Python很智能，就像它能根据上下文识别不同的数据类型（如浮动数和整数）一样，你在创建元组时也可以打破规则，省略括号：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Most of the time, however, you’ll want to include the parentheses, both for
    clarity and for when you use more complicated code such as a nested tuple (a tuple
    stored in a tuple):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数时候，你会希望包含括号，这样既能提高代码的可读性，又能在使用更复杂的代码（例如嵌套元组，即元组中存储元组）时保持一致：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Because tuples can hold a single value, separating values with commas is more
    important than using parentheses. To see why, enter the following in a console
    and check the object’s type:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元组可以包含单个值，因此使用逗号分隔值比使用括号更为重要。为了了解原因，在控制台中输入以下内容并检查对象的类型：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, Python thinks you’ve just typed an integer in parentheses! Now,
    add a trailing comma:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Python认为你刚输入了一个带括号的整数！现在，添加一个结尾逗号：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The takeaway is that single-item tuples require a trailing comma.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，单项元组需要一个结尾的逗号。
- en: '***Converting Other Types to Tuples***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将其他类型转换为元组***'
- en: 'You can also create tuples by using the built-in `tuple()` function to convert
    other data types. Enter the following in the console:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用内置的`tuple()`函数将其他数据类型转换为元组。在控制台中输入以下内容：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This snippet turned the string `Hello, World!` into a tuple. Note that each
    character in the string is now a separate element in the tuple.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段将字符串`Hello, World!`转换为元组。请注意，字符串中的每个字符现在都是元组中的一个单独元素。
- en: '**NOTE**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because “tuple” is the name of a function, you should never use it as a variable
    name.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于“tuple”是一个函数名称，你不应将其用作变量名。*'
- en: 'You can also use `tuple()` to turn a list (indicated by square brackets `[]`)
    into a tuple, as demonstrated here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`tuple()`将一个列表（由方括号`[]`表示）转换为元组，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the strings are preserved as words because each string was a separate
    item in the list.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，字符串被保留为单独的单词，因为每个字符串都是列表中的一个单独项。
- en: '***Working with Tuples***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用元组***'
- en: Tuples can be indexed and sliced just like strings (see [Chapter 7](ch07.xhtml)).
    Because tuples are immutable and can’t be modified, they don’t come with many
    built-in methods. For added utility, however, you can take advantage of general-purpose
    built-in functions from the Python Standard Library when you work with them. Some
    of these functions and methods are listed in [Table 9-2](ch09.xhtml#ch09tab2).
    You should substitute real variable and value names for those shown in italics.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以像字符串一样被索引和切片（参见[第7章](ch07.xhtml)）。由于元组是不可变的，无法修改，因此它们没有许多内置方法。然而，在使用元组时，你可以利用Python标准库中的通用内置函数以增加其实用性。这些函数和方法的一些示例列在[表9-2](ch09.xhtml#ch09tab2)中。你应当将斜体中的虚拟变量和数值替换为实际的变量和数值名称。
- en: '**Table 9-2:** Useful Built-in Functions and Tuple Methods'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-2：** 有用的内置函数和元组方法'
- en: '| **Function** | **Description** | **Example** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `tuple()` | Converts a sequence into a tuple | `tuple(`seq_name`)` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `tuple()` | 将序列转换为元组 | `tuple(`seq_name`)` |'
- en: '| `len()` | Returns the length of a sequence | `len(`tuple_name`)` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `len()` | 返回序列的长度 | `len(`tuple_name`)` |'
- en: '| `min()` | Returns the sequence item with the minimum value | `min(`tuple_name`)`
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `min()` | 返回具有最小值的序列项 | `min(`tuple_name`)` |'
- en: '| `max()` | Returns the sequence item with the maximum value | `max(`tuple_name`)`
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `max()` | 返回具有最大值的序列项 | `max(`tuple_name`)` |'
- en: '| **Method** | **Description** | **Example** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** | **示例** |'
- en: '| `count()` | Returns the count of a specified value | tuple_name.`count(`value`)`
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `count()` | 返回指定值的出现次数 | tuple_name.`count(`value`)` |'
- en: '| `index()` | Returns position of a specified value | tuple_name.`index(`value`)`
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `index()` | 返回指定值的位置 | tuple_name.`index(`value`)` |'
- en: Note that tuple *methods* are called *after* the tuple name using dot notation,
    such as tuple_name`.count(value)`. You saw `tuple()` in action in the previous
    section, so let’s start by looking at `len()`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，元组*方法*是在元组名称后使用点表示法调用的，例如tuple_name`.count(value)`。你在前一节中已经看过`tuple()`的用法，所以让我们先看看`len()`。
- en: '**Getting a Tuple’s Length**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**获取元组的长度**'
- en: 'After you make a tuple, it always has a fixed length. You can find this length
    by using the built-in `len()` function. Let’s use the tuples that we created in
    the previous section to see how this works:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元组后，它的长度是固定的。你可以使用内置的`len()`函数来找到这个长度。让我们使用之前创建的元组来看看它是如何工作的：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first result, `3`, is intuitive, as there are three items in `tup`. But
    the length of the nested tuple is only `2`, when there are clearly five items
    present.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个结果`3`是直观的，因为`tup`中有三个项目。但嵌套元组的长度只有`2`，尽管明显有五个项目存在。
- en: 'To understand what’s happening, let’s use indexing to look at the first item
    in each tuple:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解发生了什么，让我们使用索引来查看每个元组中的第一个项目：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Values enclosed by parentheses are considered a *single item* within the overall
    sequence of items in the tuple. If you need to access a value *within* an item,
    you can add another index. For example, to see the first element within each nested
    item, enter the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 括号内的值被视为元组中整体序列中的*单个项目*。如果你需要访问一个项目*内部*的值，可以再添加一个索引。例如，要查看每个嵌套项目中的第一个元素，输入以下内容：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is shown diagrammatically in [Figure 9-1](ch09.xhtml#ch09fig1). Because
    the items in the second nested tuple are strings (`'``Alice``'``,` `'``Bob``'`),
    which are in turn made up of elements (the letters), you need to index to three
    levels to access all of the elements in `nested[1]`. The first index gets the
    nested tuple, the second index gets you a string in the nested tuple, and the
    third index gets you a character within the string.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图9-1](ch09.xhtml#ch09fig1)所示。由于第二个嵌套元组中的项目是字符串（`'``Alice``'`，`'``Bob``'`），而这些字符串又由元素（字母）组成，你需要索引到三层才能访问`nested[1]`中的所有元素。第一个索引获取嵌套元组，第二个索引获取嵌套元组中的字符串，第三个索引获取字符串中的字符。
- en: '![Image](../images/09fig01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig01.jpg)'
- en: '*Figure 9-1: An example of indexing a nested tuple*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：索引嵌套元组的示例*'
- en: 'Understanding this behavior is important in the event that you want to iterate
    over a tuple to get its values one by one (we haven’t covered looping yet, so
    bear with me). This is straightforward with a non-nested tuple:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种行为很重要，万一你想迭代一个元组，逐一获取它的值时（我们还没有讲解循环，所以请耐心等待）。对于非嵌套元组，这是直接的：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For nested tuples, you need to loop through the elements in *each* nested tuple
    to get to all of the items:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌套元组，你需要遍历每个嵌套元组中的元素，以便访问所有项目：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The terms “item” and “element” have no special meaning. You could just as easily
    call them “i” and “j” or “Fred” and “George.”
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “项目”和“元素”这两个术语没有特殊含义。你完全可以把它们称为“i”和“j”或者“Fred”和“George”。
- en: '**Getting a Tuple’s Minimum and Maximum Values**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**获取元组的最小值和最大值**'
- en: 'The `min()` and `max()` functions return the minimum and maximum values in
    a tuple, respectively. Here’s an example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`min()`和`max()`函数分别返回元组中的最小值和最大值。以下是一个示例：'
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That’s easy, but what if we try it on the nested tuple? Let’s see what happens:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但如果我们尝试在嵌套元组上进行操作呢？让我们看看会发生什么：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Python raises a `TypeError` because it doesn’t know how to distinguish a minimum
    string from a minimum integer. You can find a minimum value in a tuple of strings,
    however. Check this out:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python抛出一个`TypeError`错误，因为它不知道如何区分最小字符串和最小整数。然而，你可以在字符串元组中找到最小值。看看这个：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `min()` and `max()` functions use the ASCII sorting order to sort strings.
    In an ASCII table (see *[https://www.asciitable.com/](https://www.asciitable.com/)*),
    special characters, like punctuation marks, come before the alphabet, and uppercase
    letters come before lowercase letters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`min()`和`max()`函数使用ASCII排序顺序来排序字符串。在ASCII表中（见* [https://www.asciitable.com/](https://www.asciitable.com/)*），特殊字符（如标点符号）排在字母之前，大写字母排在小写字母之前。'
- en: 'Many other built-in functions work with multiple data types. The `len()` function,
    for example, works with strings, tuples, sets, lists, and dictionaries. The membership
    operators you learned about in [Chapter 7](ch07.xhtml) also work with multiple
    types. Here’s an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他内置函数可以处理多种数据类型。例如，`len()`函数适用于字符串、元组、集合、列表和字典。在[第7章](ch07.xhtml)中学过的成员操作符也适用于多种类型。这里是一个示例：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Unpacking Tuples**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**拆解元组**'
- en: 'You can assign the values in a tuple to multiple variables at once using a
    process called *unpacking*. Let’s pretend that you’ve written a function that
    returns a Cartesian coordinate (x, y) pair as a tuple. You want to use the individual
    x and y values later in the program. Here’s how you can get at those values:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一种叫做*解包*的过程将元组中的值一次性赋给多个变量。假设你编写了一个返回笛卡尔坐标（x，y）对的函数，并希望在程序的后续部分使用单独的 x
    和 y 值。以下是你可以获取这些值的方法：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To use nested tuples, assign variables using the same parenthesis structure.
    Let’s revisit our `nested` tuple:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用嵌套元组，可以使用相同的括号结构来赋值变量。让我们重新审视我们的 `nested` 元组：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You don’t need to take all of the elements. Suppose that you want only the
    first three numbers in the nested tuple. If you try to take them directly, you’ll
    raise an exception:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要获取所有的元素。假设你只想获取嵌套元组中的前三个数字。如果直接尝试获取，它将引发一个异常：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Python expects you to unpack every item in the tuple. To get around this, you
    can unpack the tuple using the *splat* (or *star*) operator (`*`) with the insignificant
    variable symbol (`_`). Splat allows for an arbitrary number of items, so in this
    case, you’re telling Python to “get the rest” and assign them to `_`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Python 期望你解包元组中的每个项目。为了绕过这个问题，你可以使用 *splat*（或 *star*）运算符（`*`）结合无关的变量符号（`_`）来解包元组。Splat
    允许任意数量的项，所以在这种情况下，你告诉 Python “获取其余部分”并将它们赋值给 `_`：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You don’t need to use the values in `_`. These will be cleared from memory later
    when Python performs routine garbage collection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要使用 `_` 中的值。这些值将在 Python 执行常规垃圾回收时被清除出内存。
- en: '**Operator Overloading with Tuples**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**元组的运算符重载**'
- en: 'You can use operator overloading on tuples, just as with strings. For example,
    adding two tuples produces a new tuple containing the values of both tuples:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像操作字符串一样在元组上使用运算符重载。例如，将两个元组相加会产生一个新元组，包含两个元组的所有值：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the multiplication operator with an integer concatenates multiple copies
    of a tuple along with copies of the references to the objects they contain:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用乘法运算符与整数结合时，会将元组的多个副本与它们所包含的对象引用的副本连接在一起：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Unexpected Tuple Behaviors**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**意外的元组行为**'
- en: 'There are loopholes in the rule that tuples are immutable. For instance, if
    a tuple contains a *mutable* data type, you can change that item within a tuple.
    Let’s try this using a mutable list (enclosed in square brackets; we’ll look more
    at lists in the next section):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 元组不可变的规则存在漏洞。例如，如果元组包含一个*可变*数据类型，你可以在元组内更改该项。让我们通过使用一个可变列表来尝试（列表用方括号括起来；我们将在下一部分进一步了解列表）：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we were able to change the second item in the list (`[2][1]`)
    from `Bob` to `Steve`, even though tuples are immutable. This falls under the
    category of things you *can* do, but *shouldn’t*!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们能够将列表中的第二项（`[2][1]`）从 `Bob` 更改为 `Steve`，即使元组是不可变的。这属于你*可以*做的事情，但*不应该*做的事情！
- en: '**Printing Tuples**'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**打印元组**'
- en: 'Running `print()` on a tuple can be frustrating, as the default display includes
    the commas and quotation marks:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在元组上运行 `print()` 可能会令人沮丧，因为默认显示包含了逗号和引号：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To fix this, you can use the `join()` string method to print only the strings
    in a tuple:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以使用 `join()` 字符串方法来只打印元组中的字符串：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this example, we joined each item in the tuple using a space (`'' ''`).
    You can use other characters to join items, such as the newline escape sequence
    (`\n`):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用空格（`' '`）将元组中的每个项连接起来。你也可以使用其他字符来连接项，例如换行符转义序列（`\n`）：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `join()` method works only for sequences composed of strings. To handle
    mixed data types, include the `map()` built-in function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()` 方法仅适用于由字符串组成的序列。要处理混合数据类型，请包含内建函数 `map()`：'
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also use the splat operator (`*`) to print a tuple efficiently and
    attractively:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 splat 运算符（`*`）高效且美观地打印元组：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Splat takes the tuple as input and expands it into positional arguments in the
    function call. The last argument is the separator used between items for printing.
    The default separator is a space (`sep=`' ').
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Splat 将元组作为输入并将其展开为函数调用中的位置参数。最后一个参数是用于打印时项之间的分隔符。默认分隔符是空格（`sep=' '`）。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: '1.  For `tup = (1, 2, 3)`, what happens if you run this code: `tup[3]`?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  对于 `tup = (1, 2, 3)`，如果运行这段代码 `tup[3]`，会发生什么？
- en: 2.  If `test = (``'``a``'``,` `'``!``'``)`, what is the result of running `min(test)`?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  如果 `test = ('a', '!')`，运行 `min(test)` 的结果是什么？
- en: 3.  Use indexing to isolate the letter “y” in `tup = (``'``Rust``'``,` `'``R``'``,`
    `'``Go``'``,` `'``Julia``'``), (``'``Python``'``)`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  使用索引来提取`tup = (``'``Rust``'``,` `'``R``'``,` `'``Go``'``,` `'``Julia``'``),
    (``'``Python``'``)`中的字母“y”。
- en: 4.  Which of the following are characteristics of a tuple?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  以下哪些是元组的特征？
- en: a.  Fixed length
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: a. 固定长度
- en: b.  Ordered values
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: b. 有序的值
- en: c.  Contents are unchangeable
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: c. 内容不可更改
- en: d.  Holds only integers, floats, and strings
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: d. 仅包含整数、浮点数和字符串
- en: '5.  Make a “field trip” tuple containing these five items: pith helmet, rock
    hammer, hand lens, hiking boots, and sunglasses. Then, write code that removes
    the pith helmet from the tuple (because I’m not wearing that!).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  创建一个“实地考察”元组，包含这五项：顶篷帽、岩石锤、手持放大镜、登山靴和太阳镜。然后，编写代码从元组中移除顶篷帽（因为我不穿那个！）。
- en: '**Lists**'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**列表**'
- en: 'A list is a variable-length, iterable, mutable, ordered sequence of values.
    They look like tuples except they’re enclosed in brackets rather than parentheses:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一个可变长度、可迭代、有序的值序列。它们看起来像元组，只是它们被方括号而不是圆括号包围：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because lists are mutable, you can change their values at will. You can add
    items, change items, and delete items. Otherwise, lists are like tuples. They
    can hold multiple data types, including mixtures of types. You can index them,
    slice them, concatenate them, nest them, use built-in functions, and more. Lists
    are true workhorses in Python, and you will use them all the time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为列表是可变的，你可以随意更改它们的值。你可以添加项目、更改项目和删除项目。否则，列表和元组类似。它们可以保存多种数据类型，包括不同类型的混合。你可以对它们进行索引、切片、连接、嵌套、使用内置函数等等。列表是Python中的真正“工作马”，你将经常使用它们。
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Lists are objects that can be treated as values. That is, they can be stored
    in variables and passed to functions. If you hear the term list value, be aware
    that it refers to the whole list, not some value inside it.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表是可以作为值处理的对象。也就是说，它们可以存储在变量中并传递给函数。如果你听到“列表值”这个术语，请注意它指的是整个列表，而不是列表中的某个值。*'
- en: '***Creating Lists***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建列表***'
- en: 'To create a list, enclose a value or comma-delimited values in square brackets
    (`[]`):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个列表，将值或逗号分隔的值放入方括号（`[]`）中：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Because lists are mutable, you can begin with an empty list. For example, you
    might set up an empty list to hold user input later in the program. Here’s how:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因为列表是可变的，你可以从一个空列表开始。例如，你可以设置一个空列表，在程序稍后保存用户输入。操作方法如下：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also use the built-in `list()` function to convert other data types,
    like tuples and strings, into lists:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用内置的`list()`函数将其他数据类型（如元组和字符串）转换为列表：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**NOTE**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because “list” is the name of a function, never use it as a variable name.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为“list”是一个函数的名称，请勿将其用作变量名。*'
- en: '***Working with Lists***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与列表的操作***'
- en: Because lists are mutable, you can do a lot more with them than you can with
    tuples, and they come with more built-in functionality. [Table 9-3](ch09.xhtml#ch09tab3)
    summarizes the list methods. You’ll need to substitute your own names for those
    in italics. In addition, you can use the `len()`, `min()`, and `max()` built-in
    functions from [Table 9-2](ch09.xhtml#ch09tab2) with lists.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为列表是可变的，你可以对它们做更多操作，而不仅限于元组，并且它们提供了更多的内置功能。[表 9-3](ch09.xhtml#ch09tab3)总结了列表方法。你需要将斜体部分的名称替换为你自己的名称。此外，你还可以使用[表
    9-2](ch09.xhtml#ch09tab2)中的`len()`、`min()`和`max()`内置函数来处理列表。
- en: '**Table 9-3:** Built-in List Methods'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-3:** 内置列表方法'
- en: '| **Method** | **Description** | **Example** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `append()` | Add a single item to the end of a list | list_name`.append(`item`)`
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `append()` | 将单个项添加到列表末尾 | list_name`.append(`item`)` |'
- en: '| `extend()` | Add iterable items to the end of a list | list_name`.extend(`iterable`)`
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `extend()` | 将可迭代项添加到列表末尾 | list_name`.extend(`iterable`)` |'
- en: '| `insert()` | Insert an item before a given index (`i`) | list_name`.insert(`i,
    item`)` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `insert()` | 在给定索引（`i`）之前插入项 | list_name`.insert(`i, item`)` |'
- en: '| `remove()` | Remove first item from list with value = item | list_name`.remove(`item`)`
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `remove()` | 移除列表中第一个与项值相等的项 | list_name`.remove(`item`)` |'
- en: '| `pop()` | Remove and return item at given index | list_name`.pop(`index`)`
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 移除并返回给定索引处的项 | list_name`.pop(`index`)` |'
- en: '| `clear()` | Remove all items from a list | list_name`.clear()` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 移除列表中的所有项 | list_name`.clear()` |'
- en: '| `index()` | Return index of first item with value = item | list_name`.index(`item`)`
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `index()` | 返回第一个值等于项的索引 | list_name`.index(`item`)` |'
- en: '| `count()` | Return number of times an item appears in a list | list_name`.count(`item`)`
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `count()` | 返回某个项在列表中出现的次数 | list_name`.count(`item`)` |'
- en: '| `sort()` | Sort list items in place | list_name`.sort()` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `sort()` | 原地排序列表项 | list_name`.sort()` |'
- en: '| `reverse()` | Reverse list items in place | list_name`.reverse()` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `reverse()` | 原地反转列表项 | list_name`.reverse()` |'
- en: '| `copy()` | Return a shallow copy of a list | list_name`.copy()` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `copy()` | 返回列表的浅拷贝 | list_name`.copy()` |'
- en: List methods don’t work like the string methods you learned about in [Chapter
    7](ch07.xhtml). Whereas string methods perform their task and return a new string,
    list methods usually modify the list and return `None`. To sort a list, for example,
    you should use `list_name.sort()`, not `list_name = list_name.sort()`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表方法的工作方式不同于你在[第7章](ch07.xhtml)中学到的字符串方法。字符串方法执行任务并返回一个新的字符串，而列表方法通常会修改列表并返回`None`。例如，要排序一个列表，你应该使用`list_name.sort()`，而不是`list_name
    = list_name.sort()`。
- en: '**NOTE**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All of the methods for printing tuples also work with lists, so refer to “Printing
    Tuples” on [page 228](ch09.xhtml#ch00lev3sec28).*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有打印元组的方法也适用于列表，因此请参见[第228页](ch09.xhtml#ch00lev3sec28)的“打印元组”。*'
- en: '**Adding Items to Lists**'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**向列表添加项**'
- en: The `append` item lets you add an item to the end of a list.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`项允许你将一个项添加到列表的末尾。'
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To add *multiple* items to the end of a list, the items need to be in the form
    of an iterable. Let’s try adding a heron and a hare to the `patroni` list:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将*多个*项添加到列表末尾，项需要以可迭代的形式存在。让我们尝试将一只鹭鸟和一只野兔添加到`patroni`列表中：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You get a `TypeError` because the `extend()` method is looking for one argument
    (the thing between parentheses), not two. Now, try passing it a tuple of names,
    instead:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到一个`TypeError`，因为`extend()`方法期望一个参数（括号中的内容），而不是两个。现在，尝试传递一个元组的名称，看看效果：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Success! Both `append()` and `extend()` are useful when either looping through
    values and adding some of them to a list, or when adding values returned from
    a function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！无论是循环遍历值并将其中一些添加到列表中，还是添加从函数返回的值，`append()`和`extend()`都很有用。
- en: '**Inserting Values into Lists**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**插入值到列表中**'
- en: 'If you need to insert an item at a specific location in a list, not just at
    the end, use the `insert()` method and *pass* it (add between the parentheses)
    the index *before which* you want to place the item, and then the item, separated
    by a comma. For example, to add an item to the start of the `patroni` list, use
    an index of `0`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将一个项插入到列表的特定位置，而不仅仅是在末尾，可以使用`insert()`方法，并*传递*（即在括号中添加）你想放置该项之前的索引，然后是该项，两者之间用逗号分隔。例如，要将一个项添加到`patroni`列表的开头，可以使用索引`0`：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `insert()` method shifts the index for each item to accommodate the new
    item. This is computationally expensive, however, and should be avoided when possible.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`方法会为每个项调整索引，以容纳新的项。然而，这在计算上是昂贵的，应尽量避免使用。'
- en: '**Removing Items from Lists**'
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从列表中删除项**'
- en: 'If you want to remove an item from anywhere in a list, use the `pop()` method.
    Let’s remove the `cat` patronus. Because `pop()` returns the item as well as removing
    it, we can also use it in some way, such as by assigning it to a variable, though
    this is optional. Let’s take a look:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从列表的任何位置删除一个项，可以使用`pop()`方法。让我们删除`cat`的守护神。因为`pop()`不仅会删除该项，还会返回它，我们可以以某种方式使用它，比如将其赋值给一个变量，虽然这是可选的。让我们来看一下：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We now have a new variable that holds the string `cat`, whereas the `patroni`
    list no longer contains that item.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个新的变量，保存字符串`cat`，而`patroni`列表中不再包含该项。
- en: If you don’t specify an index, `pop()` removes the last item in the list.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不指定索引，`pop()`会删除列表中的最后一个项。
- en: 'Another way to remove items is to use the `del` operator, short for “delete.”
    Just pass it the index:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 删除项的另一种方法是使用`del`运算符，它是“删除”的缩写。只需传递索引给它：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `del` operator also permits slicing:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`del`运算符也允许切片操作：'
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also remove an item by naming it in the `remove()` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在`remove()`方法中指定项来删除该项：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that only the first occurrence of `'``a'` is removed. Also, if the specified
    item doesn’t exist in the list, Python will raise a `ValueError`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有第一个出现的`'a'`会被移除。而且，如果指定的项在列表中不存在，Python会引发`ValueError`。
- en: '**Changing the Value of Items in Lists**'
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更改列表中项的值**'
- en: 'You can change the value of items within a list by using indexing. Let’s change
    the `hare` patronus to a `wolf`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用索引来更改列表中项的值。让我们将`hare`的守护神更改为`wolf`：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Because `hare` came at the end of the list, we could have also used the built-in
    `len()` function to find the end of the list and use its return value:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`hare`位于列表的末尾，我们也可以使用内置的`len()`函数来找到列表的末尾，并使用其返回值：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You need to subtract one from the length of the list because iterating and indexing
    in Python start at 0, so the final index is always one less than the length of
    the list.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从列表的长度中减去1，因为 Python 中的迭代和索引是从0开始的，所以最后一个索引总是比列表的长度小1。
- en: '**Finding the Index of Items in Lists**'
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在列表中查找项目的索引**'
- en: 'Similar to the `remove()` method, the `index()` method will return the zero-based
    index of the first occurrence of a specified item in a list. It also raises a
    `ValueError` if the item doesn’t exist. Let’s fetch the index of `dog` in the
    `patroni` list:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`remove()`方法，`index()`方法将返回列表中指定项第一次出现的零基索引。如果该项不存在，它还会引发`ValueError`。让我们获取`patroni`列表中`dog`的索引：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can also use slice notation on the list to limit the search to a particular
    subsequence. Just add optional start and end arguments after the item name. The
    returned index is still computed relative to the beginning of the full sequence,
    however:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在列表上使用切片表示法，限制搜索范围到某个子序列。只需在项名后添加可选的开始和结束参数。然而，返回的索引仍然是相对于整个序列的开始来计算的：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this example, the `index()` method looked at the items between indexes `2`
    and `5` (`dog` *up to* `wolf`).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`index()`方法查看了索引`2`到`5`之间的项目（`dog` *直到* `wolf`）。
- en: 'The `count()` method returns the number of times an item appears in a list:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`方法返回某项在列表中出现的次数：'
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Sorting the Values in Lists**'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**列表中的值排序**'
- en: 'The `sort()` method sorts lists in place, either alphabetically or numerically.
    For example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`方法原地对列表进行排序，可以是按字母顺序或数字顺序。例如：'
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Computers are very literal, however, and things might not go as planned. Notice
    what happens if you try to alphabetize a list comprising letters with different
    cases:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，计算机非常字面化，事情可能不会按计划进行。注意如果你尝试按字母顺序对一个包含不同大小写字母的列表进行排序时会发生什么：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The Python default is to place capitalized letters before lowercase ones. So,
    this mixed-case example is correct by Python’s standards but probably isn’t what
    you expected or wanted. To force Python to compare apples to apples, you can use
    the optional `key` argument to convert all strings to lowercase before sorting:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的默认行为是将大写字母排在小写字母前。因此，这个混合大小写的例子虽然符合 Python 的标准，但可能并不是你预期或想要的。为了强制 Python
    将字母一视同仁，你可以使用可选的`key`参数，在排序前将所有字符串转换为小写：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `sort()` method also comes with a second optional argument for *reversing*
    the order of items in the list:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`方法还带有第二个可选参数，用于*反转*列表中项的顺序：'
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can pass `sort()` a *sort key* to let it know what parameter you want to
    sort by. In this example, we’re sorting based on the length of strings using the
    `len` sort key:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为`sort()`传递一个*排序键*，告诉它你希望按哪个参数进行排序。在这个例子中，我们根据字符串的长度使用`len`排序键进行排序：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can even write and pass `sort()` a custom function to do more complicated
    sorting. To find out more, visit the sorting tutorial at *[https://docs.python.org/3/howto/sorting.html](https://docs.python.org/3/howto/sorting.html)*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以编写并传递一个自定义函数给`sort()`，以进行更复杂的排序。要了解更多内容，请访问排序教程 *[https://docs.python.org/3/howto/sorting.html](https://docs.python.org/3/howto/sorting.html)*。
- en: '**The Curious Case of Copy**'
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**复制的奇怪案例**'
- en: The act of copying a list reveals perhaps the greatest “gotcha” in the Python
    language. Pour yourself a cup of coffee, because this may be the most important
    thing you learn all day.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 复制列表的行为可能暴露了 Python 语言中最大的“陷阱”。给自己倒杯咖啡，因为这可能是你今天学到的最重要的事情。
- en: Remember that variable names are references to an object, but not the object
    itself? Likewise, when you copy an object using an assignment statement, you copy
    only the reference to that object. When this behavior is combined with mutable
    objects, mayhem can result.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得变量名是指向对象的引用，而不是对象本身吗？同样，当你通过赋值语句复制一个对象时，你只是复制了对该对象的引用。当这种行为与可变对象结合时，可能会导致混乱。
- en: 'Let’s assign a list to another list, a seemingly straightforward thing to do:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一个列表赋值给另一个列表，看起来是件简单的事：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You might think `my_patroni` and `your_patroni` are separate lists containing
    identical values, but they’re not. Each name points to the same object in memory.
    You can confirm this by checking the identity of each:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为`my_patroni`和`your_patroni`是包含相同值的独立列表，但它们并不是。每个名称都指向内存中的同一个对象。你可以通过检查每个对象的标识来确认这一点：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'They’re the same object. So, if you alter one, you alter the other:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是同一个对象。所以，如果你修改一个，另一个也会被修改：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Changing the first item in `my_patroni` changed the same item in `your_patroni`.
    This kind of behavior can keep you up bug-hunting all night.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`my_patroni`中的第一个项同时改变了`your_patroni`中的相同项。这种行为可能会让你整夜调试找bug。
- en: 'To properly copy a mutable object, like a list, use the `copy()` method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地复制一个可变对象，比如列表，使用`copy()`方法：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Alternatively, you can use slice notation to copy the whole list from start
    to finish:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用切片表示法从头到尾复制整个列表：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Regardless of the method, each list object has a separate identity:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方法，每个列表对象都有一个独立的身份：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'That’s great, but we’re not through yet. The slice and `copy()` methods make
    a *shallow* copy. This means that if a list contains nested lists, `copy()` duplicates
    only *references* to the inner, nested lists. Let’s look at an example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们还没有完成。切片和`copy()`方法会进行*浅*拷贝。这意味着，如果一个列表包含嵌套列表，`copy()`方法只会复制指向内部嵌套列表的*引用*。让我们来看一个例子：
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As expected, these two lists have different identities, meaning that they’re
    different objects. Now let’s check the identity of the first nested list, at index
    `0`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这两个列表有不同的身份，意味着它们是不同的对象。现在让我们检查第一个嵌套列表（索引为`0`）的身份：
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This inner list is the same object in both lists. To prove it, change the first
    item in this list to `wolf`. Remember, the first index references the first nested
    list, and the second index references the first item in this list.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内部列表在两个列表中是同一个对象。为了证明这一点，改变这个列表中的第一个项为`wolf`。记住，第一个索引引用的是第一个嵌套列表，而第二个索引引用的是这个列表中的第一个项。
- en: '[PRE57]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Again, changing an item in one list has changed the same item in another. Note
    that this behavior extends only to the *nested* lists. If you append a new item
    to the `my_patroni` list, it won’t affect `your_patroni`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，修改一个列表中的项会同时修改另一个列表中的相同项。注意，这种行为仅限于*嵌套*列表。如果你向`my_patroni`列表添加一个新项，它不会影响到`your_patroni`：
- en: '[PRE58]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To avoid this type of behavior, you should import the built-in `copy` module
    and use its `deepcopy()` method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种行为，你应该导入内建的`copy`模块并使用其`deepcopy()`方法：
- en: '[PRE59]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, the nested lists are separate objects, and you’ve created a true copy of
    the original. No more “quantum entanglement” with “spooky action at a distance.”
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，嵌套列表已经是独立的对象，你已成功创建了原始列表的真正副本。不再有“量子纠缠”或“远程作用”的问题。
- en: For a slight slowdown in your code, `deepcopy()` will ensure that you’re copying
    any internal object references. This includes all mutable objects within a list
    at every possible level, thereby avoiding bugs that can cost you much more time
    to find and correct.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了略微降低代码运行速度，`deepcopy()`会确保你复制所有内部对象的引用。这包括列表中每一层级的所有可变对象，从而避免可能需要花费大量时间来发现和修复的bug。
- en: '**Checking for Membership**'
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查成员关系**'
- en: 'You can check whether an item occurs in a list using the `in` and `not_in`
    keywords. These also work on other container data types, as shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`in`和`not_in`关键字检查一个项是否出现在列表中。这些关键字同样适用于其他容器数据类型，如下所示：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Doing this for large lists is not recommended, however. Checking for membership
    in a list is computationally expensive and thus slow. Python must check through
    every value in a list to perform this operation, whereas in other collection data
    types such as sets and dictionaries, it can use very fast hash tables for a noticeable
    improvement in performance. It’s easy to convert a list into a set for this purpose,
    and we’ll do it later in this chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于大列表，不建议这样做。检查列表中的成员关系是计算开销很大的操作，因此很慢。Python必须检查列表中的每一个值才能执行此操作，而在其他集合数据类型，如集合和字典中，它可以使用非常快速的哈希表来显著提高性能。为了这个目的，将列表转换为集合非常简单，稍后我们会在本章中进行介绍。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 6.  Create an empty list named `patroni` and then add a tiger, shark, and weasel
    to it all at once.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  创建一个名为`patroni`的空列表，然后一次性向其中添加老虎、鲨鱼和鼬鼠。
- en: 7.  Delete all of the items in the previous `patroni` list.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  删除之前`patroni`列表中的所有项。
- en: 6.  Which is the *wrong* way to add “shrew” to the `patroni` list?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  向`patroni`列表中添加“鼬鼠”的*错误*方法是什么？
- en: a.  `patroni.append(``'``shrew``'``)`
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `patroni.append(``'``shrew``'``)`
- en: b.  `patroni += ['shrew'``]`
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `patroni += ['shrew'`]`
- en: c.  `patroni = patroni + 'shrew'`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `patroni = patroni + 'shrew'`
- en: d.  `patroni = patroni + ['shrew']`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`patroni = patroni + [''shrew'']`'
- en: 9.  Why shouldn’t you use `patroni += 'shrew'`?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  为什么不应该使用`patroni += 'shrew'`？
- en: 'a.  You’ll raise `TypeError: can only concatenate list (not ″str″) to list`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'a.  你将抛出`TypeError: can only concatenate list (not ″str″) to list`'
- en: b.  Augmented operators work only with strings and mathematical expressions
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: b.  增量运算符只适用于字符串和数学表达式
- en: c.  Each letter in “shrew” will become a separate item in the list
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: c. “鼩鼱”中的每个字母都会变成列表中的一个单独项
- en: d.  No one uses a shrew as a patronus
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: d. 没有人会用鼩鼱作为守护神
- en: '10.  J.K. Rowling’s personal patronus is a:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: J.K. Rowling的个人守护神是：
- en: a.  Manx cat
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: a. 曼岛猫
- en: b.  Jack Russell terrier
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: b. 杰克·拉塞尔梗
- en: c.  Heron
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: c. 鹤
- en: d.  Hummingbird
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: d. 蜂鸟
- en: '**Sets**'
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**集合**'
- en: 'A *set* is a mutable, unordered, iterable collection of *unique* elements (no
    duplicates allowed). Sets are designed to work like their mathematical counterparts
    and thus support operations such as union, intersection, and difference. Sets
    look like tuples and lists except that they’re enclosed in curly brackets:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合*是一个可变的、无序的、可迭代的包含*唯一*元素（不允许重复）的集合。集合的设计方式类似于数学中的集合，因此支持并集、交集和差集等操作。集合看起来像元组和列表，只不过它们被大括号包围：'
- en: '[PRE61]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Sets are based on a data structure known as a *hash table* that makes adding
    and searching for elements in them very fast (we looked at this data structure
    back in “The Debugger Pane” on [page 90](ch04.xhtml#ch00lev1sec32)). A deep discussion
    of hash tables is beyond the scope of this book, but basically, hashing is a process
    whereby a key or string of characters is transformed into a shorter, fixed-length
    value that’s easier to find, and these values are stored in a hash table for easy
    look-up.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 集合基于一种称为*哈希表*的数据结构，这使得向集合中添加和查找元素非常快速（我们在《调试器面板》一节中讨论过这种数据结构，见[第90页](ch04.xhtml#ch00lev1sec32)）。哈希表的深度讨论超出了本书的范围，但基本上，哈希是一种将键或字符序列转换为更短、固定长度的值的过程，这些值更容易查找，并且这些值被存储在哈希表中以便快速查找。
- en: Besides being significantly faster than tuples and lists for membership tests,
    sets let you efficiently remove duplicate values from those data types by converting
    them into a set. On the other hand, sets are slightly slower during iteration
    and take up more memory. And because sets are unordered, you can’t access elements
    using indexes, as you can with the tuples and lists.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在成员测试上比元组和列表明显更快外，集合还可以通过将元组或列表转换为集合来有效去除其中的重复值。另一方面，集合在迭代时稍微慢一些，占用的内存也更多。而且，由于集合是无序的，你不能像访问元组和列表那样使用索引来访问元素。
- en: '***Creating Sets***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建集合***'
- en: 'Sets consist of a sequence of comma-separated values enclosed by curly brackets
    (`{}`):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 集合由一系列以逗号分隔的值组成，这些值被大括号（`{}`）包围：
- en: '[PRE62]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can also copy sets using the built-in `set()` function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用内置的 `set()` 函数来复制集合：
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `set()` function also converts other data types to sets:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()` 函数也可以将其他数据类型转换为集合：'
- en: '[PRE64]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This snippet turned the string `a_string` into a set. Note that each character
    in the string is now a separate element in the set, duplicates have been removed,
    and the elements are unordered.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将字符串 `a_string` 转换为了集合。注意，字符串中的每个字符现在是集合中的一个单独元素，重复项已被删除，元素是无序的。
- en: As a side note, to create an empty set you must use `set()`, not `{}`, as the
    latter creates an empty dictionary, a data structure that we’ll cover in the next
    section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，要创建一个空集合，你必须使用 `set()`，而不是 `{}`，因为后者会创建一个空字典，这是我们将在下一节中介绍的数据结构。
- en: '**NOTE**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because “set” is the name of a function, you should never use it as a variable
    name.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为“set”是一个函数的名称，你永远不应将其用作变量名。*'
- en: The elements in sets must be *hashable*, which means they must be immutable.
    Because Python hashes each element in a set and stores the hash value, if you
    change an element in place, it gets hashed again, and the new hash value is stored
    in a different location in the hash table. This can cause conflicts and lost elements
    that prevent the set from working correctly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中的元素必须是*可哈希的*，这意味着它们必须是不可变的。因为Python对集合中的每个元素进行哈希并存储哈希值，如果你就地修改一个元素，它会被重新哈希，新的哈希值会存储在哈希表中的不同位置。这可能会导致冲突和丢失元素，从而使集合无法正常工作。
- en: 'Integers, floats, and strings are immutable, as are tuples composed of immutable
    items. You can check whether an object in Python is hashable using the `hash()`
    function:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 整数、浮动数和字符串是不可变的，就像由不可变项组成的元组一样。你可以使用 `hash()` 函数检查Python中的对象是否是可哈希的：
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Because the string `'``astrolabe``'` is immutable, it was assigned a hash value.
    If you try this with a mutable list, however, you’ll raise a `TypeError`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字符串 `'``astrolabe``'` 是不可变的，所以它被分配了一个哈希值。但是，如果你尝试对一个可变列表执行相同的操作，你将抛出一个 `TypeError`
    错误。
- en: 'To use a mutable sequence in a set, you first must convert it to a tuple. In
    this example, we convert a list to a tuple while assigning it to a set:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要在集合中使用可变序列，首先必须将其转换为元组。在这个例子中，我们在将列表赋值给集合时将其转换为元组：
- en: '[PRE66]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This works only if the tuple doesn’t contain mutable items, such as a list:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅在元组中不包含可变项（如列表）时有效：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If you have lists in your tuple, you’ll need to convert them into tuples, as
    well.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的元组中有列表，你需要将它们也转换为元组。
- en: 'Because sets use hash tables, they take up more memory than tuples and lists.
    Enter the following code into the console to see the difference:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因为集合使用哈希表，所以它们比元组和列表占用更多的内存。输入以下代码到控制台以查看差异：
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: A set of 10,000 elements takes up roughly six times the memory of a list and
    6.5 times the memory of a tuple of the same size.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含10,000个元素的集合大约占用比列表多六倍的内存，比相同大小的元组多6.5倍的内存。
- en: '***Working with Sets***'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与集合的操作***'
- en: '[Table 9-4](ch09.xhtml#ch09tab4) lists some common methods for working with
    sets. You should substitute your own variable names for the ones shown in *italics*.
    In addition to these methods, you can use many of Python’s built-in functions,
    such as `min()`, `max()`, and `len()`, with sets.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-4](ch09.xhtml#ch09tab4)列出了一些常用的集合操作方法。你应该用自己的变量名替换文中显示的*斜体*变量名。除了这些方法，你还可以使用Python的许多内置函数，例如`min()`、`max()`和`len()`，与集合一起使用。'
- en: '**Table 9-4:** Useful Built-in Set Methods'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-4:** 有用的内置集合方法'
- en: '| **Methods** | **Operator syntax** | **Description** |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **操作符语法** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| set1.`add(`item`)` |  | Add item to set |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| set1.`add(`item`)` |  | 向集合中添加项 |'
- en: '| set1.`clear()` |  | Reset to empty |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| set1.`clear()` |  | 重置为空集合 |'
- en: '| set1.`copy()` |  | Returns a shallow copy of a set |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| set1.`copy()` |  | 返回集合的浅拷贝 |'
- en: '| set1.`difference(`set2`)` | set1 - set2 | Return unshared items |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| set1.`difference(`set2`)` | set1 - set2 | 返回不共享的项 |'
- en: '| set1.`difference_update(`set2`)` | set1 -= set2 | Set set1 to items not in
    set2 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| set1.`difference_update(`set2`)` | set1 -= set2 | 将set1设置为不在set2中的项 |'
- en: '| set1`.discard(`item`)` |  | Removes selected item from a set |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| set1`.discard(`item`)` |  | 从集合中移除指定项 |'
- en: '| set1`.intersection(`set2`)` | set1 & set2 | Return all items in both sets
    |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| set1`.intersection(`set2`)` | set1 & set2 | 返回两个集合中的所有项 |'
- en: '| set1`.intersection_update(`set2`)` | set1 &= set2 | Set set1 to intersecting
    items |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| set1`.intersection_update(`set2`)` | set1 &= set2 | 将set1设置为交集项 |'
- en: '| set1`.isdisjoint(`set2`)` |  | Return True if no shared items |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| set1`.isdisjoint(`set2`)` |  | 如果没有共享项，返回True |'
- en: '| set1`.issubset(`set2`)` | set1 <= set2 | Return True if set2 contains set1
    |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| set1`.issubset(`set2`)` | set1 <= set2 | 如果set2包含set1，返回True |'
- en: '| set1`.issuperset(`set2`)` | set1 >= set2 | Return True if set1 contains set2
    |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| set1`.issuperset(`set2`)` | set1 >= set2 | 如果set1包含set2，返回True |'
- en: '| set_name`.pop()` |  | Remove arbitrary element from a set |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| set_name`.pop()` |  | 从集合中移除任意元素 |'
- en: '| set_name`.remove(`item`)` |  | Remove an item from a set |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| set_name`.remove(`item`)` |  | 从集合中移除一个元素 |'
- en: '| set1`.symmetric_difference(`set2`)` | set1 `^` set2 | Return unshared set1
    and set2 items |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| set1`.symmetric_difference(`set2`)` | set1 `^` set2 | 返回不共享的set1和set2项 |'
- en: '| set1`.symmetric_difference_update(`set2`)` | set1 `^`= set2 | Set set1 to
    unshared items |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| set1`.symmetric_difference_update(`set2`)` | set1 `^`= set2 | 将set1设置为不共享的项
    |'
- en: '| set1`.union(`set2`)` | set1 `&#124;` set2 | Return all unique items in both
    |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| set1`.union(`set2`)` | set1 `&#124;` set2 | 返回两个集合中的所有唯一项 |'
- en: '| set1`.update(`set2`)` | set1 &#124;= set2 | Set set1 to unique set1 and set2
    items |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| set1`.update(`set2`)` | set1 &#124;= set2 | 将set1设置为set1和set2的唯一项 |'
- en: The operator syntax column represents shorthand syntax that you can use with
    certain methods. These are obviously less readable than the full method names.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符语法列表示了你可以使用的某些方法的简写语法。显然，这些语法比完整的方法名更难阅读。
- en: 'Sets are good choices for datasets that can’t contain duplicates and that you
    need to compare to other datasets. Let’s assume that you’re studying the fauna
    in two farm ponds. We’ll make the dataset short for convenience, but imagine it’s
    a much more extensive list (and uses proper taxonomical naming):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 集合非常适合用于存储无法包含重复项且需要与其他数据集进行比较的数据集。假设你正在研究两个农场池塘的动物群。为了方便起见，我们会简化数据集，但可以想象它是一个更为广泛的列表（并使用适当的分类学命名）：
- en: '[PRE69]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, add a gar to `pond1`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向`pond1`添加一个gar：
- en: '[PRE70]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If you try to add another gar to `pond1`, everything will appear to work, but
    you’ll still have only one `gar` entry in the set because duplicates aren’t permitted.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试向`pond1`添加另一个gar，所有操作看起来似乎正常，但集合中依然只会有一个`gar`项，因为不允许重复项。
- en: '**Finding the Differences Between Two Sets**'
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查找两个集合之间的差异**'
- en: Let’s assume that you’ve finished and have too many animals in each set to visually
    compare. That’s okay; you can use the `difference()` method to look at animals
    that are unique to each pond. [Figure 9-2](ch09.xhtml#ch09fig2) uses a Venn diagram
    to demonstrate what this method returns.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经完成并且每个集合中的动物太多以至于无法直观比较。没问题，你可以使用`difference()`方法查看每个池塘独有的动物。[图9-2](ch09.xhtml#ch09fig2)使用Venn图演示了这种方法的返回内容。
- en: '![Image](../images/09fig02.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig02.jpg)'
- en: '*Figure 9-2: The difference() set method*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：difference()集合方法*'
- en: 'Applying this to our pond sets yields the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个方法应用于我们的池塘集合产生以下结果：
- en: '[PRE71]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Because there’s no such thing as a pond without a turtle, these results suggest
    that you need to make another field trip to `pond2`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有不带有乌龟的池塘，这些结果表明你需要再去`pond2`做一次野外考察。
- en: '**Finding the Duplicate Items in Two Sets**'
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查找两个集合中的重复项**'
- en: To see which animals are common to both ponds, use the `intersection()` method,
    described in [Figure 9-3](ch09.xhtml#ch09fig3).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看哪些动物同时存在于两个池塘，使用`intersection()`方法，详见[图9-3](ch09.xhtml#ch09fig3)。
- en: '![Image](../images/09fig03.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig03.jpg)'
- en: '*Figure 9-3: The intersection() set method*'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：intersection()集合方法*'
- en: 'Using this method on our pond data yields the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的池塘数据上使用这种方法得到以下结果：
- en: '[PRE72]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You need to do this only for `pond1` because you’ll get the same result for
    `pond2.intersection(pond1)`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需对`pond1`这样做，因为你会得到相同的结果，即`pond2.intersection(pond1)`。
- en: '**Combining Sets**'
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**合并集合**'
- en: 'Now, suppose that you sample a large lake and find more animal species than
    in the small ponds:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你对一个大湖进行了采样，并发现更多种类的动物比小池塘中的种类还多：
- en: '[PRE73]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You’re curious if the lake environment behaves like a big pond that includes
    the same animals plus a few more. To determine this, you first must combine the
    pond animals into a single set using the `union()` method, as demonstrated in
    [Figure 9-4](ch09.xhtml#ch09fig4).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道湖泊环境是否像一个大池塘，包括相同的动物以及一些额外的动物。为了确定这一点，首先必须使用`union()`方法将池塘动物合并为一个集合，如[图9-4](ch09.xhtml#ch09fig4)所示。
- en: '![Image](../images/09fig04.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig04.jpg)'
- en: '*Figure 9-4: The union() set method*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-4：union()集合方法*'
- en: '[PRE74]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '**NOTE**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can combine multiple sets at once using this syntax: set1.union(set2,
    set3, set4...`)`.*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*可以使用以下语法一次性合并多个集合：set1.union(set2, set3, set4...`)`。*'
- en: '**Determining Whether One Set Is a Superset of Another**'
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**确定一个集合是否是另一个集合的超集**'
- en: If the `lake1` set contains all the animals in the `pond_animals` set, it’s
    considered to be a *superset*. [Figure 9-5](ch09.xhtml#ch09fig5) shows how supersets
    and subsets work.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`lake1`集合包含了`pond_animals`集合中的所有动物，则被视为*超集*。[图9-5](ch09.xhtml#ch09fig5)展示了超集和子集的工作原理。
- en: '![Image](../images/09fig05.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig05.jpg)'
- en: '*Figure 9-5: The issuperset() and issubset() set methods*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-5：issuperset()和issubset()集合方法*'
- en: 'If you run `issuperset()` on the lake set, it will return `True`, indicating
    that all of the pond animals are present in the lake:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在lake集合上运行`issuperset()`，它将返回`True`，表示所有池塘动物都存在于湖中：
- en: '[PRE75]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***Creating Frozensets***'
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建Frozensets***'
- en: The built-in `frozenset()` function takes an iterable object as input and makes
    it immutable. The resulting “frozenset” is a set with elements that can’t be added,
    removed, or altered.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`frozenset()`函数接受一个可迭代对象作为输入，并使其不可变。生成的“frozenset”是一个集合，其中的元素无法添加、移除或更改。
- en: Frozensets are mainly used as dictionary keys (which must be immutable) or as
    elements in other sets, because sets can’t be inserted into sets. Frozensets are
    “safer” than sets, as there’s no risk of accidentally changing elements in frozensets
    later in your code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Frozensets主要用作字典键（必须是不可变的）或其他集合中的元素，因为集合不能被插入到集合中。Frozensets比集合更加“安全”，因为后续代码中不会意外更改frozensets中的元素。
- en: 'To make a frozenset, pass the function an iterable, such as another set:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个frozenset，传递一个可迭代对象，比如另一个集合：
- en: '[PRE76]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: You can use the same functions and methods on frozensets that you use on sets,
    as long as they don’t change the frozenset. Mathematical set operations such as
    intersection, difference, and union will all work on frozensets.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在frozensets上使用与集合相同的函数和方法，只要它们不会改变frozenset。数学集合操作如交集、差集和并集都适用于frozensets。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 11.  Why shouldn’t you use `count()` with a set?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 11.  为什么不应该使用`count()`来计算一个集合？
- en: 12.  To get all the elements in set1 and set2 but not in both, which of the
    following would you use?
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 12.  要获取集合1和集合2中所有元素但不在两者中都存在的元素，你会使用以下哪种方法？
- en: a.  `set1.difference(set2)`
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `set1.difference(set2)`
- en: b.  `set1.intersection(set2)`
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `set1.intersection(set2)`
- en: c.  `set1.symmetric_difference(set2)`
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `set1.symmetric_difference(set2)`
- en: d.  `set1.issubset(set2)`
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `set1.issubset(set2)`
- en: '13.  True or false: The best way to create an empty set is to use the `set()`
    function.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 13.  正确还是错误：创建空集的最佳方法是使用`set()`函数。
- en: 14.  Which method will not work on a frozenset?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 14.  哪种方法不适用于不可变集合？
- en: a.  `frozenset1.union(frozenset2)`
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `frozenset1.union(frozenset2)`
- en: b.  `len(frozenset1)`
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `len(frozenset1)`
- en: c.  `frozenset1.pop()`
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `frozenset1.pop()`
- en: d.  `frozenset1.copy()`
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `frozenset1.copy()`
- en: '**Dictionaries**'
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字典**'
- en: Short for dictionary, the *dict* data type is an ordered, iterable, mutable
    collection of values indexed by *keys* rather than numbers. The keys can be almost
    any data type and are mapped to one or more values. Dictionaries are considered
    the most important Python structure for storing and accessing data.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 简称字典，*dict*数据类型是一个有序的、可迭代的、可变的值集合，由*键*而不是数字索引。键可以是几乎任何数据类型，并映射到一个或多个值。字典被认为是存储和访问数据的Python结构中最重要的。
- en: 'A dictionary looks different than tuples, lists, and sets, as it has key-value
    pairs. But like a set, it’s surrounded by curly brackets:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 字典看起来与元组、列表和集合不同，因为它有键-值对。但与集合类似，它用花括号括起来：
- en: '[PRE77]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Keys have the same properties as elements in a set: they must be unique and
    immutable because they get hashed. In fact, sets are just collections of dictionary
    keys with no corresponding values. And like sets, dictionaries take up more memory
    due to the use of a hashing process.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 键具有与集合中元素相同的属性：它们必须是唯一的和不可变的，因为它们被哈希了。事实上，集合只是没有相应值的字典键的集合。像集合一样，字典由于使用了哈希过程而占用更多内存。
- en: The dictionary key is like a word in a language dictionary and the values represent
    the definition(s) for that word. Keys can be multiple objects (like a word pair),
    as long as the multiple objects are immutable (tuples can be used but not lists).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 字典键类似于语言字典中的单词，而值表示该单词的定义。键可以是多个对象（如单词对），只要这些多个对象是不可变的（可以使用元组但不能使用列表）。
- en: Values, on the other hand, can be mutable objects. And just as a word in a language
    dictionary can have more than one definition, it’s fine to have multiple values
    that map to a single key.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，值可以是可变对象。就像语言字典中的单词可以有多个定义一样，可以有多个值映射到单个键上是可以的。
- en: Because dictionaries associate, or map, one thing with another, they tend to
    be used when items in a collection are labeled. You can use them as simple databases
    whose data has a key-value relationship, such as student names and student IDs.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字典关联或映射一件事物到另一件事物，当集合中的项目被标记时，它们倾向于被用作简单的数据库。你可以把它们用作具有键-值关系的简单数据库，比如学生的姓名和学生的ID。
- en: '***Creating Dictionaries***'
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建字典***'
- en: 'A dictionary consists of comma-separated key-value pairs enclosed in curly
    brackets (`{}`). The key-value pairs are separated by colons, as shown here:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 字典由用花括号（{}）括起来的逗号分隔的键-值对组成。键-值对之间用冒号分隔，如下所示：
- en: '[PRE78]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The use of the colon distinguishes dictionaries from sets, which also use curly
    brackets.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号的使用区分了字典和使用花括号的集合。
- en: 'Now let’s make a dictionary that maps some letters to their equivalent Morse
    code symbols:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个将一些字母映射到它们对应的莫尔斯电码符号的字典：
- en: '[PRE79]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As you can see, dictionaries preserve the *insertion* order of the key-value
    pairs. This mainly affects readability when viewing the dictionary, and you should
    take this into account when entering the data.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，字典保留了键-值对的*插入*顺序。这主要影响查看字典时的可读性，输入数据时应考虑这一点。
- en: 'Now, using this `morse` dictionary, you can loop through a word and translate
    it to Morse code:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这个`morse`字典，你可以遍历一个单词并将其转换为莫尔斯电码：
- en: '[PRE80]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Note that dictionary keys are case sensitive, so the following code will raise
    an `KeyError`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字典键区分大小写，因此以下代码将引发`KeyError`错误：
- en: '[PRE81]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you’re doing something like looping through the letters in the dictionary,
    you can avoid this error by converting the letters to lowercase as part of the
    key index, as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在做像在字典中循环字母这样的事情，你可以通过将字母转换为小写作为键索引的一部分来避免这个错误，如下所示：
- en: '[PRE82]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can also use the built-in `dict()` function to create a dictionary. An
    advantage here is that you can use keyword arguments for the keys and avoid typing
    as many single quotation marks:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用内置的`dict()`函数来创建字典。这里的优势在于，你可以为键使用关键字参数，并避免键入太多单引号：
- en: '[PRE83]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**NOTE**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because “dict” is the name of a function, you should never use it as a variable
    name.*'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为“dict”是一个函数名，你永远不应该将它用作变量名。*'
- en: '***Combining Two Sequences into a Dictionary***'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将两个序列合并成一个字典***'
- en: 'You can pair up two sequences such as a tuple or list into a dictionary. Of
    course, the sequences should contain the same number of items and they should
    be ordered appropriately, so that index 5 in one list pairs with whatever’s at
    index 5 in the second list. Here’s an example translating English words to Spanish
    words. The `zip()` built-in function pairs up the two lists item by item by mapping
    similar indexes:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将两个序列（如元组或列表）配对成一个字典。当然，序列中的元素数量应该相同，并且它们应该按适当的顺序排列，这样第一个列表中的索引 5 就会和第二个列表中索引
    5 对应。以下是一个将英语单词翻译为西班牙语单词的示例。内置的`zip()`函数逐项配对这两个列表，映射相同的索引：
- en: '[PRE84]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Because the Spanish word for cold is both masculine and feminine, the two forms
    are stored in a nested list (you could also use a tuple for memory efficiency).
    You can access items in the list using standard list indexing:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 由于西班牙语中“冷”这个词既可以是男性形式也可以是女性形式，因此这两种形式存储在一个嵌套列表中（你也可以使用元组来提高内存效率）。你可以使用标准的列表索引来访问列表中的项：
- en: '[PRE85]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Of course, you’ll want either the masculine form or the feminine form to consistently
    come first in the nested lists, so you always use the same index to fetch it.
    Alternatively, you can nest a dictionary that specifies masculine (`m`) versus
    feminine (`f`):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能希望在嵌套列表中始终将男性形式或女性形式排在前面，这样你总是可以使用相同的索引来访问它。或者，你可以嵌套一个字典来指定男性（`m`）和女性（`f`）：
- en: '[PRE86]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'By using a dictionary, you don’t need to map translations to arbitrary indexes,
    and your code is much more readable and less prone to error. And if you want to
    get really pithy, you can build the translation dictionary using: `translation
    = dict(zip(english, spanish))`.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用字典，你不需要将翻译映射到任意的索引，而且你的代码更具可读性且不容易出错。如果你想让代码更简洁，可以使用以下方式构建翻译字典：`translation
    = dict(zip(english, spanish))`。
- en: '***Creating Empty Dictionaries and Values***'
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建空字典和值***'
- en: 'To make an empty dictionary, use curly brackets:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空字典，使用大括号：
- en: '[PRE87]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Values can also be empty. This is handy for setting-up placeholder keys to
    which you will assign values at a later time, like when you load a new list or
    a user provides some input. Here’s an example:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 值也可以为空。这对于设置占位符键很有用，稍后你可以为其分配值，比如当你加载一个新的列表或用户提供某些输入时。以下是一个示例：
- en: '[PRE88]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '***Working with Dictionaries***'
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***操作字典***'
- en: '[Table 9-5](ch09.xhtml#ch09tab5) summarizes some dictionary methods. You’ll
    need to substitute your own names for those in italics. In addition, you can use
    many built-in functions such as `len()`, `min()`, and `max()` with dictionaries.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-5](ch09.xhtml#ch09tab5)总结了一些字典方法。你需要将斜体中的名称替换为你自己的名称。此外，你还可以使用许多内置函数，如`len()`、`min()`和`max()`与字典一起使用。'
- en: '**Table 9-5:** Built-in Dictionary Methods'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-5：** 内置字典方法'
- en: '| **Method** | **Description** | **Example** |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `clear()` | Remove all dictionary elements | dict_name`.clear()` |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 移除字典中的所有元素 | dict_name`.clear()` |'
- en: '| `copy()` | Return a copy of a dictionary | dict_name`.copy()` |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `copy()` | 返回字典的副本 | dict_name`.copy()` |'
- en: '| `fromkeys()` | Return a dictionary with the specified keys and a value |
    dict_name `= dict.fromkeys(`key_tuple, value`)` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `fromkeys()` | 返回一个具有指定键和值的字典 | dict_name `= dict.fromkeys(`key_tuple, value`)`
    |'
- en: '| `get()` | Return the value of a specified key | dict_name`.get(`key`)` |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `get()` | 返回指定键的值 | dict_name`.get(`key`)` |'
- en: '| `items()` | Return a tuple of all key-value pairs | dict_name`.items()` |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `items()` | 返回所有键值对的元组 | dict_name`.items()` |'
- en: '| `keys()` | Return a list of a dictionary’s keys | dict_name`.keys()` |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `keys()` | 返回字典键的列表 | dict_name`.keys()` |'
- en: '| `pop()` | Remove the element with specified key | dict_name`.pop(`key`)`
    |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 移除指定键的元素 | dict_name`.pop(`key`)` |'
- en: '| `popitem()` | Remove the last inserted key-value pair | dict_name.`popitem()`
    |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `popitem()` | 移除最后插入的键值对 | dict_name.`popitem()` |'
- en: '| `setdefault()` | Insert specified key and value if no key, else return value
    if key exists | dict_name.`setdefault(`key, value`)` |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `setdefault()` | 如果键不存在，则插入指定的键和值；如果键存在，则返回其值 | dict_name.`setdefault(`key,
    value`)` |'
- en: '| `update()` | Update dictionary with specified key-value | dict_name.`update({`key:
    value`})` |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `update()` | 使用指定的键值对更新字典 | dict_name.`update({`key: value`})` |'
- en: '| `values()` | Return a list of the values in a dictionary | dict_name.`values()`
    |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `values()` | 返回字典中的值列表 | dict_name.`values()` |'
- en: '**NOTE**'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although you can change the value that’s mapped to a key, there are no dictionary
    methods that let you add a value to an existing key. To do this, you’ll need to
    import and use the collections third-party module. We’ll look at collections and
    other helpful modules in [Chapter 11](ch11.xhtml).*'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然您可以更改映射到键的值，但没有字典方法可以让您向现有键添加值。要做到这一点，您需要导入并使用 `collections` 第三方模块。我们将在[第11章](ch11.xhtml)中查看
    `collections` 和其他有用的模块。*'
- en: '**Getting the Contents of Dictionaries**'
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**获取字典内容**'
- en: 'The `keys()`, `values()`, and `items()` methods return the contents of dictionaries
    in list-like data types called `dict_keys`, `dict_values`, and `dict_items()`,
    respectively. You can iterate (loop) over these structures, but otherwise they
    don’t behave like true lists. Here’s how they work:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys()`、`values()` 和 `items()` 方法以列表形式的数据类型 `dict_keys`、`dict_values` 和 `dict_items()`
    返回字典的内容。您可以对这些结构进行迭代（循环），但它们不像真正的列表那样工作。以下是它们的工作方式：'
- en: '[PRE89]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If you want to use this output as a list, you can convert it using the `list()`
    function:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将此输出用作列表，可以使用 `list()` 函数进行转换：
- en: '[PRE90]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This returns a list of key-value pair tuples when used with `items()`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 `items()` 一起使用时，这将返回一个键值对元组列表：
- en: '[PRE91]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '**Getting the Value of a Dictionary Key**'
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**获取字典键的值**'
- en: 'As you’ve seen, if you just want the value of a key in a dictionary, you can
    use the key as you would an index with a list, as shown here:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，如果只需字典中键的值，可以像在列表中使用索引一样使用键，如下所示：
- en: '[PRE92]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This works great until you ask for a key that doesn’t exist, in which case
    Python will raise a `KeyError`. To avoid this, use the `get()` method, which lets
    you provide a default value for non-existent keys:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好用，直到您要求一个不存在的键时，Python 将引发 `KeyError`。为了避免这种情况，请使用 `get()` 方法，它允许您为不存在的键提供默认值：
- en: '[PRE93]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The second argument (`'unknown'`) passed to the `get()` method is the default
    return value. Now, when you ask for a missing key like potassium hydroxide, the
    method returns `'unknown'`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `get()` 方法的第二个参数（`'unknown'`）是默认返回值。现在，当您请求一个不存在的键（如氢氧化钾）时，该方法将返回 `'unknown'`。
- en: 'You can also check whether a key is present using the `in` keyword:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `in` 关键字来检查键是否存在：
- en: '[PRE94]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '**Adding Key-Value Pairs to a Dictionary**'
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**向字典添加键值对**'
- en: 'To add a key-value pair to a dictionary, you can use the indexing approach
    (see line `In [196]:`) or use the `update()` method:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典添加键值对，您可以使用索引方法（见第 `In [196]:` 行）或使用 `update()` 方法：
- en: '[PRE95]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'To add multiple key-value pairs, separate them with commas:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加多个键值对，请使用逗号分隔它们：
- en: '[PRE96]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '**Combining Dictionaries**'
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**合并字典**'
- en: 'You can also add a dictionary to another dictionary with `update()`, but a
    more succinct method is to use the `**` operator. Let’s chain three dictionaries
    together to make a fourth:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `update()` 将一个字典添加到另一个字典中，但更简洁的方法是使用 `**` 运算符。让我们将三个字典链接在一起，形成第四个字典：
- en: '[PRE97]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '**Removing Key-Value Pairs from a Dictionary**'
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从字典中删除键值对**'
- en: 'To remove a key-value pair, pass the key to the `pop()` method:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除一个键值对，请将键传递给 `pop()` 方法：
- en: '[PRE98]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Notice that this method returns the value, so you can assign it to a variable
    while popping if you want:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法会返回该值，因此在弹出时，如果需要，可以将其分配给变量：
- en: '[PRE99]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: You can also use the `del` keyword to remove elements; for example, `del chems[``'``KHO``'``]`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `del` 关键字来删除元素；例如，`del chems['KHO']`。
- en: '**Creating Default Values for Keys**'
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**为键创建默认值**'
- en: 'The `setdefault()` method lets you check whether a key exists and set a value
    for the key if it doesn’t. Otherwise, it returns the value of the key. Here’s
    an example:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`setdefault()` 方法允许您检查键是否存在，如果不存在，则为键设置一个值。否则，它将返回键的值。以下是一个示例：'
- en: '[PRE100]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Because the key `''``Mars``''` didn’t exist, the method added it along with
    its order in the solar system, `4`. But if you try to change an existing key,
    like `''``Earth``''`, the method will just return its value and make no changes:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 因为键 `'Mars'` 不存在，该方法添加了它及其在太阳系中的顺序 `4`。但是，如果您尝试更改现有键，如 `'Earth'`，该方法将只返回其值并不做任何更改：
- en: '[PRE101]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Suppose that you want to count the number of times the companies Pfizer, Moderna,
    and Johnson & Johnson were mentioned in articles related to the coronavirus in
    2021\. You plan to store the counts in a dictionary. The `fromkeys()` method will
    help you to set up this dictionary by populating it with keys with the same initial
    value. The default value is `None`, but in this case, use `0`. You’ll need to
    pass the keys in the form of a tuple, followed by a value:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要统计2021年与冠状病毒相关的文章中提到的Pfizer、Moderna和Johnson & Johnson的次数。你打算将这些计数存储在一个字典中。`fromkeys()`方法将帮助你创建这个字典，通过填充相同初始值的键。默认值是`None`，但在这种情况下，使用`0`。你需要以元组的形式传递键，然后再传入一个值：
- en: '[PRE102]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '**Performing a Reverse Lookup**'
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**执行反向查找**'
- en: 'Dictionaries are optimized to efficiently find the value or values for a given
    key. But sometimes you might want to find all the keys that correspond to a given
    value (such as looking up the name associated with a phone number). There’s no
    built-in functionality for doing a “reverse lookup,” so you need to define a function
    to perform the task. Let’s take a look:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 字典经过优化，能够高效地查找给定键的值。然而，有时你可能希望查找与某个值对应的所有键（比如查找与某个电话号码关联的姓名）。Python没有内置功能进行“反向查找”，所以你需要定义一个函数来执行这个任务。让我们来看一下：
- en: '[PRE103]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We haven’t covered functions yet, so let me explain. We used the `def` keyword
    to define a function named `lookup_keys` that has two parameters: `d` (for dictionary)
    and `v` (for value). Python automatically indents four spaces when you press ENTER,
    which designates that you’re working within the function. Because the same value
    can be associated with multiple keys, we created an empty list named `keys` to
    hold the values. Next, we looped through the keys in the dictionary, and if the
    key’s value matched the specified value (`v`), we appended it to the list. After
    the loop finished, we returned the list using the `return` keyword, which ended
    the function and made the list accessible to the rest of the program.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讲解函数，所以让我来解释一下。我们使用`def`关键字定义了一个名为`lookup_keys`的函数，它有两个参数：`d`（字典）和`v`（值）。按下ENTER时，Python会自动缩进四个空格，这表示你正在函数内部工作。由于同一个值可能与多个键关联，我们创建了一个名为`keys`的空列表来保存这些值。接下来，我们遍历字典中的键，如果键的值与指定的值（`v`）匹配，我们就把它加入到列表中。循环结束后，我们使用`return`关键字返回该列表，结束函数的执行，并使得该列表对程序的其他部分可用。
- en: 'Let’s test the function using the `solar_system` dictionary from the previous
    section. Pass it the name of the dictionary and `3`, for the third planet, in
    parentheses:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用上一节中的`solar_system`字典来测试这个函数。将字典的名称和`3`（第三颗行星）作为参数传入：
- en: '[PRE104]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: As you might expect, reverse lookups run slower than forward lookups.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所料，反向查找的速度比正向查找慢。
- en: '**Printing Dictionaries**'
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**打印字典**'
- en: If you print a dictionary using the `print()` function, you’ll get all the braces,
    quotation marks, and commas used to build the dictionary. To get around this,
    you can use “pretty printing” techniques.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`print()`函数打印字典，你将看到构建字典时使用的所有大括号、引号和逗号。为了避免这种情况，你可以使用“漂亮打印”技术。
- en: If you do an online search for “pretty print a Python dictionary,” you’ll find
    numerous methods such as `pprint()`, that yield more readable output than the
    built-in `print()` function. Let’s look at one of them here, the `json.dumps()`
    method.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网上搜索“漂亮打印Python字典”，你会发现很多方法，比如`pprint()`，它们能生成比内建的`print()`函数更易读的输出。我们这里来看其中的一种方法——`json.dumps()`。
- en: 'The `json.dumps()` method converts a Python object into a `JSON` string. This,
    in turn, formats the dictionary into attractive `JSON` format. The method accepts
    three parameters used for pretty printing: the dictionary name, a Boolean value
    (`True` or `False`) for whether to sort the keys, and the number of spaces for
    indentation.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.dumps()`方法将Python对象转换为`JSON`字符串。这样，它就将字典格式化为吸引人的`JSON`格式。该方法接受三个用于漂亮打印的参数：字典名称，一个布尔值（`True`或`False`）表示是否排序键，以及缩进的空格数。'
- en: 'In the following example, we import `json`, create a dictionary (`d`), and
    then print it using the `print()` function followed by `json.dumps()`, for comparison:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们导入了`json`，创建了一个字典（`d`），然后使用`print()`函数打印它，接着用`json.dumps()`进行比较：
- en: '[PRE105]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The `JSON` output is easier to digest than the horizontal layout returned by
    `print()`. It works only with data types that `JSON` supports, however, which
    means that embedded sets and functions will fail.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON`输出比`print()`返回的水平布局更易于理解。然而，它只适用于`JSON`支持的数据类型，这意味着嵌套的集合和函数将无法处理。'
- en: 'Although we’re getting ahead of ourselves, it’s worth noting that you can traverse,
    sort, and print a dictionary using a `for` loop, the built-in `sorted()` function,
    and `print()`. You can even “pretty it up” with f-strings, as in this example:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有些提前了，但值得注意的是，你可以使用`for`循环、内置的`sorted()`函数和`print()`来遍历、排序和打印字典。你甚至可以使用
    f-strings 来“美化”输出，像这样：
- en: '[PRE106]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You can indent the output similar to the `json.dumps()` method by adding spaces
    or tabs (`\t`) after the first single quote in the `print` command. Give it a
    try.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`print`命令中的第一个单引号后添加空格或制表符（`\t`），使输出格式类似于`json.dumps()`方法。试试看。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 15.  What would you use to initialize a dictionary in which all the values are
    empty?
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 15. 如果你想初始化一个所有值为空的字典，应该使用什么方法？
- en: a.  The `setdefault()` method
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: a. `setdefault()`方法
- en: b.  The `fromkeys()` method
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: b. `fromkeys()`方法
- en: c.  The `update()` method
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: c. `update()`方法
- en: d.  The built-in `zip()` function
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: d. 内置的`zip()`函数
- en: 16.  Which statement about dictionaries is false?
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 16. 关于字典，哪一项陈述是错误的？
- en: a.  Membership searches are very fast.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: a. 成员查找非常快速。
- en: b.  Dictionaries are optimized to find the key or keys for a given value.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: b. 字典被优化以查找给定值的键或键值。
- en: c.  You can pretty print dictionaries with the `pprint()` module.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: c. 你可以使用`pprint()`模块来美化字典的打印输出。
- en: d.  Dictionaries are more memory intensive than lists.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: d. 字典比列表更占用内存。
- en: '17.  Create a joke dictionary that maps setup lines to punchlines. Here’s a
    few to get you started: “Did you hear about the kidnapping? He slept for three
    hours.” “I started a band called ‘999 Megabytes.’” “You’ll never get a gig.” “I
    heard you had to shoot your dog. Was he mad?” “He wasn’t too happy about it!”'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 17. 创建一个笑话字典，将开场白与笑点相对应。以下是几个示例：“你听说过绑架案吗？他睡了三小时。” “我组建了一个名为‘999兆字节’的乐队。” “你永远也不会得到一个工作机会。”
    “我听说你不得不射杀你的狗。它生气了吗？” “它对此并不太开心！”
- en: 18.  What data type is held in the square brackets in `contacts[′Nix′, ′Goaty′]
    = ′goatynix@gmail.com′`?
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 18. 在`contacts[′Nix′, ′Goaty′] = ′goatynix@gmail.com′`中，方括号内保存的是什么数据类型？
- en: a.  String
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: a. 字符串
- en: b.  List
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: b. 列表
- en: c.  Tuple
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: c. 元组
- en: d.  Set
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: d. 集合
- en: '**Summary**'
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter you learned about the four data types for working with collections
    in Python. A tuple is an immutable sequence type that holds a collection of objects,
    indexed by integers, in a defined order. A list is a mutable sequence type that
    holds a collection of objects, indexed by integers, in a defined order. A set
    is a mutable set type that holds an unordered collection of unique objects. A
    dictionary is a mutable mapping type that holds an ordered collection of unique
    objects (keys) that map to associated objects (values).
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了四种用于处理集合数据的 Python 数据类型。元组是一个不可变的序列类型，按整数索引顺序存储对象的集合。列表是一个可变的序列类型，按整数索引顺序存储对象的集合。集合是一个可变的集合类型，存储无序的唯一对象集合。字典是一个可变的映射类型，存储有序的唯一对象（键）集合，并将这些键映射到相关的对象（值）。
- en: Each of these built-in data structures has its uses as well as its own peculiar
    behaviors. Tuples are memory efficient and good places to keep objects “safe”
    because they’re unchangeable after they’re created. Lists, being mutable, are
    flexible and useful for many jobs, though membership searches are slow. Sets can
    be used to efficiently remove duplicates from a dataset, provide very fast membership
    searches, and let you perform mathematical set operations, like union and intersection.
    Dictionaries also provide fast membership searches and let you easily set up associative
    databases for labeled data. If you are not sure how a data type is going to behave,
    take the time to test it in the interactive console before you incorporate it
    in your code.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内置数据结构各自有其用途和独特的行为。元组在内存上非常高效，是存放“安全”对象的好地方，因为它们在创建后无法更改。列表则是可变的，灵活多用，适用于许多任务，尽管成员查找较慢。集合可以高效地从数据集中删除重复项，提供非常快速的成员查找，并且允许执行数学集合操作，如并集和交集。字典也提供快速的成员查找，并且让你轻松设置关联数据库以存储标签数据。如果你不确定某种数据类型的行为，建议在将其纳入代码前，先在交互式控制台中测试一下。
- en: There’s a lot more left to learn. *Comprehensions*, which we’ll cover in the
    next chapter, provide shorthand methods for creating lists, sets, and dictionaries.
    Importable modules, such as *collections* and *itertools*, provide useful tools
    for working with container data types. We’ll look at these in [Chapter 11](ch11.xhtml).
    Then, in [Chapter 12](ch12.xhtml), we’ll look at how to load external datasets
    into lists, sets, and so on, rather than typing them in item by item. For now,
    it’s time to learn about *flow control*.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多东西需要学习。*理解式*，我们将在下一章讨论，提供了用于创建列表、集合和字典的简便方法。可以导入的模块，如*collections*和*itertools*，提供了处理容器数据类型的有用工具。我们将在[第11章](ch11.xhtml)中查看这些内容。然后，在[第12章](ch12.xhtml)中，我们将学习如何将外部数据集加载到列表、集合等中，而不是一项一项地手动输入。目前，是时候学习*流程控制*了。
