- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE CONTAINER DATA TYPES**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: According to *Merriam-Webster*, *data* is plural in form. If you’re working
    with data, you’re working with *collections* of things such as the names of students
    in a class or the luminosity of stars in the galaxy. You’re going to need somewhere
    to hold all of these collections. That’s where the container data types like tuples,
    lists, sets, and dictionaries come in handy. Each one serves a special purpose
    and comes with special abilities. Together, they’ll help you to keep your rats,
    genes, soil samples, and temperature measurements organized and under control.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore the built-in data structures listed in [Table
    9-1](ch09.xhtml#ch09tab1), along with some of their main characteristics. Remember,
    *mutability* refers to whether something can be changed (mutated) after it’s created.
    Immutable objects must be copied to a new object for their values to be altered,
    appended, or removed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** Container Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Data type** | **Mutability** | **Features** | **Examples**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence type | Tuple | Immutable | Fast, efficient, and unchangeable | `(2,
    5,` `''``Pluto``''``, 4.56)` |'
  prefs: []
  type: TYPE_TB
- en: '| Sequence type | List | Mutable | Flexible with many built-in functions |
    `[2, 5,` `''``Pluto``''``, 4.56]` |'
  prefs: []
  type: TYPE_TB
- en: '| Set type | Set | Mutable | No duplicate elements, fast searches | `{2, 5,`
    `''``Pluto``''``, 4.56}` |'
  prefs: []
  type: TYPE_TB
- en: '| Set type | Frozenset | Immutable | No duplicate elements, fast searches |
    `frozenset({2, 5,` `''``Pluto``''``, 4.56})` |'
  prefs: []
  type: TYPE_TB
- en: '| Mapping type | Dictionary | Mutable | Maps unique keys to values | `{``''``key``''``:`
    `''``value``''``}` |'
  prefs: []
  type: TYPE_TB
- en: Let’s begin by looking at the simplest of these, the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tuples**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *tuple* (pronounced *TOO-pul*) is a fixed-length, iterable, immutable, ordered
    sequence of values. These values are typically referred to as *items* or *elements*.
    Here is an example of a tuple where each name represents an item:'
  prefs: []
  type: TYPE_NORMAL
- en: ('`K. L. Putney`', '`M. B. Clark`', '`S. B. Vaughan`')
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*An iterable is a collection of items that you can loop through, such as strings,
    tuples, lists, and sets. A sequence is a positionally ordered collection of items
    that acts as a single storage unit.*'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are a lot like strings, but whereas strings can contain only characters,
    tuples are heterogeneous and can hold any type of value, including mixtures of
    different types. You can even make tuples of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are less commonly used than the *list* data type, and they have fewer
    methods that work on them. But like the old saying goes, “horses for courses.”
    There are times when tuples are preferable to other container types.
  prefs: []
  type: TYPE_NORMAL
- en: For example, because they’re immutable, tuples make good places to store objects
    like passwords. When you use a tuple, other programmers will understand that you
    don’t want those values to change. Tuples are also more memory efficient than
    lists due to their immutability, and tuple operations are smaller in size, making
    them slightly faster when working with many elements.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Tuples***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Tuples consist of a sequence of comma-separated values enclosed by parentheses.
    But Python is smart, and just as it can recognize different data types such as
    floats and integers by context, you can break the rules when creating a tuple
    and leave off the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the time, however, you’ll want to include the parentheses, both for
    clarity and for when you use more complicated code such as a nested tuple (a tuple
    stored in a tuple):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Because tuples can hold a single value, separating values with commas is more
    important than using parentheses. To see why, enter the following in a console
    and check the object’s type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, Python thinks you’ve just typed an integer in parentheses! Now,
    add a trailing comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The takeaway is that single-item tuples require a trailing comma.
  prefs: []
  type: TYPE_NORMAL
- en: '***Converting Other Types to Tuples***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also create tuples by using the built-in `tuple()` function to convert
    other data types. Enter the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This snippet turned the string `Hello, World!` into a tuple. Note that each
    character in the string is now a separate element in the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Because “tuple” is the name of a function, you should never use it as a variable
    name.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `tuple()` to turn a list (indicated by square brackets `[]`)
    into a tuple, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the strings are preserved as words because each string was a separate
    item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Tuples***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tuples can be indexed and sliced just like strings (see [Chapter 7](ch07.xhtml)).
    Because tuples are immutable and can’t be modified, they don’t come with many
    built-in methods. For added utility, however, you can take advantage of general-purpose
    built-in functions from the Python Standard Library when you work with them. Some
    of these functions and methods are listed in [Table 9-2](ch09.xhtml#ch09tab2).
    You should substitute real variable and value names for those shown in italics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2:** Useful Built-in Functions and Tuple Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `tuple()` | Converts a sequence into a tuple | `tuple(`seq_name`)` |'
  prefs: []
  type: TYPE_TB
- en: '| `len()` | Returns the length of a sequence | `len(`tuple_name`)` |'
  prefs: []
  type: TYPE_TB
- en: '| `min()` | Returns the sequence item with the minimum value | `min(`tuple_name`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `max()` | Returns the sequence item with the maximum value | `max(`tuple_name`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Method** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `count()` | Returns the count of a specified value | tuple_name.`count(`value`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `index()` | Returns position of a specified value | tuple_name.`index(`value`)`
    |'
  prefs: []
  type: TYPE_TB
- en: Note that tuple *methods* are called *after* the tuple name using dot notation,
    such as tuple_name`.count(value)`. You saw `tuple()` in action in the previous
    section, so let’s start by looking at `len()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting a Tuple’s Length**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After you make a tuple, it always has a fixed length. You can find this length
    by using the built-in `len()` function. Let’s use the tuples that we created in
    the previous section to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first result, `3`, is intuitive, as there are three items in `tup`. But
    the length of the nested tuple is only `2`, when there are clearly five items
    present.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand what’s happening, let’s use indexing to look at the first item
    in each tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Values enclosed by parentheses are considered a *single item* within the overall
    sequence of items in the tuple. If you need to access a value *within* an item,
    you can add another index. For example, to see the first element within each nested
    item, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is shown diagrammatically in [Figure 9-1](ch09.xhtml#ch09fig1). Because
    the items in the second nested tuple are strings (`'``Alice``'``,` `'``Bob``'`),
    which are in turn made up of elements (the letters), you need to index to three
    levels to access all of the elements in `nested[1]`. The first index gets the
    nested tuple, the second index gets you a string in the nested tuple, and the
    third index gets you a character within the string.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: An example of indexing a nested tuple*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding this behavior is important in the event that you want to iterate
    over a tuple to get its values one by one (we haven’t covered looping yet, so
    bear with me). This is straightforward with a non-nested tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For nested tuples, you need to loop through the elements in *each* nested tuple
    to get to all of the items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The terms “item” and “element” have no special meaning. You could just as easily
    call them “i” and “j” or “Fred” and “George.”
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting a Tuple’s Minimum and Maximum Values**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `min()` and `max()` functions return the minimum and maximum values in
    a tuple, respectively. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s easy, but what if we try it on the nested tuple? Let’s see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Python raises a `TypeError` because it doesn’t know how to distinguish a minimum
    string from a minimum integer. You can find a minimum value in a tuple of strings,
    however. Check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `min()` and `max()` functions use the ASCII sorting order to sort strings.
    In an ASCII table (see *[https://www.asciitable.com/](https://www.asciitable.com/)*),
    special characters, like punctuation marks, come before the alphabet, and uppercase
    letters come before lowercase letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many other built-in functions work with multiple data types. The `len()` function,
    for example, works with strings, tuples, sets, lists, and dictionaries. The membership
    operators you learned about in [Chapter 7](ch07.xhtml) also work with multiple
    types. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Unpacking Tuples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can assign the values in a tuple to multiple variables at once using a
    process called *unpacking*. Let’s pretend that you’ve written a function that
    returns a Cartesian coordinate (x, y) pair as a tuple. You want to use the individual
    x and y values later in the program. Here’s how you can get at those values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To use nested tuples, assign variables using the same parenthesis structure.
    Let’s revisit our `nested` tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t need to take all of the elements. Suppose that you want only the
    first three numbers in the nested tuple. If you try to take them directly, you’ll
    raise an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Python expects you to unpack every item in the tuple. To get around this, you
    can unpack the tuple using the *splat* (or *star*) operator (`*`) with the insignificant
    variable symbol (`_`). Splat allows for an arbitrary number of items, so in this
    case, you’re telling Python to “get the rest” and assign them to `_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You don’t need to use the values in `_`. These will be cleared from memory later
    when Python performs routine garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Operator Overloading with Tuples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can use operator overloading on tuples, just as with strings. For example,
    adding two tuples produces a new tuple containing the values of both tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the multiplication operator with an integer concatenates multiple copies
    of a tuple along with copies of the references to the objects they contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Unexpected Tuple Behaviors**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are loopholes in the rule that tuples are immutable. For instance, if
    a tuple contains a *mutable* data type, you can change that item within a tuple.
    Let’s try this using a mutable list (enclosed in square brackets; we’ll look more
    at lists in the next section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we were able to change the second item in the list (`[2][1]`)
    from `Bob` to `Steve`, even though tuples are immutable. This falls under the
    category of things you *can* do, but *shouldn’t*!
  prefs: []
  type: TYPE_NORMAL
- en: '**Printing Tuples**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Running `print()` on a tuple can be frustrating, as the default display includes
    the commas and quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this, you can use the `join()` string method to print only the strings
    in a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we joined each item in the tuple using a space (`'' ''`).
    You can use other characters to join items, such as the newline escape sequence
    (`\n`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `join()` method works only for sequences composed of strings. To handle
    mixed data types, include the `map()` built-in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the splat operator (`*`) to print a tuple efficiently and
    attractively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Splat takes the tuple as input and expands it into positional arguments in the
    function call. The last argument is the separator used between items for printing.
    The default separator is a space (`sep=`' ').
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '1.  For `tup = (1, 2, 3)`, what happens if you run this code: `tup[3]`?'
  prefs: []
  type: TYPE_NORMAL
- en: 2.  If `test = (``'``a``'``,` `'``!``'``)`, what is the result of running `min(test)`?
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Use indexing to isolate the letter “y” in `tup = (``'``Rust``'``,` `'``R``'``,`
    `'``Go``'``,` `'``Julia``'``), (``'``Python``'``)`.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Which of the following are characteristics of a tuple?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Fixed length
  prefs: []
  type: TYPE_NORMAL
- en: b.  Ordered values
  prefs: []
  type: TYPE_NORMAL
- en: c.  Contents are unchangeable
  prefs: []
  type: TYPE_NORMAL
- en: d.  Holds only integers, floats, and strings
  prefs: []
  type: TYPE_NORMAL
- en: '5.  Make a “field trip” tuple containing these five items: pith helmet, rock
    hammer, hand lens, hiking boots, and sunglasses. Then, write code that removes
    the pith helmet from the tuple (because I’m not wearing that!).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lists**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A list is a variable-length, iterable, mutable, ordered sequence of values.
    They look like tuples except they’re enclosed in brackets rather than parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Because lists are mutable, you can change their values at will. You can add
    items, change items, and delete items. Otherwise, lists are like tuples. They
    can hold multiple data types, including mixtures of types. You can index them,
    slice them, concatenate them, nest them, use built-in functions, and more. Lists
    are true workhorses in Python, and you will use them all the time.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lists are objects that can be treated as values. That is, they can be stored
    in variables and passed to functions. If you hear the term list value, be aware
    that it refers to the whole list, not some value inside it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Lists***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create a list, enclose a value or comma-delimited values in square brackets
    (`[]`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Because lists are mutable, you can begin with an empty list. For example, you
    might set up an empty list to hold user input later in the program. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the built-in `list()` function to convert other data types,
    like tuples and strings, into lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Because “list” is the name of a function, never use it as a variable name.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Lists***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because lists are mutable, you can do a lot more with them than you can with
    tuples, and they come with more built-in functionality. [Table 9-3](ch09.xhtml#ch09tab3)
    summarizes the list methods. You’ll need to substitute your own names for those
    in italics. In addition, you can use the `len()`, `min()`, and `max()` built-in
    functions from [Table 9-2](ch09.xhtml#ch09tab2) with lists.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-3:** Built-in List Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `append()` | Add a single item to the end of a list | list_name`.append(`item`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `extend()` | Add iterable items to the end of a list | list_name`.extend(`iterable`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `insert()` | Insert an item before a given index (`i`) | list_name`.insert(`i,
    item`)` |'
  prefs: []
  type: TYPE_TB
- en: '| `remove()` | Remove first item from list with value = item | list_name`.remove(`item`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | Remove and return item at given index | list_name`.pop(`index`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | Remove all items from a list | list_name`.clear()` |'
  prefs: []
  type: TYPE_TB
- en: '| `index()` | Return index of first item with value = item | list_name`.index(`item`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `count()` | Return number of times an item appears in a list | list_name`.count(`item`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sort()` | Sort list items in place | list_name`.sort()` |'
  prefs: []
  type: TYPE_TB
- en: '| `reverse()` | Reverse list items in place | list_name`.reverse()` |'
  prefs: []
  type: TYPE_TB
- en: '| `copy()` | Return a shallow copy of a list | list_name`.copy()` |'
  prefs: []
  type: TYPE_TB
- en: List methods don’t work like the string methods you learned about in [Chapter
    7](ch07.xhtml). Whereas string methods perform their task and return a new string,
    list methods usually modify the list and return `None`. To sort a list, for example,
    you should use `list_name.sort()`, not `list_name = list_name.sort()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All of the methods for printing tuples also work with lists, so refer to “Printing
    Tuples” on [page 228](ch09.xhtml#ch00lev3sec28).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Items to Lists**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `append` item lets you add an item to the end of a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To add *multiple* items to the end of a list, the items need to be in the form
    of an iterable. Let’s try adding a heron and a hare to the `patroni` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You get a `TypeError` because the `extend()` method is looking for one argument
    (the thing between parentheses), not two. Now, try passing it a tuple of names,
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Success! Both `append()` and `extend()` are useful when either looping through
    values and adding some of them to a list, or when adding values returned from
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inserting Values into Lists**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you need to insert an item at a specific location in a list, not just at
    the end, use the `insert()` method and *pass* it (add between the parentheses)
    the index *before which* you want to place the item, and then the item, separated
    by a comma. For example, to add an item to the start of the `patroni` list, use
    an index of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `insert()` method shifts the index for each item to accommodate the new
    item. This is computationally expensive, however, and should be avoided when possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing Items from Lists**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you want to remove an item from anywhere in a list, use the `pop()` method.
    Let’s remove the `cat` patronus. Because `pop()` returns the item as well as removing
    it, we can also use it in some way, such as by assigning it to a variable, though
    this is optional. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We now have a new variable that holds the string `cat`, whereas the `patroni`
    list no longer contains that item.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t specify an index, `pop()` removes the last item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to remove items is to use the `del` operator, short for “delete.”
    Just pass it the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `del` operator also permits slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also remove an item by naming it in the `remove()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that only the first occurrence of `'``a'` is removed. Also, if the specified
    item doesn’t exist in the list, Python will raise a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing the Value of Items in Lists**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can change the value of items within a list by using indexing. Let’s change
    the `hare` patronus to a `wolf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `hare` came at the end of the list, we could have also used the built-in
    `len()` function to find the end of the list and use its return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You need to subtract one from the length of the list because iterating and indexing
    in Python start at 0, so the final index is always one less than the length of
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Index of Items in Lists**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Similar to the `remove()` method, the `index()` method will return the zero-based
    index of the first occurrence of a specified item in a list. It also raises a
    `ValueError` if the item doesn’t exist. Let’s fetch the index of `dog` in the
    `patroni` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use slice notation on the list to limit the search to a particular
    subsequence. Just add optional start and end arguments after the item name. The
    returned index is still computed relative to the beginning of the full sequence,
    however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `index()` method looked at the items between indexes `2`
    and `5` (`dog` *up to* `wolf`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `count()` method returns the number of times an item appears in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Sorting the Values in Lists**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `sort()` method sorts lists in place, either alphabetically or numerically.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Computers are very literal, however, and things might not go as planned. Notice
    what happens if you try to alphabetize a list comprising letters with different
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python default is to place capitalized letters before lowercase ones. So,
    this mixed-case example is correct by Python’s standards but probably isn’t what
    you expected or wanted. To force Python to compare apples to apples, you can use
    the optional `key` argument to convert all strings to lowercase before sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sort()` method also comes with a second optional argument for *reversing*
    the order of items in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass `sort()` a *sort key* to let it know what parameter you want to
    sort by. In this example, we’re sorting based on the length of strings using the
    `len` sort key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can even write and pass `sort()` a custom function to do more complicated
    sorting. To find out more, visit the sorting tutorial at *[https://docs.python.org/3/howto/sorting.html](https://docs.python.org/3/howto/sorting.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Curious Case of Copy**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The act of copying a list reveals perhaps the greatest “gotcha” in the Python
    language. Pour yourself a cup of coffee, because this may be the most important
    thing you learn all day.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that variable names are references to an object, but not the object
    itself? Likewise, when you copy an object using an assignment statement, you copy
    only the reference to that object. When this behavior is combined with mutable
    objects, mayhem can result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assign a list to another list, a seemingly straightforward thing to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You might think `my_patroni` and `your_patroni` are separate lists containing
    identical values, but they’re not. Each name points to the same object in memory.
    You can confirm this by checking the identity of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'They’re the same object. So, if you alter one, you alter the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Changing the first item in `my_patroni` changed the same item in `your_patroni`.
    This kind of behavior can keep you up bug-hunting all night.
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly copy a mutable object, like a list, use the `copy()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use slice notation to copy the whole list from start
    to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of the method, each list object has a separate identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s great, but we’re not through yet. The slice and `copy()` methods make
    a *shallow* copy. This means that if a list contains nested lists, `copy()` duplicates
    only *references* to the inner, nested lists. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, these two lists have different identities, meaning that they’re
    different objects. Now let’s check the identity of the first nested list, at index
    `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This inner list is the same object in both lists. To prove it, change the first
    item in this list to `wolf`. Remember, the first index references the first nested
    list, and the second index references the first item in this list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, changing an item in one list has changed the same item in another. Note
    that this behavior extends only to the *nested* lists. If you append a new item
    to the `my_patroni` list, it won’t affect `your_patroni`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid this type of behavior, you should import the built-in `copy` module
    and use its `deepcopy()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, the nested lists are separate objects, and you’ve created a true copy of
    the original. No more “quantum entanglement” with “spooky action at a distance.”
  prefs: []
  type: TYPE_NORMAL
- en: For a slight slowdown in your code, `deepcopy()` will ensure that you’re copying
    any internal object references. This includes all mutable objects within a list
    at every possible level, thereby avoiding bugs that can cost you much more time
    to find and correct.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking for Membership**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can check whether an item occurs in a list using the `in` and `not_in`
    keywords. These also work on other container data types, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Doing this for large lists is not recommended, however. Checking for membership
    in a list is computationally expensive and thus slow. Python must check through
    every value in a list to perform this operation, whereas in other collection data
    types such as sets and dictionaries, it can use very fast hash tables for a noticeable
    improvement in performance. It’s easy to convert a list into a set for this purpose,
    and we’ll do it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Create an empty list named `patroni` and then add a tiger, shark, and weasel
    to it all at once.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Delete all of the items in the previous `patroni` list.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Which is the *wrong* way to add “shrew” to the `patroni` list?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `patroni.append(``'``shrew``'``)`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `patroni += ['shrew'``]`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `patroni = patroni + 'shrew'`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `patroni = patroni + ['shrew']`
  prefs: []
  type: TYPE_NORMAL
- en: 9.  Why shouldn’t you use `patroni += 'shrew'`?
  prefs: []
  type: TYPE_NORMAL
- en: 'a.  You’ll raise `TypeError: can only concatenate list (not ″str″) to list`'
  prefs: []
  type: TYPE_NORMAL
- en: b.  Augmented operators work only with strings and mathematical expressions
  prefs: []
  type: TYPE_NORMAL
- en: c.  Each letter in “shrew” will become a separate item in the list
  prefs: []
  type: TYPE_NORMAL
- en: d.  No one uses a shrew as a patronus
  prefs: []
  type: TYPE_NORMAL
- en: '10.  J.K. Rowling’s personal patronus is a:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Manx cat
  prefs: []
  type: TYPE_NORMAL
- en: b.  Jack Russell terrier
  prefs: []
  type: TYPE_NORMAL
- en: c.  Heron
  prefs: []
  type: TYPE_NORMAL
- en: d.  Hummingbird
  prefs: []
  type: TYPE_NORMAL
- en: '**Sets**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *set* is a mutable, unordered, iterable collection of *unique* elements (no
    duplicates allowed). Sets are designed to work like their mathematical counterparts
    and thus support operations such as union, intersection, and difference. Sets
    look like tuples and lists except that they’re enclosed in curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Sets are based on a data structure known as a *hash table* that makes adding
    and searching for elements in them very fast (we looked at this data structure
    back in “The Debugger Pane” on [page 90](ch04.xhtml#ch00lev1sec32)). A deep discussion
    of hash tables is beyond the scope of this book, but basically, hashing is a process
    whereby a key or string of characters is transformed into a shorter, fixed-length
    value that’s easier to find, and these values are stored in a hash table for easy
    look-up.
  prefs: []
  type: TYPE_NORMAL
- en: Besides being significantly faster than tuples and lists for membership tests,
    sets let you efficiently remove duplicate values from those data types by converting
    them into a set. On the other hand, sets are slightly slower during iteration
    and take up more memory. And because sets are unordered, you can’t access elements
    using indexes, as you can with the tuples and lists.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Sets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sets consist of a sequence of comma-separated values enclosed by curly brackets
    (`{}`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also copy sets using the built-in `set()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set()` function also converts other data types to sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This snippet turned the string `a_string` into a set. Note that each character
    in the string is now a separate element in the set, duplicates have been removed,
    and the elements are unordered.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, to create an empty set you must use `set()`, not `{}`, as the
    latter creates an empty dictionary, a data structure that we’ll cover in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Because “set” is the name of a function, you should never use it as a variable
    name.*'
  prefs: []
  type: TYPE_NORMAL
- en: The elements in sets must be *hashable*, which means they must be immutable.
    Because Python hashes each element in a set and stores the hash value, if you
    change an element in place, it gets hashed again, and the new hash value is stored
    in a different location in the hash table. This can cause conflicts and lost elements
    that prevent the set from working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integers, floats, and strings are immutable, as are tuples composed of immutable
    items. You can check whether an object in Python is hashable using the `hash()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Because the string `'``astrolabe``'` is immutable, it was assigned a hash value.
    If you try this with a mutable list, however, you’ll raise a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a mutable sequence in a set, you first must convert it to a tuple. In
    this example, we convert a list to a tuple while assigning it to a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This works only if the tuple doesn’t contain mutable items, such as a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If you have lists in your tuple, you’ll need to convert them into tuples, as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because sets use hash tables, they take up more memory than tuples and lists.
    Enter the following code into the console to see the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: A set of 10,000 elements takes up roughly six times the memory of a list and
    6.5 times the memory of a tuple of the same size.
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Sets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 9-4](ch09.xhtml#ch09tab4) lists some common methods for working with
    sets. You should substitute your own variable names for the ones shown in *italics*.
    In addition to these methods, you can use many of Python’s built-in functions,
    such as `min()`, `max()`, and `len()`, with sets.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-4:** Useful Built-in Set Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Methods** | **Operator syntax** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| set1.`add(`item`)` |  | Add item to set |'
  prefs: []
  type: TYPE_TB
- en: '| set1.`clear()` |  | Reset to empty |'
  prefs: []
  type: TYPE_TB
- en: '| set1.`copy()` |  | Returns a shallow copy of a set |'
  prefs: []
  type: TYPE_TB
- en: '| set1.`difference(`set2`)` | set1 - set2 | Return unshared items |'
  prefs: []
  type: TYPE_TB
- en: '| set1.`difference_update(`set2`)` | set1 -= set2 | Set set1 to items not in
    set2 |'
  prefs: []
  type: TYPE_TB
- en: '| set1`.discard(`item`)` |  | Removes selected item from a set |'
  prefs: []
  type: TYPE_TB
- en: '| set1`.intersection(`set2`)` | set1 & set2 | Return all items in both sets
    |'
  prefs: []
  type: TYPE_TB
- en: '| set1`.intersection_update(`set2`)` | set1 &= set2 | Set set1 to intersecting
    items |'
  prefs: []
  type: TYPE_TB
- en: '| set1`.isdisjoint(`set2`)` |  | Return True if no shared items |'
  prefs: []
  type: TYPE_TB
- en: '| set1`.issubset(`set2`)` | set1 <= set2 | Return True if set2 contains set1
    |'
  prefs: []
  type: TYPE_TB
- en: '| set1`.issuperset(`set2`)` | set1 >= set2 | Return True if set1 contains set2
    |'
  prefs: []
  type: TYPE_TB
- en: '| set_name`.pop()` |  | Remove arbitrary element from a set |'
  prefs: []
  type: TYPE_TB
- en: '| set_name`.remove(`item`)` |  | Remove an item from a set |'
  prefs: []
  type: TYPE_TB
- en: '| set1`.symmetric_difference(`set2`)` | set1 `^` set2 | Return unshared set1
    and set2 items |'
  prefs: []
  type: TYPE_TB
- en: '| set1`.symmetric_difference_update(`set2`)` | set1 `^`= set2 | Set set1 to
    unshared items |'
  prefs: []
  type: TYPE_TB
- en: '| set1`.union(`set2`)` | set1 `&#124;` set2 | Return all unique items in both
    |'
  prefs: []
  type: TYPE_TB
- en: '| set1`.update(`set2`)` | set1 &#124;= set2 | Set set1 to unique set1 and set2
    items |'
  prefs: []
  type: TYPE_TB
- en: The operator syntax column represents shorthand syntax that you can use with
    certain methods. These are obviously less readable than the full method names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets are good choices for datasets that can’t contain duplicates and that you
    need to compare to other datasets. Let’s assume that you’re studying the fauna
    in two farm ponds. We’ll make the dataset short for convenience, but imagine it’s
    a much more extensive list (and uses proper taxonomical naming):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a gar to `pond1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If you try to add another gar to `pond1`, everything will appear to work, but
    you’ll still have only one `gar` entry in the set because duplicates aren’t permitted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Differences Between Two Sets**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s assume that you’ve finished and have too many animals in each set to visually
    compare. That’s okay; you can use the `difference()` method to look at animals
    that are unique to each pond. [Figure 9-2](ch09.xhtml#ch09fig2) uses a Venn diagram
    to demonstrate what this method returns.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: The difference() set method*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying this to our pond sets yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Because there’s no such thing as a pond without a turtle, these results suggest
    that you need to make another field trip to `pond2`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Duplicate Items in Two Sets**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To see which animals are common to both ponds, use the `intersection()` method,
    described in [Figure 9-3](ch09.xhtml#ch09fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: The intersection() set method*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this method on our pond data yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You need to do this only for `pond1` because you’ll get the same result for
    `pond2.intersection(pond1)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining Sets**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now, suppose that you sample a large lake and find more animal species than
    in the small ponds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You’re curious if the lake environment behaves like a big pond that includes
    the same animals plus a few more. To determine this, you first must combine the
    pond animals into a single set using the `union()` method, as demonstrated in
    [Figure 9-4](ch09.xhtml#ch09fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: The union() set method*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can combine multiple sets at once using this syntax: set1.union(set2,
    set3, set4...`)`.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Determining Whether One Set Is a Superset of Another**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If the `lake1` set contains all the animals in the `pond_animals` set, it’s
    considered to be a *superset*. [Figure 9-5](ch09.xhtml#ch09fig5) shows how supersets
    and subsets work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: The issuperset() and issubset() set methods*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run `issuperset()` on the lake set, it will return `True`, indicating
    that all of the pond animals are present in the lake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '***Creating Frozensets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The built-in `frozenset()` function takes an iterable object as input and makes
    it immutable. The resulting “frozenset” is a set with elements that can’t be added,
    removed, or altered.
  prefs: []
  type: TYPE_NORMAL
- en: Frozensets are mainly used as dictionary keys (which must be immutable) or as
    elements in other sets, because sets can’t be inserted into sets. Frozensets are
    “safer” than sets, as there’s no risk of accidentally changing elements in frozensets
    later in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a frozenset, pass the function an iterable, such as another set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: You can use the same functions and methods on frozensets that you use on sets,
    as long as they don’t change the frozenset. Mathematical set operations such as
    intersection, difference, and union will all work on frozensets.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 11.  Why shouldn’t you use `count()` with a set?
  prefs: []
  type: TYPE_NORMAL
- en: 12.  To get all the elements in set1 and set2 but not in both, which of the
    following would you use?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `set1.difference(set2)`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `set1.intersection(set2)`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `set1.symmetric_difference(set2)`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `set1.issubset(set2)`
  prefs: []
  type: TYPE_NORMAL
- en: '13.  True or false: The best way to create an empty set is to use the `set()`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: 14.  Which method will not work on a frozenset?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `frozenset1.union(frozenset2)`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `len(frozenset1)`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `frozenset1.pop()`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `frozenset1.copy()`
  prefs: []
  type: TYPE_NORMAL
- en: '**Dictionaries**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Short for dictionary, the *dict* data type is an ordered, iterable, mutable
    collection of values indexed by *keys* rather than numbers. The keys can be almost
    any data type and are mapped to one or more values. Dictionaries are considered
    the most important Python structure for storing and accessing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dictionary looks different than tuples, lists, and sets, as it has key-value
    pairs. But like a set, it’s surrounded by curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Keys have the same properties as elements in a set: they must be unique and
    immutable because they get hashed. In fact, sets are just collections of dictionary
    keys with no corresponding values. And like sets, dictionaries take up more memory
    due to the use of a hashing process.'
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary key is like a word in a language dictionary and the values represent
    the definition(s) for that word. Keys can be multiple objects (like a word pair),
    as long as the multiple objects are immutable (tuples can be used but not lists).
  prefs: []
  type: TYPE_NORMAL
- en: Values, on the other hand, can be mutable objects. And just as a word in a language
    dictionary can have more than one definition, it’s fine to have multiple values
    that map to a single key.
  prefs: []
  type: TYPE_NORMAL
- en: Because dictionaries associate, or map, one thing with another, they tend to
    be used when items in a collection are labeled. You can use them as simple databases
    whose data has a key-value relationship, such as student names and student IDs.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Dictionaries***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A dictionary consists of comma-separated key-value pairs enclosed in curly
    brackets (`{}`). The key-value pairs are separated by colons, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The use of the colon distinguishes dictionaries from sets, which also use curly
    brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s make a dictionary that maps some letters to their equivalent Morse
    code symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, dictionaries preserve the *insertion* order of the key-value
    pairs. This mainly affects readability when viewing the dictionary, and you should
    take this into account when entering the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using this `morse` dictionary, you can loop through a word and translate
    it to Morse code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that dictionary keys are case sensitive, so the following code will raise
    an `KeyError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re doing something like looping through the letters in the dictionary,
    you can avoid this error by converting the letters to lowercase as part of the
    key index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the built-in `dict()` function to create a dictionary. An
    advantage here is that you can use keyword arguments for the keys and avoid typing
    as many single quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Because “dict” is the name of a function, you should never use it as a variable
    name.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Combining Two Sequences into a Dictionary***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can pair up two sequences such as a tuple or list into a dictionary. Of
    course, the sequences should contain the same number of items and they should
    be ordered appropriately, so that index 5 in one list pairs with whatever’s at
    index 5 in the second list. Here’s an example translating English words to Spanish
    words. The `zip()` built-in function pairs up the two lists item by item by mapping
    similar indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the Spanish word for cold is both masculine and feminine, the two forms
    are stored in a nested list (you could also use a tuple for memory efficiency).
    You can access items in the list using standard list indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you’ll want either the masculine form or the feminine form to consistently
    come first in the nested lists, so you always use the same index to fetch it.
    Alternatively, you can nest a dictionary that specifies masculine (`m`) versus
    feminine (`f`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'By using a dictionary, you don’t need to map translations to arbitrary indexes,
    and your code is much more readable and less prone to error. And if you want to
    get really pithy, you can build the translation dictionary using: `translation
    = dict(zip(english, spanish))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Empty Dictionaries and Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make an empty dictionary, use curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Values can also be empty. This is handy for setting-up placeholder keys to
    which you will assign values at a later time, like when you load a new list or
    a user provides some input. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '***Working with Dictionaries***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 9-5](ch09.xhtml#ch09tab5) summarizes some dictionary methods. You’ll
    need to substitute your own names for those in italics. In addition, you can use
    many built-in functions such as `len()`, `min()`, and `max()` with dictionaries.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-5:** Built-in Dictionary Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `clear()` | Remove all dictionary elements | dict_name`.clear()` |'
  prefs: []
  type: TYPE_TB
- en: '| `copy()` | Return a copy of a dictionary | dict_name`.copy()` |'
  prefs: []
  type: TYPE_TB
- en: '| `fromkeys()` | Return a dictionary with the specified keys and a value |
    dict_name `= dict.fromkeys(`key_tuple, value`)` |'
  prefs: []
  type: TYPE_TB
- en: '| `get()` | Return the value of a specified key | dict_name`.get(`key`)` |'
  prefs: []
  type: TYPE_TB
- en: '| `items()` | Return a tuple of all key-value pairs | dict_name`.items()` |'
  prefs: []
  type: TYPE_TB
- en: '| `keys()` | Return a list of a dictionary’s keys | dict_name`.keys()` |'
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | Remove the element with specified key | dict_name`.pop(`key`)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `popitem()` | Remove the last inserted key-value pair | dict_name.`popitem()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setdefault()` | Insert specified key and value if no key, else return value
    if key exists | dict_name.`setdefault(`key, value`)` |'
  prefs: []
  type: TYPE_TB
- en: '| `update()` | Update dictionary with specified key-value | dict_name.`update({`key:
    value`})` |'
  prefs: []
  type: TYPE_TB
- en: '| `values()` | Return a list of the values in a dictionary | dict_name.`values()`
    |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although you can change the value that’s mapped to a key, there are no dictionary
    methods that let you add a value to an existing key. To do this, you’ll need to
    import and use the collections third-party module. We’ll look at collections and
    other helpful modules in [Chapter 11](ch11.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the Contents of Dictionaries**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `keys()`, `values()`, and `items()` methods return the contents of dictionaries
    in list-like data types called `dict_keys`, `dict_values`, and `dict_items()`,
    respectively. You can iterate (loop) over these structures, but otherwise they
    don’t behave like true lists. Here’s how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use this output as a list, you can convert it using the `list()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a list of key-value pair tuples when used with `items()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '**Getting the Value of a Dictionary Key**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As you’ve seen, if you just want the value of a key in a dictionary, you can
    use the key as you would an index with a list, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This works great until you ask for a key that doesn’t exist, in which case
    Python will raise a `KeyError`. To avoid this, use the `get()` method, which lets
    you provide a default value for non-existent keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The second argument (`'unknown'`) passed to the `get()` method is the default
    return value. Now, when you ask for a missing key like potassium hydroxide, the
    method returns `'unknown'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check whether a key is present using the `in` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '**Adding Key-Value Pairs to a Dictionary**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To add a key-value pair to a dictionary, you can use the indexing approach
    (see line `In [196]:`) or use the `update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'To add multiple key-value pairs, separate them with commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '**Combining Dictionaries**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can also add a dictionary to another dictionary with `update()`, but a
    more succinct method is to use the `**` operator. Let’s chain three dictionaries
    together to make a fourth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '**Removing Key-Value Pairs from a Dictionary**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To remove a key-value pair, pass the key to the `pop()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this method returns the value, so you can assign it to a variable
    while popping if you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `del` keyword to remove elements; for example, `del chems[``'``KHO``'``]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Default Values for Keys**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `setdefault()` method lets you check whether a key exists and set a value
    for the key if it doesn’t. Otherwise, it returns the value of the key. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the key `''``Mars``''` didn’t exist, the method added it along with
    its order in the solar system, `4`. But if you try to change an existing key,
    like `''``Earth``''`, the method will just return its value and make no changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that you want to count the number of times the companies Pfizer, Moderna,
    and Johnson & Johnson were mentioned in articles related to the coronavirus in
    2021\. You plan to store the counts in a dictionary. The `fromkeys()` method will
    help you to set up this dictionary by populating it with keys with the same initial
    value. The default value is `None`, but in this case, use `0`. You’ll need to
    pass the keys in the form of a tuple, followed by a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '**Performing a Reverse Lookup**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Dictionaries are optimized to efficiently find the value or values for a given
    key. But sometimes you might want to find all the keys that correspond to a given
    value (such as looking up the name associated with a phone number). There’s no
    built-in functionality for doing a “reverse lookup,” so you need to define a function
    to perform the task. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We haven’t covered functions yet, so let me explain. We used the `def` keyword
    to define a function named `lookup_keys` that has two parameters: `d` (for dictionary)
    and `v` (for value). Python automatically indents four spaces when you press ENTER,
    which designates that you’re working within the function. Because the same value
    can be associated with multiple keys, we created an empty list named `keys` to
    hold the values. Next, we looped through the keys in the dictionary, and if the
    key’s value matched the specified value (`v`), we appended it to the list. After
    the loop finished, we returned the list using the `return` keyword, which ended
    the function and made the list accessible to the rest of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test the function using the `solar_system` dictionary from the previous
    section. Pass it the name of the dictionary and `3`, for the third planet, in
    parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, reverse lookups run slower than forward lookups.
  prefs: []
  type: TYPE_NORMAL
- en: '**Printing Dictionaries**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you print a dictionary using the `print()` function, you’ll get all the braces,
    quotation marks, and commas used to build the dictionary. To get around this,
    you can use “pretty printing” techniques.
  prefs: []
  type: TYPE_NORMAL
- en: If you do an online search for “pretty print a Python dictionary,” you’ll find
    numerous methods such as `pprint()`, that yield more readable output than the
    built-in `print()` function. Let’s look at one of them here, the `json.dumps()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `json.dumps()` method converts a Python object into a `JSON` string. This,
    in turn, formats the dictionary into attractive `JSON` format. The method accepts
    three parameters used for pretty printing: the dictionary name, a Boolean value
    (`True` or `False`) for whether to sort the keys, and the number of spaces for
    indentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we import `json`, create a dictionary (`d`), and
    then print it using the `print()` function followed by `json.dumps()`, for comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The `JSON` output is easier to digest than the horizontal layout returned by
    `print()`. It works only with data types that `JSON` supports, however, which
    means that embedded sets and functions will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we’re getting ahead of ourselves, it’s worth noting that you can traverse,
    sort, and print a dictionary using a `for` loop, the built-in `sorted()` function,
    and `print()`. You can even “pretty it up” with f-strings, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: You can indent the output similar to the `json.dumps()` method by adding spaces
    or tabs (`\t`) after the first single quote in the `print` command. Give it a
    try.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 15.  What would you use to initialize a dictionary in which all the values are
    empty?
  prefs: []
  type: TYPE_NORMAL
- en: a.  The `setdefault()` method
  prefs: []
  type: TYPE_NORMAL
- en: b.  The `fromkeys()` method
  prefs: []
  type: TYPE_NORMAL
- en: c.  The `update()` method
  prefs: []
  type: TYPE_NORMAL
- en: d.  The built-in `zip()` function
  prefs: []
  type: TYPE_NORMAL
- en: 16.  Which statement about dictionaries is false?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Membership searches are very fast.
  prefs: []
  type: TYPE_NORMAL
- en: b.  Dictionaries are optimized to find the key or keys for a given value.
  prefs: []
  type: TYPE_NORMAL
- en: c.  You can pretty print dictionaries with the `pprint()` module.
  prefs: []
  type: TYPE_NORMAL
- en: d.  Dictionaries are more memory intensive than lists.
  prefs: []
  type: TYPE_NORMAL
- en: '17.  Create a joke dictionary that maps setup lines to punchlines. Here’s a
    few to get you started: “Did you hear about the kidnapping? He slept for three
    hours.” “I started a band called ‘999 Megabytes.’” “You’ll never get a gig.” “I
    heard you had to shoot your dog. Was he mad?” “He wasn’t too happy about it!”'
  prefs: []
  type: TYPE_NORMAL
- en: 18.  What data type is held in the square brackets in `contacts[′Nix′, ′Goaty′]
    = ′goatynix@gmail.com′`?
  prefs: []
  type: TYPE_NORMAL
- en: a.  String
  prefs: []
  type: TYPE_NORMAL
- en: b.  List
  prefs: []
  type: TYPE_NORMAL
- en: c.  Tuple
  prefs: []
  type: TYPE_NORMAL
- en: d.  Set
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned about the four data types for working with collections
    in Python. A tuple is an immutable sequence type that holds a collection of objects,
    indexed by integers, in a defined order. A list is a mutable sequence type that
    holds a collection of objects, indexed by integers, in a defined order. A set
    is a mutable set type that holds an unordered collection of unique objects. A
    dictionary is a mutable mapping type that holds an ordered collection of unique
    objects (keys) that map to associated objects (values).
  prefs: []
  type: TYPE_NORMAL
- en: Each of these built-in data structures has its uses as well as its own peculiar
    behaviors. Tuples are memory efficient and good places to keep objects “safe”
    because they’re unchangeable after they’re created. Lists, being mutable, are
    flexible and useful for many jobs, though membership searches are slow. Sets can
    be used to efficiently remove duplicates from a dataset, provide very fast membership
    searches, and let you perform mathematical set operations, like union and intersection.
    Dictionaries also provide fast membership searches and let you easily set up associative
    databases for labeled data. If you are not sure how a data type is going to behave,
    take the time to test it in the interactive console before you incorporate it
    in your code.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot more left to learn. *Comprehensions*, which we’ll cover in the
    next chapter, provide shorthand methods for creating lists, sets, and dictionaries.
    Importable modules, such as *collections* and *itertools*, provide useful tools
    for working with container data types. We’ll look at these in [Chapter 11](ch11.xhtml).
    Then, in [Chapter 12](ch12.xhtml), we’ll look at how to load external datasets
    into lists, sets, and so on, rather than typing them in item by item. For now,
    it’s time to learn about *flow control*.
  prefs: []
  type: TYPE_NORMAL
