<html><head></head><body>
<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_359"/><span class="big">14</span><br/>LINEAR EQUATIONS</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Many engineering problems require resolving a system of linear equations. These equations arise in structural analysis, electric circuits, statistics, and optimization problems, just to name a few. Implementing algorithms to solve these ubiquitous systems of equations is key for our <em>Mechanics</em> project to deal with real-world engineering problems.</p>&#13;
<p class="indent">In this chapter, we’ll explore the concept of <em>numerical methods</em>: existing algorithms that use computers to solve systems of equations. We’ll implement a powerful method to solve systems of linear equations: the Cholesky decomposition. We’ll use this method when we need to solve the big systems of equations from the structural analysis problems in <a href="part05.xhtml#part05">Part V</a> of the book.</p>&#13;
<h3 class="h3" id="ch00lev1sec83"><strong>Systems of Linear Equations</strong></h3>&#13;
<p class="noindent">A linear equation with <em>n</em> unknowns <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …, <em>x</em><sub><em>n</em></sub> can be expressed as shown in <a href="ch14.xhtml#ch14eqa01">Equation 14.1</a>.</p>&#13;
<div class="equationc" id="ch14eqa01"><img src="../images/14eqa01.jpg" alt="Image"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_360"/>Here, <em>m</em><sub>1</sub>, <em>m</em><sub>2</sub>, …, <em>m</em><sub><em>n</em></sub> are the equation’s coefficients, known numbers that multiply each of the unknowns, and <em>b</em> is a known number that doesn’t multiply any unknown. We call this last number <em>b</em> the <em>free term</em>.</p>&#13;
<p class="indent">If the unknowns are only multiplied by a scalar, added, or subtracted, then we say the equation is <em>linear</em>. The coefficients are always known quantities. An alternative way of expressing a linear equation is shown here,</p>&#13;
<div class="equationc"><img src="../images/f0360-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">where <em>m</em><sub><em>i</em></sub> is the coefficients, <em>x</em><sub><em>i</em></sub> is the unknowns, and <em>b</em> is the free term.</p>&#13;
<p class="indent">By contrast, a nonlinear equation includes things like unknowns with an exponent (<em>x</em><sup>3</sup>), trigonometric functions (sin(<em>x</em>)), or the product of several unknowns (<em>x</em><sub>1</sub> ⋅ <em>x</em><sub>2</sub>). These equations are considerably harder to solve than linear ones, so we’ll stay focused on linear equations.</p>&#13;
<p class="indent">A system of linear equations has the form shown in <a href="ch14.xhtml#ch14eqa02">Equation 14.2</a>.</p>&#13;
<div class="equationc" id="ch14eqa02"><img src="../images/14eqa02.jpg" alt="Image"/></div>&#13;
<p class="noindent">Here, a coefficient <em>m</em><sub><em>i,j</em></sub> is the term that multiplies the <em>j</em><sup><em>th</em></sup> unknown in the <em>i</em><sup><em>th</em></sup> equation. These systems can be conveniently expressed in their matrix form as shown in <a href="ch14.xhtml#ch14eqa03">Equation 14.3</a>.</p>&#13;
<div class="equationc" id="ch14eqa03"><img src="../images/14eqa03.jpg" alt="Image"/></div>&#13;
<p class="noindent">Here, [<em>M</em>] is the matrix of coefficients,</p>&#13;
<div class="equationc"><img src="../images/f0360-02.jpg" alt="Image"/></div>&#13;
<p class="noindent">and [<em>x</em>] and [<em>b</em>] are the unknown and the free-term column vectors:</p>&#13;
<div class="equationc"><img src="../images/f0360-03.jpg" alt="Image"/></div>&#13;
<p class="indent">A solution for <a href="ch14.xhtml#ch14eqa03">Equation 14.3</a> is a set of numbers <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …, <em>x</em><sub><em>n</em></sub> that satisfies all <em>n</em> equations. Finding solutions for big systems of equations by hand can take a long time, but don’t worry: there are plenty of algorithms for solving systems like this using a computer.</p>&#13;
<p class="indent">A quick note on nomenclature. We’ll use uppercase letters inside square brackets to denote matrices: [<em>M</em>]. The items in a matrix will be named using the same letter used for the matrix but lowercase. Items will include as a subscript two comma-separated numbers, which are the row and column indices <span epub:type="pagebreak" id="page_361"/>of their position inside the matrix. For example, the number in row 3 and column 5 of the matrix [<em>M</em>] will be referred to as <em>m</em><sub>3, 5</sub>. Column and row vectors are denoted as lowercase letters inside square brackets: [<em>x</em>]. Remember that column and row vectors are also matrices.</p>&#13;
<h3 class="h3" id="ch00lev1sec84"><strong>Numerical Methods</strong></h3>&#13;
<p class="noindent"><em>Numerical methods</em> are algorithms that find an approximate solution for a system of equations using the computational power of a computer.</p>&#13;
<p class="indent">There are numerical methods designed to solve systems of linear, nonlinear, and differential systems of equations. Most numerical methods, nevertheless, are limited to solving specific types of systems. For instance, the Cholesky decomposition works only with linear systems whose coefficient matrix is symmetric and positive definite (we’ll see what this means in a bit). If we need to solve a nonlinear system of equations, or even one that is linear but with a nonsymmetric coefficient matrix, Cholesky decomposition simply won’t work.</p>&#13;
<p class="indent">There are two big families of numerical methods: <em>direct</em> and <em>iterative</em>. Direct methods use algebraic modifications on the original system to solve it. Iterative methods, on the other hand, start with an approximate solution for the system and improve it step-by-step until the solution has the desired accuracy. The Cholesky decomposition is a direct numerical method.</p>&#13;
<p class="indent">Numerical methods are a big topic: entire books have been written about it. There are many technical details about numerical methods that we won’t be covering here. But this isn’t a theory book; we’re much more interested in the practice, so we’ll implement an algorithm that solves the kinds of systems of equations that’ll arise in the structural analysis application we’ll create in the next part of the book. In this case, that means we’ll be working with linear systems with symmetric, positive-definite coefficient matrices.</p>&#13;
<h3 class="h3" id="ch00lev1sec85"><strong>Cholesky Decomposition</strong></h3>&#13;
<p class="noindent">The <em>Cholesky decomposition</em> is a direct (noniterative) method that solves linear systems of equations provided their [<em>M</em>] (the coefficient matrix) is <em>symmetric</em> and <em>positive definite</em>.</p>&#13;
<p class="indent">A symmetric matrix [<em>M</em>] is one that is equal to its transpose: [<em>M</em>] = [<em>M</em>]<sup>′</sup>. That is the same as saying that the values in the matrix are symmetric with respect to the main diagonal. In a symmetric matrix, every row contains the same values as the column with the same index, and vice versa. Note that to be symmetric, a matrix needs to be square. The following is an example of a symmetric matrix:</p>&#13;
<div class="equationc"><img src="../images/f0361-01.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_362"/>A square matrix [<em>M</em>] with <em>n</em> rows and columns is <em>positive definite</em> if for any column vector [<em>x</em>] made of <em>n</em> real numbers (with the exception of a vector filled with zeros), the expression in <a href="ch14.xhtml#ch14eqa04">Equation 14.4</a> is satisfied.</p>&#13;
<div class="equationc" id="ch14eqa04"><img src="../images/14eqa04.jpg" alt="Image"/></div>&#13;
<p class="indent">If you find a nonzero vector [<em>x</em>] that doesn’t satisfy the previous equation, then the matrix [<em>M</em>] is not positive definite.</p>&#13;
<p class="indent">We can also say that a matrix is positive definite if it’s symmetric and all its eigenvalues are positive. If you remember the process of obtaining the eigenvalues of a matrix, you might agree that it’s painful and a bit boring. In either case, proving that [<em>x</em>]<sup>′</sup>[<em>M</em>][<em>x</em>] &gt; 0 for every possible [<em>x</em>] or obtaining all eigenvalues of the matrix and making sure all are positive is an involved process.</p>&#13;
<p class="indent">We are going to skip all that technical complexity and won’t be demonstrating that the matrices we’ll work with are positive definite. We’ll apply the Cholesky factorization to a problem that is well-known for yielding systems of equations with a symmetric and positive-definite matrix: truss structure analysis using the direct stiffness method. If you ever need to apply this algorithm to any another problem, you’ll first need to figure out whether the system of equations derived for it has a matrix that Cholesky can work with. If it’s not the case, don’t worry: there are plenty of other numerical methods that you can use.</p>&#13;
<p class="indent">After we implement Cholesky’s algorithm together, I hope you feel empowered to implement any other numerical method on your own. As you’ll see, the most powerful resource we have at our disposal to make sure we get these tricky algorithms right is unit testing.</p>&#13;
<h4 class="h4" id="ch00lev2sec150"><strong><em>LU Factorization Methods</em></strong></h4>&#13;
<p class="noindent">Cholesky is a computation method from the family of so-called <em>LU</em> factorization or decomposition methods. An <em>LU</em> factorization of a given square matrix [<em>M</em>] has the form shown in <a href="ch14.xhtml#ch14eqa05">Equation 14.5</a>.</p>&#13;
<div class="equationc" id="ch14eqa05"><img src="../images/14eqa05.jpg" alt="Image"/></div>&#13;
<p class="noindent">Here, [<em>L</em>] is a <em>lower-triangular matrix</em>, and [<em>U</em>] is an <em>upper-triangular matrix</em>. A lower-triangular matrix is one where all nonzero values are on and below the main diagonal. Conversely, an upper-triangular matrix has the nonzero values on and above the main diagonal. Here’s an example of a lower-and an upper-triangular matrix:</p>&#13;
<div class="equationc"><img src="../images/f0362-01.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_363"/>Every <em>nonsingular matrix</em> (a matrix that has an inverse) always has an <em>LU</em> factorization. For example, the matrices from the previous example are the <em>LU</em> factorization for the matrix</p>&#13;
<div class="equationc"><img src="../images/f00363-p1.jpg" alt="Image"/></div>&#13;
<p class="noindent">which you can verify by multiplying the following:</p>&#13;
<div class="equationc"><img src="../images/f00363-p2.jpg" alt="Image"/></div>&#13;
<p class="indent">The Cholesky algorithm will provide us with a lower-and an upper-triangular matrix. Besides Cholesky, there are two well-known methods for obtaining the factorization of any nonsingular matrix: the Doolittle and Crout algorithms. These algorithms define the formulas necessary to compute the <em>l</em><sub><em>i,j</em></sub> and <em>u</em><sub><em>i,j</em></sub> values for the lower- and upper-triangular matrices. The benefit of these methods is that they work for any kind of matrix, not just symmetric, positive-definite matrices. We won’t be covering them here, but I encourage you to take a look and try to implement one of them yourself in our <em>Mechanics</em> project. You may want to try that as an exercise after we’ve implemented Cholesky’s algorithm.</p>&#13;
<p class="indent">It’s fair to ask, why not use the Doolittle or Crout algorithms that work with every nonsingular matrix instead of the more restrictive Cholesky? For symmetric and positive-definite matrices, Cholesky’s decomposition is about twice as fast as these other algorithms. Since we’ll use the method with the type of matrices required, we’ll want to benefit from the execution speed offered by Cholesky’s method.</p>&#13;
<p class="indent">Once we obtain the <em>LU</em> factorization for the matrix, we can solve our system of equations in two steps. Suppose our original system was as follows:</p>&#13;
<p class="noindentc">[<em>M</em>][<em>x</em>] = [<em>b</em>]</p>&#13;
<p class="noindent">After factorizing [<em>M</em>], we have <a href="ch14.xhtml#ch14eqa06">Equation 14.6</a>.</p>&#13;
<div class="equationc" id="ch14eqa06"><img src="../images/14eqa06.jpg" alt="Image"/></div>&#13;
<p class="noindent">We can extract two systems from <a href="ch14.xhtml#ch14eqa06">Equation 14.6</a> if we take the product [<em>U</em>][<em>x</em>] and substitute it with a new unknown vector [<em>y</em>]:</p>&#13;
<div class="equationc"><img src="../images/f0363-02.jpg" alt="Image"/></div>&#13;
<p class="noindent">We now have a lower-triangular matrix system, as shown in <a href="ch14.xhtml#ch14eqa07">Equation 14.7</a>,</p>&#13;
<div class="equationc" id="ch14eqa07"><img src="../images/14eqa07.jpg" alt="Image"/></div>&#13;
<p class="noindent">and an upper-triangular matrix system, as shown in <a href="ch14.xhtml#ch14eqa08">Equation 14.8</a>.</p>&#13;
<div class="equationc" id="ch14eqa08"><span epub:type="pagebreak" id="page_364"/><img src="../images/14eqa08.jpg" alt="Image"/></div>&#13;
<p class="indent">By first solving <a href="ch14.xhtml#ch14eqa07">Equation 14.7</a>, we find [<em>y</em>], which plugged into <a href="ch14.xhtml#ch14eqa08">Equation 14.8</a> allows us to compute the unknown vector [<em>x</em>]: the system’s solution. Both <a href="ch14.xhtml#ch14eqa07">Equation 14.7</a> and <a href="ch14.xhtml#ch14eqa08">Equation 14.8</a> are systems with a triangular matrix, and they can be easily solved by forward and backward substitution.</p>&#13;
<p class="indent">Take this system of equations whose coefficient matrix is lower triangular:</p>&#13;
<div class="equationc"><img src="../images/f00364-p1.jpg" alt="Image"/></div>&#13;
<p class="indent">The first unknown <em>y</em><sub>1</sub> can be computed from the first equation as follows:</p>&#13;
<div class="equationc"><img src="../images/f0364-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">From the second equation we have the following,</p>&#13;
<div class="equationc"><img src="../images/f0364-02.jpg" alt="Image"/></div>&#13;
<p class="noindent">which can be solved, as we already computed the value for <em>y</em><sub>1</sub> in the previous step. We do the same for the third equation:</p>&#13;
<div class="equationc"><img src="../images/f0364-03.jpg" alt="Image"/></div>&#13;
<p class="noindent">We have the values for <em>y</em><sub>1</sub> and <em>y</em><sub>2</sub>, so the value for <em>y</em><sub>3</sub> can be computed. This process is known as <em>forward substitution</em>. A formula to obtain the <em>y</em><sup><em>ith</em></sup> solution term using forward substitution is shown in <a href="ch14.xhtml#ch14eqa09">Equation 14.9</a> (using zero-based indices).</p>&#13;
<div class="equationc" id="ch14eqa09"><img src="../images/14eqa09.jpg" alt="Image"/></div>&#13;
<p class="indent">In a system whose coefficient matrix is upper triangular, we can use a similar substitution process, but starting from the bottom this time. The process is called <em>backward substitution</em>. This time we have the following:</p>&#13;
<div class="equationc"><img src="../images/f0364-04.jpg" alt="Image"/></div>&#13;
<p class="indent">Starting from the last equation, we can compute <em>x</em><sub>3</sub>:</p>&#13;
<div class="equationc"><img src="../images/f0364-05.jpg" alt="Image"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_365"/>With this value we can move to the second equation to obtain <em>x</em><sub>2</sub>:</p>&#13;
<div class="equationc"><img src="../images/f0365-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Lastly, from the first equation in the system, we have this:</p>&#13;
<div class="equationc"><img src="../images/f0365-02.jpg" alt="Image"/></div>&#13;
<p class="indent">For the backward substitution, the formula to compute the <em>x</em><sup><em>ith</em></sup> term is described by <a href="ch14.xhtml#ch14eqa10">Equation 14.10</a>, with <em>n</em> being the size of the system.</p>&#13;
<div class="equationc" id="ch14eqa10"><img src="../images/14eqa10.jpg" alt="Image"/></div>&#13;
<p class="indent">We’ll need to implement these formulas in our code soon. You’ll see that it’s actually simpler than it looks.</p>&#13;
<h4 class="h4" id="ch00lev2sec151"><strong><em>Understanding Cholesky</em></strong></h4>&#13;
<p class="noindent">As we discussed, the Cholesky decomposition is an <em>LU</em> method that works with symmetric, positive-definite matrices. Thanks to those properties, a matrix [<em>M</em>] can be decomposed into an [<em>L</em>][<em>U</em>] form where the upper-triangular matrix is the transpose of the lower-triangular one: [<em>U</em>] = [<em>L</em>]<sup>′</sup>. This means we only need to compute the lower-triangular matrix [<em>L</em>]: [<em>U</em>] is just its transpose. Using the Cholesky method, the [<em>M</em>] matrix factorization has the form shown in <a href="ch14.xhtml#ch14eqa11">Equation 14.11</a>.</p>&#13;
<div class="equationc" id="ch14eqa11"><img src="../images/14eqa11.jpg" alt="Image"/></div>&#13;
<p class="noindent">So, the system of equations now looks like <a href="ch14.xhtml#ch14eqa12">Equation 14.12</a>.</p>&#13;
<div class="equationc" id="ch14eqa12"><img src="../images/14eqa12.jpg" alt="Image"/></div>&#13;
<p class="noindent">In this case, we obtain the two systems we need to solve by substituting [<em>L</em>]<sup>′</sup>[<em>x</em>] with [<em>y</em>]:</p>&#13;
<div class="equationc"><img src="../images/f00365-p1.jpg" alt="Image"/></div>&#13;
<p class="noindent">As we already know, this transformation yields a lower system, which we’ll solve first using forward substitution (see <a href="ch14.xhtml#ch14eqa13">Equation 14.13</a>),</p>&#13;
<div class="equationc" id="ch14eqa13"><img src="../images/14eqa13.jpg" alt="Image"/></div>&#13;
<p class="noindent">and then using an upper system that we’ll solve by backward substitution to obtain the solution vector [<em>x</em>] (see <a href="ch14.xhtml#ch14eqa14">Equation 14.14</a>).</p>&#13;
<div class="equationc" id="ch14eqa14"><img src="../images/14eqa14.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_366"/>Given a symmetric, positive-definite matrix [<em>M</em>], we can compute the lower-triangular matrix terms of its Cholesky decomposition, the <em>l</em><sub><em>i,j</em></sub> terms, using the formulas in <a href="ch14.xhtml#ch14eqa15">Equation 14.15</a>.</p>&#13;
<div class="equationc" id="ch14eqa15"><img src="../images/14eqa15.jpg" alt="Image"/></div>&#13;
<p class="indent"><a href="ch14.xhtml#ch14eqa15">Equation 14.15</a> may look intimidating, but it’s actually not that complicated. The best way to see this is by doing an exercise by hand. Grab a pen and some paper and let’s factor a matrix together.</p>&#13;
<h4 class="h4" id="ch00lev2sec152"><strong><em>A Factorization by Hand</em></strong></h4>&#13;
<p class="noindent">Given the symmetric and positive-definite matrix</p>&#13;
<div class="equationc"><img src="../images/f0366-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">let’s find its Cholesky factorization, a lower-triangular matrix [<em>L</em>],</p>&#13;
<div class="equationc"><img src="../images/f0366-02.jpg" alt="Image"/></div>&#13;
<p class="noindent">such that [<em>M</em>] = [<em>L</em>][<em>L</em>]<sup>′</sup>. To compute the <em>l</em><sub><em>i,j</em></sub> terms, we use <a href="ch14.xhtml#ch14eqa15">Equation 14.15</a>. Don’t forget that index <em>i</em> represents the rows of the matrix, and <em>j</em> represents its columns. Let’s do it step-by-step.</p>&#13;
<p class="indent"><strong>Step 1:</strong> <em>i</em> = 0,<em>j</em> = 0. Since <em>i</em> = <em>j</em>, we use the first formula:</p>&#13;
<div class="equationc"><img src="../images/f0366-03.jpg" alt="Image"/></div>&#13;
<p class="noindent">Note that the summation is struck through because it doesn’t yield any term. This is because the summation’s end value <em>k</em> = –1 is smaller than the start one <em>k</em> = 0. As you probably know, for the summation to yield any term, the end value for <em>k</em> (the iterating variable) needs to be equal to or greater than the start value.</p>&#13;
<p class="indent"><strong>Step 2:</strong> <em>i</em> = 1,<em>j</em> = 0. In this case, <em>i</em>≠<em>j</em>, so we use the second formula:</p>&#13;
<div class="equationc"><img src="../images/f0366-04.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_367"/><strong>Step 3:</strong> <em>i</em> = 1,<em>j</em> = 1.</p>&#13;
<div class="equationc"><img src="../images/f0367-01.jpg" alt="Image"/></div>&#13;
<p class="indent"><strong>Step 4:</strong> <em>i</em> = 2,<em>j</em> = 0.</p>&#13;
<div class="equationc"><img src="../images/f0367-02.jpg" alt="Image"/></div>&#13;
<p class="indent"><strong>Step 5:</strong> <em>i</em> = 2,<em>j</em> = 1.</p>&#13;
<div class="equationc"><img src="../images/f0367-03.jpg" alt="Image"/></div>&#13;
<p class="indent"><strong>Step 6:</strong> <em>i</em> = 2,<em>j</em> = 2.</p>&#13;
<div class="equationc"><img src="../images/f0367-04.jpg" alt="Image"/></div>&#13;
<p class="indent">If we combine all the computed <em>l</em><sub><em>i,j</em></sub> values, the resulting matrix is as follows:</p>&#13;
<div class="equationc"><img src="../images/f0367-05.jpg" alt="Image"/></div>&#13;
<p class="noindent">This means that the original system’s matrix [<em>M</em>] can be factorized as follows:</p>&#13;
<div class="equationc"><img src="../images/f0367-06.jpg" alt="Image"/></div>&#13;
<p class="indent">You can do the matrix multiplication to verify that the product [<em>L</em>][<em>L</em>]<sup>′</sup> is actually equal to [<em>M</em>]. To complete the exercise, let’s suppose this matrix is the coefficient matrix of a system of equations and solve it using the forward and backward substitutions.</p>&#13;
<h4 class="h4" id="ch00lev2sec153"><strong><em>A Resolution by Hand</em></strong></h4>&#13;
<p class="noindent">Let’s suppose the matrix we decomposed earlier into its [<em>L</em>][<em>L</em>]<sup>′</sup> form is part of the following system of equations:</p>&#13;
<div class="equationc"><img src="../images/f0367-07.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_368"/>We need to find the values of <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, and <em>x</em><sub>3</sub> that satisfy all three equations. Using the Cholesky factorization we just obtained, we can rewrite the system as follows:</p>&#13;
<div class="equationc"><img src="../images/f0368-01.jpg" alt="Image"/></div>&#13;
<p class="indent">The first of the two subsystems we have to solve, [<em>L</em>][<em>y</em>] = [<em>b</em>], results from substituting [<em>L</em>]<sup>′</sup>[<em>x</em>] with a new unknown vector [<em>y</em>]:</p>&#13;
<div class="equationc"><img src="../images/f0368-02.jpg" alt="Image"/></div>&#13;
<p class="noindent">This results in the first system (the lower system):</p>&#13;
<div class="equationc"><img src="../images/f0368-03.jpg" alt="Image"/></div>&#13;
<p class="noindent">We have to solve this system using the forward-substitution formula from <a href="ch14.xhtml#ch14eqa09">Equation 14.9</a>.</p>&#13;
<h5 class="h5" id="ch00lev3sec65"><strong>Lower System: Forward Substitution</strong></h5>&#13;
<p class="noindent">Let’s apply <a href="ch14.xhtml#ch14eqa09">Equation 14.9</a> step-by-step:</p>&#13;
<p class="indent"><strong>Step 1:</strong> <em>i</em> = 0.</p>&#13;
<div class="equationc"><img src="../images/f0368-04.jpg" alt="Image"/></div>&#13;
<p class="indent"><strong>Step 2:</strong> <em>i</em> = 1.</p>&#13;
<div class="equationc"><img src="../images/f0368-05.jpg" alt="Image"/></div>&#13;
<p class="indent"><strong>Step 3:</strong> <em>i</em> = 2.</p>&#13;
<div class="equationc"><img src="../images/f0368-06.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_369"/>Thus, the solution for the first system is as follows:</p>&#13;
<div class="equationc"><img src="../images/f0369-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">With this solution, we can use backward substitution to compute [<em>x</em>]: the solution to our system of equations.</p>&#13;
<h5 class="h5" id="ch00lev3sec66"><strong>Upper System: Backward Substitution</strong></h5>&#13;
<p class="noindent">Let’s use <a href="ch14.xhtml#ch14eqa10">Equation 14.10</a> to compute the solution vector step-by-step. This time we have to solve the following system using the backward-substitution process:</p>&#13;
<div class="equationc"><img src="../images/f0369-02.jpg" alt="Image"/></div>&#13;
<p class="indent">Since the substitution is backward, we have to start from the last row (<em>i</em> = 2) and go up to the first one (<em>i</em> = 0).</p>&#13;
<p class="indent"><strong>Step 1:</strong> <em>i</em> = 2.</p>&#13;
<div class="equationc"><img src="../images/f0369-03.jpg" alt="Image"/></div>&#13;
<p class="indent"><strong>Step 2:</strong> <em>i</em> = 1.</p>&#13;
<div class="equationc"><img src="../images/f0369-04.jpg" alt="Image"/></div>&#13;
<p class="indent"><strong>Step 3:</strong> <em>i</em> = 0.</p>&#13;
<div class="equationc"><img src="../images/f0369-05.jpg" alt="Image"/></div>&#13;
<p class="indent">Then, the solution to the initial system is as follows:</p>&#13;
<div class="equationc"><img src="../images/f0369-06.jpg" alt="Image"/></div>&#13;
<p class="indent">You can test if the solution is correct by checking if the equality holds:</p>&#13;
<div class="equationc"><img src="../images/f0369-07.jpg" alt="Image"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_370"/>Now that we know how the Cholesky algorithm works and we’ve worked out an example by hand, let’s implement the algorithm in our code.</p>&#13;
<h4 class="h4" id="ch00lev2sec154"><strong><em>Implementing Cholesky</em></strong></h4>&#13;
<p class="noindent">Start by creating a new file in the <em>eqs</em> package named <em>cholesky.py</em>. In it, include the <span class="literal">cholesky_solve</span> function in <a href="ch14.xhtml#ch14lis1">Listing 14-1</a>.</p>&#13;
<pre>import math&#13;
&#13;
from eqs.matrix import Matrix&#13;
from eqs.vector import Vector&#13;
&#13;
&#13;
def cholesky_solve(sys_mat: Matrix, sys_vec: Vector):&#13;
    validate_system(sys_mat, sys_vec)&#13;
&#13;
    low_matrix = lower_matrix_decomposition(sys_mat)&#13;
    low_solution = solve_lower_sys(low_matrix, sys_vec)&#13;
    return solve_upper_sys(low_matrix, low_solution)</pre>&#13;
<p class="caption"><a id="ch14lis1"/><em>Listing 14-1: Cholesky decomposition algorithm</em></p>&#13;
<p class="indent">This function takes a <span class="literal">Matrix</span> and a <span class="literal">Vector</span> as inputs. These are the coefficient matrix and free vector of a system: the [<em>M</em>] and the [<em>b</em>] from the system of equations [<em>M</em>][<em>x</em>] = [<em>b</em>]. The returned <span class="literal">Vector</span> is [<em>x</em>], the solution to the system found applying Cholesky’s method.</p>&#13;
<p class="indent">This <span class="literal">cholesky_solve</span> function defines the highest-level algorithm, which has three main steps plus a validation of the input system. We haven’t implemented any of these functions yet; we’ll get to this shortly. The following are the three main steps to the algorithm:</p>&#13;
<div class="bqparan">&#13;
<p class="noindent"><span class="codestrong">lower_matrix_decomposition</span> Obtain [<em>L</em>], the lower-triangular matrix, by applying <a href="ch14.xhtml#ch14eqa15">Equation 14.15</a>.</p>&#13;
<p class="noindent"><span class="codestrong">solve_lower_sys</span> Solve the first subsystem, the lower-triangular system, by applying the forward-substitution technique (see <a href="ch14.xhtml#ch14eqa09">Equation 14.9</a>).</p>&#13;
<p class="noindent"><span class="codestrong">solve_upper_sys</span> Solve the second subsystem, the upper-triangular system, by applying the backward-substitution technique (see <a href="ch14.xhtml#ch14eqa10">Equation 14.10</a>).</p>&#13;
</div>&#13;
<p class="indent">From the function names, it’s easy enough to see what the code in <span class="literal">cholesky</span> <span class="literal">_solve</span> is doing. Note that we broke the function into several smaller functions. If we had thrown all the code for the Cholesky resolution into the <span class="literal">cholesky_solve</span> function, the result would be a long pile of source code with no readily identifiable structure. This code would be extremely hard to understand.</p>&#13;
<p class="indent">As a general rule, you want to divide your big algorithms into smaller subalgorithms, each contained in a small function with a descriptive name.</p>&#13;
<p class="indent">Notice the visibility of the subfunctions used by <span class="literal">cholesky_solve</span>. All the subfunctions are public. This is so that they can be unit tested individually. <span epub:type="pagebreak" id="page_371"/>The resolution algorithm is a bit complex; we’re safer if we know that each of its subparts does its job without errors.</p>&#13;
<h5 class="h5" id="ch00lev3sec67"><strong>Validating the System</strong></h5>&#13;
<p class="noindent">Let’s implement a function that validates that the system is square and has a number of columns equal to the size of the vector. Enter the code for the <span class="literal">validate_system</span> function, found in <a href="ch14.xhtml#ch14lis2">Listing 14-2</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def validate_system(sys_matrix: Matrix, sys_vector: Vector):&#13;
    if sys_matrix.cols_count != sys_vector.length:&#13;
        raise ValueError('Size mismatch between matrix and vector')&#13;
&#13;
    if not sys_matrix.is_square:&#13;
        raise ValueError('System matrix must be square')</pre>&#13;
<p class="caption"><a id="ch14lis2"/><em>Listing 14-2: System validation</em></p>&#13;
<p class="indent">We first check that the matrix has the same number columns as the vector’s length. If this condition isn’t satisfied, the system can’t be solved, so we raise an error. The same applies if the system’s matrix is not square.</p>&#13;
<p class="indent">We’re not doing any check to ensure the matrix is symmetric or positive definite; if the matrix passed to our function isn’t, the function will simply fail at some point with a by-zero division error or something similar. It’d be a nice idea to add those guards, at least the check for symmetry, but checking that the system’s matrix is positive definite may be more challenging. The symmetry check is easy to implement, but it has the downside of being computationally expensive. I encourage you to think about ways of doing these checks and maybe add them in your code.</p>&#13;
<p class="indent">Now we’re going to do something a little backward. We’re going to start with a unit test instead of the code itself. This is so that we know when our code is ready: once the tests pass. We can keep running the test to check whether the logic we’re writing is ready or not; we can refactor it until it looks readable, with the safety net of the test that will warn us if we did something wrong. This technique where the test is written before the code is known as <em>test-driven development</em>, or TDD for short.</p>&#13;
<p class="indent">We’ll start by looking at the system of equations we’ll use in the unit tests.</p>&#13;
<h5 class="h5" id="ch00lev3sec68"><strong>System of Equations for Testing</strong></h5>&#13;
<p class="noindent">To make sure we implement all the logic without bugs, we’re going to use tests for each of the subfunctions in the Cholesky algorithm. We’ll also implement a test to check that all the subfunctions work together to compute the final solution. For these tests we want to use a system of equations whose solution we know in advance.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_372"/>Let’s use the following size 4 system:</p>&#13;
<div class="equationc"><img src="../images/f0372-01.jpg" alt="Image"/></div>&#13;
<p class="indent">For this system’s matrix [<em>M</em>], the Cholesky [<em>L</em>][<em>L</em>]<sup>′</sup> factorization is as follows:</p>&#13;
<div class="equationc"><img src="../images/f0372-02.jpg" alt="Image"/></div>&#13;
<p class="noindent">The solution of the lower system,</p>&#13;
<div class="equationc"><img src="../images/f0372-03.jpg" alt="Image"/></div>&#13;
<p class="noindent">is the following vector:</p>&#13;
<div class="equationc"><img src="../images/f0372-04.jpg" alt="Image"/></div>&#13;
<p class="noindent">The final solution, resulting from the resolution of the upper system,</p>&#13;
<div class="equationc"><img src="../images/f0372-05.jpg" alt="Image"/></div>&#13;
<p class="noindent">is the following vector:</p>&#13;
<div class="equationc"><img src="../images/f0372-06.jpg" alt="Image"/></div>&#13;
<p class="indent">It’s a good idea to take some time to check all those numbers and make sure you understand the resolution process. Once you’re solid on the fundamentals of the process, let’s code it up, starting with a unit test.</p>&#13;
<h5 class="h5" id="ch00lev3sec69"><strong>Lower Matrix Factorization</strong></h5>&#13;
<p class="noindent">As we’re about to implement the most complex algorithm in the book so far, let’s first write a unit test. We’ll know our factorization logic is well implemented once the test passes. Chances are we’ll need to debug our code, and having a test will help.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_373"/>Create a new file for our test, <em>cholesky_test.py</em>, and place it inside the <em>eqs/tests</em> directory. Then enter the test code in <a href="ch14.xhtml#ch14lis3">Listing 14-3</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from eqs.cholesky import lower_matrix_decomposition&#13;
from eqs.matrix import Matrix&#13;
&#13;
&#13;
class CholeskyTest(unittest.TestCase):&#13;
    sys_matrix = Matrix(4, 4).set_data([&#13;
        4, -2, 4, 2,&#13;
        -2, 10, -2, -7,&#13;
        4, -2, 8, 4,&#13;
        2, -7, 4, 7&#13;
    ])&#13;
    low_matrix = Matrix(4, 4).set_data([&#13;
        2, 0, 0, 0,&#13;
        -1, 3, 0, 0,&#13;
        2, 0, 2, 0,&#13;
        1, -2, 1, 1&#13;
    ])&#13;
&#13;
    def test_lower_matrix_decomposition(self):&#13;
        actual = lower_matrix_decomposition(self.sys_matrix)&#13;
        self.assertEqual(self.low_matrix, actual)</pre>&#13;
<p class="caption"><a id="ch14lis3"/><em>Listing 14-3: Testing the lower matrix factorization</em></p>&#13;
<p class="indent">This test defines both the original matrix, <span class="literal">sys_matrix</span>, and the expected decomposition, <span class="literal">low_matrix</span>. Using a function we haven’t defined yet, <span class="literal">lower</span> <span class="literal">_matrix_decomposition</span>, we compute the decomposition matrix and compare it against the known solution. Your IDE should complain that you’re trying to import a function it can’t find in the <em>eqs.cholesky</em> module:</p>&#13;
<p class="pre2">    Cannot find reference 'lower_matrix_decomposition' in 'cholesky.py'</p>&#13;
<p class="indent">Let’s implement the function. Go back to the <em>cholesky.py</em> file, and after <span class="literal">validate_system</span>, enter the code in <a href="ch14.xhtml#ch14lis4">Listing 14-4</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def lower_matrix_decomposition(sys_mat: Matrix):&#13;
    size = sys_mat.rows_count&#13;
    low_mat = Matrix(size, size)&#13;
&#13;
    for i in range(size):&#13;
        sq_sum = 0&#13;
&#13;
        for j in range(i + 1): <span epub:type="pagebreak" id="page_374"/>&#13;
         <span class="ent">➊</span> m_ij = sys_mat.value_at(i, j)&#13;
&#13;
           if i == j:&#13;
               # main diagonal value&#13;
            <span class="ent">➋</span> diag_val = math.sqrt(m_ij - sq_sum)&#13;
            <span class="ent">➌</span> low_mat.set_value(diag_val, i, j)&#13;
&#13;
           else:&#13;
               # value under main diagonal&#13;
               non_diag_sum = 0&#13;
            <span class="ent">➍</span> for k in range(j):&#13;
                   l_ik = low_mat.value_at(i, k)&#13;
                   l_jk = low_mat.value_at(j, k)&#13;
                   non_diag_sum += l_ik * l_jk&#13;
&#13;
               l_jj = low_mat.value_at(j, j)&#13;
            <span class="ent">➎</span> non_diag_val = (m_ij - non_diag_sum) / l_jj&#13;
            <span class="ent">➏</span> sq_sum += non_diag_val * non_diag_val&#13;
&#13;
            <span class="ent">➐</span> low_mat.set_value(non_diag_val, i, j)&#13;
&#13;
    return low_mat</pre>&#13;
<p class="caption"><a id="ch14lis4"/><em>Listing 14-4: Lower matrix decomposition</em></p>&#13;
<p class="indent">We start by storing the size of the system in a variable named <span class="literal">size</span>. The size is the number of rows or columns—it doesn’t matter which since the matrix is square. Then we create a new square matrix, <span class="literal">low_mat</span>, of that same size. Recall that our matrices are filled with zeros when they’re instantiated.</p>&#13;
<p class="indent">The algorithm has two main nested loops. These loops iterate through all the positions in the matrix that are in the main diagonal and below it, that is, all <em>m</em><sub><em>i,j</em></sub> where <em>i</em> ≥ <em>j</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Don’t forget that Python’s</em> <span class="literal">range(n)</span> <em>function generates a sequence starting from 0 up to</em> n <em>– 1, not</em> n.</p>&#13;
</div>&#13;
<p class="indent">Inside the <span class="literal">j</span> loop, we store the value of the system’s matrix at position (<em>i,j</em>) in <span class="literal">m_ij</span> <span class="ent">➊</span>. Then, we distinguish between the case where we’re on the main diagonal (<span class="literal">i == j</span>) or below it using an <span class="literal">if else</span> statement. Recall that the formula to compute a term in the main diagonal of the decomposition matrix is as follows:</p>&#13;
<div class="equationc"><img src="../images/f0374-01.jpg" alt="Image"/></div>&#13;
<p class="indent">We used that expression to compute the value, which we store in <span class="literal">diag</span> <span class="literal">_val</span> <span class="ent">➋</span> and set in the matrix <span class="ent">➌</span>. In the calculation we used the <span class="literal">m_ij</span> value and <span class="literal">sq_sum</span>. The latter is initialized as 0 for every new iteration of <em>i</em> (for each row) and updated for every new value below the main diagonal <span class="ent">➏</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_375"/>For the case where we’re under the main diagonal (<span class="literal">i &gt; j</span>, the <span class="literal">else</span> branch), the formula to compute the <em>l</em><sub><em>i,j</em></sub> term is as follows:</p>&#13;
<div class="equationc"><img src="../images/f0375-01.jpg" alt="Image"/></div>&#13;
<p class="indent">Note that to compute this <em>l</em><sub><em>i,j</em></sub> value, we need to have <em>l</em><sub><em>j,j</em></sub>, which is a value from a previous row since <em>i</em> &gt; <em>j</em>. The first term that we compute is the sum of <em>l</em><sub><em>i,k</em></sub><em>l</em><sub><em>j,k</em></sub> with <em>k</em> going from 0 to <em>j –</em> 1. The loop in <span class="ent">➍</span> does exactly this. Before entering the loop, we initialize a variable <span class="literal">non_diag_sum</span> to zero. Inside the loop this variable gets added to the product of <span class="literal">l_ik</span> and <span class="literal">l_jk</span> for every value of <em>k</em>.</p>&#13;
<p class="indent">With <span class="literal">non_diag_sum</span> computed, we have everything we need. The value of <em>l</em><sub><em>j,j</em></sub> is extracted from <span class="literal">low_mat</span> and stored in variable <span class="literal">l_jj</span>. Then the value for the decomposition is computed and stored in variable <span class="literal">non_diag_val</span> <span class="ent">➎</span>. This value is first used to update the <span class="literal">sq_sum</span> <span class="ent">➏</span> and then stored in the decomposition matrix <span class="ent">➐</span>.</p>&#13;
<p class="indent">That’s it. Run the test we wrote earlier and make sure your code passes it. Don’t worry if it doesn’t; in fact, it’s a bit hard to get this algorithm right the first time you write it, but that’s exactly why we implemented the test first. Use the test to debug the code and carefully compare what you wrote with the printed version of the code in this book. You can also refer to the code distributed with the book.</p>&#13;
<p class="indent">To run the test in the shell, use this:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest eqs/tests/cholesky_test.py</span></pre>&#13;
<p class="indent">We’ve obtained the [<em>L</em>] decomposition matrix using Cholesky’s algorithm. Let’s now implement the resolution of the lower and upper systems.</p>&#13;
<h5 class="h5" id="ch00lev3sec70"><strong>Lower System Resolution</strong></h5>&#13;
<p class="noindent">To solve the lower-triangular system using forward substitution, we need to implement the algorithm in <a href="ch14.xhtml#ch14eqa09">Equation 14.9</a>. We’ll repeat the formula here for convenience:</p>&#13;
<div class="equationc"><img src="../images/f0375-02.jpg" alt="Image"/></div>&#13;
<p class="indent">We’re going to follow the same approach as before and write the test before we write the main code. In the <em>cholesky_test.py</em> file, enter the new test in <a href="ch14.xhtml#ch14lis5">Listing 14-5</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from eqs.cholesky import lower_matrix_decomposition, \&#13;
    <span class="codestrong1">solve_lower_sys</span>&#13;
from eqs.matrix import Matrix&#13;
from eqs.vector import Vector&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_376"/>class CholeskyTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
  <span class="ent">➊</span> sys_vec = Vector(4).set_data([20, -16, 40, 28])&#13;
  <span class="ent">➋</span> low_solution = Vector(4).set_data([10, -2, 10, 4])&#13;
&#13;
    def test_lower_matrix_decomposition(self):&#13;
        actual = lower_matrix_decomposition(self.sys_matrix)&#13;
        self.assertEqual(self.low_matrix, actual)&#13;
&#13;
  <span class="ent">➌</span> def test_lower_system_resolution(self):&#13;
        actual = solve_lower_sys(self.low_matrix, self.sys_vec)&#13;
        self.assertEqual(self.low_solution, actual)</pre>&#13;
<p class="caption"><a id="ch14lis5"/><em>Listing 14-5: Testing the lower system resolution</em></p>&#13;
<p class="indent">We’ve first imported the <span class="literal">Vector</span> class from <span class="literal">eqs.vector</span>. Then we’ve added two new vectors that we need for the new test: <span class="literal">sys_vec</span> <span class="ent">➊</span>, which is the free vector of the system of equations, and <span class="literal">low_solution</span> <span class="ent">➋</span>, the expected solution for the lower-triangular system.</p>&#13;
<p class="indent">With the test in place <span class="ent">➌</span>, let’s now implement the missing <span class="literal">solve_lower_sys</span> function. After the factorization function in the <em>cholesky.py</em> file, enter the code in <a href="ch14.xhtml#ch14lis6">Listing 14-6</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def solve_lower_sys(low_mat: Matrix, vector: Vector):&#13;
    size = vector.length&#13;
    solution = Vector(size)&#13;
&#13;
 <span class="ent">➊</span> for i in range(size):&#13;
        _sum = 0.0&#13;
&#13;
     <span class="ent">➋</span> for j in range(i):&#13;
            l_ij = low_mat.value_at(i, j)&#13;
            y_j = solution.value_at(j)&#13;
            _sum += l_ij * y_j&#13;
&#13;
        b_i = vector.value_at(i)&#13;
        l_ii = low_mat.value_at(i, i)&#13;
     <span class="ent">➌</span> solution_val = (b_i - _sum) / l_ii&#13;
        solution.set_value(solution_val, i)&#13;
&#13;
    return solution</pre>&#13;
<p class="caption"><a id="ch14lis6"/><em>Listing 14-6: Solving the lower system</em></p>&#13;
<p class="indent">The first thing we do is save the size of the system in a variable <span class="literal">size</span> and create the solution vector of that size. The main loop that iterates through <span epub:type="pagebreak" id="page_377"/>all values in the <span class="literal">sys_vector</span> is the <span class="literal">i</span> loop <span class="ent">➊</span>. In it, we start by initializing a sum to zero. The <span class="literal">j</span> loop <span class="ent">➋</span> iterates through all values from 0 to <em>i –</em> 1, updating the sum for each iteration.</p>&#13;
<p class="indent">Having obtained the sum part of the equation, we can compute the solution value, which is stored in <span class="literal">solution_val</span> <span class="ent">➌</span>. Then we set in the <span class="literal">solution</span> vector in the next line.</p>&#13;
<p class="indent">Run the two tests in <em>cholesky_test.py</em> to make sure both pass. It seems reasonable that the first one will pass: we haven’t modified the factorization function in any way, but it’s good practice to run all tests in the file, just in case we modified something that we shouldn’t have. I hope the second test also passes for you, in which case you got the new function right! You’ll need to debug your code otherwise. Take your time to do so; it’s a great exercise.</p>&#13;
<p class="indent">To run the tests from the shell, use this:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest eqs/tests/cholesky_test.py</span></pre>&#13;
<p class="indent">Let’s now work out the upper system resolution.</p>&#13;
<h5 class="h5" id="ch00lev3sec71"><strong>Upper System Resolution</strong></h5>&#13;
<p class="noindent">The resolution of the upper-triangular system using backward substitution can be carried out using <a href="ch14.xhtml#ch14eqa10">Equation 14.10</a>. As a reminder, the formula is as follows:</p>&#13;
<div class="equationc"><img src="../images/f0377-01.jpg" alt="Image"/></div>&#13;
<p class="indent">One important thing to recall is that the upper-triangular matrix [<em>U</em>], with values <em>u</em><sub><em>i,j</em></sub>, is the transpose of Cholesky’s lower-triangular decomposition: [<em>L</em>]<sup>′</sup>.</p>&#13;
<p class="indent">Once again we’ll start with the test. Open your <em>cholesky_test.py</em> file and enter the new test in <a href="ch14.xhtml#ch14lis7">Listing 14-7</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from eqs.cholesky import lower_matrix_decomposition, \&#13;
    solve_lower_sys, <span class="codestrong1">solve_upper_sys</span>&#13;
from eqs.matrix import Matrix&#13;
from eqs.vector import Vector&#13;
&#13;
&#13;
class CholeskyTest(unittest.TestCase):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
 <span class="ent">➊</span> solution = Vector(4).set_data([1, 2, 3, 4])&#13;
&#13;
    def test_lower_matrix_decomposition(self):&#13;
        actual = lower_matrix_decomposition(self.sys_matrix)&#13;
        self.assertEqual(self.low_matrix, actual)&#13;
&#13;
    <span epub:type="pagebreak" id="page_378"/>def test_lower_system_resolution(self):&#13;
        actual = solve_lower_sys(self.low_matrix, self.sys_vec)&#13;
        self.assertEqual(self.low_solution, actual)&#13;
&#13;
 <span class="ent">➋</span> def test_upper_system_resolution(self):&#13;
        actual = solve_upper_sys(&#13;
            self.low_matrix,&#13;
            self.low_solution&#13;
        )&#13;
        self.assertEqual(self.solution, actual)</pre>&#13;
<p class="caption"><a id="ch14lis7"/><em>Listing 14-7: Testing the upper system resolution</em></p>&#13;
<p class="indent">In this new test <span class="ent">➋</span>, we call <span class="literal">solve_upper_sys</span> (still to be written), passing it in both the factorized matrix <span class="literal">low_matrix</span> and the lower system solution <span class="literal">low_solution</span>. Then, we assert that the vector we get returned is the one we expect, which we’ve defined as part of the test’s data in the <span class="literal">solution</span> variable <span class="ent">➊</span>.</p>&#13;
<p class="indent">We’re now ready to implement the last part to complete Cholesky’s method: the resolution of the upper system. Open the <em>cholesky.py</em> file again and enter the <span class="literal">solve_upper_sys</span> function in <a href="ch14.xhtml#ch14lis8">Listing 14-8</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def solve_upper_sys(up_matrix: Matrix, vector: Vector):&#13;
    size = vector.length&#13;
    last_index = size - 1&#13;
    solution = Vector(size)&#13;
&#13;
 <span class="ent">➊</span> for i in range(last_index, -1, -1):&#13;
        _sum = 0.0&#13;
&#13;
     <span class="ent">➋</span> for j in range(i + 1, size):&#13;
         <span class="ent">➌</span> u_ij = up_matrix.value_transposed_at(i, j)&#13;
            x_j = solution.value_at(j)&#13;
            _sum += u_ij * x_j&#13;
&#13;
        y_i = vector.value_at(i)&#13;
     <span class="ent">➍</span> u_ii = up_matrix.value_transposed_at(i, i)&#13;
     <span class="ent">➎</span> solution_val = (y_i - _sum) / u_ii&#13;
        solution.set_value(solution_val, i)&#13;
&#13;
    return solution</pre>&#13;
<p class="caption"><a id="ch14lis8"/><em>Listing 14-8: Solving the upper system</em></p>&#13;
<p class="indent">This function is similar to the previous <span class="literal">solve_lower_sys</span> function. We start by initializing the solution vector, <span class="literal">solution</span>, with the same size as the passed-in <span epub:type="pagebreak" id="page_379"/><span class="literal">low_vector</span>. This time, as we’ll iterate starting from the last row, we save its index in the <span class="literal">last_index</span> variable.</p>&#13;
<p class="indent">The loop that iterates through all row indices goes from <span class="literal">last_index</span> all the way down to –1 (noninclusive) <span class="ent">➊</span>. The inner loop going from <em>i</em> + 1 to <span class="literal">size</span> (again, noninclusive) computes the sum of the <em>u</em><sub><em>i,j</em></sub><em>x</em><sub><em>j</em></sub> products <span class="ent">➋</span>. To obtain <span class="literal">u_ij</span>, we ask the lower-triangular matrix for the value as if it were transposed <span class="ent">➌</span>. Thanks to this neat trick, we avoid transposing [<em>L</em>], a process that is computationally expensive. This is the optimization we talked about in the previous chapter.</p>&#13;
<p class="indent">To get the divisor in <a href="ch14.xhtml#ch14eqa10">Equation 14.10</a>, we use the <span class="literal">value_transposed_at</span> function again <span class="ent">➍</span>. With this value we can already compute the solution at each row <span class="ent">➎</span> and store it in the result vector.</p>&#13;
<p class="indent">Run all the tests in the file to check whether the implementation is bug-free. Just for your reference, <a href="ch14.xhtml#ch14lis9">Listing 14-9</a> is the complete <em>cholesky.py</em>.</p>&#13;
<pre>import math&#13;
&#13;
from eqs.matrix import Matrix&#13;
from eqs.vector import Vector&#13;
&#13;
&#13;
def cholesky_solve(sys_mat: Matrix, sys_vec: Vector) -&gt; Vector:&#13;
    validate_system(sys_mat, sys_vec)&#13;
&#13;
    low_matrix = lower_matrix_decomposition(sys_mat)&#13;
    low_solution = solve_lower_sys(low_matrix, sys_vec)&#13;
    return solve_upper_sys(low_matrix, low_solution)&#13;
&#13;
&#13;
def validate_system(sys_matrix: Matrix, sys_vector: Vector):&#13;
    if sys_matrix.cols_count != sys_vector.length:&#13;
        raise ValueError('Size mismatch between matrix and vector')&#13;
&#13;
    if not sys_matrix.is_square:&#13;
        raise ValueError('System matrix must be square')&#13;
&#13;
&#13;
def lower_matrix_decomposition(sys_mat: Matrix) -&gt; Matrix:&#13;
    size = sys_mat.rows_count&#13;
    low_mat = Matrix(size, size)&#13;
&#13;
    for i in range(size):&#13;
        sq_sum = 0&#13;
&#13;
        for j in range(i + 1):&#13;
            m_ij = sys_mat.value_at(i, j)&#13;
&#13;
            if i == j:&#13;
                <span epub:type="pagebreak" id="page_380"/># main diagonal value&#13;
                diag_val = math.sqrt(m_ij - sq_sum)&#13;
                low_mat.set_value(diag_val, i, j)&#13;
&#13;
            else:&#13;
                # value under main diagonal&#13;
                non_diag_sum = 0&#13;
                for k in range(j):&#13;
                    l_ik = low_mat.value_at(i, k)&#13;
                    l_jk = low_mat.value_at(j, k)&#13;
                    non_diag_sum += l_ik * l_jk&#13;
&#13;
                l_jj = low_mat.value_at(j, j)&#13;
                non_diag_val = (m_ij - non_diag_sum) / l_jj&#13;
                sq_sum += non_diag_val * non_diag_val&#13;
&#13;
                low_mat.set_value(non_diag_val, i, j)&#13;
&#13;
    return low_mat&#13;
&#13;
&#13;
def solve_lower_sys(low_mat: Matrix, vector: Vector):&#13;
    size = vector.length&#13;
    solution = Vector(size)&#13;
&#13;
    for i in range(size):&#13;
        _sum = 0.0&#13;
&#13;
        for j in range(i):&#13;
            l_ij = low_mat.value_at(i, j)&#13;
            y_j = solution.value_at(j)&#13;
            _sum += l_ij * y_j&#13;
&#13;
        b_i = vector.value_at(i)&#13;
        l_ii = low_mat.value_at(i, i)&#13;
        solution_val = (b_i - _sum) / l_ii&#13;
        solution.set_value(solution_val, i)&#13;
&#13;
    return solution&#13;
&#13;
&#13;
def solve_upper_sys(up_matrix: Matrix, vector: Vector):&#13;
    size = vector.length&#13;
    last_index = size - 1&#13;
    solution = Vector(size)&#13;
&#13;
    for i in range(last_index, -1, -1):&#13;
        <span epub:type="pagebreak" id="page_381"/>_sum = 0.0&#13;
&#13;
        for j in range(i + 1, size):&#13;
            u_ij = up_matrix.value_transposed_at(i, j)&#13;
            x_j = solution.value_at(j)&#13;
            _sum += u_ij * x_j&#13;
&#13;
        y_i = vector.value_at(i)&#13;
        u_ii = up_matrix.value_transposed_at(i, i)&#13;
        solution_val = (y_i - _sum) / u_ii&#13;
        solution.set_value(solution_val, i)&#13;
&#13;
    return solution</pre>&#13;
<p class="caption"><a id="ch14lis9"/><em>Listing 14-9: Cholesky method result</em></p>&#13;
<p class="indent">Each of the three subfunctions that take part in the resolution of a system of equations using Cholesky’s method has been tested separately: we can be sure those work properly. Does this mean that the <span class="literal">cholesky_solve</span> function is free of bugs itself? Not necessarily. We may still make mistakes when putting all those well-tested functions together.</p>&#13;
<p class="indent">Checking that the <span class="literal">cholesky_solve</span> function works as a whole requires one more test. This a test that ensures that each of the subfunctions behaves well when combined; it’s called an <em>integration test</em>.</p>&#13;
<h4 class="h4" id="ch00lev2sec155"><strong><em>Testing Cholesky: An Integration Test</em></strong></h4>&#13;
<p class="noindent">Open your <em>cholesky_test.py</em> file one last time. Let’s add a final test (shown in <a href="ch14.xhtml#ch14lis10">Listing 14-10</a>).</p>&#13;
<pre>import unittest&#13;
&#13;
from eqs.cholesky import lower_matrix_decomposition, \&#13;
    solve_lower_sys, solve_upper_sys, <span class="codestrong1">cholesky_solve</span>&#13;
from eqs.matrix import Matrix&#13;
from eqs.vector import Vector&#13;
&#13;
&#13;
class CholeskyTest(unittest.TestCase):&#13;
    sys_matrix = Matrix(4, 4).set_data([&#13;
        4, -2, 4, 2,&#13;
        -2, 10, -2, -7,&#13;
        4, -2, 8, 4,&#13;
        2, -7, 4, 7&#13;
    ])&#13;
    low_matrix = Matrix(4, 4).set_data([&#13;
        2, 0, 0, 0,&#13;
        -1, 3, 0, 0,&#13;
        2, 0, 2, 0,&#13;
        <span epub:type="pagebreak" id="page_382"/>1, -2, 1, 1&#13;
    ])&#13;
    sys_vec = Vector(4).set_data([20, -16, 40, 28])&#13;
    low_solution = Vector(4).set_data([10, -2, 10, 4])&#13;
    solution = Vector(4).set_data([1, 2, 3, 4])&#13;
&#13;
    def test_lower_matrix_decomposition(self):&#13;
        actual = lower_matrix_decomposition(self.sys_matrix)&#13;
        self.assertEqual(self.low_matrix, actual)&#13;
&#13;
    def test_lower_system_resolution(self):&#13;
        actual = solve_lower_sys(self.low_matrix, self.sys_vec)&#13;
        self.assertEqual(self.low_solution, actual)&#13;
&#13;
    def test_upper_system_resolution(self):&#13;
        actual = solve_upper_sys(&#13;
            self.low_matrix,&#13;
            self.low_solution&#13;
        )&#13;
        self.assertEqual(self.solution, actual)&#13;
&#13;
    def test_solve_system(self):&#13;
        actual = cholesky_solve(self.sys_matrix, self.sys_vec)&#13;
        self.assertEqual(self.solution, actual)</pre>&#13;
<p class="caption"><a id="ch14lis10"/><em>Listing 14-10: Testing the Cholesky decomposition method</em></p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14lis10">Listing 14-10</a> is the resulting test file. We included the last test: <span class="literal">test_solve</span> <span class="literal">_system</span>. This test exercises the Cholesky algorithm as a whole by calling <span class="literal">cholesky_solve</span>.</p>&#13;
<p class="indent">Run all the tests in the file. If all four tests pass, you got all the code right. You should be proud of yourself for following along with the code in this long chapter. Congratulations!</p>&#13;
<p class="indent">If you want to run the tests from the command line, use this:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest eqs/tests/cholesky_test.py</span></pre>&#13;
<h3 class="h3" id="ch00lev1sec86"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we discussed numerical methods and then centered the discussion around those that solve linear systems of equations. In particular, we analyzed the Cholesky decomposition method. This [<em>L</em>][<em>U</em>] decomposition algorithm works with symmetric, positive-definite matrices and can be twice as fast as other [<em>L</em>][<em>U</em>] alternatives.</p>&#13;
<p class="indent">We paid special attention to the code’s readability. To make the algorithm easy to follow, we broke it down into smaller functions, each of which was tested separately. We started writing the test before the main algorithm’s <span epub:type="pagebreak" id="page_383"/>logic, a technique referred to as test-driven development. We included one last test integrating the complete resolution of a system of equations.</p>&#13;
<p class="indent">We’ve implemented a powerful resolution algorithm, and we’ll put it to work in <a href="part05.xhtml#part05">Part V</a> of the book.<span epub:type="pagebreak" id="page_384"/></p>&#13;
</body></html>