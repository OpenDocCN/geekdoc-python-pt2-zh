- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a book about computational thinking through the lens of *data structures*,
    constructs for organizing and storing data. It is more than a cookbook of handy
    data structures. Rather, it explores the thinking behind these structures and
    their fundamental impact on solving complex problems, using real-world analogies
    to make abstract computational concepts intuitive. The goal of this book is to
    provide new insights into how you can use preexisting structure within the data
    to your advantage or create new structures to efficiently solve problems.
  prefs: []
  type: TYPE_NORMAL
- en: Among other things, I discuss the differences between arrays and linked lists,
    the complexity and power of pointers, the effect of data structures on algorithmic
    behavior, the branching of tree-based data structures, mathematical mappings in
    hash tables, and the usefulness of randomization. In short, you’ll learn to think
    about algorithms by investigating different ways to organize the data they process.
    You’ll also apply these computational approaches to real-world problems, a surprising
    number of which focus on procuring a decent cup of coffee.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how data structures function is critical to using them effectively.
    Just as an experienced carpenter wouldn’t pound screws into wood with a hammer
    or use sandpaper to cut a two-by-four in half, an experienced programmer needs
    to choose the right tools for every job. As we’ll see repeatedly throughout the
    following chapters, every data structure comes with tradeoffs. Saws cut through
    wood more effectively than sandpaper but create coarse edges. There is no single
    data structure that is perfect for every possible use case, but this is what makes
    computer science and the development of algorithms so interesting. A good computer
    scientist must understand how different data structures behave in order to determine
    where they can be best used.
  prefs: []
  type: TYPE_NORMAL
- en: This book focuses on a few canonical data structures and uses them to explore
    fundamental themes in computational thinking. Each of these data structures is
    a useful exemplar of a more general class of data structures and of a conceptual
    approach. For example, B-trees demonstrate one approach to the problems of keeping
    search trees balanced and optimizing for expensive memory accesses. I discuss
    the tradeoffs between memory usage and accuracy with Bloom filters; the use of
    randomization with skip lists; and how to capture multidimensional structure with
    grids, quadtrees, or k-d trees. As such, this book is neither an introduction
    to programming, a comprehensive anthology of data structures, nor a full analysis
    of brewing coffee (although we will touch repeatedly on this important topic).
    Our goals are different—to develop mental tools that apply across a range of specific
    problems and programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Intended Audience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book is for anyone who wants to learn more about the thinking behind the
    data structures that lie at the heart of computer science. I assume such basic
    familiarity with programming as can be expected after taking an introductory course,
    participating in a boot camp, or working through a beginners’ programming book.
    Readers should be familiar with fundamental programming concepts such as variables,
    loops, and conditional statements. Some more adventurous readers might even have
    coded up some of the data structures or algorithms in this book already or might
    do so as they read through it. However, you won’t need to know the specific details
    of particular programming languages or algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this book appeals to a wide range of audiences. Practitioners who have
    learned basic programming from an introductory course will find an introduction
    to computational thinking that can provide a foundation for future investigation.
    Students will find a new way to understand particularly difficult or tricky topics.
    Mathematicians will learn new names and jargon for ideas they’ve used since well
    before computer science existed. And experienced computer scientists will find
    amusing new analogies to explain concepts they use every day.
  prefs: []
  type: TYPE_NORMAL
- en: Language-Agnostic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book is designed to apply to a wide range of programming languages. While
    this might come as a disappointment to the more opinionated readers who want to
    either (a) see their favorite language featured throughout these pages or (b)
    argue about the author’s terrible language preferences and how they must reflect
    suboptimal life choices (since programming languages, like sports teams, are always
    a topic for heated debate), the concepts presented in the book are generally applicable
    across a range of languages. You can implement a binary search tree in almost
    any language, for instance. In fact, most programming languages already include
    many of these basic data structures as part of their core language or a standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: The book uses pseudocode examples that are largely based on Python’s general
    syntax, since Python is a widely used and easily readable programming language.
    I denote code blocks via indentation, use standard equality notation (`==` for
    equal and `!=` for not equal), use `True` and `False` to indicate Boolean values,
    denote comments with lines starting with the `#` symbol, and pass composite data
    structures as references. Arrays are zero indexed, and the value at index `i`
    is referenced as `arr[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I also deviate from the Python syntax wherever this aids readability.
    I specify all variables as `Type: Name` to make the types explicit, and I use
    the value `null` to indicate a null pointer. I often use `WHILE` loops over `FOR`
    loops or other compact forms to clearly show how the loop is iterating and its
    termination condition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve intentionally kept the examples in this book simple in order to focus
    on the computational ideas behind them. This means that individual implementations
    may not be fully optimized and will often be more verbose than strictly necessary.
    Throughout the text, I break out different conditions to illustrate the thought
    process behind the approach. At times the implementations vary from programming
    best practices in order to structure the code in a way that matches the explanation.
    In addition, to keep the examples simple, I often leave out the basic validity
    checks that are vital to include in production programs, such as checking that
    our array access is inbounds. Needless to say, treat these examples only as illustrations
    of the concepts at hand, rather than using them verbatim in your own projects.
    This is a good rule in general: never treat pseudocode as a full implementation.
    Always incorporate the relevant testing, validity checks, and other best practices
    when implementing algorithms yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: On Analogies and Brewing Coffee
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book makes extensive use of metaphor and analogy, illustrating complex
    technical concepts by comparison to (sometimes absurd) real-world scenarios. Similes
    are scattered through this book like blueberries through a muffin. Each chapter
    explains the intricate working of data structures and algorithms with examples
    ranging from organizing your kitchen to determining whether you’ve ever tried
    a specific brew of coffee, inviting you to consider how these computational concepts
    work in a different way from computer code.
  prefs: []
  type: TYPE_NORMAL
- en: The examples will often bend the rules of reality, be oversimplified, or border
    on the ridiculous. For example, we repeatedly consider the question of storing
    and sorting extensive coffee collections, ignoring the tragic fact that coffee
    does go stale. While that means this book is not a strictly realistic guide to
    making the ultimate cup of coffee, the absurd analogies keep things fun and should
    encourage you to think outside your normal approaches. Simplifying the analogies
    allows us to focus on just those aspects that are critical to the computational
    concept. For example, when discussing the use of nearest-neighbor search to find
    a close cup of coffee, I focus on distances (the core computational concept) and
    neglect such complicating factors as fences or rivers. My goal is to tailor the
    analogy to the core of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: I use analogies to augment formal descriptions and precise code. Personally,
    I find it easier to break free from technicalities and minutiae when viewing a
    data structure’s operation in an active, narrative context with people (or even
    overcaffeinated squirrels) interacting with physical objects, rather than sticking
    to the vocabulary of `FOR` loops and variable counters. Visualizing a frantic
    chase through a maze of alleyways provides a different perspective of a graph
    algorithm from the formal context of iterating over abstract nodes and edges.
    I encourage readers to map these analogies to their own broad range of concepts,
    whether part of their daily life or fancies of the absurd.
  prefs: []
  type: TYPE_NORMAL
- en: How to Use This Book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The book is structured progressively. That is, while each chapter focuses on
    a different computational concept—either a data structure or motivating problem—each
    also builds upon the previous chapters. Most of the later chapters, for example,
    rely on the discussion of memory-linked data structures and the use of pointers
    introduced in Chapter 3. We return to the basic binary search tree structure introduced
    in Chapter 5 again and again as we examine variations of branching data structures.
    Thus, I recommend that you approach the chapters in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we explore different data structures and how they apply to various problems,
    we will see consistent themes appear, including:'
  prefs: []
  type: TYPE_NORMAL
- en: The impact of the data’s structure on algorithms accessing it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to think about performance in the worst case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of allowing for dynamic changes in your data set and how to efficiently
    enable these changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tradeoffs among memory, runtime, code complexity, and accuracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we may need to tune data structures for the problem and what tradeoffs to
    consider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can adapt data structures to tackle new problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These themes provide both a framework for thinking about the data structures
    and a set of questions to ask when facing a new problem. A critical aspect of
    choosing the data structure is understanding why it performs the way it does and
    how it will apply to new data.
  prefs: []
  type: TYPE_NORMAL
- en: Most of all, the two questions that you should keep in mind throughout the book
    are “How?” and “Why?” *How* does a given data structure enable a computation?
    *How* do we structure the data to maximize efficiency in a given context? *Why*
    does a given structure enable these computations? *How* does this data structure
    break down in a different context? *Why* is the author using that ridiculous analogy?
    *Why* is the author so obsessed with coffee? Understanding the answers to these
    questions (other than the last one) will provide the foundation you need to effectively
    use already-existing data structures and develop novel techniques in the future.
  prefs: []
  type: TYPE_NORMAL
