- en: '[9](nsp-venkitachalam503045-0008.xhtml#rch09)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[9](nsp-venkitachalam503045-0008.xhtml#rch09)'
- en: Understanding OpenGL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 OpenGL
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: In this project, you’ll create a simple program that displays a texture-mapped
    square using OpenGL and GLFW. OpenGL is a software interface to your graphics
    processing unit (GPU), and GLFW is a windowing toolkit. You’ll also learn how
    to use the C-like OpenGL Shading Language (GLSL) to write *shaders*—code that
    executes in the GPU. Shaders bring immense flexibility to computations in OpenGL.
    I’ll show you how to use GLSL shaders to transform and color geometry as you create
    a rotating, textured polygon (as shown in [Figure 9-1](nsp-venkitachalam503045-0023.xhtml#fig9-1)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将创建一个简单的程序，使用 OpenGL 和 GLFW 显示一个纹理映射的方形。OpenGL 是你与图形处理单元（GPU）之间的软件接口，而
    GLFW 是一个窗口工具包。你还将学习如何使用类似 C 语言的 OpenGL 着色语言（GLSL）来编写 *着色器*——在 GPU 上执行的代码。着色器为
    OpenGL 中的计算带来了巨大的灵活性。我将向你展示如何使用 GLSL 着色器来变换和上色几何体，同时创建一个旋转的、带纹理的多边形（如[图 9-1](nsp-venkitachalam503045-0023.xhtml#fig9-1)所示）。
- en: GPUs are optimized to perform the same operations on huge amounts of data repeatedly,
    in parallel, which makes them much faster than central processing units (CPUs)
    for rendering computer graphics. In addition, they’re being used for general-purpose
    computing, and specialized languages now let you harness your GPU hardware for
    all sorts of applications. You’ll leverage the GPU, OpenGL, and shaders in this
    project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 被优化为在大量数据上反复执行相同的操作，并行处理，这使得它们在渲染计算机图形时比中央处理单元（CPU）更快。此外，GPU 还被用于通用计算，专门的编程语言现在允许你将
    GPU 硬件应用于各种各样的应用程序。在本项目中，你将利用 GPU、OpenGL 和着色器。
- en: '![](images/nsp-venkitachalam503045-f09001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f09001.jpg)'
- en: 'Figure 9-1: The final image for the project in this chapter—a rotating polygon
    with a star image. This square polygon boundary is clipped to a black circle using
    a shader.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：本章项目的最终图像——一个旋转的多边形，带有星形图像。这个方形多边形边界使用着色器被裁剪成黑色圆形。
- en: Python is an excellent “glue” language. There are a vast number of Python *bindings*
    available for libraries written in other languages, such as C, that allow you
    to use these libraries in Python. In this chapter and in [Chapters 10](nsp-venkitachalam503045-0024.xhtml#ch10)
    and [11](nsp-venkitachalam503045-0025.xhtml#ch11), you’ll use `PyOpenGL`, the
    Python binding to OpenGL, to create computer graphics.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种出色的“胶水”语言。有大量的 Python *绑定* 可用于其他语言编写的库，例如 C，使你能够在 Python 中使用这些库。在本章以及[第
    10 章](nsp-venkitachalam503045-0024.xhtml#ch10)和[第 11 章](nsp-venkitachalam503045-0025.xhtml#ch11)中，你将使用
    `PyOpenGL`，它是 OpenGL 的 Python 绑定，用于创建计算机图形。
- en: 'Here are some of the concepts introduced in this project:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本项目中介绍的一些概念：
- en: • Using the GLFW windowing library for OpenGL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 GLFW 窗口库进行 OpenGL 编程
- en: • Using GLSL to write vertex and fragment shaders
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 GLSL 编写顶点着色器和片段着色器
- en: • Performing texture mapping
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 执行纹理映射
- en: • Using 3D transformations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 3D 变换
- en: First, let’s take a look at how OpenGL works.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看 OpenGL 是如何工作的。
- en: NOTE OpenGL went through a major transition a few years ago. It went from using
    a fixed function graphics pipeline to a programmable pipeline with a dedicated
    shading language. We refer to the latter as *modern OpenGL*, and that’s what we’ll
    be using in this book. Specifically, we’ll use OpenGL version 4.1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：OpenGL 在几年前经历了重大变革。它从使用固定功能的图形管线转变为使用具有专用着色语言的可编程管线。我们称之为 *现代 OpenGL*，而这就是本书中使用的版本。具体来说，我们将使用
    OpenGL 版本 4.1。
- en: '[How OpenGL Works](nsp-venkitachalam503045-0008.xhtml#rah1101)'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[OpenGL 工作原理](nsp-venkitachalam503045-0008.xhtml#rah1101)'
- en: Modern OpenGL makes graphics appear on your screen through a sequence of operations
    commonly known as the *3D graphics pipeline*. [Figure 9-2](nsp-venkitachalam503045-0023.xhtml#fig9-2)
    shows a simplified representation of the OpenGL 3D graphics pipeline.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 OpenGL 通过一系列操作将图形呈现在屏幕上，这些操作通常被称为 *3D 图形管线*。[图 9-2](nsp-venkitachalam503045-0023.xhtml#fig9-2)
    显示了 OpenGL 3D 图形管线的简化表示。
- en: '![](images/nsp-venkitachalam503045-f09002.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f09002.jpg)'
- en: 'Figure 9-2: The (simplified) OpenGL graphics pipeline'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：简化的 OpenGL 图形管线
- en: 'At their heart, computer graphics boil down to computing color values for the
    pixels on your screen. Say you want to make a triangle appear. In the first step
    of the pipeline, you define the 3D geometry by defining the vertices of the triangle
    in 3D space and specifying the colors associated with each vertex. These vertices
    and colors are held in data structures called *vertex buffer objects (VBOs)*.
    Next, you transform the vertices: the first transformation places the vertices
    in 3D space, and the second projects the 3D coordinates onto 2D space for display
    on a 2D screen. The color values for the corresponding vertices are also calculated
    in this step based on factors such as lighting, typically in code called the *vertex
    shader*.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，计算机图形学归结为计算屏幕上像素的颜色值。假设你想让一个三角形出现。在管线的第一步，你通过定义三角形的 3D 顶点并指定与每个顶点相关的颜色来定义
    3D 几何形状。这些顶点和颜色会保存在一种叫做*顶点缓冲对象（VBOs）*的数据结构中。接下来，你会对顶点进行变换：第一步变换将顶点置于 3D 空间中，第二步将
    3D 坐标投影到 2D 空间，以便在 2D 屏幕上显示。此步骤中还会根据照明等因素计算相应顶点的颜色值，通常在名为*顶点着色器*的代码中进行计算。
- en: Next, the geometry is *rasterized* (converted from a 3D representation to 2D
    pixels), and for each pixel (or *fragment*, to be more accurate), another block
    of code called the *fragment shader* is executed. Just as the vertex shader operates
    on 3D vertices, the fragment shader operates on the 2D fragments after rasterization.
    I say *fragment* rather than *pixel* since a pixel is what is displayed on the
    screen, whereas a fragment is the output of computations in the fragment shader,
    and depending on the next step in the pipeline, a fragment may be discarded before
    it becomes a pixel on the screen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，几何图形会被*光栅化*（从 3D 表示转换为 2D 像素），对于每个像素（或者更准确地说是*片段*），会执行另一段代码，叫做*片段着色器*。就像顶点着色器操作
    3D 顶点一样，片段着色器则作用于光栅化后的 2D 片段。我使用*片段*而不是*像素*，因为像素是显示在屏幕上的内容，而片段是片段着色器计算的输出，根据管线中的下一步，片段可能在成为屏幕上的像素之前被丢弃。
- en: Finally, each fragment passes through a series of frame buffer operations, where
    it undergoes *depth buffer testing* (checking whether one fragment obscures another),
    *blending* (mixing two fragments with transparency), and other operations that
    combine its current color with what is already on the frame buffer at that location.
    These changes end up on the final frame buffer, which is typically displayed on
    the screen.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个片段会经过一系列帧缓冲操作，在这些操作中，它会进行*深度缓冲测试*（检查一个片段是否遮挡了另一个片段）、*混合*（将两个具有透明度的片段混合）以及其他将其当前颜色与帧缓冲区中该位置已有的颜色相结合的操作。这些更改最终会出现在最终的帧缓冲区中，通常会显示在屏幕上。
- en: '[Geometric Primitives](nsp-venkitachalam503045-0008.xhtml#rbh1101)'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[几何图元](nsp-venkitachalam503045-0008.xhtml#rbh1101)'
- en: Because OpenGL is a low-level graphics library, you can’t ask it directly to
    draw a cube or a sphere, though libraries built on top of it can do such tasks
    for you. OpenGL understands only low-level geometric primitives, such as points,
    lines, and triangles.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 OpenGL 是一个低级图形库，你不能直接要求它绘制一个立方体或球体，尽管建立在 OpenGL 基础上的库可以为你完成这些任务。OpenGL 只理解低级的几何图元，如点、线和三角形。
- en: Modern OpenGL supports only the primitive types `GL_POINTS`, `GL_LINES`, `GL_LINE_STRIP`,
    `GL_LINE_LOOP`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP`, and `GL_TRIANGLE_FAN`. [Figure
    9-3](nsp-venkitachalam503045-0023.xhtml#fig9-3) shows how the vertices for the
    primitives are organized. Each vertex has a 3D coordinate such as (*x*, *y*, *z*).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 OpenGL 仅支持以下基本图元类型：`GL_POINTS`、`GL_LINES`、`GL_LINE_STRIP`、`GL_LINE_LOOP`、`GL_TRIANGLES`、`GL_TRIANGLE_STRIP`
    和 `GL_TRIANGLE_FAN`。[图 9-3](nsp-venkitachalam503045-0023.xhtml#fig9-3) 显示了这些图元的顶点是如何组织的。每个顶点都有一个像
    (*x*, *y*, *z*) 这样的 3D 坐标。
- en: '![](images/nsp-venkitachalam503045-f09003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f09003.jpg)'
- en: 'Figure 9-3: OpenGL primitives'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3：OpenGL 基本图元
- en: To draw a sphere in OpenGL, first define the geometry of the sphere mathematically
    and compute its 3D vertices. Then assemble the vertices into basic geometric primitives;
    for example, you could group each set of three vertices into a triangle. You then
    render the vertices using OpenGL.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL 中绘制一个球体，首先需要通过数学定义球体的几何形状并计算其 3D 顶点。然后将这些顶点组装成基本的几何图元；例如，可以将每组三个顶点组成一个三角形。接下来使用
    OpenGL 渲染这些顶点。
- en: '[3D Transformations](nsp-venkitachalam503045-0008.xhtml#rbh1102)'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[3D 变换](nsp-venkitachalam503045-0008.xhtml#rbh1102)'
- en: You can’t learn computer graphics without learning about 3D transformations.
    Conceptually, these are quite simple to understand. You have an object—what can
    you do to it? You can move it, stretch (or squash) it, or rotate it. You can do
    other things to it too, but these three tasks—translation, scale, and rotation—are
    the operations or transformations most commonly performed on an object. In addition
    to these commonly used transformations, you’ll use a perspective projection to
    map the 3D objects onto the 2D plane of the screen. These transformations are
    all applied on the coordinates of the object you are trying to transform.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你不学习 3D 变换就无法学习计算机图形学。从概念上讲，这些是相当简单的理解。你有一个对象——你可以对它做什么？你可以移动它，拉伸（或压缩）它，或者旋转它。你还可以对它做其他事情，但这三项任务——平移、缩放和旋转——是对一个对象执行的最常见操作或变换。除了这些常用的变换之外，你还会使用透视投影将
    3D 对象映射到屏幕的 2D 平面上。这些变换都应用于你要变换的对象的坐标。
- en: While you’re probably familiar with 3D coordinates in the form (*x*, *y*, *z*),
    in 3D computer graphics you use coordinates in the form (*x*, *y*, *z*, *w*), called
    *homogeneous coordinates*. (These coordinates come from a branch of mathematics
    called *projective geometry*, which is beyond the scope of this book.) Homogeneous
    coordinates allow you to express common 3D transformations such as translation,
    scale, and rotation as 4×4 matrices. But for the purposes of these OpenGL projects,
    all you need to know is that the homogeneous coordinate (*x*, *y*, *z*, *w*) is
    equivalent to the 3D coordinate (*x*/*w*, *y*/*w*, *z*/*w*, 1.0). A 3D point (1.0,
    2.0, 3.0) can be expressed in homogeneous coordinates as (1.0, 2.0, 3.0, 1.0).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能已经熟悉形式为（*x*，*y*，*z*）的 3D 坐标，但在 3D 计算机图形学中，你使用的是形式为（*x*，*y*，*z*，*w*）的坐标，称为
    *齐次坐标*。（这些坐标来源于一种叫做 *射影几何* 的数学分支，超出了本书的范围。）齐次坐标使你能够将常见的 3D 变换（如平移、缩放和旋转）表示为 4×4
    矩阵。但对于这些 OpenGL 项目的目的来说，你只需要知道齐次坐标（*x*，*y*，*z*，*w*）等同于 3D 坐标（*x*/*w*，*y*/*w*，*z*/*w*，1.0）。一个
    3D 点（1.0，2.0，3.0）可以表示为齐次坐标（1.0，2.0，3.0，1.0）。
- en: 'Here’s an example of a 3D transformation using a 4×4 matrix. See how the matrix
    multiplication translates a point (*x*, *y*, *z*, 1.0) to (*x* + *t*[x], *y* +
    *t*[y], *z* +*t*[z], 1.0):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 4×4 矩阵进行 3D 变换的例子。请看矩阵乘法是如何将一个点（*x*，*y*，*z*，1.0）转换为（*x* + *t*[*x*]， *y*
    + *t*[*y*]，*z* + *t*[*z*]，1.0）的：
- en: '![](images/nsp-venkitachalam503045-m09001.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m09001.jpg)'
- en: Since this operation translates a point in space, the 4×4 matrix involved is
    called a *translation matrix*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此操作是将一个点在空间中平移，所涉及的 4×4 矩阵被称为 *平移矩阵*。
- en: 'Let’s now look at another useful matrix for 3D transformation—a rotation matrix.
    The following matrix rotates a point (*x*, *y*, *z*, 1.0) counterclockwise around
    the x-axis by θ radians:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看另一个用于 3D 变换的有用矩阵——旋转矩阵。下面的矩阵将一个点（*x*，*y*，*z*，1.0）绕 x 轴逆时针旋转 θ 弧度：
- en: '![](images/nsp-venkitachalam503045-m09002.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m09002.jpg)'
- en: 'But here’s something to keep in mind: if you’re going to apply this rotation
    inside shader code, the matrix will be stored in *column-major format*, which
    means you should declare it as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一点需要记住：如果你打算在着色器代码中应用此旋转，矩阵将以 *列主格式* 存储，这意味着你应该按以下方式声明它：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that, in the code, the matrix is flipped along its diagonal compared
    to the definition of *R*[θ][,][x].
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在代码中，与 *R*[θ][,][x] 的定义相比，矩阵沿其对角线被翻转了。
- en: Two terms that you will encounter often in OpenGL are *modelview* and *projection*
    transformations. With the advent of customizable shaders in modern OpenGL, modelviews
    and projections are just generic transformations. Historically, in old-school
    versions of OpenGL, the modelview transformations were applied to your 3D model
    to position it in space, and the projection transformations were used to map the
    3D coordinates onto a 2D surface for display, as you’ll see in a moment. Modelview
    transformations are user-defined transformations that let you position your 3D
    objects, and projection transformations are projective transformations that map
    3D onto 2D.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL 中，你会经常遇到两个术语：*模型视图*和*投影*变换。随着现代 OpenGL 可自定义着色器的出现，模型视图和投影已经成为通用变换。从历史上看，在旧版
    OpenGL 中，模型视图变换用于将你的 3D 模型定位在空间中，而投影变换用于将 3D 坐标映射到 2D 表面以进行显示，正如你稍后会看到的那样。模型视图变换是用户定义的变换，让你能够定位
    3D 对象，而投影变换是将 3D 映射到 2D 的投影变换。
- en: The two most commonly used 3D graphics projective transformations are *orthographic*
    and *perspective*, but here you’ll use only perspective projections, which are
    defined by a *field of view* (the extent to which the eye can see), a *near plane*
    (the plane closest to the eye), a *far plane* (the plane farthest from the eye),
    and an *aspect ratio* (the ratio of the width to the height of the near plane).
    Together, these parameters constitute a camera model for a projection that determines
    how the 3D figure will be mapped onto a 2D screen, as shown in [Figure 9-4](nsp-venkitachalam503045-0023.xhtml#fig9-4).
    The truncated pyramid shown in the figure is the *view frustum*. The *eye* is
    the 3D location where you place the camera. (For orthographic projection, the
    eye will be at infinity, and the pyramid will become a rectangular cuboid.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的两种3D图形投影变换是*正交*投影和*透视*投影，但在这里你将只使用透视投影，它由*视场*（眼睛可以看到的范围）、*近裁剪面*（离眼睛最近的平面）、*远裁剪面*（离眼睛最远的平面）和*宽高比*（近裁剪面宽度与高度的比率）定义。这些参数共同构成一个相机模型，用于定义如何将3D物体映射到2D屏幕上，如[图9-4](nsp-venkitachalam503045-0023.xhtml#fig9-4)所示。图中的截头金字塔就是*视锥体*，*眼睛*则是放置相机的3D位置。（对于正交投影，眼睛的位置将在无穷远处，且金字塔将变成一个矩形立方体。）
- en: '![](images/nsp-venkitachalam503045-f09004.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f09004.jpg)'
- en: 'Figure 9-4: A perspective projection camera model'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：一个透视投影相机模型
- en: Once the perspective projection is complete and before rasterization, the graphics
    primitives are clipped (or cut out) against the near and far planes shown in [Figure
    9-4](nsp-venkitachalam503045-0023.xhtml#fig9-4). The near and far planes are chosen
    such that the 3D objects you want to appear onscreen lie inside the view frustum;
    otherwise, they will be clipped away.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦透视投影完成并且在光栅化之前，图形原语会根据[图9-4](nsp-venkitachalam503045-0023.xhtml#fig9-4)中显示的近裁剪面和远裁剪面进行裁剪（或剪切）。选择近裁剪面和远裁剪面时，确保你希望在屏幕上显示的3D物体位于视锥体内部；否则，它们会被裁剪掉。
- en: '[Shaders](nsp-venkitachalam503045-0008.xhtml#rbh1103)'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[着色器](nsp-venkitachalam503045-0008.xhtml#rbh1103)'
- en: You’ve seen how shaders fit into the modern OpenGL programmable graphics pipeline.
    Now let’s look at a simple pair of vertex and fragment shaders to get a sense
    of how GLSL works.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了着色器如何融入现代OpenGL可编程图形管线。现在让我们来看一对简单的顶点和片段着色器，来感受一下GLSL是如何工作的。
- en: A Vertex Shader
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个顶点着色器
- en: 'Here is a simple vertex shader that computes the position and color of a vertex:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的顶点着色器，它计算顶点的位置和颜色：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You first set the version of GLSL used in the shader to version 4.1 ❶. Then
    you define an input named `aVert` of type `vec3` (a 3D vector) for the vertex
    shader using the keyword `in` ❷. You next define two variables of type `mat4`
    (4×4 matrices), which correspond to the modelview ❸ and projection ❹ matrices.
    The `uniform` prefix to these variables indicates that they do not change during
    execution of the vertex shader for a given rendering call on a set of vertices.
    You use the `out` prefix to define the output of the vertex shader, which is a
    color variable of type `vec4` (a 4D vector to store red, green, blue, and alpha
    channels) ❺.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先在着色器中设置所使用的GLSL版本为4.1 ❶。然后，使用关键字`in`定义一个名为`aVert`的输入变量，其类型为`vec3`（一个三维向量）❷。接下来，你定义了两个类型为`mat4`（4×4矩阵）的变量，分别对应于模型视图矩阵
    ❸ 和投影矩阵 ❹。这些变量前缀为`uniform`，表示在给定的渲染调用中，这些变量在顶点着色器执行过程中不会改变。你使用`out`前缀来定义顶点着色器的输出变量，它是一个类型为`vec4`的颜色变量（一个4维向量，用于存储红色、绿色、蓝色和透明度通道）❺。
- en: Now you come to the `main()` function, where the vertex shader program starts.
    The value of `gl_Position` is computed by transforming the input `aVert` using
    the uniform matrices passed in ❻. The GLSL variable `gl_Position` is used to store
    the transformed vertices. You set the output color from the vertex shader to red
    with no transparency by using the value (1, 0, 0, 1) ❼. You’ll use this as input
    in the next shader in the pipeline.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你进入了`main()`函数，顶点着色器程序从这里开始。`gl_Position`的值是通过使用传入的uniform矩阵对输入的`aVert`进行变换来计算的
    ❻。GLSL变量`gl_Position`用于存储变换后的顶点。你将顶点着色器的输出颜色设置为红色且不透明，使用的值是(1, 0, 0, 1) ❼。你将在管线中的下一个着色器中使用这个值作为输入。
- en: A Fragment Shader
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个片段着色器
- en: 'Now let’s look at a simple fragment shader that computes the fragment color
    based on the vertex color passed in:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个简单的片段着色器，它根据传入的顶点颜色计算片段颜色：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After setting the version of GLSL used in the shader ❶, you set `vCol` as the
    input to the fragment shader ❷. This variable, `vCol`, was set as output from
    the vertex shader. (Remember, the vertex shader executes for every vertex in the
    3D scene, whereas the fragment shader executes for every fragment on the screen.)
    You also set the fragment shader’s output color variable `fragColor` ❸.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置着色器使用的 GLSL 版本 ❶ 后，你将 `vCol` 设置为片段着色器的输入 ❷。这个变量 `vCol` 是从顶点着色器的输出设置的。（记住，顶点着色器在
    3D 场景中的每个顶点上执行，而片段着色器在屏幕上的每个片段上执行。）你还设置了片段着色器的输出颜色变量 `fragColor` ❸。
- en: During rasterization (which occurs between the vertex and fragment shaders),
    OpenGL converts the transformed vertices to fragments, and the color of the fragments
    lying between the vertices is calculated by interpolating the color values at
    the vertices; `vCol` in the previous code is this interpolated color. You set
    the fragment shader’s output to be the same as the interpolated color going into
    the fragment shader ❹. By default, and in most cases, the intended output of the
    fragment shader is the screen, and the color you set ends up there (unless it’s
    affected by operations, such as depth testing, that occur in the final stage of
    the graphics pipeline).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在光栅化过程中（发生在顶点着色器和片段着色器之间），OpenGL 将变换后的顶点转换为片段，并通过对顶点的颜色值进行插值，计算位于顶点之间的片段的颜色；`vCol`
    是前面代码中的插值颜色。你将片段着色器的输出设置为与输入到片段着色器中的插值颜色相同❹。默认情况下，在大多数情况下，片段着色器的目标输出是屏幕，而你设置的颜色最终会显示在屏幕上（除非受到诸如深度测试等操作的影响，这些操作发生在图形管线的最后阶段）。
- en: For the GPU to execute the shader code, it needs to be compiled and linked to
    instructions that the hardware understands. OpenGL provides ways to do this and
    reports detailed compiler and linker errors that will help you develop the shader
    code. The compilation process also generates a table of locations or indices for
    the variables declared in your shaders so you can connect them to variables in
    your Python code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 GPU 执行着色器代码，它需要被编译并链接到硬件可以理解的指令。OpenGL 提供了方法来实现这一点，并报告详细的编译器和链接器错误，帮助你开发着色器代码。编译过程还会生成一个表，列出你在着色器中声明的变量的位置或索引，以便你可以将它们连接到
    Python 代码中的变量。
- en: '[Vertex Buffers](nsp-venkitachalam503045-0008.xhtml#rbh1104)'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[顶点缓冲区](nsp-venkitachalam503045-0008.xhtml#rbh1104)'
- en: '*Vertex buffers* are an important mechanism used by OpenGL shaders. Modern
    graphics hardware and OpenGL are designed to work with large amounts of 3D geometry.
    Consequently, several mechanisms are built into OpenGL to help transfer data from
    the program to the GPU. A typical setup to draw 3D geometry in a program will
    do the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*顶点缓冲区*是 OpenGL 着色器中使用的一个重要机制。现代图形硬件和 OpenGL 设计用于处理大量的 3D 几何体。因此，OpenGL 内置了多种机制，以帮助将数据从程序传输到
    GPU。绘制 3D 几何体的典型设置将执行以下操作：'
- en: 1\. Define arrays of coordinates, colors, and other attributes for each vertex
    of the 3D geometry.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 为每个顶点的 3D 几何体定义坐标、颜色和其他属性的数组。
- en: 2\. Create a vertex array object (VAO) and bind to it.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 创建一个顶点数组对象（VAO）并绑定到它。
- en: 3\. Create vertex buffer objects (VBOs) for each attribute, defined on a per-vertex
    basis.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 为每个属性创建顶点缓冲对象（VBO），并按顶点为单位定义。
- en: 4\. Bind to the VBO and set the buffer data using the predefined arrays.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 绑定到 VBO 并使用预定义数组设置缓冲数据。
- en: 5\. Specify the data and location of vertex attributes to be used in the shader.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 指定着色器中将使用的顶点属性的数据和位置。
- en: 6\. Enable the vertex attributes.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6\. 启用顶点属性。
- en: 7\. Render the data.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7\. 渲染数据。
- en: After you define the 3D geometry in terms of vertices, you create and bind to
    a vertex array object. VAOs are a convenient way to group geometry as multiple
    arrays of coordinates, colors, and so on. Then, for each attribute of each vertex,
    you create a vertex buffer object and set your 3D data into it. The VBO stores
    the vertex data in the GPU memory. Now, all that’s left is to connect the buffer
    data so you can access it from your shaders. You do this through calls that use
    the location of the variables employed in the shader.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在你定义了3D几何体的顶点之后，你创建并绑定一个顶点数组对象。VAO 是一种方便的方式，用于将几何体按坐标、颜色等多个数组进行分组。然后，为每个顶点的每个属性，创建一个顶点缓冲对象，并将你的
    3D 数据设置进去。VBO 将顶点数据存储在 GPU 内存中。现在，只剩下连接缓冲数据，这样你就可以在着色器中访问它。你可以通过使用着色器中使用的变量位置来完成此操作。
- en: '[Texture Mapping](nsp-venkitachalam503045-0008.xhtml#rbh1105)'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[纹理映射](nsp-venkitachalam503045-0008.xhtml#rbh1105)'
- en: Now let’s look at texture mapping, an important computer graphics technique
    that you’ll use in this chapter. *Texture mapping* is a way to give a scene a
    realistic feel with the help of a 2D picture of a 3D object (like the backdrop
    in a play). A texture is usually read from an image file and is stretched to drape
    over a geometric region by mapping the 2D coordinates (in the range [0, 1]) onto
    the 3D coordinates of the polygons. For example, [Figure 9-5](nsp-venkitachalam503045-0023.xhtml#fig9-5)
    shows an image draped onto one face of a cube. (I used `GL_TRIANGLE_STRIP` primitives
    to draw the cube faces, and the ordering of the vertices is indicated by the lines
    on the face.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下纹理映射，这是一种在本章中将使用的重要计算机图形学技术。*纹理映射* 是一种通过使用 3D 物体的 2D 图像（类似舞台背景）来赋予场景现实感的方法。纹理通常是从图像文件中读取的，并通过将
    2D 坐标（在 [0, 1] 范围内）映射到多边形的 3D 坐标，拉伸并覆盖在几何区域上。例如，[图 9-5](nsp-venkitachalam503045-0023.xhtml#fig9-5)展示了一个图像被覆盖在立方体的一个面上。（我使用了
    `GL_TRIANGLE_STRIP` 基元来绘制立方体面，并且顶点的顺序通过面上的线条表示。）
- en: '![](images/nsp-venkitachalam503045-f09005.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f09005.jpg)'
- en: 'Figure 9-5: Texture mapping'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：纹理映射
- en: In [Figure 9-5](nsp-venkitachalam503045-0023.xhtml#fig9-5), the (0, 0) corner
    of the texture is mapped to the bottom-left vertex of the cube face. Similarly,
    you can see how the other corners of the texture are mapped, with the net effect
    that the texture is “pasted” onto this cube face. The geometry of the cube face
    itself is defined as a triangle strip, and the vertices zigzag from the bottom
    to the top left and from the bottom to the top right. Textures are extremely powerful
    and versatile computer graphics tools, as you’ll see in [Chapter 11](nsp-venkitachalam503045-0025.xhtml#ch11).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 9-5](nsp-venkitachalam503045-0023.xhtml#fig9-5)中，纹理的(0, 0)角被映射到立方体面部的左下顶点。同样，你可以看到纹理的其他角是如何映射的，最终效果是纹理被“粘贴”到立方体的这一面。立方体面部的几何形状定义为三角带，顶点从底部到左上和从底部到右上呈之字形排列。纹理是非常强大且多功能的计算机图形工具，正如你将在[第
    11 章](nsp-venkitachalam503045-0025.xhtml#ch11)中看到的那样。
- en: '[The OpenGL Context](nsp-venkitachalam503045-0008.xhtml#rbh1106)'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[OpenGL 上下文](nsp-venkitachalam503045-0008.xhtml#rbh1106)'
- en: Now let’s talk about how to get OpenGL to draw stuff on the screen. The entity
    that stores all the OpenGL state information is called the *OpenGL context*. Contexts
    have a viewable, window-like area where the OpenGL drawings go, and you can have
    multiple contexts per process or run of an application, but only one context per
    thread can be current at a time. (Fortunately, the window toolkit will take care
    of most of the context handling.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论如何让 OpenGL 在屏幕上绘制内容。存储所有 OpenGL 状态信息的实体被称为 *OpenGL 上下文*。上下文具有一个可视化的、类似窗口的区域，OpenGL
    绘制内容会显示在这个区域上，并且每个进程或应用程序运行可以有多个上下文，但每次只有一个上下文可以是当前上下文（线程）。 (幸运的是，窗口工具包会处理大部分上下文的管理。)
- en: For your OpenGL output to appear in a window onscreen, you need the help of
    the operating system. For these projects, you’ll use GLFW, a lightweight cross-platform
    C library that lets you create and manage OpenGL contexts, display the 3D graphics
    in a window, and handle user input such as mouse clicks and keypresses. ([Appendix
    A](nsp-venkitachalam503045-0031.xhtml#appa) covers the installation details for
    this library.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的 OpenGL 输出出现在屏幕上的窗口中，你需要操作系统的帮助。对于这些项目，你将使用 GLFW，一个轻量级的跨平台 C 库，它允许你创建和管理
    OpenGL 上下文、在窗口中显示 3D 图形，并处理用户输入（如鼠标点击和键盘按键）。([附录 A](nsp-venkitachalam503045-0031.xhtml#appa)涵盖了此库的安装细节。)
- en: Because you’re writing code in Python and not C, you’ll also use a Python binding
    to GLFW (*glfw.py*, available in the *common* directory in the book’s code repository),
    which lets you access all the GLFW features using Python.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在使用 Python 编写代码而不是 C，你还将使用一个 Python 绑定库来访问 GLFW（*glfw.py*，可以在本书代码库的 *common*
    目录中找到），这样你就可以使用 Python 访问所有 GLFW 功能。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1102)'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah1102)'
- en: You’ll use `PyOpenGL`, a popular Python binding for OpenGL, for rendering, and
    you’ll use `numpy` arrays to represent 3D coordinates and transformation matrices.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `PyOpenGL`，一个流行的 OpenGL Python 绑定库来进行渲染，并且你会使用 `numpy` 数组来表示 3D 坐标和变换矩阵。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1103)'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1103)'
- en: In this project, you’ll build a simple Python application for displaying a rotating,
    textured polygon using OpenGL. To see the complete project code, skip ahead to
    [“The Complete Code”](nsp-venkitachalam503045-0023.xhtml#ah1107) on [page 172](nsp-venkitachalam503045-0023.xhtml#p172).
    The complete code for our simple OpenGL application resides in two files. The
    main project code discussed in this chapter is in *simpleglfw.py*, which can be
    found at [https://github.com/mkvenkit/pp2e/tree/main/simplegl](https://github.com/mkvenkit/pp2e/tree/main/simplegl).
    The helper functions are in *glutils.py*, which can be found in the GitHub repository’s
    *common* directory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将构建一个简单的 Python 应用程序，用 OpenGL 显示一个旋转的纹理多边形。要查看完整的项目代码，请跳到 [“完整代码”](nsp-venkitachalam503045-0023.xhtml#ah1107)，位于
    [第 172 页](nsp-venkitachalam503045-0023.xhtml#p172)。我们简单的 OpenGL 应用程序的完整代码分布在两个文件中。本章讨论的主要项目代码在
    *simpleglfw.py* 中，代码可以在 [https://github.com/mkvenkit/pp2e/tree/main/simplegl](https://github.com/mkvenkit/pp2e/tree/main/simplegl)
    找到。辅助函数在 *glutils.py* 中，可以在 GitHub 仓库的 *common* 目录下找到。
- en: '[The RenderWindow Class](nsp-venkitachalam503045-0008.xhtml#rbh1107)'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[RenderWindow 类](nsp-venkitachalam503045-0008.xhtml#rbh1107)'
- en: The `RenderWindow` class manages the creation of the window that displays the
    OpenGL graphics. It initializes GLFW, sets up OpenGL, manages rendering, and sets
    up callbacks to receive keyboard input.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderWindow` 类管理显示 OpenGL 图形的窗口的创建。它初始化 GLFW，设置 OpenGL，管理渲染，并设置回调以接收键盘输入。'
- en: Creating an OpenGL Window
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个 OpenGL 窗口
- en: 'The first order of business of the `RenderWindow` class is to set up GLFW so
    you have an OpenGL window to render into. The class’s initialization code addresses
    this task:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderWindow` 类的首要任务是设置 GLFW，以便你有一个 OpenGL 窗口用于渲染。该类的初始化代码完成了这一任务：'
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You initialize the GLFW library ❶, and then, starting at ❷, you set the OpenGL
    version to the OpenGL 4.1 core profile. You next create an OpenGL-capable window
    with the dimensions 800×600 ❸. Finally, you make the context current ❹, and you’re
    ready to make OpenGL calls.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你初始化了 GLFW 库❶，然后从 ❷ 开始，将 OpenGL 版本设置为 OpenGL 4.1 核心配置文件。接着，你创建了一个 OpenGL 可用的窗口，尺寸为
    800×600❸。最后，你使上下文变为当前❹，然后就可以开始执行 OpenGL 调用了。
- en: 'Next, still within the `__init__()` definition, you make some initialization calls:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，仍在 `__init__()` 定义中，你会进行一些初始化调用：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here you set the viewport or screen dimensions (width and height) where OpenGL
    will render your 3D scene ❶. Then you turn on depth testing with `GL_DEPTH_TEST`
    ❷ and set the color the background should become when `glClear()` is issued during
    rendering ❸. You choose 50 percent gray with an `alpha` setting of 1.0\. (Alpha
    is a measure of the transparency of a fragment—1.0 means fully opaque.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你设置视口或屏幕尺寸（宽度和高度），这是 OpenGL 渲染你的 3D 场景的区域❶。然后，你通过 `GL_DEPTH_TEST` 开启深度测试❷，并设置当执行
    `glClear()` 渲染时背景的颜色❸。你选择 50% 灰色，并将 `alpha` 设置为 1.0（Alpha 是片段透明度的度量——1.0 表示完全不透明）。
- en: Setting Callbacks
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置回调
- en: 'You finish the `__init__()` definition by registering event callbacks for user
    interface events within the GLFW window so you can respond to keypresses:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过注册用户界面事件的回调函数来完成 `__init__()` 定义，这样你就可以响应按键事件。
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code sets callbacks for keypresses. Every time one of these events happens,
    the function registered as a callback, `onKeyboard()`, is executed. Let’s look
    at the definition of that keyboard callback function now:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了键盘按键的回调。每次发生这些事件时，注册为回调的函数 `onKeyboard()` 会被执行。现在让我们看看该键盘回调函数的定义：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `onKeyboard()` callback is called every time a keyboard event happens. The
    arguments to the function arrive filled with useful information such as what type
    of event occurred (key-up versus key-down, for example) and which key was pressed.
    The code `glfw.GLFW_PRESS` says to look only for key-down, or `PRESS`, events
    ❶. You set an exit flag if the ESC key is pressed ❷. If any other key is pressed,
    you toggle a `showCircle` Boolean ❸. This variable will be used in the fragment
    shader to keep or discard fragments outside the circle area.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每次发生键盘事件时，都会调用 `onKeyboard()` 回调函数。函数的参数中会包含有用的信息，例如发生了什么类型的事件（例如，按键抬起与按键按下）以及哪个键被按下。代码
    `glfw.GLFW_PRESS` 表示只监听按键按下（`PRESS`）事件❶。如果按下 ESC 键，你会设置一个退出标志❷。如果按下其他任何键，则切换 `showCircle`
    布尔值❸。这个变量将在片段着色器中用于保留或丢弃圆形区域外的片段。
- en: Defining the Main Loop
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义主循环
- en: 'The `RenderWindow` class also defines the main loop of the program through
    its `run()` method. (GLFW doesn’t provide a default program loop.) The `run()`
    method updates the OpenGL window at a preset time interval. After calling the
    render methods to draw the scene, it also polls the system for any pending window
    or keyboard events. Let’s look at the method definition:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderWindow`类还通过其`run()`方法定义了程序的主循环。（GLFW并没有提供默认的程序循环。）`run()`方法以预设的时间间隔更新OpenGL窗口。调用渲染方法绘制场景后，它还会轮询系统，查看是否有待处理的窗口或键盘事件。让我们看看方法的定义：'
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the main loop, `glfw.glfwSetTime()` resets the GLFW timer to 0 ❶. You’ll
    use this timer to redraw the graphics at regular intervals. You initiate a `while`
    loop ❷ that exits only if the window is closed or `exitNow` is set to `True`.
    When the loop exits, `glfw.glfwTerminate()` is called to shut down GLFW cleanly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，`glfw.glfwSetTime()`将GLFW计时器重置为0❶。你将使用这个计时器在定时的间隔内重新绘制图形。你启动一个`while`循环❷，只有当窗口关闭或`exitNow`被设置为`True`时才退出。当循环退出时，调用`glfw.glfwTerminate()`以清理地关闭GLFW。
- en: Inside the loop, `glfw.glfwGetTime()` gets the current timer value ❸, which
    you use to calculate the elapsed time since the last drawing. By setting a desired
    interval here (in this case, to 0.1 second or 100 milliseconds), you can adjust
    the rendering frame rate. Next, `glClear()` clears the depth and color buffers
    and replaces them with the set background color to get ready for the next frame
    ❹.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内，`glfw.glfwGetTime()`获取当前的计时器值❸，你可以用它来计算自上次绘制以来经过的时间。通过在这里设置一个期望的间隔（在本例中为0.1秒或100毫秒），你可以调整渲染帧率。接下来，`glClear()`清除深度和颜色缓冲区，并用设定的背景色替换它们，为下一帧做好准备❹。
- en: You query and set the window width and height using the `glfwGetFramebufferSize()`
    function ❺. You do this in case the user has changed the window’s size. Note that
    in some systems (such as a MacBook with Retina display) the window size and frame
    buffer size can be different, so to be safe, always query the latter. You next
    compute the aspect ratio of the window ❻, which you’ll use later to set the projection
    matrix. Then you clear the viewport using the new frame buffer dimensions you
    retrieved ❼.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`glfwGetFramebufferSize()`函数查询并设置窗口的宽度和高度❺。这样做是为了防止用户改变窗口的大小。请注意，在某些系统（例如带有Retina显示屏的MacBook）中，窗口大小和帧缓冲区大小可能不同，因此为了安全起见，始终查询后者。接下来，你计算窗口的宽高比❻，稍后将用它来设置投影矩阵。然后，使用你获取的新帧缓冲区尺寸清除视口❼。
- en: 'Now let’s look at the remaining part of the `run()` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`run()`方法的剩余部分：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Still within the `while` loop, you compute the projection matrix using the `perspective()`
    method defined in *glutils.py* ❶. The projection matrix is the transformation
    that maps a 3D scene to a 2D screen. Here you ask for a 45-degree field of view
    and a near/far plane distance of 0.1/100.0\. Then you set the modelview matrix
    using the `lookAt()` method ❷, also defined in *glutils.py*. The default OpenGL
    view puts your eye at the origin looking along the negative z-direction. The modelview
    matrix created by the `lookAt()` method transforms the vertices such that the
    view matches up with the eye position and orientation specified by the call. You
    set the eye position to (0, 0, −2), looking at the origin (0, 0, 0) with an “up”
    vector of (0, 1, 0). Next, you call the `render()` method on the `scene` object
    ❸, passing in these matrices, and you call `scene.step()` so it can update the
    variables necessary for the time step ❹. (The `Scene` class, which we’ll look
    at next, encapsulates the setup and rendering of the polygon.) The `glfwSwapBuffers()`
    call ❺ swaps the back and front buffers, thus displaying your updated 3D graphic,
    and the `glfwPollEvents()` call ❻ checks for any UI events and returns control to
    the `while` loop.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在`while`循环中，你使用*glutils.py*中定义的`perspective()`方法❶计算投影矩阵。投影矩阵是将3D场景映射到2D屏幕的变换。这里你设置了45度的视场角和近/远平面的距离为0.1/100.0。然后，你使用*glutils.py*中定义的`lookAt()`方法❷设置模型视图矩阵。默认的OpenGL视图将你的眼睛放在原点，朝向负z方向。`lookAt()`方法创建的模型视图矩阵会将顶点进行转换，使得视图与眼睛位置和方向匹配。你将眼睛位置设置为(0,
    0, -2)，并朝向原点(0, 0, 0)，"上"向量为(0, 1, 0)。接下来，你调用`scene`对象的`render()`方法❸，传入这些矩阵，并调用`scene.step()`来更新时间步长所需的变量❹。（我们接下来会看`Scene`类，它封装了多边形的设置和渲染。）`glfwSwapBuffers()`调用❺交换前后缓冲区，从而显示更新后的3D图形，而`glfwPollEvents()`调用❻检查任何UI事件，并将控制权返回给`while`循环。
- en: '[The Scene Class](nsp-venkitachalam503045-0008.xhtml#rbh1108)'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[场景类](nsp-venkitachalam503045-0008.xhtml#rbh1108)'
- en: 'Now let’s look at the `Scene` class, which is responsible for initializing
    and drawing the 3D geometry. Here’s the start of the class declaration:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下 `Scene` 类，它负责初始化和绘制 3D 几何体。以下是类声明的开头：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `Scene` class constructor, you first compile and load the shaders. For
    this, you use the utility method `loadShaders()` ❶ defined in *glutils.py*, which
    provides a convenient wrapper around the series of OpenGL calls required to load
    the shader code from strings, compile it, and link it into an OpenGL program object.
    Because OpenGL is a state machine, you need to set the code to use a particular
    “program object” (because a project could have multiple programs) using the `glUseProgram()`
    call ❷.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Scene` 类构造函数中，首先编译并加载着色器。为此，你使用在 *glutils.py* 中定义的工具方法 `loadShaders()` ❶，它为从字符串加载着色器代码、编译代码并将其链接到
    OpenGL 程序对象所需的一系列 OpenGL 调用提供了一个便捷的封装。由于 OpenGL 是一个状态机，因此你需要使用 `glUseProgram()`
    调用 ❷ 设置代码以使用特定的“程序对象”（因为一个项目可能有多个程序）。
- en: 'The `__init__()` method continues by connecting the variables in the Python
    code with those in the shaders:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法继续通过将 Python 代码中的变量与着色器中的变量连接起来：'
- en: self.pMatrixUniform = glGetUniformLocation(self.program, b'uPMatrix')
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: self.pMatrixUniform = glGetUniformLocation(self.program, b'uPMatrix')
- en: self.mvMatrixUniform = glGetUniformLocation(self.program, b'uMVMatrix')
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: self.mvMatrixUniform = glGetUniformLocation(self.program, b'uMVMatrix')
- en: '# texture'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '# 纹理'
- en: self.tex2D = glGetUniformLocation(self.program, b'tex2D')
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: self.tex2D = glGetUniformLocation(self.program, b'tex2D')
- en: This code uses the `glGetUniformLocation()` method to retrieve the locations
    of the variables `uPMatrix`, `uMVMatrix`, and `tex2D` defined inside the vertex
    and fragment shaders. These locations can then be used to set the values for the
    shader variables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用 `glGetUniformLocation()` 方法检索顶点着色器和片段着色器中定义的变量 `uPMatrix`、`uMVMatrix`
    和 `tex2D` 的位置。然后可以使用这些位置设置着色器变量的值。
- en: Defining the 3D Geometry
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义 3D 几何体
- en: 'The next part of the `Scene` class’s `__init__()` method defines the 3D geometry
    for the scene. You first define the geometry for the polygon, which will take
    the form of a square:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene` 类的 `__init__()` 方法的下一部分定义了场景的 3D 几何体。首先，你定义了多边形的几何形状，这将呈现为一个正方形：'
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First you define the array of vertices of the triangle strip used to draw the
    square ❶. Think of a square of a side length of 1.0 centered at the origin. The
    bottom-left vertex of this square has the coordinates (−0.5, −0.5, 0.0); the next
    vertex (the bottom-right one) has the coordinates (0.5, −0.5, 0.0); and so on.
    The order of the four coordinates is that of a `GL_TRIANGLE_STRIP`. Essentially,
    you’re creating the square by defining two right triangles with a shared hypotenuse.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你定义了用于绘制正方形的三角形带的顶点数组❶。可以将一个边长为 1.0，中心位于原点的正方形想象出来。该正方形的左下角顶点坐标为（−0.5，−0.5，0.0）；接下来的顶点（右下角）坐标为（0.5，−0.5，0.0）；依此类推。四个坐标的顺序是
    `GL_TRIANGLE_STRIP` 的顺序。实际上，你通过定义两个共享斜边的直角三角形来创建正方形。
- en: Next, you create a VAO ❷. Once you bind to this VAO, all upcoming calls will
    be bound to it. You then create a VBO to manage the rendering of the vertex data
    ❸. Once the buffer is bound, you set the buffer data from the vertices you’ve
    defined ❹.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你创建一个 VAO ❷。一旦绑定到该 VAO，所有后续的调用将绑定到它。然后你创建一个 VBO 来管理顶点数据的渲染❸。一旦缓冲区被绑定，你就可以从已定义的顶点设置缓冲区数据❹。
- en: Now you need to enable the shaders to access this data. For that, you call `glEnableVertexAttribArray()`
    ❺. You use an index of 0 because that is the location you have set in the vertex
    shader for the vertex data variable. Calling `glVertexAttribPointer()` sets the
    location and data format of the vertex attribute array ❻. The index of the attribute
    is 0, the number of components is 3 (you use 3D vertices), and the data type of
    the vertex is `GL_FLOAT`. You then unbind the VAO ❼ so other related calls don’t
    interfere with it. In OpenGL, it’s a best practice to reset states when you’re
    done. OpenGL is a state machine, so if you leave things in a mess, they will remain
    that way.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要启用着色器以访问这些数据。为此，你调用 `glEnableVertexAttribArray()` ❺。你使用索引 0，因为这是你在顶点着色器中为顶点数据变量设置的位置。调用
    `glVertexAttribPointer()` 设置顶点属性数组的位置和数据格式❻。属性的索引是 0，组件数为 3（你使用 3D 顶点），顶点的数据类型为
    `GL_FLOAT`。然后你解除绑定 VAO❼，以防其他相关调用干扰它。在 OpenGL 中，完成后重置状态是一种最佳实践。OpenGL 是一个状态机，如果你不清理，它们将保持原样。
- en: 'The following code loads an image of a star as an OpenGL texture:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将一张星星的图像加载为 OpenGL 纹理：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The texture ID returned will be used later in rendering.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的纹理 ID 将在渲染时使用。
- en: Rotating the Square
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旋转正方形
- en: 'Next you need to update variables in the `Scene` object to make the square
    rotate on the screen. Use the class’s `step()` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要更新`Scene`对象中的变量，使得正方形能够在屏幕上旋转。使用类的`step()`方法：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At ❶, you increment the angle variable `t` and use the modulus operator (`%`)
    to keep this value within [0, 360]. This variable will be used to update the rotation
    angle in the vertex shader.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，你递增角度变量`t`并使用取模运算符（`%`）保持该值在[0, 360]范围内。这个变量将用于更新顶点着色器中的旋转角度。
- en: Rendering the Scene
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染场景
- en: 'Now let’s look at the `Scene` object’s main rendering code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`Scene`对象的主要渲染代码：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First you set up the rendering to use the shader program ❶. Starting at ❷, you
    set the computed projection and modelview matrices in the shader using the `glUniformMatrix4fv()`
    method. Then you use the `glUniform1f()` method to set `uTheta` in the shader
    program ❸. You use `glGetUniformLocation()` as before to get the location of the
    `uTheta` angle variable from the shader, and you use the Python `math.radians()`
    method to convert the angle from degrees to radians. Next, you use `glUniform1i()`
    to set the current value of the `showCircle` variable in the fragment shader ❹.
    OpenGL has a concept of multiple texture units, and `glActiveTexture()` ❺ activates
    texture unit 0 (the default). You bind the texture ID you generated earlier from
    the *star.png* image to activate it for rendering ❻. The `sampler2D` variable
    in the fragment shader is set to texture unit 0 ❼.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你设置渲染使用着色器程序❶。从❷开始，你使用`glUniformMatrix4fv()`方法在着色器中设置计算得到的投影矩阵和模型视图矩阵。然后，你使用`glUniform1f()`方法设置着色器程序中的`uTheta`❸。你像之前一样使用`glGetUniformLocation()`获取着色器中的`uTheta`角度变量的位置，然后使用
    Python 的`math.radians()`方法将角度从度数转换为弧度。接下来，你使用`glUniform1i()`设置片段着色器中`showCircle`变量的当前值❹。OpenGL有多个纹理单元的概念，`glActiveTexture()`❺激活纹理单元
    0（默认）。你将之前从*star.png*图像生成的纹理 ID 绑定到当前激活的渲染单元❻。片段着色器中的`sampler2D`变量被设置为纹理单元 0❼。
- en: 'You continue by binding to the VAO you created previously ❽. Now you see the
    benefit of using VAOs: you don’t need to repeat a whole bunch of vertex buffer–related
    calls before the actual drawing. You then call `glDrawArrays()` to render the
    bound vertex buffers ❾. The primitive type is a triangle strip, and there are
    four vertices to be rendered. Finally, you unbind the VAO at ❿, which is always
    a good coding practice.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你继续绑定之前创建的 VAO❽。现在你可以看到使用 VAO 的好处：你无需在实际绘制之前重复一堆与顶点缓冲区相关的调用。然后你调用`glDrawArrays()`来渲染绑定的顶点缓冲区❾。基本图元类型是三角带，渲染的顶点数量为四个。最后，你在❿处解绑
    VAO，这始终是一种良好的编程实践。
- en: Defining the GLSL Shaders
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义 GLSL 着色器
- en: 'Now let’s look at the most exciting part of the project—the GLSL shaders. First,
    here’s the vertex shader, which computes the position and texture coordinates
    of the vertices:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下项目中最激动人心的部分——GLSL 着色器。首先，来看一下顶点着色器，它计算顶点的位置和纹理坐标：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You use the `layout` keyword ❶ to set explicitly the location of the vertex
    attribute `aVert`—to 0, in this case. This attribute lets the vertex shader access
    the vertices that you defined for the polygon. Starting at ❷, you declare three
    `uniform` variables for the projection and modelview matrices and the rotation
    angle. These will be set from the Python code. You also set a 2D vector `vTexCoord`
    as an output from this shader ❸. This will be available as an input to the fragment
    shader.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`layout`关键字❶显式地设置顶点属性`aVert`的位置——在此案例中是 0。这个属性让顶点着色器访问你为多边形定义的顶点。从❷开始，你声明了三个`uniform`变量，用于投影矩阵、模型视图矩阵和旋转角度。这些变量将在
    Python 代码中设置。你还设置了一个 2D 向量`vTexCoord`作为此着色器的输出❸。它将作为片段着色器的输入。
- en: In the `main()` method in the shader, you set up a rotation matrix ❹, which
    rotates around the x-axis by a given angle, `uTheta`. You compute `gl_Position`
    ❺ using a concatenation of the projection, modelview, and rotation matrices. This
    gives you the position of the output vertex from the shader. You then set up a
    2D vector as a texture coordinate ❻. You may recall that you defined the triangle
    strip for a square centered at the origin with side 1.0\. Because texture coordinates
    are in the range [0, 1], you can generate these from the vertex coordinates by
    adding (0.5, 0.5) to the x- and y-values. This also demonstrates the power and
    immense flexibility of shaders for your computations. Texture coordinates and
    other variables aren’t sacrosanct; you can set them to just about anything.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器的`main()`方法中，你设置了一个旋转矩阵❹，它绕着 x 轴按给定的角度`uTheta`进行旋转。你通过连接投影矩阵、模型视图矩阵和旋转矩阵来计算`gl_Position`❺。这将为你提供着色器输出顶点的位置。接着，你设置了一个二维向量作为纹理坐标❻。你可能记得你为一个以原点为中心、边长为
    1.0 的正方形定义了三角形条带。因为纹理坐标的范围是[0, 1]，你可以通过将(0.5, 0.5)加到 x 和 y 值上来生成这些纹理坐标。这也展示了着色器在计算中的强大和巨大的灵活性。纹理坐标和其他变量并非不可更改；你可以将它们设置为几乎任何值。
- en: 'Now let’s look at the fragment shader, which computes the output pixels of
    our OpenGL program:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下片段着色器，它计算我们 OpenGL 程序的输出像素：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You start by defining inputs to the fragment shader—in this case the texture
    coordinate you set as output in the vertex shader ❶. Recall that the fragment
    shader operates on a per-pixel basis, so the values set for these variables are
    those for the current pixel, interpolated across the polygon. You declare a `sampler2D`
    variable ❷, which is linked to a particular texture unit and is used to look up
    the texture value, and a Boolean uniform flag `showCircle` ❸, which is set from
    the Python code. You also declare `fragColor` as the output from the fragment
    shader ❹. By default, this goes to the screen (after final frame buffer operations
    such as depth testing and blending).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先定义了片段着色器的输入——在本例中是你在顶点着色器中设置为输出的纹理坐标❶。回想一下，片段着色器是按像素操作的，因此为这些变量设置的值是当前像素的值，这些值是跨多边形进行插值的。你声明了一个`sampler2D`变量❷，它链接到一个特定的纹理单元，并用于查找纹理值，还有一个布尔型的
    uniform 标志`showCircle`❸，它是从 Python 代码中设置的。你还声明了`fragColor`作为片段着色器的输出❹。默认情况下，它会被送到屏幕上（经过最终的帧缓冲操作，如深度测试和混合）。
- en: Within the `main()` method, if the `showCircle` flag is not set ❼, you use the
    GLSL `texture()` method to look up the texture color value using the texture coordinate
    and the sampler. In effect, you’re just texturing the triangle strip using the
    star image. If, however, the `showCircle` flag is `true` ❺, you use the GLSL built-in
    method `distance()` to check how far the current pixel is from the center of the
    polygon. It uses the (interpolated) texture coordinates for this purpose, which
    are passed in by the vertex shader. If the distance is greater than a certain
    threshold (0.5 in this case), you call the GLSL `discard()` method, which drops
    the current pixel. If the distance is less than the threshold, you set the appropriate
    color from the texture ❻. Basically, what this does is ignore pixels that are
    outside a circle with a radius of 0.5 centered at the midpoint of the square,
    thus cutting the polygon into a circle when `showCircle` is set.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`方法中，如果没有设置`showCircle`标志❼，你使用 GLSL 的`texture()`方法，通过纹理坐标和采样器查找纹理颜色值。实际上，你只是用星形图像给三角形条带加上纹理。然而，如果`showCircle`标志为`true`❺，你使用
    GLSL 内建的`distance()`方法来检查当前像素与多边形中心的距离。它使用（插值后的）纹理坐标进行此操作，而这些坐标是由顶点着色器传递过来的。如果距离大于某个阈值（在此案例中为
    0.5），你调用 GLSL 的`discard()`方法，这将丢弃当前像素。如果距离小于阈值，则从纹理中设置相应的颜色❻。基本上，这么做是为了忽略位于正方形中心半径为
    0.5 的圆形外部的像素，从而在`showCircle`被设置时将多边形切割成一个圆形。
- en: '[Utility Functions](nsp-venkitachalam503045-0008.xhtml#rbh1109)'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[工具函数](nsp-venkitachalam503045-0008.xhtml#rbh1109)'
- en: 'I’ve referred to several utility functions defined for you in *glutils.py*
    to make working with OpenGL easier. Let’s look at an example of one of those functions
    now. The `loadTexture()` function loads an image into an OpenGL texture:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过为了方便使用 OpenGL，你可以使用在*glutils.py*中定义的几个工具函数。现在我们来看其中一个函数的例子。`loadTexture()`函数将图像加载到
    OpenGL 纹理中：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `loadTexture()` function uses the Python Imaging Library (PIL) `Image` module
    to read the image file ❶. Then it gets the data out of the `Image` object onto
    an 8-bit `numpy` array ❷ and creates an OpenGL `texture` object ❸, which is a
    prerequisite to doing anything with textures in OpenGL. You next perform the now
    familiar binding to the `texture` object ❹ so all further texture-related settings
    apply to this object. You set the unpacking alignment of data to 1 ❺, which means
    the image data will be considered to be 1-byte or 8-bit data by the hardware.
    Starting at ❻, you tell OpenGL what to do with the texture at the edges. In this
    case, you direct it to just clamp the texture color to the edge of the geometry.
    (In specifying texture coordinates, the convention is to use the letters `S` and
    `T` for the axes instead of `x` and `y`.) At ❼ and the following line, you specify
    the kind of interpolation to be used when the texture is stretched or compressed
    to map onto a polygon. In this case, *linear filtering* is specified. Finally,
    you set the image data in the bound texture ❽. At this point, the image data is
    transferred to graphics memory, and the texture is ready for use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadTexture()` 函数使用 Python Imaging Library (PIL) 的 `Image` 模块来读取图像文件 ❶。然后，它将
    `Image` 对象中的数据提取到一个 8 位的 `numpy` 数组 ❷ 中，并创建一个 OpenGL `texture` 对象 ❸，这是在 OpenGL
    中操作纹理的前提。接下来，你执行了现在熟悉的绑定操作，将 `texture` 对象 ❹ 绑定，这样所有后续与纹理相关的设置都会应用于该对象。你将数据的解包对齐方式设置为
    1 ❺，这意味着图像数据将被硬件视为 1 字节或 8 位数据。从 ❻ 开始，你告诉 OpenGL 如何处理纹理的边缘。在这个例子中，你指示它将纹理颜色限制到几何体的边缘。（在指定纹理坐标时，通常使用字母
    `S` 和 `T` 来表示轴，而不是 `x` 和 `y`。）在 ❼ 和接下来的行中，你指定了纹理在拉伸或压缩时映射到多边形的插值方式。在这种情况下，指定了*线性过滤*。最后，你将图像数据设置到已绑定的纹理
    ❽ 中。此时，图像数据已传输到图形内存，纹理已经可以使用。'
- en: '[Running the OpenGL Application](nsp-venkitachalam503045-0008.xhtml#rah1104)'
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行 OpenGL 应用程序](nsp-venkitachalam503045-0008.xhtml#rah1104)'
- en: 'Here is a sample run of the project:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该项目的一个示例运行：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You saw the output in [Figure 9-1](nsp-venkitachalam503045-0023.xhtml#fig9-1).
    Be sure to try some keypresses to toggle the circle on and off.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [图 9-1](nsp-venkitachalam503045-0023.xhtml#fig9-1) 中看到输出。记得尝试按键切换圆形的显示与隐藏。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1105)'
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah1105)'
- en: Congratulations on completing your first program using Python and OpenGL! Through
    this project, you’ve learned about creating 3D transformations, using the OpenGL
    3D graphics pipeline, and using GLSL vertex and fragment shaders to create interesting
    3D graphics. You’ve begun your journey into the fascinating world of 3D graphics
    programming.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了使用 Python 和 OpenGL 编写的第一个程序！通过这个项目，你学会了如何创建 3D 变换，使用 OpenGL 3D 图形管线，以及使用
    GLSL 顶点和片段着色器来创建有趣的 3D 图形。你已经开始了进入迷人的 3D 图形编程世界的旅程。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1106)'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah1106)'
- en: 'Here are some ideas for modifying this project:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些修改此项目的想法：
- en: '1\. The vertex shader in this project rotates the square around the x-axis
    (1, 0, 0). Can you make it rotate around the y-axis (0, 0, 1)? You can do this
    in one of two ways: first, by modifying the rotation matrix in the shader, or
    second, by computing this matrix in the Python code and passing it as a *uniform*
    into the shader. Try both!'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 本项目中的顶点着色器使得正方形围绕 x 轴 (1, 0, 0) 旋转。你能使其围绕 y 轴 (0, 0, 1) 旋转吗？你可以通过两种方式来实现：第一，修改着色器中的旋转矩阵；第二，在
    Python 代码中计算这个矩阵，并将其作为*uniform* 传递给着色器。试试看这两种方法！
- en: '2\. In the project, the texture coordinates are generated inside the vertex
    shader and passed to the fragment shader. This is a trick, and it works only because
    of the convenient values chosen for the vertices of the triangle strip. Pass the
    texture coordinates as a separate attribute into the vertex shader, similar to
    how the vertices are passed in. Now, can you make the star texture *tile* across
    the triangle strip? Instead of displaying a single star, you want to produce a
    4×4 grid of stars on the square. (Hint: use texture coordinates greater than 1.0
    and set `GL_TEXTURE_WRAP_S/T` parameters in `glTexParameterf()` to `GL_REPEAT`.)'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 在该项目中，纹理坐标是在顶点着色器内生成并传递到片段着色器的。这是一种技巧，只有选择了合适的三角形条的顶点值才有效。将纹理坐标作为单独的属性传递到顶点着色器中，类似于传递顶点的方式。现在，你能让星形纹理*拼接*在三角形条上吗？你希望在正方形上显示一个
    4×4 的星形网格，而不是单一的星星。（提示：使用大于 1.0 的纹理坐标，并在 `glTexParameterf()` 中将 `GL_TEXTURE_WRAP_S/T`
    参数设置为 `GL_REPEAT`。）
- en: '3\. By changing just your fragment shader, can you make your square look like
    [Figure 9-6](nsp-venkitachalam503045-0023.xhtml#fig9-6)? (Hint: use the GLSL `sin()`
    function.)'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 只需修改你的片段着色器，你能让你的方形看起来像[图 9-6](nsp-venkitachalam503045-0023.xhtml#fig9-6)吗？（提示：使用GLSL的`sin()`函数。）
- en: '![](images/nsp-venkitachalam503045-f09006.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f09006.jpg)'
- en: 'Figure 9-6: Using the fragment shader to block out concentric circles'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6：使用片段着色器绘制同心圆
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah1107)'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah1107)'
- en: 'Here’s the complete *simpleglfw.py* code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的*simpleglfw.py*代码：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
