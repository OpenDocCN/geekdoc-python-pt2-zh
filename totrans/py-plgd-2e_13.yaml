- en: '[9](nsp-venkitachalam503045-0008.xhtml#rch09)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[9](nsp-venkitachalam503045-0008.xhtml#rch09)'
- en: Understanding OpenGL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 OpenGL
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: In this project, you’ll create a simple program that displays a texture-mapped
    square using OpenGL and GLFW. OpenGL is a software interface to your graphics
    processing unit (GPU), and GLFW is a windowing toolkit. You’ll also learn how
    to use the C-like OpenGL Shading Language (GLSL) to write *shaders*—code that
    executes in the GPU. Shaders bring immense flexibility to computations in OpenGL.
    I’ll show you how to use GLSL shaders to transform and color geometry as you create
    a rotating, textured polygon (as shown in [Figure 9-1](nsp-venkitachalam503045-0023.xhtml#fig9-1)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将创建一个简单的程序，通过 OpenGL 和 GLFW 显示一个纹理映射的方形。OpenGL 是一种图形处理单元（GPU）的软件接口，GLFW
    是一个窗口工具包。你还将学习如何使用类似 C 的 OpenGL 着色语言（GLSL）编写*着色器*——在 GPU 中执行的代码。着色器为 OpenGL 中的计算带来了巨大的灵活性。我将向你展示如何使用
    GLSL 着色器来转换和着色几何图形，创建一个旋转的纹理多边形（如[图 9-1](nsp-venkitachalam503045-0023.xhtml#fig9-1)所示）。
- en: GPUs are optimized to perform the same operations on huge amounts of data repeatedly,
    in parallel, which makes them much faster than central processing units (CPUs)
    for rendering computer graphics. In addition, they’re being used for general-purpose
    computing, and specialized languages now let you harness your GPU hardware for
    all sorts of applications. You’ll leverage the GPU, OpenGL, and shaders in this
    project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 被优化为在巨大数据量上重复执行相同操作，并行处理，这使得它们在渲染计算机图形时比中央处理单元（CPU）快得多。此外，GPU 也被用于通用计算，现在有专门的语言可以让你利用
    GPU 硬件进行各种应用。在这个项目中，你将利用 GPU、OpenGL 和着色器。
- en: '![](images/nsp-venkitachalam503045-f09001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f09001.jpg)'
- en: 'Figure 9-1: The final image for the project in this chapter—a rotating polygon
    with a star image. This square polygon boundary is clipped to a black circle using
    a shader.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：本章项目的最终图像——一个旋转的多边形，包含星星图像。这个方形多边形的边界通过着色器被裁剪成一个黑色圆形。
- en: Python is an excellent “glue” language. There are a vast number of Python *bindings*
    available for libraries written in other languages, such as C, that allow you
    to use these libraries in Python. In this chapter and in [Chapters 10](nsp-venkitachalam503045-0024.xhtml#ch10)
    and [11](nsp-venkitachalam503045-0025.xhtml#ch11), you’ll use `PyOpenGL`, the
    Python binding to OpenGL, to create computer graphics.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种出色的“粘合”语言。对于用其他语言（如 C）编写的库，有大量的 Python *绑定* 可供使用，这些绑定使你能够在 Python
    中使用这些库。在本章以及[第 10 章](nsp-venkitachalam503045-0024.xhtml#ch10)和[第 11 章](nsp-venkitachalam503045-0025.xhtml#ch11)中，你将使用
    `PyOpenGL`，它是 Python 对 OpenGL 的绑定，用于创建计算机图形。
- en: 'Here are some of the concepts introduced in this project:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本项目中介绍的一些概念：
- en: • Using the GLFW windowing library for OpenGL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 GLFW 窗口库进行 OpenGL
- en: • Using GLSL to write vertex and fragment shaders
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 GLSL 编写顶点和片段着色器
- en: • Performing texture mapping
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 执行纹理映射
- en: • Using 3D transformations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 3D 变换
- en: First, let’s take a look at how OpenGL works.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看 OpenGL 是如何工作的。
- en: NOTE OpenGL went through a major transition a few years ago. It went from using
    a fixed function graphics pipeline to a programmable pipeline with a dedicated
    shading language. We refer to the latter as *modern OpenGL*, and that’s what we’ll
    be using in this book. Specifically, we’ll use OpenGL version 4.1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：几年前，OpenGL 经历了一个重大转变。从使用固定功能图形管线转变为使用可编程管线，并引入了专用的着色语言。我们称后者为*现代 OpenGL*，并且这就是我们在本书中将要使用的版本。具体来说，我们将使用
    OpenGL 版本 4.1。
- en: '[How OpenGL Works](nsp-venkitachalam503045-0008.xhtml#rah1101)'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[OpenGL 工作原理](nsp-venkitachalam503045-0008.xhtml#rah1101)'
- en: Modern OpenGL makes graphics appear on your screen through a sequence of operations
    commonly known as the *3D graphics pipeline*. [Figure 9-2](nsp-venkitachalam503045-0023.xhtml#fig9-2)
    shows a simplified representation of the OpenGL 3D graphics pipeline.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 OpenGL 通过一系列操作使图形出现在你的屏幕上，这些操作通常被称为*3D 图形管线*。[图 9-2](nsp-venkitachalam503045-0023.xhtml#fig9-2)展示了
    OpenGL 3D 图形管线的简化表示。
- en: '![](images/nsp-venkitachalam503045-f09002.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f09002.jpg)'
- en: 'Figure 9-2: The (simplified) OpenGL graphics pipeline'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：简化版 OpenGL 图形管线
- en: 'At their heart, computer graphics boil down to computing color values for the
    pixels on your screen. Say you want to make a triangle appear. In the first step
    of the pipeline, you define the 3D geometry by defining the vertices of the triangle
    in 3D space and specifying the colors associated with each vertex. These vertices
    and colors are held in data structures called *vertex buffer objects (VBOs)*.
    Next, you transform the vertices: the first transformation places the vertices
    in 3D space, and the second projects the 3D coordinates onto 2D space for display
    on a 2D screen. The color values for the corresponding vertices are also calculated
    in this step based on factors such as lighting, typically in code called the *vertex
    shader*.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机图形学的核心归结为为屏幕上的像素计算颜色值。假设你想显示一个三角形。在管线的第一步中，你通过在 3D 空间中定义三角形的顶点并指定与每个顶点相关的颜色来定义
    3D 几何图形。这些顶点和颜色被存储在名为*顶点缓冲对象 (VBOs)*的数据结构中。接下来，你需要变换这些顶点：第一次变换将顶点放置在 3D 空间中，第二次变换将
    3D 坐标投影到 2D 空间，以便在 2D 屏幕上显示。此步骤中，还会根据光照等因素计算相应顶点的颜色值，通常在被称为*顶点着色器*的代码中进行计算。
- en: Next, the geometry is *rasterized* (converted from a 3D representation to 2D
    pixels), and for each pixel (or *fragment*, to be more accurate), another block
    of code called the *fragment shader* is executed. Just as the vertex shader operates
    on 3D vertices, the fragment shader operates on the 2D fragments after rasterization.
    I say *fragment* rather than *pixel* since a pixel is what is displayed on the
    screen, whereas a fragment is the output of computations in the fragment shader,
    and depending on the next step in the pipeline, a fragment may be discarded before
    it becomes a pixel on the screen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，几何图形会被*光栅化*（从 3D 表示转换为 2D 像素），并且对于每个像素（或更准确地说是*片段*），会执行另一段代码，称为*片段着色器*。就像顶点着色器处理
    3D 顶点一样，片段着色器会在光栅化后处理 2D 片段。我之所以说*片段*而不是*像素*，是因为像素是屏幕上显示的内容，而片段是片段着色器计算后的输出，取决于管线中的下一步操作，片段可能在成为屏幕上的像素之前被丢弃。
- en: Finally, each fragment passes through a series of frame buffer operations, where
    it undergoes *depth buffer testing* (checking whether one fragment obscures another),
    *blending* (mixing two fragments with transparency), and other operations that
    combine its current color with what is already on the frame buffer at that location.
    These changes end up on the final frame buffer, which is typically displayed on
    the screen.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个片段会经过一系列帧缓冲操作，在这些操作中，它会进行*深度缓冲测试*（检查一个片段是否遮挡另一个片段）、*混合*（将两个带有透明度的片段混合）以及其他操作，这些操作将当前颜色与该位置帧缓冲中已有的颜色进行合并。这些变化最终会反映在最终的帧缓冲中，通常会显示在屏幕上。
- en: '[Geometric Primitives](nsp-venkitachalam503045-0008.xhtml#rbh1101)'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[几何原始图形](nsp-venkitachalam503045-0008.xhtml#rbh1101)'
- en: Because OpenGL is a low-level graphics library, you can’t ask it directly to
    draw a cube or a sphere, though libraries built on top of it can do such tasks
    for you. OpenGL understands only low-level geometric primitives, such as points,
    lines, and triangles.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 OpenGL 是一个低级图形库，你不能直接要求它绘制一个立方体或球体，尽管在其基础上构建的库可以为你完成这些任务。OpenGL 只理解低级几何原始图形，如点、线和三角形。
- en: Modern OpenGL supports only the primitive types `GL_POINTS`, `GL_LINES`, `GL_LINE_STRIP`,
    `GL_LINE_LOOP`, `GL_TRIANGLES`, `GL_TRIANGLE_STRIP`, and `GL_TRIANGLE_FAN`. [Figure
    9-3](nsp-venkitachalam503045-0023.xhtml#fig9-3) shows how the vertices for the
    primitives are organized. Each vertex has a 3D coordinate such as (*x*, *y*, *z*).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 OpenGL 只支持原始类型 `GL_POINTS`、`GL_LINES`、`GL_LINE_STRIP`、`GL_LINE_LOOP`、`GL_TRIANGLES`、`GL_TRIANGLE_STRIP`
    和 `GL_TRIANGLE_FAN`。[图 9-3](nsp-venkitachalam503045-0023.xhtml#fig9-3) 显示了原始图形顶点的组织方式。每个顶点都有一个
    3D 坐标，例如 (*x*, *y*, *z*)。
- en: '![](images/nsp-venkitachalam503045-f09003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f09003.jpg)'
- en: 'Figure 9-3: OpenGL primitives'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：OpenGL 原始图形
- en: To draw a sphere in OpenGL, first define the geometry of the sphere mathematically
    and compute its 3D vertices. Then assemble the vertices into basic geometric primitives;
    for example, you could group each set of three vertices into a triangle. You then
    render the vertices using OpenGL.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 OpenGL 中绘制一个球体，首先需要数学上定义球体的几何形状，并计算其 3D 顶点。然后，将顶点组合成基本的几何原始图形；例如，你可以将每组三个顶点组合成一个三角形。接着，使用
    OpenGL 渲染这些顶点。
- en: '[3D Transformations](nsp-venkitachalam503045-0008.xhtml#rbh1102)'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[3D 变换](nsp-venkitachalam503045-0008.xhtml#rbh1102)'
- en: You can’t learn computer graphics without learning about 3D transformations.
    Conceptually, these are quite simple to understand. You have an object—what can
    you do to it? You can move it, stretch (or squash) it, or rotate it. You can do
    other things to it too, but these three tasks—translation, scale, and rotation—are
    the operations or transformations most commonly performed on an object. In addition
    to these commonly used transformations, you’ll use a perspective projection to
    map the 3D objects onto the 2D plane of the screen. These transformations are
    all applied on the coordinates of the object you are trying to transform.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: While you’re probably familiar with 3D coordinates in the form (*x*, *y*, *z*),
    in 3D computer graphics you use coordinates in the form (*x*, *y*, *z*, *w*), called
    *homogeneous coordinates*. (These coordinates come from a branch of mathematics
    called *projective geometry*, which is beyond the scope of this book.) Homogeneous
    coordinates allow you to express common 3D transformations such as translation,
    scale, and rotation as 4×4 matrices. But for the purposes of these OpenGL projects,
    all you need to know is that the homogeneous coordinate (*x*, *y*, *z*, *w*) is
    equivalent to the 3D coordinate (*x*/*w*, *y*/*w*, *z*/*w*, 1.0). A 3D point (1.0,
    2.0, 3.0) can be expressed in homogeneous coordinates as (1.0, 2.0, 3.0, 1.0).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a 3D transformation using a 4×4 matrix. See how the matrix
    multiplication translates a point (*x*, *y*, *z*, 1.0) to (*x* + *t*[x], *y* +
    *t*[y], *z* +*t*[z], 1.0):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m09001.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Since this operation translates a point in space, the 4×4 matrix involved is
    called a *translation matrix*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now look at another useful matrix for 3D transformation—a rotation matrix.
    The following matrix rotates a point (*x*, *y*, *z*, 1.0) counterclockwise around
    the x-axis by θ radians:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m09002.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'But here’s something to keep in mind: if you’re going to apply this rotation
    inside shader code, the matrix will be stored in *column-major format*, which
    means you should declare it as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: // rotational transform
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: mat4 rot =  mat4(
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: vec4(1.0,  0.0,          0.0,         0.0),
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: vec4(0.0,  cos(uTheta),  sin(uTheta), 0.0),
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: vec4(0.0, -sin(uTheta),  cos(uTheta), 0.0),
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: vec4(0.0,  0.0,          0.0,         1.0)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, in the code, the matrix is flipped along its diagonal compared
    to the definition of *R*[θ][,][x].
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Two terms that you will encounter often in OpenGL are *modelview* and *projection*
    transformations. With the advent of customizable shaders in modern OpenGL, modelviews
    and projections are just generic transformations. Historically, in old-school
    versions of OpenGL, the modelview transformations were applied to your 3D model
    to position it in space, and the projection transformations were used to map the
    3D coordinates onto a 2D surface for display, as you’ll see in a moment. Modelview
    transformations are user-defined transformations that let you position your 3D
    objects, and projection transformations are projective transformations that map
    3D onto 2D.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL 中你会经常遇到两个术语：*模型视图*和*投影*变换。随着现代 OpenGL 引入可自定义着色器，模型视图和投影变换变成了通用的变换。在老版本的
    OpenGL 中，模型视图变换用于将 3D 模型定位到空间中，而投影变换则用于将 3D 坐标映射到 2D 表面进行显示，正如你将看到的那样。模型视图变换是用户自定义的变换，让你定位
    3D 物体，而投影变换则是投影变换，将 3D 映射到 2D。
- en: The two most commonly used 3D graphics projective transformations are *orthographic*
    and *perspective*, but here you’ll use only perspective projections, which are
    defined by a *field of view* (the extent to which the eye can see), a *near plane*
    (the plane closest to the eye), a *far plane* (the plane farthest from the eye),
    and an *aspect ratio* (the ratio of the width to the height of the near plane).
    Together, these parameters constitute a camera model for a projection that determines
    how the 3D figure will be mapped onto a 2D screen, as shown in [Figure 9-4](nsp-venkitachalam503045-0023.xhtml#fig9-4).
    The truncated pyramid shown in the figure is the *view frustum*. The *eye* is
    the 3D location where you place the camera. (For orthographic projection, the
    eye will be at infinity, and the pyramid will become a rectangular cuboid.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 两种最常用的 3D 图形投影变换是*正交投影*和*透视投影*，但在这里你将只使用透视投影，它由*视野*（眼睛能看到的范围）、*近平面*（离眼睛最近的平面）、*远平面*（离眼睛最远的平面）和*纵横比*（近平面宽高的比例）定义。这些参数共同构成了一个相机模型，用于定义如何将
    3D 物体映射到 2D 屏幕上，如[图 9-4](nsp-venkitachalam503045-0023.xhtml#fig9-4)所示。图中的截头金字塔就是*视锥体*。*眼睛*是你放置相机的
    3D 位置。（对于正交投影，眼睛的位置会在无限远处，金字塔将变成一个矩形立方体。）
- en: '![](images/nsp-venkitachalam503045-f09004.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f09004.jpg)'
- en: 'Figure 9-4: A perspective projection camera model'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：一个透视投影相机模型
- en: Once the perspective projection is complete and before rasterization, the graphics
    primitives are clipped (or cut out) against the near and far planes shown in [Figure
    9-4](nsp-venkitachalam503045-0023.xhtml#fig9-4). The near and far planes are chosen
    such that the 3D objects you want to appear onscreen lie inside the view frustum;
    otherwise, they will be clipped away.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦透视投影完成，并且在光栅化之前，图形原语会在[图 9-4](nsp-venkitachalam503045-0023.xhtml#fig9-4)所示的近平面和远平面之间进行裁剪（或剔除）。近平面和远平面的选择确保了你希望在屏幕上显示的
    3D 物体位于视锥体内；否则，它们将被裁剪掉。
- en: '[Shaders](nsp-venkitachalam503045-0008.xhtml#rbh1103)'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[着色器](nsp-venkitachalam503045-0008.xhtml#rbh1103)'
- en: You’ve seen how shaders fit into the modern OpenGL programmable graphics pipeline.
    Now let’s look at a simple pair of vertex and fragment shaders to get a sense
    of how GLSL works.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了着色器如何融入现代 OpenGL 可编程图形管线。现在，让我们看一个简单的顶点着色器和片段着色器，了解 GLSL 如何工作。
- en: A Vertex Shader
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个顶点着色器
- en: 'Here is a simple vertex shader that computes the position and color of a vertex:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的顶点着色器，用于计算顶点的位置和颜色：
- en: '❶ # version 410 core'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ # version 410 core'
- en: ❷ in vec3 aVert;
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ in vec3 aVert;
- en: ❸ uniform mat4 uMVMatrix;
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ uniform mat4 uMVMatrix;
- en: ❹ uniform mat4 uPMatrix;
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ uniform mat4 uPMatrix;
- en: ❺ out vec4 vCol;
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ out vec4 vCol;
- en: void main() {
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: void main() {
- en: // apply transformations
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: // 应用变换
- en: ❻ gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
- en: // set color
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: // 设置颜色
- en: ❼ vCol = vec4(1.0, 0.0, 0.0, 1.0);
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ vCol = vec4(1.0, 0.0, 0.0, 1.0);
- en: '}'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: You first set the version of GLSL used in the shader to version 4.1 ❶. Then
    you define an input named `aVert` of type `vec3` (a 3D vector) for the vertex
    shader using the keyword `in` ❷. You next define two variables of type `mat4`
    (4×4 matrices), which correspond to the modelview ❸ and projection ❹ matrices.
    The `uniform` prefix to these variables indicates that they do not change during
    execution of the vertex shader for a given rendering call on a set of vertices.
    You use the `out` prefix to define the output of the vertex shader, which is a
    color variable of type `vec4` (a 4D vector to store red, green, blue, and alpha
    channels) ❺.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先将着色器使用的GLSL版本设置为4.1版本❶。然后你定义了一个名为`aVert`的`vec3`类型（3D向量）输入，用于顶点着色器，使用了`in`关键字❷。接下来，你定义了两个`mat4`类型（4×4矩阵）的变量，它们分别对应模型视图❸和投影❹矩阵。这些变量的`uniform`前缀表示它们在给定渲染调用的一组顶点上，顶点着色器执行期间不会发生变化。你使用`out`前缀来定义顶点着色器的输出，它是一个`vec4`类型的颜色变量（一个4D向量，用于存储红、绿、蓝和透明度通道）❺。
- en: Now you come to the `main()` function, where the vertex shader program starts.
    The value of `gl_Position` is computed by transforming the input `aVert` using
    the uniform matrices passed in ❻. The GLSL variable `gl_Position` is used to store
    the transformed vertices. You set the output color from the vertex shader to red
    with no transparency by using the value (1, 0, 0, 1) ❼. You’ll use this as input
    in the next shader in the pipeline.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你来到了`main()`函数，这里是顶点着色器程序的开始。`gl_Position`的值是通过使用传入的统一矩阵❻变换输入的`aVert`来计算的。GLSL变量`gl_Position`用于存储变换后的顶点。你通过使用值(1,
    0, 0, 1)❼将顶点着色器的输出颜色设置为红色且无透明度。你将在管线中的下一个着色器中使用这个值作为输入。
- en: A Fragment Shader
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 片段着色器
- en: 'Now let’s look at a simple fragment shader that computes the fragment color
    based on the vertex color passed in:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个简单的片段着色器，它根据传入的顶点颜色来计算片段颜色：
- en: '❶ # version 410 core'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ # version 410 core'
- en: ❷ in vec4 vCol;
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ in vec4 vCol;
- en: ❸ out vec4 fragColor;
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ out vec4 fragColor;
- en: void main() {
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: void main() {
- en: // use vertex color
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用顶点颜色
- en: ❹ fragColor = vCol;
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ fragColor = vCol;
- en: '}'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: After setting the version of GLSL used in the shader ❶, you set `vCol` as the
    input to the fragment shader ❷. This variable, `vCol`, was set as output from
    the vertex shader. (Remember, the vertex shader executes for every vertex in the
    3D scene, whereas the fragment shader executes for every fragment on the screen.)
    You also set the fragment shader’s output color variable `fragColor` ❸.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了着色器中使用的GLSL版本❶之后，你将`vCol`设置为片段着色器的输入❷。这个变量`vCol`是从顶点着色器输出的。(记住，顶点着色器在3D场景中的每个顶点上执行，而片段着色器在屏幕上的每个片段上执行。)你还设置了片段着色器的输出颜色变量`fragColor`❸。
- en: During rasterization (which occurs between the vertex and fragment shaders),
    OpenGL converts the transformed vertices to fragments, and the color of the fragments
    lying between the vertices is calculated by interpolating the color values at
    the vertices; `vCol` in the previous code is this interpolated color. You set
    the fragment shader’s output to be the same as the interpolated color going into
    the fragment shader ❹. By default, and in most cases, the intended output of the
    fragment shader is the screen, and the color you set ends up there (unless it’s
    affected by operations, such as depth testing, that occur in the final stage of
    the graphics pipeline).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在光栅化阶段（发生在顶点着色器和片段着色器之间），OpenGL将变换后的顶点转换为片段，并通过插值计算位于顶点之间的片段的颜色；在之前的代码中，`vCol`就是这个插值后的颜色。你将片段着色器的输出设置为传入片段着色器的插值颜色❹。默认情况下，且在大多数情况下，片段着色器的预期输出是屏幕，你设置的颜色最终会显示在那里（除非它受到在图形管线最后阶段发生的操作（如深度测试）的影响）。
- en: For the GPU to execute the shader code, it needs to be compiled and linked to
    instructions that the hardware understands. OpenGL provides ways to do this and
    reports detailed compiler and linker errors that will help you develop the shader
    code. The compilation process also generates a table of locations or indices for
    the variables declared in your shaders so you can connect them to variables in
    your Python code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让GPU执行着色器代码，着色器代码需要被编译并链接为硬件能够理解的指令。OpenGL提供了方法来完成这一过程，并报告详细的编译器和链接器错误，帮助你开发着色器代码。编译过程还会生成一个包含着色器中声明的变量位置或索引的表格，以便你将它们连接到Python代码中的变量。
- en: '[Vertex Buffers](nsp-venkitachalam503045-0008.xhtml#rbh1104)'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[顶点缓冲区](nsp-venkitachalam503045-0008.xhtml#rbh1104)'
- en: '*Vertex buffers* are an important mechanism used by OpenGL shaders. Modern
    graphics hardware and OpenGL are designed to work with large amounts of 3D geometry.
    Consequently, several mechanisms are built into OpenGL to help transfer data from
    the program to the GPU. A typical setup to draw 3D geometry in a program will
    do the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Define arrays of coordinates, colors, and other attributes for each vertex
    of the 3D geometry.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Create a vertex array object (VAO) and bind to it.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Create vertex buffer objects (VBOs) for each attribute, defined on a per-vertex
    basis.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Bind to the VBO and set the buffer data using the predefined arrays.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5\. Specify the data and location of vertex attributes to be used in the shader.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6\. Enable the vertex attributes.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 7\. Render the data.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you define the 3D geometry in terms of vertices, you create and bind to
    a vertex array object. VAOs are a convenient way to group geometry as multiple
    arrays of coordinates, colors, and so on. Then, for each attribute of each vertex,
    you create a vertex buffer object and set your 3D data into it. The VBO stores
    the vertex data in the GPU memory. Now, all that’s left is to connect the buffer
    data so you can access it from your shaders. You do this through calls that use
    the location of the variables employed in the shader.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[Texture Mapping](nsp-venkitachalam503045-0008.xhtml#rbh1105)'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s look at texture mapping, an important computer graphics technique
    that you’ll use in this chapter. *Texture mapping* is a way to give a scene a
    realistic feel with the help of a 2D picture of a 3D object (like the backdrop
    in a play). A texture is usually read from an image file and is stretched to drape
    over a geometric region by mapping the 2D coordinates (in the range [0, 1]) onto
    the 3D coordinates of the polygons. For example, [Figure 9-5](nsp-venkitachalam503045-0023.xhtml#fig9-5)
    shows an image draped onto one face of a cube. (I used `GL_TRIANGLE_STRIP` primitives
    to draw the cube faces, and the ordering of the vertices is indicated by the lines
    on the face.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f09005.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-5: Texture mapping'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 9-5](nsp-venkitachalam503045-0023.xhtml#fig9-5), the (0, 0) corner
    of the texture is mapped to the bottom-left vertex of the cube face. Similarly,
    you can see how the other corners of the texture are mapped, with the net effect
    that the texture is “pasted” onto this cube face. The geometry of the cube face
    itself is defined as a triangle strip, and the vertices zigzag from the bottom
    to the top left and from the bottom to the top right. Textures are extremely powerful
    and versatile computer graphics tools, as you’ll see in [Chapter 11](nsp-venkitachalam503045-0025.xhtml#ch11).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[The OpenGL Context](nsp-venkitachalam503045-0008.xhtml#rbh1106)'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s talk about how to get OpenGL to draw stuff on the screen. The entity
    that stores all the OpenGL state information is called the *OpenGL context*. Contexts
    have a viewable, window-like area where the OpenGL drawings go, and you can have
    multiple contexts per process or run of an application, but only one context per
    thread can be current at a time. (Fortunately, the window toolkit will take care
    of most of the context handling.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来谈谈如何让 OpenGL 在屏幕上绘制内容。存储所有 OpenGL 状态信息的实体被称为 *OpenGL 上下文*。上下文拥有一个可视的、类似窗口的区域用于显示
    OpenGL 绘图，你可以为每个进程或应用程序运行拥有多个上下文，但每个线程一次只能有一个上下文是当前的。（幸运的是，窗口工具包会处理大部分的上下文管理。）
- en: For your OpenGL output to appear in a window onscreen, you need the help of
    the operating system. For these projects, you’ll use GLFW, a lightweight cross-platform
    C library that lets you create and manage OpenGL contexts, display the 3D graphics
    in a window, and handle user input such as mouse clicks and keypresses. ([Appendix
    A](nsp-venkitachalam503045-0031.xhtml#appa) covers the installation details for
    this library.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的 OpenGL 输出显示在屏幕上的窗口中，你需要操作系统的帮助。在这些项目中，你将使用 GLFW，一个轻量级的跨平台 C 库，它让你创建和管理
    OpenGL 上下文，展示 3D 图形在窗口中，并处理诸如鼠标点击和键盘按键等用户输入。（[附录 A](nsp-venkitachalam503045-0031.xhtml#appa)
    介绍了该库的安装细节。）
- en: Because you’re writing code in Python and not C, you’ll also use a Python binding
    to GLFW (*glfw.py*, available in the *common* directory in the book’s code repository),
    which lets you access all the GLFW features using Python.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用 Python 编写代码而非 C，因此你还将使用一个 Python 绑定库来访问 GLFW（*glfw.py*，可以在本书代码仓库中的 *common*
    目录下找到），该库让你能够使用 Python 来访问所有 GLFW 的功能。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1102)'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah1102)'
- en: You’ll use `PyOpenGL`, a popular Python binding for OpenGL, for rendering, and
    you’ll use `numpy` arrays to represent 3D coordinates and transformation matrices.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `PyOpenGL`，一个流行的 Python 绑定库，用于 OpenGL 渲染，同时使用 `numpy` 数组表示 3D 坐标和变换矩阵。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1103)'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1103)'
- en: In this project, you’ll build a simple Python application for displaying a rotating,
    textured polygon using OpenGL. To see the complete project code, skip ahead to
    [“The Complete Code”](nsp-venkitachalam503045-0023.xhtml#ah1107) on [page 172](nsp-venkitachalam503045-0023.xhtml#p172).
    The complete code for our simple OpenGL application resides in two files. The
    main project code discussed in this chapter is in *simpleglfw.py*, which can be
    found at [https://github.com/mkvenkit/pp2e/tree/main/simplegl](https://github.com/mkvenkit/pp2e/tree/main/simplegl).
    The helper functions are in *glutils.py*, which can be found in the GitHub repository’s
    *common* directory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将构建一个简单的 Python 应用程序，用于使用 OpenGL 显示一个旋转的、带有纹理的多边形。要查看完整的项目代码，请跳转到 [“完整代码”](nsp-venkitachalam503045-0023.xhtml#ah1107)，见
    [第172页](nsp-venkitachalam503045-0023.xhtml#p172)。我们简单的 OpenGL 应用程序的完整代码分布在两个文件中。本章讨论的主要项目代码在
    *simpleglfw.py* 中，可以在 [https://github.com/mkvenkit/pp2e/tree/main/simplegl](https://github.com/mkvenkit/pp2e/tree/main/simplegl)
    找到。辅助函数位于 *glutils.py* 文件中，可以在 GitHub 仓库的 *common* 目录中找到。
- en: '[The RenderWindow Class](nsp-venkitachalam503045-0008.xhtml#rbh1107)'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[RenderWindow 类](nsp-venkitachalam503045-0008.xhtml#rbh1107)'
- en: The `RenderWindow` class manages the creation of the window that displays the
    OpenGL graphics. It initializes GLFW, sets up OpenGL, manages rendering, and sets
    up callbacks to receive keyboard input.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderWindow` 类负责管理显示 OpenGL 图形的窗口的创建。它初始化 GLFW，设置 OpenGL，管理渲染，并设置回调以接收键盘输入。'
- en: Creating an OpenGL Window
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 OpenGL 窗口
- en: 'The first order of business of the `RenderWindow` class is to set up GLFW so
    you have an OpenGL window to render into. The class’s initialization code addresses
    this task:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderWindow` 类的首要任务是设置 GLFW，以便你能拥有一个用于渲染的 OpenGL 窗口。该类的初始化代码完成了这一任务：'
- en: 'class RenderWindow:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'class RenderWindow:'
- en: '"""GLFW rendering window class"""'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '"""GLFW 渲染窗口类"""'
- en: 'def __init__(self):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: '# save current working directory'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '# 保存当前工作目录'
- en: cwd = os.getcwd()
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: cwd = os.getcwd()
- en: '# initialize glfw'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化 glfw'
- en: ❶ glfw.glfwInit()
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ glfw.glfwInit()
- en: '# restore cwd'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '# 恢复 cwd'
- en: os.chdir(cwd)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: os.chdir(cwd)
- en: '# version hints'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '# 版本提示'
- en: ❷ glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 4)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 4)
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 1)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 1)
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,
- en: glfw.GLFW_OPENGL_CORE_PROFILE)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.GLFW_OPENGL_CORE_PROFILE)
- en: '# make a window'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建一个窗口'
- en: self.width, self.height = 800, 600
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = self.width/float(self.height)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.win = glfw.glfwCreateWindow(self.width, self.height,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: b'simpleglfw')
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '# make the context current'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: ❹ glfw.glfwMakeContextCurrent(self.win)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: You initialize the GLFW library ❶, and then, starting at ❷, you set the OpenGL
    version to the OpenGL 4.1 core profile. You next create an OpenGL-capable window
    with the dimensions 800×600 ❸. Finally, you make the context current ❹, and you’re
    ready to make OpenGL calls.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, still within the `__init__()` definition, you make some initialization calls:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize GL'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: ❶ glViewport(0, 0, self.width, self.height)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: ❷ glEnable(GL_DEPTH_TEST)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: ❸ glClearColor(0.5, 0.5, 0.5, 1.0)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Here you set the viewport or screen dimensions (width and height) where OpenGL
    will render your 3D scene ❶. Then you turn on depth testing with `GL_DEPTH_TEST`
    ❷ and set the color the background should become when `glClear()` is issued during
    rendering ❸. You choose 50 percent gray with an `alpha` setting of 1.0\. (Alpha
    is a measure of the transparency of a fragment—1.0 means fully opaque.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Setting Callbacks
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You finish the `__init__()` definition by registering event callbacks for user
    interface events within the GLFW window so you can respond to keypresses:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '# set window callbacks'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetKeyCallback(self.win, self.onKeyboard)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'This code sets callbacks for keypresses. Every time one of these events happens,
    the function registered as a callback, `onKeyboard()`, is executed. Let’s look
    at the definition of that keyboard callback function now:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'def onKeyboard(self, win, key, scancode, action, mods):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''keyboard: '', win, key, scancode, action, mods'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '❶ if action == glfw.GLFW_PRESS:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '# ESC to quit'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'if key == glfw.GLFW_KEY_ESCAPE:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.exitNow = True
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '# toggle cut'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.scene.showCircle = not self.scene.showCircle
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The `onKeyboard()` callback is called every time a keyboard event happens. The
    arguments to the function arrive filled with useful information such as what type
    of event occurred (key-up versus key-down, for example) and which key was pressed.
    The code `glfw.GLFW_PRESS` says to look only for key-down, or `PRESS`, events
    ❶. You set an exit flag if the ESC key is pressed ❷. If any other key is pressed,
    you toggle a `showCircle` Boolean ❸. This variable will be used in the fragment
    shader to keep or discard fragments outside the circle area.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Main Loop
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `RenderWindow` class also defines the main loop of the program through
    its `run()` method. (GLFW doesn’t provide a default program loop.) The `run()`
    method updates the OpenGL window at a preset time interval. After calling the
    render methods to draw the scene, it also polls the system for any pending window
    or keyboard events. Let’s look at the method definition:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'def run(self):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '# initializer timer'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: ❶ glfw.glfwSetTime(0)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: t = 0.0
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '❷ while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '# update every x seconds'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: ❸ currT = glfw.glfwGetTime()
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'if currT - t > 0.1:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '# update time'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: t = currT
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: t = currT
- en: '# clear'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '# 清除'
- en: ❹ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
- en: '# set viewport'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置视口'
- en: ❺ self.width, self.height = glfw.glfwGetFramebufferSize(self.win)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ self.width, self.height = glfw.glfwGetFramebufferSize(self.win)
- en: ❻ self.aspect = self.width/float(self.height)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ self.aspect = self.width/float(self.height)
- en: ❼ glViewport(0, 0, self.width, self.height)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ glViewport(0, 0, self.width, self.height)
- en: In the main loop, `glfw.glfwSetTime()` resets the GLFW timer to 0 ❶. You’ll
    use this timer to redraw the graphics at regular intervals. You initiate a `while`
    loop ❷ that exits only if the window is closed or `exitNow` is set to `True`.
    When the loop exits, `glfw.glfwTerminate()` is called to shut down GLFW cleanly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，`glfw.glfwSetTime()`将GLFW计时器重置为0 ❶。你将使用这个计时器定期重新绘制图形。你启动了一个`while`循环 ❷，只有当窗口关闭或`exitNow`设置为`True`时，循环才会退出。循环退出后，调用`glfw.glfwTerminate()`来干净地关闭GLFW。
- en: Inside the loop, `glfw.glfwGetTime()` gets the current timer value ❸, which
    you use to calculate the elapsed time since the last drawing. By setting a desired
    interval here (in this case, to 0.1 second or 100 milliseconds), you can adjust
    the rendering frame rate. Next, `glClear()` clears the depth and color buffers
    and replaces them with the set background color to get ready for the next frame
    ❹.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，`glfw.glfwGetTime()`获取当前计时器值 ❸，你用它来计算自上次绘制以来的经过时间。通过在这里设置一个期望的间隔（在这种情况下为0.1秒或100毫秒），你可以调整渲染的帧率。接着，`glClear()`清除深度和颜色缓冲区，并用设置的背景色替换它们，以准备下一帧
    ❹。
- en: You query and set the window width and height using the `glfwGetFramebufferSize()`
    function ❺. You do this in case the user has changed the window’s size. Note that
    in some systems (such as a MacBook with Retina display) the window size and frame
    buffer size can be different, so to be safe, always query the latter. You next
    compute the aspect ratio of the window ❻, which you’ll use later to set the projection
    matrix. Then you clear the viewport using the new frame buffer dimensions you
    retrieved ❼.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`glfwGetFramebufferSize()`函数查询并设置窗口的宽度和高度 ❺。这样做是为了应对用户可能改变了窗口的大小。请注意，在某些系统中（如配备视网膜显示屏的MacBook），窗口大小和帧缓冲区大小可能不同，因此为了安全起见，始终查询后者。接下来，你计算窗口的宽高比
    ❻，稍后将用它来设置投影矩阵。然后你使用获取到的新帧缓冲区尺寸 ❼ 清除视口。
- en: 'Now let’s look at the remaining part of the `run()` method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`run()`方法的剩余部分：
- en: '# build projection matrix'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构建投影矩阵'
- en: ❶ pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)
- en: ❷ mvMatrix = glutils.lookAt([0.0, 0.0, -2.0], [0.0, 0.0, 0.0],
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ mvMatrix = glutils.lookAt([0.0, 0.0, -2.0], [0.0, 0.0, 0.0],
- en: '[0.0, 1.0, 0.0])'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[0.0, 1.0, 0.0])'
- en: '# render'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '# 渲染'
- en: ❸ self.scene.render(pMatrix, mvMatrix)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.scene.render(pMatrix, mvMatrix)
- en: '# step'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '# 步骤'
- en: ❹ self.scene.step()
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ self.scene.step()
- en: ❺ glfw.glfwSwapBuffers(self.win)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ glfw.glfwSwapBuffers(self.win)
- en: '# poll for and process events'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查询和处理事件'
- en: ❻ glfw.glfwPollEvents()
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ glfw.glfwPollEvents()
- en: '# end'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '# 结束'
- en: glfw.glfwTerminate()
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: glfw.glfwTerminate()
- en: Still within the `while` loop, you compute the projection matrix using the `perspective()`
    method defined in *glutils.py* ❶. The projection matrix is the transformation
    that maps a 3D scene to a 2D screen. Here you ask for a 45-degree field of view
    and a near/far plane distance of 0.1/100.0\. Then you set the modelview matrix
    using the `lookAt()` method ❷, also defined in *glutils.py*. The default OpenGL
    view puts your eye at the origin looking along the negative z-direction. The modelview
    matrix created by the `lookAt()` method transforms the vertices such that the
    view matches up with the eye position and orientation specified by the call. You
    set the eye position to (0, 0, −2), looking at the origin (0, 0, 0) with an “up”
    vector of (0, 1, 0). Next, you call the `render()` method on the `scene` object
    ❸, passing in these matrices, and you call `scene.step()` so it can update the
    variables necessary for the time step ❹. (The `Scene` class, which we’ll look
    at next, encapsulates the setup and rendering of the polygon.) The `glfwSwapBuffers()`
    call ❺ swaps the back and front buffers, thus displaying your updated 3D graphic,
    and the `glfwPollEvents()` call ❻ checks for any UI events and returns control to
    the `while` loop.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[The Scene Class](nsp-venkitachalam503045-0008.xhtml#rbh1108)'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s look at the `Scene` class, which is responsible for initializing
    and drawing the 3D geometry. Here’s the start of the class declaration:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'class Scene:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '""" OpenGL 3D scene class"""'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '# initialization'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '# create shader'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: ❶ self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: ❷ glUseProgram(self.program)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: In the `Scene` class constructor, you first compile and load the shaders. For
    this, you use the utility method `loadShaders()` ❶ defined in *glutils.py*, which
    provides a convenient wrapper around the series of OpenGL calls required to load
    the shader code from strings, compile it, and link it into an OpenGL program object.
    Because OpenGL is a state machine, you need to set the code to use a particular
    “program object” (because a project could have multiple programs) using the `glUseProgram()`
    call ❷.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__init__()` method continues by connecting the variables in the Python
    code with those in the shaders:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: self.pMatrixUniform = glGetUniformLocation(self.program, b'uPMatrix')
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: self.mvMatrixUniform = glGetUniformLocation(self.program, b'uMVMatrix')
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '# texture'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: self.tex2D = glGetUniformLocation(self.program, b'tex2D')
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: This code uses the `glGetUniformLocation()` method to retrieve the locations
    of the variables `uPMatrix`, `uMVMatrix`, and `tex2D` defined inside the vertex
    and fragment shaders. These locations can then be used to set the values for the
    shader variables.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Defining the 3D Geometry
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next part of the `Scene` class’s `__init__()` method defines the 3D geometry
    for the scene. You first define the geometry for the polygon, which will take
    the form of a square:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '# define triangle strip vertices'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: ❶ vertexData = numpy.array(
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[-0.5, -0.5, 0.0,'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 0.5, -0.5, 0.0,
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: -0.5, 0.5, 0.0,
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 0.5, 0.5, 0.0], numpy.float32)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '# set up vertex array object (VAO)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.vao = glGenVertexArrays(1)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '# vertices'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.vertexBuffer = glGenBuffers(1)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: ❹ glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: GL_STATIC_DRAW)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '# enable vertex array'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: ❺ glEnableVertexAttribArray(0)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data pointer'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: ❻ glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: ❼ glBindVertexArray(0)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: First you define the array of vertices of the triangle strip used to draw the
    square ❶. Think of a square of a side length of 1.0 centered at the origin. The
    bottom-left vertex of this square has the coordinates (−0.5, −0.5, 0.0); the next
    vertex (the bottom-right one) has the coordinates (0.5, −0.5, 0.0); and so on.
    The order of the four coordinates is that of a `GL_TRIANGLE_STRIP`. Essentially,
    you’re creating the square by defining two right triangles with a shared hypotenuse.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Next, you create a VAO ❷. Once you bind to this VAO, all upcoming calls will
    be bound to it. You then create a VBO to manage the rendering of the vertex data
    ❸. Once the buffer is bound, you set the buffer data from the vertices you’ve
    defined ❹.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Now you need to enable the shaders to access this data. For that, you call `glEnableVertexAttribArray()`
    ❺. You use an index of 0 because that is the location you have set in the vertex
    shader for the vertex data variable. Calling `glVertexAttribPointer()` sets the
    location and data format of the vertex attribute array ❻. The index of the attribute
    is 0, the number of components is 3 (you use 3D vertices), and the data type of
    the vertex is `GL_FLOAT`. You then unbind the VAO ❼ so other related calls don’t
    interfere with it. In OpenGL, it’s a best practice to reset states when you’re
    done. OpenGL is a state machine, so if you leave things in a mess, they will remain
    that way.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code loads an image of a star as an OpenGL texture:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '# texture'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: self.texId = glutils.loadTexture('star.png')
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The texture ID returned will be used later in rendering.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the Square
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next you need to update variables in the `Scene` object to make the square
    rotate on the screen. Use the class’s `step()` method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: step
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def step(self):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '# increment angle'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: ❶ self.t = (self.t + 1) % 360
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: At ❶, you increment the angle variable `t` and use the modulus operator (`%`)
    to keep this value within [0, 360]. This variable will be used to update the rotation
    angle in the vertex shader.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the Scene
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at the `Scene` object’s main rendering code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'def render(self, pMatrix, mvMatrix):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '# use shader'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: ❶ glUseProgram(self.program)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '# set projection matrix'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: ❷ glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '# set modelview matrix'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '# set shader angle in radians'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: ❸ glUniform1f(glGetUniformLocation(self.program, 'uTheta'),
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: math.radians(self.t))
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '# show circle?'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: ❹ glUniform1i(glGetUniformLocation(self.program, b'showCircle'),
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: self.showCircle)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '# enable texture'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: ❺ glActiveTexture(GL_TEXTURE0)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: ❻ glBindTexture(GL_TEXTURE_2D, self.texId)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: ❼ glUniform1i(self.tex2D, 0)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: ❽ glBindVertexArray(self.vao)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '# draw'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: ❾ glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: ❿ glBindVertexArray(0)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: First you set up the rendering to use the shader program ❶. Starting at ❷, you
    set the computed projection and modelview matrices in the shader using the `glUniformMatrix4fv()`
    method. Then you use the `glUniform1f()` method to set `uTheta` in the shader
    program ❸. You use `glGetUniformLocation()` as before to get the location of the
    `uTheta` angle variable from the shader, and you use the Python `math.radians()`
    method to convert the angle from degrees to radians. Next, you use `glUniform1i()`
    to set the current value of the `showCircle` variable in the fragment shader ❹.
    OpenGL has a concept of multiple texture units, and `glActiveTexture()` ❺ activates
    texture unit 0 (the default). You bind the texture ID you generated earlier from
    the *star.png* image to activate it for rendering ❻. The `sampler2D` variable
    in the fragment shader is set to texture unit 0 ❼.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'You continue by binding to the VAO you created previously ❽. Now you see the
    benefit of using VAOs: you don’t need to repeat a whole bunch of vertex buffer–related
    calls before the actual drawing. You then call `glDrawArrays()` to render the
    bound vertex buffers ❾. The primitive type is a triangle strip, and there are
    four vertices to be rendered. Finally, you unbind the VAO at ❿, which is always
    a good coding practice.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Defining the GLSL Shaders
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at the most exciting part of the project—the GLSL shaders. First,
    here’s the vertex shader, which computes the position and texture coordinates
    of the vertices:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: version 410 core
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ❶ layout(location = 0) in vec3 aVert;
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: ❷ uniform mat4 uMVMatrix;
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uPMatrix;
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: uniform float uTheta;
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: ❸ out vec2 vTexCoord;
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: // rotational transform
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: ❹ mat4 rot = mat4(
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: vec4(1.0, 0.0, 0.0, 0.0),
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: vec4(0.0, cos(uTheta), -sin(uTheta), 0.0),
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: vec4(0.0, sin(uTheta),  cos(uTheta), 0.0),
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: vec4(0.0, 0.0,          0.0,         1.0)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: // transform vertex
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: ❺ gl_Position = uPMatrix * uMVMatrix * rot * vec4(aVert, 1.0);
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: // set texture coordinate
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: ❻ vTexCoord = aVert.xy + vec2(0.5, 0.5);
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: You use the `layout` keyword ❶ to set explicitly the location of the vertex
    attribute `aVert`—to 0, in this case. This attribute lets the vertex shader access
    the vertices that you defined for the polygon. Starting at ❷, you declare three
    `uniform` variables for the projection and modelview matrices and the rotation
    angle. These will be set from the Python code. You also set a 2D vector `vTexCoord`
    as an output from this shader ❸. This will be available as an input to the fragment
    shader.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: In the `main()` method in the shader, you set up a rotation matrix ❹, which
    rotates around the x-axis by a given angle, `uTheta`. You compute `gl_Position`
    ❺ using a concatenation of the projection, modelview, and rotation matrices. This
    gives you the position of the output vertex from the shader. You then set up a
    2D vector as a texture coordinate ❻. You may recall that you defined the triangle
    strip for a square centered at the origin with side 1.0\. Because texture coordinates
    are in the range [0, 1], you can generate these from the vertex coordinates by
    adding (0.5, 0.5) to the x- and y-values. This also demonstrates the power and
    immense flexibility of shaders for your computations. Texture coordinates and
    other variables aren’t sacrosanct; you can set them to just about anything.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the fragment shader, which computes the output pixels of
    our OpenGL program:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: version 410 core
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ❶ in vec2 vTexCoord;
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: ❷ uniform sampler2D tex2D;
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: ❸ uniform bool showCircle;
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: ❹ out vec4 fragColor;
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: if (showCircle) {
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: // discard fragment outside circle
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: ❺ if (distance(vTexCoord, vec2(0.5, 0.5)) > 0.5) {
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: discard;
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: else {
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: ❻ fragColor = texture(tex2D, vTexCoord);
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: else {
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: ❼ fragColor = texture(tex2D, vTexCoord);
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: You start by defining inputs to the fragment shader—in this case the texture
    coordinate you set as output in the vertex shader ❶. Recall that the fragment
    shader operates on a per-pixel basis, so the values set for these variables are
    those for the current pixel, interpolated across the polygon. You declare a `sampler2D`
    variable ❷, which is linked to a particular texture unit and is used to look up
    the texture value, and a Boolean uniform flag `showCircle` ❸, which is set from
    the Python code. You also declare `fragColor` as the output from the fragment
    shader ❹. By default, this goes to the screen (after final frame buffer operations
    such as depth testing and blending).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Within the `main()` method, if the `showCircle` flag is not set ❼, you use the
    GLSL `texture()` method to look up the texture color value using the texture coordinate
    and the sampler. In effect, you’re just texturing the triangle strip using the
    star image. If, however, the `showCircle` flag is `true` ❺, you use the GLSL built-in
    method `distance()` to check how far the current pixel is from the center of the
    polygon. It uses the (interpolated) texture coordinates for this purpose, which
    are passed in by the vertex shader. If the distance is greater than a certain
    threshold (0.5 in this case), you call the GLSL `discard()` method, which drops
    the current pixel. If the distance is less than the threshold, you set the appropriate
    color from the texture ❻. Basically, what this does is ignore pixels that are
    outside a circle with a radius of 0.5 centered at the midpoint of the square,
    thus cutting the polygon into a circle when `showCircle` is set.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[Utility Functions](nsp-venkitachalam503045-0008.xhtml#rbh1109)'
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’ve referred to several utility functions defined for you in *glutils.py*
    to make working with OpenGL easier. Let’s look at an example of one of those functions
    now. The `loadTexture()` function loads an image into an OpenGL texture:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'def loadTexture(filename):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '"""load OpenGL 2D texture from given image file"""'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: ❶ img = Image.open(filename)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: ❷ imgData = numpy.array(list(img.getdata()), np.int8)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: ❸ texture = glGenTextures(1)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: ❹ glBindTexture(GL_TEXTURE_2D, texture)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: ❺ glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: ❻ glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: ❼ glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: ❽ glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img.size[0], img.size[1],
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 0, GL_RGBA, GL_UNSIGNED_BYTE, imgData)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: return texture
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The `loadTexture()` function uses the Python Imaging Library (PIL) `Image` module
    to read the image file ❶. Then it gets the data out of the `Image` object onto
    an 8-bit `numpy` array ❷ and creates an OpenGL `texture` object ❸, which is a
    prerequisite to doing anything with textures in OpenGL. You next perform the now
    familiar binding to the `texture` object ❹ so all further texture-related settings
    apply to this object. You set the unpacking alignment of data to 1 ❺, which means
    the image data will be considered to be 1-byte or 8-bit data by the hardware.
    Starting at ❻, you tell OpenGL what to do with the texture at the edges. In this
    case, you direct it to just clamp the texture color to the edge of the geometry.
    (In specifying texture coordinates, the convention is to use the letters `S` and
    `T` for the axes instead of `x` and `y`.) At ❼ and the following line, you specify
    the kind of interpolation to be used when the texture is stretched or compressed
    to map onto a polygon. In this case, *linear filtering* is specified. Finally,
    you set the image data in the bound texture ❽. At this point, the image data is
    transferred to graphics memory, and the texture is ready for use.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[Running the OpenGL Application](nsp-venkitachalam503045-0008.xhtml#rah1104)'
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a sample run of the project:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: $ `python simpleglfw.py`
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: You saw the output in [Figure 9-1](nsp-venkitachalam503045-0023.xhtml#fig9-1).
    Be sure to try some keypresses to toggle the circle on and off.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1105)'
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Congratulations on completing your first program using Python and OpenGL! Through
    this project, you’ve learned about creating 3D transformations, using the OpenGL
    3D graphics pipeline, and using GLSL vertex and fragment shaders to create interesting
    3D graphics. You’ve begun your journey into the fascinating world of 3D graphics
    programming.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1106)'
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some ideas for modifying this project:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '1\. The vertex shader in this project rotates the square around the x-axis
    (1, 0, 0). Can you make it rotate around the y-axis (0, 0, 1)? You can do this
    in one of two ways: first, by modifying the rotation matrix in the shader, or
    second, by computing this matrix in the Python code and passing it as a *uniform*
    into the shader. Try both!'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '2\. In the project, the texture coordinates are generated inside the vertex
    shader and passed to the fragment shader. This is a trick, and it works only because
    of the convenient values chosen for the vertices of the triangle strip. Pass the
    texture coordinates as a separate attribute into the vertex shader, similar to
    how the vertices are passed in. Now, can you make the star texture *tile* across
    the triangle strip? Instead of displaying a single star, you want to produce a
    4×4 grid of stars on the square. (Hint: use texture coordinates greater than 1.0
    and set `GL_TEXTURE_WRAP_S/T` parameters in `glTexParameterf()` to `GL_REPEAT`.)'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3\. By changing just your fragment shader, can you make your square look like
    [Figure 9-6](nsp-venkitachalam503045-0023.xhtml#fig9-6)? (Hint: use the GLSL `sin()`
    function.)'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f09006.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-6: Using the fragment shader to block out concentric circles'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah1107)'
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the complete *simpleglfw.py* code:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: simpleglfw.py
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: A simple Python OpenGL program that uses PyOpenGL + GLFW to get an
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL 4.1 context.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: import OpenGL
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL import *
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: import numpy, math, sys, os
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: import glutils
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: import glfw
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: strVS = """
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: version 410 core
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layout(location = 0) in vec3 aVert;
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uMVMatrix;
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uPMatrix;
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: uniform float uTheta;
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: out vec2 vTexCoord;
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: // rotational transform
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: mat4 rot =  mat4(
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: vec4(1.0,  0.0,          0.0,         0.0),
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: vec4(0.0,  cos(uTheta),  sin(uTheta), 0.0),
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: vec4(0.0, -sin(uTheta),  cos(uTheta), 0.0),
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: vec4(0.0,  0.0,          0.0,         1.0)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: // transform vertex
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: gl_Position = uPMatrix * uMVMatrix * rot * vec4(aVert, 1.0);
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: // set texture coord
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: vTexCoord = aVert.xy + vec2(0.5, 0.5);
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: strFS = """
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: version 410 core
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in vec2 vTexCoord;
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: uniform sampler2D tex2D;
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: uniform bool showCircle;
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 fragColor;
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: if (showCircle) {
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: // discard fragment outside circle
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: if (distance(vTexCoord, vec2(0.5, 0.5)) > 0.5) {
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: discard;
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: else {
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: fragColor = texture(tex2D, vTexCoord);
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: else {
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: fragColor = texture(tex2D, vTexCoord);
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'class Scene:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '""" OpenGL 3D scene class"""'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '# initialization'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '# create shader'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: glUseProgram(self.program)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: self.pMatrixUniform = glGetUniformLocation(self.program,
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: b'uPMatrix')
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: self.mvMatrixUniform = glGetUniformLocation(self.program,
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: b'uMVMatrix')
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '# texture'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: self.tex2D = glGetUniformLocation(self.program, b'tex2D')
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '# define triangle strip vertices'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: vertexData = numpy.array(
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[-0.5, -0.5, 0.0,'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 0.5, -0.5, 0.0,
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: -0.5, 0.5, 0.0,
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 0.5, 0.5, 0.0], numpy.float32)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '# set up vertex array object (VAO)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: self.vao = glGenVertexArrays(1)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '# vertices'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: GL_STATIC_DRAW)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '# enable vertex array'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: glEnableVertexAttribArray(0)
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data pointer'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '# time'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: self.t = 0
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '# texture'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: self.texId = glutils.loadTexture('star.png')
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '# show circle?'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: self.showCircle = False
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '# step'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'def step(self):'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '# increment angle'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: self.t = (self.t + 1) % 360
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '# render'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'def render(self, pMatrix, mvMatrix):'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '# use shader'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: glUseProgram(self.program)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '# set proj matrix'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '# set modelview matrix'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '# set shader angle in radians'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1f(glGetUniformLocation(self.program, 'uTheta'),
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: math.radians(self.t))
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '# show circle?'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1i(glGetUniformLocation(self.program, b'showCircle'),
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: self.showCircle)
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '# enable texture'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: glActiveTexture(GL_TEXTURE0)
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: glBindTexture(GL_TEXTURE_2D, self.texId)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: glUniform1i(self.tex2D, 0)
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '# draw'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'class RenderWindow:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '"""GLFW rendering window class"""'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '# save current working directory'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: cwd = os.getcwd()
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize glfw - this changes cwd'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwInit()
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '# restore cwd'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: os.chdir(cwd)
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '# version hints'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 4)
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 1)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: glfw.GLFW_OPENGL_CORE_PROFILE)
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '# make a window'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height = 800, 600
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = self.width/float(self.height)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: self.win = glfw.glfwCreateWindow(self.width, self.height,
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: b'simpleglfw')
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '# make context current'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwMakeContextCurrent(self.win)
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize GL'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: glEnable(GL_DEPTH_TEST)
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: glClearColor(0.5, 0.5, 0.5, 1.0)
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '# set window callbacks'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetKeyCallback(self.win, self.onKeyboard)
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '# create 3D'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: self.scene = Scene()
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '# exit flag'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: self.exitNow = False
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'def onKeyboard(self, win, key, scancode, action, mods):'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''keyboard: '', win, key, scancode, action, mods'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'if action == glfw.GLFW_PRESS:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '# ESC to quit'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'if key == glfw.GLFW_KEY_ESCAPE:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: self.exitNow = True
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '# toggle cut'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: self.scene.showCircle = not self.scene.showCircle
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'def run(self):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '# initializer timer'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetTime(0)
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: t = 0.0
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '# update every x seconds'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: currT = glfw.glfwGetTime()
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 'if currT - t > 0.1:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '# update time'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: t = currT
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '# clear'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '# set viewport'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height =
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwGetFramebufferSize(self.win)
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = self.width/float(self.height)
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '# build projection matrix'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: mvMatrix = glutils.lookAt([0.0, 0.0, -2.0], [0.0, 0.0, 0.0],
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[0.0, 1.0, 0.0])'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '# render'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: self.scene.render(pMatrix, mvMatrix)
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '# step'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: self.scene.step()
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSwapBuffers(self.win)
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '# poll for and process events'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwPollEvents()
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '# end'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwTerminate()
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'def step(self):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '# step'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: self.scene.step()
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: main() function
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: print("Starting simpleglfw. "
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '"Press any key to toggle cut. Press ESC to quit.")'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: rw = RenderWindow()
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: rw.run()
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: call main
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
