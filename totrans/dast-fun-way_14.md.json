["```py\nSkipList {\n    Integer: top_level\n    Integer: max_level\n    SkipListNode: front\n}\n```", "```py\nSkipListNode {\n    Type: key\n    Type: value\n    Integer: height\n    Array of SkipListNodes: next\n}\n```", "```py\nSkipListSearch(SkipList: list, Type: target):\n    Integer: level = list.top_level\n  ❶ SkipListNode: current = list.front\n\n  ❷ WHILE level >= 0:\n        WHILE (current.next[level] != null AND\n               current.next[level].key < target):\n           current = current.next[level]\n        level = level - 1\n\n  ❸ SkipListNode: result = current.next[0]\n  ❹ IF result != null AND result.key == target:\n        return result.value\n    ELSE:\n        return null\n```", "```py\nSkipListInsert(SkipList: list, Type: key, Type: value):\n    Integer: level = list.top_level\n  ❶ SkipListNode: current = list.front\n  ❷ Array: last = a size list.max_level + 1 array of SkipListNode pointers \n                  initially set to list.front for all levels.\n\n  ❸ WHILE level >= 0:\n      ❹ WHILE (current.next[level] != null AND\n               current.next[level].key < key):\n           current = current.next[level]\n      ❺ last[level] = current\n        level = level - 1\n\n    SkipListNode: result = current.next[0]\n  ❻ IF result != null AND result.key == key:\n       result.value = value\n       return\n\n  ❼ Integer: new_level = pick a random level\n  ❽ IF new_level > list.top_level:\n        list.top_level = new_level\n    SkipListNode: new_node = SkipListNode(key, value, new_level)\n\n    Integer: j = 0\n  ❾ WHILE j <= new_level:\n         new_node.next[j] = last[j].next[j]\n         last[j].next[j] = new_node\n         j = j + 1\n```", "```py\nSkipListDelete(SkipList: list, Type: target):\n    Integer: level = list.top_level\n  ❶ SkipListNode: current = list.front\n    Array: last = a size list.max_level + 1 array of SkipListNode pointers \n                  initially set to list.front for all levels.\n\n  ❷ WHILE level >= 0:\n        WHILE (current.next[level] != null AND\n current.next[level].key < target):\n           current = current.next[level]\n        last[level] = current\n        level = level - 1\n\n  ❸ SkipListNode: result = current.next[0]\n    IF result == null OR result.key != target:\n        return\n\n    level = result.height\n    Integer: j = 0\n  ❹ WHILE j <= level:\n         last[j].next[j] = result.next[j]\n         result.next[j] = null\n         j = j + 1\n\n  ❺ IF level == list.top_level:\n        Integer: top = list.top_level\n        WHILE top > 0 AND list.front.next[top] == null:\n             top = top - 1\n        list.top_level = top\n```"]