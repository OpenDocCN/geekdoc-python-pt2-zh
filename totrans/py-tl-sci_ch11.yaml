- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FUNCTIONS AND MODULES**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A *function* is a reusable set of instructions that performs a specific task.
    When the function completes its task, the flow of execution returns to the proper
    place in the greater code structure. *Modules* are programs, usually comprising
    functions, that perform a task or group of related tasks. Whereas you can define
    functions in place, you must import modules into a Python program to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Both functions and modules let you simplify code through the process of *abstraction*.
    Abstraction is the act of moving the details of some process into a seemingly
    simpler object away from the main routine. Later, you can perform the task by
    calling the object’s name in a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: The best function and module names are short and descriptive. They allow you
    to skim the main routines of programs and get an idea of what’s going on, as if
    you were reading a summary. A good analogy is the table of contents of this book.
    Although a great many details are hidden away in the actual chapter, the headings
    and subheadings give you a good idea of what each chapter entails.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, you imported modules like `math` and `os`, and you used
    built-in functions like `print()` and `input()`. Their code was abstracted to
    the point that you never saw it. You just called a function, and something happened.
    There’ll be times, however, when a pre-built solution is either unavailable or
    insufficient, and you’ll need to create a function yourself.
  prefs: []
  type: TYPE_NORMAL
- en: By writing your own functions to reuse units of code, you can create more readable,
    better organized, and less redundant programs. In this chapter, you’ll write custom
    functions and modules and become familiar with additional built-in functions and
    third-party modules designed to make your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To write a function in Python, you define it by using the `def` keyword followed
    by a name for the function, parentheses, and a colon. As always, code coming after
    the colon must be indented, and the indented lines represent executable code.
    Here’s an example in the IPython console in the Spyder IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the console, you can complete a function by pressing ENTER twice or by
    using SHIFT-ENTER. In the editor, a function’s code block ends when you return
    to the same indentation level as the def keyword.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve now encapsulated a warning message within the `warning()` function.
    To use the message again, you need only *call* the function by entering its name
    and parentheses. This saves you from typing out the full message over and over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In a function name, the parentheses `()`, sometimes referred to as the *call
    operator*, let Python know that an object can be *invoked*, which is a fancy way
    of saying “execute this command.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Like everything else in Python, functions are objects. They belong to the `function`
    data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can assign functions to variables, use them in other functions, define them
    in other functions, return them as values from other functions, and store them
    in data structures (for example, as an item in a list).
  prefs: []
  type: TYPE_NORMAL
- en: According to Python’s PEP 8 Style Guide (*[https://pep8.org/](https://pep8.org/)*),
    you should surround top-level functions (those defined at indentation level 0)
    with two blank lines. Within functions, you should use blank lines (sparingly)
    to indicate logical sections.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Parameters and Arguments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can submit, or *pass*, input to a function; perform some operation on the
    input; and then output, or *return*, the result. To do so, you use parameters
    and arguments inside the parentheses and separate them by commas.
  prefs: []
  type: TYPE_NORMAL
- en: '*Parameters* are special kinds of variables, defined by a function, that receive
    a value when the function is called. They refer to the pieces of data provided
    as input but are not the data itself. For example, the following code defines
    a function that calculates a force value, using the famous equation *F=MA*, when
    passed mass and acceleration parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Arguments* are the actual data values input when calling the function. For
    example, you could call the `calc_force()` function with these arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-1](ch11.xhtml#ch011fig1) identifies the parameters in the `calc_force()`
    function definition and the arguments passed to it when called.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: Function definitions use parameters and function calls use arguments*'
  prefs: []
  type: TYPE_NORMAL
- en: Functions like `calc_force()` that return a value are called *fruitful* functions.
    Functions that perform an action but don’t return a value are called *void* functions.
    The `warning()` function in the previous section is an example of a void function.
  prefs: []
  type: TYPE_NORMAL
- en: With fruitful functions, the `return` statement causes execution to exit the
    function and resume at the point in the code immediately after the instruction
    that called the function, known as its *return address*. Values listed *after*
    the `return` keyword and on the same line are passed back to the code that called
    the function. For the `calc_force()` function, this would be the value in line
    `Out[5]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `return` keyword always ends a function and prevents execution of any subsequent
    code within the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Technically, all functions need to evaluate to a return value. Void functions
    satisfy this requirement by automatically returning Python’s null value, None,
    which belongs to the NoneType data type.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Positional and Keyword Arguments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Function arguments can be of two types: *positional* and *keyword*. Positional
    arguments must be entered in the correct order, as defined by the order of the
    parameters in the function definition. As shown in [Figure 11-1](ch11.xhtml#ch011fig1),
    the `calc_force()` function uses positional arguments, such that the first argument
    submitted corresponds to the mass, and the second to the acceleration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword (or *named*) arguments include a keyword and an equal sign before the
    submitted value. These are used to add clarity and make a function’s intention
    clear. Here’s how to call the `calc_force()` function using keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*According to the Python Style Guide, no spaces should be used around the equal
    sign in keyword arguments.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another advantage to keyword arguments is that you don’t need to remember the
    order in which the parameters were defined. Here, we enter arguments in reverse
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can enter both positional and keyword arguments when calling a function.
    However, after you use a keyword argument, you can’t go back to using positional
    arguments in the same function call. So, this code works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But this code fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can force the use of keyword arguments by including an asterisk (`*`) as
    the first parameter when defining a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you attempt to use positional arguments, Python will raise an exception
    and inform you that positional arguments are not accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '***Using Default Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can specify a default value for one or more parameters. This lets you simplify
    the function call if a parameter generally uses a particular value. It also lets
    you guide users to an acceptable value if the user is not sure what to enter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default parameters should be placed *after* any non-default parameters. Here’s
    an example of a function that uses a default value if the user presses ENTER without
    responding to the prompt question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a prompt and a default value as arguments. The prompt and
    default will be specified when the function is called, and the program will display
    the default in square brackets ➊. The `response` variable holds the user’s input.
    If the user enters nothing and a default value exists, the default value is returned
    ➋. Otherwise, the user’s response is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use this function to get a user’s birth country. For users currently
    in the United States, we set the default value to “USA” so they can just press
    ENTER rather than type in the name. Note how this default lets you *control* the
    response when multiple choices are possible (such as “America,” “United States,”
    “United States of America,” “US,” and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A user can override the default by entering a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In most cases, you’ll want to avoid using mutable objects like dictionaries,
    sets, or lists as default argument values in Python. This is because the default
    mutable object is initialized only *once*, when the function is *defined* rather
    than each time the function is *called*. This can produce unexpected outputs.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The naive expectation here is that everyone who calls the `dog_breeds()` function
    will start off fresh with a bulldog and dachshund and then add their dog breeds
    to this list. But because the `current` list was created once when the function
    was defined in line `In [17]`, every subsequent call to the function appends items
    to this *same* list.
  prefs: []
  type: TYPE_NORMAL
- en: '***Returning Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When functions return a value, you can store the result in a variable using
    an assignment statement. For example, the following code stores the value returned
    from running the `calc_force()` function in a variable called `force`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even return multiple values, separated by commas. You’ll need a variable
    to hold each value, as in this example, in which the function accepts a number
    as an argument and returns the square and cube of the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, functions can include multiple `return` statements. Each statement
    executes under a given condition, and as soon as one executes, the function ends.
    Try this in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `goldilocks()` function accepts a number as an argument,
    converts it to an integer, and then compares it to `42`. Each of the three possible
    outcomes (greater than, less than, or equal to) has its own `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '***Naming Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The guidelines for naming functions are the same as those for naming variables
    (see “Naming Variables” on [page 206](ch08.xhtml#ch00lev1sec56)). You can use
    letters, underscores, and numbers, as long as the first character isn’t a number.
    All characters should be lowercase, and you should separate words with an underscore.
    You’ll want to avoid reserved keywords and the names of built-in functions.
  prefs: []
  type: TYPE_NORMAL
- en: Because functions perform an action, a good naming strategy is to include a
    verb and a noun that describe that action. Some examples are `reset_password()`,
    `register_image()`, and `plot_light_curve()`.
  prefs: []
  type: TYPE_NORMAL
- en: For more on naming and defining functions, visit the documentation at *[https://docs.python.org/3/tutorial/controlflow.html#defining-functions/](https://docs.python.org/3/tutorial/controlflow.html#defining-functions/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Built-in Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Python comes with multiple built-in functions to make your coding life easier.
    You’ve already worked with many of these, including `print()`, `len()`, `type()`,
    `list()`, `input()`, `round()`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 11-1](ch11.xhtml#ch011tab1) lists some of the more frequently used built-in
    functions. To see the full list, along with detailed descriptions of each function,
    visit *[https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Frequently Used Built-in Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `abs()` | Return the absolute value of a number. |'
  prefs: []
  type: TYPE_TB
- en: '| `all()` | Return `True` if all elements of an iterable are true or if the
    iterable is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `any()` | Return `True` if any element of an iterable is true or `False`
    if iterable is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `chr()` | Return a string representing an input Unicode code point (`chr(97)`
    returns `′``a``′`). |'
  prefs: []
  type: TYPE_TB
- en: '| `dict()` | Create a new `dictionary object`. |'
  prefs: []
  type: TYPE_TB
- en: '| `dir()` | Without argument, return names in the current local scope. If an
    object is passed as an argument, return list of attributes and methods for that
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| `enumerate()` | Adds a counter to each item of an iterable object and returns
    an enumerate object. |'
  prefs: []
  type: TYPE_TB
- en: '| `filter()` | Return an iterator from those elements of an iterable for which
    function returns `True`. |'
  prefs: []
  type: TYPE_TB
- en: '| `float()` | Return a floating-point number constructed from a number or string.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `frozenset()` | Return a `frozenset` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `hash()` | Return the hash value of an object if it has one. |'
  prefs: []
  type: TYPE_TB
- en: '| `help()` | Invoke built-in help system (intended for interactive use). |'
  prefs: []
  type: TYPE_TB
- en: '| `hex()` | Convert an integer to a lowercase hexadecimal string prefixed with
    “0x.” |'
  prefs: []
  type: TYPE_TB
- en: '| `id()` | Return the identity of an object. |'
  prefs: []
  type: TYPE_TB
- en: '| `input()` | Get user input using a prompt and return it as a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `int()` | Return an integer number constructed from a number or string. |'
  prefs: []
  type: TYPE_TB
- en: '| `isinstance()` | Return `True` if the specified object is of the specified
    type; otherwise, return `False`. |'
  prefs: []
  type: TYPE_TB
- en: '| `len()` | Return the number of items in a sequence or collection (such as
    a string, list, or set). |'
  prefs: []
  type: TYPE_TB
- en: '| `list()` | Create a new `list` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `max()` | Return largest item in an iterable or the largest of two or more
    arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `min()` | Return smallest item in an iterable or the smallest of two or more
    arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `next()` | Retrieve the next item from an iterator. |'
  prefs: []
  type: TYPE_TB
- en: '| `open()` | Open a file and return a corresponding `file` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `ord()` | Return the Unicode code point of a character (`ord(``′``a``′``)`
    returns `97`). |'
  prefs: []
  type: TYPE_TB
- en: '| `pow()` | Return a number raised to the power specified. |'
  prefs: []
  type: TYPE_TB
- en: '| `print()` | Print a specified message to the screen or other standard output
    device. |'
  prefs: []
  type: TYPE_TB
- en: '| `range()` | Generate an immutable sequence of numbers for given start and
    stop integers. |'
  prefs: []
  type: TYPE_TB
- en: '| `repr()` | Return a string containing a printable representation of an object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `reversed()` | Return a reversed iterator. |'
  prefs: []
  type: TYPE_TB
- en: '| `round()` | Return a number rounded to *n*-digits precision after the decimal
    point. |'
  prefs: []
  type: TYPE_TB
- en: '| `set()` | Create a new `set` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `sorted()` | Return a new sorted list (forward or backward) from the items
    in an iterable. |'
  prefs: []
  type: TYPE_TB
- en: '| `str()` | Return a string version of an object. |'
  prefs: []
  type: TYPE_TB
- en: '| `sum()` | Return the sum of all items in an iterable. |'
  prefs: []
  type: TYPE_TB
- en: '| `tuple()` | Create a new `tuple` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `type()` | Return the type of an object. |'
  prefs: []
  type: TYPE_TB
- en: '| `zip()` | Iterate over several iterables in parallel, producing tuples with
    an item from each. |'
  prefs: []
  type: TYPE_TB
- en: It’s good practice to check whether a built-in function exists for a specific
    task before writing code on your own.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '1.  When you call a function that takes input, you pass it:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  parameters
  prefs: []
  type: TYPE_NORMAL
- en: b.  objects
  prefs: []
  type: TYPE_NORMAL
- en: c.  arguments
  prefs: []
  type: TYPE_NORMAL
- en: d.  the `def` keyword
  prefs: []
  type: TYPE_NORMAL
- en: '2.  Ideally, a function name should contain both a:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  noun and an underscore
  prefs: []
  type: TYPE_NORMAL
- en: b.  verb and an underscore
  prefs: []
  type: TYPE_NORMAL
- en: c.  verb and a noun
  prefs: []
  type: TYPE_NORMAL
- en: d.  number and an underscore
  prefs: []
  type: TYPE_NORMAL
- en: '3.  A function that returns no value is called a:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  fruitful function
  prefs: []
  type: TYPE_NORMAL
- en: b.  void function
  prefs: []
  type: TYPE_NORMAL
- en: c.  warning function
  prefs: []
  type: TYPE_NORMAL
- en: d.  module
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Write a function that accepts a user’s name and then returns their name
    stripped of vowels. You’ll want to make a string of vowels, loop through the letters
    in the name, and compare each letter to the contents of the vowel string.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Write a function that calculates momentum (mass * velocity) using keyword
    arguments only.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions and the Flow of Execution**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like conditional statements and loops, functions can cause code to branch or
    jump around. In the following example, we define two functions and call the first
    function from within the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When you call the `find_3()` function, the flow of execution moves into the
    function. But rather than return a value—and control—back to the main routine,
    this function calls another function, which could theoretically call another function
    defined somewhere higher in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of these two functions doesn’t need to be in order and can be
    separated by other code, as long as calls to the functions come *after* their
    definition. On the Spyder main menu, click **Consoles** ▸ **Restart kernel** and
    then enter the following code, which now defines `find()` before `success()`,
    with some other code in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the order in which you defined the two functions didn’t matter;
    what’s important is that you made the call to `find_3()` after they were defined.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Namespaces and Scopes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *namespace* is a collection of names. Behind the scenes, Python uses namespaces
    to map names to corresponding objects in memory. This lets Python keep track of
    all the names currently in use and prevent *collisions*, wherein two different
    objects share the same name.
  prefs: []
  type: TYPE_NORMAL
- en: Different, isolated namespaces, called *scopes*, can exist at the same time
    within a single program. When you start typing a program in the console or the
    text editor, you are in the *global* scope, and all the object names share the
    same namespace. Every time you define a function, you enter the function’s *local*
    scope, and all the names used within the function share a new namespace that’s
    hidden from both the global scope and the local scope of other functions. Thus,
    it’s possible to use the same object name within one function as you do within
    another function, or in the main program in the global scope (see [Figure 11-2](ch11.xhtml#ch011fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: This program has a global scope (gray) and two isolated local
    scopes within functions (white).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at scope behavior in practice. Enter the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, you used the same variable name (`x`) twice without
    a problem. This is because the first `x` is in the global scope, and the second
    `x` is safely tucked-away within the local scope of the function. As written,
    there’s no way for the global scope to access the `x` in the local scope. So,
    when you print `x` in line `In [44]`, you get the value in the global scope, despite
    the fact that `x` appears to have been reassigned to `5` in the function. After
    the function terminates, all its local variables are “forgotten” by Python, so
    no name conflicts occur.
  prefs: []
  type: TYPE_NORMAL
- en: Compartmentalizing the code using scopes also aids debugging. It’s easier to
    track down the source of bad values because functions can only interact with the
    rest of the program through the arguments they’re passed and the values they return.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Global Variables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Any variable assigned in the global scope is visible to both the global and
    local scopes. To indicate that you’re accessing a global variable without passing
    it to the function as an argument, and to make it fully available to the function,
    you must use the *global statement* to specify it as a *global variable* within
    the function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By adding the line `global x` in the definition of the `local_scope()` function,
    you gave the function access to the `x` variable in the global scope. Now, when
    you change the value of `x` in the function, that change is reflected in the global
    scope, and printing `x` returns `5`, not `42`, as before.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Variables in the global space can be changed from within a function, without
    the use of the global statement, if they are mutable objects.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because it’s possible to use global variables in the local scope of functions,
    you should avoid using the same names for local and global variables. Likewise,
    you should avoid using the same name for variables in local scopes. Even though
    it’s impossible to share a local variable either globally or with another function,
    this can become confusing. It’s rarely a good idea to use the same name for two
    different things, even if they never interact.
  prefs: []
  type: TYPE_NORMAL
- en: Using global variables is generally discouraged, especially in large and complex
    programs. Imagine that you have hundreds of lines of code with dozens of functions.
    One of the functions changes a global variable to the wrong value, either due
    to a bug or to a failure in logic. To find and correct this problem, you must
    search through the *entire* program rather than focus on individual functions
    or function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*An exception to the “don’t use global variables” rule is the global constant.
    It’s okay to assign constant values near the top of your program in the global
    scope. Because constants shouldn’t change value, they shouldn’t introduce complexity
    into your code.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Using a main() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the exception of short, simple programs, it’s common practice to encapsulate
    the main code of a program into a function called `main()`. This code runs the
    rest of the program by executing expressions and statements and calling functions.
    Removing it from the global scope makes it easier to find and manage.
  prefs: []
  type: TYPE_NORMAL
- en: You can define the `main()` function anywhere, but generally it’s near the start
    or end of a program. If your code and function names are very readable, placing
    `main()` at the start of a program can serve as a good summary of what the program
    does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a program that uses a `main()` function to calculate some statistics.
    Enter the following in the Spyder text editor and save it as *main_function_example.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we first import the `uniform()` method from the `random` module
    so that we can generate random float values to use as data (in real life, you’d
    load or type some data into the program). Next, we define the `main()` function.
    All this function does, in this case, is call other functions. Note how it reads
    like a summary of what the program does.
  prefs: []
  type: TYPE_NORMAL
- en: The next function, `generate_data()`, returns a list of 10 random float values,
    rounded to one decimal place, from a uniform distribution. To use the `uniform`
    method, pass it the beginning and ending values of the range that you want to
    use, in this case, 0.0 and 50.0 ➊. The next three functions will take this list
    as input (an argument) and return the mean, maximum, and minimum values, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’ve defined only functions. If you want the program to do
    something, you need to call the `main()` function before execution.
  prefs: []
  type: TYPE_NORMAL
- en: For code this simple, you could forgo use of a `main()` function and move its
    contents into the global scope, *below* the definitions of the functions being
    called. But as your code becomes longer and more complicated, a `main()` function
    will help you keep it clean and organized and make it easy to find and review
    what the program does.
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Function Topics**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you know enough about functions to handle most, if not all, of
    the coding problems you’ll encounter. There’s always more to learn, however. This
    section will give you a brief introduction to recursion, function design, lambda
    functions, and generators. Recursion is a particularly ambitious topic, and if
    you find it interesting or useful, I recommend reading more about it on your own.
  prefs: []
  type: TYPE_NORMAL
- en: '***Recursion***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Recursion* is a powerful programming technique in which a function calls itself.
    Although recursion can be accomplished using more efficient `for` and `while`
    loops, these loops can sometimes become complicated and messy.'
  prefs: []
  type: TYPE_NORMAL
- en: For difficult problems, recursive functions can provide a simpler and more readable
    way to construct code. You’ll commonly see recursion used for solving factorials,
    finding numbers in a Fibonacci sequence, and calculating compound interest for
    a loan using additional data, like regular payments.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a simple example of a recursive function named `beer()`. Notice that
    the `elif` and `else` statements include calls to the `beer()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function was inspired by the famous “99 Bottles of Beer” song. It accepts
    a number—representing bottles of beer—as an argument, and then it updates the
    number of bottles remaining and calls itself again until the number reaches zero.
    The `elif` clause in the middle is needed only to correct the grammar when one
    bottle remains.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement ➊ does *not* include a recursive call to `beer()`, because
    this is the *base condition,* or *base case,* for the function. A base condition
    is one that will end the function if the condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need a base case because recursions, like `while` loops, can go on forever.
    To see an example, enter the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will raise the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Because the `keep_on_keeping_on()` function kept calling itself, it created
    an infinite recursion, resulting in a *stack overflow.* This error occurs when
    you attempt to write more data to a memory block than it can hold. Inclusion of
    a reachable base case could have stopped this from happening, but not if it allows
    too many recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent infinite recursions, the Python interpreter limits the *depth of
    recursion*; that is, the number of recursive calls to a function, to a default
    value. To see this value, in the console, use the system module (`sys`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Although you can increase this recursion limit by passing the `sys.setrecursionlimit()`
    function an integer, you need to do this with care, as the highest possible limit
    is platform-dependent, and a high limit can still lead to a crash. A better option
    is to rewrite your code without recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The actual recursion limit is usually a bit less than the value returned by
    sys.getrecursionlimit(). On my machine, a RecursionError is raised after 2,967
    calls, despite the limit being set at 3,000.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Designing Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When it comes to writing functions, there’s a school of thought that believes
    a function “should do one thing and one thing only.” Although keeping functions
    short and simple is a good guideline, there are many cases for which longer, more
    complex functions are the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Longer functions can merge related tasks under one umbrella while reducing the
    overall number of lines of code. Thus, adding a bit of complexity *locally* to
    a function can reduce the overall *global* complexity of a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, it’s a good idea to keep the “one task only” guide in mind when writing
    functions. Here’s a simple example involving an embedded `print()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If this function is used as an intermediate step in a program—that is, if you’re
    just calculating the area to pass it on to another function—do you really want
    it printing the answer to the screen? Unnecessary printing increases the runtime
    of programs and can clutter your screen with unneeded information.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, suppose that you want to get a user’s name, convert it to
    lowercase, and then sort the letters alphabetically to find anagrams for the name
    in a dictionary. It would be silly to break these tasks into multiple functions
    to honor the “one task only” guideline.
  prefs: []
  type: TYPE_NORMAL
- en: In his book *Beyond the Basic Stuff with Python* (No Starch Press, 2021), author
    Al Sweigart recommends that functions be as short as reasonably possible but no
    shorter. They should not exceed 200 lines of code and ideally contain fewer than
    30 lines.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lambda Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember how you can reduce `for` loops to a single line of code using comprehensions?
    Well, lambda functions let you do something similar with functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *lambda function* is a single-use, unnamed function consisting of a single
    statement. They’re sometimes called an *anonymous* function because they’re defined
    with the `lambda` keyword rather than a name of their own. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Words and characters that directly follow `lambda` are treated as parameters.
    Expressions come after the colon, and returns are automatic, with no need for
    the `return` keyword. Here’s an example that multiplies two numbers together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A nice thing about lambda functions is that you can create them on the fly,
    without the need for a variable assignment. Just put the function in parentheses
    and add the arguments, also in parentheses, to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda functions are often used in conjunction with the built-in `filter()`
    function to select particular elements from a sequence. The lambda function defines
    the filtering constraint that the `filter()` function then applies to the sequence.
    Here’s an example in which we return all the numbers with a value less than `10`
    from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that you need to type cast the `filtered` object to another data type such
    as a list or tuple before you can print it.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda functions are useful in data analysis when you need to pass a function
    as an argument to a data transformation function. They’ll also save you the effort
    of typing full function definitions while preserving the readability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Generators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *generator* is a special routine for controlling the iteration behavior of
    a loop. It lets you generate a sequence *one value at a time* rather than all
    at once. Compare this to a regular function, which must create the entire sequence
    in memory before returning the result, regardless of the size of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Generators use *lazy* evaluation, which means that they compute the value of
    an item only when invoked, without having to load everything in memory first.
    As a result, generator objects have a lower memory footprint than other iterables,
    such as lists.
  prefs: []
  type: TYPE_NORMAL
- en: Generators are useful when working with sequences large enough to occupy much
    (if not all) of your system’s RAM. They’re also a good choice when you need to
    use a sequence only once.
  prefs: []
  type: TYPE_NORMAL
- en: The most familiar generator is the built-in `range()` function, which you’ve
    used before. With `range()`, it doesn’t matter for system memory if you set the
    upper limit to ten or a trillion, as each number is generated as it’s needed,
    and then discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generator functions are defined like regular functions except that they use
    a `yield` statement in place of a `return` statement. Here’s an example that yields
    the cube of each number in a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Whereas the `return` statement *ends* and *exits* a function, the `yield` statement
    *suspends* the function’s execution and sends a value back to the caller. Later,
    the function can resume where it left off. When a generator reaches its end, it’s
    “empty” and can’t be called again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to call a generator function and pass it an argument in the same
    manner as a regular function, you might be surprised by the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The issue here is that the function returned a type of iterator called a *generator
    object*. This object won’t begin executing its code until you *request* elements
    from it, for example, by using it in a `for` loop or by calling the built-in `next()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that creates a generator object (`cube_gen`) and then uses
    `next()` to get the next value from it. Behind the scenes, the generator pauses
    after each call to the `next()` function and resumes when the function is called
    again. This continues until the generator object is exhausted and raises a `StopIteration`
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the generator object is empty and can’t be used again. If you
    try to iterate over it with a `for` loop, you get nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You must remake a generator to use it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If your generator uses a simple expression, you can define it more concisely
    using a *generator expression*. A generator expression looks a lot like a list
    comprehension, but instead of square brackets, you surround the expression containing
    the `for` loop in *parentheses*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to their efficiency, generator expressions are often used in place of list
    comprehensions in functions like `min`, `max`, and `sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can convert generators to lists or tuples using type casting.
    In this example, we wrap the generator expression in the built-in `list()` function
    to convert the results to a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You might perform this action when using a very large sequence to generate a
    smaller sequence with a memory footprint small enough to store in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here, we use the `tuple()` built-in function to convert the results to
    a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Again, you might undertake this action when you need to efficiently produce
    a relatively small tuple from a larger input sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 6.  A generator function always contains which keyword?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `return`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `main`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `yield`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `range`
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Rewrite the `generate_data()` function in “Using a main() Function” on [page
    295](ch11.xhtml#ch00lev2sec154) so that it uses list comprehension rather than
    a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '8.  Write a lambda expression that prints the multiples of 5 in this list:
    `[3, 10, 16, 25, 88, 75]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '9.  True or false: The purpose of defining a `main()` function at the end of
    your code is to grant it access to any preceding functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '10.  To run a lambda function without assigning it to a variable, you must
    enclose it in:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Curley brackets
  prefs: []
  type: TYPE_NORMAL
- en: b.  Square brackets
  prefs: []
  type: TYPE_NORMAL
- en: c.  Parentheses
  prefs: []
  type: TYPE_NORMAL
- en: d.  You don’t need to enclose it at all
  prefs: []
  type: TYPE_NORMAL
- en: '**Modules**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Modules* are files—usually written in Python—that contain collections of related
    functions. Modules can be embedded in Python programs and used to perform both
    common and specialized tasks. Python’s *standard library*, for example, includes
    the `os` module, which provides widespread utility related to operating systems.
    It also includes the more specialized `math` module, which provides basic mathematical
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like functions, modules let you hide code that you don’t want to see in all
    its gory detail. In fact, many modules, as well as built-in functions, aren’t
    even *written* in Python. The standard library’s familiar `len()` function, for
    example, is implemented in the C language. Here’s some of its source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Imagine having to include code like this in your programs every time you want
    to get the length of a list or a string!
  prefs: []
  type: TYPE_NORMAL
- en: Through encapsulation, modules reduce complex code to one-line function calls.
    This, in turn, helps you to write cleaner code that’s easier to read. And the
    modules themselves let you break code into functional groups that are easier to
    access and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Modules save you time, effort, and even money in so much as most third-party
    modules are open source. Best of all, modules let you leverage the battle-tested
    efforts of experts in a field. The OpenCV computer vision module, for example,
    lets you identify faces, track objects, manipulate images and more, even if you
    know very little about the subject. You can also write your own modules if third-party
    versions aren’t available.
  prefs: []
  type: TYPE_NORMAL
- en: '***Importing Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Except for some modules in the standard library, you need to import modules
    prior to use. By convention, you should place these imports at the top of Python
    programs and insert an empty line after the last import. Consequently, you can
    think of imports as the “headwaters” of the flow of execution.
  prefs: []
  type: TYPE_NORMAL
- en: Importing modules at the top makes it easy to see which modules are being applied.
    This is important given that many times users will need to install the modules
    before running the program, and they don’t want to go on a “module scavenger hunt”
    through your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the import process using the `random` module, which lets you
    work with pseudo-random numbers. The simplest way to import this module is to
    use the `import` keyword followed by the module name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to use the functions in the `random` module, you need to use dot notation
    and enter the module name, followed by a period, followed by the function name.
    Here’s an example in which you use the `choice()` function to randomly choose
    from items in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can import multiple functions at a time using comma-separated values, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To save yourself the effort of typing `random` each time and to make your code
    lines shorter, you can just import `choice`, using the `from` keyword in the `import`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is more concise but somewhat less readable because you can forget where
    `choice()` comes from (though you can always scroll up to the top to check).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to reduce typing is to use an alias for the module name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In general, I would avoid this, except for modules for which the alias is widely
    used, such as `sns` for the seaborn plotting library and `pd` for the pandas data
    analytics library, among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, never use the `*` wildcard to import all the functions in a module,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This basically says, “import all the functions available in the `random` module.”
    You might encounter this in the literature or in other people’s code, but it’s
    considered bad practice. It imports all the functions and classes in a module
    into your namespace. As a result, names in the module might clash with the names
    of functions you define or functions of other libraries that you import. Although
    clashes rarely happen, it’s a good habit to keep your namespace as uncluttered
    as possible, so avoid `import *`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when importing multiple modules, the best practice is to import each
    module on a *separate line*. This is more readable and lets you group modules
    in the preferred order of Python standard library → third-party modules → user-defined
    modules. Each group should be separated by a blank line, and a blank line should
    follow the last `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re concerned that multiple imported modules might use the same function
    name or names, import the modules by name—or with a short alias for the name—and
    call them by using dot notation. This way, the module name will be clearly linked
    to the function name, avoiding both confusion and collisions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python libraries are collections of packages, and packages are collections
    of modules. Consequently, all three are imported in the same way: using an import
    statement made up of the import keyword and the name of the library, package,
    or module being imported.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Inspecting Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use the built-in `dir()` function to see the functions available in
    a module. Let’s look at the `random` module, used for generating random numbers.
    The output is long, so I’ve truncated it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the source code for each function, you can use the `getsource()` method
    from the `inspect` module. Let’s look at the `random` module’s `choice()` function,
    used for randomly choosing an element from a sequence. Note that these modules
    are open source and subject to updates and revisions, so your output might look
    different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `choice()` is just a function like you’ve defined before. There’s
    really nothing magic about modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see only the module’s documentation, use the `getdoc()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, the built-in functions in the Python standard library
    are written in C and thus can’t be accessed by `inspect`. To view their source
    code, you’ll need to download it from *[https://www.python.org/downloads/source/](https://www.python.org/downloads/source/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Besides checking what a module is doing, inspecting the source code can help
    you to learn how to write your own custom functions that expand on or modify an
    existing module’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing Your Own Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Python (*.py*) file can serve as a module. After you import it, it becomes
    a special `module` object whose functions can be called with dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that you’re working on a project for which you need to repeatedly
    solve the quadratic equation and calculate the volume of a sphere. As these equations
    aren’t part of the standard `math` module, you’ll need to implement them on your
    own. Rather than define functions for these tasks in every program for which you’ll
    need to perform them, you can instead define them once in a reusable module named
    `mymath` and import that where needed. The filename is used as the module name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to determine where to save the module. When a module is imported,
    the Python interpreter first searches for a *built-in* module with that name.
    If no built-in module is found, it then searches for the filename in a list of
    directories given by the `sys` module’s built-in *sys.path* variable. According
    to the documentation, this path is initialized from these locations:'
  prefs: []
  type: TYPE_NORMAL
- en: The directory containing the input script (or the current directory when no
    file is specified).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PYTHONPATH* (a list of directory names, with the same syntax as the shell
    variable PATH).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The installation-dependent default (by convention including a site-packages
    directory, handled by the `site` module).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Going forward, we’ll use the first option and store your custom modules in
    your project’s directory. This will be the simplest and most straightforward approach
    for beginners and non-developers such as scientists and engineers. However, the
    module will be available only to scripts run from the project directory. To use
    the module in other projects, you’ll need to either copy the file to those directories
    or use one of the other options in the previous list. The easiest way is to add
    the path to the *PATH* variable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `mymath` module will contain functions for solving quadratic equations and
    for calculating the volume of a sphere. I’m going to save it in the *spyder_proj_w_env*
    project that we created in the “Creating a Project in an Existing Directory” on
    [page 70](ch04.xhtml#ch00lev2sec34). If you don’t want to use this project, feel
    free to create your own project folder using the instructions in [Chapter 4](ch04.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: First, open the project by going to Spyder’s top toolbar and then clicking **Projects**
    ▸ **Open Project** ▸ **spyder_proj_w_env***.* You’ll want to see Spyder’s File
    Explorer, Text Editor, and IPython Console, such as it is presented in [Figure
    4-4](ch04.xhtml#ch04fig4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the text editor, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `quad()` function accepts the standard a, b, and c coefficients for the
    quadratic equation as arguments. It then calculates and returns both solutions
    to the equation. The `sphere_vol()` function accepts a radius as an argument and
    returns the volume of a sphere with that radius rounded to two decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The mymath module imports the built-in math module. This is fine, but be careful
    about writing and importing multiple modules that depend on one another. This
    results in circular dependencies that get messy and can cause an ImportError.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, save the program as *mymath.py* in the *code* folder by clicking **File**
    ▸ **Save as** on the top toolbar. Alternatively, you could save it at the project
    folder level ([Figure 11-3](ch11.xhtml#ch011fig3)) and still access it from scripts
    in the *code* folder. Personally, I don’t like to clutter the project folder with
    individual files, hence the decision to place it in *code*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: The mymath.py module can be saved in either the code folder or
    the main project folder.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re ever curious about what folder the Python interpreter is currently
    working in, import the operating system module (`os`) and use its `getcwd()` function
    to return the current working directory. Here’s an example in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Because the current directory is the *code* folder, you don’t need to specify
    a path to import or otherwise access other files in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s test the module in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to assign the results of the `quad()` function to a variable, remember
    that the quadratic equation has two solutions, so you’ll need to use two variables
    in the assignment statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is to it! Now, any programs in the *code* folder can import
    and use the `mymath` module, just as they can use a built-in module.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you try to import a module that’s already been imported, nothing will happen.
    So, if you change a module and want to reimport it, the best course of action
    is to restart the kernel and then import the module again. In fact, anytime Python
    is behaving strangely, you should consider restarting the kernel. As your IT support
    person likes to say, “Have you tried rebooting?”*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Naming Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When naming modules, the best practice is to use lowercase characters and separate
    words with underscores. Names should preferably be one word only, as names with
    underscores can be confused for variable names. You’ll also want to avoid special
    symbols like the dot (.) and question mark (?). These symbols can cause problems
    due to the way Python looks for modules. A filename like *my.module.py*, for example,
    would indicate to Python that the *module.py* file should be found in a folder
    named *my*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing Modules That Work in Stand-Alone Mode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *mymath.py* program you wrote in “Writing Your Own Modules” on [page 307](ch11.xhtml#ch00lev2sec161)
    just defines two functions. It works great as a module, but it’s not very usable
    on its own, because there’s no call to the functions. So, let’s turn *mymath.py*
    into a program that will run in stand-alone mode *and* work as a module.
  prefs: []
  type: TYPE_NORMAL
- en: In Spyder, open *mymath.py* in the text editor and make a copy of it using **File**
    ▸ **Save as** from the top toolbar. Name the new file *mymath2.py*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the code blocks at ➊ and ➋ to define and call a `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: At ➊, you define a `main()` function to run the program, assigning variables
    to serve as arguments to the module’s functions, calling the two functions, and
    printing the results.
  prefs: []
  type: TYPE_NORMAL
- en: For Python to evaluate whether a program is being run in stand-alone mode or
    as an imported module, it’s necessary for you to use the special built-in `__name__`
    variable ➋. If you run the program directly, `__name__` is set to `__main__`,
    and the `main()` function is called. If the program is imported, `__name__` is
    set to the module’s filename, `main()` is not invoked, and the program won’t execute
    until you call one of its functions, like `quad()` or `sphere_vol()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the program and run it using F5 or the “play” icon on the Run toolbar.
    You should see the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The program ran as if you had simply called `main()` as the last line.
  prefs: []
  type: TYPE_NORMAL
- en: '***Built-in Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Python comes with multiple built-in modules. Covering all these is beyond the
    scope of this book, but [Table 11-2](ch11.xhtml#ch011tab2) lists some commonly
    used ones, along with a brief description of each. You’ve already worked with
    several of these, including `math`, `random`, `logging`, and `inspect`. We’ll
    look at some of the other ones in chapters to come.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-2:** Frequently Used Built-in Python Modules'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `os` | Operating system tasks like directory and file creation, deletion,
    identifying the current directory, and more. |'
  prefs: []
  type: TYPE_TB
- en: '| `sys` | System operation and runtime environment tasks like exiting programs,
    getting paths, command line use, and more. |'
  prefs: []
  type: TYPE_TB
- en: '| `shutil` | Shell utilities for high-level file operations like copying, moving,
    deleting directory trees, and more. |'
  prefs: []
  type: TYPE_TB
- en: '| `inspect` | Functions to get information about live objects such as modules,
    classes, methods, functions, tracebacks, frame objects, and code objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `logging` | A flexible event logging system for monitoring a program’s flow
    of execution. |'
  prefs: []
  type: TYPE_TB
- en: '| `math` | Basic mathematical operations and constants. |'
  prefs: []
  type: TYPE_TB
- en: '| `random` | Implements pseudo-random number generators for various distributions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `statistics` | Functions for calculating mathematical statistics like mean,
    geometric mean, median, mode, covariance, and more. |'
  prefs: []
  type: TYPE_TB
- en: '| `collections` | Provides specialized container datatypes providing alternatives
    to Python’s general purpose built-in containers like dictionaries, lists, sets,
    and tuples. Useful tools include namedtuple(), deque, defaultdict, and Counter.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `itertools` | Creates iterators for efficient looping. Includes fast functions
    for zipping, computing cartesian products, generating permutations and combinations,
    cycling, and more. |'
  prefs: []
  type: TYPE_TB
- en: '| `datetime` | Supplies tools for getting and manipulating dates and times.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `re` | Tools for working with regular expressions, that specify a set of
    matching strings. Used for searching and parsing text data. |'
  prefs: []
  type: TYPE_TB
- en: '| `http` | Collects several modules for working with the HyperText Transfer
    Protocol |'
  prefs: []
  type: TYPE_TB
- en: '| `json` | Methods for working with JSON-formatted data. |'
  prefs: []
  type: TYPE_TB
- en: '| `threading` | Used for creating, controlling, and managing threads (smallest
    sequence of programmed instructions) that allow different parts of a program to
    run concurrently for speed and simplicity. |'
  prefs: []
  type: TYPE_TB
- en: '| `multiprocessing` | Permits efficient use of multiple processors on a given
    machine. |'
  prefs: []
  type: TYPE_TB
- en: It’s a good idea to be aware of built-in modules so that you don’t find yourself
    reinventing the wheel and duplicating modules that already exist. You can find
    the official documentation at *[https://docs.python.org/3/tutorial/modules.html](https://docs.python.org/3/tutorial/modules.html)*.
    But don’t think you need to memorize the modules or their contents. A simple online
    search for a particular task will generally return information on modules as well
    as actual code samples for accomplishing the task.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 11.  Write a function that calculates the force of gravity using the equation
    *F* = (*G* * mass1 * mass2) / radius², where *G* is the gravitational constant
    (6.67 × 10-11 N-m²/kg²). Treat *G* as a *global* constant.
  prefs: []
  type: TYPE_NORMAL
- en: 12.  Import the `math` module and list all the functions it contains.
  prefs: []
  type: TYPE_NORMAL
- en: '13.  The preferred way to import *all* the functions available in a module
    is to use:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  `from` module `import *`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `import` module
  prefs: []
  type: TYPE_NORMAL
- en: c.  `import` module `as *`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `from` module `import` func1`,` func2`,` func3`...`
  prefs: []
  type: TYPE_NORMAL
- en: '14.  When you import a module, Python first searches for:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  a module with that name in the current working directory
  prefs: []
  type: TYPE_NORMAL
- en: b.  a module with that name in *PYTHONPATH*
  prefs: []
  type: TYPE_NORMAL
- en: c.  a module with that name in the site-packages directory
  prefs: []
  type: TYPE_NORMAL
- en: d.  a built-in module with that name
  prefs: []
  type: TYPE_NORMAL
- en: 15.  Write a function that accepts a variable in the global scope as an argument.
    Then, rewrite the function to use the same variable as a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions are callable collections of code that let you organize your program
    into modular, logical groups. If you find yourself repeating code, you should
    stop and write a function.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion means to “run back,” and recursive functions call themselves over
    and over. Recursive functions are used to solve complex problems that can be broken
    down into smaller problems of the same type and would be difficult to implement
    using a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda functions are one-off, unnamed functions consisting of single statements.
    For simple tasks, they save you the effort of defining a complete named function.
  prefs: []
  type: TYPE_NORMAL
- en: A generator is a function that returns an object that can be iterated over a
    single time. Rather than compute all of its values at once, a generator waits
    to be asked and then *yields* its values one at a time. As a result, a generator
    has a low memory footprint, making them useful for large data sets that you need
    to use only once.
  prefs: []
  type: TYPE_NORMAL
- en: A module is a Python file containing a collection of related functions. Modules
    must be imported into other Python files to be used. Modules let you take advantage
    of the expertise and efforts of others while keeping your code clean and uncluttered.
    You can also write customized modules for your own projects.
  prefs: []
  type: TYPE_NORMAL
