- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11'
- en: FUNCTIONS AND MODULES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数和模块**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: A *function* is a reusable set of instructions that performs a specific task.
    When the function completes its task, the flow of execution returns to the proper
    place in the greater code structure. *Modules* are programs, usually comprising
    functions, that perform a task or group of related tasks. Whereas you can define
    functions in place, you must import modules into a Python program to use them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是一个可重用的指令集，用于执行特定任务。当函数完成任务后，执行流程会返回到更大代码结构中的正确位置。*模块*是程序，通常由多个函数组成，用来执行某一任务或一组相关任务。你可以在代码中定义函数，但必须导入模块才能在Python程序中使用它们。'
- en: Both functions and modules let you simplify code through the process of *abstraction*.
    Abstraction is the act of moving the details of some process into a seemingly
    simpler object away from the main routine. Later, you can perform the task by
    calling the object’s name in a single line of code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和模块都通过*抽象化*过程来简化代码。抽象化是将某个过程的细节移动到一个看似更简单的对象中，远离主要的执行流程。稍后，你可以通过一行代码调用该对象的名称来完成任务。
- en: The best function and module names are short and descriptive. They allow you
    to skim the main routines of programs and get an idea of what’s going on, as if
    you were reading a summary. A good analogy is the table of contents of this book.
    Although a great many details are hidden away in the actual chapter, the headings
    and subheadings give you a good idea of what each chapter entails.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的函数和模块名称应该简短且富有描述性。它们可以让你快速浏览程序的主要部分，了解程序的执行流程，就像是在阅读摘要一样。一个好的类比是本书的目录。尽管实际章节中隐藏了大量的细节，但标题和小节标题让你大致了解每一章的内容。
- en: In previous chapters, you imported modules like `math` and `os`, and you used
    built-in functions like `print()` and `input()`. Their code was abstracted to
    the point that you never saw it. You just called a function, and something happened.
    There’ll be times, however, when a pre-built solution is either unavailable or
    insufficient, and you’ll need to create a function yourself.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你导入了像`math`和`os`这样的模块，并使用了内置函数如`print()`和`input()`。它们的代码被抽象化到了你从未看到的程度。你只需调用一个函数，然后就会发生某些事情。然而，也有时候，预先构建的解决方案要么不可用，要么不足以满足需求，这时你需要自己创建一个函数。
- en: By writing your own functions to reuse units of code, you can create more readable,
    better organized, and less redundant programs. In this chapter, you’ll write custom
    functions and modules and become familiar with additional built-in functions and
    third-party modules designed to make your life easier.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写自己的函数来重用代码单元，你可以创建更加可读、组织更好、冗余更少的程序。在本章中，你将编写自定义函数和模块，并熟悉一些额外的内置函数和第三方模块，它们能让你的编程生活更轻松。
- en: '**Defining Functions**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定义函数**'
- en: 'To write a function in Python, you define it by using the `def` keyword followed
    by a name for the function, parentheses, and a colon. As always, code coming after
    the colon must be indented, and the indented lines represent executable code.
    Here’s an example in the IPython console in the Spyder IDE:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中编写一个函数，你需要使用`def`关键字定义它，后面跟上函数名、括号和冒号。与往常一样，冒号后面的代码必须缩进，缩进的行表示可执行的代码。以下是在Spyder
    IDE的IPython控制台中的示例：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the console, you can complete a function by pressing ENTER twice or by
    using SHIFT-ENTER. In the editor, a function’s code block ends when you return
    to the same indentation level as the def keyword.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*在控制台中，你可以通过按两次ENTER键或使用SHIFT-ENTER键来完成一个函数。在编辑器中，当代码块回到与`def`关键字相同的缩进级别时，函数的代码块就结束了。*'
- en: 'You’ve now encapsulated a warning message within the `warning()` function.
    To use the message again, you need only *call* the function by entering its name
    and parentheses. This saves you from typing out the full message over and over:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经将警告信息封装在`warning()`函数中。要再次使用该信息，只需通过输入函数名和括号来*调用*函数即可。这可以避免你一遍又一遍地输入完整的消息：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In a function name, the parentheses `()`, sometimes referred to as the *call
    operator*, let Python know that an object can be *invoked*, which is a fancy way
    of saying “execute this command.”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名中，括号`()`，有时被称为*调用操作符*，让Python知道一个对象可以被*调用*，这是“执行此命令”的一种高级说法。
- en: 'Like everything else in Python, functions are objects. They belong to the `function`
    data type:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 和Python中的其他一切一样，函数也是对象。它们属于`function`数据类型：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can assign functions to variables, use them in other functions, define them
    in other functions, return them as values from other functions, and store them
    in data structures (for example, as an item in a list).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将函数赋值给变量，在其他函数中使用它们，在其他函数中定义它们，将它们作为返回值从其他函数返回，甚至将它们存储在数据结构中（例如，作为列表中的项）。
- en: According to Python’s PEP 8 Style Guide (*[https://pep8.org/](https://pep8.org/)*),
    you should surround top-level functions (those defined at indentation level 0)
    with two blank lines. Within functions, you should use blank lines (sparingly)
    to indicate logical sections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Python 的 PEP 8 风格指南 (*[https://pep8.org/](https://pep8.org/)*)，你应该用两行空白行将顶层函数（即缩进级别为
    0 的函数）包围。在函数内部，你应该适量使用空白行来表示逻辑部分。
- en: '***Using Parameters and Arguments***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用参数和实参***'
- en: You can submit, or *pass*, input to a function; perform some operation on the
    input; and then output, or *return*, the result. To do so, you use parameters
    and arguments inside the parentheses and separate them by commas.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向函数提交或*传递*输入，执行某些操作后，再输出或*返回*结果。为此，你可以在括号内使用参数和实参，并用逗号分隔它们。
- en: '*Parameters* are special kinds of variables, defined by a function, that receive
    a value when the function is called. They refer to the pieces of data provided
    as input but are not the data itself. For example, the following code defines
    a function that calculates a force value, using the famous equation *F=MA*, when
    passed mass and acceleration parameters:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*参数* 是函数定义时使用的特殊变量，当调用函数时，它们接收一个值。它们指的是作为输入提供的数据片段，而不是数据本身。例如，以下代码定义了一个函数，该函数通过传入质量和加速度参数，使用著名的方程
    *F=MA* 来计算力的值：'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Arguments* are the actual data values input when calling the function. For
    example, you could call the `calc_force()` function with these arguments:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*实参* 是在调用函数时传入的实际数据值。例如，你可以使用以下参数调用 `calc_force()` 函数：'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Figure 11-1](ch11.xhtml#ch011fig1) identifies the parameters in the `calc_force()`
    function definition and the arguments passed to it when called.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-1](ch11.xhtml#ch011fig1) 识别了 `calc_force()` 函数定义中的参数以及调用时传入的实参。'
- en: '![Image](../images/11fig01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/11fig01.jpg)'
- en: '*Figure 11-1: Function definitions use parameters and function calls use arguments*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：函数定义使用参数，函数调用使用实参*'
- en: Functions like `calc_force()` that return a value are called *fruitful* functions.
    Functions that perform an action but don’t return a value are called *void* functions.
    The `warning()` function in the previous section is an example of a void function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `calc_force()` 这样返回值的函数被称为 *有返回值的函数*。执行某个操作但不返回值的函数被称为 *无返回值的函数*。前一节中的 `warning()`
    函数就是一个无返回值的函数示例。
- en: With fruitful functions, the `return` statement causes execution to exit the
    function and resume at the point in the code immediately after the instruction
    that called the function, known as its *return address*. Values listed *after*
    the `return` keyword and on the same line are passed back to the code that called
    the function. For the `calc_force()` function, this would be the value in line
    `Out[5]`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有返回值的函数，`return` 语句会使得执行退出函数并在调用该函数的代码点后立即恢复执行，这个位置被称为函数的 *返回地址*。在 `return`
    关键字之后同一行列出的值会传回调用函数的代码。例如，对于 `calc_force()` 函数，这将是 `Out[5]` 行的值。
- en: The `return` keyword always ends a function and prevents execution of any subsequent
    code within the function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` 关键字总是结束一个函数，防止函数内的任何后续代码继续执行。'
- en: '**NOTE**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Technically, all functions need to evaluate to a return value. Void functions
    satisfy this requirement by automatically returning Python’s null value, None,
    which belongs to the NoneType data type.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，所有函数都需要返回一个值。空函数通过自动返回 Python 的空值 None 来满足这个要求，None 属于 NoneType 数据类型。*'
- en: '***Positional and Keyword Arguments***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***位置参数与关键字参数***'
- en: 'Function arguments can be of two types: *positional* and *keyword*. Positional
    arguments must be entered in the correct order, as defined by the order of the
    parameters in the function definition. As shown in [Figure 11-1](ch11.xhtml#ch011fig1),
    the `calc_force()` function uses positional arguments, such that the first argument
    submitted corresponds to the mass, and the second to the acceleration.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数可以分为两种类型：*位置参数*和*关键字参数*。位置参数必须按照函数定义中参数的顺序输入。正如 [图 11-1](ch11.xhtml#ch011fig1)
    所示，`calc_force()` 函数使用位置参数，第一个传入的参数对应质量，第二个对应加速度。
- en: 'Keyword (or *named*) arguments include a keyword and an equal sign before the
    submitted value. These are used to add clarity and make a function’s intention
    clear. Here’s how to call the `calc_force()` function using keywords:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字（或*命名*）参数包括一个关键字和等号，后面跟着提交的值。它们用于增加清晰度并明确函数的意图。下面是如何使用关键字调用`calc_force()`函数：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**NOTE**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*According to the Python Style Guide, no spaces should be used around the equal
    sign in keyword arguments.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*根据Python风格指南，关键字参数中的等号两侧不应有空格。*'
- en: 'Another advantage to keyword arguments is that you don’t need to remember the
    order in which the parameters were defined. Here, we enter arguments in reverse
    order:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数的另一个优点是你不需要记住定义参数时的顺序。在这里，我们按相反的顺序输入参数：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can enter both positional and keyword arguments when calling a function.
    However, after you use a keyword argument, you can’t go back to using positional
    arguments in the same function call. So, this code works:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在调用函数时同时输入位置参数和关键字参数。然而，一旦使用了关键字参数，就不能在同一个函数调用中再使用位置参数。因此，这段代码是有效的：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But this code fails:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这段代码失败了：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can force the use of keyword arguments by including an asterisk (`*`) as
    the first parameter when defining a function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在定义函数时将星号（`*`）作为第一个参数来强制使用关键字参数：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, if you attempt to use positional arguments, Python will raise an exception
    and inform you that positional arguments are not accepted:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试使用位置参数，Python将抛出异常并告知你不接受位置参数：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***Using Default Values***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用默认值***'
- en: You can specify a default value for one or more parameters. This lets you simplify
    the function call if a parameter generally uses a particular value. It also lets
    you guide users to an acceptable value if the user is not sure what to enter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为一个或多个参数指定默认值。这让你在参数通常使用特定值时简化函数调用。如果用户不确定要输入什么，它还可以引导用户选择一个可接受的值。
- en: 'Default parameters should be placed *after* any non-default parameters. Here’s
    an example of a function that uses a default value if the user presses ENTER without
    responding to the prompt question:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数应放在*所有非默认参数之后*。下面是一个示例，当用户按下ENTER键而没有回应提示问题时，函数会使用默认值：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function takes a prompt and a default value as arguments. The prompt and
    default will be specified when the function is called, and the program will display
    the default in square brackets ➊. The `response` variable holds the user’s input.
    If the user enters nothing and a default value exists, the default value is returned
    ➋. Otherwise, the user’s response is returned.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个提示和一个默认值作为参数。调用函数时会指定提示和默认值，程序会在方括号中显示默认值➊。`response`变量存储用户的输入。如果用户什么都不输入且存在默认值，则返回默认值➋。否则，返回用户的响应。
- en: 'Let’s use this function to get a user’s birth country. For users currently
    in the United States, we set the default value to “USA” so they can just press
    ENTER rather than type in the name. Note how this default lets you *control* the
    response when multiple choices are possible (such as “America,” “United States,”
    “United States of America,” “US,” and so on):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个函数来获取用户的出生国家。对于目前在美国的用户，我们将默认值设置为“USA”，这样他们只需按下ENTER键，而不需要输入名称。注意这个默认值如何让你*控制*响应，尤其是当有多个可能的选项时（比如“America”、“United
    States”、“United States of America”、“US”等等）：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A user can override the default by entering a response:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过输入一个响应来覆盖默认值：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In most cases, you’ll want to avoid using mutable objects like dictionaries,
    sets, or lists as default argument values in Python. This is because the default
    mutable object is initialized only *once*, when the function is *defined* rather
    than each time the function is *called*. This can produce unexpected outputs.
    Here’s an example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你会希望避免在Python中使用像字典、集合或列表这样的可变对象作为默认参数值。这是因为默认的可变对象仅在函数*定义*时初始化一次，而不是每次函数被*调用*时初始化。这可能会导致意想不到的输出。下面是一个例子：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The naive expectation here is that everyone who calls the `dog_breeds()` function
    will start off fresh with a bulldog and dachshund and then add their dog breeds
    to this list. But because the `current` list was created once when the function
    was defined in line `In [17]`, every subsequent call to the function appends items
    to this *same* list.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的天真期望是，每个调用`dog_breeds()`函数的人都会从一只斗牛犬和腊肠犬开始，然后将他们的狗品种添加到这个列表中。但是，由于`current`列表是在函数定义时创建的（在第`In
    [17]`行），每次调用该函数时都会向这个*相同*的列表添加项目。
- en: '***Returning Values***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***返回值***'
- en: 'When functions return a value, you can store the result in a variable using
    an assignment statement. For example, the following code stores the value returned
    from running the `calc_force()` function in a variable called `force`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数返回一个值时，你可以通过赋值语句将结果存储到一个变量中。例如，下面的代码将从运行`calc_force()`函数返回的值存储到名为`force`的变量中：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can even return multiple values, separated by commas. You’ll need a variable
    to hold each value, as in this example, in which the function accepts a number
    as an argument and returns the square and cube of the number:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以返回多个值，用逗号分隔。你需要一个变量来存储每个值，如这个例子所示，函数接受一个数字作为参数，并返回该数字的平方和立方：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, functions can include multiple `return` statements. Each statement
    executes under a given condition, and as soon as one executes, the function ends.
    Try this in the console:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数可以包含多个`return`语句。每个语句在特定条件下执行，一旦某个语句执行完毕，函数就结束。试试在控制台中执行这个：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, the `goldilocks()` function accepts a number as an argument,
    converts it to an integer, and then compares it to `42`. Each of the three possible
    outcomes (greater than, less than, or equal to) has its own `return` statement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`goldilocks()`函数接受一个数字作为参数，将其转换为整数，然后与`42`进行比较。三种可能的结果（大于、小于或等于）各自有一个`return`语句。
- en: '***Naming Functions***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***命名函数***'
- en: The guidelines for naming functions are the same as those for naming variables
    (see “Naming Variables” on [page 206](ch08.xhtml#ch00lev1sec56)). You can use
    letters, underscores, and numbers, as long as the first character isn’t a number.
    All characters should be lowercase, and you should separate words with an underscore.
    You’ll want to avoid reserved keywords and the names of built-in functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数的规则与命名变量的规则相同（参见[第206页](ch08.xhtml#ch00lev1sec56)的“命名变量”）。你可以使用字母、下划线和数字，只要首字符不是数字。所有字符应为小写，并且应使用下划线分隔单词。你应避免使用保留字和内置函数的名称。
- en: Because functions perform an action, a good naming strategy is to include a
    verb and a noun that describe that action. Some examples are `reset_password()`,
    `register_image()`, and `plot_light_curve()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数执行一个动作，所以好的命名策略是包含描述该动作的动词和名词。一些例子是`reset_password()`、`register_image()`和`plot_light_curve()`。
- en: For more on naming and defining functions, visit the documentation at *[https://docs.python.org/3/tutorial/controlflow.html#defining-functions/](https://docs.python.org/3/tutorial/controlflow.html#defining-functions/)*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命名和定义函数的更多信息，请访问文档中的*[https://docs.python.org/3/tutorial/controlflow.html#defining-functions/](https://docs.python.org/3/tutorial/controlflow.html#defining-functions/)*。
- en: '***Built-in Functions***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内置函数***'
- en: Python comes with multiple built-in functions to make your coding life easier.
    You’ve already worked with many of these, including `print()`, `len()`, `type()`,
    `list()`, `input()`, `round()`, and more.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了多个内置函数，让你的编码生活更加轻松。你已经使用过许多这些函数，包括`print()`、`len()`、`type()`、`list()`、`input()`、`round()`等。
- en: '[Table 11-1](ch11.xhtml#ch011tab1) lists some of the more frequently used built-in
    functions. To see the full list, along with detailed descriptions of each function,
    visit *[https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)*.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-1](ch11.xhtml#ch011tab1)列出了更常用的内置函数。要查看完整列表以及每个函数的详细描述，请访问*[https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)*。'
- en: '**Table 11-1:** Frequently Used Built-in Functions'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 11-1：** 常用的内置函数'
- en: '| **Function** | **Description** |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `abs()` | Return the absolute value of a number. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `abs()` | 返回数字的绝对值。 |'
- en: '| `all()` | Return `True` if all elements of an iterable are true or if the
    iterable is empty. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `all()` | 如果可迭代对象的所有元素都为真，或者可迭代对象为空，返回`True`。 |'
- en: '| `any()` | Return `True` if any element of an iterable is true or `False`
    if iterable is empty. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `any()` | 如果可迭代对象的任一元素为真，或者可迭代对象为空，返回`True`。 |'
- en: '| `chr()` | Return a string representing an input Unicode code point (`chr(97)`
    returns `′``a``′`). |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `chr()` | 返回表示输入的Unicode代码点的字符串（`chr(97)`返回`''a''`）。 |'
- en: '| `dict()` | Create a new `dictionary object`. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `dict()` | 创建一个新的`字典对象`。 |'
- en: '| `dir()` | Without argument, return names in the current local scope. If an
    object is passed as an argument, return list of attributes and methods for that
    object. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `dir()` | 不带参数时，返回当前作用域中的名称。如果传入一个对象作为参数，返回该对象的属性和方法列表。 |'
- en: '| `enumerate()` | Adds a counter to each item of an iterable object and returns
    an enumerate object. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `enumerate()` | 为可迭代对象中的每个项添加一个计数器，并返回一个枚举对象。 |'
- en: '| `filter()` | Return an iterator from those elements of an iterable for which
    function returns `True`. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `filter()` | 返回一个迭代器，包含那些函数返回`True`的可迭代元素。 |'
- en: '| `float()` | Return a floating-point number constructed from a number or string.
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `float()` | 返回由数字或字符串构建的浮动数值。 |'
- en: '| `frozenset()` | Return a `frozenset` object. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `frozenset()` | 返回一个`frozenset`对象。 |'
- en: '| `hash()` | Return the hash value of an object if it has one. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `hash()` | 返回对象的哈希值（如果有的话）。 |'
- en: '| `help()` | Invoke built-in help system (intended for interactive use). |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `help()` | 调用内置帮助系统（适用于交互式使用）。 |'
- en: '| `hex()` | Convert an integer to a lowercase hexadecimal string prefixed with
    “0x.” |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `hex()` | 将整数转换为小写十六进制字符串，并以“0x”开头。 |'
- en: '| `id()` | Return the identity of an object. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `id()` | 返回一个对象的标识。 |'
- en: '| `input()` | Get user input using a prompt and return it as a string. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `input()` | 获取用户输入并将其作为字符串返回。 |'
- en: '| `int()` | Return an integer number constructed from a number or string. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `int()` | 返回由数字或字符串构建的整数。 |'
- en: '| `isinstance()` | Return `True` if the specified object is of the specified
    type; otherwise, return `False`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `isinstance()` | 如果指定的对象是指定类型的实例，则返回`True`，否则返回`False`。 |'
- en: '| `len()` | Return the number of items in a sequence or collection (such as
    a string, list, or set). |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `len()` | 返回序列或集合中的元素数量（例如字符串、列表或集合）。 |'
- en: '| `list()` | Create a new `list` object. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `list()` | 创建一个新的`list`对象。 |'
- en: '| `max()` | Return largest item in an iterable or the largest of two or more
    arguments. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `max()` | 返回可迭代对象中的最大项，或两个或更多参数中的最大值。 |'
- en: '| `min()` | Return smallest item in an iterable or the smallest of two or more
    arguments. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `min()` | 返回可迭代对象中的最小项，或两个或更多参数中的最小值。 |'
- en: '| `next()` | Retrieve the next item from an iterator. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `next()` | 从迭代器中获取下一个元素。 |'
- en: '| `open()` | Open a file and return a corresponding `file` object. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `open()` | 打开一个文件并返回相应的`file`对象。 |'
- en: '| `ord()` | Return the Unicode code point of a character (`ord(``′``a``′``)`
    returns `97`). |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `ord()` | 返回字符的Unicode码点（`ord(''a'')` 返回 `97`）。 |'
- en: '| `pow()` | Return a number raised to the power specified. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `pow()` | 返回指定幂次的数值。 |'
- en: '| `print()` | Print a specified message to the screen or other standard output
    device. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `print()` | 将指定的消息打印到屏幕或其他标准输出设备。 |'
- en: '| `range()` | Generate an immutable sequence of numbers for given start and
    stop integers. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `range()` | 生成一个不可变的数字序列，用于指定的起始和停止整数。 |'
- en: '| `repr()` | Return a string containing a printable representation of an object.
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `repr()` | 返回包含对象可打印表示形式的字符串。 |'
- en: '| `reversed()` | Return a reversed iterator. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `reversed()` | 返回一个反向迭代器。 |'
- en: '| `round()` | Return a number rounded to *n*-digits precision after the decimal
    point. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `round()` | 返回四舍五入到 *n* 位小数的数值。 |'
- en: '| `set()` | Create a new `set` object. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `set()` | 创建一个新的`set`对象。 |'
- en: '| `sorted()` | Return a new sorted list (forward or backward) from the items
    in an iterable. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `sorted()` | 从可迭代对象的元素中返回一个新的排序列表（正序或倒序）。 |'
- en: '| `str()` | Return a string version of an object. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `str()` | 返回对象的字符串版本。 |'
- en: '| `sum()` | Return the sum of all items in an iterable. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `sum()` | 返回可迭代对象中所有项的和。 |'
- en: '| `tuple()` | Create a new `tuple` object. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `tuple()` | 创建一个新的`tuple`对象。 |'
- en: '| `type()` | Return the type of an object. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `type()` | 返回一个对象的类型。 |'
- en: '| `zip()` | Iterate over several iterables in parallel, producing tuples with
    an item from each. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `zip()` | 并行遍历多个可迭代对象，生成每个元素的元组。 |'
- en: It’s good practice to check whether a built-in function exists for a specific
    task before writing code on your own.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在自己编写代码之前，先检查是否有内置函数可以完成特定任务。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: '1.  When you call a function that takes input, you pass it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  当你调用一个需要输入的函数时，你传递给它的是：
- en: a.  parameters
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: a.  参数
- en: b.  objects
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: b.  对象
- en: c.  arguments
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: c.  参数
- en: d.  the `def` keyword
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `def` 关键字
- en: '2.  Ideally, a function name should contain both a:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  理想情况下，一个函数名称应当包含以下两者：
- en: a.  noun and an underscore
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: a.  名词和下划线
- en: b.  verb and an underscore
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: b.  动词和下划线
- en: c.  verb and a noun
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: c.  动词和名词
- en: d.  number and an underscore
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: d.  数字和下划线
- en: '3.  A function that returns no value is called a:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  一个不返回值的函数称为：
- en: a.  fruitful function
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: a.  有效的函数
- en: b.  void function
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: b.  无返回值的函数
- en: c.  warning function
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: c.  警告函数
- en: d.  module
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: d.  模块
- en: 4.  Write a function that accepts a user’s name and then returns their name
    stripped of vowels. You’ll want to make a string of vowels, loop through the letters
    in the name, and compare each letter to the contents of the vowel string.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  编写一个函数，接受用户的名字并返回去除元音字母后的名字。你需要创建一个元音字母的字符串，遍历名字中的每个字母，并将每个字母与元音字符串中的内容进行比较。
- en: 5.  Write a function that calculates momentum (mass * velocity) using keyword
    arguments only.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  编写一个仅使用关键字参数的函数来计算动量（质量 * 速度）。
- en: '**Functions and the Flow of Execution**'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数与执行流程**'
- en: 'Like conditional statements and loops, functions can cause code to branch or
    jump around. In the following example, we define two functions and call the first
    function from within the second:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于条件语句和循环，函数可以导致代码分支或跳转。在下面的示例中，我们定义了两个函数，并在第二个函数内部调用第一个函数：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When you call the `find_3()` function, the flow of execution moves into the
    function. But rather than return a value—and control—back to the main routine,
    this function calls another function, which could theoretically call another function
    defined somewhere higher in the code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`find_3()`函数时，执行流程会进入该函数。但该函数并不是返回一个值并将控制权交回主程序，而是调用了另一个函数，理论上该函数可以调用代码中更高位置定义的其他函数。
- en: 'The definition of these two functions doesn’t need to be in order and can be
    separated by other code, as long as calls to the functions come *after* their
    definition. On the Spyder main menu, click **Consoles** ▸ **Restart kernel** and
    then enter the following code, which now defines `find()` before `success()`,
    with some other code in between:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数的定义不需要按顺序进行，也可以通过其他代码进行分隔，只要对这些函数的调用发生在它们定义*之后*。在Spyder主菜单中，点击**控制台** ▸
    **重启内核**，然后输入以下代码，这次将`find()`定义放在`success()`之前，中间有其他代码：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the order in which you defined the two functions didn’t matter;
    what’s important is that you made the call to `find_3()` after they were defined.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，定义这两个函数的顺序并不重要；重要的是你在它们定义之后才调用了`find_3()`。
- en: '***Using Namespaces and Scopes***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用命名空间和作用域***'
- en: A *namespace* is a collection of names. Behind the scenes, Python uses namespaces
    to map names to corresponding objects in memory. This lets Python keep track of
    all the names currently in use and prevent *collisions*, wherein two different
    objects share the same name.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名空间*是名称的集合。在幕后，Python使用命名空间将名称映射到内存中的相应对象。这使得Python能够跟踪当前正在使用的所有名称，并防止*冲突*，即两个不同的对象共享相同的名称。'
- en: Different, isolated namespaces, called *scopes*, can exist at the same time
    within a single program. When you start typing a program in the console or the
    text editor, you are in the *global* scope, and all the object names share the
    same namespace. Every time you define a function, you enter the function’s *local*
    scope, and all the names used within the function share a new namespace that’s
    hidden from both the global scope and the local scope of other functions. Thus,
    it’s possible to use the same object name within one function as you do within
    another function, or in the main program in the global scope (see [Figure 11-2](ch11.xhtml#ch011fig2)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的、独立的命名空间，称为*作用域*，可以在单个程序中同时存在。当你在控制台或文本编辑器中开始编写程序时，你位于*全局*作用域中，所有的对象名称共享同一个命名空间。每次你定义一个函数时，你进入该函数的*局部*作用域，所有在函数中使用的名称都会共享一个新的命名空间，这个命名空间对全局作用域和其他函数的局部作用域都是隐藏的。因此，在一个函数中使用与另一个函数或全局作用域中的主程序相同的对象名称是可能的（见[图
    11-2](ch11.xhtml#ch011fig2)）。
- en: '![Image](../images/11fig02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig02.jpg)'
- en: '*Figure 11-2: This program has a global scope (gray) and two isolated local
    scopes within functions (white).*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：这个程序有一个全局作用域（灰色）和两个函数中的独立局部作用域（白色）。*'
- en: 'Let’s look at scope behavior in practice. Enter the following in the console:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下作用域行为的实际应用。请在控制台中输入以下内容：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous snippet, you used the same variable name (`x`) twice without
    a problem. This is because the first `x` is in the global scope, and the second
    `x` is safely tucked-away within the local scope of the function. As written,
    there’s no way for the global scope to access the `x` in the local scope. So,
    when you print `x` in line `In [44]`, you get the value in the global scope, despite
    the fact that `x` appears to have been reassigned to `5` in the function. After
    the function terminates, all its local variables are “forgotten” by Python, so
    no name conflicts occur.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你使用了相同的变量名（`x`）两次，而没有问题。这是因为第一个`x`在全局作用域中，而第二个`x`安全地存放在函数的局部作用域中。按照当前的写法，全局作用域无法访问局部作用域中的`x`。因此，当你在`In
    [44]`行打印`x`时，你得到的是全局作用域中的值，尽管`x`在函数中看似已被重新赋值为`5`。函数终止后，Python会“忘记”所有局部变量，因此不会发生名称冲突。
- en: Compartmentalizing the code using scopes also aids debugging. It’s easier to
    track down the source of bad values because functions can only interact with the
    rest of the program through the arguments they’re passed and the values they return.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用作用域来划分代码也有助于调试。因为函数只能通过它们传递的参数和返回的值与程序的其他部分进行交互，所以更容易追踪错误值的来源。
- en: '***Using Global Variables***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用全局变量***'
- en: 'Any variable assigned in the global scope is visible to both the global and
    local scopes. To indicate that you’re accessing a global variable without passing
    it to the function as an argument, and to make it fully available to the function,
    you must use the *global statement* to specify it as a *global variable* within
    the function, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局作用域中赋值的任何变量对全局和局部作用域都是可见的。为了表明你在访问全局变量而不是将其作为参数传递给函数，并使其完全在函数中可用，你必须使用*global语句*将其指定为函数中的*全局变量*，如下所示：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By adding the line `global x` in the definition of the `local_scope()` function,
    you gave the function access to the `x` variable in the global scope. Now, when
    you change the value of `x` in the function, that change is reflected in the global
    scope, and printing `x` returns `5`, not `42`, as before.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`local_scope()`函数的定义中添加`global x`这一行，你为该函数提供了访问全局作用域中`x`变量的权限。现在，当你在函数中更改`x`的值时，这一变化将在全局作用域中反映出来，打印`x`时返回的是`5`，而不是之前的`42`。
- en: '**NOTE**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Variables in the global space can be changed from within a function, without
    the use of the global statement, if they are mutable objects.*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局空间中的变量如果是可变对象，可以在函数内进行修改，而无需使用global语句。*'
- en: Because it’s possible to use global variables in the local scope of functions,
    you should avoid using the same names for local and global variables. Likewise,
    you should avoid using the same name for variables in local scopes. Even though
    it’s impossible to share a local variable either globally or with another function,
    this can become confusing. It’s rarely a good idea to use the same name for two
    different things, even if they never interact.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在函数的局部作用域中可以使用全局变量，因此应避免在局部变量和全局变量中使用相同的名称。同样，应该避免在局部作用域中使用相同的变量名。虽然不可能在全局范围或其他函数之间共享局部变量，但这可能会造成混淆。即使它们从不交互，通常也不建议为两个不同的东西使用相同的名称。
- en: Using global variables is generally discouraged, especially in large and complex
    programs. Imagine that you have hundreds of lines of code with dozens of functions.
    One of the functions changes a global variable to the wrong value, either due
    to a bug or to a failure in logic. To find and correct this problem, you must
    search through the *entire* program rather than focus on individual functions
    or function calls.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不建议使用全局变量，尤其是在大型和复杂的程序中。试想，如果你有数百行代码和几十个函数，其中一个函数由于错误或逻辑失败将全局变量的值更改为错误的值。为了找到并修复这个问题，你必须遍历*整个*程序，而不是专注于单个函数或函数调用。
- en: '**NOTE**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*An exception to the “don’t use global variables” rule is the global constant.
    It’s okay to assign constant values near the top of your program in the global
    scope. Because constants shouldn’t change value, they shouldn’t introduce complexity
    into your code.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*“不要使用全局变量”规则的例外是全局常量。将常量值赋值到程序顶部的全局作用域是可以的。因为常量的值不应该变化，所以它们不应增加代码的复杂性。*'
- en: '***Using a main() Function***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用main()函数***'
- en: With the exception of short, simple programs, it’s common practice to encapsulate
    the main code of a program into a function called `main()`. This code runs the
    rest of the program by executing expressions and statements and calling functions.
    Removing it from the global scope makes it easier to find and manage.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了短小简单的程序外，通常将程序的主要代码封装到一个名为`main()`的函数中。这段代码通过执行表达式和语句、调用函数来运行程序的其余部分。将其从全局作用域中移除使得查找和管理更为方便。
- en: You can define the `main()` function anywhere, but generally it’s near the start
    or end of a program. If your code and function names are very readable, placing
    `main()` at the start of a program can serve as a good summary of what the program
    does.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在程序中的任何位置定义`main()`函数，但通常它位于程序的开始或结束。如果你的代码和函数名称非常易读，将`main()`放在程序的开始部分可以很好地概括程序的功能。
- en: 'Here’s a program that uses a `main()` function to calculate some statistics.
    Enter the following in the Spyder text editor and save it as *main_function_example.py*:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`main()`函数计算一些统计数据的程序。在Spyder文本编辑器中输入以下内容，并将其保存为*main_function_example.py*：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this code, we first import the `uniform()` method from the `random` module
    so that we can generate random float values to use as data (in real life, you’d
    load or type some data into the program). Next, we define the `main()` function.
    All this function does, in this case, is call other functions. Note how it reads
    like a summary of what the program does.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先从`random`模块导入`uniform()`方法，以便生成随机浮动值作为数据（在实际应用中，你会加载或输入一些数据到程序中）。接下来，我们定义了`main()`函数。就这个案例而言，函数的作用仅仅是调用其他函数。注意它的结构就像是对程序功能的总结。
- en: The next function, `generate_data()`, returns a list of 10 random float values,
    rounded to one decimal place, from a uniform distribution. To use the `uniform`
    method, pass it the beginning and ending values of the range that you want to
    use, in this case, 0.0 and 50.0 ➊. The next three functions will take this list
    as input (an argument) and return the mean, maximum, and minimum values, respectively.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数`generate_data()`返回一个包含10个随机浮动值的列表，这些值四舍五入到一个小数位，取自均匀分布。要使用`uniform`方法，需要传入你想要的范围的起始和结束值，在这个例子中是0.0和50.0➊。接下来的三个函数将接受这个列表作为输入（一个参数），分别返回均值、最大值和最小值。
- en: At this point, you’ve defined only functions. If you want the program to do
    something, you need to call the `main()` function before execution.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你只定义了函数。如果你希望程序做一些事情，执行之前需要调用`main()`函数。
- en: For code this simple, you could forgo use of a `main()` function and move its
    contents into the global scope, *below* the definitions of the functions being
    called. But as your code becomes longer and more complicated, a `main()` function
    will help you keep it clean and organized and make it easy to find and review
    what the program does.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种简单的代码，你可以不使用`main()`函数，而是将其内容移到全局作用域中，*在*被调用函数的定义下方。但是，随着代码变得更长、更复杂，`main()`函数将帮助你保持代码清晰和有序，并让你容易找到并回顾程序的功能。
- en: '**Advanced Function Topics**'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**高级函数主题**'
- en: At this point, you know enough about functions to handle most, if not all, of
    the coding problems you’ll encounter. There’s always more to learn, however. This
    section will give you a brief introduction to recursion, function design, lambda
    functions, and generators. Recursion is a particularly ambitious topic, and if
    you find it interesting or useful, I recommend reading more about it on your own.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经掌握了足够的函数知识，能够解决大部分（如果不是全部）你将遇到的编程问题。然而，总有更多的内容等待学习。本节将简要介绍递归、函数设计、lambda函数和生成器。递归是一个特别具有挑战性的主题，如果你觉得它有趣或有用，我建议你自己深入阅读。
- en: '***Recursion***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***递归***'
- en: '*Recursion* is a powerful programming technique in which a function calls itself.
    Although recursion can be accomplished using more efficient `for` and `while`
    loops, these loops can sometimes become complicated and messy.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归*是一种强大的编程技巧，其中一个函数会调用自身。虽然递归可以通过更高效的`for`和`while`循环来实现，但这些循环有时会变得复杂和凌乱。'
- en: For difficult problems, recursive functions can provide a simpler and more readable
    way to construct code. You’ll commonly see recursion used for solving factorials,
    finding numbers in a Fibonacci sequence, and calculating compound interest for
    a loan using additional data, like regular payments.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂的问题，递归函数可以提供一种更简单、更易读的方式来构建代码。你会经常看到递归被用来解决阶乘问题、查找斐波那契数列中的数字，或者计算贷款的复利利息，使用额外的数据，例如定期付款。
- en: Here’s a simple example of a recursive function named `beer()`. Notice that
    the `elif` and `else` statements include calls to the `beer()` function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的递归函数示例，名为`beer()`。注意`elif`和`else`语句中都包含了对`beer()`函数的调用。
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function was inspired by the famous “99 Bottles of Beer” song. It accepts
    a number—representing bottles of beer—as an argument, and then it updates the
    number of bottles remaining and calls itself again until the number reaches zero.
    The `elif` clause in the middle is needed only to correct the grammar when one
    bottle remains.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的灵感来源于著名的《99瓶啤酒》歌曲。它接受一个数字——代表啤酒瓶数——作为参数，然后更新剩余瓶数并再次调用自身，直到瓶数达到零。中间的`elif`语句仅用于在剩下最后一瓶时修正语法。
- en: The `if` statement ➊ does *not* include a recursive call to `beer()`, because
    this is the *base condition,* or *base case,* for the function. A base condition
    is one that will end the function if the condition is met.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句➊ *不*包括对`beer()`的递归调用，因为这是*基本条件*，或*基例*，用于函数的结束。当满足条件时，基本条件会终止函数。'
- en: 'You need a base case because recursions, like `while` loops, can go on forever.
    To see an example, enter the following in the console:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个基本情况，因为递归就像`while`循环一样，可能会一直持续下去。要查看一个示例，可以在控制台输入以下内容：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This example will raise the following exception:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将引发以下异常：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because the `keep_on_keeping_on()` function kept calling itself, it created
    an infinite recursion, resulting in a *stack overflow.* This error occurs when
    you attempt to write more data to a memory block than it can hold. Inclusion of
    a reachable base case could have stopped this from happening, but not if it allows
    too many recursive calls.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`keep_on_keeping_on()`函数不断调用自身，造成了无限递归，导致了*栈溢出*。这个错误发生在你尝试向一个内存块写入超出其容量的数据时。如果包含一个可达的基本情况，可以避免这种情况发生，但如果它允许过多的递归调用，则无法阻止。
- en: 'To prevent infinite recursions, the Python interpreter limits the *depth of
    recursion*; that is, the number of recursive calls to a function, to a default
    value. To see this value, in the console, use the system module (`sys`), as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止无限递归，Python解释器限制了*递归深度*；也就是说，限制了对一个函数的递归调用次数，默认为一个值。要查看这个值，可以在控制台中使用系统模块（`sys`），如下所示：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Although you can increase this recursion limit by passing the `sys.setrecursionlimit()`
    function an integer, you need to do this with care, as the highest possible limit
    is platform-dependent, and a high limit can still lead to a crash. A better option
    is to rewrite your code without recursion.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以通过传递一个整数给`sys.setrecursionlimit()`函数来增加递归限制，但需要小心这样做，因为最高可能的限制取决于平台，而过高的限制仍然可能导致崩溃。更好的选择是重写你的代码，避免使用递归。
- en: '**NOTE**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The actual recursion limit is usually a bit less than the value returned by
    sys.getrecursionlimit(). On my machine, a RecursionError is raised after 2,967
    calls, despite the limit being set at 3,000.*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*实际的递归限制通常比`sys.getrecursionlimit()`返回的值略小。在我的机器上，尽管限制设置为3,000，但在进行了2,967次调用后仍会引发RecursionError。*'
- en: '***Designing Functions***'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设计函数***'
- en: When it comes to writing functions, there’s a school of thought that believes
    a function “should do one thing and one thing only.” Although keeping functions
    short and simple is a good guideline, there are many cases for which longer, more
    complex functions are the better choice.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写函数时，有一种观点认为一个函数“应该只做一件事，且只做这件事”。虽然保持函数简短和简单是一个好的准则，但在许多情况下，较长、更复杂的函数反而是更好的选择。
- en: Longer functions can merge related tasks under one umbrella while reducing the
    overall number of lines of code. Thus, adding a bit of complexity *locally* to
    a function can reduce the overall *global* complexity of a program.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 较长的函数可以将相关任务合并到一个函数中，同时减少代码的总行数。因此，向函数添加一些*局部*复杂性可以减少程序的*全局*复杂性。
- en: 'Still, it’s a good idea to keep the “one task only” guide in mind when writing
    functions. Here’s a simple example involving an embedded `print()` function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在编写函数时，保持“只做一件事”的准则仍然是一个好主意。这里有一个简单的示例，涉及嵌入式`print()`函数：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If this function is used as an intermediate step in a program—that is, if you’re
    just calculating the area to pass it on to another function—do you really want
    it printing the answer to the screen? Unnecessary printing increases the runtime
    of programs and can clutter your screen with unneeded information.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个函数作为程序中的一个中间步骤使用——也就是说，如果你只是计算一个面积并将其传递给另一个函数——你真的希望它将答案打印到屏幕上吗？不必要的打印会增加程序的运行时间，并可能将不需要的信息堆积在屏幕上。
- en: On the other hand, suppose that you want to get a user’s name, convert it to
    lowercase, and then sort the letters alphabetically to find anagrams for the name
    in a dictionary. It would be silly to break these tasks into multiple functions
    to honor the “one task only” guideline.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，假设你想获取用户的名字，将其转换为小写，然后按字母顺序排列字母，以便在字典中找到这个名字的字谜。为了遵守“只做一件事”的准则，把这些任务拆分成多个函数是很傻的做法。
- en: In his book *Beyond the Basic Stuff with Python* (No Starch Press, 2021), author
    Al Sweigart recommends that functions be as short as reasonably possible but no
    shorter. They should not exceed 200 lines of code and ideally contain fewer than
    30 lines.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《*Beyond the Basic Stuff with Python*》（No Starch Press, 2021）中，作者 Al Sweigart
    推荐函数应尽可能简短，但又不能过短。它们的代码行数不应超过200行，理想情况下应少于30行。
- en: '***Lambda Functions***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Lambda 函数***'
- en: Remember how you can reduce `for` loops to a single line of code using comprehensions?
    Well, lambda functions let you do something similar with functions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得如何通过推导式将`for`循环缩减为一行代码吗？好吧，lambda函数让你可以用类似的方式处理函数。
- en: 'A *lambda function* is a single-use, unnamed function consisting of a single
    statement. They’re sometimes called an *anonymous* function because they’re defined
    with the `lambda` keyword rather than a name of their own. The syntax is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*lambda 函数* 是一个一次性使用的、没有名称的函数，由一个语句组成。它们有时被称为*匿名*函数，因为它们是通过 `lambda` 关键字定义的，而不是使用自己的名字。其语法如下：'
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Words and characters that directly follow `lambda` are treated as parameters.
    Expressions come after the colon, and returns are automatic, with no need for
    the `return` keyword. Here’s an example that multiplies two numbers together:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随 `lambda` 之后的单词和字符被视为参数。表达式出现在冒号后，返回值是自动的，无需使用 `return` 关键字。下面是一个示例，它将两个数字相乘：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A nice thing about lambda functions is that you can create them on the fly,
    without the need for a variable assignment. Just put the function in parentheses
    and add the arguments, also in parentheses, to the end:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数的一个优点是，你可以即时创建它们，而无需变量赋值。只需将函数放在括号中，并在末尾添加参数（也用括号括起来）：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lambda functions are often used in conjunction with the built-in `filter()`
    function to select particular elements from a sequence. The lambda function defines
    the filtering constraint that the `filter()` function then applies to the sequence.
    Here’s an example in which we return all the numbers with a value less than `10`
    from a list:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数通常与内置的 `filter()` 函数一起使用，用于从序列中选择特定的元素。lambda 函数定义了过滤条件，`filter()`
    函数随后将这些条件应用到序列中。下面是一个示例，我们从一个列表中返回所有小于 `10` 的数字：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that you need to type cast the `filtered` object to another data type such
    as a list or tuple before you can print it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在打印 `filtered` 对象之前，你需要将其转换为其他数据类型，如列表或元组。
- en: Lambda functions are useful in data analysis when you need to pass a function
    as an argument to a data transformation function. They’ll also save you the effort
    of typing full function definitions while preserving the readability of your code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数在数据分析中非常有用，尤其是当你需要将一个函数作为参数传递给数据转换函数时。它们还可以省去你编写完整函数定义的麻烦，同时保持代码的可读性。
- en: '***Generators***'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成器***'
- en: A *generator* is a special routine for controlling the iteration behavior of
    a loop. It lets you generate a sequence *one value at a time* rather than all
    at once. Compare this to a regular function, which must create the entire sequence
    in memory before returning the result, regardless of the size of the sequence.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成器* 是一种用于控制循环迭代行为的特殊例程。它允许你一次生成一个值，而不是一次性生成整个序列。与此相比，普通函数必须在返回结果之前先在内存中创建整个序列，无论序列的大小如何。'
- en: Generators use *lazy* evaluation, which means that they compute the value of
    an item only when invoked, without having to load everything in memory first.
    As a result, generator objects have a lower memory footprint than other iterables,
    such as lists.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器使用*懒*评估，这意味着它们只有在被调用时才计算一个项目的值，而不需要先将所有内容加载到内存中。因此，生成器对象比其他可迭代对象（如列表）占用更少的内存。
- en: Generators are useful when working with sequences large enough to occupy much
    (if not all) of your system’s RAM. They’re also a good choice when you need to
    use a sequence only once.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理足够大的序列（可能占用你系统内存的大部分或全部）时，生成器非常有用。它们也是仅需使用一次序列时的好选择。
- en: The most familiar generator is the built-in `range()` function, which you’ve
    used before. With `range()`, it doesn’t matter for system memory if you set the
    upper limit to ten or a trillion, as each number is generated as it’s needed,
    and then discarded.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的生成器是内置的 `range()` 函数，你之前可能已经使用过。使用 `range()` 时，无论你设置的上限是十还是万亿，对系统内存都没有影响，因为每个数字都是按需生成的，生成后立即丢弃。
- en: 'Generator functions are defined like regular functions except that they use
    a `yield` statement in place of a `return` statement. Here’s an example that yields
    the cube of each number in a sequence:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数的定义方式与普通函数相同，不同的是它们使用 `yield` 语句代替 `return` 语句。下面是一个示例，它生成序列中每个数字的立方：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Whereas the `return` statement *ends* and *exits* a function, the `yield` statement
    *suspends* the function’s execution and sends a value back to the caller. Later,
    the function can resume where it left off. When a generator reaches its end, it’s
    “empty” and can’t be called again.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `return` 语句会*结束*并*退出*一个函数，`yield` 语句则*挂起*函数的执行，并将一个值返回给调用者。稍后，函数可以从上次挂起的位置继续执行。当生成器到达末尾时，它变为空，无法再次调用。
- en: 'If you try to call a generator function and pass it an argument in the same
    manner as a regular function, you might be surprised by the result:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试调用生成器函数并像调用常规函数那样传递参数，您可能会对结果感到惊讶：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The issue here is that the function returned a type of iterator called a *generator
    object*. This object won’t begin executing its code until you *request* elements
    from it, for example, by using it in a `for` loop or by calling the built-in `next()`
    function.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是函数返回了一种称为*生成器对象*的迭代器类型。除非您通过在`for`循环中使用它或调用内置的`next()`函数等方式请求元素，否则此对象不会开始执行其代码。
- en: 'Here’s an example that creates a generator object (`cube_gen`) and then uses
    `next()` to get the next value from it. Behind the scenes, the generator pauses
    after each call to the `next()` function and resumes when the function is called
    again. This continues until the generator object is exhausted and raises a `StopIteration`
    exception:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个创建生成器对象（`cube_gen`）并使用`next()`获取其下一个值的示例。在幕后，生成器在每次调用`next()`函数后暂停，并在再次调用函数时恢复。这将持续进行，直到生成器对象耗尽并引发`StopIteration`异常：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'At this point, the generator object is empty and can’t be used again. If you
    try to iterate over it with a `for` loop, you get nothing:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，生成器对象为空，无法再次使用。如果您尝试使用`for`循环迭代它，将得不到任何内容：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You must remake a generator to use it again:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须重新创建生成器才能再次使用它：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If your generator uses a simple expression, you can define it more concisely
    using a *generator expression*. A generator expression looks a lot like a list
    comprehension, but instead of square brackets, you surround the expression containing
    the `for` loop in *parentheses*:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的生成器使用简单表达式，可以使用*生成器表达式*更简洁地定义它。生成器表达式看起来很像列表推导式，但是您需要将包含`for`循环的表达式用*括号*括起来：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Due to their efficiency, generator expressions are often used in place of list
    comprehensions in functions like `min`, `max`, and `sum`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其效率，生成器表达式经常用于替代函数中的列表推导式，例如`min`、`max`和`sum`：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, you can convert generators to lists or tuples using type casting.
    In this example, we wrap the generator expression in the built-in `list()` function
    to convert the results to a list:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用类型转换将生成器转换为列表或元组。在本例中，我们将生成器表达式包装在内置的`list()`函数中，将结果转换为列表：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You might perform this action when using a very large sequence to generate a
    smaller sequence with a memory footprint small enough to store in a list.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理非常大的序列以生成较小序列并且具有足够小的内存占用以存储在列表中时，您可能会执行此操作。
- en: 'And here, we use the `tuple()` built-in function to convert the results to
    a tuple:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在这里，我们使用`tuple()`内置函数将结果转换为元组：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Again, you might undertake this action when you need to efficiently produce
    a relatively small tuple from a larger input sequence.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要从较大的输入序列中高效生成相对较小的元组时，您可能会再次执行此操作。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试您的知识**'
- en: 6.  A generator function always contains which keyword?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  生成器函数始终包含哪个关键字？
- en: a.  `return`
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `return`
- en: b.  `main`
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `main`
- en: c.  `yield`
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `yield`
- en: d.  `range`
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `range`
- en: 7.  Rewrite the `generate_data()` function in “Using a main() Function” on [page
    295](ch11.xhtml#ch00lev2sec154) so that it uses list comprehension rather than
    a `for` loop.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  将“使用`main()`函数”中的`generate_data()`函数重写为列表推导式，而不是使用`for`循环，详见[第295页](ch11.xhtml#ch00lev2sec154)。
- en: '8.  Write a lambda expression that prints the multiples of 5 in this list:
    `[3, 10, 16, 25, 88, 75]`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  编写一个lambda表达式，打印出此列表中的5的倍数：`[3, 10, 16, 25, 88, 75]`。
- en: '9.  True or false: The purpose of defining a `main()` function at the end of
    your code is to grant it access to any preceding functions.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  正确还是错误：在代码末尾定义`main()`函数的目的是为了使其能够访问任何前面的函数。
- en: '10.  To run a lambda function without assigning it to a variable, you must
    enclose it in:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  要运行一个lambda函数而不将其分配给变量，您必须将其包含在：
- en: a.  Curley brackets
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: a.  花括号
- en: b.  Square brackets
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: b.  方括号
- en: c.  Parentheses
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: c.  括号
- en: d.  You don’t need to enclose it at all
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: d.  您根本不需要对其进行封闭
- en: '**Modules**'
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模块**'
- en: '*Modules* are files—usually written in Python—that contain collections of related
    functions. Modules can be embedded in Python programs and used to perform both
    common and specialized tasks. Python’s *standard library*, for example, includes
    the `os` module, which provides widespread utility related to operating systems.
    It also includes the more specialized `math` module, which provides basic mathematical
    functions.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块*是文件——通常是用 Python 编写——它们包含一组相关的函数。模块可以嵌入到 Python 程序中，用于执行常见任务和专业任务。例如，Python
    的 *标准库* 包括 `os` 模块，它提供与操作系统相关的广泛功能。它还包括更专业的 `math` 模块，提供基本的数学函数。'
- en: 'Like functions, modules let you hide code that you don’t want to see in all
    its gory detail. In fact, many modules, as well as built-in functions, aren’t
    even *written* in Python. The standard library’s familiar `len()` function, for
    example, is implemented in the C language. Here’s some of its source code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 像函数一样，模块让你隐藏你不希望看到的复杂代码。事实上，许多模块和内置函数甚至不是用Python编写的。例如，标准库中常见的`len()`函数是用 C
    语言实现的。以下是它的一些源代码：
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Imagine having to include code like this in your programs every time you want
    to get the length of a list or a string!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，每次你想获取一个列表或字符串的长度时，都需要在你的程序中包含这样的代码！
- en: Through encapsulation, modules reduce complex code to one-line function calls.
    This, in turn, helps you to write cleaner code that’s easier to read. And the
    modules themselves let you break code into functional groups that are easier to
    access and maintain.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过封装，模块将复杂的代码简化为单行函数调用。这反过来有助于你编写更简洁、易读的代码。模块本身也让你将代码拆分为更容易访问和维护的功能组。
- en: Modules save you time, effort, and even money in so much as most third-party
    modules are open source. Best of all, modules let you leverage the battle-tested
    efforts of experts in a field. The OpenCV computer vision module, for example,
    lets you identify faces, track objects, manipulate images and more, even if you
    know very little about the subject. You can also write your own modules if third-party
    versions aren’t available.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 模块节省了你的时间、精力，甚至金钱，因为大多数第三方模块都是开源的。最棒的是，模块让你能够利用领域专家经过实践检验的成果。例如，OpenCV计算机视觉模块让你即使对这个领域了解甚少，也能识别面部、追踪物体、处理图像等等。如果没有第三方版本，你还可以编写自己的模块。
- en: '***Importing Modules***'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导入模块***'
- en: Except for some modules in the standard library, you need to import modules
    prior to use. By convention, you should place these imports at the top of Python
    programs and insert an empty line after the last import. Consequently, you can
    think of imports as the “headwaters” of the flow of execution.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些标准库中的模块，你需要在使用之前先导入模块。按照约定，你应该将这些导入放在 Python 程序的顶部，并在最后一个导入之后插入一个空行。因此，你可以将导入看作是执行流程的“源头”。
- en: Importing modules at the top makes it easy to see which modules are being applied.
    This is important given that many times users will need to install the modules
    before running the program, and they don’t want to go on a “module scavenger hunt”
    through your code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块导入到顶部可以轻松查看哪些模块正在使用。考虑到很多时候用户需要在运行程序之前安装这些模块，他们不想在你的代码中进行“模块寻宝”。
- en: 'Let’s look at the import process using the `random` module, which lets you
    work with pseudo-random numbers. The simplest way to import this module is to
    use the `import` keyword followed by the module name:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`random`模块来看看导入过程，它允许你处理伪随机数。导入这个模块最简单的方法是使用`import`关键字，后面跟上模块名称：
- en: '[PRE42]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, to use the functions in the `random` module, you need to use dot notation
    and enter the module name, followed by a period, followed by the function name.
    Here’s an example in which you use the `choice()` function to randomly choose
    from items in a list:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用`random`模块中的函数，你需要使用点表示法，输入模块名称，后跟一个句点，再跟上函数名称。以下是一个例子，使用`choice()`函数从列表中的项中随机选择：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can import multiple functions at a time using comma-separated values, like
    this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用逗号分隔的值一次导入多个函数，像这样：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To save yourself the effort of typing `random` each time and to make your code
    lines shorter, you can just import `choice`, using the `from` keyword in the `import`
    statement:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省每次输入`random`的麻烦，并使你的代码行更简洁，你可以仅使用`from`关键字导入`choice`，如在`import`语句中所示：
- en: '[PRE45]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is more concise but somewhat less readable because you can forget where
    `choice()` comes from (though you can always scroll up to the top to check).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式更简洁，但可读性稍差，因为你可能会忘记`choice()`来自哪里（尽管你可以随时向上滚动到顶部查看）。
- en: 'Another way to reduce typing is to use an alias for the module name:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种减少输入的方法是为模块名使用别名：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In general, I would avoid this, except for modules for which the alias is widely
    used, such as `sns` for the seaborn plotting library and `pd` for the pandas data
    analytics library, among others.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我会避免这样做，除非是那些别名被广泛使用的模块，比如用于 seaborn 绘图库的`sns`和用于 pandas 数据分析库的`pd`等。
- en: 'Likewise, never use the `*` wildcard to import all the functions in a module,
    like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，永远不要使用`*`通配符来导入模块中的所有函数，如下所示：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This basically says, “import all the functions available in the `random` module.”
    You might encounter this in the literature or in other people’s code, but it’s
    considered bad practice. It imports all the functions and classes in a module
    into your namespace. As a result, names in the module might clash with the names
    of functions you define or functions of other libraries that you import. Although
    clashes rarely happen, it’s a good habit to keep your namespace as uncluttered
    as possible, so avoid `import *`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上表示“导入`random`模块中所有可用的函数”。你可能会在文献或其他人的代码中遇到这种写法，但这被认为是一个不好的做法。它将模块中的所有函数和类导入到你的命名空间中。结果，模块中的名称可能会与你定义的函数或其他库的函数发生冲突。虽然冲突很少发生，但养成尽量保持命名空间整洁的好习惯是很有必要的，因此应该避免使用`import
    *`。
- en: Finally, when importing multiple modules, the best practice is to import each
    module on a *separate line*. This is more readable and lets you group modules
    in the preferred order of Python standard library → third-party modules → user-defined
    modules. Each group should be separated by a blank line, and a blank line should
    follow the last `import` statement.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当导入多个模块时，最佳实践是将每个模块导入写在 *单独的行* 上。这种方式更具可读性，并且让你能够按 Python 标准库 → 第三方模块 → 用户自定义模块的优先顺序来组织模块。每一组模块之间应该用空行隔开，最后一个`import`语句后也应该跟一个空行。
- en: If you’re concerned that multiple imported modules might use the same function
    name or names, import the modules by name—or with a short alias for the name—and
    call them by using dot notation. This way, the module name will be clearly linked
    to the function name, avoiding both confusion and collisions.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心多个导入的模块可能使用相同的函数名称，可以按模块名称导入这些模块，或者为名称使用简短的别名，并通过点符号调用它们。这样，模块名就会清晰地与函数名关联，避免了混淆和冲突。
- en: '**NOTE**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Python libraries are collections of packages, and packages are collections
    of modules. Consequently, all three are imported in the same way: using an import
    statement made up of the import keyword and the name of the library, package,
    or module being imported.*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 库是包的集合，而包是模块的集合。因此，这三者的导入方式是相同的：使用由 `import` 关键字和要导入的库、包或模块的名称组成的导入语句。*'
- en: '***Inspecting Modules***'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查模块***'
- en: 'You can use the built-in `dir()` function to see the functions available in
    a module. Let’s look at the `random` module, used for generating random numbers.
    The output is long, so I’ve truncated it here:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置的`dir()`函数来查看模块中可用的函数。我们来看一下用于生成随机数的`random`模块。输出很长，因此我在这里做了截断：
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To view the source code for each function, you can use the `getsource()` method
    from the `inspect` module. Let’s look at the `random` module’s `choice()` function,
    used for randomly choosing an element from a sequence. Note that these modules
    are open source and subject to updates and revisions, so your output might look
    different:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看每个函数的源代码，你可以使用来自`inspect`模块的`getsource()`方法。我们来看一下`random`模块中的`choice()`函数，它用于从序列中随机选择一个元素。请注意，这些模块是开源的，可能会更新和修订，因此你的输出可能与我展示的不同：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can see that `choice()` is just a function like you’ve defined before. There’s
    really nothing magic about modules.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`choice()`只是一个像你之前定义的函数。模块并没有什么神奇之处。
- en: 'If you want to see only the module’s documentation, use the `getdoc()` method:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想查看模块的文档，可以使用`getdoc()`方法：
- en: '[PRE50]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As mentioned earlier, the built-in functions in the Python standard library
    are written in C and thus can’t be accessed by `inspect`. To view their source
    code, you’ll need to download it from *[https://www.python.org/downloads/source/](https://www.python.org/downloads/source/)*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python 标准库中的内置函数是用 C 编写的，因此无法通过 `inspect` 访问。要查看它们的源代码，你需要从 *[https://www.python.org/downloads/source/](https://www.python.org/downloads/source/)*
    下载。
- en: Besides checking what a module is doing, inspecting the source code can help
    you to learn how to write your own custom functions that expand on or modify an
    existing module’s functionality.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检查模块的功能外，检查源代码还可以帮助你学习如何编写自己的自定义函数，扩展或修改现有模块的功能。
- en: '***Writing Your Own Modules***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写你自己的模块***'
- en: A Python (*.py*) file can serve as a module. After you import it, it becomes
    a special `module` object whose functions can be called with dot notation.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Python（*.py*）文件可以作为一个模块。导入后，它会成为一个特殊的`module`对象，可以通过点符号调用其函数。
- en: Let’s assume that you’re working on a project for which you need to repeatedly
    solve the quadratic equation and calculate the volume of a sphere. As these equations
    aren’t part of the standard `math` module, you’ll need to implement them on your
    own. Rather than define functions for these tasks in every program for which you’ll
    need to perform them, you can instead define them once in a reusable module named
    `mymath` and import that where needed. The filename is used as the module name.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在处理一个需要反复求解二次方程并计算球体体积的项目。由于这些方程并不是`math`模块的一部分，你需要自己实现它们。为了避免在每个需要执行这些任务的程序中都定义函数，你可以一次性在一个名为`mymath`的可重用模块中定义这些函数，并在需要的地方导入该模块。文件名即为模块名。
- en: 'Next, we need to determine where to save the module. When a module is imported,
    the Python interpreter first searches for a *built-in* module with that name.
    If no built-in module is found, it then searches for the filename in a list of
    directories given by the `sys` module’s built-in *sys.path* variable. According
    to the documentation, this path is initialized from these locations:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定模块的保存位置。当导入模块时，Python解释器首先会查找一个名称匹配的*内建*模块。如果没有找到内建模块，它会在由`sys`模块的内建*sys.path*变量指定的目录列表中查找相应的文件。根据文档说明，该路径会从以下位置初始化：
- en: The directory containing the input script (or the current directory when no
    file is specified).
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含输入脚本的目录（或者如果没有指定文件，则为当前目录）。
- en: '*PYTHONPATH* (a list of directory names, with the same syntax as the shell
    variable PATH).'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PYTHONPATH*（一个目录名称的列表，其语法与shell变量PATH相同）。'
- en: The installation-dependent default (by convention including a site-packages
    directory, handled by the `site` module).
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装相关的默认值（按照惯例，包括一个由`site`模块管理的site-packages目录）。
- en: 'Going forward, we’ll use the first option and store your custom modules in
    your project’s directory. This will be the simplest and most straightforward approach
    for beginners and non-developers such as scientists and engineers. However, the
    module will be available only to scripts run from the project directory. To use
    the module in other projects, you’ll need to either copy the file to those directories
    or use one of the other options in the previous list. The easiest way is to add
    the path to the *PATH* variable, like so:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将使用第一个选项，将你的自定义模块存储在项目目录中。这对初学者和非开发者（如科学家和工程师）来说是最简单、最直接的方法。然而，这样模块只会对从项目目录中运行的脚本可用。要在其他项目中使用该模块，你需要将文件复制到那些目录中，或者使用前面列表中的其他选项。最简单的方法是将路径添加到*PATH*变量中，像这样：
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `mymath` module will contain functions for solving quadratic equations and
    for calculating the volume of a sphere. I’m going to save it in the *spyder_proj_w_env*
    project that we created in the “Creating a Project in an Existing Directory” on
    [page 70](ch04.xhtml#ch00lev2sec34). If you don’t want to use this project, feel
    free to create your own project folder using the instructions in [Chapter 4](ch04.xhtml).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`mymath`模块将包含解决二次方程和计算球体体积的函数。我将把它保存在我们在[第70页](ch04.xhtml#ch00lev2sec34)的“在现有目录中创建项目”中创建的*spyder_proj_w_env*项目中。如果你不想使用这个项目，随时可以按照[第4章](ch04.xhtml)中的说明创建自己的项目文件夹。'
- en: First, open the project by going to Spyder’s top toolbar and then clicking **Projects**
    ▸ **Open Project** ▸ **spyder_proj_w_env***.* You’ll want to see Spyder’s File
    Explorer, Text Editor, and IPython Console, such as it is presented in [Figure
    4-4](ch04.xhtml#ch04fig4).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过点击Spyder顶部工具栏中的**Projects** ▸ **Open Project** ▸ **spyder_proj_w_env***，打开项目。你将需要查看Spyder的文件浏览器、文本编辑器和IPython控制台，如[图4-4](ch04.xhtml#ch04fig4)所示。
- en: 'Now, in the text editor, enter the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在文本编辑器中输入以下代码：
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `quad()` function accepts the standard a, b, and c coefficients for the
    quadratic equation as arguments. It then calculates and returns both solutions
    to the equation. The `sphere_vol()` function accepts a radius as an argument and
    returns the volume of a sphere with that radius rounded to two decimal places.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '*The mymath module imports the built-in math module. This is fine, but be careful
    about writing and importing multiple modules that depend on one another. This
    results in circular dependencies that get messy and can cause an ImportError.*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Now, save the program as *mymath.py* in the *code* folder by clicking **File**
    ▸ **Save as** on the top toolbar. Alternatively, you could save it at the project
    folder level ([Figure 11-3](ch11.xhtml#ch011fig3)) and still access it from scripts
    in the *code* folder. Personally, I don’t like to clutter the project folder with
    individual files, hence the decision to place it in *code*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig03.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: The mymath.py module can be saved in either the code folder or
    the main project folder.*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re ever curious about what folder the Python interpreter is currently
    working in, import the operating system module (`os`) and use its `getcwd()` function
    to return the current working directory. Here’s an example in the console:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Because the current directory is the *code* folder, you don’t need to specify
    a path to import or otherwise access other files in this folder.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s test the module in the console:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you want to assign the results of the `quad()` function to a variable, remember
    that the quadratic equation has two solutions, so you’ll need to use two variables
    in the assignment statement:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That’s all there is to it! Now, any programs in the *code* folder can import
    and use the `mymath` module, just as they can use a built-in module.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '*If you try to import a module that’s already been imported, nothing will happen.
    So, if you change a module and want to reimport it, the best course of action
    is to restart the kernel and then import the module again. In fact, anytime Python
    is behaving strangely, you should consider restarting the kernel. As your IT support
    person likes to say, “Have you tried rebooting?”*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '***Naming Modules***'
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When naming modules, the best practice is to use lowercase characters and separate
    words with underscores. Names should preferably be one word only, as names with
    underscores can be confused for variable names. You’ll also want to avoid special
    symbols like the dot (.) and question mark (?). These symbols can cause problems
    due to the way Python looks for modules. A filename like *my.module.py*, for example,
    would indicate to Python that the *module.py* file should be found in a folder
    named *my*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing Modules That Work in Stand-Alone Mode***'
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *mymath.py* program you wrote in “Writing Your Own Modules” on [page 307](ch11.xhtml#ch00lev2sec161)
    just defines two functions. It works great as a module, but it’s not very usable
    on its own, because there’s no call to the functions. So, let’s turn *mymath.py*
    into a program that will run in stand-alone mode *and* work as a module.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: In Spyder, open *mymath.py* in the text editor and make a copy of it using **File**
    ▸ **Save as** from the top toolbar. Name the new file *mymath2.py*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the code blocks at ➊ and ➋ to define and call a `main()` function:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: At ➊, you define a `main()` function to run the program, assigning variables
    to serve as arguments to the module’s functions, calling the two functions, and
    printing the results.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: For Python to evaluate whether a program is being run in stand-alone mode or
    as an imported module, it’s necessary for you to use the special built-in `__name__`
    variable ➋. If you run the program directly, `__name__` is set to `__main__`,
    and the `main()` function is called. If the program is imported, `__name__` is
    set to the module’s filename, `main()` is not invoked, and the program won’t execute
    until you call one of its functions, like `quad()` or `sphere_vol()`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the program and run it using F5 or the “play” icon on the Run toolbar.
    You should see the following output in the console:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The program ran as if you had simply called `main()` as the last line.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '***Built-in Modules***'
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Python comes with multiple built-in modules. Covering all these is beyond the
    scope of this book, but [Table 11-2](ch11.xhtml#ch011tab2) lists some commonly
    used ones, along with a brief description of each. You’ve already worked with
    several of these, including `math`, `random`, `logging`, and `inspect`. We’ll
    look at some of the other ones in chapters to come.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-2:** Frequently Used Built-in Python Modules'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module** | **Description** |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| `os` | Operating system tasks like directory and file creation, deletion,
    identifying the current directory, and more. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| `sys` | System operation and runtime environment tasks like exiting programs,
    getting paths, command line use, and more. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| `shutil` | Shell utilities for high-level file operations like copying, moving,
    deleting directory trees, and more. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| `inspect` | Functions to get information about live objects such as modules,
    classes, methods, functions, tracebacks, frame objects, and code objects. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| `logging` | A flexible event logging system for monitoring a program’s flow
    of execution. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| `math` | Basic mathematical operations and constants. |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| `random` | Implements pseudo-random number generators for various distributions.
    |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| `statistics` | Functions for calculating mathematical statistics like mean,
    geometric mean, median, mode, covariance, and more. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| `collections` | Provides specialized container datatypes providing alternatives
    to Python’s general purpose built-in containers like dictionaries, lists, sets,
    and tuples. Useful tools include namedtuple(), deque, defaultdict, and Counter.
    |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| `itertools` | Creates iterators for efficient looping. Includes fast functions
    for zipping, computing cartesian products, generating permutations and combinations,
    cycling, and more. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| `datetime` | Supplies tools for getting and manipulating dates and times.
    |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| `re` | Tools for working with regular expressions, that specify a set of
    matching strings. Used for searching and parsing text data. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| `http` | Collects several modules for working with the HyperText Transfer
    Protocol |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| `json` | Methods for working with JSON-formatted data. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| `threading` | Used for creating, controlling, and managing threads (smallest
    sequence of programmed instructions) that allow different parts of a program to
    run concurrently for speed and simplicity. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| `multiprocessing` | Permits efficient use of multiple processors on a given
    machine. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: It’s a good idea to be aware of built-in modules so that you don’t find yourself
    reinventing the wheel and duplicating modules that already exist. You can find
    the official documentation at *[https://docs.python.org/3/tutorial/modules.html](https://docs.python.org/3/tutorial/modules.html)*.
    But don’t think you need to memorize the modules or their contents. A simple online
    search for a particular task will generally return information on modules as well
    as actual code samples for accomplishing the task.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 11.  Write a function that calculates the force of gravity using the equation
    *F* = (*G* * mass1 * mass2) / radius², where *G* is the gravitational constant
    (6.67 × 10-11 N-m²/kg²). Treat *G* as a *global* constant.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 12.  Import the `math` module and list all the functions it contains.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '13.  The preferred way to import *all* the functions available in a module
    is to use:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: a.  `from` module `import *`
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: b.  `import` module
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: c.  `import` module `as *`
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: d.  `from` module `import` func1`,` func2`,` func3`...`
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '14.  When you import a module, Python first searches for:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: a.  a module with that name in the current working directory
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: b.  a module with that name in *PYTHONPATH*
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: c.  a module with that name in the site-packages directory
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: d.  a built-in module with that name
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 15.  Write a function that accepts a variable in the global scope as an argument.
    Then, rewrite the function to use the same variable as a global variable.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions are callable collections of code that let you organize your program
    into modular, logical groups. If you find yourself repeating code, you should
    stop and write a function.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Recursion means to “run back,” and recursive functions call themselves over
    and over. Recursive functions are used to solve complex problems that can be broken
    down into smaller problems of the same type and would be difficult to implement
    using a loop.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Lambda functions are one-off, unnamed functions consisting of single statements.
    For simple tasks, they save you the effort of defining a complete named function.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数是一次性使用的、没有名称的函数，由单个语句组成。对于简单的任务，它们可以节省你定义完整命名函数的精力。
- en: A generator is a function that returns an object that can be iterated over a
    single time. Rather than compute all of its values at once, a generator waits
    to be asked and then *yields* its values one at a time. As a result, a generator
    has a low memory footprint, making them useful for large data sets that you need
    to use only once.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一个返回可以单次迭代的对象的函数。生成器不会一次性计算所有的值，而是等待被请求，然后逐个*生成*值。因此，生成器具有低内存占用，非常适用于只需使用一次的大数据集。
- en: A module is a Python file containing a collection of related functions. Modules
    must be imported into other Python files to be used. Modules let you take advantage
    of the expertise and efforts of others while keeping your code clean and uncluttered.
    You can also write customized modules for your own projects.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是一个包含相关函数集合的 Python 文件。模块必须被导入到其他 Python 文件中才能使用。模块使你能够利用他人的专长和努力，同时保持代码简洁清晰。你还可以为自己的项目编写自定义模块。
