<html><head></head><body>
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_105" title="105"/>6</span><br/><span class="ChapterTitle">Motion and Transformation</span></h1>
			</header>
			<figure class="opener">
				<img alt="" src="image_fi/book_art/chapterart.png"/>
			</figure>
			<p class="ChapterIntro">Applying movement to graphics of both living and inanimate objects instills them with character. Bouncy animation suggests playfulness; precise movement implies intensity, while slow motion can suggest heaviness. These techniques are applied in film, animation, dance choreography, and, of course, your favorite Pixar flick. But that’s not all. Motion is prevalent in interface design, such as subtle button-hover effects or elaborate spinning graphics that appear while your content is loading.</p>
			<p>
				In this chapter, you’ll make things move by coding with motion and transformation functions. You’ll learn how to manipulate the coordinate system with transformation functions, making it simpler to move, rotate, and scale your elements. In addition, you’ll learn how to structure an animated Processing sketch by using the <code>setup()</code> and <code>draw()</code> functions. Motion literally adds a new dimension—time—to your Processing sketches.</p>
			<h2 id="h1-500969c06-0001"><span epub:type="pagebreak" id="Page_106" title="106"/>Perceiving Motion</h2>
			<p class="BodyFirst">First, consider how motion is perceived. The brain is fed a snapshot from your retina many times each second. Provided that their screen can display a sequence of static images at a rate exceeding roughly 10 to 12 frames per second, the viewer will experience the illusion of smooth, flowing movement. Higher frame rates will appear even smoother.</p>
			<p>
				Take a moment to note the two circles in <a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a>.</p>
			<figure>
				<img alt="f06001" src="image_fi/500969c06/f06001.png"/>
				<figcaption>
					<p><a id="figure6-1">Figure 6-1</a>: Two circles (positioned left and right)</p>
				</figcaption>
			</figure>
			<p>
				If you displayed only the left circle for four seconds, followed by only the right circle for another four seconds, looping the sequence indefinitely (<a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a>), this would be an effective frame rate of 0.25 frames per second (or 0.25 <em>fps</em>). The result, most observers would agree, is a pair of alternating images depicting circles in two different positions.</p>
			<figure>
				<img alt="f06002" src="image_fi/500969c06/f06002.png"/>
				<figcaption>
					<p><a id="figure6-2">Figure 6-2</a>: Displaying alternating circles</p>
				</figcaption>
			</figure>
			<p>
				However, speed up the frame rate to around 2.5 fps (10 times faster), and the observer will begin to interpret the sequence as a single circle bouncing between two points—as if the circle were moving across the gap in the middle. The illusion is referred to as <em>beta movement</em>. Increase the frame rate further, and the two circles will appear to flicker in sync with one another. From this experiment, you can see how frame rate doesn’t affect only how fast or slow something moves, but also how you perceive the object’s motion.</p>
			<p>
				Note the numbering of the circles shown in <a href="#figure6-3" id="figureanchor6-3">Figure 6-3</a>.</p>
			<p>
				Now, suppose you want to animate this. Using the numbering to dictate the order, remove a single circle on each frame. On the first frame, remove just the circle labeled 0. On the second frame, replace circle 0 and remove only circle 1. Continue this process around the ring, and loop the animation indefinitely. Removing successive circles from each frame results in a gap that moves around the ring in a clockwise progression (<a href="#figure6-4" id="figureanchor6-4">Figure 6-4</a>).</p>
				<span epub:type="pagebreak" id="Page_107" title="107"/>
				<figure>
				<img alt="f06003" src="image_fi/500969c06/f06003.png"/>
				<figcaption>
					<p><a id="figure6-3">Figure 6-3</a>: A ring of circles numbered in a clockwise sequence</p>
				</figcaption>
			</figure>
			<figure>
				<img alt="f06004" src="image_fi/500969c06/f06004.png"/>
				<figcaption>
					<p><a id="figure6-4">Figure 6-4</a>: Animating the ring of circles</p>
				</figcaption>
			</figure>
			<p>
				If you run the animation at 1 fps, the circle just ahead of a gap appears to jump into the void left by the vacant circle (<a href="#figure6-5" id="figureanchor6-5">Figure 6-5</a>).</p>
			<figure>
				<img alt="f06005" src="image_fi/500969c06/f06005.png"/>
				<figcaption>
					<p><a id="figure6-5">Figure 6-5</a>: At 1 fps, the next circle seems to leap into the gap.</p>
				</figcaption>
			</figure>
			<p>
				At 25 fps, however, a rapidly moving phantom white dot seems to obscure the circles beneath it as it races around the ring—an illusion called the <em>phi phenomenon</em> (<a href="#figure6-6" id="figureanchor6-6">Figure 6-6</a>).</p>
			<p>Now you’re ready to build a Processing sketch that, in addition to introducing Processing’s animation functions, will allow you to experiment with these phenomena.</p>
			<span epub:type="pagebreak" id="Page_108" title="108"/>
			<figure>
				<img alt="f06006" src="image_fi/500969c06/f06006.png"/>
				<figcaption>
					<p><a id="figure6-6">Figure 6-6</a>: At 25 fps, a phantom white dot seems to obscure the circles.</p>
				</figcaption>
			</figure>
			<h2 id="h1-500969c06-0002">Adding Motion to Processing Sketches</h2>
			<p class="BodyFirst">Processing gives you the option to draw to the display window a single time or multiple times over. For animation, you use the latter approach. To make an object move, you adjust its position with each frame drawn—and if you do it rapidly enough, in small enough increments, the result is smooth, flowing motion.</p>
			<h3 id="h2-500969c06-0001">The draw() and setup() Functions</h3>
			<p class="BodyFirst">To make Processing draw something multiple times, you’ll need to structure your code by using the <code>setup()</code> and <code>draw()</code> functions. Beneath those two functions, you can nest any of the functions or statements covered in the book so far. As indicated in <a href="#figure6-7" id="figureanchor6-7">Figure 6-7</a>, where you place your code depends on when you want it to execute.</p>
			<figure>
				<img alt="f06007" src="image_fi/500969c06/f06007.png"/>
				<figcaption>
					<p><a id="figure6-7">Figure 6-7</a>: Structuring code for motion</p>
				</figcaption>
			</figure>
			<p>
				Any <code>def</code> keyword is followed by a function name, parentheses, and a colon. <span class="xref">Chapter 9</span> covers <code>def</code> in more detail, but for now, just be aware that any code indented beneath a <code>def</code> belongs to that respective function.</p>
			<p>
				The <code>setup()</code> code runs once at startup, and it typically includes things like your <code>size()</code> function and other lines that define your environmental properties. I’ll get to <code>draw()</code> in more detail shortly, but first, create a new sketch, save it as <em>perceiving_motion</em>, and then add the following code:</p>
			<pre><code><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">setup</span>(): <span class="ProcessingBlue">size</span>(500, 500) <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#004477'</span>) <span class="ProcessingBlue">noFill</span>() <span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FFFFFF'</span>) <span class="ProcessingBlue">strokeWeight</span>(3)</code></pre>
			<p><span epub:type="pagebreak" id="Page_109" title="109"/>This code resembles just about every other sketch you’ve set up so far, except for the <code>def setup()</code> line. Whenever you intend to use a <code>draw()</code> function, you have to use <code>setup()</code> too. Now add the <code>draw()</code> function:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>(): <span class="ProcessingBlue">print</span>(<span class="ProcessingRaspberry">frameCount</span>)</code></pre>
			<p>
				Processing invokes the code indented beneath the <code>draw()</code> function with each new frame. The <code>frameCount</code> is a system variable containing the number of frames displayed since starting the sketch. With each new frame, the <code>draw()</code> function calls the <code>print()</code> function, which in turn displays the current frame count in the console.</p>
			<p>
				By default, <code>draw()</code> executes at approximately 60 fps. However, as the complexity of an animation increases, the frame rate is likely to drop as your computer struggles to accommodate the demands placed on it. Adjust the frame rate by using the <code>frameRate()</code> function (within the <code>setup()</code> block), and add a condition to <code>draw()</code> to print on even-numbered frames only:</p>
			<pre><code><span class="LiteralGray">def setup():</span> <span class="LiteralGray">. . .</span><span class="ProcessingBlue">    frameRate</span>(2.5)<span class="LiteralGray">def draw():</span><span class="ProcessingGray">    </span><span class="ProcessingOlive">if</span><span class="ProcessingGray"> </span><span class="ProcessingRaspberry">frameCount</span> % 2 == 0: <span class="LiteralGray">print(frameCount)</span></code></pre>
			<p>
				With the <code>frameRate</code> set to <code>2.5</code>, the draw line runs two and a half times every second; this means that each frame is 400 milliseconds (0.4 of a second) in duration. Because the <code>print</code> line executes on every second frame, a new line appears in the console every 800 milliseconds (<a href="#figure6-8" id="figureanchor6-8">Figure 6-8</a>).</p>
			<figure>
				<img alt="f06008" src="image_fi/500969c06/f06008.png"/>
				<figcaption>
					<p><a id="figure6-8">Figure 6-8</a>: Printing the frame count on every even-numbered frame</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_110" title="110"/>To draw a circle on every even frame instead, use the following <code>circle()</code> line:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    if frameCount % 2 == 0:</span> <span class="ProcessingBlue">circle</span>(420, 250, 80)</code></pre>
			<p>
				Now run the sketch. You may be surprised to find that the circle does not flash on and off (<a href="#figure6-9" id="figureanchor6-9">Figure 6-9</a>).</p>
			<figure>
				<img alt="f06009" src="image_fi/500969c06/f06009.png"/>
				<figcaption>
					<p><a id="figure6-9">Figure 6-9</a>: The circle does not “blink.”</p>
				</figcaption>
			</figure>
			<p>
				The reason the circle does not disappear on odd frames is that everything in Processing persists after it’s drawn. On every even frame, the program draws another circle atop the existing “pile.” The <code>background()</code> color within the <code>setup()</code> function runs once at the start, filling the display window in blue to form the bottommost layer of this persistent arrangement. To “wipe” each frame before drawing the next, you can redraw a background over everything.</p>
			<p>
				Copy the <code>background('#004477')</code> line into the <code>draw()</code> section of your sketch:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span> <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#004477'</span>) <span class="LiteralGray">if frameCount % 2 == 0:</span><span class="LiteralGray">        circle(420, 250, 80)</span></code></pre>
			<p>
				The new <code>background()</code> line clears every frame before it. Be sure you have placed it above the <code>if</code> statement. In most instances, a <code>background()</code> function will sit somewhere near the top of <code>draw()</code> to avoid clearing other shapes in the current frame.</p>
			<p>Test the code. The result should be a blinking circle.</p>
			<p><span epub:type="pagebreak" id="Page_111" title="111"/>To recreate the ring of circles experiment from earlier (<a href="#figure6-3">Figure 6-3</a>), replace the existing <code>if</code> statement with a series of <code>if</code> statements:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    background('#004477')</span> hide = <span class="ProcessingRaspberry">frameCount</span> % 8<span aria-label="annotation1" class="CodeAnnotation">1</span> <span class="ProcessingOlive">if</span> hide != 0: <span class="ProcessingBlue">circle</span>(250, 80, 80) <span class="ProcessingOlive">if</span> hide != 1: <span class="ProcessingBlue">circle</span>(370, 130, 80) <span class="ProcessingOlive">if</span> hide != 2: <span class="ProcessingBlue">circle</span>(420, 250, 80) <span class="ProcessingOlive">if</span> hide != 3: <span class="ProcessingBlue">circle</span>(370, 370, 80) <span class="ProcessingOlive">if</span> hide != 4: <span class="ProcessingBlue">circle</span>(250, 420, 80) <span class="ProcessingOlive">if</span> hide != 5: <span class="ProcessingBlue">circle</span>(130, 370, 80) <span class="ProcessingOlive">if</span> hide != 6: <span class="ProcessingBlue">circle</span>(80, 250, 80) <span class="ProcessingOlive">if</span> hide != 7: <span class="ProcessingBlue">circle</span>(130, 130, 80)</code></pre>
			<p>
				The current frame count is divided by <code>8</code> <span aria-label="annotation1" class="CodeAnnotation">1</span><span class="Wingdings">, </span>and the remainder is assigned to the <code>hide</code> variable. Each <code>if</code> statement will draw a separate circle provided it hasn’t been flagged as the one to hide. For instance, on the 16th frame, <code>hide</code> is equal to <code>0</code> because 16 divides evenly by 8. On the 15th frame, <code>hide</code> is equal to <code>7</code> because 15 divided by 8 leaves a remainder of 7. On the 17th frame, <code>hide</code> is equal to <code>1</code>. The result is a stream of numbers that counts from 0 up to 7, then restarts at 0.</p>
			<p>Run the sketch. Focus on the gap as it moves around the circle. At the current frame rate of 2.5 fps, the circle just ahead of a gap appears to jump into the void left by the vacant circle. But adjust the frame rate to 25 fps, and a phantom background-colored dot appears to obscure the circles beneath it as it races around the ring.</p>
			<h3 id="h2-500969c06-0002">Global Variables</h3>
			<p class="BodyFirst">A <em>global variable</em> is one that you can access anywhere within your program. Up until this point in the book, almost every variable you have defined has been a global variable. You’ll need to understand more about global variables to manage data across multiple frames.</p>
			<p>
				Global variables are declared outside any function definitions (indented blocks beginning with <code>def</code>), usually somewhere near the top of your code. For instance, any variables that you declare outside <code>setup()</code> and <code>draw()</code> are automatically global. Conversely, any variables declared inside the indented lines of those two functions are accessible within that function alone.</p>
			<p><span epub:type="pagebreak" id="Page_112" title="112"/>As an example of this behavior in action, create a new sketch and save it as <em>global_variables</em>. Add the following code:</p>
			<pre><code><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">setup</span>(): <span aria-label="annotation1" class="CodeAnnotation">1</span> y = 1<span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>(): <span aria-label="annotation2" class="CodeAnnotation">2</span> <span class="ProcessingBlue">print</span><span class="LiteralGray">(y)</span></code></pre>
			<p>
				The <code>y</code> variable <span aria-label="annotation1" class="CodeAnnotation">1</span> is declared within the <code>setup()</code> function. As such, <code>y</code> is accessible only within the indented lines of the <code>setup()</code> block. The <code>y</code> variable’s scope, therefore, is considered to be <em>local</em> to <code>setup()</code>. <em>Scope</em>, in programming, deals with the regions where a variable (or other entity) may be accessed. In this instance, running the sketch produces an error (<a href="#figure6-10" id="figureanchor6-10">Figure 6-10</a>), because you have attempted to access and print variable <code>y</code> from within the <code>draw()</code> function <span aria-label="annotation2" class="CodeAnnotation">2</span>.</p>
			<figure>
				<img alt="f06010" src="image_fi/500969c06/f06010.png"/>
				<figcaption>
					<p><a id="figure6-10">Figure 6-10</a>: The <span class="LiteralInCaption"><code>draw()</code></span> function cannot access the <span class="LiteralInCaption"><code>y</code></span> variable declared in <span class="LiteralInCaption"><code>setup()</code></span>.</p>
				</figcaption>
			</figure>
			<p>
				Alternatively, you can move the <code>y = 1</code> line outside the <code>setup()</code> function, which places it in the global scope; this permits either function to read it. Move this line to the top of your code and insert a <code>pass</code> statement in place of the location you moved it from:</p>
			<pre><code>y = 1<span class="LiteralGray">def setup():</span> <span class="ProcessingOlive">pass</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    print(y)</span></code></pre>
			<p>
				The <code>draw()</code> function has no problems accessing <code>y</code> now that it’s declared outside <code>setup()</code>. The <code>pass</code> statement is a <em>null operation</em>—that is, nothing happens when it executes. You need to include a <code>pass</code> line because Python does not allow empty function definitions. This makes <code>pass</code> a useful placeholder for any code you have yet to write. Upon running the sketch, the console should print endless lines of <code>1</code>s.</p>
			<p><span epub:type="pagebreak" id="Page_113" title="113"/>You can override the global <code>y</code> variable on a local level with another variable of the same name—in this case, another variable named <code>y</code>. Make the following adjustments to your code:</p>
			<pre><code><span class="LiteralGray">y = 1</span><span class="LiteralGray">def setup():</span> <span aria-label="annotation1" class="CodeAnnotation">1</span> y = 0 <span aria-label="annotation2" class="CodeAnnotation">2</span> <span class="ProcessingBlue">print</span>(y)<span class="LiteralGray">def draw():</span> <span aria-label="annotation3" class="CodeAnnotation">3</span> <span class="LiteralGray">print(y)</span></code></pre>
			<p>
				The <code>setup()</code> function runs first—just once—and its <code>print</code> line <span aria-label="annotation2" class="CodeAnnotation">2</span> displays a <code>0</code>. This is because within the <code>setup()</code> function, you define the <code>y</code> as a <code>0</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>. The outer (global) <code>y</code> is still equal to 1, and it’s said to be <em>shadowed</em> by the <code>setup()</code>’s inner (local) <code>y</code> variable. The <code>draw()</code> code executes after the <code>setup()</code> code, and with every new frame, prints <span aria-label="annotation3" class="CodeAnnotation">3</span> a <code>1</code> to the console. Run the sketch, quickly stop it, and then scroll up through the console output. The first line displayed is a <code>0</code>; from there down, it’s all <code>1</code>s (<a href="#figure6-11" id="figureanchor6-11">Figure 6-11</a>).</p>
			<figure>
				<img alt="f06011" src="image_fi/500969c06/f06011.png"/>
				<figcaption>
					<p><a id="figure6-11">Figure 6-11</a>: The global <span class="LiteralInCaption"><code>y</code></span> variable is shadowed by the <span class="LiteralInCaption"><code>y = 0</code></span>.</p>
				</figcaption>
			</figure>
			<p>
				Next, remove the <code>y = 0</code> line and add code that attempts to increment the global <code>y</code> variable by <code>1</code> with each frame:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span> y += 1 <span class="LiteralGray">print(y)</span></code></pre>
			<p>
				While you can read (or shadow) any global variable, writing or reassigning values requires additional code. As a result, this code should cause Processing to display an error (<a href="#figure6-12" id="figureanchor6-12">Figure 6-12</a>).</p>
				<span epub:type="pagebreak" id="Page_114" title="114"/>
				<figure>
				<img alt="f06012" src="image_fi/500969c06/f06012.png"/>
				<figcaption>
					<p><a id="figure6-12">Figure 6-12</a>: The <span class="LiteralInCaption"><code>draw()</code></span> function cannot reassign a value to <span class="LiteralInCaption"><code>y</code></span>.</p>
				</figcaption>
			</figure>
			<p>
				This is where the <code>global</code> statement is useful. Edit your code, inserting a <code>global y</code> line at the top of the <code>draw()</code> block:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span> <span class="ProcessingTealGreen">global</span> y <span class="LiteralGray">y += 1</span><span class="LiteralGray">    print(y)</span></code></pre>
			<p>
				The global <code>y</code> variable is now bound to the local scope of <code>draw()</code>, and you may modify it as you wish. Run the sketch. The global <code>y</code> variable should now increment by 1 with each new frame (<a href="#figure6-13" id="figureanchor6-13">Figure 6-13</a>).</p>
			<figure>
				<img alt="f06013" src="image_fi/500969c06/f06013.png"/>
				<figcaption>
					<p><a id="figure6-13">Figure 6-13</a>: The global <span class="LiteralInCaption"><code>y</code></span> variable is incremented by 1 with each new frame.</p>
				</figcaption>
			</figure>
			<p>
				Global variables allow you to keep track of and update values between frames easily, which is especially useful for animating objects. Add a moving circle, the y-coordinate of which is controlled by the <code>y</code> variable:</p>
			<pre><code><span class="LiteralGray">y = 1</span><span class="LiteralGray">def setup():</span><span class="LiteralGray">    print(y)</span> <span class="ProcessingBlue">size</span>(500, 500)<span epub:type="pagebreak" id="Page_115" title="115"/><span class="ProcessingBlue">    noFill</span>() <span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FFFFFF'</span>) <span class="ProcessingBlue">strokeWeight</span>(3)<span class="LiteralGray">def draw():</span><span class="LiteralGray">    . . .</span> <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#004477'</span>) <span class="ProcessingBlue">circle</span>(<span class="ProcessingRaspberry">height</span>/2, y, 50)</code></pre>
			<p>
				I’ve placed the size, fill, and stroke properties in the <code>setup()</code> section of the code. Given that the stroke and fill are unchanged throughout the animation, there’s no need to apply those properties repeatedly in <code>draw()</code>. The circle’s y-coordinate, represented by variable <code>y</code>, moves the circle down as the frames advance. In <a href="#figure6-14" id="figureanchor6-14">Figure 6-14</a>, a motion trail has been added to convey the direction of motion.</p>
			<figure>
				<img alt="f06014" src="image_fi/500969c06/f06014.png"/>
				<figcaption>
					<p><a id="figure6-14">Figure 6-14</a>: The circle moves down from the top of the display window.</p>
				</figcaption>
			</figure>
			<p>When the circle reaches the bottom of the display window, it continues out of sight beyond the lower edge.</p>
			<h3 id="h2-500969c06-0003">Saving Frames</h3>
			<p class="BodyFirst">Processing provides the <code>saveFrame()</code> function to save frames as image files. Whenever your sketch calls a <code>saveFrame()</code>, it saves a <em>Tagged Image File Format,</em> or TIFF, image in the sketch folder. You’ll want to place this call at the end of your <code>draw()</code> function to ensure that you capture every shape rendered on the current frame. For instance, say you add the following code to a <code>draw()</code> function:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>():<span class="LiteralGray">    . . .</span><span class="ProcessingOlive">    if</span> <span class="ProcessingRaspberry">frameCount</span> % 100 == 0: <span class="ProcessingBlue">saveFrame</span>() <span class="ProcessingBlue">square</span>(10, 10, 100)</code></pre>
			<p><span epub:type="pagebreak" id="Page_116" title="116"/>As the animation encounters every 100th frame, a new image file appears in your sketch folder. This image file is named <em>screen-</em> followed by a four-digit frame count; where necessary, this frame count is padded with leading zeros, as shown in <a href="#figure6-15" id="figureanchor6-15">Figure 6-15</a>. Because <code>saveFrame()</code> precedes the <code>square()</code> line, the square appears in every frame of the animation, but never in the saved image files.</p>
			<figure>
				<img alt="f06015" src="image_fi/500969c06/f06015.png"/>
				<figcaption>
					<p><a id="figure6-15">Figure 6-15</a>: The <span class="LiteralInCaption"><code>saveFrame</code></span><span class="LiteralInCaption"><code>()</code></span> function generates an image file named using the frame count.</p>
				</figcaption>
			</figure>
			<p>If you want to save the file in an image format other than TIFF, such as JPG, PNG, or TARGA, include a filename argument with the relevant extension:</p>
			<pre><code><span class="LiteralGray">    . . .</span><span class="ProcessingBlue">        saveFrame</span>(<span class="ProcessingPurple">'frame.png'</span>)</code></pre>
			<p>
				In this case, you’d use the same filename for every image saved, which is okay for capturing a single frame, but will lead to overwriting when you call the same <code>saveFrame()</code> function multiple times. However, you can include a series of hash marks to make the frame count appear in the filename. This code generates a uniquely named PNG file with every save:</p>
			<pre><code><span class="LiteralGray">    . . .</span><span class="ProcessingBlue">        saveFrame</span>(<span class="ProcessingPurple">'frame-####.png'</span>)</code></pre>
			<p>Processing replaces the hash marks with the frame count and, if necessary, pads the count with leading zeros.</p>
			<h4 class="HeadProject"><span>Challenge #5: DVD Screensaver</span></h4>
			<p class="BodyFirst">In this task, you’ll combine <code>setup()</code>, <code>draw()</code>, global variables, and <code>if</code> statements to animate an object that bounces off the edges of the display window.</p>
			<p>
				DVD players commonly feature a bouncing DVD logo as a screensaver (<a href="#figure6-16" id="figureanchor6-16">Figure 6-16</a>), which appears after a given period of inactivity. You may have seen a variation of this on other devices, albeit with a different graphic. Intriguingly, people often find themselves staring at the pointless animation in the hope of witnessing the logo land perfectly in the corner of the screen.</p>
				<span epub:type="pagebreak" id="Page_117" title="117"/>
				<figure>
				<img alt="f06016" src="image_fi/500969c06/f06016.png"/>
				<figcaption>
					<p><a id="figure6-16">Figure 6-16</a>: The logo bounces off edges of the screen.</p>
				</figcaption>
			</figure>
			<p>
				Create a new sketch and save it as <em>dvd_screensaver</em>. Add the following code:</p>
			<pre><code>y = 100
yspeed = 2<span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">setup</span>(): <span class="ProcessingBlue">size</span>(800, 600) <span class="ProcessingBlue">fill</span>(<span class="ProcessingPurple">'#0099FF'</span>) <span class="ProcessingBlue">textSize</span>(50)<span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>(): <span aria-label="annotation1" class="CodeAnnotation">1</span> <span class="ProcessingTealGreen">global</span> <span class="LiteralGray">y, yspeed</span> <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#000000'</span>) <span aria-label="annotation2" class="CodeAnnotation">2</span> <span class="LiteralGray">y += yspeed</span> <span class="ProcessingBlue">text</span>(<span class="ProcessingPurple">'DVD'</span>, 100, y<span aria-label="annotation3" class="CodeAnnotation">3</span>)</code></pre>
			<p>
				The code is similar to that of the previous example using the circle (<a href="#figure6-14">Figure 6-14</a>). In this instance, you include a <code>yspeed</code> variable. To use a single <code>global</code> statement for multiple variables, comma-separate them <span aria-label="annotation1" class="CodeAnnotation">1</span>. With each new frame, the program adds <code>yspeed</code> to the <code>y</code> variable <span aria-label="annotation2" class="CodeAnnotation">2</span>, which serves as the y-coordinate for the DVD text <span aria-label="annotation3" class="CodeAnnotation">3</span>. Upon running the sketch, the logo should move directly down (<a href="#figure6-17" id="figureanchor6-17">Figure 6-17</a>), soon passing beyond the bottom edge of the display window.</p>
			<figure>
				<img alt="f06017" src="image_fi/500969c06/f06017.png"/>
				<figcaption>
					<p><a id="figure6-17">Figure 6-17</a>: The DVD text moves downward.</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_118" title="118"/>To make the logo rebound off the bottom edge of the display window, add the following <code>if</code> statement:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    . . .</span> <span class="ProcessingOlive">if</span> y &gt; <span class="ProcessingRaspberry">height</span>: yspeed *= -1</code></pre>
			<p>
				When the <code>y</code> variable exceeds the <code>height</code> of the display window, the <code>yspeed</code> is multiplied by <code>-1</code>, sending the logo in the opposite direction. Run the sketch; the logo should rebound as it hits the bottom edge.</p>
			<p>
				To move the logo diagonally, add some <code>x</code> values:</p>
			<pre><code><span class="LiteralGray">. . .</span>
x = 100
xspeed = 2<span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span> <span class="LiteralGray">global y, yspeed,</span> <b>x, xspeed</b> <span class="LiteralGray">background('#000000')</span> <span class="LiteralGray">y += yspeed</span> x += xspeed <span class="LiteralGray">text('DVD',</span> <b>x</b><span class="LiteralGray">, y)</span><span class="LiteralGray">    . . .</span></code></pre>
			<p>
				Here, you’ve replicated everything you did with the <code>y</code> and <code>yspeed</code> variables for the <code>text()</code> function’s <code>x</code> argument. The logo should now move vertically and horizontally. Run the sketch (<a href="#figure6-18" id="figureanchor6-18">Figure 6-18</a>).</p>
			<figure>
				<img alt="f06018" src="image_fi/500969c06/f06018.png"/>
				<figcaption>
					<p><a id="figure6-18">Figure 6-18</a>: The diagonally moving DVD text rebounds near the lower-right corner.</p>
				</figcaption>
			</figure>
			<p>
				When the logo rebounds off the bottom edge, the <code>yspeed</code> is inverted, but not the <code>xspeed</code>. This is the behavior you seek, but then the logo passes <span epub:type="pagebreak" id="Page_119" title="119"/>through the right edge. Instead, the logo must rebound off every edge it encounters. Your challenge is to complete the task. If you need help, you can access the solution at <a class="LinkURL" href="https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/dvd_screensaver/">https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/dvd_screensaver/</a>.</p>
			<h2 id="h1-500969c06-0003">Transformations</h2>
			<p class="BodyFirst">Processing’s <em>transformation functions</em> provide convenient ways to manipulate elements by using translate, rotate, scale, and shear operations (<a href="#figure6-19" id="figureanchor6-19">Figure 6-19</a>). You may apply transformations to individual shapes, groups of elements, or the entire drawing space.</p>
			<figure>
				<img alt="f06019" src="image_fi/500969c06/f06019.png"/>
				<figcaption>
					<p><a id="figure6-19">Figure 6-19</a>: From left to right: translation, rotation, scaling, and shear transformations</p>
				</figcaption>
			</figure>
			<p>
				Suppose you want to rotate a star shape (as shown in <a href="#figure6-20" id="figureanchor6-20">Figure 6-20</a>) in a clockwise direction. This star is composed of vertices using a series of <code>vertex()</code> functions; an x-y coordinate pair defines the position of each vertex.</p>
			<figure>
				<img alt="f06020" src="image_fi/500969c06/f06020.png"/>
				<figcaption>
					<p><a id="figure6-20">Figure 6-20</a>: Rotating a star shape</p>
				</figcaption>
			</figure>
			<p>
				Calculating the new positions of each vertex requires a <em>matrix</em>. You can think of a matrix as a table of numbers. For different transformations, you can add, subtract, or multiply each x-y coordinate pair with a <em>transformation matrix</em>. In the case of the star rotation, the matrix operation would look something like <a href="#figure6-21" id="figureanchor6-21">Figure 6-21</a>. The <em>x</em> and <em>y</em> values in the square brackets labeled <em>vertex</em> represent the coordinate pair for a given vertex; this is multiplied by the <em>transformation matrix</em> to calculate a new rotated vertex position. The equation in the <em>result</em> brackets reveals the workings of the matrix math.</p>
				<span epub:type="pagebreak" id="Page_120" title="120"/>
				<figure>
				<img alt="f06021" src="image_fi/500969c06/f06021.png"/>
				<figcaption>
					<p><a id="figure6-21">Figure 6-21</a>: A transformation matrix for rotation</p>
				</figcaption>
			</figure>
			<p>If matrix math looks a little confusing, don’t worry; Processing quietly handles all of it for you.</p>
			<p>
				In the next section, you’ll learn about the <code>translate()</code>, <code>rotate()</code>, <code>scale()</code>, <code>shearX()</code>, and <code>shearY()</code> functions. You’ll also see how to use the <code>pushMatrix()</code> and <code>popMatrix()</code> functions for applying transformations to selected groups of elements.</p>
			<h3 id="h2-500969c06-0004">Processing Transformation Functions</h3>
			<p class="BodyFirst">Create a new sketch and save it as <em>transformation_functions</em>. Within the sketch’s folder, create a <em>data</em> subfolder and then follow these steps:</p>
			<ol class="decimal">
				<li value="1">Open your web browser and go to <a class="LinkURL" href="https://github.com/tabreturn/processing.py-book/">https://github.com/tabreturn/processing.py-book/</a>.</li>
				<li value="2">Navigate to <em>chapter-06-motion_and_transformation</em>.</li>
				<li value="3">Download the <em>grid.png</em> and <em>grid-overlay.png</em> files.</li>
				<li value="4">Place both files in your <em>data</em> subfolder.</li>
			</ol>
			<p>Add the following setup code:</p>
			<pre><code><span class="ProcessingBlue">size</span>(800, 800)<span class="ProcessingBlue">noFill</span>()<span class="ProcessingBlue">noStroke</span>()
grid = <span class="ProcessingBlue">loadImage</span>(<span class="ProcessingPurple">'grid.png'</span>)<span class="ProcessingBlue">image</span>(grid, 0, 0)
grido = <span class="ProcessingBlue">loadImage</span>(<span class="ProcessingPurple">'grid-overlay.png'</span>)</code></pre>
			<p>
				The <code>grid</code> variable and <code>image()</code> lines load and display the <em>grid.png</em> graphic. The <em>grid-overlay.png </em>file is loaded into the variable <code>grido</code>, but it’s not rendered in the display window yet; you’ll display it later in this task.</p>
			<h3 id="h2-500969c06-0005">translate()</h3>
			<p class="BodyFirst">The <code>translate()</code> function accepts two arguments: an x-offset and y-offset. Ordinarily, an x-y coordinate of (0, 0) marks the upper left corner of the display window. This point is called the <em>origin</em>. Using <code>translate()</code>, you can reposition the coordinate system, which shifts the origin and influences everything you draw after that.</p>
			<p>
				Add a <code>translate()</code> function to your <em>transformation_functions</em> code, and display the grid-overlay graphic by using a new <code>image()</code> line.</p>
			<pre><code><span epub:type="pagebreak" id="Page_121" title="121"/><span class="LiteralGray">. . .</span><span class="ProcessingBlue">translate</span>(150, 100)<span class="ProcessingBlue">image</span>(grido, 0, 0)</code></pre>
			<p>
				The <code>translate()</code> function moves the entire coordinate system 150 pixels across and 100 pixels down. The <code>image()</code> function draws the grid-overlay graphic—a pale blue version of the first grid image—at (0, 0). The <em>grid-overlay.png</em> graphic has a transparent background, so you should see the <em>grid.png</em> file showing through it. Run the sketch to confirm that the output matches <a href="#figure6-22" id="figureanchor6-22">Figure 6-22</a>.</p>
			<figure>
				<img alt="f06022" src="image_fi/500969c06/f06022.png"/>
				<figcaption>
					<p><a id="figure6-22">Figure 6-22</a>: The grid image with the translated grid-overlay displayed above it</p>
				</figcaption>
			</figure>
			<p>The x-y coordinate (0, 0) no longer aligns with the upper left corner of the display window. The grid-overlay graphic serves as a visual representation of your new, shifted coordinate system.</p>
			<p>Add a red and a yellow square:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingBlue">fill</span>(<span class="ProcessingPurple">'#FF0000'</span>)<span class="ProcessingBlue">square</span>(0, 0, 100)<span class="ProcessingBlue">fill</span>(<span class="ProcessingPurple">'#FFFF00'</span>)<span class="ProcessingBlue">square</span>(100, 0, 100)</code></pre>
			<p><span epub:type="pagebreak" id="Page_122" title="122"/>The red and yellow squares share a y-argument of <code>0</code>, but the yellow square has an x-coordinate of <code>100</code>. Run the sketch. Processing positions both squares relative to your new origin. The yellow square should appear to the right of the red (<a href="#figure6-23" id="figureanchor6-23">Figure 6-23</a>).</p>
			<p>
				Transformations are cumulative, meaning that each subsequent transformation uses the current coordinate system as a reference, so you could have placed the yellow square 100 pixels to the right by using an additional <code>translate(100, 0)</code>:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingBlue">translate</span>(100, 0)<span class="LiteralGray">fill('#FFFF00')</span><span class="LiteralGray">square(</span><b>0</b><span class="LiteralGray">, 0, 100)</span></code></pre>
			<p>
				The new <code>translate()</code> line has an <code>x</code> argument of <code>100</code>, and the <code>x</code> argument for the <code>square()</code> is now <code>0</code>. The visual result should be the same as <a href="#figure6-23">Figure 6-23</a>.</p>
			<figure>
				<img alt="f06023" src="image_fi/500969c06/f06023.png"/>
				<figcaption>
					<p><a id="figure6-23">Figure 6-23</a>: Horizontally adjacent red and yellow squares</p>
				</figcaption>
			</figure>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box">
					<h2>Transformations within draw()</h2>
					<p class="BoxBodyFirst">Transformations within the <code>draw(</code><code>)</code> block are reset every time it re-executes. While you may have several <code>translate(</code><code>)</code> and/or other transformation functions within your <code>draw</code><code>()</code> block, the effects will not carry over into the next frame.</p>
					<p>For cumulative transformations across frames, you can use global variables as transformation arguments. In this way, the values can increment with each frame.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p><span epub:type="pagebreak" id="Page_123" title="123"/>In <span class="xref">Chapter 5</span>, you learned how to use a loop to arrange Truchet tiles. A row and column variable kept track of where to place the tiles. Alternatively, you could have used <code>translate()</code>, moving the coordinate system with each iteration of the loop.</p>
			<h3 id="h2-500969c06-0006">rotate()</h3>
			<p class="BodyFirst">The <code>rotate()</code> function rotates the coordinate system around its origin (0, 0). It accepts a single argument specified in radians. Positive values rotate clockwise, and negative values rotate counterclockwise. As with all transformation functions, the effect is cumulative. Moreover, you can mix <code>rotate()</code> and other transformation functions as you please.</p>
			<p>
				Add a new <code>rotate()</code> line beneath your first <code>translate()</code> function to rotate the grid-overlay graphic and red and yellow squares:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">translate(150, 100)</span><span class="ProcessingBlue">rotate</span>(<span class="ProcessingKhaki">QUARTER_PI</span>)<span class="LiteralGray">. . .</span></code></pre>
			<p>
				The <code>rotate()</code> function uses an argument of <code>QUARTER_PI</code> radians, equivalent to 45 degrees. Note that <code>QUARTER_PI</code> is a predefined Processing variable, equivalent to writing <code>PI/4</code>.</p>
			<p>
				Run the sketch. The two squares should appear to be rotated as a group, along with the grid-overlay graphic (<a href="#figure6-24" id="figureanchor6-24">Figure 6-24</a>).</p>
			<figure>
				<img alt="f06024" src="image_fi/500969c06/f06024.png"/>
				<figcaption>
					<p><a id="figure6-24">Figure 6-24</a>: Rotating the grid-overlay graphic and two squares</p>
				</figcaption>
			</figure>
			<p>
				The coordinate system is rotated around the current origin, which serves as the pivot point. Recall that this origin has been offset by 150 pixels for <code>x</code> and 100 pixels for <code>y</code> by the <code>translate()</code> function.</p>
			<p>
				The order of functions matters. For instance, switching the <code>translate()</code> and <code>rotate()</code> lines produces different visual results. <a href="#figure6-25" id="figureanchor6-25">Figure 6-25</a> provides a <span epub:type="pagebreak" id="Page_124" title="124"/>comparison. The ghosted squares depict the result of the transformation that occurred first. The right image is produced by performing the <code>rotate()</code> first, when the origin is aligned with the upper left corner of the display window.</p>
			<figure>
				<img alt="f06025" src="image_fi/500969c06/f06025.png"/>
				<figcaption>
					<p><a id="figure6-25">Figure 6-25</a>: The order of the <span class="LiteralInCaption"><code>translate()</code></span> and <span class="LiteralInCaption"><code>rotate()</code></span> functions matters; the image on the left shows <span class="LiteralInCaption"><code>translate()</code></span> first, and the image on the right shows <span class="LiteralInCaption"><code>rotate()</code></span> first.</p>
				</figcaption>
			</figure>
			<p>
				To rotate a square around its center, as opposed to its upper left corner, align the center of the square with the origin by offsetting the <code>x</code> and <code>y</code> arguments for <code>square()</code>.</p>
			<h3 id="h2-500969c06-0007">scale()</h3>
			<p class="BodyFirst">The <code>scale()</code> function resizes the coordinate system. One argument will scale proportionately; two arguments control the x-scale and y-scale. A <code>scale(1)</code> or <code>scale(1, 1)</code> will have no effect, as those are the default scale values.</p>
			<p>To decrease the scale, use a floating-point value between 0 and 1. Reduce the size of your existing elements:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">translate(150, 100)</span><span class="LiteralGray">rotate(QUARTER_PI)</span><span class="ProcessingBlue">scale</span>(0.5)<span class="LiteralGray">. . .</span></code></pre>
			<p>
				The scale value of <code>0.5</code> scales the elements to half their original size. Just as with <code>rotate()</code>, the scaling is relative to the origin of the current coordinate system. In other words, (0, 0) stays in place, and everything shrinks toward this point (<a href="#figure6-26" id="figureanchor6-26">Figure 6-26</a>).</p>
				<span epub:type="pagebreak" id="Page_125" title="125"/>
				<figure>
				<img alt="f06026" src="image_fi/500969c06/f06026.png"/>
				<figcaption>
					<p><a id="figure6-26">Figure 6-26</a>: Halving the size by using <span class="LiteralInCaption"><code>scale(0.5)</code></span></p>
				</figcaption>
			</figure>
			<p>
				Any value above 1 scales upward. For instance, to double the size of everything, use <code>scale(2)</code>. To reflect/flip on a given axis, use a negative value. For example, <code>scale(-1, 1)</code> flips everything horizontally, producing a mirror image of your elements.</p>
			<h3 id="h2-500969c06-0008">shearX() and shearY()<code> </code></h3>
			<p class="BodyFirst"><em>Shearing</em> a shape skews it along the horizontal or vertical axis. The result is a distorted shape with the same area. A typical shear example is transforming a rectangle into a parallelogram with slanted sides.</p>
			<p>
				The <code>shearX()</code> and <code>shearY()</code> functions apply a horizontal and vertical shear, respectively. Each function accepts a single argument specified in radians.</p>
			<p>
				To apply a vertical shear to your grid-overlay graphic and two squares, comment out the <code>rotate()</code> line and apply a 45-degree vertical shear by using a <code>shearY()</code> function:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">translate(150, 100)</span><b>#</b><span class="LiteralGray">rotate(QUARTER_PI)</span><span class="LiteralGray">scale(0.5)</span><span class="ProcessingBlue">shearY</span>(<span class="ProcessingKhaki">QUARTER_PI</span>)<span class="LiteralGray">. . .</span></code></pre>
			<p>
				The <code>rotate()</code> function is commented to make the direction of the shear more visually apparent. The <code>shearY()</code> argument is a positive number, so the shear is applied in a clockwise direction. <a href="#figure6-27" id="figureanchor6-27">Figure 6-27</a> contrasts the result of these code changes (left image) and a <code>shearX()</code> operation (right).</p>
			<p>You now know how to combine transformation functions; however, you’ll often want to contain the transformation effects to a limited selection of elements. Next, let’s look at how to use multiple coordinate matrices within a single sketch.</p>
			<span epub:type="pagebreak" id="Page_126" title="126"/>
			<figure>
				<img alt="f06027" src="image_fi/500969c06/f06027.png"/>
				<figcaption>
					<p><a id="figure6-27">Figure 6-27</a>: <var>shearY(QUARTER_PI)</var> (left) and <var>shearX(QUARTER_PI)</var> (right)<span class="LiteralInCaption"/></p>
				</figcaption>
			</figure>
			<h3 id="h2-500969c06-0009">pushMatrix() and popMatrix()</h3>
			<p class="BodyFirst">The <code>pushMatrix()</code> and <code>popMatrix()</code> functions allow you to isolate the effects of any transformation functions. In this way, you can perform different transformations on selected elements, which is especially useful for groups of elements.</p>
			<p>Any elements you add to your sketch are positioned relative to the coordinate system’s origin. Recall that each new transformation function affects the position or orientation of the origin and that each new transformation is influenced by any that precede it.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box">
					<h2>Resetting the Coordinate System with resetMatrix()</h2>
					<p class="BoxBodyFirst">If you need to clear all of your transformations, you can use the <code>resetMatrix</code><code>(</code><code>)</code> function to replace the current matrix with the <em>identity</em> <em>matrix</em>, which resets to the default coordinate system. For example, add the <code>resetMatrix</code><code>(</code><code>)</code> line just before the yellow square to clear all of the transformations preceding it:</p>
					<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingBlue">resetMatrix</span>()<span class="LiteralGray">fill('#FFFF00')</span><span class="LiteralGray">square(0, 0, 100)</span><span class="LiteralGray">. . .</span></code></pre>
					<p>
						The yellow square is now rendered relative to the original origin (upper left corner of the display window), at the standard scale, without any of the rotation or shear effects (<a href="#figure6-28" id="figureanchor6-28">Figure 6-28</a>).</p>
						<span epub:type="pagebreak" id="Page_127" title="127"/>
						<figure>
						<img alt="f06028" src="image_fi/500969c06/f06028.png"/>
						<figcaption>
							<p><a id="figure6-28">Figure 6-28</a>: The yellow square code is preceded by <var>resetMatrix()</var>.</p>
						</figcaption>
					</figure>
					<p>
						Remove the <code>resetMatrix</code><code>(</code><code>)</code> line before you continue.</p>
					å
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				If you want to apply <code>translate()</code> and <code>scale()</code> to the yellow square, but not <code>shearY()</code>, isolate the red and yellow squares, placing each within <code>pushMatrix()</code> and <code>popMatrix()</code>:</p>
			<pre><code><span class="LiteralGray">. . .</span><span aria-label="annotation1" class="CodeAnnotationHang">1</span> <span class="LiteralGray">translate(150, 100)</span><span class="LiteralGray">#rotate(QUARTER_PI)</span><span class="LiteralGray">scale(0.5)</span><span class="ProcessingBlue">pushMatrix</span>()<span aria-label="annotation2" class="CodeAnnotationHang">2</span> <span class="LiteralGray">shearY(QUARTER_PI)</span><span class="LiteralGray">image(grido, 0, 0)</span><span class="LiteralGray">fill('#FF0000')</span><span class="LiteralGray">square(0, 0, 100)</span><span class="ProcessingBlue">popMatrix</span>()<span class="ProcessingBlue">pushMatrix</span>()<span aria-label="annotation3" class="CodeAnnotationHang">3</span> <span class="LiteralGray">translate(100, 0)</span><span class="ProcessingBlue">image</span>(grido, 0, 0)<span class="LiteralGray">fill('#FFFF00')</span><span class="LiteralGray">square(0, 0, 100)</span><span class="ProcessingBlue">popMatrix</span>()</code></pre>
			<p>
				The <code>pushMatrix()</code> functions create new matrices for <code>shearY()</code> <span aria-label="annotation2" class="CodeAnnotation">2</span> and <code>translate()</code> <span aria-label="annotation3" class="CodeAnnotation">3</span>, which both extend upon the <code>translate(150, 100)</code> above <span aria-label="annotation1" class="CodeAnnotation">1</span>. The <code>popMatrix()</code> function restores the coordinate system before the previous <code>pushMatrix()</code> line. I’ve added another grid-overlay graphic to help visualize what is happening with the two coordinate systems.</p>
			<p><span epub:type="pagebreak" id="Page_128" title="128"/>As an alternative, you could undo the shear by adding <code>shearY(-QUARTER_PI)</code> after the red square, but pushing and popping matrices is the more elegant solution.</p>
			<p>
				Run the sketch. As shown in <a href="#figure6-29" id="figureanchor6-29">Figure 6-29</a>, the yellow square should appear translated and scaled, but not sheared.</p>
			<figure>
				<img alt="f06029" src="image_fi/500969c06/f06029.png"/>
				<figcaption>
					<p><a id="figure6-29">Figure 6-29</a>: The yellow square is translated and scaled, but not sheared.</p>
				</figcaption>
			</figure>
			<p>
				Now imagine that you want to move drawings made of multiple shapes across the display window. <a href="#figure6-30" id="figureanchor6-30">Figure 6-30</a> depicts a fish tank simulation; each fish is composed of many shapes. Each eye (a circle) has its own x-y coordinate, and so does every vertex that defines a curve or straight line.</p>
			<figure>
				<img alt="f06030" src="image_fi/500969c06/f06030.png"/>
				<figcaption>
					<p><a id="figure6-30">Figure 6-30</a>: Translating groups of shapes by using <span class="LiteralInCaption"><code>pushMatrix</code></span><span class="LiteralInCaption"><code>(</code></span><span class="LiteralInCaption"><code>)</code></span> and <span class="LiteralInCaption"><code>popMatrix</code></span><span class="LiteralInCaption"><code>()</code></span></p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_129" title="129"/>To track and update all of these x-y coordinates, you must store them in global variables to increment with each frame. The more efficient approach is to define each fish within a pair of <code>pushMatrix()</code> and <code>popMatrix()</code> functions. In this way, you can control the position of one fish by using one global x-y coordinate pair and a <code>translate()</code> function.</p>
			<p>
				Experiment with the <code>pushMatrix()</code> and <code>popMatrix()</code> functions containing different groups of shapes, each employing a different sequence of transformation functions. You can add animation if you like. Reuse the <code>image(grido, 0, 0)</code> line within each of your <code>pushMatrix()...</code> <code>popMatrix()</code> stacks to help visualize what’s happening.</p>
			<h4 class="HeadProject"><span>Challenge #6: Analog Clock</span></h4>
			<p class="BodyFirst">In this challenge, you’ll use all the techniques you’ve learned in this chapter to create an analog clock that displays the current time. The clock will update every second, so you’ll need to use <code>draw()</code>. To rotate the second, minute, and hour hands, you’ll use transformation functions.</p>
			<p>
				Create a new sketch and save it as <em>analog_clock</em>. Add the following code:</p>
			<pre><code><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">setup</span>(): <span class="ProcessingBlue">size</span>(600, 600) <span class="ProcessingBlue">frameRate</span>(1) <span class="ProcessingBlue">noFill</span>() <span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FFFFFF'</span>)<span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>(): <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#004477'</span>)</code></pre>
			<p>
				The frame rate is set to <code>1</code>, enough to update the second hand’s position each second.</p>
			<p>
				To retrieve the relevant time values, use the Processing <code>hour()</code>, <code>minute()</code>, and <code>second()</code> functions. Each function communicates with your computer clock to return an integer value; these functions require no arguments. Add code to the <code>draw</code> block that displays the current time in the console:</p>
			<pre><code><span class="LiteralGray">    . . .</span> h = <span class="ProcessingBlue">hour</span>() m = <span class="ProcessingBlue">minute</span>()<span class="LiteralGray">    s = </span><span class="ProcessingBlue">second</span><span class="LiteralGray">()</span> <span class="ProcessingBlue">print</span>(<span class="ProcessingPurple">'{}:{}:{}'</span>.<span class="ProcessingBlue">format</span>(h, m, s))</code></pre>
			<p>Run the sketch. With each new frame, your console displays the current hours (0 to 23), minutes (0 to 59), and seconds (0 to 59), separated by colons. The time should match that of your system clock, usually displayed in the corner of your screen.</p>
			<p>
				Creating a digital-style clock (that is, no hands, just numbers) in Processing is a simple matter of combining time and <code>text()</code> functions. For an analog clock, however, you need to convert the hours, minutes, and seconds into angles of rotation.</p>
			<p><span epub:type="pagebreak" id="Page_130" title="130"/>Begin your clock by drawing the face and hour hand:</p>
			<pre><code><span class="LiteralGray">    . . .</span> <span aria-label="annotation1" class="CodeAnnotation">1</span> <span class="ProcessingBlue">translate</span>(<span class="ProcessingRaspberry">width</span>/2, <span class="ProcessingRaspberry">height</span>/2) <span class="ProcessingBlue">strokeWeight</span>(3) <span aria-label="annotation2" class="CodeAnnotation">2</span> <span class="ProcessingBlue">circle</span>(0, 0, 350) <span class="ProcessingGray"># hour hand</span> <span aria-label="annotation3" class="CodeAnnotation">3</span> <span class="ProcessingBlue">strokeWeight</span>(10) <span class="ProcessingBlue">line</span>(0, 0, 100<span aria-label="annotation4" class="CodeAnnotation">4</span>, 0)</code></pre>
			<p>
				The <code>translate()</code> function <span aria-label="annotation1" class="CodeAnnotation">1</span> positions the origin in the center of the display window. This will make rotating the clock hands simpler, because the <code>rotate()</code> function rotates around the origin of the coordinate system. The <code>circle()</code> function, with its x-y arguments both set at zero <span aria-label="annotation2" class="CodeAnnotation">2</span>, is centered in the display window (<a href="#figure6-31" id="figureanchor6-31">Figure 6-31</a>). The hour hand is the thickest (and shortest), with a stroke weight of <code>10</code> <span aria-label="annotation3" class="CodeAnnotation">3</span> and length of <code>100</code> pixels <span aria-label="annotation4" class="CodeAnnotation">4</span>.</p>
			<figure>
				<img alt="f06031" src="image_fi/500969c06/f06031.png"/>
				<figcaption>
					<p><a id="figure6-31">Figure 6-31</a>: A clock face with an hour hand</p>
				</figcaption>
			</figure>
			<p>
				The hour hand currently rests along 0 radians (pointing east). Recall that when drawing using the <code>arc()</code> function, the angle opens from this point, clockwise (southward). However, your clock will be offset by three hours should the hand begin from a three o’clock position. Calibrate this using a <code>rotate()</code> function:</p>
			<pre><code><span class="LiteralGray">    . . .</span> <span class="ProcessingBlue">rotate</span>(-<span class="ProcessingKhaki">HALF_PI</span>) <span class="LiteralGray"># hour hand</span><span class="LiteralGray">    . . .</span></code></pre>
			<p>
				The <code>HALF_PI</code> is equivalent to <code>PI / 2</code>; by prepending this with a <code>–</code> sign, you rotate counterclockwise. Run the sketch. The hour hand should now point to twelve o’clock (directly upward).</p>
			<p><span epub:type="pagebreak" id="Page_131" title="131"/>The next step is to calculate how many radians the hand advances with each hour. Consider that a complete rotation is 2π radians; therefore, one hour equals <code>PI * 2 / 12</code>. So, six o’clock is <code>PI * 2 / 12 * 6</code>. Rather than writing <code>PI * 2</code>, though, you can use <code>TAU</code>. For example, six o’clock is equal to <code>TAU / 12 * 6</code>.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>
							Recall that π represents only a half circle in radians, so 2π tends to spring up in many formulas. In 2001, Robert Palais proposed that a new constant be devised to denote the number of radians in a “full turn,” equal to 2π; in 2010, it was decided that this value would be represented using the tau symbol (<span class="CustomCharStyle">τ</span>).</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>Rotate your hour hand to the current hour:</p>
			<pre><code><span class="LiteralGray">    . . .</span> <span class="LiteralGray"># hour hand</span> <span class="ProcessingBlue">rotate</span>(<span class="ProcessingKhaki">TAU </span>/ 12 * h)<span class="LiteralGray">    . . .</span></code></pre>
			<p>
				At twelve o’clock, the hour hand points directly upward. This is because <code>TAU / 12 * 12</code> is equal to <code>TAU</code>, or one complete rotation. For every other hour, the hand should point to the correct position (<a href="#figure6-32" id="figureanchor6-32">Figure 6-32</a>). Of course, the angle of the hand will depend on what time of day it is.</p>
			<p>
				Now add the minute and second hands. The final result should look something like <a href="#figure6-33" id="figureanchor6-33">Figure 6-33</a>.</p>
			<p>
				The second hand should advance each second. Compare the time in the console to the visual output to ensure that your code is working correctly. If you need help, you can access the solution at <a class="LinkURL" href="https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/analog_clock/">https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/analog_clock/</a>.</p>
			<figure>
				<img alt="f06032" src="image_fi/500969c06/f06032.png"/>
				<figcaption>
					<p><a id="figure6-32">Figure 6-32</a>: The hour hand pointing to two o’clock</p>
				</figcaption>
			</figure>
			<span epub:type="pagebreak" id="Page_132" title="132"/>
			<figure>
				<img alt="f06033" src="image_fi/500969c06/f06033.png"/>
				<figcaption>
					<p><a id="figure6-33">Figure 6-33</a>: The completed clock</p>
				</figcaption>
			</figure>
			<h2 id="h1-500969c06-0004">Summary</h2>
			<p class="BodyFirst">In this chapter, you learned how to structure a Processing sketch for animation. To manage variables between frames, you learned how to use global variables. You can increment global variables every frame to control shape coordinates for smooth animation. You also now know how to save frames as images. You might save an animation as a sequence of images so that you can combine them into a movie by using video editing software.</p>
			<p>You also saw how transformation functions manipulate the coordinate system, allowing you to translate, rotate, scale, and shear your elements. And you learned to modify the coordinate system to apply transformations to a select group of elements. It’s far easier to move a group of shapes by using a single translate operation than to manage a large number of coordinate variables. Moreover, applying rotate, scale, and shear operations to a single shape, let alone group, would otherwise involve complex matrix calculations.</p>
			<p>In the next chapter, you’ll learn about Python lists and how to read in data from external files. Lists will unlock powerful ways to manage and manipulate values as collections of elements, rather than individually. To help visualize list values, you’ll also explore data visualization techniques.</p>
		</section>
	</body></html>