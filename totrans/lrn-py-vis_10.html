<html><head></head><body>
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_207" title="207"/>10</span><br/><span class="ChapterTitle">Object-Oriented Programming and PVector</span></h1>
			</header>
			<figure class="opener">
				<img alt="" src="image_fi/book_art/chapterart.png"/>
			</figure>
			<p class="ChapterIntro"><em>Object-oriented programming</em> <em>(OOP)</em> deals with data structures known as <em>objects</em>. You create new objects from a class, and you can think of a class as an object template, composed of a collection of related functions and variables. You define a class for each category of objects you want to work with, and each new object will automatically adopt the features you define in its class. OOP combines everything you’ve learned so far, including variables, conditional statements, lists, dictionaries, and functions. OOP adds a remarkably effective way to organize your programs by modeling real-world objects.</p>
			<p>
				You can use classes to model tangible objects, like buildings, people, cats, and cars. Or, you can use them to model more abstract things, like bank accounts, personalities, and physical forces. Although a class will define the general features of a category of objects, you can assign unique attributes <span epub:type="pagebreak" id="Page_208" title="208"/>to differentiate each object you create. In this chapter, you’ll apply OOP techniques to program an amoeba simulation. You’ll learn how to define an amoeba class, and how to “spawn” varied amoeba from it.</p>
			<p>
				You’ll program amoeba movement by simulating physical forces. For this, you’ll use a built-in Processing class named <code>PVector</code>. The <code>PVector</code> class is an implementation of <em>Euclidean vectors</em> that includes a suite of methods for performing mathematical operations, which you’ll use to calculate the position and movement of each amoeba.</p>
			<p>To better manage your code, you’ll learn how to split your program into multiple files. You can then switch between the files that make up your sketch by using tabs in the Processing editor.</p>
			<h2 id="h1-500969c10-0001">Working with Classes</h2>
			<p class="BodyFirst">A <em>class</em> is like a blueprint for an object. As an example, consider a <code>Car</code> class that might specify, by default, that all cars have four wheels, a windshield, and so on. Certain features, like the paint color, can vary among individual cars, so when you create a new car object by using the <code>Car</code> class, you get to select a color. Such features are called <em>attributes</em>. In Python, attributes are variables that belong to a class. You can decide which attributes have predefined values (the four wheels and windshield) and which are assigned when you create a new car (the paint color).</p>
			<p>
				In this way, you can create multiple cars, each a different color, using a single class. <a href="#figure10-1" id="figureanchor10-1">Figure 10-1</a> illustrates this concept. The <code>Car</code> class includes attributes to describe the paint color, engine type, and model of each car.</p>
			<figure>
				<img alt="f10001" src="image_fi/500969c10/f10001.png"/>
				<figcaption>
					<p><a id="figure10-1">Figure 10-1</a>: The <var>Car</var> class serves as a blueprint for car objects.</p>
				</figcaption>
			</figure>
			<p>
				Drivers control a vehicle by steering, accelerating, and braking. So in addition to attributes, your <code>Car</code> class can include definitions for performing those actions, referred to as <em>methods</em>. In Python, methods are functions that belong to a class that define the operations or activities it can perform.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box">
					<h2><span epub:type="pagebreak" id="Page_209" title="209"/>Inheritance</h2>
					<p class="BoxBodyFirst">To get even more out of OOP, you can explore <em>inheritance</em> in Python. This allows one class to derive its attributes and methods from another class. For example, you could create a <code>Vehicle</code> class with accelerate, brake, and steer methods. Based on the <code>Vehicle</code> class, you can create <code>Car</code> and <code>Motorcycle</code> classes, with additional and unique attributes of their own (a steering wheel for the car, handlebars for the motorbike, and so on). I do not cover inheritance in this book.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				Now, let’s define an <code>Amoeba</code> class that includes a set of attributes and methods for controlling the appearance and behavior of amoeba objects. You’ll use that class to create many amoebas. <a href="#figure10-2" id="figureanchor10-2">Figure 10-2</a> depicts the final result of the amoeba simulation that you’re working toward.</p>
			<figure>
				<img alt="f10002" src="image_fi/500969c10/f10002.png"/>
				<figcaption>
					<p><a id="figure10-2">Figure 10-2</a>: A screenshot of the complete amoeba simulation</p>
				</figcaption>
			</figure>
			<p>
				The amoebas will wobble and distort as they move about the display window. This is not a scientifically correct representation of amoebas, but it should look pretty cool. As an extra challenge, you’ll add collision-detection code to prevent them from passing over or through one another. You’ll begin with a basic <code>Amoeba</code> class definition, and then add attributes and methods as you progress through the task.</p>
			<h3 id="h2-500969c10-0001">Defining a New Class</h3>
			<p class="BodyFirst">In Python, you define a class by using the <code>class</code> keyword. You may name a class whatever you like, but as with variable and function names, you’re limited to alphanumeric and underscore characters. Because you cannot use space characters, the recommended naming convention for classes is <em>UpperCamelCase</em>, in which the first letter of each word begins with a capital letter, starting with the first word.</p>
			<p><span epub:type="pagebreak" id="Page_210" title="210"/>To begin, your <code>Amoeba</code> class won’t do much else than print a line to the console. Start a new sketch and save it as <em>microscopic</em>. Define a new <code>Amoeba</code> class:</p>
			<pre><code><span class="ProcessingTealGreen">class</span> Amoeba(object): <span class="ProcessingTealGreen">def</span> <span class="ProcessingBlue">__init__</span>(<span class="ProcessingTealGreen">self</span>): <span class="ProcessingBlue">print</span>(<span class="ProcessingPurple">'amoeba initialized'</span>)</code></pre>
			<p>
				The <code>class</code> keyword defines a new class. Here the class name is <code>Amoeba</code>, and it’s followed by <code>object</code> in parentheses, and a colon.</p>
			<p>If you run the sketch, nothing interesting should happen, and the console will be empty.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>
							Python 2 has “old-style” and “new-style” classes. You’ll want to use the new style, which is why I include <var>object</var> in parentheses. This isn’t required in Python 3, because its classes are always new style. That said, it won’t make a difference if you happen to include the <code>object </code>part in your Python 3 programs.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				Functions that you define within the body of a class are referred to as <em>methods</em>. The <code>Amoeba</code> class includes a definition for a special method named <code>__init__</code> (with two underscores at either end). This method is one of a selection of <em>magic methods</em> that start and end with two underscores that you won’t invoke directly. I’ll get into more detail about the <code>__init__()</code> method (and the <code>self</code> parameter) soon. For now, all you need to know is that Python runs the <code>__init__()</code> method automatically for each new amoeba you create. You use this method to set up your attributes and execute code at the time of object creation.</p>
			<h3 id="h2-500969c10-0002">Creating an Instance from a Class</h3>
			<p class="BodyFirst">To <em>instantiate</em> an amoeba, you call the <code>Amoeba</code> class by name and assign it to a variable—as you would a function that returns a value. <em>Instantiate</em> is a fancy way of saying <em>create a new instance</em>, and an <em>instance</em> is synonymous with <em>object</em>.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p><span class="ColorText" style="color:#0E101A">	</span>You’ll often hear the terms <em>object</em> and <em>instance </em>used interchangeably. Correctly speaking, you create amoeba <em>objects</em> from the <code>Amoeba</code> class. A given amoeba is an <em>instance</em> of the <code>Amoeba</code> class. <em>Instance</em> emphasizes the distinct identity of a particular amoeba.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				Add a line to create a new instance from your <code>Amoeba</code> class and assign it to a variable named <code>a1</code>:</p>
			<pre><code><span class="LiteralGray">class Amoeba(object):</span><span class="LiteralGray">    </span><span class="LiteralGray">    def __init__(self):</span><span class="LiteralGray">        print('amoeba initialized')</span>
a1 = Amoeba()</code></pre>
			<p>
				When you run the sketch, Python creates a new <code>Amoeba()</code> instance. This will automatically invoke the <code>__init__()</code> method. You can use the <code>__init__()</code> <span epub:type="pagebreak" id="Page_211" title="211"/>method to define attributes and assign values to them, which you’ll do shortly. This method can also include other instructions to initialize the amoeba, as in this case, a <code>print()</code> function. When you run the sketch, the console should display a single <code>amoeba initialized</code> message.</p>
			<h3 id="h2-500969c10-0003">Adding Attributes to a Class</h3>
			<p class="BodyFirst">You can think of attributes as variables that belong to an object. And just like a variable, an attribute can contain any data you like, including numbers, strings, lists, dictionaries, and even other objects. For example, a <code>Car</code> class might have a string attribute for the model name and an integer attribute for top speed.</p>
			<p>
				In your <code>Amoeba</code> class, you’ll add three attributes to hold numbers for an x-coordinate, y-coordinate, and diameter; you’ll assign values to those attributes when you instantiate the new amoeba. The syntax resembles that used to pass arguments to a function: the parentheses of the <code>__init__()</code> method contain your list of corresponding parameters.</p>
			<p>
				Make the following changes to your code to accommodate an <code>x</code>, <code>y</code>, and <code>diameter</code> value for each new amoeba:</p>
			<pre><code><span class="LiteralGray">class Amoeba(object):</span><span class="LiteralGray">    def __init__(self</span><b>, x, y, diameter</b><span class="LiteralGray">):</span><span class="LiteralGray">        print('amoeba initialized')</span><span class="LiteralGray">a1 = Amoeba(</span><b>400, 200, 100</b><span class="LiteralGray">)</span></code></pre>
			<p>
				The <code>__init__()</code> method already includes a parameter, <code>self</code>; this is required, and it’s always the first parameter. The <code>self</code> parameter provides access to instance-specific values, like an <code>x</code> value of <code>400</code> for amoeba <code>a1</code> (but more on how that works shortly). The <code>x</code>, <code>y</code>, and <code>diameter</code> are added as the second, third, and fourth parameters. I’ve added corresponding arguments to the <code>a1</code> line. Notice, however, that I provide only three arguments and nothing for the <code>self</code> parameter. <a href="#figure10-3" id="figureanchor10-3">Figure 10-3</a> depicts how these positional arguments match up, starting from the second parameter in the <code>__init__()</code> method.</p>
			<figure>
				<img alt="f10003" src="image_fi/500969c10/f10003.png"/>
				<figcaption>
					<p><a id="figure10-3">Figure 10-3</a>: Don’t provide an argument for the <span class="LiteralInCaption"><code>self</code></span> parameter.</p>
				</figcaption>
			</figure>
			<p>You can also use keyword arguments (and specify default values for parameters), but I’ll stick to positional arguments throughout this task.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>
							If you pass the wrong number of arguments to <code>__init__()</code> or any other class method, Python will display an error message. But this error message can confuse many beginners. As an example, you can try creating a new <code>Amoeba</code> class with four arguments by using <code>Amoeba(400, 200, 100, 777)</code>. Run the sketch, and the Python error message <span epub:type="pagebreak" id="Page_212" title="212"/>will report that the <code>__init__()</code> method takes exactly four arguments, claiming that you’ve given five. This is because the <var>self</var> parameter makes it four arguments, but Python passes that value implicitly, leaving just three arguments for you to provide. Keep this in mind when you’re debugging OOP code.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				When you pass values to your <code>__init__()</code> method, it won’t automatically store them for you. For this, you need attributes, which are like variables for objects. Assign the <code>x</code>, <code>y</code>, and <code>diameter</code> parameters to new attributes. Each attribute begins with a prefix of <code>self</code>, followed by a dot, then the attribute name:</p>
			<pre><code><span class="LiteralGray">class Amoeba(object):</span><span class="LiteralGray">    def __init__(self, x, y, diameter):</span><span class="LiteralGray">        print('amoeba initialized')</span> <span class="ProcessingTealGreen">self</span>.x = x <span class="ProcessingTealGreen">self</span>.y = y <span class="ProcessingTealGreen">self</span>.d = diameter<span class="LiteralGray">a1 = Amoeba(400, 200, 100)</span></code></pre>
			<p>
				Notice that you assign <code>diameter</code> to <code>self.d</code>. Your attribute names need not match your parameter names.</p>
			<p>
				At this point, I can explain more about the <code>self</code> parameter. I’ve mentioned that <code>self</code> is an instance-specific reference. In other words, the <code>self.d</code> value of <code>100</code> belongs to amoeba <code>a1</code>. Each amoeba instance will possess its own set of <code>self.x</code>, <code>self.y</code>, and <code>self.d</code> values. For example, I might add another amoeba, <code>a3</code>, with different values:</p>
			<pre><code>a3 = Amoeba(600, 250, 200)</code></pre>
			<p>
				This will come in handy later when you add multiple amoebas to the simulation. <a href="#figure10-4" id="figureanchor10-4">Figure 10-4</a> provides a conceptual diagram of your <code>Amoeba</code> class and three possible instances.</p>
			<p>
				Next, you’ll learn how to access the <code>x</code>, <code>y</code>, and <code>d</code> values for amoeba <code>a1</code> via the <code>a1</code> instance. You’ll use those values to draw the amoeba in the display window, resembling the one depicted in the upper right corner of <a href="#figure10-4">Figure 10-4</a>.</p>
			<figure>
				<img alt="f10004" src="image_fi/500969c10/f10004.png"/>
				<figcaption>
					<p><a id="figure10-4">Figure 10-4</a>: Your <span class="LiteralInCaption"><code>A</code></span><span class="LiteralInCaption"><code>moeba</code></span> class and three instances</p>
				</figcaption>
			</figure>
			<h4 id="h3-500969c10-0001"><span epub:type="pagebreak" id="Page_213" title="213"/>Accessing Attributes</h4>
			<p class="BodyFirst">To access attributes, you use <em>dot notation</em>. For the <code>a1</code> instance, you can access the <code>x</code>, <code>y</code>, and <code>d</code> attributes as <code>a1.x</code>, <code>a1.y</code>, and <code>a1.d</code>, respectively. This is the instance name (<code>a1</code>) followed by a dot, followed by the name of the attribute you want to access.</p>
			<p>
				To get started, add this code to the end of your sketch, which draws a circle to represent amoeba <code>a1</code>:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">setup</span>(): <span class="ProcessingBlue">size</span>(800, 400) <span class="ProcessingBlue">frameRate</span>(120)<span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>(): <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#004477'</span>) <span class="ProcessingGray"># cell membrane</span> <span class="ProcessingBlue">fill</span>(0x880099FF) <span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FFFFFF'</span>) <span class="ProcessingBlue">strokeWeight</span>(3)<span class="ProcessingBlue">    circle</span>(a1.x,<span class="ProcessingGray"> </span>a1.y,<span class="ProcessingGray"> </span>a1.d)</code></pre>
			<p>
				The display window is now 800 pixels wide by 400 pixels high. The high frame rate of 120 will help smooth the wobble animation you’ll add to your amoeba later. A <em>cell membrane</em> separates an amoeba’s interior from its outside environment, and here, I’ve given this a white stroke. The fill is a semi-opaque pale blue. For the x-coordinate (first argument) in the <code>circle()</code> function, Python checks the <code>a1</code> instance for the attribute <code>self.x</code>—in this case, it’s equal to 400; the y-coordinate argument is equal to <code>200</code>, and the diameter argument is equal to <code>100</code>. The result (<a href="#figure10-5" id="figureanchor10-5">Figure 10-5</a>) is a circle with a diameter of 100 pixels positioned in the center of the display window.</p>
			<figure>
				<img alt="f10005" src="image_fi/500969c10/f10005.png"/>
				<figcaption>
					<p><a id="figure10-5">Figure 10-5</a>: A circle (rudimentary amoeba) with a diameter of 100 pixels</p>
				</figcaption>
			</figure>
			<p>
				So far, you’ve learned how to add arguments to your <code>Amoeba</code> class, which you assign to attributes when you instantiate an amoeba. In addition to those, your class can include attributes with predefined values.</p>
			<h4 id="h3-500969c10-0002">Adding an Attribute with a Default Value</h4>
			<p class="BodyFirst">Think back to the car analogy. Every car rolls off the production line with an empty gas tank. The manufacturer may fill it before it’s sold, but the tank always starts empty. For this, you decide to add an attribute to the <code>Car</code> <span epub:type="pagebreak" id="Page_214" title="214"/>class—let’s call it <code>self.fuel</code>. It has a predefined value of 0 for each new car object, but it’ll fluctuate over the lifetime of the vehicle. It’s redundant to specify by way of an argument that this should start at 0; instead, the <code>Car</code> class should automatically initialize the <code>fuel</code> attribute for you, setting it to 0 by default.</p>
			<p>
				Let’s return to the amoeba task. Every amoeba will include a nucleus with a predefined fill of red. To program this, assign a hexadecimal value (<code>#FF0000</code>) to an attribute named <code>nucleus</code> within the body of your <code>__init__()</code> method. There’s no need to add another parameter to your <code>__init__()</code> definition, because you don’t require the additional argument to specify the red fill:</p>
			<pre><code> <span class="LiteralGray">. . .</span><span class="LiteralGray">        self.x = x</span><span class="LiteralGray">        self.y = y</span><span class="LiteralGray">        self.d =  diameter</span> <span class="ProcessingTealGreen">self</span>.nucleus = <span class="ProcessingPurple">'#FF0000'</span><span class="LiteralGray">. . .</span></code></pre>
			<p>
				Now, every amoeba you create has a <code>nucleus</code> attribute assigned a value of <code>#FF0000</code>.</p>
			<p>
				Insert three new lines in your <code>draw()</code> function to render the nucleus beneath the cell membrane:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    background('#004477')</span> <span class="ProcessingGray"># nucleus</span> <span class="ProcessingBlue">fill</span>(a1.nucleus) <span class="ProcessingBlue">noStroke</span>() <span class="ProcessingBlue">circle</span>(a1.x, a1.y, a1.d/2.5)<span class="LiteralGray">    # cell membrane</span><b>    </b><span class="LiteralGray">. . .</span></code></pre>
			<p>
				The new lines set the fill and stroke, and then draw the nucleus by using a <code>circle()</code> function with a diameter that’s 2.5 times smaller (<code>a1.d/2.5</code>) than that of the cell membrane, placing it in the center of the amoeba. Run the sketch to confirm that you see a mauve nucleus; it is technically red, but you see it through the pale blue, semi-opaque membrane.</p>
			<p>You don’t set the nucleus fill when you instantiate the amoeba, but that doesn’t mean you’re stuck with a red nucleus. You can modify the attribute values after you’ve created an amoeba.</p>
			<h4 id="h3-500969c10-0003">Modifying an Attribute Value</h4>
			<p class="BodyFirst">Many attributes hold values that change as your program runs. To return to the car analogy, consider the <code>fuel</code> attribute mentioned previously with a value that’s continually shifting as the gas tank fluctuates between full and empty. You can modify the value of any attribute directly via the instance by using the same dot syntax for accessing values.</p>
			<p><span epub:type="pagebreak" id="Page_215" title="215"/>Insert a line to change the nucleus fill for amoeba instance <code>a1</code>:</p>
			<pre><code> <span class="LiteralGray">. . .</span><span class="LiteralGray">    # nucleus</span> a1.nucleus = <span class="ProcessingPurple">'#00FF00'</span><span class="LiteralGray">    fill(a1.nucleus)</span><b>   </b> <span class="LiteralGray">. . .</span></code></pre>
			<p>
				This sets the <code>nucleus</code> attribute to green, overwriting the default value of red. Run the sketch to confirm that you see a green nucleus showing through the semi-opaque membrane.</p>
			<p>
				You can also modify an attribute by using a method, which I cover in <span class="xref">“Adding Methods to a Class” on page 216</span>.</p>
			<h4 id="h3-500969c10-0004">Using a Dictionary for an Attribute</h4>
			<p class="BodyFirst">Recall that attributes can contain anything you like—numbers, strings, lists, dictionaries, objects, and so on. You’ll use a dictionary attribute that holds a mix of string (hexadecimal) and floating-point values to group the nucleus properties.</p>
			<p>
				Change your <code>nucleus</code> attribute to a dictionary that holds key-value pairs for a nucleus fill, x-coordinate, y-coordinate, and diameter. To vary the appearance of each amoeba, randomize those values:</p>
			<pre><code><span class="LiteralGray">class Amoeba(object):</span><span class="LiteralGray">    def __init__(self, x, y, diameter):</span><span class="LiteralGray">        print('amoeba initialized')</span><span class="LiteralGray">        self.x = x</span><span class="LiteralGray">        self.y = y</span><span class="LiteralGray">        self.d = diameter</span><span class="ProcessingTealGreen">        self</span>.nucleus = { <span class="ProcessingPurple">'fill'</span>: [<span class="ProcessingPurple">'#FF0000'</span>, <span class="ProcessingPurple">'#FF9900'</span>, <span class="ProcessingPurple">'#FFFF00'</span>,<span class="ProcessingPurple">                   '#00FF00'</span>, <span class="ProcessingPurple">'#0099FF'</span>][<span class="ProcessingBlue">int</span>(<span class="ProcessingBlue">random</span>(5))], <span class="ProcessingPurple">'x'</span>: <span class="ProcessingTealGreen">self</span>.d * <span class="ProcessingBlue">random</span>(-0.15, 0.15), <span class="ProcessingPurple">'y'</span>: <span class="ProcessingTealGreen">self</span>.d * <span class="ProcessingBlue">random</span>(-0.15, 0.15), <span class="ProcessingPurple">'d'</span>: <span class="ProcessingTealGreen">self</span>.d / <span class="ProcessingBlue">random</span>(2.5, 4) }<span class="LiteralGray">. . .</span></code></pre>
			<p>
				The <code>fill</code> key is paired with a hexadecimal value arbitrarily selected from a list of five colors. The nucleus color of each new amoeba is now chosen at random (although you may explicitly overwrite it afterward). The <code>x</code> and <code>y</code> keys are assigned randomized values proportional to the diameter of the cell membrane; you’ll use those to position the nucleus somewhere within the boundary of the cell membrane, but not necessarily in the center. The diameter of the nucleus (<code>d</code>) is also proportional to the cell membrane and randomly varies for each instance.</p>
			<p>
				Update your <code>draw()</code> code to work with these changes:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span epub:type="pagebreak" id="Page_216" title="216"/><span class="LiteralGray">    background('#004477')</span><span class="LiteralGray">    # nucleus</span> <span class="ProcessingBlue">fill</span>(a1.nucleus[<span class="ProcessingPurple">'fill'</span>]) <span class="ProcessingBlue">noStroke</span>() <span class="ProcessingBlue">circle</span>( a1.x + a1.nucleus[<span class="ProcessingPurple">'x'</span>],  a1.y + a1.nucleus[<span class="ProcessingPurple">'y'</span>],  a1.nucleus[<span class="ProcessingPurple">'d'</span>] )<span class="LiteralGray">    # cell membrane</span> <span class="LiteralGray">. . .</span></code></pre>
			<p>
				The <code>fill()</code> and <code>circle()</code> arguments reference the relevant dictionary keys to style and position the nucleus.</p>
			<p>
				Each time you run the sketch, Processing will generate a unique amoeba. <a href="#figure10-6" id="figureanchor10-6">Figure 10-6</a> depicts four results from four runs. Of course, it’s possible (but unlikely) that Processing will produce the same or a similar selection of randomized values, and consecutive results might appear identical.</p>
			<figure>
				<img alt="f10006" src="image_fi/500969c10/f10006.png"/>
				<figcaption>
					<p><a id="figure10-6">Figure 10-6</a>: Each amoeba is generated using randomized nucleus values.</p>
				</figcaption>
			</figure>
			<p>Now that you’ve set up the attributes to control the visual appearance of your amoeba, the next step is to add methods to animate it.</p>
			<h3 id="h2-500969c10-0004">Adding Methods to a Class</h3>
			<p class="BodyFirst">Functions that you define within the body of a class are referred to as <em>methods</em>. To return to the car analogy, drivers can control a vehicle by using methods, such as steering, accelerating, and braking. You could also include a method for refueling. Methods typically perform operations by using an object’s attributes. For example, an <code>accelerate()</code> and <code>refuel()</code> method will subtract from and add to a <code>fuel</code> attribute.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p><span epub:type="pagebreak" id="Page_217" title="217"/>Another analogy for describing object-oriented programming uses parts of speech. It goes like this: if objects (cars) are nouns, and attributes (like paint color) are adjectives, then methods (steer, accelerate, brake, and refuel) are verbs.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>You can name methods whatever you like, as long as you apply the same naming rules and conventions for functions. In other words, use only alphanumeric and underscore characters, camelCase or underscores instead of spaces, and so forth.</p>
			<p>
				You’ll create a new method to draw your amoeba for each frame. Currently, several lines in the <code>draw()</code> section of your code handle this operation. Move the nucleus and cell membrane code from the <code>draw()</code> function into the body of a new <code>display()</code> method, ensuring that your indentation is correct. Replace every <code>a1</code> prefix with <code>self</code> in the <code>display()</code> method:</p>
			<pre><code><span class="LiteralGray">class Amoeba(object):</span> <span class="LiteralGray">. . .</span> <span class="ProcessingTealGreen">def</span> display(<span class="ProcessingTealGreen">self</span><span aria-label="annotation1" class="CodeAnnotation">1</span>): <span class="ProcessingGray"># nucleus</span> <span class="ProcessingBlue">fill</span>(<span class="ProcessingTealGreen">self</span>.nucleus[<span class="ProcessingPurple">'fill'</span>]) <span class="ProcessingBlue">noStroke</span>() <span class="ProcessingBlue">circle</span>(<span class="ProcessingTealGreen">          self.</span>x + <span class="ProcessingTealGreen">self</span>.nucleus[<span class="ProcessingPurple">'x'</span>], <span class="ProcessingTealGreen">          self.</span>y + <span class="ProcessingTealGreen">self</span>.nucleus[<span class="ProcessingPurple">'y'</span>], <span class="ProcessingTealGreen">          self</span>.nucleus[<span class="ProcessingPurple">'d'</span>] ) <span class="ProcessingGray"># cell membrane</span> <span class="ProcessingBlue">fill</span>(0x880099FF) <span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FFFFFF'</span>) <span class="ProcessingBlue">strokeWeight</span>(3) <span class="ProcessingBlue">circle</span>(<span class="ProcessingTealGreen">self</span>.x, <span class="ProcessingTealGreen">self</span>.y, <span class="ProcessingTealGreen">self</span>.d)<span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    background('#004477')</span></code></pre>
			<p>
				The <code>self</code> parameter in the definition <span aria-label="annotation1" class="CodeAnnotation">1</span> provides the body of your <code>display()</code> method with access to your attributes, such as <code>self.nucleus</code> and <code>self.x</code>. The <code>display()</code> method accepts zero arguments, so the definition includes no further parameters.</p>
			<h4 id="h3-500969c10-0005">Calling a Method</h4>
			<p class="BodyFirst">Once you’ve defined a method, you can use the same dot notation as for attributes to call the method and execute the code in that method’s body—that is, the instance name followed by the method, separated by a dot. Of course, methods, like functions, include parentheses, and sometimes arguments too.</p>
			<p>
				Add an <code>a1.display()</code> call to your <code>draw()</code> function to render amoeba <code>a1</code>:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    background('#004477')</span> a1.display()</code></pre>
			<p><span epub:type="pagebreak" id="Page_218" title="218"/>You have no parameters (other than <code>self</code>) in your <code>display()</code> definition, so the method call takes no arguments. Run the sketch to confirm that it produces the same result as before (<a href="#figure10-6">Figure 10-6</a>).</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>	Just like well-named functions, well-named methods make your code easier to read and understand, for yourself and anybody else dealing with it.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				To get your amoeba wobbling, you’ll define a new method that you call from within the <code>Amoeba</code> class. Additionally, this method will accept a few arguments.</p>
			<h4 id="h3-500969c10-0006">Creating a Wobbly Amoeba</h4>
			<p class="BodyFirst">Amoebas distort and ripple, like balloons full of water. To replicate this not-quite-circular shape, you’ll replace the cell membrane’s <code>circle()</code> function with a shape formed using <code>bezierVertex()</code> functions. This is the same code that you used to draw the Chinese coin in <span class="xref">Chapter 2</span>, except here the control points are a bit wonky.</p>
			<p><a href="#figure10-7" id="figureanchor10-7">Figure 10-7</a> depicts the amoeba outline with the vertex and control points visualized. The shape isn’t perfectly round, but it is smooth with no discernible angles. For a smooth curve, the vertex and its two control points must form a straight line.</p>
			<figure>
				<img alt="f10007" src="image_fi/500969c10/f10007.png"/>
				<figcaption>
					<p><a id="figure10-7">Figure 10-7</a>: Drawing the amoeba with Bézier curves</p>
				</figcaption>
			</figure>
			<p>
				To animate the wobble effect, you need to tweak the position of the control points for each frame. To avoid discernible angles and maintain the rounded appearance of the curves, you’ll move your control points along circular paths. <a href="#figure10-8" id="figureanchor10-8">Figure 10-8</a> depicts (from left to right) two control points completing one rotation; each control point ends at the position it started, ready to repeat the motion seamlessly.</p>
			<p>
				Notice that the opposite control point is always 180 degrees ahead of or behind its counterpart. As the control points near the vertex, the curve <span epub:type="pagebreak" id="Page_219" title="219"/>grows tighter but remains rounded. The circular trajectories maintain the (virtual) straight line that runs from one control point to the other, through the vertex.</p>
			<figure>
				<img alt="f10008" src="image_fi/500969c10/f10008.png"/>
				<figcaption>
					<p><a id="figure10-8">Figure 10-8</a>: Moving the control-point coordinates along circular paths</p>
				</figcaption>
			</figure>
			<p>
				To program this effect, add a <code>circlePoint()</code> method for calculating points along the perimeter of each circular path (this method is an adaption of the <code>circlePoint()</code> function you defined in <span class="xref">Chapter 9</span>):</p>
			<pre><code><span class="LiteralGray">class Amoeba(object):</span> <span class="LiteralGray">. . .</span> <span class="ProcessingTealGreen">def</span> circlePoint(<span class="ProcessingTealGreen">self</span>, t, r): x = <span class="ProcessingBlue">cos</span>(t) * r y = <span class="ProcessingBlue">sin</span>(t) * r <span class="ProcessingOlive">return</span> [x, y] <span class="LiteralGray">. . .</span></code></pre>
			<p>
				The <code>circlePoint()</code> method accepts two arguments, a theta (<code>t</code>) value and radius (<code>r</code>). The rules of function scope apply to methods too, so the variables <code>x</code> and <code>y</code> are local to the <code>circlePoint()</code> method.</p>
			<p>
				You can call methods via the class instance—the <code>circlePoint()</code> method using <code>a1.circlePoint()</code>, for example. Of course, you’ll need to include the two arguments (for <code>t</code> and <code>r</code>). You can also call a method from within its class by using a <code>self</code> prefix—for example, <code>self.circlePoint()</code>. In this way, you can call the <code>circlePoint()</code> method from within the <code>display()</code> function, using the returned values to draw wobbly amoeba.</p>
			<p>
				Add a <code>circlePoint()</code> method call to the <code>display()</code> block, and replace the <code>circle()</code> function (for the cell membrane) with code for drawing a shape composed of <code>bezierVertex()</code> functions:</p>
			<pre><code> <span class="LiteralGray">. . .</span><span class="LiteralGray">    def display(self):</span> <span class="LiteralGray">. . .</span><span class="LiteralGray">        # cell membrane</span><span class="LiteralGray">        fill(0x880099FF)</span><span class="LiteralGray">        stroke('#FFFFFF')</span><span class="LiteralGray">        strokeWeight(3)</span> r = <span class="ProcessingTealGreen">self</span>.d / 2.0 cpl = r * 0.55 cpx, cpy = <span class="ProcessingTealGreen">self</span>.circlePoint(<span class="ProcessingRaspberry">frameCount</span>/(r/2), r/8)<span epub:type="pagebreak" id="Page_220" title="220"/>        xp, xm = <span class="ProcessingTealGreen">self</span>.x+cpx, <span class="ProcessingTealGreen">self</span>.x-cpx yp, ym = <span class="ProcessingTealGreen">self</span>.y+cpy, <span class="ProcessingTealGreen">self</span>.y-cpy <span class="ProcessingBlue">beginShape</span>() <span class="ProcessingBlue">vertex</span>( <span class="ProcessingTealGreen">self</span>.x, <span class="ProcessingTealGreen">self</span>.y-r <span class="ProcessingGray"># top vertex</span> ) <span class="ProcessingBlue">bezierVertex</span>( xp+cpl, yp-r, xm+r, ym-cpl, <span class="ProcessingTealGreen">self</span>.x+r, <span class="ProcessingTealGreen">self</span>.y <span class="ProcessingGray"># right vertex</span> ) <span class="ProcessingBlue">bezierVertex</span>( xp+r, yp+cpl, xm+cpl, ym+r, <span class="ProcessingTealGreen">self</span>.x, <span class="ProcessingTealGreen">self</span>.y+r <span class="ProcessingGray"># bottom vertex</span> ) <span class="ProcessingBlue">bezierVertex</span>( xp-cpl, yp+r, xm-r, ym+cpl, <span class="ProcessingTealGreen">self</span>.x-r, <span class="ProcessingTealGreen">self</span>.y <span class="ProcessingGray"># left vertex</span> ) <span class="ProcessingBlue">bezierVertex</span>( xp-r, yp-cpl, xm-cpl, ym-r, <span class="ProcessingTealGreen">self</span>.x, <span class="ProcessingTealGreen">self</span>.y-r <span class="ProcessingGray"># (back to) top vertex</span> ) <span class="ProcessingBlue">endShape</span>()<span class="LiteralGray">. . .</span></code></pre>
			<p>
				The <code>r</code> variable represents the radius of the amoeba. The <code>cpl</code> value is the distance from each control point to its vertex; recall that this is roughly 55 percent of the circle radius for perfectly round circles (see <span class="xref">Chapter 2</span>, Figure 2-22). The <code>circlePoint()</code> method calculates the coordinates for variables <code>cpx</code> and <code>cpy</code> by using a theta value based on the advancing <code>frameCount</code>; the <code>frameCount</code> is divided by half the amoeba radius, so that larger amoeba wobble more slowly than smaller ones. The second <code>circlePoint()</code> argument, for the radius of the circular path, is also proportional to the amoeba radius. The rest of the code uses the <code>cpl</code>, <code>cpx</code>, and <code>cpy</code> variables to plot the vertices and curves that compose the wobbly amoeba.</p>
			<p>Run the sketch to confirm that you have a wobbling amoeba.</p>
			<h4 id="h3-500969c10-0007">Modifying an Attribute by Using a Method</h4>
			<p class="BodyFirst">You can use a method to modify one or many attributes as an alternative to changing values directly via dot notation. Here’s a brief example; there’s no need to add this code to your sketch.</p>
			<p>
				When you instantiate your <code>a1</code> amoeba, your <code>__init__()</code> method randomly selects a nucleus fill from a predefined list of five colors. You can change this by assigning another value via <code>a1.nucleus['fill']</code>. Alternatively, you might define a new method to do this for you:</p>
			<pre><code><span class="LiteralGray">class Amoeba(object):</span><var>    </var><span class="LiteralGray">. . .</span><span class="ProcessingTealGreen">    def</span> styleNucleus(<span class="ProcessingTealGreen">self</span>, fill): <span class="ProcessingTealGreen">self</span>.nucleus[<span class="ProcessingPurple">'fill'</span>] = fill<var>    </var><span class="LiteralGray">. . .</span></code></pre>
			<p><span epub:type="pagebreak" id="Page_221" title="221"/>The <code>styleNulceus()</code> definition includes a parameter for a fill value. After you’ve instantiated amoeba <code>a1</code>, you can set the nucleus fill to black by using <code>a1.styleNucleus('#000000')</code> instead of <code>a1.nucleus['fill'] = '#000000'</code>. This might not seem very useful, but consider that you could add additional arguments for the nucleus dictionary’s <code>x</code>, <code>y</code>, and <code>d</code> values to change them all at once. You might even add additional logic, like an <code>if</code> statement to check the size of a diameter value before applying it:</p>
			<pre><code><span class="LiteralGray">    def styleNucleus(self, fill</span><b>, diameter</b><span class="LiteralGray">):</span><span class="LiteralGray">        self.nucleus['fill'] = fill</span> <span class="ProcessingOlive">if</span> diameter &gt; <span class="ProcessingTealGreen">self</span>.d/4 <span class="ProcessingTealGreen">and</span> diameter &lt; <span class="ProcessingTealGreen">self</span>.d/2.5: <span class="ProcessingTealGreen">self</span>.nucleus[<span class="ProcessingPurple">'d'</span>] = diameter</code></pre>
			<p>
				The <code>styleNucleus()</code> definition now includes an additional parameter for the nucleus diameter. But the new diameter value applies only if it’s appropriately sized. The <code>if</code> statement will ensure that the method ignores any value too small or too large so that you don’t end up with a tiny nucleus or an oversize one that extends beyond the cell membrane.</p>
			<p>
				Before moving on, here’s a brief recap of where you’re at in your amoeba simulation. You’ve defined an <code>Amoeba</code> class, complete with attributes to vary the appearance of each instance. You created a single amoeba, <code>a1</code>, but you’ll add other instances soon. You defined an <code>__init__()</code> method to initialize the attributes. Additionally, you defined a <code>display()</code> method to draw the amoeba that calls another method, <code>circlePoint()</code>, to make the cell membrane wobble. Later, you’ll make your amoebas move about the display window. First, though, you’ll split your <em>microscopic</em> sketch into two files.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box">
					<h2>Abstraction</h2>
					<p class="BoxBodyFirst">This is a good point to discuss <em>abstraction</em>, the process of reducing something complex to a simpler form that provides what you really need to accomplish a task. For example, if you’re designing a road map, you wouldn’t include every real-world detail—just the drivable roads, bodies of water, and labels for major landmarks. In this way, a road map presents an abstracted version of a satellite image to assist navigation better.</p>
					<p>To use another car analogy, you don’t need to be a mechanic in order to drive. As long as you can operate a gear lever, steering wheel, and pedals, you can drive a car (never mind how well). Those instruments present an abstraction of your car’s inner workings, providing an intuitive interface to control the transmission, steering system, and engine.</p>
					<p>
						In Python, you use abstraction on many levels. For example, you call the <code>print()</code> function to display things in the console. The details of how Python makes this happen are irrelevant to you; this function represents a complex set of instructions abstracted down to a single <code>print()</code> call.</p>
					<p><span epub:type="pagebreak" id="Page_222" title="222"/>In object-oriented programming, you design abstractions, deciding which details to hide and which to expose by way of attributes and methods. For example, in Python, a car object is an abstract representation of a real-world car using code. It’s simplified, because you don’t need to model each bolt, gear, and electrical wire to animate a vehicle moving about the screen. Moreover, the <code>Car</code> class will reduce a complex set of Python instructions—for appearance, movement, and so on—to a selection of intuitive methods, like <code>shiftGear()</code>, <code>steer()</code>, and <code>accelerate()</code>.</p>
					<p>As a programmer, you must decide how you apply abstraction in your programs. This includes how you model objects in Python. The best approach is not always clear, and often there’s no right or wrong way. Keep in mind, though, that good abstraction should make your code more clean, clear, modular, and maintainable.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<h2 id="h1-500969c10-0002">Splitting Your Python Code into Multiple Files</h2>
			<p class="BodyFirst">In this book, you’ve worked through a series of relatively small programming tasks. Handling each sketch in a single file has been manageable enough, but your line counts will increase as you begin to work on more complex programs. You might squeeze a <em>Tetris</em> game into several hundred lines of Processing code, but the open source Minecraft-like game <em>Minetest</em> is almost 600,000 lines of (mostly) C++ code, and Windows XP comprises about 45 million lines of source code!</p>
			<p>
				Programming languages have various mechanisms for structuring projects across multiple files. In Python, you can import code from files. Each Python file you import is referred to as a <em>module</em>. In this section, you’ll create a separate amoeba module for your <code>Amoeba</code> class.</p>
			<p>
				You’ll need to consider the most sensible ways to divide any program into modules. For example, you might group a collection of related functions into a single module. Sometimes it’s useful to add variables to a dedicated <em>configuration</em> module, providing a single location to set program-wide values. Grouping one or many related classes in a module is another great way to organize your code.</p>
			<p>
				In the Processing editor, each tab represents a module. Create a new tab/module by using the arrow to the right of your <em>microscopic</em> tab, highlighted in magenta in <a href="#figure10-9" id="figureanchor10-9">Figure 10-9</a>. From the menu that appears, select <b>New Tab</b>; name the new file <em>amoeba</em>.</p>
			<figure>
				<img alt="f10009" src="image_fi/500969c10/f10009.png"/>
				<figcaption>
					<p><a id="figure10-9">Figure 10-9</a>: Click the arrow tab, highlighted in magenta, for various tab operations.</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_223" title="223"/>This new file/module is created in the <em>microscopic</em> folder, alongside your main sketch file. Processing adds <em>.py</em> to the <em>amoeba</em> filename, the standard file extension for Python modules. The <em>amoeba.py</em> module should now appear as a tab alongside the microscopic one.</p>
			<p>
				You can switch between your main sketch and modules by using the tabs. Switch to the <em>microscopic</em> tab and select all the code for your <code>Amoeba</code> class, cut it, and then switch to the <em>amoeba.py</em> tab and paste the code there (<a href="#figure10-10" id="figureanchor10-10">Figure 10-10</a>).</p>
			<figure>
				<img alt="f10010" src="image_fi/500969c10/f10010.png"/>
				<figcaption>
					<p><a id="figure10-10">Figure 10-10</a>: The <em>amoeba.py</em> tab contains the code for your <span class="LiteralInCaption"><code>Amoeba</code></span> class.</p>
				</figcaption>
			</figure>
			<p>
				Now switch back to the <em>microscopic</em> tab. What’s left is everything from <code>a1 = Amoeba(400, 200, 100)</code> down.</p>
			<p>
				To import modules, use the <code>import</code> keyword. Your <code>import</code> line must precede any code that instantiates an amoeba. Typically, <code>import</code> lines go at the top of files to avoid getting this sequence wrong. Here’s the complete code for your <em>microscopic</em> tab:</p>
			<pre><code><span class="ProcessingTealGreen">from</span> amoeba <span class="ProcessingTealGreen">import</span> Amoeba<span class="LiteralGray">a1 = Amoeba(400, 200, 100)</span><span class="LiteralGray">    </span><span class="LiteralGray">def setup():</span><span class="LiteralGray">    size(800, 400)</span><span class="LiteralGray">    frameRate(120)</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    background('#004477')</span><span class="LiteralGray">    a1.display()</span></code></pre>
			<p>
				The <code>from</code> keyword instructs Python to open the <em>amoeba</em> module. The module takes its name from the filename, <em>amoeba.py</em>, but omits the <em>.py </em>extension. This is followed by <code>import</code> to specify the class(es) you want to import—in this case, <code>Amoeba</code>. This syntax allows you to be selective about which classes you import from modules that contain several class definitions. You can now use the <code>Amoeba</code> class as if it were defined in the <em>microscopic</em> tab.</p>
			<p>Run the sketch. It should run as usual and display a single wobbling amoeba in the center of the display window.</p>
			<p><span epub:type="pagebreak" id="Page_224" title="224"/>You can use modules to share code among projects. For example, you can copy your amoeba module into any Processing project folder. Then, you simply import it to start creating amoebas. You can also store a collection of modules in a folder-type structure known as a <em>library</em> or <em>package</em>.</p>
			<p>
				This modular system makes programming more efficient. In addition to reducing the line count of the main sketch, you conceal the inner workings of each module, leaving the programmer to focus on higher-level logic. For example, if you document your <em>amoeba</em> module, providing guidelines to instantiate amoebas and work the methods, any programmer can import and use it—creating amoebas without ever viewing the <em>amoeba.py</em> code. Additionally, modules make it easier for another programmer to browse your project code and understand your program because it’s divided into named files.</p>
			<p>
				Your <code>a1</code> amoeba remains in a fixed position, wobbling as time passes. The next step is to get it moving about the display window.</p>
			<h2 id="h1-500969c10-0003">Programming Movement with Vectors</h2>
			<p class="BodyFirst">You’ll program your amoeba movement by using vectors. These are not the vectors for scalable graphics, though, but Euclidean vectors. A <em>Euclidean vector </em>(also known as a <em>geometric</em> or <em>spatial vector</em>) represents a quantity that has both magnitude and direction. You’ll use vectors to model forces that propel your amoeba.</p>
			<p>
				In <a href="#figure10-11" id="figureanchor10-11">Figure 10-11</a>, the amoeba moves from position A to B; it’s propelled a total distance of 4 units. This distance represents a magnitude; a <em>magnitude </em>describes how powerful a force is. A force with a greater magnitude might thrust the same amoeba 20 units. Here’s the thing, though—the magnitude gives no indication of the direction in which the force is applied; you just know, from what you can glean visually, that the movement is 4 units to the right.</p>
			<figure>
				<img alt="f10011" src="image_fi/500969c10/f10011.png"/>
				<figcaption>
					<p><a id="figure10-11">Figure 10-11</a>: A magnitude of 4 units</p>
				</figcaption>
			</figure>
			<p>
				A magnitude is a <em>scalar</em> value. It’s a single quantity you can describe by using a single value, like a floating-point number or integer. For instance, the numbers 4, 1.5, 42, and one million are all scalar.</p>
			<p>
				A <em>vector</em> is described by multiple scalars. In other words, it can hold multiple floating-point or integer values. <a href="#figure10-12" id="figureanchor10-12">Figure 10-12</a> presents a vector labeled <em>v</em> as a line with an arrowhead at one end. The length of <em>v</em> is its magnitude; the slope and arrowhead indicate its specific direction.</p>
				<span epub:type="pagebreak" id="Page_225" title="225"/>
				<figure>
				<img alt="f10012" src="image_fi/500969c10/f10012.png"/>
				<figcaption>
					<p><a id="figure10-12">Figure 10-12</a>: The vector <em>v</em> extends 4 units right and 3 units up.</p>
				</figcaption>
			</figure>
			<p>
				Each vector has an x and y component, so you can express this vector as <b>v</b> = (4, 3). It describes a force to move the amoeba to a new location 4 units to the right and 3 units up from its previous location. You denote vectors in boldface type, but it’s also common to draw a small arrow above the <b>v</b> in situations where bold is impractical (for example, for handwritten formulas).</p>
			<p>
				The horizontal and vertical measurement lines in <a href="#figure10-12">Figure 10-12</a> form a right triangle with <em>v</em> as its hypotenuse. From this triangle, you can calculate the magnitude of the vector by using the <em>Pythagorean theorem</em>. The theorem states that the square of the hypotenuse is equal to the sum of the squares of the other two sides.</p>
			<p>
				If you add 4 squared (the adjacent side) to 3 squared (the opposite side), you get 25, the length of the hypotenuse squared. The square root of 25 is 5, the length of the hypotenuse and the magnitude of <em>v</em>. But you don’t need to worry about performing such calculations. Processing provides a built-in <code>PVector</code> class especially for working with vectors that includes, among other methods, a <code>mag()</code> for calculating magnitude.</p>
			<p>
				You’ll adapt your amoeba sketch to work with the <code>PVector</code> class. While showing how to make your amoeba move with vectors, I’ll also outline how the various <code>PVector</code> methods work, revealing what’s happening on a mathematical level.</p>
			<h3 id="h2-500969c10-0005">The PVector Class</h3>
			<p class="BodyFirst"><code>PVector</code> is a built-in Processing class for working with Euclidean vectors. You can use it anywhere in your sketch—no <code>import</code> line required. <code>PVector</code> can handle two- and three-dimensional vectors, but we’ll stick to the 2D variety here.</p>
			<p>
				To create a new 2D vector, the <code>PVector()</code> class requires an x and y argument. For example, this line defines the vector depicted previously in <a href="#figure10-12">Figure 10-12</a>:</p>
			<pre><code>v = <span class="ProcessingOrange">PVector</span>(4, 3)</code></pre>
			<p><span epub:type="pagebreak" id="Page_226" title="226"/>The <code>v</code> instance is a new vector that extends 4 units across and 3 units up. You should, however, switch the <code>3</code> to <code>-3</code> to match Processing’s coordinate system (where the y values decrease as you move up).</p>
			<p>
				A vector can point in any direction, negative or positive, but the magnitude is always a positive value. Use the <code>mag()</code> method to calculate the magnitude of any <code>PVector</code> instance; for example:</p>
			<pre><code>magnitude = v.<span class="ProcessingBlue">mag</span>()<span class="ProcessingBlue">print</span>(magnitude) <span class="ProcessingGray"># displays 5.0</span></code></pre>
			<p>
				You know that the <code>mag()</code> method must invoke prewritten code based on the Pythagorean theorem. It returns a floating-point value of 5.0, confirming our calculations from the previous section.</p>
			<h3 id="h2-500969c10-0006">Moving an Amoeba with PVector</h3>
			<p class="BodyFirst">You’ll create a <code>PVector</code> instance to animate amoeba <code>a1</code> moving across the display window. In <span class="xref">Chapter 6</span>, you programmed something similar—a DVD screensaver—as you instructed Processing to move a DVD logo a set number of pixels horizontally and vertically in each frame for smooth, diagonal movements. The approach is similar here, but you’ll use the <code>PVector</code> class instead. You’ll find that the vector-based approach is more efficient for simulating movement and forces.</p>
			<p>
				Switch to the <em>amoeba.py</em> tab and add a new <code>propulsion</code> vector to the <code>__init__()</code> method:</p>
			<pre><code><span class="LiteralGray">class Amoeba(object):</span><span class="LiteralGray">    def __init__(self, x, y, diameter</span><b>, xspeed, yspeed</b><span class="LiteralGray">):</span> <span class="LiteralGray">. . .</span> <span class="ProcessingTealGreen">self</span>.propulsion = <span class="ProcessingOrange">PVector</span>(xspeed, yspeed)</code></pre>
			<p>
				The propulsion vector is initialized using two additional arguments for <code>xspeed</code> and <code>yspeed</code> that’ll determine how many pixels your amoeba is propelled horizontally and vertically in each frame. In comparison to the DVD screensaver task, here you’re combining the <code>xspeed</code> and <code>yspeed</code> variables into a single vector named <code>propulsion</code>.</p>
			<p>
				Now switch to the <em>microscopic</em> tab. Use a fourth and fifth <code>Amoeba()</code> argument to set the x and y components of the propulsion vector to <code>3</code> and <code>-1</code>, respectively. Use the <code>draw()</code> function to increment your amoeba’s x and y attributes by those values:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">a1 = Amoeba(400, 200, 100</span><b>, 3, -1</b><span class="LiteralGray">)</span><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    background('#004477')</span> a1.x += a1.propulsion.x a1.y += a1.propulsion.y<span class="LiteralGray">    a1.display()</span></code></pre>
			<p><span epub:type="pagebreak" id="Page_227" title="227"/>Each frame, amoeba <code>a1</code>’s x value increases by 3 pixels; at the same time, its y value decreases by 1. In the default Processing coordinate system, reducing y moves the amoeba up. If you run the sketch, the amoeba should move (quite rapidly) along a diagonal trajectory, starting in the center of the display window and soon exiting just below the upper right corner.</p>
			<p>
				You can also use a <code>PVector</code> instance to store your amoeba’s x- and y-coordinates. In fact, you can use <code>PVector</code> to store any x-y coordinate pair; after all, it’s an object used to store two (or three) numbers, which also includes a bunch of handy methods for performing vector operations. Switch to the <em>amoeba.py</em> tab; replace the <code>self.x</code> and <code>self.y</code> attributes with a new vector named <code>self.location</code>:</p>
			<pre><code><span class="LiteralGray">class Amoeba(object):</span><span class="LiteralGray">    </span><span class="LiteralGray">    def __init__(self, x, y, diameter):</span><span class="LiteralGray">        print('amoeba initialized')</span> <span class="ProcessingTealGreen">self</span>.location = <span class="ProcessingOrange">PVector</span>(x, y) <span class="LiteralGray">. . .</span></code></pre>
			<p>
				The amoeba’s location is now a <code>PVector</code> instance too, albeit one that describes a point in the display window rather than a velocity or force. But you can’t rerun the sketch yet. First, you need to update the rest of the <em>amoeba.py </em>file to work with the new location attribute.</p>
			<p>
				Your <code>Amoeba</code> class has multiple references to <code>self.x</code> and <code>self.y</code>, and you’ll need to ensure that you replace them all with <code>self.location.x</code> and <code>self.location.y</code>, respectively. The easiest way to do this is by using a find-and-replace operation. From the Processing menu bar, select <b>Edit</b><span class="MenuArrow">▶</span><b>Find</b> to access the <b>Find</b> tool (<a href="#figure10-13" id="figureanchor10-13">Figure 10-13</a>). Enter <code class="bold">self.x</code> into the <b>Find</b> field, and <code class="bold">self.location.x</code> into the <b>Replace with</b> field. Click the <b>Replace All</b> button to apply the changes. The checkbox settings shouldn’t make any difference here. Once you’re done, do the same for <code>self.y</code>, replacing it with <code class="bold">self.location.y</code>.</p>
			<figure>
				<img alt="f10013" src="image_fi/500969c10/f10013.png"/>
				<figcaption>
					<p><a id="figure10-13">Figure 10-13</a>: The Processing Find (and Replace) tool</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_228" title="228"/>Now, change <code>a1.x</code> and <code>a1.y</code> in your <em>microscopic</em> tab to <code class="bold">a1.location.x</code> and <code class="bold">a1.location.y</code>, respectively:</p>
			<pre><code> <span class="LiteralGray">. . .</span><span class="LiteralGray">    a1.</span><b>location</b><span class="LiteralGray">.x += a1.propulsion.x</span><span class="LiteralGray">    a1.</span><b>location</b><span class="LiteralGray">.y += a1.propulsion.y</span> <span class="LiteralGray">. . .</span></code></pre>
			<p>
				You add the x components on one line and the y components on another. However, there’s a more efficient way to do this, using <code>PVector</code> addition.</p>
			<h4 id="h3-500969c10-0008">Adding Vectors</h4>
			<p class="BodyFirst">The <code>+</code> operator is used to add floating-point numbers or integers. Additionally, it serves as a concatenation operator for string operands. The <code>PVector</code> class is programmed to work with the <code>+</code> operator too. You can add one <code>PVector</code> instance to another to get a vector that’s the sum of the two. By extension, <code>+=</code> works as an augmented assignment operator, stating that the vector operand to the left of the operator is equal to itself plus the right operand.</p>
			<p>
				Replace your <code>a1.x += propulsion.x</code> and <code>a1.y += propulsion.y</code> lines with a single line to add the propulsion and location, adding <code>PVector</code> instances rather than individual components:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    background('#004477')</span> a1.location += a1.propulsion<span class="LiteralGray">    a1.display()</span></code></pre>
			<p>
				With each call of the <code>draw()</code> function (every frame), the amoeba location is incremented by the propulsion vector. If you run the sketch, the amoeba moves along the same trajectory as before, 3 pixels across and 1 up each frame, exiting just below the upper right corner of the display window.</p>
			<p>
				Let’s add a new force to the simulation. You’ll model a current flowing diagonally across the display window; it assists the amoeba’s prevailing motion, flowing toward northeast. As Wikipedia (<a class="LinkURL" href="https://en.wikipedia.org/wiki/Current_(fluid)">https://en.wikipedia.org/wiki/Current_(fluid)</a>) defines it, “A current in a fluid is the magnitude and direction of flow within that fluid.” Evidently, this is something to model using a vector.</p>
			<p>
				Add a new <code>PVector</code> named <code>current</code> to your <em>microscopic</em> tab. Add that vector to your location each frame by using the <code>draw()</code> function:</p>
			<pre><code><span class="LiteralGray">. . .</span>
current = <span class="ProcessingOrange">PVector</span>(1, -2)<span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    background('#004477')</span><span class="LiteralGray">    a1.location += a1.propulsion</span> a1.location += current<span class="LiteralGray">    a1.display()</span></code></pre>
			<p><span epub:type="pagebreak" id="Page_229" title="229"/>The propulsion vector is angled at roughly 18 degrees, pushing more rightward than upward. The current vector is angled at approximately 63 degrees, pushing more upward than rightward (<a href="#figure10-14" id="figureanchor10-14">Figure 10-14</a>). This combination makes the amoeba move faster, at an angle somewhere between the two vectors (~36 degrees). If you run the sketch, the amoeba should exit the top edge of the display window (before, it exited at the right edge).</p>
			<figure>
				<img alt="f10014" src="image_fi/500969c10/f10014.png"/>
				<figcaption>
					<p><a id="figure10-14">Figure 10-14</a>: The amoeba moves a total of 4 pixels across and 3 up each frame.</p>
				</figcaption>
			</figure>
			<p>
				Vector addition works by adding the x component of one vector to the x component of another, and likewise for the y components. In this case, adding the x components (3 + 1) equals 4, and adding the y components (–1 + –2) equals –3 . Regardless of the order in which you add vectors, the result is always the same. For example, (3, –1) + (1, –2) is the same as (1, –2) + (3, –1), and the resultant vector is (4, –3) in both instances. This makes vector addition a <em>commutative</em> operation, because changing the order of your operands doesn’t change the result.</p>
			<p>You can experiment with different current values to see what happens. A current vector of (–3, 1) cancels out the propulsion vector exactly, and the amoeba won’t move from the center of the display window. A current vector of (–3.5, 1) will overpower the propulsion’s x component and exactly match the y component, moving the amoeba slowly and directly leftward.</p>
			<p>The neat thing about this system is that you can add as many forces to the object’s location as you like. For instance, you might include a vector for wind, one for gravity, and so on.</p>
			<h4 id="h3-500969c10-0009">Subtracting Vectors</h4>
			<p class="BodyFirst">In mathematics, the result of a subtraction operation is called the <em>difference</em>. For example, when you subtract 4 from 6, you’re left with a difference of 2. Likewise, when you subtract one vector from another, the resultant vector is the difference between the two.</p>
			<p><span epub:type="pagebreak" id="Page_230" title="230"/>You can picture vector subtraction like this: begin by placing the two vectors tail to tail; between the head of each vector, draw a line; this new line is the difference vector. In <a href="#figure10-15" id="figureanchor10-15">Figure 10-15</a>, you subtract <em>b</em> from <em>a</em>; the difference (dark blue vector <em>c</em>) is (–2, –1).</p>
			<figure>
				<img alt="f10015" src="image_fi/500969c10/f10015.png"/>
				<figcaption>
					<p><a id="figure10-15">Figure 10-15</a>: Vector <em>c</em> is equal to (–2, –1).</p>
				</figcaption>
			</figure>
			<p>
				The process of vector subtraction is similar to vector addition, but rather than adding the x (with x) and y (with y) components of each vector, you’re subtracting them. Note, however, that subtraction is <em>noncommutative</em>. That means, changing the order of the operands changes the result. For example, if you subtract <em>a</em> from <em>b</em>, you get (2, 1) instead of (–2, –1). This makes vector <em>c</em> point the opposite way, switching its head and tail.</p>
			<p>
				You can subtract <code>PVector</code> instances by using the <code>–</code> operator. Here’s an example:</p>
			<pre><code><span class="ProcessingBlue">print</span>(current - a1.propulsion)</code></pre>
			<p>
				If your current vector is equal to (1, –2), this will print <code>[-2.0, -1.0, 0.0]</code> to the console. Processing prints a <code>PVector</code> instance as a list of three floating-point values, which represent the vector’s x, y, and z components, respectively. The z value is always a 0, unless you’re working with three-dimensional vectors.</p>
			<p>
				You’ve added a propulsion and current vector to the amoeba’s location to get it moving across the display window. You’ll now apply what you’ve learned about vector subtraction to get the amoeba moving toward your mouse pointer. You’ll create a new <code>PVector</code> instance called <code>pointer</code> to store the x-y coordinates of your mouse pointer. You’ll subtract <code>location</code> (which holds the amoeba’s x-y coordinates) from <code>pointer</code> to find the difference vector (<a href="#figure10-16" id="figureanchor10-16">Figure 10-16</a>), which you’ll use to redirect the amoeba.</p>
				<span epub:type="pagebreak" id="Page_231" title="231"/>
				<figure>
				<img alt="f10016" src="image_fi/500969c10/f10016.png"/>
				<figcaption>
					<p><a id="figure10-16">Figure 10-16</a>: The difference vector is equal to <span class="LiteralInCaption"><code>pointer</code></span> – <span class="LiteralInCaption"><code>location</code></span>.</p>
				</figcaption>
			</figure>
			<p>
				Ensure that your current vector is set to (1, –2). Add a new <code>PVector</code> named pointer and a difference variable that’s equal to the pointer minus the amoeba location (the difference vector depicted in <a href="#figure10-16">Figure 10-16</a>).</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">current = PVector(</span><b>1</b><span class="LiteralGray">, </span><b>-2</b><span class="LiteralGray">)</span><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    background('#004477')</span> pointer = <span class="ProcessingOrange">PVector</span>(<span class="ProcessingRaspberry">mouseX</span>, <span class="ProcessingRaspberry">mouseY</span>) difference = pointer - a1.location a1.location += difference <span class="LiteralGray">. . .</span></code></pre>
			<p>
				The <code>mouseX</code> and <code>mouseY</code> are Processing system variables that hold the x- and y-coordinates of your mouse pointer. Note, however, that Processing can begin tracking the mouse position only after you move the pointer in front of the display window; until that time, <code>mouseX</code> and <code>mouseY</code> both return a default value of 0.</p>
			<p>If you run the sketch, the amoeba will attach to the mouse pointer. This happens because the amoeba reaches the pointer position in a single “leap.” Instead, you want the amoeba to “swim” toward the pointer, advancing in small increments over multiple frames.</p>
			<h4 id="h3-500969c10-0010">Limiting Vector Magnitude</h4>
			<p class="BodyFirst">The <code>PVector</code> class provides the <code>limit()</code> method to limit the magnitude of any vector, which does not affect the direction. It requires a scalar (integer or floating-point) argument that represents a maximum magnitude.</p>
			<p>
				You’ll use the difference vector to steer the amoeba toward the mouse pointer by adding it to the propulsion vector. You’ll limit the propulsion vector to a magnitude of 3 (<a href="#figure10-17" id="figureanchor10-17">Figure 10-17</a>), enough to overpower the current marginally (which has a magnitude of 2.24) when the amoeba is swimming directly into it.</p>
				<span epub:type="pagebreak" id="Page_232" title="232"/>
				<figure>
				<img alt="f10017" src="image_fi/500969c10/f10017.png"/>
				<figcaption>
					<p><a id="figure10-17">Figure 10-17</a>: The propulsion vector’s magnitude is limited to 3.</p>
				</figcaption>
			</figure>
			<p>
				Make the following insertions/changes to the <code>draw()</code> function to steer and propel the amoeba toward the mouse pointer:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span> <span class="LiteralGray">. . .</span> <span aria-label="annotation1" class="CodeAnnotation">1</span> <b>#</b><span class="LiteralGray">a1.location += difference</span> <span aria-label="annotation2" class="CodeAnnotation">2</span> <b>a1.propulsion += difference.limit(0.03)</b> <span aria-label="annotation3" class="CodeAnnotation">3</span> <span class="LiteralGray">a1.location += a1.propulsion</span><b>.limit(3)</b><span class="LiteralGray">    a1.location += current</span><span class="LiteralGray">    a1.display()</span></code></pre>
			<p>
				First, comment out or delete the existing <code>a1.location += difference</code> line <span aria-label="annotation1" class="CodeAnnotation">1</span>. The <code>limit()</code> method restricts the <code>difference</code> vector to a magnitude of 0.03 <span aria-label="annotation2" class="CodeAnnotation">2</span>. This tiny value is added to the propulsion vector each frame—the effect rapidly accumulating—steering the amoeba progressively toward the mouse pointer. But even when the amoeba is heading directly at the pointer, the propulsion vector’s magnitude will not exceed 3 <span aria-label="annotation3" class="CodeAnnotation">3</span>.</p>
			<p>Run the sketch and position your mouse pointer over the display window somewhere near the lower left corner. The amoeba will have drifted out of view. But wait for a while, and it’ll slowly make its way toward the corner; when it reaches the pointer, it will overshoot it slightly, then turn around and overshoot it on the way back. It continues to overshoot the pointer, because it’s trying to reach its target as quickly as possible. Now move your pointer to the lower right corner. Assisted by the current, the amoeba is quick to reach the opposite side of the screen, but its higher velocity leads it to overshoot the target dramatically.</p>
			<p>
				Soon, you’ll add multiple amoebas to the simulation. To prepare them for moving at different speeds, add an attribute for maximum propulsion to the <code>Amoeba</code> class:</p>
			<pre><code><span class="LiteralGray">class Amoeba(object):</span><span class="LiteralGray">    def __init__(self, x, y, diameter, xspeed, yspeed):</span><span class="LiteralGray">        . . .</span> <span class="ProcessingTealGreen">self</span>.maxpropulsion = <span class="ProcessingTealGreen">self</span>.propulsion.<span class="ProcessingBlue">mag</span>()</code></pre>
			<p>
				This attribute will limit the magnitude/power of the amoeba’s propulsion vector based on the <code>xspeed</code> and <code>yspeed</code> arguments you provide. Adapt the code <span epub:type="pagebreak" id="Page_233" title="233"/>in your <em>microscopic</em> tab to work with the <code>maxpropulsion</code> attribute, switching out the arguments of both <code>limit()</code> methods. Additionally, adjust the values for the <code>xspeed</code>, <code>yspeed</code>, and the current vector, reducing them by a factor of 10:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">a1 = Amoeba(400, 200, 100, </span><b>0.3</b><span class="LiteralGray">, </span><b>-0.1</b><span class="LiteralGray">)</span><span class="LiteralGray">current = PVector(</span><b>0.1</b><span class="LiteralGray">, </span><b>-0.2</b><span class="LiteralGray">)</span><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><var>    </var><span class="LiteralGray">. . .</span><span class="LiteralGray">    a1.propulsion += difference.limit(</span><b>a1.maxpropulsion/100</b><span class="LiteralGray">)</span><span class="LiteralGray">    a1.location += a1.propulsion.limit(</span><b>a1.maxpropulsion</b><span class="LiteralGray">)</span> <span class="LiteralGray">. . .</span></code></pre>
			<p>The reduced propulsion and current values slow down the simulation, so the amoeba movement is more steady and controlled. The amoeba won’t wildly overshoot its target anymore, but it still makes small orbits around the pointer. The limit for the difference vector is now proportional to the amoeba’s maximum propulsion, so a faster amoeba has some extra steering power to handle its higher velocity.</p>
			<h4 id="h3-500969c10-0011">Performing Other Vector Operations</h4>
			<p class="BodyFirst">There’s more to vectors and the <code>PVector</code> class, but that’s all I cover in this book. Consider what you’ve learned as an elementary introduction to the topic. The <code>PVector</code> class can additionally handle vector multiplication, division, normalization, 3D vectors, and more. Vectors are useful for programming anything that requires physics, like video games, and you’re likely to reencounter them in your creative coding adventures.</p>
			<h2 id="h1-500969c10-0004">Adding Many Amoebas to the Simulation</h2>
			<p class="BodyFirst">You have a working amoeba module, but you’re still dealing with a single amoeba instance, <code>a1</code>, so the next step is to create a colony. You can create as many instances as you like from a single class. In this section, you’ll spawn eight amoebas in the same display window by using the <code>Amoeba</code> class. Each amoeba will vary in size, and you’ll start them at different x-y coordinates. Recall that each amoeba instance includes a dictionary of randomized nucleus values, so the nuclei will vary too.</p>
			<p>One (rather manual) approach for adding amoebas is to define additional instances with personalized variable names, with explicitly differentiated parameters. Consider these three new amoeba:</p>
			<pre><code><span class="LiteralGray">a1 = Amoeba(400, 200, 100, 0.3, -0.1)</span>
sam = Amoeba(643, 105, 56, 0.4, -0.4)
bob = Amoeba(295, 341, 108, -0.3, -0.1)
lee = Amoeba(97, 182, 198, -0.1, 0.2)
. . .</code></pre>
			<p><span epub:type="pagebreak" id="Page_234" title="234"/>You can keep adding amoebas in this manner, but the approach has its downsides. For one, you need to remember to call every <code>display()</code> method in the body of the <code>draw()</code> function to render each amoeba:</p>
			<pre><code><span class="LiteralGray">def draw():</span><var>    </var><span class="LiteralGray">. . .</span><span class="LiteralGray">    a1.display()</span> sam.display() bob.display() lee.display() . . .</code></pre>
			<p>
				This will display <code>sam</code>, <code>bob</code>, and <code>lee</code> standing still; to get those amoebas moving, the <code>draw()</code> function requires even more code. That isn’t especially efficient if you’re dealing with 5 or so amoebas, never mind 100.</p>
			<p>
				Personalized amoeba names are cute and all, but not important for this program. Instead, you’ll store the amoebas in a list. You can conveniently use a loop to generate a list of as many amoebas as you like. Then you can call each amoeba’s <code>display()</code> method (along with the code to move it) by using another loop.</p>
			<p>
				Replace the <code>a1</code> line at the top of your <em>microscopic</em> code with an empty <code>amoebas</code> list and a loop to populate it:</p>
			<pre><code><span class="LiteralGray">from amoeba import Amoeba</span>
amoebas = []<span class="ProcessingOlive">for</span> i <span class="ProcessingTealGreen">in range</span>(8): diameter = <span class="ProcessingBlue">random</span>(50, 200) speed = 1000 / (diameter * 50) x, y = <span class="ProcessingBlue">random</span>(800), <span class="ProcessingBlue">random</span>(400) amoebas.<span class="ProcessingBlue">append</span>(Amoeba(x, y, diameter, speed, speed))<span class="LiteralGray">. . .</span></code></pre>
			<p>
				With each iteration of the <code>for</code> loop, Python creates a new <code>Amoeba()</code> instance. The <code>Amoeba()</code> arguments are randomized to vary the x-coordinate, y-coordinate, and diameter of each instance. The <code>speed</code> value is based on the <code>diameter</code>—so bigger amoebas move slower (recall that the <code>propulsion</code> and <code>maxpropulsion</code> attribute is derived from the <code>xspeed</code> and <code>yspeed</code> arguments). The <code>append()</code> method adds the new amoeba instance to the <code>amoebas</code> list. The amoebas don’t have names like <code>sam</code>, <code>bob</code>, and <code>lee</code>, but you can address them by index as <code>amoebas[0]</code>, <code>amoebas[1]</code>, and so forth.</p>
			<p>
				You must add a <code>for</code> loop to the <code>draw()</code> function to render the full list of amoebas. Here’s your amended code:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>(): <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#004477'</span>) pointer = <span class="ProcessingOrange">PVector</span>(<span class="ProcessingRaspberry">mouseX</span>, <span class="ProcessingRaspberry">mouseY</span>)<span epub:type="pagebreak" id="Page_235" title="235"/> <span class="ProcessingOlive">for</span> a <span class="ProcessingTealGreen">in</span> amoebas: difference = pointer - a.location a.propulsion += difference.<span class="ProcessingBlue">limit</span>(a.maxpropulsion/100) a.location += a.propulsion.<span class="ProcessingBlue">limit</span>(a.maxpropulsion) a.location += current a.display()</code></pre>
			<p>
				The <code>for</code> loop iterates the entire <code>amoebas</code> list. For each amoeba, it calculates an updated location, and then renders that amoeba by using its <code>display()</code> method.</p>
			<p>
				The larger, slower amoebas might drift out of the display window, overwhelmed by the current, never to be seen again. To avoid this problem, add code for <em>wraparound</em> edges—so that if an amoeba exits the display window, it reappears on the opposite side, maintaining its speed and trajectory:</p>
			<pre><code><span class="LiteralGray">    . . .</span><span class="LiteralGray">    for a in amoebas:</span> <span class="LiteralGray">. . .</span> r = a.d / 2 <span class="ProcessingOlive">if</span> a.location.x - r &gt; <span class="ProcessingRaspberry">width</span>:    a.location.x = 0 - r <span class="ProcessingOlive">if</span> a.location.x + r &lt; 0:        a.location.x = <span class="ProcessingRaspberry">width</span> + r <span class="ProcessingOlive">if</span> a.location.y - r &gt; <span class="ProcessingRaspberry">height</span>:   a.location.y = 0 - r <span class="ProcessingOlive">if</span> a.location.y + r &lt; 0:        a.location.y = <span class="ProcessingRaspberry">height</span> + r</code></pre>
			<p>
				The four <code>if</code> statements check each edge of the display window. It’s necessary to incorporate the radius (variable <code>r</code>) in the conditions to ensure that the amoeba has fully left the display window before it reappears on the opposite side. Likewise, each corresponding destination is offset by <code>r</code> to prevent the amoeba from reappearing halfway over the opposite edge. You can set <code>r</code> to 0 if you’d like to see what happens otherwise.</p>
			<p>
				Each time you run the sketch, you get a different selection of amoebas. They all swarm toward your mouse pointer (although the current overpowers some of the large, slow ones), overlapping one another in the process. <a href="#figure10-18" id="figureanchor10-18">Figure 10-18</a> shows an example with eight amoebas.</p>
			<p>
				To add or remove amoebas, you can adjust the argument in the <code>range()</code> function of your first loop, and the loop in the <code>draw()</code> function will adapt dynamically. If your computer seems to be struggling, you can reduce the number of amoebas.</p>
				<span epub:type="pagebreak" id="Page_236" title="236"/>
				<figure>
				<img alt="f10018" src="image_fi/500969c10/f10018.png"/>
				<figcaption>
					<p><a id="figure10-18">Figure 10-18</a>: A display window with eight amoebas moving toward the mouse pointer</p>
				</figcaption>
			</figure>
			<h4 class="HeadProject"><span>Challenge #10: Collision Detection</span></h4>
			<p class="BodyFirst">The amoebas can overlap one another. To prevent this from happening, you must first detect where overlaps occur. From there, you can apply vector forces to push any colliding pairs apart.</p>
			<p>
				The amoebas are roughly circular, so a <em>circle-circle collision detection </em>algorithm will work nicely here. To understand how circle-circle collision detection works, refer to <a href="#figure10-19" id="figureanchor10-19">Figure 10-19</a>. The pair of circles on the left have not collided; on the right is a colliding pair. For the non-colliding circles, the distance between the centers of each circle is greater than the sum of the two radii (r1 and r2). Conversely, where the circles have collided, the distance is less than the sum of the two radii.</p>
			<figure>
				<img alt="f10019" src="image_fi/500969c10/f10019.png"/>
				<figcaption>
					<p><a id="figure10-19">Figure 10-19</a>: Circle-circle collision detection</p>
				</figcaption>
			</figure>
			<p>
				To test for collisions in Processing, you’ll need to check each amoeba against every other amoeba in the <code>amoebas</code> list. For this purpose, add another <code>for</code> loop within the <code>a in amoebas</code> loop:</p>
			<pre><code><span class="LiteralGray">    . . .</span><span class="LiteralGray">    for a in amoebas:</span><span class="LiteralGray">        . . .</span><span epub:type="pagebreak" id="Page_237" title="237"/> <span class="ProcessingOlive">for</span> b <span class="ProcessingTealGreen">in</span> amoebas: <span class="ProcessingOlive">if</span> a <span class="ProcessingTealGreen">is</span> b: <span class="ProcessingOlive">continue</span> <span class="ProcessingGray"># your solution goes here</span></code></pre>
			<p>
				You don’t want to check whether an amoeba is colliding with itself. At the top of the loop, there’s an <code>if a is b</code> test. The <code>is</code> operator compares the objects on either side of itself to determine whether they point to the same instance; if <code>a</code> is the same instance as <code>b</code>, this will evaluate as <code>True</code>. The <code>continue</code> line terminates the current iteration of the loop to start at the beginning of the next, so your “solution” code is skipped.</p>
			<p>
				Think about how you can use the distance vectors shown in <a href="#figure10-19">Figure 10-19</a> to push apart colliding amoebas. Can you add (or subtract) a fraction of the distance vector to push an amoeba in the opposite direction to the one it has collided with?</p>
			<p>
				If you need help, you can access the solution at <a class="LinkURL" href="https://github.com/tabreturn/processing.py-book/tree/master/chapter-10-object-oriented_programming_and_pvector/">https://github.com/tabreturn/processing.py-book/tree/master/chapter-10-object-oriented_programming_and_pvector/</a>.</p>
			<h2 id="h1-500969c10-0005">Summary</h2>
			<p class="BodyFirst">In this chapter, you learned how to use object-oriented programming to model real-world objects in Python. You defined a new <code>Amoeba</code> class, to which you added attributes and methods. A class serves as an object template, from which you can create countless instances. Grouping related variables (attributes) and functions (methods) into classes can help you structure code more efficiently. This is especially effective for programming larger, more complex projects.</p>
			<p>You also learned how to separate classes (and other code) into different Python files, called modules, and how to use those modules to share code between projects or as reusable components among files in the same project. Remember that modules reduce the line count of the main sketch, allowing you to focus on higher-level logic.</p>
			<p>
				This chapter also introduced Processing’s built-in <code>PVector</code> class for dealing with Euclidean vectors. A Euclidean vector describes a quantity that has both magnitude and direction, but you can also use a vector to store something’s location (as an x-y coordinate). In this chapter, you used vectors to simulate forces and control the positions of various objects in the display window.</p>
			<p>
				In the next chapter, you’ll learn how to handle mouse and keyboard interaction in Processing. I’ve already touched on the <code>mouseX</code> and <code>mouseY</code> system variables in this chapter. However, you can do much more with capturing mouse clicks and keypresses, unlocking exciting ways to interact with your Processing sketches.</p>
		</section>
	</body></html>