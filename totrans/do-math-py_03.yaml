- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**Describing Data with Statistics**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用统计学描述数据**'
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/common-01.jpg)'
- en: In this chapter, we’ll use Python to explore statistics so we can study, describe,
    and better understand sets of data. After looking at some basic statistical measures—the
    mean, median, mode, and range—we’ll move on to some more advanced measures, such
    as variance and standard deviation. Then, we’ll see how to calculate the correlation
    coefficient, which allows you to quantify the relationship between two sets of
    data. We’ll end the chapter by learning about scatter plots. Along the way, we’ll
    learn more about the Python language and standard library modules. Let’s get started
    with one of the most commonly used statistical measures—the mean.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python来探索统计学，以便研究、描述并更好地理解数据集。在介绍一些基本的统计度量——平均数、中位数、众数和极差——之后，我们将学习一些更高级的度量，例如方差和标准差。然后，我们将看到如何计算相关系数，它允许你量化两个数据集之间的关系。我们将通过学习散点图来结束本章。在这个过程中，我们将进一步了解Python语言和标准库模块。让我们从最常用的统计度量之一——平均数开始。
- en: '**NOTE**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In statistics, some statistical measures are calculated slightly differently
    depending on whether you have data for an entire population or just a sample.
    To keep things simple, we’ll stick with the calculation methods for a population
    in this chapter.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*在统计学中，一些统计度量的计算方法略有不同，具体取决于你是拥有整个群体的数据还是仅有样本数据。为了简化起见，本章我们将使用群体数据的计算方法。*'
- en: '**Finding the Mean**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**寻找平均数**'
- en: The *mean* is a common and intuitive way to summarize a set of numbers. It’s
    what we might simply call the “average” in everyday use, although as we’ll see,
    there are other kinds of averages as well. Let’s take a sample set of numbers
    and calculate the mean.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*平均数*是一个常见且直观的统计量。我们在日常生活中可能称它为“平均值”，尽管正如我们将看到的，还有其他类型的平均值。让我们以一组示例数字为例，来计算平均数。'
- en: 'Say there’s a school charity that’s been taking donations over a period of
    time spanning the last 12 days (we’ll refer to this as period A). In that time,
    the following 12 numbers represent the total dollar amount of donations received
    for each day: 100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, and 1200\.
    We can calculate the mean by summing these totals and then dividing the sum by
    the number of days. In this case, the sum of the numbers is 5733\. If we divide
    this number by 12 (the number of days), we get 477.75, which is the *mean* donation
    per day. This number gives us a general idea of how much money was donated on
    any given day.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个学校的慈善活动，在过去的12天里收到了捐款（我们将这段时间称为A期）。在这段时间里，以下12个数字代表每天收到的捐款总额：100、60、70、900、100、200、500、500、503、600、1000和1200。我们可以通过将这些总额相加，再除以天数来计算平均数。在这种情况下，数字的总和是5733。如果我们将这个数字除以12（天数），我们得到477.75，这就是每天的*平均*捐款额。这个数字为我们提供了一个大致的捐款金额。
- en: 'In a moment, we’ll write a program that calculates and prints the mean for
    a collection of numbers. As we just saw, to calculate the mean, we’ll need to
    take the sum of the list of numbers and divide it by the number of items in the
    list. Let’s look at two Python functions that make both of these operations very
    easy: sum() and len().'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个程序来计算并打印一组数字的平均数。正如我们刚刚看到的，计算平均数时，我们需要将数字列表的总和除以列表中的项数。让我们来看一下两个Python函数，它们可以非常方便地完成这两个操作：sum()和len()。
- en: 'When you use the sum() function on a list of numbers, it adds up all the numbers
    in the list and returns the result:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在数字列表上使用sum()函数时，它会将列表中的所有数字相加并返回结果：
- en: '>>> shortlist = [1, 2, 3]'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> shortlist = [1, 2, 3]'
- en: '>>> sum(shortlist)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> sum(shortlist)'
- en: '6'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 'We can use the len() function to give us the length of a list:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用len()函数来获得列表的长度：
- en: '>>> len(shortlist)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len(shortlist)'
- en: '3'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: When we use the len() function on the list, it returns 3 because there are three
    items in shortlist. Now we’re ready to write a program that will calculate the
    mean of the list of donations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对列表使用len()函数时，它会返回3，因为shortlist中有三个项。现在我们准备编写一个程序，计算捐款列表的平均数。
- en: ''''''''
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Calculating the mean
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 计算平均数
- en: ''''''''
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def calculate_mean(numbers):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculate_mean(numbers):'
- en: ➊     s = sum(numbers)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     s = sum(numbers)
- en: ➋     N = len(numbers)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     N = len(numbers)
- en: '# Calculate the mean'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算平均数'
- en: ➌     mean = s/N
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     mean = s/N
- en: return mean
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: return mean
- en: 'if __name__ == ''__main__'':'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: ➍     donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ➍     donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]
- en: ➎     mean = calculate_mean(donations)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ➎     mean = calculate_mean(donations)
- en: N = len(donations)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: N = len(donations)
- en: ➏     print('Mean donation over the last {0} days is {1}'.format(N, mean))
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ➏     print('过去{0}天的平均捐款额是{1}'.format(N, mean))
- en: First, we define a function, calculate_mean(), that accepts the argument numbers,
    which is a list of numbers. At ➊, we use the sum() function to add up the numbers
    in the list and create a label, s, to refer to the total. Similarly, at ➋, we
    use the len() function to get the length of the list and create a label, N, to
    refer to it. Then, as you can see at ➌, we calculate the mean by simply dividing
    the sum (s) by the number of members (N). At ➍, we create a list, donations, with
    the values of the donations listed earlier. We then call the calculate_mean()
    function, passing this list as an argument at ➎. Finally, we print the mean that
    was calculated at ➏.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个函数`calculate_mean()`，它接受一个参数`numbers`，这是一个数字列表。在➊处，我们使用`sum()`函数将列表中的数字相加，并创建一个标签`s`来表示总和。同样地，在➋处，我们使用`len()`函数来获取列表的长度，并创建一个标签`N`来表示它。然后，正如你在➌处看到的，我们通过将总和（s）除以元素数量（N）来计算平均值。在➍处，我们创建一个列表`donations`，其中包含之前列出的捐款数额。然后，我们调用`calculate_mean()`函数，在➎处传入该列表作为参数。最后，我们在➏处打印计算出的平均值。
- en: 'When you run the program, you should see the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，应该会看到以下内容：
- en: Mean donation over the last 12 days is 477.75
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 过去12天的平均捐款额是477.75
- en: The calculate_mean() function will calculate the sum and length of *any* list,
    so we can reuse it to calculate the mean for other sets of numbers, too.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate_mean()`函数将计算*任何*列表的总和和长度，因此我们也可以重复使用它来计算其他数字集合的平均值。'
- en: We calculated that the mean donation per day was 477.75\. It’s worth noting
    that the donations during the first few days were much lower than the mean donation
    we calculated and that the donations during the last couple of days were much
    higher. The mean gives us one way to summarize the data, but it doesn’t give us
    a full picture. There are other statistical measurements, however, that can tell
    us more about the data when compared with the mean.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算出每一天的平均捐款额为477.75。值得注意的是，最初几天的捐款远低于我们计算的平均捐款额，而最后几天的捐款则远高于平均值。平均数给我们提供了一种总结数据的方式，但它并不能提供完整的画面。然而，还有其他统计量可以在与平均数进行比较时，提供更多关于数据的信息。
- en: '**Finding the Median**'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**寻找中位数**'
- en: 'The *median* of a collection of numbers is another kind of average. To find
    the median, we sort the numbers in ascending order. If the length of the list
    of numbers is odd, the number in the middle of the list is the median. If the
    length of the list of numbers is even, we get the median by taking the mean of
    the two middle numbers. Let’s find the median of the previous list of donations:
    100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, and 1200.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数字集合的*中位数*是另一种类型的平均值。为了找到中位数，我们将数字按升序排列。如果列表中的数字个数是奇数，中间的数字就是中位数。如果列表中的数字个数是偶数，我们通过取中间两个数字的平均值来获得中位数。让我们来找一下之前捐款列表的中位数：100,
    60, 70, 900, 100, 200, 500, 500, 503, 600, 1000 和 1200。
- en: After sorting from smallest to largest, the list of numbers becomes 60, 70,
    100, 100, 200, 500, 500, 503, 600, 900, 1000, and 1200\. We have an even number
    of items in the list (12), so to get the median, we need to take the mean of the
    two middle numbers. In this case, the middle numbers are the sixth and the seventh
    numbers—500 and 500—and the mean of these two numbers is (500 + 500)/2, which
    comes out to 500\. That means the median is 500.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字从小到大排序后，数字列表变为60, 70, 100, 100, 200, 500, 500, 503, 600, 900, 1000 和 1200。我们列表中有一个偶数个元素（12个），所以为了得到中位数，我们需要取中间两个数字的平均值。在这种情况下，中间的两个数字是第六个和第七个数字——500和500——这两个数字的平均值是(500
    + 500)/2，结果为500。这意味着中位数是500。
- en: 'Now assume—just for this example—that we have another donation total for the
    13th day so that the list now looks like this: 100, 60, 70, 900, 100, 200, 500,
    500, 503, 600, 1000, 1200, and 800.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设—仅为了这个例子—我们在第13天有了另一笔捐款总额，因此列表现在看起来是这样的：100, 60, 70, 900, 100, 200, 500,
    500, 503, 600, 1000, 1200 和 800。
- en: Once again, we have to sort the list, which becomes 60, 70, 100, 100, 200, 500,
    500, 503, 600, 800, 900, 1000, and 1200\. There are 13 numbers in this list (an
    odd number), so the median for this list is simply the middle number. In this
    case, that’s the seventh number, which is 500.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，我们需要对列表进行排序，排序后列表变为60, 70, 100, 100, 200, 500, 500, 503, 600, 800, 900,
    1000 和 1200。这个列表中有13个数字（奇数个），所以这个列表的中位数就是中间的数字。在这种情况下，它是第七个数字，即500。
- en: Before we write a program to find the median of a list of numbers, let’s think
    about how we could automatically calculate the middle elements of a list in either
    case. If the length of a list (*N*) is odd, the middle number is the one in position
    (*N* + 1)/2\. If *N* is even, the two middle elements are *N*/2 and (*N*/2) +
    1\. For our first example in this section, *N* = 12, so the two middle elements
    were the 12/2 (sixth) and 12/2 + 1 (seventh) elements. In the second example,
    *N* = 13, so the seventh element, (*N* + 1)/2, was the middle element.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写一个程序来找到一组数字的中位数之前，让我们先考虑一下如何自动计算列表中的中间元素。在两种情况下，如果列表的长度 (*N*) 是奇数，中位数就是位置为
    (*N* + 1)/2 的数字。如果 *N* 是偶数，中位数则是位置为 *N*/2 和 (*N*/2) + 1 的两个中间元素。对于本节的第一个示例，*N*
    = 12，因此两个中间元素是 12/2（第六个）和 12/2 + 1（第七个）元素。在第二个示例中，*N* = 13，因此第七个元素（(*N* + 1)/2）是中位数。
- en: 'In order to write a function that calculates the median, we’ll also need to
    sort a list in ascending order. Luckily, the sort() method does just that:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个计算中位数的函数，我们还需要将列表按升序排序。幸运的是，sort() 方法正好可以实现这一点：
- en: '>>> samplelist = [4, 1, 3]'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> samplelist = [4, 1, 3]'
- en: '>>> samplelist.sort()'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> samplelist.sort()'
- en: '>>> samplelist'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> samplelist'
- en: '[1, 3, 4]'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 3, 4]'
- en: 'Now we can write our next program, which finds the median of a list of numbers:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写下一个程序，它会找到一组数字的中位数：
- en: ''''''''
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Calculating the median
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 计算中位数
- en: ''''''''
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def calculate_median(numbers):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculate_median(numbers):'
- en: ➊     N = len(numbers)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     N = len(numbers)
- en: ➋     numbers.sort()
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     numbers.sort()
- en: '# Find the median'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '# 找到中位数'
- en: 'if N % 2 == 0:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 N % 2 == 0:'
- en: '# if N is even'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果 N 是偶数'
- en: m1 = N/2
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: m1 = N / 2
- en: m2 = (N/2) + 1
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: m2 = (N / 2) + 1
- en: '# Convert to integer, match position'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '# 转换为整数，匹配位置'
- en: ➌         m1 = int(m1) - 1
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ➌         m1 = int(m1) - 1
- en: ➍         m2 = int(m2) - 1
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ➍         m2 = int(m2) - 1
- en: ➎         median = (numbers[m1] + numbers[m2])/2
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ➎         median = (numbers[m1] + numbers[m2]) / 2
- en: 'else:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: ➏         m = (N+1)/2
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ➏         m = (N + 1) / 2
- en: '# Convert to integer, match position'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '# 转换为整数，匹配位置'
- en: m = int(m) - 1
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: m = int(m) - 1
- en: median = numbers[m]
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: median = numbers[m]
- en: return median
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: return median
- en: 'if __name__ == ''__main__'':'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]
- en: median = calculate_median(donations)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: median = calculate_median(donations)
- en: N = len(donations)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: N = len(donations)
- en: print('Median donation over the last {0} days is {1}'.format(N, median))
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: print('过去 {0} 天的中位数捐赠额是 {1}'.format(N, median))
- en: The overall structure of the program is similar to that of the earlier program
    that calculates the mean. The calculate_median() function accepts a list of numbers
    and returns the median. At ➊, we calculate the length of the list and create a
    label, N, to refer to it. Next, at ➋, we sort the list using the sort() method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的整体结构类似于前面计算平均值的程序。calculate_median() 函数接受一个数字列表并返回中位数。在 ➊ 处，我们计算列表的长度，并创建一个标签
    N 来表示它。接下来，在 ➋ 处，我们使用 sort() 方法对列表进行排序。
- en: 'Then, we check to see whether N is even. If so, we find the middle elements,
    m1 and m2, which are the numbers at positions N/2 and (N/2) + 1 in the sorted
    list. The next two statements (➌ and ➍) adjust m1 and m2 in two ways. First, we
    use the int() function to convert m1 and m2 into integer form. This is because
    results of the division operator are always returned as floating point numbers,
    even when the result is equivalent to an integer. For example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查 N 是否为偶数。如果是，我们找到中间的元素 m1 和 m2，它们是排序列表中位置为 N / 2 和 (N / 2) + 1 的数字。接下来的两条语句（➌
    和 ➍）通过两种方式调整 m1 和 m2。首先，我们使用 int() 函数将 m1 和 m2 转换为整数形式。因为即使除法结果等于整数，除法运算符的结果总是返回浮点数。例如：
- en: '>>> 6/2'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 6 / 2'
- en: '3.0'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '3.0'
- en: We cannot use a floating point number as an index in a list, so we use int()
    to convert that result to an integer. We also subtract 1 from both m1 and m2 because
    positions in a list begin with 0 in Python. This means that to get the sixth and
    seventh numbers from the list, we have to ask for the numbers at index 5 and index
    6\. At ➎, we calculate the median by taking the mean of the two numbers in the
    middle positions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将浮点数作为列表的索引，因此我们使用 int() 将结果转换为整数。我们还从 m1 和 m2 中分别减去 1，因为在 Python 中列表的索引是从
    0 开始的。这意味着为了从列表中获取第六个和第七个数字，我们必须请求索引为 5 和 6 的数字。在 ➎ 处，我们通过计算中间位置两个数字的平均值来得出中位数。
- en: 'Starting at ➏, the program finds the median if there’s an odd number of items
    in the list, once again using int() and subtracting 1 to find the proper index.
    Finally, the program calculates the median for the list of donations and returns
    it. When you execute the program, it calculates that the median is 500:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从➏开始，程序会查找中位数，如果列表中的项数是奇数，它会再次使用int()并减去1来找到正确的索引。最后，程序会计算捐赠列表的中位数并返回。当你执行程序时，它会计算出中位数是500：
- en: Median donation over the last 12 days is 500.0
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 过去12天的中位数捐赠为500.0
- en: As you can see, the mean (477.75) and the median (500) are pretty close in this
    particular list, but the median is a little higher.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在这个特定的列表中，平均数（477.75）和中位数（500）非常接近，但中位数稍微高一点。
- en: '**Finding the Mode and Creating a Frequency Table**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**寻找众数并创建频率表**'
- en: 'Instead of finding the mean value or the median value of a set of numbers,
    what if you wanted to find the number that occurs most frequently? This number
    is called the *mode*. For example, consider the test scores of a math test (out
    of 10 points) in a class of 20 students: 7, 8, 9, 2, 10, 9, 9, 9, 9, 4, 5, 6,
    1, 5, 6, 7, 8, 6, 1, and 10\. The mode of this list would tell you which score
    was the most common in the class. From the list, you can see that the score of
    9 occurs most frequently, so 9 is the mode for this list of numbers. There’s no
    symbolic formula for calculating the mode—you simply count how many times each
    unique number occurs and find the one that occurs the most.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想找到一组数字的平均值或中位数，而是想找出出现频率最高的数字呢？这个数字叫做*众数*。例如，考虑一下20名学生在一次数学测试中的成绩（满分10分）：7,
    8, 9, 2, 10, 9, 9, 9, 9, 4, 5, 6, 1, 5, 6, 7, 8, 6, 1 和 10。这个列表的众数可以告诉你班上最常见的成绩是什么。从这个列表可以看出，9出现的次数最多，因此9是这个数字列表的众数。没有一个固定的公式来计算众数——你只需要统计每个唯一数字出现的次数，并找出出现最多的那个。
- en: To write a program to calculate the mode, we’ll need to have Python count how
    many times each number occurs within a list and print the one that occurs most
    frequently. The Counter class from the collections module, which is part of the
    standard library, makes this really simple for us.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个计算众数的程序，我们需要让Python计算每个数字在列表中出现的次数，并打印出出现最频繁的那个数字。collections模块中的Counter类是标准库的一部分，它使这个任务变得非常简单。
- en: '***Finding the Most Common Elements***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***寻找最常见的元素***'
- en: 'Finding the most common number in a data set can be thought of as a subproblem
    of finding an arbitrary number of most common numbers. For instance, instead of
    the most common score, what if you wanted to know the five most common scores?
    The most_common() method of the Counter class allows us to answer such questions
    easily. Let’s see an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据集里找到最常见的数字可以看作是找出若干个最常见数字的子问题。例如，如果你不仅想找出最常见的成绩，而是想知道五个最常见的成绩呢？Counter类的most_common()方法使得我们能够轻松地回答这样的问题。让我们来看一个例子：
- en: '>>> simplelist = [4, 2, 1, 3, 4]'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> simplelist = [4, 2, 1, 3, 4]'
- en: '>>> from collections import Counter'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from collections import Counter'
- en: '>>> c = Counter(simplelist)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c = Counter(simplelist)'
- en: '>>> c.most_common()'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c.most_common()'
- en: '[(4, 2), (1, 1), (2, 1), (3, 1)]'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[(4, 2), (1, 1), (2, 1), (3, 1)]'
- en: Here, we start off with a list of five numbers and import Counter from the collections
    module. Then, we create a Counter object, using c to refer to the object. We then
    call the most_common() method, which returns a list ordered by the most common
    elements.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们从一个包含五个数字的列表开始，并从collections模块导入Counter。然后，我们创建一个Counter对象，使用c来引用这个对象。接着，我们调用most_common()方法，它返回一个按最常见元素排序的列表。
- en: Each member of the list is a tuple. The first element of the first tuple is
    the number that occurs most frequently, and the second element is the number of
    times it occurs. The second, third, and fourth tuples contain the other numbers
    along with the count of the number of times they appear. This result tells us
    that 4 occurs the most (twice), while the others appear only once. Note that numbers
    that occur an equal number of times are returned by the most_common() method in
    an arbitrary order.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个元素都是一个元组。第一个元组的第一个元素是最常见的数字，第二个元素是它出现的次数。第二、第三和第四个元组包含其他数字以及它们出现的次数。这个结果告诉我们4出现的次数最多（两次），而其他数字只出现了一次。请注意，出现次数相同的数字会按照任意顺序返回。
- en: 'When you call the most_common() method, you can also provide an argument telling
    it the number of most common elements you want it to return. For example, if we
    just wanted to find the most common element, we would call it with the argument
    1:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`most_common()`方法时，你还可以提供一个参数，告诉它你想返回多少个最常见的元素。例如，如果我们只想找到最常见的元素，我们会传入参数1：
- en: '>>> c.most_common(1)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c.most_common(1)'
- en: '[(4, 2)]'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[(4, 2)]'
- en: 'If you call the method again with 2 as an argument, you’ll see this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次调用这个方法，并传入2作为参数，你将看到如下结果：
- en: '>>> c.most_common(2)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c.most_common(2)'
- en: '[(4, 2), (1, 1)]'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[(4, 2), (1, 1)]'
- en: Now the result returned by the most_common method is a list with two tuples.
    The first is the most common element, followed by the second most common. Of course,
    in this case, there are several elements tied for most common, so the fact that
    the function returns 1 here (and not 2 or 3) is arbitrary, as noted earlier.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`most_common`方法返回的结果是一个包含两个元组的列表。第一个是出现最频繁的元素，紧随其后的是第二个最频繁的元素。当然，在这种情况下，有几个元素的出现频率相同，因此函数返回1（而不是2或3）是任意的，正如之前所提到的。
- en: 'The most_common() method returns both the numbers and the number of times they
    occur. What if we want only the numbers and we don’t care about the number of
    times they occur? Here’s how we can retrieve that information:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`most_common()`方法返回的是数字及其出现次数。如果我们只想要数字，而不关心它们出现的次数，该怎么办呢？我们可以这样获取这些信息：'
- en: ➊ >>> mode = c.most_common(1)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> mode = c.most_common(1)
- en: '>>> mode'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> mode'
- en: '[(4, 2)]'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[(4, 2)]'
- en: ➋ >>> mode[0]
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> mode[0]
- en: (4, 2)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: (4, 2)
- en: ➌ >>> mode[0][0]
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> mode[0][0]
- en: '4'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: At ➊, we use the label mode to refer to the result returned by the most_common()
    method. We retrieve the first (and the only) element of this list with mode[0]
    ➋, which gives us a tuple. Because we just want the first element of the tuple,
    we can retrieve that using mode[0][0] ➌. This returns 4— the most common element,
    or the mode.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们使用`mode`标签来表示`most_common()`方法返回的结果。我们通过`mode[0]` ➋来获取这个列表的第一个（也是唯一一个）元素，得到一个元组。因为我们只需要元组中的第一个元素，所以我们可以通过`mode[0][0]`
    ➌来提取这个元素。这个值是4——即最常见的元素，或者说是众数。
- en: Now that we know how the most_common() method works, we’ll apply it to solve
    the next two problems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了`most_common()`方法的工作原理，我们将应用它来解决接下来的两个问题。
- en: '***Finding the Mode***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***寻找众数***'
- en: 'We’re ready to write a program that finds the mode for a list of numbers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好编写一个程序来查找一组数字的众数了：
- en: ''''''''
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Calculating the mode
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 计算众数
- en: ''''''''
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from collections import Counter
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: from collections import Counter
- en: 'def calculate_mode(numbers):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculate_mode(numbers):'
- en: ➊     c = Counter(numbers)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     c = Counter(numbers)
- en: ➋     mode = c.most_common(1)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     mode = c.most_common(1)
- en: ➌     return mode[0][0]
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     return mode[0][0]
- en: 'if __name__==''__main__'':'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__==''__main__'':'
- en: scores = [7,8,9,2,10,9,9,9,9,4,5,6,1,5,6,7,8,6,1,10]
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: scores = [7,8,9,2,10,9,9,9,9,4,5,6,1,5,6,7,8,6,1,10]
- en: mode = calculate_mode(scores)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: mode = calculate_mode(scores)
- en: print('The mode of the list of numbers is: {0}'.format(mode))
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: print('这个数字列表的众数是：{0}'.format(mode))
- en: 'The calculate_mode() function finds and returns the mode of the numbers passed
    to it as a parameter. To calculate the mode, we first import the class Counter
    from the collections module and use it to create a Counter object at ➊. Then,
    at ➋, we use the most_common() method, which, as we saw earlier, gives us a list
    that contains a tuple with the most common number and the number of times it occurs.
    We assign that list the label mode. Finally, we use mode[0][0] ➌ to access the
    number we want: the most frequent number from the list, which is the mode.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate_mode()`函数找到并返回传入的数字的众数。为了计算众数，我们首先从`collections`模块导入`Counter`类，并用它在➊创建一个`Counter`对象。然后，在➋，我们使用`most_common()`方法，正如之前所见，它返回一个包含元组的列表，元组里包含最常见的数字及其出现次数。我们将这个列表命名为`mode`。最后，我们使用`mode[0][0]`
    ➌来获取我们想要的数字：列表中出现次数最多的数字，即众数。'
- en: 'The rest of the program applies the calculate_mode function to the list of
    test scores we saw earlier. When you run the program, you should see the following
    output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分应用`calculate_mode`函数处理我们之前看到的测试分数列表。运行程序后，你应该会看到以下输出：
- en: The mode of the list of numbers is: 9
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字列表的众数是：9
- en: 'What if you have a set of data where two or more numbers occur the same maximum
    number of times? For example, in the list of numbers 5, 5, 5, 4, 4, 4, 9, 1, and
    3, both 4 and 5 are present three times. In such cases, the list of numbers is
    said to have multiple modes, and our program should find and print all the modes.
    The modified program follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据集中有两个或多个数字出现次数相同，并且是最大出现次数呢？例如，在数字列表[5, 5, 5, 4, 4, 4, 9, 1, 3]中，4和5都出现了三次。在这种情况下，数字列表被称为具有多个众数，我们的程序应该找出并打印所有众数。修改后的程序如下：
- en: ''''''''
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Calculating the mode when the list of numbers may
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当数字列表可能发生变化时，计算众数
- en: have multiple modes
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个众数
- en: ''''''''
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from collections import Counter
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: from collections import Counter
- en: 'def calculate_mode(numbers):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculate_mode(numbers):'
- en: c = Counter(numbers)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: c = Counter(numbers)
- en: ➊     numbers_freq = c.most_common()
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     numbers_freq = c.most_common()
- en: ➋     max_count = numbers_freq[0][1]
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     max_count = numbers_freq[0][1]
- en: modes = []
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: modes = []
- en: 'for num in numbers_freq:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'for num in numbers_freq:'
- en: '➌         if num[1] == max_count:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '➌         if num[1] == max_count:'
- en: modes.append(num[0])
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: modes.append(num[0])
- en: return modes
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: return modes
- en: 'if __name__ == ''__main__'':'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: scores = [5, 5, 5, 4, 4, 4, 9, 1, 3]
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: scores = [5, 5, 5, 4, 4, 4, 9, 1, 3]
- en: modes = calculate_mode(scores)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: modes = calculate_mode(scores)
- en: print('The mode(s) of the list of numbers are:')
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: print('该数字列表的众数是：')
- en: '➍     for mode in modes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '➍     for mode in modes:'
- en: print(mode)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: print(mode)
- en: At ➊, instead of finding only the most common element, we retrieve all the numbers
    and the number of times each appears. Next, at ➋, we find the value of the maximum
    count—that is, the maximum number of times any number occurs. Then, for each of
    the numbers, we check whether the number of times it appears is equal to the maximum
    count ➌. Each number that fulfills this condition is a mode, and we add it to
    the list modes and return the list.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们不仅仅找出最常见的元素，而是获取所有数字及其出现次数。接下来，在 ➋ 处，我们找出最大出现次数的值——即任何数字出现的最大次数。然后，对于每个数字，我们检查它出现的次数是否等于最大出现次数
    ➌。每个满足这个条件的数字就是众数，我们将其添加到众数列表中并返回该列表。
- en: At ➍, we iterate over the list returned from the calculate_mode() function and
    print each of the numbers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➍ 处，我们遍历 calculate_mode() 函数返回的列表，并打印每个数字。
- en: 'When you execute the preceding program, you should see the following output:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行上述程序时，应该会看到以下输出：
- en: 'The mode(s) of the list of numbers are:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该数字列表的众数是：
- en: '4'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: What if you wanted to find the number of times every number occurs instead of
    just the mode? A *frequency table*, as the name indicates, is a table that shows
    how many times each number occurs within a collection of numbers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想找出每个数字出现的次数，而不仅仅是众数怎么办？*频率表*，顾名思义，是一个展示每个数字在数字集合中出现次数的表格。
- en: '***Creating a Frequency Table***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建频率表***'
- en: 'Let’s consider the list of test scores again: 7, 8, 9, 2, 10, 9, 9, 9, 9, 4,
    5, 6, 1, 5, 6, 7, 8, 6, 1, and 10\. The frequency table for this list is shown
    in [Table 3-1](ch03.html#ch3tab1). For each number, we list the number of times
    it occurs in the second column.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑测试分数列表：7、8、9、2、10、9、9、9、9、4、5、6、1、5、6、7、8、6、1 和 10。该列表的频率表显示在 [表格 3-1](ch03.html#ch3tab1)
    中。对于每个数字，我们列出它在第二列中的出现次数。
- en: '**Table 3-1:** Frequency Table'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 3-1：** 频率表'
- en: '| **Score** | **Frequency** |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **得分** | **频率** |'
- en: '| --- | --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 2 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 |'
- en: '| 2 | 1 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 |'
- en: '| 4 | 1 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1 |'
- en: '| 5 | 2 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2 |'
- en: '| 6 | 3 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 3 |'
- en: '| 7 | 2 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 2 |'
- en: '| 8 | 2 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 2 |'
- en: '| 9 | 5 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 5 |'
- en: '| 10 | 2 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 2 |'
- en: Note that the sum of the individual frequencies in the second column adds up
    to the total number of scores (in this case, 20).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第二列中各个频率的总和等于总的分数数量（在这个例子中是 20）。
- en: We’ll use the most_common() method once again to print the frequency table for
    a given set of numbers. Recall that when we don’t supply an argument to the most_common()
    method, it returns a list of tuples with all the numbers and the number of times
    they appear. We can simply print each number and its frequency from this list
    to display a frequency table.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 most_common() 方法来打印给定数字集合的频率表。回顾一下，当我们不为 most_common() 方法提供参数时，它会返回一个包含所有数字及其出现次数的元组列表。我们可以直接从这个列表打印每个数字及其频率，从而展示频率表。
- en: 'Here’s the program:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序：
- en: ''''''''
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Frequency table for a list of numbers
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 数字列表的频率表
- en: ''''''''
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from collections import Counter
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: from collections import Counter
- en: 'def frequency_table(numbers):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'def frequency_table(numbers):'
- en: ➊     table = Counter(numbers)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     table = Counter(numbers)
- en: print('Number\tFrequency')
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: print('数字\t频率')
- en: '➋     for number in table.most_common():'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '➋     for number in table.most_common():'
- en: print('{0}\t{1}'.format(number[0], number[1]))
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: print('{0}\t{1}'.format(number[0], number[1]))
- en: 'if __name__==''__main__'':'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__==''__main__'':'
- en: scores = [7,8,9,2,10,9,9,9,9,4,5,6,1,5,6,7,8,6,1,10]
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: scores = [7,8,9,2,10,9,9,9,9,4,5,6,1,5,6,7,8,6,1,10]
- en: frequency_table(scores)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: frequency_table(scores)
- en: 'The function frequency_table() prints the frequency table of the list of numbers
    passed to it. At ➊, we first create a Counter object and create the label table
    to refer to it. Next, using a for loop ➋, we go through each of the tuples, printing
    the first member (the number itself) and the second member (the frequency of the
    corresponding number). We use \t to print a tab between each value to space the
    table. When you run the program, you’ll see the following output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: frequency_table() 函数打印传递给它的数字列表的频率表。在 ➊，我们首先创建一个 Counter 对象并创建标签表来引用它。接下来，使用
    `for` 循环 ➋，我们遍历每个元组，打印第一个成员（数字本身）和第二个成员（对应数字的频率）。我们使用 `\t` 在每个值之间打印一个制表符来间隔表格。当你运行程序时，你会看到以下输出：
- en: Number  Frequency
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 数字    频率
- en: 9       5
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 9       5
- en: 6       3
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 6       3
- en: 1       2
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 1       2
- en: 5       2
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 5       2
- en: 7       2
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 7       2
- en: 8       2
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 8       2
- en: 10      2
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 10      2
- en: 2       1
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 2       1
- en: 4       1
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 4       1
- en: Here, you can see that the numbers are listed in decreasing order of frequency
    because the most_common() function returns the numbers in this order. If, instead,
    you want your program to print the frequency table sorted by value from lowest
    to highest, as shown in [Table 3-1](ch03.html#ch3tab1), you’ll have to re-sort
    the list of tuples.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到数字按频率降序排列，因为 `most_common()` 函数返回的是这种顺序。如果你希望程序按值从低到高排序打印频率表，如[表格 3-1](ch03.html#ch3tab1)所示，那么你需要重新排序元组列表。
- en: 'The sort() method is all we need to modify our earlier frequency table program:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()` 方法是我们修改之前频率表程序所需的全部内容：'
- en: ''''''''
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Frequency table for a list of numbers
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 数字列表的频率表
- en: Enhanced to display the table sorted by the numbers
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 增强功能以按数字排序显示表格
- en: ''''''''
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: from collections import Counter
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: from collections import Counter
- en: 'def frequency_table(numbers):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'def frequency_table(numbers):'
- en: table = Counter(numbers)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: table = Counter(numbers)
- en: ➊     numbers_freq = table.most_common()
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     numbers_freq = table.most_common()
- en: ➋     numbers_freq.sort()
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     numbers_freq.sort()
- en: print('Number\tFrequency')
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: print('数字\t频率')
- en: '➌     for number in numbers_freq:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '➌     for number in numbers_freq:'
- en: print('{0}\t{1}'.format(number[0], number[1]))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: print('{0}\t{1}'.format(number[0], number[1]))
- en: 'if __name__ == ''__main__'':'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: scores = [7,8,9,2,10,9,9,9,9,4,5,6,1,5,6,7,8,6,1,10]
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: scores = [7,8,9,2,10,9,9,9,9,4,5,6,1,5,6,7,8,6,1,10]
- en: frequency_table(scores)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: frequency_table(scores)
- en: 'Here, we store the list returned by the most_common() method in numbers_freq
    at ➊, and then we sort it by calling the sort() method ➋. Finally, we use the
    for loop to go over the sorted tuples and print each number and its frequency
    ➌. Now when you run the program, you’ll see the following table, which is identical
    to [Table 3-1](ch03.html#ch3tab1):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过调用 `most_common()` 方法返回的列表存储在 `numbers_freq` 中，标记为 ➊，然后通过调用 `sort()`
    方法对其进行排序 ➋。最后，我们使用 `for` 循环遍历已排序的元组，并打印每个数字及其频率 ➌。现在，当你运行程序时，你会看到以下表格，它与[表格 3-1](ch03.html#ch3tab1)完全相同：
- en: Number  Frequency
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 数字    频率
- en: 1       2
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 1       2
- en: 2       1
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 2       1
- en: 4       1
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 4       1
- en: 5       2
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 5       2
- en: 6       3
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 6       3
- en: 7       2
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 7       2
- en: 8       2
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 8       2
- en: 9       5
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 9       5
- en: 10      2
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 10      2
- en: In this section, we’ve covered mean, median, and mode, which are three common
    measures for describing a list of numbers. Each of these can be useful, but they
    can also hide other aspects of the data when considered in isolation. Next, we’ll
    look at other, more advanced statistical measures that can help us draw more conclusions
    about a collection of numbers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经讨论了均值、中位数和众数，它们是描述数字列表的三种常见度量。每个度量都有其用处，但当单独考虑时，它们也可能掩盖数据的其他方面。接下来，我们将讨论其他更高级的统计度量，这些度量可以帮助我们对数字集合得出更多结论。
- en: '**Measuring the Dispersion**'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**衡量离散程度**'
- en: 'The next statistical calculations we’ll look at measure the *dispersion*, which
    tells us how far away the numbers in a set of data are from the mean of the data
    set. We’ll learn to calculate three different measurements of dispersion: range,
    variance, and standard deviation.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要讨论的统计计算是衡量*离散程度*，它告诉我们数据集中的数字与数据集均值的距离。我们将学习如何计算三种不同的离散度量：极差、方差和标准差。
- en: '***Finding the Range of a Set of Numbers***'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***找出数字集合的极差***'
- en: 'Once again, consider the list of donations during period A: 100, 60, 70, 900,
    100, 200, 500, 500, 503, 600, 1000, and 1200\. We found that the mean donation
    per day is 477.75\. But just looking at the mean, we have no idea whether all
    the donations fell into a narrow range—say between 400 and 500—or whether they
    varied much more than that—say between 60 and 1200, as in this case. For a list
    of numbers, the *range* is the difference between the highest number and the lowest
    number. You could have two groups of numbers with the exact same mean but with
    vastly different ranges, so knowing the range fills in more information about
    a set of numbers beyond what we can learn from just looking at the mean, median,
    and mode.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑A期间的捐赠列表：100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000和1200。我们发现每天的平均捐赠为477.75。但仅仅看平均值，我们无法知道所有捐赠是否集中在一个较小的范围内——比如400到500之间——还是在更广泛的范围内变化——比如60到1200，如本例所示。对于一组数字，*范围*是最大值与最小值之间的差异。你可能有两个平均值相同的数字组，但它们的范围却差异很大，因此知道范围能提供比仅仅看平均值、中位数和众数更多的信息。
- en: 'The next program finds the range of the preceding list of donations:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个程序计算前面提到的捐赠列表的范围：
- en: ''''''''
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Find the range
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 计算范围
- en: ''''''''
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def find_range(numbers):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'def find_range(numbers):'
- en: ➊     lowest = min(numbers)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     lowest = min(numbers)
- en: ➋     highest = max(numbers)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ➋     highest = max(numbers)
- en: '# Find the range'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算范围'
- en: r = highest-lowest
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: r = highest - lowest
- en: ➌     return lowest, highest, r
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     return lowest, highest, r
- en: 'if __name__ == ''__main__'':'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]
- en: ➍     lowest, highest, r = find_range(donations)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ➍     lowest, highest, r = find_range(donations)
- en: print('Lowest: {0} Highest: {1} Range: {2}'.format(lowest, highest, r))
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''最小值: {0} 最大值: {1} 范围: {2}''.format(lowest, highest, r))'
- en: The function find_range() accepts a list as a parameter and finds the range.
    First, it calculates the lowest and the highest numbers using the min() and the
    max() functions at ➊ and ➋. As the function names indicate, they find the minimum
    and the maximum values in a list of numbers.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 函数find_range()接受一个列表作为参数并计算范围。首先，它使用min()和max()函数分别在➊和➋计算出最小值和最大值。正如函数名所示，它们分别找到数字列表中的最小值和最大值。
- en: 'We then calculate the range by taking the difference between the highest and
    the lowest numbers, using the label r to refer to this difference. At ➌, we return
    all three numbers—the lowest number, the highest number, and the range. This is
    the first time in the book that we’re returning multiple values from a function—instead
    of just returning one value, this function returns three. At ➍, we use three labels
    to *receive* the three values being returned from the find_range() function. Finally,
    we print the values. When you run the program, you should see the following output:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过计算最大值和最小值之间的差异来计算范围，并用标签r表示这个差异。在➌处，我们返回所有三个数字——最小值、最大值和范围。这是本书中第一次从一个函数返回多个值——而不是仅返回一个值，这个函数返回三个值。在➍处，我们使用三个标签来*接收*从find_range()函数返回的三个值。最后，我们打印这些值。当你运行程序时，应该会看到以下输出：
- en: Lowest: 60 Highest: 1200 Range: 1140
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '最小值: 60 最大值: 1200 范围: 1140'
- en: This tells us that the days’ total donations were fairly spread out, with a
    range of 1140, because we had daily totals as small as 60 and as large as 1200.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，捐赠总额在几天内分布较为均匀，范围为1140，因为我们每天的捐赠总额从60到1200不等。
- en: '***Finding the Variance and Standard Deviation***'
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算方差和标准差***'
- en: 'The range tells us the difference between the two extremes in a set of numbers,
    but what if we want to know more about how all of the individual numbers vary
    from the mean? Were they all similar, clustered near the mean, or were they all
    different, closer to the extremes? There are two related measures of dispersion
    that tell us more about a list of numbers along these lines: the *variance* and
    the *standard deviation*. To calculate either of these, we first need to find
    the difference of each of the numbers from the mean. The variance is the average
    of the squares of those differences. A high variance means that values are far
    from the mean; a low variance means that the values are clustered close to the
    mean. We calculate the variance using the formula'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 极差告诉我们一组数字中两个极值之间的差异，但如果我们想了解所有单个数字与平均值的偏差呢？它们是否都相似，集中在平均值附近，还是它们都很不同，更接近极值？有两个相关的离散度度量可以帮助我们了解这些数字的分布：*方差*
    和 *标准差*。要计算这两个度量中的任何一个，首先需要找到每个数字与平均值的差异。方差是这些差异平方的平均值。较高的方差意味着数值远离平均值；较低的方差意味着数值集中在平均值附近。我们使用以下公式来计算方差。
- en: '![image](images/e0073-01.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0073-01.jpg)'
- en: In the formula, *x[i]* stands for individual numbers (in this case, daily total
    donations), *x*[mean] stands for the mean of these numbers (the mean daily donation),
    and *n* is the number of values in the list (the number of days on which donations
    were received). For each value in the list, we take the difference between that
    number and the mean and square it. Then, we add all those squared differences
    together and, finally, divide the whole sum by *n* to find the variance.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在公式中，*x[i]* 代表单个数字（在此情况下为每日总捐款），*x*[mean] 代表这些数字的平均值（每日平均捐款），*n* 是列表中的值的数量（即接受捐款的天数）。对于列表中的每个值，我们计算该数字与平均值的差异并将其平方。然后，我们将所有这些平方差加在一起，最后用
    *n* 除以总和，得到方差。
- en: If we want to calculate the standard deviation as well, all we have to do is
    take the square root of the variance. Values that are within one standard deviation
    of the mean can be thought of as fairly typical, whereas values that are three
    or more standard deviations away from the mean can be considered much more atypical—we
    call such values *outliers*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想计算标准差，所需要做的就是取方差的平方根。那些在平均值一个标准差以内的数值可以认为是相当典型的，而那些离平均值三个或更多标准差远的数值则可以被视为更不典型——我们称这样的数值为
    *离群值*。
- en: Why do we have these two measures of dispersion—variance and standard deviation?
    In short, the two measures are useful in different situations. Going back to the
    formula we used to calculate the variance, you can see that the variance is expressed
    in square units because it’s the average of the squared difference from the mean.
    For some mathematical formulas, it’s nicer to work with those square units instead
    of taking the square root to find the standard deviation. On the other hand, the
    standard deviation is expressed in the same units as the population data. For
    example, if you calculate the variance for our list of donations (as we will in
    a moment), the result is expressed in dollars squared, which doesn’t make a lot
    of sense. Meanwhile, the standard deviation is simply expressed in dollars, the
    same unit as each of the donations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要这两种离散度度量——方差和标准差？简而言之，这两个度量在不同情况下各有用处。回到我们用于计算方差的公式，你可以看到方差以平方单位表示，因为它是与平均值差异的平方的平均值。对于某些数学公式，使用这些平方单位而不是取平方根来计算标准差会更加方便。另一方面，标准差以与总体数据相同的单位表示。例如，如果我们计算捐款列表的方差（就像我们接下来要做的那样），结果将以“美元平方”表示，这并不太有意义。而标准差则直接以“美元”表示，与每笔捐款的单位相同。
- en: 'The following program finds the variance and standard deviation for a list
    of numbers:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序用于计算一组数字的方差和标准差：
- en: ''''''''
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: Find the variance and standard deviation of a list of numbers
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一组数字的方差和标准差
- en: ''''''''
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''''
- en: 'def calculate_mean(numbers):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculate_mean(numbers):'
- en: s = sum(numbers)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: s = sum(numbers)
- en: N = len(numbers)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: N = len(numbers)
- en: '# Calculate the mean'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算平均值'
- en: mean = s/N
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: mean = s / N
- en: return mean
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: return mean
- en: 'def find_differences(numbers):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'def find_differences(numbers):'
- en: '# Find the mean'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算平均值'
- en: mean = calculate_mean(numbers)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: mean = calculate_mean(numbers)
- en: '# Find the differences from the mean'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '# 找出与平均值的差异'
- en: diff = []
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: diff = []
- en: 'for num in numbers:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 'for num in numbers:'
- en: diff.append(num-mean)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: diff.append(num - mean)
- en: return diff
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: return diff
- en: 'def calculate_variance(numbers):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'def calculate_variance(numbers):'
- en: '# Find the list of differences'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '# 找出差异列表'
- en: ➊     diff = find_differences(numbers)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ➊     diff = find_differences(numbers)
- en: '# Find the squared differences'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算平方差'
- en: squared_diff = []
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: squared_diff = []
- en: '➋     for d in diff:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '➋     for d in diff:'
- en: squared_diff.append(d**2)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: squared_diff.append(d**2)
- en: '# Find the variance'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算方差'
- en: sum_squared_diff = sum(squared_diff)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: sum_squared_diff = sum(squared_diff)
- en: ➌     variance = sum_squared_diff/len(numbers)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ➌     variance = sum_squared_diff/len(numbers)
- en: return variance
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: return variance
- en: 'if __name__ == ''__main__'':'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]
- en: variance = calculate_variance(donations)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: variance = calculate_variance(donations)
- en: print('The variance of the list of numbers is {0}'.format(variance))
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: print('这个数字列表的方差是{0}'.format(variance))
- en: ➍     std = variance**0.5
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ➍     std = variance**0.5
- en: print('The standard deviation of the list of numbers is {0}'.format(std))
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: print('这个数字列表的标准差是{0}'.format(std))
- en: The function calculate_variance() calculates the variance of the list of numbers
    passed to it. First, it calls the find_differences() function at ➊ to calculate
    the difference of each of the numbers from the mean. The find_differences() function
    returns the difference of each donation from the mean value as a list. In this
    function, we use the calculate_mean() function we wrote earlier to find the mean
    donation. Then, starting at ➋, the squares of these differences are calculated
    and saved in a list labeled squared_diff. Next, we use the sum() function to find
    the sum of the squared differences and, finally, calculate the variance at ➌.
    At ➍, we calculate the standard deviation by taking the square root of the variance.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 函数calculate_variance()计算传递给它的数字列表的方差。首先，它在➊调用find_differences()函数来计算每个数字与平均值之间的差异。find_differences()函数返回每个捐款与平均值之间的差异，作为一个列表。在这个函数中，我们使用之前写的calculate_mean()函数来计算平均捐款。接下来，从➋开始，计算这些差异的平方，并将结果保存到一个名为squared_diff的列表中。然后，我们使用sum()函数计算这些平方差的总和，最后在➌处计算方差。在➍处，我们通过取方差的平方根来计算标准差。
- en: 'When you run the preceding program, you should see the following output:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的程序时，应该会看到以下输出：
- en: The variance of the list of numbers is 141047.35416666666
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字列表的方差是141047.35416666666
- en: The standard deviation of the list of numbers is 375.5627166887931
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字列表的标准差是375.5627166887931
- en: 'The variance and the standard deviation are both very large, meaning that the
    individual daily total donations vary greatly from the mean. Now, let’s compare
    the variance and the standard deviation for a different set of donations that
    have the same mean: 382, 389, 377, 397, 396, 368, 369, 392, 398, 367, 393, and
    396\. In this case, the variance and the standard deviation turn out to be 135.38888888888889
    and 11.63567311713804, respectively. Lower values for variance and standard deviation
    tell us that the individual numbers are closer to the mean. [Figure 3-1](ch03.html#ch3fig1)
    illustrates this point visually.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 方差和标准差都非常大，这意味着单个每日捐赠总额与平均值的偏差很大。现在，让我们比较另一组具有相同平均值的捐款：382、389、377、397、396、368、369、392、398、367、393和396。在这种情况下，方差和标准差分别为135.38888888888889和11.63567311713804。方差和标准差的较低值告诉我们，个别数字更接近平均值。[图3-1](ch03.html#ch3fig1)通过图示直观展示了这一点。
- en: '![image](images/f03-01.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/f03-01.jpg)'
- en: '*Figure 3-1: Variation of the donations around the average donation*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：捐款的变化与平均捐款的关系*'
- en: The mean donations for both lists of donations are similar, so the two lines
    overlap, appearing as a single line in the figure. However, the donations from
    the first list vary widely from the mean, whereas the donations from the second
    list are very close to the mean, which confirms what we inferred from the lower
    variance value.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 两组捐款的平均值相似，因此图中的两条线重叠，看起来像一条单一的线。然而，第一组捐款与平均值的差异较大，而第二组捐款则非常接近平均值，这验证了我们从较低方差值推断出的结论。
- en: '**Calculating the Correlation Between Two Data Sets**'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**计算两个数据集之间的相关性**'
- en: 'In this section, we’ll learn how to calculate a statistical measure that tells
    us the nature and strength of the relationship between two sets of numbers: the
    *Pearson correlation coefficient*, which I’ll call simply the *correlation coefficient*.
    Note that this coefficient measures the strength of the *linear* relationship.
    We’d have to use other measures (which we won’t be discussing here) to find out
    the coefficient when two sets have a nonlinear relationship. The coefficient can
    be either positive or negative, and its magnitude can range between –1 and 1 (inclusive).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何计算一种统计度量，它告诉我们两组数字之间关系的性质和强度：*皮尔逊相关系数*，我将简称为 *相关系数*。请注意，这个系数衡量的是*线性*关系的强度。如果两组数据之间存在非线性关系，我们需要使用其他度量方法（我们这里不讨论）来找到相应的系数。该系数可以是正值也可以是负值，且其大小范围在
    –1 到 1 之间（包括 –1 和 1）。
- en: A correlation coefficient of 0 indicates that there’s no linear correlation
    between the two quantities. (Note that this doesn’t mean the two quantities are
    independent of each other. There could still be a nonlinear relationship between
    them, for example). A coefficient of 1 or close to 1 indicates that there’s a
    strong positive linear correlation; a coefficient of exactly 1 is referred to
    as perfect positive correlation. Similarly, a correlation coefficient of –1 or
    close to –1 indicates a strong negative correlation, where 1 indicates a perfect
    negative correlation.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 相关系数为 0 表示两者之间没有线性相关性。（注意，这并不意味着这两个变量彼此独立，它们之间可能仍然存在非线性关系）。系数为 1 或接近 1 表示存在强的正线性相关性；当系数为
    1 时，称为完全正相关。类似地，相关系数为 –1 或接近 –1 表示存在强的负相关性，其中 –1 表示完全负相关。
- en: '**CORRELATION AND CAUSATION**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关性与因果性**'
- en: In statistics, you’ll often come across the statement “correlation doesn’t imply
    causation.” This is a reminder that even if two sets of observations are strongly
    correlated with each other, that doesn’t mean one variable *causes* the other.
    When two variables are strongly correlated, sometimes there’s a third factor that
    influences both variables and explains the correlation. A classic example is the
    correlation between ice cream sales and crime rates—if you track both of these
    variables in a typical city, you’re likely to find a correlation, but this doesn’t
    mean that ice cream sales cause crime (or vice versa). Ice cream sales and crime
    are correlated because they both go up as the weather gets hotter during the summer.
    Of course, this doesn’t mean that hot weather directly causes crime to go up either;
    there are more complicated causes behind that correlation as well.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，你常常会遇到“相关性不意味着因果性”这一说法。这提醒我们，即使两组观察数据之间存在强相关，也不意味着一个变量*导致*了另一个变量。当两个变量之间存在强相关时，有时会有第三个因素影响这两个变量，从而解释相关性。一个经典例子是冰淇淋销售和犯罪率之间的相关性——如果你在一个典型城市中跟踪这两个变量，你可能会发现它们之间有相关性，但这并不意味着冰淇淋销售导致了犯罪（反之亦然）。冰淇淋销售和犯罪之间的相关性，实际上是因为夏天气温变热时，它们都会增加。当然，这并不意味着热天气直接导致犯罪率上升；这其中还有其他更复杂的原因。
- en: '***Calculating the Correlation Coefficient***'
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算相关系数***'
- en: The correlation coefficient is calculated using the formula
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 相关系数是通过以下公式计算的：
- en: '![image](images/e0076-01.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![image](images/e0076-01.jpg)'
- en: 'In the above formula, *n* is the total number of values present in each set
    of numbers (the sets have to be of equal length). The two sets of numbers are
    denoted by *x* and *y* (it doesn’t matter which one you denote as which). The
    other terms are described as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述公式中，*n* 是每组数字中值的总数（这两组数据必须长度相等）。这两组数据分别用 *x* 和 *y* 表示（你可以任意选择哪个表示哪个）。其他项的含义如下：
- en: '| Σ*xy* | Sum of the products of the individual elements of the two sets of
    numbers, *x* and *y* |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| Σ*xy* | 两组数字 *x* 和 *y* 中各个元素乘积的总和 |'
- en: '| Σ*x* | Sum of the numbers in set *x* |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| Σ*x* | 集合 *x* 中数字的总和 |'
- en: '| Σ*y* | Sum of the numbers in set *y* |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| Σ*y* | 集合 *y* 中数字的总和 |'
- en: '| (Σ*x*)² | Square of the sum of the numbers in set *x* |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| (Σ*x*)² | 集合 *x* 中数字总和的平方 |'
- en: '| (Σ*y*)² | Square of the sum of the numbers in set *y* |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| (Σ*y*)² | 集合 *y* 中数字总和的平方 |'
- en: '| Σ*x*² | Sum of the squares of the numbers in set *x* |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| Σ*x*² | 集合 *x* 中数字的平方和 |'
- en: '| Σ*y*² | Sum of the squares of the numbers in set *y* |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| Σ*y*² | 集合 *y* 中数字的平方和 |'
- en: Once we’ve calculated these terms, you can combine them according to the preceding
    formula to find the correlation coefficient. For small lists, it’s possible to
    do this by hand without too much effort, but it certainly gets complicated as
    the size of each set of numbers increases.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'In a moment, we’ll write a program that calculates the correlation coefficient
    for us. In this program, we’ll use the zip() function, which will help us calculate
    the sum of products from the two sets of numbers. Here’s an example of how the
    zip() function works:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '>>> simple_list1 = [1, 2, 3]'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '>>> simple_list2 = [4, 5, 6]'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for x, y in zip(simple_list1, simple_list2):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: print(x, y)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 1 4
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 2 5
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 3 6
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The zip() function returns pairs of the corresponding elements in x and y, which
    you can then use in a loop to perform other operations (like printing, as shown
    in the preceding code). If the two lists are unequal in length, the function terminates
    when all the elements of the smaller list have been read.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re ready to write a program that will calculate the correlation coefficient
    for us:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'def find_corr_x_y(x,y):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: n = len(x)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '# Find the sum of the products'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: prod = []
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '➊     for xi,yi in zip(x,y):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: prod.append(xi*yi)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: ➋     sum_prod_x_y = sum(prod)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: ➌     sum_x = sum(x)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: ➍     sum_y = sum(y)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: squared_sum_x = sum_x**2
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: squared_sum_y = sum_y**2
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: x_square = []
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '➎     for xi in x:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: x_square.append(xi**2)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '# Find the sum'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: x_square_sum = sum(x_square)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: y_square=[]
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'for yi in y:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: y_square.append(yi**2)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '# Find the sum'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: y_square_sum = sum(y_square)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '# Use formula to calculate correlation'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: ➏     numerator = n*sum_prod_x_y - sum_x*sum_y
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: denominator_term1 = n*x_square_sum - squared_sum_x
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: denominator_term2 = n*y_square_sum - squared_sum_y
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: ➐     denominator = (denominator_term1*denominator_term2)**0.5
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: ➑     correlation = numerator/denominator
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: return correlation
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: The find_corr_x_y() function accepts two arguments, x and y, which are the two
    sets of numbers we want to calculate the correlation for. At the beginning of
    this function, we find the length of the lists and create a label, n, to refer
    to it. Next, at ➊, we have a for loop that uses the zip() function to calculate
    the product of the corresponding values from each list (multiplying together the
    first item of each list, then the second item of each list, and so on). We use
    the append() method to add these products to the list labeled prod.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: At ➋, we calculate the sum of the products stored in prod using the sum() function.
    In the statements at ➌ and ➍, we calculate the sum of the numbers in x and y,
    respectively (once again, using the sum() function). Then, we calculate the squares
    of the sum of the elements in x and y, creating the labels squared_sum_x and squared_sum_y
    to refer to them, respectively.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: In the loop starting at ➎, we calculate the square of each of the elements in
    x and find the sum of these squares. Then, we do the same for the elements in
    y. We now have all the terms we need to calculate the correlation, and we do this
    in the statements at ➏, ➐, and ➑. Finally, we return the correlation. Correlation
    is an oft-cited measure in statistical studies—in popular media and scientific
    articles alike. Sometimes we know ahead of time that there’s a correlation, and
    we just want to find the strength of that correlation. We’ll see an example of
    this in “[Reading Data from a CSV File](ch03.html#ch03lev2sec09)” on [page 86](ch03.html#page_86),
    when we calculate the correlation between data read from a file. Other times,
    we might only suspect that there might be a correlation, and we must investigate
    the data to verify whether there actually is one (as in the following example).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '***High School Grades and Performance on College Admission Tests***'
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we’ll consider a fictional group of 10 students in high school
    and investigate whether there’s a relationship between their grades in school
    and how they fared on their college admission tests. [Table 3-2](ch03.html#ch3tab2)
    lists the data we’re going to assume for our study and base our experiments on.
    The “High school grades” column lists the percentile scores of the students’ grades
    in high school, and the “College admission test scores” column shows their percentile
    scores on the college admission test.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** High School Grades and College Admission Test Performance'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '| **High school grades** | **College admission test scores** |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| 90 | 85 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| 92 | 87 |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '| 95 | 86 |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '| 96 | 97 |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '| 87 | 96 |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '| 87 | 88 |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: '| 90 | 89 |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: '| 95 | 98 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
- en: '| 98 | 98 |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: '| 96 | 87 |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
- en: To analyze this data, let’s look at a *scatter plot*. [Figure 3-2](ch03.html#ch3fig2)
    shows the scatter plot of the preceding data set, with the *x*-axis representing
    high school grades and the *y*-axis representing the corresponding college admission
    test performance.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f03-02.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: Scatter plot of high school grades and college admission test
    scores*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The plot of the data indicates that the students with the highest grades in
    high school didn’t necessarily perform better on the college admission tests and
    vice versa. Some students with poor high school grades did very well on the college
    entrance exam, while others had excellent grades but did relatively poorly on
    the college exam. If we calculate the correlation coefficient of the two data
    sets (using our program from earlier), we see that it’s approximately 0.32\. This
    means that there’s some correlation, but not a very strong one. If the correlation
    were closer to 1, we’d see this reflected in the scatter plot as well—the points
    would conform more closely to a straight, diagonal line.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that the high school grades shown in [Table 3-2](ch03.html#ch3tab2)
    are an average of individual grades in math, science, English, and social science.
    Let’s also imagine that the college exam places a high emphasis on math—much more
    so than on other subjects. Instead of looking at students’ overall high school
    grades, let’s look at just their grades in math to see whether that’s a better
    predictor of how they did on their college exam. [Table 3-3](ch03.html#ch3tab3)
    now shows only the math scores (as percentiles) and the college admission tests.
    The corresponding scatter plot is shown in [Figure 3-3](ch03.html#ch3fig3).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** High School Math Grades and College Admission Test Performance'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '| **High school math grades** | **College admission test scores** |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| 83 | 85 |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| 85 | 87 |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| 84 | 86 |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| 96 | 97 |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| 94 | 96 |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| 86 | 88 |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| 87 | 89 |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| 97 | 98 |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '| 97 | 98 |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
- en: '| 85 | 87 |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
- en: Now, the scatter plot ([Figure 3-3](ch03.html#ch3fig3)) shows the data points
    lying almost perfectly along a straight line. This is an indication of a high
    correlation between the high school math scores and performance on the college
    admission test. The correlation coefficient, in this case, turns out to be approximately
    1\. With the help of the scatter plot and correlation coefficient, we can conclude
    that there is indeed a strong relationship in this data set between grades in
    high school math and performance on college admission tests.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f03-03.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: Scatter plot of high school math grades and college admission
    test scores*'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '**Scatter Plots**'
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we saw an example of how a scatter plot can give us
    a first indication of the existence of any correlation between two sets of numbers.
    In this section, we’ll see the importance of analyzing scatter plots by looking
    at a set of four data sets. For these data sets, conventional statistical measures
    all turn out to be the same, but the scatter plots of each data set reveal important
    differences.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s go over how to create a scatter plot in Python:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = [1, 2, 3, 4]'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '>>> y = [2, 4, 6, 8]'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import matplotlib.pyplot as plt'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: ➊ >>> plt.scatter(x, y)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: <matplotlib.collections.PathCollection object at 0x7f351825d550>
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '>>> plt.show()'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: The scatter() function is used to create a scatter plot between two lists of
    numbers, x and y ➊. The only difference between this plot and the plots we created
    in [Chapter 2](ch02.html#ch02) is that here we use the scatter() function instead
    of the plot() function. Once again, we have to call show() to display the plot.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about scatter plots, let’s look at an important statistical study:
    “Graphs in Statistical Analysis” by the statistician Francis Anscombe.[¹](footnote.html#fn01)
    The study considers four different data sets—referred to as *Anscombe’s quartet*—with
    identical statistical properties: mean, variance, and correlation coefficient.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: The data sets are as shown in [Table 3-4](ch03.html#ch3tab4) (reproduced from
    the original study).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-4:** Anscombe’s Quartet—Four Different Data Sets with Almost Identical
    Statistical Measures'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '| **A** | **B** | **C** | **D** |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: '| **X1** | **Y1** | **X2** | **Y2** | **X3** | **Y3** | **X4** | **Y4** |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '| 10.0 | 8.04 | 10.0 | 9.14 | 10.0 | 7.46 | 8.0 | 6.58 |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: '| 8.0 | 6.95 | 8.0 | 8.14 | 8.0 | 6.77 | 8.0 | 5.76 |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: '| 13.0 | 7.58 | 13.0 | 8.74 | 13.0 | 12.74 | 8.0 | 7.71 |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
- en: '| 9.0 | 8.81 | 9.0 | 8.77 | 9.0 | 7.11 | 8.0 | 8.84 |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
- en: '| 11.0 | 8.33 | 11.0 | 9.26 | 11.0 | 7.81 | 8.0 | 8.47 |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
- en: '| 14.0 | 9.96 | 14.0 | 8.10 | 14.0 | 8.84 | 8.0 | 7.04 |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: '| 6.0 | 7.24 | 6.0 | 6.13 | 6.0 | 6.08 | 8.0 | 5.25 |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: '| 4.0 | 4.26 | 4.0 | 3.10 | 4.0 | 5.39 | 19.0 | 12.50 |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| 12.0 | 10.84 | 12.0 | 9.13 | 12.0 | 8.15 | 8.0 | 5.56 |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: '| 7.0 | 4.82 | 7.0 | 7.26 | 7.0 | 6.42 | 8.0 | 7.91 |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '| 5.0 | 5.68 | 5.0 | 4.74 | 5.0 | 5.73 | 8.0 | 6.89 |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: We’ll refer to the pairs (X1, Y1), (X2, Y2), (X3, Y3), and (X4, Y4) as data
    sets A, B, C, and D, respectively. [Table 3-5](ch03.html#ch3tab5) presents the
    statistical measures of the data sets rounded off to two decimal digits.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-5:** Anscombe’s Quartet—Statistical Measures'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data set** | **X** | **Y** |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| **Mean** | **Std. dev.** | **Mean** | **Std. dev.** | **Correlation** |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: '| A | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
- en: '| B | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
- en: '| C | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
- en: '| D | 9.00 | 3.32 | 7.50 | 2.03 | 0.82 |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
- en: The scatter plots for each data set are shown in [Figure 3-4](ch03.html#ch3fig4).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f03-04.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: Scatter plots of Anscombe’s quartet*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: If we look at just the traditional statistical measures (see [Table 3-5](ch03.html#ch3tab5))—
    like the mean, standard deviation, and correlation coefficient—these data sets
    seem nearly identical. But the scatter plots show that these data sets are actually
    quite different from each other. Thus, scatter plots can be an important tool
    and should be used alongside other statistical measures before drawing any conclusions
    about a data set.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading Data from Files**'
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all our programs in this chapter, the lists of numbers we used in our calculations
    were all explicitly written, or *hardcoded*, into the programs themselves. If
    you wanted to find the measures for a different data set, you’d have to enter
    the entire new data set in the program itself. You also know how to make programs
    that allow the user to enter the data as input, but with large data sets, it isn’t
    very convenient to make the user enter long lists of numbers each time he or she
    uses the program.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: A better alternative is to read the user data from a file. Let’s see a simple
    example of how we can read numbers from a file and perform mathematical operations
    on them. First, I’ll show how to read data from a simple text file with each line
    of the file containing a new data element. Then, I’ll show you how to read from
    a file where the data is stored in the well-known CSV format, which will open
    up a lot of possibilities as there are loads of useful data sets you can download
    from the Internet in CSV format. (If you aren’t familiar with file handling in
    Python, see [Appendix B](app02.html#app02) for a brief introduction.)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '***Reading Data from a Text File***'
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s take a file, *mydata.txt*, with the list of donations (one per line)
    during period A that we considered at the beginning of this chapter:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '100'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '60'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '70'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '900'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '100'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '200'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '500'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '500'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '503'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '600'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '1000'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '1200'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program will read this file and print the sum of the numbers
    stored in the file:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '# Find the sum of numbers stored in a file'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'def sum_data(filename):'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: s = 0
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '➊     with open(filename) as f:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'for line in f:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: ➋             s = s + float(line)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: print('Sum of the numbers: {0}'.format(s))
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: sum_data('mydata.txt')
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: The sum_data() function opens the file specified by the argument filename at
    ➊ and reads it line by line (f is referred to as the *file object*, and you can
    think of it as pointing to an opened file). At ➋, we convert each number to a
    floating point number using the float() function and then keep adding until we’ve
    read all the numbers. The final number, labeled s, holds the sum of the numbers,
    which is printed at the end of the function.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you run the program, you must first create a file called *mydata.txt*
    with the appropriate data and save it in the same directory as your program. You
    can create this file from IDLE itself by clicking **File**▸**New Window**, typing
    the numbers (one per line) in the new window, and then saving the file as *mydata.txt*
    in the same directory as your program. Now, if you run the program, you’ll see
    the following output:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Sum of the numbers: 5733.0
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'All our programs in this chapter have assumed that the input data is available
    in lists. To use our earlier programs on the data from a file, we need to first
    create a list from that data. Once we have a list, we can use the functions we
    wrote earlier to calculate the corresponding statistic. The following program
    calculates the mean of the numbers stored in the file *mydata.txt*:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: ''''''''
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the mean of numbers stored in a file
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: ''''''''
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_data(filename):'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: numbers = []
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(filename) as f:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'for line in f:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: ➊             numbers.append(float(line))
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: return numbers
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'def calculate_mean(numbers):'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: s = sum(numbers)
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: N = len(numbers)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: mean = s/N
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: return mean
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: ➋     data = read_data('mydata.txt')
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: mean = calculate_mean(data)
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: print('Mean: {0}'.format(mean))
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Before we can call the calculate_mean() function, we need to read the numbers
    stored in the file and convert them into a list. To do this, use the read_data()
    function, which reads the file line by line. Instead of summing the numbers, this
    function converts them into floating point numbers and adds them to the list numbers
    ➊. The list is returned, and we refer to it by the label data ➋. We then invoke
    the calculate_mean() function, which returns the mean of the data. Finally, we
    print it.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用calculate_mean()函数之前，我们需要读取存储在文件中的数字并将其转换为列表。为此，使用read_data()函数，它逐行读取文件。该函数不是求和数字，而是将它们转换为浮动点数并将它们添加到列表numbers
    ➊中。列表返回后，我们通过标签data ➋来引用它。然后我们调用calculate_mean()函数，它返回数据的均值。最后，我们打印出来。
- en: 'When you run the program, you should see the following output:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，应该看到以下输出：
- en: Mean: 477.75
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mean: 477.75'
- en: Of course, you’ll see a different value for the mean if the numbers in your
    file are different from those in this example.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果文件中的数字与你这个示例中的数字不同，你会看到一个不同的均值。
- en: See [Appendix B](app02.html#app02) for hints on how you can ask the user to
    input the filename and then modify your program accordingly. This will allow your
    program’s user to specify any data file.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[附录B](app02.html#app02)了解如何提示用户输入文件名并相应地修改程序。这将允许你的程序用户指定任何数据文件。
- en: '***Reading Data from a CSV File***'
  id: totrans-487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从CSV文件读取数据***'
- en: A comma-separated value (CSV) file consists of rows and columns with the columns
    separated from each other by commas. You can view a CSV file using a text editor
    on your operating system or specialized software, such as Microsoft Excel, OpenOffice
    Calc, or LibreOffice Calc.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 一个逗号分隔值（CSV）文件由行和列组成，列之间由逗号分隔。你可以使用操作系统上的文本编辑器或专门的软件（如Microsoft Excel、OpenOffice
    Calc或LibreOffice Calc）查看CSV文件。
- en: 'Here’s a sample CSV file containing a few numbers and their squares:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含一些数字及其平方值的CSV文件示例：
- en: Number,Squared
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: Number,Squared
- en: 10,100
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 10,100
- en: 9,81
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 9,81
- en: 22,484
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 22,484
- en: The first line is referred to as the *header*. In this case, it tells us that
    the entries in the first column of this file are numbers and those in the second
    column are the corresponding squares. The next three lines, or rows, contain a
    number and its square separated by a comma. It’s possible to read the data from
    this file using an approach similar to what I showed for the *.txt* file. However,
    Python’s standard library has a dedicated module (csv) for reading (and writing)
    CSV files, which makes things a little easier.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行被称为*头部*。在这个例子中，它告诉我们文件中第一列的条目是数字，而第二列的条目是对应的平方值。接下来的三行或行包含一个数字及其平方值，两者之间用逗号分隔。使用与我之前展示的*.txt*文件类似的方法，可以读取此文件中的数据。但是，Python的标准库有一个专门的模块(csv)，用于读取（和写入）CSV文件，这使得事情变得稍微简单一些。
- en: 'Save the numbers and their squares into a file, *numbers.csv*, in the same
    directory as your programs. The following program shows how to read this file
    and then create a scatter plot displaying the numbers against their squares:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字及其平方保存到一个名为*numbers.csv*的文件中，并放在与你的程序相同的目录中。以下程序演示了如何读取此文件，然后创建一个散点图，显示数字与其平方之间的关系：
- en: import csv
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: import csv
- en: import matplotlib.pyplot as plt
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: 'def scatter_plot(x, y):'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 'def scatter_plot(x, y):'
- en: plt.scatter(x, y)
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: plt.scatter(x, y)
- en: plt.xlabel('Number')
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: plt.xlabel('Number')
- en: plt.ylabel('Square')
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: plt.ylabel('Square')
- en: plt.show()
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'def read_csv(filename):'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_csv(filename):'
- en: numbers = []
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = []
- en: squared = []
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: squared = []
- en: 'with open(filename) as f:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(filename) as f:'
- en: ➊         reader = csv.reader(f)
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: ➊          reader = csv.reader(f)
- en: next(reader)
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: next(reader)
- en: '➋         for row in reader:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '➋          for row in reader:'
- en: numbers.append(int(row[0]))
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: numbers.append(int(row[0]))
- en: squared.append(int(row[1]))
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: squared.append(int(row[1]))
- en: return numbers, squared
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: return numbers, squared
- en: 'if __name__ == ''__main__'':'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: numbers, squared = read_csv('numbers.csv')
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: numbers, squared = read_csv('numbers.csv')
- en: scatter_plot(numbers, squared)
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: scatter_plot(numbers, squared)
- en: The read_csv() function reads the CSV file using the reader() function defined
    in the csv module (which is imported at the beginning of the program). This function
    is called with the file object f passed to it as an argument ➊. This function
    then returns a *pointer* to the first line of the CSV file. We know that the first
    line of the file is the header, which we want to skip, so we move the pointer
    to the next line using the next() function. We then read every line of the file
    with each line referred to by the label row ➋, with row[0] referring to the first
    column of the data and row[1] referring to the second. For this specific file,
    we know that both these numbers are integers, so we use the int() function to
    convert these from strings to integers and to store them in two lists. The lists
    are then returned—one containing the numbers and the other containing the squares.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: We then call the scatter_plot() function with these two lists to create the
    scatter plot. The find_corr_x_y() function we wrote earlier can also easily be
    used to find the correlation coefficient between the two sets of numbers.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s try dealing with a more complex CSV file. Open *[https://www.google.com/trends/correlate/](https://www.google.com/trends/correlate/)*
    in your browser, enter any search query you wish to (for example, *summer*), and
    click the **Search correlations** button. You’ll see that a number of results
    are returned under the heading “Correlated with summer,” and the first result
    is the one with the highest correlation (the number on the immediate left of each
    result). Click the **Scatter plot** option above the graph to see a scatter plot
    with the *x*-axis labeled *summer* and the *y*-axis labeled with the top result.
    Ignore the exact numbers plotted on both axes as we’re interested only in the
    correlation and the scatter plot.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: A little above the scatterplot, click **Export data as CSV** and a file download
    will start. Save this file in the same directory as your programs.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: This CSV file is slightly different from the one we saw earlier. At the beginning
    of the file, you’ll see a number of blank lines and lines with a '#' symbol until
    finally you’ll see the header and the data. These lines aren’t useful to us—go
    ahead and delete them by hand using whatever software you opened the file with
    so that the first line of the file is the header. Also delete any blank lines
    at the end of the file. Now save the file. This step— where we cleaned up the
    file to make it easier to process with Python—is usually called *preprocessing*
    the data.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: The header has several columns. The first contains the date of the data in each
    row (each row has data corresponding to the week that started on the date in this
    column). The second column is the search query you entered, the third column shows
    the search query with the *highest* correlation with your search query, and the
    other columns include a number of other search queries arranged in decreasing
    order of correlation with your entered search query. The numbers in these columns
    are the *z*-scores of the corresponding search queries. The *z-score* indicates
    the difference between the number of times a term was searched for during a specific
    week and the overall mean number of searches per week for that term. A positive
    *z*-score indicates that the number of searches was higher than the mean for that
    week, and a negative *z*-score indicates it was lower.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s just work with the second and the third columns. You could use
    the following read_csv() function to read these columns:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_csv(filename):'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(filename) as f:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: reader = csv.reader(f)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: next(reader)
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: summer = []
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: highest_correlated = []
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '➊         for row in reader:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: summer.append(float(row[1]))
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: highest_correlated.append(float(row[2]))
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: return summer, highest_correlated
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'This is pretty much like the earlier version of the read_csv function; the
    main change here is how we append the values to each list starting at ➊: we’re
    now reading the second and the third members of each row, and we’re storing them
    as floating point numbers.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program uses this function to calculate the correlation between
    the values for the search query you provided and the values for the query with
    the highest correlation with it. It also creates a scatter plot of these values:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: import matplotlib.pyplot as plt
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: import csv
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: ➊     summer, highest_correlated = read_csv('correlate-summer.csv')
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: corr = find_corr_x_y(summer, highest_correlated)
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: print('Highest correlation: {0}'.format(corr))
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: scatter_plot(summer, highest_correlated)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that the CSV file was saved as *correlate-summer.csv*, we call the
    read_csv() function to read the data in the second and third columns ➊. Then,
    we call the find_corr_x_y() function we wrote earlier with the two lists summer
    and highest_correlated. It returns the correlation coefficient, which we then
    print. Now, we call the scatter_plot() function we wrote earlier with these two
    lists again. Before you can run this program, you’ll need to include the definitions
    of the read_csv(), find_corr_x_y(), and scatter_plot() functions.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: On running, you’ll see that it prints the correlation coefficient and also creates
    a scatter plot. Both of these should be very similar to the data shown on the
    Google correlate website.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '**What You Learned**'
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned to calculate statistical measures to describe a
    set of numbers and the relationships between sets of numbers. You also used graphs
    to aid your understanding of these measures. You learned a number of new programming
    tools and concepts while writing programs to calculate these measures.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Challenges**'
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, apply what you’ve learned to complete the following programming challenges.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '***#1: Better Correlation Coefficient–Finding Program***'
  id: totrans-548
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The find_corr_x_y() function we wrote earlier to find the correlation co efficient
    between two sets of numbers assumes that the two sets of numbers are the same
    length. Improve the function so that it first checks the length of the lists.
    If they’re equal, only then should the function proceed with the remaining calculations;
    otherwise, it should print an error message that the correlation can’t be found.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '***#2: Statistics Calculator***'
  id: totrans-550
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Implement a statistics calculator that takes a list of numbers in the file *mydata.txt*
    and then calculates and prints their mean, median, mode, variance, and standard
    deviation using the functions we wrote earlier in this chapter.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '***#3: Experiment with Other CSV Data***'
  id: totrans-552
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can experiment with numerous interesting data sources freely available
    on the Internet. The website *[http://www.quandl.com/](http://www.quandl.com/)*
    is one such source. For this challenge, download the following data as a CVS file
    from *[http://www.quandl.com/WORLDBANK/USA_SP_POP_TOTL/](http://www.quandl.com/WORLDBANK/USA_SP_POP_TOTL/)*:
    the total population of the United States at the end of each year for the years
    1960 to 2012\. Then, calculate the mean, median, variance, and standard deviation
    of the *difference* in population over the years and create a graph showing these
    differences.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '***#4: Finding the Percentile***'
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The percentile is a commonly used statistic that conveys the value below which
    a given percentage of observations falls. For example, if a student obtained a
    95 percentile score on an exam, this means that 95 percent of the students scored
    less than or equal to the student’s score. For another example, in the list of
    numbers 5, 1, 9, 3, 14, 9, and 7, the 50th percentile is 7 and the 25th percentile
    is 3.5, a number that is not present in the list.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to find the observation corresponding to a given
    percentile, but here’s one approach.[²](footnote.html#fn02)
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want to calculate the observation at percentile *p*:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: 1\. In ascending order, sort the given list of numbers, which we might call
    data.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Calculate
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0090-01.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
- en: where *n* is the number of items in data.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 3\. If *i* is an integer, data[i] is the number corresponding to percentile
    *p*.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 4\. If *i* is *not* an integer, set *k* equal to the integral part of *i* and
    *f* equal to the fractional part of *i*. The number (1-f)*data[k] + f*data[k+1]
    is the number at percentile *p*.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, write a program that will take a set of numbers in a file
    and display the number that corresponds to a specific percentile supplied as an
    input to the program.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '***#5: Creating a Grouped Frequency Table***'
  id: totrans-565
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this challenge, your task is to write a program that creates a grouped
    frequency table from a set of numbers. A grouped frequency table displays the
    frequency of data classified into different *classes*. For example, let’s consider
    the scores we discussed in “[Creating a Frequency Table](ch03.html#ch03lev2sec03)”
    on [page 69](ch03.html#page_69): 7, 8, 9, 2, 10, 9, 9, 9, 9, 4, 5, 6, 1, 5, 6,
    7, 8, 6, 1, and 10\. A grouped frequency table would display this data as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '| **Grade** | **Frequency** |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
- en: '| 1–6 | 6 |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
- en: '| 6–11 | 14 |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
- en: 'The table classifies the grades into two classes: 1–6 (which includes 1 but
    not 6) and 6–11 (which includes 6 but not 11). It displays against them the number
    of grades that belong to each category. Determining the number of classes and
    the range of numbers in each class are two key steps involved in creating this
    table. In this example, I’ve demonstrated two classes with the range of numbers
    in each class equally divided between the two.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one simple approach to creating classes, which assumes the number of
    classes can be arbitrarily chosen:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'def create_classes(numbers, n):'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: low = min(numbers)
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: high = max(numbers)
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '# Width of each class'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: width = (high - low)/n
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: classes = []
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: a = low
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: b = low + width
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: classes = []
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: 'while a < (high-width):'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: classes.append((a, b))
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: a = b
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: b = a + width
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '# The last class may be of a size that is less than width'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: classes.append((a, high+1))
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: return classes
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'The create_classes() function accepts two arguments: a list of numbers, numbers,
    and n, the number of classes to create. It’ll return a list of tuples with each
    tuple representing a class. For example, if it’s called with numbers 7, 8, 9,
    2, 10, 9, 9, 9, 9, 4, 5, 6, 1, 5, 6, 7, 8, 6, 1, 10, and n = 4, it returns the
    following list: [(1, 3.25), (3.25, 5.5), (5.5, 7.75), (7.75, 11)]. Once you have
    the list, the next step is to go over each of the numbers and find out which of
    the returned classes it belongs to.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Your challenge is to write a program to read a list of numbers from a file and
    then to print the grouped frequency table, making use of the create_classes()
    function.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
