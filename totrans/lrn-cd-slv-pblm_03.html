<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_47"/><span class="big">3</span><br/>REPEATING CODE: DEFINITE LOOPS</h2>&#13;&#13;
<div class="imagec"><img src="Images/common.jpg" alt="image" width="150" height="150"/></div>&#13;&#13;
<p class="noindents">Computers shine when we have them repeat a process over and over. They tirelessly do exactly what we ask, whether it involves doing something 10, 100, or a billion times. In this chapter, we’ll learn about loops, statements that instruct the computer to repeat the execution of part of our program.</p>&#13;&#13;
<p class="indent">We’ll use loops to solve three problems: tracking the location of a ball under a cup, counting the number of occupied parking spaces, and determining how much data is available on a cell phone plan.</p>&#13;&#13;
<h3 class="h3a" id="ch03lev1sec1"><span class="h3aa">Problem #5: Three Cups</span></h3>&#13;&#13;
<p class="noindent">In this problem, we’ll track the location of a ball under a cup as the cups move. But the cups can move many times, so we won’t be able to write code for each move separately. Instead, we’ll learn about and use the <span class="literal">for</span> loop, which allows us to more easily run code for each move.</p>&#13;&#13;
<p class="indent">This is DMOJ problem <span class="literal">coci06c5p1</span>.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec1"><span epub:type="pagebreak" id="page_48"/>The Challenge</h4>&#13;&#13;
<p class="noindent">Borko has a row of three opaque cups: one at the left (location 1), one at the middle (location 2), and one at the right (location 3). There is a ball under the cup at the left. It’s our job to keep track of the location of the ball as Borko swaps the locations of the cups.</p>&#13;&#13;
<p class="indentb">Borko can make three types of swap:</p>&#13;&#13;
<p class="uln-indent"><strong>A</strong> Swap the left and middle cups</p>&#13;&#13;
<p class="uln-indent"><strong>B</strong> Swap the middle and right cups</p>&#13;&#13;
<p class="uln-indent"><strong>C</strong> Swap the left and right cups</p>&#13;&#13;
<p class="indenta">For example, if Borko’s first swap is type A, then he swaps the left and middle cups; because the ball starts at the left, this swap moves it to the middle. If instead his first swap is type B, then he swaps the middle and right cups; the left cup stays where it is, so the ball doesn’t change locations.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec2">Input</h4>&#13;&#13;
<p class="noindent">The input is one line of at most 50 characters. Each character specifies a type of swap that Borko makes: <span class="literal">A</span>, <span class="literal">B</span>, or <span class="literal">C</span>.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec3">Output</h4>&#13;&#13;
<p class="noindent">Output the final location of the ball:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent"><span class="literal">1</span> if the ball is at the left</li>&#13;&#13;
<li class="noindent"><span class="literal">2</span> if the ball is at the middle</li>&#13;&#13;
<li class="noindent"><span class="literal">3</span> if the ball is at the right</li>&#13;&#13;
</ul>&#13;&#13;
<h3 class="h3" id="ch03lev1sec2">Why Loops?</h3>&#13;&#13;
<p class="noindent">Consider this test case:</p>&#13;&#13;
<p class="programs">ACBA</p>&#13;&#13;
<p class="indent">There are four swaps here. To determine the final location of the ball, we need to carry out each one.</p>&#13;&#13;
<p class="indent">The first swap is type <span class="literal">A</span>, which swaps the cups at the left and middle. Since the ball starts at the left, this results in the ball moving to the middle. The second swap is type <span class="literal">C</span>, which swaps the cups at the left and right. Since the ball is currently at the middle, this has no effect on the location of the ball. The third swap is type <span class="literal">B</span>, which swaps the cups at the middle and right. This moves the ball from the middle to the right. The fourth swap is type <span class="literal">A</span>, which swaps the cups at the left and middle. This has no effect on the ball. The correct output is therefore <span class="literal">3</span>, because the ball ends up at the right.</p>&#13;&#13;
<p class="indent">Notice that for each swap, we have to make a decision to determine whether the ball moves and, if it does, to move the ball appropriately. Making decisions is something we know how to do from <a href="ch02.xhtml#ch02">Chapter 2</a>. For example, <span epub:type="pagebreak" id="page_49"/>if the swap type is <span class="literal">A</span> and the ball is at the left, then the ball moves to the middle. That looks like this:</p>&#13;&#13;
<p class="programs">if swap_type == 'A' and ball_location == 1:<br/>&#13;&#13;
    ball_location = 2</p>&#13;&#13;
<p class="indent">We could add an <span class="literal">elif</span> for each other case where the ball moves: swap type <span class="literal">A</span> and ball is at the middle, swap type <span class="literal">B</span> and ball is at the middle, swap type <span class="literal">B</span> and ball is at the right, and so on. This big <span class="literal">if</span> statement would be enough to handle one swap. But that’s not enough to solve the Three Cups problem, because we could have a test case of up to 50 swaps. We’d need to repeat the <span class="literal">if</span> statement logic for each swap. And we certainly wouldn’t want to copy and paste the same code 50 times. Imagine if you had made a typo and had to fix it 50 times. Or if you suddenly became interested in test cases with up to a million swaps. No, what we have learned so far is not going to cut it. We need a way to walk through the swaps, performing the same logic for each one. We need a loop.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec3">for Loops</h3>&#13;&#13;
<p class="noindent">Python’s <span class="literal">for</span> statement produces <em>for loops</em>. <span class="literal">for</span> loops allow us to process each element of a sequence. The only sequence type we’ve seen so far is the string. We’ll learn others as we go; <span class="literal">for</span> loops work on all of them.</p>&#13;&#13;
<p class="indent">Here’s our first example of a <span class="literal">for</span> loop:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">secret_word = 'olive'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for char in secret_word:</span><br/>&#13;&#13;
...     <span class="codestrong1">print('Letter: ' + char)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
Letter: o<br/>&#13;&#13;
Letter: l<br/>&#13;&#13;
Letter: i<br/>&#13;&#13;
Letter: v<br/>&#13;&#13;
Letter: e</p>&#13;&#13;
<p class="indent">Following the keyword <span class="literal">for</span>, we write the name of a <em>loop variable</em>. A loop variable is one that refers to different values as a loop progresses. In a <span class="literal">for</span> loop on a string, the loop variable refers to each of the string’s characters.</p>&#13;&#13;
<p class="indent">I’ve chosen the variable name <span class="literal">char</span> (for “character”) to remind us that the variable refers to a character from the string. Sometimes, it’s clearer if we use a contextual variable name. For example, in Three Cups, we could instead use the name <span class="literal">swap_type</span> to remind us that it refers to a type of swap.</p>&#13;&#13;
<p class="indent">After the variable name, we have the keyword <span class="literal">in</span> and then the string that we want to loop over. In our example, we’re looping over the string referred to by <span class="literal">secret_word</span>, which is <span class="literal">'olive'</span>.</p>&#13;&#13;
<p class="indent">Like the <span class="literal">if</span>, <span class="literal">elif</span>, and <span class="literal">else</span> lines of an <span class="literal">if</span> statement, the <span class="literal">for</span> line ends with a colon (<span class="literal">:</span>). And, also like an <span class="literal">if</span> statement, a <span class="literal">for</span> statement has an indented block of one or more statements.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_50"/>An execution of the indented statements is referred to as an <em>iteration</em> of the loop. Here’s a walk-through of what our loop does on each iteration:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">On the first iteration, Python sets <span class="literal">char</span> to refer to <span class="literal">'o'</span>, the first character of <span class="literal">'olive'</span>. It then runs the loop block, which consists only of the call to <span class="literal">print</span>. As <span class="literal">char</span> refers to <span class="literal">'o'</span>, the output produced is <span class="literal">Letter: o</span>.</li>&#13;&#13;
<li class="noindent">On the second iteration, Python sets <span class="literal">char</span> to refer to <span class="literal">'l'</span>, the second character of <span class="literal">'olive'</span>. It then calls <span class="literal">print</span>, outputting <span class="literal">Letter: l</span>.</li>&#13;&#13;
<li class="noindent">This process repeats three more times, once for each remaining character in <span class="literal">'olive'</span>.</li>&#13;&#13;
<li class="noindent">The loop then terminates. We have no code after the loop, so our program has finished running. If there was additional code after the loop, then execution would continue with that code.</li>&#13;&#13;
</ul>&#13;&#13;
<p class="indent">You can put multiple statements in the block of a <span class="literal">for</span> loop. Here’s an example:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">secret_word = 'olive'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for char in secret_word:</span><br/>&#13;&#13;
...     <span class="codestrong1">print('Letter: ' + char)</span><br/>&#13;&#13;
...     <span class="codestrong1">print('*')</span><br/>&#13;&#13;
...<br/>&#13;&#13;
Letter: o<br/>&#13;&#13;
*<br/>&#13;&#13;
Letter: l<br/>&#13;&#13;
*<br/>&#13;&#13;
Letter: i<br/>&#13;&#13;
*<br/>&#13;&#13;
Letter: v<br/>&#13;&#13;
*<br/>&#13;&#13;
Letter: e<br/>&#13;&#13;
*</p>&#13;&#13;
<p class="indent">Now we have two statements executing on each iteration of the loop: one that outputs the current letter of the string, and one that outputs a <span class="literal">*</span> character.</p>&#13;&#13;
<p class="indent">A <span class="literal">for</span> loop loops through the elements of a sequence, so the sequence’s length tells us how many iterations there will be. The <span class="literal">len</span> function takes a string and returns its length:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">len('olive')</span><br/>&#13;&#13;
5</p>&#13;&#13;
<p class="indent">Our <span class="literal">for</span> loop on <span class="literal">'olive'</span> will therefore consist of five iterations:</p>&#13;&#13;
<p class="programs">   &gt;&gt;&gt; <span class="codestrong1">secret_word = 'olive'</span><br/>&#13;&#13;
<span class="ent">❶</span> &gt;&gt;&gt; <span class="codestrong1">print(len(secret_word), 'iterations, coming right up!')</span><br/>&#13;&#13;
   &gt;&gt;&gt; <span class="codestrong1">for char in secret_word:</span><br/>&#13;&#13;
<span epub:type="pagebreak" id="page_51"/>&#13;&#13;
   ...     <span class="codestrong1">print('Letter: ' + char)</span><br/>&#13;&#13;
   ...<br/>&#13;&#13;
   5 iterations, coming right up!<br/>&#13;&#13;
   Letter: o<br/>&#13;&#13;
   Letter: l<br/>&#13;&#13;
   Letter: i<br/>&#13;&#13;
   Letter: v<br/>&#13;&#13;
   Letter: e</p>&#13;&#13;
<p class="indent">I called <span class="literal">print</span> with multiple arguments <span class="ent">❶</span>, rather than using concatenation, to avoid having to convert the length to a string.</p>&#13;&#13;
<p class="indent">A <span class="literal">for</span> loop is what’s called a <em>definite loop</em>, referring to the idea that the number of iterations is predetermined. There are also <em>indefinite loops</em>, whose iterations depend on the vagaries of what happens when your program runs. We’ll study those in the next chapter.</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">What is the output of the following code?</p>&#13;&#13;
<p class="programs">s = 'garage'<br/>&#13;&#13;
total = 0<br/>&#13;&#13;
<br/>&#13;&#13;
for char in s:<br/>&#13;&#13;
    total = total + s.count(char)<br/>&#13;&#13;
<br/>&#13;&#13;
print(total)</p>&#13;&#13;
<p class="alphat">A. <span class="literal">6</span></p>&#13;&#13;
<p class="alpha">B. <span class="literal">10</span></p>&#13;&#13;
<p class="alpha">C. <span class="literal">12</span></p>&#13;&#13;
<p class="alpha">D. <span class="literal">36</span></p>&#13;&#13;
<p class="sb-noindent1">Answer: B. For each character in <span class="literal">'garage'</span>, we add its count to <span class="literal">total</span>. There are two <span class="literal">g</span>’s, two <span class="literal">a</span>’s, one <span class="literal">r</span>, two <span class="literal">a</span>’s (again!), two <span class="literal">g</span>’s (again!), and 1 <span class="literal">e</span>.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch03lev1sec4">Nesting</h3>&#13;&#13;
<p class="noindent">The <span class="literal">for</span> loop block is one or more statements. Those statements can include one-line statements such as function calls and assignment statements. But they can also include multiline statements such as <span class="literal">if</span> statements and loops.</p>&#13;&#13;
<p class="indent">Let’s start with an example of an <span class="literal">if</span> statement inside a <span class="literal">for</span> loop. Suppose we wanted to output only the uppercase characters from a string. Strings <span epub:type="pagebreak" id="page_52"/>have an <span class="literal">isupper</span> method that we can use to determine whether a character is uppercase:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">'q'.isupper()</span><br/>&#13;&#13;
False<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">'Q'.isupper()</span><br/>&#13;&#13;
True</p>&#13;&#13;
<p class="indent">We can use <span class="literal">isupper</span> in an <span class="literal">if</span> statement to control what happens on each iteration of a <span class="literal">for</span> loop:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">title = 'The Escape'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for char in title:</span><br/>&#13;&#13;
...     <span class="codestrong1">if char.isupper():</span><br/>&#13;&#13;
...         <span class="codestrong1">print(char)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
T<br/>&#13;&#13;
E</p>&#13;&#13;
<p class="indent">Be careful with the indentation here. We need one level of indentation for the <span class="literal">for</span> loop, and an extra level of indentation for the nested <span class="literal">if</span> statement.</p>&#13;&#13;
<p class="indent">On the first iteration, <span class="literal">char</span> refers to <span class="literal">'T'</span>. Since <span class="literal">'T'</span> is uppercase, the <span class="literal">isupper</span> test returns <span class="literal">True</span>, and the <span class="literal">if</span> statement block runs. That results in the output of <span class="literal">T</span>. On the second iteration, <span class="literal">char</span> refers to <span class="literal">'h'</span>. This time, the <span class="literal">isupper</span> test returns <span class="literal">False</span>, so the <span class="literal">if</span> statement block doesn’t run. Overall, the <span class="literal">for</span> loop loops through each character of the string, but the nested <span class="literal">if</span> statement fires only twice: on the <span class="literal">'T'</span> at the beginning of the string and on the <span class="literal">'E'</span> at the beginning of <span class="literal">'Escape'</span>.</p>&#13;&#13;
<p class="indent">What about a <span class="literal">for</span> loop nested in a <span class="literal">for</span> loop? We can do that! Here’s an example:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">letters = 'ABC'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">digits = '123'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for letter in letters:</span><br/>&#13;&#13;
...     <span class="codestrong1">for digit in digits:</span><br/>&#13;&#13;
...         <span class="codestrong1">print(letter + digit)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
A1<br/>&#13;&#13;
A2<br/>&#13;&#13;
A3<br/>&#13;&#13;
B1<br/>&#13;&#13;
B2<br/>&#13;&#13;
B3<br/>&#13;&#13;
C1<br/>&#13;&#13;
C2<br/>&#13;&#13;
C3</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_53"/>The code produces all two-character strings whose first character is from <span class="literal">letters</span> and whose second character is from <span class="literal">digits</span>.</p>&#13;&#13;
<p class="indent">On the first iteration of the outer (<span class="literal">letters</span>) loop, <span class="literal">letter</span> refers to <span class="literal">'A'</span>. This iteration involves completely running the inner (<span class="literal">digits</span>) loop. The whole time the inner loop runs, <span class="literal">letter</span> refers to <span class="literal">'A'</span>. On the first iteration of the inner loop, <span class="literal">digit</span> refers to <span class="literal">1</span>, which explains the <span class="literal">A1</span> output. On the second iteration of the inner loop, <span class="literal">digit</span> refers to <span class="literal">2</span>, and <span class="literal">A2</span> is output. On the third and final iteration of the inner loop, <span class="literal">digit</span> refers to <span class="literal">3</span>, and <span class="literal">A3</span> is output.</p>&#13;&#13;
<p class="indent">We’re not done! We’ve gone through only one iteration of the outer loop. On the second iteration of the outer loop, <span class="literal">letter</span> refers to <span class="literal">'B'</span>. Now the three iterations of the inner loop run again, this time with <span class="literal">letter</span> referring to <span class="literal">'B'</span>. This accounts for the <span class="literal">B1</span>, <span class="literal">B2</span>, and <span class="literal">B3</span> outputs. Finally, on the third iteration of the outer loop, <span class="literal">letter</span> refers to <span class="literal">'C'</span>, and the inner loop produces <span class="literal">C1</span>, <span class="literal">C2</span>, and <span class="literal">C3</span>.</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">What is the output of the following code?</p>&#13;&#13;
<p class="programs">title = 'The Escape'<br/>&#13;&#13;
total = 0<br/>&#13;&#13;
<br/>&#13;&#13;
for char1 in title:<br/>&#13;&#13;
    for char2 in title:<br/>&#13;&#13;
        total = total + 1<br/>&#13;&#13;
<br/>&#13;&#13;
print(total)</p>&#13;&#13;
<p class="alphat">A. <span class="literal">10</span></p>&#13;&#13;
<p class="alpha">B. <span class="literal">20</span></p>&#13;&#13;
<p class="alpha">C. <span class="literal">100</span></p>&#13;&#13;
<p class="alpha">D. This code produces a syntax error because two nested loops cannot both use <span class="literal">title</span></p>&#13;&#13;
<p class="sb-noindent1">Answer: C. <span class="literal">total</span> starts off as <span class="literal">0</span> and is increased by 1 on each iteration of the inner loop. The length of <span class="literal">'The Escape'</span> is 10. The outer loop therefore has 10 iterations. For each of those iterations, the inner loop has 10 iterations. The inner loop therefore has 10*10 = 100 iterations in all.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch03lev1sec5"><span epub:type="pagebreak" id="page_54"/>Solving the Problem</h3>&#13;&#13;
<p class="noindent">Back to Three Cups. The structure we need is a <span class="literal">for</span> loop to go through each swap, and a nested <span class="literal">if</span> statement to keep track of where the ball is:</p>&#13;&#13;
<p class="programs">for swap_type in swaps:<br/>&#13;&#13;
    # Big if statement to keep track of the ball</p>&#13;&#13;
<p class="indent">There are three types of swaps (A, B, and C) and three possible locations for the ball, so it’s tempting to conclude that we have to write an <span class="literal">if</span> statement with 3 * 3 = 9 Boolean expressions (one after the <span class="literal">if</span> and one after each of eight <span class="literal">elif</span>s). In fact, we need only six Boolean expressions. Three of the nine don’t move the ball at all: swap type A when the ball is at the right, swap type B when the ball is at the left, and swap type C when the ball is at the middle.</p>&#13;&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex01">Listing 3-1</a> has a solution to Three Cups.</p>&#13;&#13;
<p class="programs">   swaps = input()<br/>&#13;&#13;
<br/>&#13;&#13;
   ball_location = 1<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❶</span> for swap_type in swaps:<br/>&#13;&#13;
    <span class="ent">❷</span> if swap_type == 'A' and ball_location == 1:<br/>&#13;&#13;
        <span class="ent">❸</span> ball_location = 2<br/>&#13;&#13;
       elif swap_type == 'A' and ball_location == 2:<br/>&#13;&#13;
           ball_location = 1<br/>&#13;&#13;
       elif swap_type == 'B' and ball_location == 2:<br/>&#13;&#13;
           ball_location = 3<br/>&#13;&#13;
       elif swap_type == 'B' and ball_location == 3:<br/>&#13;&#13;
           ball_location = 2<br/>&#13;&#13;
       elif swap_type == 'C' and ball_location == 1:<br/>&#13;&#13;
           ball_location = 3<br/>&#13;&#13;
       elif swap_type == 'C' and ball_location == 3:<br/>&#13;&#13;
           ball_location = 1<br/>&#13;&#13;
<br/>&#13;&#13;
   print(ball_location)</p>&#13;&#13;
<p class="ex-caption" id="ch03ex01"><em>Listing 3-1: Solving Three Cups</em></p>&#13;&#13;
<p class="indent">I’ve used <span class="literal">input</span> to assign the string of swaps to the <span class="literal">swaps</span> variable. The <span class="literal">for</span> loop <span class="ent">❶</span> loops through these swaps. Each swap is processed by the nested <span class="literal">if</span> statement <span class="ent">❷</span>. The <span class="literal">if</span> and <span class="literal">elif</span> branches each encode what happens with a given type of swap and a given ball location and then move the ball accordingly. For example, if the swap type is <span class="literal">A</span> and the ball is at location 1 <span class="ent">❷</span>, then the ball ends up at location 2 <span class="ent">❸</span>.</p>&#13;&#13;
<p class="indent">This is a code example where it matters whether we use multiple <span class="literal">elif</span>s (one big <span class="literal">if</span> statement) or multiple <span class="literal">if</span>s (multiple <span class="literal">if</span> statements). If we change the <span class="literal">elif</span>s to <span class="literal">if</span>s, then our code is no longer correct. <a href="ch03.xhtml#ch03ex02">Listing 3-2</a> shows the incorrect code.</p>&#13;&#13;
<p class="programs"><span epub:type="pagebreak" id="page_55"/># This code is incorrect<br/>&#13;&#13;
<br/>&#13;&#13;
swaps = input()<br/>&#13;&#13;
<br/>&#13;&#13;
ball_location = 1<br/>&#13;&#13;
<br/>&#13;&#13;
for swap_type in swaps:<br/>&#13;&#13;
 <span class="ent">❶</span> if swap_type == 'A' and ball_location == 1:<br/>&#13;&#13;
        ball_location = 2<br/>&#13;&#13;
 <span class="ent">❷</span> if swap_type == 'A' and ball_location == 2:<br/>&#13;&#13;
        ball_location = 1<br/>&#13;&#13;
    if swap_type == 'B' and ball_location == 2:<br/>&#13;&#13;
        ball_location = 3<br/>&#13;&#13;
    if swap_type == 'B' and ball_location == 3:<br/>&#13;&#13;
        ball_location = 2<br/>&#13;&#13;
    if swap_type == 'C' and ball_location == 1:<br/>&#13;&#13;
        ball_location = 3<br/>&#13;&#13;
    if swap_type == 'C' and ball_location == 3:<br/>&#13;&#13;
        ball_location = 1<br/>&#13;&#13;
<br/>&#13;&#13;
print(ball_location)</p>&#13;&#13;
<p class="ex-caption" id="ch03ex02"><em>Listing 3-2: Solving Three Cups incorrectly</em></p>&#13;&#13;
<p class="indent">If we say that the code is incorrect, we’re claiming that it fails at least one test case. Can you find a test case where this code produces the wrong answer?</p>&#13;&#13;
<p class="indent">Here’s one such test case:</p>&#13;&#13;
<p class="programs">A</p>&#13;&#13;
<p class="indent">It may make sense to us that the ball can move at most once per swap. But Python robotically runs the code you have written, whether it matches what we expect or not. In this case, we have only one swap, so the ball should move at most once. On the first and only iteration of the <span class="literal">for</span> loop, Python checks the expression <span class="ent">❶</span>. It’s <span class="literal">True</span>, so Python sets <span class="literal">ball_location</span> to <span class="literal">2</span>. Then, Python checks the expression <span class="ent">❷</span>. Because we just changed <span class="literal">ball_location</span> to <span class="literal">2</span>, this expression is <span class="literal">True</span>! Python therefore sets <span class="literal">ball_location</span> to <span class="literal">1</span>. The output of the program is <span class="literal">1</span> when it should be <span class="literal">2</span>.</p>&#13;&#13;
<p class="indent">This is an example of a <em>logic error</em>: an error that causes a program to follow the wrong logic and produce the wrong answer. A common term for logic error is a <em>bug</em>. When programmers work through their code to fix bugs, it’s called <em>debugging</em>.</p>&#13;&#13;
<p class="indent">It often takes only a simple test case to demonstrate when a program is incorrect. When you’re trying to narrow down what’s going wrong with your code, don’t start with long test cases. Such test case results are hard to verify by hand and often set in motion complex execution paths from which we <span epub:type="pagebreak" id="page_56"/>may learn very little. A small test case, by contrast, doesn’t cause our program to do much; if what it does is wrong, then we don’t have far to look for the culprit. Devising small, targeted test cases is not always easy. It’s a skill that you can hone through practice.</p>&#13;&#13;
<p class="indent">Submit our correct code to the judge, and then let’s move on.</p>&#13;&#13;
<p class="indent">Before continuing, you might like to try solving exercises 1 and 2 from “Chapter Exercises” on <a href="ch03.xhtml#ch03lev1sec16">page 67</a>.</p>&#13;&#13;
<h3 class="h3a" id="ch03lev1sec6"><span class="h3aa">Problem #6: Occupied Spaces</span></h3>&#13;&#13;
<p class="noindent">We know how to loop through the characters of a string. But sometimes we need to know where we are in the string, not just the character that’s stored there. This problem is one such example.</p>&#13;&#13;
<p class="indent">This is DMOJ problem <span class="literal">ccc18j2</span>.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec4">The Challenge</h4>&#13;&#13;
<p class="noindent">You supervise a parking lot with <em>n</em> parking spaces. Yesterday, you recorded whether each parking space was occupied by a car or was empty. Today, you again recorded whether each parking space was occupied by a car or was empty. Indicate the number of parking spaces that were occupied on both days.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec5">Input</h4>&#13;&#13;
<p class="noindent">The input consists of three lines.</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">The first line contains integer <em>n</em>, the number of parking spaces. <em>n</em> is between 1 and 100.</li>&#13;&#13;
<li class="noindent">The second line contains a string of <em>n</em> characters for yesterday’s information, one character for each parking space. A <span class="literal">C</span> indicates an occupied parking space (C for car), and a <span class="literal">.</span> indicates an empty parking space. For example, <span class="literal">CC.</span> means that the first two parking spaces were occupied and the third was empty.</li>&#13;&#13;
<li class="noindent">The third line contains a string of <em>n</em> characters for today’s information, in the same format as the second line.</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch03lev2sec6">Output</h4>&#13;&#13;
<p class="noindent">Output the number of parking spaces that were occupied on both days.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec7">A New Kind of Loop</h3>&#13;&#13;
<p class="noindent">We could have up to 100 parking spaces, so you may not be surprised that a loop will show up here somewhere. The kind of <span class="literal">for</span> loop we learned when <span epub:type="pagebreak" id="page_57"/>solving Three Cups can certainly loop through a string of parking-space information:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">yesterday = 'CC.'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for parking_space in yesterday:</span><br/>&#13;&#13;
...     <span class="codestrong1">print('The space is ' + parking_space)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
The space is C<br/>&#13;&#13;
The space is C<br/>&#13;&#13;
The space is .</p>&#13;&#13;
<p class="indent">That tells us whether each space was occupied yesterday. But we also need to know whether each space was also occupied today.</p>&#13;&#13;
<p class="indent">Consider this test case:</p>&#13;&#13;
<p class="programs">3<br/>&#13;&#13;
CC.<br/>&#13;&#13;
.C.</p>&#13;&#13;
<p class="indent">The first parking space was occupied yesterday. Was that parking space occupied on both days? To answer that, we need to look at the corresponding character in today’s string. It’s a <span class="literal">.</span> (empty), so this parking space was not occupied on both days.</p>&#13;&#13;
<p class="indent">What about the second parking space? That one was also occupied yesterday. And, looking at the second character of today’s string, it was also occupied today. So this <em>is</em> a parking space that was occupied on both days. (This is the only such parking space; the correct output for this test case is <span class="literal">1</span>.)</p>&#13;&#13;
<p class="indent">Looping through the characters of one string doesn’t help us find the corresponding characters in the other string. But if we could keep track of where we were in the string—we’re at the first parking space, we’re at the second parking space, and so on—we could look up the corresponding character from each string. The <span class="literal">for</span> loops we’ve learned so far are not the way to do this. The way to do this is using indexing and a new type of <span class="literal">for</span> loop.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec8">Indexing</h3>&#13;&#13;
<p class="noindent">Each character in a string has an <em>index</em>, which indicates its location. The first character is at index 0, the second character is at index 1, and so on. In natural language, we often start counting at 1. In English, no one says “the character at position 0 of <em>hello</em> is <em>h</em>.” But most programming languages, Python included, start at 0.</p>&#13;&#13;
<p class="indent">To use indexing, we follow a string by an index in square brackets. Here are some examples of indexing:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">word = 'splore'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[0]</span><br/>&#13;&#13;
's'<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_58"/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[3]</span><br/>&#13;&#13;
'o'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[5]</span><br/>&#13;&#13;
'e'</p>&#13;&#13;
<p class="indent">If we like, we can use variables in an index:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">where = 2</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[where]</span><br/>&#13;&#13;
'l'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[where + 2]</span><br/>&#13;&#13;
'r'</p>&#13;&#13;
<p class="indent">The highest index that we can use on a nonempty string is its length minus 1. (There is no valid index for an empty string.) For example, <span class="literal">'splore'</span> is length 6, so index 5 is its highest index. Any bigger and we get an error:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">word[len(word)]</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
IndexError: string index out of range<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[len(word) - 1]</span><br/>&#13;&#13;
'e'</p>&#13;&#13;
<p class="indent">How can we access the second character from the right of a string? This will do it:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">word[len(word) - 2]</span><br/>&#13;&#13;
'r'</p>&#13;&#13;
<p class="indent">But there’s an easier way. Python supports negative indices as another option for accessing characters. Index <span class="literal">-1</span> is the rightmost character, index <span class="literal">-2</span> is the second character from the right, and so on:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">word[-2]</span><br/>&#13;&#13;
'r'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[-1]</span><br/>&#13;&#13;
'e'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[-5]</span><br/>&#13;&#13;
'p'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[-6]</span><br/>&#13;&#13;
's'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[-7]</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
IndexError: string index out of range</p>&#13;&#13;
<p class="indent">The plan is to use indexing to access corresponding positions of yesterday’s and today’s parking information. We can use index 0 of each string to access information about the first parking space, index 1 to access <span epub:type="pagebreak" id="page_59"/>information about the second parking space, and so on. But before we can carry out that plan, we need to learn a new kind of <span class="literal">for</span> loop.</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">What is the output of the following code?</p>&#13;&#13;
<p class="programs">s = 'abcde'<br/>&#13;&#13;
t = s[0] + s[-5] + s[len(s) - 5]<br/>&#13;&#13;
<br/>&#13;&#13;
print(t)</p>&#13;&#13;
<p class="alphat">A. <span class="literal">aaa</span></p>&#13;&#13;
<p class="alpha">B. <span class="literal">aae</span></p>&#13;&#13;
<p class="alpha">C. <span class="literal">aee</span></p>&#13;&#13;
<p class="alpha">D. This code produces an error</p>&#13;&#13;
<p class="sb-noindent1">Answer: A. Each of the three indices refers to the first character in <span class="literal">'abcde'</span>. First, <span class="literal">s[0]</span> refers to <span class="literal">'a'</span> because <span class="literal">'a'</span> is at index 0 of the string. Second, <span class="literal">s[-5]</span> refers to <span class="literal">'a'</span> because <span class="literal">'a'</span> is the fifth character from the right. Third, <span class="literal">s[len(s) - 5]</span> refers to <span class="literal">'a'</span> because the index evaluates to 0: 5 (the length of the string) minus 5.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch03lev1sec9">Range for loops</h3>&#13;&#13;
<p class="noindent">Python’s <span class="literal">range</span> function generates ranges of integers, and we can use those ranges to control <span class="literal">for</span> loops. Rather than looping through the characters of a string, a range <span class="literal">for</span> loop loops through integers. If we provide one argument to <span class="literal">range</span>, we get a range from 0 to 1 less than that argument:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">for num in range(5):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
0<br/>&#13;&#13;
1<br/>&#13;&#13;
2<br/>&#13;&#13;
3<br/>&#13;&#13;
4</p>&#13;&#13;
<p class="indent">Notice that <span class="literal">5</span> is not output.</p>&#13;&#13;
<p class="indent">If we provide two arguments to <span class="literal">range</span>, we get a sequence from the first argument up to but not including the second argument:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">for num in range(3, 7):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
<span epub:type="pagebreak" id="page_60"/>&#13;&#13;
...<br/>&#13;&#13;
3<br/>&#13;&#13;
4<br/>&#13;&#13;
5<br/>&#13;&#13;
6</p>&#13;&#13;
<p class="indent">We can count up by a different <em>step size</em> by including a third argument. The default step size is <span class="literal">1</span>, which counts up by one. Let’s try a couple of other step sizes:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">for num in range(0, 10, 2):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
0<br/>&#13;&#13;
2<br/>&#13;&#13;
4<br/>&#13;&#13;
6<br/>&#13;&#13;
8<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for num in range(0, 10, 3):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
0<br/>&#13;&#13;
3<br/>&#13;&#13;
6<br/>&#13;&#13;
9</p>&#13;&#13;
<p class="indent">We can count backward, too, but <em>not</em> like this:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">for num in range(6, 2):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...</p>&#13;&#13;
<p class="indent">That doesn’t work, because by default <span class="literal">range</span> counts up. A step size of <span class="literal">-1</span> lets us go backward, one at a time:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">for num in range(6, 2, -1):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
6<br/>&#13;&#13;
5<br/>&#13;&#13;
4<br/>&#13;&#13;
3</p>&#13;&#13;
<p class="indent">To count down from <span class="literal">6</span> to <span class="literal">0</span>, including <span class="literal">0</span>, we need a value of <span class="literal">-1</span> for the second argument:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">for num in range(6, -1, -1):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
6<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_61"/>&#13;&#13;
5<br/>&#13;&#13;
4<br/>&#13;&#13;
3<br/>&#13;&#13;
2<br/>&#13;&#13;
1<br/>&#13;&#13;
0</p>&#13;&#13;
<p class="indent">It’s sometimes helpful to quickly look at the numbers in a range without coding a loop. Unfortunately, the <span class="literal">range</span> function doesn’t directly show us those numbers:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">range(3, 7)</span><br/>&#13;&#13;
range(3, 7)</p>&#13;&#13;
<p class="indent">We can pass that result to the <span class="literal">list</span> function to get what we want:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">list(range(3, 7))</span><br/>&#13;&#13;
[3, 4, 5, 6]</p>&#13;&#13;
<p class="indent">When called with a range, the <span class="literal">list</span> function produces a list of the range’s integers. We’ll learn all about lists later; for now, keep <span class="literal">list</span> in mind as an aid to diagnosing errors with ranges.</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">How many iterations are performed by the following loop?</p>&#13;&#13;
<p class="programs">for i in range(10, 20):<br/>&#13;&#13;
    # Some code here</p>&#13;&#13;
<p class="alphat">A. 9</p>&#13;&#13;
<p class="alpha">B. 10</p>&#13;&#13;
<p class="alpha">C. 11</p>&#13;&#13;
<p class="alpha">D. 20</p>&#13;&#13;
<p class="sb-noindent1">Answer: B. The range goes through the numbers 10, 11, 12, 13, 14, 15, 16, 17, 18, and 19. There are 10 numbers and hence 10 iterations.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch03lev1sec10">Range for Loops Through Indices</h3>&#13;&#13;
<p class="noindent">Suppose we have strings giving yesterday’s and today’s parking-space information:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">yesterday = 'CC.'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">today = '.C.'</span></p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_62"/>Given an index, we can look at yesterday’s and today’s information for that index:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">yesterday[0]</span><br/>&#13;&#13;
'C'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">today[0]</span><br/>&#13;&#13;
'.'</p>&#13;&#13;
<p class="indent">We can use a range <span class="literal">for</span> loop through the indices to process each pair of corresponding characters. We know that <span class="literal">yesterday</span> and <span class="literal">today</span> are the same length. But that length could be anything from 1 to 100, so we can’t write something like <span class="literal">range(3)</span>. We want to iterate with indices 0, 1, 2, and so on, all the way up to the length of the string minus 1. We can do that by using the length of one of the strings as the argument to <span class="literal">range</span>:</p>&#13;&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">for index in range(len(yesterday)):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(yesterday[index], today[index])</span><br/>&#13;&#13;
...<br/>&#13;&#13;
C .<br/>&#13;&#13;
C C<br/>&#13;&#13;
. .</p>&#13;&#13;
<p class="indent">I’ve called the loop variable <span class="literal">index</span>. Other popular names include <span class="literal">i</span> (the first letter of <span class="literal">index</span>) and <span class="literal">ind</span>. I’ll use <span class="literal">i</span> from here on out.</p>&#13;&#13;
<p class="indent">Don’t call this loop variable <span class="literal">status</span> or <span class="literal">information</span>. Those names imply that it takes on <span class="literal">'C'</span> and <span class="literal">'.'</span> values, when really it takes on integers.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec11">Solving the Problem</h3>&#13;&#13;
<p class="noindent">With our range <span class="literal">for</span> loops, we’re ready to solve Occupied Spaces. Our strategy is to loop through each index from the beginning of the strings to the end. We can check what’s at each index in both yesterday’s information and today’s information. Using a nested <span class="literal">if</span> statement, we’ll determine whether the parking space was occupied on both days.</p>&#13;&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex03">Listing 3-3</a> has our solution.</p>&#13;&#13;
<p class="programs">   n = int(input())<br/>&#13;&#13;
   yesterday = input()<br/>&#13;&#13;
   today = input()<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❶</span> occupied = 0<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❷</span> for i in range(len(yesterday)):<br/>&#13;&#13;
    <span class="ent">❸</span> if yesterday[i] == 'C' and today[i] == 'C':<br/>&#13;&#13;
        <span class="ent">❹</span> occupied = occupied + 1<br/>&#13;&#13;
<br/>&#13;&#13;
   print(occupied)</p>&#13;&#13;
<p class="ex-caption" id="ch03ex03"><em>Listing 3-3: Solving Occupied Spaces</em></p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_63"/>The program starts by reading the three lines of input: <span class="literal">n</span> refers to the number of parking spaces; and <span class="literal">yesterday</span> and <span class="literal">today</span> refer to yesterday’s and today’s parking-space information, respectively.</p>&#13;&#13;
<p class="indent">Notice that we don’t refer to the number of parking spaces (<span class="literal">n</span>) again. We could make use of it to tell us the length of the strings, but I’ve chosen to ignore it because it’s often not provided in real-life scenarios.</p>&#13;&#13;
<p class="indent">We use the <span class="literal">occupied</span> variable to count the number of parking spaces that were occupied both yesterday and today. We start that variable off at <span class="literal">0</span> <span class="ent">❶</span>.</p>&#13;&#13;
<p class="indent">Now we reach the range <span class="literal">for</span> loop, which loops through the valid indices of <span class="literal">yesterday</span> and <span class="literal">today</span> <span class="ent">❷</span>. For each such index, we check whether the parking space was occupied yesterday and occupied today <span class="ent">❸</span>. If it was, then we include this parking space in our total by increasing <span class="literal">occupied</span> by <span class="literal">1</span> <span class="ent">❹</span>.</p>&#13;&#13;
<p class="indent">When the range <span class="literal">for</span> loop terminates, we’ll have gone through all parking spaces. The total number of parking spaces that were occupied yesterday and today can be accessed through the <span class="literal">occupied</span> variable. All that’s left is to output that total.</p>&#13;&#13;
<p class="indent">That’ll do it for this problem. Time to submit your code to the judge.</p>&#13;&#13;
<h3 class="h3a" id="ch03lev1sec12"><span class="h3aa">Problem #7: Data Plan</span></h3>&#13;&#13;
<p class="noindent">We’ve learned that <span class="literal">for</span> loops are useful for processing data after we’ve read it from the input. They’re also often useful for reading the data itself. In this problem, we’ll tackle data that’s spread over many lines and use a <span class="literal">for</span> loop to help us read it all.</p>&#13;&#13;
<p class="indent">This is DMOJ problem <span class="literal">coci16c1p1</span>.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec7">The Challenge</h4>&#13;&#13;
<p class="noindent">Pero has a data plan with his cell phone provider that offers him <em>x</em> megabytes of data per month. In addition, any data he doesn’t use in a given month carries over to the next month. For example, if <em>x</em> is 10 and Pero uses only 4MB in a given month, the remaining 6MB carry over to the next month (in which he’d now have 10 + 6 = 16MB available).</p>&#13;&#13;
<p class="indent">We’re given the number of megabytes of data that Pero uses in each of the first <em>n</em> months. Our task is to determine the number of megabytes available for the following month.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec8">Input</h4>&#13;&#13;
<p class="noindent">The input consists of the following lines:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">A line containing integer <em>x</em>, the number of megabytes given to Pero per month. <em>x</em> is between 1 and 100.</li>&#13;&#13;
<li class="noindent">A line containing integer <em>n</em>, the number of months that Pero has had the data plan. <em>n</em> is between 1 and 100.&#13;&#13;
</li>&#13;&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_64"/><em>n</em> lines, one for each month, giving the integer number of megabytes that Pero uses in that month. Each number is at least 0 and will never outstrip the number of available megabytes. (For example, if <em>x</em> is 10 and Pero currently has 30MB available, the next number will be at most 30.)</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch03lev2sec9">Output</h4>&#13;&#13;
<p class="noindent">Output the number of megabytes available for the next month.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec13">Looping to Read Input</h3>&#13;&#13;
<p class="noindent">In all of our problems so far, we’ve known exactly how many lines to read from the input. For example, in Three Cups, we read one line; in Occupied Spaces, we read three lines. Here in Data Plan, we don’t know in advance how many lines to read, because it depends on the number that we read from the second line.</p>&#13;&#13;
<p class="indent">We can read the first line of input:</p>&#13;&#13;
<p class="programs">monthly_mb = int(input())</p>&#13;&#13;
<p class="noindent">(I’ve used variable name <span class="literal">monthly_mb</span> rather than <span class="literal">x</span> to imbue it with some meaning.)</p>&#13;&#13;
<p class="indent">And we can read the second line of input:</p>&#13;&#13;
<p class="programs">n = int(input())</p>&#13;&#13;
<p class="indent">But we can’t read any more without a loop. A range <span class="literal">for</span> loop is perfect here, because we can use it to loop exactly <span class="literal">n</span> times:</p>&#13;&#13;
<p class="programs">for i in range(n):<br/>&#13;&#13;
    # Process month</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec14">Solving the Problem</h3>&#13;&#13;
<p class="noindent">My strategy for solving the problem is to keep track of the number of megabytes that are carried over from previous months. I call this the <em>excess</em>.</p>&#13;&#13;
<p class="indent">Consider this test case:</p>&#13;&#13;
<p class="programs">10<br/>&#13;&#13;
3<br/>&#13;&#13;
4<br/>&#13;&#13;
12<br/>&#13;&#13;
1</p>&#13;&#13;
<p class="indent">In each month, Pero is given 10MB of data, and we have to process the data that he used in the provided three months. In the first month, Pero is given 10MB and uses 4MB, so the excess that carries forward is 6MB. In the second month, Pero is given 10MB more, so now he has 16MB total. He uses <span epub:type="pagebreak" id="page_65"/>12MB this month, so the excess that carries forward is 16 – 12 = 4MB. In the third month, Pero is given 10MB more, so now he has 14MB total. He uses 1MB this month, so the excess that carries forward is 14 – 1 = 13MB.</p>&#13;&#13;
<p class="indent">We need to know the number of megabytes that Pero has available for the next (that is, fourth) month. He has 13MB that carry over from the first three months, and he’s given his usual 10MB for this month, so he has a total of 13 + 10 = 23MB to use.</p>&#13;&#13;
<p class="indent">When I went to write the code based on this explanation, I neglected to add this final 10, so my output was 13 instead of 23. I was focusing exclusively on the excess and forgot that what we need is not the excess going into the next month, but the total number of megabytes available. That total is the excess plus whatever Pero is given per month.</p>&#13;&#13;
<p class="indent">See <a href="ch03.xhtml#ch03ex04">Listing 3-4</a> for the (corrected!) code.</p>&#13;&#13;
<p class="programs">   monthly_mb = int(input())<br/>&#13;&#13;
   n = int(input())<br/>&#13;&#13;
<br/>&#13;&#13;
   excess = 0<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❶</span> for i in range(n):<br/>&#13;&#13;
       used = int(input())<br/>&#13;&#13;
    <span class="ent">❷</span> excess = excess + monthly_mb - used<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❸</span> print(excess + monthly_mb)</p>&#13;&#13;
<p class="ex-caption" id="ch03ex04"><em>Listing 3-4: Solving Data Plan</em></p>&#13;&#13;
<p class="indent">The <span class="literal">excess</span> variable begins at <span class="literal">0</span>. On each iteration of the range <span class="literal">for</span> loop, we assign a value to <span class="literal">excess</span> that considers the number of megabytes given per month and the number of megabytes used in that month.</p>&#13;&#13;
<p class="indent">The range <span class="literal">for</span> loop loops <span class="literal">n</span> times, once for each month that Pero has had the data plan <span class="ent">❶</span>. The values that <span class="literal">i</span> takes on—<span class="literal">0</span>, <span class="literal">1</span>, and so on—aren’t of interest to us, because we have no reason to care about which month we’re processing. For that reason, we don’t use the value of <span class="literal">i</span> anywhere in the program. You can replace <span class="literal">i</span> with <span class="literal">_</span> (an underscore) to be explicit about the variable’s “don’t care” status, but I’ll leave it as <span class="literal">i</span> for consistency with other examples.</p>&#13;&#13;
<p class="indent">In the range <span class="literal">for</span> loop, we read the number of megabytes used in this month. Then, we update the number of excess megabytes <span class="ent">❷</span>: it’s what it was before, plus the number of megabytes that Pero gets per month, minus the number of megabytes that Pero uses this month.</p>&#13;&#13;
<p class="indent">Having computed the excess number of megabytes after <span class="literal">n</span> months, we report the number of megabytes available for the next month <span class="ent">❸</span>.</p>&#13;&#13;
<p class="indent">There are always multiple ways to solve a problem. Programming is creative, and I enjoy observing the range of solution strategies that people come up with. Even if you’ve succeeded in solving a problem, you might like to Google the problem to learn from how others have solved it. In addition, some online judges, like DMOJ, allow you to view other people’s submissions once you’ve solved the problem. For submissions that pass all of the test cases: did those programmers do things differently from you? For <span epub:type="pagebreak" id="page_66"/>submissions that fail some test cases: what’s wrong with the code? Reading other people’s code is a great way to improve your own programming skill!</p>&#13;&#13;
<p class="indent">Can you think of another way to solve Data Plan?</p>&#13;&#13;
<p class="indent">Here’s a hint: you can start by calculating the total number of megabytes that Pero is given and then subtracting the number of megabytes that he uses. I encourage you to take some time to work out how to do this before continuing!</p>&#13;&#13;
<p class="indent">The total number of megabytes given to Pero, including those given in the next month, is <em>x</em> * (<em>n</em> + 1), where <em>x</em> is the number of megabytes given per month. To determine the number of megabytes available for the next month, we can start with that total and subtract what Pero uses each month. That strategy is coded in <a href="ch03.xhtml#ch03ex05">Listing 3-5</a>.</p>&#13;&#13;
<p class="programs">monthly_mb = int(input())<br/>&#13;&#13;
n = int(input())<br/>&#13;&#13;
<br/>&#13;&#13;
total_mb = monthly_mb * (n + 1)<br/>&#13;&#13;
<br/>&#13;&#13;
for i in range(n):<br/>&#13;&#13;
    used = int(input())<br/>&#13;&#13;
    total_mb = total_mb - used<br/>&#13;&#13;
<br/>&#13;&#13;
print(total_mb)</p>&#13;&#13;
<p class="ex-caption" id="ch03ex05"><em>Listing 3-5: Solving Data Plan, alternate approach</em></p>&#13;&#13;
<p class="indent">Choose whichever solution is your favorite, and submit to the judge.</p>&#13;&#13;
<p class="indent">What’s intuitive to one person may not be intuitive to another. You might read an explanation or code and not be able to make sense of it. This doesn’t mean that you’re not smart enough. It just means you need a different presentation, one that aligns more closely to your current thinking. You might also flag difficult explanations and examples for later review. They may prove to be surprisingly useful once you’ve gained further practice.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec15">Summary</h3>&#13;&#13;
<p class="noindent">In this chapter, we learned about <span class="literal">for</span> loops. Standard <span class="literal">for</span> loops loop through the characters of a sequence; range <span class="literal">for</span> loops loop through integers in a range. Each problem that we solved required us to process many pieces of input, and we wouldn’t have been able to manage that without a loop.</p>&#13;&#13;
<p class="indent">The <span class="literal">for</span> loop is the loop of choice whenever you need to repeat code a specified number of times. Python has one other type of loop, and we’ll learn how to use it in the next chapter. Why do we need anything besides <span class="literal">for</span> loops? What can’t <span class="literal">for</span> loops do? Good questions! I’ll tell you this for now: practicing with <span class="literal">for</span> loops is a wonderful way to prepare for what’s to come.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec16"><span epub:type="pagebreak" id="page_67"/>Chapter Exercises</h3>&#13;&#13;
<p class="noindent">Here are some exercises for you to try.</p>&#13;&#13;
<ol>&#13;&#13;
<li class="noindent">DMOJ problem <span class="literal">wc17c3j3</span>, Uncrackable</li>&#13;&#13;
<li class="noindent">DMOJ problem <span class="literal">coci18c3p1</span>, Magnus</li>&#13;&#13;
<li class="noindent">DMOJ problem <span class="literal">ccc11s1</span>, English or French</li>&#13;&#13;
<li class="noindent">DMOJ problem <span class="literal">ccc11s2</span>, Multiple Choice</li>&#13;&#13;
<li class="noindent">DMOJ problem <span class="literal">coci12c5p1</span>, Ljestvica</li>&#13;&#13;
<li class="noindent">DMOJ problem <span class="literal">coci13c3p1</span>, Rijeci</li>&#13;&#13;
<li class="noindent">DMOJ problem <span class="literal">coci18c4p1</span>, Elder</li>&#13;&#13;
</ol>&#13;&#13;
<h3 class="h3" id="ch03lev1sec17">Notes</h3>&#13;&#13;
<p class="noindent">Three Cups is originally from the 2006/2007 Croatian Open Competition in Informatics, Contest 5. Occupied Spaces is originally from the 2018 Canadian Computing Competition, Junior Level. Data Plan is originally from the 2016/2017 Croatian Open Competition in Informatics, Contest 1.</p>&#13;&#13;
<span epub:type="pagebreak" id="page_68"/>&#13;&#13;
</div></body></html>