<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_47"/><span class="big">3</span><br/>REPEATING CODE: DEFINITE LOOPS</h2>&#13;&#13;
<div class="imagec"><img src="Images/common.jpg" alt="image" width="150" height="150"/></div>&#13;&#13;
<p class="noindents">Computers shine when we have them repeat a process over and over. They tirelessly do exactly what we ask, whether it involves doing something 10, 100, or a billion times. In this chapter, we’ll learn about loops, statements that instruct the computer to repeat the execution of part of our program.</p>&#13;&#13;
<p class="indent">We’ll use loops to solve three problems: tracking the location of a ball under a cup, counting the number of occupied parking spaces, and determining how much data is available on a cell phone plan.</p>&#13;&#13;
<h3 class="h3a" id="ch03lev1sec1"><span class="h3aa">Problem #5: Three Cups</span></h3>&#13;&#13;
<p class="noindent">In this problem, we’ll track the location of a ball under a cup as the cups move. But the cups can move many times, so we won’t be able to write code for each move separately. Instead, we’ll learn about and use the <code>for</code> loop, which allows us to more easily run code for each move.</p>&#13;&#13;
<p class="indent">This is DMOJ problem <code>coci06c5p1</code>.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec1"><span epub:type="pagebreak" id="page_48"/>The Challenge</h4>&#13;&#13;
<p class="noindent">Borko has a row of three opaque cups: one at the left (location 1), one at the middle (location 2), and one at the right (location 3). There is a ball under the cup at the left. It’s our job to keep track of the location of the ball as Borko swaps the locations of the cups.</p>&#13;&#13;
<p class="indentb">Borko can make three types of swap:</p>&#13;&#13;
<p class="uln-indent"><strong>A</strong> Swap the left and middle cups</p>&#13;&#13;
<p class="uln-indent"><strong>B</strong> Swap the middle and right cups</p>&#13;&#13;
<p class="uln-indent"><strong>C</strong> Swap the left and right cups</p>&#13;&#13;
<p class="indenta">For example, if Borko’s first swap is type A, then he swaps the left and middle cups; because the ball starts at the left, this swap moves it to the middle. If instead his first swap is type B, then he swaps the middle and right cups; the left cup stays where it is, so the ball doesn’t change locations.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec2">Input</h4>&#13;&#13;
<p class="noindent">The input is one line of at most 50 characters. Each character specifies a type of swap that Borko makes: <code>A</code>, <code>B</code>, or <code>C</code>.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec3">Output</h4>&#13;&#13;
<p class="noindent">Output the final location of the ball:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent"><code>1</code> if the ball is at the left</li>&#13;&#13;
<li class="noindent"><code>2</code> if the ball is at the middle</li>&#13;&#13;
<li class="noindent"><code>3</code> if the ball is at the right</li>&#13;&#13;
</ul>&#13;&#13;
<h3 class="h3" id="ch03lev1sec2">Why Loops?</h3>&#13;&#13;
<p class="noindent">Consider this test case:</p>&#13;&#13;
<pre>ACBA</pre>&#13;&#13;
<p class="indent">There are four swaps here. To determine the final location of the ball, we need to carry out each one.</p>&#13;&#13;
<p class="indent">The first swap is type <code>A</code>, which swaps the cups at the left and middle. Since the ball starts at the left, this results in the ball moving to the middle. The second swap is type <code>C</code>, which swaps the cups at the left and right. Since the ball is currently at the middle, this has no effect on the location of the ball. The third swap is type <code>B</code>, which swaps the cups at the middle and right. This moves the ball from the middle to the right. The fourth swap is type <code>A</code>, which swaps the cups at the left and middle. This has no effect on the ball. The correct output is therefore <code>3</code>, because the ball ends up at the right.</p>&#13;&#13;
<p class="indent">Notice that for each swap, we have to make a decision to determine whether the ball moves and, if it does, to move the ball appropriately. Making decisions is something we know how to do from <a href="ch02.xhtml#ch02">Chapter 2</a>. For example, <span epub:type="pagebreak" id="page_49"/>if the swap type is <code>A</code> and the ball is at the left, then the ball moves to the middle. That looks like this:</p>&#13;&#13;
<pre>if swap_type == 'A' and ball_location == 1:<br/>&#13;&#13;
    ball_location = 2</pre>&#13;&#13;
<p class="indent">We could add an <code>elif</code> for each other case where the ball moves: swap type <code>A</code> and ball is at the middle, swap type <code>B</code> and ball is at the middle, swap type <code>B</code> and ball is at the right, and so on. This big <code>if</code> statement would be enough to handle one swap. But that’s not enough to solve the Three Cups problem, because we could have a test case of up to 50 swaps. We’d need to repeat the <code>if</code> statement logic for each swap. And we certainly wouldn’t want to copy and paste the same code 50 times. Imagine if you had made a typo and had to fix it 50 times. Or if you suddenly became interested in test cases with up to a million swaps. No, what we have learned so far is not going to cut it. We need a way to walk through the swaps, performing the same logic for each one. We need a loop.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec3">for Loops</h3>&#13;&#13;
<p class="noindent">Python’s <code>for</code> statement produces <em>for loops</em>. <code>for</code> loops allow us to process each element of a sequence. The only sequence type we’ve seen so far is the string. We’ll learn others as we go; <code>for</code> loops work on all of them.</p>&#13;&#13;
<p class="indent">Here’s our first example of a <code>for</code> loop:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">secret_word = 'olive'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for char in secret_word:</span><br/>&#13;&#13;
...     <span class="codestrong1">print('Letter: ' + char)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
Letter: o<br/>&#13;&#13;
Letter: l<br/>&#13;&#13;
Letter: i<br/>&#13;&#13;
Letter: v<br/>&#13;&#13;
Letter: e</pre>&#13;&#13;
<p class="indent">Following the keyword <code>for</code>, we write the name of a <em>loop variable</em>. A loop variable is one that refers to different values as a loop progresses. In a <code>for</code> loop on a string, the loop variable refers to each of the string’s characters.</p>&#13;&#13;
<p class="indent">I’ve chosen the variable name <code>char</code> (for “character”) to remind us that the variable refers to a character from the string. Sometimes, it’s clearer if we use a contextual variable name. For example, in Three Cups, we could instead use the name <code>swap_type</code> to remind us that it refers to a type of swap.</p>&#13;&#13;
<p class="indent">After the variable name, we have the keyword <code>in</code> and then the string that we want to loop over. In our example, we’re looping over the string referred to by <code>secret_word</code>, which is <code>'olive'</code>.</p>&#13;&#13;
<p class="indent">Like the <code>if</code>, <code>elif</code>, and <code>else</code> lines of an <code>if</code> statement, the <code>for</code> line ends with a colon (<code>:</code>). And, also like an <code>if</code> statement, a <code>for</code> statement has an indented block of one or more statements.</p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_50"/>An execution of the indented statements is referred to as an <em>iteration</em> of the loop. Here’s a walk-through of what our loop does on each iteration:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">On the first iteration, Python sets <code>char</code> to refer to <code>'o'</code>, the first character of <code>'olive'</code>. It then runs the loop block, which consists only of the call to <code>print</code>. As <code>char</code> refers to <code>'o'</code>, the output produced is <code>Letter: o</code>.</li>&#13;&#13;
<li class="noindent">On the second iteration, Python sets <code>char</code> to refer to <code>'l'</code>, the second character of <code>'olive'</code>. It then calls <code>print</code>, outputting <code>Letter: l</code>.</li>&#13;&#13;
<li class="noindent">This process repeats three more times, once for each remaining character in <code>'olive'</code>.</li>&#13;&#13;
<li class="noindent">The loop then terminates. We have no code after the loop, so our program has finished running. If there was additional code after the loop, then execution would continue with that code.</li>&#13;&#13;
</ul>&#13;&#13;
<p class="indent">You can put multiple statements in the block of a <code>for</code> loop. Here’s an example:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">secret_word = 'olive'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for char in secret_word:</span><br/>&#13;&#13;
...     <span class="codestrong1">print('Letter: ' + char)</span><br/>&#13;&#13;
...     <span class="codestrong1">print('*')</span><br/>&#13;&#13;
...<br/>&#13;&#13;
Letter: o<br/>&#13;&#13;
*<br/>&#13;&#13;
Letter: l<br/>&#13;&#13;
*<br/>&#13;&#13;
Letter: i<br/>&#13;&#13;
*<br/>&#13;&#13;
Letter: v<br/>&#13;&#13;
*<br/>&#13;&#13;
Letter: e<br/>&#13;&#13;
*</pre>&#13;&#13;
<p class="indent">Now we have two statements executing on each iteration of the loop: one that outputs the current letter of the string, and one that outputs a <code>*</code> character.</p>&#13;&#13;
<p class="indent">A <code>for</code> loop loops through the elements of a sequence, so the sequence’s length tells us how many iterations there will be. The <code>len</code> function takes a string and returns its length:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">len('olive')</span><br/>&#13;&#13;
5</pre>&#13;&#13;
<p class="indent">Our <code>for</code> loop on <code>'olive'</code> will therefore consist of five iterations:</p>&#13;&#13;
<pre>   &gt;&gt;&gt; <span class="codestrong1">secret_word = 'olive'</span><br/>&#13;&#13;
<span class="ent">❶</span> &gt;&gt;&gt; <span class="codestrong1">print(len(secret_word), 'iterations, coming right up!')</span><br/>&#13;&#13;
   &gt;&gt;&gt; <span class="codestrong1">for char in secret_word:</span><br/>&#13;&#13;
<span epub:type="pagebreak" id="page_51"/>&#13;&#13;
   ...     <span class="codestrong1">print('Letter: ' + char)</span><br/>&#13;&#13;
   ...<br/>&#13;&#13;
   5 iterations, coming right up!<br/>&#13;&#13;
   Letter: o<br/>&#13;&#13;
   Letter: l<br/>&#13;&#13;
   Letter: i<br/>&#13;&#13;
   Letter: v<br/>&#13;&#13;
   Letter: e</pre>&#13;&#13;
<p class="indent">I called <code>print</code> with multiple arguments <span class="ent">❶</span>, rather than using concatenation, to avoid having to convert the length to a string.</p>&#13;&#13;
<p class="indent">A <code>for</code> loop is what’s called a <em>definite loop</em>, referring to the idea that the number of iterations is predetermined. There are also <em>indefinite loops</em>, whose iterations depend on the vagaries of what happens when your program runs. We’ll study those in the next chapter.</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">What is the output of the following code?</p>&#13;&#13;
<pre>s = 'garage'<br/>&#13;&#13;
total = 0<br/>&#13;&#13;
<br/>&#13;&#13;
for char in s:<br/>&#13;&#13;
    total = total + s.count(char)<br/>&#13;&#13;
<br/>&#13;&#13;
print(total)</pre>&#13;&#13;
<p class="alphat">A. <code>6</code></p>&#13;&#13;
<p class="alpha">B. <code>10</code></p>&#13;&#13;
<p class="alpha">C. <code>12</code></p>&#13;&#13;
<p class="alpha">D. <code>36</code></p>&#13;&#13;
<p class="sb-noindent1">Answer: B. For each character in <code>'garage'</code>, we add its count to <code>total</code>. There are two <code>g</code>’s, two <code>a</code>’s, one <code>r</code>, two <code>a</code>’s (again!), two <code>g</code>’s (again!), and 1 <code>e</code>.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch03lev1sec4">Nesting</h3>&#13;&#13;
<p class="noindent">The <code>for</code> loop block is one or more statements. Those statements can include one-line statements such as function calls and assignment statements. But they can also include multiline statements such as <code>if</code> statements and loops.</p>&#13;&#13;
<p class="indent">Let’s start with an example of an <code>if</code> statement inside a <code>for</code> loop. Suppose we wanted to output only the uppercase characters from a string. Strings <span epub:type="pagebreak" id="page_52"/>have an <code>isupper</code> method that we can use to determine whether a character is uppercase:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">'q'.isupper()</span><br/>&#13;&#13;
False<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">'Q'.isupper()</span><br/>&#13;&#13;
True</pre>&#13;&#13;
<p class="indent">We can use <code>isupper</code> in an <code>if</code> statement to control what happens on each iteration of a <code>for</code> loop:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">title = 'The Escape'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for char in title:</span><br/>&#13;&#13;
...     <span class="codestrong1">if char.isupper():</span><br/>&#13;&#13;
...         <span class="codestrong1">print(char)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
T<br/>&#13;&#13;
E</pre>&#13;&#13;
<p class="indent">Be careful with the indentation here. We need one level of indentation for the <code>for</code> loop, and an extra level of indentation for the nested <code>if</code> statement.</p>&#13;&#13;
<p class="indent">On the first iteration, <code>char</code> refers to <code>'T'</code>. Since <code>'T'</code> is uppercase, the <code>isupper</code> test returns <code>True</code>, and the <code>if</code> statement block runs. That results in the output of <code>T</code>. On the second iteration, <code>char</code> refers to <code>'h'</code>. This time, the <code>isupper</code> test returns <code>False</code>, so the <code>if</code> statement block doesn’t run. Overall, the <code>for</code> loop loops through each character of the string, but the nested <code>if</code> statement fires only twice: on the <code>'T'</code> at the beginning of the string and on the <code>'E'</code> at the beginning of <code>'Escape'</code>.</p>&#13;&#13;
<p class="indent">What about a <code>for</code> loop nested in a <code>for</code> loop? We can do that! Here’s an example:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">letters = 'ABC'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">digits = '123'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for letter in letters:</span><br/>&#13;&#13;
...     <span class="codestrong1">for digit in digits:</span><br/>&#13;&#13;
...         <span class="codestrong1">print(letter + digit)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
A1<br/>&#13;&#13;
A2<br/>&#13;&#13;
A3<br/>&#13;&#13;
B1<br/>&#13;&#13;
B2<br/>&#13;&#13;
B3<br/>&#13;&#13;
C1<br/>&#13;&#13;
C2<br/>&#13;&#13;
C3</pre>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_53"/>The code produces all two-character strings whose first character is from <code>letters</code> and whose second character is from <code>digits</code>.</p>&#13;&#13;
<p class="indent">On the first iteration of the outer (<code>letters</code>) loop, <code>letter</code> refers to <code>'A'</code>. This iteration involves completely running the inner (<code>digits</code>) loop. The whole time the inner loop runs, <code>letter</code> refers to <code>'A'</code>. On the first iteration of the inner loop, <code>digit</code> refers to <code>1</code>, which explains the <code>A1</code> output. On the second iteration of the inner loop, <code>digit</code> refers to <code>2</code>, and <code>A2</code> is output. On the third and final iteration of the inner loop, <code>digit</code> refers to <code>3</code>, and <code>A3</code> is output.</p>&#13;&#13;
<p class="indent">We’re not done! We’ve gone through only one iteration of the outer loop. On the second iteration of the outer loop, <code>letter</code> refers to <code>'B'</code>. Now the three iterations of the inner loop run again, this time with <code>letter</code> referring to <code>'B'</code>. This accounts for the <code>B1</code>, <code>B2</code>, and <code>B3</code> outputs. Finally, on the third iteration of the outer loop, <code>letter</code> refers to <code>'C'</code>, and the inner loop produces <code>C1</code>, <code>C2</code>, and <code>C3</code>.</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">What is the output of the following code?</p>&#13;&#13;
<pre>title = 'The Escape'<br/>&#13;&#13;
total = 0<br/>&#13;&#13;
<br/>&#13;&#13;
for char1 in title:<br/>&#13;&#13;
    for char2 in title:<br/>&#13;&#13;
        total = total + 1<br/>&#13;&#13;
<br/>&#13;&#13;
print(total)</pre>&#13;&#13;
<p class="alphat">A. <code>10</code></p>&#13;&#13;
<p class="alpha">B. <code>20</code></p>&#13;&#13;
<p class="alpha">C. <code>100</code></p>&#13;&#13;
<p class="alpha">D. This code produces a syntax error because two nested loops cannot both use <code>title</code></p>&#13;&#13;
<p class="sb-noindent1">Answer: C. <code>total</code> starts off as <code>0</code> and is increased by 1 on each iteration of the inner loop. The length of <code>'The Escape'</code> is 10. The outer loop therefore has 10 iterations. For each of those iterations, the inner loop has 10 iterations. The inner loop therefore has 10*10 = 100 iterations in all.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch03lev1sec5"><span epub:type="pagebreak" id="page_54"/>Solving the Problem</h3>&#13;&#13;
<p class="noindent">Back to Three Cups. The structure we need is a <code>for</code> loop to go through each swap, and a nested <code>if</code> statement to keep track of where the ball is:</p>&#13;&#13;
<pre>for swap_type in swaps:<br/>&#13;&#13;
    # Big if statement to keep track of the ball</pre>&#13;&#13;
<p class="indent">There are three types of swaps (A, B, and C) and three possible locations for the ball, so it’s tempting to conclude that we have to write an <code>if</code> statement with 3 * 3 = 9 Boolean expressions (one after the <code>if</code> and one after each of eight <code>elif</code>s). In fact, we need only six Boolean expressions. Three of the nine don’t move the ball at all: swap type A when the ball is at the right, swap type B when the ball is at the left, and swap type C when the ball is at the middle.</p>&#13;&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex01">Listing 3-1</a> has a solution to Three Cups.</p>&#13;&#13;
<pre>   swaps = input()<br/>&#13;&#13;
<br/>&#13;&#13;
   ball_location = 1<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❶</span> for swap_type in swaps:<br/>&#13;&#13;
    <span class="ent">❷</span> if swap_type == 'A' and ball_location == 1:<br/>&#13;&#13;
        <span class="ent">❸</span> ball_location = 2<br/>&#13;&#13;
       elif swap_type == 'A' and ball_location == 2:<br/>&#13;&#13;
           ball_location = 1<br/>&#13;&#13;
       elif swap_type == 'B' and ball_location == 2:<br/>&#13;&#13;
           ball_location = 3<br/>&#13;&#13;
       elif swap_type == 'B' and ball_location == 3:<br/>&#13;&#13;
           ball_location = 2<br/>&#13;&#13;
       elif swap_type == 'C' and ball_location == 1:<br/>&#13;&#13;
           ball_location = 3<br/>&#13;&#13;
       elif swap_type == 'C' and ball_location == 3:<br/>&#13;&#13;
           ball_location = 1<br/>&#13;&#13;
<br/>&#13;&#13;
   print(ball_location)</pre>&#13;&#13;
<p class="ex-caption" id="ch03ex01"><em>Listing 3-1: Solving Three Cups</em></p>&#13;&#13;
<p class="indent">I’ve used <code>input</code> to assign the string of swaps to the <code>swaps</code> variable. The <code>for</code> loop <span class="ent">❶</span> loops through these swaps. Each swap is processed by the nested <code>if</code> statement <span class="ent">❷</span>. The <code>if</code> and <code>elif</code> branches each encode what happens with a given type of swap and a given ball location and then move the ball accordingly. For example, if the swap type is <code>A</code> and the ball is at location 1 <span class="ent">❷</span>, then the ball ends up at location 2 <span class="ent">❸</span>.</p>&#13;&#13;
<p class="indent">This is a code example where it matters whether we use multiple <code>elif</code>s (one big <code>if</code> statement) or multiple <code>if</code>s (multiple <code>if</code> statements). If we change the <code>elif</code>s to <code>if</code>s, then our code is no longer correct. <a href="ch03.xhtml#ch03ex02">Listing 3-2</a> shows the incorrect code.</p>&#13;&#13;
<pre><span epub:type="pagebreak" id="page_55"/># This code is incorrect<br/>&#13;&#13;
<br/>&#13;&#13;
swaps = input()<br/>&#13;&#13;
<br/>&#13;&#13;
ball_location = 1<br/>&#13;&#13;
<br/>&#13;&#13;
for swap_type in swaps:<br/>&#13;&#13;
 <span class="ent">❶</span> if swap_type == 'A' and ball_location == 1:<br/>&#13;&#13;
        ball_location = 2<br/>&#13;&#13;
 <span class="ent">❷</span> if swap_type == 'A' and ball_location == 2:<br/>&#13;&#13;
        ball_location = 1<br/>&#13;&#13;
    if swap_type == 'B' and ball_location == 2:<br/>&#13;&#13;
        ball_location = 3<br/>&#13;&#13;
    if swap_type == 'B' and ball_location == 3:<br/>&#13;&#13;
        ball_location = 2<br/>&#13;&#13;
    if swap_type == 'C' and ball_location == 1:<br/>&#13;&#13;
        ball_location = 3<br/>&#13;&#13;
    if swap_type == 'C' and ball_location == 3:<br/>&#13;&#13;
        ball_location = 1<br/>&#13;&#13;
<br/>&#13;&#13;
print(ball_location)</pre>&#13;&#13;
<p class="ex-caption" id="ch03ex02"><em>Listing 3-2: Solving Three Cups incorrectly</em></p>&#13;&#13;
<p class="indent">If we say that the code is incorrect, we’re claiming that it fails at least one test case. Can you find a test case where this code produces the wrong answer?</p>&#13;&#13;
<p class="indent">Here’s one such test case:</p>&#13;&#13;
<pre>A</pre>&#13;&#13;
<p class="indent">It may make sense to us that the ball can move at most once per swap. But Python robotically runs the code you have written, whether it matches what we expect or not. In this case, we have only one swap, so the ball should move at most once. On the first and only iteration of the <code>for</code> loop, Python checks the expression <span class="ent">❶</span>. It’s <code>True</code>, so Python sets <code>ball_location</code> to <code>2</code>. Then, Python checks the expression <span class="ent">❷</span>. Because we just changed <code>ball_location</code> to <code>2</code>, this expression is <code>True</code>! Python therefore sets <code>ball_location</code> to <code>1</code>. The output of the program is <code>1</code> when it should be <code>2</code>.</p>&#13;&#13;
<p class="indent">This is an example of a <em>logic error</em>: an error that causes a program to follow the wrong logic and produce the wrong answer. A common term for logic error is a <em>bug</em>. When programmers work through their code to fix bugs, it’s called <em>debugging</em>.</p>&#13;&#13;
<p class="indent">It often takes only a simple test case to demonstrate when a program is incorrect. When you’re trying to narrow down what’s going wrong with your code, don’t start with long test cases. Such test case results are hard to verify by hand and often set in motion complex execution paths from which we <span epub:type="pagebreak" id="page_56"/>may learn very little. A small test case, by contrast, doesn’t cause our program to do much; if what it does is wrong, then we don’t have far to look for the culprit. Devising small, targeted test cases is not always easy. It’s a skill that you can hone through practice.</p>&#13;&#13;
<p class="indent">Submit our correct code to the judge, and then let’s move on.</p>&#13;&#13;
<p class="indent">Before continuing, you might like to try solving exercises 1 and 2 from “Chapter Exercises” on <a href="ch03.xhtml#ch03lev1sec16">page 67</a>.</p>&#13;&#13;
<h3 class="h3a" id="ch03lev1sec6"><span class="h3aa">Problem #6: Occupied Spaces</span></h3>&#13;&#13;
<p class="noindent">We know how to loop through the characters of a string. But sometimes we need to know where we are in the string, not just the character that’s stored there. This problem is one such example.</p>&#13;&#13;
<p class="indent">This is DMOJ problem <code>ccc18j2</code>.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec4">The Challenge</h4>&#13;&#13;
<p class="noindent">You supervise a parking lot with <em>n</em> parking spaces. Yesterday, you recorded whether each parking space was occupied by a car or was empty. Today, you again recorded whether each parking space was occupied by a car or was empty. Indicate the number of parking spaces that were occupied on both days.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec5">Input</h4>&#13;&#13;
<p class="noindent">The input consists of three lines.</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">The first line contains integer <em>n</em>, the number of parking spaces. <em>n</em> is between 1 and 100.</li>&#13;&#13;
<li class="noindent">The second line contains a string of <em>n</em> characters for yesterday’s information, one character for each parking space. A <code>C</code> indicates an occupied parking space (C for car), and a <code>.</code> indicates an empty parking space. For example, <code>CC.</code> means that the first two parking spaces were occupied and the third was empty.</li>&#13;&#13;
<li class="noindent">The third line contains a string of <em>n</em> characters for today’s information, in the same format as the second line.</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch03lev2sec6">Output</h4>&#13;&#13;
<p class="noindent">Output the number of parking spaces that were occupied on both days.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec7">A New Kind of Loop</h3>&#13;&#13;
<p class="noindent">We could have up to 100 parking spaces, so you may not be surprised that a loop will show up here somewhere. The kind of <code>for</code> loop we learned when <span epub:type="pagebreak" id="page_57"/>solving Three Cups can certainly loop through a string of parking-space information:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">yesterday = 'CC.'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for parking_space in yesterday:</span><br/>&#13;&#13;
...     <span class="codestrong1">print('The space is ' + parking_space)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
The space is C<br/>&#13;&#13;
The space is C<br/>&#13;&#13;
The space is .</pre>&#13;&#13;
<p class="indent">That tells us whether each space was occupied yesterday. But we also need to know whether each space was also occupied today.</p>&#13;&#13;
<p class="indent">Consider this test case:</p>&#13;&#13;
<pre>3<br/>&#13;&#13;
CC.<br/>&#13;&#13;
.C.</pre>&#13;&#13;
<p class="indent">The first parking space was occupied yesterday. Was that parking space occupied on both days? To answer that, we need to look at the corresponding character in today’s string. It’s a <code>.</code> (empty), so this parking space was not occupied on both days.</p>&#13;&#13;
<p class="indent">What about the second parking space? That one was also occupied yesterday. And, looking at the second character of today’s string, it was also occupied today. So this <em>is</em> a parking space that was occupied on both days. (This is the only such parking space; the correct output for this test case is <code>1</code>.)</p>&#13;&#13;
<p class="indent">Looping through the characters of one string doesn’t help us find the corresponding characters in the other string. But if we could keep track of where we were in the string—we’re at the first parking space, we’re at the second parking space, and so on—we could look up the corresponding character from each string. The <code>for</code> loops we’ve learned so far are not the way to do this. The way to do this is using indexing and a new type of <code>for</code> loop.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec8">Indexing</h3>&#13;&#13;
<p class="noindent">Each character in a string has an <em>index</em>, which indicates its location. The first character is at index 0, the second character is at index 1, and so on. In natural language, we often start counting at 1. In English, no one says “the character at position 0 of <em>hello</em> is <em>h</em>.” But most programming languages, Python included, start at 0.</p>&#13;&#13;
<p class="indent">To use indexing, we follow a string by an index in square brackets. Here are some examples of indexing:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">word = 'splore'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[0]</span><br/>&#13;&#13;
's'<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_58"/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[3]</span><br/>&#13;&#13;
'o'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[5]</span><br/>&#13;&#13;
'e'</pre>&#13;&#13;
<p class="indent">If we like, we can use variables in an index:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">where = 2</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[where]</span><br/>&#13;&#13;
'l'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[where + 2]</span><br/>&#13;&#13;
'r'</pre>&#13;&#13;
<p class="indent">The highest index that we can use on a nonempty string is its length minus 1. (There is no valid index for an empty string.) For example, <code>'splore'</code> is length 6, so index 5 is its highest index. Any bigger and we get an error:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">word[len(word)]</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
IndexError: string index out of range<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[len(word) - 1]</span><br/>&#13;&#13;
'e'</pre>&#13;&#13;
<p class="indent">How can we access the second character from the right of a string? This will do it:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">word[len(word) - 2]</span><br/>&#13;&#13;
'r'</pre>&#13;&#13;
<p class="indent">But there’s an easier way. Python supports negative indices as another option for accessing characters. Index <code>-1</code> is the rightmost character, index <code>-2</code> is the second character from the right, and so on:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">word[-2]</span><br/>&#13;&#13;
'r'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[-1]</span><br/>&#13;&#13;
'e'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[-5]</span><br/>&#13;&#13;
'p'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[-6]</span><br/>&#13;&#13;
's'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">word[-7]</span><br/>&#13;&#13;
Traceback (most recent call last):<br/>&#13;&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>&#13;&#13;
IndexError: string index out of range</pre>&#13;&#13;
<p class="indent">The plan is to use indexing to access corresponding positions of yesterday’s and today’s parking information. We can use index 0 of each string to access information about the first parking space, index 1 to access <span epub:type="pagebreak" id="page_59"/>information about the second parking space, and so on. But before we can carry out that plan, we need to learn a new kind of <code>for</code> loop.</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">What is the output of the following code?</p>&#13;&#13;
<pre>s = 'abcde'<br/>&#13;&#13;
t = s[0] + s[-5] + s[len(s) - 5]<br/>&#13;&#13;
<br/>&#13;&#13;
print(t)</pre>&#13;&#13;
<p class="alphat">A. <code>aaa</code></p>&#13;&#13;
<p class="alpha">B. <code>aae</code></p>&#13;&#13;
<p class="alpha">C. <code>aee</code></p>&#13;&#13;
<p class="alpha">D. This code produces an error</p>&#13;&#13;
<p class="sb-noindent1">Answer: A. Each of the three indices refers to the first character in <code>'abcde'</code>. First, <code>s[0]</code> refers to <code>'a'</code> because <code>'a'</code> is at index 0 of the string. Second, <code>s[-5]</code> refers to <code>'a'</code> because <code>'a'</code> is the fifth character from the right. Third, <code>s[len(s) - 5]</code> refers to <code>'a'</code> because the index evaluates to 0: 5 (the length of the string) minus 5.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch03lev1sec9">Range for loops</h3>&#13;&#13;
<p class="noindent">Python’s <code>range</code> function generates ranges of integers, and we can use those ranges to control <code>for</code> loops. Rather than looping through the characters of a string, a range <code>for</code> loop loops through integers. If we provide one argument to <code>range</code>, we get a range from 0 to 1 less than that argument:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for num in range(5):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
0<br/>&#13;&#13;
1<br/>&#13;&#13;
2<br/>&#13;&#13;
3<br/>&#13;&#13;
4</pre>&#13;&#13;
<p class="indent">Notice that <code>5</code> is not output.</p>&#13;&#13;
<p class="indent">If we provide two arguments to <code>range</code>, we get a sequence from the first argument up to but not including the second argument:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for num in range(3, 7):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
<span epub:type="pagebreak" id="page_60"/>&#13;&#13;
...<br/>&#13;&#13;
3<br/>&#13;&#13;
4<br/>&#13;&#13;
5<br/>&#13;&#13;
6</pre>&#13;&#13;
<p class="indent">We can count up by a different <em>step size</em> by including a third argument. The default step size is <code>1</code>, which counts up by one. Let’s try a couple of other step sizes:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for num in range(0, 10, 2):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
0<br/>&#13;&#13;
2<br/>&#13;&#13;
4<br/>&#13;&#13;
6<br/>&#13;&#13;
8<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">for num in range(0, 10, 3):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
0<br/>&#13;&#13;
3<br/>&#13;&#13;
6<br/>&#13;&#13;
9</pre>&#13;&#13;
<p class="indent">We can count backward, too, but <em>not</em> like this:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for num in range(6, 2):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...</pre>&#13;&#13;
<p class="indent">That doesn’t work, because by default <code>range</code> counts up. A step size of <code>-1</code> lets us go backward, one at a time:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for num in range(6, 2, -1):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
6<br/>&#13;&#13;
5<br/>&#13;&#13;
4<br/>&#13;&#13;
3</pre>&#13;&#13;
<p class="indent">To count down from <code>6</code> to <code>0</code>, including <code>0</code>, we need a value of <code>-1</code> for the second argument:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for num in range(6, -1, -1):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(num)</span><br/>&#13;&#13;
...<br/>&#13;&#13;
6<br/>&#13;&#13;
<span epub:type="pagebreak" id="page_61"/>&#13;&#13;
5<br/>&#13;&#13;
4<br/>&#13;&#13;
3<br/>&#13;&#13;
2<br/>&#13;&#13;
1<br/>&#13;&#13;
0</pre>&#13;&#13;
<p class="indent">It’s sometimes helpful to quickly look at the numbers in a range without coding a loop. Unfortunately, the <code>range</code> function doesn’t directly show us those numbers:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">range(3, 7)</span><br/>&#13;&#13;
range(3, 7)</pre>&#13;&#13;
<p class="indent">We can pass that result to the <code>list</code> function to get what we want:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">list(range(3, 7))</span><br/>&#13;&#13;
[3, 4, 5, 6]</pre>&#13;&#13;
<p class="indent">When called with a range, the <code>list</code> function produces a list of the range’s integers. We’ll learn all about lists later; for now, keep <code>list</code> in mind as an aid to diagnosing errors with ranges.</p>&#13;&#13;
<div class="sidebar">&#13;&#13;
<p class="sb-title"><strong>CONCEPT CHECK</strong></p>&#13;&#13;
<p class="sidebarp">How many iterations are performed by the following loop?</p>&#13;&#13;
<pre>for i in range(10, 20):<br/>&#13;&#13;
    # Some code here</pre>&#13;&#13;
<p class="alphat">A. 9</p>&#13;&#13;
<p class="alpha">B. 10</p>&#13;&#13;
<p class="alpha">C. 11</p>&#13;&#13;
<p class="alpha">D. 20</p>&#13;&#13;
<p class="sb-noindent1">Answer: B. The range goes through the numbers 10, 11, 12, 13, 14, 15, 16, 17, 18, and 19. There are 10 numbers and hence 10 iterations.</p>&#13;&#13;
</div>&#13;&#13;
<h3 class="h3" id="ch03lev1sec10">Range for Loops Through Indices</h3>&#13;&#13;
<p class="noindent">Suppose we have strings giving yesterday’s and today’s parking-space information:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">yesterday = 'CC.'</span><br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">today = '.C.'</span></pre>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_62"/>Given an index, we can look at yesterday’s and today’s information for that index:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">yesterday[0]</span><br/>&#13;&#13;
'C'<br/>&#13;&#13;
&gt;&gt;&gt; <span class="codestrong1">today[0]</span><br/>&#13;&#13;
'.'</pre>&#13;&#13;
<p class="indent">We can use a range <code>for</code> loop through the indices to process each pair of corresponding characters. We know that <code>yesterday</code> and <code>today</code> are the same length. But that length could be anything from 1 to 100, so we can’t write something like <code>range(3)</code>. We want to iterate with indices 0, 1, 2, and so on, all the way up to the length of the string minus 1. We can do that by using the length of one of the strings as the argument to <code>range</code>:</p>&#13;&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for index in range(len(yesterday)):</span><br/>&#13;&#13;
...     <span class="codestrong1">print(yesterday[index], today[index])</span><br/>&#13;&#13;
...<br/>&#13;&#13;
C .<br/>&#13;&#13;
C C<br/>&#13;&#13;
. .</pre>&#13;&#13;
<p class="indent">I’ve called the loop variable <code>index</code>. Other popular names include <code>i</code> (the first letter of <code>index</code>) and <code>ind</code>. I’ll use <code>i</code> from here on out.</p>&#13;&#13;
<p class="indent">Don’t call this loop variable <code>status</code> or <code>information</code>. Those names imply that it takes on <code>'C'</code> and <code>'.'</code> values, when really it takes on integers.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec11">Solving the Problem</h3>&#13;&#13;
<p class="noindent">With our range <code>for</code> loops, we’re ready to solve Occupied Spaces. Our strategy is to loop through each index from the beginning of the strings to the end. We can check what’s at each index in both yesterday’s information and today’s information. Using a nested <code>if</code> statement, we’ll determine whether the parking space was occupied on both days.</p>&#13;&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex03">Listing 3-3</a> has our solution.</p>&#13;&#13;
<pre>   n = int(input())<br/>&#13;&#13;
   yesterday = input()<br/>&#13;&#13;
   today = input()<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❶</span> occupied = 0<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❷</span> for i in range(len(yesterday)):<br/>&#13;&#13;
    <span class="ent">❸</span> if yesterday[i] == 'C' and today[i] == 'C':<br/>&#13;&#13;
        <span class="ent">❹</span> occupied = occupied + 1<br/>&#13;&#13;
<br/>&#13;&#13;
   print(occupied)</pre>&#13;&#13;
<p class="ex-caption" id="ch03ex03"><em>Listing 3-3: Solving Occupied Spaces</em></p>&#13;&#13;
<p class="indent"><span epub:type="pagebreak" id="page_63"/>The program starts by reading the three lines of input: <code>n</code> refers to the number of parking spaces; and <code>yesterday</code> and <code>today</code> refer to yesterday’s and today’s parking-space information, respectively.</p>&#13;&#13;
<p class="indent">Notice that we don’t refer to the number of parking spaces (<code>n</code>) again. We could make use of it to tell us the length of the strings, but I’ve chosen to ignore it because it’s often not provided in real-life scenarios.</p>&#13;&#13;
<p class="indent">We use the <code>occupied</code> variable to count the number of parking spaces that were occupied both yesterday and today. We start that variable off at <code>0</code> <span class="ent">❶</span>.</p>&#13;&#13;
<p class="indent">Now we reach the range <code>for</code> loop, which loops through the valid indices of <code>yesterday</code> and <code>today</code> <span class="ent">❷</span>. For each such index, we check whether the parking space was occupied yesterday and occupied today <span class="ent">❸</span>. If it was, then we include this parking space in our total by increasing <code>occupied</code> by <code>1</code> <span class="ent">❹</span>.</p>&#13;&#13;
<p class="indent">When the range <code>for</code> loop terminates, we’ll have gone through all parking spaces. The total number of parking spaces that were occupied yesterday and today can be accessed through the <code>occupied</code> variable. All that’s left is to output that total.</p>&#13;&#13;
<p class="indent">That’ll do it for this problem. Time to submit your code to the judge.</p>&#13;&#13;
<h3 class="h3a" id="ch03lev1sec12"><span class="h3aa">Problem #7: Data Plan</span></h3>&#13;&#13;
<p class="noindent">We’ve learned that <code>for</code> loops are useful for processing data after we’ve read it from the input. They’re also often useful for reading the data itself. In this problem, we’ll tackle data that’s spread over many lines and use a <code>for</code> loop to help us read it all.</p>&#13;&#13;
<p class="indent">This is DMOJ problem <code>coci16c1p1</code>.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec7">The Challenge</h4>&#13;&#13;
<p class="noindent">Pero has a data plan with his cell phone provider that offers him <em>x</em> megabytes of data per month. In addition, any data he doesn’t use in a given month carries over to the next month. For example, if <em>x</em> is 10 and Pero uses only 4MB in a given month, the remaining 6MB carry over to the next month (in which he’d now have 10 + 6 = 16MB available).</p>&#13;&#13;
<p class="indent">We’re given the number of megabytes of data that Pero uses in each of the first <em>n</em> months. Our task is to determine the number of megabytes available for the following month.</p>&#13;&#13;
<h4 class="h4" id="ch03lev2sec8">Input</h4>&#13;&#13;
<p class="noindent">The input consists of the following lines:</p>&#13;&#13;
<ul>&#13;&#13;
<li class="noindent">A line containing integer <em>x</em>, the number of megabytes given to Pero per month. <em>x</em> is between 1 and 100.</li>&#13;&#13;
<li class="noindent">A line containing integer <em>n</em>, the number of months that Pero has had the data plan. <em>n</em> is between 1 and 100.&#13;&#13;
</li>&#13;&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_64"/><em>n</em> lines, one for each month, giving the integer number of megabytes that Pero uses in that month. Each number is at least 0 and will never outstrip the number of available megabytes. (For example, if <em>x</em> is 10 and Pero currently has 30MB available, the next number will be at most 30.)</li>&#13;&#13;
</ul>&#13;&#13;
<h4 class="h4" id="ch03lev2sec9">Output</h4>&#13;&#13;
<p class="noindent">Output the number of megabytes available for the next month.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec13">Looping to Read Input</h3>&#13;&#13;
<p class="noindent">In all of our problems so far, we’ve known exactly how many lines to read from the input. For example, in Three Cups, we read one line; in Occupied Spaces, we read three lines. Here in Data Plan, we don’t know in advance how many lines to read, because it depends on the number that we read from the second line.</p>&#13;&#13;
<p class="indent">We can read the first line of input:</p>&#13;&#13;
<pre>monthly_mb = int(input())</pre>&#13;&#13;
<p class="noindent">(I’ve used variable name <code>monthly_mb</code> rather than <code>x</code> to imbue it with some meaning.)</p>&#13;&#13;
<p class="indent">And we can read the second line of input:</p>&#13;&#13;
<pre>n = int(input())</pre>&#13;&#13;
<p class="indent">But we can’t read any more without a loop. A range <code>for</code> loop is perfect here, because we can use it to loop exactly <code>n</code> times:</p>&#13;&#13;
<pre>for i in range(n):<br/>&#13;&#13;
    # Process month</pre>&#13;&#13;
<h3 class="h3" id="ch03lev1sec14">Solving the Problem</h3>&#13;&#13;
<p class="noindent">My strategy for solving the problem is to keep track of the number of megabytes that are carried over from previous months. I call this the <em>excess</em>.</p>&#13;&#13;
<p class="indent">Consider this test case:</p>&#13;&#13;
<pre>10<br/>&#13;&#13;
3<br/>&#13;&#13;
4<br/>&#13;&#13;
12<br/>&#13;&#13;
1</pre>&#13;&#13;
<p class="indent">In each month, Pero is given 10MB of data, and we have to process the data that he used in the provided three months. In the first month, Pero is given 10MB and uses 4MB, so the excess that carries forward is 6MB. In the second month, Pero is given 10MB more, so now he has 16MB total. He uses <span epub:type="pagebreak" id="page_65"/>12MB this month, so the excess that carries forward is 16 – 12 = 4MB. In the third month, Pero is given 10MB more, so now he has 14MB total. He uses 1MB this month, so the excess that carries forward is 14 – 1 = 13MB.</p>&#13;&#13;
<p class="indent">We need to know the number of megabytes that Pero has available for the next (that is, fourth) month. He has 13MB that carry over from the first three months, and he’s given his usual 10MB for this month, so he has a total of 13 + 10 = 23MB to use.</p>&#13;&#13;
<p class="indent">When I went to write the code based on this explanation, I neglected to add this final 10, so my output was 13 instead of 23. I was focusing exclusively on the excess and forgot that what we need is not the excess going into the next month, but the total number of megabytes available. That total is the excess plus whatever Pero is given per month.</p>&#13;&#13;
<p class="indent">See <a href="ch03.xhtml#ch03ex04">Listing 3-4</a> for the (corrected!) code.</p>&#13;&#13;
<pre>   monthly_mb = int(input())<br/>&#13;&#13;
   n = int(input())<br/>&#13;&#13;
<br/>&#13;&#13;
   excess = 0<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❶</span> for i in range(n):<br/>&#13;&#13;
       used = int(input())<br/>&#13;&#13;
    <span class="ent">❷</span> excess = excess + monthly_mb - used<br/>&#13;&#13;
<br/>&#13;&#13;
<span class="ent">❸</span> print(excess + monthly_mb)</pre>&#13;&#13;
<p class="ex-caption" id="ch03ex04"><em>Listing 3-4: Solving Data Plan</em></p>&#13;&#13;
<p class="indent">The <code>excess</code> variable begins at <code>0</code>. On each iteration of the range <code>for</code> loop, we assign a value to <code>excess</code> that considers the number of megabytes given per month and the number of megabytes used in that month.</p>&#13;&#13;
<p class="indent">The range <code>for</code> loop loops <code>n</code> times, once for each month that Pero has had the data plan <span class="ent">❶</span>. The values that <code>i</code> takes on—<code>0</code>, <code>1</code>, and so on—aren’t of interest to us, because we have no reason to care about which month we’re processing. For that reason, we don’t use the value of <code>i</code> anywhere in the program. You can replace <code>i</code> with <code>_</code> (an underscore) to be explicit about the variable’s “don’t care” status, but I’ll leave it as <code>i</code> for consistency with other examples.</p>&#13;&#13;
<p class="indent">In the range <code>for</code> loop, we read the number of megabytes used in this month. Then, we update the number of excess megabytes <span class="ent">❷</span>: it’s what it was before, plus the number of megabytes that Pero gets per month, minus the number of megabytes that Pero uses this month.</p>&#13;&#13;
<p class="indent">Having computed the excess number of megabytes after <code>n</code> months, we report the number of megabytes available for the next month <span class="ent">❸</span>.</p>&#13;&#13;
<p class="indent">There are always multiple ways to solve a problem. Programming is creative, and I enjoy observing the range of solution strategies that people come up with. Even if you’ve succeeded in solving a problem, you might like to Google the problem to learn from how others have solved it. In addition, some online judges, like DMOJ, allow you to view other people’s submissions once you’ve solved the problem. For submissions that pass all of the test cases: did those programmers do things differently from you? For <span epub:type="pagebreak" id="page_66"/>submissions that fail some test cases: what’s wrong with the code? Reading other people’s code is a great way to improve your own programming skill!</p>&#13;&#13;
<p class="indent">Can you think of another way to solve Data Plan?</p>&#13;&#13;
<p class="indent">Here’s a hint: you can start by calculating the total number of megabytes that Pero is given and then subtracting the number of megabytes that he uses. I encourage you to take some time to work out how to do this before continuing!</p>&#13;&#13;
<p class="indent">The total number of megabytes given to Pero, including those given in the next month, is <em>x</em> * (<em>n</em> + 1), where <em>x</em> is the number of megabytes given per month. To determine the number of megabytes available for the next month, we can start with that total and subtract what Pero uses each month. That strategy is coded in <a href="ch03.xhtml#ch03ex05">Listing 3-5</a>.</p>&#13;&#13;
<pre>monthly_mb = int(input())<br/>&#13;&#13;
n = int(input())<br/>&#13;&#13;
<br/>&#13;&#13;
total_mb = monthly_mb * (n + 1)<br/>&#13;&#13;
<br/>&#13;&#13;
for i in range(n):<br/>&#13;&#13;
    used = int(input())<br/>&#13;&#13;
    total_mb = total_mb - used<br/>&#13;&#13;
<br/>&#13;&#13;
print(total_mb)</pre>&#13;&#13;
<p class="ex-caption" id="ch03ex05"><em>Listing 3-5: Solving Data Plan, alternate approach</em></p>&#13;&#13;
<p class="indent">Choose whichever solution is your favorite, and submit to the judge.</p>&#13;&#13;
<p class="indent">What’s intuitive to one person may not be intuitive to another. You might read an explanation or code and not be able to make sense of it. This doesn’t mean that you’re not smart enough. It just means you need a different presentation, one that aligns more closely to your current thinking. You might also flag difficult explanations and examples for later review. They may prove to be surprisingly useful once you’ve gained further practice.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec15">Summary</h3>&#13;&#13;
<p class="noindent">In this chapter, we learned about <code>for</code> loops. Standard <code>for</code> loops loop through the characters of a sequence; range <code>for</code> loops loop through integers in a range. Each problem that we solved required us to process many pieces of input, and we wouldn’t have been able to manage that without a loop.</p>&#13;&#13;
<p class="indent">The <code>for</code> loop is the loop of choice whenever you need to repeat code a specified number of times. Python has one other type of loop, and we’ll learn how to use it in the next chapter. Why do we need anything besides <code>for</code> loops? What can’t <code>for</code> loops do? Good questions! I’ll tell you this for now: practicing with <code>for</code> loops is a wonderful way to prepare for what’s to come.</p>&#13;&#13;
<h3 class="h3" id="ch03lev1sec16"><span epub:type="pagebreak" id="page_67"/>Chapter Exercises</h3>&#13;&#13;
<p class="noindent">Here are some exercises for you to try.</p>&#13;&#13;
<ol>&#13;&#13;
<li class="noindent">DMOJ problem <code>wc17c3j3</code>, Uncrackable</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>coci18c3p1</code>, Magnus</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>ccc11s1</code>, English or French</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>ccc11s2</code>, Multiple Choice</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>coci12c5p1</code>, Ljestvica</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>coci13c3p1</code>, Rijeci</li>&#13;&#13;
<li class="noindent">DMOJ problem <code>coci18c4p1</code>, Elder</li>&#13;&#13;
</ol>&#13;&#13;
<h3 class="h3" id="ch03lev1sec17">Notes</h3>&#13;&#13;
<p class="noindent">Three Cups is originally from the 2006/2007 Croatian Open Competition in Informatics, Contest 5. Occupied Spaces is originally from the 2018 Canadian Computing Competition, Junior Level. Data Plan is originally from the 2016/2017 Croatian Open Competition in Informatics, Contest 1.</p>&#13;&#13;
<span epub:type="pagebreak" id="page_68"/>&#13;&#13;
</div></body></html>