["```py\n             'a': ['break', 'bright'],\n             'aloof': ['glorious'],\n             'and': ['aloof'],\n             'break': ['in'],\n             'bright': ['mountaintop'],\n             'clouds': ['the', 'come'],\n             'come': ['to'],\n             'dark': ['clouds'],\n             'distant': ['and'],\n             'glorious': ['the'],\n             'in': ['the'],\n             'moon': ['a', 'therefore'],\n             'mountaintop': ['distant'],\n             'our': ['thanks', 'tired'],\n             'rest': ['our'],\n             'thanks': ['dark'],\n             'the': ['clouds', 'moon', 'moon'],\n             'therefore': ['our'],\n             'tired': ['necks'],\n             'to': ['rest']\n```", "```py\n             'a break': ['in'],\n             'a bright': ['mountaintop'],\n             'aloof glorious': ['the'],\n             'and aloof': ['glorious'],\n             'break in': ['the'],\n             'bright mountaintop': ['distant'],\n             'clouds come': ['to'],\n             'clouds the': ['moon'],\n             'come to': ['rest'],\n             'dark clouds': ['come'],\n             'distant and': ['aloof'],\n             'glorious the': ['moon'],\n             'in the': ['clouds'],\n             'moon a': ['bright'],\n             'moon therefore': ['our'],\n             'mountaintop distant': ['and'],\n             'our thanks': ['dark'],\n             'our tired': ['necks'],\n             'rest our': ['tired'],\n             'thanks dark': ['clouds'],\n             'the clouds': ['the'],\n             'the moon': ['a', 'therefore'],\n             'therefore our': ['thanks'],\n             'to rest': ['our']\n```", "```py\n             'the moon a': ['bright'],\n             'the moon therefore': ['our']\n```", "```py\nImport count_syllables module\nLoad a training-corpus text file\nProcess the training corpus for spaces, newline breaks, and so on\nMap each word in corpus to the word after (Markov model order 1)\nMap each word pair in corpus to the word after (Markov model order 2)\nGive user choice of generating full haiku, redoing lines 2 or 3, or exiting\nIf first line:\n    Target syllables = 5\n    Get random word from corpus <= 4 syllables (no 1-word lines)\n    Add word to line\n    Set random word = prefix variable\n    Get mapped words after prefix\n    If mapped words have too many syllables\n        Choose new prefix word at random & repeat\n    Choose new word at random from mapped words\n    Add the new word to the line\n    Count syllables in word and calculate total in line\n    If syllables in line equal target syllables\n        Return line and last word pair in line\nElse if second or third line:\n    Target = 7 or 5\n    Line equals last word pair in previous line\n    While syllable target not reached:\n        Prefix = last word pair in line\n        Get mapped words after word-pair prefix\n        If mapped words have too many syllables\n            Choose new word-pair prefix at random and repeat\n        Choose new word at random from mapped words\n        Add the new word to the line\n        Count syllables in word and calculate total in line\n        If total is greater than target\n            Discard word, reset total, and repeat\n        Else if total is less than target\n            Add word to line, keep total, and repeat\n        Else if total is equal to target\n            Add word to line\n    Return line and last word pair in line\nDisplay results and choice menu\n```", "```py\n➊ >>> import logging\n➋ >>> logging.basicConfig(level=logging.DEBUG,\n                           format='%(levelname)s - %(message)s')\n\n   >>> word = 'scarecrow'\n   >>> VOWELS = 'aeiouy'\n   >>> num_vowels = 0\n   >>> for letter in word:\n           if letter in VOWELS:\n               num_vowels += 1\n        ➌ logging.debug('letter & count = %s-%s', letter, num_vowels)\n\n   DEBUG - letter & count = s-0\n   DEBUG - letter & count = c-0\n   DEBUG - letter & count = a-1\n   DEBUG - letter & count = r-1\n   DEBUG - letter & count = e-2\n   DEBUG - letter & count = c-2\n   DEBUG - letter & count = r-2\n   DEBUG - letter & count = o-3\n   DEBUG - letter & count = w-3\n```", "```py\n>>> import logging\n>>> logging.disable(logging.CRITICAL)\n```", "```py\n➊ import sys\n   import logging\n   import random\n   from collections import defaultdict\n   from count_syllables import count_syllables\n\n➋ logging.disable(logging.CRITICAL)  # comment out to enable debugging messages\n   logging.basicConfig(level=logging.DEBUG, format='%(message)s')\n\n➌ def load_training_file(file):\n       \"\"\"Return text file as a string.\"\"\"\n       with open(file) as f:\n        ➍ raw_haiku = f.read()\n           return raw_haiku\n\n➎ def prep_training(raw_haiku):\n       \"\"\"Load string, remove newline, split words on spaces, and return list.\"\"\"\n       corpus = raw_haiku.replace('\\n', ' ').split()\n       return corpus\n```", "```py\n➊ def map_word_to_word(corpus):\n       \"\"\"Load list & use dictionary to map word to word that follows.\"\"\"\n    ➋ limit = len(corpus) - 1\n    ➌ dict1_to_1 = defaultdict(list)\n    ➍ for index, word in enumerate(corpus):\n           if index < limit:\n            ➎ suffix = corpus[index + 1]\n               dict1_to_1[word].append(suffix)\n    ➏ logging.debug(\"map_word_to_word results for \\\"sake\\\" = %s\\n\",\n                    dict1_to_1['sake'])\n    ➐ return dict1_to_1\n➑ def map_2_words_to_word(corpus):\n       \"\"\"Load list & use dictionary to map word-pair to trailing word.\"\"\"\n    ➒ limit = len(corpus) - 2\n       dict2_to_1 = defaultdict(list)\n       for index, word in enumerate(corpus):\n           if index < limit:\n            ➓ key = word + ' ' + corpus[index + 1]\n               suffix = corpus[index + 2]\n               dict2_to_1[key].append(suffix)\n       logging.debug(\"map_2_words_to_word results for \\\"sake jug\\\" = %s\\n\",\n                     dict2_to_1['sake jug'])\n       return dict2_to_1\n```", "```py\n➊ def random_word(corpus):\n       \"\"\"Return random word and syllable count from training corpus.\"\"\"\n    ➋ word = random.choice(corpus)\n    ➌ num_syls = count_syllables(word)\n    ➍ if num_syls > 4:\n           random_word(corpus)\n       else:\n        ➎ logging.debug(\"random word & syllables = %s %s\\n\", word, num_syls)\n           return (word, num_syls)\n```", "```py\n➊ def word_after_single(prefix, suffix_map_1, current_syls, target_syls):\n       \"\"\"Return all acceptable words in a corpus that follow a single word.\"\"\"\n    ➋ accepted_words = []\n    ➌ suffixes = suffix_map_1.get(prefix)\n    ➍ if suffixes != None:\n        ➎ for candidate in suffixes:\n               num_syls = count_syllables(candidate)\n               if current_syls + num_syls <= target_syls:\n                ➏ accepted_words.append(candidate)\n    ➐ logging.debug(\"accepted words after \\\"%s\\\" = %s\\n\",\n                     prefix, set(accepted_words))\n       return accepted_words\n\n➑ def word_after_double(prefix, suffix_map_2, current_syls, target_syls):\n       \"\"\"Return all acceptable words in a corpus that follow a word pair.\"\"\"\n       accepted_words = []\n    ➒ suffixes = suffix_map_2.get(prefix)\n       if suffixes != None:\n           for candidate in suffixes:\n               num_syls = count_syllables(candidate)\n               if current_syls + num_syls <= target_syls:\n                   accepted_words.append(candidate)\n       logging.debug(\"accepted words after \\\"%s\\\" = %s\\n\",\n                     prefix, set(accepted_words))\n    ➓ return accepted_words\n```", "```py\n➊ def haiku_line(suffix_map_1, suffix_map_2, corpus, end_prev_line, target_syls):\n       \"\"\"Build a haiku line from a training corpus and return it.\"\"\"\n    ➋ line = '2/3'\n       line_syls = 0\n       current_line = []\n    ➌ if len(end_prev_line) == 0:  # build first line\n        ➍ line = '1'\n        ➎ word, num_syls = random_word(corpus)\n           current_line.append(word)\n           line_syls += num_syls\n        ➏ word_choices = word_after_single(word, suffix_map_1,\n                                            line_syls, target_syls)\n        ➐ while len(word_choices) == 0:\n               prefix = random.choice(corpus)\n               logging.debug(\"new random prefix = %s\", prefix)\n               word_choices = word_after_single(prefix, suffix_map_1,\n                                                line_syls, target_syls)\n        ➑ word = random.choice(word_choices)\n           num_syls = count_syllables(word)\n           logging.debug(\"word & syllables = %s %s\", word, num_syls)\n        ➒ line_syls += num_syls\n           current_line.append(word)\n        ➓ if line_syls == target_syls:\n               end_prev_line.extend(current_line[-2:])\n               return current_line, end_prev_line\n```", "```py\n    ➊ else: # build lines 2 and 3\n        ➋ current_line.extend(end_prev_line)\n\n    ➌ while True:\n           logging.debug(\"line = %s\\n\", line)\n        ➍ prefix = current_line[-2] + ' ' + current_line[-1]\n        ➎ word_choices = word_after_double(prefix, suffix_map_2,\n                                            line_syls, target_syls)\n        ➏ while len(word_choices) == 0:\n               index = random.randint(0, len(corpus) - 2)\n               prefix = corpus[index] + ' ' + corpus[index + 1]\n               logging.debug(\"new random prefix = %s\", prefix)\n               word_choices = word_after_double(prefix, suffix_map_2,\n                                                line_syls, target_syls)\n           word = random.choice(word_choices)\n           num_syls = count_syllables(word)\n           logging.debug(\"word & syllables = %s %s\", word, num_syls)\n\n        ➐ if line_syls + num_syls > target_syls:\n               continue\n           elif line_syls + num_syls < target_syls:\n               current_line.append(word)\n               line_syls += num_syls\n           elif line_syls + num_syls == target_syls:\n               current_line.append(word)\n               break\n\n    ➑ end_prev_line = []\n       end_prev_line.extend(current_line[-2:])\n\n    ➒ if line == '1':\n           final_line = current_line[:]\n       else:\n           final_line = current_line[2:]\n\n       return final_line, end_prev_line\n```", "```py\ndef main():\n    \"\"\"Give user choice of building a haiku or modifying an existing haiku.\"\"\"\n    intro = \"\"\"\\n\n    A thousand monkeys at a thousand typewriters...\n    or one computer...can sometimes produce a haiku.\\n\"\"\"\n    print(\"{}\".format(intro))\n\n ➊ raw_haiku = load_training_file(\"train.txt\")\n    corpus = prep_training(raw_haiku)\n    suffix_map_1 = map_word_to_word(corpus)\n    suffix_map_2 = map_2_words_to_word(corpus)\n    final = []\n\n    choice = None\n ➋ while choice != \"0\":\n\n     ➌ print(\n            \"\"\"\n            Japanese Haiku Generator\n\n            0 - Quit\n            1 - Generate a Haiku\n            2 - Regenerate Line 2\n            3 - Regenerate Line 3\n            \"\"\"\n            )\n\n     ➍ choice = input(\"Choice: \")\n        print()\n\n        # exit\n     ➎ if choice == \"0\":\n            print(\"Sayonara.\")\n            sys.exit()\n\n        # generate a full haiku\n     ➏ elif choice == \"1\":\n            final = []\n            end_prev_line = []\n            first_line, end_prev_line1 = haiku_line(suffix_map_1, suffix_map_2,\n                                                    corpus, end_prev_line, 5)\n            final.append(first_line)\n            line, end_prev_line2 = haiku_line(suffix_map_1, suffix_map_2,\n                                              corpus, end_prev_line1, 7)\n            final.append(line)\n            line, end_prev_line3 = haiku_line(suffix_map_1, suffix_map_2,\n                                              corpus, end_prev_line2, 5)\n            final.append(line)\n\n        # regenerate line 2\n     ➐ elif choice == \"2\":\n            if not final:\n                print(\"Please generate a full haiku first (Option 1).\")\n                continue\n            else:\n                line, end_prev_line2 = haiku_line(suffix_map_1, suffix_map_2,\n                                                  corpus, end_prev_line1, 7)\n                final[1] = line\n\n        # regenerate line 3\n     ➑ elif choice == \"3\":\n            if not final:\n                print(\"Please generate a full haiku first (Option 1).\")\n                continue\n            else:\n                line, end_prev_line3 = haiku_line(suffix_map_1, suffix_map_2,\n                                                  corpus, end_prev_line2, 5)\n                final[2] = line\n\n        # some unknown choice\n     ➒ else:\n            print(\"\\nSorry, but that isn't a valid choice.\", file=sys.stderr)\n            continue\n\n     ➓ # display results\n        print()\n        print(\"First line = \", end=\"\")\n        print(' '.join(final[0]), file=sys.stderr)\n        print(\"Second line = \", end=\"\")\n        print(\" \".join(final[1]), file=sys.stderr)\n        print(\"Third line = \", end=\"\")\n        print(\" \".join(final[2]), file=sys.stderr)\n        print()\n\n    input(\"\\n\\nPress the Enter key to exit.\")\n\nif __name__ == '__main__':\n    main()\n```"]