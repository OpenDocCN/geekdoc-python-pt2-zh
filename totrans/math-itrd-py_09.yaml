- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: COMPLEX NUMBERS
  prefs: []
  type: TYPE_NORMAL
- en: '*Imaginary numbers are a fine and wonderful refuge of the divine spirit, almost
    an amphibian between being and non-being. —Gottfried Leibniz*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fintro-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Numbers containing the square root of –1 have been given a bad name in math
    classes. We call the square root of –1 an *imaginary number*, or *i*. Calling
    something “imaginary” makes it seem like it doesn’t exist or like there’s no real
    purpose for it. But imaginary numbers *do* exist, and they have a lot of real-world
    applications in fields such as electromagnetism, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you get a taste of the kinds of beautiful art you can create
    using *complex numbers*, which are numbers that have both a real and imaginary
    part written in the form of *a* + *bi*, where *a* and *b* are real numbers and
    *i* is the imaginary number. Because a complex number holds two different bits
    of information, real and imaginary, you can use it to turn one-dimensional objects
    into two-dimensional ones. Using Python, manipulating these numbers becomes easier,
    and we can use them for some very magical purposes. In fact, we use complex numbers
    to explain behaviors of electrons and photons, and what we think of as natural,
    “normal” numbers are actually complex numbers whose imaginary parts equal zero!
  prefs: []
  type: TYPE_NORMAL
- en: We begin this chapter by reviewing how to plot complex numbers in the complex
    coordinate plane. You also learn how to express complex numbers as Python lists
    and then write functions to add and multiply them. Finally, you learn how to find
    the magnitude, or absolute value, of a complex number. Knowing how to manipulate
    complex numbers will come in handy when we write the programs for creating the
    Mandelbrot set and the Julia set later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: THE COMPLEX COORDINATE SYSTEM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As Frank Farris summed up in his brilliant and beautifully illustrated book
    *Creating Symmetry*, “Complex numbers . . . are simply a way to express the Cartesian
    ordered pair of real numbers, (*x, y*), compactly as a single number *z* = *x*
    + *iy*.” We all know the Cartesian coordinate system uses *x* to represent the
    horizontal axis and *y* to represent the vertical axis, but we never add or multiply
    those numbers; they just represent a location.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, complex numbers not only can represent locations but they can also
    be operated on like any other numbers. It helps to look at complex numbers geometrically.
    Let’s change our coordinate system a little so that now the real numbers are on
    the horizontal axis and the imaginary numbers are on the vertical axis, as in
    [Figure 7-1](ch07.xhtml#ch07fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f128-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The complex coordinate system*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see where *a* + *bi* and *a* – *bi* would be located on a complex
    coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: '### ADDING COMPLEX NUMBERS'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding and subtracting complex numbers are the same as with real numbers: you
    start at one number and take the number of steps represented by the other number.
    For example, to add the numbers 2 + 3*i* and 4 + *i*, you would simply add the
    real parts and the imaginary parts of the numbers separately to get 6 + 4*i*,
    as shown in [Figure 7-2](ch07.xhtml#ch07fig2).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f129-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Adding two complex numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we start at 4 + *i*. To add 2 + 3*i*, we move two units in the
    positive real direction and three units in the positive imaginary direction, and
    end up at 6 + 4*i*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write the function for adding two complex numbers using the code in [Listing
    7-1](ch07.xhtml#ch07list1). Open a new file in IDLE and name it *complex.py*.
  prefs: []
  type: TYPE_NORMAL
- en: 'def cAdd(a,b):'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''adds two complex numbers'''''''
  prefs: []
  type: TYPE_NORMAL
- en: return [a[0]+b[0],a[1]+b[1]]
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-1: The function for adding two complex numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we define the function called cAdd(), giving it two complex numbers in
    list form [x,y], which returns another list. The first term of the list, a[0]+b[0],
    is the sum of the first terms of the complex numbers (index 0) we provide. The
    second term, a[1]+b[1], is the sum of the second terms (index 1) of the two complex
    numbers. Save and run this program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s test the program using the complex numbers u = 1 + 2i and v = 3 +
    4i. Plug them into our cAdd() function in the interactive shell, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> u = [1,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> v = [3,4]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> cAdd(u,v)'
  prefs: []
  type: TYPE_NORMAL
- en: '[6, 4]'
  prefs: []
  type: TYPE_NORMAL
- en: You should get 6 + 4*i*, which is the sum of the complex numbers 1 + 2*i* and
    3 + 4*i*. Adding complex numbers is just like taking steps in the x-direction
    and then in the y-direction, and we’ll see this function again when we want to
    create beautiful designs like the Mandelbrot set and the Julia set.
  prefs: []
  type: TYPE_NORMAL
- en: MULTIPLYING A COMPLEX NUMBER BY I
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But adding complex numbers isn’t the most useful thing. Multiplying them is.
    For example, multiplying a complex number by *i* rotates the complex number around
    the origin by 90 degrees. In the complex coordinate system, multiplying a real
    number by –1 would rotate it 180 degrees around the origin, as shown in [Figure
    7-3](ch07.xhtml#ch07fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f130-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Multiplying a number by –1 as a 180-degree rotation*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, 1 times –1 equals –1, which rotates 1 over to the other side
    of zero.
  prefs: []
  type: TYPE_NORMAL
- en: Because multiplying a complex number by –1 is the same as a 180 degree rotation,
    the square root of –1 would represent a 90 degree rotation, as shown in [Figure
    7-4](ch07.xhtml#ch07fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f130-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: Multiplying a number by* i *as a 90-degree rotation*'
  prefs: []
  type: TYPE_NORMAL
- en: This means that *i* represents the square root of –1, the number that rotates
    us halfway to –1 when we multiply it by 1\. Multiplying the result (*i*) by *i*
    again causes us to rotate 90 degrees more, and we end up with –1\. This confirms
    the definition of the square root because we are able to get to the negative value
    of a number by multiplying it by the same number (*i*) twice.
  prefs: []
  type: TYPE_NORMAL
- en: MULTIPLYING TWO COMPLEX NUMBERS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s see what happens when we multiply two complex numbers. Just like you
    would multiply two binomial expressions, you can multiply two complex numbers
    algebraically using the FOIL method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e131-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To make this easier, let’s translate this process into a cMult() function, as
    shown in [Listing 7-2](ch07.xhtml#ch07list2).
  prefs: []
  type: TYPE_NORMAL
- en: 'def cMult(u,v):'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''Returns the product of two complex numbers'''''''
  prefs: []
  type: TYPE_NORMAL
- en: return [u[0]*v[0]-u[1]*v[1],u[1]*v[0]+u[0]*v[1]]
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-2: Writing the function for multiplying two complex numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the cMult() function, try multiplying u = 1 + 2*i* by v = 3 + 4*i*.
    Enter the following in the interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> u = [1,2]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> v = [3,4]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> cMult(u,v)'
  prefs: []
  type: TYPE_NORMAL
- en: '[-5, 10]'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the product is –5 + 10*i*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from the previous section that multiplying a complex number by *i* is
    the same as performing a 90 degree rotation about the origin of the complex coordinate
    system. Let’s try it now with v = 3 + 4*i*:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> cMult([3,4],[0,1])'
  prefs: []
  type: TYPE_NORMAL
- en: '[-4, 3]'
  prefs: []
  type: TYPE_NORMAL
- en: The result is –4 + 3*i*. When we graph 3 + 4*i* and –4 + 3*i*, you should see
    something like what’s shown in [Figure 7-5](ch07.xhtml#ch07fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f132-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Rotating a complex number 90 degrees by multiplying by* i'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, –4 + 3*i* is 90 degrees rotation from 3 + 4*i*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to add and multiply complex numbers, let’s go over how
    to find the magnitude of a complex number, which you’ll use to create the Mandelbrot
    set and Julia set.
  prefs: []
  type: TYPE_NORMAL
- en: WRITING THE MAGNITUDE() FUNCTION
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *magnitude*, or *absolute value*, of a complex number is how far the complex
    number is away from the origin on the complex coordinate plane. Now let’s create
    a magnitude function using the Pythagorean theorem. Return to *complex.py* and
    make sure to import the square root function from Python’s math module at the
    top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: from math import sqrt
  prefs: []
  type: TYPE_NORMAL
- en: 'The magnitude() function is just the Pythagorean theorem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def magnitude(z):'
  prefs: []
  type: TYPE_NORMAL
- en: return sqrt(z[0]**2 + z[1]**2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s find the magnitude of the complex number 2 + i:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> magnitude([2,1])'
  prefs: []
  type: TYPE_NORMAL
- en: '2.23606797749979'
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re ready to write a Python program that colors the pixels on the display
    window according to how large the complex numbers get. The unexpected behavior
    of complex numbers will result in an infinitely complicated design that’s impossible
    to replicate without a computer!
  prefs: []
  type: TYPE_NORMAL
- en: CREATING THE MANDELBROT SET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create the Mandelbrot set, we’re going to represent each pixel on our display
    window as a complex number, *z*, then repeatedly square the value, and add the
    original number *z*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e132-01.jpg) Then, we’re going to do the same to the output,
    again and again. If the number keeps getting larger, we’ll color the pixel corresponding
    to the original complex number according to how many iterations it takes for its
    magnitude to get bigger than a certain number, like 2\. If the number keeps getting
    smaller, we’ll give it a different color.'
  prefs: []
  type: TYPE_NORMAL
- en: You already know that multiplying a number by a number larger than 1 makes the
    original number larger. A number multiplied by 1 stays the same, and multiplying
    by a number smaller than 1 makes the original number smaller. Complex numbers
    follow a similar pattern, which you can represent on the complex plane as shown
    in [Figure 7-6](ch07.xhtml#ch07fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f133-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: Visualizing what happens when you multiply complex numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: If we were only multiplying complex numbers, the Mandelbrot set would look like
    [Figure 7-6](ch07.xhtml#ch07fig6), a circle. But not only is the complex number
    squared, a number is added afterward. This will change the circle into an infinitely
    complicated and surprisingly beautiful figure. But before we can do that, we need
    to operate on every point on the grid!
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the result of the operation, some will get smaller and *converge*
    to zero. Others will get bigger and *diverge*. Getting close to a number in math
    terms is called *converging*. Getting too big in math terms is called *diverging*.
    For our purposes, we’ll color every pixel on the grid according to how many iterations
    it takes it to get too big and fly off the grid. The formula we plug the number
    into is similar to our cMult() function from [Listing 7-2](ch07.xhtml#ch07list2),
    with an extra step. We square the number, add the original complex number to the
    square, and then repeat that process until it diverges. If the magnitude of the
    squared complex number gets larger than 2, it means it has diverged (we can pick
    any number we want to be the maximum). If it never gets bigger than 2, we’ll leave
    it black.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s try the Mandelbrot set operation manually using the complex
    number *z* = 0.25 + 1.5*i*:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> z = [0.25,1.5]'
  prefs: []
  type: TYPE_NORMAL
- en: 'We square z by multiplying it by itself and saving the result to the variable
    z2:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> z2 = cMult(z,z)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> z2'
  prefs: []
  type: TYPE_NORMAL
- en: '[-2.1875, 0.75]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we add z2 and z using the cAdd() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> cAdd(z2,z)'
  prefs: []
  type: TYPE_NORMAL
- en: '[-1.9375, 2.25]'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a function we can use to test if this complex number is more than two
    units away from the origin using the Pythagorean theorem. Let’s use our magnitude()
    function from earlier to check if the magnitude of the complex number we got is
    greater than 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> magnitude([-1.9375,2.25])'
  prefs: []
  type: TYPE_NORMAL
- en: '2.969243380054926'
  prefs: []
  type: TYPE_NORMAL
- en: 'We set the rule as follows: “If a number gets more than two units away from
    the origin, it diverges.” Therefore, the complex number *z* = 0.25 + 1.5*i* diverges
    after only 1 iteration!'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, let’s try with *z* = 0.25 + 0.75*i*, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> z = [0.25,0.75]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> z2 = cMult(z,z)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> z3 = cAdd(z2,z)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> magnitude(z3)'
  prefs: []
  type: TYPE_NORMAL
- en: '1.1524430571616109'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we repeated the same process as before, except this time we need to add
    z2 and z again, saving it as z3. It’s still within two units of the origin, so
    let’s replace z with this new value and put it back through the process again.
    First, we create a new variable, z1, that we can use to square the original z:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> z1 = z'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s repeat the process using the newest value of our complex number, z3.
    We’ll square it, add z1, and find the magnitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> z2 = cMult(z3,z3)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> z3 = cAdd(z2,z1)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> magnitude(z3)'
  prefs: []
  type: TYPE_NORMAL
- en: '0.971392565148097'
  prefs: []
  type: TYPE_NORMAL
- en: Because 0.97 is smaller than 1.152, we might guess that the result is getting
    smaller and therefore doesn’t look like it’s going to diverge, but we’ve only
    repeated the process twice. Doing this by hand is laborious! Let’s automate the
    steps so that we can repeat the process quickly and easily. We’ll use the squaring,
    adding, and finding the magnitude functions to write a function called mandelbrot()
    that automates the checking process so that we can visually separate the diverging
    numbers from the converging ones. What design do you think it’ll make? A circle?
    An ellipse? Let’s find out!
  prefs: []
  type: TYPE_NORMAL
- en: WRITING THE MANDELBROT() FUNCTION
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s open a Processing sketch and call it *mandelbrot.pyde*. The Mandelbrot
    set we’re trying to re-create here is named after the mathematician Benoit Mandelbrot,
    who first explored this process using computers in the 1970s. We’ll repeat the
    squaring and adding process a maximum number of times, or until the number diverges,
    as shown in [Listing 7-3](ch07.xhtml#ch07list3).
  prefs: []
  type: TYPE_NORMAL
- en: 'def mandelbrot(z,num):'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''runs the process num times'
  prefs: []
  type: TYPE_NORMAL
- en: and returns the diverge count '''
  prefs: []
  type: TYPE_NORMAL
- en: ➊ count=0
  prefs: []
  type: TYPE_NORMAL
- en: '#define z1 as z'
  prefs: []
  type: TYPE_NORMAL
- en: z1=z
  prefs: []
  type: TYPE_NORMAL
- en: '#iterate num times'
  prefs: []
  type: TYPE_NORMAL
- en: '➋ while count <= num:'
  prefs: []
  type: TYPE_NORMAL
- en: '#check for divergence'
  prefs: []
  type: TYPE_NORMAL
- en: 'if magnitude(z1) > 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '#return the step it diverged on'
  prefs: []
  type: TYPE_NORMAL
- en: return count
  prefs: []
  type: TYPE_NORMAL
- en: '#iterate z'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ z1=cAdd(cMult(z1,z1),z)
  prefs: []
  type: TYPE_NORMAL
- en: count+=1
  prefs: []
  type: TYPE_NORMAL
- en: '#if z hasn''t diverged by the end'
  prefs: []
  type: TYPE_NORMAL
- en: return num
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-3: Writing the mandelbrot() function to check how many steps a complex
    number takes to diverge*'
  prefs: []
  type: TYPE_NORMAL
- en: The mandelbrot() function takes a complex number, z, and a number of iterations
    as parameters. It returns the number of times it took for z to diverge, and if
    it never diverges, it returns num (at the end of the function). We create a count
    variable ➊ to keep track of the iterations, and we create a new complex number,
    z1, that gets squared and so on without changing z.
  prefs: []
  type: TYPE_NORMAL
- en: We start a loop to repeat the process while the count variable is less than num
    ➋. Inside the loop we check the magnitude of z1 to see whether z1 has diverged,
    and if it has, we return count and stop the code. Otherwise, we square z1 and
    add z to it ➌, which is the definition of our operation on complex numbers. Finally,
    we increment the count variable by 1 and loop through the process again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the *mandelbrot.pyde* program, we can plug in our complex number *z*
    = 0.25 + 0.75*i* and check the magnitude after every iteration. Here are the magnitudes
    after each loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '0.7905694150420949'
  prefs: []
  type: TYPE_NORMAL
- en: '1.1524430571616109'
  prefs: []
  type: TYPE_NORMAL
- en: '0.971392565148097'
  prefs: []
  type: TYPE_NORMAL
- en: '1.1899160852817983'
  prefs: []
  type: TYPE_NORMAL
- en: '2.122862368187107'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first number is the magnitude of z = 0.25 + 0.75*i* before any iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e136-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that it diverges after four iterations because it gets bigger than
    two units away from the origin. [Figure 7-7](ch07.xhtml#ch07fig7) graphs each
    step so you can visualize them.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f136-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Running the complex number 0.25 + 0.75* i *through the* mandelbrot()
    *function until it diverges*'
  prefs: []
  type: TYPE_NORMAL
- en: The red circle has a radius of two units and represents the limit we put on
    the complex number diverging. When squaring and adding in the original value of
    z, we cause the locations of the numbers to rotate and translate and eventually
    to get further away from the origin than our rule allows.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use some of the graphing tricks we learned in [Chapter 4](ch04.xhtml#ch04)
    to graph points and functions in the Processing display. Copy and paste all the
    complex number functions from *complex.py* (cAdd, cMult, and magnitude) to the
    bottom of *mandelbrot.pyde*. We’ll use Processing’s println() function to print
    to the console the number of steps it takes a point to diverge. Add the code in
    [Listing 7-4](ch07.xhtml#ch07list4) before the mandelbrot() code you wrote in
    [Listing 7-3](ch07.xhtml#ch07list3).
  prefs: []
  type: TYPE_NORMAL
- en: '*mandelbrot.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: '#range of x-values'
  prefs: []
  type: TYPE_NORMAL
- en: xmin = -2
  prefs: []
  type: TYPE_NORMAL
- en: xmax = 2
  prefs: []
  type: TYPE_NORMAL
- en: '#range of y-values'
  prefs: []
  type: TYPE_NORMAL
- en: ymin = -2
  prefs: []
  type: TYPE_NORMAL
- en: ymax = 2
  prefs: []
  type: TYPE_NORMAL
- en: '#calculate the range'
  prefs: []
  type: TYPE_NORMAL
- en: rangex = xmax - xmin
  prefs: []
  type: TYPE_NORMAL
- en: rangey = ymax - ymin
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: global xscl, yscl
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: noStroke()
  prefs: []
  type: TYPE_NORMAL
- en: xscl = float(rangex)/width
  prefs: []
  type: TYPE_NORMAL
- en: yscl = float(rangey)/height
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: z = [0.25,0.75]
  prefs: []
  type: TYPE_NORMAL
- en: println(mandelbrot(z,10))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-4: The beginning of the Mandelbrot code*'
  prefs: []
  type: TYPE_NORMAL
- en: We calculate the range of real values (x) and imaginary values (y) at the top
    of the program. Inside setup(), we calculate the scale factors (xscl and yscl)
    we need to multiply the pixels by (in this case, 0 to 600) in order to get the complex
    numbers (in this case, between –2 and 2). In the draw() function we define our
    complex number z, and then we feed it into the mandelbrot() function and print
    out what we get. Nothing will appear on the screen yet, but in the console, you’ll
    see the number 4 printed out. Now we’ll go through every pixel on the screen and
    put their location into the mandelbrot() function and display the results.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to our mandelbrot() function in the *mandelbrot.pyde* program.
    Repeating the multiplication and addition operations on a pixel’s location returns
    a number, and if the number never diverges, we color the pixel black. The entire
    draw() function is shown in [Listing 7-5](ch07.xhtml#ch07list5).
  prefs: []
  type: TYPE_NORMAL
- en: '*mandelbrot.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: '#origin in center:'
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/2,height/2)
  prefs: []
  type: TYPE_NORMAL
- en: '#go over all x''s and y''s on the grid'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ for x in range(width):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for y in range(height):'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ z = [(xmin + x * xscl) ,
  prefs: []
  type: TYPE_NORMAL
- en: (ymin + y * yscl) ]
  prefs: []
  type: TYPE_NORMAL
- en: '#put it into the mandelbrot function'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ col=mandelbrot(z,100)
  prefs: []
  type: TYPE_NORMAL
- en: '#if mandelbrot returns 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'if col == 100:'
  prefs: []
  type: TYPE_NORMAL
- en: 'fill(0) #make the rectangle black'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'fill(255) #make the rectangle white'
  prefs: []
  type: TYPE_NORMAL
- en: '#draw a tiny rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: rect(x,y,1,1)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-5: Looping over all the pixels in the display window*'
  prefs: []
  type: TYPE_NORMAL
- en: Going over all the pixels requires a nested loop for x and y ➊. We declare complex
    number z to be x + *i*y ➋. Calculating the complex number z from the window coordinates
    is a little tricky. We start at the xmin value, for instance, and add the number
    of steps we’re taking multiplied by the scale factor. We’re not going between
    0 and 600, which is the size of the display window in pixels; we’re just going
    between –2 and 2\. We run that through the mandelbrot() function ➌.
  prefs: []
  type: TYPE_NORMAL
- en: The mandelbrot() function squares and adds the complex number 100 times and
    returns the number of iterations it took for the number to diverge. This number
    is saved to a variable called col since color is already a keyword in Processing.
    The number in col determines what color we make that pixel. For now, let’s just
    get a Mandelbrot set on the screen by making every pixel that never diverges black.
    Otherwise, we’ll make the rectangle white. Run this code and you should see the
    famous Mandelbrot set, like in [Figure 7-8](ch07.xhtml#ch07fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f138-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: The famous Mandelbrot set*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Isn’t it amazing? And it’s definitely unexpected: just by squaring and adding
    complex numbers, and coloring the pixels according to how large the numbers get,
    we’ve drawn an infinitely complicated design that could never have been imagined
    without a computer! You can zoom in on specific spots in the design by changing
    the range of x and y, like in [Listing 7-6](ch07.xhtml#ch07list6).'
  prefs: []
  type: TYPE_NORMAL
- en: '#range of x-values'
  prefs: []
  type: TYPE_NORMAL
- en: xmin = -0.25
  prefs: []
  type: TYPE_NORMAL
- en: xmax = 0.25
  prefs: []
  type: TYPE_NORMAL
- en: '#range of y-values'
  prefs: []
  type: TYPE_NORMAL
- en: ymin = -1
  prefs: []
  type: TYPE_NORMAL
- en: ymax = -0.5
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-6: Changing the range of values to zoom in on the Mandelbrot set*'
  prefs: []
  type: TYPE_NORMAL
- en: Now the output should look like [Figure 7-9](ch07.xhtml#ch07fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f139-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: Zooming in on the Mandelbrot set!*'
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend that you investigate videos people have posted on the internet
    of zooming in on the Mandelbrot set.
  prefs: []
  type: TYPE_NORMAL
- en: ADDING COLOR TO THE MANDELBROT SET
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s add some color to your Mandelbrot design. Let Processing know you’re
    using the HSB (Hue, Saturation, Brightness) scale, not the RGB (Red, Green, Blue)
    scale, by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup():'
  prefs: []
  type: TYPE_NORMAL
- en: size(600,600)
  prefs: []
  type: TYPE_NORMAL
- en: colorMode(HSB)
  prefs: []
  type: TYPE_NORMAL
- en: noStroke()
  prefs: []
  type: TYPE_NORMAL
- en: 'Then color the rectangles according to the value returned by the mandelbrot()
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if col == 100:'
  prefs: []
  type: TYPE_NORMAL
- en: fill(0)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: fill(3*col,255,255)
  prefs: []
  type: TYPE_NORMAL
- en: '#draw a tiny rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: rect(x*xscl,y*yscl,1,1)
  prefs: []
  type: TYPE_NORMAL
- en: In the fill line, we multiply the col variable (the number of iterations it takes
    the complex number to diverge) by 3 and make that the H (hue) component of the
    HSB color mode. Run this code, and you should see a nicely colored Mandelbrot
    set like in [Figure 7-10](ch07.xhtml#ch07fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f140-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: Using divergence values to color the Mandelbrot set*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the points that diverge every step, from the dark orange circle
    to lighter orange ovals that become the black Mandelbrot set. You can experiment
    with other colors too. For example, change the fill line to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: fill(255-15*col,255,255)
  prefs: []
  type: TYPE_NORMAL
- en: Run this update, and you’ll see more blue in the picture, as shown in [Figure
    7-11](ch07.xhtml#ch07fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f140-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*[Figure 7-11](ch07.xhtml#ch07fig11): Experimenting with different colors in
    the Mandelbrot set*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore a related design called the Julia set, which can change
    its appearance depending on the inputs we give it.
  prefs: []
  type: TYPE_NORMAL
- en: CREATING THE JULIA SET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Mandelbrot set, to determine the color of each point, we started with
    the point as a complex number z and then repeatedly squared the value and added
    the original number z. The Julia set is constructed just like the Mandelbrot set,
    but after squaring the complex number, instead of adding the original complex
    number of that point, we keep adding a constant complex number, *c*, which has
    the same value for all points. By starting with different values for *c*, we can
    create lots of different Julia sets.
  prefs: []
  type: TYPE_NORMAL
- en: WRITING THE JULIA() FUNCTION
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Wikipedia page for the Julia set gives a bunch of examples of beautiful
    Julia sets and the complex numbers to use to create them. Let’s try to create
    one using *c* = –0.8 + 0.156*i*. We can easily modify our mandelbrot() function
    to be a julia() function. Save your *mandelbrot.pyde* sketch as *julia.pyde* and
    change the code for the mandelbrot() function so it looks like [Listing 7-7](ch07.xhtml#ch07list7).
  prefs: []
  type: TYPE_NORMAL
- en: '*julia.pyde*'
  prefs: []
  type: TYPE_NORMAL
- en: 'def julia(z,c,num):'
  prefs: []
  type: TYPE_NORMAL
- en: '''''''runs the process num times'
  prefs: []
  type: TYPE_NORMAL
- en: and returns the diverge count'''
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: '#define z1 as z'
  prefs: []
  type: TYPE_NORMAL
- en: z1 = z
  prefs: []
  type: TYPE_NORMAL
- en: '#iterate num times'
  prefs: []
  type: TYPE_NORMAL
- en: 'while count <= num:'
  prefs: []
  type: TYPE_NORMAL
- en: '#check for divergence'
  prefs: []
  type: TYPE_NORMAL
- en: 'if magnitude(z1) > 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '#return the step it diverged on'
  prefs: []
  type: TYPE_NORMAL
- en: return count
  prefs: []
  type: TYPE_NORMAL
- en: '#iterate z'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ z1 = cAdd(cMult(z1,z1),c)
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-7: Writing the julia() function*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s pretty much the same as the Mandelbrot function. The only line of code
    that changed is ➊, where z is changed to c. The complex number c will be different
    from z, so we’ll have to pass that to the julia() function in draw(), as shown
    in [Listing 7-8](ch07.xhtml#ch07list8).
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw():'
  prefs: []
  type: TYPE_NORMAL
- en: '#origin in center:'
  prefs: []
  type: TYPE_NORMAL
- en: translate(width/2,height/2)
  prefs: []
  type: TYPE_NORMAL
- en: '#go over all x''s and y''s on the grid'
  prefs: []
  type: TYPE_NORMAL
- en: x = xmin
  prefs: []
  type: TYPE_NORMAL
- en: 'while x < xmax:'
  prefs: []
  type: TYPE_NORMAL
- en: y = ymin
  prefs: []
  type: TYPE_NORMAL
- en: 'while y < ymax:'
  prefs: []
  type: TYPE_NORMAL
- en: z = [x,y]
  prefs: []
  type: TYPE_NORMAL
- en: ➊ c = [-0.8,0.156]
  prefs: []
  type: TYPE_NORMAL
- en: '#put it into the julia program'
  prefs: []
  type: TYPE_NORMAL
- en: col = julia(z,c,100)
  prefs: []
  type: TYPE_NORMAL
- en: '#if julia returns 100'
  prefs: []
  type: TYPE_NORMAL
- en: 'if col == 100:'
  prefs: []
  type: TYPE_NORMAL
- en: fill(0)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: '#map the color from 0 to 100'
  prefs: []
  type: TYPE_NORMAL
- en: '#to 0 to 255'
  prefs: []
  type: TYPE_NORMAL
- en: '#coll = map(col,0,100,0,300)'
  prefs: []
  type: TYPE_NORMAL
- en: fill(3*col,255,255)
  prefs: []
  type: TYPE_NORMAL
- en: rect(x*xscl,y*yscl,1,1)
  prefs: []
  type: TYPE_NORMAL
- en: y += 0.01
  prefs: []
  type: TYPE_NORMAL
- en: x += 0.01
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-8: Writing the draw() function for the Julia set*'
  prefs: []
  type: TYPE_NORMAL
- en: Everything is the same as in *mandelbrot.pyde* until we declare the complex
    number c ➊ we’ve chosen for this Julia set. Just below that we add c to the arguments
    in the call to the julia() function. When you run it, you get a design much different
    from the Mandelbrot set, as shown in [Figure 7-12](ch07.xhtml#ch07fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f142-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: The Julia set for* c *= –0.8 + 0.156* i'
  prefs: []
  type: TYPE_NORMAL
- en: The great thing about the Julia set is you can change the input c and get a
    different output. For example, if you change *c* to 0.4 + 0.6*i*, you should see
    something like [Figure 7-13](ch07.xhtml#ch07fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f143-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: The Julia set for* c *= –0.4 + 0.6*i'
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 7-1: DRAWING A JULIA SET'
  prefs: []
  type: TYPE_NORMAL
- en: Draw a Julia set with *c* = 0.285 + 0.01*i*.
  prefs: []
  type: TYPE_NORMAL
- en: SUMMARY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how complex numbers get plotted on the complex
    coordinate plane and how they allow you to perform rotations—and you followed
    their logic down the rabbit hole, learning how to add and multiply them. You used
    what you learned to write the mandelbrot() and julia() functions to transform
    complex numbers into incredible art that never would have been possible without
    the creation of complex numbers and the invention of computers.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, these numbers are anything but imaginary! Hopefully, when you
    think of complex numbers now, they’ll remind you of the beautiful designs you
    can make with numbers and code.
  prefs: []
  type: TYPE_NORMAL
