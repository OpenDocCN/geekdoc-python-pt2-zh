- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: COMPLEX NUMBERS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 复数
- en: '*Imaginary numbers are a fine and wonderful refuge of the divine spirit, almost
    an amphibian between being and non-being. —Gottfried Leibniz*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚数是神圣精神的美妙庇护所，几乎是存在与非存在之间的两栖物种。——戈特弗里德·莱布尼茨*'
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: Numbers containing the square root of –1 have been given a bad name in math
    classes. We call the square root of –1 an *imaginary number*, or *i*. Calling
    something “imaginary” makes it seem like it doesn’t exist or like there’s no real
    purpose for it. But imaginary numbers *do* exist, and they have a lot of real-world
    applications in fields such as electromagnetism, for instance.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 –1 的平方根的数字在数学课堂上常常被误解。我们把 –1 的平方根称为 *虚数*，或 *i*。称某物为“虚拟”会让它看起来像是不存在的，或者好像没有实际的用途。但虚数确实存在，而且在电磁学等领域中有很多实际应用。
- en: In this chapter, you get a taste of the kinds of beautiful art you can create
    using *complex numbers*, which are numbers that have both a real and imaginary
    part written in the form of *a* + *bi*, where *a* and *b* are real numbers and
    *i* is the imaginary number. Because a complex number holds two different bits
    of information, real and imaginary, you can use it to turn one-dimensional objects
    into two-dimensional ones. Using Python, manipulating these numbers becomes easier,
    and we can use them for some very magical purposes. In fact, we use complex numbers
    to explain behaviors of electrons and photons, and what we think of as natural,
    “normal” numbers are actually complex numbers whose imaginary parts equal zero!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将体验使用 *复数* 创建美丽艺术作品的乐趣。复数是具有实部和虚部的数字，写成 *a* + *bi* 的形式，其中 *a* 和 *b* 是实数，*i*
    是虚数。由于复数包含两个不同的信息，实部和虚部，你可以利用它将一维物体转化为二维物体。使用 Python 后，操作这些数字变得更加简单，我们可以将其用于一些非常神奇的用途。事实上，我们使用复数来解释电子和光子的行为，而我们认为是自然的、“正常”的数字实际上是虚部为零的复数！
- en: We begin this chapter by reviewing how to plot complex numbers in the complex
    coordinate plane. You also learn how to express complex numbers as Python lists
    and then write functions to add and multiply them. Finally, you learn how to find
    the magnitude, or absolute value, of a complex number. Knowing how to manipulate
    complex numbers will come in handy when we write the programs for creating the
    Mandelbrot set and the Julia set later in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时，我们回顾如何在复数坐标平面中绘制复数。你还将学习如何将复数表示为 Python 列表，然后编写函数对其进行加法和乘法运算。最后，你将学习如何求复数的大小或绝对值。在本章后面，我们编写用于生成曼德尔布罗特集合和朱莉亚集合的程序时，了解如何操作复数将大有帮助。
- en: THE COMPLEX COORDINATE SYSTEM
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复数坐标系
- en: As Frank Farris summed up in his brilliant and beautifully illustrated book
    *Creating Symmetry*, “Complex numbers . . . are simply a way to express the Cartesian
    ordered pair of real numbers, (*x, y*), compactly as a single number *z* = *x*
    + *iy*.” We all know the Cartesian coordinate system uses *x* to represent the
    horizontal axis and *y* to represent the vertical axis, but we never add or multiply
    those numbers; they just represent a location.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如弗兰克·法里斯在他精彩且插图精美的著作《*对称的创造*》中总结的那样：“复数……仅仅是一种将实数的笛卡尔有序对（*x, y*）紧凑地表示为一个单一数字
    *z* = *x* + *iy* 的方式。” 我们都知道，笛卡尔坐标系使用 *x* 表示水平轴，*y* 表示垂直轴，但我们从未对这些数字进行加法或乘法运算；它们仅仅代表一个位置。
- en: In contrast, complex numbers not only can represent locations but they can also
    be operated on like any other numbers. It helps to look at complex numbers geometrically.
    Let’s change our coordinate system a little so that now the real numbers are on
    the horizontal axis and the imaginary numbers are on the vertical axis, as in
    [Figure 7-1](ch07.xhtml#ch07fig1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，复数不仅可以表示位置，还可以像其他数字一样进行运算。从几何角度来看复数会更有帮助。让我们稍微改变一下坐标系统，使得实数位于水平轴上，虚数位于垂直轴上，如
    [图 7-1](ch07.xhtml#ch07fig1) 所示。
- en: '![image](../images/f128-01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f128-01.jpg)'
- en: '*Figure 7-1: The complex coordinate system*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：复数坐标系*'
- en: Here, you can see where *a* + *bi* and *a* – *bi* would be located on a complex
    coordinate system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 *a* + *bi* 和 *a* – *bi* 在复数坐标系中的位置。
- en: '### ADDING COMPLEX NUMBERS'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '### 复数相加'
- en: 'Adding and subtracting complex numbers are the same as with real numbers: you
    start at one number and take the number of steps represented by the other number.
    For example, to add the numbers 2 + 3*i* and 4 + *i*, you would simply add the
    real parts and the imaginary parts of the numbers separately to get 6 + 4*i*,
    as shown in [Figure 7-2](ch07.xhtml#ch07fig2).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的加法和减法与实数的操作一样：你从一个数开始，然后按照另一个数所表示的步数进行操作。例如，要加上 2 + 3*i* 和 4 + *i*，你只需分别加上它们的实部和虚部，得到
    6 + 4*i*，如[图 7-2](ch07.xhtml#ch07fig2)所示。
- en: '![image](../images/f129-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f129-01.jpg)'
- en: '*Figure 7-2: Adding two complex numbers*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：加法运算的复数*'
- en: As you can see, we start at 4 + *i*. To add 2 + 3*i*, we move two units in the
    positive real direction and three units in the positive imaginary direction, and
    end up at 6 + 4*i*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们从 4 + *i* 开始。为了加上 2 + 3*i*，我们向正实轴方向移动两个单位，向正虚轴方向移动三个单位，最终到达 6 + 4*i*。
- en: Let’s write the function for adding two complex numbers using the code in [Listing
    7-1](ch07.xhtml#ch07list1). Open a new file in IDLE and name it *complex.py*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个用于加法运算的复数函数，代码示例见[清单 7-1](ch07.xhtml#ch07list1)。在 IDLE 中打开一个新文件并命名为 *complex.py*。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: The function for adding two complex numbers*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：加法运算函数示例*'
- en: Here, we define the function called `cAdd()`, giving it two complex numbers
    in list form `[x,y]`, which returns another list. The first term of the list,
    `a[0]+b[0]`, is the sum of the first terms of the complex numbers (index 0) we
    provide. The second term, `a[1]+b[1]`, is the sum of the second terms (index 1)
    of the two complex numbers. Save and run this program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `cAdd()` 的函数，给它两个复数以列表形式 `[x,y]` 传入，该函数返回另一个列表。列表的第一个元素 `a[0]
    + b[0]` 是我们提供的复数的第一个项（索引 0）的和。第二个元素 `a[1] + b[1]` 是两个复数的第二个项（索引 1）的和。保存并运行此程序。
- en: 'Now let’s test the program using the complex numbers `u = 1 + 2i` and `v =
    3 + 4i`. Plug them into our `cAdd()` function in the interactive shell, like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用复数 `u = 1 + 2i` 和 `v = 3 + 4i` 来测试这个程序。在交互式 shell 中将它们传递给我们的 `cAdd()`
    函数，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should get 6 + 4*i*, which is the sum of the complex numbers 1 + 2*i* and
    3 + 4*i*. Adding complex numbers is just like taking steps in the x-direction
    and then in the y-direction, and we’ll see this function again when we want to
    create beautiful designs like the Mandelbrot set and the Julia set.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到 6 + 4*i*，这是复数 1 + 2*i* 和 3 + 4*i* 的和。复数相加就像是先沿 x 方向走一步，再沿 y 方向走一步，当我们需要创建像曼德尔布罗集和朱莉亚集这样的美丽设计时，这个函数还会再次出现。
- en: MULTIPLYING A COMPLEX NUMBER BY I
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘以复数的 *i*
- en: But adding complex numbers isn’t the most useful thing. Multiplying them is.
    For example, multiplying a complex number by *i* rotates the complex number around
    the origin by 90 degrees. In the complex coordinate system, multiplying a real
    number by –1 would rotate it 180 degrees around the origin, as shown in [Figure
    7-3](ch07.xhtml#ch07fig3).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，复数相加并不是最有用的操作，乘法才是。例如，乘以 *i* 会让复数绕原点旋转 90 度。在复数坐标系统中，乘以 -1 相当于绕原点旋转 180 度，如[图
    7-3](ch07.xhtml#ch07fig3)所示。
- en: '![image](../images/f130-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f130-01.jpg)'
- en: '*Figure 7-3: Multiplying a number by –1 as a 180-degree rotation*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：乘以 -1 表示 180 度旋转*'
- en: As you can see, 1 times –1 equals –1, which rotates 1 over to the other side
    of zero.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，1 乘以 -1 等于 -1，这使得 1 绕零点旋转到了另一侧。
- en: Because multiplying a complex number by –1 is the same as a 180 degree rotation,
    the square root of –1 would represent a 90 degree rotation, as shown in [Figure
    7-4](ch07.xhtml#ch07fig4).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因为乘以 -1 相当于进行 180 度的旋转，所以 -1 的平方根表示 90 度的旋转，如[图 7-4](ch07.xhtml#ch07fig4)所示。
- en: '![image](../images/f130-02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f130-02.jpg)'
- en: '*Figure 7-4: Multiplying a number by* i *as a 90-degree rotation*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：乘以 *i* 表示 90 度旋转*'
- en: This means that *i* represents the square root of –1, the number that rotates
    us halfway to –1 when we multiply it by 1\. Multiplying the result (*i*) by *i*
    again causes us to rotate 90 degrees more, and we end up with –1\. This confirms
    the definition of the square root because we are able to get to the negative value
    of a number by multiplying it by the same number (*i*) twice.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 *i* 代表 -1 的平方根，乘以 1 时将我们旋转至 -1 的一半。将结果 (*i*) 再乘以 *i* 会让我们再旋转 90 度，最终得到
    -1。这样就验证了平方根的定义，因为通过将同一个数 (*i*) 自身乘以两次，我们可以得到一个负数。
- en: MULTIPLYING TWO COMPLEX NUMBERS
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘法运算：两个复数的乘法
- en: 'Let’s see what happens when we multiply two complex numbers. Just like you
    would multiply two binomial expressions, you can multiply two complex numbers
    algebraically using the FOIL method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们相乘两个复数时会发生什么。就像你会用FOIL方法相乘两个二项式一样，你可以用代数方式通过FOIL方法相乘两个复数：
- en: '![image](../images/e131-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e131-01.jpg)'
- en: To make this easier, let’s translate this process into a `cMult()` function,
    as shown in [Listing 7-2](ch07.xhtml#ch07list2).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这一过程，让我们将这个过程转化为`cMult()`函数，如[列表 7-2](ch07.xhtml#ch07list2)所示。
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-2: Writing the function for multiplying two complex numbers*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-2：编写乘法函数以相乘两个复数*'
- en: 'To test the `cMult()` function, try multiplying u = 1 + 2*i* by v = 3 + 4*i*.
    Enter the following in the interactive shell:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`cMult()`函数，尝试将u = 1 + 2*i*与v = 3 + 4*i*相乘。在交互式shell中输入以下内容：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the product is –5 + 10*i*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，乘积是–5 + 10*i*。
- en: 'Recall from the previous section that multiplying a complex number by *i* is
    the same as performing a 90 degree rotation about the origin of the complex coordinate
    system. Let’s try it now with v = 3 + 4*i*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一节内容，复数与*i*相乘等同于在复平面坐标系原点进行90度旋转。现在，让我们用v = 3 + 4*i*来试一试：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result is –4 + 3*i*. When we graph 3 + 4*i* and –4 + 3*i*, you should see
    something like what’s shown in [Figure 7-5](ch07.xhtml#ch07fig5).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 –4 + 3*i*。当我们将3 + 4*i*与–4 + 3*i*画出时，你应该会看到类似于[图 7-5](ch07.xhtml#ch07fig5)所示的内容。
- en: '![image](../images/f132-01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f132-01.jpg)'
- en: '*Figure 7-5: Rotating a complex number 90 degrees by multiplying by* i'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：通过与*i*相乘将复数旋转90度*'
- en: As you can see, –4 + 3*i* is 90 degrees rotation from 3 + 4*i*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，–4 + 3*i*是3 + 4*i*的90度旋转结果。
- en: Now that you know how to add and multiply complex numbers, let’s go over how
    to find the magnitude of a complex number, which you’ll use to create the Mandelbrot
    set and Julia set.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何加法和乘法运算复数，让我们来看看如何求一个复数的模，你将使用它来创建曼德尔布罗特集和朱莉亚集。
- en: WRITING THE MAGNITUDE() FUNCTION
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写MAGNITUDE()函数
- en: 'The *magnitude*, or *absolute value*, of a complex number is how far the complex
    number is away from the origin on the complex coordinate plane. Now let’s create
    a magnitude function using the Pythagorean theorem. Return to *complex.py* and
    make sure to import the square root function from Python’s `math` module at the
    top of the file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的*模*，或*绝对值*，表示复数与复平面原点的距离。现在，让我们使用毕达哥拉斯定理来创建一个模函数。返回到*complex.py*并确保在文件顶部从Python的`math`模块导入平方根函数：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `magnitude()` function is just the Pythagorean theorem:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`magnitude()`函数就是毕达哥拉斯定理：'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s find the magnitude of the complex number 2 + i:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来找出复数2 + i的模：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now you’re ready to write a Python program that colors the pixels on the display
    window according to how large the complex numbers get. The unexpected behavior
    of complex numbers will result in an infinitely complicated design that’s impossible
    to replicate without a computer!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好编写一个Python程序，根据复数的大小为显示窗口上的像素上色。复数的意外行为将导致一个无限复杂的设计，无法在没有计算机的情况下复制！
- en: CREATING THE MANDELBROT SET
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建曼德尔布罗特集
- en: To create the Mandelbrot set, we’re going to represent each pixel on our display
    window as a complex number, *z*, then repeatedly square the value, and add the
    original number *z*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建曼德尔布罗特集，我们将把显示窗口上的每个像素表示为复数*z*，然后反复对其进行平方，并加上原始的复数*z*。
- en: '![image](../images/e132-01.jpg) Then, we’re going to do the same to the output,
    again and again. If the number keeps getting larger, we’ll color the pixel corresponding
    to the original complex number according to how many iterations it takes for its
    magnitude to get bigger than a certain number, like 2\. If the number keeps getting
    smaller, we’ll give it a different color.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](../images/e132-01.jpg) 然后，我们将对输出进行相同的处理，一次又一次。如果数值持续增大，我们将根据其模大于某个特定值（如2）所需的迭代次数为原始复数对应的像素上色。如果数值持续变小，我们将为其选择不同的颜色。'
- en: You already know that multiplying a number by a number larger than 1 makes the
    original number larger. A number multiplied by 1 stays the same, and multiplying
    by a number smaller than 1 makes the original number smaller. Complex numbers
    follow a similar pattern, which you can represent on the complex plane as shown
    in [Figure 7-6](ch07.xhtml#ch07fig6).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道，将一个数与大于1的数相乘会使原始数变大。将一个数与1相乘保持不变，而与小于1的数相乘则会使原始数变小。复数遵循类似的模式，你可以在复平面上表示，如[图
    7-6](ch07.xhtml#ch07fig6)所示。
- en: '![image](../images/f133-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f133-01.jpg)'
- en: '*Figure 7-6: Visualizing what happens when you multiply complex numbers*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：可视化当你乘以复数时发生的情况*'
- en: If we were only multiplying complex numbers, the Mandelbrot set would look like
    [Figure 7-6](ch07.xhtml#ch07fig6), a circle. But not only is the complex number
    squared, a number is added afterward. This will change the circle into an infinitely
    complicated and surprisingly beautiful figure. But before we can do that, we need
    to operate on every point on the grid!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是在乘以复数，曼德布罗集合将看起来像[图 7-6](ch07.xhtml#ch07fig6)，一个圆形。但不仅仅是对复数进行平方，之后还会加上一个数字。这将使得圆形变成一个无限复杂且令人惊叹的美丽图形。但是在此之前，我们需要对网格上的每个点进行操作！
- en: Depending on the result of the operation, some will get smaller and *converge*
    to zero. Others will get bigger and *diverge*. Getting close to a number in math
    terms is called *converging*. Getting too big in math terms is called *diverging*.
    For our purposes, we’ll color every pixel on the grid according to how many iterations
    it takes it to get too big and fly off the grid. The formula we plug the number
    into is similar to our `cMult()` function from [Listing 7-2](ch07.xhtml#ch07list2),
    with an extra step. We square the number, add the original complex number to the
    square, and then repeat that process until it diverges. If the magnitude of the
    squared complex number gets larger than 2, it means it has diverged (we can pick
    any number we want to be the maximum). If it never gets bigger than 2, we’ll leave
    it black.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作的结果，有些复数将变小并*收敛*到零，而其他的则变大并*发散*。在数学术语中，接近某个数字称为*收敛*，而变得过大则称为*发散*。对于我们的目的，我们将根据每个像素点需要多少次迭代才能变得太大并飞出网格来为其上色。我们将数字代入的公式类似于我们在[清单
    7-2](ch07.xhtml#ch07list2)中使用的 `cMult()` 函数，只不过多了一步。我们将数字平方，再加上原始的复数，并重复这个过程，直到它发散。如果平方后的复数的大小大于
    2，就意味着它已经发散（我们可以选择任何数字作为最大值）。如果它从未超过 2，我们将保持其颜色为黑色。
- en: 'For example, let’s try the Mandelbrot set operation manually using the complex
    number *z* = 0.25 + 1.5*i*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们手动尝试使用复数 *z* = 0.25 + 1.5*i* 来进行曼德布罗集合操作：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We square `z` by multiplying it by itself and saving the result to the variable
    `z2`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 `z` 乘以它自己并将结果保存到变量 `z2` 来进行平方：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we add `z2` and `z` using the `cAdd()` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 `cAdd()` 函数将 `z2` 和 `z` 相加：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have a function we can use to test if this complex number is more than two
    units away from the origin using the Pythagorean theorem. Let’s use our `magnitude()`
    function from earlier to check if the magnitude of the complex number we got is
    greater than 2:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个函数可以用来测试这个复数是否距离原点超过两单位，方法是使用毕达哥拉斯定理。我们可以使用之前的 `magnitude()` 函数来检查得到的复数的大小是否大于
    2：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We set the rule as follows: “If a number gets more than two units away from
    the origin, it diverges.” Therefore, the complex number *z* = 0.25 + 1.5*i* diverges
    after only 1 iteration!'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设定规则如下：“如果一个数字离原点超过两单位，它就会发散。”因此，复数 *z* = 0.25 + 1.5*i* 在进行 1 次迭代后就会发散！
- en: 'This time, let’s try with *z* = 0.25 + 0.75*i*, as shown next:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们尝试 *z* = 0.25 + 0.75*i*，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we repeated the same process as before, except this time we need to add
    `z2` and `z` again, saving it as `z3`. It’s still within two units of the origin,
    so let’s replace `z` with this new value and put it back through the process again.
    First, we create a new variable, `z1`, that we can use to square the original
    `z`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重复了之前的相同过程，只不过这次我们需要再次将 `z2` 和 `z` 相加，并将其保存为 `z3`。它仍然在离原点两单位以内，因此我们用这个新值替换
    `z` 并再次进行该过程。首先，我们创建一个新变量 `z1`，用于对原始的 `z` 进行平方：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s repeat the process using the newest value of our complex number, `z3`.
    We’ll square it, add `z1`, and find the magnitude:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用复数 `z3` 的最新值重复这个过程。我们将对其进行平方，加上 `z1`，然后找出大小：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because 0.97 is smaller than 1.152, we might guess that the result is getting
    smaller and therefore doesn’t look like it’s going to diverge, but we’ve only
    repeated the process twice. Doing this by hand is laborious! Let’s automate the
    steps so that we can repeat the process quickly and easily. We’ll use the squaring,
    adding, and finding the magnitude functions to write a function called `mandelbrot()`
    that automates the checking process so that we can visually separate the diverging
    numbers from the converging ones. What design do you think it’ll make? A circle?
    An ellipse? Let’s find out!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 0.97 小于 1.152，我们可能猜测结果正在变小，因此看起来不会发散，但我们只重复了两次这个过程。手动进行这些操作很费劲！让我们自动化这些步骤，以便能够快速轻松地重复这一过程。我们将使用平方、相加和求大小的函数来编写一个名为
    `mandelbrot()` 的函数，自动化检查过程，这样我们就能将发散的数字与收敛的数字区分开来。你认为它会呈现什么样的设计？一个圆形？一个椭圆？让我们来看看！
- en: WRITING THE MANDELBROT() FUNCTION
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 `MANDELBROT()` 函数
- en: Let’s open a Processing sketch and call it *mandelbrot.pyde*. The Mandelbrot
    set we’re trying to re-create here is named after the mathematician Benoit Mandelbrot,
    who first explored this process using computers in the 1970s. We’ll repeat the
    squaring and adding process a maximum number of times, or until the number diverges,
    as shown in [Listing 7-3](ch07.xhtml#ch07list3).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个 Processing 草图，并将其命名为 *mandelbrot.pyde*。我们在这里尝试重现的 Mandelbrot 集合以数学家贝努瓦·曼德布罗特（Benoit
    Mandelbrot）的名字命名，他在 1970 年代首次使用计算机探索这个过程。我们将重复平方和相加的过程，最多迭代若干次，或者直到数字发散，具体过程见[清单
    7-3](ch07.xhtml#ch07list3)。
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 7-3: Writing the `mandelbrot()` function to check how many steps a
    complex number takes to diverge*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-3：编写 `mandelbrot()` 函数以检查复数发散所需的步数*'
- en: The `mandelbrot()` function takes a complex number, `z`, and a number of iterations
    as parameters. It returns the number of times it took for `z` to diverge, and
    if it never diverges, it returns `num` (at the end of the function). We create
    a `count` variable ➊ to keep track of the iterations, and we create a new complex
    number, `z1`, that gets squared and so on without changing `z`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`mandelbrot()` 函数接受一个复数 `z` 和一个迭代次数作为参数。它返回 `z` 发散所需的次数，如果 `z` 永远不发散，则返回 `num`（在函数结束时）。我们创建了一个
    `count` 变量 ➊ 来跟踪迭代次数，并创建了一个新的复数 `z1`，它被平方并如此继续，但 `z` 保持不变。'
- en: We start a loop to repeat the process while the `count` variable is less than `num`
    ➋. Inside the loop we check the magnitude of `z1` to see whether `z1` has diverged,
    and if it has, we return `count` and stop the code. Otherwise, we square `z1`
    and add `z` to it ➌, which is the definition of our operation on complex numbers.
    Finally, we increment the `count` variable by 1 and loop through the process again.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始一个循环，在 `count` 变量小于 `num` ➋ 时重复这个过程。在循环内，我们检查 `z1` 的大小，看看它是否已经发散，如果发散了，我们返回
    `count` 并停止代码。否则，我们对 `z1` 进行平方操作并将 `z` 加到其中 ➌，这就是我们对复数的操作定义。最后，我们将 `count` 变量加
    1，并再次进行循环。
- en: 'Using the *mandelbrot.pyde* program, we can plug in our complex number *z*
    = 0.25 + 0.75*i* and check the magnitude after every iteration. Here are the magnitudes
    after each loop:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *mandelbrot.pyde* 程序，我们可以将复数 *z* = 0.25 + 0.75*i* 插入，并在每次迭代后检查其大小。以下是每次循环后的大小：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first number is the magnitude of z = 0.25 + 0.75*i* before any iterations:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字是 z = 0.25 + 0.75*i* 在任何迭代之前的大小：
- en: '![image](../images/e136-01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e136-01.jpg)'
- en: You can see that it diverges after four iterations because it gets bigger than
    two units away from the origin. [Figure 7-7](ch07.xhtml#ch07fig7) graphs each
    step so you can visualize them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它在四次迭代后发散，因为它与原点的距离超过了两单位。[图 7-7](ch07.xhtml#ch07fig7) 绘制了每一步的图表，帮助你可视化它们。
- en: '![image](../images/f136-01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f136-01.jpg)'
- en: '*Figure 7-7: Running the complex number 0.25 + 0.75* i *through the* mandelbrot()
    *function until it diverges*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：运行复数 0.25 + 0.75*i* 通过 `mandelbrot()` 函数直到它发散*'
- en: The red circle has a radius of two units and represents the limit we put on
    the complex number diverging. When squaring and adding in the original value of
    `z`, we cause the locations of the numbers to rotate and translate and eventually
    to get further away from the origin than our rule allows.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 红色圆圈的半径为两单位，表示我们对复数发散设定的限制。当对原始值 `z` 进行平方和相加时，我们使数字的位置旋转并平移，最终使它们距离原点比我们的规则允许的更远。
- en: Let’s use some of the graphing tricks we learned in [Chapter 4](ch04.xhtml#ch04)
    to graph points and functions in the Processing display. Copy and paste all the
    complex number functions from *complex.py* (`cAdd`, `cMult`, and `magnitude`)
    to the bottom of *mandelbrot.pyde*. We’ll use Processing’s `println()` function
    to print to the console the number of steps it takes a point to diverge. Add the
    code in [Listing 7-4](ch07.xhtml#ch07list4) before the `mandelbrot()` code you
    wrote in [Listing 7-3](ch07.xhtml#ch07list3).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用在[第 4 章](ch04.xhtml#ch04)中学到的一些绘图技巧，在Processing显示中绘制点和函数。将*complex.py*中的所有复数函数（`cAdd`、`cMult`和`magnitude`）复制并粘贴到*mandelbrot.pyde*文件的底部。我们将使用Processing的`println()`函数打印出一个点发散所需的步骤数。将[清单
    7-4](ch07.xhtml#ch07list4)中的代码添加到你在[清单 7-3](ch07.xhtml#ch07list3)中编写的`mandelbrot()`代码之前。
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 7-4: The beginning of the Mandelbrot code*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-4：曼德博集合代码的开始部分*'
- en: We calculate the range of real values (`x`) and imaginary values (`y`) at the
    top of the program. Inside `setup()`, we calculate the scale factors (`xscl` and
    `yscl`) we need to multiply the pixels by (in this case, 0 to 600) in order to
    get the complex numbers (in this case, between –2 and 2). In the `draw()` function
    we define our complex number `z`, and then we feed it into the `mandelbrot()`
    function and print out what we get. Nothing will appear on the screen yet, but
    in the console, you’ll see the number 4 printed out. Now we’ll go through every
    pixel on the screen and put their location into the `mandelbrot()` function and
    display the results.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序的顶部计算实数值（`x`）和虚数值（`y`）的范围。在`setup()`函数内，我们计算所需的缩放因子（`xscl`和`yscl`），将像素乘以（在这种情况下是0到600），以获得复数（在这种情况下是从–2到2）。在`draw()`函数中，我们定义我们的复数`z`，然后将其传递给`mandelbrot()`函数并打印出结果。此时，屏幕上不会显示任何内容，但在控制台中，你会看到打印出的数字4。现在，我们将遍历屏幕上的每一个像素，并将它们的位置输入`mandelbrot()`函数并显示结果。
- en: Let’s return to our `mandelbrot()` function in the *mandelbrot.pyde* program.
    Repeating the multiplication and addition operations on a pixel’s location returns
    a number, and if the number never diverges, we color the pixel black. The entire
    `draw()` function is shown in [Listing 7-5](ch07.xhtml#ch07list5).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`mandelbrot()`函数，位于*mandelbrot.pyde*程序中。对像素位置进行重复的乘法和加法操作会返回一个数值，如果这个数值从不发散，我们就将该像素涂成黑色。整个`draw()`函数展示在[清单
    7-5](ch07.xhtml#ch07list5)中。
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 7-5: Looping over all the pixels in the display window*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-5：遍历显示窗口中所有像素*'
- en: Going over all the pixels requires a nested loop for `x` and `y` ➊. We declare
    complex number `z` to be x + *i*y ➋. Calculating the complex number `z` from the
    window coordinates is a little tricky. We start at the `xmin` value, for instance,
    and add the number of steps we’re taking multiplied by the scale factor. We’re
    not going between 0 and 600, which is the size of the display window in pixels;
    we’re just going between –2 and 2\. We run that through the `mandelbrot()` function
    ➌.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历所有像素需要一个嵌套循环来处理`x`和`y` ➊。我们声明复数`z`为x + *i*y ➋。根据窗口坐标计算复数`z`稍微有点复杂。我们从`xmin`值开始，例如，然后加上我们所采取的步数乘以缩放因子。我们并不是在0和600之间变化，这是显示窗口的像素大小；我们实际上是在–2和2之间变化。我们将其传递给`mandelbrot()`函数
    ➌。
- en: The `mandelbrot()` function squares and adds the complex number 100 times and
    returns the number of iterations it took for the number to diverge. This number
    is saved to a variable called `col` since `color` is already a keyword in Processing.
    The number in `col` determines what color we make that pixel. For now, let’s just
    get a Mandelbrot set on the screen by making every pixel that never diverges black.
    Otherwise, we’ll make the rectangle white. Run this code and you should see the
    famous Mandelbrot set, like in [Figure 7-8](ch07.xhtml#ch07fig8).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`mandelbrot()`函数将复数平方并加起来100次，并返回数值发散所需的迭代次数。这个数字保存到一个名为`col`的变量中，因为`color`已经是Processing中的关键词。`col`中的数字决定我们将该像素设置为哪种颜色。目前，我们只需通过将每个不发散的像素设置为黑色，来在屏幕上绘制曼德博集合。否则，我们将使矩形变为白色。运行这段代码，你应该会看到著名的曼德博集合，像[图
    7-8](ch07.xhtml#ch07fig8)中那样。'
- en: '![image](../images/f138-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f138-01.jpg)'
- en: '*Figure 7-8: The famous Mandelbrot set*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：著名的曼德博集合*'
- en: 'Isn’t it amazing? And it’s definitely unexpected: just by squaring and adding
    complex numbers, and coloring the pixels according to how large the numbers get,
    we’ve drawn an infinitely complicated design that could never have been imagined
    without a computer! You can zoom in on specific spots in the design by changing
    the range of `x` and `y`, like in [Listing 7-6](ch07.xhtml#ch07list6).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不觉得这很神奇吗？而且绝对是出乎意料的：仅通过对复数进行平方并相加，再根据数字的大小给像素上色，我们就绘制出了一个复杂到无穷的图案，没有计算机，这种设计是无法想象的！你可以通过改变`x`和`y`的范围来放大图案中的特定区域，像在[清单
    7-6](ch07.xhtml#ch07list6)中一样。
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 7-6: Changing the range of values to zoom in on the Mandelbrot set*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-6：改变值的范围以放大曼德布罗集合*'
- en: Now the output should look like [Figure 7-9](ch07.xhtml#ch07fig9).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出应该类似于[图 7-9](ch07.xhtml#ch07fig9)。
- en: '![image](../images/f139-01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f139-01.jpg)'
- en: '*Figure 7-9: Zooming in on the Mandelbrot set!*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：放大曼德布罗集合！*'
- en: I highly recommend that you investigate videos people have posted on the internet
    of zooming in on the Mandelbrot set.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐你查看网上一些人发布的关于放大曼德布罗集合的视频。
- en: ADDING COLOR TO THE MANDELBROT SET
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为曼德布罗集合添加颜色
- en: 'Now let’s add some color to your Mandelbrot design. Let Processing know you’re
    using the HSB (Hue, Saturation, Brightness) scale, not the RGB (Red, Green, Blue)
    scale, by adding the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为你的曼德布罗设计添加一些颜色。通过添加以下代码，告诉Processing你使用的是HSB（色调、饱和度、亮度）色标，而不是RGB（红色、绿色、蓝色）色标：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then color the rectangles according to the value returned by the `mandelbrot()`
    function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后根据`mandelbrot()`函数返回的值为矩形上色：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `fill` line, we multiply the `col` variable (the number of iterations
    it takes the complex number to diverge) by 3 and make that the H (hue) component
    of the HSB color mode. Run this code, and you should see a nicely colored Mandelbrot
    set like in [Figure 7-10](ch07.xhtml#ch07fig10).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fill`行中，我们将`col`变量（复数发散所需的迭代次数）乘以3，并将其作为HSB颜色模式中的H（色调）组件。运行这段代码，你应该会看到一个漂亮的着色曼德布罗集合，就像在[图
    7-10](ch07.xhtml#ch07fig10)中看到的那样。
- en: '![image](../images/f140-01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f140-01.jpg)'
- en: '*Figure 7-10: Using divergence values to color the Mandelbrot set*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：使用发散值为曼德布罗集合着色*'
- en: 'You can see the points that diverge every step, from the dark orange circle
    to lighter orange ovals that become the black Mandelbrot set. You can experiment
    with other colors too. For example, change the fill line to the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到每一步发散的点，从深橙色的圆圈到变成黑色曼德布罗集合的浅橙色椭圆。你也可以试验其他颜色。例如，将填充行更改为以下内容：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run this update, and you’ll see more blue in the picture, as shown in [Figure
    7-11](ch07.xhtml#ch07fig11).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此更新，你会看到图像中更多的蓝色，正如[图 7-11](ch07.xhtml#ch07fig11)所示。
- en: '![image](../images/f140-02.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f140-02.jpg)'
- en: '*[Figure 7-11](ch07.xhtml#ch07fig11): Experimenting with different colors in
    the Mandelbrot set*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图 7-11](ch07.xhtml#ch07fig11)：在曼德布罗集合中试验不同的颜色*'
- en: Next, we’ll explore a related design called the Julia set, which can change
    its appearance depending on the inputs we give it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索一个相关的设计，叫做朱莉亚集合，它的外观可以根据我们输入的不同而变化。
- en: CREATING THE JULIA SET
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建朱莉亚集合
- en: In the Mandelbrot set, to determine the color of each point, we started with
    the point as a complex number z and then repeatedly squared the value and added
    the original number z. The Julia set is constructed just like the Mandelbrot set,
    but after squaring the complex number, instead of adding the original complex
    number of that point, we keep adding a constant complex number, *c*, which has
    the same value for all points. By starting with different values for *c*, we can
    create lots of different Julia sets.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在曼德布罗集合中，为了确定每个点的颜色，我们从点作为复数z开始，然后反复对其平方并加上原始数字z。朱莉亚集合的构造方式与曼德布罗集合相同，但在对复数进行平方之后，我们并不是加上该点的原始复数，而是不断加上一个常数复数*c*，该常数对所有点保持相同。通过为*c*选择不同的值，我们可以创建许多不同的朱莉亚集合。
- en: WRITING THE JULIA() FUNCTION
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写`JULIA()`函数
- en: The Wikipedia page for the Julia set gives a bunch of examples of beautiful
    Julia sets and the complex numbers to use to create them. Let’s try to create
    one using *c* = –0.8 + 0.156*i*. We can easily modify our `mandelbrot()` function
    to be a `julia()` function. Save your *mandelbrot.pyde* sketch as *julia.pyde*
    and change the code for the `mandelbrot()` function so it looks like [Listing
    7-7](ch07.xhtml#ch07list7).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科页面上列出了许多美丽的 Julia 集合示例，以及用于创造这些集合的复数。让我们尝试使用 *c* = –0.8 + 0.156*i* 来创建一个。我们可以轻松地将
    `mandelbrot()` 函数修改为 `julia()` 函数。将你的 *mandelbrot.pyde* 草图保存为 *julia.pyde*，并更改
    `mandelbrot()` 函数的代码，使其看起来像[清单 7-7](ch07.xhtml#ch07list7)。
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 7-7: Writing the `julia()` function*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-7：为 Julia 集合编写 `julia()` 函数*'
- en: It’s pretty much the same as the Mandelbrot function. The only line of code
    that changed is ➊, where `z` is changed to `c`. The complex number `c` will be
    different from `z`, so we’ll have to pass that to the `julia()` function in `draw()`,
    as shown in [Listing 7-8](ch07.xhtml#ch07list8).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它与曼德尔布罗特函数几乎相同。唯一改变的代码行是➊，其中 `z` 被改为 `c`。复数 `c` 会与 `z` 不同，因此我们需要将其传递给 `draw()`
    中的 `julia()` 函数，如[清单 7-8](ch07.xhtml#ch07list8)所示。
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 7-8: Writing the `draw()` function for the Julia set*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-8：为 Julia 集合编写 `draw()` 函数*'
- en: Everything is the same as in *mandelbrot.pyde* until we declare the complex
    number `c` ➊ we’ve chosen for this Julia set. Just below that we add `c` to the
    arguments in the call to the `julia()` function. When you run it, you get a design
    much different from the Mandelbrot set, as shown in [Figure 7-12](ch07.xhtml#ch07fig12).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们为这个 Julia 集合选择的复数 `c` ➊ 之外，其他与 *mandelbrot.pyde* 中的内容完全相同。紧接着，我们将 `c` 添加到调用
    `julia()` 函数时的参数中。当你运行时，你将得到一个与曼德尔布罗特集合大不相同的设计，如[图 7-12](ch07.xhtml#ch07fig12)所示。
- en: '![image](../images/f142-01.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f142-01.jpg)'
- en: '*Figure 7-12: The Julia set for* c *= –0.8 + 0.156* i'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：对应于* c *= –0.8 + 0.156* i 的 Julia 集合'
- en: The great thing about the Julia set is you can change the input `c` and get
    a different output. For example, if you change *c* to 0.4 + 0.6*i*, you should
    see something like [Figure 7-13](ch07.xhtml#ch07fig13).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 集合的精彩之处在于你可以改变输入的 `c` 值，从而得到不同的输出。例如，如果你将 *c* 改为 0.4 + 0.6*i*，你应该会看到类似于[图
    7-13](ch07.xhtml#ch07fig13)的图案。
- en: '![image](../images/f143-01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f143-01.jpg)'
- en: '*Figure 7-13: The Julia set for* c *= –0.4 + 0.6*i'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：对应于* c *= –0.4 + 0.6*i 的 Julia 集合'
- en: 'EXERCISE 7-1: DRAWING A JULIA SET'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7-1：绘制 Julia 集合
- en: Draw a Julia set with *c* = 0.285 + 0.01*i*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个 *c* = 0.285 + 0.01*i* 的 Julia 集合。
- en: SUMMARY
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how complex numbers get plotted on the complex
    coordinate plane and how they allow you to perform rotations—and you followed
    their logic down the rabbit hole, learning how to add and multiply them. You used
    what you learned to write the `mandelbrot()` and `julia()` functions to transform
    complex numbers into incredible art that never would have been possible without
    the creation of complex numbers and the invention of computers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了复数是如何在复数坐标平面上绘制的，以及它们如何让你执行旋转操作——并且你跟随它们的逻辑，深入学习了如何加法和乘法运算。你使用学到的知识编写了
    `mandelbrot()` 和 `julia()` 函数，将复数转化为不可思议的艺术作品，这些艺术作品如果没有复数的发明和计算机的出现，是无法实现的。
- en: As you’ve seen, these numbers are anything but imaginary! Hopefully, when you
    think of complex numbers now, they’ll remind you of the beautiful designs you
    can make with numbers and code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些数字一点也不虚幻！希望当你现在想到复数时，它们会让你想起那些你可以通过数字和代码创造出来的美丽设计。
