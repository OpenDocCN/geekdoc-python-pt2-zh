- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: COMPLEX NUMBERS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 复数
- en: '*Imaginary numbers are a fine and wonderful refuge of the divine spirit, almost
    an amphibian between being and non-being. —Gottfried Leibniz*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚数是神圣精神的一个美妙而精致的避难所，几乎是存在与非存在之间的两栖物种。—戈特弗里德·莱布尼茨*'
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: Numbers containing the square root of –1 have been given a bad name in math
    classes. We call the square root of –1 an *imaginary number*, or *i*. Calling
    something “imaginary” makes it seem like it doesn’t exist or like there’s no real
    purpose for it. But imaginary numbers *do* exist, and they have a lot of real-world
    applications in fields such as electromagnetism, for instance.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 包含平方根-1的数字在数学课堂上常常被冠上一个不太好的名字。我们称平方根-1为*虚数*，或者*i*。把某物称为“虚拟的”会让它看起来似乎不存在，或者没有实际用途。但虚数*确实*存在，并且在电磁学等领域中有很多实际应用。
- en: In this chapter, you get a taste of the kinds of beautiful art you can create
    using *complex numbers*, which are numbers that have both a real and imaginary
    part written in the form of *a* + *bi*, where *a* and *b* are real numbers and
    *i* is the imaginary number. Because a complex number holds two different bits
    of information, real and imaginary, you can use it to turn one-dimensional objects
    into two-dimensional ones. Using Python, manipulating these numbers becomes easier,
    and we can use them for some very magical purposes. In fact, we use complex numbers
    to explain behaviors of electrons and photons, and what we think of as natural,
    “normal” numbers are actually complex numbers whose imaginary parts equal zero!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将体验使用*复数*创造的美丽艺术作品。复数是既有实部又有虚部的数字，表示为 *a* + *bi*，其中 *a* 和 *b* 是实数，*i*
    是虚数。由于复数包含两种不同的信息——实部和虚部，你可以用它来将一维物体转变为二维物体。使用 Python 后，操作这些数字变得更加容易，我们可以将它们用于一些非常神奇的目的。实际上，我们用复数来解释电子和光子的行为，而我们认为的自然、“正常”的数字实际上是虚部为零的复数！
- en: We begin this chapter by reviewing how to plot complex numbers in the complex
    coordinate plane. You also learn how to express complex numbers as Python lists
    and then write functions to add and multiply them. Finally, you learn how to find
    the magnitude, or absolute value, of a complex number. Knowing how to manipulate
    complex numbers will come in handy when we write the programs for creating the
    Mandelbrot set and the Julia set later in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时，我们回顾了如何在复数坐标平面中绘制复数。你还将学习如何将复数表示为 Python 列表，然后编写函数来对它们进行加法和乘法运算。最后，你将学习如何求复数的模，或称绝对值。掌握复数的操作技巧对后续章节中编写创建曼德尔布罗集合和朱利亚集合的程序将大有帮助。
- en: THE COMPLEX COORDINATE SYSTEM
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂坐标系统
- en: As Frank Farris summed up in his brilliant and beautifully illustrated book
    *Creating Symmetry*, “Complex numbers . . . are simply a way to express the Cartesian
    ordered pair of real numbers, (*x, y*), compactly as a single number *z* = *x*
    + *iy*.” We all know the Cartesian coordinate system uses *x* to represent the
    horizontal axis and *y* to represent the vertical axis, but we never add or multiply
    those numbers; they just represent a location.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如弗兰克·法里斯在他精彩且精美插图的著作《创造对称》中总结的那样：“复杂数... 只是表达实数的笛卡尔有序对（*x, y*）的一种紧凑的方式，作为一个单一的数字
    *z* = *x* + *iy*。”我们都知道，笛卡尔坐标系使用 *x* 表示横轴，*y* 表示纵轴，但我们从不对这些数字进行加法或乘法操作；它们只是表示一个位置。
- en: In contrast, complex numbers not only can represent locations but they can also
    be operated on like any other numbers. It helps to look at complex numbers geometrically.
    Let’s change our coordinate system a little so that now the real numbers are on
    the horizontal axis and the imaginary numbers are on the vertical axis, as in
    [Figure 7-1](ch07.xhtml#ch07fig1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，复数不仅可以表示位置，还可以像其他数字一样进行运算。我们可以从几何角度来看待复数。让我们稍微调整一下坐标系统，使得实数位于横轴，虚数位于纵轴，如[图
    7-1](ch07.xhtml#ch07fig1)所示。
- en: '![image](../images/f128-01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f128-01.jpg)'
- en: '*Figure 7-1: The complex coordinate system*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：复杂坐标系统*'
- en: Here, you can see where *a* + *bi* and *a* – *bi* would be located on a complex
    coordinate system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 *a* + *bi* 和 *a* – *bi* 在复数坐标系统中的位置。
- en: '### ADDING COMPLEX NUMBERS'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '### 复数的加法'
- en: 'Adding and subtracting complex numbers are the same as with real numbers: you
    start at one number and take the number of steps represented by the other number.
    For example, to add the numbers 2 + 3*i* and 4 + *i*, you would simply add the
    real parts and the imaginary parts of the numbers separately to get 6 + 4*i*,
    as shown in [Figure 7-2](ch07.xhtml#ch07fig2).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 加减复数与加减实数是一样的：你从一个数开始，然后根据另一个数的大小进行步进。例如，要将复数 2 + 3*i* 和 4 + *i* 相加，你只需分别将实部和虚部相加，得到
    6 + 4*i*，如[图 7-2](ch07.xhtml#ch07fig2)所示。
- en: '![image](../images/f129-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f129-01.jpg)'
- en: '*Figure 7-2: Adding two complex numbers*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：加两个复数*'
- en: As you can see, we start at 4 + *i*. To add 2 + 3*i*, we move two units in the
    positive real direction and three units in the positive imaginary direction, and
    end up at 6 + 4*i*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们从 4 + *i* 开始。为了加上 2 + 3*i*，我们首先在实数轴上向正方向移动两步，再在虚数轴上向正方向移动三步，最终到达 6 +
    4*i*。
- en: Let’s write the function for adding two complex numbers using the code in [Listing
    7-1](ch07.xhtml#ch07list1). Open a new file in IDLE and name it *complex.py*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用[清单 7-1](ch07.xhtml#ch07list1)中的代码来编写一个加两个复数的函数。在 IDLE 中打开一个新文件并命名为 *complex.py*。
- en: 'def cAdd(a,b):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'def cAdd(a,b):'
- en: '''''''adds two complex numbers'''''''
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''将两个复数相加'''''''
- en: return [a[0]+b[0],a[1]+b[1]]
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: return [a[0]+b[0],a[1]+b[1]]
- en: '*Listing 7-1: The function for adding two complex numbers*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：两个复数相加的函数*'
- en: Here, we define the function called cAdd(), giving it two complex numbers in
    list form [x,y], which returns another list. The first term of the list, a[0]+b[0],
    is the sum of the first terms of the complex numbers (index 0) we provide. The
    second term, a[1]+b[1], is the sum of the second terms (index 1) of the two complex
    numbers. Save and run this program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 cAdd() 的函数，输入两个复数的列表形式 [x,y]，并返回另一个列表。列表的第一个元素 a[0]+b[0] 是我们提供的两个复数的第一项（索引
    0）的和。第二个元素 a[1]+b[1] 是两个复数的第二项（索引 1）的和。保存并运行这个程序。
- en: 'Now let’s test the program using the complex numbers u = 1 + 2i and v = 3 +
    4i. Plug them into our cAdd() function in the interactive shell, like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用复数 u = 1 + 2i 和 v = 3 + 4i 来测试程序。将它们输入到我们的 cAdd() 函数中，如下所示：
- en: '>>> u = [1,2]'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> u = [1,2]'
- en: '>>> v = [3,4]'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> v = [3,4]'
- en: '>>> cAdd(u,v)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> cAdd(u,v)'
- en: '[6, 4]'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[6, 4]'
- en: You should get 6 + 4*i*, which is the sum of the complex numbers 1 + 2*i* and
    3 + 4*i*. Adding complex numbers is just like taking steps in the x-direction
    and then in the y-direction, and we’ll see this function again when we want to
    create beautiful designs like the Mandelbrot set and the Julia set.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到 6 + 4*i*，这是复数 1 + 2*i* 和 3 + 4*i* 的和。加复数就像先在 x 轴方向上走一步，再在 y 轴方向上走一步，我们在创建像曼德尔布罗特集和朱莉亚集这样的美丽图形时会再次看到这个函数。
- en: MULTIPLYING A COMPLEX NUMBER BY I
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘以复数 I
- en: But adding complex numbers isn’t the most useful thing. Multiplying them is.
    For example, multiplying a complex number by *i* rotates the complex number around
    the origin by 90 degrees. In the complex coordinate system, multiplying a real
    number by –1 would rotate it 180 degrees around the origin, as shown in [Figure
    7-3](ch07.xhtml#ch07fig3).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但加复数并不是最有用的事情，乘复数才是。例如，将复数乘以 *i* 会将复数围绕原点旋转90度。在复数坐标系中，将实数乘以 -1 会围绕原点旋转180度，正如在[图
    7-3](ch07.xhtml#ch07fig3)中所示。
- en: '![image](../images/f130-01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f130-01.jpg)'
- en: '*Figure 7-3: Multiplying a number by –1 as a 180-degree rotation*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：将一个数乘以 -1 作为180度旋转*'
- en: As you can see, 1 times –1 equals –1, which rotates 1 over to the other side
    of zero.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，1 乘以 -1 等于 -1，这会将 1 旋转到零的另一侧。
- en: Because multiplying a complex number by –1 is the same as a 180 degree rotation,
    the square root of –1 would represent a 90 degree rotation, as shown in [Figure
    7-4](ch07.xhtml#ch07fig4).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因为将复数乘以 -1 相当于进行180度旋转，所以 -1 的平方根表示的是90度旋转，正如在[图 7-4](ch07.xhtml#ch07fig4)中所示。
- en: '![image](../images/f130-02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f130-02.jpg)'
- en: '*Figure 7-4: Multiplying a number by* i *as a 90-degree rotation*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：将一个数乘以* i *作为90度旋转*'
- en: This means that *i* represents the square root of –1, the number that rotates
    us halfway to –1 when we multiply it by 1\. Multiplying the result (*i*) by *i*
    again causes us to rotate 90 degrees more, and we end up with –1\. This confirms
    the definition of the square root because we are able to get to the negative value
    of a number by multiplying it by the same number (*i*) twice.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 *i* 代表 –1 的平方根，这个数字当我们将它与 1 相乘时会将我们旋转到 –1 的一半位置。再次将结果（*i*）与 *i* 相乘会导致我们再旋转
    90 度，最终得到 –1。这确认了平方根的定义，因为我们能够通过将一个数字与相同的数字（*i*）相乘两次，得到该数字的负值。
- en: MULTIPLYING TWO COMPLEX NUMBERS
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘法两个复数
- en: 'Let’s see what happens when we multiply two complex numbers. Just like you
    would multiply two binomial expressions, you can multiply two complex numbers
    algebraically using the FOIL method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们将两个复数相乘时会发生什么。就像你乘法两个二项式一样，你可以使用 FOIL 方法代数地乘法两个复数：
- en: '![image](../images/e131-01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e131-01.jpg)'
- en: To make this easier, let’s translate this process into a cMult() function, as
    shown in [Listing 7-2](ch07.xhtml#ch07list2).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个过程，让我们将其转化为一个 cMult() 函数，如[列表 7-2](ch07.xhtml#ch07list2)所示。
- en: 'def cMult(u,v):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 'def cMult(u,v):'
- en: '''''''Returns the product of two complex numbers'''''''
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''返回两个复数的乘积'''''''
- en: return [u[0]*v[0]-u[1]*v[1],u[1]*v[0]+u[0]*v[1]]
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: return [u[0]*v[0]-u[1]*v[1],u[1]*v[0]+u[0]*v[1]]
- en: '*Listing 7-2: Writing the function for multiplying two complex numbers*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-2: 编写两个复数相乘的函数*'
- en: 'To test the cMult() function, try multiplying u = 1 + 2*i* by v = 3 + 4*i*.
    Enter the following in the interactive shell:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 cMult() 函数，尝试将 u = 1 + 2*i* 和 v = 3 + 4*i* 相乘。在交互式命令行中输入以下内容：
- en: '>>> u = [1,2]'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> u = [1,2]'
- en: '>>> v = [3,4]'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> v = [3,4]'
- en: '>>> cMult(u,v)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> cMult(u,v)'
- en: '[-5, 10]'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[-5, 10]'
- en: As you can see, the product is –5 + 10*i*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，乘积是 –5 + 10*i*。
- en: 'Recall from the previous section that multiplying a complex number by *i* is
    the same as performing a 90 degree rotation about the origin of the complex coordinate
    system. Let’s try it now with v = 3 + 4*i*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一节提到的，将复数乘以 *i* 就相当于围绕复数坐标系统的原点进行 90 度的旋转。现在，让我们用 v = 3 + 4*i* 来试试：
- en: '>>> cMult([3,4],[0,1])'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> cMult([3,4],[0,1])'
- en: '[-4, 3]'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[-4, 3]'
- en: The result is –4 + 3*i*. When we graph 3 + 4*i* and –4 + 3*i*, you should see
    something like what’s shown in [Figure 7-5](ch07.xhtml#ch07fig5).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 –4 + 3*i*。当我们将 3 + 4*i* 和 –4 + 3*i* 绘制在图表上时，你应该看到类似[图 7-5](ch07.xhtml#ch07fig5)所示的样子。
- en: '![image](../images/f132-01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f132-01.jpg)'
- en: '*Figure 7-5: Rotating a complex number 90 degrees by multiplying by* i'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5: 通过乘以* i 将复数旋转 90 度'
- en: As you can see, –4 + 3*i* is 90 degrees rotation from 3 + 4*i*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，–4 + 3*i* 是 3 + 4*i* 旋转了 90 度的结果。
- en: Now that you know how to add and multiply complex numbers, let’s go over how
    to find the magnitude of a complex number, which you’ll use to create the Mandelbrot
    set and Julia set.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何加法和乘法复数，让我们来看看如何求复数的模长，这将用于创建曼德尔布罗特集和朱莉亚集。
- en: WRITING THE MAGNITUDE() FUNCTION
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 magnitude() 函数
- en: 'The *magnitude*, or *absolute value*, of a complex number is how far the complex
    number is away from the origin on the complex coordinate plane. Now let’s create
    a magnitude function using the Pythagorean theorem. Return to *complex.py* and
    make sure to import the square root function from Python’s math module at the
    top of the file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的 *模*，或 *绝对值*，是复数在复数坐标平面上离原点的距离。现在，让我们使用勾股定理创建一个模长函数。返回 *complex.py* 文件，并确保在文件顶部导入
    Python 数学模块中的平方根函数：
- en: from math import sqrt
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: from math import sqrt
- en: 'The magnitude() function is just the Pythagorean theorem:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: magnitude() 函数就是勾股定理：
- en: 'def magnitude(z):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'def magnitude(z):'
- en: return sqrt(z[0]**2 + z[1]**2)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: return sqrt(z[0]**2 + z[1]**2)
- en: 'Let’s find the magnitude of the complex number 2 + i:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出复数 2 + i 的模长：
- en: '>>> magnitude([2,1])'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> magnitude([2,1])'
- en: '2.23606797749979'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '2.23606797749979'
- en: Now you’re ready to write a Python program that colors the pixels on the display
    window according to how large the complex numbers get. The unexpected behavior
    of complex numbers will result in an infinitely complicated design that’s impossible
    to replicate without a computer!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好编写一个 Python 程序，根据复数的大小为显示窗口上的像素着色。复数的意外行为将导致一个无限复杂的设计，这在没有计算机的情况下是无法复制的！
- en: CREATING THE MANDELBROT SET
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建曼德尔布罗特集
- en: To create the Mandelbrot set, we’re going to represent each pixel on our display
    window as a complex number, *z*, then repeatedly square the value, and add the
    original number *z*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建曼德尔布罗特集，我们将把显示窗口上的每个像素表示为一个复数 *z*，然后重复对其平方，并加上原始的复数 *z*。
- en: '![image](../images/e132-01.jpg) Then, we’re going to do the same to the output,
    again and again. If the number keeps getting larger, we’ll color the pixel corresponding
    to the original complex number according to how many iterations it takes for its
    magnitude to get bigger than a certain number, like 2\. If the number keeps getting
    smaller, we’ll give it a different color.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](../images/e132-01.jpg) 然后，我们将对输出进行相同的操作，一遍又一遍。如果数字不断增大，我们将根据其幅度变大超过某个特定数值（如
    2）所需的迭代次数来为对应的原始复数像素上色。如果数字不断变小，我们将为其赋予不同的颜色。'
- en: You already know that multiplying a number by a number larger than 1 makes the
    original number larger. A number multiplied by 1 stays the same, and multiplying
    by a number smaller than 1 makes the original number smaller. Complex numbers
    follow a similar pattern, which you can represent on the complex plane as shown
    in [Figure 7-6](ch07.xhtml#ch07fig6).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道，乘以大于 1 的数会使原始数变大，乘以 1 的数保持不变，而乘以小于 1 的数会使原始数变小。复数遵循类似的规律，你可以在复平面上表示它们，如
    [图 7-6](ch07.xhtml#ch07fig6) 所示。
- en: '![image](../images/f133-01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f133-01.jpg)'
- en: '*Figure 7-6: Visualizing what happens when you multiply complex numbers*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：可视化当你乘以复数时发生的情况*'
- en: If we were only multiplying complex numbers, the Mandelbrot set would look like
    [Figure 7-6](ch07.xhtml#ch07fig6), a circle. But not only is the complex number
    squared, a number is added afterward. This will change the circle into an infinitely
    complicated and surprisingly beautiful figure. But before we can do that, we need
    to operate on every point on the grid!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是在进行复数相乘，曼德尔布罗特集合将看起来像 [图 7-6](ch07.xhtml#ch07fig6) 中的一个圆。然而，不仅仅是复数被平方，之后还加了一个数。这将把圆形变成一个无限复杂且惊人美丽的图形。但在我们做这些之前，我们需要对网格上的每个点进行操作！
- en: Depending on the result of the operation, some will get smaller and *converge*
    to zero. Others will get bigger and *diverge*. Getting close to a number in math
    terms is called *converging*. Getting too big in math terms is called *diverging*.
    For our purposes, we’ll color every pixel on the grid according to how many iterations
    it takes it to get too big and fly off the grid. The formula we plug the number
    into is similar to our cMult() function from [Listing 7-2](ch07.xhtml#ch07list2),
    with an extra step. We square the number, add the original complex number to the
    square, and then repeat that process until it diverges. If the magnitude of the
    squared complex number gets larger than 2, it means it has diverged (we can pick
    any number we want to be the maximum). If it never gets bigger than 2, we’ll leave
    it black.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作的结果，有些会变小并*收敛*到零。其他的则会变大并*发散*。在数学中，接近某个数被称为*收敛*；而变得过大被称为*发散*。为了我们的目的，我们将根据每个像素的迭代次数为网格上的每个像素着色，直到它变得过大并飞出网格。我们将数字代入的公式类似于
    [清单 7-2](ch07.xhtml#ch07list2) 中的 cMult() 函数，只是多了一个步骤。我们先平方该数，再将原始复数加到平方上，然后重复这个过程，直到它发散。如果平方后的复数幅度大于
    2，就意味着它已经发散了（我们可以选择任何一个数字作为最大值）。如果它从未超过 2，我们就将其保持为黑色。
- en: 'For example, let’s try the Mandelbrot set operation manually using the complex
    number *z* = 0.25 + 1.5*i*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们手动尝试使用复数 *z* = 0.25 + 1.5*i* 进行曼德尔布罗特集合的操作：
- en: '>>> z = [0.25,1.5]'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z = [0.25,1.5]'
- en: 'We square z by multiplying it by itself and saving the result to the variable
    z2:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 z 自乘并将结果保存到变量 z2 来对 z 进行平方：
- en: '>>> z2 = cMult(z,z)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z2 = cMult(z,z)'
- en: '>>> z2'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z2'
- en: '[-2.1875, 0.75]'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[-2.1875, 0.75]'
- en: 'Then we add z2 and z using the cAdd() function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 cAdd() 函数将 z2 和 z 相加：
- en: '>>> cAdd(z2,z)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> cAdd(z2,z)'
- en: '[-1.9375, 2.25]'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[-1.9375, 2.25]'
- en: 'We have a function we can use to test if this complex number is more than two
    units away from the origin using the Pythagorean theorem. Let’s use our magnitude()
    function from earlier to check if the magnitude of the complex number we got is
    greater than 2:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个函数可以用来测试这个复数是否超出原点两单位远，利用勾股定理。让我们使用之前的 magnitude() 函数来检查我们得到的复数的幅度是否大于
    2：
- en: '>>> magnitude([-1.9375,2.25])'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> magnitude([-1.9375,2.25])'
- en: '2.969243380054926'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '2.969243380054926'
- en: 'We set the rule as follows: “If a number gets more than two units away from
    the origin, it diverges.” Therefore, the complex number *z* = 0.25 + 1.5*i* diverges
    after only 1 iteration!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设定规则如下：“如果一个数离原点超过两单位，它就会发散。”因此，复数 *z* = 0.25 + 1.5*i* 在仅仅 1 次迭代后就发散了！
- en: 'This time, let’s try with *z* = 0.25 + 0.75*i*, as shown next:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，让我们尝试 *z* = 0.25 + 0.75*i*，如下所示：
- en: '>>> z = [0.25,0.75]'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z = [0.25,0.75]'
- en: '>>> z2 = cMult(z,z)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z2 = cMult(z,z)'
- en: '>>> z3 = cAdd(z2,z)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z3 = cAdd(z2,z)'
- en: '>>> magnitude(z3)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> magnitude(z3)'
- en: '1.1524430571616109'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '1.1524430571616109'
- en: 'Here, we repeated the same process as before, except this time we need to add
    z2 and z again, saving it as z3. It’s still within two units of the origin, so
    let’s replace z with this new value and put it back through the process again.
    First, we create a new variable, z1, that we can use to square the original z:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重复了之前的过程，只不过这次我们需要将 z2 和 z 相加，保存为 z3。它仍然在原点的两单位范围内，所以我们将 z 替换为这个新值，并再次执行该过程。首先，我们创建一个新变量
    z1，用于平方原始的 z：
- en: '>>> z1 = z'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z1 = z'
- en: 'Let’s repeat the process using the newest value of our complex number, z3.
    We’ll square it, add z1, and find the magnitude:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用复数 z3 的最新值重复这个过程。我们将它平方，加入 z1，然后找出大小：
- en: '>>> z2 = cMult(z3,z3)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z2 = cMult(z3,z3)'
- en: '>>> z3 = cAdd(z2,z1)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z3 = cAdd(z2,z1)'
- en: '>>> magnitude(z3)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> magnitude(z3)'
- en: '0.971392565148097'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '0.971392565148097'
- en: Because 0.97 is smaller than 1.152, we might guess that the result is getting
    smaller and therefore doesn’t look like it’s going to diverge, but we’ve only
    repeated the process twice. Doing this by hand is laborious! Let’s automate the
    steps so that we can repeat the process quickly and easily. We’ll use the squaring,
    adding, and finding the magnitude functions to write a function called mandelbrot()
    that automates the checking process so that we can visually separate the diverging
    numbers from the converging ones. What design do you think it’ll make? A circle?
    An ellipse? Let’s find out!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 0.97 小于 1.152，我们可以猜测结果正在变小，因此看起来似乎不会发散，但我们仅仅重复了两次这个过程。手动做这个过程非常费力！让我们自动化这些步骤，这样我们就能快速且轻松地重复这个过程。我们将使用平方、加法和大小函数来编写一个名为
    mandelbrot() 的函数，自动化检查过程，以便我们可以直观地将发散的数字与收敛的数字区分开来。你觉得它会形成什么样的图形？一个圆？一个椭圆？让我们来看看吧！
- en: WRITING THE MANDELBROT() FUNCTION
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 MANDELBROT() 函数
- en: Let’s open a Processing sketch and call it *mandelbrot.pyde*. The Mandelbrot
    set we’re trying to re-create here is named after the mathematician Benoit Mandelbrot,
    who first explored this process using computers in the 1970s. We’ll repeat the
    squaring and adding process a maximum number of times, or until the number diverges,
    as shown in [Listing 7-3](ch07.xhtml#ch07list3).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个 Processing 草图，并命名为 *mandelbrot.pyde*。我们在这里尝试重建的曼德尔布罗集（Mandelbrot set）是以数学家
    Benoit Mandelbrot 的名字命名的，他在 1970 年代首次使用计算机探索了这个过程。我们将重复平方和加法过程，最多迭代 num 次，或者直到数字发散，如
    [清单 7-3](ch07.xhtml#ch07list3) 所示。
- en: 'def mandelbrot(z,num):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'def mandelbrot(z,num):'
- en: '''''''runs the process num times'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''运行过程 num 次'
- en: and returns the diverge count '''
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回发散次数 '''
- en: ➊ count=0
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ count=0
- en: '#define z1 as z'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '#将 z1 定义为 z'
- en: z1=z
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: z1=z
- en: '#iterate num times'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '#迭代 num 次'
- en: '➋ while count <= num:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 当 count <= num 时：
- en: '#check for divergence'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '#检查发散'
- en: 'if magnitude(z1) > 2.0:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 magnitude(z1) > 2.0:'
- en: '#return the step it diverged on'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#返回发散的步骤'
- en: return count
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: return count
- en: '#iterate z'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#迭代 z'
- en: ➌ z1=cAdd(cMult(z1,z1),z)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ z1=cAdd(cMult(z1,z1),z)
- en: count+=1
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: count+=1
- en: '#if z hasn''t diverged by the end'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '#如果 z 在结束时没有发散'
- en: return num
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: return num
- en: '*Listing 7-3: Writing the mandelbrot() function to check how many steps a complex
    number takes to diverge*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-3：编写 mandelbrot() 函数来检查复数发散需要多少步骤*'
- en: The mandelbrot() function takes a complex number, z, and a number of iterations
    as parameters. It returns the number of times it took for z to diverge, and if
    it never diverges, it returns num (at the end of the function). We create a count
    variable ➊ to keep track of the iterations, and we create a new complex number,
    z1, that gets squared and so on without changing z.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: mandelbrot() 函数以复数 z 和迭代次数 num 作为参数。它返回 z 发散所需的次数，如果从不发散，则返回 num（在函数结束时）。我们创建了一个
    count 变量 ➊ 来跟踪迭代次数，并创建了一个新的复数 z1，它被平方，依此类推，但不改变 z。
- en: We start a loop to repeat the process while the count variable is less than num
    ➋. Inside the loop we check the magnitude of z1 to see whether z1 has diverged,
    and if it has, we return count and stop the code. Otherwise, we square z1 and
    add z to it ➌, which is the definition of our operation on complex numbers. Finally,
    we increment the count variable by 1 and loop through the process again.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始一个循环，当 count 变量小于 num 时重复该过程 ➋。在循环内，我们检查 z1 的大小，以查看 z1 是否已经发散，如果发散则返回 count
    并停止代码。否则，我们将 z1 平方并加上 z ➌，这就是我们对复数操作的定义。最后，我们将 count 变量加 1，并再次执行循环。
- en: 'Using the *mandelbrot.pyde* program, we can plug in our complex number *z*
    = 0.25 + 0.75*i* and check the magnitude after every iteration. Here are the magnitudes
    after each loop:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *mandelbrot.pyde* 程序，我们可以将复数 *z* = 0.25 + 0.75*i* 插入，并检查每次迭代后的大小。以下是每次循环后的大小：
- en: '0.7905694150420949'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '0.7905694150420949'
- en: '1.1524430571616109'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '1.1524430571616109'
- en: '0.971392565148097'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '0.971392565148097'
- en: '1.1899160852817983'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '1.1899160852817983'
- en: '2.122862368187107'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '2.122862368187107'
- en: 'The first number is the magnitude of z = 0.25 + 0.75*i* before any iterations:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字是 z = 0.25 + 0.75*i* 经过任何迭代之前的幅度：
- en: '![image](../images/e136-01.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e136-01.jpg)'
- en: You can see that it diverges after four iterations because it gets bigger than
    two units away from the origin. [Figure 7-7](ch07.xhtml#ch07fig7) graphs each
    step so you can visualize them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它在经过四次迭代后发散，因为它离原点的距离超过了两个单位。[图 7-7](ch07.xhtml#ch07fig7) 绘制了每个步骤，你可以通过图形化来观察它们。
- en: '![image](../images/f136-01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f136-01.jpg)'
- en: '*Figure 7-7: Running the complex number 0.25 + 0.75* i *through the* mandelbrot()
    *function until it diverges*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：将复数 0.25 + 0.75*i* 通过 mandelbrot() 函数直到它发散*'
- en: The red circle has a radius of two units and represents the limit we put on
    the complex number diverging. When squaring and adding in the original value of
    z, we cause the locations of the numbers to rotate and translate and eventually
    to get further away from the origin than our rule allows.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 红色圆圈的半径为两个单位，表示我们设定的复数发散的限制。当对 z 的原始值进行平方和加法时，我们会导致数值的位置旋转和平移，并最终使其远离原点，超过我们的规则允许的范围。
- en: Let’s use some of the graphing tricks we learned in [Chapter 4](ch04.xhtml#ch04)
    to graph points and functions in the Processing display. Copy and paste all the
    complex number functions from *complex.py* (cAdd, cMult, and magnitude) to the
    bottom of *mandelbrot.pyde*. We’ll use Processing’s println() function to print
    to the console the number of steps it takes a point to diverge. Add the code in
    [Listing 7-4](ch07.xhtml#ch07list4) before the mandelbrot() code you wrote in
    [Listing 7-3](ch07.xhtml#ch07list3).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用在[第 4 章](ch04.xhtml#ch04)中学到的一些绘图技巧，在 Processing 显示器中绘制点和函数。将 *complex.py*
    中的所有复数函数（cAdd、cMult 和 magnitude）复制并粘贴到 *mandelbrot.pyde* 的底部。我们将使用 Processing
    的 println() 函数在控制台输出一个点发散所需的步骤数。在你在[清单 7-3](ch07.xhtml#ch07list3)中编写的 mandelbrot()
    代码之前，加入[清单 7-4](ch07.xhtml#ch07list4)中的代码。
- en: '*mandelbrot.pyde*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*mandelbrot.pyde*'
- en: '#range of x-values'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#x 值的范围'
- en: xmin = -2
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: xmin = -2
- en: xmax = 2
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: xmax = 2
- en: '#range of y-values'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#y 值的范围'
- en: ymin = -2
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ymin = -2
- en: ymax = 2
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ymax = 2
- en: '#calculate the range'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '#计算范围'
- en: rangex = xmax - xmin
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: rangex = xmax - xmin
- en: rangey = ymax - ymin
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: rangey = ymax - ymin
- en: 'def setup():'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global xscl, yscl
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: global xscl, yscl
- en: size(600,600)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: noStroke()
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: noStroke()
- en: xscl = float(rangex)/width
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: xscl = float(rangex)/width
- en: yscl = float(rangey)/height
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: yscl = float(rangey)/height
- en: 'def draw():'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: z = [0.25,0.75]
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: z = [0.25,0.75]
- en: println(mandelbrot(z,10))
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: println(mandelbrot(z,10))
- en: '*Listing 7-4: The beginning of the Mandelbrot code*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-4：Mandelbrot 代码的开头*'
- en: We calculate the range of real values (x) and imaginary values (y) at the top
    of the program. Inside setup(), we calculate the scale factors (xscl and yscl)
    we need to multiply the pixels by (in this case, 0 to 600) in order to get the complex
    numbers (in this case, between –2 and 2). In the draw() function we define our
    complex number z, and then we feed it into the mandelbrot() function and print
    out what we get. Nothing will appear on the screen yet, but in the console, you’ll
    see the number 4 printed out. Now we’ll go through every pixel on the screen and
    put their location into the mandelbrot() function and display the results.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序的顶部计算实数值（x）和虚数值（y）的范围。在 setup() 中，我们计算所需的缩放因子（xscl 和 yscl），这些因子需要乘以像素值（在此情况下为
    0 到 600），以便获得复数（在此情况下为 -2 到 2）。在 draw() 函数中，我们定义复数 z，然后将其传入 mandelbrot() 函数，并打印出我们得到的结果。此时屏幕上不会显示任何内容，但在控制台中你将看到数字
    4 被打印出来。现在我们将遍历屏幕上的每个像素，并将它们的位置传入 mandelbrot() 函数，显示出结果。
- en: Let’s return to our mandelbrot() function in the *mandelbrot.pyde* program.
    Repeating the multiplication and addition operations on a pixel’s location returns
    a number, and if the number never diverges, we color the pixel black. The entire
    draw() function is shown in [Listing 7-5](ch07.xhtml#ch07list5).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 *mandelbrot.pyde* 程序中的 mandelbrot() 函数。对一个像素的位置重复进行乘法和加法操作会返回一个数值，如果这个数值从未发散，我们就将像素涂成黑色。整个
    draw() 函数的代码如[清单 7-5](ch07.xhtml#ch07list5)所示。
- en: '*mandelbrot.pyde*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*mandelbrot.pyde*'
- en: 'def draw():'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: '#origin in center:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '#原点位于中心：'
- en: translate(width/2,height/2)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: '#go over all x''s and y''s on the grid'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '#遍历网格上的所有 x 和 y'
- en: '➊ for x in range(width):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ for x in range(width):'
- en: 'for y in range(height):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'for y in range(height):'
- en: ➋ z = [(xmin + x * xscl) ,
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ z = [(xmin + x * xscl) ,
- en: (ymin + y * yscl) ]
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (ymin + y * yscl) ]
- en: '#put it into the mandelbrot function'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '#将其传入 mandelbrot 函数'
- en: ➌ col=mandelbrot(z,100)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ col=mandelbrot(z,100)
- en: '#if mandelbrot returns 0'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '#如果 mandelbrot 返回 0'
- en: 'if col == 100:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'if col == 100:'
- en: 'fill(0) #make the rectangle black'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(0) #将矩形填充为黑色'
- en: 'else:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: 'fill(255) #make the rectangle white'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(255) #将矩形设置为白色'
- en: '#draw a tiny rectangle'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#绘制一个小矩形'
- en: rect(x,y,1,1)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: rect(x,y,1,1)
- en: '*Listing 7-5: Looping over all the pixels in the display window*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-5：遍历显示窗口中的所有像素*'
- en: Going over all the pixels requires a nested loop for x and y ➊. We declare complex
    number z to be x + *i*y ➋. Calculating the complex number z from the window coordinates
    is a little tricky. We start at the xmin value, for instance, and add the number
    of steps we’re taking multiplied by the scale factor. We’re not going between
    0 and 600, which is the size of the display window in pixels; we’re just going
    between –2 and 2\. We run that through the mandelbrot() function ➌.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历所有像素需要对x和y进行嵌套循环 ➊。我们声明复数z为x + *i*y ➋。根据窗口坐标计算复数z有点棘手。例如，我们从xmin值开始，然后加上我们采取的步数乘以缩放因子。我们不是在0和600之间移动，600是显示窗口的像素大小；我们只是介于–2和2之间。然后我们将其传递给mandelbrot()函数
    ➌。
- en: The mandelbrot() function squares and adds the complex number 100 times and
    returns the number of iterations it took for the number to diverge. This number
    is saved to a variable called col since color is already a keyword in Processing.
    The number in col determines what color we make that pixel. For now, let’s just
    get a Mandelbrot set on the screen by making every pixel that never diverges black.
    Otherwise, we’ll make the rectangle white. Run this code and you should see the
    famous Mandelbrot set, like in [Figure 7-8](ch07.xhtml#ch07fig8).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: mandelbrot()函数对复数进行100次平方和相加，并返回复数发散所需的迭代次数。这个数字会保存在名为col的变量中，因为在Processing中“color”已是一个关键字。col中的数字决定了我们为该像素设置的颜色。目前，我们先通过将所有没有发散的像素设置为黑色来在屏幕上显示曼德尔布罗特集合。否则，我们将矩形设置为白色。运行此代码后，你应该能看到著名的曼德尔布罗特集合，像[图
    7-8](ch07.xhtml#ch07fig8)那样。
- en: '![image](../images/f138-01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f138-01.jpg)'
- en: '*Figure 7-8: The famous Mandelbrot set*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：著名的曼德尔布罗特集合*'
- en: 'Isn’t it amazing? And it’s definitely unexpected: just by squaring and adding
    complex numbers, and coloring the pixels according to how large the numbers get,
    we’ve drawn an infinitely complicated design that could never have been imagined
    without a computer! You can zoom in on specific spots in the design by changing
    the range of x and y, like in [Listing 7-6](ch07.xhtml#ch07list6).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 真不惊人吗？而且完全出乎意料：仅仅通过对复数进行平方和相加，并根据数字的增大程度为像素上色，我们就绘制出了一个无法想象的复杂图案，这个图案如果没有计算机是根本无法构思的！你可以通过更改x和y的范围来放大设计中的特定部分，就像在[清单
    7-6](ch07.xhtml#ch07list6)中那样。
- en: '#range of x-values'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '#x值范围'
- en: xmin = -0.25
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: xmin = -0.25
- en: xmax = 0.25
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: xmax = 0.25
- en: '#range of y-values'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#y值范围'
- en: ymin = -1
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ymin = -1
- en: ymax = -0.5
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ymax = -0.5
- en: '*Listing 7-6: Changing the range of values to zoom in on the Mandelbrot set*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-6：更改值范围以放大曼德尔布罗特集合*'
- en: Now the output should look like [Figure 7-9](ch07.xhtml#ch07fig9).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出应该像[图 7-9](ch07.xhtml#ch07fig9)那样显示。
- en: '![image](../images/f139-01.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f139-01.jpg)'
- en: '*Figure 7-9: Zooming in on the Mandelbrot set!*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：放大曼德尔布罗特集合！*'
- en: I highly recommend that you investigate videos people have posted on the internet
    of zooming in on the Mandelbrot set.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你查看一些人们在互联网上发布的放大曼德尔布罗特集合的视频。
- en: ADDING COLOR TO THE MANDELBROT SET
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向曼德尔布罗特集合添加颜色
- en: 'Now let’s add some color to your Mandelbrot design. Let Processing know you’re
    using the HSB (Hue, Saturation, Brightness) scale, not the RGB (Red, Green, Blue)
    scale, by adding the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为你的曼德尔布罗特设计添加一些颜色。通过添加以下代码，告诉Processing你使用的是HSB（色相、饱和度、亮度）色彩模式，而不是RGB（红、绿、蓝）色彩模式：
- en: 'def setup():'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: colorMode(HSB)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: colorMode(HSB)
- en: noStroke()
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: noStroke()
- en: 'Then color the rectangles according to the value returned by the mandelbrot()
    function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后根据mandelbrot()函数返回的值为这些矩形上色：
- en: 'if col == 100:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'if col == 100:'
- en: fill(0)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: fill(0)
- en: 'else:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: fill(3*col,255,255)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: fill(3*col,255,255)
- en: '#draw a tiny rectangle'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '#绘制一个小矩形'
- en: rect(x*xscl,y*yscl,1,1)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: rect(x*xscl,y*yscl,1,1)
- en: In the fill line, we multiply the col variable (the number of iterations it takes
    the complex number to diverge) by 3 and make that the H (hue) component of the
    HSB color mode. Run this code, and you should see a nicely colored Mandelbrot
    set like in [Figure 7-10](ch07.xhtml#ch07fig10).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在fill行中，我们将col变量（复数发散所需的迭代次数）乘以3，并使其成为HSB色彩模式中的H（色相）分量。运行此代码后，你应该能看到像[图 7-10](ch07.xhtml#ch07fig10)那样的漂亮着色曼德尔布罗特集合。
- en: '![image](../images/f140-01.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f140-01.jpg)'
- en: '*Figure 7-10: Using divergence values to color the Mandelbrot set*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：使用发散值为曼德尔布罗特集合上色*'
- en: 'You can see the points that diverge every step, from the dark orange circle
    to lighter orange ovals that become the black Mandelbrot set. You can experiment
    with other colors too. For example, change the fill line to the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到每一步发散的点，从深橙色的圆圈到变成黑色 Mandelbrot 集合的浅橙色椭圆。你还可以尝试其他颜色。例如，修改填充行如下：
- en: fill(255-15*col,255,255)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: fill(255-15*col,255,255)
- en: Run this update, and you’ll see more blue in the picture, as shown in [Figure
    7-11](ch07.xhtml#ch07fig11).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个更新，你会看到图像中更多的蓝色，如 [图 7-11](ch07.xhtml#ch07fig11) 所示。
- en: '![image](../images/f140-02.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f140-02.jpg)'
- en: '*[Figure 7-11](ch07.xhtml#ch07fig11): Experimenting with different colors in
    the Mandelbrot set*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图 7-11](ch07.xhtml#ch07fig11)：在 Mandelbrot 集中实验不同的颜色*'
- en: Next, we’ll explore a related design called the Julia set, which can change
    its appearance depending on the inputs we give it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索一个相关的设计，称为 Julia 集，它可以根据我们给定的输入改变外观。
- en: CREATING THE JULIA SET
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 JULIA 集
- en: In the Mandelbrot set, to determine the color of each point, we started with
    the point as a complex number z and then repeatedly squared the value and added
    the original number z. The Julia set is constructed just like the Mandelbrot set,
    but after squaring the complex number, instead of adding the original complex
    number of that point, we keep adding a constant complex number, *c*, which has
    the same value for all points. By starting with different values for *c*, we can
    create lots of different Julia sets.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mandelbrot 集中，为了确定每个点的颜色，我们从一个复数点 z 开始，然后重复对其进行平方并加上原始的 z 值。Julia 集的构造方式与
    Mandelbrot 集相同，但在平方复数后，我们不是加上该点的原始复数，而是不断加上一个常数复数 *c*，该常数对所有点的值相同。通过为 *c* 设置不同的值，我们可以创建出许多不同的
    Julia 集。
- en: WRITING THE JULIA() FUNCTION
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写 JULIA() 函数
- en: The Wikipedia page for the Julia set gives a bunch of examples of beautiful
    Julia sets and the complex numbers to use to create them. Let’s try to create
    one using *c* = –0.8 + 0.156*i*. We can easily modify our mandelbrot() function
    to be a julia() function. Save your *mandelbrot.pyde* sketch as *julia.pyde* and
    change the code for the mandelbrot() function so it looks like [Listing 7-7](ch07.xhtml#ch07list7).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Wikipedia 上关于 Julia 集的页面提供了许多美丽 Julia 集的示例以及创建它们所需的复数。让我们尝试使用 *c* = –0.8 + 0.156*i*
    来创建一个。我们可以轻松地将 mandelbrot() 函数修改为 julia() 函数。将你的 *mandelbrot.pyde* 草图保存为 *julia.pyde*，并更改
    mandelbrot() 函数的代码，使其如下所示 [列表 7-7](ch07.xhtml#ch07list7)。
- en: '*julia.pyde*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*julia.pyde*'
- en: 'def julia(z,c,num):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'def julia(z,c,num):'
- en: '''''''runs the process num times'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''执行 num 次过程'
- en: and returns the diverge count'''
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回发散计数'''
- en: count = 0
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: count = 0
- en: '#define z1 as z'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '#定义 z1 为 z'
- en: z1 = z
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: z1 = z
- en: '#iterate num times'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '#迭代 num 次'
- en: 'while count <= num:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当 count <= num 时：
- en: '#check for divergence'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '#检查是否发散'
- en: 'if magnitude(z1) > 2.0:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 magnitude(z1) > 2.0:'
- en: '#return the step it diverged on'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '#返回它发散的步骤'
- en: return count
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 count
- en: '#iterate z'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '#迭代 z'
- en: ➊ z1 = cAdd(cMult(z1,z1),c)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ z1 = cAdd(cMult(z1,z1),c)
- en: count += 1
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: count += 1
- en: '*Listing 7-7: Writing the julia() function*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-7：编写 julia() 函数*'
- en: It’s pretty much the same as the Mandelbrot function. The only line of code
    that changed is ➊, where z is changed to c. The complex number c will be different
    from z, so we’ll have to pass that to the julia() function in draw(), as shown
    in [Listing 7-8](ch07.xhtml#ch07list8).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 Mandelbrot 函数几乎相同。唯一改变的代码行是 ➊，其中 z 改为了 c。复数 c 与 z 不同，因此我们需要将其传递给 draw() 中的
    julia() 函数，如 [列表 7-8](ch07.xhtml#ch07list8) 所示。
- en: 'def draw():'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 draw()：
- en: '#origin in center:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '#原点在中心：'
- en: translate(width/2,height/2)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: translate(width/2,height/2)
- en: '#go over all x''s and y''s on the grid'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '#遍历网格上的所有 x 和 y'
- en: x = xmin
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: x = xmin
- en: 'while x < xmax:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当 x < xmax 时：
- en: y = ymin
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: y = ymin
- en: 'while y < ymax:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当 y < ymax 时：
- en: z = [x,y]
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: z = [x,y]
- en: ➊ c = [-0.8,0.156]
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ c = [-0.8,0.156]
- en: '#put it into the julia program'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '#将其放入 julia 程序'
- en: col = julia(z,c,100)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: col = julia(z,c,100)
- en: '#if julia returns 100'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '#如果 julia 返回 100'
- en: 'if col == 100:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 col == 100:'
- en: fill(0)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: fill(0)
- en: 'else:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: '#map the color from 0 to 100'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '#将颜色映射从 0 到 100'
- en: '#to 0 to 255'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '#从 0 到 255'
- en: '#coll = map(col,0,100,0,300)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '#coll = map(col,0,100,0,300)'
- en: fill(3*col,255,255)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: fill(3*col,255,255)
- en: rect(x*xscl,y*yscl,1,1)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: rect(x*xscl,y*yscl,1,1)
- en: y += 0.01
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: y += 0.01
- en: x += 0.01
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: x += 0.01
- en: '*Listing 7-8: Writing the draw() function for the Julia set*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-8：编写 julia 集的 draw() 函数*'
- en: Everything is the same as in *mandelbrot.pyde* until we declare the complex
    number c ➊ we’ve chosen for this Julia set. Just below that we add c to the arguments
    in the call to the julia() function. When you run it, you get a design much different
    from the Mandelbrot set, as shown in [Figure 7-12](ch07.xhtml#ch07fig12).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一切与 *mandelbrot.pyde* 一样，直到我们声明为此 Julia 集选择的复数 c ➊。紧接着，我们在调用 `julia()` 函数时将
    c 添加到参数中。当你运行它时，你会看到一个与 Mandelbrot 集截然不同的设计，如 [图 7-12](ch07.xhtml#ch07fig12) 所示。
- en: '![image](../images/f142-01.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f142-01.jpg)'
- en: '*Figure 7-12: The Julia set for* c *= –0.8 + 0.156* i'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：* c *= –0.8 + 0.156*i 的 Julia 集'
- en: The great thing about the Julia set is you can change the input c and get a
    different output. For example, if you change *c* to 0.4 + 0.6*i*, you should see
    something like [Figure 7-13](ch07.xhtml#ch07fig13).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 集的伟大之处在于，你可以改变输入的 c 值，从而得到不同的输出。例如，如果你将 *c* 改为 0.4 + 0.6*i*，你应该能看到类似于
    [图 7-13](ch07.xhtml#ch07fig13) 的效果。
- en: '![image](../images/f143-01.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f143-01.jpg)'
- en: '*Figure 7-13: The Julia set for* c *= –0.4 + 0.6*i'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：* c *= –0.4 + 0.6*i 的 Julia 集'
- en: 'EXERCISE 7-1: DRAWING A JULIA SET'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7-1：绘制一个 Julia 集
- en: Draw a Julia set with *c* = 0.285 + 0.01*i*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个 *c* = 0.285 + 0.01*i* 的 Julia 集。
- en: SUMMARY
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how complex numbers get plotted on the complex
    coordinate plane and how they allow you to perform rotations—and you followed
    their logic down the rabbit hole, learning how to add and multiply them. You used
    what you learned to write the mandelbrot() and julia() functions to transform
    complex numbers into incredible art that never would have been possible without
    the creation of complex numbers and the invention of computers.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何在复数坐标平面上绘制复数，以及它们如何使你能够执行旋转——你跟随它们的逻辑进入了更深的领域，学习了如何对复数进行加法和乘法运算。你运用所学内容编写了
    `mandelbrot()` 和 `julia()` 函数，将复数转化为令人惊叹的艺术作品，这些作品在没有复数的创造和计算机发明之前是无法实现的。
- en: As you’ve seen, these numbers are anything but imaginary! Hopefully, when you
    think of complex numbers now, they’ll remind you of the beautiful designs you
    can make with numbers and code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些数一点也不“虚构”！希望现在，当你想到复数时，它们能让你想起你用数字和代码创造的美丽设计。
