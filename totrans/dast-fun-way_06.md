# 6

字典树与适应性数据结构

![](img/chapterart.png)

二叉搜索树虽然功能强大，但只是使用树形结构来更好组织数据的一种方式。我们可以通过根据特定搜索问题来优化树分割数据的方式，而不是依赖大小比较来划分数据集。例如，在本章中，我们解决了如何在树中存储和搜索字符串的问题。通过扩展二叉搜索树的通用分支方法，以捕捉数据中的额外结构，我们可以在字符串集合中高效地搜索目标字符串。

我们首先讨论如何将二叉搜索树直接应用于字符串数据，但其开销比其他数据类型更高。考虑到字符串的顺序特性，我们接着将调整我们的搜索树，以更高效地存储字符串。结果是一个分支结构，未来或许能激发出世界上最奢华的文件柜：字典树（发音为“try”）。

字典树是一种数据结构，在每一层上根据字符串的*单个*字符进行分支。这种拆分策略大大减少了每个节点比较的成本。通过这种视角，我们探讨了如何将各种算法和数据结构的基础概念适应于新的问题类型。

## 字符串的二叉搜索树

在考虑是否可以改进一个算法时，我们应该首先理解当前方法的局限性——否则就没有理由去构建一个更复杂的数据结构。因此，在深入探讨针对字符串的特定数据结构之前，我们将先了解在用二叉搜索树存储字符串时存在的不足之处。首先，让我们看看如何将二叉搜索树用于这种搜索。

### 树中的字符串

二叉搜索树不仅可以存储数字，还可以存储任何可排序的东西，从鞋子（按大小或气味排序）到僵尸电影（按票房收入或恐怖程度排序）再到食物项（按价格、辣度或未来 24 小时内导致呕吐的可能性排序）。二叉搜索树在这方面非常灵活。我们所需要的只是能够对项进行排序的能力。

为了在二叉搜索树中存储字符串，我们可以将元素按字母顺序排序。例如，图 6-1 中的每个二叉搜索树节点都是一个字符串，将其子树划分为字典中该字符串之前和之后的字符串。我们沿用了二叉搜索树中的大于和小于符号，X < Y 表示字符串 X 在字母表中排在字符串 Y 之前。

![该二叉搜索树的根节点是 Laugh。它的左子节点是 Feet，右子节点是 Rock。各种子树也按字母顺序组织。](img/f06001.png)

图 6-1：用单词构建的二叉搜索树

我们像搜索数字一样搜索二叉搜索树中的字符串。例如，在图 6-1 中查找字符串“LIGHT”，我们从根节点开始。然后，我们将目标值与节点的值进行比较，使用字母顺序，继续沿左分支或右分支前进：

1.  LIGHT > LAUGH：我们沿着右分支继续前进。

1.  LIGHT < ROCK：我们沿着左分支继续前进。

1.  LIGHT < MAIN：我们沿着左分支继续前进。

1.  LIGHT == LIGHT：我们已找到目标值，可以终止搜索。

在图 6-2 中，阴影区域的椭圆表示在搜索过程中探测到的 12 个节点中的 4 个。

![标记搜索字符串 LIGHT 路径的图示。搜索路径从 LAUGH 到 ROCK 再到 MAIN 最后到 LIGHT，包含这些字符串的节点已被灰色标出。](img/f06002.png)

图 6-2：在搜索二叉搜索树中的字符串“LIGHT”时的遍历路径

乍一看，二叉搜索树似乎提供了一种简单、高效的机制来搜索字符串数据——无需修改。如果我们的树是平衡的，那么搜索的最坏情况下的代价将与条目的数量的对数成比例。在图 6-2 中，我们能够将搜索范围限制为只检查 12 个节点中的 4 个。

然而，我们忘记了一个关键因素——每次比较的代价。如第一章所述，比较两个字符串比比较一对数字要昂贵。事实上，在最坏的情况下，字符串比较操作的代价与字符串的长度成比例。现在，我们的树搜索的代价不仅取决于字符串的数量，还取决于它们的长度，这意味着我们增加了一个新的复杂度维度。

为了解决这个问题，并实现比二叉搜索树更高的计算节省，我们必须考虑字符串数据结构的两个重要方面：字符串的顺序排列和涉及的字母或字符的有限数量。

### 字符串比较的代价

到目前为止，我们在搜索字符串时忽略了两个重要的信息。第一个是字符串比较的顺序性。为了确定字符串的字母顺序，我们从字符串的第一个字符开始，逐个字符进行比较，直到发现不同之处。这个不同决定了该字符串在搜索树中的相对顺序——其余的字符无关紧要。

在图 6-3 中的例子中，ZOMBIE 排在 ZOOM 之前，因为第三个位置的字符：M 排在 O 之前。我们不关心剩余字符 BIE 和 M 的关系，可以忽略它们。

![一张显示字符串 ZOOM 和 ZOMBIE 比较的图。前两个字符用等号标记，表示它们相同。第三个字符用大于号标记，表示 O 在 M 后面。最后的字符被灰色标出，表示它们被忽略。](img/f06003.png)

图 6-3：两个字符串的比较按字符逐个进行，直到找到第一个不匹配的字符对。

正如我们在第一章中所看到的，二叉搜索树中对字符串进行的逐个比较，天生比数字的比较更为昂贵。即使是比较 图 6-3 中的这两个相对较短的字符串，也需要进行三次独立的比较：Z 对 Z，O 对 O，以及 O 对 M。当我们比较更长的字符串时，比如我们最喜欢的电影台词，代价可能会变得相当显著。如果字符串有较高的重叠度，情况会更加严重。试想一个按照名字对我们的咖啡系列进行索引的二叉搜索树。如果我们插入几百个名字为“Jeremy’s Gourmet High Caffeine Experience”的咖啡，我们就需要比较大量的字符来决定“Jeremy’s Gourmet High Caffeine Experience: Medium Roast”应该排在“Jeremy’s Gourmet High Caffeine Experience: City Roast”之前还是之后。我们的二叉搜索树算法在每个节点都会支付这笔代价。

我们在努力提高搜索效率时，还没有考虑到的第二个关键信息是，在许多语言中，每个位置只能包含少量字母。英文单词只使用 26 个字母（忽略大小写）。即便我们包含数字和其他字符，实际中有效字符的集合仍然是有限的。这意味着在每个位置上，字符串可以继续的方式是有限的——即下一个字符的选择是有限的。正如我们将要看到的，这一见解使我们能够定义一个分区函数，从而在字符串的下一个字符上进行多重分割。

我们可以将这些见解结合起来，构建一个与现实世界中比较字符串的方式类似的数据结构。由此产生的数据结构——字典树，经过优化，能够考虑到字符串中的附加结构。

## 字典树

*字典树*（Tries）是基于树的结构，通过字符串的前缀将其划分为不同的分支。计算机科学家 René de la Briandais 提出了字典树的基本方法，旨在改善在内存访问较慢的计算机上进行文件搜索的效率，而计算机科学家兼物理学家 Edward Fredkin 则提出了这个名称。与每个节点将数据分成两个集合不同，我们根据目前的前缀将树进行分支（逐步比较）。此外，我们允许树在每个节点分裂成多于两个的分支（字符数限制）。事实上，对于英文单词，我们可以让树在每个节点分成 26 条分支——每条分支对应可能的下一个字母。因此，字典树中的每个节点都代表当前的前缀。

就像二叉搜索树一样，字典树从根节点开始，在这种情况下表示空前缀。然后，每个分支定义了字符串中的下一个字符。自然，这意味着每个节点可以有超过两个子节点，如图 6-4 所示。

![一个字典树节点，包含指向以 A、B、C 等字符开头的字符串子节点的指针。](img/f06004.png)

图 6-4：字典树节点在当前位置的每个可能字符上分支。

我们可以通过使用指针数组来实现每个字典树节点的分支，每个字符对应一个数组槽。在某些情况下，我们可能能够在数据结构中使用比数组更节省内存的表示方式。毕竟，即使是英语单词，大多数非平凡的前缀也会有明显少于 26 个有效选项来表示下一个字母。不过，为了简单起见，我们暂时会坚持使用数组实现。本章的讨论和示例实现也主要聚焦于英语单词（26 个字母和 26 个元素的子节点数组），尽管这些算法也适用于其他字符集。

可以将字典树的分支结构比作一个大型事件的注册表。当我们参加世界顶级的“计算机科学中的咖啡类比”会议时，我们会去注册桌领取个人化的信息包和免费的会议纪念品（希望是咖啡杯）。由于参与人数众多，组织者将信息包分成可管理的小组，以防止队伍绕着会议中心排队。与其通过一系列二元拆分（比如“你的姓氏是在 Smith 之前还是之后？”），组织者根据姓氏的首字母将参与者分成 26 条不同的队伍。这样，一下子，众多与会者就被缩小成 26 条更易管理的队伍。字典树就在每个节点上执行这种壮观的多路分支。

与二叉搜索树类似，我们不需要为树的空分支创建节点。图 6-5 展示了这种结构的一个例子，其中阴影字母代表字典树中的空分支。我们不会为这些分支创建子节点。使用与二叉搜索树相同的术语，我们将至少有一个子节点的节点称为*内部节点*，没有任何子节点的节点称为*叶节点*。因此，尽管每个节点在理论上有可能有最多 26 个分支（当仅使用英语字母时），我们的字典树将相对稀疏。后续节点可能只会有少数几个分支。

![一个字典树的前三个层级。每个节点展示了以 A、B 或 C 开始的可能分支。某些字符被灰色显示，表示在不同分支中没有子节点。](img/f06005.png)

图 6-5：字典树只为非空分支创建节点，从而避免在未使用的分支上浪费空间。

与二叉搜索树不同，前缀树中的并非每个节点都代表有效条目。虽然每个叶子节点都是有效条目，但一些内部节点可能只是通往完整字符串的前缀。例如，一个包含字符串 COFFEE 的前缀树将包含一个表示前缀 COFFE 的中间节点。尽管这是作者在喝了太多咖啡后常常使用的拼写方式，但它实际上不是一个有效的单词或条目。我们不希望我们的数据结构仅仅因为有一个对应该前缀的节点，就暗示 COFFE 是有效的。然而，在某些情况下，内部节点可能是完全有效的条目。如果一个前缀树包含字符串 CAT 和 CATALOG，那么 CAT 的节点将是内部节点，因为它至少有一个子节点，位于到 CATALOG 节点的路径上。

为了解决这个歧义，我们在前缀树节点中存储一个指示符，表示当前前缀是否代表有效条目。这可以简单地是一个布尔值 `is_entry`，如果对应有效条目的节点为 `True`，否则为 `False`：

```py
TrieNode {
    Boolean: is_entry
    Array of TrieNodes: children
}
```

在这个例子中，COFFE 的节点会有 `is_entry = False`，而 COFFEE 的节点会有 `is_entry = True`。

或者，我们可以在前缀树节点中存储一些更有用的信息，例如某个条目被插入的次数。或者，如果我们正在跟踪每个条目的辅助数据，例如单词的定义或一系列滑稽的双关语，我们可以使用这些数据的存在作为一个指示符。那些不代表有效条目的前缀可以指向 `null` 或空的数据结构。这看起来可能有些苛刻，但只有真正的单词才能成为我们最好的双关语。

和二叉搜索树一样，我们可以通过将根节点包装在一个前缀树对象中，来清理前缀树的接口：

```py
Trie {
    TrieNode: root
}
```

与二叉搜索树不同，我们的前缀树总是有一个（非空的）根节点。我们在创建前缀树数据结构时同时创建这个根节点。即使是完全空的前缀树，我们也会分配一个根节点（`is_entry = False`），表示字符串的开始。`Trie` 数据结构不仅将根节点包装在一个方便的容器中，还允许我们隐藏一些操作中需要的额外记账信息。

一个有用的字典树类比是终极现实世界的文件系统。想象一个建筑，作为存储世界上每个话题详细文件的系统——高效文件存储方案的纪念碑。我们根据话题的第一个字母对其进行划分，就像百科全书的书籍一样，因此我们的建筑有 26 层楼。我们为每个字母保留一个楼层，这些楼层提供了我们第一层次的划分。然后，我们将每一层填充 26 个房间，每个房间代表话题的第二个字母。每个房间里会有 26 个文件柜，用来划分第三个字母；每个文件柜有 26 个抽屉（第四个字母），每个抽屉有 26 个分区（第五个字母），依此类推。在每一层，我们通过共同的前缀将条目分组。只要我们有高速电梯，就可以相对轻松地找到任何话题。

### 搜索字典树

搜索字典树类似于搜索二叉查找树，因为我们从树的顶部根节点开始，向下移动，选择通向搜索目标的分支。然而，在字典树的情况下，我们选择与字符串中下一个字母对应的分支。我们不需要比较完整的字符串，甚至不需要比较前缀的开始部分。这些都已经在之前的节点中完成。我们只需要考虑下一个字符——每一层只进行一次比较。

回到文件建筑类比，假设你正在搜索你最喜欢的作者的信息。在到达 K 楼后，你会面对 26 个标有 A 到 Z 的房间，它们代表了从 KA 到 KZ 的前缀。你下一步的行动只取决于作者名字的第二个字母。你不需要再浪费时间考虑第一个字母——那已经在电梯里完成了。这个楼层上的每个房间都以 K 开头，你自信地走向标有 U 的房间。

使用这种方法实现代码的一种复杂性是，我们在每一层的搜索中所做的比较都会发生变化。在第一层，我们检查第一个字符是否匹配——但在第二层，我们需要检查第二个字符。我们的搜索不再将整个目标与节点中的值进行比较。我们需要额外的信息，就是在这一层我们要检查的字符的位置。我们可以通过将要检查的索引传递给递归搜索函数，并在每次递归时递增它，来跟踪这个额外的状态。

字典树包装器使我们能够隐藏对根节点的引用和递归函数所需的初始计数器，从而简化字典树用户看到的代码：

```py
TrieSearch(Trie: trie, String: target):
    return TrieNodeSearch(tr.root, target, 0)
```

这个包装器保证后续的搜索函数会在一个非空节点和正确的初始索引下被调用。

递归搜索字典树的代码比搜索二叉查找树的代码稍微复杂一些，因为我们必须处理不同长度的目标值：

```py
TrieNodeSearch(TrieNode: current, String: target, Integer: index):
  ❶ IF index == length(target):
        IF current.is_entry:
            return current
        ELSE:
            return null

  ❷ Character: next_letter = target[index]
  ❸ Integer: next_index = LetterToIndex(next_letter)
    TrieNode: next_child = current.children[next_index]
  ❹ IF next_child == null:
        return null
    ELSE:
        return TrieNodeSearch(next_child, target, index+1)
```

这段代码首先通过检查目标字符串的长度与当前深度，来确定目标是否应该位于此层级❶。如果索引等于字符串的长度（即超过字符串的最后一个字符），代码会检查当前节点是否是有效条目。这一步检查在搜索终止于内部节点时尤其必要，因为我们需要确认该节点本身是有效条目，而不仅仅是另一个条目的前缀。

如果代码还没有到达目标字符串的末尾，它会通过检查目标❷中的下一个字符继续搜索。我们可以定义一个辅助函数，将字符映射到数组中的正确索引❸。然后，代码检查是否存在相应的子节点❹。如果没有对应的子节点，代码返回`null`，确定`target`不在字典树中。如果有对应的子节点，代码会沿着那个分支继续搜索。

以最近一集我们最喜欢的周六早晨动画片中的感叹词 YIKES 和 ZOUNDS 为例，如图 6-6 所示，我们可以记录一些辅助数据，比如单词的出现频率和是谁说的，这样我们就可以在聚会上纠正人们的引用。毕竟，如果数据结构不能帮助我们在学究式的争论中获胜，那它还有什么用呢？

![包含字符串 EGADS、YIKES、YIP、YIPPEE、ZONK 和 ZOUNDS 的字典树。](img/f06006.png)

图 6-6：由漫画短语构建的字典树

为了检查本周的剧集是否包含我们最喜欢的漫画词汇 ZONK，我们可以简单地搜索字典树。我们从字典树的顶部开始，并根据每个字符选择相应的分支，如图 6-7 所示。

![图 6-6 中的字典树，以下节点被高亮显示：根节点、Z、ZO、ZON 和 ZONK。高亮节点显示了从根节点到包含 ZONK 节点的路径。](img/f06007.png)

图 6-7：对漫画短语的字典树进行 ZONK 搜索。阴影节点表示搜索过程中经过的路径。

由于字典树只包含具有数据的节点，我们可以通过观察死胡同来判断一个字符串是否不在字典树中。例如，我们知道 ZIPPY 没有出现在这集里，因为在前缀 Z 之后我们遇到了死胡同。前缀 ZI 没有分支。如果有些自以为是的人宣称他们最喜欢的台词包含了感叹词 ZIPPY，我们可以通过简单的搜索来证明他们错了。

乍一看，似乎添加大量内部节点会增加搜索的成本。然而，这种新结构实际上大大提高了我们的搜索效率。在目标字符串的每个字符位置，我们在当前节点进行一次查找，检查该字符是否有现有的子节点，然后继续访问相应的子节点；因此，查找次数和比较次数随着目标字符串的长度增长。与二叉搜索树不同，成功的 trie 搜索所需的比较次数与 trie 中存储的字符串数量无关。即使我们将整个字典填充进 trie，仍然只需要访问六个节点来检查字符串 EGADS。

当然，像计算机科学中的一切一样，这种效率并非免费的。我们付出了显著的内存开销。我们不再为每个字符串存储一个节点及指向两个子节点的指针，而是为字符串中的每个字符存储一个节点，并存储大量指向潜在子节点的指针。重叠的前缀有助于降低每个字符串的内存开销。如果多个条目共享相同的前缀，例如 ZO 对于 ZOUNDS 和 ZONK（见图 6-6），这些条目将共享这些初始重叠字符的节点。

### 添加和删除节点

与二叉搜索树类似，trie 是一种动态数据结构，当我们添加或删除节点时，它会根据数据的变化进行适应，从而准确地表示数据的变化。将一个字符串添加到 trie 的方式类似于将数据添加到二叉搜索树。我们沿着树往下走，就像是在搜索这个字符串一样。一旦我们遇到死胡同，就可以在该节点下创建一个子树，以捕捉该字符串中剩余的字符。与二叉搜索树的插入不同，在插入单个条目时，我们可能会添加多个新的内部节点。

顶层的`Trie`函数通过调用递归的搜索函数，传入（非空）根节点和正确的初始深度来设置插入操作：

```py
TrieInsert(Trie: tr, String: new_value):
    TrieNodeInsert(tr.root, new_value, 0)
```

我们不需要将根节点的创建当作特例来处理，因为在创建 trie 本身时我们会分配一个初始的根节点。

插入的代码与搜索功能的代码类似：

```py
TrieNodeInsert(TrieNode: current, String: new_value, Integer: index):
  ❶ IF index == length(new_value):
        current.is_entry = True
    ELSE:
        Character: next_letter = new_value[index]
        Integer: next_index = LetterToIndex(next_letter)
        TrieNode: next_child = current.children[next_index]
      ❷ IF next_child == null:
            current.children[next_index] = TrieNode()
          ❸ TrieNodeInsert(current.children[next_index], 
                           new_value, index + 1)
        ELSE:
          ❹ TrieNodeInsert(next_child, new_value, index + 1)
```

这段代码首先通过检查当前的位置与插入字符串的长度进行比较 ❶。当到达字符串的末尾时，它会将当前节点标记为有效条目。根据使用情况，代码可能还需要更新节点的辅助数据。若代码还未到达字符串末尾，它会查找下一个字符并检查是否存在相应的子节点 ❷。如果没有，代码将创建一个新的子节点。然后，它会递归调用`TrieNodeInsert`函数，传入正确的子节点（❸或❹）。

例如，如果我们想将字符串 EEK 添加到我们的卡通感叹词列表中，我们将添加两个节点：一个表示前缀 EE 的内部节点，以及一个表示完整字符串 EEK 的叶子节点。图 6-8 展示了这个添加过程，带阴影的节点表示在插入过程中创建的字典树节点。

删除节点遵循类似的过程，但相反：从最终字符的节点开始，我们向上遍历树，删除不再需要的节点。我们停止删除节点，直到遇到一个内部节点，该节点要么至少有一个非空的子分支，从而代表字典树中其他字符串的有效前缀，要么它本身是树中存储的字符串，因此代表一个有效的叶子节点。

与搜索和插入一样，我们从封装代码开始，首先从根节点开始删除操作，并使用正确的索引：

```py
TrieDelete(Trie: tr, String: target):
    TrieNodeDelete(tr.root, target, 0)
```

该函数不返回任何值。

删除节点的代码基于搜索和插入的代码，最初沿着树向下遍历，直到找到要删除的入口。当代码返回到字典树时，附加逻辑会修剪空分支。代码返回一个布尔值，指示当前节点是否可以安全删除，从而允许父节点修剪该分支。

![图 6-6 中的字典树，添加了节点来存储字符串 EE 和 EEK。新增的节点位于前缀 E 的节点下方的分支中。](img/f06008.png)

图 6-8：将 EEK 添加到卡通短语的字典树中。新的节点以阴影显示。

```py
TrieNodeDelete(TrieNode: current, String: target, Integer: index):
  ❶ IF index == length(target):
        IF current.is_entry:
            current.is_entry = False
    ELSE:
      ❷ Character: next_letter = target[index]
        Integer: next_index = LetterToIndex(next_letter)
        TrieNode: next_child = current.children[next_index]
        IF next_child != null:
          ❸ IF TrieNodeDelete(next_child, target, index+1):
               current.children[next_index] = null

    # Do not delete this node if it has either an entry or a child.
  ❹ IF current.is_entry:
        return False
  ❺ FOR EACH ptr IN current.children:
        IF ptr != null:
            return False
    return True
```

这段代码首先比较被删除字符串的长度与当前层级，如果当前节点正在被删除，则改变`is_entry`的值 ❶。否则，算法将递归地沿着树向下遍历，使用与搜索和插入功能相同的逻辑 ❷。它查找下一个字符，找到对应的节点，检查该节点是否存在，如果存在，则递归下降到该节点。如果节点不存在，目标字符串不在字典树中，代码将停止向下继续。然后，代码会从父节点删除空分支。每次调用`TrieNodeDelete`都会返回一个布尔值，表示是否可以安全地删除对应的节点。如果`TrieNodeDelete`返回`True`，父节点将立即删除子节点 ❸。

该函数以逻辑判断是否允许父节点删除当前节点作为结束。如果`is_entry == True` ❹，即表示是有效的入口，或者当前节点至少有一个非空的子节点 ❺，它将返回`False`。它通过`FOR`循环遍历每个子节点，并检查是否为`null`来进行最后的检查。如果任何一个子节点不是`null`，代码将立即返回`False`，因为该节点是一个必要的内部节点。需要注意的是，如果目标字符串不在字典树中，代码会返回`False`，因为代码从不将任何节点的`is_entry`设置为`False`，因此没有新的修剪机会。

考虑从我们示例中的 trie 中删除字符串 YIPPEE。如果 trie 中也包含单词 YIP 作为条目，我们将删除从 YIP 节点开始的所有后续节点，如图 6-9 所示。YIPPEE 节点本身被标记为可以删除，因为它是一个叶子节点，并且 `is_entry` 已标记为 `False` 作为删除的一部分。当函数返回到 YIP 节点时，它立即删除其唯一的子节点（分支 E）。YIP 节点现在是一个叶子节点，`is_entry == False`，并可以被其父节点删除。这个过程继续向上树结构进行，直到遇到 YIP 节点，该节点的 `is_entry == True`，因为字符串 YIP 存在于 trie 中。

由于删除需要从根节点到达单个叶子节点的往返，成本再次与目标字符串的长度成正比。与搜索和插入一样，成本与 trie 中存储的字符串总数无关。

![图 6-8 中的 Trie，节点 YIPP、YIPPE 和 YIPPEE 被灰色虚线标记，以表示它们将被删除。](img/f06009.png)

图 6-9：从包含字符串 YIP 的卡通短语的 trie 中删除字符串 YIPPEE。被删除的节点有虚线标记并被灰色显示。

## 为什么这很重要

我们现在可以看到 trie 如何解决我们之前提出的二叉搜索树的问题：它们的搜索成本取决于单词的数量和长度。在本章的简短示例中，trie 并没有提供太多的优势。实际上，额外的分支所带来的开销可能使它们比二叉搜索树或排序列表效率更低。然而，随着我们添加越来越多的字符串，并且具有相似前缀的字符串数量增加，trie 的成本效益会越来越高。原因有两个：首先，trie 中的查找成本与条目的数量无关，第二，字符串比较本身可能是昂贵的。在二叉搜索树中，这两个因素是复合的，因为我们在每个节点上都需要进行字符串比较。

在实际应用中，例如，我们可能会在文字处理器中使用 trie 来跟踪字典中的单词。每个节点的辅助数据可能包括单词的定义或常见的拼写错误。当用户输入和编辑时，程序可以高效地检查每个单词是否在字典中，并在其不在字典时进行高亮显示。这个程序极大地受益于自然语言中共享的前缀和有限的字符数。

例如，如果我们正在撰写一篇关于百科全书历史的深入文章，我们不希望在比较*encyclopedia*与相邻词汇*encyclopedias*、*encyclopedic*、*encyclopedist*等时支付过高的成本。请记住，如图 6-10 所示，比较两个字符串字母顺序的算法是通过遍历这两个字符串，比较每个字符。尽管程序在找到不同字符时会停止，但比较相似前缀的成本会累积。在一个活跃的文字处理器文档中，我们可能需要不断修改词汇集。每次插入或编辑都需要在我们的数据结构中进行查找。

![词汇“encyclopedic”和“encyclopedias”之间的字符串比较。前 11 个字符标记为相等。](img/f06010.png)

图 6-10：一个昂贵的字符串比较示例

对于 trie 的一个更好的用途，可能是跟踪结构化标签的数据结构——例如序列号、型号或 SKU 代码——这些通常格式化为简短的字母数字字符串。例如，我们可以创建一个简单的 trie 来存储按序列号索引的产品注册信息。即使销售了数十亿个产品，所有操作的成本也会随着序列号的长度线性增长。如果我们的序列号包含结构信息，例如代表设备型号的前缀，我们可以通过限制初始节点的分支因子来进一步节省开销（因为许多字符串将使用相同的前缀）。辅助数据可以包括关于设备购买地点或时间的信息。

比任何具体应用更重要的是，tries 演示了如何利用数据中的进一步结构来优化操作成本。我们将二叉搜索树的分支结构与字符串的顺序特性结合起来。这一改进再次展示了本书的核心主题：我们通常可以利用数据固有的结构来提高算法效率。
