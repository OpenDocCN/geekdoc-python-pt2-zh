- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ACTIVATING SAFETY DOORS**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the space station, doors restrict access to certain zones and ensure that
    astronauts can only get into areas where they’re qualified to work. Many doors
    require personal access passes to open, and the engineering bay doors can only
    be opened with a button in Mission Control. The engineering bay doors also have
    a timer that closes them automatically to increase security.
  prefs: []
  type: TYPE_NORMAL
- en: The doors also enforce safety rules that require astronauts to have a working
    suit before they can enter the airlock and to have a buddy with them before the
    door to the planet surface can open. Footage from the security camera suggests
    that some astronauts have found a way to bypass the buddy requirement so they
    can enjoy the serenity of a solo walk on the planet’s surface.
  prefs: []
  type: TYPE_NORMAL
- en: You installed the doors in the space station when you installed the props. In
    this chapter, you’ll add the code to open and close the doors, as well as add
    a few other tricks and puzzles to make the game more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: '**PLANNING WHERE TO PUT SAFETY DOORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Doors are clearly a vital part of the space station design, but they’re also
    important for the game’s design. Most obviously, they present a challenging puzzle:
    players need to find a way to open locked doors.'
  prefs: []
  type: TYPE_NORMAL
- en: The doors also help us to tell a story, in which there are obstacles that the
    hero must overcome using their survival training and logical thinking. The game’s
    puzzles will only be satisfying if the player has to think about them a little
    bit. So it’s important that we can control when players see the different puzzle
    elements. Imagine you enter a room and there’s rampant fire blocking the other
    exit. If you’re already carrying a fire extinguisher, you just whip it out and
    use it. There’s no real challenge. It’s more intriguing if you see the threat
    (or the puzzle), and then have to figure out the solution. By sealing off parts
    of the map, we can guide players to see a problem before they see its solution.
    We can’t be certain they’ll notice everything we put in their path, but we can
    give them an opportunity to experience the game at its best.
  prefs: []
  type: TYPE_NORMAL
- en: Doors also enable us to get more value from the map. Although it might not feel
    like it after typing it in, the game map isn’t huge. We can provide a richer experience
    and a longer game by requiring players to cross difficult rooms more than once.
    For example, if we put a key at the end of a corridor, we can direct the player
    to retrace their steps along the corridor and use the key in a door they passed
    on the way.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-1](ch11.xhtml#ch11fig1) shows the location of doors in the game.
    Without giving too much away, players won’t be able to get into room 36 before
    they’ve gotten into the top-right section of the space station (via room 34).
    They won’t be able to visit room 27 until they’ve gotten into room 40, either.
    By strategically placing items in the locked rooms, including access cards, we
    can direct the player through the game and through the story.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig11-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: The game map with doors shown in red*'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re designing your own games, think carefully about where you put your
    props. It’s one of the most important elements in ensuring the game presents players
    with an enjoyable challenge.
  prefs: []
  type: TYPE_NORMAL
- en: '**POSITIONING THE DOORS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve positioned all the doors in *Escape* at the top or bottom exit of a room
    because of the game’s top-down perspective. If a door was in a side exit, players
    would only see its top surface, and we need to make sure something as important
    as a door can be clearly seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the doors are at the top of the room and remain open after the player
    opens them. The exception is the door between rooms 32 and 27, which has a timer
    mechanism that shuts it automatically. This timer provides an additional challenge:
    the player must rush to get to the room from the switch that opens the door, before
    the door closes.'
  prefs: []
  type: TYPE_NORMAL
- en: The doors in *Escape* are objects 20 to 26\. Their images and descriptions are
    set up in the objects dictionary (see “[Making the Space Station Objects Dictionary](ch05.xhtml#lev79)”
    on [page 85](ch05.xhtml#page_85)). The door positions are set up in the props
    dictionary (see “[Adding the Props Information](ch09.xhtml#lev117)” on [page 151](ch09.xhtml#page_151)).
    Each door has an *x* position that puts it in the room’s doorway. To work out
    the *x* position for a door, just divide the room width by 2, round it down, and
    then subtract 1.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s add some controls to enable players to open the doors.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING ACCESS CONTROLS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To enable the player to open the doors, we need to add some instructions to
    the use_object() function in the USE OBJECTS part of the program. One new code
    snippet will open the timed door to the engineering bay when the player presses
    a button in one of the rooms. You’ll add this code between the instructions for
    handling objects 16 and 68.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other new code addition will enable the player to use access cards to open
    the doors: put this after the code for using recipes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-1](ch11.xhtml#ch11list1) shows the new code to add. Because these
    instructions are part of the use_object() function, the first one is indented
    by four spaces. Your new elif instruction should line up with the elif instruction
    above it.'
  prefs: []
  type: TYPE_NORMAL
- en: Open *listing10-7.py* from the previous chapter and add these new lines to it.
    Save your program as *listing11-1.py*. You can run it using pgzrun listing11-1.py,
    but we haven’t added all the code necessary to make the doors work properly yet.
    You shouldn’t see any error messages, though.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing11-1.py*'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: 'elif item_player_is_on == 16:'
  prefs: []
  type: TYPE_NORMAL
- en: energy += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if energy > 100:'
  prefs: []
  type: TYPE_NORMAL
- en: energy = 100
  prefs: []
  type: TYPE_NORMAL
- en: use_message = "You munch the lettuce and get a little energy back"
  prefs: []
  type: TYPE_NORMAL
- en: draw_energy_air()
  prefs: []
  type: TYPE_NORMAL
- en: '➊     elif item_player_is_on == 42:'
  prefs: []
  type: TYPE_NORMAL
- en: '➋         if current_room == 27:'
  prefs: []
  type: TYPE_NORMAL
- en: ➌             open_door(26)
  prefs: []
  type: TYPE_NORMAL
- en: '➍         props[25][0] = 0 # Door from RM32 to engineering bay'
  prefs: []
  type: TYPE_NORMAL
- en: 'props[26][0] = 0 # Door inside engineering bay'
  prefs: []
  type: TYPE_NORMAL
- en: ➎         clock.schedule_unique(shut_engineering_door, 60)
  prefs: []
  type: TYPE_NORMAL
- en: use_message = "You press the button"
  prefs: []
  type: TYPE_NORMAL
- en: show_text("Door to engineering bay is open for 60 seconds", 1)
  prefs: []
  type: TYPE_NORMAL
- en: sounds.say_doors_open.play()
  prefs: []
  type: TYPE_NORMAL
- en: sounds.doors.play()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif item_carrying == 68 or item_player_is_on == 68:'
  prefs: []
  type: TYPE_NORMAL
- en: energy = 100
  prefs: []
  type: TYPE_NORMAL
- en: use_message = "You use the food to restore your energy"
  prefs: []
  type: TYPE_NORMAL
- en: remove_object(68)
  prefs: []
  type: TYPE_NORMAL
- en: draw_energy_air()
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: 'for recipe in RECIPES:'
  prefs: []
  type: TYPE_NORMAL
- en: ingredient1 = recipe[0]
  prefs: []
  type: TYPE_NORMAL
- en: ingredient2 = recipe[1]
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: add_object(combination)
  prefs: []
  type: TYPE_NORMAL
- en: sounds.combine.play()
  prefs: []
  type: TYPE_NORMAL
- en: '# {key object number: door object number}'
  prefs: []
  type: TYPE_NORMAL
- en: ➏     ACCESS_DICTIONARY = { 79:22, 80:23, 81:24 }
  prefs: []
  type: TYPE_NORMAL
- en: '➐     if item_carrying in ACCESS_DICTIONARY:'
  prefs: []
  type: TYPE_NORMAL
- en: door_number = ACCESS_DICTIONARY[item_carrying]
  prefs: []
  type: TYPE_NORMAL
- en: '➑         if props[door_number][0] == current_room:'
  prefs: []
  type: TYPE_NORMAL
- en: use_message = "You unlock the door!"
  prefs: []
  type: TYPE_NORMAL
- en: ➒             sounds.say_doors_open.play()
  prefs: []
  type: TYPE_NORMAL
- en: sounds.doors.play()
  prefs: []
  type: TYPE_NORMAL
- en: open_door(door_number)
  prefs: []
  type: TYPE_NORMAL
- en: show_text(use_message, 0)
  prefs: []
  type: TYPE_NORMAL
- en: time.sleep(0.5)
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-1: Adding the ability to open doors*'
  prefs: []
  type: TYPE_NORMAL
- en: The button to open the door to the engineering bay is object 42\. There is one
    of these buttons outside the engineering bay to provide access, and another inside
    the engineering bay, so the player doesn’t get trapped inside.
  prefs: []
  type: TYPE_NORMAL
- en: If the player is using the button ➊, the code to open the door runs. If they’re
    using the button inside the room ➋, the open_door() function is used to show the
    door opening ➌. We’ll add that function shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The props dictionary is updated to change the room number for the door to 0,
    removing the door from the room (and from the game) ➍. This door works on a timer,
    so the program schedules the function to close the door 60 seconds later ➎. If
    you find it too difficult to get to the room in time, you can change the number
    60 to a larger number. This number should give you just about enough time, whether
    you’re using a PC or Raspberry Pi 3; or a Raspberry Pi 2, where the game runs
    a little bit more slowly.
  prefs: []
  type: TYPE_NORMAL
- en: The second chunk of code enables players to use keys to open the doors. We create
    a new dictionary called ACCESS_DICTIONARY that uses the access card number as
    the dictionary key and the door number as the data ➏. So object 79 (an access
    card) is used to open door 22, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: The objects used to open the doors in *Escape* are all access cards, but if
    you’re modifying the game, you could use any object. You could use a crowbar to
    pry doors open, or (if you make a game set in a fantasy world) you could use different
    magic spells. Just make sure players can reasonably work out what to use.
  prefs: []
  type: TYPE_NORMAL
- en: When the player presses U, the door opens if they have selected one of the items
    in the dictionary for unlocking doors ➐ and if they are standing in the same room
    as the door it unlocks ➑. We also play a sound effect of a computer voice saying
    “doors open” ➒. This is just a recording, like any other sound in the game.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE DOORS OPEN AND CLOSE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll place the functions for opening, closing, and animating the doors into
    a new DOORS section of the program. You need to add this section after the USE
    OBJECTS section but before the START section at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-2](ch11.xhtml#ch11list2) shows the first two functions you need
    to add to start the DOORS section. Add the new lines, and save your program as
    *listing11-2.py*. The DOORS section is still incomplete: you can run the program
    (using pgzrun listing11-2.py) to check for errors, but the doors won’t work yet.'
  prefs: []
  type: TYPE_NORMAL
- en: '*listing11-2.py*'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: sounds.completion.play()
  prefs: []
  type: TYPE_NORMAL
- en: sounds.say_mission_complete.play()
  prefs: []
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: '##   DOORS   ##'
  prefs: []
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def open_door(opening_door_number):'
  prefs: []
  type: TYPE_NORMAL
- en: global door_frames, door_shadow_frames
  prefs: []
  type: TYPE_NORMAL
- en: global door_frame_number, door_object_number
  prefs: []
  type: TYPE_NORMAL
- en: ➋     door_frames = [images.door1, images.door2, images.door3,
  prefs: []
  type: TYPE_NORMAL
- en: images.door4, images.floor]
  prefs: []
  type: TYPE_NORMAL
- en: '# (Final frame restores shadow ready for when door reappears).'
  prefs: []
  type: TYPE_NORMAL
- en: door_shadow_frames = [images.door1_shadow, images.door2_shadow,
  prefs: []
  type: TYPE_NORMAL
- en: images.door3_shadow, images.door4_shadow,
  prefs: []
  type: TYPE_NORMAL
- en: images.door_shadow]
  prefs: []
  type: TYPE_NORMAL
- en: door_frame_number = 0
  prefs: []
  type: TYPE_NORMAL
- en: door_object_number = opening_door_number
  prefs: []
  type: TYPE_NORMAL
- en: ➌     do_door_animation()
  prefs: []
  type: TYPE_NORMAL
- en: '➍ def close_door(closing_door_number):'
  prefs: []
  type: TYPE_NORMAL
- en: global door_frames, door_shadow_frames
  prefs: []
  type: TYPE_NORMAL
- en: global door_frame_number, door_object_number, player_y
  prefs: []
  type: TYPE_NORMAL
- en: ➎     door_frames = [images.door4, images.door3, images.door2,
  prefs: []
  type: TYPE_NORMAL
- en: images.door1, images.door]
  prefs: []
  type: TYPE_NORMAL
- en: door_shadow_frames = [images.door4_shadow, images.door3_shadow,
  prefs: []
  type: TYPE_NORMAL
- en: images.door2_shadow, images.door1_shadow,
  prefs: []
  type: TYPE_NORMAL
- en: images.door_shadow]
  prefs: []
  type: TYPE_NORMAL
- en: door_frame_number = 0
  prefs: []
  type: TYPE_NORMAL
- en: door_object_number = closing_door_number
  prefs: []
  type: TYPE_NORMAL
- en: '# If player is in same row as a door, they must be in open doorway'
  prefs: []
  type: TYPE_NORMAL
- en: '➏     if player_y == props[door_object_number][1]:'
  prefs: []
  type: TYPE_NORMAL
- en: '➐         if player_y == 0: # if in the top doorway'
  prefs: []
  type: TYPE_NORMAL
- en: '➑             player_y = 1 # move them down'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: '➒             player_y = room_height - 2 # move them up'
  prefs: []
  type: TYPE_NORMAL
- en: ➓     do_door_animation()
  prefs: []
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: '##   START   ##'
  prefs: []
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-2: Setting up the door animations*'
  prefs: []
  type: TYPE_NORMAL
- en: The open_door() and close_door() functions set up the door animations for opening
    and closing. You’ve already seen open_door() ➊ mentioned in [Listing 11-1](ch11.xhtml#ch11list1).
    In [Listing 11-2](ch11.xhtml#ch11list2), we define that function so it can run
    if the player opens a door using a key, for example.
  prefs: []
  type: TYPE_NORMAL
- en: The door animation has five frames, numbered 0 to 4, as shown in [Table 11-1](ch11.xhtml#ch11tab1).
    We store images for the animation in a list called door_frames ➋➎ and store the
    frame number in the variable door_frame_number. In the open_door() and close_door()
    functions, we set the frame number to 0, the first frame.
  prefs: []
  type: TYPE_NORMAL
- en: In the variable door_object_number, we store the object number of the door that
    will be opening or closing. After the variables and list have been set up, the
    function do_door_animation() is started to carry out the animation using them
    ➌➓. We’ll add that function shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function for closing the door ➍ is similar to the function for opening
    the door ➊ with two exceptions: the animation frames are different, and there
    is a check to stop the door from closing on top of the player.'
  prefs: []
  type: TYPE_NORMAL
- en: If the player is in the same *y* position as the door ➏, it means the player
    is standing in the doorway. In that case, if the player is in the top row ➐, we
    set their *y* position to 1 ➑ to move them to the next row down. If the player
    is not in the top row, we set their *y* position to the second row from the bottom
    ➒, just inside the door.
  prefs: []
  type: TYPE_NORMAL
- en: This means the astronaut jumps out of the way of the doors of their own accord,
    but it’s more realistic than them ending up inside the door!
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** The Animation Frames for the Doors'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Frame number** | **0** | **1** | **2** | **3** | **4** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Opening** | ![image](../images/f0189-01.jpg) | ![image](../images/f0189-02.jpg)
    | ![image](../images/f0189-03.jpg) | ![image](../images/f0189-04.jpg) | **Final
    frame is a floor tile (no door).** |'
  prefs: []
  type: TYPE_TB
- en: '| **Closing** | ![image](../images/f0189-05.jpg) | ![image](../images/f0189-06.jpg)
    | ![image](../images/f0189-07.jpg) | ![image](../images/f0189-08.jpg) | ![image](../images/f0189-09.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '**ADDING THE DOOR ANIMATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The do_door_animation() function will manage the animation of the doors opening
    and closing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place the do_door_animation() function inside the DOORS section of the program,
    after the close_door() function you added in [Listing 11-2](ch11.xhtml#ch11list2).
    Add the new lines in [Listing 11-3](ch11.xhtml#ch11list3), and save your program
    as *listing11-3.py*. You can run this version of the game using pgzrun listing11-3.py.
    The doors that are opened with a key should now be working. I’ll tell you how
    to test them in Training Mission #1 shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: '*listing11-3.py*'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: 'player_y = room_height - 2 # move them up'
  prefs: []
  type: TYPE_NORMAL
- en: do_door_animation()
  prefs: []
  type: TYPE_NORMAL
- en: 'def do_door_animation():'
  prefs: []
  type: TYPE_NORMAL
- en: global door_frames, door_frame_number, door_object_number, objects
  prefs: []
  type: TYPE_NORMAL
- en: ➊     objects[door_object_number][0] = door_frames[door_frame_number]
  prefs: []
  type: TYPE_NORMAL
- en: objects[door_object_number][1] = door_shadow_frames[door_frame_number]
  prefs: []
  type: TYPE_NORMAL
- en: ➋     door_frame_number += 1
  prefs: []
  type: TYPE_NORMAL
- en: '➌     if door_frame_number == 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '➍         if door_frames[-1] == images.floor:'
  prefs: []
  type: TYPE_NORMAL
- en: '➎             props[door_object_number][0] = 0 # remove door from props list'
  prefs: []
  type: TYPE_NORMAL
- en: '# Regenerate room map from the props'
  prefs: []
  type: TYPE_NORMAL
- en: '# to put the door in the room if required.'
  prefs: []
  type: TYPE_NORMAL
- en: ➏         generate_map()
  prefs: []
  type: TYPE_NORMAL
- en: '➐     else:'
  prefs: []
  type: TYPE_NORMAL
- en: ➑         clock.schedule(do_door_animation, 0.15)
  prefs: []
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: '##   START   ##'
  prefs: []
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-3: Adding the door animation*'
  prefs: []
  type: TYPE_NORMAL
- en: The objects dictionary contains, among other things, the image to use for a
    particular object. This new function starts by changing the door’s image in that
    dictionary to the current animation frame ➊. When the room is redrawn, it will
    now use that animation frame.
  prefs: []
  type: TYPE_NORMAL
- en: The function then increases the animation frame number by 1 ➋ so the next animation
    frame can be shown next time this function runs. If the frame is now 5, it means
    we’ve reached the end of the animation ➌. In that case, we check whether the door
    has opened (rather than closed) by seeing whether the final frame was a floor
    tile, showing no door ➍. (An index number of -1 gives you the last item in a list.)
  prefs: []
  type: TYPE_NORMAL
- en: If the door has now fully opened, the props data is updated to remove this door
    from the game by changing its room number to 0 ➎. If the current animation frame
    is the final frame, whether the door is opening or closing, a new room map is
    generated ➏, which ensures the door is added or removed correctly in the current
    room.
  prefs: []
  type: TYPE_NORMAL
- en: If the current frame isn’t the final animation frame ➐, the function sets itself
    to run again in 0.15 seconds ➑ to show the next frame in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why I didn’t combine the two if instructions ➌➍. The reason
    is that the generate_map() function needs to run at the end of the animation,
    whether the door is opening or closing. If we combined the two if instructions,
    this function would only run when the door had opened.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRAINING MISSION #1**'
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the program, the doors should be fully functional. Can you
    test that they work? Find the access card for the door in the community room and
    use it. Stand in the community room and use the access card for its door by selecting
    the access card in your inventory and pressing U. If you need a hint, look at
    the map in [Figure 11-1](ch11.xhtml#ch11fig1). The community room is number 39,
    and the key for it is in room 41\. Remember that people sometimes tidy things
    away, and the key might not be lying in plain sight.
  prefs: []
  type: TYPE_NORMAL
- en: '**SHUTTING THE TIMED DOOR**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we need to add a new function called shut_engineering_door() to shut the
    door to the engineering bay automatically. This function is set to run after a
    delay of 60 seconds when the door is opened (see [Listing 11-1](ch11.xhtml#ch11list1)),
    giving the player a minute to run from the button to the door before it shuts!
  prefs: []
  type: TYPE_NORMAL
- en: Put this function in the DOORS section of the program after the do_door_animation()
    function you just added. Add the new lines in [Listing 11-4](ch11.xhtml#ch11list4),
    and save the program as *listing11-4.py*. Then run this program using pgzrun listing11-4.py.
    You should see no error messages. The timed door should be working now, but I’ll
    show you an easier way to test it shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing11-4.py*'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: clock.schedule(do_door_animation, 0.15)
  prefs: []
  type: TYPE_NORMAL
- en: 'def shut_engineering_door():'
  prefs: []
  type: TYPE_NORMAL
- en: global current_room, door_room_number, props
  prefs: []
  type: TYPE_NORMAL
- en: '➊     props[25][0] = 32 # Door from room 32 to the engineering bay.'
  prefs: []
  type: TYPE_NORMAL
- en: '➋     props[26][0] = 27 # Door inside engineering bay.'
  prefs: []
  type: TYPE_NORMAL
- en: '➌     generate_map() # Add door to room_map for if in affected room.'
  prefs: []
  type: TYPE_NORMAL
- en: '➍     if current_room == 27:'
  prefs: []
  type: TYPE_NORMAL
- en: ➎         close_door(26)
  prefs: []
  type: TYPE_NORMAL
- en: '➏     if current_room == 32:'
  prefs: []
  type: TYPE_NORMAL
- en: ➐         close_door(25)
  prefs: []
  type: TYPE_NORMAL
- en: show_text("The computer tells you the doors are closed.", 1)
  prefs: []
  type: TYPE_NORMAL
- en: sounds.say_doors_closed.play()
  prefs: []
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: '##   START   ##'
  prefs: []
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-4: Adding the code to shut the engineering door automatically*'
  prefs: []
  type: TYPE_NORMAL
- en: The shut_engineering_door() function has two door props to work with, objects
    25 and 26, because the player can see this door from either side depending on
    which room they’re in. The first thing we do is update the props dictionary so
    these doors appear in the rooms ➊➋.
  prefs: []
  type: TYPE_NORMAL
- en: We then call the generate_map() function ➌. If the player is in a room with
    one of these doors, this function updates the room map for the current room. In
    other cases, the generate_map() function still runs, but nothing changes.
  prefs: []
  type: TYPE_NORMAL
- en: If the player is in the engineering bay (room 27) ➍, they need to see door 26
    closing ➎, so the program starts the animation. If the player is on the other
    side of the door, in room 32 ➏, we need to show them door 25 closing ➐.
  prefs: []
  type: TYPE_NORMAL
- en: '**RED ALERT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t mix up door numbers and room numbers. Door numbers are object numbers
    and aren’t related to the room they’re in.*'
  prefs: []
  type: TYPE_NORMAL
- en: To test that the engineering bay door is working correctly, we’d have to run
    the game, press the button, and race to the engineering bay. So to save time,
    let’s engineer a solution that enables us to get around the space station more
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A TELEPORTER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While you’re still building the space station, you might find it helpful to
    be able to jump to any room in an instant. Using the latest in molecular transfer
    technology, we can install a *teleporter* that allows you to type in a room number
    and go straight there. This is a huge benefit when you’re testing the game, but
    it’s a restricted technology and isn’t approved for use in a real mission on the
    space station. You’ll need to remove it before you finish building the game. I’m
    trusting you with highly classified technology here.
  prefs: []
  type: TYPE_NORMAL
- en: Place the teleporter code with the other player controls in the game_loop()
    function, in the GAME LOOP part of the program. I recommend that you add it after
    the instructions for starting the use_object function. Because these instructions
    are inside a function, you need to indent the if instruction by four spaces and
    then indent the instructions under it by four more spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Add the new instructions in [Listing 11-5](ch11.xhtml#ch11list5), and then save
    your file as *listing11-5.py*. You can run this program using pgzrun listing11-5.py.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing11-5.py*'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: 'if keyboard.u:'
  prefs: []
  type: TYPE_NORMAL
- en: use_object()
  prefs: []
  type: TYPE_NORMAL
- en: '## Teleporter for testing'
  prefs: []
  type: TYPE_NORMAL
- en: '## Remove this section for the real game'
  prefs: []
  type: TYPE_NORMAL
- en: '➊     if keyboard.x:'
  prefs: []
  type: TYPE_NORMAL
- en: ➋         current_room = int(input("Enter room number:"))
  prefs: []
  type: TYPE_NORMAL
- en: ➌         player_x = 2
  prefs: []
  type: TYPE_NORMAL
- en: player_y = 2
  prefs: []
  type: TYPE_NORMAL
- en: ➍         generate_map()
  prefs: []
  type: TYPE_NORMAL
- en: ➎         start_room()
  prefs: []
  type: TYPE_NORMAL
- en: sounds.teleport.play()
  prefs: []
  type: TYPE_NORMAL
- en: '## Teleport section ends'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-5: Adding a teleporter*'
  prefs: []
  type: TYPE_NORMAL
- en: When you press the X key ➊, the program will ask you to type in a room number
    ➋. This request appears in the command line window where you type in your pgzrun
    instruction to run the program. You might need to click this window to bring it
    to the front and will need to click the game window to play again afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: The input() function takes whatever you enter and puts it in a string. Because
    we need the input as a number, we use the int() function to convert it to an integer
    (or whole number) ➋.
  prefs: []
  type: TYPE_NORMAL
- en: The number you enter goes into the current_room variable. There’s no error checking
    here, so the program might crash if you don’t enter a valid room number. If you
    enter text instead of a number, for example, the program freezes.
  prefs: []
  type: TYPE_NORMAL
- en: You’re teleported to position *y* = 2, *x* = 2 ➌ inside the room you choose.
    This is usually a fairly safe place to be, but if the teleporter puts you inside
    some scenery, you can usually just walk out of it. The room map is regenerated
    ➍, and the room is restarted ➎, completing your teleportation to your new destination.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRAINING MISSION #2**'
  prefs: []
  type: TYPE_NORMAL
- en: Use the teleporter to beam into room 27 so you can test the door in the engineering
    bay. Use the button at the top of the room to open the door (press U while walking
    into the button), and wait in the room until the door closes. Open the door again,
    but this time leave the room and check that the door still closes when seen from
    the other side. The door animation should work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '**ACTIVATING THE AIRLOCK SECURITY DOOR**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a safety feature, the airlock door to the planet’s surface uses a weight
    sensor to open it. One astronaut must stand on the pressure pad to open the door,
    enabling another one to walk through it. This design ensures that astronauts cannot
    go out onto the planet’s surface without support in the space station.
  prefs: []
  type: TYPE_NORMAL
- en: To enable this safety feature, we’ll need to add a new function to the program’s
    DOORS section. [Listing 11-6](ch11.xhtml#ch11list6) shows the code for the new
    function, which animates the door. Add this code after the shut_engineering_door()
    function you added in [Listing 11-4](ch11.xhtml#ch11list4). Save your updated
    program as *listing11-6.py*. You can run your program using pgzrun listing11-6.py,
    but the airlock door is not activated yet.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing11-6.py*'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: show_text("The computer tells you the doors are closed.", 1)
  prefs: []
  type: TYPE_NORMAL
- en: sounds.say_doors_closed.play()
  prefs: []
  type: TYPE_NORMAL
- en: 'def door_in_room_26():'
  prefs: []
  type: TYPE_NORMAL
- en: global airlock_door_frame, room_map
  prefs: []
  type: TYPE_NORMAL
- en: ➊     frames = [images.door, images.door1, images.door2,
  prefs: []
  type: TYPE_NORMAL
- en: images.door3,images.door4, images.floor
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: shadow_frames = [images.door_shadow, images.door1_shadow,
  prefs: []
  type: TYPE_NORMAL
- en: images.door2_shadow, images.door3_shadow,
  prefs: []
  type: TYPE_NORMAL
- en: images.door4_shadow, None]
  prefs: []
  type: TYPE_NORMAL
- en: '➋     if current_room != 26:'
  prefs: []
  type: TYPE_NORMAL
- en: clock.unschedule(door_in_room_26)
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '# prop 21 is the door in Room 26.'
  prefs: []
  type: TYPE_NORMAL
- en: ➌     if ((player_y == 8 and player_x == 2) or props[63] == [26, 8, 2]) \
  prefs: []
  type: TYPE_NORMAL
- en: 'and props[21][0] == 26:'
  prefs: []
  type: TYPE_NORMAL
- en: ➍         airlock_door_frame += 1
  prefs: []
  type: TYPE_NORMAL
- en: '➎         if airlock_door_frame == 5:'
  prefs: []
  type: TYPE_NORMAL
- en: 'props[21][0] = 0 # Remove door from map when fully open.'
  prefs: []
  type: TYPE_NORMAL
- en: room_map[0][1] = 0
  prefs: []
  type: TYPE_NORMAL
- en: room_map[0][2] = 0
  prefs: []
  type: TYPE_NORMAL
- en: room_map[0][3] = 0
  prefs: []
  type: TYPE_NORMAL
- en: ➏     if ((player_y != 8 or player_x != 2) and props[63] != [26, 8, 2]) \
  prefs: []
  type: TYPE_NORMAL
- en: 'and airlock_door_frame > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if airlock_door_frame == 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '# Add door to props and map so animation is shown.'
  prefs: []
  type: TYPE_NORMAL
- en: props[21][0] = 26
  prefs: []
  type: TYPE_NORMAL
- en: room_map[0][1] = 21
  prefs: []
  type: TYPE_NORMAL
- en: room_map[0][2] = 255
  prefs: []
  type: TYPE_NORMAL
- en: room_map[0][3] = 255
  prefs: []
  type: TYPE_NORMAL
- en: airlock_door_frame -= 1
  prefs: []
  type: TYPE_NORMAL
- en: ➐     objects[21][0] = frames[airlock_door_frame]
  prefs: []
  type: TYPE_NORMAL
- en: objects[21][1] = shadow_frames[airlock_door_frame]
  prefs: []
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: '##   START   ##'
  prefs: []
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-6: Adding the weight-activated door in the airlock*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve added the door_in_room_26() function to the game to enable a specific puzzle.
    To avoid telling you the solution and spoiling the puzzle, I won’t cover everything
    that’s in the code here, but I’m sure you can work it out if you want to!
  prefs: []
  type: TYPE_NORMAL
- en: We store the animation frames for the door in the list frames, including the
    first frame that shows the door shut and the final frame that shows an empty floor
    tile instead of the door ➊.
  prefs: []
  type: TYPE_NORMAL
- en: We store the animation frame for the airlock door in the airlock_door_frame
    variable. If the player is standing on the pressure pad (at position *y* = 8 and
    *x* = 2) and the door is in the room ➌, the animation frame number is increased
    to open the door a bit more ➍. If the animation frame is now 5 ➎, then the door
    is fully opened, and the props dictionary and room map are updated to remove the
    door from the room.
  prefs: []
  type: TYPE_NORMAL
- en: We add another section of code to close the door when the player is *not* standing
    on the pressure pad and the door is already at least partially open ➏, so the
    door closes if the player moves off the pressure pad. The program only displays
    props that are in the room map for the current room, so the first instructions
    put the door (object 21) into the room map, even though the first animation frame
    will show the door fully open.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we change the image file for the door in the objects dictionary to
    the current animation frame ➐. The door’s shadow image is also updated. As a result,
    when the room is drawn, the picture for the door shows its current animation frame.
  prefs: []
  type: TYPE_NORMAL
- en: This airlock routine creates a smooth effect where the door slides open when
    the player steps on the pressure pad, but slides shut again the moment they walk
    off. If they step back onto the pad while the door is shutting, it starts to open
    again.
  prefs: []
  type: TYPE_NORMAL
- en: To make the airlock routine work, we also need to add the instruction to make
    the door_in_room_26() function run every 0.05 seconds when the player enters the
    room. When the door_in_room_26() function starts, it checks whether the player
    is still in room 26\. If the player has left the room, the instructions at ➋ in
    [Listing 11-6](ch11.xhtml#ch11list6) stop the function from running regularly
    and exit the function (using a return instruction) so that the door animation
    stops.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll put the code that starts the door_in_room_26() function into the start_room()
    function at the top of the GAME LOOP section. The start_room() function runs when
    the player enters a room. [Listing 11-7](ch11.xhtml#ch11list7) shows the new instructions
    to add.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing11-7.py*'
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: 'GAME LOOP ##'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '###############'
  prefs: []
  type: TYPE_NORMAL
- en: 'def start_room():'
  prefs: []
  type: TYPE_NORMAL
- en: global airlock_door_frame
  prefs: []
  type: TYPE_NORMAL
- en: 'show_text("You are here: " + room_name, 0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'if current_room == 26: # Room with self-shutting airlock door'
  prefs: []
  type: TYPE_NORMAL
- en: airlock_door_frame = 0
  prefs: []
  type: TYPE_NORMAL
- en: clock.schedule_interval(door_in_room_26, 0.05)
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-7: Scheduling the door animation for the airlock*'
  prefs: []
  type: TYPE_NORMAL
- en: Save your program as *listing11-7.py* and run it using pgzrun listing11-7.py.
    In the game, press X to use the teleporter and beam into room 26\. Now you can
    test that the pressure pad works as expected (see [Figure 11-2](ch11.xhtml#ch11fig2)).
    Try walking on it, off it, and across it to see how the door behaves.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you leave through the exit at the bottom of this room, a door appears
    that blocks your way back again. (Normally, you would only enter the airlock by
    opening that door and removing it from the game.) When you teleport into rooms,
    strange things like this might happen. It messes with the space-time continuum.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig11-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: Standing on the pressure pad opens the door.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING EXITS FOR YOUR OWN GAME DESIGNS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re closing off exits for your own map designs, you might need to move
    or remove doors in those exits as well. To remove a door from the game, change
    the entry for that door in the props dictionary so its first number is a 0, or
    delete its entry from the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re customizing the game, you might also want to remove some of the custom
    code here that enables the special doors for the engineering bay and the airlock.
    To disable the pressure pad door, remove the new code in [Listings 11-6](ch11.xhtml#ch11list6)
    and [11-7](ch11.xhtml#ch11list7). To remove the timed door to the engineering
    bay, remove the code shown in [Listing 11-4](ch11.xhtml#ch11list4), and additionally
    remove the first chunk of new code in [Listing 11-1](ch11.xhtml#ch11list1) for
    pressing the button (using object 42).
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION ACCOMPLISHED?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve now finished building the space station, and it’s fully functional. It
    seems you can now settle into your new life, conducting experiments and exploring
    the red planet.
  prefs: []
  type: TYPE_NORMAL
- en: But, wait! What’s this? There could be trouble ahead.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARE YOU FIT TO FLY?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check the following boxes to confirm that you’ve learned the key lessons in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  Doors can seal off parts of the game map, so
    players can discover puzzle elements in the right order.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  Doors need to go at the top or the bottom of
    a room.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  Doors that are opened with access cards stay
    open.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  You can use the functions provided to add doors
    that close automatically, such as the door in the engineering bay.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  Doors are positioned using the props dictionary.
    Their images and descriptions are stored in the objects dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  To animate the door, the program changes its
    image in the objects dictionary. When the room is redrawn, the new image is used
    for the door.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  If a door can be seen from both sides, it needs
    to be represented with two door props: one in each of the rooms where it can be
    seen.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  ACCESS_DICTIONARY is used to remember which access
    cards unlock which doors. You could use other objects to open doors by making
    changes in this dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  To adjust the difficulty of the game, you can
    change the delay before the engineering door slams shut.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The teleporter enables you to beam into any room
    for testing purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The input() function in Python treats what you
    enter as a string. To enable players to type in a number, use the int() function
    to convert what they enter to an integer.'
  prefs: []
  type: TYPE_NORMAL
