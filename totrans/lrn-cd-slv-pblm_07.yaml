- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: READING AND WRITING FILES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: To this point, we’ve read all input using the input function and written all
    output using the print function. These functions read from standard input (defaulting
    to the keyboard) and write to standard output (defaulting to the screen), respectively.
    While we can change these defaults using input and output redirection, sometimes
    a program needs more control over its files. For example, your word processor
    allows you to open whichever document file you like and save a file with whatever
    name you like, without you messing around with standard input and standard output.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过 input 函数读取所有输入，并通过 print 函数写入所有输出。这些函数分别从标准输入（默认为键盘）读取并写入到标准输出（默认为屏幕）。虽然我们可以使用输入和输出重定向来改变这些默认设置，但有时程序需要更多的文件控制。例如，你的文字处理器允许你打开任何文档文件并以你喜欢的名称保存文件，而无需操作标准输入和标准输出。
- en: 'In this chapter, we’ll learn how to write programs that manipulate text files.
    We’ll solve two problems using files: correctly formatting an essay and seeding
    a farm to feed cows.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何编写处理文本文件的程序。我们将通过文件解决两个问题：正确格式化文章和为农场播种以喂养奶牛。
- en: 'Problem #16: Essay Formatting'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #16：文章格式化'
- en: 'There’s one important difference between this problem and all the problems
    we’ve solved to this point: this one requires us to read from and write to specific
    files! Look out for this as you read the problem description.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与我们之前解决的所有问题之间有一个重要的区别：这个问题要求我们从特定的文件中读取并写入文件！在阅读问题描述时要特别注意这一点。
- en: This is USACO 2020 January Bronze Contest problem Word Processor. This is the
    first problem in the book from the USACO (USA Computing Olympiad) judge. To find
    the problem, go to *[http://usaco.org/](http://usaco.org/)*, click **Contests**,
    click **2020 January Contest Results**, and then click **View problem** under
    Word Processor.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 USACO 2020 年 1 月铜奖竞赛问题《文字处理器》。这是本书中来自 USACO（美国计算机奥林匹克竞赛）评审的第一个问题。要找到该问题，请访问
    *[http://usaco.org/](http://usaco.org/)*，点击 **Contests**，点击 **2020 January Contest
    Results**，然后点击 **View problem** 查看《文字处理器》问题。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'Bessie the cow is writing an essay. Each word in the essay contains only lowercase
    or uppercase characters. Her teacher has specified the maximum number of characters,
    not counting spaces, that can occur per line. To satisfy this requirement, Bessie
    writes down the words of the essay using the following rules:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 奶牛贝西正在写一篇文章。文章中的每个单词仅包含小写或大写字母。她的老师指定了每行最多可以出现的字符数（不包括空格）。为了满足这一要求，贝西使用以下规则写下文章中的单词：
- en: If the next word fits on the current line, add it to the current line. Include
    a space between each pair of words on the line.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果下一个单词可以放在当前行中，则将其添加到当前行。在每两个单词之间加上一个空格。
- en: Otherwise, put this word on a new line; this line becomes the new current line.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，将该单词放在新的一行；这一行变为新的当前行。
- en: Output the essay with the correct words on each line.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式正确的文章，每行显示正确的单词。
- en: Input
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *word.in*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为 *word.in* 的文件中读取输入。
- en: The input consists of two lines.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由两行组成。
- en: The first line contains two integers separated by a space. The first integer
    is *n*, the number of words in the essay; it’s between 1 and 100\. The second
    integer is *k*, the maximum number of characters (not counting spaces) that can
    occur per line; it’s between 1 and 80.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含两个由空格分隔的整数。第一个整数是 *n*，即文章中的单词数；它的范围是 1 到 100。第二个整数是 *k*，即每行最多可包含的字符数（不包括空格）；它的范围是
    1 到 80。
- en: The second line contains *n* words, with a space between each pair of words.
    Each word has at most *k* characters.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行包含 *n* 个单词，每两个单词之间用空格隔开。每个单词最多包含 *k* 个字符。
- en: Output
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *word.out*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入名为 *word.out* 的文件。
- en: Output the properly formatted essay.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式正确的文章。
- en: Working with Files
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件操作
- en: The Essay Formatting problem requires that we read from file *word.in* and write
    to file *word.out*. Before we can do those things, though, we need to learn how
    to open files in our programs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 《文章格式化》问题要求我们从 *word.in* 文件中读取，并将输出写入 *word.out* 文件。不过，在我们做这些事情之前，我们需要学习如何在程序中打开文件。
- en: Opening a File
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打开文件
- en: Using your text editor, create a new file called *word.in*. Put that file in
    the same directory that you’ve been using for your *.py* Python programs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本编辑器创建一个名为 *word.in* 的新文件。将该文件放在你用来存放 *.py* Python 程序的相同目录下。
- en: This is the first time that we’re creating a file that doesn’t end with *.py*.
    Instead, it ends with *.in*. Be sure to name the file *word.in*, not *word.py*.
    The *in* is short for input; you’ll see it used often for files that contain input
    for a program.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次创建一个不以 *.py* 结尾的文件。相反，它以 *.in* 结尾。请确保将文件命名为 *word.in*，而不是 *word.py*。*in*
    是输入的缩写；你会经常看到它用于包含程序输入的文件。
- en: 'In that file, let’s place valid input for the Essay Formatting problem. Enter
    the following into the file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们将为论文格式化问题输入有效内容。请将以下内容输入文件：
- en: 12 13
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 12 13
- en: perhaps better poetry will be written in the language of digital computers
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更好的诗歌将在数字计算机的语言中写成
- en: Save the file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'To open the file in Python, we use the open function. We pass two arguments:
    the first is the filename, and the second is the mode in which to open the file.
    The mode determines how we can interact with the file.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Python 中打开文件，我们使用 open 函数。我们传递两个参数：第一个是文件名，第二个是打开文件的模式。模式决定了我们如何与文件进行交互。
- en: 'Here’s how we can open *word.in*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何打开 *word.in*：
- en: '>>> open(''word.in'', ''r'')'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> open(''word.in'', ''r'')'
- en: ❶ <_io.TextIOWrapper name='word.in' mode='r' encoding='cp1252'>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ <_io.TextIOWrapper name='word.in' mode='r' encoding='cp1252'>
- en: In this function call, we’ve provided a mode of 'r'. The r stands for “read”
    and opens the file so that we can read from it. The mode happens to be an optional
    parameter whose default is 'r', so we can leave it out if we like. But I’ll explicitly
    include the 'r' throughout the book for consistency.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数调用中，我们提供了 'r' 模式。r 代表“读取”，并打开文件以便我们从中读取。模式是一个可选参数，其默认值是 'r'，所以我们可以选择不写。但为了保持一致性，我会在本书中明确包含
    'r'。
- en: When we use open, Python gives us some information about how the file was opened
    ❶. For example, it confirms the filename and mode. The bit about encoding indicates
    how the file was decoded from its state on disk into a form that we can read.
    Files can be encoded using a variety of encodings, but we don’t need to worry
    about encodings in this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 open 时，Python 会提供一些关于文件打开方式的信息 ❶。例如，它会确认文件名和模式。关于编码的部分表示文件如何从磁盘上的状态解码为我们可以读取的形式。文件可以使用多种编码方式进行编码，但在本书中我们不需要担心编码问题。
- en: 'If we try to open a file for reading that doesn’t exist, we get an error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试打开一个不存在的文件进行读取，就会得到一个错误：
- en: '>>> open(''blah.in'', ''r'')'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> open(''blah.in'', ''r'')'
- en: 'Traceback (most recent call last):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，位于 <module>
- en: 'FileNotFoundError: [Errno 2] No such file or directory: ''blah.in'''
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'FileNotFoundError: [Errno 2] 没有那个文件或目录: ''blah.in'''
- en: If you’re getting this error when opening *word.in*, double-check that the file
    is named correctly and in the directory from which you started Python.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在打开 *word.in* 时遇到此错误，请仔细检查文件名是否正确，且文件是否位于你启动 Python 时的目录中。
- en: In addition to mode 'r' for reading, there’s mode 'w' for writing. If we use
    'w', then we’re opening a file so that we can put text in it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 'r' 模式用于读取，还有 'w' 模式用于写入。如果我们使用 'w'，则表示我们正在打开一个文件，以便向其中写入文本。
- en: Be careful with mode 'w'. If you use 'w' with a file that already exists, the
    contents of that file will be deleted. I just accidentally did that with my *word.in*
    file. No big deal, because it was easy to re-create. But no one would be happy
    if we accidentally overwrote an important file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用 'w' 模式。如果你用 'w' 打开一个已存在的文件，那个文件的内容会被删除。我刚刚就不小心用 'w' 打开了我的 *word.in* 文件。没关系，因为很容易重新创建它。但是如果我们不小心覆盖了一个重要文件，那可就糟了。
- en: If you use 'w' with a filename that doesn’t exist, it creates an empty file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 'w' 打开一个不存在的文件，它会创建一个空文件。
- en: 'Let’s use mode ''w'' to create an empty file called *blah.in*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 'w' 模式创建一个空文件，名为 *blah.in*：
- en: '>>> open(''blah.in'', ''w'')'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> open(''blah.in'', ''w'')'
- en: <_io.TextIOWrapper name='blah.in' mode='w' encoding='cp1252'>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <_io.TextIOWrapper name='blah.in' mode='w' encoding='cp1252'>
- en: 'Now that *blah.in* exists, we can open it for reading without getting an error:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 *blah.in* 文件已经存在，我们可以打开它进行读取而不会出错：
- en: '>>> open(''blah.in'', ''r'')'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> open(''blah.in'', ''r'')'
- en: <_io.TextIOWrapper name='blah.in' mode='r' encoding='cp1252'>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <_io.TextIOWrapper name='blah.in' mode='r' encoding='cp1252'>
- en: 'What’s that _io.TextIOWrapper that we keep seeing? That’s the type of the value
    that open returns:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那个我们一直看到的 _io.TextIOWrapper 是什么？那是 open 返回值的类型：
- en: '>>> type(open(''word.in'', ''r''))'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(open(''word.in'', ''r''))'
- en: <class '_io.TextIOWrapper'>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <class '_io.TextIOWrapper'>
- en: Think of this type as a file type. Its values represent open files, and you’ll
    see shortly that it has methods that we can call.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个类型视为文件类型。它的值表示已打开的文件，你会很快看到它有一些我们可以调用的方法。
- en: As with any function, if we don’t assign what open returns to a variable, then
    its return value is lost. The way we’ve been calling open so far doesn’t give
    us any way to refer to the file that we’ve opened!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何函数一样，如果我们没有将 open 返回的结果赋值给变量，那么它的返回值会丢失。到目前为止，我们调用 open 的方式并没有给我们提供任何方式来引用我们打开的文件！
- en: 'Here’s how we can make a variable refer to an open file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以让变量引用打开文件的方式：
- en: '>>> input_file = open(''word.in'', ''r'')'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file = open(''word.in'', ''r'')'
- en: '>>> input_file'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file'
- en: <_io.TextIOWrapper name='word.in' mode='r' encoding='cp1252'>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <_io.TextIOWrapper name='word.in' mode='r' encoding='cp1252'>
- en: We’ll be able to use input_file to read from 'word.in'.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 input_file 从 'word.in' 中读取数据。
- en: 'When solving Essay Formatting, we’ll also need a way to write to file ''word.out''.
    Here’s a variable that will help us do that:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决 Essay Formatting 时，我们还需要一种方式将内容写入文件 'word.out'。以下是一个有助于我们完成这项任务的变量：
- en: '>>> output_file = open(''word.out'', ''w'')'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file = open(''word.out'', ''w'')'
- en: '>>> output_file'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file'
- en: <_io.TextIOWrapper name='word.out' mode='w' encoding='cp1252'>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <_io.TextIOWrapper name='word.out' mode='w' encoding='cp1252'>
- en: Reading from a File
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: To read a line from an open file, we use the file’s readline method. That method
    returns a string containing the contents of the next line of the file. In that
    way, it’s similar to the input function. Unlike input, however, readline reads
    from a file rather than from standard input.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要从已打开的文件中读取一行，我们使用文件的 readline 方法。该方法返回一个字符串，包含文件中下一行的内容。从这个角度来看，它类似于 input
    函数。然而，与 input 不同，readline 是从文件中读取数据，而不是从标准输入读取。
- en: 'Let’s open *word.in* and read its two lines:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 *word.in* 并读取它的两行：
- en: '>>> input_file = open(''word.in'', ''r'')'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file = open(''word.in'', ''r'')'
- en: '>>> input_file.readline()'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file.readline()'
- en: '''12 13\n'''
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '''12 13\n'''
- en: '>>> input_file.readline()'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file.readline()'
- en: '''perhaps better poetry will be written in the language of digital computers\n'''
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '''或许更好的诗歌将会用数字计算机的语言写成\n'''
- en: 'What’s unexpected here is the \n at the end of each string. We certainly didn’t
    see that when using input to read a line. The \ symbol in a string is an *escape
    character*. It escapes from the standard interpretation of characters and changes
    their meaning. We don’t treat \n as the two separate characters \ and n. Instead,
    \n is just one character: a newline character. All lines in a file, perhaps except
    for the last, end with a newline character. If they didn’t, then everything would
    be on a single line! The readline method is literally giving us the entire line,
    including its terminating newline character.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里意外的是每个字符串末尾的 \n。我们在使用 input 读取一行时显然没有看到这个。字符串中的 \ 符号是 *转义字符*。它跳脱了字符的标准解释并改变了其含义。我们不把
    \n 当作两个独立的字符 \ 和 n 来处理。相反，\n 就是一个字符：换行符。文件中的所有行，除了最后一行，都会以换行符结束。如果没有换行符，所有内容就会被挤到一行！readline
    方法字面上返回的是整行内容，包括它的结束换行符。
- en: 'Here’s how we can embed newlines in our own strings:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以如何在字符串中嵌入换行符：
- en: '>>> ''one\ntwo\nthree'''
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''one\ntwo\nthree'''
- en: '''one\ntwo\nthree'''
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '''one\ntwo\nthree'''
- en: '>>> print(''one\ntwo\nthree'')'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(''one\ntwo\nthree'')'
- en: one
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: one
- en: two
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: two
- en: three
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: three
- en: The Python shell doesn’t process the effects of escape characters, but print
    does.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Python shell 不处理转义字符的效果，但 print 会。
- en: 'The \n sequence is useful in strings because it helps us add multiple lines.
    But we rarely want those newlines in the lines that we read from files. To get
    rid of them, we can use the string rstrip method. This method is like strip except
    that it removes whitespace only from the right of a string (not the left). As
    far as it’s concerned, newlines are whitespace just like spaces:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: \n 序列在字符串中非常有用，因为它帮助我们添加多行内容。但我们很少希望从文件中读取的行包含这些换行符。为了去除它们，我们可以使用字符串的 rstrip
    方法。这个方法类似于 strip，不过它只会从字符串的右边（而不是左边）去除空白字符。对于它而言，换行符就像空格一样是空白字符：
- en: '>>> ''hello\nthere\n\n'''
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''hello\nthere\n\n'''
- en: '''hello\nthere\n\n'''
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '''hello\nthere\n\n'''
- en: '>>> ''hello\nthere\n\n''.rstrip()'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''hello\nthere\n\n''.rstrip()'
- en: '''hello\nthere'''
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '''hello\nthere'''
- en: 'Let’s try reading from the file again, this time stripping out the newlines:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再尝试从文件中读取一次，这次去掉换行符：
- en: '>>> input_file = open(''word.in'', ''r'')'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file = open(''word.in'', ''r'')'
- en: '>>> input_file.readline().rstrip()'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file.readline().rstrip()'
- en: '''12 13'''
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '''12 13'''
- en: '>>> input_file.readline().rstrip()'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file.readline().rstrip()'
- en: '''perhaps better poetry will be written in the language of digital computers'''
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '''或许更好的诗歌将会用数字计算机的语言写成'''
- en: At this point, we’ve read the two lines, so there’s nothing left to read from
    the file. The readline method signals this by returning an empty string.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经读取了两行，因此文件中没有剩余内容可读。readline 方法通过返回一个空字符串来标识这一点。
- en: '>>> input_file.readline().rstrip()'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file.readline().rstrip()'
- en: ''''''
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ''''''
- en: The empty string means that we’ve reached the end of the file. If we want to
    read the lines again, we must reopen the file to start at its beginning.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 空字符串意味着我们已经到达了文件的末尾。如果我们想再次读取这些行，必须重新打开文件，从头开始。
- en: 'Let’s do that, this time saving each line using variables:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这么做，这次使用变量保存每一行：
- en: '>>> input_file = open(''word.in'', ''r'')'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file = open(''word.in'', ''r'')'
- en: '>>> first = input_file.readline().rstrip()'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first = input_file.readline().rstrip()'
- en: '>>> second = input_file.readline().rstrip()'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> second = input_file.readline().rstrip()'
- en: '>>> first'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> first'
- en: '''12 13'''
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '''12 13'''
- en: '>>> second'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> second'
- en: '''perhaps better poetry will be written in the language of digital computers'''
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '''也许更好的诗歌将用数字计算机的语言写成'''
- en: 'If we need to read all of the lines from a file, no matter how many there are,
    we can use a for loop. Files in Python act as sequences of lines, so we can loop
    over them just like we loop over strings and lists:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要读取文件中的所有行，不管有多少行，我们可以使用 for 循环。Python 中的文件就像是行的序列，我们可以像遍历字符串和列表一样遍历它们：
- en: '>>> input_file = open(''word.in'', ''r'')'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file = open(''word.in'', ''r'')'
- en: '>>> for line in input_file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for line in input_file:'
- en: '...     print(line.rstrip())'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(line.rstrip())'
- en: '...'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 12 13
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 12 13
- en: perhaps better poetry will be written in the language of digital computers
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更好的诗歌将用数字计算机的语言写成。
- en: 'Unlike a string or loop, though, we can’t loop over the file a second time,
    because the first one takes us to its end. If we try, we get nothing:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串或循环不同，我们不能再次遍历文件，因为第一次遍历已经将我们带到了文件的末尾。如果我们再试一次，什么也得不到：
- en: '>>> for line in input_file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for line in input_file:'
- en: '...     print(line.rstrip())'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(line.rstrip())'
- en: '...'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '**CONCEPT CHECK**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: We want to use a while loop to output each line of the open file input_file.
    (The file could be any file; I’m not assuming that it’s related to Essay Formatting.)
    Which of the following pieces of code correctly does this?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用 while 循环输出打开的文件 input_file 中的每一行。（该文件可以是任何文件；我并不假设它与《论文格式化》有关。）以下哪段代码正确地实现了这一点？
- en: A.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: A.
- en: 'while input_file.readline() != '''':'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'while input_file.readline() != '''':'
- en: print(input_file.readline().rstrip())
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: print(input_file.readline().rstrip())
- en: B.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: B.
- en: line = 'x'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: line = 'x'
- en: 'while line != '''':'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'while line != '''':'
- en: line = input_file.readline()
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: line = input_file.readline()
- en: print(line.rstrip())
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: print(line.rstrip())
- en: C.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: C.
- en: line = input_file.readline()
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: line = input_file.readline()
- en: 'while line != '''':'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'while line != '''':'
- en: line = input_file.readline()
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: line = input_file.readline()
- en: print(line.rstrip())
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: print(line.rstrip())
- en: D. All of the above
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: D. 上述所有选项
- en: E. None of the above
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: E. 以上皆非
- en: Before looking at the answer, I encourage you to create a file with four or
    five lines in it and try each piece of code on the file. You might also consider
    adding a character like * to the beginning of each line that’s output so that
    you can see any otherwise blank lines.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看答案之前，我建议你创建一个包含四五行内容的文件，并在该文件上尝试每段代码。你还可以考虑在每行输出的开头加一个像 * 这样的字符，以便你能看到任何原本是空白的行。
- en: 'Answer: E. Each piece of code has a subtle error.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：E. 每段代码都有一个微妙的错误。
- en: Code A outputs only every other line of the file. For example, the while loop’s
    Boolean expression causes the first line to be read . . . and lost, because it
    isn’t assigned to a variable. The first iteration of the loop therefore outputs
    the second line of the file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 A 只输出文件的每隔一行。例如，while 循环的布尔表达式使得第一行被读取……但丢失了，因为它没有被赋值给一个变量。循环的第一次迭代因此输出文件的第二行。
- en: Code B comes very close to doing the right thing. It outputs all the lines of
    the file, but also outputs an extraneous blank line at the end.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 B 非常接近正确的做法。它输出了文件的所有行，但也在末尾输出了一个多余的空白行。
- en: Code C fails to print the first line of the file. That’s because the first line
    is read before the loop, but then the loop reads the second line without having
    printed the first. It also produces an extraneous blank line at the end, just
    like code B.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 C 未能打印文件的第一行。原因是第一行在循环之前被读取，但循环接着读取第二行，而没有打印第一行。它还会像代码 B 一样在末尾输出一个多余的空白行。
- en: 'Here’s correct code to read and print each line:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是正确的代码来读取并打印每一行：
- en: line = input_file.readline()
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: line = input_file.readline()
- en: 'while line != '''':'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'while line != '''':'
- en: print(line.rstrip())
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: print(line.rstrip())
- en: line = input_file.readline()
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: line = input_file.readline()
- en: Writing to a File
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 写入文件
- en: To write a line to an open file, we use the file’s write method. We pass it
    a string, and that string is added to the end of the file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要写一行到一个打开的文件中，我们使用文件的 write 方法。我们传递一个字符串，这个字符串会被添加到文件的末尾。
- en: 'To solve Essay Formatting, we’ll write to *word.out*. We’re not ready to solve
    that problem yet, so let’s instead write to *blah.out*. Here’s how we can write
    one line to that file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决作文格式化问题，我们将写入*word.out*。但我们还没有准备好解决这个问题，所以我们暂时写入*blah.out*。下面是我们如何将一行写入该文件：
- en: '>>> output_file = open(''blah.out'', ''w'')'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file = open(''blah.out'', ''w'')'
- en: '>>> output_file.write(''hello'')'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file.write(''hello'')'
- en: '5'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: What’s that 5 doing there? The write method returns the number of characters
    written. It’s good confirmation that we’ve written the quantity of text that we
    expected to write.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那个5是怎么回事？`write`方法返回写入的字符数。这是确认我们确实写入了预期的文本量的好方法。
- en: If you open *blah.out* in your text editor, you should see the text hello in
    there.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在文本编辑器中打开*blah.out*，你应该会看到里面有文本hello。
- en: 'Let’s try writing three lines to the file. Here goes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试向文件写入三行。开始吧：
- en: '>>> output_file = open(''blah.out'', ''w'')'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file = open(''blah.out'', ''w'')'
- en: '>>> output_file.write(''sq'')'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file.write(''sq'')'
- en: '2'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> output_file.write(''ui'')'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file.write(''ui'')'
- en: '2'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '>>> output_file.write(''sh'')'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file.write(''sh'')'
- en: '2'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 'Based on what I’ve told you so far, you might expect *blah.out* to look like
    this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我到目前为止告诉你的内容，你可能会期望*blah.out*看起来像这样：
- en: sq
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: sq
- en: ui
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ui
- en: sh
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: sh
- en: 'But if you open *blah.out* in your text editor, you should instead see the
    following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你在文本编辑器中打开*blah.out*，你应该会看到以下内容：
- en: squish
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: squish
- en: 'The characters are on a single line like that because write doesn’t add newlines
    for us! If we want separate lines, we need to be explicit, like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 字符会在同一行上，因为`write`不会为我们添加换行符！如果我们希望分开行，我们需要显式地这样做：
- en: '>>> output_file = open(''blah.out'', ''w'')'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file = open(''blah.out'', ''w'')'
- en: '>>> output_file.write(''sq\n'')'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file.write(''sq\n'')'
- en: '3'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '>>> output_file.write(''ui\n'')'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file.write(''ui\n'')'
- en: '3'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '>>> output_file.write(''sh\n'')'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file.write(''sh\n'')'
- en: '3'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 'Notice in each case that write writes three characters, not two. The newline
    counts as a character. Now if you open *blah.out* in your text editor, you should
    see the text spread across three lines:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在每个例子中，`write`写入了三个字符，而不是两个。换行符也算作一个字符。现在如果你在文本编辑器中打开*blah.out*，你应该会看到文本分布在三行上：
- en: sq
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: sq
- en: ui
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ui
- en: sh
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: sh
- en: 'Unlike print, write works only if you call it with a string. To write a number
    to a file, convert it to a string first:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与`print`不同，`write`只有在你传入一个字符串时才有效。要将数字写入文件，首先将其转换为字符串：
- en: '>>> num = 7788'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> num = 7788'
- en: '>>> output_file = open(''blah.out'', ''w'')'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file = open(''blah.out'', ''w'')'
- en: '>>> output_file.write(str(num) + ''\n'')'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> output_file.write(str(num) + ''\n'')'
- en: '5'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: Closing Files
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关闭文件
- en: It’s good practice to close a file once you’re done with it. It signals to readers
    of your code that the file is no longer being used.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 养成在完成操作后关闭文件的好习惯。这告诉你的代码的读者，文件已经不再使用。
- en: Closing files also helps your operating system manage your computer’s resources.
    When you use the write method, what you write may not end up in the file immediately.
    Rather, Python or your operating system might wait until it has a bunch of write
    requests and then write them all at once. Closing a file that you wrote to guarantees
    that what you wrote to the file is safely stored in the file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭文件还有助于操作系统管理计算机的资源。当你使用`write`方法时，你写入的内容可能不会立即写入文件。相反，Python或你的操作系统可能会等到有一堆写入请求，然后一次性将它们写入。关闭一个你曾写入的文件能确保你写入的内容安全地存储在文件中。
- en: 'To close a file, call its close method. Here’s an example of opening a file,
    reading a line, and closing it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭文件，调用其`close`方法。下面是打开文件、读取一行并关闭它的示例：
- en: '>>> input_file = open(''word.in'', ''r'')'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file = open(''word.in'', ''r'')'
- en: '>>> input_file.readline()'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file.readline()'
- en: '''12 13\n'''
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '''12 13\n'''
- en: '>>> input_file.close()'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file.close()'
- en: 'Once you’ve closed a file, you can no longer read from or write to the file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦关闭文件，你就不能再从文件中读取或写入：
- en: '>>> input_file.readline()'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file.readline()'
- en: 'Traceback (most recent call last):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: File "<stdin>", line 1, in <module>
- en: 'ValueError: I/O operation on closed file.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'ValueError: 在已关闭的文件上进行I/O操作。'
- en: Solving the Problem
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: Back to Essay Formatting. Now we know how to read from *word.in* and write to
    *word.out*. That takes care of the input and output requirements. It’s time to
    tackle the problem itself.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 回到作文格式化问题。现在我们知道如何从*word.in*读取并写入*word.out*了。这就处理了输入和输出的要求。接下来是解决问题本身。
- en: Let’s start by exploring a test case to make sure we know how to solve this
    problem. Then we’ll see the code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过探索一个测试用例来确保我们知道如何解决这个问题。然后我们再看代码。
- en: Exploring a Test Case
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: 'Here’s the *word.in* file I’ve been using:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我一直在使用的*word.in*文件：
- en: 12 13
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 12 13
- en: perhaps better poetry will be written in the language of digital computers
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更好的诗歌将用数字计算机的语言来写作
- en: There are 12 words, and the maximum number of characters on a line (not counting
    spaces) is 13\. We should add words to the current line as long as they fit; once
    a word doesn’t fit, we’ll start a new line with that word.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有12个单词，且每行的最大字符数（不包括空格）是13。我们应该尽可能将单词添加到当前行，只要它们适合；一旦一个单词无法放入当前行，我们就从下一个新行开始，并将该单词放入新行。
- en: The word perhaps contains seven characters, so it fits on the first line. The
    word better contains six characters. We can put that on the first line, too; with
    perhaps already there, we’re at a total of 13 characters (not including the space
    between the two words).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单词perhaps包含七个字符，所以它可以放在第一行。单词better包含六个字符。它也能放在第一行；已经有perhaps在这里，我们一共是13个字符（不包括两个单词之间的空格）。
- en: The word poetry can’t go on the first line, so we start a new line with poetry
    as its first word. The word will fits next to poetry on the second line. Similarly,
    be fits next to will. We’re at 12 nonspace characters so far. Now we have the
    word written, and with only one character of room on line 2, we’re forced to start
    the next line with written as its first word.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 单词poetry不能放在第一行，所以我们从新的一行开始，poetry作为第一单词。这个单词will可以紧接着poetry放在第二行。同样，be可以紧接will放置。到目前为止我们已经有了12个非空格字符。现在我们有了单词written，由于第二行只剩下一个字符的位置，我们被迫从新的一行开始，written作为第一单词。
- en: 'Following this process to the end, the full essay that we need to write to
    *word.out* is this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个过程一直走下去，我们需要写到*word.out*的完整文章是这样的：
- en: perhaps better
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更好
- en: poetry will be
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 诗歌将是
- en: written in the
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 写在
- en: language of
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 语言
- en: digital
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 数字
- en: computers
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机
- en: The Code
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: Our solution is in [Listing 7-1](ch07.xhtml#ch07ex01).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案在[列表7-1](ch07.xhtml#ch07ex01)中。
- en: ❶ input_file = open('word.in', 'r')
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ input_file = open('word.in', 'r')
- en: ❷ output_file = open('word.out', 'w')
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ output_file = open('word.out', 'w')
- en: ❸ lst = input_file.readline().split()
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ lst = input_file.readline().split()
- en: n = int(lst[0])  # n not needed
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'n = int(lst[0])  # n 不需要'
- en: k = int(lst[1])
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: k = int(lst[1])
- en: words = input_file.readline().split()
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: words = input_file.readline().split()
- en: ❹ line = ''
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ line = ''
- en: chars_on_line = 0
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: chars_on_line = 0
- en: 'for word in words:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '对于每个单词 in words:'
- en: '❺ if chars_on_line + len(word) <= k:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '❺ 如果 chars_on_line + len(word) <= k:'
- en: line = line + word + ' '
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: line = line + word + ' '
- en: chars_on_line = chars_on_line + len(word)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: chars_on_line = chars_on_line + len(word)
- en: 'else:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: ❻ output_file.write(line[:-1] + '\n')
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ output_file.write(line[:-1] + '\n')
- en: line = word + ' '
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: line = word + ' '
- en: chars_on_line = len(word)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: chars_on_line = len(word)
- en: ❼ output_file.write(line[:-1] + '\n')
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ output_file.write(line[:-1] + '\n')
- en: input_file.close()
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: '*Listing 7-1: Solving Essay Formatting*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-1：解决文章格式问题*'
- en: 'To begin, we open the input file ❶ and output file ❷. Notice the modes: we
    open the input file with mode ''r'' (for reading) and open the output file with
    mode ''w'' (for writing). We could have opened the output file a little later,
    right before we use it, but I’ve chosen to open both files here to simplify the
    organization of the program. Similarly, we could close a file as soon as we no
    longer need it, but in this book, I’ve chosen to close all files together at the
    end of the program. For long-running programs that manipulate many files, you
    likely want to keep files open only when needed.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们打开输入文件 ❶ 和输出文件 ❷。注意模式：我们以'r'模式（读取）打开输入文件，以'w'模式（写入）打开输出文件。我们也可以稍后再打开输出文件，正好在我们需要它的时候，但我选择在这里同时打开两个文件，以简化程序的组织。同样的，我们可以在不再需要文件时立即关闭它们，但在本书中，我选择在程序结束时一起关闭所有文件。对于长时间运行且操作多个文件的程序，你可能只希望在需要时才保持文件打开。
- en: 'Next, we read the first line of the input file ❸. This line contains two space-separated
    integers: n, the number of words, and k, the maximum number of allowed characters
    (not counting spaces) per line. As always with space-separated values, we use
    split to separate them. We then read the second line, which contains the essay
    words. Again we use split, this time to split the string of words into a list
    of words. That takes care of the input.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们读取输入文件的第一行 ❸。这一行包含两个由空格分隔的整数：n，单词的数量，以及k，每行允许的最大字符数（不包括空格）。像往常一样，使用split来分割这些值。然后我们读取第二行，这一行包含文章的单词。我们再次使用split，这次是将单词的字符串分割成一个单词列表。这就完成了输入的处理。
- en: 'Two variables drive the main portion of the program: line and chars_on_line.
    The line variable refers to the current line; we start out with it referring to
    the empty string ❹. The chars_on_line variable refers to the number of characters,
    not counting spaces, on the current line.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个变量驱动程序的主要部分：line和chars_on_line。line变量表示当前行；我们从让它指向空字符串❹开始。chars_on_line变量表示当前行上的字符数，不包括空格。
- en: You may wonder why I’m maintaining chars_on_line at all. Couldn’t we just use
    len(line) instead? Well, if we did that, we’d be including spaces in our count,
    and spaces don’t count toward the number of characters allowed per line. We could
    fix that by subtracting the count of spaces, and I encourage you to try that on
    your own if you find it more intuitive than keeping the chars_on_line variable
    in there.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我要维护chars_on_line。我们不可以直接使用len(line)吗？嗯，如果这样做，我们会将空格也计入在内，而空格不计入每行允许的字符数。我们可以通过减去空格的数量来解决这个问题，如果你觉得这样更直观，而不是保持chars_on_line变量在那里的话，我鼓励你自己试试看。
- en: Now it’s time to loop through all of the words. For each word, we have to determine
    whether it goes on the current line or next line.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候遍历所有单词了。对于每个单词，我们需要确定它是放在当前行还是下一行。
- en: If the number of nonspace characters on the current line plus the number of
    characters in the current word is at most k, then the current word fits on the
    current line ❺. In that case, we add the word plus a space to the current line
    and update the number of nonspace characters on the line.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前行上的非空字符数量加上当前单词的字符数量最多为k，那么当前单词可以放入当前行❺。在这种情况下，我们将单词和一个空格添加到当前行，并更新当前行上的非空字符数量。
- en: Otherwise, the current word doesn’t fit on the current line. The current line
    is done! We therefore write the line to the output file ❻ and update the line
    and chars_on_line variables to reflect that this is the only word on the now-current
    line.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，当前单词不能放入当前行。当前行已结束！因此，我们将当前行写入输出文件❻，并更新line和chars_on_line变量，以反映这是现在的唯一单词所在的当前行。
- en: 'There are two things to note about the write call ❻. First, the [:-1] slice
    is in there to prevent us from outputting the space that follows the last word
    on the line. Second, you may have expected me to use an f-string here, like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 关于write调用❻，有两点需要注意。首先，[ :-1 ]切片是用来防止我们输出行末尾跟随的空格。其次，你可能期待我在这里使用f-string，像这样：
- en: output_file.write(f'{line[:-1]}\n')
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.write(f'{line[:-1]}\n')
- en: However, at the time of writing, the USACO judge is running an older version
    of Python that doesn’t support f-strings.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，写作时，USACO评测器正在运行一个较旧版本的Python，这个版本不支持f-string。
- en: Why are we outputting line after the loop ends ❼? The reason is that each iteration
    of the for loop is guaranteed to leave line with one or more words that we have
    not output yet. Consider what happens with each word that we process. If the current
    word fits on the current line, we don’t output anything. If the current word doesn’t
    fit on the current line, then we output the current line, but not the word on
    the next line. We therefore need to write line to the output file *after* the
    loop ❼; otherwise, the last line in the essay will be lost.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在循环结束后我们要输出line❼？原因是每次for循环迭代结束时，line中都会留下一个或多个尚未输出的单词。考虑我们处理每个单词时发生的情况。如果当前单词可以放入当前行，我们什么都不输出。如果当前单词不能放入当前行，那么我们会输出当前行，但不会输出下行的单词。因此，我们需要在循环后将line写入输出文件❼；否则，文章的最后一行会丢失。
- en: The final thing we do is close both files.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们关闭两个文件。
- en: One annoying aspect of writing to a file rather than the screen is that we aren’t
    shown the output when we run the program. To see the output, we have to open the
    output file in our text editor.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据写入文件而不是屏幕的一个烦人之处是，当我们运行程序时，看不到输出。为了查看输出，我们必须在文本编辑器中打开输出文件。
- en: 'Here’s a tip: develop the program using print calls rather than write calls
    so that all output goes to the screen. That should make it easier to find errors
    in your program and avoid having to switch back and forth between your code and
    the output file. Once you’re happy with the code, you can change the print calls
    back to write calls. Then be sure to do a little more testing, just to make sure
    that everything ends up in the file as it should.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小提示：在开发程序时，使用print调用而不是write调用，这样所有输出都会显示在屏幕上。这应该能让你更容易找到程序中的错误，并避免在代码和输出文件之间来回切换。一旦你对代码满意了，就可以把print调用改回write调用。然后，一定要进行更多的测试，确保一切都正确地写入文件中。
- en: We’re ready to submit to the USACO judge. Send it our code! All test cases should
    pass.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好提交给USACO评测员了。把我们的代码提交给他们吧！所有测试用例都应该通过。
- en: 'Problem #17: Farm Seeding'
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题#17：农场播种
- en: We can use a loop to read a specified number of lines from a file. We’ll do
    that in this problem, and we’ll see that it’s similar to using a loop with input
    to read from standard input.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用循环从文件中读取指定数量的行。在这个问题中我们会这么做，而且我们会发现它和使用循环从标准输入中读取输入非常相似。
- en: In [Chapter 6](ch06.xhtml#ch06), when we solved Action Figures, we learned about
    top-down design using functions. It’s an important skill, composing multiple functions
    to solve a problem. And since there isn’t much more to say about files, I’ve chosen
    a problem that doubles as a site for top-down design.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.xhtml#ch06)中，当我们解决“动作人偶”问题时，我们学习了如何使用函数进行自顶向下的设计。这是一项重要技能，能够通过组合多个函数来解决问题。由于关于文件的内容不多，我选择了一个问题，它同时也是自顶向下设计的一个应用场景。
- en: This is a challenging problem. We’ll first need to understand exactly what we’re
    being asked to do. After that, we’ll need to develop a way to solve the problem
    and think carefully about why our solution is correct.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有挑战性的问题。我们首先需要明确我们被要求做什么。之后，我们需要开发一种解决问题的方法，并仔细思考我们的解决方案为何是正确的。
- en: This is USACO 2019 February Bronze Contest problem The Great Revegetation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是USACO 2019年2月青铜竞赛问题“伟大的再生草”。
- en: The Challenge
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Farmer John has *n* pastures, all of which he would like to seed with grass.
    The pastures are numbered 1, 2, . . ., *n*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Farmer John有*n*个牧场，所有这些牧场他都希望种植草种。这些牧场的编号为1、2、……、*n*。
- en: Farmer John has four different types of grass seed, numbered 1, 2, 3, and 4\.
    He’ll choose one of these grass types for each pasture.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Farmer John有四种不同类型的草种，编号为1、2、3和4。他将从中选择一种草种类型用于每个牧场。
- en: Farmer John also has *m* cows. Each cow has two favorite pastures in which it
    eats grass. Each cow cares only about its two favorite pastures, no others. For
    a healthy diet, each cow requires that its two pastures have different types of
    grass. For example, for some given cow, it would be okay if one of its pastures
    had grass type 1 and the other had grass type 4\. But it would not be okay if
    both of its pastures had grass type 1.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Farmer John还拥有*m*头牛。每头牛有两个最喜欢的牧场，在这些牧场中它吃草。每头牛只关心它的两个最喜欢的牧场，其他牧场不关心。为了保持健康的饮食，每头牛要求它的两个牧场使用不同类型的草种。例如，对于某头牛来说，如果其中一个牧场的草种类型为1，另一个牧场的草种类型为4，那是可以的。但如果两个牧场的草种类型都是1，那就是不允许的。
- en: A pasture might be the favorite of more than one cow. But it’s guaranteed that
    a pasture is the favorite of no more than three cows.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一个牧场可能是多头牛的最爱。但保证一个牧场最多只有三头牛最喜欢。
- en: Determine the grass type to use in each pasture. Each pasture is required to
    use a grass type between 1 and 4, and each cow’s two favorite pastures must have
    different grass types.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 确定每个牧场使用的草种类型。每个牧场需要使用1到4之间的某种草种类型，而且每头牛的两个最喜欢的牧场必须使用不同的草种类型。
- en: Input
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *revegetate.in*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为*revegetate.in*的文件中读取输入。
- en: 'The input consists of the following lines:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由以下几行组成：
- en: A line containing two integers separated by a space. The first integer is *n*,
    the number of pastures; it’s between 2 and 100\. The second integer is *m*, the
    number of cows; it’s between 1 and 150.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含两个整数，用空格分隔。第一个整数是*n*，表示牧场的数量；它的值介于2和100之间。第二个整数是*m*，表示牛的数量；它的值介于1和150之间。
- en: '*m* lines, each of which gives the two favorite pasture numbers for a cow.
    These pasture numbers are integers between 1 and *n* and are separated by a space.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m*行，每行给出一头牛最喜欢的两个牧场编号。这些牧场编号是介于1和*n*之间的整数，并且用空格分隔。'
- en: Output
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *revegetate.out*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 输出写入名为*revegetate.out*的文件中。
- en: Output a valid way to seed the pastures. The output is a line of *n* characters,
    each of which is a '1', '2', '3', or '4'. The first character is the grass type
    for pasture 1, the second is the grass type for pasture 2, and so on.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 输出一种有效的牧场播种方式。输出是一行*n*个字符，每个字符是'1'、'2'、'3'或'4'。第一个字符表示牧场1的草种类型，第二个表示牧场2的草种类型，以此类推。
- en: We can interpret these *n* characters as an integer with *n* digits. For example,
    if we have the five grass types '11123', then we can interpret this as the integer
    11123.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这*n*个字符解释为一个具有*n*位数字的整数。例如，如果我们有五个草种类型'11123'，我们可以将其解释为整数11123。
- en: This integer interpretation comes into play when we have a choice of what to
    output. If there are multiple valid ways to seed the pastures, we must output
    the one that’s smallest when interpreted as an integer. For example, if both '11123'
    and '22123' are valid, we output the string '11123' because 11123 is less than
    22123.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有选择输出内容时，这种整数解释就起作用了。如果有多种有效的方式来给牧场播种，我们必须输出以整数方式解释后最小的那个。例如，如果'11123'和'22123'都是有效的，我们会输出字符串'11123'，因为11123小于22123。
- en: Exploring a Test Case
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: We’re going to use top-down design to arrive at a solution for this problem.
    Working through a test case will help us sift the tasks.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用自顶向下的设计方法来解决这个问题。通过分析测试用例，我们可以帮助我们筛选任务。
- en: 'Here’s the test case:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试用例：
- en: 8 6
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 8 6
- en: 5 4
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 5 4
- en: 2 4
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 2 4
- en: 3 5
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 3 5
- en: 4 1
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 4 1
- en: 2 1
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 2 1
- en: 5 2
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 5 2
- en: The first line of the test case tells us that we have eight pastures. They’re
    numbered from 1 to 8\. The first line also tells us that we have six cows. The
    problem doesn’t specify a numbering for the cows, so I’ll just number them starting
    at 0\. The two favorite pastures of each cow are in [Table 7-1](ch07.xhtml#ch07tab01)
    for easy reference.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例的第一行告诉我们有八个牧场，它们的编号从 1 到 8。同时第一行还告诉我们有六头奶牛。问题没有为奶牛指定编号，所以我将从编号 0 开始编号。每头奶牛最喜欢的两个牧场列在[表
    7-1](ch07.xhtml#ch07tab01)中，方便参考。
- en: '**Table 7-1:** Farm Seeding Example, Cows'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** 农场播种示例，奶牛'
- en: '| **Cow** | **Pasture 1** | **Pasture 2** |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **奶牛** | **牧场 1** | **牧场 2** |'
- en: '| --- | --- | --- |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 5 | 4 |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 5 | 4 |'
- en: '| 1 | 2 | 4 |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 4 |'
- en: '| 2 | 3 | 5 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | 5 |'
- en: '| 3 | 4 | 1 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 4 | 1 |'
- en: '| 4 | 2 | 1 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2 | 1 |'
- en: '| 5 | 5 | 2 |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 2 |'
- en: In this problem, we’re being asked to make *n* decisions. What grass type should
    we use for pasture 1? What grass type should we use for pasture 2? Pasture 3?
    Pasture 4? And so on, all the way up to pasture *n*. One strategy for these kinds
    of problems is to make one decision at a time, without making a mistake on any
    of them. If we manage to finish with decision *n* and haven’t made any mistakes
    along the way, then our solution must be correct.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们需要做出 *n* 个决策。我们应该为牧场 1 选择哪种草种类型？为牧场 2 选择哪种草种类型？牧场 3 呢？牧场 4 呢？依此类推，直到牧场
    *n*。解决这类问题的一种策略是一次做一个决策，确保每次决策都没有错误。如果我们在做出第 *n* 个决策时没有犯错，那么我们的解答一定是正确的。
- en: Let’s go through the pastures from 1 to 8 and see if we can assign a grass type
    to each of them. We need to prioritize choosing small-numbered grass types so
    that we end with the smallest grass types when interpreted as a number.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从牧场 1 到 8 一一检查，看看是否能为每个牧场分配草种类型。我们需要优先选择编号较小的草种类型，这样当作为数字来解释时，最终的草种类型会尽可能小。
- en: What grass type should we choose for pasture 1? The only cows that care about
    pasture 1 are cows 3 and 4, so we focus only on those two. If we had already chosen
    grass types for some of these cows’ pastures, then we’d have to be careful with
    our choice for pasture 1\. We wouldn’t want to give some cow two pastures with
    the same grass type, because that would break the rules! We haven’t chosen any
    grass types yet, so nothing can go wrong no matter what we choose for pasture
    1\. Since we want the smallest grass types, though, we’ll choose grass type 1.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为牧场 1 选择哪种草种类型？关心牧场 1 的奶牛只有奶牛 3 和奶牛 4，所以我们只需要关注它们。如果我们已经为这些奶牛的某些牧场选择了草种类型，我们就需要小心选择牧场
    1 的草种类型。我们不想给某头奶牛两个相同草种类型的牧场，因为那样会违反规则！不过我们还没有选择任何草种类型，所以无论选择什么，牧场 1 都不会出错。不过，既然我们希望选择最小的草种类型，那么我们选择草种类型
    1。
- en: 'I’ll collect our grass-type decisions in tables. Here’s the decision we just
    made, grass type 1 for pasture 1:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我会将我们的草种类型决策收集到表格中。下面是我们刚才做出的决策，牧场 1 使用草种类型 1：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| **牧场** | **草种类型** |'
- en: '| --- | --- |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: 'Let’s move on. What grass type should we choose for pasture 2? The cows that
    care about pasture 2 are cows 1, 4, and 5, so we focus on those. One of cow 4’s
    pastures is pasture 1, and we chose grass type 1 for that pasture, so grass type
    1 is eliminated as a grass type for pasture 2\. If we used grass type 1 for pasture
    2, then we’d be giving cow 4 two pastures with the same grass type, and that would
    break the rules. Cows 1 and 5, however, don’t eliminate any other grass types,
    because we haven’t chosen grass types for their pastures yet. We therefore choose
    grass type 2, the smallest-numbered grass type that’s available. Here’s where
    we stand:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进。我们应该为牧场 2 选择什么草种？关心牧场 2 的牛是牛 1、牛 4 和牛 5，因此我们聚焦于这几头牛。牛 4 的牧场之一是牧场 1，我们为那个牧场选择了草种
    1，所以草种 1 被排除作为牧场 2 的草种。如果我们为牧场 2 使用草种 1，那么我们将给牛 4 分配两个相同草种的牧场，这违反了规则。然而，牛 1 和牛
    5 不排除任何其他草种，因为我们还没有为它们的牧场选择草种。因此，我们选择草种 2，最小的可用草种。现在的情况是：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| **牧场** | **草种** |'
- en: '| --- | --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 2 |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 |'
- en: 'What grass type should we choose for pasture 3? The only cow that cares about
    pasture 3 is cow 2\. Cow 2’s pastures are pastures 3 and 5\. That cow doesn’t
    eliminate any grass types, however, because we haven’t assigned a grass type to
    pasture 5! To get the smallest number, we’ll use grass type 1 for pasture 3\.
    Here’s our next snapshot:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为牧场 3 选择什么草种？唯一关心牧场 3 的牛是牛 2。牛 2 的牧场是牧场 3 和牧场 5。然而，这头牛并没有排除任何草种，因为我们还没有为牧场
    5 分配草种！为了选出最小的编号，我们为牧场 3 使用草种 1。以下是我们的下一个快照：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| **牧场** | **草种** |'
- en: '| --- | --- |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 2 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 |'
- en: '| 3 | 1 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 |'
- en: I can see three tasks in our top-down design crystallizing here. First, we need
    to obtain the cows that care about the current pasture. Second, we need to determine
    which grass types those cows eliminate from consideration. Third, we need to choose
    the smallest-numbered grass type that wasn’t eliminated. Each of those is a prime
    candidate for a function.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我能看到我们从自上而下的设计中提炼出了三个任务。首先，我们需要获得关心当前牧场的牛。第二，我们需要确定这些牛排除的草种。第三，我们需要选择一个最小编号的未被排除的草种。每一个任务都非常适合成为一个函数。
- en: 'Let’s keep going. We have three cows that care about pasture 4: cows 0, 1,
    and 3\. Cow 0 doesn’t eliminate any grass types, because we haven’t assigned grass
    types to its pastures yet. Cow 1 eliminates grass type 2 because we assigned grass
    type 2 to pasture 2 (its other pasture). And cow 3 eliminates grass type 1 because
    we assigned grass type 1 to pasture 1 (its other pasture). The smallest available
    grass type, then, is 3, so that’s what we use for pasture 4:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进。我们有三头牛关心牧场 4：牛 0、牛 1 和牛 3。牛 0 不排除任何草种，因为我们还没有为它的牧场分配草种。牛 1 排除了草种 2，因为我们为牧场
    2（它的另一个牧场）分配了草种 2。牛 3 排除了草种 1，因为我们为牧场 1（它的另一个牧场）分配了草种 1。那么，最小的可用草种是 3，因此我们为牧场
    4 使用草种 3：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **牧场** | **草种** |'
- en: '| --- | --- |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 2 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 |'
- en: '| 3 | 1 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 |'
- en: '| 4 | 3 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 |'
- en: On to pasture 5\. The cows that care about pasture 5 are cows 0, 2, and 5\.
    Cow 0 eliminates grass type 3; cow 2 eliminates grass type 1; and cow 5 eliminates
    grass type 2\. So grass types 1, 2, and 3 are out. Our only choice is grass type
    4.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 进入牧场 5。关心牧场 5 的牛是牛 0、牛 2 和牛 5。牛 0 排除了草种 3；牛 2 排除了草种 1；牛 5 排除了草种 2。所以草种 1、2 和
    3 被排除。我们唯一的选择是草种 4。
- en: That was close! We almost ran out of grass types there. Lucky for us, there
    was no other cow that cared about pasture 5 and eliminated grass type 4.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 真是差点！我们差点用尽了草种。幸运的是，没有其他牛关心牧场 5 并排除了草种 4。
- en: 'Or, wait. This wasn’t luck at all, because of this bit from the problem description:
    “It’s guaranteed that a pasture is the favorite of no more than three cows.” This
    means that at most three grass types can be eliminated for each pasture. We’ll
    never be stuck! And we don’t even have to worry about the ramifications of past
    choices on our next decision. No matter what we did in the past, we’ll always
    have at least one available grass type.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，等等，这根本不是运气，因为问题描述中有这么一段：“保证每个牧场最多只有三头牛喜欢。”这意味着每个牧场最多会排除三个草种。我们永远不会卡住！我们甚至不需要担心之前的选择对下一个决策的影响。不管我们过去做了什么，我们总会有至少一个可用的草种。
- en: 'Let’s add pasture 5 to our table:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在表格中添加牧场 5：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| **牧场** | **草种** |'
- en: '| --- | --- |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 2 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 |'
- en: '| 3 | 1 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 |'
- en: '| 4 | 3 |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 |'
- en: '| 5 | 4 |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 4 |'
- en: 'There are three pastures to go. But no cow cares about any of them, so we can
    just use grass type 1 in each case. That gives us this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个牧场要处理。但没有牛关心其中任何一个，所以我们可以在每种情况下都使用草地类型1。结果就是：
- en: '| **Pasture** | **Grass type** |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| **牧场** | **草地类型** |'
- en: '| --- | --- |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 2 |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 |'
- en: '| 3 | 1 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1 |'
- en: '| 4 | 3 |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 |'
- en: '| 5 | 4 |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 4 |'
- en: '| 6 | 1 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 1 |'
- en: '| 7 | 1 |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1 |'
- en: '| 8 | 1 |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1 |'
- en: 'We can read the grass types from top to bottom to obtain the correct output
    for this example. The output is as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从上到下读取草地类型，以获得这个例子的正确输出。输出如下：
- en: '12134111'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '12134111'
- en: Top-Down Design
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自上而下设计
- en: With a good understanding of the tasks that we’ll need to complete, we’ll turn
    to a top-down design of this problem.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对我们需要完成的任务有了充分的理解，我们将转向这个问题的自上而下设计。
- en: The Top Level
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 顶层设计
- en: We discovered three tasks in the previous section as we worked through a test
    case. Before our program can solve any of those tasks, we need to read the input,
    so that’s a fourth task. We also need to write the output. That will take some
    thought and a few lines of code, so let’s call that our fifth task.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，当我们处理一个测试用例时，发现了三个任务。在我们的程序能够解决这些任务之前，我们需要先读取输入，这就成了第四个任务。我们还需要编写输出。这将需要一些思考和几行代码，所以我们把它叫做第五个任务。
- en: 'Here are our five main tasks:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们五个主要任务：
- en: Read input.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取输入。
- en: Identify cows that care about current pasture.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定关心当前牧场的牛。
- en: Eliminate grass types for current pasture.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消除当前牧场的草地类型。
- en: Choose smallest-numbered grass type for current pasture.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为当前牧场选择编号最小的草地类型。
- en: Write output.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写输出。
- en: As we did when solving Action Figures in [Chapter 6](ch06.xhtml#ch06), we’ll
    start with a framework of TODO comments and remove each TODO as we solve it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在解决[第六章](ch06.xhtml#ch06)的动作模型时所做的那样，我们将从TODO注释的框架开始，并在解决每个TODO时将其移除。
- en: We begin with mostly comments. Since we’ll need to open the files at the start
    and close them at the end, I’ve also added that code.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始时大部分是注释。由于我们需要在开始时打开文件并在结束时关闭文件，我还加了这段代码。
- en: 'Here’s where we begin:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们开始的地方：
- en: Main Program
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主程序
- en: input_file = open('revegetate.in', 'r')
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: input_file = open('revegetate.in', 'r')
- en: output_file = open('revegetate.out', 'w')
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: output_file = open('revegetate.out', 'w')
- en: 'TODO: Read input'
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'TODO: 读取输入'
- en: 'TODO: Identify cows that care about pasture'
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'TODO: 确定关心牧场的牛'
- en: 'TODO: Eliminate grass types for pasture'
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'TODO: 消除草地类型对于牧场的影响'
- en: 'TODO: Choose smallest-numbered grass type for pasture'
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'TODO: 为牧场选择编号最小的草地类型'
- en: 'TODO: Write output'
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'TODO: 编写输出'
- en: input_file.close()
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: 'Task 1: Read Input'
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务 1：读取输入
- en: 'Reading the first line of input, with the integers *n* and *m*, is something
    we know how to do. It’s straightforward enough that I don’t think we need a function
    for it, so let’s do it directly. Next we need to read the pasture information
    for the *m* cows, and here a function seems warranted. Let’s remove the TODO in
    the Read input comment, handle the first line of input, and call the read_cows
    function, which we’ll write shortly:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 读取输入的第一行，其中包括整数*n*和*m*，这是我们知道如何完成的任务。它足够简单，我认为我们不需要为此写一个函数，所以我们直接进行。接下来，我们需要读取*m*头牛的牧场信息，这时就需要一个函数。让我们去掉“读取输入”注释中的TODO，处理第一行输入，并调用read_cows函数，稍后我们将编写这个函数：
- en: '# Main Program'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '# 主程序'
- en: input_file = open('revegetate.in', 'r')
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: input_file = open('revegetate.in', 'r')
- en: output_file = open('revegetate.out', 'w')
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: output_file = open('revegetate.out', 'w')
- en: '# Read input'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取输入'
- en: lst = input_file.readline().split()
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: lst = input_file.readline().split()
- en: num_pastures = int(lst[0])
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: num_pastures = int(lst[0])
- en: num_cows = int(lst[1])
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: num_cows = int(lst[1])
- en: ❶ favorites = read_cows(input_file, num_cows)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ favorites = read_cows(input_file, num_cows)
- en: '# TODO: Identify cows that care about pasture'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 确定关心牧场的牛'
- en: '# TODO: Eliminate grass types for pasture'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 消除草地类型对于牧场的影响'
- en: '# TODO: Choose smallest-numbered grass type for pasture'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 为牧场选择编号最小的草地类型'
- en: '# TODO: Write output'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 编写输出'
- en: input_file.close()
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: 'The read_cows function that we’re calling ❶ will take a file that’s already
    open for reading, and read the two favorite pastures for each cow. It’ll return
    a list of lists, where each inner list contains the two pasture numbers for a
    given cow. Here’s the code:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用的read_cows函数 ❶ 将会接收一个已经打开的文件进行读取，读取每头牛的两个最喜欢的牧场。它将返回一个列表，其中每个内部列表包含一头牛的两个牧场编号。代码如下：
- en: 'def read_cows(input_file, num_cows):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_cows(input_file, num_cows):'
- en: '"""'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: input_file is a file open for reading; cow information is next to read.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: input_file是一个打开用于读取的文件；牛的信息接下来将被读取。
- en: num_cows is the number of cows in the file.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: num_cows是文件中的牛的数量。
- en: Read the cows' favorite pastures from input_file.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 从input_file读取牛最喜欢的牧场。
- en: Return a list of each cow's two favorite pastures;
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 返回每头牛两个最喜欢的牧场的列表；
- en: each value in the list is a list of two values giving the
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个值都是一个包含两个值的列表，表示
- en: favorite pastures for one cow.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 每头牛最喜欢的牧场。
- en: '"""'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: favorites = []
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: favorites = []
- en: 'for i in range(num_cows):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(num_cows):'
- en: ❶ lst = input_file.readline().split()
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ lst = input_file.readline().split()
- en: lst[0] = int(lst[0])
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: lst[0] = int(lst[0])
- en: lst[1] = int(lst[1])
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: lst[1] = int(lst[1])
- en: ❷ favorites.append(lst)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ favorites.append(lst)
- en: return favorites
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: return favorites
- en: This function accumulates the cows’ favorite pastures into the favorites list.
    It does that using a range for loop that loops num_cows times, once for each cow.
    We need the loop because the number of lines to read depends on the number of
    cows in the file.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将牛的最喜欢的牧场累积到favorites列表中。它使用一个range循环，循环次数为num_cows，即每头牛一次。我们需要这个循环，因为读取的行数取决于文件中牛的数量。
- en: On each iteration of the loop, we read the next line and split it into its two
    components ❶. We then use int to convert the components from strings to integers.
    When we append this list to favorites ❷, we’re therefore appending a list of two
    integers.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环迭代中，我们读取下一行并将其拆分成两个部分❶。然后我们使用int将这些部分从字符串转换为整数。当我们将这个列表追加到favorites❷时，我们实际上是在追加一个包含两个整数的列表。
- en: The last thing we do is return the list of favorite pastures.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们做的是返回一个包含每头牛最喜欢的牧场的列表。
- en: Before we continue, let’s make sure that we know how to call this function.
    We’ll practice calling it on its own, independent from the larger program that
    we’re building. It’s useful to test functions like this so that we can fix any
    errors that we might find along the way.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们确保知道如何调用这个函数。我们将独立于我们正在构建的更大程序来练习调用它。像这样测试函数是有用的，这样我们可以在发现任何错误时进行修复。
- en: 'Use your text editor to create a file named *revegetate.in* with the following
    contents (the same as the test case we studied earlier):'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的文本编辑器创建一个名为*revegetate.in*的文件，并填入以下内容（与我们之前研究的测试用例相同）：
- en: 8 6
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 8 6
- en: 5 4
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 5 4
- en: 2 4
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 2 4
- en: 3 5
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 3 5
- en: 4 1
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 4 1
- en: 2 1
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 2 1
- en: 5 2
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 5 2
- en: Now, in the Python shell, enter the code for our read_cows function.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Python shell中输入我们的read_cows函数代码。
- en: 'Here’s what we do to call read_cows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们调用read_cows的方式：
- en: '>>> input_file = open(''revegetate.in'', ''r'')'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input_file = open(''revegetate.in'', ''r'')'
- en: ❶ >>> input_file.readline()
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> input_file.readline()
- en: '''8 6\n'''
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '''8 6\n'''
- en: ❷ >>> read_cows(input_file, 6)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ >>> read_cows(input_file, 6)
- en: '[[5, 4], [2, 4], [3, 5], [4, 1], [2, 1], [5, 2]]'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[[5, 4], [2, 4], [3, 5], [4, 1], [2, 1], [5, 2]]'
- en: The read_cows function reads only the information for the cows. Since we’re
    testing this function in isolation, outside of our program, we need to read the
    first line of the file ourselves before we call it ❶. When we then call read_cows,
    we get back a list giving the favorite pastures for each cow. Also notice that
    we’re calling read_cows with an open file, *not* a filename ❷.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: read_cows函数仅读取有关牛的信息。由于我们在程序外单独测试这个函数，在调用它❶之前，我们需要自己读取文件的第一行。然后，当我们调用read_cows时，返回一个列表，列出每头牛最喜欢的牧场。同时注意，我们是用打开的文件调用read_cows，而*不是*文件名❷。
- en: 'Be sure to include our read_cows function, along with the functions we’ll write
    for other tasks, before our # Main Program comment. Then we can move on to Task
    2.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在# 主程序注释之前包含我们的read_cows函数，以及我们将为其他任务编写的函数。然后我们可以继续进行任务2。
- en: 'Task 2: Identify Cows'
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务2：识别牛
- en: Our overall strategy for solving this problem is to consider each pasture in
    turn, deciding which grass type to use. We’ll organize this work inside a loop,
    with each iteration of the loop responsible for seeding one pasture. For each
    pasture, we need to identify the cows that care about the pasture, eliminate the
    used grass types, and choose the smallest-numbered available grass type. These
    three tasks must run for each pasture, so we’ll indent them inside the loop.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决这个问题的整体策略是依次考虑每个牧场，决定使用哪种草类型。我们将在循环内组织这项工作，每次循环迭代负责播种一个牧场。对于每个牧场，我们需要识别出关心该牧场的牛，排除已用的草类型，并选择编号最小的可用草类型。这三项任务必须针对每个牧场执行，因此我们会将它们缩进到循环内。
- en: We’ll write a function called cows_with_favorite that tells us the cows who
    care about the current pasture.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为cows_with_favorite的函数，告诉我们关心当前牧场的牛。
- en: 'Here’s what we’ve got now for our main program:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这是目前我们的主程序：
- en: Main Program
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主程序
- en: input_file = open('revegetate.in', 'r')
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: input_file = open('revegetate.in', 'r')
- en: output_file = open('revegetate.out', 'w')
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: output_file = open('revegetate.out', 'w')
- en: Read input
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取输入
- en: lst = input_file.readline().split()
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: lst = input_file.readline().split()
- en: num_pastures = int(lst[0])
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: num_pastures = int(lst[0])
- en: num_cows = int(lst[1])
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: num_cows = int(lst[1])
- en: favorites = read_cows(input_file, num_cows)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: favorites = read_cows(input_file, num_cows)
- en: 'for i in range(1, num_pastures + 1):'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, num_pastures + 1):'
- en: '# Identify cows that care about pasture'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '# 识别关心牧场的奶牛'
- en: ❶ cows = cows_with_favorite(favorites, i)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ cows = cows_with_favorite(favorites, i)
- en: '# TODO: Eliminate grass types for pasture'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 为牧场消除草种'
- en: '# TODO: Choose smallest-numbered grass type for pasture'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 选择编号最小的草种作为牧场草种'
- en: 'TODO: Write output'
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'TODO: 写入输出'
- en: input_file.close()
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: 'The cows_with_favorite function that we’re calling ❶ takes a list of the cows’
    favorite pastures and a pasture number and returns the cows that care about that
    pasture. Here’s the code:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用的 cows_with_favorite 函数❶接受一份奶牛的最爱牧场列表和一个牧场编号，并返回关心该牧场的奶牛。以下是代码：
- en: 'def cows_with_favorite(favorites, pasture):'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'def cows_with_favorite(favorites, pasture):'
- en: '"""'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: favorites is a list of favorite pastures, as returned by read_cows.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: favorites 是由 read_cows 返回的最爱牧场列表。
- en: pasture is a pasture number.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: pasture 是牧场编号。
- en: Return list of cows that care about pasture.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 返回关心牧场的奶牛列表。
- en: '"""'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: cows = []
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: cows = []
- en: 'for i in range(len(favorites)):'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(len(favorites)):'
- en: 'if favorites[i][0] == pasture or favorites[i][1] == pasture:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 'if favorites[i][0] == pasture or favorites[i][1] == pasture:'
- en: cows.append(i)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: cows.append(i)
- en: return cows
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: return cows
- en: The function loops through favorites, looking for cows that care about pasture
    number pasture. Each cow that cares about the pasture is added to the cows list
    that is ultimately returned.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数循环遍历 favorites，查找关心牧场编号 pasture 的奶牛。每头关心该牧场的奶牛都会被添加到最终返回的 cows 列表中。
- en: 'Let’s do a little test. Enter our cows_with_favorite function into the Python
    shell. Here’s the call that we’ll try:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 做一个小测试。在Python shell中输入我们的 cows_with_favorite 函数。以下是我们将尝试的调用：
- en: '>>> cows_with_favorite([[5, 4], [2, 4], [3, 5]], 5)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> cows_with_favorite([[5, 4], [2, 4], [3, 5]], 5)'
- en: 'We have three cows here, and we’re asking which ones care about pasture 5.
    The cows at indices 0 and 2 care about pasture 5, and that’s exactly what the
    function tells us:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三头奶牛，我们在询问哪些奶牛关心牧场5。索引为0和2的奶牛关心牧场5，这正是该函数告诉我们的：
- en: '[0, 2]'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 2]'
- en: 'Task 3: Eliminate Grass Types'
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务3：消除草种
- en: Now we know the cows that care about the current pasture. Our next step is to
    figure out which grass types these cows eliminate from consideration for the current
    pasture. We eliminate the grass types that are used in a pasture associated with
    one or more of these cows. We’ll write a function called types_used that tells
    us the grass types that have already been used (and are therefore eliminated for
    the current pasture).
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了关心当前牧场的奶牛。我们的下一步是弄清楚这些奶牛会从当前牧场的草种中消除哪些选择。我们会消除已经在这些奶牛相关的牧场中使用过的草种。我们将编写一个名为
    types_used 的函数，告诉我们哪些草种已经被使用（因此对于当前牧场被消除）。
- en: 'Here is our main program, updated with a call to this function:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的主程序，已经更新，加入了对该函数的调用：
- en: '# Main Program'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '# 主程序'
- en: input_file = open('revegetate.in', 'r')
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: input_file = open('revegetate.in', 'r')
- en: output_file = open('revegetate.out', 'w')
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: output_file = open('revegetate.out', 'w')
- en: '# Read input'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取输入'
- en: lst = input_file.readline().split()
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: lst = input_file.readline().split()
- en: num_pastures = int(lst[0])
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: num_pastures = int(lst[0])
- en: num_cows = int(lst[1])
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: num_cows = int(lst[1])
- en: favorites = read_cows(input_file, num_cows)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: favorites = read_cows(input_file, num_cows)
- en: ❶ pasture_types = [0]
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pasture_types = [0]
- en: 'for i in range(1, num_pastures + 1):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, num_pastures + 1):'
- en: '# Identify cows that care about pasture'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '# 识别关心牧场的奶牛'
- en: cows = cows_with_favorite(favorites, i)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: cows = cows_with_favorite(favorites, i)
- en: '# Eliminate grass types for pasture'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '# 为牧场消除草种'
- en: ❷ eliminated = types_used(favorites, cows, pasture_types)
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ eliminated = types_used(favorites, cows, pasture_types)
- en: '# TODO: Choose smallest-numbered grass type for pasture'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 选择编号最小的草种作为牧场草种'
- en: '# TODO: Write output'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '# TODO: 写入输出'
- en: input_file.close()
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: In addition to calling the types_used function ❷, I’ve also added a variable
    called pasture_types ❶. The list referred to by this variable will keep track
    of the grass type for each pasture.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调用 types_used 函数❷外，我还添加了一个名为 pasture_types ❶ 的变量。这个变量所引用的列表将跟踪每个牧场的草种。
- en: Recall that the pastures are numbered starting from 1\. Python lists, on the
    other hand, are indexed starting from 0\. I don’t like this discrepancy; if we
    simply started adding grass types to pasture_types, then the grass type for pasture
    1 would be at index 0, the grass type for pasture 2 would be at index 1, and so
    on, always off by one. That’s why I added a bogus 0 at the beginning of the list
    ❶; when we later add the grass type for pasture 1, it’ll be placed at index 1
    to match.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，牧场是从 1 开始编号的。然而，Python 的列表是从 0 开始索引的。我不喜欢这种不一致；如果我们直接开始向 pasture_types 添加草的类型，那么牧场
    1 的草的类型就会位于索引 0，牧场 2 的草的类型位于索引 1，依此类推，总是会有一个偏差。因此，我在列表的开头加了一个假的 0 ❶；当我们之后为牧场 1
    添加草的类型时，它会被放置在索引 1 处，以便与编号匹配。
- en: 'Suppose we’ve figured out the grass types for the first four pastures. Here’s
    how pasture_types might look at that point:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经找出了前四个牧场的草的类型。这时，pasture_types 可能是这样的：
- en: '[0, 1, 2, 1, 3]'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 1, 2, 1, 3]'
- en: If we want the grass type for pasture 1, we look at index 1; if we want the
    grass type for pasture 2, we look at index 2; and so on. If we want the grass
    type for pasture 5? Well, no, we can’t have that, because we haven’t figured it
    out yet. If the length of pasture_types is 5, it means that we’ve figured out
    the grass types for only the first four pastures. In general, the number of grass
    types that we’ve figured out is one less than the list’s length.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要牧场 1 的草的类型，我们查看索引 1；如果我们想要牧场 2 的草的类型，我们查看索引 2；以此类推。如果我们想要牧场 5 的草的类型？不行，我们还没找出来。如果
    pasture_types 的长度是 5，这意味着我们只找出了前四个牧场的草的类型。一般来说，我们找出的草的类型数量比列表的长度少一个。
- en: 'Now we’re ready for the types_used function. It takes three parameters: the
    list of favorite pastures for each cow, the cows that care about the current pasture,
    and the grass types chosen for pastures so far. It returns the list of grass types
    that are already used and therefore eliminated for the current pasture. Here goes:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好使用 types_used 函数了。它有三个参数：每头牛最喜欢的牧场列表、关心当前牧场的牛列表，以及迄今为止已选定的草的类型。它返回一个已经被使用的草的类型列表，这些类型因此被排除在当前牧场之外。接下来我们就开始：
- en: 'def types_used(favorites, cows, pasture_types):'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 'def types_used(favorites, cows, pasture_types):'
- en: '"""'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: favorites is a list of favorite pastures, as returned by read_cows.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: favorites 是由 read_cows 返回的最喜欢的牧场列表。
- en: cows is a list of cows.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: cows 是一组牛的列表。
- en: pasture_types is a list of grass types.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: pasture_types 是一个草的类型列表。
- en: Return a list of the grass types already used by cows.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个已经被牛使用过的草的类型列表。
- en: '"""'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: used = []
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: used = []
- en: 'for cow in cows:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 'for cow in cows:'
- en: pasture_a = favorites[cow][0]
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: pasture_a = favorites[cow][0]
- en: pasture_b = favorites[cow][1]
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: pasture_b = favorites[cow][1]
- en: '❶ if pasture_a < len(pasture_types):'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ 如果 pasture_a < len(pasture_types):'
- en: used.append(pasture_types[pasture_a])
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: used.append(pasture_types[pasture_a])
- en: '❷ if pasture_b < len(pasture_types):'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ 如果 pasture_b < len(pasture_types):'
- en: used.append(pasture_types[pasture_b])
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: used.append(pasture_types[pasture_b])
- en: return used
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: return used
- en: Each cow has two favorite pastures, which I refer to by pasture_a and pasture_b.
    For each of these pastures, we check whether a grass type has already been chosen
    for it at ❶ and ❷. A grass type has already been chosen if that pasture is already
    an index in pasture_types. These grass types are all added to the used list, which
    the function returns after looping through all of the relevant cows.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 每头牛有两个最喜欢的牧场，我将其分别称为 pasture_a 和 pasture_b。对于每一个牧场，我们会在 ❶ 和 ❷ 处检查是否已经为其选择了草的类型。如果该牧场已经是
    pasture_types 中的一个索引，那么就说明草的类型已经选好了。所有这些草的类型都会被添加到 used 列表中，并在循环遍历所有相关牛后返回该列表。
- en: What if more than one cow uses the same pasture—what does our code do then?
    Let’s come up with a simple test case to answer that question.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多头牛使用相同的牧场——我们的代码会怎么做呢？让我们设计一个简单的测试用例来回答这个问题。
- en: 'Enter our types_used function into the Python shell. Here’s a call of that
    function; let’s predict what it returns:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 进入我们的 types_used 函数并在 Python shell 中运行它。以下是该函数的调用，让我们预测它返回什么：
- en: '>>> types_used([[5, 4], [2, 4], [3, 5]], [0, 1], [0, 1, 2, 1, 3])'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> types_used([[5, 4], [2, 4], [3, 5]], [0, 1], [0, 1, 2, 1, 3])'
- en: Let’s be careful so we don’t get lost. The first argument gives the favorite
    pastures for three cows. The second argument gives the cows that care about a
    particular pasture; these are cows 0 and 1. And the third argument gives the grass
    types that we’ve decided on so far.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们小心点，避免迷路。第一个参数给出了三头牛最喜欢的牧场。第二个参数给出了关心某个特定牧场的牛；这些是牛0和牛1。第三个参数给出了我们迄今为止决定的草的类型。
- en: Now, what are the grass types already used, and therefore eliminated, by cows
    0 and 1? Cow 0 cares about pasture 4, and pasture 4 uses grass type 3, so grass
    type 3 is eliminated. Cow 1 cares about pasture 2, and pasture 2 uses grass type
    2, so grass type 2 is eliminated. Cow 1 also cares about pasture 4—but we already
    know, from cow 0, that pasture 4’s grass type 3 is eliminated.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'The return value of our function is this:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[3, 2, 3]'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Two 3s in there, one coming from cow 0 and the other from cow 1.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: It may seem tidier to have just one 3 in there, but what we have—with the duplicate—is
    just fine. If a grass type is in that list, then it’s eliminated, no matter whether
    it’s in there once, twice, or three times.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 4: Choose Smallest-Numbered Grass Type'
  id: totrans-507
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Having obtained the grass types that are eliminated, we can move onto our next
    task: choosing the smallest-numbered available grass type for the current pasture.
    To solve this one, we’ll call a new function, smallest_available. It will return
    the grass type that we should use for the current pasture.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the main program, updated with a call to the smallest_available function:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Main Program
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: input_file = open('revegetate.in', 'r')
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('revegetate.out', 'w')
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Read input
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: lst = input_file.readline().split()
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: num_pastures = int(lst[0])
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: num_cows = int(lst[1])
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: favorites = read_cows(input_file, num_cows)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types = [0]
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, num_pastures + 1):'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '# Identify cows that care about pasture'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: cows = cows_with_favorite(favorites, i)
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '# Eliminate grass types for pasture'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: eliminated = types_used(favorites, cows, pasture_types)
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '# Choose smallest-numbered grass type for pasture'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: ❶ pasture_type = smallest_available(eliminated)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: ❷ pasture_types.append(pasture_type)
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'TODO: Write output'
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: input_file.close()
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Once we obtain the smallest-numbered grass type for the current pasture ❶, we
    add it to our list of chosen grass types ❷.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the smallest_available function itself:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'def smallest_available(used):'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: used is a list of used grass types.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Return the smallest-numbered grass type that is not in used.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: grass_type = 1
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'while grass_type in used:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: grass_type = grass_type + 1
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: return grass_type
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: The function begins with grass type 1. It then loops until it finds a grass
    type that isn’t already used, increasing the grass type by one on each iteration.
    Once a free grass type is found, the function returns it. And remember, there
    are at most three grass types that have been used out of the four available, so
    this function is guaranteed to be successful.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 5: Write Output'
  id: totrans-542
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve got our answer, right there in pasture_types! Now all we have to do is
    output it. Here’s the main program a final time:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '# Main Program'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: input_file = open('revegetate.in', 'r')
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('revegetate.out', 'w')
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '# Read input'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: lst = input_file.readline().split()
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: num_pastures = int(lst[0])
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: num_cows = int(lst[1])
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: favorites = read_cows(input_file, num_cows)
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types = [0]
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, num_pastures + 1):'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '# Identify cows that care about pasture'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '# 确定关心牧场的牛'
- en: cows = cows_with_favorite(favorites, i)
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: cows = cows_with_favorite(favorites, i)
- en: '# Eliminate grass types for pasture'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '# 排除牧场的草类型'
- en: eliminated = types_used(favorites, cows, pasture_types)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: eliminated = types_used(favorites, cows, pasture_types)
- en: '# Choose smallest-numbered grass type for pasture'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '# 选择编号最小的草类型作为牧场'
- en: pasture_type = smallest_available(eliminated)
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: pasture_type = smallest_available(eliminated)
- en: pasture_types.append(pasture_type)
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: pasture_types.append(pasture_type)
- en: '# Write output'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '# 写入输出'
- en: ❶ pasture_types.pop(0)
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pasture_types.pop(0)
- en: ❷ write_pastures(output_file, pasture_types)
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ write_pastures(output_file, pasture_types)
- en: input_file.close()
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: input_file.close()
- en: output_file.close()
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: output_file.close()
- en: Before writing the output, we remove the bogus 0 at the beginning of pasture_types
    ❶. We don’t want to output that 0, as it isn’t a real grass type. Then, we call
    write_pastures to actually write the output ❷.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入输出之前，我们移除pasture_types开头的虚假0❶。我们不想输出这个0，因为它不是一个真实的草类型。然后，我们调用write_pastures来实际写入输出❷。
- en: 'All we need now is the write_pastures function. It takes a file open for writing,
    and a list of grass types, and outputs the grass types to the file. Here’s the
    code:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要write_pastures函数。它接受一个打开供写入的文件和一个草类型列表，并将这些草类型输出到文件中。下面是代码：
- en: 'def write_pastures(output_file, pasture_types):'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 'def write_pastures(output_file, pasture_types):'
- en: '"""'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: output_file is a file open for writing.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: output_file是一个打开供写入的文件。
- en: pasture_types is a list of integer grass types.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: pasture_types是一个整数草类型的列表。
- en: Output pasture_types to output_file.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 将牧场类型输出到output_file。
- en: '"""'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: pasture_types_str = []
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: pasture_types_str = []
- en: '❶ for pasture_type in pasture_types:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于pasture_type中的每一个牧场类型：
- en: pasture_types_str.append(str(pasture_type))
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: pasture_types_str.append(str(pasture_type))
- en: ❷ output = ''.join(pasture_types_str)
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ output = ''.join(pasture_types_str)
- en: ❸ output_file.write(output + '\n')
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ output_file.write(output + '\n')
- en: Right now, pasture_types is a list of integers. As we’ll see in a second, it’s
    more convenient to work with a list of strings here, so I create a new list with
    each integer as a string ❶. I don’t modify the pasture_types list itself, because
    that could shock the caller of this function. The caller calls this function expecting
    only that output gets written to output_file, not that its pasture_types list
    is modified. The function has no business modifying its list parameter.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，pasture_types是一个整数列表。正如我们稍后会看到的，在这里使用字符串列表会更方便，所以我创建了一个新的列表，其中每个整数作为字符串❶。我没有修改pasture_types列表本身，因为那样可能会影响到调用此函数的代码。调用者调用此函数时，期望的只是将输出写入output_file，而不是其pasture_types列表被修改。这个函数不应该修改其列表参数。
- en: To produce the output, we need to call write with a string, not a list. And
    we need to output the strings from the list with no spaces between them. The string
    join method works wonderfully here. As we learned in “Joining a List into a String”
    in [Chapter 5](ch05.xhtml#ch05), the string that we call join on serves as the
    separator that’s placed between values in the list. Since we don’t want any separator
    between the values, we use an empty string as the separator ❷. The join method
    works only on a list of strings, not a list of integers, which is why I converted
    the list of integers to a list of strings at the start of this function ❶.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 为了产生输出，我们需要使用字符串而不是列表来调用write。并且我们需要无空格地输出列表中的字符串。这里使用字符串的join方法非常有效。正如我们在[第5章](ch05.xhtml#ch05)中的“将列表连接成字符串”部分所学，调用join方法的字符串作为分隔符，插入列表值之间。由于我们不希望在值之间有任何分隔符，我们使用空字符串作为分隔符❷。join方法仅对字符串列表有效，而不是整数列表，这也是为什么我在这个函数开始时将整数列表转换为字符串列表❶。
- en: With the output as a single string, we can write it to the file ❸.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将输出作为单个字符串，我们可以将其写入文件❸。
- en: Putting It All Together
  id: totrans-582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将所有内容结合起来
- en: The complete program is in [Listing 7-2](ch07.xhtml#ch07ex02).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的程序见[示例7-2](ch07.xhtml#ch07ex02)。
- en: 'def read_cows(input_file, num_cows):'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 'def read_cows(input_file, num_cows):'
- en: '"""'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: input_file is a file open for reading; cow information is next to read.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: input_file是一个打开供读取的文件；接下来是读取牛群信息。
- en: num_cows is the number of cows in the file.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: num_cows是文件中的牛的数量。
- en: Read the cows' favorite pastures from input_file.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 从input_file读取牛群喜欢的牧场。
- en: Return a list of each cow's two favorite pastures;
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 返回每头牛最喜欢的两个牧场的列表；
- en: each value in the list is a list of two values giving the
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个值是一个包含两个值的列表，表示
- en: favorite pastures for one cow.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 每头牛最喜欢的牧场。
- en: '"""'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: favorites = []
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: favorites = []
- en: 'for i in range(num_cows):'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 对于i在范围(num_cows)内：
- en: lst = input_file.readline().split()
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: lst = input_file.readline().split()
- en: lst[0] = int(lst[0])
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: lst[0] = int(lst[0])
- en: lst[1] = int(lst[1])
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: lst[1] = int(lst[1])
- en: favorites.append(lst)
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: favorites.append(lst)
- en: return favorites
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 返回favorites
- en: 'def cows_with_favorite(favorites, pasture):'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 'def cows_with_favorite(favorites, pasture):'
- en: '"""'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: favorites is a list of favorite pastures, as returned by read_cows.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: pasture is a pasture number.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Return list of cows that care about pasture.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: cows = []
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(favorites)):'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 'if favorites[i][0] == pasture or favorites[i][1] == pasture:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: cows.append(i)
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: return cows
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: 'def types_used(favorites, cows, pasture_types):'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: favorites is a list of favorite pastures, as returned by read_cows.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: cows is a list of cows.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types is a list of grass types.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Return a list of the grass types already used by cows.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: used = []
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'for cow in cows:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: pasture_a = favorites[cow][0]
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: pasture_b = favorites[cow][1]
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: 'if pasture_a < len(pasture_types):'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: used.append(pasture_types[pasture_a])
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: 'if pasture_b < len(pasture_types):'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: used.append(pasture_types[pasture_b])
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: return used
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 'def smallest_available(used):'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: used is a list of used grass types.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: Return the smallest-numbered grass type that is not in used.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: grass_type = 1
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'while grass_type in used:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: grass_type = grass_type + 1
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: return grass_type
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'def write_pastures(output_file, pasture_types):'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: output_file is a file open for writing.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types is a list of integer grass types.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Output pasture_types to output_file.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types_str = []
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: 'for pasture_type in pasture_types:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types_str.append(str(pasture_type))
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: output = ''.join(pasture_types_str)
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: output_file.write(output + '\n')
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: Main Program
  id: totrans-647
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: input_file = open('revegetate.in', 'r')
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('revegetate.out', 'w')
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: Read input
  id: totrans-650
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: lst = input_file.readline().split()
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: num_pastures = int(lst[0])
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: num_cows = int(lst[1])
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: favorites = read_cows(input_file, num_cows)
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types = [0]
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, num_pastures + 1):'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '# Identify cows that care about pasture'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: cows = cows_with_favorite(favorites, i)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '# Eliminate grass types for pasture'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: eliminated = types_used(favorites, cows, pasture_types)
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '# Choose smallest-numbered grass type for pasture'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: pasture_type = smallest_available(eliminated)
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types.append(pasture_type)
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: Write output
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pasture_types.pop(0)
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: write_pastures(output_file, pasture_types)
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-2: Solving Farm Seeding*'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: We did it! An intimidating problem, made more manageable by the application
    of top-down design. Feel free to submit our work to the USACO judge.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to be overwhelmed by a problem when you first read it. But remember
    that you don’t need to tackle it in one huge step. Break it down, solve each task
    that you can solve, and you’ll be well on your way to a solution for the overall
    problem. You’ve made huge strides in the amount of Python that you know and your
    ability to design programs and solve problems. Solving these problems is within
    your grasp!
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Let’s think about a new version of Farm Seeding where there’s no restriction
    on the number of cows that care about a pasture. A pasture might be the favorite
    of four cows, five cows, or even more. We’re still not allowed to give a cow two
    pastures with the same grass type.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we’re solving this new version of the problem and have a test case
    where a pasture is the favorite of more than three cows. Which of the following
    is true of that test case?
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: A. It’s *guaranteed* that there’s *no way* to solve it with only four grass
    types.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: B. There might be a way to solve it. If there is, it’s *possible* that our original
    solution ([Listing 7-2](ch07.xhtml#ch07ex02)) *will* do so.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: C. There might be a way to solve it. If there is, it’s *guaranteed* that our
    original solution ([Listing 7-2](ch07.xhtml#ch07ex02)) *will* do so.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: D. There might be a way to solve it. If there is, it’s *guaranteed* that our
    original solution ([Listing 7-2](ch07.xhtml#ch07ex02)) *won’t* do so.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. We can find a test case that is correctly solved by our program,
    and we can find a test case that can be solved but not by our program. The former
    eliminates A and D as correct responses; the latter eliminates C as the correct
    response.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a test case that is correctly solved by our program:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 2 4
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 1 2
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: 1 2
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: 1 2
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 1 2
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: Each pasture is the favorite of four cows. Nevertheless, we can solve this test
    case using only two grass types. Try our program, and you should see that it correctly
    solves this test case.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: 'Now here’s a test case that can be solved, but not by our program:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: 6 10
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: 2 3
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: 2 4
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 3 4
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: 2 5
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 3 5
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 4 5
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: 1 6
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: 3 6
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: 4 6
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 5 6
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: The mistake that our program makes is to use grass type 1 for pasture 1\. In
    so doing, it’s forced to use grass type 5—which isn’t allowed!—for pasture 6\.
    Our program fails, but don’t conclude that there isn’t a way to solve this test
    case. In particular, use grass type 2 for pasture 1, and you should be able to
    find a way to solve this test case using only four grass types. It’s possible
    to solve these kinds of test cases with a more sophisticated program, and I encourage
    you to think about this on your own if you’re interested.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned how to open, read from, write to, and close files.
    Files are useful whenever you need to store information and use it as input later.
    They’re also useful for communicating information to your users. We also learned
    that we process files similarly to how we process standard input and standard
    output.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll learn how to store a collection of values in a Python
    set or dictionary. Storing a collection of values—that sounds like what a list
    does. We’ll see, though, that sets and dictionaries can make it easier for us
    to solve some kinds of problems.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try. All of them are from the USACO judge
    and require reading and writing files. They’ll also require you to dust the cobwebs
    off material from previous chapters.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: USACO 2018 December Bronze Contest problem Mixing Milk
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2017 February Bronze Contest problem Why Did the Cow Cross the Road
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2017 US Open Bronze Contest problem The Lost Cow
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2019 December Bronze Contest problem Cow Gymnastics
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2017 US Open Bronze Contest problem Bovine Genomics
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2018 US Open Bronze Contest problem Team Tic Tac Toe
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2018年美国公开赛青铜奖竞赛问题：井字棋队伍
- en: USACO 2019 February Bronze Contest problem Sleepy Cow Herding
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2019年2月青铜奖竞赛问题：睡意朦胧的牛群
- en: Notes
  id: totrans-712
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Essay Formatting is originally from the USACO 2020 January Bronze Contest. Farm
    Seeding is originally from the USACO 2019 February Bronze Contest.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 《作文格式》最初来源于USACO 2020年1月的青铜奖竞赛。 《农场播种》最初来源于USACO 2019年2月的青铜奖竞赛。
- en: There are many types of files besides text files. You might like to work with
    HTML files, Excel spreadsheets, PDF files, Word documents, or image files. Python
    can help! See *Automate the Boring Stuff with Python*, 2nd edition by Al Sweigart
    (No Starch Press, 2019) for much more information.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文本文件之外，还有许多种类的文件。你可能会喜欢处理HTML文件、Excel电子表格、PDF文件、Word文档或图像文件。Python可以帮助你！有关更多信息，请参阅*《用Python自动化无聊的事情》*（第二版），作者：Al
    Sweigart（No Starch Press，2019年）。
- en: 'The “perhaps better poetry” line is from J. C. R. Licklider, as quoted in *Computers
    and the World of the Future*, edited by Martin Greenberger (MIT Press, 1962):'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: “也许更好的诗歌”这一句话来自J. C. R. Licklider，引用自*《计算机与未来世界》*，由马丁·格林伯格编辑（麻省理工学院出版社，1962年）：
- en: But some people write poetry in the language we speak. Perhaps better poetry
    will be written in the language of digital computers of the future than has ever
    been written in English.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有些人用我们说的语言写诗。也许在未来数字计算机的语言中，写出的诗会比用英语写的更好。
