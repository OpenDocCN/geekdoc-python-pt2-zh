- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: READING AND WRITING FILES
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To this point, we’ve read all input using the input function and written all
    output using the print function. These functions read from standard input (defaulting
    to the keyboard) and write to standard output (defaulting to the screen), respectively.
    While we can change these defaults using input and output redirection, sometimes
    a program needs more control over its files. For example, your word processor
    allows you to open whichever document file you like and save a file with whatever
    name you like, without you messing around with standard input and standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll learn how to write programs that manipulate text files.
    We’ll solve two problems using files: correctly formatting an essay and seeding
    a farm to feed cows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #16: Essay Formatting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s one important difference between this problem and all the problems
    we’ve solved to this point: this one requires us to read from and write to specific
    files! Look out for this as you read the problem description.'
  prefs: []
  type: TYPE_NORMAL
- en: This is USACO 2020 January Bronze Contest problem Word Processor. This is the
    first problem in the book from the USACO (USA Computing Olympiad) judge. To find
    the problem, go to *[http://usaco.org/](http://usaco.org/)*, click **Contests**,
    click **2020 January Contest Results**, and then click **View problem** under
    Word Processor.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Bessie the cow is writing an essay. Each word in the essay contains only lowercase
    or uppercase characters. Her teacher has specified the maximum number of characters,
    not counting spaces, that can occur per line. To satisfy this requirement, Bessie
    writes down the words of the essay using the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If the next word fits on the current line, add it to the current line. Include
    a space between each pair of words on the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, put this word on a new line; this line becomes the new current line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output the essay with the correct words on each line.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Read input from the file named *word.in*.
  prefs: []
  type: TYPE_NORMAL
- en: The input consists of two lines.
  prefs: []
  type: TYPE_NORMAL
- en: The first line contains two integers separated by a space. The first integer
    is *n*, the number of words in the essay; it’s between 1 and 100\. The second
    integer is *k*, the maximum number of characters (not counting spaces) that can
    occur per line; it’s between 1 and 80.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line contains *n* words, with a space between each pair of words.
    Each word has at most *k* characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write output to the file named *word.out*.
  prefs: []
  type: TYPE_NORMAL
- en: Output the properly formatted essay.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Essay Formatting problem requires that we read from file *word.in* and write
    to file *word.out*. Before we can do those things, though, we need to learn how
    to open files in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a File
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using your text editor, create a new file called *word.in*. Put that file in
    the same directory that you’ve been using for your *.py* Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first time that we’re creating a file that doesn’t end with *.py*.
    Instead, it ends with *.in*. Be sure to name the file *word.in*, not *word.py*.
    The *in* is short for input; you’ll see it used often for files that contain input
    for a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that file, let’s place valid input for the Essay Formatting problem. Enter
    the following into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: 12 13
  prefs: []
  type: TYPE_NORMAL
- en: perhaps better poetry will be written in the language of digital computers
  prefs: []
  type: TYPE_NORMAL
- en: Save the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open the file in Python, we use the open function. We pass two arguments:
    the first is the filename, and the second is the mode in which to open the file.
    The mode determines how we can interact with the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can open *word.in*:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> open(''word.in'', ''r'')'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ <_io.TextIOWrapper name='word.in' mode='r' encoding='cp1252'>
  prefs: []
  type: TYPE_NORMAL
- en: In this function call, we’ve provided a mode of 'r'. The r stands for “read”
    and opens the file so that we can read from it. The mode happens to be an optional
    parameter whose default is 'r', so we can leave it out if we like. But I’ll explicitly
    include the 'r' throughout the book for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: When we use open, Python gives us some information about how the file was opened
    ❶. For example, it confirms the filename and mode. The bit about encoding indicates
    how the file was decoded from its state on disk into a form that we can read.
    Files can be encoded using a variety of encodings, but we don’t need to worry
    about encodings in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to open a file for reading that doesn’t exist, we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> open(''blah.in'', ''r'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: 'FileNotFoundError: [Errno 2] No such file or directory: ''blah.in'''
  prefs: []
  type: TYPE_NORMAL
- en: If you’re getting this error when opening *word.in*, double-check that the file
    is named correctly and in the directory from which you started Python.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to mode 'r' for reading, there’s mode 'w' for writing. If we use
    'w', then we’re opening a file so that we can put text in it.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with mode 'w'. If you use 'w' with a file that already exists, the
    contents of that file will be deleted. I just accidentally did that with my *word.in*
    file. No big deal, because it was easy to re-create. But no one would be happy
    if we accidentally overwrote an important file.
  prefs: []
  type: TYPE_NORMAL
- en: If you use 'w' with a filename that doesn’t exist, it creates an empty file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use mode ''w'' to create an empty file called *blah.in*:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> open(''blah.in'', ''w'')'
  prefs: []
  type: TYPE_NORMAL
- en: <_io.TextIOWrapper name='blah.in' mode='w' encoding='cp1252'>
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that *blah.in* exists, we can open it for reading without getting an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> open(''blah.in'', ''r'')'
  prefs: []
  type: TYPE_NORMAL
- en: <_io.TextIOWrapper name='blah.in' mode='r' encoding='cp1252'>
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s that _io.TextIOWrapper that we keep seeing? That’s the type of the value
    that open returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> type(open(''word.in'', ''r''))'
  prefs: []
  type: TYPE_NORMAL
- en: <class '_io.TextIOWrapper'>
  prefs: []
  type: TYPE_NORMAL
- en: Think of this type as a file type. Its values represent open files, and you’ll
    see shortly that it has methods that we can call.
  prefs: []
  type: TYPE_NORMAL
- en: As with any function, if we don’t assign what open returns to a variable, then
    its return value is lost. The way we’ve been calling open so far doesn’t give
    us any way to refer to the file that we’ve opened!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can make a variable refer to an open file:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file = open(''word.in'', ''r'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file'
  prefs: []
  type: TYPE_NORMAL
- en: <_io.TextIOWrapper name='word.in' mode='r' encoding='cp1252'>
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be able to use input_file to read from 'word.in'.
  prefs: []
  type: TYPE_NORMAL
- en: 'When solving Essay Formatting, we’ll also need a way to write to file ''word.out''.
    Here’s a variable that will help us do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file = open(''word.out'', ''w'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file'
  prefs: []
  type: TYPE_NORMAL
- en: <_io.TextIOWrapper name='word.out' mode='w' encoding='cp1252'>
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a File
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To read a line from an open file, we use the file’s readline method. That method
    returns a string containing the contents of the next line of the file. In that
    way, it’s similar to the input function. Unlike input, however, readline reads
    from a file rather than from standard input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open *word.in* and read its two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file = open(''word.in'', ''r'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file.readline()'
  prefs: []
  type: TYPE_NORMAL
- en: '''12 13\n'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file.readline()'
  prefs: []
  type: TYPE_NORMAL
- en: '''perhaps better poetry will be written in the language of digital computers\n'''
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s unexpected here is the \n at the end of each string. We certainly didn’t
    see that when using input to read a line. The \ symbol in a string is an *escape
    character*. It escapes from the standard interpretation of characters and changes
    their meaning. We don’t treat \n as the two separate characters \ and n. Instead,
    \n is just one character: a newline character. All lines in a file, perhaps except
    for the last, end with a newline character. If they didn’t, then everything would
    be on a single line! The readline method is literally giving us the entire line,
    including its terminating newline character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can embed newlines in our own strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''one\ntwo\nthree'''
  prefs: []
  type: TYPE_NORMAL
- en: '''one\ntwo\nthree'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(''one\ntwo\nthree'')'
  prefs: []
  type: TYPE_NORMAL
- en: one
  prefs: []
  type: TYPE_NORMAL
- en: two
  prefs: []
  type: TYPE_NORMAL
- en: three
  prefs: []
  type: TYPE_NORMAL
- en: The Python shell doesn’t process the effects of escape characters, but print
    does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The \n sequence is useful in strings because it helps us add multiple lines.
    But we rarely want those newlines in the lines that we read from files. To get
    rid of them, we can use the string rstrip method. This method is like strip except
    that it removes whitespace only from the right of a string (not the left). As
    far as it’s concerned, newlines are whitespace just like spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''hello\nthere\n\n'''
  prefs: []
  type: TYPE_NORMAL
- en: '''hello\nthere\n\n'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''hello\nthere\n\n''.rstrip()'
  prefs: []
  type: TYPE_NORMAL
- en: '''hello\nthere'''
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try reading from the file again, this time stripping out the newlines:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file = open(''word.in'', ''r'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file.readline().rstrip()'
  prefs: []
  type: TYPE_NORMAL
- en: '''12 13'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file.readline().rstrip()'
  prefs: []
  type: TYPE_NORMAL
- en: '''perhaps better poetry will be written in the language of digital computers'''
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve read the two lines, so there’s nothing left to read from
    the file. The readline method signals this by returning an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file.readline().rstrip()'
  prefs: []
  type: TYPE_NORMAL
- en: ''''''
  prefs: []
  type: TYPE_NORMAL
- en: The empty string means that we’ve reached the end of the file. If we want to
    read the lines again, we must reopen the file to start at its beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do that, this time saving each line using variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file = open(''word.in'', ''r'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> first = input_file.readline().rstrip()'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> second = input_file.readline().rstrip()'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> first'
  prefs: []
  type: TYPE_NORMAL
- en: '''12 13'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> second'
  prefs: []
  type: TYPE_NORMAL
- en: '''perhaps better poetry will be written in the language of digital computers'''
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to read all of the lines from a file, no matter how many there are,
    we can use a for loop. Files in Python act as sequences of lines, so we can loop
    over them just like we loop over strings and lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file = open(''word.in'', ''r'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for line in input_file:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(line.rstrip())'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 12 13
  prefs: []
  type: TYPE_NORMAL
- en: perhaps better poetry will be written in the language of digital computers
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike a string or loop, though, we can’t loop over the file a second time,
    because the first one takes us to its end. If we try, we get nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for line in input_file:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(line.rstrip())'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: We want to use a while loop to output each line of the open file input_file.
    (The file could be any file; I’m not assuming that it’s related to Essay Formatting.)
    Which of the following pieces of code correctly does this?
  prefs: []
  type: TYPE_NORMAL
- en: A.
  prefs: []
  type: TYPE_NORMAL
- en: 'while input_file.readline() != '''':'
  prefs: []
  type: TYPE_NORMAL
- en: print(input_file.readline().rstrip())
  prefs: []
  type: TYPE_NORMAL
- en: B.
  prefs: []
  type: TYPE_NORMAL
- en: line = 'x'
  prefs: []
  type: TYPE_NORMAL
- en: 'while line != '''':'
  prefs: []
  type: TYPE_NORMAL
- en: line = input_file.readline()
  prefs: []
  type: TYPE_NORMAL
- en: print(line.rstrip())
  prefs: []
  type: TYPE_NORMAL
- en: C.
  prefs: []
  type: TYPE_NORMAL
- en: line = input_file.readline()
  prefs: []
  type: TYPE_NORMAL
- en: 'while line != '''':'
  prefs: []
  type: TYPE_NORMAL
- en: line = input_file.readline()
  prefs: []
  type: TYPE_NORMAL
- en: print(line.rstrip())
  prefs: []
  type: TYPE_NORMAL
- en: D. All of the above
  prefs: []
  type: TYPE_NORMAL
- en: E. None of the above
  prefs: []
  type: TYPE_NORMAL
- en: Before looking at the answer, I encourage you to create a file with four or
    five lines in it and try each piece of code on the file. You might also consider
    adding a character like * to the beginning of each line that’s output so that
    you can see any otherwise blank lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: E. Each piece of code has a subtle error.'
  prefs: []
  type: TYPE_NORMAL
- en: Code A outputs only every other line of the file. For example, the while loop’s
    Boolean expression causes the first line to be read . . . and lost, because it
    isn’t assigned to a variable. The first iteration of the loop therefore outputs
    the second line of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Code B comes very close to doing the right thing. It outputs all the lines of
    the file, but also outputs an extraneous blank line at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Code C fails to print the first line of the file. That’s because the first line
    is read before the loop, but then the loop reads the second line without having
    printed the first. It also produces an extraneous blank line at the end, just
    like code B.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s correct code to read and print each line:'
  prefs: []
  type: TYPE_NORMAL
- en: line = input_file.readline()
  prefs: []
  type: TYPE_NORMAL
- en: 'while line != '''':'
  prefs: []
  type: TYPE_NORMAL
- en: print(line.rstrip())
  prefs: []
  type: TYPE_NORMAL
- en: line = input_file.readline()
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a File
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To write a line to an open file, we use the file’s write method. We pass it
    a string, and that string is added to the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve Essay Formatting, we’ll write to *word.out*. We’re not ready to solve
    that problem yet, so let’s instead write to *blah.out*. Here’s how we can write
    one line to that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file = open(''blah.out'', ''w'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file.write(''hello'')'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: What’s that 5 doing there? The write method returns the number of characters
    written. It’s good confirmation that we’ve written the quantity of text that we
    expected to write.
  prefs: []
  type: TYPE_NORMAL
- en: If you open *blah.out* in your text editor, you should see the text hello in
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try writing three lines to the file. Here goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file = open(''blah.out'', ''w'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file.write(''sq'')'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file.write(''ui'')'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file.write(''sh'')'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on what I’ve told you so far, you might expect *blah.out* to look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: sq
  prefs: []
  type: TYPE_NORMAL
- en: ui
  prefs: []
  type: TYPE_NORMAL
- en: sh
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you open *blah.out* in your text editor, you should instead see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: squish
  prefs: []
  type: TYPE_NORMAL
- en: 'The characters are on a single line like that because write doesn’t add newlines
    for us! If we want separate lines, we need to be explicit, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file = open(''blah.out'', ''w'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file.write(''sq\n'')'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file.write(''ui\n'')'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file.write(''sh\n'')'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice in each case that write writes three characters, not two. The newline
    counts as a character. Now if you open *blah.out* in your text editor, you should
    see the text spread across three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: sq
  prefs: []
  type: TYPE_NORMAL
- en: ui
  prefs: []
  type: TYPE_NORMAL
- en: sh
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike print, write works only if you call it with a string. To write a number
    to a file, convert it to a string first:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num = 7788'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file = open(''blah.out'', ''w'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> output_file.write(str(num) + ''\n'')'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: Closing Files
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s good practice to close a file once you’re done with it. It signals to readers
    of your code that the file is no longer being used.
  prefs: []
  type: TYPE_NORMAL
- en: Closing files also helps your operating system manage your computer’s resources.
    When you use the write method, what you write may not end up in the file immediately.
    Rather, Python or your operating system might wait until it has a bunch of write
    requests and then write them all at once. Closing a file that you wrote to guarantees
    that what you wrote to the file is safely stored in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To close a file, call its close method. Here’s an example of opening a file,
    reading a line, and closing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file = open(''word.in'', ''r'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file.readline()'
  prefs: []
  type: TYPE_NORMAL
- en: '''12 13\n'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file.close()'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve closed a file, you can no longer read from or write to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file.readline()'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: 'ValueError: I/O operation on closed file.'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Back to Essay Formatting. Now we know how to read from *word.in* and write to
    *word.out*. That takes care of the input and output requirements. It’s time to
    tackle the problem itself.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by exploring a test case to make sure we know how to solve this
    problem. Then we’ll see the code.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s the *word.in* file I’ve been using:'
  prefs: []
  type: TYPE_NORMAL
- en: 12 13
  prefs: []
  type: TYPE_NORMAL
- en: perhaps better poetry will be written in the language of digital computers
  prefs: []
  type: TYPE_NORMAL
- en: There are 12 words, and the maximum number of characters on a line (not counting
    spaces) is 13\. We should add words to the current line as long as they fit; once
    a word doesn’t fit, we’ll start a new line with that word.
  prefs: []
  type: TYPE_NORMAL
- en: The word perhaps contains seven characters, so it fits on the first line. The
    word better contains six characters. We can put that on the first line, too; with
    perhaps already there, we’re at a total of 13 characters (not including the space
    between the two words).
  prefs: []
  type: TYPE_NORMAL
- en: The word poetry can’t go on the first line, so we start a new line with poetry
    as its first word. The word will fits next to poetry on the second line. Similarly,
    be fits next to will. We’re at 12 nonspace characters so far. Now we have the
    word written, and with only one character of room on line 2, we’re forced to start
    the next line with written as its first word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this process to the end, the full essay that we need to write to
    *word.out* is this:'
  prefs: []
  type: TYPE_NORMAL
- en: perhaps better
  prefs: []
  type: TYPE_NORMAL
- en: poetry will be
  prefs: []
  type: TYPE_NORMAL
- en: written in the
  prefs: []
  type: TYPE_NORMAL
- en: language of
  prefs: []
  type: TYPE_NORMAL
- en: digital
  prefs: []
  type: TYPE_NORMAL
- en: computers
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our solution is in [Listing 7-1](ch07.xhtml#ch07ex01).
  prefs: []
  type: TYPE_NORMAL
- en: ❶ input_file = open('word.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: ❷ output_file = open('word.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: ❸ lst = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: n = int(lst[0])  # n not needed
  prefs: []
  type: TYPE_NORMAL
- en: k = int(lst[1])
  prefs: []
  type: TYPE_NORMAL
- en: words = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: ❹ line = ''
  prefs: []
  type: TYPE_NORMAL
- en: chars_on_line = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for word in words:'
  prefs: []
  type: TYPE_NORMAL
- en: '❺ if chars_on_line + len(word) <= k:'
  prefs: []
  type: TYPE_NORMAL
- en: line = line + word + ' '
  prefs: []
  type: TYPE_NORMAL
- en: chars_on_line = chars_on_line + len(word)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: ❻ output_file.write(line[:-1] + '\n')
  prefs: []
  type: TYPE_NORMAL
- en: line = word + ' '
  prefs: []
  type: TYPE_NORMAL
- en: chars_on_line = len(word)
  prefs: []
  type: TYPE_NORMAL
- en: ❼ output_file.write(line[:-1] + '\n')
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-1: Solving Essay Formatting*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we open the input file ❶ and output file ❷. Notice the modes: we
    open the input file with mode ''r'' (for reading) and open the output file with
    mode ''w'' (for writing). We could have opened the output file a little later,
    right before we use it, but I’ve chosen to open both files here to simplify the
    organization of the program. Similarly, we could close a file as soon as we no
    longer need it, but in this book, I’ve chosen to close all files together at the
    end of the program. For long-running programs that manipulate many files, you
    likely want to keep files open only when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we read the first line of the input file ❸. This line contains two space-separated
    integers: n, the number of words, and k, the maximum number of allowed characters
    (not counting spaces) per line. As always with space-separated values, we use
    split to separate them. We then read the second line, which contains the essay
    words. Again we use split, this time to split the string of words into a list
    of words. That takes care of the input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two variables drive the main portion of the program: line and chars_on_line.
    The line variable refers to the current line; we start out with it referring to
    the empty string ❹. The chars_on_line variable refers to the number of characters,
    not counting spaces, on the current line.'
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why I’m maintaining chars_on_line at all. Couldn’t we just use
    len(line) instead? Well, if we did that, we’d be including spaces in our count,
    and spaces don’t count toward the number of characters allowed per line. We could
    fix that by subtracting the count of spaces, and I encourage you to try that on
    your own if you find it more intuitive than keeping the chars_on_line variable
    in there.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to loop through all of the words. For each word, we have to determine
    whether it goes on the current line or next line.
  prefs: []
  type: TYPE_NORMAL
- en: If the number of nonspace characters on the current line plus the number of
    characters in the current word is at most k, then the current word fits on the
    current line ❺. In that case, we add the word plus a space to the current line
    and update the number of nonspace characters on the line.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the current word doesn’t fit on the current line. The current line
    is done! We therefore write the line to the output file ❻ and update the line
    and chars_on_line variables to reflect that this is the only word on the now-current
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things to note about the write call ❻. First, the [:-1] slice
    is in there to prevent us from outputting the space that follows the last word
    on the line. Second, you may have expected me to use an f-string here, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: output_file.write(f'{line[:-1]}\n')
  prefs: []
  type: TYPE_NORMAL
- en: However, at the time of writing, the USACO judge is running an older version
    of Python that doesn’t support f-strings.
  prefs: []
  type: TYPE_NORMAL
- en: Why are we outputting line after the loop ends ❼? The reason is that each iteration
    of the for loop is guaranteed to leave line with one or more words that we have
    not output yet. Consider what happens with each word that we process. If the current
    word fits on the current line, we don’t output anything. If the current word doesn’t
    fit on the current line, then we output the current line, but not the word on
    the next line. We therefore need to write line to the output file *after* the
    loop ❼; otherwise, the last line in the essay will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: The final thing we do is close both files.
  prefs: []
  type: TYPE_NORMAL
- en: One annoying aspect of writing to a file rather than the screen is that we aren’t
    shown the output when we run the program. To see the output, we have to open the
    output file in our text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a tip: develop the program using print calls rather than write calls
    so that all output goes to the screen. That should make it easier to find errors
    in your program and avoid having to switch back and forth between your code and
    the output file. Once you’re happy with the code, you can change the print calls
    back to write calls. Then be sure to do a little more testing, just to make sure
    that everything ends up in the file as it should.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re ready to submit to the USACO judge. Send it our code! All test cases should
    pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #17: Farm Seeding'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use a loop to read a specified number of lines from a file. We’ll do
    that in this problem, and we’ll see that it’s similar to using a loop with input
    to read from standard input.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.xhtml#ch06), when we solved Action Figures, we learned about
    top-down design using functions. It’s an important skill, composing multiple functions
    to solve a problem. And since there isn’t much more to say about files, I’ve chosen
    a problem that doubles as a site for top-down design.
  prefs: []
  type: TYPE_NORMAL
- en: This is a challenging problem. We’ll first need to understand exactly what we’re
    being asked to do. After that, we’ll need to develop a way to solve the problem
    and think carefully about why our solution is correct.
  prefs: []
  type: TYPE_NORMAL
- en: This is USACO 2019 February Bronze Contest problem The Great Revegetation.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Farmer John has *n* pastures, all of which he would like to seed with grass.
    The pastures are numbered 1, 2, . . ., *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Farmer John has four different types of grass seed, numbered 1, 2, 3, and 4\.
    He’ll choose one of these grass types for each pasture.
  prefs: []
  type: TYPE_NORMAL
- en: Farmer John also has *m* cows. Each cow has two favorite pastures in which it
    eats grass. Each cow cares only about its two favorite pastures, no others. For
    a healthy diet, each cow requires that its two pastures have different types of
    grass. For example, for some given cow, it would be okay if one of its pastures
    had grass type 1 and the other had grass type 4\. But it would not be okay if
    both of its pastures had grass type 1.
  prefs: []
  type: TYPE_NORMAL
- en: A pasture might be the favorite of more than one cow. But it’s guaranteed that
    a pasture is the favorite of no more than three cows.
  prefs: []
  type: TYPE_NORMAL
- en: Determine the grass type to use in each pasture. Each pasture is required to
    use a grass type between 1 and 4, and each cow’s two favorite pastures must have
    different grass types.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Read input from the file named *revegetate.in*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing two integers separated by a space. The first integer is *n*,
    the number of pastures; it’s between 2 and 100\. The second integer is *m*, the
    number of cows; it’s between 1 and 150.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*m* lines, each of which gives the two favorite pasture numbers for a cow.
    These pasture numbers are integers between 1 and *n* and are separated by a space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write output to the file named *revegetate.out*.
  prefs: []
  type: TYPE_NORMAL
- en: Output a valid way to seed the pastures. The output is a line of *n* characters,
    each of which is a '1', '2', '3', or '4'. The first character is the grass type
    for pasture 1, the second is the grass type for pasture 2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We can interpret these *n* characters as an integer with *n* digits. For example,
    if we have the five grass types '11123', then we can interpret this as the integer
    11123.
  prefs: []
  type: TYPE_NORMAL
- en: This integer interpretation comes into play when we have a choice of what to
    output. If there are multiple valid ways to seed the pastures, we must output
    the one that’s smallest when interpreted as an integer. For example, if both '11123'
    and '22123' are valid, we output the string '11123' because 11123 is less than
    22123.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to use top-down design to arrive at a solution for this problem.
    Working through a test case will help us sift the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: 8 6
  prefs: []
  type: TYPE_NORMAL
- en: 5 4
  prefs: []
  type: TYPE_NORMAL
- en: 2 4
  prefs: []
  type: TYPE_NORMAL
- en: 3 5
  prefs: []
  type: TYPE_NORMAL
- en: 4 1
  prefs: []
  type: TYPE_NORMAL
- en: 2 1
  prefs: []
  type: TYPE_NORMAL
- en: 5 2
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the test case tells us that we have eight pastures. They’re
    numbered from 1 to 8\. The first line also tells us that we have six cows. The
    problem doesn’t specify a numbering for the cows, so I’ll just number them starting
    at 0\. The two favorite pastures of each cow are in [Table 7-1](ch07.xhtml#ch07tab01)
    for easy reference.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Farm Seeding Example, Cows'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Cow** | **Pasture 1** | **Pasture 2** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 5 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 3 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 4 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 5 | 2 |'
  prefs: []
  type: TYPE_TB
- en: In this problem, we’re being asked to make *n* decisions. What grass type should
    we use for pasture 1? What grass type should we use for pasture 2? Pasture 3?
    Pasture 4? And so on, all the way up to pasture *n*. One strategy for these kinds
    of problems is to make one decision at a time, without making a mistake on any
    of them. If we manage to finish with decision *n* and haven’t made any mistakes
    along the way, then our solution must be correct.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through the pastures from 1 to 8 and see if we can assign a grass type
    to each of them. We need to prioritize choosing small-numbered grass types so
    that we end with the smallest grass types when interpreted as a number.
  prefs: []
  type: TYPE_NORMAL
- en: What grass type should we choose for pasture 1? The only cows that care about
    pasture 1 are cows 3 and 4, so we focus only on those two. If we had already chosen
    grass types for some of these cows’ pastures, then we’d have to be careful with
    our choice for pasture 1\. We wouldn’t want to give some cow two pastures with
    the same grass type, because that would break the rules! We haven’t chosen any
    grass types yet, so nothing can go wrong no matter what we choose for pasture
    1\. Since we want the smallest grass types, though, we’ll choose grass type 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll collect our grass-type decisions in tables. Here’s the decision we just
    made, grass type 1 for pasture 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pasture** | **Grass type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s move on. What grass type should we choose for pasture 2? The cows that
    care about pasture 2 are cows 1, 4, and 5, so we focus on those. One of cow 4’s
    pastures is pasture 1, and we chose grass type 1 for that pasture, so grass type
    1 is eliminated as a grass type for pasture 2\. If we used grass type 1 for pasture
    2, then we’d be giving cow 4 two pastures with the same grass type, and that would
    break the rules. Cows 1 and 5, however, don’t eliminate any other grass types,
    because we haven’t chosen grass types for their pastures yet. We therefore choose
    grass type 2, the smallest-numbered grass type that’s available. Here’s where
    we stand:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pasture** | **Grass type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'What grass type should we choose for pasture 3? The only cow that cares about
    pasture 3 is cow 2\. Cow 2’s pastures are pastures 3 and 5\. That cow doesn’t
    eliminate any grass types, however, because we haven’t assigned a grass type to
    pasture 5! To get the smallest number, we’ll use grass type 1 for pasture 3\.
    Here’s our next snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pasture** | **Grass type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: I can see three tasks in our top-down design crystallizing here. First, we need
    to obtain the cows that care about the current pasture. Second, we need to determine
    which grass types those cows eliminate from consideration. Third, we need to choose
    the smallest-numbered grass type that wasn’t eliminated. Each of those is a prime
    candidate for a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s keep going. We have three cows that care about pasture 4: cows 0, 1,
    and 3\. Cow 0 doesn’t eliminate any grass types, because we haven’t assigned grass
    types to its pastures yet. Cow 1 eliminates grass type 2 because we assigned grass
    type 2 to pasture 2 (its other pasture). And cow 3 eliminates grass type 1 because
    we assigned grass type 1 to pasture 1 (its other pasture). The smallest available
    grass type, then, is 3, so that’s what we use for pasture 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pasture** | **Grass type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 3 |'
  prefs: []
  type: TYPE_TB
- en: On to pasture 5\. The cows that care about pasture 5 are cows 0, 2, and 5\.
    Cow 0 eliminates grass type 3; cow 2 eliminates grass type 1; and cow 5 eliminates
    grass type 2\. So grass types 1, 2, and 3 are out. Our only choice is grass type
    4.
  prefs: []
  type: TYPE_NORMAL
- en: That was close! We almost ran out of grass types there. Lucky for us, there
    was no other cow that cared about pasture 5 and eliminated grass type 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, wait. This wasn’t luck at all, because of this bit from the problem description:
    “It’s guaranteed that a pasture is the favorite of no more than three cows.” This
    means that at most three grass types can be eliminated for each pasture. We’ll
    never be stuck! And we don’t even have to worry about the ramifications of past
    choices on our next decision. No matter what we did in the past, we’ll always
    have at least one available grass type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add pasture 5 to our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pasture** | **Grass type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 4 |'
  prefs: []
  type: TYPE_TB
- en: 'There are three pastures to go. But no cow cares about any of them, so we can
    just use grass type 1 in each case. That gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pasture** | **Grass type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'We can read the grass types from top to bottom to obtain the correct output
    for this example. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '12134111'
  prefs: []
  type: TYPE_NORMAL
- en: Top-Down Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a good understanding of the tasks that we’ll need to complete, we’ll turn
    to a top-down design of this problem.
  prefs: []
  type: TYPE_NORMAL
- en: The Top Level
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We discovered three tasks in the previous section as we worked through a test
    case. Before our program can solve any of those tasks, we need to read the input,
    so that’s a fourth task. We also need to write the output. That will take some
    thought and a few lines of code, so let’s call that our fifth task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are our five main tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Read input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify cows that care about current pasture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eliminate grass types for current pasture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose smallest-numbered grass type for current pasture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we did when solving Action Figures in [Chapter 6](ch06.xhtml#ch06), we’ll
    start with a framework of TODO comments and remove each TODO as we solve it.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with mostly comments. Since we’ll need to open the files at the start
    and close them at the end, I’ve also added that code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s where we begin:'
  prefs: []
  type: TYPE_NORMAL
- en: Main Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: input_file = open('revegetate.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('revegetate.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: 'TODO: Read input'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TODO: Identify cows that care about pasture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TODO: Eliminate grass types for pasture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TODO: Choose smallest-numbered grass type for pasture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TODO: Write output'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 1: Read Input'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Reading the first line of input, with the integers *n* and *m*, is something
    we know how to do. It’s straightforward enough that I don’t think we need a function
    for it, so let’s do it directly. Next we need to read the pasture information
    for the *m* cows, and here a function seems warranted. Let’s remove the TODO in
    the Read input comment, handle the first line of input, and call the read_cows
    function, which we’ll write shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '# Main Program'
  prefs: []
  type: TYPE_NORMAL
- en: input_file = open('revegetate.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('revegetate.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: '# Read input'
  prefs: []
  type: TYPE_NORMAL
- en: lst = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: num_pastures = int(lst[0])
  prefs: []
  type: TYPE_NORMAL
- en: num_cows = int(lst[1])
  prefs: []
  type: TYPE_NORMAL
- en: ❶ favorites = read_cows(input_file, num_cows)
  prefs: []
  type: TYPE_NORMAL
- en: '# TODO: Identify cows that care about pasture'
  prefs: []
  type: TYPE_NORMAL
- en: '# TODO: Eliminate grass types for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: '# TODO: Choose smallest-numbered grass type for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: '# TODO: Write output'
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: 'The read_cows function that we’re calling ❶ will take a file that’s already
    open for reading, and read the two favorite pastures for each cow. It’ll return
    a list of lists, where each inner list contains the two pasture numbers for a
    given cow. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_cows(input_file, num_cows):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: input_file is a file open for reading; cow information is next to read.
  prefs: []
  type: TYPE_NORMAL
- en: num_cows is the number of cows in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Read the cows' favorite pastures from input_file.
  prefs: []
  type: TYPE_NORMAL
- en: Return a list of each cow's two favorite pastures;
  prefs: []
  type: TYPE_NORMAL
- en: each value in the list is a list of two values giving the
  prefs: []
  type: TYPE_NORMAL
- en: favorite pastures for one cow.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: favorites = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(num_cows):'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ lst = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: lst[0] = int(lst[0])
  prefs: []
  type: TYPE_NORMAL
- en: lst[1] = int(lst[1])
  prefs: []
  type: TYPE_NORMAL
- en: ❷ favorites.append(lst)
  prefs: []
  type: TYPE_NORMAL
- en: return favorites
  prefs: []
  type: TYPE_NORMAL
- en: This function accumulates the cows’ favorite pastures into the favorites list.
    It does that using a range for loop that loops num_cows times, once for each cow.
    We need the loop because the number of lines to read depends on the number of
    cows in the file.
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration of the loop, we read the next line and split it into its two
    components ❶. We then use int to convert the components from strings to integers.
    When we append this list to favorites ❷, we’re therefore appending a list of two
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we do is return the list of favorite pastures.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, let’s make sure that we know how to call this function.
    We’ll practice calling it on its own, independent from the larger program that
    we’re building. It’s useful to test functions like this so that we can fix any
    errors that we might find along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your text editor to create a file named *revegetate.in* with the following
    contents (the same as the test case we studied earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: 8 6
  prefs: []
  type: TYPE_NORMAL
- en: 5 4
  prefs: []
  type: TYPE_NORMAL
- en: 2 4
  prefs: []
  type: TYPE_NORMAL
- en: 3 5
  prefs: []
  type: TYPE_NORMAL
- en: 4 1
  prefs: []
  type: TYPE_NORMAL
- en: 2 1
  prefs: []
  type: TYPE_NORMAL
- en: 5 2
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the Python shell, enter the code for our read_cows function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we do to call read_cows:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> input_file = open(''revegetate.in'', ''r'')'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ >>> input_file.readline()
  prefs: []
  type: TYPE_NORMAL
- en: '''8 6\n'''
  prefs: []
  type: TYPE_NORMAL
- en: ❷ >>> read_cows(input_file, 6)
  prefs: []
  type: TYPE_NORMAL
- en: '[[5, 4], [2, 4], [3, 5], [4, 1], [2, 1], [5, 2]]'
  prefs: []
  type: TYPE_NORMAL
- en: The read_cows function reads only the information for the cows. Since we’re
    testing this function in isolation, outside of our program, we need to read the
    first line of the file ourselves before we call it ❶. When we then call read_cows,
    we get back a list giving the favorite pastures for each cow. Also notice that
    we’re calling read_cows with an open file, *not* a filename ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to include our read_cows function, along with the functions we’ll write
    for other tasks, before our # Main Program comment. Then we can move on to Task
    2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 2: Identify Cows'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our overall strategy for solving this problem is to consider each pasture in
    turn, deciding which grass type to use. We’ll organize this work inside a loop,
    with each iteration of the loop responsible for seeding one pasture. For each
    pasture, we need to identify the cows that care about the pasture, eliminate the
    used grass types, and choose the smallest-numbered available grass type. These
    three tasks must run for each pasture, so we’ll indent them inside the loop.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll write a function called cows_with_favorite that tells us the cows who
    care about the current pasture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we’ve got now for our main program:'
  prefs: []
  type: TYPE_NORMAL
- en: Main Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: input_file = open('revegetate.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('revegetate.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: Read input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: lst = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: num_pastures = int(lst[0])
  prefs: []
  type: TYPE_NORMAL
- en: num_cows = int(lst[1])
  prefs: []
  type: TYPE_NORMAL
- en: favorites = read_cows(input_file, num_cows)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, num_pastures + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '# Identify cows that care about pasture'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ cows = cows_with_favorite(favorites, i)
  prefs: []
  type: TYPE_NORMAL
- en: '# TODO: Eliminate grass types for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: '# TODO: Choose smallest-numbered grass type for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: 'TODO: Write output'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: 'The cows_with_favorite function that we’re calling ❶ takes a list of the cows’
    favorite pastures and a pasture number and returns the cows that care about that
    pasture. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def cows_with_favorite(favorites, pasture):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: favorites is a list of favorite pastures, as returned by read_cows.
  prefs: []
  type: TYPE_NORMAL
- en: pasture is a pasture number.
  prefs: []
  type: TYPE_NORMAL
- en: Return list of cows that care about pasture.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: cows = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(favorites)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if favorites[i][0] == pasture or favorites[i][1] == pasture:'
  prefs: []
  type: TYPE_NORMAL
- en: cows.append(i)
  prefs: []
  type: TYPE_NORMAL
- en: return cows
  prefs: []
  type: TYPE_NORMAL
- en: The function loops through favorites, looking for cows that care about pasture
    number pasture. Each cow that cares about the pasture is added to the cows list
    that is ultimately returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do a little test. Enter our cows_with_favorite function into the Python
    shell. Here’s the call that we’ll try:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> cows_with_favorite([[5, 4], [2, 4], [3, 5]], 5)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three cows here, and we’re asking which ones care about pasture 5.
    The cows at indices 0 and 2 care about pasture 5, and that’s exactly what the
    function tells us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[0, 2]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 3: Eliminate Grass Types'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we know the cows that care about the current pasture. Our next step is to
    figure out which grass types these cows eliminate from consideration for the current
    pasture. We eliminate the grass types that are used in a pasture associated with
    one or more of these cows. We’ll write a function called types_used that tells
    us the grass types that have already been used (and are therefore eliminated for
    the current pasture).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our main program, updated with a call to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '# Main Program'
  prefs: []
  type: TYPE_NORMAL
- en: input_file = open('revegetate.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('revegetate.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: '# Read input'
  prefs: []
  type: TYPE_NORMAL
- en: lst = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: num_pastures = int(lst[0])
  prefs: []
  type: TYPE_NORMAL
- en: num_cows = int(lst[1])
  prefs: []
  type: TYPE_NORMAL
- en: favorites = read_cows(input_file, num_cows)
  prefs: []
  type: TYPE_NORMAL
- en: ❶ pasture_types = [0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, num_pastures + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '# Identify cows that care about pasture'
  prefs: []
  type: TYPE_NORMAL
- en: cows = cows_with_favorite(favorites, i)
  prefs: []
  type: TYPE_NORMAL
- en: '# Eliminate grass types for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ eliminated = types_used(favorites, cows, pasture_types)
  prefs: []
  type: TYPE_NORMAL
- en: '# TODO: Choose smallest-numbered grass type for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: '# TODO: Write output'
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: In addition to calling the types_used function ❷, I’ve also added a variable
    called pasture_types ❶. The list referred to by this variable will keep track
    of the grass type for each pasture.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the pastures are numbered starting from 1\. Python lists, on the
    other hand, are indexed starting from 0\. I don’t like this discrepancy; if we
    simply started adding grass types to pasture_types, then the grass type for pasture
    1 would be at index 0, the grass type for pasture 2 would be at index 1, and so
    on, always off by one. That’s why I added a bogus 0 at the beginning of the list
    ❶; when we later add the grass type for pasture 1, it’ll be placed at index 1
    to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we’ve figured out the grass types for the first four pastures. Here’s
    how pasture_types might look at that point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[0, 1, 2, 1, 3]'
  prefs: []
  type: TYPE_NORMAL
- en: If we want the grass type for pasture 1, we look at index 1; if we want the
    grass type for pasture 2, we look at index 2; and so on. If we want the grass
    type for pasture 5? Well, no, we can’t have that, because we haven’t figured it
    out yet. If the length of pasture_types is 5, it means that we’ve figured out
    the grass types for only the first four pastures. In general, the number of grass
    types that we’ve figured out is one less than the list’s length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re ready for the types_used function. It takes three parameters: the
    list of favorite pastures for each cow, the cows that care about the current pasture,
    and the grass types chosen for pastures so far. It returns the list of grass types
    that are already used and therefore eliminated for the current pasture. Here goes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def types_used(favorites, cows, pasture_types):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: favorites is a list of favorite pastures, as returned by read_cows.
  prefs: []
  type: TYPE_NORMAL
- en: cows is a list of cows.
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types is a list of grass types.
  prefs: []
  type: TYPE_NORMAL
- en: Return a list of the grass types already used by cows.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: used = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for cow in cows:'
  prefs: []
  type: TYPE_NORMAL
- en: pasture_a = favorites[cow][0]
  prefs: []
  type: TYPE_NORMAL
- en: pasture_b = favorites[cow][1]
  prefs: []
  type: TYPE_NORMAL
- en: '❶ if pasture_a < len(pasture_types):'
  prefs: []
  type: TYPE_NORMAL
- en: used.append(pasture_types[pasture_a])
  prefs: []
  type: TYPE_NORMAL
- en: '❷ if pasture_b < len(pasture_types):'
  prefs: []
  type: TYPE_NORMAL
- en: used.append(pasture_types[pasture_b])
  prefs: []
  type: TYPE_NORMAL
- en: return used
  prefs: []
  type: TYPE_NORMAL
- en: Each cow has two favorite pastures, which I refer to by pasture_a and pasture_b.
    For each of these pastures, we check whether a grass type has already been chosen
    for it at ❶ and ❷. A grass type has already been chosen if that pasture is already
    an index in pasture_types. These grass types are all added to the used list, which
    the function returns after looping through all of the relevant cows.
  prefs: []
  type: TYPE_NORMAL
- en: What if more than one cow uses the same pasture—what does our code do then?
    Let’s come up with a simple test case to answer that question.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter our types_used function into the Python shell. Here’s a call of that
    function; let’s predict what it returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> types_used([[5, 4], [2, 4], [3, 5]], [0, 1], [0, 1, 2, 1, 3])'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s be careful so we don’t get lost. The first argument gives the favorite
    pastures for three cows. The second argument gives the cows that care about a
    particular pasture; these are cows 0 and 1. And the third argument gives the grass
    types that we’ve decided on so far.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what are the grass types already used, and therefore eliminated, by cows
    0 and 1? Cow 0 cares about pasture 4, and pasture 4 uses grass type 3, so grass
    type 3 is eliminated. Cow 1 cares about pasture 2, and pasture 2 uses grass type
    2, so grass type 2 is eliminated. Cow 1 also cares about pasture 4—but we already
    know, from cow 0, that pasture 4’s grass type 3 is eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return value of our function is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[3, 2, 3]'
  prefs: []
  type: TYPE_NORMAL
- en: Two 3s in there, one coming from cow 0 and the other from cow 1.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem tidier to have just one 3 in there, but what we have—with the duplicate—is
    just fine. If a grass type is in that list, then it’s eliminated, no matter whether
    it’s in there once, twice, or three times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 4: Choose Smallest-Numbered Grass Type'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Having obtained the grass types that are eliminated, we can move onto our next
    task: choosing the smallest-numbered available grass type for the current pasture.
    To solve this one, we’ll call a new function, smallest_available. It will return
    the grass type that we should use for the current pasture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the main program, updated with a call to the smallest_available function:'
  prefs: []
  type: TYPE_NORMAL
- en: Main Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: input_file = open('revegetate.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('revegetate.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: Read input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: lst = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: num_pastures = int(lst[0])
  prefs: []
  type: TYPE_NORMAL
- en: num_cows = int(lst[1])
  prefs: []
  type: TYPE_NORMAL
- en: favorites = read_cows(input_file, num_cows)
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types = [0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, num_pastures + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '# Identify cows that care about pasture'
  prefs: []
  type: TYPE_NORMAL
- en: cows = cows_with_favorite(favorites, i)
  prefs: []
  type: TYPE_NORMAL
- en: '# Eliminate grass types for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: eliminated = types_used(favorites, cows, pasture_types)
  prefs: []
  type: TYPE_NORMAL
- en: '# Choose smallest-numbered grass type for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ pasture_type = smallest_available(eliminated)
  prefs: []
  type: TYPE_NORMAL
- en: ❷ pasture_types.append(pasture_type)
  prefs: []
  type: TYPE_NORMAL
- en: 'TODO: Write output'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: Once we obtain the smallest-numbered grass type for the current pasture ❶, we
    add it to our list of chosen grass types ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the smallest_available function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def smallest_available(used):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: used is a list of used grass types.
  prefs: []
  type: TYPE_NORMAL
- en: Return the smallest-numbered grass type that is not in used.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: grass_type = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'while grass_type in used:'
  prefs: []
  type: TYPE_NORMAL
- en: grass_type = grass_type + 1
  prefs: []
  type: TYPE_NORMAL
- en: return grass_type
  prefs: []
  type: TYPE_NORMAL
- en: The function begins with grass type 1. It then loops until it finds a grass
    type that isn’t already used, increasing the grass type by one on each iteration.
    Once a free grass type is found, the function returns it. And remember, there
    are at most three grass types that have been used out of the four available, so
    this function is guaranteed to be successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task 5: Write Output'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve got our answer, right there in pasture_types! Now all we have to do is
    output it. Here’s the main program a final time:'
  prefs: []
  type: TYPE_NORMAL
- en: '# Main Program'
  prefs: []
  type: TYPE_NORMAL
- en: input_file = open('revegetate.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('revegetate.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: '# Read input'
  prefs: []
  type: TYPE_NORMAL
- en: lst = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: num_pastures = int(lst[0])
  prefs: []
  type: TYPE_NORMAL
- en: num_cows = int(lst[1])
  prefs: []
  type: TYPE_NORMAL
- en: favorites = read_cows(input_file, num_cows)
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types = [0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, num_pastures + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '# Identify cows that care about pasture'
  prefs: []
  type: TYPE_NORMAL
- en: cows = cows_with_favorite(favorites, i)
  prefs: []
  type: TYPE_NORMAL
- en: '# Eliminate grass types for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: eliminated = types_used(favorites, cows, pasture_types)
  prefs: []
  type: TYPE_NORMAL
- en: '# Choose smallest-numbered grass type for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: pasture_type = smallest_available(eliminated)
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types.append(pasture_type)
  prefs: []
  type: TYPE_NORMAL
- en: '# Write output'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ pasture_types.pop(0)
  prefs: []
  type: TYPE_NORMAL
- en: ❷ write_pastures(output_file, pasture_types)
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: Before writing the output, we remove the bogus 0 at the beginning of pasture_types
    ❶. We don’t want to output that 0, as it isn’t a real grass type. Then, we call
    write_pastures to actually write the output ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need now is the write_pastures function. It takes a file open for writing,
    and a list of grass types, and outputs the grass types to the file. Here’s the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def write_pastures(output_file, pasture_types):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: output_file is a file open for writing.
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types is a list of integer grass types.
  prefs: []
  type: TYPE_NORMAL
- en: Output pasture_types to output_file.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types_str = []
  prefs: []
  type: TYPE_NORMAL
- en: '❶ for pasture_type in pasture_types:'
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types_str.append(str(pasture_type))
  prefs: []
  type: TYPE_NORMAL
- en: ❷ output = ''.join(pasture_types_str)
  prefs: []
  type: TYPE_NORMAL
- en: ❸ output_file.write(output + '\n')
  prefs: []
  type: TYPE_NORMAL
- en: Right now, pasture_types is a list of integers. As we’ll see in a second, it’s
    more convenient to work with a list of strings here, so I create a new list with
    each integer as a string ❶. I don’t modify the pasture_types list itself, because
    that could shock the caller of this function. The caller calls this function expecting
    only that output gets written to output_file, not that its pasture_types list
    is modified. The function has no business modifying its list parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To produce the output, we need to call write with a string, not a list. And
    we need to output the strings from the list with no spaces between them. The string
    join method works wonderfully here. As we learned in “Joining a List into a String”
    in [Chapter 5](ch05.xhtml#ch05), the string that we call join on serves as the
    separator that’s placed between values in the list. Since we don’t want any separator
    between the values, we use an empty string as the separator ❷. The join method
    works only on a list of strings, not a list of integers, which is why I converted
    the list of integers to a list of strings at the start of this function ❶.
  prefs: []
  type: TYPE_NORMAL
- en: With the output as a single string, we can write it to the file ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The complete program is in [Listing 7-2](ch07.xhtml#ch07ex02).
  prefs: []
  type: TYPE_NORMAL
- en: 'def read_cows(input_file, num_cows):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: input_file is a file open for reading; cow information is next to read.
  prefs: []
  type: TYPE_NORMAL
- en: num_cows is the number of cows in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Read the cows' favorite pastures from input_file.
  prefs: []
  type: TYPE_NORMAL
- en: Return a list of each cow's two favorite pastures;
  prefs: []
  type: TYPE_NORMAL
- en: each value in the list is a list of two values giving the
  prefs: []
  type: TYPE_NORMAL
- en: favorite pastures for one cow.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: favorites = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(num_cows):'
  prefs: []
  type: TYPE_NORMAL
- en: lst = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: lst[0] = int(lst[0])
  prefs: []
  type: TYPE_NORMAL
- en: lst[1] = int(lst[1])
  prefs: []
  type: TYPE_NORMAL
- en: favorites.append(lst)
  prefs: []
  type: TYPE_NORMAL
- en: return favorites
  prefs: []
  type: TYPE_NORMAL
- en: 'def cows_with_favorite(favorites, pasture):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: favorites is a list of favorite pastures, as returned by read_cows.
  prefs: []
  type: TYPE_NORMAL
- en: pasture is a pasture number.
  prefs: []
  type: TYPE_NORMAL
- en: Return list of cows that care about pasture.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: cows = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(favorites)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if favorites[i][0] == pasture or favorites[i][1] == pasture:'
  prefs: []
  type: TYPE_NORMAL
- en: cows.append(i)
  prefs: []
  type: TYPE_NORMAL
- en: return cows
  prefs: []
  type: TYPE_NORMAL
- en: 'def types_used(favorites, cows, pasture_types):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: favorites is a list of favorite pastures, as returned by read_cows.
  prefs: []
  type: TYPE_NORMAL
- en: cows is a list of cows.
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types is a list of grass types.
  prefs: []
  type: TYPE_NORMAL
- en: Return a list of the grass types already used by cows.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: used = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for cow in cows:'
  prefs: []
  type: TYPE_NORMAL
- en: pasture_a = favorites[cow][0]
  prefs: []
  type: TYPE_NORMAL
- en: pasture_b = favorites[cow][1]
  prefs: []
  type: TYPE_NORMAL
- en: 'if pasture_a < len(pasture_types):'
  prefs: []
  type: TYPE_NORMAL
- en: used.append(pasture_types[pasture_a])
  prefs: []
  type: TYPE_NORMAL
- en: 'if pasture_b < len(pasture_types):'
  prefs: []
  type: TYPE_NORMAL
- en: used.append(pasture_types[pasture_b])
  prefs: []
  type: TYPE_NORMAL
- en: return used
  prefs: []
  type: TYPE_NORMAL
- en: 'def smallest_available(used):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: used is a list of used grass types.
  prefs: []
  type: TYPE_NORMAL
- en: Return the smallest-numbered grass type that is not in used.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: grass_type = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'while grass_type in used:'
  prefs: []
  type: TYPE_NORMAL
- en: grass_type = grass_type + 1
  prefs: []
  type: TYPE_NORMAL
- en: return grass_type
  prefs: []
  type: TYPE_NORMAL
- en: 'def write_pastures(output_file, pasture_types):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: output_file is a file open for writing.
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types is a list of integer grass types.
  prefs: []
  type: TYPE_NORMAL
- en: Output pasture_types to output_file.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types_str = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for pasture_type in pasture_types:'
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types_str.append(str(pasture_type))
  prefs: []
  type: TYPE_NORMAL
- en: output = ''.join(pasture_types_str)
  prefs: []
  type: TYPE_NORMAL
- en: output_file.write(output + '\n')
  prefs: []
  type: TYPE_NORMAL
- en: Main Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: input_file = open('revegetate.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('revegetate.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: Read input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: lst = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: num_pastures = int(lst[0])
  prefs: []
  type: TYPE_NORMAL
- en: num_cows = int(lst[1])
  prefs: []
  type: TYPE_NORMAL
- en: favorites = read_cows(input_file, num_cows)
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types = [0]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, num_pastures + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '# Identify cows that care about pasture'
  prefs: []
  type: TYPE_NORMAL
- en: cows = cows_with_favorite(favorites, i)
  prefs: []
  type: TYPE_NORMAL
- en: '# Eliminate grass types for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: eliminated = types_used(favorites, cows, pasture_types)
  prefs: []
  type: TYPE_NORMAL
- en: '# Choose smallest-numbered grass type for pasture'
  prefs: []
  type: TYPE_NORMAL
- en: pasture_type = smallest_available(eliminated)
  prefs: []
  type: TYPE_NORMAL
- en: pasture_types.append(pasture_type)
  prefs: []
  type: TYPE_NORMAL
- en: Write output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pasture_types.pop(0)
  prefs: []
  type: TYPE_NORMAL
- en: write_pastures(output_file, pasture_types)
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-2: Solving Farm Seeding*'
  prefs: []
  type: TYPE_NORMAL
- en: We did it! An intimidating problem, made more manageable by the application
    of top-down design. Feel free to submit our work to the USACO judge.
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to be overwhelmed by a problem when you first read it. But remember
    that you don’t need to tackle it in one huge step. Break it down, solve each task
    that you can solve, and you’ll be well on your way to a solution for the overall
    problem. You’ve made huge strides in the amount of Python that you know and your
    ability to design programs and solve problems. Solving these problems is within
    your grasp!
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s think about a new version of Farm Seeding where there’s no restriction
    on the number of cows that care about a pasture. A pasture might be the favorite
    of four cows, five cows, or even more. We’re still not allowed to give a cow two
    pastures with the same grass type.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we’re solving this new version of the problem and have a test case
    where a pasture is the favorite of more than three cows. Which of the following
    is true of that test case?
  prefs: []
  type: TYPE_NORMAL
- en: A. It’s *guaranteed* that there’s *no way* to solve it with only four grass
    types.
  prefs: []
  type: TYPE_NORMAL
- en: B. There might be a way to solve it. If there is, it’s *possible* that our original
    solution ([Listing 7-2](ch07.xhtml#ch07ex02)) *will* do so.
  prefs: []
  type: TYPE_NORMAL
- en: C. There might be a way to solve it. If there is, it’s *guaranteed* that our
    original solution ([Listing 7-2](ch07.xhtml#ch07ex02)) *will* do so.
  prefs: []
  type: TYPE_NORMAL
- en: D. There might be a way to solve it. If there is, it’s *guaranteed* that our
    original solution ([Listing 7-2](ch07.xhtml#ch07ex02)) *won’t* do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. We can find a test case that is correctly solved by our program,
    and we can find a test case that can be solved but not by our program. The former
    eliminates A and D as correct responses; the latter eliminates C as the correct
    response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a test case that is correctly solved by our program:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 4
  prefs: []
  type: TYPE_NORMAL
- en: 1 2
  prefs: []
  type: TYPE_NORMAL
- en: 1 2
  prefs: []
  type: TYPE_NORMAL
- en: 1 2
  prefs: []
  type: TYPE_NORMAL
- en: 1 2
  prefs: []
  type: TYPE_NORMAL
- en: Each pasture is the favorite of four cows. Nevertheless, we can solve this test
    case using only two grass types. Try our program, and you should see that it correctly
    solves this test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now here’s a test case that can be solved, but not by our program:'
  prefs: []
  type: TYPE_NORMAL
- en: 6 10
  prefs: []
  type: TYPE_NORMAL
- en: 2 3
  prefs: []
  type: TYPE_NORMAL
- en: 2 4
  prefs: []
  type: TYPE_NORMAL
- en: 3 4
  prefs: []
  type: TYPE_NORMAL
- en: 2 5
  prefs: []
  type: TYPE_NORMAL
- en: 3 5
  prefs: []
  type: TYPE_NORMAL
- en: 4 5
  prefs: []
  type: TYPE_NORMAL
- en: 1 6
  prefs: []
  type: TYPE_NORMAL
- en: 3 6
  prefs: []
  type: TYPE_NORMAL
- en: 4 6
  prefs: []
  type: TYPE_NORMAL
- en: 5 6
  prefs: []
  type: TYPE_NORMAL
- en: The mistake that our program makes is to use grass type 1 for pasture 1\. In
    so doing, it’s forced to use grass type 5—which isn’t allowed!—for pasture 6\.
    Our program fails, but don’t conclude that there isn’t a way to solve this test
    case. In particular, use grass type 2 for pasture 1, and you should be able to
    find a way to solve this test case using only four grass types. It’s possible
    to solve these kinds of test cases with a more sophisticated program, and I encourage
    you to think about this on your own if you’re interested.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned how to open, read from, write to, and close files.
    Files are useful whenever you need to store information and use it as input later.
    They’re also useful for communicating information to your users. We also learned
    that we process files similarly to how we process standard input and standard
    output.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll learn how to store a collection of values in a Python
    set or dictionary. Storing a collection of values—that sounds like what a list
    does. We’ll see, though, that sets and dictionaries can make it easier for us
    to solve some kinds of problems.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try. All of them are from the USACO judge
    and require reading and writing files. They’ll also require you to dust the cobwebs
    off material from previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: USACO 2018 December Bronze Contest problem Mixing Milk
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2017 February Bronze Contest problem Why Did the Cow Cross the Road
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2017 US Open Bronze Contest problem The Lost Cow
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2019 December Bronze Contest problem Cow Gymnastics
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2017 US Open Bronze Contest problem Bovine Genomics
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2018 US Open Bronze Contest problem Team Tic Tac Toe
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2019 February Bronze Contest problem Sleepy Cow Herding
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Essay Formatting is originally from the USACO 2020 January Bronze Contest. Farm
    Seeding is originally from the USACO 2019 February Bronze Contest.
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of files besides text files. You might like to work with
    HTML files, Excel spreadsheets, PDF files, Word documents, or image files. Python
    can help! See *Automate the Boring Stuff with Python*, 2nd edition by Al Sweigart
    (No Starch Press, 2019) for much more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “perhaps better poetry” line is from J. C. R. Licklider, as quoted in *Computers
    and the World of the Future*, edited by Martin Greenberger (MIT Press, 1962):'
  prefs: []
  type: TYPE_NORMAL
- en: But some people write poetry in the language we speak. Perhaps better poetry
    will be written in the language of digital computers of the future than has ever
    been written in English.
  prefs: []
  type: TYPE_NORMAL
