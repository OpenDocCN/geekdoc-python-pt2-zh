<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header0501" class="chapter" epub:type="chapter" id="ch05" role="doc-chapter">
<header id="header0501">
<h1 class="cn"><span aria-label=" Page 79. " class="page" epub:type="pagebreak" id="p79" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch05">5</a></h1>
<h1 class="ct">Flocking Boids</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">Look closely at a flock of birds or a school of fish, and you’ll notice that although the group is composed of individual creatures, the group as a whole seems to have a life of its own. The birds in a flock align with each other as they move and flow over and around obstacles. They break formation when disturbed or startled, but then they regroup, as if controlled by some larger force.</p>
<p>In 1986, <span class="idx" data-term="Reynolds, Craig"/>Craig Reynolds created a realistic-looking simulation of the flocking behavior of birds called the <span class="idx" data-term="Boids simulations"/><span class="idx" data-term="computer-generated swarms"/><i>Boids model</i>. One remarkable thing about the Boids model (named after the stereotypical New Yorker’s pronunciation of the word <i>birds</i>) is that only three simple rules govern the interaction between individuals in the flock, yet the model produces remarkably realistic flocking behavior. The Boids model is widely studied and has even been used to animate computer-generated swarms like the marching penguins in the movie <i>Batman Returns</i> (1992).</p>
<p><span aria-label=" Page 80. " class="page" epub:type="pagebreak" id="p80" role="doc-pagebreak"/>In this project, you’ll use Reynolds’s three rules to create a Boids simulation of the flocking behavior of <i>N</i> birds and plot their positions and directions of movement over time. You’ll also provide a method to add a bird to the flock, as well as a scatter effect that you can use to study the impact of a local disturbance on the flock. Boids is called an <span class="idx" data-term="N-body simulation"/><i>N</i>-body simulation because it models a dynamic system of <i>N</i> particles that exert forces on each other.</p>
<section>
<h2 class="ah" id="ah0701"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0701">How It Works</a></h2>
<p class="paft">The three core <span class="idx" data-level1="rules" data-term="Boids simulations"/>rules of the Boids simulation are as follows:</p>
<p class="pcust2"><span class="hemb">Separation</span> Keep a minimum distance between the boids.</p>
<p class="pcust2"><span class="hemb">Alignment</span> Point each boid in the average direction of movement of its local flockmates.</p>
<p class="pcust2"><span class="hemb">Cohesion</span> Move each boid toward the center of mass of its local flockmates.</p>
<p>Boids simulations can add other rules too, such as ones to avoid obstacles or scatter the flock when it’s disturbed, as you’ll learn in the following sections. To create the Boids animation, you’ll do the following for every time step in the simulation:</p>
<ol style="list-style-type:none">
<li class="nlf">1. For all boids in the flock:
            <ol style="list-style-type:none">
<li class="nl1">a. Apply the three core rules.</li>
<li class="nl1">b. Apply any additional rules.</li>
<li class="nl1">c. Apply all boundary conditions.</li>
</ol>
</li>
<li class="nl">2. Update the positions and velocities of the boids.</li>
<li class="nll">3. Plot the new positions and velocities.</li>
</ol>
<p>As you’ll see, these simple steps create a flock with evolving, complex behavior.</p>
</section>
<section>
<h2 class="ah" id="ah0702"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0702">Requirements</a></h2>
<p class="paft">These are the Python modules you’ll be using in this simulation:</p>
<ul style="list-style-type:none">
<li class="blf">• <code>numpy</code> arrays to store the positions and velocities of the boids</li>
<li class="bl">• The <code>matplotlib</code> library to animate the boids</li>
<li class="bl">• <code>argparse</code> to process command line options</li>
<li class="bll">• The <code>scipy.spatial.distance</code> module, which has some really neat methods for calculating distances between points</li>
</ul>
<p>I chose to use <code>matplotlib</code> for boids as a matter of simplicity and convenience. To draw a huge number of boids as quickly as possible, you might use something like the OpenGL library. We’ll explore graphics in more detail in <a class="xref" href="nsp-venkitachalam503045-0018.xhtml#pt03">Part III</a> of this book.</p>
</section>
<section>
<h2 class="ah" id="ah0703"><span aria-label=" Page 81. " class="page" epub:type="pagebreak" id="p81" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0703">The Code</a></h2>
<p class="paft">You’ll encapsulate the behavior of a group of boids in a class called <code>Boids</code>. First you’ll set the initial positions and velocities of the boids. Next, you’ll set up the boundary conditions for the simulation, look at how the boids are drawn, and implement the Boids simulation rules discussed earlier. Finally, you’ll add some interesting events to the simulation by allowing the user to add boids and scatter the flock. To see the full project code, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0017.xhtml#ah0707">“The Complete Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0017.xhtml#p96">page 96</a>. You can also download it from the book’s GitHub repository at <a class="url-i" href="https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py">https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py</a>.</p>
<section>
<h3 class="bh" id="bh0701"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0701">Initializing the Simulation</a></h3>
<p class="paft">The Boids simulation needs to compute the position and velocities of the boids at each step by pulling information from <code>numpy</code> arrays. At the <span class="idx" data-level1="initial conditions" data-term="Boids simulations"/>beginning of the simulation, you use the <code>Boids</code> class’s <code>__init__()</code> method to create those arrays and initialize all boids in approximately the center of the screen, with their velocities set in random directions.</p>
<div class="codeline">
<p class="clf">import argparse</p>
<p class="cl">import math</p>
<p class="cl">import numpy as np</p>
<p class="cl">import matplotlib.pyplot as plt</p>
<p class="cl">import matplotlib.animation as animation</p>
<p class="cl">from scipy.spatial.distance import squareform, pdist</p>
<p class="cl">from numpy.linalg import norm</p>
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ width, height = 640, 480</p>
<p class="clf">class Boids:</p>
<p class="cl">    """class that represents Boids simulation"""</p>
<p class="cl">    def __init__(self, N):</p>
<p class="cl">        """initialize the Boids simulation"""</p>
<p class="cl">        # init position &amp; velocities</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.pos = [width/2.0, height/2.0] +</p>
<p class="cl">                   10*np.<span class="idx" data-level1="random" data-term="numpy module"/>random.rand(2*N).<span class="idx" data-level1="array" data-level2="reshape" data-term="numpy module"/>reshape(N, 2)</p>
<p class="cl">        # normalized random velocities</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ angles = 2*math.pi*np.random.rand(N)</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ self.vel = np.array(list(zip(np.<span class="idx" data-level1="cos" data-term="numpy module"/>cos(angles), np.<span class="idx" data-level1="sin" data-term="numpy module"/>sin(angles))))</p>
<p class="cll">        self.N = N</p>
</div>
<p>First you import the modules required for the program and set the width and height of the simulation window on the screen <!--<ccust1>1</ccust1>-->❶. Then you begin declaring the <code>Boids</code> class. Within the class’s <code>__init__()</code> method, you create a <code>numpy</code> array called <code>pos</code> to store the x- and y-coordinates of all the boids <!--<ccust1>2</ccust1>-->❷. For the initial value of each pair of coordinates, you start with the center of the window, <code>[width/2.0, height/2.0]</code>, and add a random displacement of up to 10 units. The code <code>np.random.rand(2*N)</code> creates a one-dimensional array of 2<i>N</i> random numbers in the range [0, 1], which you multiply by 10 to scale to a range of [0, 10]. The <code>reshape()</code> call converts the one-dimensional array into a two-dimensional array of shape (<i>N</i>, 2), perfect <span aria-label=" Page 82. " class="page" epub:type="pagebreak" id="p82" role="doc-pagebreak"/>for storing <i>N</i> pairs of x- and y-coordinates. Notice, too, the <code>numpy</code> <span class="idx" data-level1="broadcasting" data-term="numpy module"/>broadcasting rules in action here: the 1×2 array <code>[width/2.0, height/2.0]</code> representing the center of the window is added to each element in the <i>N</i>×2 array to randomly offset each boid’s position from the center.</p>
<p>Next, you create an array of random unit <span class="idx" data-level1="velocity" data-term="vectors"/><span class="idx" data-term="velocity vectors"/>velocity vectors (these are vectors of <span class="idx" data-level1="magnitude of" data-term="vectors"/><span class="idx" data-level1="vector" data-term="magnitude"/>magnitude 1.0, pointing in random directions) for each boid using the following method: given an angle <i>t</i>, the pair of numbers (cos(<i>t</i>), sin(<i>t</i>)) lie on a circle of radius 1.0, centered at the origin (0, 0). If you draw a line from the origin to a point on this circle, it becomes a unit vector that depends on the angle <i>t</i>. So if you choose <i>t</i> at random, you end up with a random velocity vector. <a class="xref" href="nsp-venkitachalam503045-0017.xhtml#fig5-1">Figure 5-1</a> illustrates this scheme.</p>
<figure class="figure" id="fig5-1">
<p class="fig"><img alt="" height="564" src="images/nsp-venkitachalam503045-f05001.jpg" style="width:95%; height:auto;" width="670"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 5-1:</span> Generating random unit velocity vectors</p>
</figcaption>
</figure>
<p>Returning to the code, you put this method into action by first generating an array of <i>N</i> random angles in the range [0, 2π] <!--<ccust1>3</ccust1>-->❸. Then you create an array of random unit velocity vectors by calculating the cosine and sine of those angles <!--<ccust1>4</ccust1>-->❹. You group the coordinates of each vector using Python’s built-in <span class="idx" data-term="zip() method"/><code>zip()</code> method. The following is a simple example of <code>zip()</code>. This joins two lists into a list of tuples. The <code>list()</code> is needed because just calling <code>zip</code> will create only an iterator—you need all the elements in the list.</p>
<div class="codeline">
<p class="clf">&gt;&gt;&gt; list(<code class="b">zip([0, 1, 2], [3, 4, 5]))</code></p>
<p class="cll">[(0, 3), (1, 4), (2, 5)]</p>
</div>
<p>In summary, you’ve generated two arrays that will be useful throughout the simulation, <code>pos</code> and <code>vel</code>. The first contains random positions clustered within a 10-pixel radius around the center of the screen, and the second contains unit velocities pointing in random directions. This means that at the start of the simulation, the boids will all hover around the center of the screen, pointed in random directions.</p>
<p>The <code>__init__()</code> method continues by declaring some constant values that will help govern the simulation:</p>
<div class="codeline">
<p class="clf">        # min dist of approach</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ self.minDist = 25.0</p>
<p class="cl">        # max magnitude of velocities calculated by "rules"</p>
<p class="cl"><span aria-label=" Page 83. " class="page" epub:type="pagebreak" id="p83" role="doc-pagebreak"/>      <!--<ccust1>2</ccust1>-->❷ self.maxRuleVel = 0.03</p>
<p class="cl">        # max magnitude of final velocity</p>
<p class="cll">      <!--<ccust1>3</ccust1>-->❸ self.maxVel = 2.0</p>
</div>
<p>Here you define the minimum distance of approach between two boids <!--<ccust1>1</ccust1>-->❶. You’ll use this value later to apply the separation rule. Then you define <code>maxRuleVel</code>, which limits how much a boid’s velocity can be changed each time one of the simulation rules is applied <!--<ccust1>2</ccust1>-->❷. You also define <code>maxVel</code>, which sets an overall limit on the boids’ velocities <!--<ccust1>3</ccust1>-->❸.</p>
</section>
<section>
<h3 class="bh" id="bh0702"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0702">Setting <span class="idx" data-level1="boundary conditions" data-term="Boids simulations"/>Boundary Conditions</a></h3>
<p class="paft">Birds fly in a boundless sky, but the boids must play in limited space. To create that space, you’ll set boundary conditions, as you did with the toroidal boundary condition in the Game of Life simulation in <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#ch03">Chapter 3</a>. In this case, you’ll apply a <span class="idx" data-level1="tiled boundary conditions" data-term="Boids simulations"/><i>tiled boundary condition</i> (actually the continuous space version of the boundary condition you used in <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#ch03">Chapter 3</a>).</p>
<p>Think of the Boids simulation as taking place in a tiled space: when a boid moves out of a tile, it moves in from the opposite direction to an identical tile. The main difference between the toroidal and tiled boundary conditions is that this Boids simulation won’t take place on a discrete grid; instead, the birds move over a continuous region. <a class="xref" href="nsp-venkitachalam503045-0017.xhtml#fig5-2">Figure 5-2</a> shows what those tiled boundary conditions look like.</p>
<figure class="figure" id="fig5-2">
<p class="fig"><img alt="" height="935" src="images/nsp-venkitachalam503045-f05002.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 5-2:</span> Tiled boundary conditions</p>
</figcaption>
</figure>
<p><span aria-label=" Page 84. " class="page" epub:type="pagebreak" id="p84" role="doc-pagebreak"/>Look at the tile in the middle. The birds flying out to the right are entering the tile on the right, but the boundary conditions ensure that they actually come right back into the center tile through the tile at the left. You can see the same thing happening at the top and bottom tiles.</p>
<p>You implement the tiled boundary conditions for the Boids simulation as a method on the <code>Boids</code> class:</p>
<div class="codeline">
<p class="clf">def applyBC(self):</p>
<p class="cl">    """apply boundary conditions"""</p>
<p class="cl">    deltaR = 2.0</p>
<p class="cl">    for coord in self.pos:</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ if coord[0] &gt; width + deltaR:</p>
<p class="cl">            coord[0] = - deltaR</p>
<p class="cl">        if coord[0] &lt; - deltaR:</p>
<p class="cl">            coord[0] = width + deltaR</p>
<p class="cl">        if coord[1] &gt; height + deltaR:</p>
<p class="cl">            coord[1] = - deltaR</p>
<p class="cl">        if coord[1] &lt; - deltaR:</p>
<p class="cll">            coord[1] = height + deltaR</p>
</div>
<p>This method applies the tiled boundary conditions to each set of boid coordinates in the <code>pos</code> array. For example, if an x-coordinate is greater than the width of the window <!--<ccust1>1</ccust1>-->❶, you set it back to the left edge of the window. The <code>deltaR</code> in this line provides a slight buffer, which allows the boid to move slightly outside the window before it starts coming back in from the opposite direction, thus producing a better visual effect. You perform a similar check at the left, top, and bottom edges of the window.</p>
</section>
<section>
<h3 class="bh" id="bh0703"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0703"><span class="idx" data-level1="drawing (begin)" data-term="Boids simulations"/>Drawing a Boid</a></h3>
<p class="paft">To build the animation, you need to know each boid’s position and velocity and have a way to indicate both the position and direction of motion at each time step.</p>
<section>
<h4 class="ch" id="ch0701">Plotting the Boid’s Body and Head</h4>
<p class="paft">To animate the boids, you use <code>matplotlib</code> and a little trick to plot both the position and velocity. Draw each boid as two circles, as shown in <a class="xref" href="nsp-venkitachalam503045-0017.xhtml#fig5-3">Figure 5-3</a>. The larger circle represents the body, and the smaller one represents the head. Point <i>P</i> marks the center of the body. For our purposes, you can consider <i>P</i> to be the position of the boid, and you’ll set it using coordinates from the <code>pos</code> array discussed earlier. Point <i>H</i> is the center of the head. You calculate the position of <i>H</i> according to the formula <i>H</i> = <i>P</i> + <i>k</i> × <i>V</i>, where <i>V</i> is the velocity of the boid and <i>k</i> is a constant representing the distance from the center of the body to the center of the head. This way, the boid’s head will be aligned with its direction of motion at any given time, which visually communicates the boid’s direction of movement more clearly than just drawing the body alone.</p>
<figure class="figure" id="fig5-3">
<p class="fig"><span aria-label=" Page 85. " class="page" epub:type="pagebreak" id="p85" role="doc-pagebreak"/><img alt="" height="1130" src="images/nsp-venkitachalam503045-f05003.jpg" style="width:95%; height:auto;" width="913"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 5-3:</span> Representing a boid</p>
</figcaption>
</figure>
<p>In the following snippet from the program’s <code>main()</code> function, you draw the boid’s body and head as circular markers using <code>matplotlib</code>:</p>
<div class="codeline">
<p class="clf">fig = plt.figure()</p>
<p class="cl">ax = plt.axes(xlim=(0, width), ylim=(0, height))</p>
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ pts, = ax.plot([], [], markersize=10, c='k', marker='o', ls='None')</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ head, = ax.plot([], [], markersize=4, c='r', marker='o', ls='None')</p>
<p class="cl2"><!--<ccust1>3</ccust1>-->❸ anim = <span class="idx" data-level1="animation" data-term="matplotlib module"/>animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),</p>
<p class="cll">                               interval=50)</p>
</div>
<p>You set the size and shape of the markers for the boid’s body (<code>pts</code>) <!--<ccust1>1</ccust1>-->❶ and head (<code>head</code>) <!--<ccust1>2</ccust1>-->❷. The <code>'k'</code> and <code>'r'</code> strings specify the colors black and red, respectively, and <code>'o'</code> produces a circular marker. The <code>ax.plot()</code> method returns a list of <code>matplotlib.lines.Line2D</code> objects. The <code>,</code> syntax in these lines picks up the first and only element in this list.</p>
<p>You next initialize a <code>matplotlib animation.FuncAnimation()</code> object <!--<ccust1>3</ccust1>-->❸, which sets up a callback function <code>tick()</code> to be called for every frame of the animation (we’ll look at this function later in the chapter). The <code>fargs</code> parameter lets you specify the arguments of the callback function, and you also set the time interval (50 milliseconds in this case) at which this function will be called. Now that you know how to draw the body and the head, let’s see how to update their positions.</p>
</section>
<section>
<h4 class="ch" id="ch0702">Updating the Boid’s Position</h4>
<p class="paft">Once the animation starts, you need to update both the boid’s position and the location of the head, which tells you the direction in which the boid is moving. You do so with this code:</p>
<div class="codeline">
<p class="clf">vec = self.pos + 10*self.vel/self.maxVel</p>
<p class="cll">head.set_data(vec.<span class="idx" data-level1="array" data-term="numpy module"/>reshape(2*self.N)[::2], vec.reshape(2*self.N)[1::2])</p>
</div>
<p><span aria-label=" Page 86. " class="page" epub:type="pagebreak" id="p86" role="doc-pagebreak"/>First you calculate the position of the head by applying the <i>H</i> = <i>P</i> + <i>k</i> × <i>V</i> formula discussed earlier. You use a <i>k</i> value of 10 units in the direction of the velocity (<code>vel</code>). You then update (<code>reshape</code>) the <code>matplotlib</code> axis (<code>set_data</code>) with the new values of the head position. The <code>[::2]</code> picks out the even-numbered elements (x-axis values) from the velocity list, and the <code>[1::2]</code> picks out the odd-numbered elements (y-axis values).<span class="idx" data-level1="drawing (end)" data-term="Boids simulations"/></p>
</section>
</section>
<section>
<h3 class="bh" id="bh0704"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0704"><span class="idx" data-level1="rules" data-term="Boids simulations"/>Applying the Rules of the Boids</a></h3>
<p class="paft">In this section, we’ll look at how to implement the three rules of the Boids simulation—separation, alignment, and cohesion—to recalculate the boids’ velocities at each time step. We’ll start by focusing just on the separation rule. The goal is to generate a new velocity vector for each boid that pushes it away from its nearby flockmates, defined as all the boids within a certain radius <i>R</i>. Given two boids <i>i</i> and <i>j</i> with positions <i>P</i><sub class="i">i</sub> and <i>P</i><sub class="i">j</sub>, <i>P</i><sub class="i">i</sub> − <i>P</i><sub class="i">j</sub> produces a new velocity vector for boid <i>i</i> that points away from boid <i>j</i>. We’ll call this a <i>displacement vector</i>. To calculate a new velocity vector <i>V</i><sub class="i">i</sub> for boid <i>i</i> that on average pushes it away from <i>all</i> its nearby flockmates, simply sum all the displacement vectors between boid <i>i</i> and each boid within radius <i>R</i>. In other words, <i>V</i><sub class="i">i</sub> = (<i>P</i><sub class="i">i</sub> − <i>P</i><sub>1</sub>) + (<i>P</i><sub class="i">i</sub> − <i>P</i><sub>2</sub>) + . . . (<i>P</i><sub class="i">i</sub> − <i>P</i><sub class="i">N</sub>), provided the distance between boids <i>i</i> and <i>j</i> is less than <i>R</i>. You can write this more formally as:</p>
<div class="equation">
<p class="eq"><img alt="" height="65" src="images/nsp-venkitachalam503045-m05001.jpg" width="372"/></p>
</div>
<p>Notice that implementing this rule—and, indeed, implementing the other Boids rules as well—involves calculating the distance between each boid and every other boid to determine which boids are local flockmates. The traditional way to do this in Python would be to use a pair of nested loops to iterate through the boids. As you’ll see, however, <code>numpy</code> arrays provide more efficient methods that bypass the need for loops. We’ll implement both approaches and compare the results and then apply what we’ve learned to the actual simulation code.</p>
<section>
<h4 class="ch" id="ch0703">Using Nested Loops</h4>
<p class="paft">First, let’s define a function <code>test1()</code> that implements the separation rule in a straightforward way, using loops:</p>
<div class="codeline">
<p class="clf">def test1(pos, radius):</p>
<p class="cl">    # fill output with zeros</p>
<p class="cl">    vel = np.zeros(2*N).reshape(N, 2)</p>
<p class="cl">    # for each pos</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ for (i1, p1) in enumerate(pos):</p>
<p class="cl">        # velocity contribution</p>
<p class="cl">        val = np.array([0.0, 0.0])</p>
<p class="cl">        # for each other pos</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ for (i2, p2) in enumerate(pos):</p>
<p class="cl">            if i1 != i2:</p>
<p class="cl">                # calculate distance from p1</p>
<p class="cl"><span aria-label=" Page 87. " class="page" epub:type="pagebreak" id="p87" role="doc-pagebreak"/>                dist = math.<span class="idx" data-level1="sqrt" data-term="math module"/>sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) +</p>
<p class="cl">                                 (p2[1]-p1[1])*(p2[1]-p1[1]))</p>
<p class="cl">                # apply threshold</p>
<p class="cl">              <!--<ccust1>3</ccust1>-->❸ if dist &lt; radius:</p>
<p class="cl">                  <!--<ccust1>4</ccust1>-->❹ val += (p2 - p1)</p>
<p class="cl">        # set velocity</p>
<p class="cl">        vel[i1] = val</p>
<p class="cl">    # return computed velocity</p>
<p class="cll">    return vel</p>
</div>
<p>This code uses a nested pair of loops. The outer loop <!--<ccust1>1</ccust1>-->❶ goes through each boid in the <code>pos</code> array. The inner loop <!--<ccust1>2</ccust1>-->❷ computes the distance between the current boid and each other boid in the array. If the distance is less than the threshold defined as the function’s <code>radius</code> parameter <!--<ccust1>3</ccust1>-->❸, you calculate the displacement vector as discussed earlier and add the result to <code>val</code> <!--<ccust1>4</ccust1>-->❹. At the end of each cycle of the inner loop, <code>val</code> holds a new velocity that will push the current boid away from its neighbors. You store that velocity back in the <code>vel</code> array.</p>
</section>
<section>
<h4 class="ch" id="ch0704">Using numpy Methods</h4>
<p class="paft">Now let’s define a function <code>test2()</code> that does the same thing “the <code>numpy</code> way,” <span class="idx" data-level1="avoiding" data-term="loops"/><span class="idx" data-term="avoiding loops"/>avoiding loops and using highly optimized <span class="idx" data-level1="optimization" data-term="numpy module"/><code>numpy</code> methods. You’ll also use methods from the <code>scipy.spatial.distance</code> module to efficiently calculate the distance between points:</p>
<div class="codeline">
<p class="clf">def test2(pos, radius):</p>
<p class="cl">    # get distance matrix</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ distMatrix = squareform(pdist(pos))</p>
<p class="cl">    # apply threshold</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ D = distMatrix &lt; radius</p>
<p class="cl">    # compute velocity</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ vel = pos*D.<span class="idx" data-level1="array" data-term="numpy module"/>sum(axis=1).reshape(N, 1) - D.dot(pos)</p>
<p class="cll">    return vel</p>
</div>
<p>You use the <code>squareform()</code> and <code>pdist()</code> methods (defined in the <code>scipy</code> library) to calculate the distances between every possible pair of points in the <code>pos</code> array <!--<ccust1>1</ccust1>-->❶. For an array of <i>N</i> points, <span class="idx" data-level1="spatial.squareform" data-term="scipy module"/><code>squareform()</code> gives you an <i>N</i>×<i>N</i> matrix, where any given entry <i>M</i><sub class="i">ij</sub> is the distance between points <i>P</i><sub class="i">i</sub> and <i>P</i><sub class="i">j</sub>. Let’s consider a quick example of how that looks. In this code, you call the methods on an array of three points:</p>
<div class="codeline">
<p class="clf">&gt;&gt;&gt; <code class="b">import numpy as np</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">from scipy.spatial.distance import squareform, pdist</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">x = np.array([[0.0, 0.0], [1.0, 1.0], [2.0, 2.0]])</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">squareform(pdist(x))</code></p>
<p class="cl">array([[0.        , 1.41421356, 2.82842712],</p>
<p class="cl">       [1.41421356, 0.        , 1.41421356],</p>
<p class="cll">       [2.82842712, 1.41421356, 0.        ]])</p>
</div>
<p>Since you provide an array of three points, the result is a 3×3 matrix of distance calculations. The values in the first row, for example, tell you the <span aria-label=" Page 88. " class="page" epub:type="pagebreak" id="p88" role="doc-pagebreak"/>distance between the first point (<code>[0.0, 0.0]</code>) and each point in the array. The zeros running diagonally down the array correspond to the distance between each point and itself.</p>
<p>Returning to the <code>test2()</code> function, you next <span class="idx" data-level1="spatial.distance" data-term="scipy module"/>filter the matrix based on whether the distance is less than the specified <code>radius</code> <!--<ccust1>2</ccust1>-->❷. Using the same example array of three points, you have the following:</p>
<div class="codeline">
<p class="clf">&gt;&gt;&gt; <span class="idx" data-level1="spatial.distance module" data-term="scipy module"/><code class="b">squareform(</code><span class="idx" data-level1="spatial.pdist module" data-term="scipy module"/><code class="b">pdist(x)) &lt; 1.4</code></p>
<p class="cl">array([[ True, False, False],</p>
<p class="cl">       [False,  True, False],</p>
<p class="cll">       [False, False,  True]])</p>
</div>
<p>The <code>&lt;</code> comparison creates a Boolean matrix of <code>True/False</code> values corresponding to the original distance matrix—<code>True</code> if a distance is less than the given threshold (in this example, 1.4).</p>
<p>Back in <code>test2()</code>, you use a modified version of the equation for <i>V</i><sub class="i">i</sub> discussed earlier, broadcast over the entire <code>pos</code> array <!--<ccust1>3</ccust1>-->❸. That equation can be rewritten as:</p>
<div class="equation">
<p class="eq"><img alt="" height="71" src="images/nsp-venkitachalam503045-m05002.jpg" width="207"/></p>
</div>
<p>Here, the second summation term on the right includes only the points <i>P</i> that satisfy the distance criteria. The number of elements in the summation term is <i>m</i>. This equation can again be written as:</p>
<div class="equation">
<p class="eq"><img alt="" height="50" src="images/nsp-venkitachalam503045-m05003.jpg" width="239"/></p>
</div>
<p class="pcon">where <i>D</i><sub class="i">ij</sub> is row <i>i</i> of the Boolean matrix you generated <!--<ccust1>2</ccust1>-->❷, <i>m</i> is the number of <code>True</code> values in that row, and <i>P</i><sub class="i">j</sub> is all the points <i>P</i> that fall within the specified radius of the current boid.</p>
<p>The <code>D.sum</code> method <!--<ccust1>3</ccust1>-->❸ adds up the <code>True</code> values in the Boolean matrix in a column-wise fashion, giving you <i>m</i> from the equation. The reshape is required because the result of the sum is a one-dimensional array of <i>N</i> values (shape (<i>N</i>, )), and you want it to be of shape (<i>N</i>, 1) so it’s compatible for multiplication with the position array. The <code>D.dot(pos)</code> part of the line <!--<ccust1>3</ccust1>-->❸ is taking the dot product (multiplication) of the Boolean matrix and the array of boid positions, which corresponds to the <i>D</i><sub class="i">ij</sub><i>P</i><sub class="i">j</sub> part of the equation.</p>
</section>
<section>
<h4 class="ch" id="ch0705">Comparing Approaches</h4>
<p class="paft">Comparing the two approaches, <code>test2()</code> is much more compact than <code>test1()</code>, but its real advantage is speed. Let’s use the Python <code>timeit</code> module to evaluate the <span class="idx" data-term="performance analysis"/><span class="idx" data-term="timing"/>performance of the two functions. First, enter the code for the functions <code>test1()</code> and <code>test2()</code> in a file named <i>test.py</i>, as shown here:</p>
<div class="codeline">
<p class="clf">import math</p>
<p class="cl">import numpy as np</p>
<p class="cl">from scipy.spatial.distance import squareform, pdist, cdist</p>
<p class="clf">N = 100</p>
<p class="cl">width, height = 640, 480</p>
<p class="cl"><span aria-label=" Page 89. " class="page" epub:type="pagebreak" id="p89" role="doc-pagebreak"/>pos = np.array(list(zip(width*np.random.rand(N), height*np.random.rand(N))))</p>
<p class="clf">def test1(pos, radius):</p>
<p class="cl">--<code class="i">snip</code>--</p>
<p class="clf">def test2(post, radius):</p>
<p class="cll">--<code class="i">snip</code>--</p>
</div>
<p>Now use the <code>timeit</code> module in a Python interpreter session to compare the performance of the two functions:</p>
<div class="codeline1">
<p class="cl1f">&gt;&gt;&gt; <code class="b">from</code> <span class="idx" data-level1="timeit" data-term="timeit module"/><code class="b">timeit import timeit</code></p>
<p class="cl1">&gt;&gt;&gt; <code class="b">timeit('test1(pos, 100)', 'from test import test1, N, pos, width, height', number=100)</code></p>
<p class="cl1">7.880876064300537</p>
<p class="cl1">&gt;&gt;&gt; <code class="b">timeit('test2(pos, 100)', 'from test import test2, N, pos, width, height', number=100)</code></p>
<p class="cl1l">0.036969900131225586</p>
</div>
<p>On my computer, the <code>numpy</code> code without loops runs about 200 times faster than the code that uses explicit loops! But why? Aren’t they both doing more or less the same thing?</p>
<p>As an interpreted language, Python is inherently slower than compiled languages like C. The <code>numpy</code> library brings the convenience of Python and performance nearly equal to that of C by providing highly optimized methods that operate on arrays of data. In general, you’ll find that <code>numpy</code> works best when you reorganize your algorithm as steps that operate on entire arrays at once, without looping through individual elements to perform computations.</p>
</section>
<section>
<h4 class="ch" id="ch0706">Writing the Final Method</h4>
<p class="paft">Now that you’ve compared the two approaches, you’re ready to use what you’ve learned to write a final version of the method that applies all three rules of the simulation and returns updated velocities for all the boids. The <code>applyRules()</code> method, part of the <code>Boids</code> class, uses the optimized <code>numpy</code> techniques discussed earlier.</p>
<div class="codeline">
<p class="clf"><span aria-label=" Page 90. " class="page" epub:type="pagebreak" id="p90" role="doc-pagebreak"/>def applyRules(self):</p>
<p class="cl">    # get pairwise distances</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ self.distMatrix = squareform(pdist(self.pos))</p>
<p class="cl">    # apply rule #1: separation</p>
<p class="cl">    D = self.distMatrix &lt; self.minDist</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ self.limit(vel, self.maxRuleVel)</p>
<p class="clf">    # distance threshold for alignment (different from separation)</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ D = self.distMatrix &lt; 50.0</p>
<p class="clf">    # apply rule #2: alignment</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ vel2 = D.dot(self.vel)</p>
<p class="cl">    self.limit(vel2, self.maxRuleVel)</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ vel += vel2</p>
<p class="clf">    # apply rule #3: cohesion</p>
<p class="cl">  <!--<ccust1>7</ccust1>-->❼ vel3 = D.dot(self.pos) - self.pos</p>
<p class="cl">    self.limit(vel3, self.maxRuleVel)</p>
<p class="cl">  <!--<ccust1>8</ccust1>-->❽ vel += vel3</p>
<p class="cls">    return vel</p>
</div>
<p>You compute the pairwise distance matrix between the boids using the <code>squareform()</code> and <code>pdist()</code> methods from the <code>scipy</code> library, as discussed earlier <!--<ccust1>1</ccust1>-->❶. When you apply the separation rule using <code>numpy</code> methods <!--<ccust1>2</ccust1>-->❷, each boid is pushed away from neighboring boids within a distance of <code>minDist</code> (25 pixels). The calculated velocities are clamped, or restricted, to a certain maximum value using the <code>Boids</code> class’s <code>limit()</code> method <!--<ccust1>3</ccust1>-->❸, which we’ll look at later. Without this restriction, the velocities would increase with each time step, and the simulation would go haywire.</p>
<p>You next generate a new Boolean matrix using a distance threshold of 50 pixels rather than 25 <!--<ccust1>4</ccust1>-->❹. You’ll use this broader definition of neighboring flockmates to apply the alignment and cohesion rules. The alignment rule is implemented so that each boid is influenced by and aligns itself with the average velocity of its neighbors. You get that average simply by taking the dot product of <code>D</code> (the Boolean matrix) and the velocity array <!--<ccust1>5</ccust1>-->❺. Once again, you restrict the calculated velocities to a maximum so they don’t increase indefinitely. (Using the compact <code>numpy</code> syntax makes all these computations simple and fast.)</p>
<p>Finally, you apply the cohesion rule by adding the positions of all the neighboring boids and then subtracting the position of the current boid <!--<ccust1>7</ccust1>-->❼. This produces a velocity vector for each boid that points to the <span class="idx" data-term="centroid"/><i>centroid</i> or geometric center of its neighbors. Again, you limit the velocities to keep them from getting out of control.</p>
<p>Each of the three rules produces its own velocity vector for each boid. At <!--<ccust1>6</ccust1>-->❻ and <!--<ccust1>8</ccust1>-->❽, you add these vectors together, producing an overall velocity vector for each boid that reflects the influence of all three simulation rules. You store the final velocity vectors in the <code>vel</code> array.</p>
</section>
<section>
<h4 class="ch" id="ch0707"><span aria-label=" Page 91. " class="page" epub:type="pagebreak" id="p91" role="doc-pagebreak"/>Limiting the Velocities</h4>
<p class="paft">In the previous section, you saw how the <code>limit()</code> method was called after applying each rule to keep the boids’ velocities from getting out of control. Here’s that method:</p>
<div class="codeline">
<p class="clf">def limit(self, X, maxVal):</p>
<p class="cl">    """limit the magnitude of 2D vectors in array X to maxValue"""</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ for vec in X:</p>
<p class="cll">        self.limitVec(vec, maxVal)</p>
</div>
<p>This method is designed to take in an array of velocity vectors, extract each individual vector <!--<ccust1>1</ccust1>-->❶, and pass it along to the <code>limitVec()</code> method, which looks like this:</p>
<div class="codeline">
<p class="clf">def limitVec(self, vec, maxVal):</p>
<p class="cl">    """limit the magnitude of the 2D vector"""</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ mag = norm(vec)</p>
<p class="cl">    if mag &gt; maxVal:</p>
<p class="cll">      <!--<ccust1>2</ccust1>-->❷ vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag</p>
</div>
<p>You use the <code>norm()</code> function from the <code>numpy</code> library to calculate the magnitude of the vector <!--<ccust1>1</ccust1>-->❶. If it exceeds the maximum, you scale the x and y portions of the vector in proportion to the vector’s magnitude <!--<ccust1>2</ccust1>-->❷. The maximum value was defined as <code>self.maxRuleVel = 0.03</code> as part of the initialization of the <code>Boids</code> class.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh0705"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0705">Influencing the Simulation</a></h3>
<p class="paft">The core rules in the Boids simulation will cause the boids to automatically exhibit flocking behavior. But let’s make things more interesting by allowing the user to influence the simulation as it runs. Specifically, you’ll create the ability to add boids to the flock or make the flock scatter with the click of your mouse.</p>
<p>The first step to inject events into the simulation while it’s running is to add an <i>event handler</i> to the <code>matplotlib</code> canvas. This is a piece of code that calls a function every time a certain event, such as a mouse click, happens. Here’s how to do it:</p>
<div class="codeline">
<p class="cls">cid = fig.canvas.<span class="idx" data-level1="mpl_connect" data-term="matplotlib module"/>mpl_connect('button_press_event', boids.buttonPress)</p>
</div>
<p>You use the <code>mpl_connect()</code> method to add a button press event handler to the <code>matplotlib</code> canvas. This handler will call the <code>buttonPress()</code> method of the <code>Boids</code> class every time a mouse button is pressed in the simulation window. Next, you need to define the <code>buttonPress()</code> method.</p>
<section>
<h4 class="ch" id="ch0708">Adding a Boid</h4>
<p class="paft">The first part of the <code>buttonPress()</code> method adds a boid to the simulation at the location of your cursor and assigns that boid a random velocity, when the <i>left</i> mouse button is pressed.</p>
<div class="codeline">
<p class="clf"><span aria-label=" Page 92. " class="page" epub:type="pagebreak" id="p92" role="doc-pagebreak"/>def buttonPress(self, event):</p>
<p class="cl">"""event handler for matplotlib button presses"""</p>
<p class="cl"># left-click to add a boid</p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ if event.button is 1:</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ self.pos = np.concatenate((self.pos,</p>
<p class="cl">                               np.array([[event.xdata, event.ydata]])),</p>
<p class="cl">                               axis=0)</p>
<p class="cl">    # generate a random velocity</p>
<p class="cl">    angles = 2*math.pi*np.random.rand(1)</p>
<p class="cl">    v = np.array(list(zip(np.sin(angles), np.cos(angles))))</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ self.vel = np.<span class="idx" data-level1="array" data-term="numpy module"/>concatenate((self.vel, v), axis=0)</p>
<p class="cll">  <!--<ccust1>4</ccust1>-->❹ self.N += 1</p>
</div>
<p>First you ensure that the mouse event is a left-click <!--<ccust1>1</ccust1>-->❶. Then you append the mouse location given by (<code>event.xdata, event.ydata</code>) to the array of boid positions <!--<ccust1>2</ccust1>-->❷. You also generate a random velocity vector, add it to the array of boid velocities <!--<ccust1>3</ccust1>-->❸, and increment the count of boids by 1 <!--<ccust1>4</ccust1>-->❹.<span class="idx" data-level1="adding a boid (end)" data-term="Boids simulations"/></p>
</section>
<section>
<h4 class="ch" id="ch0709"><span class="idx" data-level1="scattering" data-term="Boids simulations"/>Scattering the Boids</h4>
<p class="paft">The three simulation rules keep the boids in a flock as they move around. But what happens when the flock is disturbed? To simulate this situation, you can introduce a “scatter” effect: when you right-click in the simulation window, the flock will scatter from the location of the click. You can think of this as how the flock might respond to the sudden appearance of a predator or a loud noise that spooks the birds. You implement this effect as a continuation of the <code>buttonPress()</code> method:</p>
<div class="codeline">
<p class="clf">    # right-click to scatter boids</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ elif event.button is 3:</p>
<p class="cl">        # add scattering velocity</p>
<p class="cll">        self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))</p>
</div>
<p>Here you check whether the mouse button press is a right-click event <!--<ccust1>1</ccust1>-->❶. If so, you change the velocity for every boid by adding a vector that points away from the point where the disturbance arose (that is, where the mouse was clicked). You calculate this vector much like you calculated the displacement vectors for the separation rule. If <i>P</i><sub class="i">i</sub> is the position of a boid and <i>P</i><sub class="i">m</sub> is the point where the mouse was clicked, <i>P</i><sub class="i">i</sub> − <i>P</i><sub class="i">m</sub> is a vector that points away from the mouse click. You multiply this vector by <code>0.1</code> to keep the magnitude of the disturbance small. Initially, the boids will fly away from that point, but as you’ll see, the three rules prevail, and the boids will coalesce again as a flock.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh0706"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0706">Incrementing the Simulation</a></h3>
<p class="paft">At each time step in the simulation, you need to apply the rules to calculate the boids’ new velocities, update the boids’ positions based on those velocities, enforce the boundary conditions, and redraw everything in the display window. You can coordinate all this activity from the <code>tick()</code> function, which will be called at each frame of the <code>matplotlib</code> <span class="idx" data-level1="animation" data-term="Boids simulations"/>animation.</p>
<div class="codeline">
<p class="clf"><span aria-label=" Page 93. " class="page" epub:type="pagebreak" id="p93" role="doc-pagebreak"/>def tick(frameNum, pts, head, boids):</p>
<p class="cl">    """update function for animation"""</p>
<p class="cl">    boids.tick(frameNum, pts, head)</p>
<p class="cll">    return pts, head</p>
</div>
<p>The stand-alone <code>tick()</code> function simply calls the <code>tick()</code> method of the <code>Boids</code> class. The latter is defined as follows:</p>
<div class="codeline">
<p class="clf">def tick(self, frameNum, pts, head):</p>
<p class="cl">    """update the simulation by one time step"""</p>
<p class="cl">    # apply rules</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ self.vel += self.applyRules()</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ self.limit(self.vel, self.maxVel)</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ self.pos += self.vel</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ self.applyBC()</p>
<p class="cl">    # update data</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ pts.set_data(self.pos.reshape(2*self.N)[::2],</p>
<p class="cl">                 self.pos.reshape(2*self.N)[1::2])</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ vec = self.pos + 10*self.vel/self.maxVel</p>
<p class="cl">  <!--<ccust1>7</ccust1>-->❼ head.set_data(vec.reshape(2*self.N)[::2],</p>
<p class="cll">                  vec.reshape(2*self.N)[1::2])</p>
</div>
<p>This method is where everything comes together. You apply the boid rules using the <code>applyRules()</code> method that we already looked at <!--<ccust1>1</ccust1>-->❶. Then you limit the computed velocities of the boids using the <code>self.maxVel</code> threshold <!--<ccust1>2</ccust1>-->❷. (Even though you limited the velocity vector generated by each individual rule, the overall velocity determined by adding all three rules together may still be too large.) You next compute the updated positions of the boids by adding the new velocity vectors to the old array of positions <!--<ccust1>3</ccust1>-->❸. For example, if a boid was at position [0, 0] and has a velocity vector of [1, 1], its new position after one time step would be [1, 1]. You apply the boundary conditions for the simulation by calling <code>applyBC()</code> <!--<ccust1>4</ccust1>-->❹.</p>
<p>The call to <code>pts.set_data()</code> <!--<ccust1>5</ccust1>-->❺ updates the <code>matplotlib</code> axis with the boids’ new positions. The <code>[::2]</code> picks out the even-numbered elements (x-axis values) from the <code>pos</code> array, and the <code>[1::2]</code> picks out the odd-numbered elements (y-axis values). This will redraw the larger circles representing the boids’ bodies. Next, you need to draw the smaller circles representing the boids’ heads. You calculate the position of each boid’s head so it will point in the boid’s direction of motion by applying the <i>H</i> = <i>P</i> + <i>k</i> × <i>V</i> formula discussed earlier <!--<ccust1>6</ccust1>-->❻. Recall that <i>P</i> is the center of a boid’s body, <i>k</i> is a constant representing the distance from the center of the body to the center of the head (you use a value of 10 units), and <i>V</i> is the boid’s velocity. Once you have the new head positions, you draw them via the same technique you used to draw the bodies <!--<ccust1>7</ccust1>-->❼.</p>
</section>
<section>
<h3 class="bh" id="bh0707"><span aria-label=" Page 94. " class="page" epub:type="pagebreak" id="p94" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0707">Parsing Arguments and Instantiating the Boids</a></h3>
<p class="paft">The program’s <code>main()</code> function begins by handling command line arguments and instantiating the <code>Boids</code> class:</p>
<div class="codeline">
<p class="clf">def main():</p>
<p class="cl">    # use sys.argv if needed</p>
<p class="cl">    print('starting boids...')</p>
<p class="clf">    parser = argparse.<span class="idx" data-level1="ArgumentParser" data-term="argparse module"/>ArgumentParser(description="Implementing Craig</p>
<p class="cl">                                     Reynolds's Boids...")</p>
<p class="cl">    # add arguments</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ parser.add_argument('--num-boids', dest='N', required=False)</p>
<p class="cl">    args = parser.parse_args()</p>
<p class="clf">    # set the initial number of boids</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ N = 100</p>
<p class="cl">    if args.N:</p>
<p class="cl">        N = int(args.N)</p>
<p class="clf">    # create boids</p>
<p class="cll">  <!--<ccust1>3</ccust1>-->❸ boids = Boids(N)</p>
</div>
<p>You use the familiar <code>argparse</code> module to create a command line option for setting the initial number of boids in the simulation <!--<ccust1>1</ccust1>-->❶. If no argument is provided at the command line, the simulation defaults to 100 boids <!--<ccust1>2</ccust1>-->❷. You set the simulation in motion by creating an object of the <code>Boids</code> class <!--<ccust1>3</ccust1>-->❸.</p>
<p>The <code>main()</code> function continues with the code to create and animate a <code>matplotlib</code> plot. We’ve already discussed this code in <a class="xref" href="nsp-venkitachalam503045-0017.xhtml#ch0701">“Plotting the Boid’s Body and Head”</a> on <a class="xref" href="nsp-venkitachalam503045-0017.xhtml#p84">page 84</a>.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah0704"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0704">Running the Boids Simulation</a></h2>
<p class="paft">Let’s see what happens when you run the simulation. Enter the following:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python boids.py</code></p>
</div>
<p>The Boids simulation should start with all the boids clustered around the center of the window. Let the simulation run for a while, and the boids should start to flock as they form a pattern similar to the one shown in <a class="xref" href="nsp-venkitachalam503045-0017.xhtml#fig5-4">Figure 5-4</a>.</p>
<figure class="figure" id="fig5-4">
<p class="fig"><span aria-label=" Page 95. " class="page" epub:type="pagebreak" id="p95" role="doc-pagebreak"/><img alt="" height="424" src="images/nsp-venkitachalam503045-f05004.jpg" width="539"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 5-4:</span> A sample run of the Boids simulation</p>
</figcaption>
</figure>
<p>Left-click the simulation window. A new boid should appear at that location, and its velocity should change as it encounters the flock. Now right-click. The flock should initially scatter from your cursor but then recoalesce.</p>
</section>
<section>
<h2 class="ah" id="ah0705"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0705">Summary</a></h2>
<p class="paft">In this project, you simulated the flocking of birds (or boids) using the three rules proposed by Craig Reynolds. You looked at how operating on an entire <code>numpy</code> array at once is much faster than performing the same operations inside an explicit loop. You used the <code>scipy.spatial</code> module to perform fast and convenient distance calculations, and you implemented a <code>matplotlib</code> trick that uses two markers to represent both the position and the direction of points. Finally, you added interactivity to the simulation in the form of an event handler to respond to button presses within the <code>matplotlib</code> plot.</p>
</section>
<section>
<h2 class="ah" id="ah0706"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0706">Experiments!</a></h2>
<p class="paft">Here are some ways you might further explore flocking behavior:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Implement <span class="idx" data-level1="obstacle avoidance" data-term="Boids simulations"/>obstacle avoidance for your flock of boids by writing a new method called <code>avoidObstacle()</code> and applying it right after you apply the three rules, as follows:
            <div class="codeline">
<p class="cl3f">self.vel += self.applyRules()</p>
<p class="cl3l">self.vel += self.avoidObstacle()</p>
</div>
<p class="nlp">The <code>avoidObstacle()</code> method should use a predefined tuple (<i>x</i>, <i>y</i>, <i>R</i>) to add an additional velocity term to a boid, pushing it away from the obstacle location (<i>x</i>, <i>y</i>), but only when the boid is within radius <i>R</i> of the obstacle. Think of this as the distance at which a boid sees the obstacle and steers away from it. You can specify the (<i>x</i>, <i>y</i>, <i>R</i>) tuple using a command line option.</p>
</li>
<li class="nl"><span aria-label=" Page 96. " class="page" epub:type="pagebreak" id="p96" role="doc-pagebreak"/>2. What happens when the boids fly through a strong gust of wind? Simulate this by adding a global velocity component to all the boids at random time steps in the simulation. The boids should temporarily be affected by the wind but return to the flock once the wind stops.</li>
</ol>
</section>
<section>
<h2 class="ah" id="ah0707"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0707">The Complete Code</a></h2>
<p class="paft">Here’s the complete code for the Boids simulation:</p>
<div class="codeline1">
<p class="cl1f">"""</p>
<p class="cl1">boids.py</p>
<p class="cl1f">An implementation of Craig Reynolds's Boids simulation.</p>
<p class="cl1f">Author: Mahesh Venkitachalam</p>
<p class="cl1">"""</p>
<p class="cl1f">import argparse</p>
<p class="cl1">import math</p>
<p class="cl1">import numpy as np</p>
<p class="cl1">import matplotlib.pyplot as plt</p>
<p class="cl1">import matplotlib.animation as animation</p>
<p class="cl1">from scipy.spatial.distance import squareform, pdist</p>
<p class="cl1">from numpy.linalg import norm</p>
<p class="cl1f">width, height = 640, 480</p>
<p class="cl1f">class Boids:</p>
<p class="cl1">    """class that represents Boids simulation"""</p>
<p class="cl1">    def __init__(self, N):</p>
<p class="cl1">        """initialize the Boids simulation"""</p>
<p class="cl1">        # init position &amp; velocities</p>
<p class="cl1">        self.pos = [width/2.0, height/2.0] +</p>
<p class="cl1">                   10*np.random.rand(2*N).reshape(N, 2)</p>
<p class="cl1">        # normalized random velocities</p>
<p class="cl1">        angles = 2*math.pi*np.random.rand(N)</p>
<p class="cl1">        self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))</p>
<p class="cl1">        self.N = N</p>
<p class="cl1">        # min dist of approach</p>
<p class="cl1">        self.minDist = 25.0</p>
<p class="cl1">        # max magnitude of velocities calculated by "rules"</p>
<p class="cl1">        self.maxRuleVel = 0.03</p>
<p class="cl1">        # max magnitude of final velocity</p>
<p class="cl1">        self.maxVel = 2.0</p>
<p class="cl1f">    def tick(self, frameNum, pts, head):</p>
<p class="cl1">        """update the simulation by one time step"""</p>
<p class="cl1">        # apply rules</p>
<p class="cl1">        self.vel += self.applyRules()</p>
<p class="cl1">        self.limit(self.vel, self.maxVel)</p>
<p class="cl1">        self.pos += self.vel</p>
<p class="cl1">        self.applyBC()</p>
<p class="cl1">        # update data</p>
<p class="cl1">        pts.set_data(self.pos.reshape(2*self.N)[::2],</p>
<p class="cl1">                     self.pos.reshape(2*self.N)[1::2])</p>
<p class="cl1"><span aria-label=" Page 97. " class="page" epub:type="pagebreak" id="p97" role="doc-pagebreak"/>        vec = self.pos + 10*self.vel/self.maxVel</p>
<p class="cl1">        head.set_data(vec.reshape(2*self.N)[::2],</p>
<p class="cl1">                      vec.reshape(2*self.N)[1::2])</p>
<p class="cl1f">    def limitVec(self, vec, maxVal):</p>
<p class="cl1">        """limit magnitude of 2D vector"""</p>
<p class="cl1">        mag = norm(vec)</p>
<p class="cl1">        if mag &gt; maxVal:</p>
<p class="cl1">            vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag</p>
<p class="cl1f">    def limit(self, X, maxVal):</p>
<p class="cl1">        """limit magnitude of 2D vectors in array X to maxValue"""</p>
<p class="cl1">        for vec in X:</p>
<p class="cl1">            self.limitVec(vec, maxVal)</p>
<p class="cl1f">    def applyBC(self):</p>
<p class="cl1">        """apply boundary conditions"""</p>
<p class="cl1">        deltaR = 2.0</p>
<p class="cl1">        for coord in self.pos:</p>
<p class="cl1">            if coord[0] &gt; width + deltaR:</p>
<p class="cl1">                coord[0] = - deltaR</p>
<p class="cl1">            if coord[0] &lt; - deltaR:</p>
<p class="cl1">                coord[0] = width + deltaR</p>
<p class="cl1">            if coord[1] &gt; height + deltaR:</p>
<p class="cl1">                coord[1] = - deltaR</p>
<p class="cl1">            if coord[1] &lt; - deltaR:</p>
<p class="cl1">                coord[1] = height + deltaR</p>
<p class="cl1f">    def applyRules(self):</p>
<p class="cl1">        # get pairwise distances</p>
<p class="cl1">        self.distMatrix = squareform(pdist(self.pos))</p>
<p class="cl1">        # apply rule #1 - separation</p>
<p class="cl1">        D = self.distMatrix &lt; self.minDist</p>
<p class="cl1">        vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)</p>
<p class="cl1">        self.limit(vel, self.maxRuleVel)</p>
<p class="cl1f">        # different distance threshold</p>
<p class="cl1">        D = self.distMatrix &lt; 50.0</p>
<p class="cl1f">        # apply rule #2 - alignment</p>
<p class="cl1">        vel2 = D.dot(self.vel)</p>
<p class="cl1">        self.limit(vel2, self.maxRuleVel)</p>
<p class="cl1">        vel += vel2;</p>
<p class="cl1f">        # apply rule #1 - cohesion</p>
<p class="cl1">        vel3 = D.dot(self.pos) - self.pos</p>
<p class="cl1">        self.limit(vel3, self.maxRuleVel)</p>
<p class="cl1">        vel += vel3</p>
<p class="cl1f">        return vel</p>
<p class="cl1f">    def buttonPress(self, event):</p>
<p class="cl1">        """event handler for matplotlib button presses"""</p>
<p class="cl1">        # left-click - add a boid</p>
<p class="cl1">        if event.button == 1:</p>
<p class="cl1">            self.pos = np.concatenate((self.pos,</p>
<p class="cl1"><span aria-label=" Page 98. " class="page" epub:type="pagebreak" id="p98" role="doc-pagebreak"/>                                       np.array([[event.xdata, event.ydata]])),</p>
<p class="cl1">                                       axis=0)</p>
<p class="cl1">            # random velocity</p>
<p class="cl1">            angles = 2*math.pi*np.random.rand(1)</p>
<p class="cl1">            v = np.array(list(zip(np.sin(angles), np.cos(angles))))</p>
<p class="cl1">            self.vel = np.concatenate((self.vel, v), axis=0)</p>
<p class="cl1">            self.N += 1</p>
<p class="cl1">        # right-click - scatter</p>
<p class="cl1">        elif event.button == 3:</p>
<p class="cl1">            # add scattering velocity</p>
<p class="cl1">            self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))</p>
<p class="cl1f">def tick(frameNum, pts, head, boids):</p>
<p class="cl1">    """update function for animation"""</p>
<p class="cl1">    boids.tick(frameNum, pts, head)</p>
<p class="cl1">    return pts, head</p>
<p class="cl1f"># main() function</p>
<p class="cl1">def main():</p>
<p class="cl1">    # use sys.argv if needed</p>
<p class="cl1">    print('starting boids...')</p>
<p class="cl1f">    parser = argparse.ArgumentParser(description=</p>
<p class="cl1">                                     "Implementing Craig Reynolds's Boids...")</p>
<p class="cl1">    # add arguments</p>
<p class="cl1">    parser.add_argument('--num-boids', dest='N', required=False)</p>
<p class="cl1">    args = parser.parse_args()</p>
<p class="cl1f">    # number of boids</p>
<p class="cl1">    N = 100</p>
<p class="cl1">    if args.N:</p>
<p class="cl1">        N = int(args.N)</p>
<p class="cl1f">    # create boids</p>
<p class="cl1">    boids = Boids(N)</p>
<p class="cl1f">    # setup plot</p>
<p class="cl1">    fig = plt.figure()</p>
<p class="cl1">    ax = plt.axes(xlim=(0, width), ylim=(0, height))</p>
<p class="cl1f">    pts = ax.plot([], [], markersize=10,</p>
<p class="cl1">                  c='k', marker='o', ls='None')</p>
<p class="cl1f">    head, = ax.plot([], [], markersize=4,</p>
<p class="cl1">                    c='r', marker='o', ls='None')</p>
<p class="cl1">    anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),</p>
<p class="cl1">                                   interval=50)</p>
<p class="cl1f">    # add a "button press" event handler</p>
<p class="cl1">    cid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)</p>
<p class="cl1f">    plt.show()</p>
<p class="cl1f"># call main</p>
<p class="cl1">if __name__ == '__main__':</p>
<p class="cl1">    main()</p>
</div>
</section>
</section>
</div></body></html>