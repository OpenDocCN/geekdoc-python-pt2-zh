<html><head></head><body>
  <div id="sbo-rt-content"><h2 class="h2" id="app02"><a id="page_221"/><strong><span class="big">B</span></strong><br/><strong>Overview of Python Topics</strong></h2>
<div class="image1"><img src="images/common-01.jpg" alt="image"/></div>
<p class="noindent">The aim of this appendix is twofold: to provide a quick refresher on some Python topics that weren’t thoroughly introduced in the chapters and to introduce topics that will help you write better Python programs.</p>
<h3 class="h3" id="app02lev1sec01"><strong>if __name__ == '__main__'</strong></h3>
<p class="noindent">Throughout the book, we’ve used the following block of code, where <code>func()</code> is a function we’ve defined in the program:</p>
<pre>if __name__ == '__main__':<br/>    # Do something<br/>    func()</pre>
<p class="indent">This block of code ensures that the statements within the block are executed only when the program is run on its own.</p>
<p class="indent"><a id="page_222"/>When a program runs, the special variable <code>__name__</code> is set to <code>__main__</code> automatically, so the <code>if</code> condition evaluates to <code>True</code> and the function <code>func()</code> is called. However, <code>__name__</code> is set differently when you import the program into another program (see “<a href="app02.html#app02lev1sec07">Reusing Code</a>” on <a href="app02.html#page_235">page 235</a>).</p>
<p class="indent">Here’s a quick demonstration. Consider the following program, which we’ll call <em>factorial.py</em>:</p>
<pre>   # Find the factorial of a number<br/>   def fact(n):<br/>       p = 1<br/>       for i in range(1, n+1):<br/>           p = p*i<br/>       return p<br/><br/><span class="ent">➊</span> print(__name__)<br/><br/>   if __name__ == '__main__':<br/>       n = int(input('Enter an integer to find the factorial of: '))<br/>       f = fact(n)<br/>       print('Factorial of {0}: {1}'.format(n, f))</pre>
<p class="indent">The program defines a function, <code>fact()</code>, that calculates the factorial of the integer passed to it. When you run it, it prints <code>__main__</code>, which corresponds to the <code>print</code> statement at <span class="ent">➊</span>, because <code>__name__</code> is automatically set to <code>__main__</code>. Then, it asks an integer to be entered, calculates the factorial, and prints it:</p>
<pre>__main__<br/>Enter an integer to find the factorial of: 5<br/>Factorial of 5: 120</pre>
<p class="indent">Now, say you need to calculate the factorial in another program. Instead of writing the function again, you decide to reuse this function by importing it:</p>
<pre>from factorial import fact<br/>if __name__ == '__main__':<br/>    print('Factorial of 5: {0}'.format(fact(5)))</pre>
<p class="indent">Note that both the programs must be in the same directory. When you run this program, you’ll get the following output:</p>
<pre>factorial<br/>Factorial of 5: 120</pre>
<p class="indent">When your program is imported by another program, the value of the variable <code>__main__</code> is set to that program’s filename, without the extension. In this case, the value of <code>__name__</code> is <code>factorial</code> instead of <code>__main__</code>. Because the condition <code>__name__ == '__main__'</code> now evaluates to <code>False</code>, the program doesn’t ask for the user’s input anymore. Remove the condition to see for yourself what happens!</p>
<p class="indent"><a id="page_223"/>To summarize, it’s good practice to use <code>if __name__ == '__main__'</code> in your programs so that the statements you want executed when your program is run as a standalone are also <em>not</em> executed when your program is imported into another program.</p>
<h3 class="h3" id="app02lev1sec02"><strong>List Comprehensions</strong></h3>
<p class="noindent">Let’s say we have a list of integers and we want to create a new list containing the squares of the elements of the original list. Here’s one way that we could do this that’s already familiar to you:</p>
<pre>   &gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3, 4]</span><br/>   &gt;&gt;&gt; <span class="codestrong">x_square = []</span><br/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">for n in x:</span><br/><span class="ent">➋</span>         <span class="codestrong">x_square.append(n**2)</span><br/>   &gt;&gt;&gt; <span class="codestrong">x_square</span><br/>   [1, 4, 9, 16]</pre>
<p class="indent">Here, we used a code pattern that we’ve used in various programs throughout the book. We create an empty list, <code>x_square</code>, and then successively append to it as we calculate the square. We can do this in a more efficient way using <em>list comprehensions</em>:</p>
<pre><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong">x_square = [n**2 for n in x]</span><br/>   &gt;&gt;&gt; <span class="codestrong">x_square</span><br/>   [1, 4, 9, 16]</pre>
<p class="indent">The statement at <span class="ent">➌</span> is referred to as a <em>list comprehension</em> in Python. It consists of an expression—here, <code>n**2</code>—followed by a <code>for</code> loop, <code>for n in x</code>. Note that it basically allows us to combine the two statements at <span class="ent">➊</span> and <span class="ent">➋</span> into one to create a new list in one statement.</p>
<p class="indent">As another example, consider one of the programs we wrote in “<a href="ch02.html#ch02lev3sec05">Drawing the Trajectory</a>” on <a href="ch02.html#page_51">page 51</a> to draw the trajectory of a body in projectile motion. In these programs, we have the following block of code to calculate the <em>x</em>- and <em>y</em>-coordinates of the body at each time instant:</p>
<pre># Find time intervals<br/>intervals = frange(0, t_flight, 0.001)<br/># List of x and y coordinates<br/>x = []<br/>y = []<br/>for t in intervals:<br/>    x.append(u*math.cos(theta)*t)<br/>    y.append(u*math.sin(theta)*t - 0.5*g*t*t)</pre>
<p class="indent">Using list comprehension, you can rewrite the block of code as follows:</p>
<pre># Find time intervals<br/>intervals = frange(0, t_flight, 0.001)<br/># List of x and y coordinates<br/><a id="page_224"/><br/>x = [u*math.cos(theta)*t for t in intervals]<br/>y = [u*math.sin(theta)*t - 0.5*g*t*t for t in intervals]</pre>
<p class="indent">The code is more compact now, as you didn’t have to create the empty lists, write a <code>for</code> loop, and append to the lists. List comprehension lets you do this in a single statement.</p>
<p class="indent">You can also add conditionals to a list comprehension in order to selectively choose which list items are evaluated in the expression. Consider, once again, the first example:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">x = [1, 2, 3, 4]</span><br/>&gt;&gt;&gt; <span class="codestrong">x_square = [n**2 for n in x if n%2 == 0]</span><br/>&gt;&gt;&gt; <span class="codestrong">x_square</span><br/>[4, 16]</pre>
<p class="indent">In this list comprehension, we use the <code>if</code> condition to explicitly tell Python to evaluate the expression <code>n**2</code> only on the even list items of <code>x</code>.</p>
<h3 class="h3" id="app02lev1sec03"><strong>Dictionary Data Structure</strong></h3>
<p class="noindent">We first used a Python dictionary in <a href="ch04.html#ch04">Chapter 4</a> while implementing the <code>subs()</code> method in SymPy. Let’s explore Python dictionaries in more detail. Consider a simple dictionary:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">d = {'key1': 5, 'key2': 20}</span></pre>
<p class="indent">This code creates a dictionary with two keys—<code>'key1'</code> and <code>'key2'</code>—with values <code>5</code> and <code>20</code>, respectively. Only strings, numbers, and tuples can be keys in a Python dictionary. These data types are referred to as <em>immutable</em> data types—once created, they can’t be changed—so a list can’t be a key because we can add and remove elements from a list.</p>
<p class="indent">We already know that to retrieve the value corresponding to <code>'key1'</code> in the dictionary, we need to specify it as <code>d['key1']</code>. This is one of the most common use cases of a dictionary. A related use case is checking whether the dictionary contains a certain key, <code>'x'</code>. We can check that as follows:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">d = {'key1': 5, 'key2': 20}</span><br/>&gt;&gt;&gt; <span class="codestrong">'x' in d</span><br/>False</pre>
<p class="indent">Once we create a dictionary, we can add a new key-value pair to it, similar to how we can append elements to a list. Here’s an example:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">d = {'key1': 5, 'key2': 20}</span><br/>&gt;&gt;&gt; <span class="codestrong">if 'x' in d:</span><br/>        <span class="codestrong">print(d['x'])</span><br/><span class="codestrong">else:</span><br/>        <span class="codestrong">d['x'] = 1</span><br/><a id="page_225"/><br/>&gt;&gt;&gt; <span class="codestrong">d</span><br/>{'key1': 5, 'x': 1, 'key2': 20}</pre>
<p class="indent">This code snippet checks whether the key <code>'x'</code> already exists in the dictionary, <code>d</code>. If it does, it prints the value corresponding to it; otherwise, it adds the key to the dictionary with <code>1</code> as the corresponding value. Similar to Python’s behavior with sets, Python can’t guarantee a particular order of the key-value pairs in a dictionary. The key-value pairs can be in any order, irrespective of the order of insertion.</p>
<p class="indent">Besides specifying the key as an index to the dictionary, we can also use the <code>get()</code> method to retrieve the value corresponding to the key:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">d.get('x')</span><br/>1</pre>
<p class="indent">If you specify a nonexistent key to the <code>get()</code> method, <code>None</code> is returned. On the other hand, if you do so while using the index style of retrieving, you’ll get an error.</p>
<p class="indent">The <code>get()</code> method also lets you set a default value for nonexistent keys:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">d.get('y', 0)</span><br/>0</pre>
<p class="indent">There’s no key <code>'y'</code> in the dictionary <code>d</code>, so <code>0</code> is returned. If there is a key, however, the value is returned instead:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">d['y'] = 1</span><br/>&gt;&gt;&gt; <span class="codestrong">d.get('y', 0)</span><br/>1</pre>
<p class="indent">The <code>keys()</code> and <code>values()</code> methods each return a list-like data structure of all the keys and values, respectively, in a dictionary:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">d.keys()</span><br/>dict_keys(['key1', 'x', 'key2', 'y'])<br/>&gt;&gt;&gt; <span class="codestrong">d.values()</span><br/>dict_values([5, 1, 20, 1])</pre>
<p class="indent">To iterate over the key and value pairs in a dictionary, use the <code>items()</code> method:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">d.items()</span><br/>dict_items([('key1', 5), ('x', 1), ('key2', 20), ('y', 1)])</pre>
<p class="indent">This method returns a <em>view</em> of tuples, and each tuple is a key-value pair. We can use the following code snippet to print them nicely:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">for k, v in d.items():</span><br/>        <span class="codestrong">print(k, v)</span><br/><a id="page_226"/><br/>key1 5<br/>x 1<br/>key2 20<br/>y 1</pre>
<p class="indent">Views are more memory efficient than lists, and they don’t let you add or remove items.</p>
<h3 class="h3" id="app02lev1sec04"><strong>Multiple Return Values</strong></h3>
<p class="noindent">In the programs we’ve written so far, most of the functions return a single value, but functions sometimes return multiple values. We saw an example of such a function in “<a href="ch03.html#ch03lev1sec04">Measuring the Dispersion</a>” on <a href="ch03.html#page_71">page 71</a>, where in the program to find the range, we returned three numbers from the <code>find_range()</code> function. Here’s another example of the approach we took there:</p>
<pre>import math<br/>def components(u, theta):<br/>    x = u*math.cos(theta)<br/>    y = u*math.sin(theta)<br/>    return x, y</pre>
<p class="indent">The <code>components()</code> function accepts a velocity, <code>u</code>, and an angle, <code>theta</code>, in radians as parameters, and it calculates the <code>x</code> and <code>y</code> components and returns them. To return the calculated components, we simply list the corresponding Python labels in the return statement separated by a comma. This creates and returns a tuple consisting of the items <code>x</code> and <code>y</code>. In the calling code, we receive the multiple values:</p>
<pre>if __name__ == '__main__':<br/>    theta = math.radians(45)<br/>    x, y = components(theta)</pre>
<p class="indent">Because the <code>components()</code> function returns a tuple, we can retrieve the returned values using tuple indices:</p>
<pre>c = components(theta)<br/>x = c[0]<br/>y = c[1]</pre>
<p class="indent">This has advantages because we don’t have to know all the different values being returned. For one, you don’t have to write <code>x,y,z = myfunc1()</code> when the function returns three values or <code>a,x,y,z = myfunc1()</code> when the function returns four values, and so on.</p>
<p class="indent">In either of the preceding cases, the code calling the <code>components()</code> function must know which of the return values correspond to which component of the velocity, as there’s no way to know that from the values themselves.</p>
<p class="indent"><a id="page_227"/>A user-friendly approach is to return a dictionary object instead, as we saw in the case of SymPy’s <code>solve()</code> function when used with the <code>dict=True</code> keyword argument. Here’s how we can rewrite the preceding components function to return a dictionary:</p>
<pre>import math<br/><br/>def components(theta):<br/>    x = math.cos(theta)<br/>    y = math.sin(theta)<br/><br/>    return {'x': x, 'y': y}</pre>
<p class="indent">Here, we return a dictionary with the keys <code>'x'</code> and <code>'y'</code> referring to the <code>x</code> and <code>y</code> components and their corresponding numerical values. With this new function definition, we don’t need to worry about the order of the returned values. We just use the key <code>'x'</code> to retrieve the <code>x</code> component and the key <code>'y'</code> to retrieve the <code>y</code> component:</p>
<pre>if __name__ == '__main__':<br/>    theta = math.radians(45)<br/>    c = components(theta)<br/>    y = c['y']<br/>    x = c['x']<br/>    print(x, y)</pre>
<p class="indent">This approach eliminates the need to use indices to refer to a specific returned value. The following code rewrites the program to find the range (see “<a href="ch03.html#ch03lev1sec04">Measuring the Dispersion</a>” on <a href="ch03.html#page_71">page 71</a>) so that the results are returned as a dictionary instead of a tuple:</p>
<pre>   '''<br/>   Find the range using a dictionary to return values<br/>   '''<br/>   def find_range(numbers):<br/>       lowest = min(numbers)<br/>       highest = max(numbers)<br/>       # Find the range<br/>       r = highest-lowest<br/>       return {'lowest':lowest, 'highest':highest, 'range':r}<br/><br/>   if __name__ == '__main__':<br/>       donations = [100, 60, 70, 900, 100, 200, 500, 500, 503, 600, 1000, 1200]<br/>       result = find_range(donations)<br/><span class="ent">➊</span>     print('Lowest: {0} Highest: {1} Range: {2}'.<br/>              format(result['lowest'], result['highest'], result['range']))</pre>
<p class="indent">The <code>find_range()</code> function now returns a dictionary with the keys <code>lowest</code>, <code>highest</code>, and <code>range</code> and with the lowest number, highest number, and the range as their corresponding values. At <span class="ent">➊</span>, we simply use the corresponding key to retrieve the corresponding value.</p>
<p class="indent"><a id="page_228"/>If we were just interested in the range of a group of numbers and we didn’t care about the lowest and highest numbers, we’d just use <code>result['range']</code> and not worry about what other values were returned.</p>
<h3 class="h3" id="app02lev1sec05"><strong>Exception Handling</strong></h3>
<p class="noindent">In <a href="ch01.html#ch01">Chapter 1</a>, we learned that trying to convert a string such as <code>'1.1'</code> to an integer using the <code>int()</code> function results in a <code>ValueError</code> exception. But with a <code>try...except</code> block, we can print a user-friendly error message:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">try:</span><br/>        <span class="codestrong">int('1.1')</span><br/><span class="codestrong">except ValueError:</span><br/>        <span class="codestrong">print('Failed to convert 1.1 to an integer')</span><br/><br/>Failed to convert 1.1 to an integer</pre>
<p class="indent">When any statement in the <code>try</code> block raises an exception, the type of exception raised is matched with the one specified by the <code>except</code> statement. If there’s a match, the program resumes in the <code>except</code> block. If the exception doesn’t match, the program execution halts and displays the exception. Here’s an example:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">try:</span><br/>        <span class="codestrong">print(1/0)</span><br/><span class="codestrong">except ValueError:</span><br/>        <span class="codestrong">print('Division unsuccessful')</span><br/><br/>Traceback (most recent call last):<br/>  File "&lt;pyshell#66&gt;", line 2, in &lt;module&gt;<br/>    print(1/0)<br/>ZeroDivisionError: division by zero</pre>
<p class="indent">This code block attempts a division by 0, which results in a <code>ZeroDivisionError</code> exception. Although the division is carried out in a <code>try...except</code> block, the exception type is incorrectly specified, and the exception isn’t handled correctly. The correct way to handle this exception is to specify <code>ZeroDivisionError</code> as the exception type.</p>
<h4 class="h4" id="app02lev2sec01"><strong><em>Specifying Multiple Exception Types</em></strong></h4>
<p class="noindent">You can also specify multiple exception types. Consider the function <code>reciprocal()</code>, which returns the reciprocal of the number passed to it:</p>
<pre>def reciprocal(n):<br/>    try:<br/>        print(1/n)<br/>    except (ZeroDivisionError, TypeError):<br/>        print('You entered an invalid number')</pre>
<p class="indent"><a id="page_229"/>We defined the function <code>reciprocal()</code>, which prints the reciprocal of the user’s input. We know that if the function is called with 0, it’ll cause a <code>ZeroDivisionError</code> exception. If you pass a string, however, it’ll cause a <code>TypeError</code> exception. The function considers both these cases as invalid input and specifies both <code>ZeroDivisionError</code> and <code>TypeError</code> in the <code>except</code> statement as a tuple.</p>
<p class="indent">Let’s try calling the function with a valid input—that is, a nonzero number:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">reciprocal(5)</span><br/>0.2</pre>
<p class="indent">Next, we call the function with 0 as the argument:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">reciprocal(0)</span><br/>Enter an integer: <span class="codestrong">0</span><br/>You entered an invalid number</pre>
<p class="indent">The <code>0</code> argument raises the <code>ZeroDivisionError</code> exception, which is in the tuple of exception types specified to the <code>except</code> statement, so the code prints an error message.</p>
<p class="indent">Now, let’s enter a string:</p>
<pre>&gt;&gt;&gt; <span class="codestrong">reciprocal('1')</span></pre>
<p class="indent">In this case, we entered an invalid number, which raises the <code>TypeError</code> exception. This exception is also in the tuple of specified exceptions, so the code prints an error message. If you want to give a more specific error message, we can just specify multiple <code>except</code> statements as follows:</p>
<pre><span class="codestrong">def reciprocal(n):</span><br/>    <span class="codestrong">try:</span><br/>        <span class="codestrong">print(1/n)</span><br/>    <span class="codestrong">except TypeError:</span><br/>        <span class="codestrong">print('You must specify a number')</span><br/>    <span class="codestrong">except ZeroDivisionError:</span><br/>        <span class="codestrong">print('Division by 0 is invalid')</span><br/><br/>&gt;&gt;&gt; <span class="codestrong">reciprocal(0)</span><br/>Division by 0 is invalid<br/>&gt;&gt;&gt; <span class="codestrong">reciprocal('1')</span><br/>You must specify a number</pre>
<p class="indent">In addition to <code>TypeError</code>, <code>ValueError</code>, and <code>ZeroDivisionError</code>, there are a number of other built-in exception types. The Python documentation at <em><a href="https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions">https://docs.python.org/3.4/library/exceptions.html#bltin-exceptions</a></em> lists the builtin exceptions for Python 3.4.</p>
<h4 class="h4" id="app02lev2sec02"><a id="page_230"/><strong><em>The else Block</em></strong></h4>
<p class="noindent">The <code>else</code> block is used to specify which statements to execute when there’s no exception. Consider an example from the program we wrote to draw the trajectory of a projectile (see “<a href="ch02.html#ch02lev3sec05">Drawing the Trajectory</a>” on <a href="ch02.html#page_51">page 51</a>):</p>
<pre>   if __name__ == '__main__':<br/>       try:<br/>           u = float(input('Enter the initial velocity (m/s): '))<br/>           theta = float(input('Enter the angle of projection (degrees): '))<br/>       except ValueError:<br/>           print('You entered an invalid input')<br/><span class="ent">➊</span>     else:<br/>           draw_trajectory(u, theta)<br/>           plt.show()</pre>
<p class="indentb">If the input for <code>u</code> or <code>theta</code> couldn’t be converted to a floating point number, it doesn’t make sense for the program to call the <code>draw_trajectory()</code> and <code>plt.show()</code> functions. Instead, we specify these two statements in the <code>else</code> block at <span class="ent">➊</span>. Using <code>try...except...else</code> will let you manage different types of errors during runtime and take appropriate action when there is an error or when there is none:</p>
<p class="order">1. If there’s an exception and there’s an <code>except</code> statement corresponding to the exception type raised, the execution is transferred to the corresponding <code>except</code> block.</p>
<p class="order">2. If there’s no exception, the execution is transferred to the <code>else</code> block.</p>
<h3 class="h3" id="app02lev1sec06"><strong>Reading Files in Python</strong></h3>
<p class="noindent">Opening a file is the first step to reading data from it. Let’s start with a quick example. Consider a file that consists of a collection of numbers with one number per line:</p>
<pre>100<br/>60<br/>70<br/>900<br/>100<br/>200<br/>500<br/>500<br/>503<br/>600<br/>1000<br/>1200</pre>
<p class="indent"><a id="page_231"/>We want to write a function that reads the file and returns a list of those numbers:</p>
<pre>   def read_data(path):<br/>       numbers = []<br/><span class="ent">➊</span>     f = open(path)<br/><span class="ent">➋</span>     for line in f:<br/>           numbers.append(float(line))<br/>       f.close()<br/>       return numbers</pre>
<p class="indent">First, we define the function <code>read_data()</code> and create an empty list to store all of the numbers. At <span class="ent">➊</span>, we use the <code>open()</code> function to open the file whose location has been specified via the argument path. An example of the path would be <em>/home/username/mydata.txt</em> on Linux, <em>C:\mydata.txt</em> on Microsoft Windows, or <em>/Users/Username/mydata.txt</em> on OS X. The <code>open()</code> function returns a file object, which we use the label <code>f</code> to refer to. We can go over each line of the file using a <code>for</code> loop at <span class="ent">➋</span>. Because each line is returned as a string, we convert it into a number and append it to the list <code>numbers</code>. The loop stops executing once all the lines have been read, and we close the file using the <code>close()</code> method. Finally, we return the <code>numbers</code> list.</p>
<p class="indent">This is similar to how we read the numbers from a file in <a href="ch03.html#ch03">Chapter 3</a>, although we didn’t have to close the file explicitly because we used a different approach there. Using the approach we took in <a href="ch03.html#ch03">Chapter 3</a>, we would rewrite the preceding function as follows:</p>
<pre>   def read_data(path):<br/>       numbers = []<br/><span class="ent">➊</span>     with open(path) as f:<br/>           for line in f:<br/>               numbers.append(float(line))<br/><span class="ent">➋</span>     return numbers</pre>
<p class="indent">The key statement here is at <span class="ent">➊</span>. It’s similar to writing <code>f = open(path)</code> but only partially. Besides opening the file and assigning the file object returned by <code>open()</code> to <code>f</code>, it also sets up a new <em>context</em> with all the statements in that block—in this case, all the statements before the <code>return</code> statement. When all the statements in the body have been executed, the file is automatically closed. That is, when the execution reaches the statement at <span class="ent">➋</span>, the file is closed without needing an explicit call to the <code>close()</code> method. This method also means that if there are any exceptions while working with the file, it’ll still be closed before the program exits. This is the preferred approach to working with files.</p>
<h4 class="h4" id="app02lev2sec03"><a id="page_232"/><strong><em>Reading All the Lines at Once</em></strong></h4>
<p class="noindent">Instead of reading the lines one by one to build a list, we can use the <code>readlines()</code> method to read all the lines into a list at once. This results in a more compact function:</p>
<pre>   def read_data(path):<br/>       with open(path) as f:<br/><span class="ent">➊</span>         lines = f.readlines()<br/>       numbers = [float(n) for n in lines]<br/>       return numbers</pre>
<p class="indent">We read all the lines of the file into a list using the <code>readlines()</code> method at <span class="ent">➊</span>. Then, we convert each of the items in the list into a floating point number using the <code>float()</code> function and list comprehension. Finally, we return the list <code>numbers</code>.</p>
<h4 class="h4" id="app02lev2sec04"><strong><em>Specifying the Filename as Input</em></strong></h4>
<p class="noindent">The <code>read_data()</code> function takes the file path as an argument. If your program allows you to specify the filename as an input, this function should work for any file as long as the file contains data we expect to read. Here’s an example:</p>
<pre>if __name__=='__main__':<br/>    data_file = input('Enter the path of the file: ')<br/>    data = read_data(data_file)<br/>    print(data)</pre>
<p class="indent">Once you’ve added this code to the end of the <code>read_data()</code> function and run it, it’ll ask you to input the path to the file. Then, it’ll print the numbers it reads from the file:</p>
<p class="programscustom">Enter the path of the file <span class="codestrong">/home/amit/work/mydata.txt</span><br/>[100.0,60.0,70.0,900.0,100.0,200.0,500.0,500.0,503.0,600.0,1000.0,1200.0]</p>
<h4 class="h4" id="app02lev2sec05"><strong><em>Handling Errors When Reading Files</em></strong></h4>
<p class="noindent">There are a couple of things that can go wrong when reading files: (1) the file can’t be read, or (2) the data in the file isn’t in the expected format. Here’s an example of what happens when a file can’t be read:</p>
<pre>Enter the path of the file: <span class="codestrong">/home/amit/work/mydata2.txt</span><br/>Traceback (most recent call last):<br/>  File "read_file.py", line 11, in &lt;module&gt;<br/>    data = read_data(data_file)<br/>  File "read_file.py", line 4, in read_data<br/>    with open(path) as f:<br/>FileNotFoundError: [Errno 2] No such file or directory: '/home/amit/work/<br/>mydata2.txt'</pre>
<p class="indent"><a id="page_233"/>Because I entered a file path that doesn’t exist, the <code>FileNotFoundError</code> exception is raised when we try to open the file. We can make the program display a user-friendly error message by modifying our <code>read_data()</code> function as follows:</p>
<pre>def read_data(path):<br/>    numbers = []<br/>    try:<br/>        with open(path) as f:<br/>            for line in f:<br/>                numbers.append(float(line))<br/>    except FileNotFoundError:<br/>        print('File not found')<br/>    return numbers</pre>
<p class="indent">Now, when you specify a nonexistent file path, you’ll get an error message instead:</p>
<pre>Enter the path of the file: <span class="codestrong">/home/amit/work/mydata2.txt</span><br/>File not found</pre>
<p class="indent">The second source of errors can be that the data in the file isn’t what your program expects to read. For example, consider a file that has the following:</p>
<pre>10<br/>20<br/>3o<br/>1/5<br/>5.6</pre>
<p class="indent">The third line in this file isn’t convertible to a floating point number because it has the letter <code>o</code> in it instead of the number <code>0</code>, and the fourth line consists of <code>1/5</code>, a fraction in string form, which <code>float()</code> can’t handle.</p>
<p class="indent">If you supply this data file to the earlier program, it’ll produce the following error:</p>
<pre>Enter the path of the file: <span class="codestrong">bad_data.txt</span><br/>Traceback (most recent call last):<br/>  File "read_file.py", line 13, in &lt;module&gt;<br/>    data = read_data(data_file)<br/>  File "read_file.py", line 6, in read_data<br/>    numbers.append(float(line))<br/>ValueError: could not convert string to float: '3o\n'</pre>
<p class="indent">The third line in the file is <code>3o</code>, not the number <code>30</code>, so when we attempt to convert it into a floating point number, the result is <code>ValueError</code>. There are two approaches you can take when such data is present in a file. The first <a id="page_234"/>is to report the error and exit the program. The modified <code>read_data()</code> function would appear as follows:</p>
<pre>   def read_data(path):<br/>       numbers = []<br/>       try:<br/>           with open(path) as f:<br/>               for line in f:<br/><span class="ent">➊</span>               try:<br/><span class="ent">➋</span>                   n = float(line)<br/>                 except ValueError:<br/>                     print('Bad data: {0}'.format(line))<br/><span class="ent">➌</span>                   break<br/><span class="ent">➍</span>               numbers.append(n)<br/>       except FileNotFoundError:<br/>           print('File not found')<br/>       return numbers</pre>
<p class="indent">We insert another <code>try...except</code> block in the function starting at <span class="ent">➊</span>, and we convert the line into a floating point number at <span class="ent">➋</span>. If the program raises the <code>ValueError</code> exception, we print an error message with the offending line and exit out of the <code>for</code> loop using <code>break</code> at <span class="ent">➌</span>. The program then stops reading the file. The returned list, <code>numbers</code>, contains all the data that was successfully read before encountering the bad data. If there’s no error, we append the floating point number to the <code>numbers</code> list at <span class="ent">➍</span>.</p>
<p class="indent">Now when you supply the file <em>bad_data.txt</em> to the program, it’ll read only the first two lines, display the error message, and exit:</p>
<pre>Enter the path of the file: <span class="codestrong">bad_data.txt</span><br/>Bad data: 3o<br/><br/>[10.0, 20.0]</pre>
<p class="indent">Returning partial data may not be desirable, so we could just replace the break statement at <span class="ent">➌</span> with <code>return</code> and no data would be returned.</p>
<p class="indent">The second approach is to ignore the error and continue with the rest of the file. Here’s a modified <code>read_data()</code> function that does this:</p>
<pre>   def read_data(path):<br/>       numbers = []<br/>       try:<br/>           with open(path) as f:<br/>               for line in f:<br/>                   try:<br/>                       n = float(line)<br/>                   except ValueError:<br/>                       print('Bad data: {0}'.format(line))<br/><span class="ent">➊</span>                     continue<br/>                   numbers.append(n)<br/>       except FileNotFoundError:<br/>           print('File not found')<br/>       return numbers</pre>
<p class="indent"><a id="page_235"/>The only change here is that instead of breaking out of the <code>for</code> loop, we just continue with the next iteration using the <code>continue</code> statement at <span class="ent">➊</span>. The output from the program is now as follows:</p>
<pre>Bad data: 3o<br/><br/>Bad data: 1/5<br/><br/>[10.0, 20.0, 5.6]</pre>
<p class="indent">The specific application where you’re reading the file will determine which of the above approaches you want to take to handle bad data.</p>
<h3 class="h3" id="app02lev1sec07"><strong>Reusing Code</strong></h3>
<p class="noindent">Throughout this book, we’ve used classes and functions that were either part of the Python standard library or available after installing third-party packages, such as matplotlib and SymPy. Now we’ll look at a quick example of how we can import our own programs into other programs.</p>
<p class="indent">Consider the function <code>find_corr_x_y()</code> that we wrote in “<a href="ch03.html#ch03lev1sec05">Calculating the Correlation Between Two Data Sets</a>” on <a href="ch03.html#page_75">page 75</a>. We’ll create a separate file, <em>correlation.py</em>, which has only the function definition:</p>
<pre>'''<br/>Function to calculate the linear correlation coefficient<br/>'''<br/><br/>def find_corr_x_y(x,y):<br/>    # Size of each set<br/>    n = len(x)<br/><br/>    # Find the sum of the products<br/>    prod=[]<br/>    for xi,yi in zip(x,y):<br/>        prod.append(xi*yi)<br/><br/>    sum_prod_x_y = sum(prod)<br/>    sum_x = sum(x)<br/>    sum_y = sum(y)<br/>    squared_sum_x = sum_x**2<br/>    squared_sum_y = sum_y**2<br/><br/>    x_square=[]<br/>    for xi in x:<br/>        x_square.append(xi**2)<br/>    x_square_sum = sum(x_square)<br/><br/>    y_square=[]<br/>    for yi in y:<br/>        y_square.append(yi**2)<br/>    y_square_sum = sum(y_square)<br/><br/>    numerator = n*sum_prod_x_y - sum_x*sum_y<br/>    denominator_term1 = n*x_square_sum - squared_sum_x<br/>    denominator_term2 = n*y_square_sum - squared_sum_y<br/>    denominator = (denominator_term1*denominator_term2)**0.5<br/><br/>    correlation = numerator/denominator<br/><br/>    return correlation</pre>
<p class="indent"><a id="page_236"/>Without the <em>.py</em> file extension, a Python file is referred to as a module. This is usually reserved for files that define classes and functions that’ll be used in other programs. The following program imports the <code>find_corr_x_y()</code> function from the correlation module we just defined:</p>
<pre>from correlation import find_corr_x_y<br/>if __name__ == '__main__':<br/>    high_school_math = [83, 85, 84, 96, 94, 86, 87, 97, 97, 85]<br/>    college_admission = [85, 87, 86, 97, 96, 88, 89, 98, 98, 87]<br/>    corr = find_corr_x_y(high_school_math, college_admission)<br/>    print('Correlation coefficient: {0}'.format(corr))</pre>
<p class="indent">This program finds the correlation between the high school math grades and college admission scores of students we considered in <a href="ch03.html#ch3tab3">Table 3-3</a> on <a href="ch03.html#page_80">page 80</a>. We import the <code>find_corr_x_y()</code> function from the correlation module, create the lists representing the two sets of grades, and call the <code>find_corr_x_y()</code> function with the two lists as arguments. When you run the program, it’ll print the correlation coefficient. Note that the two files must be in the same directory—this is strictly to keep things simple.</p>
</div>
</body></html>