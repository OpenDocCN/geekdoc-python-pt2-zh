<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_33"/><strong><span class="big">3</span></strong><br/><strong>DOCUMENTATION AND GOOD API PRACTICE</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">In this chapter, we’ll discuss documentation; specifically, how to automate the trickier and more tedious aspects of documenting your project with <em>Sphinx</em>. While you will still have to write the documentation yourself, Sphinx will simplify your task. As it is common to provide features using a Python library, we’ll also look at how to manage and document your public API changes. Because your API will have to evolve as you make changes to its features, it’s rare to get everything built perfectly from the outset, but I’ll show you a few things you can do to ensure your API is as user-friendly as possible.</p>&#13;
<p class="indent">We’ll end this chapter with an interview with Christophe de Vienne, author of the Web Services Made Easy framework, in which he discusses best practices for developing and maintaining APIs.</p>&#13;
<h3 class="h3" id="lev1sec14"><span epub:type="pagebreak" id="page_34"/><strong>Documenting with Sphinx</strong></h3>&#13;
<p class="noindent">Documentation is one of the most important parts of writing software. Unfortunately, a lot of projects don’t provide proper documentation. Writing documentation is seen as complicated and daunting, but it doesn’t have to be: with the tools available to Python programmers, documenting your code can be just as easy as writing it.</p>&#13;
<p class="indent">One of the biggest reasons for sparse or nonexistent documentation is that many people assume the only way to document code is by hand. Even with multiple people on a project, this means one or more of your team will end up having to juggle contributing code with maintaining documentation—and if you ask any developer which job they’d prefer, you can be sure they’ll say they’d rather write software than write <em>about</em> software.</p>&#13;
<p class="indent">Sometimes the documentation process is completely separate from the development process, meaning that the documentation is written by people who did not write the actual code. Furthermore, any documentation produced this way is likely to be out-of-date: it’s almost impossible for manual documentation to keep up with the pace of development, regardless of who handles it.</p>&#13;
<p class="indent">Here’s the bottom line: the more degrees of separation between your code and your documentation, the harder it will be to keep the latter properly maintained. So why keep them separate at all? It’s not only possible to put your documentation directly in the code itself, but it’s also simple to convert that documentation into easy-to-read HTML and PDF files.</p>&#13;
<p class="indent">The most common format for Python documentation is <em>reStructuredText</em>, or <em>reST</em> for short. It’s a lightweight markup language (like Markdown) that’s as easy to read and write for humans as it is for computers. Sphinx is the most commonly used tool for working with this format; Sphinx can read reST-formatted content and output documentation in a variety of other formats.</p>&#13;
<p class="indent">I recommend that your project documentation always include the following:</p>&#13;
<ul>&#13;
<li><p class="noindent">The problem your project is intended to solve, in one or two sentences.</p></li>&#13;
<li><p class="noindent">The license your project is distributed under. If your software is open source, you should also include this information in a header in each code file; just because you’ve uploaded your code to the Internet doesn’t mean that people will know what they’re allowed to do with it.</p></li>&#13;
<li><p class="noindent">A small example of how your code works.</p></li>&#13;
<li><p class="noindent">Installation instructions.</p></li>&#13;
<li><p class="noindent">Links to community support, mailing list, IRC, forums, and so on.</p></li>&#13;
<li><p class="noindent">A link to your bug tracker system.</p></li>&#13;
<li><p class="noindent">A link to your source code so that developers can download and start delving into it right away.</p></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_35"/>You should also include a <em>README.rst</em> file that explains what your project does. This README should be displayed on your GitHub or PyPI project page; both sites know how to handle reST formatting.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you’re using GitHub, you can also add a <span class="roman">CONTRIBUTING.rst</span> file that will be displayed when someone submits a pull request. It should provide a checklist for users to follow before they submit the request, including things like whether your code follows PEP 8 and reminders to run the unit tests. Read the Docs <span class="roman">(<a href="http://readthedocs.org/">http://readthedocs.org/</a>)</span> allows you to build and publish your documentation online automatically. Signing up and configuring a project is straightforward. Then Read the Docs searches for your Sphinx configuration file, builds your documentation, and makes it available for your users to access. It’s a great companion to code-hosting sites.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="lev2sec11"><strong><em>Getting Started with Sphinx and reST</em></strong></h4>&#13;
<p class="noindent">You can get Sphinx from <em><a href="http://www.sphinx-doc.org/">http://www.sphinx-doc.org/</a></em>. There are installation instructions on the site, but the easiest method is to install with <code>pip install sphinx</code>.</p>&#13;
<p class="indent">Once Sphinx is installed, run <code>sphinx-quickstart</code> in your project’s top-level directory. This will create the directory structure that Sphinx expects to find, along with two files in the <em>doc/source</em> folder: <em>conf.py</em>, which contains Sphinx’s configuration settings (and is absolutely required for Sphinx to work), and <em>index.rst</em>, which serves as the front page of your documentation. Once you run the quick-start command, you’ll be taken through a series of steps to designate naming conventions, version conventions, and options for other useful tools and standards.</p>&#13;
<p class="indent">The <em>conf.py</em> file contains a few documented variables, such as the project name, the author, and the theme to use for HTML output. Feel free to edit this file at your convenience.</p>&#13;
<p class="indent">Once you’ve built your structure and set your defaults, you can build your documentation in HTML by calling <code>sphinx-build</code> with your source directory and output directory as arguments, as shown in <a href="ch03.xhtml#ch3list1">Listing 3-1</a>. The command <code>sphinx-build</code> reads the <em>conf.py</em> file from the source directory and parses all the <em>.rst</em> files from this directory. It renders them in HTML in the output directory.</p>&#13;
<pre>$ <span class="codestrong1">sphinx-build doc/source doc/build</span><br/>  import pkg_resources<br/>Running Sphinx v1.2b1<br/>loading pickled environment... done<br/>No builder selected, using default: html<br/>building [html]: targets for 1 source files that are out of date<br/>updating environment: 0 added, 0 changed, 0 removed<br/>looking for now-outdated files... none found<br/>preparing documents... done<br/>writing output... [100%] index<br/>writing additional files... genindex search<span epub:type="pagebreak" id="page_36"/><br/>copying static files... done<br/>dumping search index... done<br/>dumping object inventory... done<br/>build succeeded.</pre>&#13;
<p class="listing1"><a id="ch3list1"/><em>Listing 3-1: Building a basic Sphinx HTML document</em></p>&#13;
<p class="indent">Now you can open <em><a href="http://doc/build/index.html">doc/build/index.html</a></em> in your favorite browser and read your documentation.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you’re using <span class="codeitalic">setuptools</span> or <span class="codeitalic">pbr</span> (see <a href="ch05.xhtml#ch05">Chapter 5</a>) for packaging, Sphinx extends them to support the command <span class="codeitalic">setup.py build_sphinx</span>, which will run <span class="codeitalic">sphinx-build</span> automatically. The <span class="codeitalic">pbr</span> integration of Sphinx has some saner defaults, such as outputting the documentation in the /<span class="roman">doc</span> subdirectory.</em></p>&#13;
</div>&#13;
<p class="indent">Your documentation begins with the <em>index.rst</em> file, but it doesn’t have to end there: reST supports <code>include</code> directives to include reST files from other reST files, so there’s nothing stopping you from dividing your documentation into multiple files. Don’t worry too much about syntax and semantics to start; reST offers a lot of formatting possibilities, but you’ll have plenty of time to dive into the reference later. The complete reference (<em><a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html</a></em>) explains how to create titles, bulleted lists, tables, and more.</p>&#13;
<h4 class="h4" id="lev2sec12"><strong><em>Sphinx Modules</em></strong></h4>&#13;
<p class="noindent">Sphinx is highly extensible: its basic functionality supports only manual documentation, but it comes with a number of useful modules that enable automatic documentation and other features. For example, <code>sphinx.ext.autodoc</code> extracts reST-formatted docstrings from your modules and generates <em>.rst</em> files for inclusion. This is one of the options <code>sphinx-quickstart</code> will ask if you want to activate. If you didn’t select that option, however, you can still edit your <em>conf.py</em> file and add it as an extension like so:</p>&#13;
<pre>extensions = ['sphinx.ext.autodoc']</pre>&#13;
<p class="indent">Note that <code>autodoc</code> will <em>not</em> automatically recognize and include your modules. You need to explicitly indicate which modules you want documented by adding something like <a href="ch03.xhtml#ch3list2">Listing 3-2</a> to one of your <em>.rst</em> files.</p>&#13;
<pre>   .. automodule:: foobar<br/><span class="ent">➊</span>     :members:<br/><span class="ent">➋</span>     :undoc-members:<br/><span class="ent">➌</span>     :show-inheritance:</pre>&#13;
<p class="listing1"><a id="ch3list2"/><em>Listing 3-2: Indicating the modules for <span class="codeitalic">autodoc</span> to document</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_37"/>In <a href="ch03.xhtml#ch3list2">Listing 3-2</a>, we make three requests, all of which are optional: that all documented members be printed <span class="ent">➊</span>, that all undocumented members be printed <span class="ent">➋</span>, and that inheritance be shown <span class="ent">➌</span>. Also note the following:</p>&#13;
<ul>&#13;
<li><p class="noindent">If you don’t include any directives, Sphinx won’t generate any output.</p></li>&#13;
<li><p class="noindent">If you only specify <code>:members:</code>, undocumented nodes on your module, class, or method tree will be skipped, even if all their members are documented. For example, if you document the methods of a class but not the class itself, <code>:members:</code> will exclude both the class and its methods. To keep this from happening, you’d have to write a docstring for the class or specify <code>:undoc-members:</code> as well.</p></li>&#13;
<li><p class="noindent">Your module needs to be where Python can import it. Adding <code>.</code>, <code>..</code>, and/or <code>../..</code> to <code>sys.path</code> can help.</p></li>&#13;
</ul>&#13;
<p class="indent">The <code>autodoc</code> extension gives you the power to include most of your documentation in your source code. You can even pick and choose which modules and methods to document—it’s not an “all-or-nothing” solution. By maintaining your documentation directly alongside your source code, you can easily ensure it stays up to date.</p>&#13;
<h5 class="h5"><strong>Automating the Table of Contents with autosummary</strong></h5>&#13;
<p class="noindent">If you’re writing a Python library, you’ll usually want to format your API documentation with a table of contents containing links to individual pages for each module.</p>&#13;
<p class="indent">The <code>sphinx.ext.autosummary</code> module was created specifically to handle this common use case. First, you need to enable it in your <em>conf.py</em> by adding the following line:</p>&#13;
<pre>extensions = ['sphinx.ext.autosummary']</pre>&#13;
<p class="indent">Then, you can add something like the following to an <em>.rst</em> file to automatically generate a table of contents for the specified modules:</p>&#13;
<pre>.. autosummary::<br/><br/>   mymodule<br/>   mymodule.submodule</pre>&#13;
<p class="indent">This will create files called <em>generated/mymodule.rst</em> and <em>generated/mymodule.submodule.rst</em> containing the autodoc directives described earlier. Using this same format, you can specify which parts of your module API you want included in your documentation.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <span class="codeitalic">sphinx-apidoc</span> command can automatically create these files for you; check out the Sphinx documentation to find out more.</em></p>&#13;
</div>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_38"/><strong>Automating Testing with doctest</strong></h5>&#13;
<p class="noindent">Another useful feature of Sphinx is the ability to run <code>doctest</code> on your examples automatically when you build your documentation. The standard Python <code>doctest</code> module searches your documentation for code snippets and tests whether they accurately reflect what your code does. Every paragraph starting with the primary prompt <code>&gt;&gt;&gt;</code> is treated as a code snippet to test. For example, if you wanted to document the standard <code>print</code> function from Python, you could write this documentation snippet and <code>doctest</code> would check the result:</p>&#13;
<pre>    To print something to the standard output, use the :py:func:`print`<br/>function:<br/>&gt;&gt;&gt; <span class="codestrong1">print("foobar")</span><br/>    foobar</pre>&#13;
<p class="indent">Having such examples in your documentation lets users understand your API. However, it’s easy to put off and eventually forget to update your examples as your API evolves. Fortunately, <code>doctest</code> helps make sure this doesn’t happen. If your documentation includes a step-by-step tutorial, <code>doctest</code> will help you keep it up to date throughout development by testing every line it can.</p>&#13;
<p class="indent">You can also use <code>doctest</code> for <em>documentation-driven development (DDD)</em>: write your documentation and examples first and then write code to match your documentation. Taking advantage of this feature is as simple as running <code>sphinx-build</code> with the special <code>doctest</code> builder, like this:</p>&#13;
<pre>$ <span class="codestrong1">sphinx-build -b doctest doc/source doc/build</span><br/>Running Sphinx v1.2b1<br/>loading pickled environment... done<br/>building [doctest]: targets for 1 source files that are out of date<br/>updating environment: 0 added, 0 changed, 0 removed<br/>looking for now-outdated files... none found<br/>running tests...<br/><br/>Document: index<br/>---------------<br/>1 items passed all tests:<br/>   1 tests in default<br/>1 tests in 1 items.<br/>1 passed and 0 failed.<br/>Test passed.<br/><br/>Doctest summary<br/>===============<br/>    1 test<br/>    0 failures in tests<br/>    0 failures in setup code<br/>    0 failures in cleanup code<br/>build succeeded.</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_39"/>When using the <code>doctest</code> builder, Sphinx reads the usual <em>.rst</em> files and executes code examples that are contained in those files.</p>&#13;
<p class="indent">Sphinx also provides a bevy of other features, either out of the box or through extension modules, including these:</p>&#13;
<ul>&#13;
<li><p class="noindent">Linking between projects</p></li>&#13;
<li><p class="noindent">HTML themes</p></li>&#13;
<li><p class="noindent">Diagrams and formulas</p></li>&#13;
<li><p class="noindent">Output to Texinfo and EPUB format</p></li>&#13;
<li><p class="noindent">Linking to external documentation</p></li>&#13;
</ul>&#13;
<p class="indent">You might not need all this functionality right away, but if you ever need it in the future, it’s good to know about in advance. Again, check out the full Sphinx documentation to find out more.</p>&#13;
<h4 class="h4" id="lev2sec13"><strong><em>Writing a Sphinx Extension</em></strong></h4>&#13;
<p class="noindent">Sometimes off-the-shelf solutions just aren’t enough and you need to create custom tools to deal with a situation.</p>&#13;
<p class="indent">Say you’re writing an HTTP REST API. Sphinx will only document the Python side of your API, forcing you to write your REST API documentation by hand, with all the problems that entails. The creators of Web Services Made Easy (WSME) (interviewed at the end of this chapter) have come up with a solution: a Sphinx extension called <code>sphinxcontrib-pecanwsme</code> that analyzes docstrings and actual Python code to generate REST API documentation automatically.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For other HTTP frameworks, such as Flask, Bottle, and Tornado, you can use <span class="codeitalic">sphinxcontrib.httpdomain</span>.</em></p>&#13;
</div>&#13;
<p class="indent">My point is that whenever you know you could extract information from your code to build documentation, you should, and you should also automate the process. This is better than trying to maintain manually written documentation, especially when you can leverage auto-publication tools such as Read the Docs.</p>&#13;
<p class="indent">We’ll examine the <code>sphinxcontrib-pecanwsme</code> extension as an example of writing your own Sphinx extension. The first step is to write a module—preferably as a submodule of <code>sphinxcontrib</code>, as long as your module is generic enough—and pick a name for it. Sphinx requires this module to have one predefined function called <code>setup(app)</code>, which contains the methods you’ll use to connect your code to Sphinx events and directives. The full list of methods is available in the Sphinx extension API at <em><a href="http://www.sphinx-doc.org/en/master/extdev/appapi.html">http://www.sphinx-doc.org/en/master/extdev/appapi.html</a></em>.</p>&#13;
<p class="indent">For example, the <code>sphinxcontrib-pecanwsme</code> extension includes a single directive called <code>rest-controller</code>, added using the <code>setup(app)</code> function. This added directive needs a fully qualified controller class name to generate documentation for, as shown in <a href="ch03.xhtml#ch3list3">Listing 3-3</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_40"/>def setup(app):<br/>    app.add_directive('rest-controller', RESTControllerDirective)</pre>&#13;
<p class="listing1"><a id="ch3list3"/><em>Listing 3-3: Code from <span class="codeitalic">sphinxcontrib.pecanwsme.rest.setup</span> that adds the <span class="codeitalic">rest-controller</span> directive</em></p>&#13;
<p class="indent">The <code>add_directive</code> method in <a href="ch03.xhtml#ch3list3">Listing 3-3</a> registers the <code>rest-controller</code> directive and delegates its handling to the <code>RESTControllerDirective</code> class. This <code>RESTControllerDirective</code> class exposes certain attributes that indicate how the directive treats content, whether it has arguments, and so on. The class also implements a <code>run()</code> method that actually extracts the documentation from your code and returns parsed data to Sphinx.</p>&#13;
<p class="indent">The repository at <em><a href="https://bitbucket.org/birkenfeld/sphinx-contrib/src/">https://bitbucket.org/birkenfeld/sphinx-contrib/src/</a></em> has many small modules that can help you develop your own extensions.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Even though Sphinx is written in Python and targets it by default, extensions are available that allow it to support other languages as well. You can use Sphinx to document your project in full, even if it uses multiple languages at once.</em></p>&#13;
</div>&#13;
<p class="indent">As another example, in one of my projects named Gnocchi—a database for storing and indexing time series data at a large scale—I’ve used a custom Sphinx extension to autogenerate documentation. Gnocchi provides a REST API, and usually to document such an API, projects will manually write examples of what an API request and its response should look like. Unfortunately, this approach is error prone and out of sync with reality.</p>&#13;
<p class="indent">Using the unit-testing code available to test the Gnocchi API, we built a Sphinx extension to run Gnocchi and generate an <em>.rst</em> file containing HTTP requests and responses run against a real Gnocchi server. In this way, we ensure the documentation is up to date: the server responses are not manually crafted, and if a manually written request fails, then the documentation process fails, and we know that we must fix the documentation.</p>&#13;
<p class="indent">Including that code in the book would be too verbose, but you can check the sources of Gnocchi online and look at the <code>gnocchi.gendoc</code> module to get an idea of how it works.</p>&#13;
<h4 class="h4" id="lev2sec14"><strong><em>Managing Changes to Your APIs</em></strong></h4>&#13;
<p class="noindent">Well-documented code is a sign to other developers that the code is suitable to be imported and used to build something else. When building a library and exporting an API for other developers to use, for example, you want to provide the reassurance of solid documentation.</p>&#13;
<p class="indent">This section will cover best practices for public APIs. These will be exposed to users of your library or application, and while you can do whatever you like with internal APIs, public APIs should be handled with care.</p>&#13;
<p class="indent">To distinguish between public and private APIs, the Python convention is to prefix the symbol for a private API with an underscore: <code>foo</code> is public, but <code>_bar</code> is private. You should use this convention both to recognize <span epub:type="pagebreak" id="page_41"/>whether another API is public or private and to name your own APIs. In contrast to other languages, such as Java, Python does not enforce any restriction on accessing code marked as private or public. The naming conventions are just to facilitate understanding among programmers.</p>&#13;
<h4 class="h4" id="lev2sec15"><strong><em>Numbering API Versions</em></strong></h4>&#13;
<p class="noindent">When properly constructed, the version number of an API can give users a great deal of information. Python has no particular system or convention in place for numbering API versions, but we can take inspiration from Unix platforms, which use a complex management system for libraries with fine-grained version identifiers.</p>&#13;
<p class="indent">Generally, your version numbering should reflect changes in the API that will impact users. For example, when the API has a major change, the major version number might change from 1 to 2. When only a few new API calls are added, the lesser number might go from 2.2 to 2.3. If a change only involves bug fixes, the version might bump from 2.2.0 to 2.2.1. A good example of how to use version numbering is the Python <code>requests</code> library (<em><a href="https://pypi.python.org/pypi/requests/">https://pypi.python.org/pypi/requests/</a></em>). This library increments its API numbers based on the number of changes in each new version and the impact the changes might have on consuming programs.</p>&#13;
<p class="indent">Version numbers hint to developers that they should look at changes between two releases of a library, but alone they are not enough to fully guide a developer: you must provide detailed documentation to describe those changes.</p>&#13;
<h4 class="h4" id="lev2sec16"><strong><em>Documenting Your API Changes</em></strong></h4>&#13;
<p class="noindent">Whenever you make changes to an API, the first and most important thing to do is to heavily document them so that a consumer of your code can get a quick overview of what’s changing. Your document should cover the following:</p>&#13;
<ul>&#13;
<li><p class="noindent">New elements of the new interface</p></li>&#13;
<li><p class="noindent">Elements of the old interface that are deprecated</p></li>&#13;
<li><p class="noindent">Instructions on how to migrate to the new interface</p></li>&#13;
</ul>&#13;
<p class="indent">You should also make sure that you don’t remove the old interface right away. I recommend keeping the old interface until it becomes too much trouble to do so. If you have marked it as deprecated, users will know not to use it.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch3list4">Listing 3-4</a> is an example of good API change documentation for code that provides a representation of a car object that can turn in any direction. For whatever reason, the developers decided to retract the <code>turn_left</code> method and instead provide a generic <code>turn</code> method that can take the direction as an argument.</p>&#13;
<pre><span epub:type="pagebreak" id="page_42"/>class Car(object):<br/><br/>    def turn_left(self):<br/>        """Turn the car left.<br/><br/>        .. deprecated:: 1.1<br/>           Use :func:`turn` instead with the direction argument set to left<br/>        """<br/>        self.turn(direction='left')<br/><br/>    def turn(self, direction):<br/>        """Turn the car in some direction.<br/><br/>        :param direction: The direction to turn to.<br/>        :type direction: str<br/>        """<br/>        # Write actual code for the turn function here instead<br/>        pass</pre>&#13;
<p class="listing1"><a id="ch3list4"/><em>Listing 3-4: An example of API change documentation for a car object</em></p>&#13;
<p class="indent">The triple quotes here, <code>"""</code>, indicate the start and end of the docstrings, which will be pulled into the documentation when the user enters <code>help(Car.turn_left)</code> into the terminal or extracts the documentation with an external tool such as Sphinx. The deprecation of the <code>car.turn_left</code> method is indicated by <code>.. deprecated 1.1</code>, where <code>1.1</code> refers to the first version released that ships this code as deprecated.</p>&#13;
<p class="indent">Using this deprecation method and making it visible via Sphinx clearly tells users that the function should not be used and gives them direct access to the new function along with an explanation of how to migrate old code.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch3fig1">Figure 3-1</a> shows Sphinx documentation that explains some deprecated functions.</p>&#13;
<div class="image"><a id="ch3fig1"/><img alt="image" src="../images/f03-01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 3-1: Explanation of some deprecated functions</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_43"/>The downside of this approach is that it relies on developers reading your changelog or documentation when they upgrade to a newer version of your Python package. However, there is a solution for that: mark your deprecated functions with the <code>warnings</code> module.</p>&#13;
<h4 class="h4" id="lev2sec17"><strong><em>Marking Deprecated Functions with the warnings Module</em></strong></h4>&#13;
<p class="noindent">Though deprecated modules should be marked well enough in documentation that users will not attempt to call them, Python also provides the <code>warnings</code> module, which allows your code to issue various kinds of warnings when a deprecated function is called. These warnings, <code>DeprecationWarning</code> and <code>PendingDeprecationWarning</code>, can be used to tell the developer that a function they’re calling is deprecated or going to be deprecated, respectively.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For those who work with C, this is a handy counterpart to the <span class="codeitalic">__attribute__ ((deprecated))</span> GCC extension.</em></p>&#13;
</div>&#13;
<p class="indent">To go back to the car object example in <a href="ch03.xhtml#ch3list4">Listing 3-4</a>, we can use this to warn users when they are attempting to call deprecated functions, as shown in <a href="ch03.xhtml#ch3list5">Listing 3-5</a>.</p>&#13;
<pre>import warnings<br/><br/>class Car(object):<br/>    def turn_left(self):<br/>        """Turn the car left.<br/><br/>     <span class="ent">➊</span> .. deprecated:: 1.1<br/>           Use :func:`turn` instead with the direction argument set to "left".<br/>        """<br/>     <span class="ent">➋</span> warnings.warn("turn_left is deprecated; use turn instead",<br/>                      DeprecationWarning)<br/>        self.turn(direction='left')<br/><br/>    def turn(self, direction):<br/>        """Turn the car in some direction.<br/><br/>        :param direction: The direction to turn to.<br/>        :type direction: str<br/>        """<br/>        # Write actual code here instead<br/>        pass</pre>&#13;
<p class="listing1"><a id="ch3list5"/><em>Listing 3-5: A documented change to the car object API using the <span class="codeitalic">warnings</span> module</em></p>&#13;
<p class="indent">Here, the <code>turn_left</code> function has been deprecated <span class="ent">➊</span>. By adding the <code>warnings.warn</code> line, we can write our own error message <span class="ent">➋</span>. Now, if any code should call the <code>turn_left</code> function, a warning will appear that looks like this:</p>&#13;
<pre>&gt;&gt;&gt; Car().turn_left()<br/>__main__:8: DeprecationWarning: turn_left is deprecated; use turn instead</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_44"/>Python 2.7 and later versions, by default, do not print any warnings emitted by the <code>warnings</code> module because the warnings are filtered. To see those warnings printed, you need to pass the <code>-W</code> option to the Python executable. The option <code>-W</code> all will print all warnings to <code>stderr</code>. See the Python man page for more information on the possible values for <code>-W</code>.</p>&#13;
<p class="indent">When running test suites, developers can run Python with the <code>-W</code> error option, which will raise an error every time an obsolete function is called. Developers using your library can readily find exactly where their code needs to be fixed. <a href="ch03.xhtml#ch3list6">Listing 3-6</a> shows how Python transforms warnings into fatal exceptions when Python is called with the <code>-W</code> error option.</p>&#13;
<pre>&gt;&gt;&gt; import warnings<br/>&gt;&gt;&gt; warnings.warn("This is deprecated", DeprecationWarning)<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>DeprecationWarning: This is deprecated</pre>&#13;
<p class="listing1"><a id="ch3list6"/><em>Listing 3-6: Running <span class="codeitalic">Python</span> with the <span class="codeitalic">-W</span> error option and getting a deprecation error</em></p>&#13;
<p class="indent">Warnings are usually missed at runtime, and running a production system with the <code>-W</code> error option is rarely a good idea. Running the test suite of a Python application with the <code>-W</code> error option, on the other hand, can be a good way to catch warnings and fix them early on.</p>&#13;
<p class="indent">However, manually writing all those warnings, docstring updates, and so on can become tedious, so the <code>debtcollector</code> library has been created to help automate some of that. The <code>debtcollector</code> library provides a few decorators that you can use with your functions to make sure the correct warnings are emitted and the docstring is updated correctly. <a href="ch03.xhtml#ch3list7">Listing 3-7</a> shows how you can, with a simple decorator, indicate that a function has been moved to some other place.</p>&#13;
<pre>from debtcollector import moves<br/><br/>class Car(object):<br/>    @moves.moved_method('turn', version='1.1')<br/>    def turn_left(self):<br/>        """Turn the car left."""<br/><br/>        return self.turn(direction='left')<br/>    def turn(self, direction):<br/>        """Turn the car in some direction.<br/><br/>        :param direction: The direction to turn to.<br/>        :type direction: str<br/>        """<br/><br/>        # Write actual code here instead<br/>        pass</pre>&#13;
<p class="listing1"><a id="ch3list7"/><em>Listing 3-7: An API change automated with <span class="codeitalic">debtcollector</span></em></p>&#13;
<p class="indent">Here we’re using the <code>moves()</code> method from <code>debtcollector</code>, whose <code>moved_method</code> decorator makes <code>turn_left</code> emit a <code>DeprecationWarning</code> whenever it’s called.</p>&#13;
<h3 class="h3" id="lev1sec15"><span epub:type="pagebreak" id="page_45"/><strong>Summary</strong></h3>&#13;
<p class="noindent">Sphinx is the de facto standard for documenting Python projects. It supports a wide variety of syntax, and it is easy to add new syntax or features if your project has particular needs. Sphinx can also automate tasks such as generating indexes or extracting documentation from your code, making it easy to maintain documentation in the long run.</p>&#13;
<p class="indent">Documenting changes to your API is critical, especially when you deprecate functionality, so that users are not caught unawares. Ways to document deprecations include the Sphinx deprecated keyword and the <code>warnings</code> module, and the <code>debtcollector</code> library can automate maintaining this documentation.</p>&#13;
<h3 class="h3" id="lev1sec16"><strong>Christophe de Vienne on Developing APIs</strong></h3>&#13;
<p class="noindent">Christophe is a Python developer and the author of the WSME (Web Services Made Easy) framework, which allows developers to define web services in a Pythonic way and supports a wide variety of APIs, allowing it to be plugged into many other web frameworks.</p>&#13;
<p class="noindentt"><strong>What mistakes do developers tend to make when designing a Python API?</strong></p>&#13;
<p class="noindent">There are a few common mistakes I avoid when designing a Python API by following these rules:</p>&#13;
<ul>&#13;
<li><p class="noindentt"><strong>Don’t make it too complicated.</strong> Keep it simple. Complicated APIs are hard to understand and hard to document. While the actual library functionality doesn’t <em>have</em> to be simple as well, it’s smart to make it simple so users can’t easily make mistakes. For example, the library is very simple and intuitive, but it does complex things behind the scenes. The <code>urllib</code> API, by contrast, is almost as complicated as the things it does, making it hard to use.</p></li>&#13;
<li><p class="noindentt"><strong>Make the magic visible.</strong> When your API does things that your documentation doesn’t explain, your end users will want to crack open your code and see what’s going on under the hood. It’s okay if you’ve got some magic happening behind the scenes, but your end users should never see anything unexpected happening up front, or they could become confused or rely on a behavior that may change.</p></li>&#13;
<li><p class="noindentt"><strong>Don’t forget use cases.</strong> When you’re so focused on writing code, it’s easy to forget to think about how your library will actually be used. Thinking up good use cases makes it easier to design an API.</p></li>&#13;
<li><p class="noindentt"><strong>Write unit tests.</strong> <em>TDD (test-driven development)</em> is a very efficient way to write libraries, especially in Python, because it forces the developer to assume the role of the end user from the very beginning, which leads the developer to design for usability. It’s the only approach I know of that allows a programmer to completely rewrite a library, as a last resort.</p></li>&#13;
</ul>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_46"/><strong>What aspects of Python may affect how easy it is to design a library API?</strong></p>&#13;
<p class="noindent">Python has no built-in way to define which sections of the API are public and which are private, which can be both a problem and an advantage.</p>&#13;
<p class="indent">It’s a problem because it can lead the developer to not fully consider which parts of their API are public and which parts should remain private. But with a little discipline, documentation, and (if needed) tools like <code>zope.interface</code>, it doesn’t stay a problem for long.</p>&#13;
<p class="indent">It’s an advantage when it makes it quicker and easier to refactor APIs while keeping compatibility with previous versions.</p>&#13;
<p class="noindentt"><strong>What do you consider when thinking about your API’s evolution, deprecation, and removal?</strong></p>&#13;
<p class="noindent">There are several criteria I weigh when making any decision regarding API development:</p>&#13;
<ul>&#13;
<li><p class="noindentt"><strong>How difficult will it be for users of the library to adapt their code?</strong> Considering that there are people relying on your API, any change you make has to be worth the effort needed to adopt it. This rule is intended to prevent incompatible changes to the parts of the API that are in common use. That said, one of the advantages of Python is that it’s relatively easy to refactor code to adopt an API change.</p></li>&#13;
<li><p class="noindentt"><strong>How easy will it be to maintain my API?</strong> Simplifying the implementation, cleaning up the codebase, making the API easier to use, having more complete unit tests, making the API easier to understand at first glance . . . all of these things will make your life as a maintainer easier.</p></li>&#13;
<li><p class="noindentt"><strong>How can I keep my API consistent when applying a change?</strong> If all the functions in your API follow a similar pattern (such as requiring the same parameter in the first position), make sure new functions follow that pattern as well. Also, doing too many things at once is a great way to end up doing none of them right: keep your API focused on what it’s meant to do.</p></li>&#13;
<li><p class="noindentt"><strong>How will users benefit from the change?</strong> Last but not least, always consider the users’ point of view.</p></li>&#13;
</ul>&#13;
<p class="noindentt"><strong>What advice do you have regarding API documentation in Python?</strong></p>&#13;
<p class="noindent">Good documentation makes it easy for newcomers to adopt your library. Neglecting it will drive away a lot of potential users—not just beginners, either. The problem is, documenting is difficult, so it gets neglected all the time!</p>&#13;
<ul>&#13;
<li><p class="noindentt"><strong>Document early and include your documentation build in continuous integration.</strong> With the Read the Docs tool for creating and hosting documentation, there’s no excuse for not having documentation built and published (at least for open source software).</p></li>&#13;
<li><p class="noindentt"><span epub:type="pagebreak" id="page_47"/><strong>Use docstrings to document classes and functions in your API.</strong> If you follow the PEP 257 (<em><a href="https://www.python.org/dev/peps/pep-0257/">https://www.python.org/dev/peps/pep-0257/</a></em>) guidelines, developers won’t have to read your source to understand what your API does. Generate HTML documentation from your docstrings—and don’t limit it to the API reference.</p></li>&#13;
<li><p class="noindentt"><strong>Give practical examples throughout.</strong> Have at least one “startup guide” that will show newcomers how to build a working example. The first page of the documentation should give a quick overview of your API’s basic and representative use case.</p></li>&#13;
<li><p class="noindentt"><strong>Document the evolution of your API in detail, version by version.</strong> Version control system (VCS) logs are not enough!</p></li>&#13;
<li><p class="noindentt"><strong>Make your documentation accessible and, if possible, comfortable to read.</strong> Your users need to be able to find it easily and get the information they need without feeling like they’re being tortured. Publishing your documentation through PyPI is one way to achieve this; publishing on Read the Docs is also a good idea, since users will expect to find your documentation there.</p></li>&#13;
<li><p class="noindentt"><strong>Finally, choose a theme that is both efficient and attractive.</strong> I chose the “Cloud” Sphinx theme for WSME, but there are plenty of other themes out there to choose from. You don’t have to be a web expert to produce nice-looking documentation.</p></li>&#13;
</ul>&#13;
</body></html>