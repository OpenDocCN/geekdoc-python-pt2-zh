- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: FINDING PALINGRAM SPELLS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 查找回文短语的拼写**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Radar. Kayak. Rotator. Sexes. What do these words all have in common? They’re
    *palindromes*, words that are spelled the same forward and backward. Even better
    are *palingrams*, whole phrases that behave the same way. Napoleon is the author
    of the most famous palingram. When he first saw Elba, the island of his exile,
    he said, “Able was I ere I saw Elba.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Radar。Kayak。Rotator。Sexes。这些词有什么共同点？它们是*回文*，即正读和反读都相同的单词。更棒的是*回文短语*，它们是完整的短语，也表现得一样。拿破仑就是最著名的回文短语的作者。当他第一次看到厄尔巴岛——他的流放地时，他说：“Able
    was I ere I saw Elba。”
- en: 'In 2011, DC Comics published an interesting story that made clever use of palingrams.
    The superhero sorceress Zatanna was cursed so that she could cast spells only
    by speaking palindromically. She managed to think up just enough two-word phrases
    like *nurses run*, *stack cats*, and *puff up* to defeat her sword-wielding attacker.
    This got me wondering: just how many “combative” palingrams are there? And are
    there better choices for Zatanna?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，DC Comics 发布了一个有趣的故事，巧妙地运用了回文短语。超级女巫 Zatanna 被施下了一个诅咒，只有通过回文方式说话才能施展魔法。她想出了足够多的双词短语，比如
    *nurses run*、*stack cats* 和 *puff up*，用这些回文短语击败了持剑攻击者。这让我开始好奇：究竟有多少“具有攻击性”的回文短语呢？Zatanna
    是否有更好的选择？
- en: In this chapter, you’ll load dictionary files from the internet and use Python
    to discover first palindromes and then the more complex palingrams in those files.
    Then you’ll use a tool called cProfile to analyze your palingram code so that
    you can make it more performant. Finally, you’ll sift through the palingrams to
    see how many have an “aggressive” nature.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将从互联网上加载字典文件，并使用 Python 首先发现回文词，然后在这些文件中发现更复杂的回文短语。接着，你将使用名为 cProfile
    的工具来分析你的回文短语代码，以便提升性能。最后，你将筛选出回文短语，看看其中有多少具有“攻击性”特征。
- en: '**Finding and Opening a Dictionary**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查找并打开字典**'
- en: All the projects in this chapter require a listing of words in a text file format,
    commonly referred to as a *dictionary file*, so let’s start by learning how to
    load one.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有项目都需要一个文本文件格式的单词列表，通常称为*字典文件*，所以我们从学习如何加载一个字典文件开始。
- en: Despite their name, dictionary files contain only words—no pronunciation, syllable
    count, definitions, and so on. This is good news, as those things would just get
    in our way. And even better, dictionary files are available online for free.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们被称为字典文件，但这些文件只包含单词——没有发音、音节数、定义等信息。这是好消息，因为这些内容会干扰我们的工作。更好的是，字典文件可以在线免费下载。
- en: You can find suitable dictionary files at the locations listed in [Table 2-1](ch02.xhtml#ch02tab1).
    Download one of the files or, if it opens directly, copy and paste the contents
    into a text editor like Notepad or WordPad (TextEdit on macOS) and save it as
    a *.txt* file. Keep the dictionary in the same folder as the Python code. I used
    the *2of4brif.txt* file to prepare this project. It can be found in the downloadable
    *12dicts-6.0.2.zip* file on the website listed first in [Table 2-1](ch02.xhtml#ch02tab1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[表 2-1](ch02.xhtml#ch02tab1)列出的位置找到合适的字典文件。下载其中一个文件，或者如果文件直接打开，可以将其内容复制并粘贴到文本编辑器（如
    Notepad 或 WordPad，macOS 上的 TextEdit）中，然后将其保存为 *.txt* 文件。将字典文件保存在与 Python 代码相同的文件夹中。我使用了
    *2of4brif.txt* 文件来准备这个项目。它可以在[表 2-1](ch02.xhtml#ch02tab1)中第一个网站提供的可下载 *12dicts-6.0.2.zip*
    文件中找到。
- en: '**Table 2-1:** Downloadable Dictionary Files'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1:** 可下载字典文件'
- en: '| **File** | **Number of words** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **文件** | **单词数** |'
- en: '| --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *[http://wordlist.aspell.net/12dicts/](http://wordlist.aspell.net/12dicts/)*
    | 60,388 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| *[http://wordlist.aspell.net/12dicts/](http://wordlist.aspell.net/12dicts/)*
    | 60,388 |'
- en: '| *[https://inventwithpython.com/dictionary.txt](https://inventwithpython.com/dictionary.txt)*
    | 45,000 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| *[https://inventwithpython.com/dictionary.txt](https://inventwithpython.com/dictionary.txt)*
    | 45,000 |'
- en: '| *[http://www-personal.umich.edu/~jlawler/wordlist.html](http://www-personal.umich.edu/~jlawler/wordlist.html)*
    | 69,903 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| *[http://www-personal.umich.edu/~jlawler/wordlist.html](http://www-personal.umich.edu/~jlawler/wordlist.html)*
    | 69,903 |'
- en: '| *[http://greenteapress.com/thinkpython2/code/words.txt](http://greenteapress.com/thinkpython2/code/words.txt)*
    | 113,809 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| *[http://greenteapress.com/thinkpython2/code/words.txt](http://greenteapress.com/thinkpython2/code/words.txt)*
    | 113,809 |'
- en: In addition to the files in [Table 2-1](ch02.xhtml#ch02tab1), Unix and Unix-like
    operating systems come packaged with a large newline-delimited word file of more
    than 200,000 words. It is usually stored in */usr/share/dict/words* or */usr/dict/words*.
    On Debian GNU/Linux, word lists are in */usr/share/opendict/dictionaries*. The
    macOS dictionaries are generally found in */Library/Dictionaries*, and non-English
    dictionaries are included. You may need to do an online search for your operating
    system and version to find the exact directory path if you want to use one of
    these files.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Some dictionary files exclude *a* and *I* as words. Others may include every
    letter in the dictionary as a single word “header” (such as *d* at the start of
    words beginning with *d*). We’ll ignore one-letter palindromes in these projects,
    so these issues shouldn’t be a problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '***Handling Exceptions When Opening Files***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whenever you load an external file, your program should automatically check
    for I/O issues, like missing files or incorrect filenames, and let you know if
    there is a problem.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following try and except statements to catch and handle *exceptions*,
    which are errors detected during execution:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '➊ try:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '➋ with open(file) as in_file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: do something
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'except IOError➌ as e:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: ➍ print("{}\nError opening {}. Terminating program.".format(e, file),
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: file=sys.stderr)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: ➎ sys.exit(1)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The try clause is executed first ➊. The with statement will automatically close
    the file after the nested block of code, regardless of how the block exits ➋.
    Closing files prior to terminating a process is a good practice. If you don’t
    close those files, you could run out of file descriptors (mainly a problem with
    large scripts that run for a long time), lock the file from further access in
    Windows, corrupt the files, or lose data if you are writing to the file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: If something goes wrong and if the type of error matches the exception named
    after the except keyword ➌, the rest of the try clause is skipped, and the except
    clause is executed ➍. If nothing goes wrong, the try clause is executed, and the
    except clause is skipped. The print statement in the except clause lets you know
    there’s a problem, and the file=sys.stderr argument colors the error statement
    red in the IDLE interpreter window.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The sys.exit(1) ➎ statement is used to terminate the program. The 1 in sys.exit(1)
    indicates that the program experienced an error and did not close successfully.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: If an exception occurs that *doesn’t* match the named exception in the except
    clause, it is passed to any outer try statements or the main program execution.
    If no handler is found, the *unhandled exception* causes the program to stop with
    a standard “traceback” error message.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '***Loading the Dictionary File***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 2-1](ch02.xhtml#ch02list1) loads a dictionary file as a list. Manually
    enter this script or download it as *load_dictionary.py* from *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: You can import this file into other programs as a module and run it with a one-line
    statement. Remember, a module is simply a Python program that can be used in another
    Python program. As you’re probably aware, modules represent a form of *abstraction*.
    Abstraction means you don’t have to worry about all the coding details. A principle
    of abstraction is *encapsulation*, the act of hiding the details. We encapsulate
    the file-loading code in a module so you don’t have to see or worry about the
    detailed code in another program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此文件作为模块导入到其他程序中，并通过一行代码运行它。记住，模块只是一个可以在另一个 Python 程序中使用的 Python 程序。正如你可能已经知道的那样，模块代表了一种*抽象*的形式。抽象意味着你不必关心所有的编码细节。抽象的一个原则是*封装*，即隐藏细节的行为。我们将文件加载代码封装在模块中，这样你就不必在另一个程序中看到或担心详细的代码。
- en: '*load_dictionary.py*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*load_dictionary.py*'
- en: '"""Load a text file as a list.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将文本文件加载为列表。'
- en: 'Arguments:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: -text file name (and directory path, if needed)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '- 文本文件名（如有必要，还需包含目录路径）'
- en: 'Exceptions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 异常：
- en: -IOError if filename not found.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果找不到文件名，则会引发 IOError。'
- en: 'Returns:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值：
- en: -A list of all words in a text file in lower case.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '- 以小写形式列出文本文件中的所有单词。'
- en: Requires-import sys
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 需要导入：sys
- en: '"""'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ➊ import sys
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import sys
- en: '➋ def load(file):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def load(file):'
- en: '"""Open a text file & return a list of lowercase strings."""'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '"""打开文本文件并返回一个小写字符串的列表。"""'
- en: 'try:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'with open(file) as in_file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(file) as in_file:'
- en: ➌ loaded_txt = in_file.read().strip().split('\n')
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ loaded_txt = in_file.read().strip().split('\n')
- en: ➍ loaded_txt = [x.lower() for x in loaded_txt]
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ loaded_txt = [x.lower() for x in loaded_txt]
- en: return loaded_txt
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: return loaded_txt
- en: 'except IOError as e:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'except IOError as e:'
- en: ➎ print("{}\nError opening {}. Terminating program.".format(e, file),
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ print("{}\nError opening {}. Terminating program.".format(e, file),
- en: file=sys.stderr)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: file=sys.stderr)
- en: sys.exit(1)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit(1)
- en: '*Listing 2-1: The module for loading a dictionary file as a list*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-1：将字典文件加载为列表的模块*'
- en: After the docstring, we import system functions with sys so that our error-handling
    code will work ➊. The next block of code defines a function based on the previous
    file-opening discussion ➋. The function takes a filename as an argument.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档字符串之后，我们导入系统函数 sys，以便我们的错误处理代码能够正常工作 ➊。接下来的代码块根据之前的文件打开讨论定义了一个函数 ➋。该函数以文件名作为参数。
- en: If no exceptions are raised, the text file’s whitespace is removed, and its
    items are split into separate lines and added to a list ➌. We want each word to
    be a separate item in the list, before the list is returned. And since case matters
    to Python, the words in the list are converted to lowercase via *list comprehension*
    ➍. List comprehension is a shorthand way to convert a list, or other iterable,
    into another list. In this case, it replaces a for loop.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有抛出异常，则文本文件的空白字符被移除，文件中的项被分割成单独的行并添加到列表中 ➌。我们希望每个单词都是列表中的一个独立项，然后再返回该列表。由于
    Python 对大小写敏感，列表中的单词通过*列表推导* ➍ 转换为小写。列表推导是一种将列表或其他可迭代对象转换为另一个列表的简便方法。在这种情况下，它取代了
    for 循环。
- en: If an I/O error is encountered, the program displays the standard error message,
    designated by the e, along with a message describing the event and informing the
    user that the program is ending ➎. The sys.exit(1) command then terminates the
    program.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到 I/O 错误，程序会显示标准错误消息，由 e 指定，同时输出描述事件的消息并通知用户程序即将结束 ➎。然后，sys.exit(1) 命令终止程序。
- en: This code example is for illustrative purposes, to show how these steps work
    together. Generally, you wouldn’t call sys.exit() from a module, as you may want
    your program to do something—like write a log file—prior to terminating. In later
    chapters, we’ll move both the try-except blocks and sys.exit() into a main() function
    for clarity and control.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例仅用于说明，展示这些步骤如何协同工作。通常，你不会从模块中调用 sys.exit()，因为你可能希望程序在终止之前执行某些操作——比如写日志文件。在后续章节中，我们将把
    try-except 块和 sys.exit() 移入 main() 函数，以便更加清晰和可控。
- en: '**Project #2: Finding Palindromes**'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #2：查找回文**'
- en: You’ll start by finding single-word palindromes in a dictionary and then move
    on to the more difficult palindromic phrases.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从查找词典中的单字回文开始，然后转向更困难的回文短语。
- en: '**THE OBJECTIVE**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use Python to search an English language dictionary file for palindromes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 在英语词典文件中查找回文。
- en: '***The Strategy and Pseudocode***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: 'Before you get into the code, step back and think about what you want to do
    conceptually. Identifying palindromes is easy: simply compare a word to itself
    sliced backward. Here is an example of slicing a word front to back and then back
    to front:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，先停下来思考一下你从概念上想做什么。识别回文字符串很简单：只需将一个单词与它自己倒过来切片进行比较。以下是一个将单词从前到后切片，然后再从后到前切片的示例：
- en: '>>> word = ''NURSES'''
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word = ''NURSES'''
- en: '>>> word[:]'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word[:]'
- en: '''NURSES'''
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '''NURSES'''
- en: '>>> word[::-1]'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word[::-1]'
- en: '''SESRUN'''
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '''SESRUN'''
- en: If you don’t provide values when slicing a string (or any sliceable type), the
    default is to use the start of the string, the end of the string, and a positive
    step equal to 1.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在切片字符串（或任何可切片类型）时不提供值，则默认使用字符串的起始位置、结束位置和步长为1的正向切片。
- en: '[Figure 2-1](ch02.xhtml#ch02fig1) illustrates the reverse slicing process.
    I’ve provided a starting position of 2 and a step of –1. Because no end index
    is provided (there is no index or space between the colons), the implication is
    to go backward (because the index step is –1) until there are no more characters
    left.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](ch02.xhtml#ch02fig1)展示了反向切片过程。我提供了起始位置为2，步长为-1。由于没有提供结束索引（冒号之间没有索引或空格），所以意味着要向后切片（因为步长为-1），直到没有更多字符为止。'
- en: '![image](../images/f0023-01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0023-01.jpg)'
- en: '*Figure 2-1: An example of negative slicing for* word = ''NURSES'''
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：''NURSES'' 这个单词的负向切片示例*'
- en: Negative slicing doesn’t behave exactly the same way as forward slicing, and
    the positive and negative position values and endpoints are asymmetrical. This
    can lead to confusion, so let’s restrict our negative slicing to the simple [::-1]
    format.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 负向切片的行为与正向切片略有不同，正负位置值和端点是不对称的。这可能会导致混淆，因此我们将限制负向切片为简单的[::-1]格式。
- en: 'Finding palindromes in the dictionary will take fewer lines of code than loading
    the dictionary file! Here’s the pseudocode:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找回文所需的代码行数将比加载字典文件还少！这是伪代码：
- en: Load digital dictionary file as a list of words
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字字典文件加载为一个单词列表
- en: Create an empty list to hold palindromes
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空列表来存储回文
- en: 'Loop through each word in the word list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历单词列表中的每个单词：
- en: 'If word sliced forward is the same as word sliced backward:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正向切片的单词与反向切片的单词相同：
- en: Append word to palindrome list
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词添加到回文列表
- en: Print palindrome list
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 打印回文列表
- en: '***The Palindrome Code***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回文代码***'
- en: '[Listing 2-2](ch02.xhtml#ch02list2), *palindromes.py*, reads in an English
    dictionary file, identifies which words are palindromes, saves them to a list,
    and prints the list as stacked items. You can download this code from the book’s
    resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    You will also need *load_dictionary.py* and a dictionary file; save all three
    files in the same folder.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-2](ch02.xhtml#ch02list2)，*palindromes.py*，读取英文字典文件，识别哪些单词是回文，将它们保存到列表中，并将列表作为堆叠项打印。你可以从本书的资源下载此代码，访问*
    [https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。你还需要*load_dictionary.py*和字典文件；将这三个文件保存在同一文件夹中。'
- en: '*palindromes.py*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*palindromes.py*'
- en: '"""Find palindromes (letter palingrams) in a dictionary file."""'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在字典文件中查找回文（字母回文组）。"""'
- en: ➊ import load_dictionary
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import load_dictionary
- en: ➋ word_list = load_dictionary.load('2of4brif.txt')
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ word_list = load_dictionary.load('2of4brif.txt')
- en: ➌ pali_list = []
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ pali_list = []
- en: '➍ for word in word_list:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ for word in word_list:'
- en: 'if len(word) > 1 and word == word[::-1]:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 len(word) > 1 且 word == word[::-1]：
- en: pali_list.append(word)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: pali_list.append(word)
- en: print("\nNumber of palindromes found = {}\n".format(len(pali_list)))
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: print("\n找到的回文数量 = {}\n".format(len(pali_list)))
- en: ➎ print(*pali_list, sep='\n')
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ print(*pali_list, sep='\n')
- en: '*Listing 2-2: Finds palindromes in loaded dictionary file*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-2：在加载的字典文件中查找回文*'
- en: Start by importing *load_dictionary.py* as a module ➊. Note that the *.py* extension
    is not used for importing. Also, the module is in the same folder as this script,
    so we don’t have to specify a directory path to the module. And since the module
    contains the required import sys line, we don’t need to repeat it here.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将*load_dictionary.py*作为模块导入 ➊。注意，导入时不使用*.py*扩展名。而且，该模块与此脚本位于同一文件夹，因此我们无需指定模块的目录路径。而且，由于该模块包含所需的import
    sys行，因此我们无需在此重复。
- en: To populate our word list with words from the dictionary, call the load() function
    in the load_dictionary module with dot notation ➋. Pass it the name of the external
    dictionary file. Again, you don’t need to specify a path if the dictionary file
    is in the same folder as the Python script. The filename you use may be different
    depending on the dictionary you downloaded.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从字典中填充我们的单词列表，在load_dictionary模块中使用点表示法调用load()函数 ➋。将外部字典文件的名称传递给它。如果字典文件与Python脚本位于同一文件夹中，你不需要指定路径。你使用的文件名可能会因你下载的字典而有所不同。
- en: Next, create an empty list to hold the palindromes ➌ and start looping through
    every word in word_list ➍, comparing the forward slice to the reverse slice. If
    the two slices are identical, append the word to pali_list. Notice that only words
    with more than one letter are allowed (len(word) > 1), which follows the strictest
    definition of a palindrome.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个空列表来存储回文 ➌，并开始遍历word_list中的每个单词 ➍，将正向切片与反向切片进行比较。如果两个切片相同，将该单词附加到pali_list中。请注意，只有长度大于1的单词才被允许（len(word)
    > 1），这符合回文的最严格定义。
- en: Finally, print the palindromes in an attractive way—stacked and with no quotation
    marks or commas ➎. You can accomplish this by looping through every word in the
    list, but there is a more efficient way to do it. You can use the *splat* operator
    (designated by the *), which takes a list as input and expands it into positional
    arguments in the function call. The last argument is the separator used between
    multiple list values for printing. The default separator is a space (sep=' '),
    but instead, print each item on a new line (sep='\n').
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以一种吸引人的方式打印回文——堆叠并且没有引号或逗号 ➎。你可以通过遍历列表中的每个单词来实现这一点，但有一种更高效的方法。你可以使用*splat*操作符（由*表示），它将列表作为输入并将其展开为函数调用中的位置参数。最后一个参数是用于打印多个列表值之间的分隔符。默认的分隔符是空格（sep='
    '），但你可以改为在每个项之间换行（sep='\n'）。
- en: Single-word palindromes are rare, at least in English. Using a 60,000-word dictionary
    file, you’ll be lucky to find about 60, or only 0.1 percent of all the words.
    Despite their rarity, however, they’re easy enough to find with Python. So, let’s
    move on to the more interesting, and more complicated, palingrams.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 单词回文很少见，至少在英语中是这样。使用一个60,000个单词的字典文件，你可能幸运地找到大约60个，或者仅占所有单词的0.1%。尽管它们稀有，然而，用Python查找它们却非常容易。所以，让我们继续处理更有趣且更复杂的回文对。
- en: '**Project #3: Finding Palingrams**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #3：寻找回文对**'
- en: Finding palingrams requires a bit more effort than finding one-word palindromes.
    In this section, we’ll plan and write code to find word-pair palingrams.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 查找回文对比查找单个回文单词需要更多的努力。在本节中，我们将规划并编写代码来查找单词对回文。
- en: '**THE OBJECTIVE**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use Python to search an English language dictionary for two-word palingrams.
    Analyze and optimize the palingram code using the cProfile tool.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python在英语词典中搜索两词回文对。使用cProfile工具分析和优化回文代码。
- en: '***The Strategy and Pseudocode***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: Example word-pair palingrams are *nurses run* and *stir grits*. (In case you’re
    wondering, grits are a ground-corn breakfast dish, similar to Italian polenta.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的单词对回文有*nurses run*和*stir grits*。（顺便说一下，grits是一种玉米早餐菜肴，类似于意大利的玉米粥。）
- en: Like palindromes, palingrams read the same forward and backward. I like to think
    of these as a *core* word, like *nurses*, from which a *palindromic sequence*
    and *reversed word* are derived (see [Figure 2-2](ch02.xhtml#ch02fig2)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与回文类似，回文对正着读和反着读是一样的。我喜欢将它们看作是一个*核心*单词，比如*nurses*，从中派生出一个*回文序列*和*反向单词*（见[图 2-2](ch02.xhtml#ch02fig2)）。
- en: '![image](../images/f0025-01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0025-01.jpg)'
- en: '*Figure 2-2: Dissecting word-pair palingrams*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：解剖单词对回文*'
- en: 'Our program will examine the core word. Based on [Figure 2-2](ch02.xhtml#ch02fig2),
    we can make the following inferences about the core word:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将检查核心单词。根据[图 2-2](ch02.xhtml#ch02fig2)，我们可以对核心单词做出以下推断：
- en: It can have either an odd or even number of letters.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可以是奇数或偶数个字母。
- en: One contiguous part of the word spells a real word when read backward.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单词的一个相邻部分反向拼读时形成一个真实的单词。
- en: This contiguous part can occupy part or all of the core word.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个相邻部分可以占据核心单词的一部分或全部。
- en: The other contiguous part contains a palindromic sequence of letters.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个相邻部分包含一个回文字母序列。
- en: The palindromic sequence can occupy part or all of the core word.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回文序列可以占据核心单词的一部分或全部。
- en: The palindromic sequence does not have to be a real word (unless it occupies
    the *whole* word).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回文序列不必是一个真实的单词（除非它占据了*整个*单词）。
- en: The two parts cannot overlap or share letters.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个部分不能重叠或共享字母。
- en: The sequence is reversible.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该序列是可逆的。
- en: '**NOTE**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If the reversed word occupies the whole core word and is not a palindrome,
    it’s called a* semordnilap*. A semordnilap is similar to a palindrome except for
    one key difference: rather than spelling the* same *word when read backward, it
    spells a* different *word. Examples are* bats *and* stab*, and* wolf *and* flow*.
    Semordnilap, by the way, is* palindromes *spelled backward.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果反转词占据整个核心单词并且不是回文，则称其为*逆向词*。逆向词与回文相似，但有一个关键区别：它不会在反向读取时拼出*相同*的单词，而是拼出*不同*的单词。例如，*bats*和*stab*，以及*wolf*和*flow*。顺便提一下，逆向词是*回文*的反写。*'
- en: '[Figure 2-3](ch02.xhtml#ch02fig3) represents an arbitrary word of six letters.
    The Xs represent the part of the word that *might* form a real word when read
    backward (like *run* in *nurses*). The Os represent the *possible* palindromic
    sequence (like *ses* in *nurses*). The word represented in the left column in
    [Figure 2-3](ch02.xhtml#ch02fig3) behaves like *nurses* in [Figure 2-2](ch02.xhtml#ch02fig2),
    with the reversed word at the start. The word represented by the right column
    behaves like *grits*, with the reversed word at the end. Note that the number
    of combinations in each column is the total number of letters in the word plus
    one; note too that the top and bottom rows represent an identical circumstance.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](ch02.xhtml#ch02fig3)表示一个任意的六个字母单词。Xs表示单词的部分，*可能*在反向读取时形成一个真正的单词（例如*run*在*nurses*中）。Os表示*可能的*回文序列（例如*nurses*中的*ses*）。[图
    2-3](ch02.xhtml#ch02fig3)左列中表示的单词行为像[图 2-2](ch02.xhtml#ch02fig2)中的*nurses*，其反转词在开头。右列中表示的单词行为像*grits*，其反转词在末尾。请注意，每列中的组合数是单词中字母总数加一；还要注意，顶部和底部行表示相同的情况。'
- en: The top row in each column represents a semordnilap. The bottom row in each
    represents a palindrome. These are both reversed words, just different *types*
    of reversed words. Hence, they count as one entity and both can be identified
    with a single line of code in a single loop.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每列的顶部行表示一个逆向词。每列的底部行表示一个回文。这些都是反转词，只是不同的*类型*的反转词。因此，它们算作一个实体，可以通过单行代码在一个循环中进行识别。
- en: '![image](../images/f0026-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0026-01.jpg)'
- en: '*Figure 2-3: Possible positions for letters of the reversed word (X) and the
    palindromic sequence (O) in a six-letter core word*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：六个字母核心单词中反转词（X）和回文序列（O）的位置可能性*'
- en: To see the diagram in action, consider [Figure 2-4](ch02.xhtml#ch02fig4), which
    shows the palingrams *devils lived* and *retro porter*. *Devils* and *porter*
    are both core words and mirror images of each other with respect to palindromic
    sequences and reversed words. Compare this to the semordnilap *evil* and the palindrome
    *kayak*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看图表的实际应用，考虑[图 2-4](ch02.xhtml#ch02fig4)，其中显示了回文*devils lived*和*retro porter*。*Devils*和*porter*都是核心单词，是相互镜像的，它们在回文序列和反转词方面相对应。将其与逆向词*evil*和回文*kayak*进行比较。
- en: '![image](../images/f0027-01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0027-01.jpg)'
- en: '*Figure 2-4: Reversed words (Xs) and palindromic sequences (Os) in words, semordnilaps,
    and palindromes.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：单词中的反转词（Xs）和回文序列（Os），逆向词和回文。*'
- en: Palindromes are both reversed words *and* palindromic sequences. Since they
    have the same pattern of Xs as in semordnilaps, they can be handled with the same
    code used for semordnilaps.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回文既是反转词*也是*回文序列。由于它们具有与逆向词相同的 X 模式，因此可以使用与逆向词相同的代码进行处理。
- en: From a strategy perspective, you’ll need to loop through each word in the dictionary
    and evaluate it for *all of the combinations* in [Figure 2-3](ch02.xhtml#ch02fig3).
    Assuming a 60,000-word dictionary, the program will need to take about 500,000
    passes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从策略角度来看，你需要循环遍历字典中的每个单词，并评估它在[图 2-3](ch02.xhtml#ch02fig3)中*所有可能的组合*。假设字典中有60,000个单词，那么程序大约需要进行500,000次遍历。
- en: To understand the loops, take a look at the core word for the palingram *stack
    cats* in [Figure 2-5](ch02.xhtml#ch02fig5). Your program needs to loop through
    the letters in the word, starting with an end letter and adding a letter with
    each iteration. To find palingrams like *stack cats*, it will simultaneously evaluate
    the word for the presence of a palindromic sequence at the end of the core word,
    *stack*, and a reversed word at the start. Note that the first loop in [Figure
    2-5](ch02.xhtml#ch02fig5) will be successful, as a single letter (*k*) can serve
    as a palindrome in this situation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这些循环，请查看[图 2-5](ch02.xhtml#ch02fig5)中的回文核心单词 *stack cats*。你的程序需要遍历单词中的字母，从末尾字母开始，每次迭代添加一个字母。为了找到像
    *stack cats* 这样的回文，它将同时评估单词末尾的回文序列 *stack* 和开头的反转单词。请注意，[图 2-5](ch02.xhtml#ch02fig5)中的第一个循环会成功，因为一个单字母
    (*k*) 就可以在这种情况下作为回文。
- en: '![image](../images/f0027-02.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0027-02.jpg)'
- en: '*Figure 2-5: Example loops through a core word, simultaneously looking for
    palindromes and reversed words*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：示例遍历核心单词，同时查找回文和反转单词*'
- en: But you’re not through yet. To capture the “mirror image” behavior in [Figure
    2-3](ch02.xhtml#ch02fig3), you have to run the loops in reverse, looking for palindromic
    sequences at the start of the word and reversed words at the end. This will allow
    you to find palingrams like *stir grits*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但你还没有完成。为了捕捉[图 2-3](ch02.xhtml#ch02fig3)中的“镜像”行为，你必须反向运行循环，查找单词开头的回文序列和单词末尾的反转单词。这将帮助你找到像
    *stir grits* 这样的回文。
- en: 'Here is the pseudocode for a palingram-finding algorithm:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是查找回文的伪代码：
- en: Load digital dictionary as a list of words
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 加载数字字典作为单词列表
- en: Start an empty list to hold palingrams
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个空列表以保存回文
- en: 'For word in word list:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单词列表中的每个单词：
- en: Get length of word
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 获取单词的长度
- en: 'If length > 1:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果长度 > 1：
- en: 'Loop through the letters in the word:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历单词中的字母：
- en: If reversed word fragment at front of word is in word list and letters
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果反转单词片段位于单词前部并且字母
- en: 'after form a palindromic sequence:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 形成回文序列后：
- en: Append word and reversed word to palingram list
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词和反转单词添加到回文列表
- en: If reversed word fragment at end of word is in word list and letters
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果反转单词片段位于单词末尾并且字母
- en: 'before form a palindromic sequence:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在形成回文序列之前：
- en: Append reversed word and word to palingram list
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将反转单词和单词添加到回文列表
- en: Sort palingram list alphabetically
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 按字母顺序排序回文列表
- en: Print word-pair palingrams from palingram list
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 打印回文列表中的单词对
- en: '***The Palingrams Code***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回文代码***'
- en: '[Listing 2-3](ch02.xhtml#ch02list3), *palingrams.py*, loops through a word
    list, identifies which words form word-pair palingrams, saves those pairs to a
    list, and prints the list as stacked items. You can download the code from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    I suggest you use the *2of4brif.txt* dictionary file to start so that your results
    will match mine. Store your dictionary and *load_dictionary.py* in the same folder
    as the palingrams script.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-3](ch02.xhtml#ch02list3)，*palingrams.py*，遍历单词列表，识别哪些单词形成单词对回文，将这些对保存到列表中，并将列表打印为堆叠项。你可以从
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载代码。我建议你先使用 *2of4brif.txt* 字典文件，这样你的结果将与我的匹配。将字典和 *load_dictionary.py* 存储在与回文脚本相同的文件夹中。'
- en: '*palingrams.py*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*palingrams.py*'
- en: '"""Find all word-pair palingrams in a dictionary file."""'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '"""查找字典文件中的所有单词对回文。"""'
- en: import load_dictionary
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: import load_dictionary
- en: word_list = load_dictionary.load('2of4brif.txt')
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: word_list = load_dictionary.load('2of4brif.txt')
- en: '# find word-pair palingrams'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查找单词对回文'
- en: '➊ def find_palingrams():'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def find_palingrams():'
- en: '"""Find dictionary palingrams."""'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '"""查找字典中的回文词。"""'
- en: pali_list = []
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: pali_list = []
- en: 'for word in word_list:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单词列表中的每个单词：
- en: ➋ end = len(word)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ end = len(word)
- en: ➌ rev_word = word[::-1]
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ rev_word = word[::-1]
- en: '➍ if end > 1:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ 如果 end > 1：
- en: '➎ for i in range(end):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 对于 i 在 range(end) 中：
- en: '➏ if word[i:] == rev_word[:end-i] and rev_word[end-i:] in word_list:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ 如果 word[i:] == rev_word[:end-i] 且 rev_word[end-i:] 在 word_list 中：
- en: pali_list.append((word, rev_word[end-i:]))
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: pali_list.append((word, rev_word[end-i:]))
- en: '➐ if word[:i] == rev_word[end-i:] and rev_word[:end-i] in word_list:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ 如果 word[:i] == rev_word[end-i:] 且 rev_word[:end-i] 在 word_list 中：
- en: pali_list.append((rev_word[:end-i], word))
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: pali_list.append((rev_word[:end-i], word))
- en: ➑ return pali_list
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ 返回 pali_list
- en: ➒ palingrams = find_palingrams()
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ palingrams = find_palingrams()
- en: '# sort palingrams on first word'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '# 按第一个单词排序回文'
- en: palingrams_sorted = sorted(palingrams)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: palingrams_sorted = sorted(palingrams)
- en: '# display list of palingrams'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '# 显示回文列表'
- en: ➓ print("\nNumber of palingrams = {}\n".format(len(palingrams_sorted)))
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ➓ print("\n回文数 = {}\n".format(len(palingrams_sorted)))
- en: 'for first, second in palingrams_sorted:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'for first, second in palingrams_sorted:'
- en: print("{} {}".format(first, second))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: print("{} {}".format(first, second))
- en: '*Listing 2-3: Finds and prints word-pair palingrams in loaded dictionary*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-3：查找并打印加载字典中的单词对回文*'
- en: After repeating the steps you used in the *palindromes.py* code to load a dictionary
    file, define a function to find palingrams ➊. Using a function will allow you
    to isolate the code later and time how long it takes to process all the words
    in the dictionary.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在重复使用*palindromes.py*代码加载字典文件的步骤后，定义一个函数来查找回文单词对 ➊。使用函数将允许你以后将代码隔离开来，并测量处理字典中所有单词所需的时间。
- en: Immediately start a list called pali_list to hold all the palingrams the program
    discovers. Next, start a for loop to evaluate the words in word_list. For each
    word, find its length and assign its length to the variable end ➋. The word’s
    length determines the indexes the program uses to slice through the word, looking
    for every possible reversed word-palindromic sequence combination, as in [Figure
    2-3](ch02.xhtml#ch02fig3).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 立即开始一个名为`pali_list`的列表，用于保存程序发现的所有回文单词对。接下来，启动一个`for`循环来评估`word_list`中的单词。对于每个单词，找到它的长度并将其赋值给变量`end`
    ➋。单词的长度决定了程序使用的切片索引，用于在单词中查找每个可能的反转单词回文序列组合，如[图2-3](ch02.xhtml#ch02fig3)所示。
- en: Next, negatively slice through the word and assign the results to the variable
    rev_word ➌. An alternative to word[::-1] is ''.join(reversed(word)), which some
    consider more readable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，反向切片单词并将结果赋给变量`rev_word` ➌。`word[::-1]`的替代方法是`''.join(reversed(word))`，有些人认为这种方法更具可读性。
- en: Since you are looking for word-pair palingrams, exclude single-letter words
    ➍. Then nest another for statement to loop through the letters in the current
    word ➎.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在寻找单词对回文，因此排除单个字母的单词 ➍。然后嵌套另一个`for`语句来遍历当前单词中的字母 ➎。
- en: Now, run a conditional requiring the back end of the word to be palindromic
    and the front end to be a reverse word in the word list (in other words, a “real”
    word) ➏. If a word passes the test, it is appended to the palingram list, immediately
    followed by the reversed word.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行一个条件判断，要求单词的后端是回文的，前端是字典中反转的单词（换句话说，是一个“真实”单词） ➏。如果一个单词通过了测试，它就会被添加到回文单词对列表中，紧接着是它的反转单词。
- en: Based on [Figure 2-3](ch02.xhtml#ch02fig3), you know you have to repeat the
    conditional, but change the slicing direction and word order to reverse the output.
    In other words, you must capture palindromic sequences at the start of the word
    rather than at the end ➐. Return the list of palingrams to complete the function
    ➑.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[图2-3](ch02.xhtml#ch02fig3)，你知道需要重复条件判断，但要改变切片方向和单词顺序，以反转输出。换句话说，你必须在单词的开始捕捉回文序列，而不是在末尾
    ➐。返回回文单词对列表，以完成函数 ➑。
- en: With the function defined, call it ➒. Since the order in which dictionary words
    are added to the palingram list switches during the loop, the palingrams won’t
    be in alphabetical order. So, sort the list so that the first words in the word
    pair are in alphabetical order. Print the length of the list ➓, then print each
    word-pair on a separate line.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 定义完函数后，调用它 ➒。由于字典单词在回文单词对列表中的添加顺序在循环中发生了变化，所以回文单词对不会按照字母顺序排列。因此，需要对列表进行排序，使得单词对中的第一个单词按字母顺序排列。打印列表的长度
    ➓，然后将每个单词对单独打印在一行上。
- en: As written, *palingrams.py* will take about three minutes to run on a dictionary
    file with about 60,000 words. In the next sections, we’ll investigate the cause
    of this long runtime and see what we can do to fix it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如文所述，*palingrams.py* 在包含约60,000个单词的字典文件上运行大约需要三分钟。在接下来的章节中，我们将调查导致这个长运行时间的原因，并看看我们可以做些什么来解决这个问题。
- en: '***Palingram Profiling***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回文单词对性能分析***'
- en: '*Profiling* is an analytical process that gathers statistics on a program’s
    behavior—for example, the number and duration of function calls—as the program
    executes. Profiling is a key part of the optimization process. It tells you exactly
    what parts of a program are taking the most time or memory. That way, you’ll know
    where to focus your efforts to improve performance.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*性能分析*是一个分析过程，通过它收集程序行为的统计数据——例如函数调用的数量和持续时间——在程序执行时进行。性能分析是优化过程的关键部分。它可以告诉你程序中哪些部分占用了最多的时间或内存。这样，你就能知道将精力集中在哪些地方以提高性能。'
- en: '**Profiling with cProfile**'
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用cProfile进行性能分析**'
- en: A *profile* is a measurement output—a record of how long and how often parts
    of a program are executed. The Python standard library provides a handy profiling
    interface, cProfile, which is a C extension suitable for profiling long-running
    programs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Something in the find_palingrams() function probably accounts for the relatively
    long runtime of the *palingrams.py* program. To confirm, let’s run cProfile.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Copy the following code into a new file named *cprofile_test.py* and save it
    in the same folder as *palingrams.py* and the dictionary file. This code imports
    cProfile and the palingrams program, and it runs cProfile on the find_palingrams()
    function—called with dot notation. Note again that you don’t need to specify the
    *.py* extension.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: import cProfile
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: import palingrams
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: cProfile.run('palingrams.find_palingrams()')
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *cprofile_test.py* and, after it finishes (you will see the >>> in the
    interpreter window), you should see something similar to the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 62622 function calls in 199.452 seconds
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordered by: standard name'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 1    0.000    0.000  199.451  199.451 <string>:1(<module>)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 1  199.433  199.433  199.451  199.451 palingrams.py:7(find_palingrams)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 1    0.000    0.000  199.452  199.452 {built-in method builtins.exec}
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 60388    0.018    0.000    0.018    0.000 {built-in method builtins.len}
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 2230    0.001    0.000    0.001    0.000 {method 'append' of 'list' objects}
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: All that looping, slicing, and searching took 199.452 seconds on my machine,
    but of course your times may differ from mine. You also get additional information
    on some of the built-in functions, and since each palingram called the built-in
    append() function, you can even see the number of palingrams found (2,230).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '*The most common way to run* cProfile *is directly in the interpreter. This
    lets you dump your output to a text file and view it with a web viewer. For more
    information, visit* [https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**Profiling with time**'
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another way to time the program is to use time.time(), which returns an *epoch
    timestamp*—the number of seconds since 12 AM on January 1, 1970 UTC (the *Unix
    epoch*). Copy *palingrams.py* to a new file, save it as *palingrams_timed.py*,
    and insert the following code at the very top:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: import time
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: start_time = time.time()
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go to the end of the file and add the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: end_time = time.time()
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: print("Runtime for this program was {} seconds.".format(end_time - start_time))
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Save and run the file. You should get the following feedback at the bottom
    of the interpreter window—give or take a few seconds:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Runtime for this program was 222.73954558372498 seconds.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The runtime is longer than before, as you are now evaluating the whole program,
    including printing, rather than just the find_palingrams() function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Unlike cProfile, time doesn’t provide detailed statistics, but like cProfile,
    it can be run on individual code components. Edit the file you just ran, moving
    the start and end time statements (as shown below in bold) so they bracket our
    long-running find_palingrams() function. Leave the import and print statements
    unchanged at the top and bottom of the file, respectively.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与cProfile不同，time模块没有提供详细的统计信息，但像cProfile一样，它可以在单独的代码组件上运行。编辑你刚刚运行的文件，将开始时间和结束时间语句（如下所示，以粗体标出）移动，使它们包围我们的长时间运行的`find_palingrams()`函数。保持文件顶部和底部的导入和打印语句不变。
- en: start_time = time.time()
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: start_time = time.time()
- en: palingrams = find_palingrams()
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: palingrams = find_palingrams()
- en: end_time = time.time()
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: end_time = time.time()
- en: 'Save and run the file. You should get the following feedback at the bottom
    of the interpreter window:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行文件。你应该在解释器窗口底部看到以下反馈：
- en: Runtime for this program was 199.42786622047424 seconds.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序的运行时间为199.42786622047424秒。
- en: This now matches the initial results using cProfile. You won’t get the exact
    same time if you rerun the program or use a different timer, but don’t get hung
    up on it. It’s the *relative* times that are important for guiding code optimization.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这与使用cProfile时的初始结果一致。如果你重新运行程序或使用不同的计时器，你不会得到完全相同的时间，但不要太在意。重要的是*相对*时间，这有助于指导代码优化。
- en: '***Palingram Optimization***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回文优化***'
- en: I’m sorry, but three minutes of my life is too long to wait for palingrams.
    Armed with our profiling results, we know that the find_palingrams() function
    accounts for most of the processing time. This probably has something to do with
    reading and writing to lists, slicing over lists, or searching in lists. Using
    an alternative data structure to lists—like tuples, sets, or dictionaries—might
    speed up the function. Sets, in particular, are significantly faster than lists
    when using the in keyword. Sets use a hashtable for very fast lookups. With hashing,
    strings of text are converted to unique numbers that are much smaller than the
    referenced text and much more efficient to search. With a list, on the other hand,
    you have to do a linear search through each item.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对不起，但三分钟对我来说太长了，等不及等回文串的生成了。通过我们的性能分析结果，我们知道`find_palingrams()`函数占用了大部分处理时间。这可能与读取和写入列表、切片操作或在列表中查找有关。使用替代的数据结构，如元组、集合或字典，可能会加速该函数的执行。特别是集合，当使用`in`关键字时，集合的查找速度比列表快得多。集合使用哈希表进行非常快速的查找。通过哈希，文本字符串会被转换为独特的数字，这些数字比引用的文本小得多，并且搜索效率更高。相比之下，使用列表时，必须对每个项目进行线性搜索。
- en: 'Think of it this way: if you’re searching your house for your lost cell phone,
    you could emulate a list by looking through every room before finding it (in the
    proverbial last place you look). But by emulating a set, you can basically dial
    your cell number from another phone, listen for the ringtone, and go straight
    to the proper room.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这样想：如果你在家里找丢失的手机，你可以通过查看每个房间来模拟列表查找，直到找到手机（通常是你最后检查的地方）。但通过模拟集合，你可以基本上用另一部手机拨打你的手机号码，听铃声，然后直接找到正确的房间。
- en: A downside to using sets is that the order of the items in the set isn’t controllable
    and duplicate values aren’t allowed. With lists, the order is preserved and duplicates
    are allowed, but lookups take longer. Fortunately for us, we don’t care about
    order or duplicates, so sets are the way to go!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合的一个缺点是，集合中项的顺序不可控，并且不允许重复值。而列表则保留顺序并允许重复，但查找时间较长。幸运的是，我们不关心顺序或重复项，因此集合是最佳选择！
- en: '[Listing 2-4](ch02.xhtml#ch02list4) is the find_palingrams() function from
    the original *palingrams.py* program, edited to use a set of words rather than
    a list of words. You can find it in a new program named *palingrams_optimized.py*,
    which you can download from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*,
    or just make these changes to your copy of *palingrams_timed.py* if you want to
    check the new runtime yourself.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单2-4](ch02.xhtml#ch02list4)是从原始的*palingrams.py*程序中提取的`find_palingrams()`函数，已修改为使用单词集合而不是单词列表。你可以在一个名为*palingrams_optimized.py*的新程序中找到它，你可以从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载，或者如果你想亲自检查新的运行时间，也可以对你自己的*palingrams_timed.py*副本做出这些更改。'
- en: '*palingrams_optimized.py*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*palingrams_optimized.py*'
- en: 'def find_palingrams():'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'def find_palingrams():'
- en: '"""Find dictionary palingrams."""'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '"""查找字典中的回文串。"""'
- en: pali_list = []
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: pali_list = []
- en: ➊ words = set(word_list)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ words = set(word_list)
- en: '➋ for word in words:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ for word in words:'
- en: end = len(word)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: end = len(word)
- en: rev_word = word[::-1]
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: rev_word = word[::-1]
- en: 'if end > 1:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'if end > 1:'
- en: 'for i in range(end):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(end):'
- en: '➌ if word[i:] == rev_word[:end-i] and rev_word[end-i:] in words:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: pali_list.append((word, rev_word[end-i:]))
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '➍ if word[:i] == rev_word[end-i:] and rev_word[:end-i] in words:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: pali_list.append((rev_word[:end-i], word))
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: return pali_list
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2-4: The* find_palingrams() *function optimized with sets*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Only four lines change. Define a new variable, words, which is a set of word_list
    ➊. Then loop through the set ➋, looking for membership of word slices in this
    set ➌➍, rather than in a list as before.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the new runtime for the find_palingrams() function in *palingrams_optimized.py*:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Runtime for this program was 0.4858267307281494 seconds.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Wow! From over three minutes to under a second! *That’s* optimization! And the
    difference is in the data structure. Verifying the membership of a word in a *list*
    was the thing that was killing us.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Why did I first show you the “incorrect” way to do this? Because that’s how
    things happen in the real world. You get the code to work, and then you optimize
    it. This is a simple example that an experienced programmer would have gotten
    right from the start, but it is emblematic of the overall concept of optimization:
    get it to work as best as you can, then make it better.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**dnE ehT**'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve written code to find palindromes and palingrams, profiled code using
    cProfile, and optimized code by using the appropriate data structure for the task.
    So how did we do with respect to Zatanna? Does she have a fighting chance?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Here I’ve listed some of the more “aggressive” palingrams found in the *2of4brif*
    dictionary file—everything from the unexpected *sameness enemas* to the harsh
    *torsos rot* to my personal favorite as a geologist: *eroded ore*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '| dump mud | drowsy sword | sameness enemas |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| legs gel | denims mined | lepers repel |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| sleet eels | dairy raid | slam mammals |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| eroded ore | rise sir | pots nonstop |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| strafe farts | torsos rot | swan gnaws |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| wolfs flow | partner entrap | nuts stun |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| slaps pals | flack calf | knobs bonk |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '**Further Reading**'
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Think Python, 2nd Edition* (O’Reilly, 2015) by Allen Downey has a short and
    lucid description of hashtables and why they are so efficient. It’s also an excellent
    Python reference book.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Dictionary Cleanup**'
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data files available on the internet are not always “plug and play.” You may
    find you need to massage the data a bit before applying it to your project. As
    mentioned earlier, some online dictionary files include each letter of the alphabet
    as a word. These will cause problems if you want to permit the use of one-letter
    words in palingrams like *acidic a*. You could always remove them by directly
    editing the dictionary text file, but this is tedious and for losers. Instead,
    write a short script that removes these after the dictionary has been loaded into
    Python. To test that it works, edit your dictionary file to include a few one-letter
    words like *b* and *c*. For a solution, see the appendix, or find a copy (*dictionary_cleanup_practice.py*)
    online at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上的数据文件并不总是“即插即用”。你可能会发现，在将其应用到你的项目之前，需要对数据进行一些处理。如前所述，一些在线词典文件将字母表中的每个字母都作为一个单词。这会在你希望允许在回文词中使用单个字母的情况下（例如*acidic
    a*）引发问题。你可以通过直接编辑词典文本文件来删除这些单字母单词，但这既繁琐又适合失败者。相反，可以编写一个短小的脚本，在将词典加载到Python后删除这些单字母单词。为了测试它是否有效，编辑你的词典文件，添加一些像*b*和*c*这样的单字母单词。解决方案请参见附录，或者在*
    [https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*网站上找到一个副本（*dictionary_cleanup_practice.py*）。
- en: '**Challenge Project: Recursive Approach**'
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：递归方法**'
- en: With Python, there is usually more than one way to skin a cat. Take a look at
    the discussion and pseudocode at the Khan Academy website (*[https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/using-recursion-to-determine-whether-a-word-is-a-palindrome/](https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/using-recursion-to-determine-whether-a-word-is-a-palindrome/)*).
    Then rewrite the *palindrome.py* program so that it uses recursion to identify
    palindromes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python，通常有不止一种方法来解决问题。请查看可汗学院网站上的讨论和伪代码（* [https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/using-recursion-to-determine-whether-a-word-is-a-palindrome/](https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/using-recursion-to-determine-whether-a-word-is-a-palindrome/)*）。然后重写*palindrome.py*程序，使其使用递归来识别回文。
