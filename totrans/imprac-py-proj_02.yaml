- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: FINDING PALINGRAM SPELLS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 查找回文短语**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Radar. Kayak. Rotator. Sexes. What do these words all have in common? They’re
    *palindromes*, words that are spelled the same forward and backward. Even better
    are *palingrams*, whole phrases that behave the same way. Napoleon is the author
    of the most famous palingram. When he first saw Elba, the island of his exile,
    he said, “Able was I ere I saw Elba.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 雷达、皮划艇、回转器、性别。这些词有什么共同点？它们是*回文*，即正着读和反着读一样的词。更棒的是*回文短语*，即整个短语也具有相同的特性。拿破仑就是最著名回文短语的作者。当他第一次看到厄尔巴岛时，作为流放地，他说：“Able
    was I ere I saw Elba。”
- en: 'In 2011, DC Comics published an interesting story that made clever use of palingrams.
    The superhero sorceress Zatanna was cursed so that she could cast spells only
    by speaking palindromically. She managed to think up just enough two-word phrases
    like *nurses run*, *stack cats*, and *puff up* to defeat her sword-wielding attacker.
    This got me wondering: just how many “combative” palingrams are there? And are
    there better choices for Zatanna?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，DC Comics出版了一个有趣的故事，巧妙地利用了回文短语。超级英雄女巫扎塔娜被下了诅咒，只有通过回文方式才能施展魔法。她想出了一些足够用的两字短语，比如*nurses
    run*、*stack cats*和*puff up*，成功击败了持剑的攻击者。这让我想知道：到底有多少“具有攻击性”的回文短语？是否有更好的选择适合扎塔娜？
- en: In this chapter, you’ll load dictionary files from the internet and use Python
    to discover first palindromes and then the more complex palingrams in those files.
    Then you’ll use a tool called `cProfile` to analyze your palingram code so that
    you can make it more performant. Finally, you’ll sift through the palingrams to
    see how many have an “aggressive” nature.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将从互联网上加载词典文件，并使用Python首先发现回文，然后在这些文件中发现更复杂的回文短语。接着，你将使用一个名为`cProfile`的工具分析回文短语代码，从而使其更加高效。最后，你将筛选回文短语，看看有多少个具有“攻击性”特征。
- en: '**Finding and Opening a Dictionary**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查找和打开词典**'
- en: All the projects in this chapter require a listing of words in a text file format,
    commonly referred to as a *dictionary file*, so let’s start by learning how to
    load one.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有项目都需要一个以文本文件格式列出的单词表，通常称为*词典文件*，所以我们从学习如何加载一个词典文件开始。
- en: Despite their name, dictionary files contain only words—no pronunciation, syllable
    count, definitions, and so on. This is good news, as those things would just get
    in our way. And even better, dictionary files are available online for free.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名为“词典文件”，这些文件仅包含单词——没有发音、音节数量、定义等信息。这是个好消息，因为这些内容反而会妨碍我们。更棒的是，词典文件可以在线免费获取。
- en: You can find suitable dictionary files at the locations listed in [Table 2-1](ch02.xhtml#ch02tab1).
    Download one of the files or, if it opens directly, copy and paste the contents
    into a text editor like Notepad or WordPad (TextEdit on macOS) and save it as
    a *.txt* file. Keep the dictionary in the same folder as the Python code. I used
    the *2of4brif.txt* file to prepare this project. It can be found in the downloadable
    *12dicts-6.0.2.zip* file on the website listed first in [Table 2-1](ch02.xhtml#ch02tab1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[表2-1](ch02.xhtml#ch02tab1)中列出的地址找到合适的词典文件。下载其中一个文件，或者如果文件直接打开，复制并粘贴内容到文本编辑器（如记事本或WordPad，macOS上的TextEdit）中，并将其保存为*.txt*文件。将词典文件与Python代码保存在同一文件夹中。我使用了*2of4brif.txt*文件来准备这个项目。它可以在[表2-1](ch02.xhtml#ch02tab1)中列出的第一个网站上下载的*12dicts-6.0.2.zip*文件中找到。
- en: '**Table 2-1:** Downloadable Dictionary Files'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 可下载的词典文件'
- en: '| **File** | **Number of words** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **文件** | **单词数量** |'
- en: '| --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *[http://wordlist.aspell.net/12dicts/](http://wordlist.aspell.net/12dicts/)*
    | 60,388 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| *[http://wordlist.aspell.net/12dicts/](http://wordlist.aspell.net/12dicts/)*
    | 60,388 |'
- en: '| *[https://inventwithpython.com/dictionary.txt](https://inventwithpython.com/dictionary.txt)*
    | 45,000 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| *[https://inventwithpython.com/dictionary.txt](https://inventwithpython.com/dictionary.txt)*
    | 45,000 |'
- en: '| *[http://www-personal.umich.edu/~jlawler/wordlist.html](http://www-personal.umich.edu/~jlawler/wordlist.html)*
    | 69,903 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| *[http://www-personal.umich.edu/~jlawler/wordlist.html](http://www-personal.umich.edu/~jlawler/wordlist.html)*
    | 69,903 |'
- en: '| *[http://greenteapress.com/thinkpython2/code/words.txt](http://greenteapress.com/thinkpython2/code/words.txt)*
    | 113,809 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| *[http://greenteapress.com/thinkpython2/code/words.txt](http://greenteapress.com/thinkpython2/code/words.txt)*
    | 113,809 |'
- en: In addition to the files in [Table 2-1](ch02.xhtml#ch02tab1), Unix and Unix-like
    operating systems come packaged with a large newline-delimited word file of more
    than 200,000 words. It is usually stored in */usr/share/dict/words* or */usr/dict/words*.
    On Debian GNU/Linux, word lists are in */usr/share/opendict/dictionaries*. The
    macOS dictionaries are generally found in */Library/Dictionaries*, and non-English
    dictionaries are included. You may need to do an online search for your operating
    system and version to find the exact directory path if you want to use one of
    these files.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[表 2-1](ch02.xhtml#ch02tab1)中的文件外，Unix及类Unix操作系统通常还会附带一个以换行符分隔的包含超过20万个单词的大型字典文件。该文件通常存储在*/usr/share/dict/words*或*/usr/dict/words*中。在Debian
    GNU/Linux中，单词列表位于*/usr/share/opendict/dictionaries*。macOS字典通常位于*/Library/Dictionaries*，并且包含非英语字典。如果你想使用这些文件，你可能需要在线搜索你的操作系统和版本，找到确切的目录路径。
- en: Some dictionary files exclude *a* and *I* as words. Others may include every
    letter in the dictionary as a single word “header” (such as *d* at the start of
    words beginning with *d*). We’ll ignore one-letter palindromes in these projects,
    so these issues shouldn’t be a problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字典文件会排除*a*和*I*作为单词。其他字典可能将每个字母作为一个单独的“头词”包括在字典中（例如以*d*开头的单词会以*d*作为头词）。在这些项目中，我们将忽略一字母回文，因此这些问题不应成为困扰。
- en: '***Handling Exceptions When Opening Files***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理打开文件时的异常***'
- en: Whenever you load an external file, your program should automatically check
    for I/O issues, like missing files or incorrect filenames, and let you know if
    there is a problem.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你加载外部文件时，你的程序应该自动检查输入/输出问题，比如缺失文件或文件名错误，并在出现问题时通知你。
- en: 'Use the following `try` and `except` statements to catch and handle *exceptions*,
    which are errors detected during execution:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下`try`和`except`语句来捕获和处理在执行过程中检测到的*异常*：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `try` clause is executed first ➊. The `with` statement will automatically
    close the file after the nested block of code, regardless of how the block exits
    ➋. Closing files prior to terminating a process is a good practice. If you don’t
    close those files, you could run out of file descriptors (mainly a problem with
    large scripts that run for a long time), lock the file from further access in
    Windows, corrupt the files, or lose data if you are writing to the file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`语句首先执行 ➊。`with`语句会在嵌套代码块执行完毕后自动关闭文件，不管该块是如何退出的 ➋。在结束进程前关闭文件是一种良好的实践。如果不关闭文件，可能会用完文件描述符（这通常是长时间运行的大脚本的问题）、在Windows中锁定文件使其无法进一步访问、损坏文件，或者在写入文件时丢失数据。'
- en: If something goes wrong and if the type of error matches the exception named
    after the `except` keyword ➌, the rest of the `try` clause is skipped, and the
    `except` clause is executed ➍. If nothing goes wrong, the `try` clause is executed,
    and the `except` clause is skipped. The `print` statement in the `except` clause
    lets you know there’s a problem, and the `file=sys.stderr` argument colors the
    error statement red in the IDLE interpreter window.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，且错误类型与`except`关键字后面指定的异常类型匹配 ➌，则跳过剩余的`try`语句，执行`except`语句 ➍。如果没有出现问题，则执行`try`语句并跳过`except`语句。`except`语句中的`print`语句会让你知道出现了问题，而`file=sys.stderr`参数会在IDLE解释器窗口中将错误信息显示为红色。
- en: The `sys.exit(1)` ➎ statement is used to terminate the program. The `1` in `sys.exit(1)`
    indicates that the program experienced an error and did not close successfully.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.exit(1)` ➎语句用于终止程序。`sys.exit(1)`中的`1`表示程序遇到错误并未成功关闭。'
- en: If an exception occurs that *doesn’t* match the named exception in the `except`
    clause, it is passed to any outer `try` statements or the main program execution.
    If no handler is found, the *unhandled exception* causes the program to stop with
    a standard “traceback” error message.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生一个*未命名的异常*，并且它不匹配`except`语句中的命名异常，它会被传递给任何外部的`try`语句或主程序执行。如果没有找到处理程序，*未处理的异常*将导致程序停止并显示标准的“回溯”错误信息。
- en: '***Loading the Dictionary File***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加载字典文件***'
- en: '[Listing 2-1](ch02.xhtml#ch02list1) loads a dictionary file as a list. Manually
    enter this script or download it as *load_dictionary.py* from *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-1](ch02.xhtml#ch02list1)将字典文件作为列表加载。你可以手动输入这个脚本，或者从*[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*下载它作为*load_dictionary.py*。'
- en: You can import this file into other programs as a module and run it with a one-line
    statement. Remember, a module is simply a Python program that can be used in another
    Python program. As you’re probably aware, modules represent a form of *abstraction*.
    Abstraction means you don’t have to worry about all the coding details. A principle
    of abstraction is *encapsulation*, the act of hiding the details. We encapsulate
    the file-loading code in a module so you don’t have to see or worry about the
    detailed code in another program.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个文件作为模块导入到其他程序中，并通过一行语句运行它。记住，模块只是一个可以在另一个 Python 程序中使用的 Python 程序。正如你可能已经知道的，模块代表了一种*抽象*。抽象意味着你不必担心所有的编码细节。抽象的一个原则是*封装*，即隐藏细节。我们将文件加载代码封装在一个模块中，这样你就不需要看到或担心其他程序中的详细代码。
- en: '*load_dictionary.py*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*load_dictionary.py*'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 2-1: The module for loading a dictionary file as a list*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-1：将字典文件加载为列表的模块*'
- en: After the docstring, we import system functions with `sys` so that our error-handling
    code will work ➊. The next block of code defines a function based on the previous
    file-opening discussion ➋. The function takes a filename as an argument.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档字符串之后，我们导入了系统函数`sys`，以便我们的错误处理代码可以正常工作 ➊。接下来的代码块定义了一个基于之前文件打开讨论的函数 ➋。该函数以文件名作为参数。
- en: If no exceptions are raised, the text file’s whitespace is removed, and its
    items are split into separate lines and added to a list ➌. We want each word to
    be a separate item in the list, before the list is returned. And since case matters
    to Python, the words in the list are converted to lowercase via *list comprehension*
    ➍. List comprehension is a shorthand way to convert a list, or other iterable,
    into another list. In this case, it replaces a `for` loop.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有抛出异常，文本文件的空白字符会被去除，其内容将被拆分成单独的行并添加到列表中 ➌。我们希望每个单词在返回之前都成为列表中的一个独立项。而且由于大小写对
    Python 具有重要意义，列表中的单词会通过*列表推导式* ➍转换为小写。列表推导式是一种简写方式，用于将列表或其他可迭代对象转换为另一个列表。在这种情况下，它替代了`for`循环。
- en: If an I/O error is encountered, the program displays the standard error message,
    designated by the `e`, along with a message describing the event and informing
    the user that the program is ending ➎. The `sys.exit(1)` command then terminates
    the program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到 I/O 错误，程序会显示标准的错误信息，由`e`表示，并附带描述事件的消息，告知用户程序即将结束 ➎。然后，`sys.exit(1)`命令终止程序。
- en: This code example is for illustrative purposes, to show how these steps work
    together. Generally, you wouldn’t call `sys.exit()` from a module, as you may
    want your program to do something—like write a log file—prior to terminating.
    In later chapters, we’ll move both the `try`-`except` blocks and `sys.exit()`
    into a `main()` function for clarity and control.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例是为了说明这些步骤如何一起工作。通常情况下，你不会在模块中调用`sys.exit()`，因为你可能希望你的程序在终止之前做一些事情——比如写入日志文件。在后面的章节中，我们会将`try`-`except`块和`sys.exit()`都移到`main()`函数中，以便更清晰地控制。
- en: '**Project #2: Finding Palindromes**'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #2：寻找回文**'
- en: You’ll start by finding single-word palindromes in a dictionary and then move
    on to the more difficult palindromic phrases.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从在字典中找到单个单词的回文开始，然后转向更困难的回文短语。
- en: '**THE OBJECTIVE**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use Python to search an English language dictionary file for palindromes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 在英文词典文件中搜索回文。
- en: '***The Strategy and Pseudocode***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: 'Before you get into the code, step back and think about what you want to do
    conceptually. Identifying palindromes is easy: simply compare a word to itself
    sliced backward. Here is an example of slicing a word front to back and then back
    to front:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进入代码之前，先退后一步，思考一下你想要做的事情。从概念上讲，识别回文是很简单的：只需将一个单词与其反向切片后的结果进行比较。以下是一个将单词从前到后切片然后再从后到前切片的例子：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you don’t provide values when slicing a string (or any sliceable type), the
    default is to use the start of the string, the end of the string, and a positive
    step equal to `1`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在切片字符串（或任何可切片类型）时不提供值，默认会使用字符串的起始位置、结束位置和步长为`1`。
- en: '[Figure 2-1](ch02.xhtml#ch02fig1) illustrates the reverse slicing process.
    I’ve provided a starting position of `2` and a step of `–1`. Because no end index
    is provided (there is no index or space between the colons), the implication is
    to go backward (because the index step is `–1`) until there are no more characters
    left.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](ch02.xhtml#ch02fig1)展示了反向切片过程。我提供了起始位置为`2`，步长为`-1`。由于没有提供结束索引（冒号之间没有索引或空格），意味着要反向切片（因为索引步长是`-1`），直到没有更多字符可用。'
- en: '![image](../images/f0023-01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0023-01.jpg)'
- en: '*Figure 2-1: An example of negative slicing for* word = ''NURSES'''
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：负切片的示例，针对* word = ''NURSES'''
- en: Negative slicing doesn’t behave exactly the same way as forward slicing, and
    the positive and negative position values and endpoints are asymmetrical. This
    can lead to confusion, so let’s restrict our negative slicing to the simple `[::-1]`
    format.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 负切片的行为与正切片不完全相同，正负位置值和端点是不对称的。这可能会导致混淆，因此让我们将负切片限制为简单的 `[::-1]` 格式。
- en: 'Finding palindromes in the dictionary will take fewer lines of code than loading
    the dictionary file! Here’s the pseudocode:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在词典中查找回文所需的代码行数比加载词典文件还少！这是伪代码：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***The Palindrome Code***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回文代码***'
- en: '[Listing 2-2](ch02.xhtml#ch02list2), *palindromes.py*, reads in an English
    dictionary file, identifies which words are palindromes, saves them to a list,
    and prints the list as stacked items. You can download this code from the book’s
    resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    You will also need *load_dictionary.py* and a dictionary file; save all three
    files in the same folder.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-2](ch02.xhtml#ch02list2)，*palindromes.py*，读取英文词典文件，识别哪些单词是回文，将它们保存到列表中，并将列表以堆叠的形式打印出来。你可以从本书的资源页面下载此代码，网址为
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。你还需要
    *load_dictionary.py* 和一个词典文件；将所有三个文件保存在同一文件夹中。'
- en: '*palindromes.py*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*palindromes.py*'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 2-2: Finds palindromes in loaded dictionary file*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-2：查找加载的词典文件中的回文*'
- en: Start by importing *load_dictionary.py* as a module ➊. Note that the *.py* extension
    is not used for importing. Also, the module is in the same folder as this script,
    so we don’t have to specify a directory path to the module. And since the module
    contains the required `import sys` line, we don’t need to repeat it here.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过将 *load_dictionary.py* 作为模块导入 ➊。注意，导入时不使用 *.py* 扩展名。此外，由于该模块与此脚本在同一文件夹中，因此我们无需指定模块的目录路径。并且由于模块已经包含了所需的
    `import sys` 语句，我们不需要在此重复它。
- en: To populate our word list with words from the dictionary, call the `load()`
    function in the `load_dictionary` module with dot notation ➋. Pass it the name
    of the external dictionary file. Again, you don’t need to specify a path if the
    dictionary file is in the same folder as the Python script. The filename you use
    may be different depending on the dictionary you downloaded.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用词典中的单词填充我们的单词列表，可以通过点符号 ➋ 调用 `load()` 函数，来自 `load_dictionary` 模块。将外部词典文件的名称传递给它。如果词典文件与
    Python 脚本在同一文件夹中，则不需要指定路径。你使用的文件名可能会根据你下载的词典有所不同。
- en: Next, create an empty list to hold the palindromes ➌ and start looping through
    every word in `word_list` ➍, comparing the forward slice to the reverse slice.
    If the two slices are identical, append the word to `pali_list`. Notice that only
    words with more than one letter are allowed (`len(word) > 1`), which follows the
    strictest definition of a palindrome.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个空列表来保存回文 ➌，并开始循环遍历 `word_list` 中的每个单词 ➍，将正向切片与反向切片进行比较。如果这两个切片相同，则将该单词添加到
    `pali_list`。注意，只有长度大于一的单词才被允许（`len(word) > 1`），这符合回文的最严格定义。
- en: Finally, print the palindromes in an attractive way—stacked and with no quotation
    marks or commas ➎. You can accomplish this by looping through every word in the
    list, but there is a more efficient way to do it. You can use the *splat* operator
    (designated by the `*`), which takes a list as input and expands it into positional
    arguments in the function call. The last argument is the separator used between
    multiple list values for printing. The default separator is a space (`sep=' '`),
    but instead, print each item on a new line (`sep='\n'`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以一种美观的方式打印回文——堆叠显示且没有引号或逗号 ➎。你可以通过循环遍历列表中的每个单词来完成这项工作，但有一种更高效的方式。你可以使用 *拆包*
    操作符（由 `*` 表示），它将列表作为输入，并将其扩展为函数调用中的位置参数。最后一个参数是多个列表值之间的分隔符。默认分隔符是空格（`sep=' '`），但你可以改为将每个项目打印在新的一行上（`sep='\n'`）。
- en: Single-word palindromes are rare, at least in English. Using a 60,000-word dictionary
    file, you’ll be lucky to find about 60, or only 0.1 percent of all the words.
    Despite their rarity, however, they’re easy enough to find with Python. So, let’s
    move on to the more interesting, and more complicated, palingrams.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 单词回文很少，至少在英语中是这样的。使用一个包含 60,000 个单词的词典文件，你最多可能会找到约 60 个回文单词，约占所有单词的 0.1%。尽管它们很稀少，但使用
    Python 查找它们还是很容易的。那么，让我们继续更有趣、更复杂的回文组合。
- en: '**Project #3: Finding Palingrams**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #3：寻找回文组合**'
- en: Finding palingrams requires a bit more effort than finding one-word palindromes.
    In this section, we’ll plan and write code to find word-pair palingrams.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 查找回文词对比查找单词回文需要更多的努力。在本节中，我们将规划并编写代码来查找词对回文。
- en: '**THE OBJECTIVE**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use Python to search an English language dictionary for two-word palingrams.
    Analyze and optimize the palingram code using the cProfile tool.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 搜索英语词典中的双词回文。使用 cProfile 工具分析和优化回文代码。
- en: '***The Strategy and Pseudocode***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: Example word-pair palingrams are *nurses run* and *stir grits*. (In case you’re
    wondering, grits are a ground-corn breakfast dish, similar to Italian polenta.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例子词对回文有*nurses run*和*stir grits*。（如果你在想，grits 是一种玉米早餐食品，类似于意大利的玉米粥。）
- en: Like palindromes, palingrams read the same forward and backward. I like to think
    of these as a *core* word, like *nurses*, from which a *palindromic sequence*
    and *reversed word* are derived (see [Figure 2-2](ch02.xhtml#ch02fig2)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 像回文一样，回文词对正反读都相同。我喜欢把这些看作是一个*核心*词，比如*nurses*，从中衍生出一个*回文序列*和*反向单词*（见[图 2-2](ch02.xhtml#ch02fig2)）。
- en: '![image](../images/f0025-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0025-01.jpg)'
- en: '*Figure 2-2: Dissecting word-pair palingrams*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：解析词对回文图*'
- en: 'Our program will examine the core word. Based on [Figure 2-2](ch02.xhtml#ch02fig2),
    we can make the following inferences about the core word:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将分析核心词。基于[图 2-2](ch02.xhtml#ch02fig2)，我们可以对核心词做出以下推断：
- en: It can have either an odd or even number of letters.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可以是奇数或偶数个字母。
- en: One contiguous part of the word spells a real word when read backward.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单词的一个连续部分在反向读取时拼写出一个实际单词。
- en: This contiguous part can occupy part or all of the core word.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个连续部分可以占据核心词的一部分或全部。
- en: The other contiguous part contains a palindromic sequence of letters.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个连续部分包含一个回文序列的字母。
- en: The palindromic sequence can occupy part or all of the core word.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回文序列可以占据核心词的一部分或全部。
- en: The palindromic sequence does not have to be a real word (unless it occupies
    the *whole* word).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回文序列不必是实际的单词（除非它占据了*整个*单词）。
- en: The two parts cannot overlap or share letters.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两部分不能重叠或共享字母。
- en: The sequence is reversible.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该序列是可逆的。
- en: '**NOTE**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If the reversed word occupies the whole core word and is not a palindrome,
    it’s called a* semordnilap*. A semordnilap is similar to a palindrome except for
    one key difference: rather than spelling the* same *word when read backward, it
    spells a* different *word. Examples are* bats *and* stab*, and* wolf *and* flow*.
    Semordnilap, by the way, is* palindromes *spelled backward.*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果反向单词占据了整个核心词并且不是回文，它被称为*反向回文（semordnilap）*。反向回文与回文相似，除了一个关键的区别：它不是在反向读取时拼写出*相同*的单词，而是拼写出*不同*的单词。例子有*bats*和*stab*，还有*wolf*和*flow*。顺便说一下，semordnilap
    就是回文反过来的拼写。*'
- en: '[Figure 2-3](ch02.xhtml#ch02fig3) represents an arbitrary word of six letters.
    The Xs represent the part of the word that *might* form a real word when read
    backward (like *run* in *nurses*). The Os represent the *possible* palindromic
    sequence (like *ses* in *nurses*). The word represented in the left column in
    [Figure 2-3](ch02.xhtml#ch02fig3) behaves like *nurses* in [Figure 2-2](ch02.xhtml#ch02fig2),
    with the reversed word at the start. The word represented by the right column
    behaves like *grits*, with the reversed word at the end. Note that the number
    of combinations in each column is the total number of letters in the word plus
    one; note too that the top and bottom rows represent an identical circumstance.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](ch02.xhtml#ch02fig3)表示一个任意的六个字母的单词。Xs代表当单词反向阅读时，*可能*形成实际单词的部分（例如*run*在*nurses*中）。Os代表*可能的*回文序列（例如*nurses*中的*ses*）。[图
    2-3](ch02.xhtml#ch02fig3)左栏中表示的单词像[图 2-2](ch02.xhtml#ch02fig2)中的*nurses*一样，反向单词位于开头。右栏中的单词像*grits*一样，反向单词位于结尾。请注意，每一列的组合数是单词中字母的总数加一；还要注意，上下行表示的是相同的情况。'
- en: The top row in each column represents a semordnilap. The bottom row in each
    represents a palindrome. These are both reversed words, just different *types*
    of reversed words. Hence, they count as one entity and both can be identified
    with a single line of code in a single loop.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每列的顶部行表示一个反向词（semordnilap）。每列的底部行表示一个回文。它们都是反向单词，只是*类型*不同的反向单词。因此，它们被视为同一个实体，并且可以通过单行代码在单个循环中识别。
- en: '![image](../images/f0026-01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0026-01.jpg)'
- en: '*Figure 2-3: Possible positions for letters of the reversed word (X) and the
    palindromic sequence (O) in a six-letter core word*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：六个字母核心单词中反向单词（X）和回文序列（O）的可能位置*'
- en: To see the diagram in action, consider [Figure 2-4](ch02.xhtml#ch02fig4), which
    shows the palingrams *devils lived* and *retro porter*. *Devils* and *porter*
    are both core words and mirror images of each other with respect to palindromic
    sequences and reversed words. Compare this to the semordnilap *evil* and the palindrome
    *kayak*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看图示的实际操作，考虑 [图 2-4](ch02.xhtml#ch02fig4)，其中展示了 palingrams *devils lived* 和
    *retro porter*。*Devils* 和 *porter* 是两个核心单词，并且在回文序列和反向单词方面相互镜像。将其与倒序词 *evil* 和回文
    *kayak* 进行比较。
- en: '![image](../images/f0027-01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0027-01.jpg)'
- en: '*Figure 2-4: Reversed words (Xs) and palindromic sequences (Os) in words, semordnilaps,
    and palindromes.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：单词中的反向单词（X）和回文序列（O），倒序词和回文。*'
- en: Palindromes are both reversed words *and* palindromic sequences. Since they
    have the same pattern of Xs as in semordnilaps, they can be handled with the same
    code used for semordnilaps.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 回文既是反向单词 *也是* 回文序列。由于它们具有与倒序词相同的 X 模式，因此可以使用与倒序词相同的代码进行处理。
- en: From a strategy perspective, you’ll need to loop through each word in the dictionary
    and evaluate it for *all of the combinations* in [Figure 2-3](ch02.xhtml#ch02fig3).
    Assuming a 60,000-word dictionary, the program will need to take about 500,000
    passes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从策略角度来看，你需要遍历字典中的每个单词，并根据 [图 2-3](ch02.xhtml#ch02fig3) 中的 *所有组合* 进行评估。假设字典包含
    60,000 个单词，程序大约需要进行 500,000 次循环。
- en: To understand the loops, take a look at the core word for the palingram *stack
    cats* in [Figure 2-5](ch02.xhtml#ch02fig5). Your program needs to loop through
    the letters in the word, starting with an end letter and adding a letter with
    each iteration. To find palingrams like *stack cats*, it will simultaneously evaluate
    the word for the presence of a palindromic sequence at the end of the core word,
    *stack*, and a reversed word at the start. Note that the first loop in [Figure
    2-5](ch02.xhtml#ch02fig5) will be successful, as a single letter (*k*) can serve
    as a palindrome in this situation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解循环，看看 [图 2-5](ch02.xhtml#ch02fig5) 中的核心单词 *stack cats*。你的程序需要从单词的结尾字母开始，逐步加入字母。在寻找像
    *stack cats* 这样的 palingram 时，它将同时评估单词末尾是否存在回文序列 *stack*，并且在开始处是否有反向单词。注意， [图 2-5](ch02.xhtml#ch02fig5)
    中的第一个循环会成功，因为单个字母 (*k*) 在这种情况下可以作为回文。
- en: '![image](../images/f0027-02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0027-02.jpg)'
- en: '*Figure 2-5: Example loops through a core word, simultaneously looking for
    palindromes and reversed words*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：示例循环遍历核心单词，同时寻找回文和反向单词*'
- en: But you’re not through yet. To capture the “mirror image” behavior in [Figure
    2-3](ch02.xhtml#ch02fig3), you have to run the loops in reverse, looking for palindromic
    sequences at the start of the word and reversed words at the end. This will allow
    you to find palingrams like *stir grits*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但你还没有完成。为了捕捉 [图 2-3](ch02.xhtml#ch02fig3) 中的“镜像”行为，你需要反向运行循环，寻找单词开头的回文序列和结尾的反向单词。这将使你能够找到像
    *stir grits* 这样的 palingram。
- en: 'Here is the pseudocode for a palingram-finding algorithm:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个找到 palingram 的伪代码：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***The Palingrams Code***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Palingrams 代码***'
- en: '[Listing 2-3](ch02.xhtml#ch02list3), *palingrams.py*, loops through a word
    list, identifies which words form word-pair palingrams, saves those pairs to a
    list, and prints the list as stacked items. You can download the code from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    I suggest you use the *2of4brif.txt* dictionary file to start so that your results
    will match mine. Store your dictionary and *load_dictionary.py* in the same folder
    as the palingrams script.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-3](ch02.xhtml#ch02list3)，*palingrams.py*，遍历单词列表，识别哪些单词形成单词对 palingram，保存这些对到一个列表中，并将列表作为堆叠项目打印出来。你可以从
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载代码。我建议你使用 *2of4brif.txt* 字典文件开始，这样你的结果会和我的一致。将字典文件和 *load_dictionary.py* 存放在与
    palingrams 脚本相同的文件夹中。'
- en: '*palingrams.py*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*palingrams.py*'
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 2-3: Finds and prints word-pair palingrams in loaded dictionary*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-3：在加载的字典中查找并打印单词对 palingram*'
- en: After repeating the steps you used in the *palindromes.py* code to load a dictionary
    file, define a function to find palingrams ➊. Using a function will allow you
    to isolate the code later and time how long it takes to process all the words
    in the dictionary.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用*palindromes.py*代码加载词典文件后，定义一个函数来查找回文组合 ➊。使用函数可以让你在之后将代码隔离开来，并计算处理词典中所有单词所需的时间。
- en: Immediately start a list called `pali_list` to hold all the palingrams the program
    discovers. Next, start a `for` loop to evaluate the words in `word_list`. For
    each word, find its length and assign its length to the variable `end` ➋. The
    word’s length determines the indexes the program uses to slice through the word,
    looking for every possible reversed word-palindromic sequence combination, as
    in [Figure 2-3](ch02.xhtml#ch02fig3).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 立即启动一个名为`pali_list`的列表，用于存储程序发现的所有回文组合。接下来，启动一个`for`循环来评估`word_list`中的单词。对于每个单词，找到它的长度并将其赋值给变量`end`
    ➋。单词的长度决定了程序用来切片单词的索引，从而查找每一个可能的反转单词-回文序列组合，如[图2-3](ch02.xhtml#ch02fig3)所示。
- en: Next, negatively slice through the word and assign the results to the variable
    `rev_word` ➌. An alternative to `word[::-1]` is `''.join(reversed(word))`, which
    some consider more readable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，反向切片单词并将结果赋值给变量`rev_word` ➌。`word[::-1]`的替代方法是`''.join(reversed(word))`，一些人认为这种方法更具可读性。
- en: Since you are looking for word-pair palingrams, exclude single-letter words
    ➍. Then nest another `for` statement to loop through the letters in the current
    word ➎.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在寻找单词对的回文组合，排除掉单字母单词 ➍。然后嵌套另一个`for`语句，遍历当前单词中的字母 ➎。
- en: Now, run a conditional requiring the back end of the word to be palindromic
    and the front end to be a reverse word in the word list (in other words, a “real”
    word) ➏. If a word passes the test, it is appended to the palingram list, immediately
    followed by the reversed word.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行一个条件判断，要求单词的后半部分是回文，并且前半部分是单词列表中反转的单词（换句话说，是真正的单词） ➏。如果单词通过测试，它将被添加到回文组合列表中，并紧接着是反转后的单词。
- en: Based on [Figure 2-3](ch02.xhtml#ch02fig3), you know you have to repeat the
    conditional, but change the slicing direction and word order to reverse the output.
    In other words, you must capture palindromic sequences at the start of the word
    rather than at the end ➐. Return the list of palingrams to complete the function
    ➑.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[图2-3](ch02.xhtml#ch02fig3)，你知道需要重复条件判断，但要改变切片方向和单词顺序，以反转输出。换句话说，你必须捕获单词开头的回文序列，而不是结尾
    ➐。返回回文组合列表以完成函数 ➑。
- en: With the function defined, call it ➒. Since the order in which dictionary words
    are added to the palingram list switches during the loop, the palingrams won’t
    be in alphabetical order. So, sort the list so that the first words in the word
    pair are in alphabetical order. Print the length of the list ➓, then print each
    word-pair on a separate line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了函数后，调用它 ➒。由于在循环过程中添加到回文组合列表中的词典单词的顺序发生变化，回文组合将不会按字母顺序排列。因此，排序该列表，以确保词对中的第一个单词按字母顺序排列。打印列表的长度
    ➓，然后将每个单词对单独打印在一行上。
- en: As written, *palingrams.py* will take about three minutes to run on a dictionary
    file with about 60,000 words. In the next sections, we’ll investigate the cause
    of this long runtime and see what we can do to fix it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按照现有的写法，*palingrams.py*在约60,000个单词的词典文件上运行大约需要三分钟。在接下来的部分中，我们将探讨这个长时间运行的原因，并看看我们能做些什么来解决这个问题。
- en: '***Palingram Profiling***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回文组合分析***'
- en: '*Profiling* is an analytical process that gathers statistics on a program’s
    behavior—for example, the number and duration of function calls—as the program
    executes. Profiling is a key part of the optimization process. It tells you exactly
    what parts of a program are taking the most time or memory. That way, you’ll know
    where to focus your efforts to improve performance.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*分析*是一个分析过程，它在程序执行时收集程序行为的统计数据——例如函数调用的数量和持续时间。分析是优化过程中的关键部分。它能告诉你程序中哪些部分占用了最多的时间或内存。这样，你就知道应该在哪些地方集中精力以提高性能。'
- en: '**Profiling with cProfile**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用cProfile进行分析**'
- en: A *profile* is a measurement output—a record of how long and how often parts
    of a program are executed. The Python standard library provides a handy profiling
    interface, `cProfile`, which is a C extension suitable for profiling long-running
    programs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*配置文件*是一个度量输出——记录程序各部分执行的时长和频率。Python标准库提供了一个方便的分析接口`cProfile`，它是一个适用于分析长时间运行程序的C扩展。'
- en: Something in the `find_palingrams()` function probably accounts for the relatively
    long runtime of the *palingrams.py* program. To confirm, let’s run `cProfile`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_palingrams()`函数中的某些内容可能导致*palingrams.py*程序的相对较长运行时间。为了确认，我们运行`cProfile`。'
- en: Copy the following code into a new file named *cprofile_test.py* and save it
    in the same folder as *palingrams.py* and the dictionary file. This code imports
    `cProfile` and the palingrams program, and it runs `cProfile` on the `find_palingrams()`
    function—called with dot notation. Note again that you don’t need to specify the
    *.py* extension.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码复制到一个新文件中，命名为*cprofile_test.py*，并将其保存在与*palingrams.py*和字典文件相同的文件夹中。该代码导入了`cProfile`和palingrams程序，并对`find_palingrams()`函数进行`cProfile`分析——通过点符号调用。再次提醒，你无需指定*.py*扩展名。
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run *cprofile_test.py* and, after it finishes (you will see the `>>>` in the
    interpreter window), you should see something similar to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*cprofile_test.py*，在它完成后（你会看到解释器窗口中的`>>>`），你应该会看到类似下面的内容：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All that looping, slicing, and searching took 199.452 seconds on my machine,
    but of course your times may differ from mine. You also get additional information
    on some of the built-in functions, and since each palingram called the built-in
    `append()` function, you can even see the number of palingrams found (2,230).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的循环、切片和搜索在我的机器上花费了199.452秒，但当然你的时间可能与我的不同。你还会获得一些内置函数的额外信息，且由于每个palingram都调用了内置的`append()`函数，你甚至可以看到找到的palingrams数量（2,230）。
- en: '**NOTE**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The most common way to run* cProfile *is directly in the interpreter. This
    lets you dump your output to a text file and view it with a web viewer. For more
    information, visit* [https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*最常见的运行* cProfile *方式是在解释器中直接运行。这可以让你将输出转储到文本文件，并通过网页查看器查看。更多信息，请访问* [https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html)。'
- en: '**Profiling with time**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用time进行性能分析**'
- en: 'Another way to time the program is to use `time.time()`, which returns an *epoch
    timestamp*—the number of seconds since 12 AM on January 1, 1970 UTC (the *Unix
    epoch*). Copy *palingrams.py* to a new file, save it as *palingrams_timed.py*,
    and insert the following code at the very top:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种对程序进行计时的方法是使用`time.time()`，它返回一个*纪元时间戳*——自1970年1月1日UTC午夜12点以来的秒数（*Unix纪元*）。将*palingrams.py*复制到一个新文件中，保存为*palingrams_timed.py*，并在文件顶部插入以下代码：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now go to the end of the file and add the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在去文件的末尾，添加以下代码：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Save and run the file. You should get the following feedback at the bottom
    of the interpreter window—give or take a few seconds:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行文件。你应该在解释器窗口的底部看到以下反馈——大约几秒钟：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The runtime is longer than before, as you are now evaluating the whole program,
    including printing, rather than just the `find_palingrams()` function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间比之前长，因为你现在在评估整个程序，包括打印输出，而不仅仅是`find_palingrams()`函数。
- en: Unlike `cProfile`, `time` doesn’t provide detailed statistics, but like `cProfile`,
    it can be run on individual code components. Edit the file you just ran, moving
    the start and end time statements (as shown below in bold) so they bracket our
    long-running `find_palingrams()` function. Leave the `import` and `print` statements
    unchanged at the top and bottom of the file, respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与`cProfile`不同，`time`不提供详细的统计数据，但像`cProfile`一样，它可以在单个代码组件上运行。编辑你刚才运行的文件，将开始和结束时间语句（如下所示的粗体部分）移到我们长时间运行的`find_palingrams()`函数两侧。保持文件顶部和底部的`import`和`print`语句不变。
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Save and run the file. You should get the following feedback at the bottom
    of the interpreter window:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行文件。你应该在解释器窗口的底部看到以下反馈：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This now matches the initial results using `cProfile`. You won’t get the exact
    same time if you rerun the program or use a different timer, but don’t get hung
    up on it. It’s the *relative* times that are important for guiding code optimization.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在与使用`cProfile`时的初始结果相匹配。如果重新运行程序或使用不同的计时器，你不会得到完全相同的时间，但不要纠结于此。重要的是*相对*时间，用于指导代码优化。
- en: '***Palingram Optimization***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Palingram优化***'
- en: I’m sorry, but three minutes of my life is too long to wait for palingrams.
    Armed with our profiling results, we know that the `find_palingrams()` function
    accounts for most of the processing time. This probably has something to do with
    reading and writing to lists, slicing over lists, or searching in lists. Using
    an alternative data structure to lists—like tuples, sets, or dictionaries—might
    speed up the function. Sets, in particular, are significantly faster than lists
    when using the `in` keyword. Sets use a hashtable for very fast lookups. With
    hashing, strings of text are converted to unique numbers that are much smaller
    than the referenced text and much more efficient to search. With a list, on the
    other hand, you have to do a linear search through each item.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉，三分钟的等待时间对我来说太长了。根据我们的性能分析结果，我们知道 `find_palingrams()` 函数占用了大部分处理时间。这可能与读取和写入列表、对列表进行切片或在列表中查找有关。使用其他数据结构（如元组、集合或字典）可能会加速该函数。特别是，使用
    `in` 关键字时，集合比列表要快得多。集合使用哈希表进行非常快速的查找。通过哈希，文本字符串会被转换为独特的数字，这些数字比引用的文本要小得多，查找也更高效。而列表则需要对每个项进行线性搜索。
- en: 'Think of it this way: if you’re searching your house for your lost cell phone,
    you could emulate a list by looking through every room before finding it (in the
    proverbial last place you look). But by emulating a set, you can basically dial
    your cell number from another phone, listen for the ringtone, and go straight
    to the proper room.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你在家里找丢失的手机，你可以通过查看每个房间来模拟一个列表，直到在（俗话说的）最后一个地方找到它。但如果你模拟一个集合，你基本上可以从另一部电话拨打你的手机号码，听到铃声后直接走到正确的房间。
- en: A downside to using sets is that the order of the items in the set isn’t controllable
    and duplicate values aren’t allowed. With lists, the order is preserved and duplicates
    are allowed, but lookups take longer. Fortunately for us, we don’t care about
    order or duplicates, so sets are the way to go!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合的一个缺点是，集合中项目的顺序不可控，并且不允许重复值。使用列表时，顺序被保留且允许重复，但查找速度较慢。幸运的是，我们不关心顺序或重复，因此集合是最佳选择！
- en: '[Listing 2-4](ch02.xhtml#ch02list4) is the `find_palingrams()` function from
    the original *palingrams.py* program, edited to use a set of words rather than
    a list of words. You can find it in a new program named *palingrams_optimized.py*,
    which you can download from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*,
    or just make these changes to your copy of *palingrams_timed.py* if you want to
    check the new runtime yourself.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 2-4](ch02.xhtml#ch02list4) 是原始 *palingrams.py* 程序中的 `find_palingrams()`
    函数，经过编辑，改用一个单词集合而不是一个单词列表。你可以在一个名为 *palingrams_optimized.py* 的新程序中找到它，你可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载，或者如果你想自己检查新的运行时间，也可以直接对你的 *palingrams_timed.py* 版本做这些更改。'
- en: '*palingrams_optimized.py*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*palingrams_optimized.py*'
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 2-4: The* find_palingrams() *function optimized with sets*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-4: 使用集合优化的* find_palingrams() *函数*'
- en: Only four lines change. Define a new variable, `words`, which is a set of `word_list`
    ➊. Then loop through the set ➋, looking for membership of word slices in this
    set ➌➍, rather than in a list as before.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 只有四行代码需要更改。定义一个新的变量 `words`，它是 `word_list` 的集合 ➊。然后遍历集合 ➋，查找单词切片在这个集合中的成员资格
    ➌➍，而不是像以前那样在列表中查找。
- en: 'Here’s the new runtime for the `find_palingrams()` function in *palingrams_optimized.py*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 *palingrams_optimized.py* 中 `find_palingrams()` 函数的新运行时间：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Wow! From over three minutes to under a second! *That’s* optimization! And the
    difference is in the data structure. Verifying the membership of a word in a *list*
    was the thing that was killing us.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！从三分钟缩短到不到一秒！*这就是*优化！差异就在于数据结构。验证一个单词是否属于*列表*是让我们头疼的地方。
- en: 'Why did I first show you the “incorrect” way to do this? Because that’s how
    things happen in the real world. You get the code to work, and then you optimize
    it. This is a simple example that an experienced programmer would have gotten
    right from the start, but it is emblematic of the overall concept of optimization:
    get it to work as best as you can, then make it better.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我先展示了“错误”的做法？因为这就是现实世界中的情况。你先让代码运行起来，然后再进行优化。这是一个简单的例子，经验丰富的程序员从一开始就能做对，但它代表了优化的总体概念：先让它尽可能地工作，再去改进它。
- en: '**dnE ehT**'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**dnE ehT**'
- en: You’ve written code to find palindromes and palingrams, profiled code using
    `cProfile`, and optimized code by using the appropriate data structure for the
    task. So how did we do with respect to Zatanna? Does she have a fighting chance?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经编写了用于查找回文和回文字符串的代码，使用 `cProfile` 对代码进行了性能分析，并通过使用适合任务的数据结构优化了代码。那么，我们在 Zatanna
    面前表现如何？她有机会获胜吗？
- en: 'Here I’ve listed some of the more “aggressive” palingrams found in the *2of4brif*
    dictionary file—everything from the unexpected *sameness enemas* to the harsh
    *torsos rot* to my personal favorite as a geologist: *eroded ore*.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我列出了一些在 *2of4brif* 字典文件中找到的“更具攻击性”的回文字符串——从意外的 *相同灌肠* 到严厉的 *躯干腐烂*，再到作为地质学家的我最喜欢的
    *风化矿石*。
- en: '| dump mud | drowsy sword | sameness enemas |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 倾倒泥土 | 昏昏欲睡剑 | 相同灌肠 |'
- en: '| legs gel | denims mined | lepers repel |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 腿部凝胶 | 牛仔裤挖掘 | 麻风病人排斥 |'
- en: '| sleet eels | dairy raid | slam mammals |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 冰雹鳗鱼 | 乳制品袭击 | 猛击哺乳动物 |'
- en: '| eroded ore | rise sir | pots nonstop |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 风化矿石 | 升起先生 | 锅不停 |'
- en: '| strafe farts | torsos rot | swan gnaws |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 滑行放屁 | 躯干腐烂 | 天鹅啃咬 |'
- en: '| wolfs flow | partner entrap | nuts stun |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 狼流 | 伙伴陷阱 | 坚果震惊 |'
- en: '| slaps pals | flack calf | knobs bonk |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 拍打伙伴 | 拍打小腿 | 旋钮撞击 |'
- en: '**Further Reading**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*Think Python, 2nd Edition* (O’Reilly, 2015) by Allen Downey has a short and
    lucid description of hashtables and why they are so efficient. It’s also an excellent
    Python reference book.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 《*Think Python, 2nd Edition*》（O’Reilly，2015），由 Allen Downey 编写，简洁明了地描述了哈希表及其为何如此高效。这也是一本很棒的
    Python 参考书。
- en: '**Practice Project: Dictionary Cleanup**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：字典清理**'
- en: Data files available on the internet are not always “plug and play.” You may
    find you need to massage the data a bit before applying it to your project. As
    mentioned earlier, some online dictionary files include each letter of the alphabet
    as a word. These will cause problems if you want to permit the use of one-letter
    words in palingrams like *acidic a*. You could always remove them by directly
    editing the dictionary text file, but this is tedious and for losers. Instead,
    write a short script that removes these after the dictionary has been loaded into
    Python. To test that it works, edit your dictionary file to include a few one-letter
    words like *b* and *c*. For a solution, see the appendix, or find a copy (*dictionary_cleanup_practice.py*)
    online at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上可用的数据文件并不总是“即插即用”。你可能会发现，在将数据应用到项目之前，你需要稍微处理一下数据。如前所述，一些在线字典文件将每个字母作为一个单词。若要允许在回文字符串中使用一字母单词（例如
    *acidic a*），这些字母将会造成问题。你可以通过直接编辑字典文本文件来删除它们，但这很繁琐且不划算。相反，编写一个简短的脚本，在字典加载到 Python
    后删除这些单词。为了测试它是否有效，可以编辑你的字典文件，加入一些像 *b* 和 *c* 这样的单字母单词。有关解决方案，请参见附录，或在网上找到副本 (*dictionary_cleanup_practice.py*)，网址为
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。
- en: '**Challenge Project: Recursive Approach**'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：递归方法**'
- en: With Python, there is usually more than one way to skin a cat. Take a look at
    the discussion and pseudocode at the Khan Academy website (*[https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/using-recursion-to-determine-whether-a-word-is-a-palindrome/](https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/using-recursion-to-determine-whether-a-word-is-a-palindrome/)*).
    Then rewrite the *palindrome.py* program so that it uses recursion to identify
    palindromes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，通常有不止一种方法解决问题。请查看 Khan Academy 网站上的讨论和伪代码（*[https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/using-recursion-to-determine-whether-a-word-is-a-palindrome/](https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/using-recursion-to-determine-whether-a-word-is-a-palindrome/)*）。然后重写
    *palindrome.py* 程序，使其使用递归来识别回文。
