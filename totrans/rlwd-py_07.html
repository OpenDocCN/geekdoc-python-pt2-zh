<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_150"/><span epub:type="pagebreak" id="page_151"/><span class="big">7</span><br/>SELECTING MARTIAN LANDING SITES</h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">Landing a spacecraft on Mars is extraordinarily difficult and fraught with peril. No one wants to lose a billion-dollar probe, so engineers must emphasize operational safety. They may spend years searching satellite images for the safest landing sites that satisfy mission objectives. And they have a lot of ground to cover. Mars has almost the same amount of dry land as Earth!</p>&#13;
<p class="indent">Analyzing an area this large requires the help of computers. In this chapter, you’ll use Python and the Jet Propulsion Laboratory’s pride and joy, the Mars Orbiter Laser Altimeter (MOLA) map, to choose and rank candidate landing sites for a Mars lander. To load and extract useful information from the MOLA map, you’ll use the Python Imaging Library, OpenCV, <span class="literal">tkinter</span>, and <span class="literal">NumPy</span>.</p>&#13;
<h3 class="h3" id="ch00lev1sec50"><strong>How to Land on Mars</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_152"/>There are many ways to land a probe on Mars, including with parachutes, balloons, retro rockets, and jet packs. Regardless of the method, most landings follow the same basic safety rules.</p>&#13;
<p class="indent">The first rule is to target low-lying areas. A probe may enter the Martian atmosphere going as fast as 27,000 kilometers per hour (kph). Slowing it down for a soft landing requires a nice thick atmosphere. But the Martian atmosphere is thin—roughly 1 percent the density of Earth’s. To find enough of it to make a difference, you need to aim for the lowest elevations, where the air is denser and the flight through it takes as long as possible.</p>&#13;
<p class="indent">Unless you have a specialty probe, like one designed for a polar cap, you’ll want to land near the equator. Here, you’ll find plenty of sunshine to feed the probe’s solar panels, and temperatures stay warm enough to protect the probe’s delicate machinery.</p>&#13;
<p class="indent">You’ll want to avoid sites covered in boulders that can destroy the probe, prevent its panels from opening, block its robotic arm, or leave it tilted away from the sun. For similar reasons, you’ll want to stay away from areas with steep slopes, such as those found on the rims of craters. From a safety standpoint, flatter is better, and boring is beautiful.</p>&#13;
<p class="indent">Another challenge of landing on Mars is that you can’t be very precise. It’s hard to fly 50 million kilometers or more, graze the atmosphere, and land exactly where you intended. Inaccuracies in interplanetary navigation, along with variances in Martian atmospheric properties, make hitting a small target very uncertain.</p>&#13;
<p class="indent">Consequently, NASA runs lots of computer simulations for each landing coordinate. Each simulation run produces a coordinate, and the scatter of points that results from thousands of runs forms an elliptical shape with the long axis parallel to the probe’s flight path. These <em>landing ellipses</em> can be quite large (<a href="ch07.xhtml#ch07fig1">Figure 7-1</a>), though the accuracy improves with each new mission.</p>&#13;
<div class="image"><img src="../images/fig07-01.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig1"/>Figure 7-1: Scaled comparison of 1997 <span class="normal">Mars Pathfinder</span> landing site (left) with Southern California (right)</p>&#13;
<p class="indent">The 2018 <em>InSight</em> lander had a landing ellipse of only 130 km × 27 km. The probability of the probe landing somewhere within that ellipse was around 99 percent.</p>&#13;
<h3 class="h3" id="ch00lev1sec51"><strong>The MOLA Map</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_153"/>To identify suitable landing spots, you’ll need a map of Mars. Between 1997 and 2001, a tool aboard the <em>Mars Global Surveyor</em> (<em>MGS</em>) spacecraft shined a laser on Mars and timed its reflection 600 million times. From these measurements, researchers led by Maria Zuber and David Smith produced a detailed global topography map known as MOLA (<a href="ch07.xhtml#ch07fig2">Figure 7-2</a>).</p>&#13;
<div class="image"><img src="../images/fig07-02.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig2"/>Figure 7-2: MOLA shaded relief map of Mars</p>&#13;
<p class="indent">To see the spectacular color version of MOLA, along with a legend, go to the Wikipedia page for the <em>Mars Global Surveyor</em>. The blues in this map correspond to where oceans and seas probably existed on Mars billions of years ago. Their distribution is based on a combination of elevation and diagnostic surface features, like ancient shorelines.</p>&#13;
<p class="indent">The laser measurements for MOLA have a vertical positional accuracy of around 3 to 13 m and a horizontal positional accuracy of about 100 m. Pixel resolution is 463 m per pixel. By itself, the MOLA map lacks the detail needed to safely choose a final landing ellipse, but it’s perfect for the scoping work you’ll be asked to do.</p>&#13;
<h3 class="h3ab" id="ch00lev1sec52"><strong>Project #10: Selecting Martian Landing Sites</strong></h3>&#13;
<p class="noindent">Let’s pretend you’re a NASA summer intern working on the Orpheus Project, a mission designed to listen for marsquakes and study the interior of the planet, much like the 2018 Mars <em>InSight</em> mission. Because the purpose of Orpheus is to study the interior of Mars, interesting features of the planet’s surface aren’t that important. Safety is the prime concern, making this mission an engineer’s dream come true.</p>&#13;
<p class="indent">Your job is to find at least a dozen regions from which NASA staff can select smaller candidate landing ellipses. According to your supervisor, the regions should be rectangles 670 km long (E–W) and 335 km wide (N–S). To address safety concerns, the regions should straddle the equator between 30° N and 30° S latitude, lie at low elevations, and be as smooth and flat as possible.</p>&#13;
<div class="sidebar96">&#13;
<p class="Problem-Head">THE OBJECTIVE</p>&#13;
<p class="Body-Problem"><span epub:type="pagebreak" id="page_154"/>Write a Python program that uses an image of the MOLA map to choose the 20 safest 670 km × 335 km regions near the Martian equator from which to select landing ellipses for the <em>Orpheus</em> lander.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec37"><strong><em>The Strategy</em></strong></h4>&#13;
<p class="noindent">First, you’ll need a way to divide the MOLA digital map into rectangular regions and extract statistics on elevation and surface roughness. This means you’ll be working with pixels, so you’ll need imaging tools. And since NASA is always containing costs, you’ll want to use free, open source libraries like OpenCV, the Python Imaging Library (PIL), <span class="literal">tkinter</span>, and <span class="literal">NumPy</span>. For an over-view and installation instructions, see “Installing the Python Libraries” on <a href="ch01.xhtml#page_6">page 6</a> for OpenCV and <span class="literal">NumPy</span>, and see “The Word Cloud and PIL Modules” on <a href="ch03.xhtml#page_65">page 65</a> for PIL. The <span class="literal">tkinter</span> module comes preinstalled with Python.</p>&#13;
<p class="indent">To honor the elevation constraints, you can simply calculate the average elevation for each region. For measuring how smooth a surface is at a given scale, you have lots of choices, some of them quite sophisticated. Besides basing smoothness on elevation data, you can look for differential shadowing in stereo images; the amount of scattering in radar, laser, and microwave reflections; thermal variations in infrared images; and so on. Many roughness estimates involve tedious analyses along <em>transects</em>, which are lines drawn on the planet’s surface along which variations in height are measured and scrutinized. Since you’re not really a summer intern with three months to burn, you’re going to keep things simple and use two common measurements that you’ll apply to each rectangular region: standard deviation and peak-to-valley.</p>&#13;
<p class="indent"><em>Standard deviation</em>, also called <em>root-mean-square</em> by physical scientists, is a measure of the spread in a set of numbers. A low standard deviation indicates that the values in a set are close to the average value; a high standard deviation indicates they are spread out over a wider range. A map region with a low standard deviation for elevation means that the area is flattish, with little variance from the average elevation value.</p>&#13;
<p class="indent">Technically, the standard deviation for a population of samples is the square root of the average of the squared deviations from the mean, represented by the following formula:</p>&#13;
<div class="image1"><img src="../images/equ_page_154_01.jpg" alt="Image"/></div>&#13;
<p class="noindent">where σ is the standard deviation, <em>N</em> is the number of samples, <em>h</em><sub><em>i</em></sub> is the current height sample, and <em>h</em><sub><em>0</em></sub> is the mean of all the heights.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_155"/>The <em>peak-to-valley</em> statistic is the difference in height between the highest and lowest points on a surface. It captures the maximum elevation change for the surface. This is important as a surface may have a relatively low standard deviation—suggesting smoothness—yet contain a significant hazard, as shown in the cross section in <a href="ch07.xhtml#ch07fig3">Figure 7-3</a>.</p>&#13;
<div class="image"><img src="../images/fig07-03.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig3"/>Figure 7-3: A surface profile (black line) with standard deviation (StD) and peak-to-valley (PV) statistics</p>&#13;
<p class="indent">You can use the standard deviation and peak-to-valley statistics as comparative metrics. For each rectangular region, you’re looking for the lowest values of each statistic. And because each statistic records something slightly different, you’ll find the best 20 rectangular regions based on each statistic and then select only the rectangles that overlap to find the best rectangles overall.</p>&#13;
<h4 class="h4" id="ch00lev2sec38"><strong><em>The Site Selector Code</em></strong></h4>&#13;
<p class="noindent">The <em>site_selector.py</em> program uses a grayscale image of the MOLA map (<a href="ch07.xhtml#ch07fig4">Figure 7-4</a>) to select the landing site rectangles and the shaded color map (<a href="ch07.xhtml#ch07fig2">Figure 7-2</a>) to post them. Elevation is represented by a single channel in the grayscale image, so it’s easier to use than the three-channel (RGB) color image.</p>&#13;
<div class="image"><img src="../images/fig07-04.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig4"/>Figure 7-4: Mars MGS MOLA Digital Elevation Model 463m v2 (<span class="normal">mola_1024x501.png</span>)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_156"/>You can find the program, the grayscale image (<em>mola_1024x501.png</em>), and the color image (<em>mola_color_1024x506.png</em>) in the <em>Chapter_7</em> folder, downloadable from <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a></em>. Keep these files together in the same folder and don’t rename them.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The MOLA map comes in multiple file sizes and resolutions. You’re using the smallest size here to speed up the download and run times.</em></p>&#13;
</div>&#13;
<h5 class="h5"><strong>Importing Modules and Assigning User Input Constants</strong></h5>&#13;
<p class="noindent"><a href="ch07.xhtml#ch07list1">Listing 7-1</a> imports modules and assigns constants that represent user input parameters. These include image filenames, the dimensions of the rectangular regions, a maximum elevation limit, and the number of candidate rectangles to consider.</p>&#13;
<pre><span class="codeitalic1">site_selector.py</span>, part 1&#13;
import tkinter as tk&#13;
from PIL import Image, ImageTk&#13;
import numpy as np&#13;
import cv2 as cv&#13;
&#13;
# CONSTANTS: User Input:&#13;
IMG_GRAY = cv.imread('mola_1024x501.png', cv.IMREAD_GRAYSCALE)&#13;
IMG_COLOR = cv.imread('mola_color_1024x506.png')&#13;
RECT_WIDTH_KM = 670  &#13;
RECT_HT_KM = 335  &#13;
MAX_ELEV_LIMIT = 55  &#13;
NUM_CANDIDATES = 20  &#13;
MARS_CIRCUM = 21344</pre>&#13;
<p class="listing"><a id="ch07list1"/>Listing 7-1: Importing modules and assigning user input constants</p>&#13;
<p class="indent">Start by importing the <span class="literal">tkinter</span> module. This is Python’s default GUI library for developing desktop applications. You’ll use it to make the final display: a window with the color MOLA map at the top and a text description of the posted rectangles at the bottom. Most Windows, macOS, and Linux machines come with <span class="literal">tkinter</span> already installed. If you don’t have it or need the latest version, you can download and install it from <em><a href="https://www.activestate.com/">https://www.activestate.com/</a></em>. Online documentation for the module can be found at <em><a href="https://docs.python.org/3/library/tk.html">https://docs.python.org/3/library/tk.html</a></em>.</p>&#13;
<p class="indent">Next, import the <span class="literal">Image</span> and <span class="literal">ImageTK</span> modules from the Python Imaging Library. The <span class="literal">Image</span> module provides a class that represents a PIL image. It also provides factory functions, including functions to load images from files and create new images. The <span class="literal">ImageTK</span> module contains support for creating and modifying <span class="literal">tkinter</span>’s <span class="literal">BitmapImage</span> and <span class="literal">PhotoImage</span> objects from PIL images. Again, you’ll use these at the end of the program to place the color map and some descriptive text in a summary window. Finally, finish the imports with <span class="literal">NumPy</span> and OpenCV.</p>&#13;
<p class="indent">Now, assign some constants that represent user input that won’t change as the program runs. First, use the OpenCV <span class="literal">imread()</span> method to load the grayscale MOLA image. Note that you have to use the <span class="literal">cv.IMREAD_GRAYSCALE</span> flag, as the method loads images in color by default. Repeat the code <span epub:type="pagebreak" id="page_157"/>without the flag to load the color image. Then add constants for the rectangle size. In the next listing, you’ll convert these dimensions to pixels for use with the map image.</p>&#13;
<p class="indent">Next, to ensure the rectangles target smooth areas at low elevations, you should limit the search to lightly cratered, flat terrain. These regions are believed to represent old ocean bottoms. Thus, you’ll want to set the maximum elevation limit to a grayscale value of 55, which corresponds closely to the areas thought to be remnants of ancient shorelines (see <a href="ch07.xhtml#ch07fig5">Figure 7-5</a>).</p>&#13;
<div class="image"><img src="../images/fig07-05.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig5"/>Figure 7-5: MOLA map with pixel values ≤ 55 colored black to represent ancient Martian oceans</p>&#13;
<p class="indent">Now, specify the number of rectangles to display, represented by the <span class="literal">NUM_CANDIDATES</span> variable. Later, you’ll select these from a sorted list of rectangle statistics. Complete the user input constants by assigning a constant to hold the Martian circumference, in kilometers. You’ll use this later to determine the number of pixels per kilometer.</p>&#13;
<h5 class="h5"><strong>Assigning Derived Constants and Creating the screen Object</strong></h5>&#13;
<p class="noindent"><a href="ch07.xhtml#ch07list2">Listing 7-2</a> assigns constants that are derived from other constants. These values will update automatically if the user changes the previous constants,  for example, to test different rectangle sizes or elevation limits. The listing ends by creating <span class="literal">tkinter</span> <span class="literal">screen</span> and <span class="literal">canvas</span> objects for the final display.</p>&#13;
<pre><span class="codeitalic1">site_selector.py</span>, part 2&#13;
   # CONSTANTS: Derived:&#13;
   IMG_HT, IMG_WIDTH = IMG_GRAY.shape&#13;
   PIXELS_PER_KM = IMG_WIDTH / MARS_CIRCUM&#13;
   RECT_WIDTH = int(PIXELS_PER_KM * RECT_WIDTH_KM)&#13;
   RECT_HT = int(PIXELS_PER_KM * RECT_HT_KM)&#13;
<span class="ent">➊</span> LAT_30_N = int(IMG_HT / 3)&#13;
   LAT_30_S = LAT_30_N * 2&#13;
   STEP_X = int(RECT_WIDTH / 2)&#13;
   STEP_Y = int(RECT_HT / 2)&#13;
&#13;
<span class="ent">➋</span> screen = tk.Tk()&#13;
   canvas = tk.Canvas(screen, width=IMG_WIDTH, height=IMG_HT + 130)</pre>&#13;
<p class="listing"><a id="ch07list2"/>Listing 7-2: Assigning derived constants and setting up the <span class="literal">tkinter</span> screen</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_158"/>Start by unpacking the height and width of the image using the <span class="literal">shape</span> attribute. OpenCV stores images as <span class="literal">NumPy</span> ndarrays, which are <em>n</em>-dimensional arrays—or tables—of elements of the same type. For an image array, <span class="literal">shape</span> is a tuple of the number of rows, columns, and channels. The height represents the number of pixel rows in the image, and the width represents the number of pixel columns in the image. Channels represent the number of components used to represent each pixel (such as red, green, and blue). For grayscale images with one channel, <span class="literal">shape</span> is just a tuple of the area’s height and width.</p>&#13;
<p class="indent">To convert the rectangle dimensions from kilometers to pixels, you need to know how many pixels there are per kilometer. So, divide the image width by the circumference to get the pixels per kilometer at the equator. Then convert width and height into pixels. You’ll use these to derive values for index slicing later, so make sure they are integers by using <span class="literal">int()</span>. The value of these constants should now be 32 and 16, respectively.</p>&#13;
<p class="indent">You want to limit your search to the warmest and sunniest areas, which straddle the equator between 30° north latitude and 30° south latitude (<a href="ch07.xhtml#ch07fig6">Figure 7-6</a>). In terms of climatic criteria, this region corresponds to the tropics on Earth.</p>&#13;
<div class="image"><img src="../images/fig07-06.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig6"/>Figure 7-6: Latitude ( <span class="normal">y</span>-axis) and longitude ( <span class="normal">x</span>-axis) on Mars</p>&#13;
<p class="indent">Latitude values start at 0° at the equator and end at 90° at the poles. To find 30° north, all you need to do is divide the image height by 3 <span class="ent">➊</span>. To get to 30° south, double the number of pixels it took to get to 30° north.</p>&#13;
<p class="indent">Restricting the search to the equatorial region of Mars has a beneficial side effect. The MOLA map you’re using is based on a <em>cylindrical projection</em>, used to transfer the surface of a globe onto a flat plane. This causes converging lines of longitude to be parallel, badly distorting features near the poles. You may have noticed this on wall maps of the earth, where Greenland looks like a continent and Antarctica is impossibly huge (see <a href="ch07.xhtml#ch07fig7">Figure 7-7</a>).</p>&#13;
<p class="indent">Fortunately, this distortion is minimized near the equator, so you don’t have to factor it into the rectangle dimensions. You can verify this by checking the shape of craters on the MOLA map. So long as they’re nice and circular—rather than oval—projection-related effects can be ignored.</p>&#13;
<div class="image"><img src="../images/fig07-07.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig7"/>Figure 7-7: Forcing lines of longitude to be parallel distorts the size of features near the poles.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_159"/>Next, you’ll need to divide up the map into rectangular regions. A logical place to begin is the upper-left corner, tucked under the 30° north latitude line (<a href="ch07.xhtml#ch07fig8">Figure 7-8</a>).</p>&#13;
<div class="image"><img src="../images/fig07-08.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig8"/>Figure 7-8: Position of the first numbered rectangle</p>&#13;
<p class="indent">The program will draw this first rectangle, number it, and calculate the elevation statistics within it. It will then move the rectangle eastward and repeat the process. How far you move the rectangle each time is defined by the <span class="literal">STEP_X</span> and <span class="literal">STEP_Y</span> constants and depends on something called <em>aliasing</em>.</p>&#13;
<p class="indent">Aliasing is a resolution issue. It occurs when you don’t take enough samples to identify all the important surface features in an area. This can cause you to “skip over” a feature, such as a crater, and fail to recognize it. For example, in <a href="ch07.xhtml#ch07fig9">Figure 7-9</a>A, there’s a suitably smooth landing ellipse between two large craters. However, as laid out in <a href="ch07.xhtml#ch07fig9">Figure 7-9</a>B, no rectan-gular region corresponds to this ellipse; both rectangles in the vicinity partially sample a crater rim. As a result, none of the drawn rectangles contains a suitable landing ellipse, even though one exists in the vicinity. <span epub:type="pagebreak" id="page_160"/>With this arrangement of rectangles, the ellipse in <a href="ch07.xhtml#ch07fig9">Figure 7-9</a>A is <em>aliased</em>. But shift each rectangle by half its width, as in <a href="ch07.xhtml#ch07fig9">Figure 7-9</a>C, and the smooth area is properly sampled and recognized.</p>&#13;
<div class="image"><img src="../images/fig07-09.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig9"/>Figure 7-9: Example of aliasing due to rectangle positioning</p>&#13;
<p class="indent">The rule of thumb to avoid aliasing effects is to make the step size less than or equal to half the width of the smallest feature you want to identify. For this project, use half the rectangle width so the displays don’t become too busy.</p>&#13;
<p class="indent">Now it’s time to look ahead to the final display. Create a <span class="literal">screen</span> instance of the <span class="literal">tkinter</span> <span class="literal">Tk()</span> class <span class="ent">➋</span>. The <span class="literal">tkinter</span> application is Python’s wrapper of the GUI toolkit Tk, originally written in a computer language called TCL. It needs the <span class="literal">screen</span> window to link to an underlying tcl/tk interpreter that translates <span class="literal">tkinter</span> commands into tcl/tk commands.</p>&#13;
<p class="indent">Next, create a <span class="literal">tkinter</span> <span class="literal">canvas</span> object. This is a rectangular drawing area designed for complex layouts of graphics, text, widgets, and frames. Pass it the <span class="literal">screen</span> object, set its width equal to the MOLA image, and set its height equal to the height of the MOLA image plus 130. The extra padding beneath the image will hold the text summarizing the statistics for the displayed rectangles.</p>&#13;
<p class="indent">It’s more typical to place the <span class="literal">tkinter</span> code just described at the <em>end</em> of programs, rather than at the beginning. I chose to put it near the top to make the code explanation easier to follow. You can also embed this code within the function that makes the final display. However, this can cause problems for macOS users. For macOS 10.6 or newer, the Apple-supplied Tcl/Tk 8.5 has serious bugs that can cause application crashes (see <em><a href="https://www.python.org/download/mac/tcltk/">https://www.python.org/download/mac/tcltk/</a></em>).</p>&#13;
<h5 class="h5"><strong>Defining and Initializing a Search Class</strong></h5>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_161"/><a href="ch07.xhtml#ch07list3">Listing 7-3</a> defines a class that you’ll use to search for suitable rectangular regions. It then defines the class’s <span class="literal">__init__()</span> initialization method, used to instantiate new objects. For a quick overview of OOP, see “Defining the Search Class” on <a href="ch01.xhtml#page_10">page 10</a>, where you also define a search class.</p>&#13;
<pre><span epub:type="pagebreak" id="page_162"/><span class="codeitalic1">site_selector.py</span>, part 3&#13;
class Search():&#13;
    """Read image and identify landing rectangles based on input criteria.""" &#13;
 &#13;
   def __init__(self, name):&#13;
       self.name = name&#13;
    <span class="ent">➊</span> self.rect_coords = {}&#13;
       self.rect_means = {}&#13;
       self.rect_ptps = {}&#13;
       self.rect_stds = {}&#13;
    <span class="ent">➋</span> self.ptp_filtered = []&#13;
       self.std_filtered = []&#13;
       self.high_graded_rects = []</pre>&#13;
<p class="listing"><a id="ch07list3"/>Listing 7-3: Defining the <span class="literal">Search</span> class and <span class="literal">__init__()</span> method</p>&#13;
<p class="indent">Define a class called <span class="literal">Search</span>. Then define the <span class="literal">__init__()</span> method used to create new objects. The <span class="literal">name</span> parameter will allow you to give a personalized name to each object when you create it later in the <span class="literal">main()</span> function.</p>&#13;
<p class="indent">Now you’re ready to start assigning attributes. Start by linking the object’s name with the argument you’ll provide when you create the object. Then assign four empty dictionaries to hold important statistics for each rectangle <span class="ent">➊</span>. These include the rectangle’s corner-point coordinates and its mean elevation, peak-to-valley, and standard deviation statistics. For a key, all these dictionaries will use consecutive numbers, starting with 1. You’ll want to filter the statistics to find the lowest values, so set up two empty lists to hold these <span class="ent">➋</span>. Note that I use the term <span class="literal">ptp</span>, rather than <span class="literal">ptv</span>, to represent the peak-to-valley statistic. That’s to be consistent with the <span class="literal">NumPy</span> built-in method for this calculation, which is called <em>peak-to-peak</em>.</p>&#13;
<p class="indent">At the end of the program, you’ll place rectangles that occur in both the sorted standard deviation and peak-to-valley lists in a new list named <span class="literal">high_graded_rects</span>. This list will contain the numbers of the rectangles with the lowest combined scores. These rectangles will be the best places to look for landing ellipses.</p>&#13;
<h5 class="h5"><strong>Calculating Rectangle Statistics</strong></h5>&#13;
<p class="noindent">Still in the <span class="literal">Search</span> class, <a href="ch07.xhtml#ch07list4">Listing 7-4</a> defines a method that calculates statistics in a rectangle, adds the statistics to the appropriate dictionary, and then moves to the next rectangle and repeats the process. The method honors the elevation limit by using the rectangles in low-lying areas only to populate the dictionaries.</p>&#13;
<pre><span class="codeitalic1">site_selector.py</span>, part 4&#13;
def run_rect_stats(self):&#13;
    """Define rectangular search areas and calculate internal stats."""&#13;
    ul_x, ul_y = 0, LAT_30_N&#13;
    lr_x, lr_y = RECT_WIDTH, LAT_30_N + RECT_HT&#13;
    rect_num = 1&#13;
   &#13;
    while True:&#13;
     <span class="ent">➊</span> rect_img = IMG_GRAY[ul_y : lr_y, ul_x : lr_x]&#13;
        self.rect_coords[rect_num] = [ul_x, ul_y, lr_x, lr_y]&#13;
        if np.mean(rect_img) &lt;= MAX_ELEV_LIMIT:&#13;
            self.rect_means[rect_num] = np.mean(rect_img)&#13;
            self.rect_ptps[rect_num] = np.ptp(rect_img)&#13;
            self.rect_stds[rect_num] = np.std(rect_img)&#13;
        rect_num += 1&#13;
 &#13;
        ul_x += STEP_X&#13;
        lr_x = ul_x + RECT_WIDTH&#13;
      <span class="ent">➋</span> if lr_x &gt; IMG_WIDTH:&#13;
            ul_x = 0&#13;
            ul_y += STEP_Y&#13;
            lr_x = RECT_WIDTH&#13;
            lr_y += STEP_Y&#13;
      <span class="ent">➌</span> if lr_y &gt; LAT_30_S + STEP_Y:&#13;
            break</pre>&#13;
<p class="listing"><a id="ch07list4"/>Listing 7-4: Calculating rectangle statistics and moving the rectangle</p>&#13;
<p class="indent">Define the <span class="literal">run_rect_stats()</span> method, which takes <span class="literal">self</span> as an argument. Then assign local variables for the upper-left and lower-right corners of each rectangle. Initialize them using a combination of coordinates and constants. This will place the first rectangle along the left side of the image with its top boundary at 30° north latitude.</p>&#13;
<p class="indent">Keep track of the rectangles by numbering them, starting with 1. These numbers will serve as the keys for the dictionaries used to record coordinates and stats. You’ll also use them to identify the rectangles on the map, as demonstrated earlier in <a href="ch07.xhtml#ch07fig8">Figure 7-8</a>.</p>&#13;
<p class="indent">Now, start a <span class="literal">while</span> loop that will automate the process of moving the rectangles and recording their statistics. This loop will run until more than half of a rectangle extends below latitude 30° south, at which time the loop will <span class="literal">break</span>.</p>&#13;
<p class="indent">As mentioned previously, OpenCV stores images as <span class="literal">NumPy</span> arrays. To calculate the stats within the active rectangle, rather than the whole image, create a subarray using normal slicing <span class="ent">➊</span>. Call this subarray <span class="literal">rect_img</span>, for “rectangular image.” Then, add the rectangle number and these coordinates to the <span class="literal">rect_coords</span> dictionary. You’ll want to keep a record of these coordinates for the NASA staff, who’ll use your rectangles as the starting point for more detailed investigations later.</p>&#13;
<p class="indent">Next, start a conditional to check that the current rectangle is at or below the maximum elevation limit specified for the project. As part of this statement, use <span class="literal">NumPy</span> to calculate the mean elevation for the <span class="literal">rect_img</span> subarray.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_163"/>If the rectangle passes the elevation test, populate the three dictionaries with the coordinates, peak-to-valley, and standard deviation statistics, as appropriate. Note that you can perform the calculation as part of the process, using <span class="literal">np.ptp</span> for peak-to-valley and <span class="literal">np.std</span> for standard deviation.</p>&#13;
<p class="indent">Next, advance the <span class="literal">rect_num</span> variable by 1 and move the rectangle. Move the upper-left <em>x</em>-coordinate by the step size and then shift the lower-right <em>x</em>-coordinate by the width of the rectangle. You don’t want the rectangle to extend past the right side of the image, so check whether <span class="literal">lr_x</span> is greater than the image width <span class="ent">➋</span>. If it is, set the upper-left <em>x</em>-coordinate to <span class="literal">0</span> to move the rectangle back to the starting position on the left side of the screen. Then move its <em>y</em>-coordinates down so that the new rectangles move along a new row. If the bottom of this new row is more than half a rectangle height below 30° south latitude, you’ve fully sampled the search area and can end the loop <span class="ent">➌</span>.</p>&#13;
<p class="indent">Between 30° north and south latitude, the image is bounded on both sides by relatively high, cratered terrain that isn’t suitable for a landing site (see <a href="ch07.xhtml#ch07fig6">Figure 7-6</a>). Thus, you can ignore the final step that shifts the rectangle by one-half its width. Otherwise, you would need to add code that wraps a rectangle from one side of the image to the other and calculates the statistics for each part. We’ll take a closer look at this situation in the final challenge project at the end of the chapter.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>When you draw something on an image, such as a rectangle, the drawing becomes part of the image. The altered pixels will be included in any <span class="codeitalic">NumPy</span> analyses you run, so be sure to calculate any statistics before you annotate the image.</em></p>&#13;
</div>&#13;
<h5 class="h5"><strong>Checking the Rectangle Locations</strong></h5>&#13;
<p class="noindent">Still indented under the <span class="literal">Search</span> class, <a href="ch07.xhtml#ch07list5">Listing 7-5</a> defines a method that performs quality control. It prints the coordinates of all the rectangles and then draws them on the MOLA map. This will let you verify that the search area has been fully evaluated and the rectangle size is what you expected it to be.</p>&#13;
<pre><span class="codeitalic1">site_selector.py</span>, part 5&#13;
def draw_qc_rects(self):&#13;
        """Draw overlapping search rectangles on image as a check."""&#13;
        img_copy = IMG_GRAY.copy()&#13;
        rects_sorted = sorted(self.rect_coords.items(), key=lambda x: x[0])&#13;
        print("\nRect Number and Corner Coordinates (ul_x, ul_y, lr_x, lr_y):")&#13;
        for k, v in rects_sorted:&#13;
            print("rect: {}, coords: {}".format(k, v))&#13;
            cv.rectangle(img_copy,&#13;
                         (self.rect_coords[k][0], self.rect_coords[k][1]),&#13;
                         (self.rect_coords[k][2], self.rect_coords[k][3]),&#13;
                         (255, 0, 0), 1)&#13;
        cv.imshow('QC Rects {}'.format(self.name), img_copy)&#13;
        cv.waitKey(3000)&#13;
        cv.destroyAllWindows()</pre>&#13;
<p class="listing"><a id="ch07list5"/>Listing 7-5: Drawing all the rectangles on the MOLA map as a quality control step</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_164"/>Start by defining a method to draw the rectangles on the image. Anything you draw on an image in OpenCV becomes part of the image, so first make a copy of the image in the local space.</p>&#13;
<p class="indent">You’ll want to provide NASA with a printout of the identification number and coordinates for each rectangle. To print these in numerical order, sort the items in the <span class="literal">rect_coords</span> dictionary using a lambda function. If you haven’t used a lambda function before, you can find a short description on <a href="ch05.xhtml#page_107">page 107</a> in <a href="ch05.xhtml">Chapter 5</a>.</p>&#13;
<p class="indent">Print a header for the list and then start a <span class="literal">for</span> loop through the keys and values in the newly sorted dictionary. The key is the rectangle number, and the value is the list of coordinates, as shown in the following output:</p>&#13;
<pre>Rect Number and Corner Coordinates (ul_x, ul_y, lr_x, lr_y):&#13;
rect: 1, coords: [0, 167, 32, 183]&#13;
rect: 2, coords: [16, 167, 48, 183]&#13;
&#13;
<span class="codeitalic1">--snip--</span>&#13;
&#13;
rect: 1259, coords: [976, 319, 1008, 335]&#13;
rect: 1260, coords: [992, 319, 1024, 335]</pre>&#13;
<p class="indent">Use the OpenCV <span class="literal">rectangle()</span> method to draw the rectangles on the image. Pass it the image on which to draw, the rectangle coordinates, a color, and a line width. Access the coordinates directly from the <span class="literal">rect_coords</span> dictionary using the key and the list index (0 = upper-left <em>x</em>, 1 = upper-left <em>y</em>, 2 = lower-right <em>x</em>, 3 = lower-right <em>y</em>).</p>&#13;
<p class="indent">To display the image, call the OpenCV <span class="literal">imshow()</span> method and pass it a name for the window and the image variable. The rectangles should cover Mars in a band centered on the equator (<a href="ch07.xhtml#ch07fig10">Figure 7-10</a>). Leave the window up for three seconds and then destroy it.</p>&#13;
<div class="image"><img src="../images/fig07-10.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig10"/>Figure 7-10: All 1,260 rectangles drawn by the <span class="literal">draw_qc_rects()</span> method</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_165"/>If you compare <a href="ch07.xhtml#ch07fig10">Figure 7-10</a> to <a href="ch07.xhtml#ch07fig8">Figure 7-8</a>, you may notice that the rect-angles appear smaller than expected. This is because you stepped the rectangles across and down the image using half the rectangle width and height so that they overlap each other.</p>&#13;
<h5 class="h5"><strong>Sorting the Statistics and High Grading the Rectangles</strong></h5>&#13;
<p class="noindent">Continuing with the <span class="literal">Search</span> class definition, <a href="ch07.xhtml#ch07list6">Listing 7-6</a> defines a method to find the rectangles with the best potential landing sites. The method sorts the dictionaries containing the rectangle statistics, makes lists of the top rectangles based on the peak-to-valley and standard deviation statistics, and then makes a list of any rectangles shared between these two lists. The shared rectangles will be the best candidates for landing sites, as they’ll have the smallest peak-to-valley and standard deviation statistics.</p>&#13;
<pre><span class="codeitalic1">site_selector.py</span>, part 6&#13;
def sort_stats(self): &#13;
    """Sort dictionaries by values and create lists of top N keys."""&#13;
    ptp_sorted = (sorted(self.rect_ptps.items(), key=lambda x: x[1]))&#13;
    self.ptp_filtered = [x[0] for x in ptp_sorted[:NUM_CANDIDATES]]&#13;
    std_sorted = (sorted(self.rect_stds.items(), key=lambda x: x[1]))&#13;
    self.std_filtered = [x[0] for x in std_sorted[:NUM_CANDIDATES]]    &#13;
    for rect in self.std_filtered:&#13;
        if rect in self.ptp_filtered:&#13;
            self.high_graded_rects.append(rect)</pre>&#13;
<p class="listing"><a id="ch07list6"/>Listing 7-6: Sorting and high grading the rectangles based on their statistics</p>&#13;
<p class="indent">Define a method called <span class="literal">sort_stats()</span>. Sort the <span class="literal">rect_ptps</span> dictionary with a lambda function that sorts the values rather than the keys. The values in this dictionary are the peak-to-valley measurements. This should create a list of tuples, with the rectangle number at index 0 and the peak-to-valley value at index 1.</p>&#13;
<p class="indent">Next, use list comprehension to populate the <span class="literal">self.ptp_filtered</span> attribute with the rectangle numbers in the <span class="literal">ptp_sorted</span> list. Use index slicing to select only the first 20 values, as stipulated by the <span class="literal">NUM_CANDIDATES</span> constant. You now have the 20 rectangles with the lowest peak-to-valley scores. Repeat this same basic code for standard deviation, producing a list of the 20 rectangles with the lowest standard deviation.</p>&#13;
<p class="indent">Finish the method by looping through the rectangle numbers in the <span class="literal">std_filtered</span> list and comparing them to those in the <span class="literal">ptp_filtered</span> list. Append matching numbers to the <span class="literal">high_graded_rects</span> instance attribute you created previously with the <span class="literal">__init__()</span> method.</p>&#13;
<h5 class="h5"><strong>Drawing the Filtered Rectangles on the Map</strong></h5>&#13;
<p class="noindent"><a href="ch07.xhtml#ch07list7">Listing 7-7</a>, still indented under the <span class="literal">Search</span> class, defines a method that draws the 20 best rectangles on the grayscale MOLA map. You’ll call this method in the <span class="literal">main()</span> function.<span epub:type="pagebreak" id="page_166"/></p>&#13;
<pre><span class="codeitalic1">site_selector.py</span>, part 7 &#13;
def draw_filtered_rects(self, image, filtered_rect_list):&#13;
    """Draw rectangles in list on image and return image."""&#13;
    img_copy = image.copy()&#13;
    for k in filtered_rect_list: &#13;
        cv.rectangle(img_copy,&#13;
                     (self.rect_coords[k][0], self.rect_coords[k][1]),&#13;
                     (self.rect_coords[k][2], self.rect_coords[k][3]),&#13;
                     (255, 0, 0), 1)&#13;
        cv.putText(img_copy, str(k),&#13;
                   (self.rect_coords[k][0] + 1, self.rect_coords[k][3]- 1),&#13;
                   cv.FONT_HERSHEY_PLAIN, 0.65, (255, 0, 0), 1)&#13;
  &#13;
 <span class="ent">➊</span> cv.putText(img_copy, '30 N', (10, LAT_30_N - 7),&#13;
               cv.FONT_HERSHEY_PLAIN, 1, 255)&#13;
    cv.line(img_copy, (0, LAT_30_N), (IMG_WIDTH, LAT_30_N),&#13;
            (255, 0, 0), 1)&#13;
    cv.line(img_copy, (0, LAT_30_S), (IMG_WIDTH, LAT_30_S),&#13;
            (255, 0, 0), 1)&#13;
    cv.putText(img_copy, '30 S', (10, LAT_30_S + 16),&#13;
               cv.FONT_HERSHEY_PLAIN, 1, 255)&#13;
&#13;
    return img_copy</pre>&#13;
<p class="listing"><a id="ch07list7"/>Listing 7-7: Drawing filtered rectangles and latitude lines on MOLA map</p>&#13;
<p class="indent">Start by defining the method, which in this case takes multiple arguments. Besides <span class="literal">self</span>, the method will need a loaded image and a list of rectangle numbers. Use a local variable to copy the image and then start looping through the rectangle numbers in the <span class="literal">filtered_rect_list</span>. With each loop, draw a rectangle by using the rectangle number to access the corner coordinates in the <span class="literal">rect_coords</span> dictionary.</p>&#13;
<p class="indent">So you can tell one rectangle from another, use OpenCV’s <span class="literal">putText()</span> method to post the rectangle number in the bottom-left corner of each rectangle. It needs the image, the text (as a string), coordinates for the upper-left <em>x</em> and lower-right <em>x</em>, a font, a line width, and a color.</p>&#13;
<p class="indent">Next, draw the annotated latitude limits, starting with the text for 30° north <span class="ent">➊</span>. Then draw the line using OpenCV’s <span class="literal">line()</span> method. It takes as arguments an image, a pair of (<em>x</em>, <em>y</em>) coordinates for the start and end of the line, a color, and a thickness. Repeat these basic instructions for 30° south latitude.</p>&#13;
<p class="indent">End the method by returning the annotated image. The best rectangles, based on the peak-to-valley and standard deviation statistics, are shown in <a href="ch07.xhtml#ch07fig11">Figures 7-11</a> and <a href="ch07.xhtml#ch07fig12">7-12</a>, respectively.</p>&#13;
<p class="indent">These two figures show the top 20 rectangles for each statistic. That doesn’t mean they always agree. The rectangle with the lowest standard deviation may not appear in the peak-to-valley figure due to the presence of a single small crater. To find the flattest, smoothest rectangles, you need to identify the rectangles that appear in both figures and show them in their own display.<span epub:type="pagebreak" id="page_167"/></p>&#13;
<div class="image"><img src="../images/fig07-11.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig11"/>Figure 7-11: The 20 rectangles with the lowest peak-to-valley scores</p>&#13;
<div class="image"><img src="../images/fig07-12.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig12"/>Figure 7-12: The 20 rectangles with the lowest standard deviations</p>&#13;
<h5 class="h5"><strong>Making the Final Color Display</strong></h5>&#13;
<p class="noindent"><a href="ch07.xhtml#ch07list8">Listing 7-8</a> finishes the <span class="literal">Search</span> class by defining a method to summarize the best rectangles. It uses <span class="literal">tkinter</span> to make a summary window with the rectangles posted on the color MOLA image. It also prints the rectangles’ statistics below the image as text objects. This adds a little work, but it’s a cleaner-looking solution than posting the summarized stats directly on the image with OpenCV.<span epub:type="pagebreak" id="page_168"/></p>&#13;
<pre><span class="codeitalic1">site_selector.py</span>, part 8&#13;
def make_final_display(self):&#13;
    """Use Tk to show map of final rects &amp; printout of their statistics."""&#13;
    screen.title('Sites by MOLA Gray STD &amp; PTP {} Rect'.format(self.name))&#13;
&#13;
    img_color_rects = self.draw_filtered_rects(IMG_COLOR,&#13;
                                               self.high_graded_rects)&#13;
&#13;
 <span class="ent">➊</span> img_converted = cv.cvtColor(img_color_rects, cv.COLOR_BGR2RGB)&#13;
    img_converted = ImageTk.PhotoImage(Image.fromarray(img_converted)) &#13;
    canvas.create_image(0, 0, image=img_converted, anchor=tk.NW)&#13;
&#13;
 <span class="ent">➋</span> txt_x = 5&#13;
    txt_y = IMG_HT + 20&#13;
    for k in self.high_graded_rects:&#13;
        canvas.create_text(txt_x, txt_y, anchor='w', font=None,&#13;
                           text="rect={} mean elev={:.1f} std={:.2f} ptp={}"&#13;
                           .format(k, self.rect_means[k], self.rect_stds[k],&#13;
                                   self.rect_ptps[k]))&#13;
        txt_y += 15&#13;
     <span class="ent">➌</span> if txt_y &gt;= int(canvas.cget('height')) - 10:&#13;
            txt_x += 300&#13;
            txt_y = IMG_HT + 20        &#13;
    canvas.pack()&#13;
    screen.mainloop()</pre>&#13;
<p class="listing"><a id="ch07list8"/>Listing 7-8: Making the final display using the color MOLA map</p>&#13;
<p class="indent">After defining the method, give the <span class="literal">tkinter</span> <span class="literal">screen</span> window a title that links to the name of your search object.</p>&#13;
<p class="indent">Then, to make the final color image for display, name a local variable <span class="literal">img_color_rects</span> and call the <span class="literal">draw_filtered_rects()</span> method. Pass it the color MOLA image and the list of high-graded rectangles. This will return the colored image with the final rectangles and latitude limits.</p>&#13;
<p class="indent">Before you can post this new color image in the <span class="literal">tkinter</span> <span class="literal">canvas</span>, you need to convert the colors from OpenCV’s Blue-Green-Red (BGR) format to the Red-Green-Blue (RGB) format used by <span class="literal">tkinter</span>. Do this with the OpenCV <span class="literal">cvtColor()</span> method. Pass it the image variable and the <span class="literal">COLOR_BGR2RGB</span> flag <span class="ent">➊</span>. Name the result <span class="literal">img_converted</span>.</p>&#13;
<p class="indent">At this point, the image is still a <span class="literal">NumPy</span> array. To convert to a <span class="literal">tkinter</span>- compatible photo image, you need to use the PIL <span class="literal">ImageTk</span> module’s <span class="literal">PhotoImage</span> class and the <span class="literal">Image</span> module’s <span class="literal">fromarray()</span> method. Pass the method the RGB image variable you created in the previous step.</p>&#13;
<p class="indent">With the image finally <span class="literal">tkinter</span> ready, place it in the <span class="literal">canvas</span> using the <span class="literal">create_image()</span> method. Pass the method the coordinates of the upper-left corner of the canvas (<span class="literal">0, 0</span>), the converted image, and a northwest anchor direction.</p>&#13;
<p class="indent">Now all that’s left is to add the summary text. Start by assigning coordinates for the bottom-left corner of the first text object <span class="ent">➋</span>. Then begin looping through the rectangle numbers in the high-graded rectangle list. Use the <span class="literal">create_text()</span> method to place the text in the <span class="literal">canvas</span>. Pass it a pair <span epub:type="pagebreak" id="page_169"/>of coordinates, a left-justified anchor direction, the default font, and a text string. Get the statistics by accessing the different dictionaries using the rectangle number, designated <span class="literal">k</span> for “key.”</p>&#13;
<p class="indent">Increment the text box’s <em>y</em>-coordinate by 15 after drawing each text object. Then write a conditional to check that the text is greater than or within 10 pixels of the bottom of the <span class="literal">canvas</span> <span class="ent">➌</span>. You can obtain the height of the <span class="literal">canvas</span> using the <span class="literal">cget()</span> method.</p>&#13;
<p class="indent">If the text is too close to the bottom of the <span class="literal">canvas</span>, you need to start a new column. Shift the <span class="literal">txt_x</span> variable over by 300 and reset <span class="literal">txt_y</span> to the image height plus 20.</p>&#13;
<p class="indent">Finish the method definition by packing the <span class="literal">canvas</span> and then calling the <span class="literal">screen</span> object’s <span class="literal">mainloop()</span>. Packing optimizes the placement of objects in the <span class="literal">canvas</span>. The <span class="literal">mainloop()</span> is an infinite loop that runs <span class="literal">tkinter</span>, waits for an event to occur, and processes the event until the window is closed.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The height of the color image (506 pixels) is slightly larger than that of the grayscale image (501 pixels). I chose to ignore this, but if you’re a stickler for accuracy, you can use OpenCV to shrink the height of the color image using <span class="codeitalic">IMG_COLOR = cv.resize(IMG_COLOR, (1024, 501), interpolation = cv.INTER_AREA).</span></em></p>&#13;
</div>&#13;
<h5 class="h5"><strong>Running the Program with main()</strong></h5>&#13;
<p class="noindent"><a href="ch07.xhtml#ch07list9">Listing 7-9</a> defines a <span class="literal">main()</span> function to run the program.</p>&#13;
<pre><span class="codeitalic1">site_selector.py</span>, part 9&#13;
   def main():&#13;
       app = Search('670x335 km')&#13;
       app.run_rect_stats()&#13;
       app.draw_qc_rects()&#13;
       app.sort_stats()&#13;
       ptp_img = app.draw_filtered_rects(IMG_GRAY, app.ptp_filtered)&#13;
       std_img = app.draw_filtered_rects(IMG_GRAY, app.std_filtered)&#13;
&#13;
    <span class="ent">➊</span> cv.imshow('Sorted by ptp for {} rect'.format(app.name), ptp_img)&#13;
       cv.waitKey(3000)&#13;
       cv.imshow('Sorted by std for {} rect'.format(app.name), std_img)&#13;
       cv.waitKey(3000)&#13;
&#13;
       app.make_final_display()  # Includes call to mainloop().&#13;
&#13;
<span class="ent">➋</span> if __name__ == '__main__':&#13;
      main()</pre>&#13;
<p class="listing"><a id="ch07list9"/>Listing 7-9: Defining and calling the <span class="literal">main()</span> function used to run the program</p>&#13;
<p class="indent">Start by instantiating an <span class="literal">app</span> object from the <span class="literal">Search</span> class. Name it <span class="literal">670x335</span> <span class="literal">km</span> to document the size of the rectangular regions being investigated. Next, call the <span class="literal">Search</span> methods in order. Run the statistics on the rectangles and draw the quality control rectangles. Sort the statistics from smallest to largest and then draw the rectangles with the best peak-to-valley and standard deviation statistics. Show the results <span class="ent">➊</span> and finish the function by making the final summary display.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_170"/>Back in the global space, add the code that lets the program run as an imported module or in stand-alone mode <span class="ent">➋</span>.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07fig13">Figure 7-13</a> shows the final display. It includes the high-graded rectangles and the summary statistics sorted based on standard deviation.</p>&#13;
<div class="image"><img src="../images/fig07-13.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig13"/>Figure 7-13: Final display with high-graded rectangles and summary statistics sorted by standard deviation</p>&#13;
<h4 class="h4" id="ch00lev2sec39"><strong><em>Results</em></strong></h4>&#13;
<p class="noindent">After you’ve made the final display, the first thing you should do is perform a sanity check. Make sure that the rectangles are within the allowed latitude and elevation limits and that they appear to be in smooth terrain. Likewise, the rectangles based on the peak-to-valley and standard deviation statistics, shown in <a href="ch07.xhtml#ch07fig11">Figures 7-11</a> and <a href="ch07.xhtml#ch07fig12">7-12</a>, respectively, should match the constraints and mostly pick the same rectangles.</p>&#13;
<p class="indent">As noted previously, the rectangles in <a href="ch07.xhtml#ch07fig11">Figures 7-11</a> and <a href="ch07.xhtml#ch07fig12">7-12</a> don’t perfectly overlap. That’s because you’re using two different metrics for smoothness. One thing you can be sure of, though, is that the rectangles that do overlap will be the smoothest of all the rectangles.</p>&#13;
<p class="indent">While all the rectangle locations look reasonable in the final display, the concentration of rectangles on the far-west side of the map is particularly encouraging. This is the smoothest terrain in the search area (<a href="ch07.xhtml#ch07fig14">Figure 7-14</a>), and your program clearly recognized it.</p>&#13;
<p class="indent">This project focused on safety concerns, but scientific objectives drive site selection for most missions. In the practice projects at the end of the chapter, you’ll get a chance to incorporate an additional constraint— geology—into the site selection equation.</p>&#13;
<div class="image"><img src="../images/fig07-14.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig14"/>Figure 7-14: The very smooth terrain west of the Olympus Mons lava fields</p>&#13;
<h3 class="h3" id="ch00lev1sec53"><span epub:type="pagebreak" id="page_171"/><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you used Python, OpenCV, the Python Imaging Library, <span class="literal">NumPy</span>, and <span class="literal">tkinter</span> to load, analyze, and display an image. Because OpenCV treats images as <span class="literal">NumPy</span> arrays, you can easily extract information from parts of an image and evaluate it with Python’s many scientific libraries.</p>&#13;
<p class="indent">The dataset you used was quick to download and fast to run. While a real intern would have used a larger and more rigorous dataset, such as one composed of millions of actual elevation measurements, you got to see how the process works with little effort and reasonable results.</p>&#13;
<h3 class="h3" id="ch00lev1sec54"><strong>Further Reading</strong></h3>&#13;
<p class="noindent">The Jet Propulsion Laboratory has several short and fun videos about landing on Mars. Find them with online searches for <em>Mars in a Minute: How Do You Choose a Landing Site?</em>, <em>Mars in a Minute: How Do You Get to Mars?</em>, and <em>Mars in a Minute: How Do You Land on Mars?</em>.</p>&#13;
<p class="indent"><em>Mapping Mars: Science, Imagination, and the Birth of a World</em> (Picador, 2002), by Oliver Morton, tells the story of the contemporary exploration of Mars, including the creation of the MOLA map.</p>&#13;
<p class="indent"><em>The Atlas of Mars: Mapping Its Geography and Geology</em> (Cambridge University Press, 2019), by Kenneth Coles, Kenneth Tanaka, and Philip Christensen, is a spectacular all-purpose reference atlas of Mars that includes maps of topography, geology, mineralogy, thermal properties, near-surface water-ice, and more.</p>&#13;
<p class="indent">The data page for the MOLA map used in Project 10 is at <em><a href="https://astrogeology.usgs.gov/search/map/Mars/GlobalSurveyor/MOLA/Mars_MGS_MOLA_DEM_mosaic_global_463m/">https://astrogeology.usgs.gov/search/map/Mars/GlobalSurveyor/MOLA/Mars_MGS_MOLA_DEM_mosaic_global_463m/</a></em>.</p>&#13;
<p class="indent">Detailed Martian datasets are available on the Mars Orbital Data Explorer site produced by the PDS Geoscience Node at Washington University in St. Louis (<em><a href="https://ode.rsl.wustl.edu/mars/index.aspx">https://ode.rsl.wustl.edu/mars/index.aspx</a></em>).</p>&#13;
<h3 class="h3" id="ch00lev1sec55"><span epub:type="pagebreak" id="page_172"/><strong>Practice Project: Confirming That Drawings Become Part of an Image</strong></h3>&#13;
<p class="noindent">Write a Python program that verifies that drawings added to an image, such as text, lines, rectangles, and so on, become part of that image. Use <span class="literal">NumPy</span> to calculate the mean, standard deviation, and peak-to-valley statistics on a rectangular region in the MOLA grayscale image, but don’t draw the rectangle outline. Then draw a white line around the region and rerun the statistics. Do the two runs agree?</p>&#13;
<p class="indent">You can find a solution, <em>practice_confirm_drawing_part_of_image.py</em>, in the appendix or <em>Chapter_7</em> folder, downloadable from <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a></em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec56"><strong>Practice Project: Extracting an Elevation Profile</strong></h3>&#13;
<p class="noindent">An elevation profile is a two-dimensional, cross-sectional view of a landscape. It provides a side view of a terrain’s relief along a line drawn between locations on a map. Geologists can use profiles to study the smoothness of a surface and visualize its topography. For this practice project, draw a west-to-east profile that passes through the caldera of the largest volcano in the solar system, Olympus Mons (<a href="ch07.xhtml#ch07fig15">Figure 7-15</a>).</p>&#13;
<div class="image"><img src="../images/fig07-15.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig15"/>Figure 7-15: Vertically exaggerated west-east profile through Olympus Mons</p>&#13;
<p class="indent">Use the <em>Mars MGS MOLA - MEX HRSC Blended DEM Global 200m v2</em> map shown in <a href="ch07.xhtml#ch07fig15">Figure 7-15</a>. This version has better lateral resolution than the one you used for Project 10. It also uses the full elevation range in the MOLA data. You can find a copy, <em>mola_1024x512_200mp.jpg</em>, in the <em>Chapter_7</em> folder, downloadable from the book’s website. A solution, <em>practice_profile_olympus.py</em>, is available in the same folder and in the appendix.</p>&#13;
<h3 class="h3" id="ch00lev1sec57"><span epub:type="pagebreak" id="page_173"/><strong>Practice Project: Plotting in 3D</strong></h3>&#13;
<p class="noindent">Mars is an asymmetrical planet, with the southern hemisphere dominated by ancient cratered highlands and the north characterized by smooth, flat lowlands. To make this more apparent, use the 3D plotting functionality in <span class="literal">matplotlib</span> to display the <em>mola_1024x512_200mp.jpg</em> image you used in the previous practice project (<a href="ch07.xhtml#ch07fig16">Figure 7-16</a>).</p>&#13;
<div class="image"><img src="../images/fig07-16.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig16"/>Figure 7-16: A 3D contour plot of Mars, looking toward the west</p>&#13;
<p class="indent">With <span class="literal">matplotlib</span>, you can make 3D relief plots using points, lines, contours, wireframes, and surfaces. Although the plots are somewhat crude, you can generate them quickly. You can also use the mouse to interactively grab the plot and change the viewpoint. They are particularly useful for people who have trouble visualizing topography from 2D maps.</p>&#13;
<p class="indent">In <a href="ch07.xhtml#ch07fig16">Figure 7-16</a>, the exaggerated vertical scale makes the elevation difference from south to north easy to see. It’s also easy to spot the tallest mountain (Olympus Mons) and the deepest crater (Hellas Planitia).</p>&#13;
<p class="indent">You can reproduce the plot in <a href="ch07.xhtml#ch07fig16">Figure 7-16</a>—sans annotation—with the <em>practice_3d_plotting.py</em> program in the appendix or <em>Chapter_7</em> folder, downloadable from the book’s website. The map image can be found in the same folder.</p>&#13;
<h3 class="h3" id="ch00lev1sec58"><strong>Practice Project: Mixing Maps</strong></h3>&#13;
<p class="noindent">Make up a new project that adds a bit of science to the site selection process. Combine the MOLA map with a color geology map and find the smoothest rectangular regions within the volcanic deposits at Tharsis Montes (see arrow in <a href="ch07.xhtml#ch07fig17">Figure 7-17</a>).</p>&#13;
<div class="image"><img src="../images/fig07-17.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig17"/>Figure 7-17: Geological map of Mars. The arrow points to the Tharsis volcanic deposits.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_174"/>Since the Tharsis Montes region lies at a high altitude, focus on finding the flattest and smoothest parts of the volcanic deposits, rather than targeting the lowest elevations. To isolate the volcanic deposits, consider thresholding a grayscale version of the map. <em>Thresholding</em> is a segmentation technique that partitions an image into a foreground and a background.</p>&#13;
<p class="indent">With thresholding, you convert a grayscale image into a binary image where pixels above or between specified threshold values are set to 1 and all others are set to 0. You can use this binary image to filter the MOLA map, as shown in <a href="ch07.xhtml#ch07fig18">Figure 7-18</a>.</p>&#13;
<div class="image"><img src="../images/fig07-18.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig18"/>Figure 7-18: Filtered MOLA map over the Tharsis Montes region, with ptp (left) and std (right) rectangles</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_175"/>You can find the geological map, <em>Mars_Global_Geology_Mariner9_1024.jpg</em>, in the <em>Chapter_7</em> folder, downloadable from the book’s website. The volcanic deposits will be light pink in color. For the elevation map, use <em>mola_1024x512_200mp.jpg</em>  from the “Extracting an Elevation Profile” practice project on <a href="ch07.xhtml#page_172">page 172</a>.</p>&#13;
<p class="indent">A solution, contained in <em>practice_geo_map_step_1of2.py</em>  and <em>practice_geo_map_step_2of2.py</em>, can be found in the same folder and in the appendix. Run the <em>practice_geo_map_step_1of2.py</em> program first to generate the filter for step 2.</p>&#13;
<h3 class="h3" id="ch00lev1sec59"><strong>Challenge Project: Making It Three in a Row</strong></h3>&#13;
<p class="noindent">Edit the “Extracting an Elevation Profile” project so that the profile passes through the three volcanoes on Tharsis Montes, as shown in <a href="ch07.xhtml#ch07fig19">Figure 7-19</a>.</p>&#13;
<div class="image"><img src="../images/fig07-19.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig19"/>Figure 7-19: Diagonal profile through the three volcanoes on Tharsis Montes</p>&#13;
<p class="indent">Other interesting features to profile are Valles Marineris, a canyon nine times as long and four times as deep as the Grand Canyon, and Hellas Planitia, considered the third or fourth largest impact crater in the solar system (<a href="ch07.xhtml#ch07fig19">Figure 7-19</a>).</p>&#13;
<h3 class="h3" id="ch00lev1sec60"><strong>Challenge Project: Wrapping Rectangles</strong></h3>&#13;
<p class="noindent">Edit the <em>site_selector.py</em> code so that it accommodates rectangle dimensions that don’t divide evenly into the width of the MOLA image. One way to do this is to add code that splits the rectangle into two pieces (one along the right edge of the map and the other along the left edge), calculates statistics for each, and then recombines them into a full rectangle. Another approach is to duplicate the image and “stitch” it to the original image, as shown in <a href="ch07.xhtml#ch07fig20">Figure 7-20</a>. This way, you won’t have to split the rectangles; just decide when to stop stepping them across the map.</p>&#13;
<div class="image"><img src="../images/fig07-20.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch07fig20"/>Figure 7-20: The grayscale MOLA image duplicated and repeated</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_176"/>Of course, for efficiency, you don’t have to duplicate the whole map. You only need a strip along the eastern margin wide enough to accommodate the final overlapping rectangle.</p>&#13;
</body></html>