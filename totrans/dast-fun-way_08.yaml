- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Grids
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网格
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we look at what happens as we consider multidimensional values
    and targets. The data structures we’ve examined so far have all shared a common
    constraint—they organize data based on a single value. Many real-world problems
    involve multiple important dimensions, and we need to extend our data structures
    to handle searches over such data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将探讨当我们考虑多维值和目标时会发生什么。到目前为止，我们所研究的数据结构都共享一个共同的约束——它们基于单一值来组织数据。许多现实世界中的问题涉及多个重要维度，因此我们需要扩展我们的数据结构，以处理这种数据上的搜索。
- en: This chapter starts by introducing nearest-neighbor search, which will serve
    as our motivating use case for multidimensional data. As we will see, the generality
    of nearest-neighbor search makes it very flexible and applicable to a wide range
    of spatial and non-spatial problems. It can help us find the cup of coffee closest
    to our current location or the brand best suited to our tastes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍最近邻搜索，它将作为我们多维数据的激励性应用案例。正如我们将看到的，最近邻搜索的普适性使其非常灵活，适用于各种空间和非空间问题。它可以帮助我们找到离我们当前位置最近的咖啡店，或者最适合我们口味的品牌。
- en: We then introduce the grid data structure and show how it facilitates nearest-neighbor
    search over two dimensions, using spatial relationships within the data to prune
    out infeasible regions of the search space. We briefly discuss how these approaches
    can be extended to more than two dimensions. We will also see how these data structures
    fall short, providing the motivation for further spatial data structures.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们介绍网格数据结构，并展示它如何在二维空间上促进最近邻搜索，利用数据中的空间关系来修剪掉不可行的搜索区域。我们还简要讨论了这些方法如何扩展到二维以上的情况。我们将看到这些数据结构的不足之处，并为进一步的空间数据结构提供动机。
- en: Introducing Nearest-Neighbor Search
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍最近邻搜索
- en: 'As its name implies, *nearest-neighbor search* consists of finding a particular
    data point closest to a given search target—for example, the coffee shop nearest
    our current location. Formally, we define nearest-neighbor search as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名字所示，*最近邻搜索*的核心是找到离给定搜索目标最近的特定数据点——例如，离我们当前位置最近的咖啡店。形式上，我们将最近邻搜索定义如下：
- en: Given a set of *N* data points *X* = {*x*[1], *x*[2], … , *x*[N]}, a target
    value *x*’, and a distance function *dist*(*x*,*y*), find the point *x*[*i*] ∈
    *X* that minimizes *dist*(*x*’,*x*[*i*]).
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定一组*N*个数据点 *X* = {*x*[1], *x*[2], … , *x*[N]}，一个目标值 *x*’，以及一个距离函数 *dist*(*x*,*y*)，找到数据点
    *x*[*i*] ∈ *X*，使得 *dist*(*x*’，*x*[*i*])最小。
- en: Nearest-neighbor search is closely related to the target value search we used
    to motivate binary search in Chapter 2. Both algorithms search for a specific
    data point within a set of data. The key difference lies in the success criteria.
    Whereas binary search tests for an exact match within a data set, which may or
    may not be present, nearest-neighbor search is only concerned with finding the
    closest match.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最近邻搜索与我们在第二章中用来激发二分搜索的目标值搜索密切相关。两者的算法都是在数据集中搜索特定的数据点。关键的区别在于成功标准。二分搜索是测试数据集中是否存在确切匹配，而最近邻搜索只关注找到最接近的匹配。
- en: This framing makes nearest-neighbor search useful for many types of multiple-dimensional
    data. We could be searching a map for nearby coffee shops, a list of historical
    temperatures for days similar to the current date, or a list of “close” misspellings
    of a given word. As long as we can define a distance between the search target
    and other values, we can find nearest neighbors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种框架使得最近邻搜索对许多类型的多维数据都非常有用。我们可能在搜索地图上的附近咖啡店，查找与当前日期相似的历史温度，或者搜索某个单词的“近似”拼写。只要我们能够定义搜索目标与其他值之间的距离，就能找到最近邻。
- en: In past chapters, we primarily considered targets that are individual numeric
    values, like the data stored in binary search trees and heaps. While we sometimes
    included auxiliary data, the targets themselves remained simple. In contrast,
    nearest-neighbor search is most interesting when dealing with multidimensional
    data, which may be stored in a variety of other data structures such as arrays,
    tuples, or composite data structures. Later in this chapter, we look at example
    two-dimensional search problems and their targets. For now, though, let’s introduce
    a basic algorithm for this search.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的章节中，我们主要考虑了像二叉搜索树和堆中存储的数字值这样的目标。虽然我们有时也包括辅助数据，但目标本身仍然很简单。相比之下，最近邻搜索在处理多维数据时最为有趣，这些数据可能存储在各种其他数据结构中，例如数组、元组或复合数据结构。在本章后面，我们将介绍二维搜索问题及其目标。现在，让我们先介绍一种基本的搜索算法。
- en: Nearest-Neighbor Search with Linear Scan
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用线性扫描的最近邻搜索
- en: As a baseline algorithm for nearest-neighbor search, we start with a modified
    version of the linear scan algorithm from Chapter 2. The linear scan algorithm
    isn’t particularly exciting; you can implement it with a simple loop in most programming
    languages. Yet, because of its simplicity, linear scan provides a good starting
    point from which to examine more complex and efficient algorithms.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最近邻搜索的基线算法，我们从第2章的线性扫描算法的修改版开始。线性扫描算法并不特别激动人心；你可以用大多数编程语言通过一个简单的循环来实现它。然而，正因为它的简单性，线性扫描提供了一个很好的起点，帮助我们检视更复杂和高效的算法。
- en: 'Consider the problem of nearest-neighbor search with numbers using the absolute
    distance: *dist*(*x*,*y*) = |*x* – *y*|. Given a list of numbers and a search
    target, we want to find the closest number on the list. Perhaps we wake up in
    a new city and need to find our first cup of coffee in the morning. The hotel’s
    concierge provides a list of coffee shops on the same street, along with a helpful
    map. Not recognizing any of the businesses, we resolve to prioritize expedience
    and visit the coffee shop closest to the hotel.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用绝对距离的最近邻搜索问题：*dist*(*x*,*y*) = |*x* – *y*|。给定一组数字和一个搜索目标，我们想找到列表中最接近的数字。也许我们在一个新的城市醒来，需要找个地方喝早晨的第一杯咖啡。酒店的礼宾部提供了同一条街上的咖啡店列表，并附上了一张有用的地图。由于我们不认识任何这些商店，我们决定优先选择方便的咖啡店，去离酒店最近的那一家。
- en: We can visualize this search with a number line shown in [Figure 8-1](#figure8-1).
    The points represent different coffee shops and their location with respect to
    the start of the map, while the X represents our hotel with a location of 2.2
    miles along the street.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过图[8-1](#figure8-1)中的数字线来可视化这个搜索。图中的点代表不同的咖啡店及其相对于地图起点的位置，而X则代表我们的酒店，距离街道上的2.2英里处。
- en: '![A number line with seven candidate neighbors and one target point. The target
    point sits at 2.2 with the closest neighbor at 2.6.](image_fi/502604c08/f08001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![一条包含七个候选邻居和一个目标点的数字线。目标点位于2.2，最近邻居在2.6处。](image_fi/502604c08/f08001.png)'
- en: 'Figure 8-1: A one-dimensional nearest-neighbor search represented as a number
    line'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1：表示为数字线的一个维度最近邻搜索
- en: 'In a program, the points in [Figure 8-1](#figure8-1) might represent unsorted
    values within an array. However, visualizing these values along a real-valued
    number line has two advantages in the context of nearest-neighbor search. First,
    it clarifies the importance of distance: we can see the gaps between our target
    value and each data point. Second, it helps us generalize the techniques beyond
    a single dimension, as we’ll see in the next section.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，图[8-1](#figure8-1)中的点可能表示数组中的未排序值。然而，在最近邻搜索的上下文中，将这些值可视化为实数轴有两个优点。首先，它明确了距离的重要性：我们可以看到目标值与每个数据点之间的间隔。其次，它帮助我们将技巧推广到多维度，正如我们将在下一节中看到的那样。
- en: For now, the linear scan proceeds through each data point, as shown in [Figure
    8-2](#figure8-2), computing the distance for the current data point and comparing
    it to the minimum distance found so far. Here we consider the points in sorted
    order since they are already along the number line, but linear scan does not require
    a particular ordering. It uses the data’s ordering within the list.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，线性扫描会按照图[8-2](#figure8-2)所示，逐个遍历每个数据点，计算当前数据点的距离，并与迄今为止找到的最小距离进行比较。在这里，我们按排序顺序考虑这些点，因为它们已经沿着数字线排列，但线性扫描并不要求特定的排序。它使用数据在列表中的顺序。
- en: '![The linear scan computes each data point’s distance from the target point.
    A series of number lines shows each pair of points and their corresponding distance.](image_fi/502604c08/f08002.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![线性扫描计算每个数据点到目标点的距离。若干数轴展示了每对点及其对应的距离。](image_fi/502604c08/f08002.png)'
- en: 'Figure 8-2: A linear scan through the data points in a one-dimensional nearest-neighbor
    search'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2：一维最近邻搜索中的数据点线性扫描
- en: In the first comparison in [Figure 8-2](#figure8-2), we find a point at distance
    1.8\. This becomes our best option so far, our *candidate nearest neighbor*. It
    might not be a *good* neighbor—1.8 miles is a bit far to walk for our morning
    cup of joe—but it’s the best we’ve seen. The next two steps discover better candidates
    at distances 1.2 and 0.4, respectively. Alas, the remaining four comparisons don’t
    produce a better candidate; the point at distance 0.4 remains the closest we’ve
    found. In the end, the algorithm returns that third point on our number line as
    the nearest neighbor. We head to the coffee shop, confident we’re heading to the
    closest one on the street.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 8-2](#figure8-2)中的第一次比较中，我们找到了一个距离为1.8的点。到目前为止，这成为了我们的最佳选择，即我们的*候选最近邻*。它可能不是一个*理想的*邻居——1.8英里对于我们早上的咖啡来说，走路有点远——但它是我们见过的最好的。接下来的两步分别发现了距离1.2和0.4的更好候选点。遗憾的是，剩余的四次比较并没有找到更好的候选点；距离0.4的点仍然是我们找到的最近邻。在最终，算法返回了我们的数字轴上第三个点作为最近邻。我们信心满满地前往咖啡店，确信我们正在前往街上最接近的那一家。
- en: '[Listing 8-1](#listing8-1) shows the code for a linear scan using an arbitrary
    distance function. We use floating-point values for the one-dimensional case but
    can extend the function to multiple dimensions by using composite data structures
    or other representations.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-1](#listing8-1)展示了使用任意距离函数的线性扫描代码。我们在一维情况下使用浮点值，但可以通过使用复合数据结构或其他表示方法将该函数扩展到多维情况。'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: The code for a linear scan nearest-neighbor algorithm'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-1：线性扫描最近邻算法的代码
- en: 'The code starts by checking whether the array is empty and, if so, returning
    `null` ❶, since there is no closest point. The code then picks the first item
    in the array as the initial candidate nearest neighbor and computes the distance
    from that point to the target ❷. This information provides a starting point for
    our search: we compare all future points against the best candidate and distance
    so far. The remainder of the code uses a `WHILE` loop to iterate over the remaining
    elements in the array ❸, computing the distance to the target and comparing that
    to the best distance found so far. The code updates the best candidate and best
    distance found whenever it finds a closer candidate ❹, then returns the closest
    neighbor ❺.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查数组是否为空，如果为空，则返回`null` ❶，因为没有最近邻点。接下来，代码将数组中的第一个项目选为初始的候选最近邻，并计算该点到目标的距离
    ❷。这为我们的搜索提供了一个起点：我们将所有后续的点与当前最佳候选和距离进行比较。代码的其余部分使用`WHILE`循环遍历数组中的剩余元素 ❸，计算它们到目标的距离，并与当前找到的最佳距离进行比较。每当找到更近的候选时，代码会更新最佳候选和最佳距离
    ❹，最后返回最接近的邻居 ❺。
- en: Beyond providing a simple implementation of nearest-neighbor search, the linear
    scan algorithm also trivially supports different distance functions or even higher-dimensional
    points. First, let’s look at some example problems in this two-dimensional space.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供简单的最近邻查找实现外，线性扫描算法还轻松支持不同的距离函数，甚至是更高维度的点。首先，让我们来看一些在这个二维空间中的示例问题。
- en: Searching Spatial Data
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索空间数据
- en: Imagine that you are multiple hours into a cross-country road trip and desperately
    need a coffee refill. Panic floods your mind as you realize that you haven’t mapped
    out the optimal coffee shops along your route. You take a few deep breaths, pull
    out the map shown in [Figure 8-3](#figure8-3), and locate numerous towns with
    known coffee establishments. Prioritizing expedience over quality, you vow to
    find the closest café.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你已经驾驶几个小时，进行着一次横跨国家的公路旅行，并且迫切需要一杯咖啡续杯。你猛然意识到，自己没有规划好沿途的最佳咖啡店，恐慌涌上心头。你深吸一口气，拿出[图
    8-3](#figure8-3)中展示的地图，找到多个有已知咖啡店的城镇。你把效率放在首位，决心找到最近的咖啡馆。
- en: '![A two‐dimensional map of towns. The target point lies in the middle left
    near the towns of Gridville, Cartesian, and Fort Fortran.](image_fi/502604c08/f08003.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![一个二维城镇地图。目标点位于中左侧，靠近Gridville、Cartesian和Fort Fortran等城镇。](image_fi/502604c08/f08003.png)'
- en: 'Figure 8-3: A map as an example of two-dimensional data'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3：作为二维数据示例的地图
- en: 'The data consists of two-dimensional points—towns with *x*, *y* coordinates.
    These data points can be stored as an ordered tuple (*x*, *y*); a small, fixed-size
    array [*x*, *y*]; or even a composite data structure for two-dimensional spatial
    points:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数据由二维点组成——带有 *x* 和 *y* 坐标的城镇。这些数据点可以存储为一个有序元组（*x*, *y*）；一个小型固定大小的数组 [*x*, *y*]；甚至可以使用复合数据结构来表示二维空间点：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When determining which town is closest, we’ll focus on just the straight-line
    distance to the coffee shop. In any real-world navigation task, we’d also need
    to consider obstacles standing between us and our coffee. For now, though, let’s
    just consider the Euclidean distance to the coffee shops. If our current point
    is (*x*[1]*, y*[1]) and the coffee shop is at (*x*[2]*, y*[2]), then the distance
    is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定哪个城镇最接近时，我们将仅关注与咖啡店的直线距离。在任何现实世界的导航任务中，我们还需要考虑我们和咖啡之间的障碍物。然而，目前，我们只考虑到咖啡店的欧几里得距离。如果当前点是
    (*x*[1]*, y*[1])，而咖啡店在 (*x*[2]*, y*[2]) 处，那么距离为：
- en: '![G08001](image_fi/502604c08/G08001.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![G08001](image_fi/502604c08/G08001.png)'
- en: We could use the linear-scan algorithm in [Listing 8-1](#listing8-1). The algorithm
    computes the distance from our target to each candidate point, as shown in [Figure
    8-4](#figure8-4).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[清单 8-1](#listing8-1)中的线性扫描算法。该算法计算从目标到每个候选点的距离，如[图 8-4](#figure8-4)所示。
- en: '![An illustration of the distance computations from our target point to each
    of the 11 towns on the map. The distances are represented by dashed lines from
    the target point to the town.](image_fi/502604c08/f08004.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![一张插图，展示了从目标点到地图上11个城镇的距离计算。距离通过从目标点到各城镇的虚线表示。](image_fi/502604c08/f08004.png)'
- en: 'Figure 8-4: A linear scan nearest-neighbor search computes the distance from
    the target to each candidate point.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4：线性扫描最近邻搜索计算从目标到每个候选点的距离。
- en: The point with the smallest distance to the target, shown in [Figure 8-5](#figure8-5),
    is the target’s nearest neighbor. The dashed line represents the distance to the
    closest point, and the dotted circle shows the area of our map that is closer
    than (or equal to) the closest point. No other points lie closer than the nearest
    neighbor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与目标的距离最小的点，如[图 8-5](#figure8-5)所示，就是目标的最近邻。虚线表示与最近点的距离，虚线圆圈显示的是我们地图上距离最近点（或等于最近点）的区域。没有其他点的距离比最近邻点更近。
- en: '![The map with a dashed line from the target point to the nearest neighbor
    and a dotted circle indicating the space that falls within this radius.](image_fi/502604c08/f08005.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![一张从目标点到最近邻之间有虚线，并且有一个虚线圆圈表示此半径范围内的区域的地图。](image_fi/502604c08/f08005.png)'
- en: 'Figure 8-5: The point with the smallest distance to the target is that target’s
    nearest neighbor.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5：与目标的距离最小的点就是该目标的最近邻。
- en: As we’ve seen multiple times, though, this type of linear scan search quickly
    becomes inefficient as the number of points increases. If the current edition
    of the *Coffee Lover’s Guide to Roadside Coffee* lists 100,000 coffee shops, it
    would be needlessly time-consuming to check each one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们多次看到的那样，当点的数量增加时，这种类型的线性扫描搜索会迅速变得低效。如果《咖啡爱好者指南》当前版本列出了10万个咖啡馆，逐一检查每个咖啡馆将会是一个不必要的时间消耗。
- en: We shouldn’t need to look at every single data point in two-dimensional space.
    Some points are too far away to matter. We would never consider Alaskan coffee
    shops when driving through Florida. This is not to disparage Alaskan cafés—I’m
    sure there are plenty that equal their Floridian peers in terms of taste and quality.
    It’s simply a matter of expedience. We can’t survive an hour without our coffee,
    let alone a multi-day drive. If we are driving through northern Florida, we need
    to focus on northern Floridian coffee establishments.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该需要查看二维空间中的每一个数据点。有些点距离太远，不需要考虑。当我们驾驶穿越佛罗里达时，我们不会考虑阿拉斯加的咖啡店。这并不是贬低阿拉斯加的咖啡馆——我相信有许多咖啡馆在口味和质量上与佛罗里达的同类相匹配。这仅仅是为了效率考虑。我们无法在没有咖啡的情况下生存一个小时，更别提几天的驾车旅行了。如果我们在北佛罗里达驾驶，我们需要关注的是北佛罗里达的咖啡馆。
- en: As we saw in binary search, we can often use structure within the data to help
    eliminate large numbers of candidates. We can even adapt binary search to find
    nearest neighbors in one-dimensional space. Unfortunately, a simple sort will
    not help in the two-dimensional case. If we sort and search either x or y dimensions,
    as shown in [Figure 8-6](#figure8-6), we get the wrong answer—the closest neighbor
    in the one-dimensional space is not the same as the closest two-dimensional neighbor.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在二分查找中所见，我们常常可以利用数据中的结构来帮助排除大量候选项。我们甚至可以将二分查找法改编为在一维空间中寻找最近邻。不幸的是，简单的排序在二维情况下并不奏效。如果我们按照x轴或y轴排序并进行搜索，如[图8-6](#figure8-6)所示，结果是错误的——一维空间中的最近邻与二维空间中的最近邻并不相同。
- en: We need to use information from all relevant dimensions to make accurate pruning
    decisions. A point close to our target along a single dimension might be staggeringly
    far away in other dimensions. If we sort our list of coffee shops by latitude,
    our search for locations near our current latitude in northern Florida might return
    quite a few “close” results from Houston. Similarly, if we sort by longitude,
    we might be swamped with entries from Cleveland. We need to explore new approaches,
    adapted from our experience with one-dimensional data but also making use of the
    structure inherent in higher dimensions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要利用所有相关维度的信息来做出准确的剪枝决策。在某一维度上接近目标的点，在其他维度上可能相距非常远。如果我们按照纬度对咖啡店列表进行排序，搜索位于我们当前佛罗里达北部纬度附近的地点时，可能会返回来自休斯顿的一些“接近”结果。类似地，如果我们按经度排序，可能会收到来自克利夫兰的条目。我们需要探索新的方法，借鉴我们在一维数据中的经验，同时也利用高维度固有的结构。
- en: '![On the left, a projection of the map points from Figure 8‐3 onto the Y‐axis.
    On the right, a projection of the points onto the X‐axis. In both cases, the closest
    neighbor in one dimension is not the same as the closest neighbor in two dimensions.](image_fi/502604c08/f08006b.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![左侧是图8-3中地图点在Y轴上的投影。右侧是点在X轴上的投影。在这两种情况下，单一维度上的最近邻与二维空间中的最近邻并不相同。](image_fi/502604c08/f08006b.png)'
- en: 'Figure 8-6: Projecting the data to one dimension along either the y-axis (left)
    or x-axis (right) removes important spatial information about the other dimension.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6：将数据投影到单一维度（左侧为y轴，右侧为x轴）会丢失关于另一个维度的重要空间信息。
- en: Grids
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格
- en: '*Grids* are data structures for storing two-dimensional data. Like arrays,
    grids consist of a fixed set of *bins*, or *cells*. Since we are initially covering
    two-dimensional data, we use a two-dimensional arrangement of bins and index each
    bin with two numbers, *xbin* and *ybin*, representing the bin numbers along the
    x-axis and y-axis respectively. [Figure 8-7](#figure8-7) shows an example grid.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*网格*是用于存储二维数据的数据结构。像数组一样，网格由一组固定的*区间*或*单元格*组成。由于我们最初处理的是二维数据，因此我们使用二维的区间排列，并用两个数字*xbin*和*ybin*来索引每个区间，分别表示x轴和y轴上的区间编号。[图8-7](#figure8-7)展示了一个网格示例。'
- en: '![A two‐by‐two grid over the map. Bins are labeled 0 and 1 along both the X
    and Y dimension, resulting in a total of four quadrants.](image_fi/502604c08/f08007.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![地图上的二维网格。X轴和Y轴上的标记分别为0和1，共有四个象限。](image_fi/502604c08/f08007.png)'
- en: 'Figure 8-7: A 2×2 grid of spatial data points'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-7：一个2×2的空间数据点网格
- en: Unlike arrays, we can’t restrict each bin to hold a single value. Grid cells
    are defined by spatial bounds—a high and low edge along each dimension. No matter
    how finely we draw the grid, multiple points might fall within the same cell,
    so we need our bins to store multiple elements apiece. Each bin stores a list
    of *all* data points that fall within that bin’s range.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组不同，我们不能将每个区间限制为仅存储一个值。网格单元是由空间边界定义的——每个维度上的高低边界。无论我们如何精细地绘制网格，多个点可能会落在同一个单元格内，因此我们需要让每个区间能够存储多个元素。每个区间存储一个包含该区间范围内*所有*数据点的列表。
- en: We can visualize the difference between grids and arrays as different forms
    of refrigerator storage. The egg carton is an array with one individual space
    for each egg. In contrast, the vegetable drawer is like a grid bin. It contains
    multiple items of the same type, all vegetables. We might stuff a single drawer
    with twenty-five onions. The egg carton, on the other hand, contains only a fixed
    number of eggs, each in its designated place. While vegetable drawers may generate
    intense debates about where to correctly store tomatoes or cucumbers, the bounds
    of a grid cell are defined with mathematical precision.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将网格和数组之间的区别形象化为冰箱存储的不同形式。蛋盒是一个数组，每个蛋都有一个独立的空间。相比之下，蔬菜抽屉更像是一个网格箱，它包含了多种相同类型的物品，全部是蔬菜。我们可能把一个抽屉塞满二十五个洋葱。另一方面，蛋盒只包含固定数量的鸡蛋，每个鸡蛋都有指定的位置。而蔬菜抽屉可能会引发关于番茄或黄瓜应该存放在哪里的激烈讨论，但网格单元的边界是通过数学精确定义的。
- en: Grids use the points’ coordinates to determine their storage, allowing us to
    use the data’s spatial structure to limit our searches. To see how this is possible,
    we first need to consider the details of the grid’s structure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 网格使用点的坐标来确定它们的存储方式，使我们能够利用数据的空间结构来限制搜索范围。为了理解这一点，我们首先需要考虑网格结构的细节。
- en: Grid Structure
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格结构
- en: The top-level data structure for our grid contains some extra bookkeeping information.
    As shown in [Figure 8-8](#figure8-8), we need to include multiple pieces of information
    along each dimension. In addition to the number of bins along the x- and y-dimensions,
    we must track the spatial bounds along each dimension. We use `x_start` and `x_end`
    to indicate the minimum and maximum values of x included in our grid. Similarly,
    `y_start` and `y_end` capture the spatial bounds for y.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网格的顶层数据结构包含一些额外的记录信息。如图 [8-8](#figure8-8) 所示，我们需要在每个维度上包含多项信息。除了 x 和 y 维度上的箱子数量，我们还必须跟踪每个维度的空间边界。我们使用
    `x_start` 和 `x_end` 来表示网格中包含的 x 的最小值和最大值。类似地，`y_start` 和 `y_end` 捕捉 y 的空间边界。
- en: '![The grid spans x_start to x_end along the x‐axis and y_start to y_end along
    the y‐axis. the grid has 6 bins along each dimension, and the resulting bin widths
    are shown. ](image_fi/502604c08/f08008.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![该网格从 x_start 到 x_end 跨越 x 轴，从 y_start 到 y_end 跨越 y 轴。网格在每个维度上有 6 个箱子，结果箱子的宽度如图所示。](image_fi/502604c08/f08008.png)'
- en: 'Figure 8-8: A grid with specified starting and ending values along each dimension'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8：一个沿每个维度指定起始和结束值的网格
- en: 'We can derive some top-level information from the number of bins and the spatial
    bounds, but we often want to store that additional information about the grid
    for convenience. Precomputing the width of the bins along each dimension simplifies
    later code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从箱子数量和空间边界中推导出一些顶层信息，但为了方便起见，我们通常希望存储有关网格的额外信息。预计算每个维度上箱子的宽度可以简化后续的代码：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Other useful information might include the total number of points stored in
    the grid or the number of empty bins. We can track all this information in a composite
    data structure. For two-dimensional data, our typical data structure would look
    like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的信息可能包括存储在网格中的总点数或空箱子的数量。我们可以在一个复合数据结构中跟踪所有这些信息。对于二维数据，我们典型的数据结构可能如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For a fixed-size grid, we can map from a point’s spatial coordinates to the
    grid’s bin using a simple mathematical computation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于固定大小的网格，我们可以通过简单的数学计算，将一个点的空间坐标映射到网格的箱子中：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The switch from “one bin, one value” to “spatial partitioning” has important
    consequences beyond index mapping. It means that we can no longer store the data
    as a set of fixed bins in the computer’s memory. Each square could contain an
    arbitrary number of data points. Each grid square needs its own internal data
    structure to store its points. One common and effective data structure for storing
    points within the bin is a linked list like the one in [Figure 8-9](#figure8-9).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从“一个箱子，一个值”到“空间划分”的转换不仅对索引映射有重要影响，还意味着我们不能再将数据存储为计算机内存中的一组固定箱子。每个方格可能包含任意数量的数据点。每个网格方格需要拥有自己的内部数据结构来存储其数据点。存储箱子内数据点的一种常见且有效的数据结构是链表，如图
    [8-9](#figure8-9) 所示。
- en: '![A grid shown as a list of four bins (a flattened matrix), each pointing to
    the start of a linked list of points. The first three bins contain three points,
    and the final bin (xbin = 1, ybin = 1) includes two points.](image_fi/502604c08/f08009.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![一个网格显示为四个箱子的列表（一个扁平化的矩阵），每个箱子指向一个数据点链表的起始位置。前三个箱子包含三个点，而最后一个箱子（xbin = 1，ybin
    = 1）包含两个点。](image_fi/502604c08/f08009.png)'
- en: 'Figure 8-9: A representation of the data structure used to store points in
    a grid'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-9：用于存储网格中点的结构表示
- en: 'Each bin stores the pointer to the head of a linked list, which contains all
    the points in that bin. We accomplish this with another, internal data structure
    to store individual points:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个箱子存储指向链表头部的指针，链表包含该箱子中的所有点。我们通过另一个内部数据结构来存储每个点，从而实现这一点：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Alternatively, we could use the `LinkedListNode` data structure from Chapter
    3 and store a pair to represent the *x*, *y* coordinates.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们也可以使用第 3 章中的`LinkedListNode`数据结构，存储一个表示* x *，* y *坐标的对。
- en: Building Grids and Inserting Points
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建网格并插入点
- en: We construct a grid for our data set by allocating an empty grid data structure
    and iteratively inserting points using a single `FOR` loop over the data points.
    The high-level structure of the grid itself (the spatial bounds and number of
    bins along each dimension) is fixed at time of creation and does not change with
    the data added.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过分配一个空的网格数据结构并使用一个单独的`FOR`循环遍历数据点，逐步插入点来构建数据集的网格。网格本身的高级结构（每个维度的空间边界和箱子的数量）在创建时是固定的，并不会随着添加的数据发生变化。
- en: As shown in [Listing 8-2](#listing8-2), inserting a point consists of finding
    the correct bin and prepending the new point to the beginning of the linked list
    for that bin.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如[列表 8-2](#listing8-2)所示，插入点的过程包括找到正确的箱子并将新点添加到该箱子的链表的开头。
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-2: A function to insert a new point into a grid'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-2：插入新点到网格中的函数
- en: The code first computes the x and y bins for the new point ❶ and confirms that
    the new point falls within a valid bin ❷. While it’s always important to confirm
    that you are accessing an in-bounds array index whenever using an array, spatial
    data structures present additional concerns. We might not be able to predefine
    a fixed, finite grid that works for every possible future point. Therefore, it
    is important to consider what happens when previously unseen points fall outside
    the range covered by your spatial data structure. In this example, we return a
    Boolean to indicate whether or not the point could be inserted ❹. However, you
    might prefer other mechanisms, such as throwing an exception, depending on the
    programming language.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先计算新点的 x 和 y 箱子 ❶，并确认新点落在有效的箱子内 ❷。虽然在使用数组时始终重要的是确认你访问的是一个有效的数组索引，但空间数据结构还涉及额外的注意事项。我们可能无法为每一个可能的未来点预定义一个固定的、有限的网格。因此，考虑到当之前未见过的点落在空间数据结构所覆盖的范围之外时会发生什么，是非常重要的。在这个例子中，我们返回一个布尔值，表示该点是否能够被插入
    ❹。然而，根据不同的编程语言，你可能更喜欢其他机制，比如抛出异常。
- en: Once we have determined that point does fit within our grid, the code finds
    the appropriate bin. The code prepends the new point to the front of the list,
    creating a new list if the bin was previously empty ❸. The function concludes
    by returning `True` ❹.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定该点适合我们的网格，代码就会找到合适的箱子。如果该箱子之前是空的，代码会将新点添加到列表的前端，并创建一个新的列表 ❸。函数最后通过返回`True`
    ❹来结束。
- en: Deleting Points
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除点
- en: We can use a similar approach to insertion for deleting points from a grid.
    One additional difficulty is determining which point in the bin to delete. In
    many use cases, the user might insert arbitrarily close or even duplicate points
    into the grid. For example, if we are storing a list of ground coffees available
    to purchase, we might insert multiple points for a single coffee shop. Ideally,
    we use other identifying information, such as the name or ID number of the coffee,
    to determine which of the points to delete. In this section, we present the simple
    and general approach of deleting the first matching point in our linked list.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的插入方法来删除网格中的点。一个额外的难题是确定在箱子中要删除哪个点。在许多应用场景中，用户可能会向网格中插入任意接近甚至重复的点。例如，如果我们存储的是可供购买的地面咖啡列表，可能会为同一家咖啡店插入多个点。理想情况下，我们会使用其他识别信息，如咖啡的名称或
    ID 编号，来确定删除哪个点。在这一部分，我们展示了删除链表中第一个匹配点的简单通用方法。
- en: Due to the limited precision of floating-point variables, we also might not
    be able to use a direct equality test. In [Listing 8-3](#listing8-3), we use a
    helper function to find a point that is close enough. The `approx_equal` function
    returns `True` if both points are within a threshold distance in both dimensions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点变量的精度有限，我们也可能无法使用直接的相等测试。在[列表 8-3](#listing8-3)中，我们使用一个辅助函数来查找一个足够接近的点。`approx_equal`函数在两个点在两个维度上都在阈值距离内时返回`True`。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 8-3: Code to check whether two data points, represented as a pair of
    floating-point numbers, are equal'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-3：检查是否两个数据点（表示为一对浮动小数）相等的代码
- en: The code checks each dimension independently and compares the distance to a
    threshold. The threshold will depend on the use case and the numerical precision
    of your programming language. Generally, we want these thresholds to be just large
    enough to account for the float’s numerical precision.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码独立检查每个维度，并将距离与阈值进行比较。阈值将取决于使用场景和编程语言的数值精度。通常，我们希望这些阈值足够大，以便能够考虑浮动小数的数值精度。
- en: Deletion consists of finding the correct bin, traversing the linked list until
    we find a match, and removing the match by splicing it out of the list. Our delete
    function returns `True` if a point was found and deleted and `False` otherwise.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作包括找到正确的桶，遍历链表直到找到匹配项，然后通过将其从链表中切除来删除该匹配项。如果找到并删除了一个点，我们的删除函数返回`True`，否则返回`False`。
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code first computes the x and y bins for the new point ❶ and confirms that
    the new point falls within a valid bin ❷. Next it checks whether the target bin
    is empty ❸, returning `False` if it is.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先计算新点的 x 和 y 桶 ❶，并确认新点位于有效的桶内 ❷。接着，它检查目标桶是否为空 ❸，如果为空则返回`False`。
- en: If there are points to check, the code iterates through the list ❹. Unlike the
    code for insertion, we track both the current node and the previous one so that
    we can splice the target node out of the list. The code uses the `approx_equal`
    helper function from [Listing 8-3](#listing8-3) to test each point ❺. When it
    finds a matching point, it splices it out of the list, taking care to correctly
    handle the special case of the first node in the list ❻, and returns `True`. Thus,
    only the *first* matching point in the list is removed. If the current point does
    not match, the search continues to the next node in the list ❼. If the search
    finishes the entire list, the function returns `False` to indicate that no matching
    node was deleted.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有需要检查的点，代码会遍历列表 ❹。与插入代码不同，我们跟踪当前节点和前一个节点，以便能够从列表中将目标节点切除。该代码使用来自[示例 8-3](#listing8-3)的`approx_equal`辅助函数测试每个点
    ❺。当找到匹配的点时，它会将其从列表中切除，并正确处理列表中第一个节点的特殊情况 ❻，然后返回`True`。因此，只有列表中*第一个*匹配的点被删除。如果当前点不匹配，搜索将继续到列表中的下一个节点
    ❼。如果搜索完成整个列表，函数返回`False`，表示没有删除匹配的节点。
- en: Searches Over Grids
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格搜索
- en: 'Now that we’ve learned how to construct grid data structures, let’s use them
    to improve our nearest-neighbor searches. First, we examine the problem of pruning
    grid cells that are too far away, which will allow us to avoid unnecessary computations
    within grid cells. We then consider two basic searches: a linear scan over all
    the bins and an expanding search.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何构造网格数据结构，让我们使用它们来改善最近邻搜索。首先，我们检查修剪远离的网格单元的问题，这将使我们避免在网格单元内进行不必要的计算。接着，我们考虑两种基本的搜索方式：对所有桶的线性扫描和扩展搜索。
- en: Pruning Bins
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修剪桶
- en: The grid’s spatial structure allows us to limit how many points we need to check,
    excluding those outside the range we’re interested in (northern Florida). Once
    we have a candidate neighbor and its associated distance, we can use that distance
    to *prune bins**. Before checking the points in a bin, we ask whether *any* point
    within the bin’s spatial bounds could be closer than the current best distance.
    If not, we can ignore the bin.*
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的空间结构使我们能够限制需要检查的点的数量，排除掉那些不在我们感兴趣的范围内（佛罗里达州北部）。一旦我们得到了候选邻居及其相关的距离，我们可以利用这个距离来*修剪桶*。在检查桶内的点之前，我们会问是否*任何*位于桶空间范围内的点比当前最佳距离更近。如果没有，我们就可以忽略这个桶。
- en: '*Determining whether *any* point within a bin lies within a given distance
    from our target point may sound like a daunting task. However, if we are using
    Euclidean distance ![i08001](image_fi/502604c08/i08001.png), which we can encapsulate
    in this simple helper function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*确定桶内*任何*点是否在给定的距离内，可能听起来像是一个艰巨的任务。然而，如果我们使用欧几里得距离 ![i08001](image_fi/502604c08/i08001.png)，我们可以将其封装在这个简单的辅助函数中：'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: thenthe test boils down to simple mathematics. We start by finding the closest
    possible point in the grid cell and use that for our pruning test. Specifically,
    if the closest possible point in the grid cell is further than our current best
    candidate, there is no reason to check any of the actual points stored in the
    bin. They all must be further away. If a target point falls within the cell—that
    is, if its x and y values are within the cell’s x and y ranges, respectively—the
    distance to the cell (and thus the closest possible point) is zero.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试简化为简单的数学运算。我们首先找到网格单元中最接近的点，并将其用于剪枝测试。具体而言，如果网格单元中最接近的点距离当前最佳候选点更远，则没有理由检查存储在该单元格中的任何实际点。它们都必须更远。如果目标点位于单元格内——也就是说，如果其
    x 和 y 值分别在单元格的 x 和 y 范围内——则到单元格的距离（因此最接近的点的距离）为零。
- en: If the point falls outside the cell, then the closest possible point in the
    cell must lie on the edge of the cell. [Figure 8-10](#figure8-10) shows a variety
    of points outside the grid cell and the corresponding closest points within the
    cell. For points outside the grid cell, we need to compute the distance to the
    closest edge point.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点位于单元格外部，则单元格中最接近的点必须位于单元格的边缘。[图 8-10](#figure8-10) 显示了网格单元外的多种点以及单元格内相应的最接近点。对于网格单元外的点，我们需要计算到最近边缘点的距离。
- en: '![Eight target points shown as gray circles and their corresponding closest
    points within the cell. The closest points to targets outside the cell are on
    the cell’s perimeter.](image_fi/502604c08/f08010.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![八个目标点显示为灰色圆圈，它们在单元格内的最接近点。单元格外的目标点的最接近点位于单元格的边界。](image_fi/502604c08/f08010.png)'
- en: 'Figure 8-10: Points outside a grid cell (gray circles) and the corresponding
    closest points within the cell (solid circles)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-10：网格单元外的点（灰色圆圈）及单元格内相应的最接近点（实心圆圈）
- en: 'We can compute the Euclidean distance between a point and the nearest edge
    of a grid’s bin by considering each dimension independently. We find the minimum
    distance needed to shift the x value within the bin’s range and the minimum distance
    to shift the y value within the bin’s range. For the grid bin (*xbin*, *ybin*),
    the minimum and maximum x and y dimensions are:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过分别考虑每个维度，计算一个点到网格单元边缘的欧几里得距离。我们找到将 x 值移到单元格范围内所需的最小距离，以及将 y 值移到单元格范围内所需的最小距离。对于网格单元格（*xbin*，*ybin*），最小和最大
    x 和 y 维度为：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can compute the distance as follows (in the case of Euclidean distance):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式计算距离（以欧几里得距离为例）：
- en: '![g08002](image_fi/502604c08/g08002.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![g08002](image_fi/502604c08/g08002.png)'
- en: where
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: IF *x* < *x*_*min* THEN *x*[dist] *= x*_*min* − *x*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x* < *x*_*min*，则 *x*[dist] *= x*_*min* − *x*
- en: IF *x*_*min* ≤ *x* ≤ *x*_*max* THEN *x*[dist] = 0
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x*_*min* ≤ *x* ≤ *x*_*max*，则 *x*[dist] = 0
- en: IF *x* > *x*_*max* THEN *x*[dist] = *x* – *x*_*max*
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x* > *x*_*max*，则 *x*[dist] = *x* – *x*_*max*
- en: and
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以及
- en: IF *y* < *y_min* THEN *y*[dist] = *y_min* − *y*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *y* < *y_min*，则 *y*[dist] = *y_min* − *y*
- en: IF *y_min* ≤ *y* ≤ *y_max* THEN *y*[dist] = 0
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *y_min* ≤ *y* ≤ *y_max*，则 *y*[dist] = 0
- en: IF *y* > *y_max* THEN *y*[dist] = *y* − *y_max*
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*y* > *y_max*，则 *y*[dist] = *y* − *y_max*
- en: If the minimum distance to any possible point in the bin is greater than that
    of our current closest point, then nothing in the bin could replace the current
    closest point. We can ignore the entire bin!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到单元格中任何可能点的最小距离大于当前最接近点的距离，则单元格中的任何内容都无法替代当前的最接近点。我们可以忽略整个单元格！
- en: The code for computing the minimum distance from a point to a bin can be encapsulated
    into the following helper function. This function implements the mathematical
    logic above.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 计算点到单元格最小距离的代码可以封装成以下帮助函数。该函数实现了上述数学逻辑。
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 8-4: A helper function that computes the closest distance from a target
    point to a given bin'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-4：一个帮助函数，用于计算目标点到给定单元格的最短距离
- en: 'The code starts by checking that the bin indices are valid ❶. In this example,
    we use an infinite distance to indicate that the function’s caller has referenced
    an invalid bin. This logic allows us to use this lookup function in pruning computations
    that might ask about invalid bins. However, this may lead to confusion: Why is
    the function returning any distance for an invalid bin? Depending on the usage,
    it might be preferable to throw an error indicating that the bin indices are invalid.
    Either way, the function’s behavior should be clearly documented for users.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查容器索引是否有效 ❶。在这个例子中，我们使用无穷大作为距离，表示函数的调用者引用了一个无效的容器。这种逻辑使得我们可以在剪枝计算中使用此查找函数，查找可能涉及无效容器的情况。然而，这可能会导致混淆：为什么对于无效的容器，函数会返回某个距离？根据使用情况，可能更倾向于抛出错误，指出容器索引无效。无论哪种方式，函数的行为应当清晰地记录在文档中，供用户参考。
- en: The remainder of the code proceeds through the distance logic above for the
    x and y dimensions (❷ and ❸, respectively). The code computes the minimum and
    maximum values for the bin, compares them with the point’s value along that dimension,
    and computes the distance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 代码接下来按照上述的距离逻辑继续执行 x 和 y 维度的计算（❷ 和 ❸）。代码计算容器的最小值和最大值，将它们与点在该维度上的值进行比较，并计算距离。
- en: To visualize this distance test, imagine that a raucous game of catch sends
    a ball over our fence into the yard of our friendly, but exceedingly lazy, neighbor.
    They will return the ball, of course, but without exerting any more effort than
    absolutely necessary. What is the shortest distance they need to throw the ball
    in order for it to (just barely) return to our yard? If their longitude already
    falls within the bounds of our yard, they will throw in a pure north or south
    direction so as not to add any unnecessary east/west distance. In the end, their
    throw always lands exactly on the fence such that it falls back into our property.
    Our neighbor may be lazy, but they have some impressive throwing skills.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了直观地理解这个距离测试，想象一下，一个喧闹的接球游戏把球扔过我们的栅栏，落到我们友好但极其懒惰的邻居院子里。他们当然会把球扔回来，但不会付出超过绝对必要的任何努力。他们需要扔球的最短距离是多少，才能（勉强）把球送回我们的院子？如果他们的经度已经在我们院子的范围内，他们会朝纯粹的北方或南方扔球，以避免增加不必要的东西/西方向的距离。最终，他们的投掷总是正好落在栅栏上，使得球重新掉回我们的财产。我们的邻居虽然懒惰，但投掷技巧可真是惊人。
- en: Linear Scan Over Bins
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性扫描过容器
- en: The simplest approach to searching a grid would iterate through all the grid’s
    bins using a linear scan and only check those that could contain a potential nearest
    neighbor. This is not a particularly good algorithm, but it provides an easy introduction
    to working with and pruning bins.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索网格的最简单方法是使用线性扫描遍历所有网格容器，并只检查那些可能包含潜在最近邻居的容器。这不是一个特别好的算法，但它提供了一个简单的引入，帮助理解如何操作和剪枝容器。
- en: 'The linear search algorithm simply applies the aforementioned minimum distance
    test to each bin before checking its contents:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索算法简单地对每个容器应用前述的最小距离测试，然后检查其内容：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 8-5: A nearest-neighbor search that uses a linear scan over a grids
    bin with pruning tests on each bin.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-5：使用线性扫描过网格容器并在每个容器上进行剪枝测试的最近邻搜索。
- en: The code starts by setting the best distance to infinity to indicate that no
    best point has been found so far ❶. Then the algorithm scans through each bin
    using a pair of nested `WHILE` loops that iterate over the x and y bins ❷. Before
    checking the individual points in the bin, the code performs a minimum distance
    test to check whether *any* point in the bin could be a better neighbor ❸. If
    the bin may contain better neighbors, the code uses a third `WHILE` loop to iterate
    through the linked list of points in the bin ❹. It tests the distance to each
    point and compares it with the best distance found so far ❺. The function completes
    by returning the best candidate found, which may be `null` if the grid is empty
    ❻.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先将最佳距离设置为无穷大，表示目前尚未找到最佳点 ❶。然后，算法使用一对嵌套的`WHILE`循环对每个容器进行扫描，循环遍历 x 和 y 容器 ❷。在检查容器中的各个点之前，代码先执行最小距离测试，以检查容器中的*任何*点是否可能是更好的邻居
    ❸。如果容器可能包含更好的邻居，代码使用第三个`WHILE`循环来遍历容器中点的链表 ❹。它测试与每个点的距离，并将其与迄今为止找到的最佳距离进行比较 ❺。函数最后返回找到的最佳候选点，如果网格为空，则可能返回`null`
    ❻。
- en: The algorithm in [Listing 8-5](#listing8-5) allows us to prune out entire bins,
    along with all the points they contain, whenever we determine that minimum distance
    to any point in the bin is greater than the distance to the best point seen so
    far. If we have a large number of points per bin, this can lead to significant
    savings. However, if the grid is sparsely populated, we might end up paying more
    to check each of the bins than we would have if we’d checked each point individually.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-5](#listing8-5)中的算法允许我们在确定某个箱子内的任何点到目标点的最小距离大于目前为止找到的最佳点的距离时，剔除整个箱子及其包含的所有点。如果每个箱子中的点数较多，这将带来显著的节省。然而，如果网格稀疏，我们可能会花费更多的时间去检查每个箱子，而不是逐个检查每个点。'
- en: Unlike the `GridInsert` function in [Listing 8-2](#listing8-2), our linear scan
    works with target points inside or outside the grid’s spatial bounds. `GridLinearScanNN`
    does not need to map the target point to a bin and therefore does not care if
    the target is on the grid itself. It will still return the nearest neighbor from
    the grid (or `null` if the grid is empty). This provides an additional level of
    flexibility to our nearest-neighbor search that can be useful when encountering
    new, non-typical targets.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与[清单 8-2](#listing8-2)中的`GridInsert`函数不同，我们的线性扫描可以处理网格空间边界内外的目标点。`GridLinearScanNN`不需要将目标点映射到某个箱子，因此不关心目标是否位于网格本身。它仍然会返回网格中的最近邻点（如果网格为空，则返回`null`）。这为我们的最近邻搜索提供了额外的灵活性，特别是在遇到新的、非典型的目标时。
- en: Ideal Expanding Search over Bins
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理想的箱子扩展搜索
- en: While the linear scan algorithm allows us to prune out entire bins based on
    their minimum distance to our target point, we’re still not using all the spatial
    information at our disposal. We waste a significant amount of computation by testing
    bins that are far from our target point. We can do better if we prioritize bins
    by their proximity to their target, first searching the bins closest to our target
    point and halting the search when the remaining bins are further than the nearest
    neighbor we have found so far. We call this an *expanding search*, because we
    effectively expand out from the bin containing the target point until we have
    found the nearest neighbor.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然线性扫描算法允许我们根据目标点的最小距离剔除整个箱子，但我们仍然没有充分利用手头的所有空间信息。通过测试距离目标点较远的箱子，我们浪费了大量计算。如果我们根据箱子与目标的接近程度来优先搜索箱子，先搜索离目标点最近的箱子，并在剩余的箱子距离我们找到的最近邻点更远时停止搜索，这样会更有效。我们称之为*扩展搜索*，因为我们实际上是从包含目标点的箱子扩展出去，直到找到最近的邻居。
- en: To visualize this improved scanning method, imagine a panicked search for our
    car keys in the morning. We start with the area (comparable to a grid cell) where
    the car keys would be if we had stored them correctly. We inspect every inch of
    the kitchen counter before admitting that we must have misplaced the keys. Spiraling
    out to other parts of the house (that is, other bins), we check nearby locations,
    such as the coffee table and the floor, before venturing further and further away.
    This search continues, exploring less and less likely locations, until we find
    the keys mysteriously sitting in the sock drawer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形象地说明这种改进的扫描方法，想象一下早晨慌乱地寻找车钥匙。我们从车钥匙应该放置的区域开始（类似于一个网格单元）。我们仔细检查了厨房台面，直到承认钥匙肯定被放错了地方。然后，我们开始检查家中的其他地方（即其他箱子），先检查咖啡桌和地板附近的地方，随后继续向更远的地方搜索。这个搜索不断进行，探索那些不太可能的地方，直到我们发现钥匙神奇地出现在袜子抽屉里。
- en: For an example of an expanding scan in action, consider our map overlaid with
    a four-by-four grid, as shown in [Figure 8-11](#figure8-11). We find the closest
    bin to our target point by asking, “Into which bin does our target point fall?”
    and using the grid index-mapping equations. Since it is possible that our target
    point falls outside the grid, we might also need to shift the computed bin indices
    into the valid range. In [Figure 8-11](#figure8-11), the target point is in the
    third bin up in the leftmost column (*xbin* = 0 and *ybin* = 2 in our notation).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以[图 8-11](#figure8-11)为例，考虑我们的地图上叠加了一个四乘四的网格。我们通过问“我们的目标点落在哪个箱子里？”并使用网格索引映射公式来找到离目标点最近的箱子。由于目标点可能位于网格外部，我们还可能需要将计算出的箱子索引调整到有效范围内。在[图
    8-11](#figure8-11)中，目标点位于最左列第三个箱子里（在我们的符号中，*xbin* = 0，*ybin* = 2）。
- en: '![The map points from figure 8‐3 placed in a four‐by‐four grid.](image_fi/502604c08/f08011.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 8-3中的地图点，放置在四乘四的网格中。](image_fi/502604c08/f08011.png)'
- en: 'Figure 8-11: A 4×4 grid of two-dimensional points'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-11：一个二维点的4×4网格
- en: We can start our search in the target point’s bin and test every point in that
    bin. As long as the bin isn’t empty, we are guaranteed to find our first *candidate*
    nearest neighbor, as shown in [Figure 8-12](#figure8-12). Unfortunately, since
    we’re not organizing or sorting the points within each bin, we can’t do better
    in this case than a linear scan through that bin’s points. Of course, if the initial
    bin is empty, we must progress our search outward to neighboring bins, incrementally
    trying further and further bins until we find one containing a data point to be
    our candidate nearest neighbor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从目标点所在的格子开始搜索，并测试该格子中的每个点。只要该格子不为空，我们就能找到我们的第一个*候选*最近邻，如[图8-12](#figure8-12)所示。不幸的是，由于我们没有在每个格子内对点进行组织或排序，因此在这种情况下，我们无法比对该格子中的点进行线性扫描更高效。当然，如果初始格子为空，我们必须向外扩展搜索到相邻的格子，逐步尝试更远的格子，直到找到包含数据点的格子作为我们的候选最近邻。
- en: '![The four‐by‐four grid of map points from Figure 8‐11 with a dashed line to
    the candidate nearest neighbor. The first candidate falls within the same bin.](image_fi/502604c08/f08012.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图8-11中的四×四网格地图点，带有虚线指向候选最近邻。第一个候选点位于同一个格子内。](image_fi/502604c08/f08012.png)'
- en: 'Figure 8-12: An initial candidate nearest neighbor found in the same bin as
    the target point'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-12：在与目标点相同的格子中找到的初始候选最近邻
- en: Once we obtain this initial candidate for nearest neighbor, we are still not
    done. The candidate is just that—a candidate. It’s possible there could be a closer
    point in one of the adjacent bins. This is more likely if our target point is
    near the edge of a bin. In [Figure 8-13](#figure8-13), the dashed circle represents
    the space of all points that are closer to or at the same distance from the current
    candidate. Any other point that falls within the circle could be the true nearest
    neighbor. The shaded grid cells are those that overlap this region.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了这个初步的最近邻候选点，我们还没有完成。这个候选点仅仅是一个候选。很可能在相邻的格子中存在一个更近的点。如果目标点靠近格子的边缘，这种情况更为可能。在[图8-13](#figure8-13)中，虚线圆圈表示所有比当前候选点更近或距离相等的点的空间。任何落在圆圈内的点都有可能是实际的最近邻。被阴影标示的网格单元就是与该区域重叠的部分。
- en: '![The four‐by‐four grid of map points from Figure 8‐11 with a dotted circle
    showing the region of space with distance closer than or equal to the current
    candidate neighbor. Four grid cells overlapping this circle are shaded, indicating
    that they could contain a closer neighbor.](image_fi/502604c08/f08013.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图8-11中的四×四网格地图点，带有虚线圆圈，显示距离当前候选邻居相等或更近的区域。与此圆圈重叠的四个网格单元被阴影标示，表明它们可能包含更近的邻居。](image_fi/502604c08/f08013.png)'
- en: 'Figure 8-13: A candidate nearest neighbor and the gridcells that could contain
    points closer to the target'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-13：候选最近邻和可能包含比目标点更近的点的网格单元
- en: To visualize why we need to continue to check other bins, imagine you want to
    determine the closest person to you at an outdoor party. You’re telling a particularly
    embarrassing story, involving the use of spoiled milk in your coffee, and want
    to make sure that only the intended audience hears you. Your best friend standing
    by the house might appear to be closest to you, but, if you’re near your fence,
    you also need to consider people on the other side. If your neighbor is planting
    flowers along their side of the fence, they might actually be closer and hear
    all of the humiliating details. You can’t discount them because there is a fence
    in the way. This is why we always check neighboring bins—and why you should always
    be careful about telling embarrassing stories in public.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解为什么我们需要继续检查其他格子，假设你想在一个户外派对上找出离你最近的人。你正在讲一个特别尴尬的故事，涉及将变质的牛奶放入咖啡中，你希望确保只有目标听众能听到。站在房子旁边的最好朋友看起来可能离你最近，但如果你靠近围栏，你还需要考虑另一边的人。如果你的邻居正在沿着他们那边的围栏种花，他们可能实际上离你更近，能听到所有那些令人羞愧的细节。你不能因为围栏挡住了视线就忽视他们。这就是为什么我们总是检查相邻的格子——也就是为什么你在公共场合讲尴尬故事时需要小心。
- en: We continue to expand out the search to include *all* nearby bins until we can
    guarantee that no possible point in the remaining bins could be closer than our
    candidate nearest neighbor. Once we have checked all the bins within the radius
    of our nearest-neighbor candidate, we can ignore any bins beyond that. We don’t
    even need to check their distance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续扩展搜索，包含*所有*附近的单元格，直到可以保证剩余的单元格中没有比我们候选的最近邻更近的点。一旦我们检查了所有在最近邻半径范围内的单元格，就可以忽略超出该范围的单元格，甚至不需要检查它们的距离。
- en: The tradeoff for this improved grid search is algorithmic complexity. Instead
    of scanning across every one of the bins—an algorithm we could implement with
    a nested pair of `FOR` loops—the optimized search spirals out from a single bin,
    exploring further and further away until we can prove that none of the unexplored
    bins could contain a better neighbor. This requires additional logic in the search
    order (outward spiral), bounds checking (avoiding testing bins off the edge of
    the grid), and termination criteria (knowing when to stop). The next section presents
    a simple example of an expanding search for illustrative purposes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改进的网格搜索的权衡是算法复杂度。我们不再扫描每一个单元格——这个算法可以通过嵌套的`FOR`循环来实现——而是优化后的搜索从一个单元格开始螺旋式向外扩展，逐步探查更远的区域，直到我们能够证明没有未探索的单元格可能包含更好的邻居。这需要在搜索顺序（外向螺旋）、边界检查（避免测试网格边缘外的单元格）和终止条件（知道何时停止）中增加额外的逻辑。下一节将展示一个简化扩展搜索的简单示例，用于说明目的。
- en: Simplified Expanding Search
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化的扩展搜索
- en: 'Let’s consider a simplified (and non-optimized) version of an expanding search
    that moves outward in a diamond-shaped pattern. Instead of executing a perfect
    spiral out from the initial bin, the search uses an increasing distance from an
    initial bin. For simplicity of implementation, we will use a Manhattan distance
    on the grid indices that counts the steps between grid cells:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简化版（且未优化）的扩展搜索，该搜索以菱形模式向外移动。与从初始单元格执行完美的螺旋扩展不同，搜索使用了从初始单元格开始的逐步增大的距离。为了简化实现，我们将使用网格索引上的曼哈顿距离，它计算网格单元之间的步数：
- en: '*d* = |*xbin*[1] − *xbin*[2]| + |*ybin*[1] − *ybin*[2]|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*d* = |*xbin*[1] − *xbin*[2]| + |*ybin*[1] − *ybin*[2]|'
- en: While this search pattern is unlikely to be efficient for grids with drastically
    different bin widths along each dimension, it provides an easy-to-follow illustration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种搜索模式对于在每个维度上具有显著不同单元格宽度的网格效率较低，但它提供了一个易于理解的示例。
- en: '[Figure 8-14](#figure8-14) shows the first four iterations of the search. During
    the first iteration in [Figure 8-14](#figure8-14)(a), we search the bin containing
    the target point (zero steps away). During the next iteration in [Figure 8-14](#figure8-14)(b),
    we search all bins a single step away. On each subsequent iteration, we search
    all the bins that are one step further out.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-14](#figure8-14)显示了搜索的前四次迭代。在[图 8-14](#figure8-14)(a)的第一次迭代中，我们搜索包含目标点的单元格（距离为零步）。在接下来的[图
    8-14](#figure8-14)(b)迭代中，我们搜索所有距离一步的单元格。在每次后续的迭代中，我们搜索所有距离目标点更远的一步单元格。'
- en: '![Four iterations of an example expanding search. In the first iteration, a
    single bin containing the target point is shaded. In the second iteration, four
    bins, all one step away, are shaded. In the third iteration, eight bins, all two
    steps away, are shaded.](image_fi/502604c08/f08014.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![扩展搜索的四次迭代示例。在第一次迭代中，包含目标点的单元格被阴影标记。在第二次迭代中，四个单元格，它们距离目标点一步之遥，被阴影标记。在第三次迭代中，八个单元格，它们距离目标点两步之遥，被阴影标记。](image_fi/502604c08/f08014.png)'
- en: 'Figure 8-14: The first four iterations of a simplified expanding search on
    a grid'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-14：网格上简化扩展搜索的前四次迭代
- en: We start with a helper function that checks whether any points within a specified
    bin are closer to our target point (`x`, `y`) than a given `threshold`. This function
    encodes our linear scan through the bin’s points. If there is at least one point
    closer than `threshold`, the function returns the closest such point. The use
    of a threshold value will allow us to use the helper function to compare the bin’s
    points to the best candidates from other bins.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个辅助函数，检查指定单元格内的任何点是否比给定的`threshold`更接近目标点(`x`, `y`)。这个函数实现了对单元格点的线性扫描。如果至少有一个点比`threshold`更近，函数将返回距离最近的点。使用阈值可以让我们使用此辅助函数将单元格的点与其他单元格的最佳候选进行比较。
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 8-6: A helper function that returns the closest point in a bin to the
    target point as long as it is below the given threshold'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-6：一个辅助函数，返回距离目标点最近的单元格，只要该单元格低于给定的阈值
- en: The code starts with a safety check that we are accessing a valid bin ❶. If
    not, it returns `null` to indicate that there are no valid points. The code then
    uses a `WHILE` loop to iterate through each point in the bin ❸, computing its
    distance from the target point, comparing it to the best distance seen so far,
    and saving it as the new best candidate if it is closer ❹. The code finishes by
    returning the closest point ❺. Since the code initially set `best_dist` to the
    `threshold` value before checking any points ❷, it will only mark points with
    a distance less than `threshold` as new candidates. The function returns `null`
    if none of the bin’s points are closer than `threshold`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先进行安全检查，确保我们正在访问一个有效的区域 ❶。若无效，则返回`null`，表示没有有效的点。接着，代码使用`WHILE`循环遍历该区域内的每个点
    ❸，计算其与目标点的距离，将其与迄今为止看到的最佳距离进行比较，并在更近时保存为新的最佳候选点 ❹。最后，代码返回最接近的点 ❺。由于代码在检查任何点之前，已将`best_dist`设置为`threshold`值
    ❷，因此只有距离小于`threshold`的点才会被标记为新的候选点。如果该区域内没有点距离小于`threshold`，函数将返回`null`。
- en: The code for performing the expanding search works by iterating through a different
    number of steps and checking all bins that can be reached in that number of steps.
    As in previous searches, we track the best candidate seen so far. The search concludes
    after iteration *d* if there are no valid grid cells *d* steps away that could
    contain a closer neighbor.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 执行扩展搜索的代码通过不同步长的迭代，检查在该步长内可以到达的所有区域。与之前的搜索一样，我们会跟踪目前为止看到的最佳候选点。如果在*d*次迭代后，没有任何有效的网格单元在*d*步之内能包含一个更近的邻居，搜索就会结束。
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code starts by finding the closest bin within the grid to our target point,
    taking care to map targets outside the grid to their closest bin in the grid ❶.
    The resulting bin (`xb`, `yb`) will be the starting point for the search. By mapping
    bins outside the grid to a valid bin, the function can return the nearest neighbor
    for target points that lie outside the grid itself.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先通过查找网格中离目标点最近的区域来开始，特别注意将网格外的目标点映射到网格内最近的区域 ❶。得到的区域（`xb`，`yb`）将作为搜索的起始点。通过将网格外的区域映射到有效区域，函数可以返回网格外目标点的最近邻。
- en: The code then uses a `WHILE` loop to explore outward from this initial bin by
    increasing amounts ❷. The variable `steps` tracks the distance used for the current
    iteration. The `WHILE` loop is conditioned on the variable `explore`, which indicates
    that the next iteration may include a valid bin and we should thus continue exploring
    at the next value of `steps`. As we will see shortly, the `WHILE` loop terminates
    as soon as it completes a full iteration where *none* of the bins visited could
    have held a closer neighbor.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，代码通过使用`WHILE`循环，从这个初始区域开始逐步向外扩展 ❷。变量`steps`跟踪当前迭代使用的步长。`WHILE`循环的条件由变量`explore`控制，这表示下一次迭代可能会包含一个有效的区域，因此我们应该继续在下一个步长值下进行探索。正如我们稍后会看到的，`WHILE`循环会在完成一次迭代后终止，如果*没有*一个区域的邻居比当前的更近。
- en: Within the main `WHILE` loop, the code iterates across the different x-index
    offsets from `-steps` to `steps` as though scanning horizontally across the grid
    ❸. The total number of steps in the x-direction and y-direction are fixed by `steps`,
    so the code can programmatically compute the remaining number of steps to use
    in the (positive or negative) y-direction ❹. Starting with the negative y-direction,
    the code uses `MinDistToBin` from [Listing 8-4](#listing8-4) to check whether
    the bin indices are valid and, if so, determine the distance to that bin ❺. It
    can skip any bins that are invalid or too far away. If the bin could contain a
    closer point than our current candidate, the code uses `GridCheckBin` from [Listing
    8-6](#listing8-6) to check for such a point ❻. Whenever a closer point has been
    found, the code saves it as the new closest candidate and updates its estimate
    of the closest distance. The second `IF` block performs the same checks in the
    positive y-direction as long as the y-offset is not zero (in which case we have
    already checked the bin in the negative y-direction) ❽.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`WHILE`循环中，代码会遍历从`-steps`到`steps`的不同x索引偏移，就像是在网格上水平扫描一样❸。x方向和y方向的总步数由`steps`确定，因此代码可以通过编程计算在（正向或负向）y方向上还需使用的步数❹。从负y方向开始，代码使用来自[Listing
    8-4](#listing8-4)的`MinDistToBin`来检查桶的索引是否有效，如果有效，则确定到该桶的距离❺。它可以跳过任何无效的或距离太远的桶。如果该桶可能包含比当前候选点更接近的点，代码会使用来自[Listing
    8-6](#listing8-6)的`GridCheckBin`来检查是否存在这样的点❻。每当找到更接近的点时，代码将其保存为新的最近候选点，并更新其对最短距离的估计。第二个`IF`块在y方向正向的情况下执行相同的检查，只要y偏移不为零（如果为零，则已经检查过负y方向的桶）❽。
- en: During an iteration of the outer `WHILE` loop ❷, the code resets `explore` to
    `False`. It later updates `explore` to `True` if any of the calls to `MinDistToBin`
    indicate that a bin could contain a closer neighbor (❼ and ❾). Thus, the outer
    loop continues until it reaches a number of steps where every bin is either further
    than `best_d` or lies off the grid (and is therefore invalid). While other termination
    criteria may provide more exact tests and terminate earlier, we use this rule
    in the code due to its simplicity.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部`WHILE`循环的一个迭代过程中❷，代码将`explore`重置为`False`。如果任何调用`MinDistToBin`的结果表明某个桶可能包含更接近的邻居（❼和❾），代码会将`explore`更新为`True`。因此，外部循环会继续，直到达到一个步骤数，在这个步骤数下，每个桶要么距离`best_d`更远，要么位于网格之外（因此是无效的）。虽然其他终止条件可能提供更精确的测试并提前终止，但由于其简便性，我们在代码中使用了这个规则。
- en: The Importance of Grid Size
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格大小的重要性
- en: The size of our grid’s bins has a massive impact on the efficiency of our search.
    The larger our bins, the more points we may need to check per bin. Remember that
    our grid searches still do a linear scan through the points within each visited
    bin. However, partitioning the grid into finer bins has tradeoffs both in terms
    of memory and the number of empty bins we may encounter. As we shrink the size
    of the grid’s bins, we often need to search more individual bins before we even
    find the first candidate nearest neighbor and the cost of checking bins increases.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网格中桶的大小对搜索效率有巨大的影响。桶越大，我们可能需要检查每个桶中的更多点。记住，我们的网格搜索仍然会对每个访问到的桶中的点执行线性扫描。然而，将网格划分为更细的桶在内存和可能遇到的空桶数量上都有权衡。当我们缩小网格桶的大小时，我们通常需要搜索更多的单个桶，才能找到第一个候选最近邻，而且检查桶的成本也会增加。
- en: '[Figure 8-15](#figure8-15) shows an extreme case where the grid is too fine.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 8-15](#figure8-15)显示了一个极端的情况，其中网格太细。'
- en: '![The map points from figure 8‐3 placed in a 17‐by‐17 grid. There are now 36
    bins that are closer than the nearest neighbor.](image_fi/502604c08/f08015.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图8-3中的地图点被放置在一个17x17的网格中。现在有36个桶比最近的邻居更近。](image_fi/502604c08/f08015.png)'
- en: 'Figure 8-15: A fine grid in which most of the bins are empty'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-15：一个细致的网格，其中大多数桶是空的
- en: In [Figure 8-15](#figure8-15), we must search 36 bins in order to find the nearest
    neighbor. This is clearly more expensive than the example in [Figure 8-13](#figure8-13),
    where we only needed to check four bins and two individual points. Sadly, it might
    even be more expensive than the linear scan search, which checked every one of
    the 11 data points.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Figure 8-15](#figure8-15)中，我们必须搜索36个桶才能找到最近的邻居。这显然比[Figure 8-13](#figure8-13)中的例子更昂贵，在那个例子中我们只需要检查四个桶和两个单独的点。遗憾的是，它甚至可能比线性扫描搜索更昂贵，后者检查了所有11个数据点。
- en: Consider this in the context of our search for coffee shops. If we partition
    the space too finely, such as in 1 m by 1 m squares, we’ll be facing a grid that
    contains mostly empty bins. If we partition the space more coarsely, such as 5
    km by 5 km squares, we might bucket entire cities and their multitudes of coffee
    shops in a single bin while still leaving (to our utmost horror) a large number
    of bins nearly or completely empty.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将其置于我们寻找咖啡店的背景下。如果我们将空间划分得过于精细，比如 1 米 × 1 米的方格，那么我们将面临一个大多数单元格都是空的网格。如果我们将空间划分得更粗糙，比如
    5 公里 × 5 公里的方格，那么我们可能会将整个城市及其成群的咖啡店归为一个单元格，而仍然留下（令人震惊）大量几乎为空的单元格。
- en: The optimal grid size often depends on multiple factors, including the number
    of points and their distribution. More complex techniques, such as non-uniform
    grids, can be used to dynamically adapt to the data. In the next chapter, we will
    consider several tree-based data structures that dynamically enable this type
    of adaptation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最优的网格大小通常取决于多个因素，包括点的数量及其分布。更复杂的技术，例如非均匀网格，可以用来动态适应数据。在下一章中，我们将讨论几种基于树的数据结构，它们能够动态地实现这种适应。
- en: Beyond Two Dimensions
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越二维
- en: 'The grid-based techniques developed for two dimensions can be scaled to higher
    dimensional data as well. We might need to search a multi-floor office building
    for the closest available conference room. We can search for nearest neighbors
    in three-dimensional data by incorporating the *z* coordinate into our distance
    computation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为二维开发的基于网格的技术也可以扩展到高维数据。我们可能需要在一个多层的办公大楼中寻找最近的可用会议室。我们可以通过将 *z* 坐标纳入距离计算来搜索三维数据中的最近邻：
- en: '![g08003](image_fi/502604c08/g08003.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![g08003](image_fi/502604c08/g08003.png)'
- en: 'Or, more generally, we can define Euclidean distance over *d*-dimensional data
    as:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更一般地，我们可以定义 *d* 维数据的欧几里得距离为：
- en: '![g08004](image_fi/502604c08/g08004.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![g08004](image_fi/502604c08/g08004.png)'
- en: where *x*[i][*d*]is the *d*th dimension of the *i*th data point.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *x*[i][*d*] 是第 *i* 个数据点的 *d* 维度。
- en: 'Higher-dimensional data comes with another challenge for the grid-based approach
    we’ve considered in this chapter: it requires us to partition the space along
    more dimensions. The space required to store such data structures explodes quickly
    as we consider higher dimensions. For data with *D* dimensions and *K* bins per
    dimension, we need *K*^(*D*) individual bins! This can require a huge amount of
    memory. [Figure 8-16](#figure8-16) shows a three-dimensional example, a 5×5×5
    grid, which already includes a large number of individual bins.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 高维数据为我们在本章中讨论的基于网格的方法带来了另一个挑战：它要求我们沿更多维度划分空间。随着我们考虑更高维度，存储这种数据结构所需的空间会迅速爆炸。对于
    *D* 维数据和每维 *K* 个单元格，我们需要 *K*^(*D*) 个单独的单元格！这可能需要大量的内存。[图 8-16](#figure8-16) 展示了一个三维示例，一个
    5×5×5 的网格，它已经包含了大量的单元格。
- en: Worse, as we increase the number of grid bins, we’re likely increasing the percentage
    of empty bins. Checking those empty bins is wasted work. For this reason, grids
    aren’t ideal for higher-dimensional problems. In the next chapter, we will introduce
    a better approach for scaling to higher-dimensional data—the k-d tree.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟的是，随着我们增加网格的单元数，我们可能会增加空单元格的比例。检查这些空单元格是浪费的工作。因此，网格方法并不适用于更高维度的问题。在下一章中，我们将介绍一种更好的方法来处理高维数据——k-d树。
- en: While it is difficult to think of an everyday spatial problem using more than
    three dimensions, we can use our nearest-neighbor formulation on data beyond spatial
    points. In the next section, we will see how nearest-neighbor search can be used
    to help us find similar coffee or days with similar weather conditions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很难想象一个日常空间问题会使用超过三维的数据，但我们可以将最近邻的思想应用于超越空间点的数据。在下一节中，我们将看到如何使用最近邻搜索帮助我们找到相似的咖啡馆或具有相似天气条件的日子。
- en: '![A five‐by‐five‐by‐five grid for three‐dimensional points.](image_fi/502604c08/f08016.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![A five‐by‐five‐by‐five grid for three‐dimensional points.](image_fi/502604c08/f08016.png)'
- en: 'Figure 8-16: A grid of three-dimensional points'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-16：三维点的网格
- en: Beyond Spatial Data
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越空间数据
- en: Spatial data, such as locations on a map, provides a simple visual example for
    both nearest-neighbor search and grids themselves. We’re accustomed to thinking
    about locations in terms of proximity, since we regularly ask ourselves questions
    like “What is the closest gas station?” or “Where is the closest hotel to the
    conference center?” Yet the nearest-neighbor problem extends beyond spatial data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 空间数据，如地图上的位置，为最近邻搜索和网格本身提供了一个简单的可视化示例。我们习惯于以接近度来思考位置，因为我们经常问自己类似“最近的加油站在哪里？”或“离会议中心最近的酒店在哪里？”这样的问题。然而，最近邻问题不仅仅局限于空间数据。
- en: Let’s consider the critical problem of selecting the next-best brand of coffee
    to purchase when our favorite brand is out of stock. To find something similar
    to our favorite brew, we might consider what attributes we liked about that coffee,
    such as strength or acidity level, and then look for other coffees with similar
    attributes. We can extend nearest-neighbor search to find these “close” coffees.
    To do so, we first record every coffee we have ever sampled in a coffee log, noting
    such properties as strength and acidity, as shown in [Figure 8-17](#figure8-17).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个关键问题：当我们最喜欢的咖啡品牌缺货时，如何选择下一个最佳品牌。为了找到与我们最喜欢的咖啡相似的品牌，我们可以考虑喜欢的咖啡属性，比如强度或酸度，然后寻找其他具有相似属性的咖啡。我们可以扩展最近邻搜索来找到这些“接近”的咖啡。为此，我们首先记录下每一款曾品尝过的咖啡，记录其属性，如强度和酸度，如[图8-17](#figure8-17)所示。
- en: Over the years, we build a comprehensive mapping of the coffee landscape. Performing
    a nearest-neighbor search on this data allows us to find varieties of coffee similar
    to a target value. Looking for a strong, low-acidity brew to fuel the hurried
    work before a tight deadline? We can picture exactly the coffee we want, that
    sublime brew we had once in Hawai’i. Unfortunately, the upcoming deadline does
    not provide enough slack to justify a quick trip to Hawai’i. But have no fear!
    We use our thorough analysis of the coffee’s attributes, as captured in our coffee
    log, to define a search target and then search for a local brand that might be
    similar enough.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我们建立了一个全面的咖啡地理图谱。对这些数据执行最近邻搜索可以帮助我们找到与目标值相似的咖啡品种。需要寻找一种浓郁、低酸度的咖啡来为紧张的截止日期前的匆忙工作提供能量？我们能准确想象出我们想要的咖啡，那款我们曾在夏威夷品尝过的绝妙咖啡。不幸的是，接下来的截止日期没有足够的时间来支持我们去夏威夷一趟。但不用担心！我们利用对咖啡属性的全面分析（记录在我们的咖啡日志中）来定义搜索目标，然后寻找一个可能足够相似的本地品牌。
- en: '![On the left is a two‐dimensional plot of data points with one axis labeled
    strength and the other acidity. On the right is the same points with a grid overlaid.](image_fi/502604c08/f08017b.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![左图是一个二维数据点的图，x轴标记为强度，y轴标记为酸度。右图是相同的点，覆盖了一个网格。](image_fi/502604c08/f08017b.png)'
- en: 'Figure 8-17: An example of coffee attributes as two-dimensional data (left)
    and those points in a grid (right)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-17：咖啡属性作为二维数据的示例（左图）以及这些点在网格中的位置（右图）
- en: To perform this search, we just need a way to compute distances for attributes
    like coffee strength or acidity. The nearest-neighbor algorithm relies on our
    ability to distinguish “near” versus “far” neighbors. While it is possible to
    define distance measures over other types, such as strings, we restrict our discussion
    in this chapter to real-valued attributes for consistency.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行此搜索，我们只需要一种计算咖啡强度或酸度等属性距离的方法。最近邻算法依赖于我们区分“近”邻居和“远”邻居的能力。虽然有可能为其他类型（如字符串）定义距离度量，但为了保持一致性，本章将讨论实际值属性。
- en: With spatial data points, we have simple standard measures of the distances
    between two points (*x*[1]*, y*[1]) and (*x*[2]*, y*[2]), such as the Euclidean
    distance used earlier*.* But the optimal distance measure for any problem will
    depend on the problem itself. When evaluating brands of coffee, we might want
    to weight the attributes differently in different situations. Before our impending
    deadline, caffeine content takes precedence over factors such as the acidity level.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于空间数据点，我们有简单的标准度量来计算两个点（*x*[1]*, y*[1]）和（*x*[2]*, y*[2]）之间的距离，例如之前使用的欧几里得距离*。*
    但任何问题的最优距离度量将取决于问题本身。当评估咖啡品牌时，我们可能希望在不同的情况下以不同的方式加权各个属性。在即将到来的截止日期之前，咖啡因含量比酸度等因素更为重要。
- en: 'One common distance measure for non-spatial data is weighted Euclidean distance:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的非空间数据距离度量是加权欧几里得距离：
- en: '![g08005](image_fi/502604c08/g08005.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![g08005](image_fi/502604c08/g08005.png)'
- en: where *x*[*i*][*d*]is the *d*th dimension of the *i*th data point and *w*[*d*]is
    the weighting for the *d*th dimension. This formulation allows us to weight the
    impact of the different dimensions. In this case, we might set the weight of caffeine
    content to twice that of acidity, skewing the search toward coffees that are similarly
    caffeinated. We can even vary the weights per search.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*x*[*i*][*d*]表示第*i*个数据点的第*d*维度，*w*[*d*]表示第*d*维度的权重。这个公式允许我们对不同维度的影响进行加权。在这种情况下，我们可以将咖啡因含量的权重设置为酸度的两倍，从而将搜索偏向于咖啡因含量相似的咖啡。我们甚至可以根据每次搜索的需求调整权重。
- en: Of course, our search makes no guarantees as to the suitability of other aspects
    of the coffee. We’re only measuring proximity along the specified dimensions.
    If we are searching for an everyday coffee by matching only strength and acidity,
    then we do not consider roast level, batch size, growing conditions, caffeine
    content, or even the concentration of nutrients in the soil. If the nearest neighbor
    turns out to be decaf, our search wouldn’t account for this travesty. We’d be
    left with substandard coffee and tears of disappointment. It is important to make
    sure your distance computation takes into consideration all the dimensions of
    interest.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的搜索无法保证咖啡的其他方面是否适合。我们仅仅是在衡量指定维度上的接近度。如果我们只通过强度和酸度来匹配寻找日常咖啡，那么我们不会考虑烘焙程度、批次大小、种植条件、咖啡因含量，甚至土壤中的营养物质浓度。如果最近的邻居是无咖啡因的咖啡，我们的搜索将无法考虑到这一灾难。我们只会得到低质量的咖啡和失望的泪水。确保你的距离计算考虑到所有相关维度是很重要的。
- en: Why This Matters
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: Nearest-neighbor search allows us to find points that are “close” to some target
    value, whether spatial or non-spatial. From an algorithmic point of view, nearest-neighbor
    search moves us from searching for an exact target to searching based on distance
    metrics. The details of search get more complex as we step away from one-dimensional
    data sets into the realm of multidimensional data. As we saw with the shift from
    arrays to grids, this extension opens a range of new questions in terms of how
    we organize and search the data. It’s no longer possible to consider a simple
    ordering, as we did with a binary search for one-dimensional data. We need to
    adapt our data structures to a new type of multidimensional structure. Grids provide
    a new way to structure data based on aggregating points within the same spatial
    regions into the same bin.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最近邻搜索使我们能够找到与某个目标值“接近”的点，无论是空间的还是非空间的。从算法角度来看，最近邻搜索使我们从寻找精确目标转向基于距离度量进行搜索。当我们从一维数据集进入多维数据领域时，搜索的细节变得更加复杂。正如我们从数组到网格的转变所看到的，这种扩展带来了许多新的问题，涉及我们如何组织和搜索数据。我们不再能够像对一维数据进行二分查找时那样考虑简单的排序。我们需要将数据结构调整为一种新的多维结构类型。网格提供了一种新的数据组织方式，通过将相同空间区域内的点聚集到同一个桶中来结构化数据。
- en: At the same time, grids illustrate a different structure than the one-bucket,
    one-value structure we have seen with arrays. Grids use linked-list or other internal
    data structures to store multiple values per bin, a technique we will reuse in
    future chapters. By using this structure, grids also introduce a new tradeoff
    to consider—the size of the bins. By increasing the size of the bins, we can shift
    cost from evaluating many small bins to scanning through a large number of points
    per bin. Choosing the right number of bins is an example of the common task of
    *tuning* our data structure for the specific problem at hand.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在数组中看到的“一个桶一个值”的结构不同，网格展示了一种不同的结构。网格使用链表或其他内部数据结构在每个桶中存储多个值，这是我们将在未来章节中复用的一种技术。通过使用这种结构，网格还引入了一个新的权衡需要考虑——桶的大小。通过增加桶的大小，我们可以将成本从评估多个小桶转移到扫描每个桶中的大量数据点。选择合适数量的桶是*调优*数据结构以解决具体问题的一个常见任务。
- en: In the next chapter, we’ll take spatial partitioning further by combining the
    adaptive properties of trees with the spatial properties of grids. In doing so,
    we’ll address some of the major drawbacks of grids—and make the search for a good
    cup of coffee significantly more efficient.*
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过将树的自适应特性与网格的空间特性结合，进一步探讨空间划分。这样做，我们将解决网格的一些主要缺点——并使寻找一杯好咖啡的过程显著更高效。
