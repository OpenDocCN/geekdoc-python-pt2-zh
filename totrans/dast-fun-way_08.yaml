- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Grids
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网格
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we look at what happens as we consider multidimensional values
    and targets. The data structures we’ve examined so far have all shared a common
    constraint—they organize data based on a single value. Many real-world problems
    involve multiple important dimensions, and we need to extend our data structures
    to handle searches over such data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在考虑多维值和目标时会发生什么。到目前为止，我们所检查的数据结构都具有一个共同的约束——它们基于单一值组织数据。许多现实世界的问题涉及多个重要维度，我们需要扩展数据结构以处理这种数据的搜索。
- en: This chapter starts by introducing nearest-neighbor search, which will serve
    as our motivating use case for multidimensional data. As we will see, the generality
    of nearest-neighbor search makes it very flexible and applicable to a wide range
    of spatial and non-spatial problems. It can help us find the cup of coffee closest
    to our current location or the brand best suited to our tastes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍最近邻搜索，它将作为我们多维数据的激励用例。正如我们所看到的，最近邻搜索的通用性使得它非常灵活，适用于广泛的空间和非空间问题。它可以帮助我们找到离当前位置最近的咖啡，或是最适合我们口味的品牌。
- en: We then introduce the grid data structure and show how it facilitates nearest-neighbor
    search over two dimensions, using spatial relationships within the data to prune
    out infeasible regions of the search space. We briefly discuss how these approaches
    can be extended to more than two dimensions. We will also see how these data structures
    fall short, providing the motivation for further spatial data structures.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着介绍网格数据结构，并展示它如何通过使用数据中的空间关系修剪掉不可行的搜索空间区域，来促进二维的最近邻搜索。我们简要讨论如何将这些方法扩展到二维以上的情况。我们还将看到这些数据结构的不足之处，这为进一步的空间数据结构提供了动机。
- en: Introducing Nearest-Neighbor Search
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入最近邻搜索
- en: 'As its name implies, *nearest-neighbor search* consists of finding a particular
    data point closest to a given search target—for example, the coffee shop nearest
    our current location. Formally, we define nearest-neighbor search as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，*最近邻搜索*就是找到离给定搜索目标最近的特定数据点——例如，离我们当前位置最近的咖啡店。正式地，我们将最近邻搜索定义如下：
- en: Given a set of *N* data points *X* = {*x*[1], *x*[2], … , *x*[N]}, a target
    value *x*’, and a distance function *dist*(*x*,*y*), find the point *x*[*i*] ∈
    *X* that minimizes *dist*(*x*’,*x*[*i*]).
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定一组 *N* 个数据点 *X* = {*x*[1], *x*[2], … , *x*[N]}，一个目标值 *x*’，以及一个距离函数 *dist*(*x*,*y*)，找出数据集
    *X* 中的点 *x*[*i*] ∈ *X*，使得 *dist*(*x*’，*x*[*i*]) 最小。
- en: Nearest-neighbor search is closely related to the target value search we used
    to motivate binary search in Chapter 2. Both algorithms search for a specific
    data point within a set of data. The key difference lies in the success criteria.
    Whereas binary search tests for an exact match within a data set, which may or
    may not be present, nearest-neighbor search is only concerned with finding the
    closest match.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最近邻搜索与我们在第2章中用于激励二分查找的目标值搜索密切相关。这两种算法都在数据集中搜索特定的数据点。关键的区别在于成功标准。二分查找测试数据集中是否存在精确匹配，而最近邻搜索只关心找到最接近的匹配。
- en: This framing makes nearest-neighbor search useful for many types of multiple-dimensional
    data. We could be searching a map for nearby coffee shops, a list of historical
    temperatures for days similar to the current date, or a list of “close” misspellings
    of a given word. As long as we can define a distance between the search target
    and other values, we can find nearest neighbors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种框架使得最近邻搜索在处理多维数据时非常有用。我们可能在地图上寻找附近的咖啡店，在历史气温列表中寻找与当前日期相似的天数，或在给定单词的“近似”拼写中进行搜索。只要我们能定义搜索目标与其他值之间的距离，就能找到最近邻。
- en: In past chapters, we primarily considered targets that are individual numeric
    values, like the data stored in binary search trees and heaps. While we sometimes
    included auxiliary data, the targets themselves remained simple. In contrast,
    nearest-neighbor search is most interesting when dealing with multidimensional
    data, which may be stored in a variety of other data structures such as arrays,
    tuples, or composite data structures. Later in this chapter, we look at example
    two-dimensional search problems and their targets. For now, though, let’s introduce
    a basic algorithm for this search.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们主要考虑了那些作为单一数值的目标，例如存储在二叉搜索树和堆中的数据。虽然有时会包含辅助数据，但目标本身仍然保持简单。相比之下，最近邻搜索在处理多维数据时最为有趣，这些数据可能存储在各种其他数据结构中，如数组、元组或复合数据结构。在本章后续内容中，我们将讨论一些二维搜索问题及其目标。不过，现在让我们先介绍一个基本的搜索算法。
- en: Nearest-Neighbor Search with Linear Scan
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用线性扫描的最近邻搜索
- en: As a baseline algorithm for nearest-neighbor search, we start with a modified
    version of the linear scan algorithm from Chapter 2. The linear scan algorithm
    isn’t particularly exciting; you can implement it with a simple loop in most programming
    languages. Yet, because of its simplicity, linear scan provides a good starting
    point from which to examine more complex and efficient algorithms.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最近邻搜索的基准算法，我们从第二章中的线性扫描算法的修改版本开始。线性扫描算法并不特别引人注目；你可以通过在大多数编程语言中写一个简单的循环来实现它。然而，由于它的简洁性，线性扫描为我们提供了一个很好的起点，能够从中检视更复杂和高效的算法。
- en: 'Consider the problem of nearest-neighbor search with numbers using the absolute
    distance: *dist*(*x*,*y*) = |*x* – *y*|. Given a list of numbers and a search
    target, we want to find the closest number on the list. Perhaps we wake up in
    a new city and need to find our first cup of coffee in the morning. The hotel’s
    concierge provides a list of coffee shops on the same street, along with a helpful
    map. Not recognizing any of the businesses, we resolve to prioritize expedience
    and visit the coffee shop closest to the hotel.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设想一个使用绝对距离进行最近邻搜索的问题：*dist*(*x*,*y*) = |*x* – *y*|。给定一个数字列表和一个搜索目标，我们希望找到列表中最接近的数字。也许我们在一个陌生的城市醒来，早晨需要找第一杯咖啡。酒店的礼宾部提供了同一条街道上的咖啡店列表，并附带了一张有用的地图。由于我们对这些商店并不熟悉，因此决定优先选择便利，去酒店附近的咖啡店。
- en: We can visualize this search with a number line shown in [Figure 8-1](#figure8-1).
    The points represent different coffee shops and their location with respect to
    the start of the map, while the X represents our hotel with a location of 2.2
    miles along the street.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过数轴来可视化这个搜索过程，如[图8-1](#figure8-1)所示。这些点代表不同的咖啡店及其相对于地图起点的位置，而X则表示我们的酒店，位于街道上2.2英里处。
- en: '![A number line with seven candidate neighbors and one target point. The target
    point sits at 2.2 with the closest neighbor at 2.6.](image_fi/502604c08/f08001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![一个数轴，展示了七个候选邻居和一个目标点。目标点位于2.2，最近的邻居位于2.6。](image_fi/502604c08/f08001.png)'
- en: 'Figure 8-1: A one-dimensional nearest-neighbor search represented as a number
    line'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-1：一维最近邻搜索表示为数轴
- en: 'In a program, the points in [Figure 8-1](#figure8-1) might represent unsorted
    values within an array. However, visualizing these values along a real-valued
    number line has two advantages in the context of nearest-neighbor search. First,
    it clarifies the importance of distance: we can see the gaps between our target
    value and each data point. Second, it helps us generalize the techniques beyond
    a single dimension, as we’ll see in the next section.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，[图8-1](#figure8-1)中的点可能表示数组中未排序的值。然而，在最近邻搜索的背景下，将这些值可视化为实数轴上的值有两个优势。首先，它阐明了距离的重要性：我们可以看到目标值与每个数据点之间的间隔。其次，它帮助我们将技术推广到多维空间，正如我们将在下一节看到的那样。
- en: For now, the linear scan proceeds through each data point, as shown in [Figure
    8-2](#figure8-2), computing the distance for the current data point and comparing
    it to the minimum distance found so far. Here we consider the points in sorted
    order since they are already along the number line, but linear scan does not require
    a particular ordering. It uses the data’s ordering within the list.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，线性扫描算法按顺序遍历每个数据点，如[图8-2](#figure8-2)所示，计算当前数据点的距离，并与迄今为止找到的最小距离进行比较。这里我们考虑的是按排序顺序排列的点，因为它们已经沿着数轴排列，但线性扫描不要求特定的排序。它使用的是列表中数据的排列顺序。
- en: '![The linear scan computes each data point’s distance from the target point.
    A series of number lines shows each pair of points and their corresponding distance.](image_fi/502604c08/f08002.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![线性扫描计算每个数据点到目标点的距离。一系列数字线展示了每一对点及其对应的距离。](image_fi/502604c08/f08002.png)'
- en: 'Figure 8-2: A linear scan through the data points in a one-dimensional nearest-neighbor
    search'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2：一维最近邻搜索中数据点的线性扫描
- en: In the first comparison in [Figure 8-2](#figure8-2), we find a point at distance
    1.8\. This becomes our best option so far, our *candidate nearest neighbor*. It
    might not be a *good* neighbor—1.8 miles is a bit far to walk for our morning
    cup of joe—but it’s the best we’ve seen. The next two steps discover better candidates
    at distances 1.2 and 0.4, respectively. Alas, the remaining four comparisons don’t
    produce a better candidate; the point at distance 0.4 remains the closest we’ve
    found. In the end, the algorithm returns that third point on our number line as
    the nearest neighbor. We head to the coffee shop, confident we’re heading to the
    closest one on the street.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 8-2](#figure8-2)的第一次比较中，我们发现一个距离为1.8的点。这成为了我们迄今为止的最佳选择，我们的*候选最近邻*。它可能不是一个*好*邻居——1.8英里步行去喝早上的咖啡有点远——但它是我们看到的最好的。接下来的两步发现了分别位于1.2和0.4距离处的更好候选点。遗憾的是，剩下的四次比较并没有找到更好的候选点；距离0.4的点仍然是我们找到的最接近的点。最终，算法返回了数字线上的第三个点作为最近邻。我们信心满满地走向咖啡店，确信我们正朝着街上最近的一家咖啡店走去。
- en: '[Listing 8-1](#listing8-1) shows the code for a linear scan using an arbitrary
    distance function. We use floating-point values for the one-dimensional case but
    can extend the function to multiple dimensions by using composite data structures
    or other representations.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-1](#listing8-1)展示了使用任意距离函数的线性扫描代码。我们使用浮动值进行一维情况，但可以通过使用复合数据结构或其他表示方法将其扩展到多维。'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: The code for a linear scan nearest-neighbor algorithm'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-1：线性扫描最近邻算法的代码
- en: 'The code starts by checking whether the array is empty and, if so, returning
    `null` ❶, since there is no closest point. The code then picks the first item
    in the array as the initial candidate nearest neighbor and computes the distance
    from that point to the target ❷. This information provides a starting point for
    our search: we compare all future points against the best candidate and distance
    so far. The remainder of the code uses a `WHILE` loop to iterate over the remaining
    elements in the array ❸, computing the distance to the target and comparing that
    to the best distance found so far. The code updates the best candidate and best
    distance found whenever it finds a closer candidate ❹, then returns the closest
    neighbor ❺.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查数组是否为空，如果为空，则返回`null` ❶，因为没有最近的点。然后，代码选择数组中的第一个项作为初始候选最近邻，并计算该点到目标的距离
    ❷。这些信息为我们的搜索提供了起点：我们将所有后续点与目前为止的最佳候选点和距离进行比较。剩余的代码使用`WHILE`循环遍历数组中的其余元素 ❸，计算到目标的距离，并将其与目前找到的最佳距离进行比较。每当找到一个更接近的候选点时，代码都会更新最佳候选点和最佳距离
    ❹，然后返回最近的邻居 ❺。
- en: Beyond providing a simple implementation of nearest-neighbor search, the linear
    scan algorithm also trivially supports different distance functions or even higher-dimensional
    points. First, let’s look at some example problems in this two-dimensional space.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供最近邻搜索的简单实现外，线性扫描算法还轻松支持不同的距离函数，甚至是高维数据点。首先，让我们来看一些在二维空间中的示例问题。
- en: Searching Spatial Data
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索空间数据
- en: Imagine that you are multiple hours into a cross-country road trip and desperately
    need a coffee refill. Panic floods your mind as you realize that you haven’t mapped
    out the optimal coffee shops along your route. You take a few deep breaths, pull
    out the map shown in [Figure 8-3](#figure8-3), and locate numerous towns with
    known coffee establishments. Prioritizing expedience over quality, you vow to
    find the closest café.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您已经开车好几个小时，正在进行一场跨国公路旅行，急需加一次咖啡。突然间，当您意识到自己没有规划沿途的最佳咖啡店时，慌乱涌上心头。您深吸一口气，拿出[图
    8-3](#figure8-3)中显示的地图，找到了几个已知有咖啡店的城镇。优先考虑快捷而非质量，您下定决心要找到最近的咖啡馆。
- en: '![A two‐dimensional map of towns. The target point lies in the middle left
    near the towns of Gridville, Cartesian, and Fort Fortran.](image_fi/502604c08/f08003.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![一个二维的城镇地图。目标点位于地图中左中部，靠近Gridville、Cartesian和Fort Fortran城镇。](image_fi/502604c08/f08003.png)'
- en: 'Figure 8-3: A map as an example of two-dimensional data'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-3：作为二维数据示例的地图
- en: 'The data consists of two-dimensional points—towns with *x*, *y* coordinates.
    These data points can be stored as an ordered tuple (*x*, *y*); a small, fixed-size
    array [*x*, *y*]; or even a composite data structure for two-dimensional spatial
    points:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数据由二维点组成——带有*x*、*y*坐标的城镇。这些数据点可以存储为有序元组（*x*，*y*）、一个小的固定大小数组[*x*，*y*]，甚至可以使用一个复合数据结构来表示二维空间点：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When determining which town is closest, we’ll focus on just the straight-line
    distance to the coffee shop. In any real-world navigation task, we’d also need
    to consider obstacles standing between us and our coffee. For now, though, let’s
    just consider the Euclidean distance to the coffee shops. If our current point
    is (*x*[1]*, y*[1]) and the coffee shop is at (*x*[2]*, y*[2]), then the distance
    is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定哪个城镇最接近时，我们将仅关注到咖啡馆的直线距离。在任何实际的导航任务中，我们还需要考虑我们与咖啡之间的障碍物。然而现在，让我们仅考虑到咖啡馆的欧几里得距离。如果我们当前的位置是(*x*[1]*，y*[1])，而咖啡馆位于(*x*[2]*，y*[2])，则距离为：
- en: '![G08001](image_fi/502604c08/G08001.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![G08001](image_fi/502604c08/G08001.png)'
- en: We could use the linear-scan algorithm in [Listing 8-1](#listing8-1). The algorithm
    computes the distance from our target to each candidate point, as shown in [Figure
    8-4](#figure8-4).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[清单8-1](#listing8-1)中的线性扫描算法。该算法计算从目标点到每个候选点的距离，如[图8-4](#figure8-4)所示。
- en: '![An illustration of the distance computations from our target point to each
    of the 11 towns on the map. The distances are represented by dashed lines from
    the target point to the town.](image_fi/502604c08/f08004.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图示展示了从目标点到地图上每个11个城镇的距离计算。距离由从目标点到各城镇的虚线表示。](image_fi/502604c08/f08004.png)'
- en: 'Figure 8-4: A linear scan nearest-neighbor search computes the distance from
    the target to each candidate point.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-4：线性扫描最近邻搜索计算从目标点到每个候选点的距离。
- en: The point with the smallest distance to the target, shown in [Figure 8-5](#figure8-5),
    is the target’s nearest neighbor. The dashed line represents the distance to the
    closest point, and the dotted circle shows the area of our map that is closer
    than (or equal to) the closest point. No other points lie closer than the nearest
    neighbor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 距离目标最近的点，如[图8-5](#figure8-5)所示，就是目标的最近邻。虚线表示到最近点的距离，虚圆圈显示的是我们地图上比最近点更近（或等于）的区域。没有其他点比最近邻更靠近目标。
- en: '![The map with a dashed line from the target point to the nearest neighbor
    and a dotted circle indicating the space that falls within this radius.](image_fi/502604c08/f08005.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图中展示了从目标点到最近邻点的虚线，以及一个表示在该半径内的区域的虚圆圈。](image_fi/502604c08/f08005.png)'
- en: 'Figure 8-5: The point with the smallest distance to the target is that target’s
    nearest neighbor.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-5：距离目标最近的点即为该目标的最近邻。
- en: As we’ve seen multiple times, though, this type of linear scan search quickly
    becomes inefficient as the number of points increases. If the current edition
    of the *Coffee Lover’s Guide to Roadside Coffee* lists 100,000 coffee shops, it
    would be needlessly time-consuming to check each one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们多次看到的那样，随着点的数量增加，这种线性扫描搜索很快就变得低效。如果《*咖啡爱好者的路边咖啡指南*》当前列出了100,000家咖啡馆，那么检查每一家就会变得不必要地耗时。
- en: We shouldn’t need to look at every single data point in two-dimensional space.
    Some points are too far away to matter. We would never consider Alaskan coffee
    shops when driving through Florida. This is not to disparage Alaskan cafés—I’m
    sure there are plenty that equal their Floridian peers in terms of taste and quality.
    It’s simply a matter of expedience. We can’t survive an hour without our coffee,
    let alone a multi-day drive. If we are driving through northern Florida, we need
    to focus on northern Floridian coffee establishments.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要查看二维空间中的每个数据点。有些点距离太远，根本不重要。当我们开车穿越佛罗里达时，我们绝不会考虑阿拉斯加的咖啡馆。这并不是要贬低阿拉斯加的咖啡馆——我确信其中有很多在口味和质量上与佛罗里达的同行相当。这仅仅是出于实用考虑。我们不能在没有咖啡的情况下生存一小时，更不用说长时间的车程了。如果我们正在穿越佛罗里达北部，我们需要关注的是佛罗里达北部的咖啡馆。
- en: As we saw in binary search, we can often use structure within the data to help
    eliminate large numbers of candidates. We can even adapt binary search to find
    nearest neighbors in one-dimensional space. Unfortunately, a simple sort will
    not help in the two-dimensional case. If we sort and search either x or y dimensions,
    as shown in [Figure 8-6](#figure8-6), we get the wrong answer—the closest neighbor
    in the one-dimensional space is not the same as the closest two-dimensional neighbor.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在二分查找中看到的，我们通常可以利用数据中的结构来帮助消除大量候选项。我们甚至可以将二分查找方法应用于一维空间中寻找最近邻。不幸的是，在二维情况下，简单的排序并不会有所帮助。如果我们对
    X 或 Y 维度进行排序并搜索，如[图 8-6](#figure8-6)所示，我们会得到错误的答案——一维空间中最近的邻居与二维空间中最近的邻居并不相同。
- en: We need to use information from all relevant dimensions to make accurate pruning
    decisions. A point close to our target along a single dimension might be staggeringly
    far away in other dimensions. If we sort our list of coffee shops by latitude,
    our search for locations near our current latitude in northern Florida might return
    quite a few “close” results from Houston. Similarly, if we sort by longitude,
    we might be swamped with entries from Cleveland. We need to explore new approaches,
    adapted from our experience with one-dimensional data but also making use of the
    structure inherent in higher dimensions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要利用所有相关维度的信息来做出准确的剪枝决策。在某一维度上接近目标的点，在其他维度上可能相距极远。如果我们按照纬度对咖啡店进行排序，我们在佛罗里达北部寻找接近当前纬度的位置时，可能会返回一些来自休斯顿的“接近”结果。同样，如果我们按经度排序，可能会被克利夫兰的条目淹没。我们需要探索新的方法，这些方法源自我们在一维数据上的经验，同时也利用了高维数据固有的结构。
- en: '![On the left, a projection of the map points from Figure 8‐3 onto the Y‐axis.
    On the right, a projection of the points onto the X‐axis. In both cases, the closest
    neighbor in one dimension is not the same as the closest neighbor in two dimensions.](image_fi/502604c08/f08006b.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![左侧是图 8-3 中地图点的投影到 Y 轴，右侧是投影到 X 轴。在这两种情况下，一维中最接近的邻居与二维中最接近的邻居并不相同。](image_fi/502604c08/f08006b.png)'
- en: 'Figure 8-6: Projecting the data to one dimension along either the y-axis (left)
    or x-axis (right) removes important spatial information about the other dimension.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-6：将数据投影到 Y 轴（左）或 X 轴（右）上的一维空间，会丧失关于另一个维度的重要空间信息。
- en: Grids
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格
- en: '*Grids* are data structures for storing two-dimensional data. Like arrays,
    grids consist of a fixed set of *bins*, or *cells*. Since we are initially covering
    two-dimensional data, we use a two-dimensional arrangement of bins and index each
    bin with two numbers, *xbin* and *ybin*, representing the bin numbers along the
    x-axis and y-axis respectively. [Figure 8-7](#figure8-7) shows an example grid.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*网格*是用于存储二维数据的数据结构。像数组一样，网格由一组固定的*单元格*组成。由于我们最初是处理二维数据，我们使用二维排列的单元格，并通过两个数字
    *xbin* 和 *ybin* 来索引每个单元格，分别表示沿 X 轴和 Y 轴的单元格编号。[图 8-7](#figure8-7)展示了一个网格的示例。'
- en: '![A two‐by‐two grid over the map. Bins are labeled 0 and 1 along both the X
    and Y dimension, resulting in a total of four quadrants.](image_fi/502604c08/f08007.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![一个二维的网格覆盖在地图上。网格的 X 轴和 Y 轴都标记为 0 和 1，共形成四个象限。](image_fi/502604c08/f08007.png)'
- en: 'Figure 8-7: A 2×2 grid of spatial data points'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7：一个 2×2 的空间数据点网格
- en: Unlike arrays, we can’t restrict each bin to hold a single value. Grid cells
    are defined by spatial bounds—a high and low edge along each dimension. No matter
    how finely we draw the grid, multiple points might fall within the same cell,
    so we need our bins to store multiple elements apiece. Each bin stores a list
    of *all* data points that fall within that bin’s range.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组不同，我们不能限制每个单元格只存储一个值。网格单元是由空间边界定义的——每个维度上有高低边界。无论我们如何细化网格，多个点可能落入同一个单元格，因此我们需要让每个单元格存储多个元素。每个单元格存储一个包含该单元格范围内*所有*数据点的列表。
- en: We can visualize the difference between grids and arrays as different forms
    of refrigerator storage. The egg carton is an array with one individual space
    for each egg. In contrast, the vegetable drawer is like a grid bin. It contains
    multiple items of the same type, all vegetables. We might stuff a single drawer
    with twenty-five onions. The egg carton, on the other hand, contains only a fixed
    number of eggs, each in its designated place. While vegetable drawers may generate
    intense debates about where to correctly store tomatoes or cucumbers, the bounds
    of a grid cell are defined with mathematical precision.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将网格和数组的区别比作不同类型的冰箱存储方式。蛋盒是一个数组，每个鸡蛋都有一个独立的空间。相比之下，蔬菜抽屉就像一个网格容器。它包含多个相同类型的物品，全部是蔬菜。我们可能会把一个抽屉塞满二十五个洋葱。而蛋盒则只包含固定数量的鸡蛋，每个鸡蛋都有其指定的位置。虽然蔬菜抽屉可能引发关于番茄或黄瓜应该正确存放在哪里的激烈争论，但网格单元的边界是通过数学精确定义的。
- en: Grids use the points’ coordinates to determine their storage, allowing us to
    use the data’s spatial structure to limit our searches. To see how this is possible,
    we first need to consider the details of the grid’s structure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 网格使用点的坐标来决定它们的存储方式，这使得我们可以利用数据的空间结构来限制搜索范围。为了理解这是如何实现的，我们首先需要考虑网格结构的细节。
- en: Grid Structure
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格结构
- en: The top-level data structure for our grid contains some extra bookkeeping information.
    As shown in [Figure 8-8](#figure8-8), we need to include multiple pieces of information
    along each dimension. In addition to the number of bins along the x- and y-dimensions,
    we must track the spatial bounds along each dimension. We use `x_start` and `x_end`
    to indicate the minimum and maximum values of x included in our grid. Similarly,
    `y_start` and `y_end` capture the spatial bounds for y.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网格的顶层数据结构包含了一些额外的记录信息。如[图 8-8](#figure8-8)所示，我们需要在每个维度上包含多项信息。除了沿 x 轴和 y 轴的容器数量外，我们还必须跟踪每个维度的空间边界。我们使用`x_start`和`x_end`来指示网格中包含的
    x 值的最小值和最大值。类似地，`y_start`和`y_end`用于捕捉 y 维度的空间边界。
- en: '![The grid spans x_start to x_end along the x‐axis and y_start to y_end along
    the y‐axis. the grid has 6 bins along each dimension, and the resulting bin widths
    are shown. ](image_fi/502604c08/f08008.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![该网格从 x_start 到 x_end 跨越 x 轴，从 y_start 到 y_end 跨越 y 轴。网格在每个维度上有 6 个容器，且结果显示了容器的宽度。](image_fi/502604c08/f08008.png)'
- en: 'Figure 8-8: A grid with specified starting and ending values along each dimension'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8：一个在每个维度上都有指定起始值和结束值的网格
- en: 'We can derive some top-level information from the number of bins and the spatial
    bounds, but we often want to store that additional information about the grid
    for convenience. Precomputing the width of the bins along each dimension simplifies
    later code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从容器的数量和空间边界中推导出一些顶层信息，但为了方便起见，我们通常希望存储有关网格的额外信息。预先计算每个维度上容器的宽度可以简化后续的代码：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Other useful information might include the total number of points stored in
    the grid or the number of empty bins. We can track all this information in a composite
    data structure. For two-dimensional data, our typical data structure would look
    like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的信息可能包括网格中存储的总点数或空的容器数量。我们可以通过一个复合数据结构来跟踪所有这些信息。对于二维数据，我们的典型数据结构大致如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For a fixed-size grid, we can map from a point’s spatial coordinates to the
    grid’s bin using a simple mathematical computation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个固定大小的网格，我们可以通过一个简单的数学计算将点的空间坐标映射到网格的容器中：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The switch from “one bin, one value” to “spatial partitioning” has important
    consequences beyond index mapping. It means that we can no longer store the data
    as a set of fixed bins in the computer’s memory. Each square could contain an
    arbitrary number of data points. Each grid square needs its own internal data
    structure to store its points. One common and effective data structure for storing
    points within the bin is a linked list like the one in [Figure 8-9](#figure8-9).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从“一个容器，一个值”到“空间分区”的转变具有重要的后果，超出了索引映射的范畴。这意味着我们不能再将数据作为一组固定的容器存储在计算机内存中。每个方格可以包含任意数量的数据点。每个网格方格需要拥有自己的内部数据结构来存储其点。存储点的一个常见且有效的数据结构是链表，如[图
    8-9](#figure8-9)所示。
- en: '![A grid shown as a list of four bins (a flattened matrix), each pointing to
    the start of a linked list of points. The first three bins contain three points,
    and the final bin (xbin = 1, ybin = 1) includes two points.](image_fi/502604c08/f08009.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![一个网格显示为四个容器的列表（一个扁平化的矩阵），每个容器指向一个包含点的链表的起始位置。前几个容器包含三个点，而最后一个容器（xbin = 1，ybin
    = 1）包含两个点。](image_fi/502604c08/f08009.png)'
- en: 'Figure 8-9: A representation of the data structure used to store points in
    a grid'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-9：用于存储网格中点的数据显示结构
- en: 'Each bin stores the pointer to the head of a linked list, which contains all
    the points in that bin. We accomplish this with another, internal data structure
    to store individual points:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个桶存储指向链表头部的指针，链表中包含该桶的所有点。我们通过另一个内部数据结构来存储单个点来实现这一点：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Alternatively, we could use the `LinkedListNode` data structure from Chapter
    3 and store a pair to represent the *x*, *y* coordinates.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用第 3 章中的`LinkedListNode`数据结构，并存储一对表示 *x*，*y* 坐标的值。
- en: Building Grids and Inserting Points
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建网格并插入点
- en: We construct a grid for our data set by allocating an empty grid data structure
    and iteratively inserting points using a single `FOR` loop over the data points.
    The high-level structure of the grid itself (the spatial bounds and number of
    bins along each dimension) is fixed at time of creation and does not change with
    the data added.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过分配一个空的网格数据结构并使用一个单一的`FOR`循环遍历数据点，迭代地插入点来构建数据集的网格。网格本身的高级结构（空间范围和每个维度的桶数量）在创建时是固定的，并且不会随着添加的数据变化。
- en: As shown in [Listing 8-2](#listing8-2), inserting a point consists of finding
    the correct bin and prepending the new point to the beginning of the linked list
    for that bin.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 8-2](#listing8-2)所示，插入点的过程包括找到正确的桶并将新点添加到该桶对应链表的开头。
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-2: A function to insert a new point into a grid'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-2：一个将新点插入网格的函数
- en: The code first computes the x and y bins for the new point ❶ and confirms that
    the new point falls within a valid bin ❷. While it’s always important to confirm
    that you are accessing an in-bounds array index whenever using an array, spatial
    data structures present additional concerns. We might not be able to predefine
    a fixed, finite grid that works for every possible future point. Therefore, it
    is important to consider what happens when previously unseen points fall outside
    the range covered by your spatial data structure. In this example, we return a
    Boolean to indicate whether or not the point could be inserted ❹. However, you
    might prefer other mechanisms, such as throwing an exception, depending on the
    programming language.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先计算新点的 x 和 y 桶 ❶，并确认新点落在有效的桶中 ❷。虽然在使用数组时，始终要确保访问的是有效的数组索引，但空间数据结构带来了额外的关注点。我们可能无法预定义一个适用于每个未来可能点的固定、有限的网格。因此，考虑到之前未见过的点可能会落在空间数据结构所覆盖范围之外，显得尤为重要。在这个例子中，我们返回一个布尔值来指示点是否能被插入
    ❹。然而，根据编程语言的不同，您可能更倾向于使用其他机制，比如抛出异常。
- en: Once we have determined that point does fit within our grid, the code finds
    the appropriate bin. The code prepends the new point to the front of the list,
    creating a new list if the bin was previously empty ❸. The function concludes
    by returning `True` ❹.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定该点适合放入网格中，代码会找到合适的桶。代码将新点添加到列表的前端，如果桶之前为空，则创建一个新的列表 ❸。函数最终返回`True` ❹。
- en: Deleting Points
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除点
- en: We can use a similar approach to insertion for deleting points from a grid.
    One additional difficulty is determining which point in the bin to delete. In
    many use cases, the user might insert arbitrarily close or even duplicate points
    into the grid. For example, if we are storing a list of ground coffees available
    to purchase, we might insert multiple points for a single coffee shop. Ideally,
    we use other identifying information, such as the name or ID number of the coffee,
    to determine which of the points to delete. In this section, we present the simple
    and general approach of deleting the first matching point in our linked list.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的插入方法来删除网格中的点。一个额外的难点是确定要删除桶中哪一个点。在许多使用场景中，用户可能会在网格中插入任意接近甚至重复的点。例如，如果我们要存储可购买的咖啡列表，可能会为同一家咖啡店插入多个点。理想情况下，我们使用其他标识信息，如咖啡的名称或ID编号，来确定要删除哪个点。在本节中，我们介绍了删除链表中第一个匹配点的简单通用方法。
- en: Due to the limited precision of floating-point variables, we also might not
    be able to use a direct equality test. In [Listing 8-3](#listing8-3), we use a
    helper function to find a point that is close enough. The `approx_equal` function
    returns `True` if both points are within a threshold distance in both dimensions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点数变量的精度限制，我们可能无法使用直接的相等性测试。在[清单 8-3](#listing8-3)中，我们使用一个辅助函数来找到一个足够接近的点。`approx_equal`函数会在两个点在两个维度上都在阈值距离内时返回`True`。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 8-3: Code to check whether two data points, represented as a pair of
    floating-point numbers, are equal'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-3: 检查两个数据点（表示为一对浮点数）是否相等的代码'
- en: The code checks each dimension independently and compares the distance to a
    threshold. The threshold will depend on the use case and the numerical precision
    of your programming language. Generally, we want these thresholds to be just large
    enough to account for the float’s numerical precision.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 代码独立检查每个维度，并将距离与阈值进行比较。阈值将取决于具体的应用场景和编程语言的数值精度。通常，我们希望这些阈值足够大，以便考虑到浮点数的数值精度。
- en: Deletion consists of finding the correct bin, traversing the linked list until
    we find a match, and removing the match by splicing it out of the list. Our delete
    function returns `True` if a point was found and deleted and `False` otherwise.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作包括找到正确的桶，遍历链表直到找到匹配项，然后通过从链表中切除匹配项来完成删除。我们的删除函数如果找到并删除了一个点，则返回`True`，否则返回`False`。
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code first computes the x and y bins for the new point ❶ and confirms that
    the new point falls within a valid bin ❷. Next it checks whether the target bin
    is empty ❸, returning `False` if it is.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先计算新点的x和y桶❶，并确认新点是否落在一个有效的桶内❷。接下来，它检查目标桶是否为空❸，如果为空则返回`False`。
- en: If there are points to check, the code iterates through the list ❹. Unlike the
    code for insertion, we track both the current node and the previous one so that
    we can splice the target node out of the list. The code uses the `approx_equal`
    helper function from [Listing 8-3](#listing8-3) to test each point ❺. When it
    finds a matching point, it splices it out of the list, taking care to correctly
    handle the special case of the first node in the list ❻, and returns `True`. Thus,
    only the *first* matching point in the list is removed. If the current point does
    not match, the search continues to the next node in the list ❼. If the search
    finishes the entire list, the function returns `False` to indicate that no matching
    node was deleted.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有点需要检查，代码会遍历列表❹。与插入操作的代码不同，我们同时追踪当前节点和前一个节点，以便能够从链表中切除目标节点。代码使用[Listing 8-3](#listing8-3)中的`approx_equal`辅助函数来测试每个点❺。当找到匹配的点时，它会将其从链表中切除，特别处理链表中第一个节点的特殊情况❻，然后返回`True`。因此，只有列表中*第一个*匹配的点会被删除。如果当前点不匹配，搜索将继续到下一个节点❼。如果搜索完成整个列表，函数将返回`False`，表示没有匹配的节点被删除。
- en: Searches Over Grids
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格上的搜索
- en: 'Now that we’ve learned how to construct grid data structures, let’s use them
    to improve our nearest-neighbor searches. First, we examine the problem of pruning
    grid cells that are too far away, which will allow us to avoid unnecessary computations
    within grid cells. We then consider two basic searches: a linear scan over all
    the bins and an expanding search.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何构建网格数据结构，让我们利用它们来改进最近邻搜索。首先，我们检查如何修剪距离过远的网格单元，这将帮助我们避免在网格单元内进行不必要的计算。接着，我们考虑两种基本的搜索方式：对所有桶进行线性扫描和扩展搜索。
- en: Pruning Bins
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修剪桶
- en: The grid’s spatial structure allows us to limit how many points we need to check,
    excluding those outside the range we’re interested in (northern Florida). Once
    we have a candidate neighbor and its associated distance, we can use that distance
    to *prune bins**. Before checking the points in a bin, we ask whether *any* point
    within the bin’s spatial bounds could be closer than the current best distance.
    If not, we can ignore the bin.*
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的空间结构使我们能够限制需要检查的点数，排除那些位于我们不感兴趣的范围之外的点（如北佛罗里达）。一旦我们有了一个候选邻居及其相关的距离，我们就可以利用这个距离来*修剪桶*。在检查一个桶中的点之前，我们会问是否有*任何*点在该桶的空间范围内可能比当前最好的距离更近。如果没有，我们可以忽略这个桶。*
- en: '*Determining whether *any* point within a bin lies within a given distance
    from our target point may sound like a daunting task. However, if we are using
    Euclidean distance ![i08001](image_fi/502604c08/i08001.png), which we can encapsulate
    in this simple helper function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*确定桶内的*任意*点是否在距离目标点给定的范围内听起来可能是一项艰巨的任务。然而，如果我们使用欧几里得距离 ![i08001](image_fi/502604c08/i08001.png)，我们可以将其封装在这个简单的辅助函数中：'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: thenthe test boils down to simple mathematics. We start by finding the closest
    possible point in the grid cell and use that for our pruning test. Specifically,
    if the closest possible point in the grid cell is further than our current best
    candidate, there is no reason to check any of the actual points stored in the
    bin. They all must be further away. If a target point falls within the cell—that
    is, if its x and y values are within the cell’s x and y ranges, respectively—the
    distance to the cell (and thus the closest possible point) is zero.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If the point falls outside the cell, then the closest possible point in the
    cell must lie on the edge of the cell. [Figure 8-10](#figure8-10) shows a variety
    of points outside the grid cell and the corresponding closest points within the
    cell. For points outside the grid cell, we need to compute the distance to the
    closest edge point.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Eight target points shown as gray circles and their corresponding closest
    points within the cell. The closest points to targets outside the cell are on
    the cell’s perimeter.](image_fi/502604c08/f08010.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-10: Points outside a grid cell (gray circles) and the corresponding
    closest points within the cell (solid circles)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compute the Euclidean distance between a point and the nearest edge
    of a grid’s bin by considering each dimension independently. We find the minimum
    distance needed to shift the x value within the bin’s range and the minimum distance
    to shift the y value within the bin’s range. For the grid bin (*xbin*, *ybin*),
    the minimum and maximum x and y dimensions are:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can compute the distance as follows (in the case of Euclidean distance):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![g08002](image_fi/502604c08/g08002.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: where
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: IF *x* < *x*_*min* THEN *x*[dist] *= x*_*min* − *x*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: IF *x*_*min* ≤ *x* ≤ *x*_*max* THEN *x*[dist] = 0
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: IF *x* > *x*_*max* THEN *x*[dist] = *x* – *x*_*max*
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: and
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: IF *y* < *y_min* THEN *y*[dist] = *y_min* − *y*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: IF *y_min* ≤ *y* ≤ *y_max* THEN *y*[dist] = 0
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: IF *y* > *y_max* THEN *y*[dist] = *y* − *y_max*
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: If the minimum distance to any possible point in the bin is greater than that
    of our current closest point, then nothing in the bin could replace the current
    closest point. We can ignore the entire bin!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The code for computing the minimum distance from a point to a bin can be encapsulated
    into the following helper function. This function implements the mathematical
    logic above.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 8-4: A helper function that computes the closest distance from a target
    point to a given bin'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The code starts by checking that the bin indices are valid ❶. In this example,
    we use an infinite distance to indicate that the function’s caller has referenced
    an invalid bin. This logic allows us to use this lookup function in pruning computations
    that might ask about invalid bins. However, this may lead to confusion: Why is
    the function returning any distance for an invalid bin? Depending on the usage,
    it might be preferable to throw an error indicating that the bin indices are invalid.
    Either way, the function’s behavior should be clearly documented for users.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the code proceeds through the distance logic above for the
    x and y dimensions (❷ and ❸, respectively). The code computes the minimum and
    maximum values for the bin, compares them with the point’s value along that dimension,
    and computes the distance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: To visualize this distance test, imagine that a raucous game of catch sends
    a ball over our fence into the yard of our friendly, but exceedingly lazy, neighbor.
    They will return the ball, of course, but without exerting any more effort than
    absolutely necessary. What is the shortest distance they need to throw the ball
    in order for it to (just barely) return to our yard? If their longitude already
    falls within the bounds of our yard, they will throw in a pure north or south
    direction so as not to add any unnecessary east/west distance. In the end, their
    throw always lands exactly on the fence such that it falls back into our property.
    Our neighbor may be lazy, but they have some impressive throwing skills.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Linear Scan Over Bins
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest approach to searching a grid would iterate through all the grid’s
    bins using a linear scan and only check those that could contain a potential nearest
    neighbor. This is not a particularly good algorithm, but it provides an easy introduction
    to working with and pruning bins.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The linear search algorithm simply applies the aforementioned minimum distance
    test to each bin before checking its contents:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 8-5: A nearest-neighbor search that uses a linear scan over a grids
    bin with pruning tests on each bin.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The code starts by setting the best distance to infinity to indicate that no
    best point has been found so far ❶. Then the algorithm scans through each bin
    using a pair of nested `WHILE` loops that iterate over the x and y bins ❷. Before
    checking the individual points in the bin, the code performs a minimum distance
    test to check whether *any* point in the bin could be a better neighbor ❸. If
    the bin may contain better neighbors, the code uses a third `WHILE` loop to iterate
    through the linked list of points in the bin ❹. It tests the distance to each
    point and compares it with the best distance found so far ❺. The function completes
    by returning the best candidate found, which may be `null` if the grid is empty
    ❻.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm in [Listing 8-5](#listing8-5) allows us to prune out entire bins,
    along with all the points they contain, whenever we determine that minimum distance
    to any point in the bin is greater than the distance to the best point seen so
    far. If we have a large number of points per bin, this can lead to significant
    savings. However, if the grid is sparsely populated, we might end up paying more
    to check each of the bins than we would have if we’d checked each point individually.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `GridInsert` function in [Listing 8-2](#listing8-2), our linear scan
    works with target points inside or outside the grid’s spatial bounds. `GridLinearScanNN`
    does not need to map the target point to a bin and therefore does not care if
    the target is on the grid itself. It will still return the nearest neighbor from
    the grid (or `null` if the grid is empty). This provides an additional level of
    flexibility to our nearest-neighbor search that can be useful when encountering
    new, non-typical targets.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Ideal Expanding Search over Bins
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the linear scan algorithm allows us to prune out entire bins based on
    their minimum distance to our target point, we’re still not using all the spatial
    information at our disposal. We waste a significant amount of computation by testing
    bins that are far from our target point. We can do better if we prioritize bins
    by their proximity to their target, first searching the bins closest to our target
    point and halting the search when the remaining bins are further than the nearest
    neighbor we have found so far. We call this an *expanding search*, because we
    effectively expand out from the bin containing the target point until we have
    found the nearest neighbor.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: To visualize this improved scanning method, imagine a panicked search for our
    car keys in the morning. We start with the area (comparable to a grid cell) where
    the car keys would be if we had stored them correctly. We inspect every inch of
    the kitchen counter before admitting that we must have misplaced the keys. Spiraling
    out to other parts of the house (that is, other bins), we check nearby locations,
    such as the coffee table and the floor, before venturing further and further away.
    This search continues, exploring less and less likely locations, until we find
    the keys mysteriously sitting in the sock drawer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: For an example of an expanding scan in action, consider our map overlaid with
    a four-by-four grid, as shown in [Figure 8-11](#figure8-11). We find the closest
    bin to our target point by asking, “Into which bin does our target point fall?”
    and using the grid index-mapping equations. Since it is possible that our target
    point falls outside the grid, we might also need to shift the computed bin indices
    into the valid range. In [Figure 8-11](#figure8-11), the target point is in the
    third bin up in the leftmost column (*xbin* = 0 and *ybin* = 2 in our notation).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![The map points from figure 8‐3 placed in a four‐by‐four grid.](image_fi/502604c08/f08011.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-11: A 4×4 grid of two-dimensional points'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We can start our search in the target point’s bin and test every point in that
    bin. As long as the bin isn’t empty, we are guaranteed to find our first *candidate*
    nearest neighbor, as shown in [Figure 8-12](#figure8-12). Unfortunately, since
    we’re not organizing or sorting the points within each bin, we can’t do better
    in this case than a linear scan through that bin’s points. Of course, if the initial
    bin is empty, we must progress our search outward to neighboring bins, incrementally
    trying further and further bins until we find one containing a data point to be
    our candidate nearest neighbor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![The four‐by‐four grid of map points from Figure 8‐11 with a dashed line to
    the candidate nearest neighbor. The first candidate falls within the same bin.](image_fi/502604c08/f08012.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-12: An initial candidate nearest neighbor found in the same bin as
    the target point'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Once we obtain this initial candidate for nearest neighbor, we are still not
    done. The candidate is just that—a candidate. It’s possible there could be a closer
    point in one of the adjacent bins. This is more likely if our target point is
    near the edge of a bin. In [Figure 8-13](#figure8-13), the dashed circle represents
    the space of all points that are closer to or at the same distance from the current
    candidate. Any other point that falls within the circle could be the true nearest
    neighbor. The shaded grid cells are those that overlap this region.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![The four‐by‐four grid of map points from Figure 8‐11 with a dotted circle
    showing the region of space with distance closer than or equal to the current
    candidate neighbor. Four grid cells overlapping this circle are shaded, indicating
    that they could contain a closer neighbor.](image_fi/502604c08/f08013.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-13: A candidate nearest neighbor and the gridcells that could contain
    points closer to the target'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: To visualize why we need to continue to check other bins, imagine you want to
    determine the closest person to you at an outdoor party. You’re telling a particularly
    embarrassing story, involving the use of spoiled milk in your coffee, and want
    to make sure that only the intended audience hears you. Your best friend standing
    by the house might appear to be closest to you, but, if you’re near your fence,
    you also need to consider people on the other side. If your neighbor is planting
    flowers along their side of the fence, they might actually be closer and hear
    all of the humiliating details. You can’t discount them because there is a fence
    in the way. This is why we always check neighboring bins—and why you should always
    be careful about telling embarrassing stories in public.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: We continue to expand out the search to include *all* nearby bins until we can
    guarantee that no possible point in the remaining bins could be closer than our
    candidate nearest neighbor. Once we have checked all the bins within the radius
    of our nearest-neighbor candidate, we can ignore any bins beyond that. We don’t
    even need to check their distance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The tradeoff for this improved grid search is algorithmic complexity. Instead
    of scanning across every one of the bins—an algorithm we could implement with
    a nested pair of `FOR` loops—the optimized search spirals out from a single bin,
    exploring further and further away until we can prove that none of the unexplored
    bins could contain a better neighbor. This requires additional logic in the search
    order (outward spiral), bounds checking (avoiding testing bins off the edge of
    the grid), and termination criteria (knowing when to stop). The next section presents
    a simple example of an expanding search for illustrative purposes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Simplified Expanding Search
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s consider a simplified (and non-optimized) version of an expanding search
    that moves outward in a diamond-shaped pattern. Instead of executing a perfect
    spiral out from the initial bin, the search uses an increasing distance from an
    initial bin. For simplicity of implementation, we will use a Manhattan distance
    on the grid indices that counts the steps between grid cells:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '*d* = |*xbin*[1] − *xbin*[2]| + |*ybin*[1] − *ybin*[2]|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: While this search pattern is unlikely to be efficient for grids with drastically
    different bin widths along each dimension, it provides an easy-to-follow illustration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-14](#figure8-14) shows the first four iterations of the search. During
    the first iteration in [Figure 8-14](#figure8-14)(a), we search the bin containing
    the target point (zero steps away). During the next iteration in [Figure 8-14](#figure8-14)(b),
    we search all bins a single step away. On each subsequent iteration, we search
    all the bins that are one step further out.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Four iterations of an example expanding search. In the first iteration, a
    single bin containing the target point is shaded. In the second iteration, four
    bins, all one step away, are shaded. In the third iteration, eight bins, all two
    steps away, are shaded.](image_fi/502604c08/f08014.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-14: The first four iterations of a simplified expanding search on
    a grid'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We start with a helper function that checks whether any points within a specified
    bin are closer to our target point (`x`, `y`) than a given `threshold`. This function
    encodes our linear scan through the bin’s points. If there is at least one point
    closer than `threshold`, the function returns the closest such point. The use
    of a threshold value will allow us to use the helper function to compare the bin’s
    points to the best candidates from other bins.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 8-6: A helper function that returns the closest point in a bin to the
    target point as long as it is below the given threshold'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The code starts with a safety check that we are accessing a valid bin ❶. If
    not, it returns `null` to indicate that there are no valid points. The code then
    uses a `WHILE` loop to iterate through each point in the bin ❸, computing its
    distance from the target point, comparing it to the best distance seen so far,
    and saving it as the new best candidate if it is closer ❹. The code finishes by
    returning the closest point ❺. Since the code initially set `best_dist` to the
    `threshold` value before checking any points ❷, it will only mark points with
    a distance less than `threshold` as new candidates. The function returns `null`
    if none of the bin’s points are closer than `threshold`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The code for performing the expanding search works by iterating through a different
    number of steps and checking all bins that can be reached in that number of steps.
    As in previous searches, we track the best candidate seen so far. The search concludes
    after iteration *d* if there are no valid grid cells *d* steps away that could
    contain a closer neighbor.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code starts by finding the closest bin within the grid to our target point,
    taking care to map targets outside the grid to their closest bin in the grid ❶.
    The resulting bin (`xb`, `yb`) will be the starting point for the search. By mapping
    bins outside the grid to a valid bin, the function can return the nearest neighbor
    for target points that lie outside the grid itself.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The code then uses a `WHILE` loop to explore outward from this initial bin by
    increasing amounts ❷. The variable `steps` tracks the distance used for the current
    iteration. The `WHILE` loop is conditioned on the variable `explore`, which indicates
    that the next iteration may include a valid bin and we should thus continue exploring
    at the next value of `steps`. As we will see shortly, the `WHILE` loop terminates
    as soon as it completes a full iteration where *none* of the bins visited could
    have held a closer neighbor.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Within the main `WHILE` loop, the code iterates across the different x-index
    offsets from `-steps` to `steps` as though scanning horizontally across the grid
    ❸. The total number of steps in the x-direction and y-direction are fixed by `steps`,
    so the code can programmatically compute the remaining number of steps to use
    in the (positive or negative) y-direction ❹. Starting with the negative y-direction,
    the code uses `MinDistToBin` from [Listing 8-4](#listing8-4) to check whether
    the bin indices are valid and, if so, determine the distance to that bin ❺. It
    can skip any bins that are invalid or too far away. If the bin could contain a
    closer point than our current candidate, the code uses `GridCheckBin` from [Listing
    8-6](#listing8-6) to check for such a point ❻. Whenever a closer point has been
    found, the code saves it as the new closest candidate and updates its estimate
    of the closest distance. The second `IF` block performs the same checks in the
    positive y-direction as long as the y-offset is not zero (in which case we have
    already checked the bin in the negative y-direction) ❽.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: During an iteration of the outer `WHILE` loop ❷, the code resets `explore` to
    `False`. It later updates `explore` to `True` if any of the calls to `MinDistToBin`
    indicate that a bin could contain a closer neighbor (❼ and ❾). Thus, the outer
    loop continues until it reaches a number of steps where every bin is either further
    than `best_d` or lies off the grid (and is therefore invalid). While other termination
    criteria may provide more exact tests and terminate earlier, we use this rule
    in the code due to its simplicity.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The Importance of Grid Size
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The size of our grid’s bins has a massive impact on the efficiency of our search.
    The larger our bins, the more points we may need to check per bin. Remember that
    our grid searches still do a linear scan through the points within each visited
    bin. However, partitioning the grid into finer bins has tradeoffs both in terms
    of memory and the number of empty bins we may encounter. As we shrink the size
    of the grid’s bins, we often need to search more individual bins before we even
    find the first candidate nearest neighbor and the cost of checking bins increases.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-15](#figure8-15) shows an extreme case where the grid is too fine.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![The map points from figure 8‐3 placed in a 17‐by‐17 grid. There are now 36
    bins that are closer than the nearest neighbor.](image_fi/502604c08/f08015.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-15: A fine grid in which most of the bins are empty'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 8-15](#figure8-15), we must search 36 bins in order to find the nearest
    neighbor. This is clearly more expensive than the example in [Figure 8-13](#figure8-13),
    where we only needed to check four bins and two individual points. Sadly, it might
    even be more expensive than the linear scan search, which checked every one of
    the 11 data points.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Consider this in the context of our search for coffee shops. If we partition
    the space too finely, such as in 1 m by 1 m squares, we’ll be facing a grid that
    contains mostly empty bins. If we partition the space more coarsely, such as 5
    km by 5 km squares, we might bucket entire cities and their multitudes of coffee
    shops in a single bin while still leaving (to our utmost horror) a large number
    of bins nearly or completely empty.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The optimal grid size often depends on multiple factors, including the number
    of points and their distribution. More complex techniques, such as non-uniform
    grids, can be used to dynamically adapt to the data. In the next chapter, we will
    consider several tree-based data structures that dynamically enable this type
    of adaptation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Beyond Two Dimensions
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The grid-based techniques developed for two dimensions can be scaled to higher
    dimensional data as well. We might need to search a multi-floor office building
    for the closest available conference room. We can search for nearest neighbors
    in three-dimensional data by incorporating the *z* coordinate into our distance
    computation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![g08003](image_fi/502604c08/g08003.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'Or, more generally, we can define Euclidean distance over *d*-dimensional data
    as:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![g08004](image_fi/502604c08/g08004.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: where *x*[i][*d*]is the *d*th dimension of the *i*th data point.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Higher-dimensional data comes with another challenge for the grid-based approach
    we’ve considered in this chapter: it requires us to partition the space along
    more dimensions. The space required to store such data structures explodes quickly
    as we consider higher dimensions. For data with *D* dimensions and *K* bins per
    dimension, we need *K*^(*D*) individual bins! This can require a huge amount of
    memory. [Figure 8-16](#figure8-16) shows a three-dimensional example, a 5×5×5
    grid, which already includes a large number of individual bins.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Worse, as we increase the number of grid bins, we’re likely increasing the percentage
    of empty bins. Checking those empty bins is wasted work. For this reason, grids
    aren’t ideal for higher-dimensional problems. In the next chapter, we will introduce
    a better approach for scaling to higher-dimensional data—the k-d tree.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: While it is difficult to think of an everyday spatial problem using more than
    three dimensions, we can use our nearest-neighbor formulation on data beyond spatial
    points. In the next section, we will see how nearest-neighbor search can be used
    to help us find similar coffee or days with similar weather conditions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![A five‐by‐five‐by‐five grid for three‐dimensional points.](image_fi/502604c08/f08016.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-16: A grid of three-dimensional points'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Beyond Spatial Data
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spatial data, such as locations on a map, provides a simple visual example for
    both nearest-neighbor search and grids themselves. We’re accustomed to thinking
    about locations in terms of proximity, since we regularly ask ourselves questions
    like “What is the closest gas station?” or “Where is the closest hotel to the
    conference center?” Yet the nearest-neighbor problem extends beyond spatial data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the critical problem of selecting the next-best brand of coffee
    to purchase when our favorite brand is out of stock. To find something similar
    to our favorite brew, we might consider what attributes we liked about that coffee,
    such as strength or acidity level, and then look for other coffees with similar
    attributes. We can extend nearest-neighbor search to find these “close” coffees.
    To do so, we first record every coffee we have ever sampled in a coffee log, noting
    such properties as strength and acidity, as shown in [Figure 8-17](#figure8-17).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, we build a comprehensive mapping of the coffee landscape. Performing
    a nearest-neighbor search on this data allows us to find varieties of coffee similar
    to a target value. Looking for a strong, low-acidity brew to fuel the hurried
    work before a tight deadline? We can picture exactly the coffee we want, that
    sublime brew we had once in Hawai’i. Unfortunately, the upcoming deadline does
    not provide enough slack to justify a quick trip to Hawai’i. But have no fear!
    We use our thorough analysis of the coffee’s attributes, as captured in our coffee
    log, to define a search target and then search for a local brand that might be
    similar enough.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![On the left is a two‐dimensional plot of data points with one axis labeled
    strength and the other acidity. On the right is the same points with a grid overlaid.](image_fi/502604c08/f08017b.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-17: An example of coffee attributes as two-dimensional data (left)
    and those points in a grid (right)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: To perform this search, we just need a way to compute distances for attributes
    like coffee strength or acidity. The nearest-neighbor algorithm relies on our
    ability to distinguish “near” versus “far” neighbors. While it is possible to
    define distance measures over other types, such as strings, we restrict our discussion
    in this chapter to real-valued attributes for consistency.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: With spatial data points, we have simple standard measures of the distances
    between two points (*x*[1]*, y*[1]) and (*x*[2]*, y*[2]), such as the Euclidean
    distance used earlier*.* But the optimal distance measure for any problem will
    depend on the problem itself. When evaluating brands of coffee, we might want
    to weight the attributes differently in different situations. Before our impending
    deadline, caffeine content takes precedence over factors such as the acidity level.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'One common distance measure for non-spatial data is weighted Euclidean distance:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![g08005](image_fi/502604c08/g08005.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: where *x*[*i*][*d*]is the *d*th dimension of the *i*th data point and *w*[*d*]is
    the weighting for the *d*th dimension. This formulation allows us to weight the
    impact of the different dimensions. In this case, we might set the weight of caffeine
    content to twice that of acidity, skewing the search toward coffees that are similarly
    caffeinated. We can even vary the weights per search.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Of course, our search makes no guarantees as to the suitability of other aspects
    of the coffee. We’re only measuring proximity along the specified dimensions.
    If we are searching for an everyday coffee by matching only strength and acidity,
    then we do not consider roast level, batch size, growing conditions, caffeine
    content, or even the concentration of nutrients in the soil. If the nearest neighbor
    turns out to be decaf, our search wouldn’t account for this travesty. We’d be
    left with substandard coffee and tears of disappointment. It is important to make
    sure your distance computation takes into consideration all the dimensions of
    interest.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Why This Matters
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nearest-neighbor search allows us to find points that are “close” to some target
    value, whether spatial or non-spatial. From an algorithmic point of view, nearest-neighbor
    search moves us from searching for an exact target to searching based on distance
    metrics. The details of search get more complex as we step away from one-dimensional
    data sets into the realm of multidimensional data. As we saw with the shift from
    arrays to grids, this extension opens a range of new questions in terms of how
    we organize and search the data. It’s no longer possible to consider a simple
    ordering, as we did with a binary search for one-dimensional data. We need to
    adapt our data structures to a new type of multidimensional structure. Grids provide
    a new way to structure data based on aggregating points within the same spatial
    regions into the same bin.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, grids illustrate a different structure than the one-bucket,
    one-value structure we have seen with arrays. Grids use linked-list or other internal
    data structures to store multiple values per bin, a technique we will reuse in
    future chapters. By using this structure, grids also introduce a new tradeoff
    to consider—the size of the bins. By increasing the size of the bins, we can shift
    cost from evaluating many small bins to scanning through a large number of points
    per bin. Choosing the right number of bins is an example of the common task of
    *tuning* our data structure for the specific problem at hand.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take spatial partitioning further by combining the
    adaptive properties of trees with the spatial properties of grids. In doing so,
    we’ll address some of the major drawbacks of grids—and make the search for a good
    cup of coffee significantly more efficient.*
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
