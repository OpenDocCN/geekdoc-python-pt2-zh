- en: '11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ANIMATIONS, SIMULATIONS, AND THE TIME LOOP
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same way vector images visualize static problems, animations help us build
    visual intuition for dynamic problems. A single image can show us only how things
    are at a specific point in time. When the properties of a system change over time,
    we’ll need an animation to get the complete story.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like a static analysis presents a system in a moment, a *simulation* presents
    the evolution of a system over time. Animations are a good way of presenting the
    results of this evolution. There are two good reasons for engineers to simulate
    dynamic systems: it’s a great exercise to solidify your understanding of these
    systems, and it’s quite fun.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll start exploring the engaging world of animations, starting
    with a few definitions. We’ll then learn how to make drawings move across the
    canvas. We’ll use Tkinter’s canvas and, more importantly, our CanvasDrawing wrapper
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining Terms**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s define a few of the terms we’ll be using in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '***What Is an Animation?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *animation* is the sensation of motion generated by a rapid succession of
    images. Because the computer draws these images to the screen extremely quickly,
    our eyes perceive motion.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make animations by drawing something to the canvas, clearing it, and then
    drawing something else. Each drawing, which remains on the screen for a fraction
    of a second, is called a *frame*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, [Figure 11-1](ch11.xhtml#ch11fig1), which depicts each frame
    of an animation: a triangle moving right.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: The animation frames of a triangle*'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the four frames in the animation has the triangle in a slightly different
    position. If we draw them on the canvas, one after the other, clearing the previous
    drawing, the triangle will appear to move.
  prefs: []
  type: TYPE_NORMAL
- en: Simple, isn’t it? We’ll build our first animation in this chapter soon, but
    first let’s define the terms *system* and *simulation*, as they’ll appear frequently
    in our discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '***What Is a System?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The word *system*, in our context, refers to whatever we’re drawing to the canvas
    in an animation. It consists of a group of objects subject to some physical laws
    and interacting with one another. We’ll use these laws to derive a mathematical
    model, often in the form of a system of differential equations. We’ll resolve
    these equations using numerical methods, which yield the values that describe
    the system at discrete points in time. These values might be the system’s position
    or velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at an example of a system and derive its equation. Let’s
    suppose we have a body with mass *m* subject to an external force that is a function
    of time, ![Image](../images/ftvictorit.jpg). [Figure 11-2](ch11.xhtml#ch11fig2)
    depicts a *free body diagram*. There, you can see the external force and its weight
    force applied, where ![Image](../images/gvictorit.jpg) is gravity’s acceleration
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: A mass subject to external force*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Newton’s second law and denoting the position vector of the body by ![Image](../images/pvictorit.jpg),
    we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0289-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Solving for the acceleration ![Image](../images/pcapvictorit.jpg),
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0289-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous vector equation can be broken down into its two scalar components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0289-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These two equations express the acceleration of the body function of time. To
    simulate this simple system, we’d need to obtain a new value for the acceleration,
    velocity, and position of the body for each frame of the animation. We’ll see
    what this means in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: '***What Is a Simulation?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *simulation* is the study of the evolution of a system whose behavior is mathematically
    described. Simulations harness the computation power of modern central processing
    units (CPUs) to understand how a given system would behave under real conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Computer simulations are in general cheaper and simpler to set up than real-world
    experiments, so they’re used to study and predict the behavior of many engineering
    designs.
  prefs: []
  type: TYPE_NORMAL
- en: Take the system whose equations we derived in the previous section. Given an
    expression of the external force with respect to time like
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0289-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and the mass for the body is said to be *m* = 5kg, the acceleration equations
    become the following.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0290-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These scalar equations give us the acceleration components for the body at every
    moment in time. Since the equations are simple, we can integrate them to obtain
    the expression of the velocity components,
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0290-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where *Ẋ*[0] and *Ẏ*[0] are the components of the initial velocity: the velocity
    at time *t* = 0\. We know the velocity of the mass for every moment in time. If
    we want to animate the movement of the mass, we need an expression for the position,
    which we can obtain by integrating the velocity equations,'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0290-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *X*[0] and *Y*[0] are the initial position components for the mass. We
    can now create an animation to understand how the body moves under the effect
    of the external force by simply creating a sequence of time values, obtaining
    the position for each of them, and then drawing a rectangle to the screen at that
    position.
  prefs: []
  type: TYPE_NORMAL
- en: The *differential equations* relating how the acceleration of the system varies
    with respect to time for this example were straightforward, which allowed us to
    obtain an analytic solution using integration. We usually don’t get an analytic
    solution for the system under simulation, so we tend to resort to numerical methods.
  prefs: []
  type: TYPE_NORMAL
- en: The *analytic solution* is the exact solution, whereas a *numerical solution*
    is obtained using computer algorithms that look for an approximation of the solution.
    A common numerical method, although not the most precise, is *Euler’s method*.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the simulation in real time means we need to solve the equations as
    often as we draw frames. For example, if we want to simulate at a rate of 50 frames
    per second (fps), then we need to both draw the frames and solve the equations
    50 times per second.
  prefs: []
  type: TYPE_NORMAL
- en: At 50 fps, the time between frames is 20 milliseconds. Taking into account the
    fact that your computer requires some of those milliseconds to redraw the screen
    with the current frame, we’re left with little time for the math.
  prefs: []
  type: TYPE_NORMAL
- en: Simulations can also be computed ahead of time and later played back. This way
    solving the equations can take as long as required; the animation takes place
    only when all frames are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Video game engines use real-time simulations as they need to simulate the world
    around the player as they interact with it, something that can’t be determined
    ahead of time. These engines tend to trade accuracy for speed; their results are
    not physically accurate but look realistic to the naked eye.
  prefs: []
  type: TYPE_NORMAL
- en: Complex engineering systems require an ahead-of-time simulation since the governing
    equations for these problems are complex and require a much more exact solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is the Time Loop?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Real-time simulations happen inside a loop, which we’ll refer to as the *time
    loop* or *main loop*. This loop executes as many times per second as frames are
    drawn to the screen. Here’s some pseudocode showing what a time loop might look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To make the animations look smooth, we want a steady frame rate. This means
    the drawing phase of the simulation should take place at evenly spaced points
    in time. (While not strictly necessary, there are techniques to adapt the frame
    rate to the processor and GPU’s throughput, but we won’t be getting that advanced
    in this book.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The time elapsed between consecutive frames is referred to as the *time delta*,
    or *δt*; it’s inversely proportional to the frame rate (fps) and typically measured
    in seconds or milliseconds: ![Image](../images/f00291-p1.jpg). As a consequence,
    everything happening in our time loop should take less than a single time delta
    to complete.'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in the loop is solving the equations to figure out how the system
    has evolved during the elapsed time delta. Then, we draw the system’s new configuration
    to the screen. We need to measure the time taken so far in the loop and store
    the result in the time_taken variable.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the program is paused or put to sleep until an entire time delta
    has elapsed. The time we sleep can be figured out by subtracting time _taken from
    time_delta. The last step before ending the loop is to advance the current time
    by a time delta; the loop then starts over again. [Figure 11-3](ch11.xhtml#ch11fig3)
    shows the time line with the events in the time loop drawn.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: The time loop events*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have those definitions out of the way, let’s implement a time loop
    and start animating.
  prefs: []
  type: TYPE_NORMAL
- en: '**Our First Animation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the beginning of the chapter, we explained how we can achieve the sensation
    of motion by drawing something many times per second. The time loop is in charge
    of keeping these drawings at a steady rate. Let’s implement our first time loop.
  prefs: []
  type: TYPE_NORMAL
- en: '***Setup***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start by creating a new file where we can experiment. In the *simulation*
    package, create a new file and name it *hello_motion.py*. Enter the code in [Listing
    11-1](ch11.xhtml#ch11lis1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-1: The hello_motion.py file*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code in [Listing 11-1](ch11.xhtml#ch11lis1), we start by creating a
    600 × 600–pixel canvas and adding it to the grid of the main window. Then we initialize
    some variables: frame_rate_s holds the time between two consecutive frames, in
    seconds; frame_count is the count of how many frames have already been drawn;
    and max_frames is the number of total frames we’ll draw.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Note that the variables storing time-related quantities include information
    in their name about the unit they use. The* s *in* frame_rate_s *or* elapsed_s
    *indicates seconds. It’s good practice to do this, as it helps the developer understand
    what units the code is working with without needing to read comments or pick through
    all the code. When you spend many hours a day coding, these small details end
    up saving you a lot of time and frustration.*'
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the time loop ➊, which executes max_frames times at a rate of frame_rate_s,
    at least in principle (as you’ll see in a minute). Note that we chose to limit
    the simulation using a maximum number of frames, but we could also limit it by
    time, that is, keep running the loop until a given amount of time has elapsed,
    just like we did in the pseudocode shown earlier. Both approaches work fine.
  prefs: []
  type: TYPE_NORMAL
- en: In the loop we start by storing the current time in update_start. After the
    updates to the system and the drawing have taken place, we store the time again,
    this time in update_end. The time elapsed is then computed by subtracting update_start
    from update_end and stored in elapsed_s ➎. We use this quantity to calculate how
    long the loop needs to sleep to keep the frame rate steady, subtracting elapsed_s
    from frame_rate_s. That amount is stored in remaining_time_s, and if it’s greater
    than zero, we sleep the loop ➏.
  prefs: []
  type: TYPE_NORMAL
- en: If remaining_time_s is less than zero, the loop took longer than the frame rate,
    meaning it can’t keep up with the rhythm we imposed on it. If this happens often,
    the time loop will become unsteady, and animations may look chunky, in which case
    it’s better to simply reduce the frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The magic happens (or will happen, to be more precise) in update _system ➋
    and redraw ➌, which we call in the loop to update and redraw the system. Here’s
    where we’ll soon be writing our drawing code. The pass statement is used in Python
    as a placeholder: it doesn’t do anything, but it allows us to have, for example,
    a valid function body.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a call to update from main window tk ➍, which tells Tkinter to
    run the main loop until all pending events have been processed. This is necessary
    to force Tkinter to look for the events that may trigger changes in the user interface
    widgets, including our canvas.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the file now; you’ll see an empty window apparently doing nothing,
    but it’s actually running the loop max_frames times.
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding a Frame Count Label***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s add a label under the canvas to let us know the current frame being drawn
    to the canvas and the total number of frames. We can update its value in update.
    First, add Label to the tkinter imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, under the definition of the canvas, add the label ([Listing 11-2](ch11.xhtml#ch11lis2)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-2: Adding a label to the window*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, update the label’s text in update by setting the value of its text
    variable, label ([Listing 11-3](ch11.xhtml#ch11lis3)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-3: Updating the label’s text*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to run the file now. The canvas is still blank, but the label below it
    now displays the current frame. Your program should look like [Figure 11-4](ch11.xhtml#ch11fig4):
    a blank window with a frame count going from 1 to 100.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: The frame count label*'
  prefs: []
  type: TYPE_NORMAL
- en: Just for reference, your code at this stage should look like [Listing 11-4](ch11.xhtml#ch11lis4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-4: Hello canvas with label*'
  prefs: []
  type: TYPE_NORMAL
- en: To have anything drawn on the canvas, we need to have a system. Let’s first
    take a look at how to add and update a system to our simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Updating the System***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this example, we’ll keep it simple and draw a circle whose center is always
    at the center of the canvas, point (300, 300). Its radius will grow, starting
    with a value of zero. When the radius grows larger than the canvas and is no longer
    visible, we’ll set it back to zero. This will generate a psychedelic tunnel-like
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can represent our “system” with an instance of our Circle class. Since we’ll
    be drawing the circle to the canvas, let’s also create an instance of Canvas Drawing,
    using an identity affine transformation. Under the definition of variables frame_rate_s,
    frame_count, and max_frames, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t forget to include the needed imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We need to update the value of the radius every frame in update_system so that
    when redraw does its thing, the circle gets drawn with the updated value for the
    radius. In update_system, enter the code in [Listing 11-5](ch11.xhtml#ch11lis5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-5: Updating the circle’s radius*'
  prefs: []
  type: TYPE_NORMAL
- en: The value for the radius is updated by adding 15 to the current value. Using
    the modulo operator (%), whenever the radius becomes greater than 450, the value
    wraps around and goes back to zero.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Quick reminder: the modulo operator* % *returns the remainder of dividing
    its two operands. For instance,* 5 % 3 *yields* 2.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve probably realized that we mutated the circle’s radius property instead
    of creating a new circle with the value for the new radius; it’s the first time
    in the book we mutate the properties of our geometric primitives. The reason is
    that, for simulations, maintaining the throughput of the loop is crucial, and
    creating a new instance of the system for each frame would have a high performance
    impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the system defined in each of the frames: a circle whose center
    point is kept centered in the window while the radius gradually increases in size.
    Let’s draw it to the screen!'
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Motion***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the effect of motion, the canvas has to be cleared and the system
    redrawn in each and every frame. Before redraw is invoked in the main loop, update_system
    has already updated the circle. In redraw, we simply need to clear whatever is
    drawn on the canvas and draw the circle again. Update redraw using the code in
    [Listing 11-6](ch11.xhtml#ch11lis6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-6: Redrawing the circle every frame*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve probably been waiting for this grand moment for the whole chapter, so
    go ahead and execute the file. You should see a circle growing in size until it
    disappears from the screen and then starting over again.
  prefs: []
  type: TYPE_NORMAL
- en: Just for your reference, at this point, your *hello_motion.py* code should look
    like [Listing 11-7](ch11.xhtml#ch11lis7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-7: Resulting simulation*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that before drawing anything, the redraw function clears the canvas. Can
    you guess what would happen if we forgot to do so? Comment that line out and run
    the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All circles drawn should remain on the canvas, as you see in [Figure 11-5](ch11.xhtml#ch11fig5).
  prefs: []
  type: TYPE_NORMAL
- en: We’ve drawn our first animation on the canvas, and it looks fantastic. If we
    were to write another, though, we’d have to copy and paste the code for the main
    loop. To avoid this needless duplication, let’s move the main loop code into a
    function that can be easily reused.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: What it’d look like if we forgot to clean the canvas*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstracting the Main Loop Function**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main loop we just wrote had a fair amount of logic that will be the same
    for all simulations. Copying and pasting this code over and over again would not
    only be bad practice, but if we found an improvement or wanted to make a change
    to our implementation, we’d need to edit the code of all our simulations. We don’t
    want to duplicate knowledge: we should define the logic for a main simulation
    loop in just one place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a generic version of the main loop, we need to do an abstraction
    exercise. Let’s ask ourselves the following questions regarding the implementation
    of the main loop: Is there something that’s never going to change in it, and is
    there anything simulation-specific? The while loop, the order of the operations
    inside of it, and the time calculations are the same for every simulation. Conversely,
    there are three pieces of logic that vary from simulation to simulation, namely,
    the decision that keeps the loop running, the updating, and the drawing.'
  prefs: []
  type: TYPE_NORMAL
- en: If we encapsulate those in functions that the simulations implement, they can
    be passed to our main loop abstraction. The main loop we implement only needs
    to care about the timing, that is, trying to keep the frame rate stable.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named *loop.py* in the *simulation* package. Enter the code
    in [Listing 11-8](ch11.xhtml#ch11lis8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-8: Simulation’s main loop function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you should notice is that three of the arguments to the main_loop
    function are also functions: update_fn, redraw_fn, and should_continue _fn. These
    functions contain the logic that’s simulation-specific, so our main loop simply
    needs to call them as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Passing functions as arguments to other functions was covered in [Chapter
    1](ch01.xhtml#ch01), on [page 27](ch02.xhtml#ch00lev2sec20). You may want to refer
    to this section for a quick refresher.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main_loop function starts by declaring three variables: frame, which holds
    the current frame index; time_s, which holds the total time elapsed; and last_elapsed_s,
    which holds the number of seconds it took the last frame to complete. The condition
    to keep the loop running is now delegated to the should_continue_fn function ➊.
    The loop will continue as long as this function returns true. It accepts two arguments:
    the frame count and the total time elapsed in seconds. If you recall, most of
    our simulations will be limited by one of these values, so we pass them to the
    function so that it has the information required to decide whether the loop should
    keep running.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the update_fn function ➋ updates the system under simulation and the
    user interface. This function receives three parameters: the time elapsed since
    the last frame, last_elapsed_s; the total elapsed time for the simulation, time_s;
    and the current frame number, frame. As we’ll see later in the book, when we introduce
    physics to our simulations, the amount of time elapsed since the last frame is
    an important piece of data. Lastly comes redraw_fn ➌, which draws the system to
    the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to our abstraction of the simulation’s main loop, we won’t need to write
    this logic anymore. Let’s try to refactor our simulation from the previous section
    using this definition of the main loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Refactoring Our Simulation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve created an abstraction of the main loop, let’s take a look at
    how our simulation could be refactored to include the main loop function.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named *hello_motion_refactor.py* and enter the code from [Listing
    11-9](ch11.xhtml#ch11lis9). You may want to copy and paste the first lines from
    *hello_motion.py*, those that define the UI. Note that to make the code a bit
    shorter, I’ve removed the frame count label from the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-9: Refactored version of hello_motion.py*'
  prefs: []
  type: TYPE_NORMAL
- en: If we go toward the end of the code, we find the call to main_loop. We’re passing
    in the functions that we previously defined, with the sole difference being that
    now those functions must declare the proper parameters to match the functions
    main_loop expects.
  prefs: []
  type: TYPE_NORMAL
- en: This code is much simpler to follow. All the logic to keep a steady frame rate
    has been moved away to its own function, so we can focus our attention on the
    simulation itself without needing to deal with those details. Let’s now take some
    time to play with some of the parameters of the simulation and understand how
    they affect the final result.
  prefs: []
  type: TYPE_NORMAL
- en: '***Playing with the Circle Divisions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember that the CanvasDrawing class includes an affine transformation as part
    of its state, and every geometric primitive gets transformed by it before being
    drawn. Remember also that this is the reason a circle is converted to a generic
    polygon using a number of divisions high enough to approximate the circumference.
    The transformation happens in the drawing command; hence, the number of divisions
    has to be passed in, or else the default of 30 is used.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to function redraw from [Listing 11-9](ch11.xhtml#ch11lis9),
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'you can see we used 50 divisions, but we could have used any other number.
    Let’s try with 10, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Rerun the file. Can you see the difference? What about if you try with 6 divisions?
    [Figure 11-6](ch11.xhtml#ch11fig6) shows the simulation using 50, 10, and 6 divisions
    for the circle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: Circles drawn using 50, 10, and 6 divisions*'
  prefs: []
  type: TYPE_NORMAL
- en: After this interesting experiment we can clearly see the influence of the divisions
    used to approximate a circle. Let’s now experiment with the affine transformation
    used to transform the geometric primitives before they’re drawn to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '***Playing with the Affine Transformation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The affine transformation applied to the drawing in our simulation is an identity
    transformation: it keeps points exactly where they are. But we could use this
    transformation to do something different, such as invert the y-axis so that it
    points upward, for example. Go back to *hello_motion_refactor.py* and locate the
    line where the transformation is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, edit it so that it inverts the y-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run the simulation again. What do you see? Just a little rim coming from the
    top of the canvas, right? What’s happening is that we inverted the y-axis, but
    the origin of coordinates is still in the upper-left corner; thus, the circle
    we’re trying to draw is outside the window, as depicted by [Figure 11-7](ch11.xhtml#ch11fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Simulation with the y-axis inverted*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily fix this problem by translating the origin of the coordinates
    all the way down to the lower-left corner of the canvas. Since the canvas height
    is 600 pixels, we can set the transformation to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It may surprise you that the value for the vertical translation is 600 and not
    – 600, but remember that in the original system of coordinates, the y direction
    points downward, and this affine transformation refers to that system.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer, it may be easier to understand the process of obtaining that
    transformation by concatenating two simpler ones, the first moving the origin
    downward 600 pixels and the second flipping the y-axis,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: which yields the same transformation, as you can see.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s add some shear in the horizontal direction to see how the circle
    gets deformed. Try the following values for the transformation,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: and run the simulation again. You should see a shape similar to that in [Figure
    11-8](ch11.xhtml#ch11fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-8: A circle drawn using a horizontal shear*'
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s your turn to play with the values and see whether you can build a better
    intuition for how the animations, drawings, and transformations are working. You’ve
    created something beautiful from scratch, so take your time to experiment with
    it. Try to change the circle primitive using a triangle or a rectangle. You can
    update the geometric primitive by moving it instead of changing its size. Play
    around with the affine transformation values and try to reason about how the drawing
    should look before you actually run the simulation. Use this exercise to reinforce
    your affine transformation intuition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cleaning Up the Module**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s do two small refactors to the module to clean it up a bit. First, create
    a new folder in the *simulation* package and name it *examples*. We’ll use it
    to house all the files that are not part of the simulation and drawing logic,
    but rather examples we wrote in this chapter. So, basically, move all the files
    except for *draw.py* and *loop.py* there. Your folder structure in *simulation*
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: simulation
  prefs: []
  type: TYPE_NORMAL
- en: '|- examples'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- hello_canvas.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- hello_motion.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- ...'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- draw.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- loop.py'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing we want to do is add both the CanvasDrawing class and the
    main_loop function to the default exports of the *simulation* package. Open file
    *__init__.py* in *simulation* and add the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! From now on we’ll be able to import both using a shorter syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about the time loop. The time loop keeps executing
    while a condition is met, and its main job is to keep the frame rate steady. In
    this loop two things take place: the updating of the system under simulation and
    the redrawing of the screen. Those operations are timed so that when they’re done,
    we know how much more time remains to complete a cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the time loop will appear in all of our simulations, we decided to
    implement it as a function. This function gets passed other functions: one that
    updates the system, another that draws it to the screen, and a last one that decides
    whether the simulation is over or not.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll use this time loop function to animate affine transformations.
  prefs: []
  type: TYPE_NORMAL
