- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ANIMATIONS, SIMULATIONS, AND THE TIME LOOP
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: The same way vector images visualize static problems, animations help us build
    visual intuition for dynamic problems. A single image can show us only how things
    are at a specific point in time. When the properties of a system change over time,
    we’ll need an animation to get the complete story.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like a static analysis presents a system in a moment, a *simulation* presents
    the evolution of a system over time. Animations are a good way of presenting the
    results of this evolution. There are two good reasons for engineers to simulate
    dynamic systems: it’s a great exercise to solidify your understanding of these
    systems, and it’s quite fun.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll start exploring the engaging world of animations, starting
    with a few definitions. We’ll then learn how to make drawings move across the
    canvas. We’ll use Tkinter’s canvas and, more importantly, our CanvasDrawing wrapper
    class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining Terms**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s define a few of the terms we’ll be using in this section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '***What Is an Animation?***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *animation* is the sensation of motion generated by a rapid succession of
    images. Because the computer draws these images to the screen extremely quickly,
    our eyes perceive motion.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make animations by drawing something to the canvas, clearing it, and then
    drawing something else. Each drawing, which remains on the screen for a fraction
    of a second, is called a *frame*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, [Figure 11-1](ch11.xhtml#ch11fig1), which depicts each frame
    of an animation: a triangle moving right.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: The animation frames of a triangle*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Each of the four frames in the animation has the triangle in a slightly different
    position. If we draw them on the canvas, one after the other, clearing the previous
    drawing, the triangle will appear to move.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Simple, isn’t it? We’ll build our first animation in this chapter soon, but
    first let’s define the terms *system* and *simulation*, as they’ll appear frequently
    in our discussion.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '***What Is a System?***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The word *system*, in our context, refers to whatever we’re drawing to the canvas
    in an animation. It consists of a group of objects subject to some physical laws
    and interacting with one another. We’ll use these laws to derive a mathematical
    model, often in the form of a system of differential equations. We’ll resolve
    these equations using numerical methods, which yield the values that describe
    the system at discrete points in time. These values might be the system’s position
    or velocity.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at an example of a system and derive its equation. Let’s
    suppose we have a body with mass *m* subject to an external force that is a function
    of time, ![Image](../images/ftvictorit.jpg). [Figure 11-2](ch11.xhtml#ch11fig2)
    depicts a *free body diagram*. There, you can see the external force and its weight
    force applied, where ![Image](../images/gvictorit.jpg) is gravity’s acceleration
    vector.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig02.jpg)'
- en: '*Figure 11-2: A mass subject to external force*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：受外力作用的物体*'
- en: 'Using Newton’s second law and denoting the position vector of the body by ![Image](../images/pvictorit.jpg),
    we get the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用牛顿第二定律，并将物体的位置向量表示为![Image](../images/pvictorit.jpg)，我们得到以下方程：
- en: '![Image](../images/f0289-01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0289-01.jpg)'
- en: Solving for the acceleration ![Image](../images/pcapvictorit.jpg),
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 求解加速度![Image](../images/pcapvictorit.jpg)，
- en: '![Image](../images/f0289-02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0289-02.jpg)'
- en: 'The previous vector equation can be broken down into its two scalar components:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述向量方程可以分解为其两个标量分量：
- en: '![Image](../images/f0289-03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0289-03.jpg)'
- en: These two equations express the acceleration of the body function of time. To
    simulate this simple system, we’d need to obtain a new value for the acceleration,
    velocity, and position of the body for each frame of the animation. We’ll see
    what this means in a minute.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方程表示物体加速度是时间的函数。为了模拟这个简单系统，我们需要为动画的每一帧获得物体的加速度、速度和位置的新值。我们稍后会看到这意味着什么。
- en: '***What Is a Simulation?***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***什么是仿真？***'
- en: A *simulation* is the study of the evolution of a system whose behavior is mathematically
    described. Simulations harness the computation power of modern central processing
    units (CPUs) to understand how a given system would behave under real conditions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*仿真*是研究一个系统演化的过程，该系统的行为可以通过数学公式描述。仿真利用现代中央处理单元（CPU）的计算能力来理解在实际条件下给定系统的表现。'
- en: Computer simulations are in general cheaper and simpler to set up than real-world
    experiments, so they’re used to study and predict the behavior of many engineering
    designs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机仿真通常比实际实验更便宜且更易于设置，因此它们被广泛用于研究和预测许多工程设计的行为。
- en: Take the system whose equations we derived in the previous section. Given an
    expression of the external force with respect to time like
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们在上一节中推导的系统为例。给定一个关于时间的外力表达式，如下所示：
- en: '![Image](../images/f0289-04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0289-04.jpg)'
- en: and the mass for the body is said to be *m* = 5kg, the acceleration equations
    become the following.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 物体的质量假设为*m* = 5kg时，加速度方程变为以下形式。
- en: '![Image](../images/f0290-01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0290-01.jpg)'
- en: These scalar equations give us the acceleration components for the body at every
    moment in time. Since the equations are simple, we can integrate them to obtain
    the expression of the velocity components,
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标量方程给出了物体在每一时刻的加速度分量。由于这些方程简单，我们可以通过积分得到速度分量的表达式，
- en: '![Image](../images/f0290-02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0290-02.jpg)'
- en: 'where *Ẋ*[0] and *Ẏ*[0] are the components of the initial velocity: the velocity
    at time *t* = 0\. We know the velocity of the mass for every moment in time. If
    we want to animate the movement of the mass, we need an expression for the position,
    which we can obtain by integrating the velocity equations,'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*Ẋ*[0]和*Ẏ*[0]是初始速度的分量：即时间*t* = 0时的速度。我们知道物体在每一时刻的速度。如果我们想要为物体的运动制作动画，就需要一个位置的表达式，这可以通过积分速度方程得到，
- en: '![Image](../images/f0290-03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0290-03.jpg)'
- en: where *X*[0] and *Y*[0] are the initial position components for the mass. We
    can now create an animation to understand how the body moves under the effect
    of the external force by simply creating a sequence of time values, obtaining
    the position for each of them, and then drawing a rectangle to the screen at that
    position.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*X*[0]和*Y*[0]是物体的初始位置分量。我们现在可以通过创建一系列时间值来生成动画，计算每个时间点的位置，然后在该位置上画一个矩形显示在屏幕上，从而理解物体在外力作用下如何运动。
- en: The *differential equations* relating how the acceleration of the system varies
    with respect to time for this example were straightforward, which allowed us to
    obtain an analytic solution using integration. We usually don’t get an analytic
    solution for the system under simulation, so we tend to resort to numerical methods.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与该例子中系统加速度如何随时间变化相关的*微分方程*是直接的，这使得我们能够通过积分得到解析解。我们通常无法为仿真中的系统获得解析解，因此我们倾向于使用数值方法。
- en: The *analytic solution* is the exact solution, whereas a *numerical solution*
    is obtained using computer algorithms that look for an approximation of the solution.
    A common numerical method, although not the most precise, is *Euler’s method*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*解析解*是精确解，而*数值解*是通过计算机算法寻找解的近似值。常见的数值方法，尽管不是最精确的，是*欧拉法*。'
- en: Drawing the simulation in real time means we need to solve the equations as
    often as we draw frames. For example, if we want to simulate at a rate of 50 frames
    per second (fps), then we need to both draw the frames and solve the equations
    50 times per second.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实时绘制模拟意味着我们需要在每次绘制帧时都解算一次方程。例如，如果我们希望以每秒50帧（fps）的速率进行模拟，那么我们需要每秒解算方程50次并绘制50帧。
- en: At 50 fps, the time between frames is 20 milliseconds. Taking into account the
    fact that your computer requires some of those milliseconds to redraw the screen
    with the current frame, we’re left with little time for the math.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在50帧每秒（fps）的情况下，帧之间的时间为20毫秒。考虑到计算机需要一些时间来重绘当前帧，我们只剩下很少的时间来进行数学计算。
- en: Simulations can also be computed ahead of time and later played back. This way
    solving the equations can take as long as required; the animation takes place
    only when all frames are ready.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟也可以提前计算好，然后稍后回放。通过这种方式，解算方程的时间可以根据需要延长；只有当所有帧都准备好时，动画才会进行。
- en: Video game engines use real-time simulations as they need to simulate the world
    around the player as they interact with it, something that can’t be determined
    ahead of time. These engines tend to trade accuracy for speed; their results are
    not physically accurate but look realistic to the naked eye.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏引擎使用实时模拟，因为它们需要模拟玩家与世界互动的过程，这种互动无法提前确定。这些引擎通常以速度换取精度；它们的结果在物理上不完全准确，但从肉眼看起来是逼真的。
- en: Complex engineering systems require an ahead-of-time simulation since the governing
    equations for these problems are complex and require a much more exact solution.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的工程系统需要提前模拟，因为这些问题的控制方程非常复杂，需要更精确的解决方案。
- en: '**What Is the Time Loop?**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是时间循环？**'
- en: 'Real-time simulations happen inside a loop, which we’ll refer to as the *time
    loop* or *main loop*. This loop executes as many times per second as frames are
    drawn to the screen. Here’s some pseudocode showing what a time loop might look
    like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实时模拟发生在一个循环内，我们将其称为*时间循环*（time loop）或*主循环*（main loop）。这个循环每秒执行的次数与屏幕上绘制的帧数相同。以下是一些伪代码，展示时间循环可能的样子：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To make the animations look smooth, we want a steady frame rate. This means
    the drawing phase of the simulation should take place at evenly spaced points
    in time. (While not strictly necessary, there are techniques to adapt the frame
    rate to the processor and GPU’s throughput, but we won’t be getting that advanced
    in this book.)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使动画看起来更流畅，我们需要保持稳定的帧率。这意味着模拟的绘制阶段应该在时间上均匀分布地进行。（虽然这并非绝对必要，但有些技术可以根据处理器和GPU的吞吐量调整帧率，不过在本书中我们不会深入探讨这些技术。）
- en: 'The time elapsed between consecutive frames is referred to as the *time delta*,
    or *δt*; it’s inversely proportional to the frame rate (fps) and typically measured
    in seconds or milliseconds: ![Image](../images/f00291-p1.jpg). As a consequence,
    everything happening in our time loop should take less than a single time delta
    to complete.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 连续帧之间的时间差称为*时间差*（time delta）或*δt*；它与帧率（fps）成反比，通常以秒或毫秒为单位进行度量： ![Image](../images/f00291-p1.jpg)。因此，时间循环中发生的所有事情都应该在一个时间差内完成。
- en: The first step in the loop is solving the equations to figure out how the system
    has evolved during the elapsed time delta. Then, we draw the system’s new configuration
    to the screen. We need to measure the time taken so far in the loop and store
    the result in the time_taken variable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的第一步是解算方程，找出系统在经过的时间差（delta）期间是如何演变的。然后，我们将系统的新配置绘制到屏幕上。我们需要测量当前循环中已经过去的时间，并将结果存储在`time_taken`变量中。
- en: At this point, the program is paused or put to sleep until an entire time delta
    has elapsed. The time we sleep can be figured out by subtracting time _taken from
    time_delta. The last step before ending the loop is to advance the current time
    by a time delta; the loop then starts over again. [Figure 11-3](ch11.xhtml#ch11fig3)
    shows the time line with the events in the time loop drawn.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，程序会暂停或进入休眠状态，直到整个时间差已过。我们可以通过从`time_delta`中减去`time_taken`来计算需要休眠的时间。在结束循环之前的最后一步是将当前时间向前推进一个时间差；然后循环重新开始。[图
    11-3](ch11.xhtml#ch11fig3)展示了时间线和时间循环中的事件。
- en: '![Image](../images/11fig03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig03.jpg)'
- en: '*Figure 11-3: The time loop events*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：时间循环事件*'
- en: Now that we have those definitions out of the way, let’s implement a time loop
    and start animating.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些定义，接下来让我们实现一个时间循环并开始动画制作。
- en: '**Our First Animation**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我们的第一个动画**'
- en: At the beginning of the chapter, we explained how we can achieve the sensation
    of motion by drawing something many times per second. The time loop is in charge
    of keeping these drawings at a steady rate. Let’s implement our first time loop.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '***Setup***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start by creating a new file where we can experiment. In the *simulation*
    package, create a new file and name it *hello_motion.py*. Enter the code in [Listing
    11-1](ch11.xhtml#ch11lis1).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-1: The hello_motion.py file*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code in [Listing 11-1](ch11.xhtml#ch11lis1), we start by creating a
    600 × 600–pixel canvas and adding it to the grid of the main window. Then we initialize
    some variables: frame_rate_s holds the time between two consecutive frames, in
    seconds; frame_count is the count of how many frames have already been drawn;
    and max_frames is the number of total frames we’ll draw.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '*Note that the variables storing time-related quantities include information
    in their name about the unit they use. The* s *in* frame_rate_s *or* elapsed_s
    *indicates seconds. It’s good practice to do this, as it helps the developer understand
    what units the code is working with without needing to read comments or pick through
    all the code. When you spend many hours a day coding, these small details end
    up saving you a lot of time and frustration.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the time loop ➊, which executes max_frames times at a rate of frame_rate_s,
    at least in principle (as you’ll see in a minute). Note that we chose to limit
    the simulation using a maximum number of frames, but we could also limit it by
    time, that is, keep running the loop until a given amount of time has elapsed,
    just like we did in the pseudocode shown earlier. Both approaches work fine.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: In the loop we start by storing the current time in update_start. After the
    updates to the system and the drawing have taken place, we store the time again,
    this time in update_end. The time elapsed is then computed by subtracting update_start
    from update_end and stored in elapsed_s ➎. We use this quantity to calculate how
    long the loop needs to sleep to keep the frame rate steady, subtracting elapsed_s
    from frame_rate_s. That amount is stored in remaining_time_s, and if it’s greater
    than zero, we sleep the loop ➏.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: If remaining_time_s is less than zero, the loop took longer than the frame rate,
    meaning it can’t keep up with the rhythm we imposed on it. If this happens often,
    the time loop will become unsteady, and animations may look chunky, in which case
    it’s better to simply reduce the frame rate.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'The magic happens (or will happen, to be more precise) in update _system ➋
    and redraw ➌, which we call in the loop to update and redraw the system. Here’s
    where we’ll soon be writing our drawing code. The pass statement is used in Python
    as a placeholder: it doesn’t do anything, but it allows us to have, for example,
    a valid function body.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a call to update from main window tk ➍, which tells Tkinter to
    run the main loop until all pending events have been processed. This is necessary
    to force Tkinter to look for the events that may trigger changes in the user interface
    widgets, including our canvas.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 还调用了从主窗口 tk ➍ 更新，这告诉 Tkinter 运行主循环，直到所有待处理事件都被处理完。这是强制 Tkinter 查找可能触发用户界面小部件（包括我们的画布）变化的事件所必需的。
- en: You can run the file now; you’ll see an empty window apparently doing nothing,
    but it’s actually running the loop max_frames times.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行文件了；你会看到一个空白窗口，表面上什么也没做，但它实际上正在运行最大帧数次数的循环。
- en: '***Adding a Frame Count Label***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***添加帧计数标签***'
- en: 'Let’s add a label under the canvas to let us know the current frame being drawn
    to the canvas and the total number of frames. We can update its value in update.
    First, add Label to the tkinter imports:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在画布下方添加一个标签，显示当前绘制到画布上的帧以及总帧数。我们可以在 update 中更新它的值。首先，向 tkinter 导入中添加 Label：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, under the definition of the canvas, add the label ([Listing 11-2](ch11.xhtml#ch11lis2)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在画布定义下方添加标签（[Listing 11-2](ch11.xhtml#ch11lis2)）。
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 11-2: Adding a label to the window*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-2: 向窗口添加标签*'
- en: Finally, update the label’s text in update by setting the value of its text
    variable, label ([Listing 11-3](ch11.xhtml#ch11lis3)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过设置标签的文本变量 label 的值，在 update 中更新标签的文本（[Listing 11-3](ch11.xhtml#ch11lis3)）。
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 11-3: Updating the label’s text*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-3: 更新标签文本*'
- en: 'Try to run the file now. The canvas is still blank, but the label below it
    now displays the current frame. Your program should look like [Figure 11-4](ch11.xhtml#ch11fig4):
    a blank window with a frame count going from 1 to 100.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试着运行文件。画布仍然是空白的，但下面的标签现在显示了当前帧。你的程序应该像[Figure 11-4](ch11.xhtml#ch11fig4)那样：一个空白窗口，帧计数从
    1 到 100。
- en: '![Image](../images/11fig04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig04.jpg)'
- en: '*Figure 11-4: The frame count label*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 11-4: 帧计数标签*'
- en: Just for reference, your code at this stage should look like [Listing 11-4](ch11.xhtml#ch11lis4).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 仅供参考，此阶段你的代码应该像[Listing 11-4](ch11.xhtml#ch11lis4)这样。
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 11-4: Hello canvas with label*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-4: 画布与标签*'
- en: To have anything drawn on the canvas, we need to have a system. Let’s first
    take a look at how to add and update a system to our simulation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在画布上绘制任何内容，我们需要有一个系统。让我们先来看一下如何向我们的模拟中添加和更新一个系统。
- en: '***Updating the System***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更新系统***'
- en: For this example, we’ll keep it simple and draw a circle whose center is always
    at the center of the canvas, point (300, 300). Its radius will grow, starting
    with a value of zero. When the radius grows larger than the canvas and is no longer
    visible, we’ll set it back to zero. This will generate a psychedelic tunnel-like
    effect.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将保持简单，绘制一个圆，其中心始终位于画布的中心点（300, 300）。它的半径将从零开始增长。当半径大于画布并不再可见时，我们将其重置为零。这将生成一个类似迷幻隧道的效果。
- en: 'We can represent our “system” with an instance of our Circle class. Since we’ll
    be drawing the circle to the canvas, let’s also create an instance of Canvas Drawing,
    using an identity affine transformation. Under the definition of variables frame_rate_s,
    frame_count, and max_frames, add the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 Circle 类的一个实例来表示我们的“系统”。由于我们将把圆绘制到画布上，所以我们还需要创建一个 Canvas Drawing 的实例，并使用身份仿射变换。在变量
    frame_rate_s、frame_count 和 max_frames 的定义下，添加以下内容：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Don’t forget to include the needed imports:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了包含必要的导入：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We need to update the value of the radius every frame in update_system so that
    when redraw does its thing, the circle gets drawn with the updated value for the
    radius. In update_system, enter the code in [Listing 11-5](ch11.xhtml#ch11lis5).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 update_system 中每帧更新半径的值，这样当重新绘制时，圆就会以更新后的半径值绘制。在 update_system 中，输入 [Listing
    11-5](ch11.xhtml#ch11lis5) 中的代码。
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 11-5: Updating the circle’s radius*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-5: 更新圆的半径*'
- en: The value for the radius is updated by adding 15 to the current value. Using
    the modulo operator (%), whenever the radius becomes greater than 450, the value
    wraps around and goes back to zero.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 半径的值通过将当前值加上 15 来更新。使用取模运算符（%），每当半径大于 450 时，值会回绕并重新归零。
- en: '**NOTE**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Quick reminder: the modulo operator* % *returns the remainder of dividing
    its two operands. For instance,* 5 % 3 *yields* 2.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*温馨提示：取模运算符* % *返回两个操作数相除后的余数。例如，* 5 % 3 *等于* 2。'
- en: You’ve probably realized that we mutated the circle’s radius property instead
    of creating a new circle with the value for the new radius; it’s the first time
    in the book we mutate the properties of our geometric primitives. The reason is
    that, for simulations, maintaining the throughput of the loop is crucial, and
    creating a new instance of the system for each frame would have a high performance
    impact.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，我们修改了圆形的半径属性，而不是用新的半径值创建一个新的圆形；这是本书中第一次修改几何原件的属性。这样做的原因是，在模拟中，保持循环的吞吐量非常关键，而为每一帧创建一个新的系统实例会对性能产生较大的影响。
- en: 'We now have the system defined in each of the frames: a circle whose center
    point is kept centered in the window while the radius gradually increases in size.
    Let’s draw it to the screen!'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在每一帧中定义了系统：一个圆形，它的中心点始终保持在窗口的中心，而半径逐渐增大。让我们把它绘制到屏幕上吧！
- en: '***Creating Motion***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建运动***'
- en: To create the effect of motion, the canvas has to be cleared and the system
    redrawn in each and every frame. Before redraw is invoked in the main loop, update_system
    has already updated the circle. In redraw, we simply need to clear whatever is
    drawn on the canvas and draw the circle again. Update redraw using the code in
    [Listing 11-6](ch11.xhtml#ch11lis6).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建运动效果，画布必须在每一帧中都被清空，并且系统要重新绘制。在主循环中调用重绘之前，`update_system`已经更新了圆形。在重绘中，我们只需清除画布上已经绘制的内容，再次绘制圆形。使用[清单
    11-6](ch11.xhtml#ch11lis6)中的代码更新重绘。
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 11-6: Redrawing the circle every frame*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-6：每帧重绘圆形*'
- en: You’ve probably been waiting for this grand moment for the whole chapter, so
    go ahead and execute the file. You should see a circle growing in size until it
    disappears from the screen and then starting over again.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经等待了整个章节的这个重要时刻，现在可以执行文件了。你应该会看到一个圆形逐渐变大，直到从屏幕上消失，然后再重新开始。
- en: Just for your reference, at this point, your *hello_motion.py* code should look
    like [Listing 11-7](ch11.xhtml#ch11lis7).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 仅供参考，此时你的*hello_motion.py*代码应该类似于[清单 11-7](ch11.xhtml#ch11lis7)。
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 11-7: Resulting simulation*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-7：结果模拟*'
- en: Note that before drawing anything, the redraw function clears the canvas. Can
    you guess what would happen if we forgot to do so? Comment that line out and run
    the simulation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在绘制任何内容之前，重绘函数会清除画布。如果我们忘记这么做，你能猜到会发生什么吗？将那一行注释掉，然后运行模拟。
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All circles drawn should remain on the canvas, as you see in [Figure 11-5](ch11.xhtml#ch11fig5).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有绘制的圆形应保持在画布上，就像你在[图 11-5](ch11.xhtml#ch11fig5)中看到的那样。
- en: We’ve drawn our first animation on the canvas, and it looks fantastic. If we
    were to write another, though, we’d have to copy and paste the code for the main
    loop. To avoid this needless duplication, let’s move the main loop code into a
    function that can be easily reused.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在画布上绘制了第一个动画，看起来很棒。然而，如果我们再写一个，我们就不得不复制并粘贴主循环的代码。为了避免这种不必要的重复，让我们将主循环代码移动到一个可以轻松重用的函数中。
- en: '![Image](../images/11fig05.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/11fig05.jpg)'
- en: '*Figure 11-5: What it’d look like if we forgot to clean the canvas*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：如果我们忘记清理画布，会是什么样子*'
- en: '**Abstracting the Main Loop Function**'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**抽象化主循环函数**'
- en: 'The main loop we just wrote had a fair amount of logic that will be the same
    for all simulations. Copying and pasting this code over and over again would not
    only be bad practice, but if we found an improvement or wanted to make a change
    to our implementation, we’d need to edit the code of all our simulations. We don’t
    want to duplicate knowledge: we should define the logic for a main simulation
    loop in just one place.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的主循环包含了相当多的逻辑，这些逻辑在所有模拟中都是相同的。如果我们不断地复制和粘贴这些代码，不仅会违反编码规范，而且如果我们发现了改进之处或想要修改实现，我们就需要编辑所有模拟的代码。我们不希望重复知识：我们应该在一个地方定义主模拟循环的逻辑。
- en: 'To implement a generic version of the main loop, we need to do an abstraction
    exercise. Let’s ask ourselves the following questions regarding the implementation
    of the main loop: Is there something that’s never going to change in it, and is
    there anything simulation-specific? The while loop, the order of the operations
    inside of it, and the time calculations are the same for every simulation. Conversely,
    there are three pieces of logic that vary from simulation to simulation, namely,
    the decision that keeps the loop running, the updating, and the drawing.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个通用版本的主循环，我们需要进行抽象化操作。让我们问自己以下几个问题，关于主循环的实现：其中有没有什么永远不会改变的部分，或者有没有什么特定于仿真的内容？while
    循环、内部操作的顺序以及时间计算在每个仿真中都是相同的。相反，有三部分逻辑会因仿真不同而有所变化，即决定主循环是否继续的条件、更新操作和绘制操作。
- en: If we encapsulate those in functions that the simulations implement, they can
    be passed to our main loop abstraction. The main loop we implement only needs
    to care about the timing, that is, trying to keep the frame rate stable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些逻辑封装到仿真所实现的函数中，它们就可以被传递给我们的主循环抽象。我们实现的主循环只需要关注时序，即尽量保持帧率稳定。
- en: Create a new file named *loop.py* in the *simulation* package. Enter the code
    in [Listing 11-8](ch11.xhtml#ch11lis8).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *simulation* 包中创建一个名为 *loop.py* 的新文件。输入 [示例 11-8](ch11.xhtml#ch11lis8) 中的代码。
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 11-8: Simulation’s main loop function*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-8：仿真主循环函数*'
- en: 'The first thing you should notice is that three of the arguments to the main_loop
    function are also functions: update_fn, redraw_fn, and should_continue _fn. These
    functions contain the logic that’s simulation-specific, so our main loop simply
    needs to call them as needed.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该首先注意到，main_loop 函数的三个参数也是函数：update_fn、redraw_fn 和 should_continue_fn。这些函数包含了特定于仿真的逻辑，因此我们的主循环只需按需调用它们。
- en: '**NOTE**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Passing functions as arguments to other functions was covered in [Chapter
    1](ch01.xhtml#ch01), on [page 27](ch02.xhtml#ch00lev2sec20). You may want to refer
    to this section for a quick refresher.*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*将函数作为参数传递给其他函数的内容已在[第1章](ch01.xhtml#ch01)的[第27页](ch02.xhtml#ch00lev2sec20)中介绍过。你可能想参考这一部分以便快速复习。*'
- en: 'The main_loop function starts by declaring three variables: frame, which holds
    the current frame index; time_s, which holds the total time elapsed; and last_elapsed_s,
    which holds the number of seconds it took the last frame to complete. The condition
    to keep the loop running is now delegated to the should_continue_fn function ➊.
    The loop will continue as long as this function returns true. It accepts two arguments:
    the frame count and the total time elapsed in seconds. If you recall, most of
    our simulations will be limited by one of these values, so we pass them to the
    function so that it has the information required to decide whether the loop should
    keep running.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: main_loop 函数首先声明三个变量：frame，表示当前帧的索引；time_s，表示总的经过时间；以及 last_elapsed_s，表示上一个帧完成所用的秒数。继续循环的条件现在被委托给
    should_continue_fn 函数 ➊。只要该函数返回 true，循环将继续。它接受两个参数：帧数和总的经过时间（秒）。如果你还记得，我们的大多数仿真将由其中一个值限制，因此我们将它们传递给该函数，以便它能够获得判断循环是否应该继续运行所需的信息。
- en: 'Next, the update_fn function ➋ updates the system under simulation and the
    user interface. This function receives three parameters: the time elapsed since
    the last frame, last_elapsed_s; the total elapsed time for the simulation, time_s;
    and the current frame number, frame. As we’ll see later in the book, when we introduce
    physics to our simulations, the amount of time elapsed since the last frame is
    an important piece of data. Lastly comes redraw_fn ➌, which draws the system to
    the screen.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，update_fn 函数 ➋ 用于更新仿真系统和用户界面。该函数接收三个参数：自上一个帧以来的时间间隔 last_elapsed_s；仿真总的经过时间
    time_s；以及当前的帧数 frame。正如我们在后续章节中会看到的，当我们将物理引擎引入仿真时，自上一个帧以来的时间间隔将成为一个重要的数据。最后是 redraw_fn
    ➌，用于将系统绘制到屏幕上。
- en: Thanks to our abstraction of the simulation’s main loop, we won’t need to write
    this logic anymore. Let’s try to refactor our simulation from the previous section
    using this definition of the main loop.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了我们对仿真主循环的抽象，我们不再需要编写这部分逻辑。让我们尝试使用这种主循环定义来重构上一节的仿真。
- en: '**Refactoring Our Simulation**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**重构我们的仿真**'
- en: Now that we’ve created an abstraction of the main loop, let’s take a look at
    how our simulation could be refactored to include the main loop function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了主循环的抽象，让我们看看如何重构我们的仿真，来包含主循环函数。
- en: Create a new file named *hello_motion_refactor.py* and enter the code from [Listing
    11-9](ch11.xhtml#ch11lis9). You may want to copy and paste the first lines from
    *hello_motion.py*, those that define the UI. Note that to make the code a bit
    shorter, I’ve removed the frame count label from the UI.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件，命名为 *hello_motion_refactor.py*，并输入[列表 11-9](ch11.xhtml#ch11lis9)中的代码。你可能想要复制并粘贴
    *hello_motion.py* 中的前几行，这些行定义了用户界面。请注意，为了让代码简短一些，我已从界面中移除了帧计数标签。
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 11-9: Refactored version of hello_motion.py*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-9：重构后的 hello_motion.py 版本*'
- en: If we go toward the end of the code, we find the call to main_loop. We’re passing
    in the functions that we previously defined, with the sole difference being that
    now those functions must declare the proper parameters to match the functions
    main_loop expects.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看代码的结尾部分，找到调用 `main_loop` 的位置。我们传入了之前定义的函数，唯一的区别是，现在这些函数必须声明适当的参数，以匹配 `main_loop`
    函数所期望的参数。
- en: This code is much simpler to follow. All the logic to keep a steady frame rate
    has been moved away to its own function, so we can focus our attention on the
    simulation itself without needing to deal with those details. Let’s now take some
    time to play with some of the parameters of the simulation and understand how
    they affect the final result.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更加简洁易懂。所有保持稳定帧率的逻辑已经被移到它自己的函数中，这样我们就能专注于模拟本身，而不需要处理那些细节。现在，让我们花点时间玩一下模拟的一些参数，了解它们是如何影响最终结果的。
- en: '***Playing with the Circle Divisions***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***玩转圆形分段***'
- en: Remember that the CanvasDrawing class includes an affine transformation as part
    of its state, and every geometric primitive gets transformed by it before being
    drawn. Remember also that this is the reason a circle is converted to a generic
    polygon using a number of divisions high enough to approximate the circumference.
    The transformation happens in the drawing command; hence, the number of divisions
    has to be passed in, or else the default of 30 is used.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，CanvasDrawing 类在其状态中包括一个仿射变换，并且每个几何图形在绘制之前都会通过这个变换进行转换。还要记住，这也是为什么圆形会被转换成一个通用多边形，使用足够多的分段来近似圆周的原因。变换发生在绘制命令中；因此，必须传入分段数，否则会使用默认值
    30。
- en: Going back to function redraw from [Listing 11-9](ch11.xhtml#ch11lis9),
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[列表 11-9](ch11.xhtml#ch11lis9)中的 `redraw` 函数，
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'you can see we used 50 divisions, but we could have used any other number.
    Let’s try with 10, for example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们使用了 50 个分段，但我们也可以使用其他任何数字。例如，我们可以尝试 10 个分段：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Rerun the file. Can you see the difference? What about if you try with 6 divisions?
    [Figure 11-6](ch11.xhtml#ch11fig6) shows the simulation using 50, 10, and 6 divisions
    for the circle.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行文件。你能看到差异吗？如果你尝试使用 6 个分段，结果如何？[图 11-6](ch11.xhtml#ch11fig6) 显示了使用 50、10
    和 6 个分段进行圆形模拟的结果。
- en: '![Image](../images/11fig06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/11fig06.jpg)'
- en: '*Figure 11-6: Circles drawn using 50, 10, and 6 divisions*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-6：使用 50、10 和 6 个分段绘制的圆形*'
- en: After this interesting experiment we can clearly see the influence of the divisions
    used to approximate a circle. Let’s now experiment with the affine transformation
    used to transform the geometric primitives before they’re drawn to the canvas.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这个有趣的实验后，我们可以清楚地看到分段数量如何影响圆形的近似效果。现在让我们来实验一下用于在绘制到画布之前转换几何图形的仿射变换。
- en: '***Playing with the Affine Transformation***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***玩转仿射变换***'
- en: 'The affine transformation applied to the drawing in our simulation is an identity
    transformation: it keeps points exactly where they are. But we could use this
    transformation to do something different, such as invert the y-axis so that it
    points upward, for example. Go back to *hello_motion_refactor.py* and locate the
    line where the transformation is defined:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模拟中应用的仿射变换是一个恒等变换：它保持点的位置不变。但我们可以使用这个变换做些不同的事，比如反转 y 轴，使其指向上方。例如，返回到 *hello_motion_refactor.py*，找到定义变换的那一行：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, edit it so that it inverts the y-axis:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编辑它以反转 y 轴：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the simulation again. What do you see? Just a little rim coming from the
    top of the canvas, right? What’s happening is that we inverted the y-axis, but
    the origin of coordinates is still in the upper-left corner; thus, the circle
    we’re trying to draw is outside the window, as depicted by [Figure 11-7](ch11.xhtml#ch11fig7).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行模拟。你看到什么了？只是从画布顶部冒出来的一点边缘，对吧？发生的情况是，我们反转了 y 轴，但坐标原点仍然在左上角；因此，我们尝试绘制的圆形超出了窗口范围，如[图
    11-7](ch11.xhtml#ch11fig7)所示。
- en: '![Image](../images/11fig07.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/11fig07.jpg)'
- en: '*Figure 11-7: Simulation with the y-axis inverted*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily fix this problem by translating the origin of the coordinates
    all the way down to the lower-left corner of the canvas. Since the canvas height
    is 600 pixels, we can set the transformation to be as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It may surprise you that the value for the vertical translation is 600 and not
    – 600, but remember that in the original system of coordinates, the y direction
    points downward, and this affine transformation refers to that system.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer, it may be easier to understand the process of obtaining that
    transformation by concatenating two simpler ones, the first moving the origin
    downward 600 pixels and the second flipping the y-axis,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: which yields the same transformation, as you can see.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s add some shear in the horizontal direction to see how the circle
    gets deformed. Try the following values for the transformation,
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: and run the simulation again. You should see a shape similar to that in [Figure
    11-8](ch11.xhtml#ch11fig8).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-8: A circle drawn using a horizontal shear*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s your turn to play with the values and see whether you can build a better
    intuition for how the animations, drawings, and transformations are working. You’ve
    created something beautiful from scratch, so take your time to experiment with
    it. Try to change the circle primitive using a triangle or a rectangle. You can
    update the geometric primitive by moving it instead of changing its size. Play
    around with the affine transformation values and try to reason about how the drawing
    should look before you actually run the simulation. Use this exercise to reinforce
    your affine transformation intuition.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '**Cleaning Up the Module**'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s do two small refactors to the module to clean it up a bit. First, create
    a new folder in the *simulation* package and name it *examples*. We’ll use it
    to house all the files that are not part of the simulation and drawing logic,
    but rather examples we wrote in this chapter. So, basically, move all the files
    except for *draw.py* and *loop.py* there. Your folder structure in *simulation*
    should look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: simulation
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '|- examples'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- hello_canvas.py'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- hello_motion.py'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- ...'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '|- draw.py'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '|- loop.py'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing we want to do is add both the CanvasDrawing class and the
    main_loop function to the default exports of the *simulation* package. Open file
    *__init__.py* in *simulation* and add the following imports:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That’s it! From now on we’ll be able to import both using a shorter syntax.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about the time loop. The time loop keeps executing
    while a condition is met, and its main job is to keep the frame rate steady. In
    this loop two things take place: the updating of the system under simulation and
    the redrawing of the screen. Those operations are timed so that when they’re done,
    we know how much more time remains to complete a cycle.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the time loop will appear in all of our simulations, we decided to
    implement it as a function. This function gets passed other functions: one that
    updates the system, another that draws it to the screen, and a last one that decides
    whether the simulation is over or not.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为时间循环将在我们所有的模拟中出现，我们决定将其实现为一个函数。这个函数接收其他函数作为参数：一个用于更新系统，另一个用于将其绘制到屏幕上，最后一个用于决定模拟是否结束。
- en: In the next chapter, we’ll use this time loop function to animate affine transformations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将使用这个时间循环函数来动画仿射变换。
