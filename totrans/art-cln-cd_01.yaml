- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: How Complexity Harms Your Productivity
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性如何损害你的生产力
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we’re going to have a comprehensive look at the important and
    highly underexplored topic of complexity. What exactly is *complexity*? Where
    does it occur? How does it damage your productivity? Complexity is the enemy of
    the lean and efficient organization and individual, so it’s worth taking a close
    look at all areas where we find complexity and what forms it takes. This chapter
    focuses on the problem—complexity—and the remaining chapters will explore effective
    methods to attack it by redirecting the released resources previously occupied
    by complexity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将全面探讨一个重要且高度未被充分研究的话题——复杂性。究竟什么是*复杂性*？它在哪里发生？它如何损害你的生产力？复杂性是精益高效的组织和个人的敌人，因此值得仔细观察我们在哪些领域发现复杂性以及它表现出哪些形式。本章专注于问题——复杂性，接下来的章节将探讨通过重新分配之前被复杂性占用的资源来有效解决这一问题的方法。
- en: 'Let’s start with a quick overview of where complexity may be daunting to a
    new coder:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先快速概览一下新手程序员可能会觉得复杂的地方：
- en: Choosing a programming language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一种编程语言
- en: Choosing a coding project to work on—from thousands of open source projects
    and myriads of problems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个编程项目来进行——从成千上万的开源项目和无数的问题中选择
- en: Deciding which libraries to use (scikit-learn versus NumPy versus TensorFlow)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定使用哪些库（scikit-learn 与 NumPy 与 TensorFlow）
- en: Deciding which emerging technologies to invest time in—Alexa apps, smartphone
    apps, browser-based web apps, integrated Facebook or WeChat apps, virtual reality
    apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定将时间投入哪些新兴技术——Alexa 应用、智能手机应用、基于浏览器的 web 应用、集成的 Facebook 或微信应用、虚拟现实应用
- en: Choosing a coding editor such as PyCharm, Integrated Development and Learning
    Environment (IDLE), and Atom
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个编码编辑器，如 PyCharm、集成开发与学习环境（IDLE）和 Atom
- en: Given the great confusion caused by these sources of complexity, it’s no surprise
    that *“How do I start?”* is one of the most common questions from programming
    beginners.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些复杂性来源所带来的巨大困惑，*“我该从哪里开始？”* 成为编程初学者最常见的问题之一，也就不足为奇了。
- en: The best way to start is *not* by choosing a programming book and reading about
    all the syntactical features of the programming language. Many ambitious students
    buy programming books as an incentive and then add the learning task to their
    to-do lists—if they’ve spent money on the book, they better read it or the investment
    will be lost. But as with so many other tasks on to-do lists, *reading a programming
    book* is seldomly completed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的开始方式是*不要*通过选择一本编程书并阅读编程语言的所有语法特性来开始。许多有抱负的学生购买编程书籍作为激励，然后把学习任务加入他们的待办事项列表——如果他们已经花钱买了书，他们最好去读，否则投资就会丧失。但和许多待办事项列表中的任务一样，*阅读编程书籍*很少能完成。
- en: 'The best way to start is to choose a practical code project—a simple one if
    you’re a beginner—and push it to completion. Don’t read coding books or random
    tutorials on the web before completing a full project. Don’t scroll through endless
    feeds on StackOverflow. Just set up the project and start coding with the limited
    skills you have and your common sense. A student of mine wanted to create a financial
    dashboard application checking the historic returns of different asset allocations
    to answer questions such as “What was the maximum down year of a portfolio consisting
    of 50 percent stocks and 50 percent government bonds?” At first she didn’t know
    how to approach this project but soon found out about a framework called Python
    Dash that deals with building data-based web apps. She learned how to set up a
    server and studied just the HyperText Markup Language (HTML) and Cascading Style
    Sheets (CSS) she needed to move forward, and now her app is live and has already
    helped thousands of people find the right asset allocation. But, more importantly,
    she joined the team of developers that created Python Dash and is even writing
    a book about it with No Starch Press. She did all of this in one year—and you
    can, too. It’s okay if you don’t understand what you’re doing; you will gradually
    increase your understanding. Read articles only to make progress on the project
    in front of you. The process of finishing your first project introduces a number
    of highly relevant problems, including:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的开始方式是选择一个实用的编码项目——如果你是初学者，可以选择一个简单的项目——并推动它完成。在完成一个完整项目之前，不要去阅读编码书籍或互联网上的随机教程，也不要在
    StackOverflow 上翻阅无休止的帖子。只需设置好项目并利用你现有的有限技能和常识开始编码。我的一位学生想要创建一个财务仪表盘应用，用于查看不同资产配置的历史回报，以回答像“由
    50% 股票和 50% 政府债券组成的投资组合在某一年最大的亏损是多少？”这样的提问。起初，她不知道如何着手这个项目，但很快发现了一个名为 Python Dash
    的框架，这个框架专注于构建基于数据的 web 应用。她学习了如何设置服务器，并且只研究了她所需的超文本标记语言（HTML）和层叠样式表（CSS），最终她的应用已经上线，并且帮助了成千上万的人找到合适的资产配置。但更重要的是，她加入了创建
    Python Dash 的开发团队，甚至与 No Starch Press 一起写了一本关于它的书。她在一年内完成了这一切——你也可以做到。如果你不理解自己在做什么也没关系；你会逐渐增加自己的理解。只要通过阅读文章推动当前项目的进展即可。完成第一个项目的过程会引入一系列非常相关的问题，包括：
- en: Which code editor should you use?
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该使用哪个代码编辑器？
- en: How do you install your project’s programming language?
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何安装你项目的编程语言？
- en: How do you read input from a file?
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从文件中读取输入？
- en: How do you store the input in your program for later use?
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在程序中存储输入以供后续使用？
- en: How do you manipulate the input to obtain the desired output?
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何处理输入以获得期望的输出？
- en: By answering these questions, you’ll gradually build a well-rounded skill set.
    Over time, you’ll be able to answer these questions better and more easily. You’ll
    be able to solve much bigger problems, and you’ll build up an internal database
    of programming patterns and conceptual insights. Even advanced coders learn and
    improve with this same process—only the coding projects have become much larger
    and more complicated.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答这些问题，你将逐步建立起一个全面的技能组合。随着时间的推移，你将能够更好、更轻松地回答这些问题。你将能够解决更大、更复杂的问题，并积累起一个内部的编程模式和概念洞察数据库。即便是高级程序员，也通过相同的过程进行学习和提升——只不过编码项目变得更大、更复杂。
- en: With this project-based learning approach, you’ll likely find that you struggle
    with complexity in areas such as finding bugs in ever-growing codebases, understanding
    code components and how they interact, choosing the right feature to be implemented
    next, and understanding the mathematical and conceptual basics of the code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种基于项目的学习方法，你很可能会发现自己在诸如寻找日益增长的代码库中的 bug、理解代码组件及其交互、选择下一个要实现的功能以及理解代码的数学和概念基础等方面与复杂性作斗争。
- en: 'Complexity is everywhere, at every stage of a project. The hidden cost of this
    complexity is often that brand-new coders throw in the towel and their projects
    never see the light of day. So, the question arises: How do I solve the problem
    of complexity?'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性无处不在，贯穿项目的每个阶段。这种复杂性的隐藏成本通常是，刚入门的程序员会放弃，他们的项目最终无法实现。所以，问题就来了：我该如何解决复杂性问题？
- en: 'The answer is straightforward: *simplicity*. Seek simplicity and focus in every
    stage of the coding cycle. If you take only one thing away from this book, let
    it be this: take a radically minimalistic position in every area you encounter
    in programming. Throughout the book, we’ll discuss all of the following methods:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：*简单性*。在编码的每个阶段寻求简单性和专注。如果你从这本书中只记住一件事，那就是：在你遇到的编程领域中采取极简的立场。全书将讨论以下所有方法：
- en: Declutter your day, do fewer tasks, and focus your efforts on the tasks that
    matter. For example, instead of starting 10 new interesting code projects in parallel,
    carefully select one and focus all your efforts on finishing this one project.
    In Chapter 2, you’ll learn about the 80/20 principle in programming in greater
    detail.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理你的日程，做更少的任务，把精力集中在重要的任务上。例如，与其平行启动10个有趣的新代码项目，不如仔细挑选一个并将所有精力集中在完成这个项目上。在第2章，你将更详细地了解编程中的80/20原则。
- en: Given one software project, strip away all unnecessary features and focus on
    the minimum viable product (see Chapter 3), ship it, and validate your hypotheses
    quickly and efficiently.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个软件项目，去除所有不必要的功能，专注于最小可行产品（见第3章），发布它，并快速高效地验证你的假设。
- en: Write simple and concise code wherever you can. In Chapter 4, you’ll learn many
    practical tips for how to accomplish this.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的地方编写简单而简洁的代码。在第4章，你将学到如何实现这一目标的许多实用技巧。
- en: Reduce time and effort spent on premature optimization—optimizing code without
    need is one of the major reasons for unnecessary complexity (see Chapter 5).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少在过早优化上花费的时间和精力——没有必要的代码优化是导致不必要复杂性的主要原因之一（见第5章）。
- en: Reduce switching time by blocking large chunks of time for programming to obtain
    a state of *flow*—a term from psychological research to describe a focused state
    of mind that increases your attention, focus, and productivity. Chapter 6 is all
    about reaching a state of flow.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将大量时间块集中用于编程，减少切换时间，以达到*心流*状态——这是心理学研究中的术语，用来描述一种集中的心理状态，它能够提高你的注意力、专注力和生产力。第6章将全面讲解如何达到心流状态。
- en: Apply the Unix philosophy of focusing code functions on one objective only (“Do
    One Thing Well”). See Chapter 7 for a detailed guide to the Unix philosophy with
    Python code examples.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运用Unix哲学，专注于代码功能的单一目标（“做好一件事”）。有关Unix哲学的详细指南，包含Python代码示例，请见第7章。
- en: Apply simplicity in design to create beautiful, clean, and focused user interfaces
    that are easy to use and intuitive (see Chapter 8).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计中应用简化原则，创造美观、简洁、专注且易于使用的直观用户界面（见第8章）。
- en: Apply focusing techniques when planning your career, your next project, your
    day, or your area of expertise (see Chapter 9).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在规划职业、下一个项目、一天的工作或你的专业领域时，应用聚焦技巧（见第9章）。
- en: Let’s dive deeper into the concept of complexity to develop an understanding
    of one of the great enemies of your coding productivity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨复杂性这一概念，理解它是你编码生产力的巨大敌人之一。
- en: What Is Complexity?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是复杂性？
- en: In different fields, the term *complexity* comes with different meanings. Sometimes,
    it’s strictly defined, such as the *computational complexity* of a computer program
    that provides a means to analyze a given code function for varying inputs. Other
    times, it’s loosely defined as the amount or structure of interactions between
    system components. In this book, we’re going to use it more generically.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的领域，*复杂性*这个术语有不同的含义。有时它被严格定义，比如计算机程序的*计算复杂度*，这为分析给定代码功能在不同输入下的表现提供了一种方法。其他时候，它是宽泛定义的，指的是系统组件之间的交互量或结构。在本书中，我们将更广泛地使用它。
- en: 'We’ll define *complexity* as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将*复杂性*定义如下：
- en: Complexity A whole, made up of parts, that is difficult to analyze, understand,
    or explain.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复杂性是由多个部分组成的整体，难以分析、理解或解释。
- en: 'Complexity describes a whole system or entity. Because complexity makes the
    system difficult to explain, complexity causes struggle and confusion. Because
    real-world systems are messy, you’ll find complexity everywhere: the stock market,
    social trends, emerging political viewpoints, and big computer programs with hundreds
    of thousands of lines of code—such as the Windows operating system.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性描述的是一个整体或实体。由于复杂性使得系统难以解释，它会引起挣扎和困惑。因为现实世界的系统很混乱，你会发现复杂性无处不在：股市、社会趋势、新兴的政治观点、以及拥有数十万行代码的大型计算机程序——例如Windows操作系统。
- en: 'If you’re a coder, you are especially prone to overwhelming complexity, such
    as from these different sources that we’ll cover in this chapter:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个程序员，你尤其容易受到复杂性困扰，来自这些我们将在本章讨论的不同来源：
- en: Complexity in a project life cycle
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目生命周期中的复杂性
- en: Complexity in software and algorithmic theory
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件和算法理论中的复杂性
- en: Complexity in learning
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习中的复杂性
- en: Complexity in processes
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流程中的复杂性
- en: Complexity in social networks
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 社交网络中的复杂性
- en: Complexity in your daily life
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你日常生活中的复杂性
- en: Complexity in a Project Life Cycle
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目生命周期中的复杂性
- en: 'Let’s dive into the different stages of the project life cycle: planning, defining,
    designing, building, testing, and deployment (see [Figure 1-1](#figure1-1)).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨项目生命周期的不同阶段：规划、定义、设计、构建、测试和部署（见[图 1-1](#figure1-1)）。
- en: '![Life cycle graphic showing a circle of arrows pointing from planning to defining
    to designing to building to testing to deployment and back to planning. ](image_fi/502185c01/f01001.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![生命周期图示，展示一个从规划到定义、设计、构建、测试、部署再回到规划的箭头循环。](image_fi/502185c01/f01001.png)'
- en: 'Figure 1-1: The six conceptual phases of a software project based on the official
    Institute of Electrical and Electronics Engineers (IEEE) standard for software
    engineering'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：基于电气与电子工程师协会（IEEE）软件工程标准的软件项目六个概念性阶段
- en: Even if you’re working on a very small software project, you’re likely going
    through all six phases of the software development life cycle. Note that you may
    not necessarily go through each phase only once—in modern software development,
    a more iterative approach is generally preferred where each phase is revisited
    multiple times. Next, we’ll look at how complexity has a significant impact on
    each phase.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你正在处理一个非常小的软件项目，你也很可能经历软件开发生命周期的所有六个阶段。请注意，你不一定只能经历每个阶段一次——在现代软件开发中，更倾向于采用迭代方法，每个阶段会被反复
    revisited。接下来，我们将探讨复杂性如何对每个阶段产生重要影响。
- en: Planning
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规划
- en: The first stage of the software development life cycle is the planning phase,
    sometimes known in engineering literature as *requirement analysis*. The purpose
    of this phase is to determine how the product will look. A successful planning
    phase leads to a strictly defined set of required features to deliver to the end
    user.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发生命周期的第一阶段是规划阶段，有时在工程学文献中被称为*需求分析*。这个阶段的目的是确定产品的外观。成功的规划阶段将导致一个严格定义的、需要交付给最终用户的特性集合。
- en: 'Whether you’re a single person working on your hobby project or you’re responsible
    for managing and orchestrating collaboration among multiple software development
    teams, you must figure out the optimal set of features of the software. A number
    of factors must be taken into consideration: the costs of building a feature,
    the risk of not being able to successfully implement the feature, the expected
    value for the end user, marketing and sales implications, maintainability, scalability,
    legal restrictions, and many more.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是一个人独自工作于你的爱好项目，还是负责管理和协调多个软件开发团队的协作，你都必须弄清楚软件的最优特性集合。需要考虑许多因素：构建一个特性的成本、无法成功实施该特性的风险、最终用户的预期价值、市场营销和销售的影响、可维护性、可扩展性、法律限制等等。
- en: This phase is crucial because it can save you from wasting massive amounts of
    energy later. Planning mistakes can lead to millions of dollars’ worth of wasted
    resources. On the other hand, careful planning can set the business up for great
    success in the years to follow. The planning phase is a time to apply your newly
    acquired skill of 80/20 thinking (see Chapter 2).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段至关重要，因为它可以帮助你避免以后浪费大量精力。规划上的错误可能导致数百万美元的资源浪费。另一方面，谨慎的规划可以为接下来的几年中业务的巨大成功奠定基础。规划阶段是应用你新获得的80/20思维技巧的时候（见第二章）。
- en: 'The planning phase is also difficult to do right because of the complexity
    involved. Several considerations add to the complexity: assessing risk properly
    in advance, figuring out the strategic direction of a company or an organization,
    guessing the customers’ responses, weighing the positive impact of different feature
    candidates, and determining the legal implications of a given software feature.
    Taken together, the sheer complexity of solving this multidimensional problem
    is killing us.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Defining
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The defining phase consists of translating the results from the planning phase
    into properly specified software requirements. In other words, it formalizes the
    output of the previous phase to gain approval or feedback from clients and end
    users who will later use the product.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve spent a lot of time planning and figuring out the project requirements
    but fail in communicating them well, it’ll cause significant problems and difficulties
    later. A wrongly specified requirement that helps the project may be just as bad
    as a correctly formulated requirement that doesn’t. Effective communication and
    precise specification are crucial to avoid ambiguities and misunderstandings.
    In all human communication, getting your message across is a highly complex endeavor
    due to the “curse of knowledge” and other psychological biases that outweigh the
    relevance of personal experiences. If you try to deliver ideas (or requirements
    for that matter) out of your head and into another one’s head, be careful: complexity
    is out to get you!'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Designing
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of the designing phase is to draft the architecture of the system,
    decide on the modules and components that deliver the defined functionality, and
    design the user interface—while keeping the requirements developed in the previous
    two phases in mind. The gold standard of the designing phase is to create a crystal-clear
    picture of how the final software product will look and how it’s built. This holds
    for all methods of software engineering. Agile approaches would just iterate over
    those phases more quickly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: But the devil lies in the detail! A great system designer must know about the
    pros and cons of a huge variety of software tools they may use to build the system.
    For example, some libraries may be easy for the programmer to use but slow in
    execution speed. Building custom libraries is harder for the programmers but may
    result in much higher speed and, consequently, improved usability of the final
    software product. The designing phase must fix these variables so that the benefit-to-cost
    ratio is maximized.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Building
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The building phase is where many coders want to spend all their time. This is
    where the transformation from the architectural draft to the software product
    happens. Your ideas transform into tangible results.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Through proper preparation in the previous phases, a lot of complexity has already
    been eliminated. Ideally, the builders should know which features to implement
    from all the possible features, how the features look, and which tools to use
    to implement them. Yet, the building phase is always full of new and emerging
    problems. Unexpected things like bugs in external libraries, performance issues,
    corrupted data, and human mistakes can slow progress. Building a software product
    is a highly complicated endeavor. A small spelling mistake can undermine viability
    of the whole software product.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前期阶段的适当准备，许多复杂性已经被排除。理想情况下，构建者应该知道要实现哪些功能，功能的外观如何，以及要使用哪些工具来实现它们。然而，构建阶段总是充满了新出现的问题。外部库中的错误、性能问题、数据损坏以及人为错误等意外情况可能会减缓进度。构建软件产品是一项极其复杂的工作。一个小小的拼写错误就可能破坏整个软件产品的可行性。
- en: Testing
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试
- en: Congratulations! You’ve implemented all requested features, and the program
    seems to work. You’re not done yet, though. You still must test the behavior of
    your software product for different user inputs and usage patterns. This phase
    is often the most important of all—so much so that many practitioners now advocate
    the use of *test-driven development* where you don’t even start to implement (in
    the building phase) without having written all tests. While you can argue against
    that point of view, it’s generally a good idea to spend time testing your product
    by creating test cases and checking if the software delivers the correct result
    for these test cases.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你已经实现了所有要求的功能，并且程序似乎正常工作。然而，你还没有完成。你仍然需要测试软件产品在不同用户输入和使用模式下的行为。这个阶段通常是最重要的——以至于许多实践者现在提倡使用*测试驱动开发*，即在实施（构建阶段）之前，必须先编写所有的测试。虽然你可以反对这种观点，但通常来说，花时间通过创建测试用例并检查软件是否为这些测试用例提供正确的结果，是个不错的主意。
- en: 'For example, say you’re implementing a self-driving car. You must write *unit
    tests* to check that each little function (a *unit*) in your code generates the
    desired output for a given input. Unit tests will usually uncover some faulty
    functions that behave strangely under certain (extreme) inputs. For example, consider
    the following Python function stub that calculates the average red, green, and
    blue (RGB) color value of an image, perhaps used to differentiate whether you’re
    traveling through a city or a forest:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在实现一辆自动驾驶汽车。你必须编写*单元测试*，检查代码中每个小功能（即*单元*）是否为给定输入生成预期的输出。单元测试通常能发现一些在特定（极端）输入下表现异常的错误函数。例如，考虑以下Python函数代码，它计算图像的平均红色、绿色和蓝色（RGB）值，也许可以用来区分你是穿越城市还是森林：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example, the following list of pixels will yield the average red, green,
    and blue values of 96.0, 64.0, and 11.0, respectively:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下像素列表将分别得出96.0、64.0和11.0的平均红、绿、蓝值：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s the output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Although the function seems simple enough, many things can go wrong in practice.
    What if the pixel list of tuples is corrupted and some (RGB) tuples have only
    two instead of three elements? What if one value is of a non-integer type? What
    if the output must be a tuple of integers to avoid the floating-point error that
    is inherent to all floating-point computations?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个函数看起来足够简单，但在实际操作中，许多事情可能会出错。如果像素元组列表被损坏，其中一些（RGB）元组只有两个元素而不是三个怎么办？如果其中一个值是非整数类型呢？如果输出必须是整数元组，以避免所有浮点计算固有的浮点错误怎么办？
- en: A unit test can test for all of those conditions to make sure that the function
    works in isolation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以测试所有这些条件，以确保函数在孤立情况下正常工作。
- en: 'Here are two simple unit tests, one that checks whether the function works
    for a border case with zeros as inputs and another that checks whether the function
    returns a tuple of integers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个简单的单元测试，一个检查函数是否在输入为零的边界情况下正常工作，另一个检查函数是否返回整数元组：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result shows that the type check fails and the function doesn’t return
    the correct type, which should be tuple-of-integer values:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示类型检查失败，函数没有返回正确的类型，应该是一个整数元组：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In a more realistic setting, testers would write hundreds of those unit tests
    to check the function against all types of inputs—and whether it generates the
    expected outputs. Only if the unit tests reveal that the function works properly
    can we move on to test higher-level functions of the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在更现实的环境中，测试人员需要编写数百个单元测试来检查函数对所有类型输入的响应——并验证它是否生成了预期的输出。只有当单元测试表明函数运行正常时，我们才能继续测试应用程序的更高级功能。
- en: In fact, even if all your unit tests successfully pass, you haven’t yet completed
    the testing phase. You must test the correct interaction of the units as they’re
    building a greater whole. You must design real-world tests, driving the car for
    thousands or even tens of thousands of miles to uncover unexpected behavior patterns
    under strange and unpredictable situations. What if your car drives on a small
    road without road signs? What if the car in front of you abruptly stops? What
    if multiple cars wait for each other at a crossroad? What if the driver suddenly
    steers into approaching traffic?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，即使所有单元测试都成功通过，您仍然没有完成测试阶段。您必须测试各个单元如何正确地相互作用，共同构建一个更大的整体。您必须设计现实世界的测试，像驾驶汽车一样测试数千甚至数万辆英里，以揭示在陌生和不可预测的情况下出现的意外行为模式。假设您的汽车行驶在没有路标的小路上怎么办？如果前方的车突然停下怎么办？如果多辆车在十字路口互相等待怎么办？如果驾驶员突然转向迎面而来的车流怎么办？
- en: There are so many tests to consider; the complexity is so high that many people
    throw in the towel here. What looked good in theory, even after your first implementation,
    often fails in practice after applying different levels of software testing such
    as unit tests or real-world usage tests.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的测试非常多；复杂性极高，以至于许多人在这里放弃了。理论上看起来不错的东西，即使是首次实现后，往往在实践中也会失败，特别是在应用了不同级别的软件测试（如单元测试或现实世界使用测试）后。
- en: Deployment
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署
- en: The software has now passed the rigorous testing phase. It’s time to deploy
    it! Deployment can take many forms. Apps may be published to marketplaces, packages
    may be published to repositories, and major (or minor) releases may be made public.
    In a more iterative and agile approach to software development, you revisit the
    deployment phase multiple times using *continuous deployment*. Depending on your
    concrete project, this phase requires you to launch the product, create marketing
    campaigns, talk to early users of the product, fix new bugs that will surely come
    to light after being exposed to users, orchestrate the deployment of the software
    on different operating systems, support and troubleshoot different kinds of problems,
    or maintain the codebase to adapt and improve over time. This phase can become
    quite messy, given the complexity and interdependency of the various design choices
    you made and implemented in previous phases. The subsequent chapters will suggest
    tactics to help you overcome the mess.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该软件现在已经通过了严格的测试阶段。是时候部署它了！部署可以有多种形式。应用程序可能会发布到市场，软件包可能会发布到仓库，重大（或次要）版本可能会公开发布。在一种更迭代和敏捷的软件开发方法中，您需要多次回顾部署阶段，采用*持续部署*的方式。根据具体项目的不同，这一阶段可能需要您推出产品、创建营销活动、与早期用户沟通、修复在用户使用后必然暴露的新问题、协调软件在不同操作系统上的部署、支持和排除各种问题，或维护代码库以便随着时间的推移适应和改进。由于您在前几个阶段做出的各种设计选择及其相互依赖性，这个阶段可能会变得非常混乱。后续章节将提供一些策略，帮助您克服这些混乱。
- en: Complexity in Software and Algorithmic Theory
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件和算法理论中的复杂性
- en: There can be as much complexity *within* a piece of software as there is in
    the process that surrounds software development. Many metrics in software engineering
    measure the complexity of software in a formal way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一段软件内部的复杂性可能与软件开发过程中所涉及的复杂性一样多。许多软件工程的度量标准会以正式的方式衡量软件的复杂性。
- en: First, we’ll look at *algorithmic complexity*, which is concerned with the resource
    requirements of different algorithms. Using algorithmic complexity, you can compare
    different algorithms that solve the same problem. For example, say you’ve implemented
    a game application with a high-score rating system. You want the players with
    the highest scores to appear at the top of the list and the players with the lowest
    scores to appear at the bottom. In other words, you need to *sort* the list. Thousands
    of algorithms exist for sorting a list, and sorting a list is computationally
    more demanding for 1,000,000 players than it is for 100 players. Some algorithms
    scale better with increasing size of the list input; others scale worse. While
    your app serves a few hundred users, it doesn’t really matter which algorithm
    you choose, but as your user base grows, the runtime complexity of the list grows
    superlinearly. Soon, the end users will have to wait longer and longer for the
    list to be sorted. They’ll start complaining, and you’ll need better algorithms!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-2](#figure1-2) exemplifies the algorithmic complexity of two schematic
    algorithms. The x-axis shows the size of the list to be sorted. The y-axis shows
    the runtime of the algorithm (in time units). Algorithm 1 is much slower than
    Algorithm 2\. In fact, the inefficiency of Algorithm 1 becomes more apparent the
    more list elements must be sorted. Using Algorithm 1, your game app would become
    slower the more users are playing.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph showing list size on the x-axis and runtime on the y-axis. The line
    shows a steady upward trend. ](image_fi/502185c01/f01002.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: Algorithmic complexity of two different sorting algorithms'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see whether this holds for real Python sorting routines. [Figure 1-3](#figure1-3)
    compares three popular sorting algorithms: bubble sort, Quicksort, and Timsort.
    Bubble sort has the highest algorithmic complexity. Quicksort and Timsort have
    the same asymptotical algorithmic complexity. But the Timsort algorithm is still
    much faster—that’s why it’s used as Python’s default sorting routine. The runtime
    of the bubble sort algorithm explodes with a growing list size.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 1-4](#figure1-4), we repeat this experiment but only for Quicksort
    and Timsort. Again, there’s a drastic difference in algorithmic complexity: Timsort
    scales better and is faster for the growing list size. Now you see why Python’s
    built-in sorting algorithm hasn’t changed for such a long time!'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph showing list size (number of elements) on the x-axis and runtime in
    seconds on the y-axis. Three lines represent bubble sort, quicksort, and Timsort.
    The lines for quicksort and Timsort are flat along the 0-second point on the y-axis.
    The line for Timsort is a steady, slightly curved incline between the x- and y-axes.](image_fi/502185c01/f01003.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: Algorithmic complexity of bubble sort, Quicksort, and Timsort'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph showing list size (number of elements) on the x-axis and runtime in
    seconds on the y-axis. two lines represent Quicksort and Timsort. The line for
    quicksort raises slightly from 0.0 seconds to about 0.05 seconds on the y-axis
    as it moves along the x-axis. The line for Timsort is a jagged but fairly even
    incline between the x- and y-axes.](image_fi/502185c01/f01004.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: Algorithmic complexity of Quicksort and Timsort'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-1](#listing1-1) shows the code in Python in case you want to reproduce
    the experiment. I’d recommend you choose a smaller value for `n` because the code
    runs a long time on my machine before terminating.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 1-1: Measuring elapsed runtime for three popular sorting routines'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Algorithmic complexity is a thoroughly researched field. In my opinion, the
    improved algorithms produced from this research are among the most valuable technological
    assets of humanity, allowing us to solve the same problems with fewer resources,
    over and over. We truly stand on the shoulders of giants.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: In addition to algorithmic complexity, we can measure the complexity of code
    with *cyclomatic complexity*. This metric, developed by Thomas McCabe in 1976,
    describes the number of *linearly independent paths* through your code, or the
    number of paths that have at least one edge that’s not in another path. For example,
    code with an `if` statement would result in two independent paths through your
    code, so it would have a higher cyclomatic complexity than flat code without any
    branching like that in an `if` statement. [Figure 1-5](#figure1-5) shows the cyclomatic
    complexity of two Python programs that process user input and respond accordingly.
    The first program contains only one conditional branch, which could be considered
    a fork in the road. Either branch could be taken, but not both. Thus, the cyclomatic
    complexity is two because there are two linearly independent paths. The second
    program contains two conditional branches leading to a total of three linearly
    independent paths and a cyclomatic complexity of three. Each additional `if` statement
    increases cyclomatic complexity.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Left side of figure shows a diagram of cyclomatic complexity equaling 2\.
    A start node points to a second node containing code with a condition. Two arrows
    exit this node: path 1 points to an end node, and path 2 points to second node
    containing a print statement.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Right side of figure shows a diagram of cyclomatic complexity equaling 3\. the
    start node points to node containing a condition. Two arrows exit this node, the
    first pointing to an end node, the second to a second conditional node. From this
    node, arrows point to two more print statement nodes. From each of these conditional
    nodes, an arrow points to the same end node.](image_fi/502185c01/f01005.png)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1-5: Cyclomatic complexity of two Python programs'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The cyclomatic complexity is a solid proxy metric for the hard-to-measure *cognitive
    complexity*, that is, how difficult it is to understand a given codebase. However,
    cyclomatic complexity ignores the cognitive complexity that comes from, say, multiple
    nested `for` loops compared to a flat `for` loop. That’s why other measures such
    as `NPath` complexity improve upon cyclomatic complexity. To sum up, code complexity
    not only is an important subject of algorithmic theory but also is relevant for
    all practical matters when implementing code—and for writing easy-to-understand,
    readable, and robust code. Both algorithmic theory and programming complexity
    have been thoroughly researched for decades. A primary goal of these efforts is
    to *reduce computational and non-computational complexity* to mitigate its harmful
    effects on productivity and resource utilization of humans and machines alike.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Complexity in Learning
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Facts don’t exist in a vacuum but are interrelated. Consider these two facts:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Walt Disney was born in the year 1901.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Louis Armstrong was born in the year 1901.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you fed a program with these facts, it could answer questions like *“What’s
    the birth year of Walt Disney?”* as well as questions like *“Who was born in 1901?”*
    To answer the latter, the program must figure out the interdependency of different
    facts. It may model the information like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To get all persons born in 1901, it could use the query `(*, born, 1901)` or
    any other way to relate the facts and group them together.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In 2012, Google launched a new search feature showing info boxes on the search
    result page. These fact-based info boxes are populated using a data structure
    called the *knowledge graph*, which is a massive database of billions of interrelated
    facts to represent information in a network-like structure. Instead of storing
    objective and independent facts, this database maintains information about the
    interrelationship between different facts and other pieces of information. The
    Google search engine uses this knowledge graph to enrich its search results with
    higher-level knowledge and form answers autonomously.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-6](#figure1-6) shows an example. One node on the knowledge graph
    may be about the famous computer scientist Alan Turing. In the knowledge graph,
    the concept of `Alan Turing` is connected to different pieces of information such
    as his birth year (`1912`), his fields of study (`Computer science`, `Philosophy`,
    `Linguistics`), and his doctoral advisor (`Alonzo Church`). Each of those pieces
    of information is also connected to other facts (Alonzo Church’s field of study
    was `Computer science` as well), forming a massive network of interrelated facts.
    You can use this network to acquire new information and answer user queries programmatically.
    A query about the `"field of study of Turing''s doctoral advisor"` would result
    in the deducted answer `"Computer science"`. While this may sound trivial or obvious,
    the ability to generate new factoids like these has led to a breakthrough in information
    retrieval and search engine relevancy. You’d probably agree that it’s far more
    effective to learn by association than by remembering unrelated facts.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Knowledge graph representing connections between various topics. The seven
    topic nodes contain the following: 1912, linguistics, alan turing, computer science,
    alonzo church, philosophy, and human. Arrows point between them, connecting them
    via criteria such as “has field of study” and “has birth year.” ](image_fi/502185c01/f01006.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-6: Knowledge graph representations'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Every field of study focuses only on a small part of the graph, each consisting
    of myriads of interrelated factoids. You can only really understand a field by
    taking into account related facts. To understand Alan Turing thoroughly, you must
    research his beliefs, his philosophies, and the characteristics of his doctorate
    advisor. To understand Church, you must investigate his relationship to Turing.
    Of course, there are too many related dependencies and facts in the graph to expect
    to understand everything. The complexity of these interrelations imposes the most
    fundamental boundaries around your ambitions to learn. Learning and complexity
    are two sides of the same coin: complexity is at the boundary of the knowledge
    you’ve already acquired. To learn more, you must first know how to control complexity.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re getting kind of abstract here, so let’s have an example! Say you want
    to program a trading bot that buys and sells assets according to a set of sophisticated
    rules. You could learn lots of useful knowledge before starting your project:
    the basics of programming, distributed systems, databases, application programming
    interfaces (APIs), web services, machine learning, and data science and the related
    mathematics. You could learn about practical tools such as Python, NumPy, scikit-learn,
    ccxt, TensorFlow, and Flask. You could learn about trading strategies and stock
    market philosophies. Many people approach these problems with such a mindset and
    so never feel ready to start the project. The problem is that the more you learn,
    the less knowledgeable you feel. You’ll never attain sufficient mastery in all
    those fields to truly satisfy your desire to feel prepared. Overwhelmed by the
    complexity of the whole endeavor, you feel like quitting. Complexity is about
    to take its next victim: you.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, in the chapters of this book, you’ll learn skills to combat complexity:
    focus, simplification, scaling down, reduction, and minimalism. This book will
    teach you those skills.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Complexity in Processes
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *process* is a series of actions taken with the goal of realizing a defined
    result. The complexity of a process is calculated by its number of actions, participants,
    or branches. In general, the more actions (and participants), the more complicated
    a process becomes (see [Figure 1-7](#figure1-7)).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Top half of figure shows a simple process with the term “Code” pointing to
    “Test” pointing to “Launch.” Bottom half shows a slightly more complex process
    showing the term “Code” three times, all pointing to “feedback.” From “feedback”
    a rightward arrow labeled Yes points to Test and a downward arrow labeled No points
    back to Code. From Test a rightward arrow labeled Yes points to Launch and a downward
    arrow labeled No points back to the term Code.](image_fi/502185c01/f01007.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-7: Two example processes: one-person development versus team development'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Many software companies follow process models for different aspects of the
    business in an attempt to simplify processes. Here are some examples:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Software development may use agile development or scrum.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customer relationship development may use customer relationship management (CRM)
    and sales scripts.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New product and business model creation may use the business model canvas.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When organizations accumulate too many processes, complexity starts to clog
    the system. For example, before Uber entered the scene, the process of traveling
    from location A to B often involved many steps: finding telephone numbers of taxi
    organizations, comparing rates, preparing different payment options, and planning
    different modes of transportation. For many, Uber streamlined the process of traveling
    from A to B, integrating the whole planning process into an easy-to-use mobile
    application. The radical simplification performed by Uber made traveling more
    convenient for customers and reduced planning time and costs compared to the traditional
    taxi industry.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: In overly complex organizations, innovation finds fewer vehicles for change
    because it’s unable to break through the complexity. Resources are wasted as actions
    within processes become redundant. Trying to fix the suffering business, managers
    invest energy in establishing new processes and new actions, and the vicious cycle
    begins to destroy the business or organization.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Complexity is the enemy of efficiency. The solution here is minimalism: to
    keep your processes efficient, you must radically weed out unnecessary steps and
    actions. It’s very unlikely that you’ll find your processes *oversimplified*.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Complexity in Your Daily Life, or Death by a Thousand Cuts
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of this book is to increase the productivity of your programming
    efforts. Your progress can be interrupted by your own personal daily habits and
    routines. You must tackle the daily distractions and the constant competition
    for your valuable time. Computer science professor Cal Newport talks about this
    in his excellent book *Deep Work: Rules for Focused Success in a Distracted World*
    (Grand Central Publishing, 2016). He argues that there’s both an *increasing*
    demand for work that requires deep thinking—such as programming, researching,
    medicine, and writing—and a *decreasing* supply of time to do it due to the proliferation
    of communication devices and entertainment systems. If increasing demand meets
    decreasing supply, economic theory suggests that prices will rise. If you are
    capable of engaging in deep work, your economic value will increase. There has
    never been a better time for programmers who can engage in deep work.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the caveat: it has become almost impossible to engage in deep work if
    you don’t brutally enforce its prioritization. The external world is a nonstop
    distraction. Your colleagues pop into your office. Your smartphone demands your
    attention every 20 minutes. Your inbox pops up a new email dozens of times a day—each
    asking for a slice of your time.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Deep work results in delayed gratification; it’s a satisfying feeling to have
    spent weeks of work on a computer program and find that it works. However, what
    you *desire* in most moments is instant gratification. Your subconscious often
    looks for ways to escape from the effort of deep work. Small rewards produce an
    easy boost of endorphins: checking your messages, engaging in meaningless chitchat,
    flicking through Netflix. The promise of delayed gratification becomes less and
    less attractive compared to the happy, colorful, and lively world of instant gratification.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Your efforts to stay focused and productive are prone to dying the death of
    a thousand cuts. Yes, you can turn off your smartphone once and use willpower
    to avoid checking your social media and switching on your favorite shows, but
    can you do it consistently day after day? Here, too, the answer lies in applying
    radical minimalism to the root of the problem: *uninstall* social media apps rather
    than trying to manage consumption, *reduce* the number of projects and tasks you’re
    involved in rather than trying to do more by working more, *go deep* into one
    programming language rather than spending lots of time switching between many.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you should be thoroughly motivated by the need to overcome complexity.
    For further exploration of complexity and how we might overcome it, I do recommend
    reading *Deep Work* by Cal Newport.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Complexity harms productivity and reduces focus. If you don’t take early control
    over complexity, it will quickly consume your most precious resource: time. At
    the end of your life, you won’t judge whether you’ve led a meaningful life based
    on how many emails you’ve replied to, hours of computer games you’ve played, or
    Sudoku puzzles you’ve solved. By learning how to handle complexity, by keeping
    it simple, you’ll be able to fight complexity and give yourself a powerful competitive
    advantage.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'In Chapter 2, you’ll learn about the power of the 80/20 principle: focus on
    the vital few and ignore the trivial many.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
