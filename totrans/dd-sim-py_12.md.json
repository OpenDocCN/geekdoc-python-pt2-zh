["```py\nnumber = None\nwhile number is None:\n    try:\n        number = int(input(\"Enter a number: \"))\n    except ValueError:\n        print(\"You must enter a number.\")\n\nprint(f\"You entered {number}\")\n```", "```py\nEnter a number: forty\nYou must enter a number.\nEnter a number: \nYou must enter a number.\nEnter a number: 40\nYou entered 40\n```", "```py\nnumber = None\nwhile number is None:\n    try:\n        **raw =** input(\"Enter a number **('q' to quit):** \")\n        **if raw == 'q':**\n **break**\n        number = **int(raw)**\n    except ValueError:\n print(\"You must enter a number.\")\n\nprint(f\"You entered {number}\")\n```", "```py\nEnter a number ('q' to quit): foo\nYou must enter a number.\nEnter a number ('q' to quit): q\nYou entered None\n```", "```py\nnumber = None\nwhile number is None:\n    try:\n        raw = input(\"Enter a number ('q' to quit): \")\n        if raw == 'q':\n            break\n        number = int(raw)\n    except ValueError:\n        print(\"You must enter a number.\")\n**else:**\n **print(f\"You entered {number}\")**\n```", "```py\nEnter a number ('q' to quit): q\n```", "```py\nnumbers = [\"One\", \"Two\", \"Three\"]\n\nfor number in numbers:\n    print(number)\nelse:\n    print(\"We're done!\")\n```", "```py\nOne\nTwo\nThree\nWe're done!\n```", "```py\norder = (\"Jason\", \"pumpkin spice latte\", 12)\n```", "```py\nprint(order[1])  # prints \"pumpkin spice latte\"\n```", "```py\norders = (\"pumpkin spice latte\",)\n```", "```py\nfrom collections import namedtuple\n\nCoffeeOrder = namedtuple( ❶ \"CoffeeOrder\", ❷('item', 'addons', 'to_go'))\n\norder = CoffeeOrder('pumpkin spice latte', ('whipped cream',), True)\nprint( ❸ order.item)  # prints 'pumpkin spice latte'\nprint( ❹ order[2])    # prints 'True'\n```", "```py\nspecials = [\"pumpkin spice latte\", \"caramel macchiato\", \"mocha cappuccino\"]\n```", "```py\nprint(specials[1])      # prints \"caramel macchiato\"\n```", "```py\ndrink = specials.pop()  # return and remove last item\nprint(drink)            # prints \"mocha cappuccino\"\nprint(specials)         # prints ['pumpkin spice latte', 'caramel macchiato']\n```", "```py\ndrink = specials.pop(1)  # return and remove item [1]\nprint(drink)             # prints \"caramel macchiato\"\nprint(specials)          # prints ['pumpkin spice latte']\n```", "```py\nspecials.append(\"cold brew\")  # inserts item at end\nprint(specials)               # prints ['pumpkin spice latte', 'cold brew']\n```", "```py\nspecials.insert(1, \"americano\")  # inserts as item [1]\nprint(specials)                  # prints ['pumpkin spice latte', 'americano', 'cold brew']\n```", "```py\nfrom collections import deque\ncustomers = deque(['Daniel', 'Denis'])\n```", "```py\ncustomers.append('Simon')\nprint(customers)  # prints deque(['Daniel', 'Denis', 'Simon'])\n```", "```py\ncustomer = customers.popleft()\nprint(customer)   # prints 'Daniel'\nprint(customers)  # prints deque(['Denis', 'Simon'])\n```", "```py\ncustomers.appendleft('James')\nprint(customers)  # prints deque(['James', 'Denis', 'Simon'])\n```", "```py\nlast_in_line = customers.pop()\nprint(last_in_line)  # prints 'Simon'\n```", "```py\nprint(customers)  # prints deque(['James', 'Denis'])\n```", "```py\nraffle = {'James', 'Denis', 'Simon'}\n```", "```py\nraffle.add('Daniel')\nraffle.add('Denis')\nprint(raffle)  # prints {'Daniel', 'Denis', 'Simon', 'James'}\n```", "```py\nraffle.discard('Simon')\nprint(raffle)  # prints {'Daniel', 'Denis', 'James'}\n```", "```py\nwinner = raffle.pop()\nprint(winner)  # prints arbitrary item of set, e.g. 'Denis'\n```", "```py\nraffle = {'Kyle', 'Denis', 'Jason'}\nprev_winners = frozenset({'Denis', 'Simon'})\n```", "```py\nraffle -= prev_winners  # remove previous winners\nprint(raffle)           # prints {'Jason', 'Kyle'}\n```", "```py\nwinner = raffle.pop()\nprint(winner)  # prints arbitrary item of set, e.g. 'Kyle'\n```", "```py\nmenu = {\"drip\": 1.95, \"cappuccino\": 2.95}\n```", "```py\nprint(menu[\"drip\"])  # prints 1.95\n```", "```py\nmenu[\"americano\"] = 2.49\nprint(menu)  # prints {'drip': 1.95, 'cappuccino': 2.95, 'americano': 2.49}\n```", "```py\ndel menu[\"americano\"]  # removes \"americano\" from dictionary\nprint(menu)            # prints {'drip': 1.95, 'cappuccino': 2.95}\n```", "```py\nmenu = {'drip': 1.95, 'cappuccino': 2.95, 'americano': 2.49}\n\ndef checkout(order):\n    try:\n        print(f\"Your total is { ❶ menu[order]}\")\n    except KeyError:\n        print(\"That item is not on the menu.\")\n\ncheckout(\"drip\")  # prints \"Your total is 1.95\"\ncheckout(\"tea\")   # prints \"That item is not on the menu.\"\n```", "```py\nmenu = {'drip': 1.95, 'cappuccino': 2.95, 'americano': 2.49}\n\ndef checkout(order):\n  ❶ if order in menu:\n        print(f\"Your total is { ❷ menu[order]}\")\n    else:\n        print(\"That item is not on the menu.\")\n\ncheckout(\"drip\")  # prints \"Your total is 1.95\"\ncheckout(\"tea\")   # prints \"That item is not on the menu.\"\n```", "```py\nfrom collections import deque\n\ncustomers = deque(['Kyle', 'Simon', 'James'])\n```", "```py\nfirst, second, third = customers\nprint(first)   # prints 'Kyle'\nprint(second)  # prints 'Simon'\nprint(third)   # prints 'James'\n```", "```py\nfrom collections import deque\n\ncustomers = deque(['Kyle', 'Simon', 'James'])\n**customers.append('Daniel')**\n```", "```py\nfirst, second, third = customers  **# raises ValueError**\nprint(first)                      # never reached\nprint(second)                     # never reached\nprint(third)                      # never reached\n```", "```py\nfirst, second, third**, _** = customers\nprint(first)    # prints 'Kyle'\nprint(second)   # prints 'Simon'\nprint(third)    # prints 'James'\n```", "```py\nfirst, second, **_, _** = customers\nprint(first)   # prints 'Kyle'\nprint(second)  # prints 'Simon'\n```", "```py\nbaristas = ('Jason'**,**)\nbarista, = baristas\nprint(barista)  # prints 'Jason'\n```", "```py\nfirst, second, ***rest** = customers\nprint(first)    # prints 'Kyle'\nprint(second)   # prints 'Simon'\nprint(**rest**)     # prints ['James', 'Daniel']\n```", "```py\nfirst, *middle, last = customers\nprint(first)    # prints 'Kyle'\nprint(middle)   # prints ['Simon', 'James']\nprint(last)     # prints 'Daniel'\n```", "```py\n*_, second_to_last, last = customers\nprint(second_to_last)  # prints 'James'\nprint(last)            # prints 'Daniel'\n```", "```py\nmenu = {'drip': 1.95, 'cappuccino': 2.95, 'americano': 2.49}\n```", "```py\na, b, c = menu\nprint(a)  # prints 'drip'\nprint(b)  # prints 'cappuccino'\nprint(c)  # prints 'americano'\n```", "```py\na, b, c = **menu.values()**\nprint(a)  # prints 1.95\nprint(b)  # prints 2.95\nprint(c)  # prints 2.49\n```", "```py\na, b, c = **menu.items()**\nprint(a)  # prints ('drip', 1.95)\nprint(b)  # prints ('cappuccino', 2.95)\nprint(c)  # prints ('americano', 2.49)\n```", "```py\n(a_name, a_price), (b_name, b_price), *_ = menu.items()\nprint(a_name)    # prints 'drip'\nprint(a_price)   # prints 1.95\nprint(b_name)    # prints 'cappuccino'\nprint(b_price)   # prints 2.95\n```", "```py\norder = ['venti', 'no whip', 'mocha latte', 'for here']\n\nmatch order:\n    case ('tall', *drink, 'for here'):\n        drink = ' '.join(drink)\n        print(f\"Filling ceramic mug with {drink}.\")\n    case ['grande', *drink, 'to go']:\n        drink = ' '.join(drink)\n        print(f\"Filling large paper cup with {drink}.\")\n    case ('venti', *drink, 'for here'):\n        drink = ' '.join(drink)\n        print(f\"Filling extra large tumbler with {drink}.\")\n```", "```py\norder = {\n    'size': 'venti',\n    'notes': 'no whip',\n    'drink': 'mocha latte',\n    'serve': 'for here'\n}\n\nmatch order:\n    case {'size': 'tall', 'serve': 'for here', 'drink': drink}:\n        print(f\"Filling ceramic mug with {drink}.\")\n    case {'size': 'grande', 'serve': 'to go', 'drink': drink}:\n        print(f\"Filling large paper cup with {drink}.\")\n    case {'size': 'venti', 'serve': 'for here', 'drink': drink}:\n        print(f\"Filling extra large tumbler with {drink}.\")\n```", "```py\norder = {\n    'size': 'venti',\n    'notes': 'no whip',\n    'drink': 'mocha latte',\n    'serve': 'for here'\n}\n\nmatch order:\n    case {'size': 'tall', 'serve': 'for here', ****rest}**:\n        **drink = f\"{rest['notes']} {rest['drink']}\"**\n        print(f\"Filling ceramic mug with {drink}.\")\n    case {'size': 'grande', 'serve': 'to go', ****rest}**:\n        **drink = f\"{rest['notes']} {rest['drink']}\"**\n        print(f\"Filling large paper cup with {drink}.\")\n    case {'size': 'venti', 'serve': 'for here', ****rest}**:\n        **drink = f\"{rest['notes']} {rest['drink']}\"**\n        print(f\"Filling extra large tumbler with {drink}.\")\n```", "```py\nmatch order:\n    case {'size': 'tall', 'serve': 'for here'}:\n        drink = f\"{**order**['notes']} {**order**['drink']}\"\n        print(f\"Filling ceramic mug with {drink}.\")\n    case {'size': 'grande', 'serve': 'to go'}:\n        drink = f\"{**order**['notes']} {**order**['drink']}\"\n        print(f\"Filling large paper cup with {drink}.\")\n    case {'size': 'venti', 'serve': 'for here'}:\n        drink = f\"{**order**['notes']} {**order**['drink']}\"\n        print(f\"Filling extra large tumbler with {drink}.\")\n```", "```py\nspecials = [\"pumpkin spice latte\", \"caramel macchiato\", \"mocha cappuccino\"]\nprint(specials[1])  # prints \"caramel macchiato\"\nspecials[1] = \"drip\"\nprint(specials[1])  # prints \"drip\"\n```", "```py\nspecials = [\"pumpkin spice latte\", \"caramel macchiato\", \"mocha cappuccino\"]\nprint(**specials.__getitem__(1)**)  # prints \"caramel macchiato\"\n**specials.__setitem__(1, \"drip\")**\nprint(**specials.__getitem__(1)**)  # prints \"drip\"\n```", "```py\n[`start`:`stop`:`step`]\n```", "```py\norders = [\n    \"caramel macchiato\",\n    \"drip\",\n    \"pumpkin spice latte\",\n    \"drip\",\n    \"cappuccino\",\n    \"americano\",\n    \"mocha latte\",\n]\n```", "```py\nthree_four_five = orders[3:6]\nprint(three_four_five)  # prints ['drip', 'cappuccino', 'americano']\n```", "```py`One important rule: `start` must always refer to an item that comes before `stop`. By default, lists are traversed first to last, so the `start` must be less than `stop`.    A slice doesn’t require all three arguments. If you leave out `start`, the slice begins at the first element. If you leave off `stop`, the slice finishes with the final element.    If I wanted all the items in the list except the first four, I’d use this:    ```", "```py    Listing 9-55: *slice_orders.py:3*    I start at index `4`. Then, since I didn’t specify a `stop` after the required colon, the slice includes the rest of the items up to the very end of the list.    I can access the first two items in the list this way:    ```", "```py    Listing 9-56: *slice_orders.py:4*    I didn’t specify a start before the colon, so it defaults to the beginning of the list. The end, which is *exclusive*, is `2`, so the slice includes all items before index `2`. This gives me the first two items in the list.    ### Negative Indices    I can also use negative numbers as indices, which enable me to count backward from the end of the list or tuple. For example, an index of `-1` refers to the last item in the list:    ```", "```py    Listing 9-57: *slice_orders.py:5*    Negative indices work with slicing, too. For example, if I wanted to get the three orders at the end of the list, I could use this:    ```", "```py    Listing 9-58: *slice_orders.py:6*    The slice starts at the third index from the end (`-3`) and goes to the end. When determining negative indices, remember that `-1` is the last item—that is, it’s one index before the “end,” which *has* no index.    If I wanted the third-from-last and second-from-last orders, but not the last order, I could define both `start` and `stop` as negative indices:    ```", "```py    Listing 9-59: *slice_orders.py:7*    Remember, the `start` index must always come before the `stop`, and lists are traversed from left to right, by default. Thus, the `start` must be `-3`, or third-from-end, and the `stop` must be `-1`; so the last included index is `-2`, or second-from-end.    ### Steps    By default, lists are traversed first to last, from the lowest index to the highest, one by one. The third part of the slice notation, `step`, lets you change that behavior so you can better control which values are included in the slice, and in what order.    For example, I could create a slice containing every other coffee order, starting from the second order, by setting the `step` part to `2`:    ```", "```py    Listing 9-60: *slice_orders.py:8*    I `start` the slice at index `1`. Since I haven’t specified a `stop` index, the slice goes to the end of the list. The `step` argument of `2` tells Python to grab every second item. With the `orders` list, that means the slice will consist of the items at indices `1`, `3`, and `5`.    A negative `step` argument reverses the direction the list or tuple is read in. For example, a `step` of `-1`, with no `start` or `stop`, will return a reversed version of the entire `orders` list:    ```", "```py    Listing 9-61: *slice_orders.py:9*    You’ll notice I had to precede the `-1` with two colons, to delineate that no values had been specified for `start` or `stop`. Otherwise, Python would have no way to know that the `-1` was for the third argument.    I can even get a reversed version of the data sliced in [Listing 9-60](#listing9-60), although there’s a bit of a trick to it. Here’s the code:    ```", "```py    Listing 9-62: *slice_orders.py:10*    The `step` of `-2` means the slice grabs every other value in reverse order. The list is traversed from right to left. That changes the behavior of `start` and `stop`. I `start` at the second-to-last item (`-2`), but because I omitted a value for `stop`, it defaults to the beginning of the list, instead of the end. If I left off both `start` and `stop`, I’d get every other value in reverse, starting from the last item.    This reversed behavior radically affects what values are used for `start` and `stop`, and this misunderstanding can easily result in bugs. For example, if I want the third, fourth, and fifth items in reverse order, my first attempt might look like the following, which would *not* work:    ```", "```py    Listing 9-63: *slice_orders.py:11a*    The negative `step` value means I’m traversing the list in reverse order. Remember that `start` must always be traversed before `stop`.    If I traverse the list from ending to beginning, then I have to reverse the `start` and `stop` values, like so:    ```", "```py    Listing 9-64: *slice_orders.py:11b*    Moving backward through the list, the slice starts at index `5` and stops at index `2`, which is not included.    ### Copy with Slice    One more thing to know about slices is that they always return a new list or tuple with the selected items; the original list or tuple still exists as it was. This code creates a perfect shallow copy of the list:    ```", "```py    Listing 9-65: *slice_orders.py:12*    Since neither `start` nor `stop` is specified, the slice includes all items.    ### Slice Objects    You can also directly create a `slice` object for reuse by using the `slice()` initializer method.    ```", "```py    The `start`, `stop`, and (optionally) `step` values are passed as positional arguments. In practice, this approach is more limited than regular slice notation, since it is not possible to omit the `stop` value.    In any case, I can now use `my_slice` in place of slice notation, such as in the `print()` statement above.    ### Slicing on Custom Objects    If you want to implement slicing in your own objects, you’ll only need to accept a slice object as an argument on the same special methods needed to make the object subscriptable: `__getitem__(self, sliced)`, `__setitem__(self, sliced)`, and `__delitem__(self, sliced)`. Then, you can get the three parts of the slice object with `sliced.start`, `sliced.stop`, and `sliced.step`.    A decent example for this would be pretty involved, so I’ll leave this explanation here.    ### Using islice    You can still slice a deque or any collection that isn’t subscriptable by using `itertools.islice()`, which behaves the same as slice notation, except that it doesn’t support negative values for any of the parameters.    The arguments that `islice()` accepts are ordered, so you have to remember the order:    ```", "```py    For example, `islice()` can take a slice from a dictionary, which cannot be sliced by ordinary slice notation because it isn’t subscriptable. Here, I get every other item from the dictionary:    ```", "```py    Listing 9-66: *islice_orders.py*    I pass the dictionary as a list of tuples to the `islice` ❶, followed by the `start`, `stop`, and `step` values necessary to take every other item. Then, I create a new dictionary from the `islice` and bind it to `menu`. Running that code produces the following output:    ```", "```py    ## The in Operator    You can use the `in` operator to quickly check whether a particular value is contained in any collection.    As before, I’ll start with a list of orders:    ```", "```py    Listing 9-67: *in_orders.py:1*    For example, I might need to see if anyone wants a mocha cappuccino in my `orders` list before I open the new bottle of chocolate syrup:    ```", "```py    Listing 9-68: *in_orders.py:2*    I place the value I’m looking for to the left of the `in` operator and the collection I’m searching to the right. The operator returns `True` if at least one instance of the value is found in the collection; otherwise, it returns `False`.    You can also check whether a list omits a specific item. For example, I might decide to shut off the coffee maker if no one wants any drip coffee right now. I can check if there are any orders for `\"drip\"` with this code:    ```", "```py    Listing 9-69: *in_orders.py:3*    The addition of `not` inverts the `in` condition, so the expression evaluates to `True` if the value is *not* found in the collection.    You can add support for the `in` operator to your custom classes by implementing the special method `__contains__()`.    ## Checking Collection Length    To find out how many items a collection contains, use the `len()` function. That’s all there is to it. For example, if I have a list of waiting customers, I can find out how many customers are standing in line:    ```", "```py    Listing 9-70: *len_customers.py*    The `len()` function returns the number of items in `customers` as an integer. Since there are three items in `customers`, the value `3` is returned. In the case of a dictionary, `len()` would return the number of key-value pairs.    You’ll use `len()` less than you might expect when you employ iteration, which changes the way you traverse through collections such that you seldom need to know the length.    You don’t even need `len()` when testing whether a collection is empty. If a collection contains content, it is “truthy,” meaning it can be evaluated directly to `True`. Otherwise, if the collection is empty, it is “falsey,” meaning it evaluates directly to `False`. I’ll use this to see if there are any customers in the café right now.    ```", "```py    Listing 9-71: *no_customers.py*    Because `customers` is empty, it is “falsey,” meaning it evaluates to `False` in a boolean context, such as when used as an expression ❶. Therefore, when the above program is run, the following is displayed:    ```", "```py    Sure enough, if I directly cast `customers` to a boolean value, it prints `False`.    Usually, the only time you’ll use `len()` is when you need the length of a collection as a piece of data in its own right, such as when calculating the average number of orders per day for the week:    ```", "```py    Listing 9-72: *average_orders.py*    The `average_orders` is printed to the screen:    ```", "```py    ## Iteration    All collections in Python are designed to work with *iteration*, by which you can directly access items on demand, one by one. Iteration patterns aren’t even limited to collections. You can leverage this concept to generate or process data *iteratively*: “on demand,” instead of all up front. You’ll see this in depth in Chapter 10.    Before you can start using iteration effectively, you must understand how it actually works. Then, you can use it to access, sort, and process items in collections.    ### Iterables and Iterators    One of the most compelling features of Python is its approach to iteration, by way of two fairly straightforward concepts: *iterables* and *iterators*.    An *iterable* is any object whose items or values can be accessed one at a time, on demand. For example, a list is an iterable; you can iterate over each item in the list, one by one. For an object to be iterable, it must have an associated iterator, which is returned from the object’s instance method `__iter__()`.    An *iterator* is the object that performs the actual iteration, providing ready access to the next item in the iterable it is traversing. To be an iterable, an object needs to implement the special method `__next__()`, which accepts no parameters and returns a value. This method advances to the next item in the iterable it traverses and returns that value.    Iterators must also implement the method `__iter__()`, which returns the iterator object itself (usually `self`). This convention is necessary so that code that accepts an iterable can also accept an iterator without any difficulty, as you’ll see shortly.    That’s really all there is to it! All collections are iterables, and each has at least one dedicated companion iterator class.    I’ll implement a custom iterator class later in this chapter.    ### Manually Using Iterators    Before introducing automatic iteration, it’s helpful to understand what is going on behind the scenes when using an iterator.    To demonstrate this, I’ll traverse the values in a list, using an iterator I manually access and control. I’ll go through this example twice: once, directly calling the special methods; and another time, allowing Python to call them implicitly.    I’ll start by defining a list, which is an iterable:    ```", "```py    Listing 9-73: *specials_iteration.py:1*    To iterate over the collection, I first acquire an iterator:    ```", "```py    Listing 9-74: *specials_iteration.py:2*    A list, like all iterables, implements the special method `__iter__()`, which returns an iterator object for this list. I acquire two separate iterators here, each of which can operate independently of the other.    When I check the data type of `first_iterator`, I see it’s an instance of the class `list_iterator`, as seen in the output:    ```", "```py    I use the iterator object to access the items in the list `specials`:    ```", "```py    Listing 9-75: *specials_iteration.py:3*    The first call to the iterator’s `__next__()` method advances to the first item in the list and returns its value, which I bind to `item` and print to the screen, outputting the following:    ```", "```py    A subsequent call advances to and returns the second item:    ```", "```py    Listing 9-76: *specials_iteration.py:4*    That outputs the following:    ```", "```py    Each iterator tracks its position in the iterable separately. If I call the `__next__()` method on `second_iterator`, it advances to and returns the first item in the list:    ```", "```py    Listing 9-77: *manual_iteration.py:5*    Printing `item` shows the first item in the list:    ```", "```py    Yet `first_iterator` still remembers its own position and can be advanced to the third item in the list:    ```", "```py    Listing 9-78: *specials_iteration.py:6*    That prints the value of the third item:    ```", "```py    Once an iterator has run through all the items in the iterable being traversed, calling `__next__()` again raises the special exception `StopIteration`:    ```", "```py    Listing 9-79: *specials_iteration.py:7*    Thankfully, I don’t need to call `__iter__()` and `__next__()` manually, in any case. Instead, I can use Python’s built-in functions `iter()` and `next()` and pass in the iterable or iterator, respectively. The special methods will be invoked behind the scenes.    Here’s that same example again, but now using those built-in functions:    ```", "```py    Listing 9-80: *specials_iteration.py:2b-7b*    As you can see, there’s a lot of repetition in this manual approach, which suggests that I could use a loop to handle iteration. In fact, using a `for` loop is the standard way to work with iteration, as it calls `iter()` and `next()` implicitly, so I don’t have to. However, to drive the underlying mechanics home first, I’ll wrap this same manual iteration logic in a `while` loop:    ```", "```py    Listing 9-81: *specials_iteration_v2.py*    I first acquire an iterator for the `specials` list ❶. Then, in an infinite `while` loop, I try to access the next value in the iterable by passing the iterator to `next()` ❷. If this raises the `StopIteration` exception ❸, I know I’ve traversed all the items in the `specials` list, and I break out of the loop with the `break` keyword. Otherwise, I print out the `item` I receive from the iterator.    Although it’s helpful to understand how to manually handle iterators, you will seldom need to! A `for` loop would almost always handle the example in [Listing 9-81](#listing9-81):    ```", "```py    Listing 9-82: *specials_iteration_v3.py*    This eliminates the need to directly acquire an iterator. I’ll cover this approach next.    ### Iterating with for Loops    One very helpful rule for loops and iteration in Python is that *you never need a counter variable for loop control*. In other words, virtually none of the traditional loop algorithms you’re used to apply here! Python always has a better way, mainly because iterables can directly control `for` loops.    Take another look at that queue of people at the Uncomment Café. For each person in line, the barista would take an order, make it, and deliver it. Here’s how I would do that. (For expediency of example, this code merely announces that each order is ready.)    ```", "```py    Listing 9-83: *iterate_orders_list.py*    I loop through the `customers` list, which is an iterable. On each iteration, I bind each current item to `customer` so it works in the suite of the loop like any other variable ❶.    For each item in the list, I print a string announcing the order for the `customer` for that iteration. Here’s the output of that code (truncated):    ```", "```py    A linear collection is pretty straightforward (no pun intended). Iterables with multiple values in any given item, such as from the `items()` dictionary view or from a two-dimensional list, must be treated differently.    To demonstrate this, I’ll rewrite `customers` as a list of tuples, with each tuple containing a name and a coffee order. Then, I’ll loop through them to announce their order:    ```", "```py    Listing 9-84: *iterate_orders_dict.py:1*    In the `for` loop, I iterate over the list `customers`. On the left, I unpack each tuple item on the list into two names: `customer` and `drink` ❶.    Here’s the resulting output:    ```", "```py    ### Sorting Collections in Loops    Loops also allow you to do more advanced processing of this data. For example, let’s say everyone could submit their orders through an app. (We are programmers, after all.)    I might want to sort the list of orders alphabetically, so I can search through them more easily. However, I still want to follow a first-come, first-served rule. Therefore, I don’t want to modify the original `customers` list, since its sequence still matters:    ```", "```py    Listing 9-85: *iterate_orders_dict.py:2*    The `sorted()` ❶ function returns a list of the sorted items from whatever collection is passed to it. By default, it will sort by the first value in an item, in ascending order. In this case, the first item is the customer name, but I want to sort by the name of the drink ordered instead. I change this behavior by passing a callable *key function* to the `key=` named argument ❷. This callable, a `lambda` in this case, must accept an item as an argument and return the value I want to sort that item by. In this case, I want to sort by the second item in each tuple, which I return via `x[1]` ❸. Through all of this, `customers` remains unchanged.    You’ll also notice that I use the underscore in the unpacking list to ignore the first value in each tuple, the customer name, because I don’t need it in this loop. This is usually the best way to pick and choose items from a small tuple in a `for` loop. On the other hand, if each item were a collection with many subitems, it might work better to bind the entire item to one name and access what I need from it in the suite of the loop.    Running that code, I get this output for this part:    ```", "```py    ### Enumerating Loops    You never need a counter variable for loop control. This will come as a major paradigm shift to many developers, who are used to C-style loop control. You may wonder what to do if you need the index itself.    Python offers `enumerate()` for such situations. The added benefit of using this function instead of manual indices is that it works with all iterables, even those that aren’t subscriptable.    I’ll use `enumerate()` to see the order of each person in line, along with their order:    ```", "```py    Listing 9-86: *iterate_orders_dict.py:3*    Here, `enumerate()` returns a tuple with the count (which is sometimes, coincidentally, the index) as an integer in the first position and the item from the collection in the second. By default, the count would start at 0, but I want the first person in line to be displayed as “`#1`”—so I override this default by passing `1` to `start=`.    Since my collection consists of tuples, I have to use compound unpacking with parentheses to get each item from within the tuple item ❶. Once I have the number, the customer name, and the drink, I compose those pieces together into a single `print` statement.    The output of this part of the code looks like this:    ```", "```py    ### Mutation in Loops    You’ll notice that I’ve been using a `list` for my queue of customers, whereas before, I used a `deque` and removed customers from the queue after serving them. This is preferable, so I’ll start by defining the `customers` deque:    ```", "```py    Listing 9-87: *process_orders.py:1*    Combining the knowledge so far, you might think, “Aha! I only need to use a `deque` and `popleft()` after each customer.” Yet, if I try to follow that approach, it won’t run:    ```", "```py    Listing 9-88: *process_orders.py:2a*    The issue here is that I’m mutating the collection while I’m iterating over it! This can confuse the iterator, potentially causing all sorts of undefined behavior, so Python tries not to allow it. Attempting to mutate a collection while iterating over it, whether you’re adding, removing, or reordering items, usually raises a `RuntimeError`.    There are two ways to fix this problem. The first is to make a copy of the collection before iterating over it:    ```", "```py    Listing 9-89: *process_orders.py:2b*    I had to use the `copy()` method, since deques don’t support the slice notation that would have allowed the snazzier colon in square brackets (`[:]`). Because the loop is iterating over a copy of the collection ❶, I am free to mutate the original however I like ❷, although this is seldom considered the ideal solution.    Since I want to remove items until the collection is emptied, I can use a `while` loop instead of a `for` loop:    ```", "```py    Listing 9-90: *process_orders.py:2c*    The `while` loop iterates until the collection `customers` indicates it is empty by evaluating to `False`. On each iteration, I use `popleft()` to access the next item, since that both returns and removes the item from the collection ❷. Unpacking is done in the suite of the loop ❶.    On the other hand, if I wanted to expand or reorder the contents of a collection while iterating over it, I’d need to create a new collection.    To demonstrate this, here is a rather convoluted example. For every drink ordered, I want to create a second serving of the same drink later. (I’ll leave the purpose behind this to your imagination.) In my first attempt at this, I’ll do this the wrong way, which won’t work.    As usual, I start by defining my list:    ```", "```py    Here, I’m attempting to add the same drink to the end of the list I’m iterating over:    ```", "```py    Listing 9-91: *double_orders.py:2a*    This example is particularly evil because, unlike the prior example, a `RuntimeError` is not raised when I attempt to mutate `orders` from within the suite of the loop. Instead, because there’s always a new item at the end of the list `orders`, the loop keeps running until the program runs out of memory and dies. Yuck.    To correct this, I need to create a new list for appending to:    ```", "```py    Listing 9-92: *double_orders.py:2b*    I define `new_orders` as a copy of `orders`, using slice notation to create the exact copy. Then, I iterate over `orders`, but I append to `new_orders`. Finally, when I’m done, I rebind `orders` to the new list, throwing the old list away.    ### Loop Nesting and Alternatives    As you might expect, you can nest loops. One situation where I might use this would be when running a coffee-tasting event where I wanted each guest to taste each type of coffee. Here’s a program to tell me who to give what sample to.    I start by defining two lists: one of samples and the other of guests:    ```", "```py    Listing 9-93: *tasting_lists.py:1*    Now I iterate over both lists at once:    ```", "```py    Listing 9-94: *tasting_lists.py:2a*    The outer loop iterates over the list `samples`. For each item in `samples`, the inner loop iterates over the list of `guests`, giving each one a sample.    Running that code produces the following output (truncated for brevity):    ```", "```py    Using nested loops is seldom considered the best solution in Python, for a couple of reasons. First, nesting itself is something Python developers like to avoid, as suggested by The Zen of Python:    > Flat is better than nested.    Nested structures are less readable and more *brittle*, meaning they are easily mistyped, due to their reliance on multiple levels of indentation. Python developers conventionally like to avoid any unnecessary nesting. A readable solution that is *flatter* (with less nesting) will almost invariably be preferred.    Second, *it’s impossible to break out of nested loops*. The `continue` and `break` keywords can only control the loop they’re directly in, not any outer or inner loops thereof. There are some “clever” ways around this, like putting the nested loop in a function and breaking out of the function by using a `return` statement. However, these hacks add complexity, nesting layers, or both, and they are thus discouraged.    Instead, anytime you’re thinking of using a nested loop, consider whether there are any viable alternatives. In the case of my example, I can achieve the same result as before in a single loop by using the `product()` function from the incredibly versatile `itertools` module (which I’ll introduce properly later):    ```", "```py    Listing 9-95: *tasting_lists.py:2b*    The `itertools.product()` function combines two or more iterables into a single iterable that contains tuples with every possible combination of items ❷. I unpack each of these tuples into names I can use to access the individual values in the suite of the loop ❶.    The output is the exact same as before.    Between the built-in iteration functions and the `itertools` module, Python has functions to cover most common situations where nested loops might ordinarily be used. If nothing already exists to do what you want, you can always write your own iterable function (called a *generator*; see Chapter 10) or an iterable class (see later in this chapter).    It may be impossible to avoid nested loops in most cases, but you’ll often find there is a cleaner, flatter solution.    ## Iteration Tools    Python has a whole bevy of handy tools for iterating over containers. For most of these, the official documentation is your friend. I’ll skim through some of the most common and useful tools here.    ### Basic Built-in Tools    A number of iteration tools are built into the language itself. Each of these requires you to pass at least a single iterable.    *   `all()` returns `True` if every item in the iterable evaluates to `True`. *   `any()` returns `True` if any item in the iterable evaluates to `True`. *   `enumerate()` (seen earlier) is an iterable that returns a tuple for each item in the iterable you pass to it. The first value in the tuple is the item’s “index,” and the second is the item value itself. This even works with iterables that aren’t subscriptable. This tool optionally accepts a `start=` argument, which defines the integer value to use as the first index. *   `max()` returns the largest item in the iterable. It optionally accepts a `key=` argument, which is usually a callable specifying what part of a collection item to sort on. *   `min()` is the same as `max()`, except that it returns the smallest item in the iterable. *   `range()` is an iterable that returns a sequence of integers from an optional starting value (default `0`) to one less than an ending value. An optional third argument can define the step. The `range(3)` iterable produces the values `(0,1,2)`, while `range(2,5)` produces the values `(2,3,4)`, and `range(1,6,2)` produces the values `(1,3,5)`. *   `reversed()` returns an iterator that iterates through the iterable, backward.     `sorted()` returns a list containing all the items of the iterable, sorted. It optionally accepts a `key=` argument, which is used in the same way as on `max()`. *   `sum()` returns the sum of all the items in the iterable, so long as all the items are numeric values. It optionally accepts a `start=` argument, which is the initial value of the sum.    The last three built-in iterables I’ll cover are more complicated, so I’ll detail each in the following subsections.    ### Filter    The `filter` iterable allows you to search for values in an iterable that fit a particular criterion. Say I have a list of orders and I want to find out how many of them call for drip coffee:    ```", "```py    Listing 9-96: *orders_filter.py*    To create the `filter` instance, I call its initializer ❷ and pass two arguments: the callable to use for filtering ❸ and the iterable being filtered ❹. I convert this `filter` iterable to a list ❶ before assigning that list to `drip_orders`.    Remember, the callable you use for filtering can be a function, a lambda, or anything else that can be treated as a function. Whatever the callable is, it should return a value that can be evaluated to a boolean, indicating whether the value passed to it should be included in the end result. In this case, that filtering callable will be a lambda, which returns `True` if the string `'drip'` is anywhere in the value passed to it ❸. Because the logic is simple, the lambda makes sense, but if I had wanted more complicated test logic, I would have written a proper function instead. The `filter` iterable will contain those items that pass the test specified by the lambda.    Finally, I print out the number of items in `drip_orders` ❺, which is the number of items that `filter` extracted from `orders`.    It just goes to show, you can even make a coffee filter with Python!    ### Map    The `map` iterable will pass every item in an iterable to a callable as an argument. Then, it will pass the returned value back as its own current iterative value.    In my café, I can define a function for brewing and then use `map()` to apply that function to each of the pending orders.    I’ll start by defining my orders list:    ```", "```py    Listing 9-97: *brew_map.py:1*    I’ll also define a function to handle brewing:    ```", "```py    Listing 9-98: *brew_map.py:2*    This function accepts an order as its sole argument, and then it returns that same order after it has been “made.”    I want to call `brew()` for each item in `orders`, passing each current order as an argument. For that, I’ll use `map()`:    ```", "```py    Listing 9-99: *brew_map.py:3*    In my `for` loop, I create an instance of the `map` iterable, passing the `brew()` function and the `orders` collection to the `map` initializer.    For each item in `orders`, the `brew()` function is called, and the item is passed as the argument. The value returned by `brew()` is then passed back by the `map` to the loop, which binds it to `order`, so it can be used in the suite of the loop. This process repeats until every item in `orders` has been iterated over.    You can also use `map()` with multiple iterables, with the current item of each being used as one of the arguments to the callable. Once one of the iterators has run out of values, `map` is done. Here’s how I would use it to add the cost and tip for multiple orders:    ```", "```py    Listing 9-100: *grand_total_map.py*    I have two lists: `cost` contains the price of each order, and `tip` contains the tip given for each order. In the loop, I create a `map` that calls the `operator.add()` function, passing the current item from `cost` as the first argument and the current item from `tip` as the second argument. The sum of the two values is returned and bound to `total`. I print that `total` value out, formatting it to display values to two decimal places.    Running that code outputs this:    ```", "```py    ### Zip    The `zip` iterable combines multiple iterables together. On each iteration, it takes the next value for each iterable in turn and packs them all together into a tuple. Once one of the iterables has been exhausted, `zip` stops.    This is particularly useful if you want to create a dictionary from multiple lists, although you could populate any collection using `zip`.    Here, I start with two lists. One list represents the regular customers, and one represents their usual orders. I want to turn this into a dictionary, so I can look up “the usual” by customer name:    ```", "```py    Listing 9-101: *usuals_zip.py*    I create a `zip` iterable ❷ whose items are tuples derived from the items in the `regulars` ❸ and `usuals` ❹ iterables: `('William', 'french press')`, `('Devin', 'double-shot espresso')`, and so forth. Then, I pass this iterable to the `dict()` initializer ❶, creating a dictionary (`usual_orders`) with the first item of each tuple as the key and the second item of each tuple as the value.    I’ll demonstrate that this works by looking up and printing Devin’s usual order:    ```", "```py    Listing 9-102: *usuals_zip.py*    The dictionary contains five items, since the shortest iterable, `regulars`, had five items. As a result, the excess item in `usuals` (namely, `'drip'`) is ignored by `zip`.    ### Itertools    The `itertools` module contains many useful classes for working with iteration. Very few Python developers memorize all of these. They instead refer to the documentation via the website or the `help()` command, whenever the topic comes up.    Here are a few highlights. Understand that I’ll skip most of the optional arguments, for the sake of brevity:    1.  `accumulate` repeatedly performs a two-argument function and uses the result of each call as the first argument for the next call. The current item in the iterable is the second argument. On each iteration, the current result is returned. By default, this uses the `operator.add()` function. 2.  `chain` produces a list containing each item from each iterable passed to it, in order. `chain([1,2,3], [4,5,6])` would produce `1`, `2`, `3`, `4`, `5`, and `6`. 3.  `combinations` produces every possible subsequence of items in the provided iterable, with the specified number of items in each combination. `combinations([1,2,3], 2)` would produce `(1, 2)`, `(1, 3)`, and `(2, 3)`. 4.  `dropwhile` drops (skips) items in an iterable as long as some expression evaluates to `True`, and then it returns every item after that. So `dropwhile(lambda n:n!=42, [5,6,42,7,53])` would produce `42`, `7`, and `53`, since the predicate lambda returns `True` until it encounters the value `42`. 5.  `filterfalse` is the same as `filter`, except that it works in exactly the opposite manner: the callable must return `False` to include the item. 6.  `islice` performs slices on nonsubscriptable iterables. It is identical in behavior to slicing, except that it doesn’t support negative values for the `start`, `stop`, or `step`. 7.  `permutations` produces every possible permutation of the items in the provided iterable, with the specified number of items in each permutation. `permutations([1,2,3], 2)` would produce `(1, 2)`, `(1, 3)`, `(2, 1)`, `(2, 3)`, `(3, 1)`, and `(3, 2)`. 8.  `product` produces the Cartesian product of the provided iterables. `product([1,2], [3,4])` would produce `(1, 3)`, `(1, 4)`, `(2, 3)`, and `(2, 4)`. 9.  `starmap` behaves like `map`, except that it passes each item in the provided iterator as a starred argument. `starmap(func, [(1,2), (3,4)]` would call `func(1,2)` and then `func(3,4)`. 10.  `takewhile` behaves in exactly the opposite way as does `dropwhile`. It takes items from the provided iterator, as long as the provided predicate evaluates to `True`. As soon as the predicate evaluates to `False`, it ignores the rest of the items.    There are a few more classes in `itertools` besides these. Read the documentation for more information!    ## Custom Iterable Classes    Though Python offers plenty of collections and other iterables, there may arise a situation when you need to write your *own* iterable class. Thankfully, this is not difficult.    Often, you’ll write two classes: an *iterable* and a corresponding *iterator*. This is a matter of separation of concerns: the iterable is responsible for storing or generating values, while the iterator is responsible for tracking the current position in that iterable. This allows you to make multiple independent iterator instances for the same iterable.    There are situations where it is beneficial for a single class to be both an iterable and an iterator. One such situation occurs when the iterable object’s data is nonreproducible, such as with data streamed over a network. Another case is infinite iterators, which I’ll revisit in Chapter 10.    For now, I’ll stick with the typical two-class approach. Here’s a simple iterable class that I can use for tracking café patrons and the details of their orders. (In the real world, I probably wouldn’t solve the problem with a custom iterable class like this, but it works as an example.)    I’ll start by defining the iterable class for tracking customers:    ```", "```py    Listing 9-103: *cafequeue.py:1*    The class will have three instance attributes: `_queue`, a list containing customer names; `_orders`, a dictionary storing customer orders; and `_togo`, a dictionary storing whether the customer wants their order to go or not.    To make the class iterable, I define the `__iter__()` special method:    ```", "```py    Listing 9-104: *cafequeue.py:2*    The `__iter__()` method must return an instance of the corresponding iterator class. (I’ll define this class in a moment.)    To make this iterable class useful, I’d like to do some other things with it, besides iterate over its data. The `add_customer()` instance method will allow me to add a new customer:    ```", "```py    Listing 9-105: *cafequeue.py:3*    I will want to check how many customers are in line by using the `len()` built-in function, so I must define the `__len__()` special instance method:    ```", "```py    Listing 9-106: *cafequeue.py:4*    Remember, `len()` is only for when I actually need to work with the length of the queue itself. For example, if I wanted an LCD display in the cafe to show how many customers are in line, the code for that display could use `len()` on a `CafeQueue` object to get that data. Even so, I never use `len()` directly in the loop header as part of iteration.    Finally, I’d like to check whether a particular customer is in the queue, so I define the `__contains__()` special method:    ```", "```py    Listing 9-107: *cafequeue.py:5*    Now that I have the `CafeQueue` class, I can define the corresponding iterator class, which I’m calling `CafeQueueIterator`. Ordinarily, these two classes would be defined in the same module, as I’ve done here.    I’ll start with the iterator’s initializer:    ```", "```py    Listing 9-108: *cafequeue.py:6*    This iterator class is responsible for keeping track of its own position in the iterable. The initializer receives a single argument: the iterable instance associated with the iterator instance ❶.    This is why, in the iterable’s `__iter__()` method, I can use the line `return CafeQueueIterator(self)` (see [Listing 9-108](#listing9-108)). I pass the iterable instance to the iterator initializer, where it is stored as the instance attribute `_cafe`.    An iterator class must define the special method `__next__()`, which returns the next item in the iterable:    ```", "```py    Listing 9-109: *cafequeue.py:7*    The `__next__()` method is responsible for keeping track of the iterator’s position in the iterable. Iterables can be infinite (something I’ll cover in depth in Chapter 10), so there is no built-in means of stopping iteration. In `__next__()`, if I’ve iterated over all the items in the iterable ❶, I raise `StopIteration` ❷. Otherwise, after retrieving the current item from the iterable, I must update the iterator’s position ❸ before finally returning the item ❹.    Each item contains multiple elements, so I pack the data for an item into a tuple: `(``customer``,` `orders``,` `to_go``)`. This can be unpacked in a `for` loop during iteration. If you look at the `CafeQueue` class again ([Listing 9-103](#listing9-103)), you’ll notice that `orders` will be a tuple of varying length, containing each order for the customer.    The special method `__iter__()` must also be defined in an iterator class. This method is always expected to return an iterator, but since this instance *is* an iterator, `__iter__()` only needs to return `self`.    ```", "```py    Listing 9-110: *cafequeue.py:8*    Now that I have both my iterable (`CafeQueue`) and iterator (`CafeQueueIterator`) classes written, I can use them like any other collection. I create a new `CafeQueue` and populate it with data:    ```", "```py    Listing 9-111: *cafequeue.py:9*    Before I iterate over the collection, I’ll test using `len()` and `in`:    ```", "```py    Listing 9-112: *cafequeue.py:10*    I can see how many customers are in the queue with `len()` and check for individual customers using `in`. All’s well, so far!    I want to use this new iterable to automate making and delivering orders to the customers. Remember that each item in the iterable will be a tuple `(``customers``,` `orders``,` `to_go``)` and that `orders` is itself a tuple of unknown length. Although it’s simple in this example, you can imagine that brewing an order could theoretically be quite involved, so I’ll use the stand-alone `brew()` function from [Listing 9-98](#listing9-98) to handle each order:    ```", "```py    Listing 9-113: *cafequeue.py:11*    Nothing remarkable there.    So then, here’s the loop for working with the `CafeQueue` instance `queue`:    ```", "```py    Listing 9-114: *cafequeue.py:12*    The `for` loop iterates over `queue`, unpacking each item tuple into three names: `customer`, `orders`, and `to_go`.    I use a nested loop to pass each item in the `orders` tuple to the `brew()` function ❶. This particular `for` loop is pretty simple, so I can write it as a flat statement.    Finally, I use `to_go` to determine whether to announce the order is ready or to take it out to the customer’s table.    ## Wrapping Up    Iteration simplifies how one works with loops and collections. Practically any class can be an iterable if it defines an `__iter__()` method, which returns a corresponding iterator object. An iterator class keeps track of its position in traversing its corresponding iterable, and it must have a `__next__()` method for returning the next item in the iterable. All Python collections are iterables, and the language offers a number of useful iterator classes, including many in the `itertools` module.    Python’s `for` loop is designed specifically for working with iterables and iterators; it handles the calls to `__iter__()` and `__next__()` behind the scenes, allowing you to focus on what you want to do with each item instead.    Now’s a good time to get a coffee refill before we dive into the next chapter, wherein I’ll introduce the related concepts of *infinite iterators*, *generators*, and *generator expressions*. (Bring me back a pumpkin spice latte while you’re up there, hey?)```"]