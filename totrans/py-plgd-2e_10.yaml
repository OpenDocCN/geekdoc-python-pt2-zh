- en: '[7](nsp-venkitachalam503045-0008.xhtml#rch07)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[7](nsp-venkitachalam503045-0008.xhtml#rch07)'
- en: Photomosaics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 照片马赛克
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: When I was in the sixth grade, I saw a picture like the one shown in [Figure
    7-1](nsp-venkitachalam503045-0020.xhtml#fig7-1) but couldn’t quite figure out
    what it was. After squinting at it for a while, I eventually figured it out. (Turn
    the book upside down, and view it from across the room. I won’t tell anyone.)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我读六年级时，我看到了一个像[图 7-1](nsp-venkitachalam503045-0020.xhtml#fig7-1)中显示的图片，但我无法完全弄清楚它是什么。经过一段时间的凝视后，我最终理解了它。（把书倒过来，从房间的对面看。我不会告诉任何人。）
- en: The puzzle works because of how the human eye functions. The low-resolution,
    blocky image shown in the figure is hard to recognize up close, but when it is
    seen from a distance, you know what it represents because your eyes perceive less
    detail, which makes the edges smooth.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题之所以有效，是因为人眼的工作方式。图中显示的低分辨率、方块状图像近距离看起来很难识别，但当从远处观看时，您知道它代表什么，因为您的眼睛感知到的细节较少，使边缘更平滑。
- en: 'A *photomosaic* is an image that works according to a similar principle. You
    take a *target* image, split it into a grid of rectangles, and replace each rectangle
    with another, smaller image that matches that section of the target. When you
    look at a photomosaic from a distance, all you see is the target image, but if
    you come closer, the secret is revealed: the image actually consists of many tiny
    images!'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*照片马赛克* 是根据类似原理制作的图像。您将一个*目标*图像分割成矩形网格，并将每个矩形替换为另一张小图像，该小图像与目标的相应部分匹配。当您从远处观看照片马赛克时，您只能看到目标图像，但是当您靠近时，秘密揭示了：图像实际上由许多小图像组成！'
- en: '![](images/nsp-venkitachalam503045-f07001.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f07001.jpg)'
- en: 'Figure 7-1: A puzzling image'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：一个令人困惑的图像
- en: In this project, you’ll create a photomosaic using Python. You’ll divide a target
    image into a grid and replace each block in the grid with a suitable image to
    create a photomosaic of the original. You’ll be able to specify the grid dimensions
    and choose whether input images can be reused in the mosaic.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您将使用Python创建一个照片马赛克。您将把目标图像划分成网格，并将网格中的每个块替换为合适的图像，以创建原始图像的照片马赛克。您可以指定网格的维度，并选择是否可以在马赛克中重复使用输入图像。
- en: 'As you work on the project, you’ll learn how to do the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发项目的过程中，您将学会如何执行以下操作：
- en: • Create images using the Python Imaging Library (PIL).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用Python Imaging Library（PIL）创建图像。
- en: • Compute the average RGB value of an image.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 计算图像的平均RGB值。
- en: • Crop images.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 裁剪图像。
- en: • Replace part of an image by pasting in another image.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 替换图像的一部分，通过粘贴另一张图像。
- en: • Compare RGB values using a measurement of average distance in three dimensions.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用三维平均距离测量比较RGB值。
- en: • Use a data structure called a *k-d tree* to efficiently find the image that
    best matches a section of the target image.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用称为*k-d树*的数据结构，有效地找到最匹配目标图像部分的图像。
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0901)'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[工作原理](nsp-venkitachalam503045-0008.xhtml#rah0901)'
- en: 'To create a photomosaic, begin with a blocky, low-resolution version of the
    target image (because the number of tile images would be too great in a high-resolution
    image). The user inputs the dimensions *M*×*N* (where *M* is the number of rows
    and *N* is the number of columns) of the mosaic. Next, build the mosaic according
    to this methodology:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建照片马赛克，首先使用一个方块状、低分辨率的目标图像（因为在高分辨率图像中，图像数量太多）。用户输入马赛克的维度*M*×*N*（其中*M*是行数，*N*是列数）。接下来，按照这种方法构建马赛克：
- en: 1\. Read the input images, which will be drawn on to replace the tiles in the
    original image.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 读取输入图像，将其绘制以替换原始图像中的瓦片。
- en: 2\. Read the target image and split it into an *M*×*N* grid of tiles.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 读取目标图像并将其分割为一个*M*×*N*网格的瓦片。
- en: 3\. For each tile, find the best match from the input images.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 对于每个瓦片，从输入图像中找到最佳匹配。
- en: 4\. Create the final mosaic by arranging the selected input images in an *M*×*N*
    grid.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 通过将选择的输入图像排列在*M*×*N*网格中创建最终的马赛克。
- en: '[Splitting the Target Image](nsp-venkitachalam503045-0008.xhtml#rbh0901)'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[分割目标图像](nsp-venkitachalam503045-0008.xhtml#rbh0901)'
- en: We’ll start by looking at how to split the target image into an *M*×*N* grid
    of tiles. Follow the scheme shown in [Figure 7-2](nsp-venkitachalam503045-0020.xhtml#fig7-2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看如何将目标图像分割成一个*M*×*N*网格的瓦片。按照[图 7-2](nsp-venkitachalam503045-0020.xhtml#fig7-2)中显示的方案操作。
- en: '![](images/nsp-venkitachalam503045-f07002.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f07002.jpg)'
- en: 'Figure 7-2: Splitting the target image'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：分割目标图像
- en: We split the original image into a grid of tiles with *N* columns arranged along
    the x-axis and *M* rows arranged along the y-axis. Each tile is represented by
    an index (*i*, *j*) and is *w* pixels wide and *h* pixels high. According to this
    scheme, the original image is *w* × *N* pixels wide and *h* × *M* pixels high.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将原始图像划分为一个包含*N*列（沿x轴排列）和*M*行（沿y轴排列）的网格。每个图块由索引（*i*, *j*）表示，宽度为*w*像素，高度为*h*像素。根据这一方案，原始图像的宽度为*w*
    × *N*像素，高度为*h* × *M*像素。
- en: The right side of [Figure 7-2](nsp-venkitachalam503045-0020.xhtml#fig7-2) shows
    how to calculate the pixel coordinates for a single tile from this grid. The tile
    with index (*i*, *j*) has a top-left corner coordinate of (*i* × *w, i* × *j*)
    and a bottom-right corner coordinate of ((*i* + 1) × *w*, (*j* + 1) × *h*). These
    coordinates can be used with the PIL to crop and create tiles from the original
    image.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-2](nsp-venkitachalam503045-0020.xhtml#fig7-2)的右侧展示了如何计算来自此网格的单个图块的像素坐标。索引为（*i*,
    *j*）的图块的左上角坐标为（*i* × *w*, *j* × *h*），右下角坐标为（(*i* + 1) × *w*, (*j* + 1) × *h*）。这些坐标可以与PIL一起使用，以裁剪并创建来自原始图像的图块。'
- en: '[Averaging Color Values](nsp-venkitachalam503045-0008.xhtml#rbh0902)'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[平均颜色值](nsp-venkitachalam503045-0008.xhtml#rbh0902)'
- en: 'Every pixel in an image has a color that can be represented numerically by
    its red, green, and blue values. In this case, you are using 8-bit images, so
    each of these three color components has an 8-bit value in the range [0, 255].
    You can therefore determine the average color of an image by taking the average
    of the red, green, and blue values for all of the image’s pixels. Given an image
    with a total of *N* pixels, the average RGB is calculated as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图像中的每个像素都有一个颜色，可以通过其红色、绿色和蓝色值以数字形式表示。在这种情况下，你使用的是8位图像，因此每个颜色组件都有一个位于[0, 255]范围内的8位值。因此，你可以通过计算图像所有像素的红色、绿色和蓝色值的平均值来确定图像的平均颜色。给定一张包含总计*N*个像素的图像，平均RGB值可以按以下方式计算：
- en: '![](images/nsp-venkitachalam503045-m07001.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m07001.jpg)'
- en: Like the RGB for an individual pixel, the average RGB for a whole image is a
    triplet, not a scalar or single number, because the averages are calculated separately
    for each color component. You calculate the average RGB to match the tiles from
    the target image with replacements from among the input images.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与单个像素的RGB值一样，整张图像的平均RGB值也是一个三元组，而不是标量或单个数字，因为每个颜色组件的平均值是分别计算的。你计算平均RGB值是为了通过替换输入图像中的图块与目标图像的图块进行匹配。
- en: '[Matching Images](nsp-venkitachalam503045-0008.xhtml#rbh0903)'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[匹配图像](nsp-venkitachalam503045-0008.xhtml#rbh0903)'
- en: For each tile in the target image, you need to find a matching image from the
    images in the input folder specified by the user. To determine whether two images
    match, use the average RGB values. The best match is the input image with the
    average RGB value closest to that of the tile from the target image.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标图像中的每个图块，你需要从用户指定的输入文件夹中的图像中找到一个匹配的图像。为了确定两张图像是否匹配，使用平均RGB值。最佳匹配是输入图像，其平均RGB值最接近目标图像中图块的平均RGB值。
- en: 'The simplest way to find the best match is to calculate the distance between
    the average RGB values as if they were points in 3D space. After all, each average
    RGB consists of three numbers, which you can think of as x-, y-, and z-axis coordinates.
    You can thus use the following formula from the geometry for calculating the distance
    between two 3D points:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最佳匹配的最简单方法是计算平均RGB值之间的距离，就好像它们是三维空间中的点一样。毕竟，每个平均RGB值由三个数字组成，你可以将它们视为x轴、y轴和z轴的坐标。因此，你可以使用几何学中用于计算两个三维点之间距离的以下公式：
- en: '![](images/nsp-venkitachalam503045-m07002.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m07002.jpg)'
- en: Here you compute the distance between the points (*r*[1], *g*[1], *b*[1]) and
    (*r*[2], *g*[2], *b*[2]). Given a target average RGB value (*r*[1], *g*[1], *b*[1]),
    you can plug a list of average RGB values from the input images into the previous
    formula as (*r*[2], *g*[2], *b*[2]) to find the closest matching image. However,
    there might be hundreds or even thousands of input images to check. We should
    therefore give some thought to how to efficiently search the set of input images
    to find the best match.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你计算的是点（*r*[1], *g*[1], *b*[1]）和（*r*[2], *g*[2], *b*[2]）之间的距离。给定一个目标平均RGB值（*r*[1],
    *g*[1], *b*[1]），你可以将输入图像的平均RGB值列表代入到之前的公式中，作为（*r*[2], *g*[2], *b*[2]），以找到最匹配的图像。然而，可能有数百甚至数千张输入图像需要检查。因此，我们应该考虑如何高效地搜索输入图像集，以找到最佳匹配。
- en: Using Linear Search
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用线性搜索
- en: 'The simplest approach to searching for a match is a *linear search*. In this
    method, you just iterate through all the RGB values one by one and find the one
    with the minimum distance to the query value. The code will look something like
    this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索匹配的最简单方法是线性搜索。在此方法中，您只需逐一迭代所有 RGB 值，并找到与查询值距离最小的值。代码将如下所示：
- en: min_dist = MAX_VAL
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: min_dist = MAX_VAL
- en: 'for val in vals:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'for val in vals:'
- en: dist = distance(query, val)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: dist = distance(query, val)
- en: 'if dist < MAX_VAL:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 dist < MAX_VAL：
- en: min_dist = dist
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: min_dist = dist
- en: You go through each value in the list `vals` one by one and calculate the distance
    between that value and `query`. If the result is less than `min_dist` (which was
    initialized as the maximum possible distance between two points), you update `min_dist`
    with the distance you just calculated. After checking every item in `vals`, `min_dist`
    will contain the smallest distance in the whole dataset.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 逐一遍历列表 `vals` 中的每个值，并计算该值与 `query` 之间的距离。如果结果小于 `min_dist`（它被初始化为两点之间的最大可能距离），则使用刚计算的距离更新
    `min_dist`。检查完 `vals` 中的每个项后，`min_dist` 将包含整个数据集中的最小距离。
- en: Although a linear search method is easy to understand and implement, it isn’t
    very efficient. If there are *N* values in the `vals` list, the search will take
    an amount of time proportional to *N*. You can achieve much better performance
    with a different data structure and search algorithm.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管线性搜索方法易于理解和实现，但效率并不高。如果 `vals` 列表中有 *N* 个值，则搜索将花费与 *N* 成正比的时间。您可以通过不同的数据结构和搜索算法实现更高的性能。
- en: Using k-d Trees
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 k-d 树
- en: 'A *k-d tree*, or *k-dimensional tree*, is a data structure that partitions
    a space of *k* dimensions—that is, it divides the space into a number of non-overlapping
    subspaces. This data structure provides a way to sort and search through datasets
    whose members are points in *k*-dimensional space. The dataset is represented
    as a *binary tree*: each point in the dataset becomes a node in the tree, and
    each node can have two child nodes. In other words, each node in the tree divides
    the space into two parts, called *subtrees*. One part points to the left of the
    node (the node’s left child and its descendants), and the other points to the
    right of the node (the node’s right child and its descendants).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*k-d 树*（或 *k 维树*）是一种数据结构，它将 *k* 维空间划分为多个不重叠的子空间。这种数据结构提供了一种对 *k* 维空间中点的数据集进行排序和搜索的方法。数据集表示为
    *二叉树*：数据集中的每个点成为树中的一个节点，每个节点可以有两个子节点。换句话说，树中的每个节点将空间分为两部分，称为 *子树*。一个部分指向节点的左边（节点的左子节点及其后代），另一个部分指向节点的右边（节点的右子节点及其后代）。'
- en: Each node of the tree is associated with one of the dimensions of the space,
    and that’s the dimension used to determine if points belong in the node’s left
    subtree or right subtree. If a node is associated with the x-axis, for example,
    points whose x-values are less than that node’s x-value will be put in the node’s
    left subtree, and points whose x-values are greater than the node’s x-value will
    be put in the right subtree. A common method to select the dimension associated
    with each node is to cycle through them as you move down the levels of the tree.
    For example, in the case of a three-dimensional k-d tree, you could set the dimensions
    to be x, y, z, x, y, z, and so on, moving down the tree. Nodes at the same tree
    height will have the same splitting dimension.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 树的每个节点与空间的一个维度相关联，这是用于确定点属于节点的左子树还是右子树的维度。例如，如果一个节点与 x 轴相关联，则 x 值小于该节点 x 值的点将放入节点的左子树，而
    x 值大于节点 x 值的点将放入右子树。选择每个节点相关联的维度的常见方法是在树的各层级中循环遍历它们。例如，在三维 k-d 树的情况下，可以将维度设置为
    x、y、z、x、y、z 等，依此类推。在同一树高度的节点将具有相同的分割维度。
- en: 'Let’s look at a simple example of a k-d tree. Say you have the following set
    of points, *P*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个 k-d 树的简单示例。假设您有以下一组点 *P*：
- en: '*P* = {(5, 3), (2, 4), (1, 2), (6, 6), (7, 2), (4, 6), (2, 8)}'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* = {(5, 3), (2, 4), (1, 2), (6, 6), (7, 2), (4, 6), (2, 8)}'
- en: In this case, you’d build a two-dimensional k-d tree, since each member of *P*
    describes a point in two-dimensional space. You start by associating the first
    node, or the *root* node, (5, 3), with the x-dimension. Then you add the next
    point, (2, 4), as a left child of the root node, since the point’s x-coordinate,
    2, is less than 5, the x-coordinate of the root. The node (2, 4), being on the
    second level of the k-d tree, will use the y-dimension for partition. The next
    point in the list is (1, 2). Starting again at the root, 1 < 5, so you go to the
    left child of the root node. You then compare (1, 2) with (2, 4) using the y-dimension.
    Since 2 < 4, you add (1, 2) as the left child of (2, 4).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你将构建一个二维k-d树，因为*P*中的每个成员描述了一个二维空间中的点。首先，你将第一个节点或*根*节点（5, 3）与x维度关联。然后，你将下一个点（2,
    4）作为根节点的左子节点，因为该点的x坐标2小于根节点的x坐标5。节点（2, 4），作为k-d树的第二层节点，将使用y维度进行划分。接下来的点是（1, 2）。从根节点开始，1
    < 5，所以你转到根节点的左子节点。然后，你使用y维度将（1, 2）与（2, 4）进行比较。由于2 < 4，你将（1, 2）作为（2, 4）的左子节点添加。
- en: If you continue in this fashion for all the points in *P*, you’ll create the
    tree and space partitioning shown in [Figure 7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对*P*中的所有点继续以这种方式操作，你将创建如[图7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3)所示的树和空间划分。
- en: '![](images/nsp-venkitachalam503045-f07003.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f07003.jpg)'
- en: 'Figure 7-3: An example of a k-d tree'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-3：k-d树的示例
- en: The top image of [Figure 7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3) shows
    the space partitioning scheme for the tree we just discussed. Starting with point
    (5, 3), you split the space in two along the x-dimension by drawing a vertical
    line through that point. Next, you use point (2, 4) to split the left half of
    the first partition along the y-dimension by drawing a horizontal line through
    the point, stopping when the line hits the vertical line. Continue in this fashion
    with the remaining points, and you’ll get the partitioning scheme shown in the
    figure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3)的顶部图像显示了我们刚才讨论的树的空间划分方案。从点（5,
    3）开始，你通过在该点画一条垂直线将空间沿x维度分成两部分。接下来，使用点（2, 4）通过在该点画一条水平线来将第一个划分的左半部分沿y维度分割，直到线与垂直线相交。以这种方式继续处理剩余的点，你将得到图中显示的划分方案。'
- en: Why should you care about k-d trees? The answer is that once you arrange a dataset
    this way, you can search through it much more quickly. Specifically, a *nearest-neighbor
    search*—finding the point closest to a queried point—is much faster with a k-d
    tree than a linear search. For a dataset of *N* values, the average nearest-neighbor
    search of a k-d tree takes a time proportional to log(*N*), much less than the
    time proportional to *N* that a linear search would take.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你应该关心k-d树？答案是，一旦你以这种方式安排数据集，你可以更快地进行搜索。具体来说，*最近邻搜索*——找到最接近查询点的点——在k-d树中比线性搜索要快得多。对于一个包含*N*个值的数据集，k-d树的平均最近邻搜索时间是与log(*N*)成正比的，比线性搜索与*N*成正比的时间要短得多。
- en: To demonstrate, let’s try to find the point from *P* nearest to point *q*, (2,
    3), which is shown in [Figure 7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3).
    Looking at the figure, you can see that point (2, 4) is the match. The nearest-neighbor
    algorithm will find the match by traversing down the tree from (5, 3) to (2, 4).
    The algorithm knows, for example, that the right subtree of the root can be skipped,
    since *q*’s x-coordinate is less than the root node’s x-coordinate. The spatial
    partitioning scheme thus lets you skip a larger number of comparisons than with
    a linear search. This is what makes the k-d tree useful for our problem.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，假设我们要找到点*P*中距离点*q*（2, 3）最近的点，如[图7-3](nsp-venkitachalam503045-0020.xhtml#fig7-3)所示。从图中可以看出，点（2,
    4）是匹配点。最近邻算法会通过从（5, 3）到（2, 4）遍历树来找到匹配点。例如，算法知道，根节点的右子树可以被跳过，因为*q*的x坐标小于根节点的x坐标。因此，空间划分方案使得你可以跳过比线性搜索更多的比较。这就是k-d树在我们问题中有用的地方。
- en: 'How can you use a k-d tree in the photomosaic code? You could try to write
    an implementation from scratch, but there’s an easier option: the `scipy` library
    already has a built-in k-d tree class. We’ll look at how to leverage this class
    later in the chapter.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在光栅马赛克代码中使用k-d树？你可以尝试从头开始编写一个实现，但有一个更简单的选择：`scipy`库已经有一个内置的k-d树类。我们将在本章后面讨论如何利用这个类。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0902)'
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah0902)'
- en: For this project, you’ll use `Pillow` to read in the images, access their underlying
    data, and create and modify the images. You’ll also use `numpy` to manipulate
    image data and `scipy` to search the image data using a k-d tree.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将使用`Pillow`来读取图像，访问它们的基础数据，并创建和修改图像。你还将使用`numpy`来操作图像数据，使用`scipy`通过k-d树搜索图像数据。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0903)'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0903)'
- en: You’ll begin by reading in the input images that you’ll draw on to create the
    photomosaic. Next, you’ll compute the average RGB value of the images, split the
    target into a grid, and find the image that best matches each tile in the grid.
    Finally, you’ll assemble the image tiles to create the actual photomosaic. To
    see the complete project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0020.xhtml#ah0907)
    on [page 129](nsp-venkitachalam503045-0020.xhtml#p129). You can also find the
    code at [https://github.com/mkvenkit/pp2e/tree/main/photomosaic](https://github.com/mkvenkit/pp2e/tree/main/photomosaic).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要读取输入图像，用于创建照片马赛克。接下来，计算图像的平均RGB值，将目标分割成网格，并找到最佳匹配每个网格瓦片的图像。最后，组装图像瓦片以创建实际的照片马赛克。要查看完整的项目代码，请跳转到[“完整代码”](nsp-venkitachalam503045-0020.xhtml#ah0907)，位于[第129页](nsp-venkitachalam503045-0020.xhtml#p129)。你也可以在[https://github.com/mkvenkit/pp2e/tree/main/photomosaic](https://github.com/mkvenkit/pp2e/tree/main/photomosaic)找到该代码。
- en: '[Reading In the Input Images](nsp-venkitachalam503045-0008.xhtml#rbh0904)'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[读取输入图像](nsp-venkitachalam503045-0008.xhtml#rbh0904)'
- en: 'First read in the input images from a given folder. Here’s how to do that:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从给定文件夹中读取输入图像。以下是如何完成此操作的方法：
- en: 'def getImages(imageDir):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getImages(imageDir):'
- en: '"""'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: given a directory of images, return a list of Images
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个图像目录，返回一个图像列表
- en: '"""'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ❶ files = os.listdir(imageDir)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ files = os.listdir(imageDir)
- en: images = []
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: images = []
- en: 'for file in files:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'for file in files:'
- en: ❷ filePath = os.path.abspath(os.path.join(imageDir, file))
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ filePath = os.path.abspath(os.path.join(imageDir, file))
- en: 'try:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: '# explicit load so we don''t run into resource crunch'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '# 明确加载以避免资源危机'
- en: ❸ fp = open(filePath, "rb")
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ fp = open(filePath, "rb")
- en: im = Image.open(fp)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: im = Image.open(fp)
- en: images.append(im)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: images.append(im)
- en: '# force loading the image data from file'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '# 强制加载来自文件的图像数据'
- en: ❹ im.load()
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ im.load()
- en: '# close the file'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭文件'
- en: ❺ fp.close()
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ fp.close()
- en: 'except:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: '# skip'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '# 跳过'
- en: 'print("Invalid image: %s" % (filePath,))'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: print("无效图像：%s" % (filePath,))
- en: return images
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: return images
- en: You first use `os.listdir()` to gather the filenames in the *imageDir* directory
    in a list called `files` ❶. Next, you iterate through each file in the list and
    load it into a PIL `Image` object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用`os.listdir()`获取列表`files`中*imageDir*目录中的文件名 ❶。接下来，遍历列表中的每个文件并将其加载到PIL `Image`对象中。
- en: You use `os.path.abspath()` and `os.path.join()` to get the complete filename
    of the image ❷. This idiom is commonly used in Python to ensure that your code
    will work with both relative paths (for example, *\foo\bar\*) and absolute paths
    (*c:\foo\bar\*), as well as across operating systems with different directory-naming
    conventions (\ in Windows versus / in Linux).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`os.path.abspath()`和`os.path.join()`获取图像文件的完整文件名 ❷。这种习惯用法在Python中常用，可确保代码能处理相对路径（例如，*\foo\bar\*）和绝对路径（例如，*c:\foo\bar\*），以及在不同操作系统中使用不同目录命名约定（Windows中的\与Linux中的/）。
- en: To load the files into PIL `Image` objects, you could pass each filename to
    the `Image.open()` method, but if your photomosaic folder had hundreds or thousands
    of images, doing so would be highly resource intensive. Instead, you can use Python
    to open each image and pass the file handle `fp` into PIL using `Image.open()`.
    Once the image has been loaded, close the file handle and release the system resources.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件加载到PIL `Image`对象中，你可以将每个文件名传递给`Image.open()`方法，但如果你的照片马赛克文件夹中有数百或数千个图像，这样做将非常耗费资源。相反，你可以使用Python打开每个图像，并将文件句柄`fp`传递给PIL的`Image.open()`。一旦加载了图像，关闭文件句柄并释放系统资源。
- en: You open the image file using `open()` ❸ and then pass the handle to `Image.open()`
    and store the resulting image, `im`, in a list called `images`. Calling `Image.load()`
    ❹ force-loads the image data inside `im` because `open()` is a lazy operation.
    It identifies the image but doesn’t actually read all the image data until you
    try to use the image. You finish by closing the file handle to release system
    resources ❺.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`open()` ❸ 打开图像文件，然后将句柄传递给`Image.open()`并将结果图像`im`存储在名为`images`的列表中。调用`Image.load()`
    ❹ 强制加载`im`内部的图像数据，因为`open()`是惰性操作。它标识图像但直到尝试使用图像时才实际读取所有图像数据。最后，通过关闭文件句柄来释放系统资源
    ❺。
- en: '[Calculating the Average Color Value of an Image](nsp-venkitachalam503045-0008.xhtml#rbh0905)'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[计算图像的平均颜色值](nsp-venkitachalam503045-0008.xhtml#rbh0905)'
- en: Once you’ve read in the input images, you need to calculate each image’s average
    color value. You also need to find the average color value for each section of
    the target image. Create a function `getAverageRGB()` to handle both tasks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取了输入图像后，你需要计算每个图像的平均颜色值。你还需要计算目标图像每个区域的平均颜色值。创建一个函数 `getAverageRGB()` 来处理这两个任务。
- en: 'def getAverageRGB(image):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getAverageRGB(image):'
- en: '"""'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: return the average color value as (r, g, b) for each input image
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 返回每个输入图像的平均颜色值，格式为 (r, g, b)
- en: '"""'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# get each tile image as a numpy array'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将每个瓦片图像作为 numpy 数组获取'
- en: ❶ im = np.array(image)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ im = np.array(image)
- en: '# get the shape of each input image'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取每个输入图像的形状'
- en: ❷ w,h,d = im.shape
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ w,h,d = im.shape
- en: '# get the average RGB value'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取平均 RGB 值'
- en: ❸ return tuple(np.average(im.reshape(w*h, d), axis=0))
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回元组(np.average(im.reshape(w*h, d), axis=0))
- en: The function takes in an `Image` object—it could be one of the input images
    or a section of the target image—and uses `numpy` to convert it into a data array ❶.
    The resulting `numpy` array has the shape (`w`, `h`, `d`), where `w` is the width
    of the image, `h` is the height, and `d` is the depth, which, in the case of RGB
    images, is three units (one each for R, G, and B). You store the `shape` tuple
    ❷ and then compute the average RGB value by reshaping the array into a more convenient
    form with shape (`w*h`, `d`) so that you can compute the average using `numpy.average()`
    ❸. (You performed a similar operation in [Chapter 6](nsp-venkitachalam503045-0019.xhtml#ch06)
    to get the average brightness of a grayscale image.) You return the result as
    a tuple.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个 `Image` 对象——它可以是一个输入图像，也可以是目标图像的一部分——并使用 `numpy` 将其转换为数据数组❶。生成的 `numpy`
    数组的形状为 (`w`, `h`, `d`)，其中 `w` 是图像的宽度，`h` 是高度，`d` 是深度，对于 RGB 图像，`d` 的值为三（分别对应 R、G、B）。你将
    `shape` 元组存储为 ❷，然后通过将数组重塑为形状为 (`w*h`, `d`) 的更方便的形式来计算平均 RGB 值，以便使用 `numpy.average()`
    ❸ 进行平均计算。（你在[第 6 章](nsp-venkitachalam503045-0019.xhtml#ch06)中执行了类似的操作来获取灰度图像的平均亮度。）最终你将结果作为一个元组返回。
- en: '[Splitting the Target Image into a Grid](nsp-venkitachalam503045-0008.xhtml#rbh0906)'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[将目标图像分割成网格](nsp-venkitachalam503045-0008.xhtml#rbh0906)'
- en: 'Now you need to split the target image into an *M*×*N* grid of smaller images.
    Let’s create a function to do that:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要将目标图像分割成 *M*×*N* 的小图像网格。我们来创建一个函数来完成这个任务：
- en: 'def splitImage(image, size):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'def splitImage(image, size):'
- en: '"""'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: given the image and dimensions (rows, cols), return an m*n list of images
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 给定图像和尺寸（行，列），返回一个 m*n 的图像列表
- en: '"""'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ❶ W, H = image.size[0], image.size[1]
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ W, H = image.size[0], image.size[1]
- en: ❷ m, n = size
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ m, n = size
- en: ❸ w, h = int(W/n), int(H/m)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ w, h = int(W/n), int(H/m)
- en: '# image list'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '# 图像列表'
- en: imgs = []
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: imgs = []
- en: '# generate a list of images'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '# 生成图像列表'
- en: 'for j in range(m):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(m):'
- en: 'for i in range(n):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(n):'
- en: '# append cropped image'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加裁剪后的图像'
- en: ❹ imgs.append(image.crop((i*w, j*h, (i+1)*w, (j+1)*h)))
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ imgs.append(image.crop((i*w, j*h, (i+1)*w, (j+1)*h)))
- en: return imgs
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: return imgs
- en: First you gather the dimensions of the target image ❶ and the grid size ❷. Then
    you calculate the dimensions of each tile in the target image using basic division
    ❸. Next you need to iterate through the grid dimensions and cut out and store
    each tile as a separate image. Calling `image.crop()` ❹ crops out a portion of
    the image using the upper-left and lower-right image coordinates as arguments
    (as discussed in [“Splitting the Target Image”](nsp-venkitachalam503045-0020.xhtml#bh0901)
    on [page 115](nsp-venkitachalam503045-0020.xhtml#p115)). You end up with a list
    of images—first, all the images in the first row of the grid, from left to right;
    then all the images in the second row of the grid; and so on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你获取目标图像的尺寸 ❶ 和网格大小 ❷。然后，你使用基本的除法来计算目标图像中每个瓦片的尺寸 ❸。接下来，你需要遍历网格尺寸，切割并将每个瓦片存储为独立的图像。调用
    `image.crop()` ❹ 使用图像的左上角和右下角坐标作为参数来裁剪图像（如[“将目标图像分割成网格”](nsp-venkitachalam503045-0020.xhtml#bh0901)中所讨论的，位于[第
    115 页](nsp-venkitachalam503045-0020.xhtml#p115)）。最终你会得到一个图像列表——首先是网格中第一行的所有图像，从左到右；接着是第二行的所有图像，依此类推。
- en: '[Finding the Best Match for a Tile](nsp-venkitachalam503045-0008.xhtml#rbh0907)'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[查找瓦片的最佳匹配](nsp-venkitachalam503045-0008.xhtml#rbh0907)'
- en: 'Now let’s find the best match for a tile from the folder of input images. We’ll
    look at two ways of doing this: using a linear search and using a k-d tree. For
    the linear search method, you create a utility function, `getBestMatchIndex()`,
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来寻找来自输入图像文件夹中最匹配的一个瓦片。我们将介绍两种方法：使用线性搜索和使用k-d树。对于线性搜索方法，你需要创建一个实用函数`getBestMatchIndex()`，如下所示：
- en: 'def getBestMatchIndex(input_avg, avgs):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getBestMatchIndex(input_avg, avgs):'
- en: '"""'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: return index of the best image match based on average RGB value distance
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 返回基于平均RGB值距离的最佳图像匹配索引
- en: '"""'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# input image average'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '# 输入图像的平均值'
- en: avg = input_avg
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: avg = input_avg
- en: '# get the closest RGB value to input, based on RGB distance'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '# 基于RGB距离，获取与输入最接近的RGB值'
- en: index = 0
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: index = 0
- en: ❶ min_index = 0
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ min_index = 0
- en: ❷ min_dist = float("inf")
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ min_dist = float("inf")
- en: '❸ for val in avgs:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于avgs中的每个val：
- en: ❹ dist = ((val[0] - avg[0])*(val[0] - avg[0]) +
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ dist = ((val[0] - avg[0])*(val[0] - avg[0]) + '
- en: (val[1] - avg[1])*(val[1] - avg[1]) +
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '(val[1] - avg[1])*(val[1] - avg[1]) + '
- en: (val[2] - avg[2])*(val[2] - avg[2]))
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: (val[2] - avg[2])*(val[2] - avg[2]))
- en: '❺ if dist < min_dist:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果dist小于min_dist：
- en: min_dist = dist
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: min_dist = dist
- en: min_index = index
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: min_index = index
- en: index += 1
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: index += 1
- en: return min_index
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 返回min_index
- en: You’re trying to search `avgs`, a list of the average RGB values of the input
    images, to find the one closest to `input_avg`, the average RGB value of one of
    the tiles in the target image. To start, you initialize the closest match index
    to 0 ❶ and the minimum distance to infinity ❷. Then you loop through the values
    in the list of averages ❸ and start computing distances ❹ using the standard formula
    shown in [“Matching Images”](nsp-venkitachalam503045-0020.xhtml#bh0903) on [page 116](nsp-venkitachalam503045-0020.xhtml#p116).
    (You skip taking the square root to reduce computation time.) If the computed
    distance is less than the stored minimum distance `min_dist`, it’s replaced with
    the new minimum distance ❺. This test will always pass the first time, since any
    distance will be less than infinity. At the end of the iteration, `min_index`
    is the index of the average RGB value from the `avgs` list that is closest to
    `input_avg`. Now you can use this index to select the matching image from the
    list of input images.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在尝试搜索`avgs`，一个包含输入图像平均RGB值的列表，以找到与`input_avg`（目标图像中某瓦片的平均RGB值）最接近的那个。首先，你初始化最接近的匹配索引为0
    ❶，并将最小距离初始化为无穷大 ❷。然后你遍历平均值列表中的每个值 ❸，并开始使用标准公式计算距离 ❹，公式如[“匹配图像”](nsp-venkitachalam503045-0020.xhtml#bh0903)第116页所示。(为了减少计算时间，你跳过了开方步骤。)如果计算得到的距离小于已存储的最小距离`min_dist`，则用新的最小距离
    ❺ 来替代。由于任何距离都小于无穷大，因此第一次测试总是通过的。迭代结束时，`min_index`是`avgs`列表中与`input_avg`最接近的平均RGB值的索引。现在，你可以使用这个索引来从输入图像列表中选择匹配的图像。
- en: 'Now let’s find the best matches using a k-d tree instead of a linear search.
    Here’s the function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用k-d树来寻找最佳匹配，而不是线性搜索。以下是函数：
- en: 'def getBestMatchIndicesKDT(qavgs, kdtree):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: def getBestMatchIndicesKDT(qavgs, kdtree)
- en: '"""'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: return indices of best Image matches based on RGB value distance
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 返回基于RGB值距离的最佳图像匹配的索引
- en: uses a k-d tree
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用k-d树
- en: '"""'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# e.g., [array([2.]), array([9], dtype=int64)]'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '# 例如，[array([2.]), array([9], dtype=int64)]'
- en: ❶ res = list(kdtree.query(qavgs, k=1))
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ res = list(kdtree.query(qavgs, k=1))
- en: ❷ min_indices = res[1]
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ min_indices = res[1]
- en: return min_indices
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 返回min_indices
- en: 'The `getBestMatchIndicesKDT()` function takes two arguments: `qavgs` is the
    list of average RGB values for each tile in the target image, and `kdtree` is
    the `scipy KDTree` object created using a list of average RGB values from the
    input images. (We’ll be creating the `KDTree` object in [“Creating the Photomosaic”](nsp-venkitachalam503045-0020.xhtml#bh0909)
    on [page 124](nsp-venkitachalam503045-0020.xhtml#p124).) You use the `KDTree`
    object’s `query()` method to get the points in the tree that are closest to the
    ones in `qavgs` ❶. Here, the `k` parameter is the number of nearest neighbors
    to the queried point you want to return. You just need the closest match, so you
    pass in `k=1`. The return value from the `query()` method is a tuple consisting
    of two `numpy` arrays with the distances and indices of the matches. You need
    the indices, so you pick the second value from the result ❷.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBestMatchIndicesKDT()`函数有两个参数：`qavgs`是目标图像中每个瓦片的平均RGB值列表，`kdtree`是使用输入图像的平均RGB值列表创建的`scipy
    KDTree`对象。（我们将在[“创建拼图”](nsp-venkitachalam503045-0020.xhtml#bh0909)一节的[第124页](nsp-venkitachalam503045-0020.xhtml#p124)中创建`KDTree`对象。）你将使用`KDTree`对象的`query()`方法来获取与`qavgs`中点最接近的树中点❶。在这里，`k`参数是你想要返回的与查询点最接近的邻居数量。你只需要最接近的匹配项，因此传入`k=1`。`query()`方法的返回值是一个包含两个`numpy`数组的元组，分别表示匹配项的距离和索引。你需要的是索引，所以从结果中选择第二个值❷。'
- en: Notice that the `query()` method ❶ allows you to pass in a list of query points
    instead of just one. This actually runs faster than querying results one by one,
    and it means you’ll have to call the `getBestMatchIndicesKDT()` function only
    once, whereas you’ll have to call the linear search `getBestMatch()` function
    many times, once for each tile in the photomosaic.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`query()`方法❶允许你传入一个查询点列表，而不仅仅是一个。这实际上比逐个查询结果要快，这意味着你只需要调用一次`getBestMatchIndicesKDT()`函数，而在使用线性搜索的`getBestMatch()`函数时，你必须多次调用，每次处理拼图中的一个瓦片。
- en: The complete program will include an option to choose which of the previous
    two functions to use, the linear search version or the k-d tree version. It will
    also have a timer to test which search method is faster.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的程序将包括一个选项，允许你选择使用之前的两个函数中的哪个，线性搜索版本或k-d树版本。它还将具有一个计时器，用于测试哪种搜索方法更快。
- en: '[Creating an Image Grid](nsp-venkitachalam503045-0008.xhtml#rbh0908)'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建图像网格](nsp-venkitachalam503045-0008.xhtml#rbh0908)'
- en: You need one more utility function before moving on to photomosaic creation.
    The `createImageGrid()` function will create a grid of images of size *M*×*N*.
    This image grid is the final photomosaic image, created from the list of selected
    input images.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行拼图创建之前，你需要一个额外的工具函数。`createImageGrid()`函数将创建一个大小为 *M*×*N* 的图像网格。这个图像网格就是最终的拼图图像，它是由选定的输入图像列表创建而成的。
- en: 'def createImageGrid(images, dims):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createImageGrid(images, dims):'
- en: '"""'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: given a list of images and a grid size (m, n), create a grid of images
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个图像列表和一个网格大小(m, n)，创建一个图像网格
- en: '"""'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ❶ m, n = dims
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ m, n = dims
- en: '# sanity check'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '# 完整性检查'
- en: assert m*n == len(images)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: assert m*n == len(images)
- en: '# get the maximum height and width of the images'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取图像的最大高度和宽度'
- en: '# don''t assume they''re all equal'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '# 不要假设它们都是相等的'
- en: ❷ width = max([img.size[0] for img in images])
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ width = max([img.size[0] for img in images])
- en: height = max([img.size[1] for img in images])
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: height = max([img.size[1] for img in images])
- en: '# create the target image'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建目标图像'
- en: ❸ grid_img = Image.new('RGB', (n*width, m*height))
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ grid_img = Image.new('RGB', (n*width, m*height))
- en: '# paste the tile images into the image grid'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将瓦片图像粘贴到图像网格中'
- en: 'for index in range(len(images)):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'for index in range(len(images)):'
- en: ❹ row = int(index/n)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ row = int(index/n)
- en: ❺ col = index - n*row
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ col = index - n*row
- en: ❻ grid_img.paste(images[index], (col*width, row*height))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ grid_img.paste(images[index], (col*width, row*height))
- en: return grid_img
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: return grid_img
- en: 'The function takes two parameters: a list of images (the input images you chose
    based on the closest RGB match to the individual tiles of the target image) and
    a tuple with the photomosaic’s dimensions (the number of rows and columns you
    want it to have). You gather the dimensions of the grid ❶ and then use `assert`
    to see whether the number of images supplied to `createImageGrid()` matches the
    grid size. (The `assert` method checks assumptions in your code, especially during
    development and testing.) Then you compute the maximum width and height of the
    selected images ❷, since they may not all be the same size. You’ll use these maximum
    dimensions to set the standard tile size for the photomosaic. If an input image
    won’t completely fill a tile, the spaces between the tiles will show as solid
    black by default.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数有两个参数：一个图像列表（即你根据与目标图像各个瓦片最接近的RGB值选择的输入图像），和一个包含照片马赛克尺寸的元组（你希望它有的行数和列数）。你获取网格的尺寸
    ❶，然后使用`assert`来检查传递给`createImageGrid()`的图像数量是否与网格大小匹配。（`assert`方法用于检查代码中的假设，特别是在开发和测试期间。）然后，你计算所选图像的最大宽度和高度
    ❷，因为它们可能大小不一。你将使用这些最大尺寸来设置照片马赛克的标准瓦片尺寸。如果输入图像无法完全填充一个瓦片，则瓦片之间的空隙默认会显示为纯黑色。
- en: Next, you create an empty `Image` sized to fit all images in the grid ❸; you’ll
    paste the tile images into this. Then you fill the image grid by looping through
    the selected images and pasting them into the appropriate spot on the grid using
    the `Image.paste()` method ❻. The first argument to `Image.paste()` is the `Image`
    object to be pasted, and the second is the top-left coordinate. Now you need to
    figure out in which row and column to paste an input image into the image grid.
    To do so, you express the image index in terms of rows and columns. The index
    of a tile in the image grid is given by *N* × *row* + *col*, where *N* is the
    number of cells along the width and (*row*, *col*) is the coordinate in the grid;
    at ❹, you determine the row from the previous formula, and at ❺, the column.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个空的`Image`，其大小适合所有图像在网格中的位置 ❸；你将把拼图图像粘贴到这里。然后，通过循环遍历选定的图像，并使用`Image.paste()`方法将它们粘贴到网格的适当位置，填充图像网格
    ❻。`Image.paste()`的第一个参数是要粘贴的`Image`对象，第二个是左上角坐标。现在你需要弄清楚将输入图像粘贴到图像网格的哪一行和哪一列。为此，你需要将图像的索引表示为行和列。图像网格中拼图的索引由
    *N* × *row* + *col* 给出，其中 *N* 是网格宽度上的单元格数量，(*row*, *col*) 是网格中的坐标；在❹，你从之前的公式中确定行数，而在❺时确定列数。
- en: '[Creating the Photomosaic](nsp-venkitachalam503045-0008.xhtml#rbh0909)'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建照片马赛克](nsp-venkitachalam503045-0008.xhtml#rbh0909)'
- en: 'Now that you have all the required utilities, let’s write the main function
    that creates the photomosaic. Here’s the start of the function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经具备了所有必要的工具，让我们编写创建照片马赛克的主函数。下面是函数的开始部分：
- en: def createPhotomosaic(target_image, input_images, grid_size,
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: def createPhotomosaic(target_image, input_images, grid_size,
- en: 'reuse_images, use_kdt):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'reuse_images, use_kdt):'
- en: '"""'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: creates photomosaic given target and input images
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 给定目标图像和输入图像，创建照片马赛克
- en: '"""'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: print('splitting input image...')
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在拆分输入图像...')
- en: '# split target image'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '# 拆分目标图像'
- en: ❶ target_images = splitImage(target_image, grid_size)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ target_images = splitImage(target_image, grid_size)
- en: print('finding image matches...')
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在寻找图像匹配...')
- en: '# for each target image, pick one from input'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '# 对每个目标图像，从输入图像中挑选一张'
- en: output_images = []
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: output_images = []
- en: '# for user feedback'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '# 用于用户反馈'
- en: count = 0
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: count = 0
- en: ❷ batch_size = int(len(target_images)/10)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ batch_size = int(len(target_images)/10)
- en: '# calculate input image averages'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算输入图像的平均值'
- en: avgs = []
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: avgs = []
- en: '❸ for img in input_images:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于输入图像中的每一张图片：
- en: avgs.append(getAverageRGB(img))
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: avgs.append(getAverageRGB(img))
- en: '# compute target averages'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算目标图像的平均值'
- en: avgs_target = []
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: avgs_target = []
- en: '❹ for img in target_images:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于目标图像中的每一张图片：
- en: '# target subimage average'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '# 目标子图像的平均值'
- en: avgs_target.append(getAverageRGB(img))
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: avgs_target.append(getAverageRGB(img))
- en: The `createPhotomosaic()` function takes as input the target image, the list
    of input images, the size of the generated photomosaic (number of rows and columns),
    and flags indicating whether an image can be reused and whether to use a k-d tree
    to search for image matches. The function begins by calling `splitImage()` ❶ to
    split the target into a grid of smaller image tiles. Once the image is split,
    you’re ready to start finding matches for each tile from the images in the input
    folder. Because this process can be lengthy, however, it’s a good idea to provide
    feedback to users to let them know that the program is still working. To help
    with this feedback, you set `batch_size` to one-tenth the total number of tile
    images ❷. The choice of one-tenth is arbitrary and simply a way for the program
    to say “I’m still alive.” Each time the program processes a tenth of the images,
    it will print a message indicating that it’s still running.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`createPhotomosaic()`函数的输入包括目标图像、输入图像列表、生成的拼图大小（行数和列数），以及指示是否可以重用图像和是否使用k-d树来搜索图像匹配的标志。该函数首先调用`splitImage()`❶将目标图像分割成小的图像块网格。一旦图像被分割，你就可以开始从输入文件夹中的图像中为每个图像块寻找匹配。然而，由于这个过程可能会很耗时，因此最好给用户一些反馈，让他们知道程序仍在运行。为了提供这种反馈，你将`batch_size`设置为总图像块数的十分之一❷。这个十分之一的选择是任意的，纯粹是让程序能够说“我还在运行”。每次程序处理十分之一的图像时，它都会打印一条消息，表示它还在运行。'
- en: To find image matches, you need the average RGB values. You iterate over the
    input images ❸ and use your `getAverageRGB()` function to compute the average
    RGB value for each one, storing the results in the list `avgs`. Then you do the
    same for each tile in the target image ❹, storing the average RGB values into
    the list `avgs_target`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到图像匹配，你需要计算平均RGB值。你遍历输入图像❸，并使用`getAverageRGB()`函数计算每张图像的平均RGB值，将结果存储在`avgs`列表中。然后，你对目标图像中的每个图像块做同样的处理❹，将平均RGB值存储到`avgs_target`列表中。
- en: 'The function continues with an `if...else` statement to find RGB matches using
    either a k-d tree or a linear search. Let’s look at the `if` branch first, which
    runs if the `use_kdt` flag was set to `True`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数继续执行一个`if...else`语句，用来通过k-d树或线性搜索找到RGB匹配。我们首先来看`if`分支，它在`use_kdt`标志被设置为`True`时执行：
- en: '# use k-d tree for average match?'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用k-d树进行平均匹配？'
- en: 'if use_kdt:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'if use_kdt:'
- en: '# create k-d tree'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建k-d树'
- en: ❶ kdtree = KDTree(avgs)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ kdtree = KDTree(avgs)
- en: '# query k-d tree'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查询k-d树'
- en: ❷ match_indices = getBestMatchIndicesKDT(avgs_target, kdtree)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ match_indices = getBestMatchIndicesKDT(avgs_target, kdtree)
- en: '# process matches'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '# 处理匹配'
- en: '❸ for match_index in match_indices:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ for match_index in match_indices:'
- en: ❹ output_images.append(input_images[match_index])
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ output_images.append(input_images[match_index])
- en: You create a `KDTree` object using the list of average RGB values from the input
    images ❶ and retrieve the indices of the best matches by passing in `avgs_target`
    and the `KDTree` object to your `getBestMatchIndicesKDT()` helper function ❷.
    Then you iterate through all the matching indices ❸, find the corresponding input
    images, and append them to the list `output_images` ❹.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过使用输入图像列表中的平均RGB值❶来创建一个`KDTree`对象，并通过将`avgs_target`和`KDTree`对象传递给`getBestMatchIndicesKDT()`辅助函数❷来获取最佳匹配的索引。然后，你遍历所有匹配的索引❸，找到对应的输入图像，并将它们附加到列表`output_images`❹中。
- en: 'Next, let’s look at the `else` branch, which performs a linear search for matches:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`else`分支，它执行线性搜索来查找匹配：
- en: 'else:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '# use linear search'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用线性搜索'
- en: '❶ for avg in avgs_target:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for avg in avgs_target:'
- en: '# find match index'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '# 找到匹配索引'
- en: ❷ match_index = getBestMatchIndex(avg, avgs)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ match_index = getBestMatchIndex(avg, avgs)
- en: ❸ output_images.append(input_images[match_index])
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ output_images.append(input_images[match_index])
- en: '# user feedback'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '# 用户反馈'
- en: '❹ if count > 0 and batch_size > 10 and count % batch_size == 0:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ if count > 0 and batch_size > 10 and count % batch_size == 0:'
- en: print('processed %d of %d...' %(count, len(target_images)))
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: print('已处理 %d 个，共 %d 个...' % (count, len(target_images)))
- en: count += 1
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: count += 1
- en: '# remove selected image from input if flag set'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果设置了标志，则从输入中移除选定的图像'
- en: '❺ if not reuse_images:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '❺ if not reuse_images:'
- en: input_images.remove(match)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: input_images.remove(match)
- en: For the linear search, you start iterating through the average RGB values of
    the target image tiles ❶. For each tile, you search for the closest match in the
    list of averages for the input images using `getBestMatchIndex()` ❷. The result
    is returned as an index, which you use to retrieve the `Image` object and store
    it in the `output_images` list ❸. For every `batch_size` number of images processed
    ❹, you print a message to the user. If the `reuse_images` flag is set to `False`
    ❺, you remove the selected input image from the list so that it won’t be reused
    in another tile. (This works best when you have a wide range of input images to
    choose from.)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于线性搜索，你开始通过目标图像瓦片的平均RGB值进行迭代 ❶。对于每个瓦片，你使用`getBestMatchIndex()` ❷在输入图像的平均值列表中搜索最接近的匹配。结果作为索引返回，接着你用这个索引来获取`Image`对象，并将其存储在`output_images`列表中
    ❸。每处理`batch_size`数量的图像 ❹，你都会向用户打印一条消息。如果`reuse_images`标志设置为`False` ❺，你会将选中的输入图像从列表中移除，以防止它在其他瓦片中被重复使用。（当输入图像种类多样时，这种做法效果最好。）
- en: 'All that remains in the `createPhotomosaic()` function is to arrange the input
    images into the final photomosaic:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createPhotomosaic()`函数中，剩下的就是将输入图像排列成最终的照片拼贴：
- en: print('creating mosaic...')
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在创建拼贴图像...')
- en: '# draw mosaic to image'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将拼贴绘制到图像上'
- en: ❶ mosaic_image = createImageGrid(output_images, grid_size)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ mosaic_image = createImageGrid(output_images, grid_size)
- en: '# return mosaic'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回拼贴图像'
- en: return mosaic_image
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 返回mosaic_image
- en: You use the `createImageGrid()` function to build the photomosaic ❶. Then you
    return the resulting image as `mosaic_image`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`createImageGrid()`函数来构建照片拼贴 ❶。然后，你将结果图像作为`mosaic_image`返回。
- en: '[Writing the main() Function](nsp-venkitachalam503045-0008.xhtml#rbh0910)'
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[编写main()函数](nsp-venkitachalam503045-0008.xhtml#rbh0910)'
- en: The `main()` function of the program takes in and parses command line arguments,
    loads all the images, and does some additional setup. Then it calls the `createPhotomosaic()`
    function and saves the resulting photomosaic. As the photomosaic is built, Python
    times how long the process takes, allowing you to compare the performance of the
    k-d tree with that of the linear search.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的`main()`函数接收并解析命令行参数，加载所有图像，并做一些额外的设置。然后它调用`createPhotomosaic()`函数，并保存生成的照片拼贴。在拼贴构建的过程中，Python会记录处理时间，方便你对比k-d树和线性搜索的性能。
- en: Adding the Command Line Options
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加命令行选项
- en: 'The `main()` function supports these command line options:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数支持以下命令行选项：'
- en: '# parse arguments'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数'
- en: parser = argparse.ArgumentParser(description='Creates a photomosaic from
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description='从
- en: input images')
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 输入图像')
- en: '# add arguments'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: parser.add_argument('--target-image', dest='target_image', required=True)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--target-image', dest='target_image', required=True)
- en: parser.add_argument('--input-folder', dest='input_folder', required=True)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--input-folder', dest='input_folder', required=True)
- en: parser.add_argument('--grid-size', nargs=2, dest='grid_size',
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--grid-size', nargs=2, dest='grid_size',
- en: required=True)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: required=True)
- en: parser.add_argument('--output-file', dest='outfile', required=False)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--output-file', dest='outfile', required=False)
- en: parser.add_argument('--kdt', action='store_true', required=False)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--kdt', action='store_true', required=False)
- en: 'This code contains three required command line parameters: the name of the
    target image, the name of the input folder of images, and the grid size. The fourth
    parameter is for the optional filename for the output. If the filename is omitted,
    the photomosaic will be written to a file named *mosaic.png*. The fifth argument
    is a Boolean flag that enables the k-d tree search instead of linear search for
    matching average RGB values.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含三个必需的命令行参数：目标图像的名称、输入图像文件夹的名称以及网格大小。第四个参数是可选的输出文件名。如果没有提供文件名，照片拼贴将保存为名为*mosaic.png*的文件。第五个参数是一个布尔标志，用于启用k-d树搜索，而不是线性搜索来匹配平均RGB值。
- en: Controlling the Size of the Photomosaic
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制照片拼贴的大小
- en: 'Once all the images are loaded, one issue to address in the `main()` function
    is the size (in pixels) of the resulting photomosaic. If you were to blindly paste
    the input images together based on matching tiles in the target, you could end
    up with a huge photomosaic that is much bigger than the target. To avoid this,
    resize the input images to match the size of each tile in the grid. (This has
    the added benefit of speeding up the average RGB computation since you’ll be using
    smaller images.) Here’s the section of the `main()` function that handles this
    task:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: print('resizing images...')
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '# for given grid size, compute the maximum width and height of tiles'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: ❶ dims = (int(target_image.size[0]/grid_size[1]),
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: int(target_image.size[1]/grid_size[0]))
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'print("max tile dims: %s" % (dims,))'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '# resize'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'for img in input_images:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: ❷ img.thumbnail(dims)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: You compute the target dimensions based on the specified number of rows and
    columns in the grid ❶; then you use the PIL `Image.``thumbnail()` method to resize
    the input images to fit those dimensions ❷.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Timing the Performance
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When the program is run, you’ll want to know how long it takes to execute.
    Use the Python `timeit` module for this purpose. The approach for finding execution
    time is outlined here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: import timeit
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: start timing
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ❶ start = timeit.default_timer()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: run some code here...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: --`snip`--
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: stop timing
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ❷ stop = timeit.default_timer()
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''Execution time: %f seconds'' % (stop - start, ))'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: You record the start time using the `timeit` module’s default timer ❶. Then,
    after running some code, you record the stop time ❷. Computing the difference
    gives you the execution time measured in seconds.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[Running the Photomosaic Generator](nsp-venkitachalam503045-0008.xhtml#rah0904)'
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s first run the program using the default linear search approach. The photomosaic
    will consist of a grid of 128×128 images:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: $ `python photomosaic.py --target-image test-data/cherai.jpg --input-folder`
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '`  test-data/set6/ --grid-size 128 128`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: reading input folder...
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: starting photomosaic creation...
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: resizing images...
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'max tile dims: (23, 15)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: splitting input image...
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: finding image matches...
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: processed 1638 of 16384...
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: processed 3276 of 16384...
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: processed 4914 of 16384...
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: processed 6552 of 16384...
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: processed 8190 of 16384...
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: processed 9828 of 16384...
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: processed 11466 of 16384...
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: processed 13104 of 16384...
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: processed 14742 of 16384...
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: processed 16380 of 16384...
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: creating mosaic...
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: saved output to mosaic.png
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: done.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time:    setup: 0.402047 seconds'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '❶ Execution time: creation: 2.123931 seconds'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time:    total: 2.525978 seconds'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-4(a)](nsp-venkitachalam503045-0020.xhtml#fig7-4) shows the target
    image, and [Figure 7-4(b)](nsp-venkitachalam503045-0020.xhtml#fig7-4) shows the
    resulting photomosaic. You can see a close-up of the photomosaic in [Figure 7-4(c)](nsp-venkitachalam503045-0020.xhtml#fig7-4).
    As you can see in the output, it takes about 2.1 seconds ❶ to find the best match
    for each of the 16,384 tiles in the photomosaic using a linear search. That’s
    not bad, but we can do better.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f07004.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: A sample run of the photomosaic generator'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the same program with the `--kdt` option, which enables the use of
    a k-d tree to search for image matches. Here are the results:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: $ `python photomosaic.py --target-image test-data/cherai.jpg --input-folder`
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '`  test-data/set6/ --grid-size 128 128 --kdt`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: reading input folder...
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: starting photomosaic creation...
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: resizing images...
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'max tile dims: (23, 15)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: splitting input image...
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: finding image matches...
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: creating mosaic...
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: saved output to mosaic.png
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: done.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time:    setup: 0.410334 seconds'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '❶ Execution time: creation: 1.089237 seconds'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution time:    total: 1.499571 seconds'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The photomosaic creation time has dropped from about 2.1 seconds to less than
    1.1 seconds ❶ with a k-d tree. That’s almost twice the speed!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0905)'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you learned how to create a photomosaic, given a target image
    and a collection of input images. When viewed from a distance, the photomosaic
    looks like the original image, but up close, you can see the individual images
    that make up the mosaic. You also learned about an interesting data structure,
    the k-d tree, which significantly sped up the process of finding the closest match
    for each tile in the mosaic.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0906)'
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some ways to further explore photomosaics:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Write a program that creates a blocky version of any image, similar to [Figure
    7-1](nsp-venkitachalam503045-0020.xhtml#fig7-1).
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '2\. With the code in this chapter, you created the photomosaic by pasting the
    matched images without any gaps in between. A more artistic presentation might
    include a uniform gap of a few pixels around each tile image. How would you create
    the gap? (Hint: factor in the gaps when computing the final image dimensions and
    when pasting the images in `createImageGrid()`.)'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0907)'
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the complete code for the project:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: photomosaic.py
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Creates a photomosaic given a target image and a folder of input images.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: import os, random, argparse
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: from PIL import Image
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: from scipy.spatial import KDTree
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: import timeit
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'def getAverageRGBOld(image):'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: given PIL Image, return average value of color as (r, g, b)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '# no. of pixels in image'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: npixels = image.size[0]*image.size[1]
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '# get colors as [(cnt1, (r1, g1, b1)), ...]'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: cols = image.getcolors(npixels)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '# get [(c1*r1, c1*g1, c1*g2), ...]'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: sumRGB = [(x[0]*x[1][0], x[0]*x[1][1], x[0]*x[1][2]) for x in cols]
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '# calculate (sum(ci*ri)/np, sum(ci*gi)/np, sum(ci*bi)/np)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '# the zip gives us [(c1*r1, c2*r2, ...), (c1*g1, c1*g2, ...), ...]'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: avg = tuple([int(sum(x)/npixels) for x in zip(*sumRGB)])
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: return avg
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'def getAverageRGB(image):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: given PIL Image, return average value of color as (r, g, b)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '# get image as numpy array'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: im = np.array(image)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '# get shape'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: w,h,d = im.shape
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '# get average'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: return tuple(np.average(im.reshape(w*h, d), axis=0))
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'def splitImage(image, size):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: given Image and dims (rows, cols) returns an m*n list of Images
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: W, H = image.size[0], image.size[1]
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: m, n = size
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: w, h = int(W/n), int(H/m)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '# image list'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: imgs = []
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '# generate list of images'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(m):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '# append cropped image'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: imgs.append(image.crop((i*w, j*h, (i+1)*w, (j+1)*h)))
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: return imgs
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'def getImages(imageDir):'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: given a directory of images, return a list of Images
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: files = os.listdir(imageDir)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: images = []
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'for file in files:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: filePath = os.path.abspath(os.path.join(imageDir, file))
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '# explicit load so we don''t run into resource crunch'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: fp = open(filePath, "rb")
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: im = Image.open(fp)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: images.append(im)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '# force loading image data from file'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: im.load()
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '# close the file'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: fp.close()
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '# skip'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Invalid image: %s" % (filePath,))'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: return images
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'def getBestMatchIndex(input_avg, avgs):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: return index of best Image match based on RGB value distance
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '# input image average'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: avg = input_avg
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '# get the closest RGB value to input, based on x/y/z distance'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: index = 0
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: min_index = 0
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: min_dist = float("inf")
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'for val in avgs:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: dist = ((val[0] - avg[0])*(val[0] - avg[0]) +
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: (val[1] - avg[1])*(val[1] - avg[1]) +
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: (val[2] - avg[2])*(val[2] - avg[2]))
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'if dist < min_dist:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: min_dist = dist
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: min_index = index
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: index += 1
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: return min_index
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'def getBestMatchIndicesKDT(qavgs, kdtree):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: return indices of best Image matches based on RGB value distance
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: using a k-d tree
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '# e.g., [array([2.]), array([9], dtype=int64)]'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: res = list(kdtree.query(qavgs, k=1))
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: min_indices = res[1]
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: return min_indices
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'def createImageGrid(images, dims):'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: given a list of images and a grid size (m, n), create
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: a grid of images
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: m, n = dims
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '# sanity check'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: assert m*n == len(images)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '# get max height and width of images'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '# i.e., not assuming they are all equal'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: width = max([img.size[0] for img in images])
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: height = max([img.size[1] for img in images])
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '# create output image'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: grid_img = Image.new('RGB', (n*width, m*height))
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '# paste images'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'for index in range(len(images)):'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: row = int(index/n)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: col = index - n*row
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: grid_img.paste(images[index], (col*width, row*height))
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: return grid_img
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: def createPhotomosaic(target_image, input_images, grid_size,
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'reuse_images, use_kdt):'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: creates photomosaic given target and input images
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: print('splitting input image...')
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '# split target image'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: target_images = splitImage(target_image, grid_size)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: print('finding image matches...')
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '# for each target image, pick one from input'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: output_images = []
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '# for user feedback'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: batch_size = int(len(target_images)/10)
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '# calculate input image averages'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: avgs = []
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'for img in input_images:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: avgs.append(getAverageRGB(img))
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '# compute target averages'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: avgs_target = []
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'for img in target_images:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '# target subimage average'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: avgs_target.append(getAverageRGB(img))
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '# use k-d tree for average match?'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'if use_kdt:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '# create k-d tree'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: kdtree = KDTree(avgs)
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '# query k-d tree'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: match_indices = getBestMatchIndicesKDT(avgs_target, kdtree)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '# process matches'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'for match_index in match_indices:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: output_images.append(input_images[match_index])
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '# use linear search'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'for avg in avgs_target:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '# find match index'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: match_index = getBestMatchIndex(avg, avgs)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: output_images.append(input_images[match_index])
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '# user feedback'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'if count > 0 and batch_size > 10 and count % batch_size == 0:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: print('processed {} of {}...'.format(count,
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: len(target_images)))
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '# remove selected image from input if flag set'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'if not reuse_images:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: input_images.remove(match)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: print('creating mosaic...')
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '# draw mosaic to image'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: mosaic_image = createImageGrid(output_images, grid_size)
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '# return mosaic'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: return mosaic_image
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: gather our code in a main() function
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '# command line args are in sys.argv[1], sys.argv[2]...'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '# sys.argv[0] is the script name itself and can be ignored'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '# parse arguments'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: parser = argparse.ArgumentParser(description='Creates a photomosaic
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: from input images')
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '# add arguments'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--target-image', dest='target_image', required=True)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--input-folder', dest='input_folder', required=True)
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--grid-size', nargs=2, dest='grid_size',
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: required=True)
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--output-file', dest='outfile', required=False)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--kdt', action='store_true', required=False)
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: args = parser.parse_args()
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '# start timing'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: start = timeit.default_timer()
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '###### INPUTS ######'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '# target image'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: target_image = Image.open(args.target_image)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '# input images'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: print('reading input folder...')
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: input_images = getImages(args.input_folder)
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '# check if any valid input images found'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: 'if input_images == []:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: print('No input images found in %s. Exiting.' % (args.input_folder, ))
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: exit()
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '# shuffle list - to get a more varied output?'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: random.shuffle(input_images)
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '# size of grid'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: grid_size = (int(args.grid_size[0]), int(args.grid_size[1]))
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '# output'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: output_filename = 'mosaic.png'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.outfile:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: output_filename = args.outfile
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '# reuse any image in input'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: reuse_images = True
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '# resize the input to fit original image size?'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: resize_input = True
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '# use k-d trees for matching'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: use_kdt = False
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.kdt:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: use_kdt = True
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '##### END INPUTS #####'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: print('starting photomosaic creation...')
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '# if images can''t be reused, ensure m*n <= num_of_images'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: 'if not reuse_images:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'if grid_size[0]*grid_size[1] > len(input_images):'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: print('grid size less than number of images')
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: exit()
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '# resizing input'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: 'if resize_input:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: print('resizing images...')
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '# for given grid size, compute max dims w,h of tiles'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: dims = (int(target_image.size[0]/grid_size[1]),
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: int(target_image.size[1]/grid_size[0]))
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'print("max tile dims: %s" % (dims,))'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '# resize'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'for img in input_images:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: img.thumbnail(dims)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '# setup time'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: t1 = timeit.default_timer()
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '# create photomosaic'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: mosaic_image = createPhotomosaic(target_image, input_images, grid_size,
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: reuse_images, use_kdt)
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '# write out mosaic'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: mosaic_image.save(output_filename, 'PNG')
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: print("saved output to %s" % (output_filename,))
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: print('done.')
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '# creation time'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: t2 = timeit.default_timer()
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''Execution time:    setup: %f seconds'' % (t1 - start, ))'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''Execution time: creation: %f seconds'' % (t2 - t1, ))'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: 'print(''Execution time:    total: %f seconds'' % (t2 - start, ))'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: standard boilerplate to call the main() function to begin
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: the program.
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
