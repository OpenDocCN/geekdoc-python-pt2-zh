- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MOVING INTO THE SPACE STATION**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve outfitted the space station with scenery, life support systems,
    and other equipment, it’s time to move in. In this chapter, you’ll see yourself
    in the space station for the first time, and you’ll be able to move around and
    explore the rooms. You might feel a bit stiff from the journey to begin with,
    but you’ll soon be walking all over the base.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll discover how to animate the astronaut and use the keyboard controls to
    move them around. You’ll also add code to enable the astronaut to move between
    rooms. Is there life on Mars? There is now.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARRIVING ON THE SPACE STATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use [Listing 6-6](ch06.xhtml#ch06list6) from [Chapter 6](ch06.xhtml#ch06)
    as a starting point in this chapter, so open *listing6-6.py*. We’ll add code to
    show you in your space suit in the space station. Eventually, you’ll be able to
    move around using the arrow keys.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISABLING THE ROOM NAVIGATION CONTROLS IN THE EXPLORER SECTION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, we’ve been using the arrow keys in the `EXPLORER` section to show different
    rooms on the map. We’re going to start using those keys to move the astronaut
    around the rooms. First, we need to disable the existing controls. Scroll down
    to the `EXPLORER` part of the program and highlight the instructions shown in
    [Listing 7-1](ch07.xhtml#ch07list1). Click **Format** ▸ **Comment Out Region**
    to turn those instructions into comments so the program will ignore them. (You
    can also just delete them if you prefer.) Save your program as *listing7-1.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing7-1.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1: Turning off the keyboard controls in the* EXPLORER *section*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can add code that uses the arrow keys to move the astronaut.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING NEW VARIABLES**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by setting up some variables. The most important of these are your
    starting coordinates where you’ll teleport in. As before, we add variables to
    the `VARIABLES` part of the program, near the start. Add the new lines in [Listing
    7-2](ch07.xhtml#ch07list2). Save your program as *listing7-2.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing7-2.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2: Adding player variables*'
  prefs: []
  type: TYPE_NORMAL
- en: The `VARIABLES` section already includes a value for `current_room`, which is
    the room you’ll start in. (If you changed the value of `current_room` while experimenting
    in [Chapter 6](ch06.xhtml#ch06), make sure you change it back to 31.) We make
    new `player_y` and `player_x` variables ➊ to contain numbers for your starting
    position in the room. Here, we’re setting up two variables in a single line. The
    numbers are put into the variables in the same order they’re listed, so `2` goes
    into `player_y` (the first number goes into the first variable), and `5` goes
    into `player_x`. These variables will change as you move around the rooms on the
    space station and will be used to check where you are and draw you in the correct
    place. Your position is measured using the same tile coordinates as for the scenery
    positions.
  prefs: []
  type: TYPE_NORMAL
- en: We also set up a `game_over` variable ➋ to tell the program whether the game
    has ended. At the start of the program, we set the variable to `False`. It will
    stay `False` until the game ends and then become `True`. The program checks this
    variable to see whether the player is allowed to move. It would be odd if the
    player kept moving after they died!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll set up the images for the player’s walking animation. Animation
    is a trick of the eye. You start with a series of similar pictures with slight
    differences that show small movements. When you switch between them quickly, you
    can fool the eye into thinking the image is moving. In our game, we’ll use a series
    of images of the astronaut walking that show the legs in different positions.
    When we switch between them quickly, the astronaut’s legs will look like they’re
    moving.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: The key to making animation work is to make sure the images are similar enough.
    If the images are too different, the effect doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Each image in an animation is known as a *frame*. [Table 7-1](ch07.xhtml#ch07tab1)
    shows the animation frames we’ll use. We’ll number our frames starting at 0, which
    will be the resting position when the astronaut isn’t walking. When the player
    is walking up the screen, we see their back because they’re walking away from
    us in the room.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** The Animation Frames for the Astronaut'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Frame 0** | **Frame 1** | **Frame 2** | **Frame 3** | **Frame
    4** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `left` | ![image](../images/f0114-01.jpg) | ![image](../images/f0114-02.jpg)
    | ![image](../images/f0114-03.jpg) | ![image](../images/f0114-04.jpg) | ![image](../images/f0114-05.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `right` | ![image](../images/f0114-06.jpg) | ![image](../images/f0114-07.jpg)
    | ![image](../images/f0114-08.jpg) | ![image](../images/f0114-09.jpg) | ![image](../images/f0114-10.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `up` | ![image](../images/f0114-11.jpg) | ![image](../images/f0114-12.jpg)
    | ![image](../images/f0114-13.jpg) | ![image](../images/f0114-14.jpg) | ![image](../images/f0114-15.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `down` | ![image](../images/f0114-16.jpg) | ![image](../images/f0114-17.jpg)
    | ![image](../images/f0114-18.jpg) | ![image](../images/f0114-19.jpg) | ![image](../images/f0114-20.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: The `PLAYER` dictionary ➌ stores the animation frames. The direction names—up,
    down, left, and right—are the dictionary keys. Each dictionary entry is a list
    that has the image of the player standing, plus four animation frames for that
    direction of walking (see [Table 7-1](ch07.xhtml#ch07tab1)). The `PLAYER` dictionary
    will be used together with the direction the player is facing ➍ and the number
    of the animation frame ➎ to display the correct image as the player walks or stands
    still. The `player_image` variable ➏ stores the current image of the astronaut.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Appendix B](appb.xhtml#appb) at the back of the book describes the important
    variables in the *Escape* program, so look there if you can’t remember what a
    particular variable does.'
  prefs: []
  type: TYPE_NORMAL
- en: '**TELEPORTING ONTO THE SPACE STATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Get ready to beam down! With the starting coordinates in place, let’s add the
    code to make you appear in the space station.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-3](ch07.xhtml#ch07list3) shows the lines you need to add to the
    `EXPLORER` part of the program. As before, you only need to add the new lines.
    Don’t change the other lines. Just use them to find your way around the program
    code. The first new line ➊ is indented by eight spaces because it’s inside a function
    and also inside a loop. Save your program as *listing7-3.py*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*listing7-3.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-3: Drawing the player in the room*'
  prefs: []
  type: TYPE_NORMAL
- en: These new instructions draw you in the room. The `y` loop draws the room from
    back to front. The `x` loop draws the scenery in each row from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: After each row is drawn, the program checks whether the player is standing in
    that row ➊. This instruction should be lined up with the `for x in range(room_width)`
    line rather than indented further, because it’s not inside the `x` loop. It will
    run once, after the `x` loop has finished.
  prefs: []
  type: TYPE_NORMAL
- en: If the player *is* in the row the program has just drawn, the next line ➋ puts
    the picture of the player into the variable `image_to_draw`. The image is taken
    from the `PLAYER` dictionary of animation frames, using the player’s direction
    and the animation frame number.
  prefs: []
  type: TYPE_NORMAL
- en: The last new line ➌ draws the player using the `image_to_draw` variable you
    just set up, which contains the picture. It also uses the player’s *x* and *y*
    position variables to work out where to draw the image on the screen. [Chapter
    3](ch03.xhtml#ch03) explains how the position onscreen is calculated (see “[Working
    Out Where to Draw Each Item](ch03.xhtml#lev58)” on [page 56](ch03.xhtml#page_56)).
    The `player_offset_x` and `player_offset_y` variables were set up in [Listing
    7-2](ch07.xhtml#ch07list2) and are used to position the player partway between
    tiles as they walk between them. You’ll learn more about these variables shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Get ready to teleport! Brace yourself! Take a deep breath.
  prefs: []
  type: TYPE_NORMAL
- en: Run your program using pgzrun listing7-3.py. If your teleportation was successful,
    you should be on the space station (see [Figure 7-1](ch07.xhtml#ch07fig1)). If
    not, check the program changes you made in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: One side effect of teleporting is that at first you can’t move. As we add more
    code, you’ll find that the side effect wears off.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig7-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The astronaut arrives!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE MOVEMENT CODE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll add a totally new section called `GAME LOOP`. This is the heart of
    the program. The `game_loop()` function will run several times a second and enable
    you to move. Later in the book, we’ll add more instructions here that enable you
    to do things with the objects you find.
  prefs: []
  type: TYPE_NORMAL
- en: Add this new section between the `MAKE MAP` and `EXPLORER` sections. [Listing
    7-4](ch07.xhtml#ch07list4) shows you what it looks like. Save the program as *listing7-4.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing7-4.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-4: Adding player movement*'
  prefs: []
  type: TYPE_NORMAL
- en: At the very end of the program, you also need to add a new section called `START`,
    which will make the `game_loop()` function run every 0.03 seconds. [Listing 7-5](ch07.xhtml#ch07list5)
    shows you the lines to add. This instruction isn’t indented, because it doesn’t
    belong to a function. Python runs the instructions that *aren’t* inside a function
    in the order they appear in the program, from top to bottom. This instruction
    runs after all the variables, map, scenery, and prop data have been set up and
    the functions have been defined in the instructions above. Save your program as
    *listing7-5.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing7-5.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-5: Setting the* game_loop() *function to run regularly*'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program using pgzrun listing7-5.py. You should be in the room (as shown
    in [Figure 7-1](ch07.xhtml#ch07fig1)) and be able to move using the arrow keys!
    You might notice your legs disappear when you walk up the screen. This is a side
    effect of teleportation that will wear off when we improve the code for drawing
    rooms in [Chapter 8](ch08.xhtml#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the program won’t work properly if you walk out the door, but
    it should stop you from walking through walls or furniture. If you *can* walk
    through objects, double-check the new code you just added. If you still have problems,
    carefully check the line that sets up the `items_player_may_stand_on` list at
    the end of the `OBJECTS` part of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING THE MOVEMENT CODE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to play the game and customize it with your own designs, you don’t
    need to understand how the code in this chapter works. You can simply replace
    the images and the data for maps, scenery, and props. This movement code, and
    the code for moving between rooms, which you’ll add later in this chapter, should
    keep working. However, if you want to understand how the code works and want to
    see how you could add animation to your programs, I’ll break it down now. This
    code is the real engine of the game, so in many ways it’s the most exciting bit!
  prefs: []
  type: TYPE_NORMAL
- en: If you’re getting a sense of déjà vu, it’s because you’ve already seen much
    of this code. In [Chapter 2](ch02.xhtml#ch02), for your spacewalk, you used code
    to change the player’s position using keyboard controls and a function called
    `game_loop()` to control movement. Let’s refresh our memories and see what’s new
    in [Listing 7-4](ch07.xhtml#ch07list4).
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-4](ch07.xhtml#ch07list4), we define a function called `game_loop()`
    ➊ at the start of this new section. The `clock.schedule_interval()` function we
    added at the end of the program (see [Listing 7-5](ch07.xhtml#ch07list5)) makes
    this `game_loop()` function run every 0.03 seconds. Each time the `game_loop()`
    function runs, it checks whether you’ve pressed an arrow key or are walking and,
    if so, updates your position.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of `game_loop()`, we tell Python which variables are global variables
    ➋ (see “[Understanding the Spacewalk Listing](ch01.xhtml#lev30)” on [page 27](ch01.xhtml#page_27)
    for a refresher on why we need to do this). Some of these aren’t used yet, but
    we’ll need them later.
  prefs: []
  type: TYPE_NORMAL
- en: Then we check the `game_over` variable. If it’s set to `True` ➌, the `game_loop()`
    function finishes without running any of its other instructions because the game
    is over. This variable stops the player from moving when the game ends. For now,
    it won’t do anything, because nothing in our program causes the game to end.
  prefs: []
  type: TYPE_NORMAL
- en: The `game_loop()` function checks whether the player is already walking ➍. It
    takes four animation frames to walk one tile across the screen. If the player
    is moving, the `player_frame` variable contains a number between 1 and 4, which
    represents the animation frame being used. If the player is walking, the program
    increases the `player_frame` variable by 1 to move to the next animation frame.
    That means the `draw()` function in the `EXPLORER` section will show the next
    animation frame the next time it runs.
  prefs: []
  type: TYPE_NORMAL
- en: When `player_frame` reaches 5, it means all the animation frames have been shown
    and the animation has ended. In that case, the program resets `player_frame` to
    0 to end the animation. When the animation ends, the program also resets the `player_offset_x`
    and `player_offset_y` variables. I’ll tell you what these do in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see whether the player has pressed a key to start a new walking animation.
    Before we let the player move, we save their current position ➎ by storing the
    *x* position in the variable `old_player_x` and the *y* position in the variable
    `old_player_y`. We will use these variables to move the player back if they try
    to walk somewhere they shouldn’t, such as into a wall pillar.
  prefs: []
  type: TYPE_NORMAL
- en: The program then uses a familiar block of code to change the player’s *x* and
    *y* position variables if an arrow key is pressed ➏. We measure the player’s position
    in tiles, the same units we use for positioning the scenery. This is different
    from when we used pixels as the measurement in [Chapter 1](ch01.xhtml#ch01).
  prefs: []
  type: TYPE_NORMAL
- en: When the player presses the right arrow key, the program adds 1 to the *x* position.
    If the player presses the left arrow key, it subtracts 1\. We use similar code
    to change the *y* position if the player presses the up or down arrow keys.
  prefs: []
  type: TYPE_NORMAL
- en: When the player moves, the global variables `from_player_x` and `from_player_y`
    store the position the player is walking from. These variables will be used later
    to check whether the player has been hit by a hazard while walking. The `player_direction`
    variable is also set to the direction they’re moving, and the `player_frame` is
    set to 1, the first frame in the animation sequence.
  prefs: []
  type: TYPE_NORMAL
- en: As in [Chapter 1](ch01.xhtml#ch01), we use `elif` to combine our checks for
    a keypress. This ensures the player cannot change the *x* and *y* positions at
    the same time to move diagonally. In our 3D room, walking diagonally would enable
    the player to walk through obstacles, squeezing through impossible gaps.
  prefs: []
  type: TYPE_NORMAL
- en: After moving the player, we check whether the new position puts them somewhere
    they’re allowed to be ➐. We do this by using `room_map` to see what item is in
    the position they’re standing at and checking it against the list `items_player_may_stand_on`.
    There is some code I’ve commented out here too, which we’ll need to enable later
    to stop players from walking through hazards.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the keyword `in` to check whether something is in a list. By using
    the keyword `not` with it, we can see whether something is missing from a list.
    The following line means “If the number in the map where the player is standing
    isn’t in the list of items, the player is allowed to stand on . . .”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the player is standing on something that isn’t in the `items_player_may_stand_on`
    list, we reset the player’s *x* and *y* positions to their position before they
    moved.
  prefs: []
  type: TYPE_NORMAL
- en: All of this happens so fast that the player doesn’t notice anything. If they
    try to walk into a wall, it looks like they never went anywhere! This is a simpler
    way of stopping the player from walking through walls than checking whether each
    movement is allowed before making it.
  prefs: []
  type: TYPE_NORMAL
- en: The program also sets the `player_frame` variable to 0 if the player’s position
    must be reset ➑. This turns off the player animation again.
  prefs: []
  type: TYPE_NORMAL
- en: When you press the right arrow key, the astronaut steps one tile to the right.
    It takes four frames to animate this, so the astronaut is displayed at positions
    that are partway across the tile while this animation plays out. The `player_offset_x`
    and `player_offset_y` variables are used to work out where to draw the astronaut.
    These variables are calculated at the end of the `game_loop()` function ➒. The
    `draw()` function (see [Listing 7-3](ch07.xhtml#ch07list3)) multiplies the offset
    values by the size of a tile (30 pixels) because images are drawn in pixels. For
    example, if the offset is 0.25 tiles, the astronaut is drawn roughly 7 pixels
    away from the center of the new tile. The computer will round the number because
    you can’t position something using half a pixel.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the left side of [Figure 7-2](ch07.xhtml#ch07fig2). For the first animation
    frame when the astronaut is walking left, we need to add three-quarters of a tile
    to the player’s new tile position (0.75). For the second animation frame, we add
    half a tile (0.5) to the player’s new tile position before drawing it. For the
    third animation frame, we add a quarter of a tile to the player’s new tile position.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig7-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Understanding how the astronaut is positioned during the animation*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate these offset numbers using the frame number. Here’s the calculation
    for walking left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that this calculation makes sense by working out the numbers on your
    own. For example, here is the calculation when the animation frame is 2:'
  prefs: []
  type: TYPE_NORMAL
- en: 0.25 × 2 = 0.5
  prefs: []
  type: TYPE_NORMAL
- en: 1 − 0.5 = 0.5
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 7-2](ch07.xhtml#ch07fig2), 0.5 is the correct offset for frame 2.
  prefs: []
  type: TYPE_NORMAL
- en: When the player walks right, we need to subtract part of a tile from the player’s
    position, so the offsets are negative. Look at the right side of [Figure 7-2](ch07.xhtml#ch07fig2).
    For frame 1, adding −0.75 puts the astronaut three-quarters of a tile to the *left*
    of their new position.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can work out the *x* offset for walking right using the frame number too.
    Here’s the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**TRAINING MISSION #1**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you check that the formula works? Use it to find the offset values for frames
    1 and 3, and check that they match the offset values in [Figure 7-2](ch07.xhtml#ch07fig2).
  prefs: []
  type: TYPE_NORMAL
- en: The offsets for the *y* direction work the same. When the astronaut is moving
    up, we calculate the *y* offset using the same formula as the left offset. When
    the astronaut is moving down, we calculate the *y* offset using the same formula
    as the right offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, the `game_loop()` function does this:'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not walking, it starts the walking animation when you press a key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are walking, it works out the next animation frame and the positions
    partway across the tile to use when drawing you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’ve reached the end of the animation sequence, it resets it so you can
    move again. The movement is fluid, so if you hold down a key, you’ll cycle through
    animation frames 1 to 4 and won’t see the standing position until you stop walking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MOVING BETWEEN ROOMS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’re on your feet, you’ll want to explore the space station fully.
    Let’s add some code to the `game_loop()` function that lets you walk into the
    next room. Add the new code in [Listing 7-6](ch07.xhtml#ch07list6), which goes
    after we check for keypresses and before we check whether the player is standing
    somewhere they shouldn’t be. Make sure you include the instructions with comment
    symbols (`#`) at the start. We’ll need them later.
  prefs: []
  type: TYPE_NORMAL
- en: The grayed-out lines in [Listing 7-6](ch07.xhtml#ch07list6) show you where to
    add the new code. Save your program as *listing7-6.py*. Run it using pgzrun listing7-6.py
    and then walk around the space station! This is a good time to look around, before
    the doors are fitted and certain areas are locked down.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing7-6.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-6: Enabling the player to move between rooms*'
  prefs: []
  type: TYPE_NORMAL
- en: To see how this code works, let’s use an example room map. [Figure 7-3](ch07.xhtml#ch07fig3)
    shows a room 9 tiles wide and 9 tiles high with exits on each wall. We’ll use
    this image to understand the player’s position when they’ve left the room.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, the positions on the map are numbered starting at 0 in the top
    left. The yellow squares show where the player might be if they walked out of
    the room:'
  prefs: []
  type: TYPE_NORMAL
- en: If the player’s *y* position is −1, they’ve walked out of the top exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player’s *x* position is −1, they’ve walked out of the left exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player’s *y* position is the same as the `room_height` variable, they’ve
    walked out of the bottom. The tile positions are numbered starting at 0, so if
    the player goes into row 9 in a room that has 9 rows, they’ve already left the
    room.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, if the player’s *x* position is the same as the `room_width` variable,
    they’ve walked out of the right exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](../images/fig7-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Working out whether the player has walked through an exit*'
  prefs: []
  type: TYPE_NORMAL
- en: The new code lines check whether the player position means they’ve walked out
    of the room. If the player’s *x* position is the same as `room_width` ➊, they’re
    outside the door on the right, as shown in [Figure 7-3](ch07.xhtml#ch07fig3).
  prefs: []
  type: TYPE_NORMAL
- en: 'When a player leaves the room, we need to change the number of the room they’re
    in, which is stored in the `current_room` variable. When they go through a door
    on the right, the room number increases by 1 ➋. Look at the room map again (flip
    back to [Figure 4-1](ch04.xhtml#ch04fig1) on [page 60](ch04.xhtml#page_60)) to
    see that this makes sense: room numbers increase from left to right. For example,
    if the player is in room 33 and walks through the exit on the right, they end
    up in room 34.'
  prefs: []
  type: TYPE_NORMAL
- en: The program then generates a new `room_map` list ➌ to use in displaying and
    navigating the new room. The player is repositioned at the opposite side of the
    room ➍, so it looks like they’ve walked through the doorway. If the player exits
    to the right of the room, they enter the next room from the left ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Rooms are lots of different sizes, so we also need to change the player’s *y*
    position to put them in the middle of the doorway. Otherwise, the player might
    emerge from a wall! We set the player’s position to be half the height of the
    room ➎, which means they’re right in the middle of the doorway. When they enter
    the room, we reset the player animation, too ➏.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included a couple of features here that we’ll need later, so make sure
    you include the `clock.unschedule(hazard_move)` ➊ and `start_room()` ➐ instructions.
    The `start_room()` function will display the room name when the player enters
    a new room. We’ll talk about those instructions more later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `return` instruction exits the `game_loop()` function ➑. Any further
    instructions in the function won’t run this time around. When the function starts
    again, it will start from the top as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code block ➒ checks whether the player went through the left door.
    To go through the left door, the program does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether the `player_x` variable contains `-1` (see [Figure 7-3](ch07.xhtml#ch07fig3)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtracts 1 from the current room number to go into the room on the left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the player’s *x* position to be just inside the doorway on the right. This
    position is the `room_width` minus 1\. (You can check this in [Figure 7-3](ch07.xhtml#ch07fig3).
    In a room that has a `room_width` of 9, the player’s *x* position should be 8.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the player’s *y* position to the middle using the `room_height`. This is
    the same approach as walking through the right exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same code structure is used for the top and bottom exits ➓. However, the
    program checks the player’s *y* position to see if they used an exit and sets
    their new position to enter through a top or bottom doorway.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we change the room number by 5 instead of 1 because that’s how many
    rooms wide the game map is (see [Figure 4-1](ch04.xhtml#ch04fig1)). For example,
    if you’re in room 37 and you go through the top exit, you end up in room 32 (which
    is 37 minus 5). If you’re in room 37 and go through the bottom exit, you end up
    in room 42 (37 plus 5). We stored the number 5 in the variable `MAP_WIDTH` earlier,
    and the program uses it here.
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re able to freely explore the space station. In the next chapter, we’ll
    fix the remaining few bugs in the room display.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARE YOU FIT TO FLY?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check the following boxes to confirm that you’ve learned the key lessons in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The player’s position in the *Escape* game is
    measured in tiles, just like the scenery.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The `game_loop()` function controls player movement
    and is scheduled to run every 0.03 seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  If the player moves somewhere they aren’t allowed
    to be, they’re put back in their previous position so fast you won’t see them
    move.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The program checks the player’s *x* and *y* positions
    to see whether they’ve walked out of an exit. If they have, they’ll appear in
    the middle of the opposite exit in the next room.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The animation frames are stored in the `PLAYER`
    dictionary and have a list of images for each direction. The dictionary key is
    the direction name, and an index number gets the particular frame needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  Frame 0 is the standing-still position. Frames
    1, 2, 3, and 4 show the astronaut walking.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The `game_loop()` function increases the animation
    frame number used when the player is walking.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The `player_offset_x` and `player_offset_y` variables
    are used to position the astronaut correctly when walking into a new tile.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0126-01.jpg)'
  prefs: []
  type: TYPE_IMG
