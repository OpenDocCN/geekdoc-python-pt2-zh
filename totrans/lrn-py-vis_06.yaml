- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Motion and Transformation
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Applying movement to graphics of both living and inanimate objects instills
    them with character. Bouncy animation suggests playfulness; precise movement implies
    intensity, while slow motion can suggest heaviness. These techniques are applied
    in film, animation, dance choreography, and, of course, your favorite Pixar flick.
    But that’s not all. Motion is prevalent in interface design, such as subtle button-hover
    effects or elaborate spinning graphics that appear while your content is loading.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll make things move by coding with motion and transformation
    functions. You’ll learn how to manipulate the coordinate system with transformation
    functions, making it simpler to move, rotate, and scale your elements. In addition,
    you’ll learn how to structure an animated Processing sketch by using the `setup()`
    and `draw()` functions. Motion literally adds a new dimension—time—to your Processing
    sketches.
  prefs: []
  type: TYPE_NORMAL
- en: Perceiving Motion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, consider how motion is perceived. The brain is fed a snapshot from your
    retina many times each second. Provided that their screen can display a sequence
    of static images at a rate exceeding roughly 10 to 12 frames per second, the viewer
    will experience the illusion of smooth, flowing movement. Higher frame rates will
    appear even smoother.
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment to note the two circles in [Figure 6-1](#figure6-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06001](image_fi/500969c06/f06001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: Two circles (positioned left and right)'
  prefs: []
  type: TYPE_NORMAL
- en: If you displayed only the left circle for four seconds, followed by only the
    right circle for another four seconds, looping the sequence indefinitely ([Figure
    6-2](#figure6-2)), this would be an effective frame rate of 0.25 frames per second
    (or 0.25 *fps*). The result, most observers would agree, is a pair of alternating
    images depicting circles in two different positions.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06002](image_fi/500969c06/f06002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: Displaying alternating circles'
  prefs: []
  type: TYPE_NORMAL
- en: However, speed up the frame rate to around 2.5 fps (10 times faster), and the
    observer will begin to interpret the sequence as a single circle bouncing between
    two points—as if the circle were moving across the gap in the middle. The illusion
    is referred to as *beta movement*. Increase the frame rate further, and the two
    circles will appear to flicker in sync with one another. From this experiment,
    you can see how frame rate doesn’t affect only how fast or slow something moves,
    but also how you perceive the object’s motion.
  prefs: []
  type: TYPE_NORMAL
- en: Note the numbering of the circles shown in [Figure 6-3](#figure6-3).
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose you want to animate this. Using the numbering to dictate the order,
    remove a single circle on each frame. On the first frame, remove just the circle
    labeled 0\. On the second frame, replace circle 0 and remove only circle 1\. Continue
    this process around the ring, and loop the animation indefinitely. Removing successive
    circles from each frame results in a gap that moves around the ring in a clockwise
    progression ([Figure 6-4](#figure6-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06003](image_fi/500969c06/f06003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: A ring of circles numbered in a clockwise sequence'
  prefs: []
  type: TYPE_NORMAL
- en: '![f06004](image_fi/500969c06/f06004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: Animating the ring of circles'
  prefs: []
  type: TYPE_NORMAL
- en: If you run the animation at 1 fps, the circle just ahead of a gap appears to
    jump into the void left by the vacant circle ([Figure 6-5](#figure6-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06005](image_fi/500969c06/f06005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: At 1 fps, the next circle seems to leap into the gap.'
  prefs: []
  type: TYPE_NORMAL
- en: At 25 fps, however, a rapidly moving phantom white dot seems to obscure the
    circles beneath it as it races around the ring—an illusion called the *phi phenomenon*
    ([Figure 6-6](#figure6-6)).
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re ready to build a Processing sketch that, in addition to introducing
    Processing’s animation functions, will allow you to experiment with these phenomena.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06006](image_fi/500969c06/f06006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-6: At 25 fps, a phantom white dot seems to obscure the circles.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Motion to Processing Sketches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processing gives you the option to draw to the display window a single time
    or multiple times over. For animation, you use the latter approach. To make an
    object move, you adjust its position with each frame drawn—and if you do it rapidly
    enough, in small enough increments, the result is smooth, flowing motion.
  prefs: []
  type: TYPE_NORMAL
- en: The draw() and setup() Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make Processing draw something multiple times, you’ll need to structure your
    code by using the `setup()` and `draw()` functions. Beneath those two functions,
    you can nest any of the functions or statements covered in the book so far. As
    indicated in [Figure 6-7](#figure6-7), where you place your code depends on when
    you want it to execute.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06007](image_fi/500969c06/f06007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-7: Structuring code for motion'
  prefs: []
  type: TYPE_NORMAL
- en: Any `def` keyword is followed by a function name, parentheses, and a colon.
    Chapter 9 covers `def` in more detail, but for now, just be aware that any code
    indented beneath a `def` belongs to that respective function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setup()` code runs once at startup, and it typically includes things like
    your `size()` function and other lines that define your environmental properties.
    I’ll get to `draw()` in more detail shortly, but first, create a new sketch, save
    it as *perceiving_motion*, and then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code resembles just about every other sketch you’ve set up so far, except
    for the `def setup()` line. Whenever you intend to use a `draw()` function, you
    have to use `setup()` too. Now add the `draw()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Processing invokes the code indented beneath the `draw()` function with each
    new frame. The `frameCount` is a system variable containing the number of frames
    displayed since starting the sketch. With each new frame, the `draw()` function
    calls the `print()` function, which in turn displays the current frame count in
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `draw()` executes at approximately 60 fps. However, as the complexity
    of an animation increases, the frame rate is likely to drop as your computer struggles
    to accommodate the demands placed on it. Adjust the frame rate by using the `frameRate()`
    function (within the `setup()` block), and add a condition to `draw()` to print
    on even-numbered frames only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With the `frameRate` set to `2.5`, the draw line runs two and a half times every
    second; this means that each frame is 400 milliseconds (0.4 of a second) in duration.
    Because the `print` line executes on every second frame, a new line appears in
    the console every 800 milliseconds ([Figure 6-8](#figure6-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06008](image_fi/500969c06/f06008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-8: Printing the frame count on every even-numbered frame'
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a circle on every even frame instead, use the following `circle()`
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now run the sketch. You may be surprised to find that the circle does not flash
    on and off ([Figure 6-9](#figure6-9)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06009](image_fi/500969c06/f06009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-9: The circle does not “blink.”'
  prefs: []
  type: TYPE_NORMAL
- en: The reason the circle does not disappear on odd frames is that everything in
    Processing persists after it’s drawn. On every even frame, the program draws another
    circle atop the existing “pile.” The `background()` color within the `setup()`
    function runs once at the start, filling the display window in blue to form the
    bottommost layer of this persistent arrangement. To “wipe” each frame before drawing
    the next, you can redraw a background over everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `background(''#004477'')` line into the `draw()` section of your sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The new `background()` line clears every frame before it. Be sure you have placed
    it above the `if` statement. In most instances, a `background()` function will
    sit somewhere near the top of `draw()` to avoid clearing other shapes in the current
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: Test the code. The result should be a blinking circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recreate the ring of circles experiment from earlier ([Figure 6-3](#figure6-3)),
    replace the existing `if` statement with a series of `if` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The current frame count is divided by `8` 1, and the remainder is assigned to
    the `hide` variable. Each `if` statement will draw a separate circle provided
    it hasn’t been flagged as the one to hide. For instance, on the 16th frame, `hide`
    is equal to `0` because 16 divides evenly by 8\. On the 15th frame, `hide` is
    equal to `7` because 15 divided by 8 leaves a remainder of 7\. On the 17th frame,
    `hide` is equal to `1`. The result is a stream of numbers that counts from 0 up
    to 7, then restarts at 0.
  prefs: []
  type: TYPE_NORMAL
- en: Run the sketch. Focus on the gap as it moves around the circle. At the current
    frame rate of 2.5 fps, the circle just ahead of a gap appears to jump into the
    void left by the vacant circle. But adjust the frame rate to 25 fps, and a phantom
    background-colored dot appears to obscure the circles beneath it as it races around
    the ring.
  prefs: []
  type: TYPE_NORMAL
- en: Global Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *global variable* is one that you can access anywhere within your program.
    Up until this point in the book, almost every variable you have defined has been
    a global variable. You’ll need to understand more about global variables to manage
    data across multiple frames.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables are declared outside any function definitions (indented blocks
    beginning with `def`), usually somewhere near the top of your code. For instance,
    any variables that you declare outside `setup()` and `draw()` are automatically
    global. Conversely, any variables declared inside the indented lines of those
    two functions are accessible within that function alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of this behavior in action, create a new sketch and save it as
    *global_variables*. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `y` variable 1 is declared within the `setup()` function. As such, `y` is
    accessible only within the indented lines of the `setup()` block. The `y` variable’s
    scope, therefore, is considered to be *local* to `setup()`. *Scope*, in programming,
    deals with the regions where a variable (or other entity) may be accessed. In
    this instance, running the sketch produces an error ([Figure 6-10](#figure6-10)),
    because you have attempted to access and print variable `y` from within the `draw()`
    function 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06010](image_fi/500969c06/f06010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-10: The `draw()` function cannot access the `y` variable declared
    in `setup()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can move the `y = 1` line outside the `setup()` function,
    which places it in the global scope; this permits either function to read it.
    Move this line to the top of your code and insert a `pass` statement in place
    of the location you moved it from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `draw()` function has no problems accessing `y` now that it’s declared outside
    `setup()`. The `pass` statement is a *null operation*—that is, nothing happens
    when it executes. You need to include a `pass` line because Python does not allow
    empty function definitions. This makes `pass` a useful placeholder for any code
    you have yet to write. Upon running the sketch, the console should print endless
    lines of `1`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can override the global `y` variable on a local level with another variable
    of the same name—in this case, another variable named `y`. Make the following
    adjustments to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `setup()` function runs first—just once—and its `print` line 2 displays
    a `0`. This is because within the `setup()` function, you define the `y` as a
    `0` 1. The outer (global) `y` is still equal to 1, and it’s said to be *shadowed*
    by the `setup()`’s inner (local) `y` variable. The `draw()` code executes after
    the `setup()` code, and with every new frame, prints 3 a `1` to the console. Run
    the sketch, quickly stop it, and then scroll up through the console output. The
    first line displayed is a `0`; from there down, it’s all `1`s ([Figure 6-11](#figure6-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06011](image_fi/500969c06/f06011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-11: The global `y` variable is shadowed by the `y = 0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, remove the `y = 0` line and add code that attempts to increment the global
    `y` variable by `1` with each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: While you can read (or shadow) any global variable, writing or reassigning values
    requires additional code. As a result, this code should cause Processing to display
    an error ([Figure 6-12](#figure6-12)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06012](image_fi/500969c06/f06012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-12: The `draw()` function cannot reassign a value to `y`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the `global` statement is useful. Edit your code, inserting a
    `global y` line at the top of the `draw()` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The global `y` variable is now bound to the local scope of `draw()`, and you
    may modify it as you wish. Run the sketch. The global `y` variable should now
    increment by 1 with each new frame ([Figure 6-13](#figure6-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06013](image_fi/500969c06/f06013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-13: The global `y` variable is incremented by 1 with each new frame.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Global variables allow you to keep track of and update values between frames
    easily, which is especially useful for animating objects. Add a moving circle,
    the y-coordinate of which is controlled by the `y` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I’ve placed the size, fill, and stroke properties in the `setup()` section of
    the code. Given that the stroke and fill are unchanged throughout the animation,
    there’s no need to apply those properties repeatedly in `draw()`. The circle’s
    y-coordinate, represented by variable `y`, moves the circle down as the frames
    advance. In [Figure 6-14](#figure6-14), a motion trail has been added to convey
    the direction of motion.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06014](image_fi/500969c06/f06014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-14: The circle moves down from the top of the display window.'
  prefs: []
  type: TYPE_NORMAL
- en: When the circle reaches the bottom of the display window, it continues out of
    sight beyond the lower edge.
  prefs: []
  type: TYPE_NORMAL
- en: Saving Frames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Processing provides the `saveFrame()` function to save frames as image files.
    Whenever your sketch calls a `saveFrame()`, it saves a *Tagged Image File Format,*
    or TIFF, image in the sketch folder. You’ll want to place this call at the end
    of your `draw()` function to ensure that you capture every shape rendered on the
    current frame. For instance, say you add the following code to a `draw()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As the animation encounters every 100th frame, a new image file appears in your
    sketch folder. This image file is named *screen-* followed by a four-digit frame
    count; where necessary, this frame count is padded with leading zeros, as shown
    in [Figure 6-15](#figure6-15). Because `saveFrame()` precedes the `square()` line,
    the square appears in every frame of the animation, but never in the saved image
    files.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06015](image_fi/500969c06/f06015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-15: The `saveFrame``()` function generates an image file named using
    the frame count.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to save the file in an image format other than TIFF, such as JPG,
    PNG, or TARGA, include a filename argument with the relevant extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you’d use the same filename for every image saved, which is okay
    for capturing a single frame, but will lead to overwriting when you call the same
    `saveFrame()` function multiple times. However, you can include a series of hash
    marks to make the frame count appear in the filename. This code generates a uniquely
    named PNG file with every save:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Processing replaces the hash marks with the frame count and, if necessary, pads
    the count with leading zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #5: DVD Screensaver'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this task, you’ll combine `setup()`, `draw()`, global variables, and `if`
    statements to animate an object that bounces off the edges of the display window.
  prefs: []
  type: TYPE_NORMAL
- en: DVD players commonly feature a bouncing DVD logo as a screensaver ([Figure 6-16](#figure6-16)),
    which appears after a given period of inactivity. You may have seen a variation
    of this on other devices, albeit with a different graphic. Intriguingly, people
    often find themselves staring at the pointless animation in the hope of witnessing
    the logo land perfectly in the corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06016](image_fi/500969c06/f06016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-16: The logo bounces off edges of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new sketch and save it as *dvd_screensaver*. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code is similar to that of the previous example using the circle ([Figure
    6-14](#figure6-14)). In this instance, you include a `yspeed` variable. To use
    a single `global` statement for multiple variables, comma-separate them 1. With
    each new frame, the program adds `yspeed` to the `y` variable 2, which serves
    as the y-coordinate for the DVD text 3. Upon running the sketch, the logo should
    move directly down ([Figure 6-17](#figure6-17)), soon passing beyond the bottom
    edge of the display window.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06017](image_fi/500969c06/f06017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-17: The DVD text moves downward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the logo rebound off the bottom edge of the display window, add the
    following `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When the `y` variable exceeds the `height` of the display window, the `yspeed`
    is multiplied by `-1`, sending the logo in the opposite direction. Run the sketch;
    the logo should rebound as it hits the bottom edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'To move the logo diagonally, add some `x` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, you’ve replicated everything you did with the `y` and `yspeed` variables
    for the `text()` function’s `x` argument. The logo should now move vertically
    and horizontally. Run the sketch ([Figure 6-18](#figure6-18)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06018](image_fi/500969c06/f06018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-18: The diagonally moving DVD text rebounds near the lower-right corner.'
  prefs: []
  type: TYPE_NORMAL
- en: When the logo rebounds off the bottom edge, the `yspeed` is inverted, but not
    the `xspeed`. This is the behavior you seek, but then the logo passes through
    the right edge. Instead, the logo must rebound off every edge it encounters. Your
    challenge is to complete the task. If you need help, you can access the solution
    at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/dvd_screensaver/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/dvd_screensaver/).
  prefs: []
  type: TYPE_NORMAL
- en: Transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processing’s *transformation functions* provide convenient ways to manipulate
    elements by using translate, rotate, scale, and shear operations ([Figure 6-19](#figure6-19)).
    You may apply transformations to individual shapes, groups of elements, or the
    entire drawing space.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06019](image_fi/500969c06/f06019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-19: From left to right: translation, rotation, scaling, and shear
    transformations'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to rotate a star shape (as shown in [Figure 6-20](#figure6-20))
    in a clockwise direction. This star is composed of vertices using a series of
    `vertex()` functions; an x-y coordinate pair defines the position of each vertex.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06020](image_fi/500969c06/f06020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-20: Rotating a star shape'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the new positions of each vertex requires a *matrix*. You can think
    of a matrix as a table of numbers. For different transformations, you can add,
    subtract, or multiply each x-y coordinate pair with a *transformation matrix*.
    In the case of the star rotation, the matrix operation would look something like
    [Figure 6-21](#figure6-21). The *x* and *y* values in the square brackets labeled
    *vertex* represent the coordinate pair for a given vertex; this is multiplied
    by the *transformation matrix* to calculate a new rotated vertex position. The
    equation in the *result* brackets reveals the workings of the matrix math.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06021](image_fi/500969c06/f06021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-21: A transformation matrix for rotation'
  prefs: []
  type: TYPE_NORMAL
- en: If matrix math looks a little confusing, don’t worry; Processing quietly handles
    all of it for you.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn about the `translate()`, `rotate()`, `scale()`,
    `shearX()`, and `shearY()` functions. You’ll also see how to use the `pushMatrix()`
    and `popMatrix()` functions for applying transformations to selected groups of
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Processing Transformation Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new sketch and save it as *transformation_functions*. Within the sketch’s
    folder, create a *data* subfolder and then follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your web browser and go to [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to *chapter-06-motion_and_transformation*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the *grid.png* and *grid-overlay.png* files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place both files in your *data* subfolder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following setup code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `grid` variable and `image()` lines load and display the *grid.png* graphic.
    The *grid-overlay.png* file is loaded into the variable `grido`, but it’s not
    rendered in the display window yet; you’ll display it later in this task.
  prefs: []
  type: TYPE_NORMAL
- en: translate()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `translate()` function accepts two arguments: an x-offset and y-offset.
    Ordinarily, an x-y coordinate of (0, 0) marks the upper left corner of the display
    window. This point is called the *origin*. Using `translate()`, you can reposition
    the coordinate system, which shifts the origin and influences everything you draw
    after that.'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `translate()` function to your *transformation_functions* code, and display
    the grid-overlay graphic by using a new `image()` line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `translate()` function moves the entire coordinate system 150 pixels across
    and 100 pixels down. The `image()` function draws the grid-overlay graphic—a pale
    blue version of the first grid image—at (0, 0). The *grid-overlay.png* graphic
    has a transparent background, so you should see the *grid.png* file showing through
    it. Run the sketch to confirm that the output matches [Figure 6-22](#figure6-22).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06022](image_fi/500969c06/f06022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-22: The grid image with the translated grid-overlay displayed above
    it'
  prefs: []
  type: TYPE_NORMAL
- en: The x-y coordinate (0, 0) no longer aligns with the upper left corner of the
    display window. The grid-overlay graphic serves as a visual representation of
    your new, shifted coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a red and a yellow square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The red and yellow squares share a y-argument of `0`, but the yellow square
    has an x-coordinate of `100`. Run the sketch. Processing positions both squares
    relative to your new origin. The yellow square should appear to the right of the
    red ([Figure 6-23](#figure6-23)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Transformations are cumulative, meaning that each subsequent transformation
    uses the current coordinate system as a reference, so you could have placed the
    yellow square 100 pixels to the right by using an additional `translate(100, 0)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The new `translate()` line has an `x` argument of `100`, and the `x` argument
    for the `square()` is now `0`. The visual result should be the same as [Figure
    6-23](#figure6-23).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06023](image_fi/500969c06/f06023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-23: Horizontally adjacent red and yellow squares'
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 5, you learned how to use a loop to arrange Truchet tiles. A row
    and column variable kept track of where to place the tiles. Alternatively, you
    could have used `translate()`, moving the coordinate system with each iteration
    of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: rotate()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `rotate()` function rotates the coordinate system around its origin (0,
    0). It accepts a single argument specified in radians. Positive values rotate
    clockwise, and negative values rotate counterclockwise. As with all transformation
    functions, the effect is cumulative. Moreover, you can mix `rotate()` and other
    transformation functions as you please.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `rotate()` line beneath your first `translate()` function to rotate
    the grid-overlay graphic and red and yellow squares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `rotate()` function uses an argument of `QUARTER_PI` radians, equivalent
    to 45 degrees. Note that `QUARTER_PI` is a predefined Processing variable, equivalent
    to writing `PI/4`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the sketch. The two squares should appear to be rotated as a group, along
    with the grid-overlay graphic ([Figure 6-24](#figure6-24)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06024](image_fi/500969c06/f06024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-24: Rotating the grid-overlay graphic and two squares'
  prefs: []
  type: TYPE_NORMAL
- en: The coordinate system is rotated around the current origin, which serves as
    the pivot point. Recall that this origin has been offset by 150 pixels for `x`
    and 100 pixels for `y` by the `translate()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The order of functions matters. For instance, switching the `translate()` and
    `rotate()` lines produces different visual results. [Figure 6-25](#figure6-25)
    provides a comparison. The ghosted squares depict the result of the transformation
    that occurred first. The right image is produced by performing the `rotate()`
    first, when the origin is aligned with the upper left corner of the display window.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06025](image_fi/500969c06/f06025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-25: The order of the `translate()` and `rotate()` functions matters;
    the image on the left shows `translate()` first, and the image on the right shows
    `rotate()` first.'
  prefs: []
  type: TYPE_NORMAL
- en: To rotate a square around its center, as opposed to its upper left corner, align
    the center of the square with the origin by offsetting the `x` and `y` arguments
    for `square()`.
  prefs: []
  type: TYPE_NORMAL
- en: scale()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `scale()` function resizes the coordinate system. One argument will scale
    proportionately; two arguments control the x-scale and y-scale. A `scale(1)` or
    `scale(1, 1)` will have no effect, as those are the default scale values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To decrease the scale, use a floating-point value between 0 and 1\. Reduce
    the size of your existing elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The scale value of `0.5` scales the elements to half their original size. Just
    as with `rotate()`, the scaling is relative to the origin of the current coordinate
    system. In other words, (0, 0) stays in place, and everything shrinks toward this
    point ([Figure 6-26](#figure6-26)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06026](image_fi/500969c06/f06026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-26: Halving the size by using `scale(0.5)`'
  prefs: []
  type: TYPE_NORMAL
- en: Any value above 1 scales upward. For instance, to double the size of everything,
    use `scale(2)`. To reflect/flip on a given axis, use a negative value. For example,
    `scale(-1, 1)` flips everything horizontally, producing a mirror image of your
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: shearX() and shearY()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Shearing* a shape skews it along the horizontal or vertical axis. The result
    is a distorted shape with the same area. A typical shear example is transforming
    a rectangle into a parallelogram with slanted sides.'
  prefs: []
  type: TYPE_NORMAL
- en: The `shearX()` and `shearY()` functions apply a horizontal and vertical shear,
    respectively. Each function accepts a single argument specified in radians.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply a vertical shear to your grid-overlay graphic and two squares, comment
    out the `rotate()` line and apply a 45-degree vertical shear by using a `shearY()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `rotate()` function is commented to make the direction of the shear more
    visually apparent. The `shearY()` argument is a positive number, so the shear
    is applied in a clockwise direction. [Figure 6-27](#figure6-27) contrasts the
    result of these code changes (left image) and a `shearX()` operation (right).
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to combine transformation functions; however, you’ll often
    want to contain the transformation effects to a limited selection of elements.
    Next, let’s look at how to use multiple coordinate matrices within a single sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06027](image_fi/500969c06/f06027.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-27: `shearY(QUARTER_PI)` (left) and `shearX(QUARTER_PI)` (right)'
  prefs: []
  type: TYPE_NORMAL
- en: pushMatrix() and popMatrix()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `pushMatrix()` and `popMatrix()` functions allow you to isolate the effects
    of any transformation functions. In this way, you can perform different transformations
    on selected elements, which is especially useful for groups of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Any elements you add to your sketch are positioned relative to the coordinate
    system’s origin. Recall that each new transformation function affects the position
    or orientation of the origin and that each new transformation is influenced by
    any that precede it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to apply `translate()` and `scale()` to the yellow square, but
    not `shearY()`, isolate the red and yellow squares, placing each within `pushMatrix()`
    and `popMatrix()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `pushMatrix()` functions create new matrices for `shearY()` 2 and `translate()`
    3, which both extend upon the `translate(150, 100)` above 1. The `popMatrix()`
    function restores the coordinate system before the previous `pushMatrix()` line.
    I’ve added another grid-overlay graphic to help visualize what is happening with
    the two coordinate systems.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, you could undo the shear by adding `shearY(-QUARTER_PI)`
    after the red square, but pushing and popping matrices is the more elegant solution.
  prefs: []
  type: TYPE_NORMAL
- en: Run the sketch. As shown in [Figure 6-29](#figure6-29), the yellow square should
    appear translated and scaled, but not sheared.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06029](image_fi/500969c06/f06029.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-29: The yellow square is translated and scaled, but not sheared.'
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine that you want to move drawings made of multiple shapes across the
    display window. [Figure 6-30](#figure6-30) depicts a fish tank simulation; each
    fish is composed of many shapes. Each eye (a circle) has its own x-y coordinate,
    and so does every vertex that defines a curve or straight line.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06030](image_fi/500969c06/f06030.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-30: Translating groups of shapes by using `pushMatrix``(``)` and `popMatrix``()`'
  prefs: []
  type: TYPE_NORMAL
- en: To track and update all of these x-y coordinates, you must store them in global
    variables to increment with each frame. The more efficient approach is to define
    each fish within a pair of `pushMatrix()` and `popMatrix()` functions. In this
    way, you can control the position of one fish by using one global x-y coordinate
    pair and a `translate()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment with the `pushMatrix()` and `popMatrix()` functions containing different
    groups of shapes, each employing a different sequence of transformation functions.
    You can add animation if you like. Reuse the `image(grido, 0, 0)` line within
    each of your `pushMatrix()...` `popMatrix()` stacks to help visualize what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #6: Analog Clock'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this challenge, you’ll use all the techniques you’ve learned in this chapter
    to create an analog clock that displays the current time. The clock will update
    every second, so you’ll need to use `draw()`. To rotate the second, minute, and
    hour hands, you’ll use transformation functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new sketch and save it as *analog_clock*. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The frame rate is set to `1`, enough to update the second hand’s position each
    second.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the relevant time values, use the Processing `hour()`, `minute()`,
    and `second()` functions. Each function communicates with your computer clock
    to return an integer value; these functions require no arguments. Add code to
    the `draw` block that displays the current time in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Run the sketch. With each new frame, your console displays the current hours
    (0 to 23), minutes (0 to 59), and seconds (0 to 59), separated by colons. The
    time should match that of your system clock, usually displayed in the corner of
    your screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a digital-style clock (that is, no hands, just numbers) in Processing
    is a simple matter of combining time and `text()` functions. For an analog clock,
    however, you need to convert the hours, minutes, and seconds into angles of rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin your clock by drawing the face and hour hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `translate()` function 1 positions the origin in the center of the display
    window. This will make rotating the clock hands simpler, because the `rotate()`
    function rotates around the origin of the coordinate system. The `circle()` function,
    with its x-y arguments both set at zero 2, is centered in the display window ([Figure
    6-31](#figure6-31)). The hour hand is the thickest (and shortest), with a stroke
    weight of `10` 3 and length of `100` pixels 4.
  prefs: []
  type: TYPE_NORMAL
- en: '![f06031](image_fi/500969c06/f06031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-31: A clock face with an hour hand'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hour hand currently rests along 0 radians (pointing east). Recall that
    when drawing using the `arc()` function, the angle opens from this point, clockwise
    (southward). However, your clock will be offset by three hours should the hand
    begin from a three o’clock position. Calibrate this using a `rotate()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `HALF_PI` is equivalent to `PI / 2`; by prepending this with a `–` sign,
    you rotate counterclockwise. Run the sketch. The hour hand should now point to
    twelve o’clock (directly upward).
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to calculate how many radians the hand advances with each hour.
    Consider that a complete rotation is 2π radians; therefore, one hour equals `PI
    * 2 / 12`. So, six o’clock is `PI * 2 / 12 * 6`. Rather than writing `PI * 2`,
    though, you can use `TAU`. For example, six o’clock is equal to `TAU / 12 * 6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rotate your hour hand to the current hour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At twelve o’clock, the hour hand points directly upward. This is because `TAU
    / 12 * 12` is equal to `TAU`, or one complete rotation. For every other hour,
    the hand should point to the correct position ([Figure 6-32](#figure6-32)). Of
    course, the angle of the hand will depend on what time of day it is.
  prefs: []
  type: TYPE_NORMAL
- en: Now add the minute and second hands. The final result should look something
    like [Figure 6-33](#figure6-33).
  prefs: []
  type: TYPE_NORMAL
- en: The second hand should advance each second. Compare the time in the console
    to the visual output to ensure that your code is working correctly. If you need
    help, you can access the solution at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/analog_clock/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-06-motion_and_transformation/analog_clock/).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06032](image_fi/500969c06/f06032.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-32: The hour hand pointing to two o’clock'
  prefs: []
  type: TYPE_NORMAL
- en: '![f06033](image_fi/500969c06/f06033.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-33: The completed clock'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to structure a Processing sketch for animation.
    To manage variables between frames, you learned how to use global variables. You
    can increment global variables every frame to control shape coordinates for smooth
    animation. You also now know how to save frames as images. You might save an animation
    as a sequence of images so that you can combine them into a movie by using video
    editing software.
  prefs: []
  type: TYPE_NORMAL
- en: You also saw how transformation functions manipulate the coordinate system,
    allowing you to translate, rotate, scale, and shear your elements. And you learned
    to modify the coordinate system to apply transformations to a select group of
    elements. It’s far easier to move a group of shapes by using a single translate
    operation than to manage a large number of coordinate variables. Moreover, applying
    rotate, scale, and shear operations to a single shape, let alone group, would
    otherwise involve complex matrix calculations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about Python lists and how to read in data
    from external files. Lists will unlock powerful ways to manage and manipulate
    values as collections of elements, rather than individually. To help visualize
    list values, you’ll also explore data visualization techniques.
  prefs: []
  type: TYPE_NORMAL
