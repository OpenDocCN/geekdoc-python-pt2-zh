- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iteration and Randomness
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: In Chapter 4, you learned how to program divergent paths for Python to follow.
    In this chapter, you’ll create looped paths with `while` and `for` loop statements.
    *Loop statements* repeat actions, so you don’t need to rewrite the same or similar
    code multiple times, resulting in fewer lines of code. In other words, you can
    solve problems more efficiently with code that’s easier to adapt. You’ll use these
    loop statements to generate visual patterns in Processing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn to apply randomness to your patterns to make them more compelling
    and unpredictable. Processing’s `random()` function is useful for generating randomized
    arguments in your shape functions, allowing you to create irregular designs. You
    can also randomize the conditions for your control flow statements so that your
    code executes differently on each run. Randomness is, undoubtedly, one of the
    most useful and exciting tools in the creative coder’s toolset, because it allows
    you to write programs that can produce unpredictable results.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Iteration
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In computer programming, *iteration* is the process of repeating a series of
    instructions a specified number of times or until a condition is met. As an example,
    say you want to tile a floor. Starting in one corner, you lay one tile. Then you
    place another tile next to it, repeating the process until you’ve reached the
    opposite wall, at which point you move down a row and continue. In this scenario,
    placing an individual tile is a single iteration. In many iterative processes,
    the result of a previous iteration defines the starting point of the next.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Tasks like tiling can be tedious work, though. Humans are exemplary in reasoning
    and creative thought, but if not sufficiently stimulated, they tend to lose interest
    in performing such monotonous activities. Computers, however, excel at performing
    repetitive tasks rapidly and accurately, especially when numbers are involved.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Using Iteration to Draw Concentric Circles
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin exploring iteration in Processing, create a new sketch and save it
    as *concentric_circles*. Add the following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each `circle()` function has its x-y coordinate placed in the center of the
    display window. The first circle is the smallest, with a diameter argument of
    `30`; each subsequent circle is 30 pixels larger in diameter than the one preceding
    it. The program runs each `circle()` function line by line, advancing toward a
    display window filled with concentric circles ([Figure 5-1](#figure5-1)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![f05001](image_fi/500969c05/f05001.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: Three circles rendered using three `circle()` functions'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: However, to fill the entire window, you’d need to write many more `circle()`
    lines. Instead of adding `circle()` functions manually, you can use a Python `while`loop
    to run them iteratively.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: while Loops
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `while` loop is a control flow statement that looks and behaves much like
    `if`. The key difference is that `while` continues to execute the lines indented
    beneath it *until* its accompanying condition is no longer true.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in your *concentric_circles* sketch, comment out the `circle()` lines
    by using `''''''` for multiline comments, and add a basic `while` loop structure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `i` variable is defined to serve as your *loop counter*, controlling the
    iterations of the `while` statement. For the `while` expression, `i` is equal
    to 0 and, therefore, is less than 24\. Unlike an `if` statement that would execute
    the `print()` function a single time, the `while` repeatedly executes the `print`
    line until the value of `i` reaches 24—which, in this case, is never.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Running the sketch should print an endless list of `0` digits to the console
    ([Figure 5-2](#figure5-2)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![f05002](image_fi/500969c05/f05002.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: The console lists endless lines of zeros.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: This code has crashed your program by sending it into an infinitive loop! To
    exit the program, click the **Stop** button. Processing may take some time to
    respond. The variable `i` remains 0, and the `i < 24` condition never achieves
    the `False` required to conclude the loop.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'To correct this, add 1 to `i` with each iteration of the `while` loop:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This new line states that the loop counter, `i`, is equal to itself plus 1\.
    On the first iteration, `i` is 0, which is less than 24, so the program prints
    `0`, adds 1 to `i`, and then begins the process again. On the next iteration,
    `i` is 1, which is still less than 24, so the program prints `1`, adds 1 to it,
    and restarts the process. The iteration continues as long as `i < 24` evaluates
    to `True`. Once `i` reaches 24, the program exits the loop and runs any other
    code that follows the `while` block.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Note that the output never reaches 24 ([Figure 5-3](#figure5-3)), because the
    `while` condition states “where `i` is less than 24,” not “less than or equal
    to 24.”
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw 24 circles, place a `circle()` function within the loop:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![f05003](image_fi/500969c05/f05003.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: The console displays 0 to 23, but not 24.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: To avoid drawing 24 circles of exactly the same size, in the same position,
    use `i` as a multiplier for the `circle()` diameter argument. On the first iteration,
    the diameter argument is equal to `30*0`. Therefore, the first circle, placed
    in the very center of the display window, has a diameter of 0 and doesn’t render
    ([Figure 5-4](#figure5-4)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The other 23 circles are enough to fill the 500 × 500 pixel area. By changing
    the number in the `while` statement, you may draw as many (or as few) circles
    as you like.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![f05004](image_fi/500969c05/f05004.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: The drawing now has 24 circles (one invisible, and some partially
    cropped).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: for Loops
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python `for` loop executes a given block of code a specified number of times.
    Unlike the `while` loop that relies on a conditional expression, the `for` loop
    iterates a sequence. A *sequence* is a collection of values; for instance, string
    data is a sequence of characters. Python *lists* are particularly versatile sequences,
    which I cover in Chapter 7. To generate sequences for the `for` loops in this
    section, you’ll use the `range()` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop is more appropriate than a `while` loop when you’ve established
    the number of iterations required before entering the loop. Generally speaking,
    the `for` loop is shorter and simpler, and won’t trigger infinite loops. When
    either a `while` or `for` will do, opt for the `for` loop.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the easiest ways to understand the `for` loop is to convert something
    you already wrote that uses a `while` statement. Save *concentric_circles* as
    a new sketch called *for_loop* by using **File**▶**Save As**. Comment out the
    `while` loop parts, and add the following `for` loop:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `while` loop version, recall that you had to define the `i` variable
    to serve as a loop counter. With each iteration of the `while` block, you also
    had to increment `i` to avoid entering an endless loop. The `for` statement does
    away with the need to define and manage a separate counter variable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: So, `i = 0` 1 is no longer necessary, nor is the nested statement to increment
    it 2. Instead, the `range()` function takes its argument of `24` to generate a
    sequence from 0 up to but not including 24 that controls the `for` 3 loop iteration
    behavior. On the first iteration, `i` is equal to 0, the first value in the sequence.
    With each subsequent iteration, the next value in the `range()` sequence is assigned
    to `i`. When `i` reaches 23, the `for` block runs for the last time, and then
    Python exits the loop. Run the sketch to confirm that the display window looks
    the same as [Figure 5-4](#figure5-4).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The `range()` function can handle up to three parameters. Provide two arguments
    for a start and end value, respectively:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this instance, the `circle()` function should execute three times, for `i`
    = 10, `i` = 11, and `i` = 12\. Run the sketch to see the result ([Figure 5-5](#figure5-5)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: You should see three concentric rings.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![f05005](image_fi/500969c05/f05005.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: Result for `range(10, 13)`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Now use three range arguments to represent a start, end, and step size, respectively.
    The *step size* is the difference between each integer in the sequence:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this instance, the `circle()` function should execute four times, for `i`
    = 3, `i` = 6, `i` = 9, and `i` = 12\. The result should be four rings with enlarged
    spacing ([Figure 5-6](#figure5-6)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![f05006](image_fi/500969c05/f05006.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: Result for `range(3, 13, 3)`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Experiment with different range arguments to see how the circles are affected.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #4: Create Line Patterns'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this challenge, recreate the three patterns shown in [Figure 5-7](#figure5-7)
    by using the `line()` function and one `for` loop for each. Don’t worry if your
    code produces a slightly different result, as long as the basic pattern remains
    the same.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not sure where to begin, here are a few clues to help you approach
    each pattern:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The left pattern is similar to the concentric circles, except it has 12 diagonal
    lines.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the middle pattern, the line spacing increases by a multiple of 1.5 with
    each `for` loop iteration. Defining an additional variable may help.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right pattern requires an `if...else` structure nested within the `for`
    loop. You might consider using a modulo (`%`) operator, described in Chapter 1,
    to establish whether `i` is odd or even.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need help, you can find the solution at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/for_loop_patterns/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/for_loop_patterns/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![f05007](image_fi/500969c05/f05007.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: Three `for` loop patterns'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: break and continue Statements
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loops provide an efficient way to automate and repeat tasks. Sometimes, though,
    you need to exit a loop prematurely. For example, when you draw a series of concentric
    circles to fill the display window, like in the earlier task, you might want to
    *break* the loop if the circles reach the edge of the display window before exhausting
    the sequence of `range()` values. If Python encounters a `break` statement within
    a `for` or `while` loop, it will immediately terminate the loop. Once the loop
    is terminated, your program will move along as usual.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you need to terminate an iteration (not the entire loop), prompting
    Python to begin the next iteration immediately. For this, use the `continue` statement.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a brief example comparing an ordinary loop, a loop with a `break`
    statement, and a loop with a `continue` statement. There’s no need to write any
    code. [Figure 5-8](#figure5-8) depicts three dotted lines, drawn from left to
    right using each type of loop.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop for the pale blue (top) dotted line looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With each iteration, the `circle()` function draws a new dot, placing it 20
    pixels to the right of its predecessor. The first dot has an x-coordinate of 20;
    the loop completes as the dotted line reaches the `width` of the display window.
    This loop is not concerned with the two vertical red bands and draws dots right
    through them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![f05008](image_fi/500969c05/f05008.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-8: Drawing dotted lines using different loops'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop for the orange (middle) dotted line looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `get()` function accepts an x-y coordinate and returns the color for the
    pixel at that position; to extract the red value for the pixel, you wrap the `get()`
    function with a `red()` function. This will return a red value between 0 and 255
    based on the RGB mixture, which means a value of 255 for any pixels in the bright
    red bands (`#FF0000`). The loop will check for a red pixel before it draws a dot;
    if detected, the `break` statement will terminate the loop. The `fill()` and `circle()`
    functions do not draw a dot on the final iteration, because the `break` statement
    exits the loop immediately.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop for the green (bottom) dotted line looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This loop will check for a red pixel before it draws a dot; if the pixel is
    detected, the `continue` statement immediately terminates the current iteration
    of the loop to start at the beginning of the next, skipping over the `fill()`
    and `circle()` functions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Randomness
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Randomness is an important concept in computer programming because of its applications
    in cryptography. Moreover, randomness is programmed into everything from video
    games to simulations to gambling software. However, computer-generated random
    numbers aren’t truly random, because they’re created using a specific algorithm.
    If you know the algorithm and the conditions used to generate “random” numbers,
    you can predict patterns in the sequence. Therefore, a computer can simulate randomness
    only by generating *pseudorandom* numbers, which are not truly random but statistically
    similar enough to actual random numbers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll use the Processing `random()` and `randomSeed()` functions
    to generate pseudorandom values. With these randomized values, you’ll draw more
    interesting patterns than you might be able to create with predefined values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: random() Function
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each time you call Processing’s `random()` function, it produces an unexpected
    value within a specified range. To begin experimenting with randomness, create
    a new sketch and save it as *random_functions*. Add the following setup code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The new sketch has a blue background. Soon, you’ll draw points; the size of
    your points is affected by the `strokeWeight()` function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The `random()` function can accept up to two arguments. In the case of a single
    argument, you’re defining an upper limit:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code will display a random floating-point value ranging from 0 up to but
    not including 5.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Two arguments represent an upper and lower limit, respectively:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This time around, the console displays a random floating-point number ranging
    from 5 up to but not including 10.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a random integer instead, wrap the `random()` function in `int()`.
    This converts the floating point to an integer by removing the decimal point and
    everything that follows it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Figure 5-9](#figure5-9) shows what you can expect to see. Of course, given
    that the values are random, the console output will appear differently on your
    computer, as well as each time you run the sketch.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![f05009](image_fi/500969c05/f05009.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![f05009](image_fi/500969c05/f05009.png)'
- en: 'Figure 5-9: Experimenting with different `random``()` arguments'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-9：尝试不同的 `random()` 参数
- en: 'Next, let’s generate 50 random values. Rather than print a long list in the
    console area, plot them as a series of points sharing a y-coordinate. Add the
    following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们生成50个随机值。与其在控制台区域打印一长串数据，不如将它们作为一系列共享 y 坐标的点进行绘制。添加以下代码：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `point()` function uses the `random()` function to define its x-coordinate.
    The y-coordinate is always `height/2`. The points should distribute differently
    each time you run the sketch ([Figure 5-10](#figure5-10)).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `point()` 函数使用 `random()` 函数来定义其 x 坐标。y 坐标始终为 `height/2`。每次运行草图时，点的位置应该会有所不同（[图
    5-10](#figure5-10)）。
- en: '![f05010](image_fi/500969c05/f05010.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![f05010](image_fi/500969c05/f05010.png)'
- en: 'Figure 5-10: Random values distributed along a line'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-10：沿一条直线分布的随机值
- en: 'Now change the `range` argument from `50` to `500`, and plot the point using
    random x- and y-coordinates:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将 `range` 参数从 `50` 改为 `500`，并使用随机的 x 和 y 坐标绘制点：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result should be a display window filled with 500 randomly positioned points
    ([Figure 5-11](#figure5-11)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个显示窗口，里面填充了500个随机位置的点（[图 5-11](#figure5-11)）。
- en: '![f05011](image_fi/500969c05/f05011.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![f05011](image_fi/500969c05/f05011.png)'
- en: 'Figure 5-11: Filling the display window with randomly positioned points'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-11：用随机摆放的点填充显示窗口
- en: Each time you run the sketch, it produces a (slightly) different arrangement.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行草图时，它都会生成一个（略微）不同的排列。
- en: Random Seed
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机种子
- en: In Figures 5-10 and 5-11, Processing picks the coordinates from a pseudorandom
    *sequence* of numbers. This pseudorandom sequence itself relies on a *random seed*,
    which is an initial number the random function selects based on something unpredictable,
    like keystroke timing. For instance, you may have pressed your last key 684 milliseconds
    past the tick of the previous second. For a random number between 0 and 9, your
    computer can grab the last digit of the 684 (which is a 4). The random seed determines
    what you’ll get from your first `random()` call as well as all subsequent calls.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 5-10 和图 5-11 中，Processing 从伪随机的 *序列* 中选择坐标。这个伪随机序列本身依赖于一个 *随机种子*，这是一个随机函数根据不可预测的因素（如按键时间）选择的初始数字。例如，你可能在上一秒的时刻过去684毫秒时按下了最后一个键。对于
    0 到 9 之间的随机数，你的计算机会抓取 684 的最后一位数字（即 4）。随机种子决定了你从第一次 `random()` 调用中得到的结果以及后续所有调用的结果。
- en: 'You can use Processing’s `randomSeed()` function to set the random seed manually.
    Change the range argument to `10`, and insert a `randomSeed()` line at the very
    top of your working sketch:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Processing 的 `randomSeed()` 函数手动设置随机种子。将范围参数改为 `10`，并在工作草图的最顶部插入一行 `randomSeed()`：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This `randomSeed()` function accepts a single argument, any integer of your
    choice, but you’ll use `213` for this example. Unlike the 500-point ([Figure 5-11](#figure5-11))
    version in which no random seed had been defined, every run of the code produces
    the same pattern, on any computer that executes it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `randomSeed()` 函数接受一个单一的参数，任何你选择的整数，不过在本例中我们使用 `213`。与 500 个点的（[图 5-11](#figure5-11)）版本不同，该版本没有定义随机种子，每次运行代码时都会产生相同的模式，在任何执行它的计算机上都是如此。
- en: This ability to ensure that the program generates the same sequence of pseudorandom
    numbers with every run is useful in many applications. For example, suppose you
    developed a platform game using levels composed of randomly positioned obstacles.
    Not having to place obstacles manually would save a lot of time. However, you
    discover that specific sequences of pseudorandom numbers produce more engaging
    levels than others. What’s more, the resulting levels vary in difficulty, so you
    need to control the order in which the player progresses through them. If you’re
    aware of the seed values that produce each level, you can reproduce any of them,
    on demand, with just an integer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种确保程序每次运行时生成相同伪随机数序列的能力在许多应用中非常有用。例如，假设你开发了一个平台游戏，关卡中包含随机摆放的障碍物。不需要手动摆放障碍物可以节省大量时间。然而，你发现某些伪随机数序列生成的关卡比其他的更具吸引力。而且，生成的关卡难度不同，所以你需要控制玩家通过关卡的顺序。如果你知道哪些种子值生成了每个关卡，你就可以仅通过一个整数按需重现任何一个关卡。
- en: In the next section, you’ll combine a `for` loop and the `random()` function
    to create interesting tile arrangements.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，你将结合 `for` 循环和 `random()` 函数来创建有趣的瓷砖排列。
- en: Truchet Tiles
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Truchet 瓷砖
- en: Sébastien Truchet (1657–1729), a French Dominican priest, was active in the
    fields of mathematics, hydraulics, graphics, and typography. Among his many contributions,
    he developed a scheme for creating interesting patterns using tiles, which have
    since become known as *Truchet tiles*. The original Truchet tile is square and
    divided by a diagonal line between its opposing corners. This tile can be rotated
    in multiples of 90 degrees to produce four variants, as shown in [Figure 5-12](#figure5-12).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![f05012](image_fi/500969c05/f05012.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-12: A Truchet tile, presented in its four possible orientations'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: These tiles are arranged on a square grid, either randomly or according to a
    pattern, to create aesthetically pleasing designs. [Figure 5-13](#figure5-13)
    presents just four possible arrangements, including a randomized tiling (bottom
    right) with some ordered approaches.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![f05013](image_fi/500969c05/f05013.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-13: Four Truchet tile layouts'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll use the quarter-circle Truchet tile, shown in [Figure 5-14](#figure5-14),
    in its two possible orientations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply the looping and randomness techniques you learned in this chapter
    to create different patterns using this tile. Create a new sketch and save it
    as *truchet_tiles*. Add the following setup code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The new sketch has a blue background. Every shape you draw will have no fill
    and a white stroke of 3 pixels. This is for drawing the quarter-circle designs
    shown in [Figure 5-14](#figure5-14). Each tile is 50 × 50 pixels, so there’s room
    for exactly 12 (600 ÷ 50) columns and 12 rows. Filling the display window, therefore,
    requires 144 (12 × 12) tiles, hence the `range(1, 145)`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![f05014](image_fi/500969c05/f05014.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-14: Quarter-circle Truchet tiles'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Run the sketch. A single tile should appear in the upper left corner ([Figure
    5-15](#figure5-15)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![f05015](image_fi/500969c05/f05015.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-15: All 144 tiles placed in the upper left corner'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In actuality, in [Figure 5-15](#figure5-15), you’re looking at all 144 tiles
    placed in the same position!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'To control the column and row positioning, use `col` and `row` variables. Amend
    your script as per the boldface code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With each iteration of the loop, the `col` variable (tile y-coordinate) is increased
    by `50`. The result should be that each tile is placed to the right of its predecessor,
    as shown in [Figure 5-16](#figure5-16).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![f05016](image_fi/500969c05/f05016.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-16: The remaining 132 tiles lie beyond the right edge.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a problem, though: the program doesn’t know when to return to the left
    edge and begin a new row. Instead, the tiles overflow, extending out beyond the
    right edge where you cannot see them.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'To correct this, nest an `if` statement within the loop:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `i % 12` will return 0 for any value of `i` divisible by 12\. In other words,
    if the remainder of a divide-by-12 operation is equal to 0, you know that you’ve
    just laid another 12 tiles. At this moment, the `row` variable is advanced by
    50, and the `col` resets to 0\. The next tile is now set up for placement at the
    beginning of a new row, which should result in a display window filled with tiles
    ([Figure 5-17](#figure5-17)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![f05017](image_fi/500969c05/f05017.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-17: The display window filled with quarter-circle Truchet tiles'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things more interesting, randomize the orientation of each tile by
    adding this `if...else` structure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A `random(2)` function 1 will return a floating-point value ranging from 0 up
    to but not including 2\. Converting the result to an integer by wrapping it in
    an `int()`, therefore, produces a 0 or 1\. This is akin to flipping a coin, which
    is now performed with each iteration to decide which of the two tile orientations
    to pick. Because this “coin flip” operation returns a Boolean-compatible value—a
    0 or 1—it can stand alone as the `if` statement’s condition, no relational operators
    necessary. The `else` code 2 runs if the result of the coin flip is a 0, because
    a `0` is equivalent to `False` (and `if` runs only on a `True`).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Each time you run the sketch, the display window presents a different pattern
    ([Figure 5-18](#figure5-18)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![f05018](image_fi/500969c05/f05018.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-18: An arrangement of randomized quarter-circle Truchet tiles'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever played the strategy game *Trax*, this pattern will look familiar.
    Another tile-based strategy game, *Tantrix*, uses a hexagonal adaptation of a
    Truchet tile. Of course, there’s far more to tiles than the Truchet variety. You
    can try adding fills, switching out semicircles for diagonal lines, adding extra
    tiles to the set, or adding rules about which tiles can be placed next to one
    another ([Figure 5-19](#figure5-19)). If you’re looking for some fun projects,
    plenty of tiling patterns are available for inspiration.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![f05019](image_fi/500969c05/f05019.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-19: Variations of Truchet tiles'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: You can find code for some Truchet tile variations at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/truchet_tiles_variations](https://github.com/tabreturn/processing.py-book/tree/master/chapter-05-iteration_and_randomness/truchet_tiles_variations).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: As your programs grow more complex, you’ll find multiple ways to code the same
    outcome. For example, you could have laid the quarter-circle Truchet tiles by
    using a loop within a loop, using `range()` functions with a step-size argument,
    in various combinations. Among the Truchet tile variations on Github, you’ll find
    an example named *loop_within_a_loop* that uses this approach. Now that you understand
    control flow, you can begin thinking about how to optimize your algorithms for
    improved readability and efficiency.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve now learned about iteration and how to program loops using `while` and
    `for` statements; this allows you to accomplish more in fewer lines of code, with
    code that’s more adaptable. Loops will reappear throughout the course of this
    book, providing plenty more opportunities for you to master them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经学习了迭代以及如何使用`while`和`for`语句编写循环；这让您能够用更少的代码行完成更多的任务，且代码更加灵活。循环将在本书的后续章节中不断出现，为您提供更多掌握它们的机会。
- en: This chapter also introduced randomness, which is useful in a variety of computing
    applications, including creative coding. The Processing `random()` function generates
    sequences of pseudorandom numbers, which you can control using a random seed in
    order to produce the same sequence of values each time you run your sketch.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了随机性，它在各种计算应用中都很有用，包括创意编程。Processing 的`random()`函数生成伪随机数序列，您可以通过使用随机种子来控制这些序列，从而确保每次运行草图时产生相同的值序列。
- en: The next chapter deals with motion. You’ll learn how to add movement to your
    Processing sketches, and you’ll also look at transformation functions as efficient
    ways to move, rotate, and scale your elements, which is especially useful for
    groups of shapes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍运动。您将学习如何为您的Processing草图添加运动，同时也会学习变换函数，作为高效的方式来移动、旋转和缩放您的元素，特别适用于一组形状。
