- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aliens!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll add aliens to *Alien Invasion*. We’ll add one alien near
    the top of the screen and then generate a whole fleet of aliens. We’ll make the
    fleet advance sideways and down, and we’ll get rid of any aliens hit by a bullet.
    Finally, we’ll limit the number of ships a player has and end the game when the
    player runs out of ships.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: As you work through this chapter, you’ll learn more about Pygame and about managing
    a large project. You’ll also learn to detect collisions between game objects,
    like bullets and aliens. Detecting collisions helps you define interactions between
    elements in your games. For example, you can confine a character inside the walls
    of a maze or pass a ball between two characters. We’ll continue to work from a
    plan that we revisit occasionally to maintain the focus of our code-writing sessions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Before we start writing new code to add a fleet of aliens to the screen, let’s
    look at the project and update our plan.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the Project
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re beginning a new phase of development on a large project, it’s always
    a good idea to revisit your plan and clarify what you want to accomplish with
    the code you’re about to write. In this chapter, we’ll do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Add a single alien to the top-left corner of the screen, with appropriate spacing
    around it.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill the upper portion of the screen with as many aliens as we can fit horizontally.
    We’ll then create additional rows of aliens until we have a full fleet.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the fleet move sideways and down until the entire fleet is shot down, an
    alien hits the ship, or an alien reaches the ground. If the entire fleet is shot
    down, we’ll create a new fleet. If an alien hits the ship or the ground, we’ll
    destroy the ship and create a new fleet.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the number of ships the player can use, and end the game when the player
    has used up the allotted number of ships.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll refine this plan as we implement features, but this is specific enough
    to start writing code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: You should also review your existing code when you begin working on a new series
    of features in a project. Because each new phase typically makes a project more
    complex, it’s best to clean up any cluttered or inefficient code. We’ve been refactoring
    as we go, so there isn’t any code that we need to refactor at this point.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Creating the First Alien
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Placing one alien on the screen is like placing a ship on the screen. Each alien’s
    behavior is controlled by a class called `Alien`, which we’ll structure like the
    `Ship` class. We’ll continue using bitmap images for simplicity. You can find
    your own image for an alien or use the one shown in [Figure 13-1](#figure13-1),
    which is available in the book’s resources at [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e).
    This image has a gray background, which matches the screen’s background color.
    Make sure you save the image file you choose in the *images* folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c13/f13001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: The alien we’ll use to build the fleet'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Alien Class
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll write the `Alien` class and save it as *alien.py*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**alien.py**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most of this class is like the `Ship` class, except for the alien’s placement
    on the screen. We initially place each alien near the top-left corner of the screen;
    we add a space to the left of it that’s equal to the alien’s width and a space
    above it equal to its height ❶, so it’s easy to see. We’re mainly concerned with
    the aliens’ horizontal speed, so we’ll track the horizontal position of each alien
    precisely ❷.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: This `Alien` class doesn’t need a method for drawing it to the screen; instead,
    we’ll use a Pygame group method that automatically draws all the elements of a
    group to the screen.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Instance of the Alien
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want to create an instance of `Alien` so we can see the first alien on the
    screen. Because it’s part of our setup work, we’ll add the code for this instance
    at the end of the `__init__()` method in `AlienInvasion`. Eventually, we’ll create
    an entire fleet of aliens, which will be quite a bit of work, so we’ll make a
    new helper method called `_create_fleet()`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The order of methods in a class doesn’t matter, as long as there’s some consistency
    to how they’re placed. I’ll place `_create_fleet()` just before the `_update_screen()`
    method, but anywhere in `AlienInvasion` will work. First, we’ll import the `Alien`
    class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the updated `import` statements for *alien_invasion.py*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And here’s the updated `__init__()` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We create a group to hold the fleet of aliens, and we call `_create_fleet()`,
    which we’re about to write.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the new `_create_fleet()` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this method, we’re creating one instance of `Alien` and then adding it to
    the group that will hold the fleet. The alien will be placed in the default upper-left
    area of the screen.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the alien appear, we need to call the group’s `draw()` method in `_update_screen()`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you call `draw()` on a group, Pygame draws each element in the group at
    the position defined by its `rect` attribute. The `draw()` method requires one
    argument: a surface on which to draw the elements from the group. [Figure 13-2](#figure13-2)
    shows the first alien on the screen.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c13/f13002.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: The first alien appears.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Now that the first alien appears correctly, we’ll write the code to draw an
    entire fleet.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Building the Alien Fleet
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To draw a fleet, we need to figure out how to fill the upper portion of the
    screen with aliens, without overcrowding the game window. There are a number of
    ways to accomplish this goal. We’ll approach it by adding aliens across the top
    of the screen, until there’s no space left for a new alien. Then we’ll repeat
    this process, as long as we have enough vertical space to add a new row.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Row of Aliens
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’re ready to generate a full row of aliens. To make a full row, we’ll
    first make a single alien so we have access to the alien’s width. We’ll place
    an alien on the left side of the screen and then keep adding aliens until we run
    out of space:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We get the alien’s width from the first alien we created, and then define a
    variable called `current_x` ❶. This refers to the horizontal position of the next
    alien we intend to place on the screen. We initially set this to one alien width,
    to offset the first alien in the fleet from the left edge of the screen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we begin the `while` loop ❷; we’re going to keep adding aliens *while*
    there’s enough room to place one. To determine whether there’s room to place another
    alien, we’ll compare `current_x` to some maximum value. A first attempt at defining
    this loop might look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This seems like it might work, but it would place the final alien in the row
    at the far-right edge of the screen. So we add a little margin on the right side
    of the screen. As long as there’s at least two alien widths’ worth of space at
    the right edge of the screen, we enter the loop and add another alien to the fleet.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever there’s enough horizontal space to continue the loop, we want to do
    two things: create an alien at the correct position, and define the horizontal
    position of the next alien in the row. We create an alien and assign it to `new_alien`
    ❸. Then we set the precise horizontal position to the current value of `current_x`
    ❹. We also position the alien’s `rect` at this same *x*-value, and add the new
    alien to the group `self.aliens`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we increment the value of `current_x` ❺. We add two alien widths to
    the horizontal position, to move past the alien we just added and to leave some
    space between the aliens as well. Python will re-evaluate the condition at the
    start of the `while` loop and decide if there’s room for another alien. When there’s
    no room left, the loop will end, and we should have a full row of aliens.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: When you run *Alien Invasion* now, you should see the first row of aliens appear,
    as in [Figure 13-3](#figure13-3).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c13/f13003.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: The first row of aliens'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring _create_fleet()
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the code we’ve written so far was all we needed to create a fleet, we’d
    probably leave `_create_fleet()` as is. But we have more work to do, so let’s
    clean up the method a bit. We’ll add a new helper method, `_create_alien()`, and
    call it from `_create_fleet()`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The method `_create_alien()` requires one parameter in addition to `self`:
    the *x*-value that specifies where the alien should be placed ❶. The code in the
    body of `_create_alien()` is the same code that was in `_create_fleet()`, except
    we use the parameter name `x_position` in place of `current_x`. This refactoring
    will make it easier to add new rows and create an entire fleet.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Adding Rows
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To finish the fleet, we’ll keep adding more rows until we run out of room. We’ll
    use a nested loop—we’ll wrap another `while` loop around the current one. The
    inner loop will place aliens horizontally in a row by focusing on the aliens’
    *x*-values. The outer loop will place aliens vertically by focusing on the *y*-values.
    We’ll stop adding rows when we get near the bottom of the screen, leaving enough
    space for the ship and some room to start firing at the aliens.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成舰队的创建，我们将不断添加更多的行，直到没有空间为止。我们将使用嵌套循环——在当前的`while`循环外再包裹一个循环。内层循环通过关注外星人的*
    x *坐标，将外星人横向放置在一行中。外层循环通过关注* y *坐标，将外星人纵向放置。我们将在接近屏幕底部时停止添加行，留出足够的空间给飞船并留有一些空间来开始向外星人开火。
- en: 'Here’s how to nest the two `while` loops in `_create_fleet()`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在`_create_fleet()`中嵌套两个`while`循环的：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ll need to know the alien’s height in order to place rows, so we grab the
    alien’s width and height using the `size` attribute of an alien `rect` ❶. A `rect`’s
    `size` attribute is a tuple containing its width and height.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道外星人的高度，以便放置行，所以我们通过外星人`rect`的`size`属性来获取外星人的宽度和高度 ❶。一个`rect`的`size`属性是一个包含其宽度和高度的元组。
- en: Next, we set the initial *x*- and *y*-values for the placement of the first
    alien in the fleet ❷. We place it one alien width in from the left and one alien
    height down from the top. Then we define the `while` loop that controls how many
    rows are placed onto the screen ❸. As long as the *y*-value for the next row is
    less than the screen height, minus three alien heights, we’ll keep adding rows.
    (If this doesn’t leave the right amount of space, we can adjust it later.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为舰队中第一个外星人的放置设置初始的* x *和* y *坐标 ❷。我们将其放置在离左边一外星人宽度的位置，并向下放置一个外星人高度的距离。然后我们定义一个`while`循环来控制有多少行外星人被放置到屏幕上
    ❸。只要下一行的* y *坐标小于屏幕高度减去三倍外星人高度，我们就会继续添加行。（如果这没有留下足够的空间，我们可以稍后调整。）
- en: We call `_create_alien()`, and pass it the *y*-value as well as its *x*-position
    ❹. We’ll modify `_create_alien()` in a moment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`_create_alien()`并传递* y *坐标以及其* x *位置 ❹。稍后我们会修改`_create_alien()`方法。
- en: Notice the indentation of the last two lines of code ❺. They’re inside the outer
    `while` loop, but outside the inner `while` loop. This block runs after the inner
    loop is finished; it runs once after each row is created. After each row has been
    added, we reset the value of `current_x` so the first alien in the next row will
    be placed at the same position as the first alien in the previous rows. Then we
    add two alien heights to the current value of `current_y`, so the next row will
    be placed further down the screen. Indentation is really important here; if you
    don’t see the correct fleet when you run *alien_invasion.py* at the end of this
    section, check the indentation of all the lines in these nested loops.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后两行代码的缩进 ❺。它们位于外层`while`循环内，但在内层`while`循环外。这段代码在内层循环完成后运行；每添加一行后它就执行一次。每添加一行后，我们重置`current_x`的值，以便下一行的第一个外星人放置在与上一行的第一个外星人相同的位置。然后我们将`current_y`的当前值加上两个外星人高度，这样下一行就会放得更低。缩进在这里非常重要；如果在本节末尾运行`alien_invasion.py`时看不到正确的舰队，请检查这些嵌套循环中所有行的缩进。
- en: 'We need to modify `_create_alien()` to set the vertical position of the alien
    correctly:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`_create_alien()`方法来正确设置外星人的垂直位置：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We modify the definition of the method to accept the *y*-value for the new alien,
    and we set the vertical position of the `rect` in the body of the method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改方法的定义，使其接受新外星人的* y *坐标，并在方法体内设置`rect`的垂直位置。
- en: When you run the game now, you should see a full fleet of aliens, as shown in
    [Figure 13-4](#figure13-4).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行游戏时，你应该能看到一个完整的外星人舰队，如[图 13-4](#figure13-4)所示。
- en: '![](image_fi/502703c13/f13004.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c13/f13004.png)'
- en: 'Figure 13-4: The full fleet appears.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-4：完整的舰队出现了。
- en: In the next section, we’ll make the fleet move!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将让舰队开始移动！
- en: Making the Fleet Move
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让舰队移动
- en: Now let’s make the fleet of aliens move to the right across the screen until
    it hits the edge, and then make it drop a set amount and move in the other direction.
    We’ll continue this movement until all aliens have been shot down, one collides
    with the ship, or one reaches the bottom of the screen. Let’s begin by making
    the fleet move to the right.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让外星人舰队向右移动，直到碰到屏幕边缘，然后向下移动一定的距离并朝相反方向移动。我们将继续这个移动，直到所有外星人被击败、其中一个与飞船碰撞，或者某个外星人到达屏幕底部。我们先从让舰队向右移动开始。
- en: Moving the Aliens Right
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让外星人向右移动
- en: 'To move the aliens, we’ll use an `update()` method in *alien.py*, which we’ll
    call for each alien in the group of aliens. First, add a setting to control the
    speed of each alien:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then use this setting to implement `update()` in *alien.py*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**alien.py**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We create a `settings` parameter in `__init__()` so we can access the alien’s
    speed in `update()`. Each time we update an alien’s position, we move it to the
    right by the amount stored in `alien_speed`. We track the alien’s exact position
    with the `self.x` attribute, which can hold float values ❶. We then use the value
    of `self.x` to update the position of the alien’s `rect` ❷.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main `while` loop, we already have calls to update the ship and bullet
    positions. Now we’ll add a call to update the position of each alien as well:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’re about to write some code to manage the movement of the fleet, so we create
    a new method called `_update_aliens()`. We update the aliens’ positions after
    the bullets have been updated, because we’ll soon be checking to see whether any
    bullets hit any aliens.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Where you place this method in the module is not critical. But to keep the
    code organized, I’ll place it just after `_update_bullets()` to match the order
    of method calls in the `while` loop. Here’s the first version of `_update_aliens()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `update()` method on the `aliens` group, which calls each alien’s
    `update()` method. When you run *Alien Invasion* now, you should see the fleet
    move right and disappear off the side of the screen.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Creating Settings for Fleet Direction
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll create the settings that will make the fleet move down the screen
    and to the left when it hits the right edge of the screen. Here’s how to implement
    this behavior:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The setting `fleet_drop_speed` controls how quickly the fleet drops down the
    screen each time an alien reaches either edge. It’s helpful to separate this speed
    from the aliens’ horizontal speed so you can adjust the two speeds independently.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: To implement the setting `fleet_direction`, we could use a text value such as
    `'left'` or `'right'`, but we’d end up with `if`-`elif` statements testing for
    the fleet direction. Instead, because we only have two directions to deal with,
    let’s use the values 1 and −1 and switch between them each time the fleet changes
    direction. (Using numbers also makes sense because moving right involves adding
    to each alien’s *x*-coordinate value, and moving left involves subtracting from
    each alien’s *x*-coordinate value.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Checking Whether an Alien Has Hit the Edge
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need a method to check whether an alien is at either edge, and we need to
    modify `update()` to allow each alien to move in the appropriate direction. This
    code is part of the `Alien` class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**alien.py**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can call the new method `check_edges()` on any alien to see whether it’s
    at the left or right edge. The alien is at the right edge if the `right` attribute
    of its `rect` is greater than or equal to the `right` attribute of the screen’s
    `rect`. It’s at the left edge if its `left` value is less than or equal to 0 ❶.
    Rather than put this conditional test in an `if` block, we put the test directly
    in the `return` statement. This method will return `True` if the alien is at the
    right or left edge, and `False` if it is not at either edge.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对任何外星人调用新的`check_edges()`方法，查看它是否位于左侧或右侧边缘。如果外星人的`rect`的`right`属性大于或等于屏幕`rect`的`right`属性，则它位于右边缘。如果它的`left`值小于或等于0
    ❶，则它位于左边缘。我们没有把这个条件判断放在`if`语句块中，而是直接把判断放在了`return`语句中。这个方法会在外星人位于右边缘或左边缘时返回`True`，否则返回`False`。
- en: We modify the method `update()` to allow motion to the left or right by multiplying
    the alien’s speed by the value of `fleet_direction` ❷. If `fleet_direction` is
    1, the value of `alien_speed` will be added to the alien’s current position, moving
    the alien to the right; if `fleet_direction` is −1, the value will be subtracted
    from the alien’s position, moving the alien to the left.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了`update()`方法，允许外星人向左或向右移动，方法是将外星人的速度乘以`fleet_direction`的值 ❷。如果`fleet_direction`为1，外星人的当前位置会加上`alien_speed`的值，外星人向右移动；如果`fleet_direction`为−1，值会从外星人的位置中减去，外星人向左移动。
- en: Dropping the Fleet and Changing Direction
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 舰队下降并改变方向
- en: When an alien reaches the edge, the entire fleet needs to drop down and change
    direction. Therefore, we need to add some code to `AlienInvasion` because that’s
    where we’ll check whether any aliens are at the left or right edge. We’ll make
    this happen by writing the methods `_check_fleet_edges()` and `_change_fleet_direction()`,
    and then modifying `_update_aliens()`. I’ll put these new methods after `_create_alien()`,
    but again, the placement of these methods in the class isn’t critical.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当外星人到达屏幕边缘时，整个舰队需要下降并改变方向。因此，我们需要在`AlienInvasion`中添加一些代码，因为我们将在这里检查是否有外星人处于左侧或右侧边缘。我们将通过编写`_check_fleet_edges()`和`_change_fleet_direction()`方法来实现这一点，然后修改`_update_aliens()`。我会把这些新方法放在`_create_alien()`之后，但方法在类中的位置并不重要。
- en: '**alien_invasion.py**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In `_check_fleet_edges()`, we loop through the fleet and call `check_edges()`
    on each alien ❶. If `check_edges()` returns `True`, we know an alien is at an
    edge and the whole fleet needs to change direction; so we call `_change_fleet_direction()`
    and break out of the loop ❷. In `_change_fleet_direction()`, we loop through all
    the aliens and drop each one using the setting `fleet_drop_speed` ❸; then we change
    the value of `fleet_direction` by multiplying its current value by −1\. The line
    that changes the fleet’s direction isn’t part of the `for` loop. We want to change
    each alien’s vertical position, but we only want to change the direction of the
    fleet once.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_check_fleet_edges()`中，我们遍历整个舰队，并对每个外星人调用`check_edges()` ❶。如果`check_edges()`返回`True`，我们就知道有外星人处于边缘，整个舰队需要改变方向；因此，我们调用`_change_fleet_direction()`并跳出循环
    ❷。在`_change_fleet_direction()`中，我们遍历所有外星人并使用`fleet_drop_speed`设置让它们下降 ❸；然后我们将`fleet_direction`的值乘以−1来改变方向。改变舰队方向的那一行代码不是`for`循环的一部分。我们希望改变每个外星人的垂直位置，但只希望改变舰队的方向一次。
- en: 'Here are the changes to `_update_aliens()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`_update_aliens()`的修改：
- en: '**alien_invasion.py**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve modified the method by calling `_check_fleet_edges()` before updating
    each alien’s position.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在更新每个外星人位置之前调用`_check_fleet_edges()`方法来修改了这个方法。
- en: When you run the game now, the fleet should move back and forth between the
    edges of the screen and drop down every time it hits an edge. Now we can start
    shooting down aliens and watch for any aliens that hit the ship or reach the bottom
    of the screen.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行游戏时，舰队应该会在屏幕的边缘之间来回移动，每次碰到边缘时就会下降。现在我们可以开始射击外星人，并观察任何碰到飞船或到达屏幕底部的外星人。
- en: Shooting Aliens
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射击外星人
- en: We’ve built our ship and a fleet of aliens, but when the bullets reach the aliens,
    they simply pass through because we aren’t checking for collisions. In game programming,
    *collisions* happen when game elements overlap. To make the bullets shoot down
    aliens, we’ll use the function `sprite.groupcollide()` to look for collisions
    between members of two groups.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建造了我们的飞船和一支外星人舰队，但当子弹击中外星人时，它们会直接穿透过去，因为我们没有检测碰撞。在游戏编程中，*碰撞*发生在游戏元素重叠时。为了让子弹击落外星人，我们将使用`sprite.groupcollide()`函数来检查两个组成员之间的碰撞。
- en: Detecting Bullet Collisions
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测子弹碰撞
- en: We want to know right away when a bullet hits an alien so we can make an alien
    disappear as soon as it’s hit. To do this, we’ll look for collisions immediately
    after updating the position of all the bullets.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在子弹击中外星人时立即得知，这样我们就能在外星人被击中时立即让它消失。为此，我们将在更新所有子弹的位置后，立即检查碰撞。
- en: The `sprite.groupcollide()` function compares the `rect`s of each element in
    one group with the `rect`s of each element in another group. In this case, it
    compares each bullet’s `rect` with each alien’s `rect` and returns a dictionary
    containing the bullets and aliens that have collided. Each key in the dictionary
    will be a bullet, and the corresponding value will be the alien that was hit.
    (We’ll also use this dictionary when we implement a scoring system in Chapter
    14.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`sprite.groupcollide()`函数将一个组中每个元素的`rect`与另一个组中每个元素的`rect`进行比较。在这种情况下，它将每颗子弹的`rect`与每个外星人的`rect`进行比较，并返回一个包含发生碰撞的子弹和外星人的字典。字典中的每个键将是一个子弹，而对应的值将是被击中的外星人。（我们将在第14章实现评分系统时使用这个字典。）'
- en: 'Add the following code to the end of `_update_bullets()` to check for collisions
    between bullets and aliens:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`_update_bullets()`的末尾，以检查子弹与外星人之间的碰撞：
- en: '**alien_invasion.py**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The new code we added compares the positions of all the bullets in `self.bullets`
    and all the aliens in `self.aliens`, and identifies any that overlap. Whenever
    the `rect`s of a bullet and alien overlap, `groupcollide()` adds a key-value pair
    to the dictionary it returns. The two `True` arguments tell Pygame to delete the
    bullets and aliens that have collided. (To make a high-powered bullet that can
    travel to the top of the screen, destroying every alien in its path, you could
    set the first Boolean argument to `False` and keep the second Boolean argument
    set to `True`. The aliens hit would disappear, but all bullets would stay active
    until they disappeared off the top of the screen.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的新代码比较了`self.bullets`中所有子弹和`self.aliens`中所有外星人的位置，并识别出任何重叠的部分。每当子弹和外星人的`rect`重叠时，`groupcollide()`会将一个键值对添加到它返回的字典中。两个`True`参数告诉Pygame删除已经碰撞的子弹和外星人。（要制作一颗可以穿越屏幕顶部并摧毁其路径上所有外星人的高能子弹，你可以将第一个布尔参数设置为`False`，并将第二个布尔参数保持为`True`。被击中的外星人会消失，但所有子弹会一直保持活动状态，直到它们消失在屏幕顶部。）
- en: When you run *Alien Invasion* now, aliens you hit should disappear. [Figure
    13-5](#figure13-5) shows a fleet that has been partially shot down.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行*外星人入侵*时，击中的外星人应该会消失。[图 13-5](#figure13-5)展示了一个部分被击落的舰队。
- en: '![](image_fi/502703c13/f13005.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c13/f13005.png)'
- en: 'Figure 13-5: We can shoot aliens!'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-5：我们可以击落外星人！
- en: Making Larger Bullets for Testing
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为测试制作更大的子弹
- en: You can test many features of *Alien Invasion* simply by running the game, but
    some features are tedious to test in the normal version of the game. For example,
    it’s a lot of work to shoot down every alien on the screen multiple times to test
    whether your code responds to an empty fleet correctly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行游戏来测试*外星人入侵*的许多功能，但某些功能在游戏的正常版本中测试起来很繁琐。例如，测试代码是否正确响应空舰队时，必须多次击落屏幕上的每个外星人，这是一项繁重的工作。
- en: To test particular features, you can change certain game settings to focus on
    a particular area. For example, you might shrink the screen so there are fewer
    aliens to shoot down or increase the bullet speed and give yourself lots of bullets
    at once.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试特定功能，你可以更改某些游戏设置以集中测试特定区域。例如，你可以缩小屏幕，使需要击落的外星人更少，或增加子弹速度并一次性给予自己许多子弹。
- en: My favorite change for testing *Alien Invasion* is to use really wide bullets
    that remain active even after they’ve hit an alien (see [Figure 13-6](#figure13-6)).
    Try setting `bullet_width` to 300, or even 3,000, to see how quickly you can shoot
    down the fleet!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我测试*外星人入侵*时最喜欢的更改是使用非常宽的子弹，即使它们击中外星人后仍保持活动状态（见[图 13-6](#figure13-6)）。试试将`bullet_width`设置为300，甚至3,000，看看你能多快击落舰队！
- en: '![](image_fi/502703c13/f13006.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c13/f13006.png)'
- en: 'Figure 13-6: Extra-powerful bullets make some aspects of the game easier to
    test.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-6：超强子弹使游戏中的某些方面更容易进行测试。
- en: Changes like these will help you test the game more efficiently and possibly
    spark ideas for giving players bonus powers. Just remember to restore the settings
    to normal when you’re finished testing a feature.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的更改将帮助你更高效地测试游戏，并可能激发为玩家提供额外能力的创意。只需记得在测试完某个功能后，将设置恢复到正常状态。
- en: Repopulating the Fleet
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新填充舰队
- en: 'One key feature of *Alien Invasion* is that the aliens are relentless: every
    time the fleet is destroyed, a new fleet should appear.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*外星入侵*的一个关键特点是外星人是无情的：每当舰队被摧毁时，新的舰队应当出现。'
- en: To make a new fleet of aliens appear after a fleet has been destroyed, we first
    check whether the `aliens` group is empty. If it is, we make a call to `_create_fleet()`.
    We’ll perform this check at the end of `_update_bullets()`, because that’s where
    individual aliens are destroyed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在舰队被摧毁后让新的外星舰队出现，我们首先检查`aliens`组是否为空。如果为空，我们会调用`_create_fleet()`。我们将在`_update_bullets()`的最后进行此检查，因为那是个别外星人被摧毁的地方。
- en: '**alien_invasion.py**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We check whether the `aliens` group is empty ❶. An empty group evaluates to
    `False`, so this is a simple way to check whether the group is empty. If it is,
    we get rid of any existing bullets by using the `empty()` method, which removes
    all the remaining sprites from a group ❷. We also call `_create_fleet()`, which
    fills the screen with aliens again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查`aliens`组是否为空 ❶。一个空的组会被评估为`False`，所以这是一种简单的方法来检查组是否为空。如果为空，我们通过使用`empty()`方法清除所有现有的子弹，该方法会从组中移除所有剩余的精灵
    ❷。我们还会调用`_create_fleet()`，重新填充屏幕上的外星人。
- en: Now a new fleet appears as soon as you destroy the current fleet.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦你摧毁当前舰队，新的舰队就会出现。
- en: Speeding Up the Bullets
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加速子弹
- en: If you’ve tried firing at the aliens in the game’s current state, you might
    find that the bullets aren’t traveling at the best speed for gameplay. They might
    be a little too slow or a little too fast. At this point, you can modify the settings
    to make the gameplay more interesting. Keep in mind that the game is going to
    get progressively faster, so don’t make the game too fast at the beginning.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试过在当前状态下向外星人开火，你可能会发现子弹的速度不适合游戏玩法。它们可能有些太慢，或者有些太快。此时，你可以修改设置，使游戏玩法更有趣。请记住，游戏会逐渐加速，所以开始时不要让游戏速度过快。
- en: 'We modify the speed of the bullets by adjusting the value of `bullet_speed`
    in *settings.py*. On my system, I’ll adjust the value of `bullet_speed` to 2.5,
    so the bullets travel a little faster:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调整*settings.py*中`bullet_speed`的值来修改子弹的速度。在我的系统上，我将`bullet_speed`的值调整为2.5，这样子弹会稍微快一点：
- en: '**settings.py**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The best value for this setting depends on your experience of the game, so find
    a value that works for you. You can adjust other settings as well.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置的最佳值取决于你对游戏的经验，因此需要找到适合你的值。你还可以调整其他设置。
- en: Refactoring _update_bullets()
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构_update_bullets()
- en: 'Let’s refactor `_update_bullets()` so it’s not doing so many different tasks.
    We’ll move the code for dealing with bullet-alien collisions to a separate method:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构`_update_bullets()`，让它不再做这么多不同的任务。我们将处理子弹和外星人碰撞的代码移到一个单独的方法中：
- en: '**alien_invasion.py**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’ve created a new method, `_check_bullet_alien_collisions()`, to look for
    collisions between bullets and aliens and to respond appropriately if the entire
    fleet has been destroyed. Doing so keeps `_update_bullets()` from growing too
    long and simplifies further development.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新方法`_check_bullet_alien_collisions()`，用来检查子弹和外星人之间的碰撞，并在整个舰队被摧毁时作出适当反应。这样做避免了`_update_bullets()`变得过长，并简化了后续的开发。
- en: Ending the Game
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束游戏
- en: What’s the fun and challenge in playing a game you can’t lose? If the player
    doesn’t shoot down the fleet quickly enough, we’ll have the aliens destroy the
    ship when they make contact. At the same time, we’ll limit the number of ships
    a player can use, and we’ll destroy the ship when an alien reaches the bottom
    of the screen. The game will end when the player has used up all their ships.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 玩一个无法失败的游戏有什么乐趣和挑战呢？如果玩家没有足够快地击落舰队，我们会让外星人摧毁飞船，当它们接触到飞船时。同时，我们会限制玩家可使用的飞船数量，当外星人到达屏幕底部时，飞船会被摧毁。游戏将在玩家用完所有飞船后结束。
- en: Detecting Alien-Ship Collisions
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测外星飞船碰撞
- en: 'We’ll start by checking for collisions between aliens and the ship so we can
    respond appropriately when an alien hits it. We’ll check for alien-ship collisions
    immediately after updating the position of each alien in `AlienInvasion`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从检查外星人和飞船之间的碰撞开始，以便在外星人撞击飞船时做出适当反应。我们会在更新每个外星人的位置后立即检查外星人-飞船碰撞，在`AlienInvasion`中执行：
- en: '**alien_invasion.py**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `spritecollideany()` function takes two arguments: a sprite and a group.
    The function looks for any member of the group that has collided with the sprite
    and stops looping through the group as soon as it finds one member that has collided
    with the sprite. Here, it loops through the group `aliens` and returns the first
    alien it finds that has collided with `ship`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'If no collisions occur, `spritecollideany()` returns `None` and the `if` block
    won’t execute ❶. If it finds an alien that has collided with the ship, it returns
    that alien and the `if` block executes: it prints `Ship hit!!!` ❷. When an alien
    hits the ship, we’ll need to do a number of tasks: delete all remaining aliens
    and bullets, recenter the ship, and create a new fleet. Before we write code to
    do all this, we want to know that our approach to detecting alien-ship collisions
    works correctly. Writing a `print()` call is a simple way to ensure we’re detecting
    these collisions properly.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Now when you run *Alien Invasion,* the message *Ship hit!!!* should appear in
    the terminal whenever an alien runs into the ship. When you’re testing this feature,
    set `fleet_drop_speed` to a higher value, such as 50 or 100, so the aliens reach
    your ship faster.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Responding to Alien-Ship Collisions
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we need to figure out exactly what will happen when an alien collides with
    the ship. Instead of destroying the `ship` instance and creating a new one, we’ll
    count how many times the ship has been hit by tracking statistics for the game.
    Tracking statistics will also be useful for scoring.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a new class, `GameStats`, to track game statistics, and let’s save
    it as *game_stats.py*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**game_stats.py**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We’ll make one `GameStats` instance for the entire time *Alien Invasion* is
    running, but we’ll need to reset some statistics each time the player starts a
    new game. To do this, we’ll initialize most of the statistics in the `reset_stats()`
    method, instead of directly in `__init__()`. We’ll call this method from `__init__()`
    so the statistics are set properly when the `GameStats` instance is first created
    ❶. But we’ll also be able to call `reset_stats()` anytime the player starts a
    new game. Right now we have only one statistic, `ships_left`, the value of which
    will change throughout the game.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of ships the player starts with should be stored in *settings.py*
    as `ship_limit`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to make a few changes in *alien_invasion.py* to create an instance
    of `GameStats`. First, we’ll update the `import` statements at the top of the
    file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We import the `sleep()` function from the `time` module in the Python standard
    library, so we can pause the game for a moment when the ship is hit. We also import
    `GameStats`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create an instance of `GameStats` in `__init__()`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We make the instance after creating the game window but before defining other
    game elements, such as the ship.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: When an alien hits the ship, we’ll subtract 1 from the number of ships left,
    destroy all existing aliens and bullets, create a new fleet, and reposition the
    ship in the middle of the screen. We’ll also pause the game for a moment so the
    player can notice the collision and regroup before a new fleet appears.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put most of this code in a new method called `_ship_hit()`. We’ll call
    this method from `_update_aliens()` when an alien hits the ship:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The new method `_ship_hit()` coordinates the response when an alien hits a ship.
    Inside `_ship_hit()`, the number of ships left is reduced by 1 ❶, after which
    we empty the groups `bullets` and `aliens` ❷.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a new fleet and center the ship ❸. (We’ll add the method `center_ship()`
    to `Ship` in a moment.) Then we add a pause after the updates have been made to
    all the game elements but before any changes have been drawn to the screen, so
    the player can see that their ship has been hit ❹. The `sleep()` call pauses program
    execution for half a second, long enough for the player to see that the alien
    has hit the ship. When the `sleep()` function ends, code execution moves on to
    the `_update_screen()` method, which draws the new fleet to the screen.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'In `_update_aliens()`, we replace the `print()` call with a call to `_ship_hit()`
    when an alien hits the ship:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s the new method `center_ship()`, which belongs in *ship.py*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**ship.py**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We center the ship the same way we did in `__init__()`. After centering it,
    we reset the `self.x` attribute, which allows us to track the ship’s exact position.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Run the game, shoot a few aliens, and let an alien hit the ship. The game should
    pause, and a new fleet should appear with the ship centered at the bottom of the
    screen again.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Aliens That Reach the Bottom of the Screen
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If an alien reaches the bottom of the screen, we’ll have the game respond the
    same way it does when an alien hits the ship. To check when this happens, add
    a new method in *alien_invasion.py*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The method `_check_aliens_bottom()` checks whether any aliens have reached the
    bottom of the screen. An alien reaches the bottom when its `rect.bottom` value
    is greater than or equal to the screen’s height ❶. If an alien reaches the bottom,
    we call `_ship_hit()`. If one alien hits the bottom, there’s no need to check
    the rest, so we break out of the loop after calling `_ship_hit()`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll call this method from `_update_aliens()`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We call `_check_aliens_bottom()` after updating the positions of all the aliens
    and after looking for alien-ship collisions. Now a new fleet will appear every
    time the ship is hit by an alien or an alien reaches the bottom of the screen.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Game Over!
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Alien Invasion* feels more complete now, but the game never ends. The value
    of `ships_left` just grows increasingly negative. Let’s add a `game_active` flag,
    so we can end the game when the player runs out of ships. We’ll set this flag
    at the end of the `__init__()` method in `AlienInvasion`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we add code to `_ship_hit()` that sets `game_active` to `False` when the
    player has used up all their ships:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Most of `_ship_hit()` is unchanged. We’ve moved all the existing code into an
    `if` block, which tests to make sure the player has at least one ship remaining.
    If so, we create a new fleet, pause, and move on. If the player has no ships left,
    we set `game_active` to `False`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Identifying When Parts of the Game Should Run
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to identify the parts of the game that should always run and the parts
    that should run only when the game is active:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the main loop, we always need to call `_check_events()`, even if the game
    is inactive. For example, we still need to know if the user presses Q to quit
    the game or clicks the button to close the window. We also continue updating the
    screen so we can make changes to the screen while waiting to see whether the player
    chooses to start a new game. The rest of the function calls need to happen only
    when the game is active, because when the game is inactive, we don’t need to update
    the positions of game elements.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Now when you play *Alien Invasion*, the game should freeze when you’ve used
    up all your ships.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to add a large number of identical elements
    to a game by creating a fleet of aliens. You used nested loops to create a grid
    of elements, and you made a large set of game elements move by calling each element’s
    `update()` method. You learned to control the direction of objects on the screen
    and to respond to specific situations, such as when the fleet reaches the edge
    of the screen. You detected and responded to collisions when bullets hit aliens
    and aliens hit the ship. You also learned how to track statistics in a game and
    use a `game_active` flag to determine when the game is over.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter of this project, we’ll add a Play button so the
    player can choose when to start their first game and whether to play again when
    the game ends. We’ll speed up the game each time the player shoots down the entire
    fleet, and we’ll add a scoring system. The final result will be a fully playable
    game!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
