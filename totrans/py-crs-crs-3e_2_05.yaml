- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Aliens!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 外星人！
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In this chapter, we’ll add aliens to *Alien Invasion*. We’ll add one alien near
    the top of the screen and then generate a whole fleet of aliens. We’ll make the
    fleet advance sideways and down, and we’ll get rid of any aliens hit by a bullet.
    Finally, we’ll limit the number of ships a player has and end the game when the
    player runs out of ships.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向*外星人入侵*游戏中添加外星人。我们将在屏幕的顶部附近添加一个外星人，然后生成一整队外星人。我们将使这支舰队向横向和纵向移动，并且在外星人被子弹击中时将其移除。最后，我们将限制玩家可使用的飞船数量，并在玩家用完所有飞船时结束游戏。
- en: As you work through this chapter, you’ll learn more about Pygame and about managing
    a large project. You’ll also learn to detect collisions between game objects,
    like bullets and aliens. Detecting collisions helps you define interactions between
    elements in your games. For example, you can confine a character inside the walls
    of a maze or pass a ball between two characters. We’ll continue to work from a
    plan that we revisit occasionally to maintain the focus of our code-writing sessions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的过程中，你将学到更多关于Pygame的知识，以及如何管理一个大型项目。你还将学到如何检测游戏对象之间的碰撞，比如子弹和外星人。检测碰撞帮助你定义游戏中元素之间的互动。例如，你可以把角色限制在迷宫的墙壁内，或者在两个角色之间传递一个球。我们将继续遵循一个偶尔会重新审视的计划，以保持我们编写代码时的专注。
- en: Before we start writing new code to add a fleet of aliens to the screen, let’s
    look at the project and update our plan.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写新代码，向屏幕添加外星人舰队之前，让我们先看看项目并更新我们的计划。
- en: Reviewing the Project
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾项目
- en: 'When you’re beginning a new phase of development on a large project, it’s always
    a good idea to revisit your plan and clarify what you want to accomplish with
    the code you’re about to write. In this chapter, we’ll do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在大型项目中开始一个新的开发阶段时，重新审视你的计划并明确你想要通过编写的代码实现什么目标总是一个好主意。在本章中，我们将进行以下操作：
- en: Add a single alien to the top-left corner of the screen, with appropriate spacing
    around it.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕的左上角添加一个外星人，并确保周围有适当的间距。
- en: Fill the upper portion of the screen with as many aliens as we can fit horizontally.
    We’ll then create additional rows of aliens until we have a full fleet.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填满屏幕上方的区域，尽可能水平地排列多个外星人。然后我们将继续创建额外的外星人行，直到形成一支完整的舰队。
- en: Make the fleet move sideways and down until the entire fleet is shot down, an
    alien hits the ship, or an alien reaches the ground. If the entire fleet is shot
    down, we’ll create a new fleet. If an alien hits the ship or the ground, we’ll
    destroy the ship and create a new fleet.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让舰队横向和纵向移动，直到整个舰队被击落、外星人撞到飞船，或外星人到达地面。如果整个舰队被击落，我们将创建一个新的舰队。如果外星人撞到飞船或地面，我们将摧毁飞船并创建一个新的舰队。
- en: Limit the number of ships the player can use, and end the game when the player
    has used up the allotted number of ships.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制玩家可以使用的飞船数量，并在玩家用尽所有飞船时结束游戏。
- en: We’ll refine this plan as we implement features, but this is specific enough
    to start writing code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在实现功能时完善这个计划，但这个计划已经足够具体，足以开始编写代码。
- en: You should also review your existing code when you begin working on a new series
    of features in a project. Because each new phase typically makes a project more
    complex, it’s best to clean up any cluttered or inefficient code. We’ve been refactoring
    as we go, so there isn’t any code that we need to refactor at this point.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始为项目中的新功能编写代码时，你也应该回顾现有的代码。因为每一个新阶段通常会使项目变得更加复杂，所以最好清理任何杂乱或低效的代码。我们在进行时已经进行了重构，因此目前没有任何需要重构的代码。
- en: Creating the First Alien
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建第一个外星人
- en: Placing one alien on the screen is like placing a ship on the screen. Each alien’s
    behavior is controlled by a class called `Alien`, which we’ll structure like the
    `Ship` class. We’ll continue using bitmap images for simplicity. You can find
    your own image for an alien or use the one shown in [Figure 13-1](#figure13-1),
    which is available in the book’s resources at [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e).
    This image has a gray background, which matches the screen’s background color.
    Make sure you save the image file you choose in the *images* folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上放置一个外星人就像放置一艘飞船一样。每个外星人的行为由一个名为`Alien`的类控制，我们将像`Ship`类一样构建它。为了简化，我们将继续使用位图图像。你可以为外星人选择自己的图像，或者使用在[图13-1](#figure13-1)中显示的图像，该图像在本书的资源中可找到，网址为[https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e)。这张图像有一个灰色背景，和屏幕的背景颜色匹配。确保你将选择的图像文件保存在*images*文件夹中。
- en: '![](image_fi/502703c13/f13001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c13/f13001.png)'
- en: 'Figure 13-1: The alien we’ll use to build the fleet'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1：我们将用来建立舰队的外星人
- en: Creating the Alien Class
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建外星人类
- en: 'Now we’ll write the `Alien` class and save it as *alien.py*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写`Alien`类，并将其保存为*alien.py*：
- en: '**alien.py**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien.py**'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most of this class is like the `Ship` class, except for the alien’s placement
    on the screen. We initially place each alien near the top-left corner of the screen;
    we add a space to the left of it that’s equal to the alien’s width and a space
    above it equal to its height ❶, so it’s easy to see. We’re mainly concerned with
    the aliens’ horizontal speed, so we’ll track the horizontal position of each alien
    precisely ❷.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的大部分内容与`Ship`类相似，除了外星人在屏幕上的位置。我们最初将每个外星人放置在屏幕的左上角附近；在它的左侧添加一个与外星人宽度相等的空隙，在它的上方添加一个与外星人高度相等的空隙
    ❶，这样更容易查看。我们主要关注外星人的水平速度，因此我们将精确跟踪每个外星人的水平位置 ❷。
- en: This `Alien` class doesn’t need a method for drawing it to the screen; instead,
    we’ll use a Pygame group method that automatically draws all the elements of a
    group to the screen.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Alien`类不需要绘制它到屏幕上的方法；相反，我们将使用Pygame的组方法，它会自动将组中的所有元素绘制到屏幕上。
- en: Creating an Instance of the Alien
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建外星人实例
- en: We want to create an instance of `Alien` so we can see the first alien on the
    screen. Because it’s part of our setup work, we’ll add the code for this instance
    at the end of the `__init__()` method in `AlienInvasion`. Eventually, we’ll create
    an entire fleet of aliens, which will be quite a bit of work, so we’ll make a
    new helper method called `_create_fleet()`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想创建一个`Alien`实例，这样就可以在屏幕上看到第一个外星人。由于这属于我们的设置工作，我们会在`AlienInvasion`中的`__init__()`方法末尾添加这个实例的代码。最终，我们将创建一个完整的外星舰队，这将是相当繁重的工作，所以我们将创建一个新的辅助方法，命名为`_create_fleet()`。
- en: The order of methods in a class doesn’t matter, as long as there’s some consistency
    to how they’re placed. I’ll place `_create_fleet()` just before the `_update_screen()`
    method, but anywhere in `AlienInvasion` will work. First, we’ll import the `Alien`
    class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的方法顺序并不重要，只要它们的位置保持一致。我将把`_create_fleet()`放在`_update_screen()`方法之前，但在`AlienInvasion`类中的任何地方都可以。首先，我们将导入`Alien`类。
- en: 'Here are the updated `import` statements for *alien_invasion.py*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*alien_invasion.py*的更新`import`语句：
- en: '**alien_invasion.py**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And here’s the updated `__init__()` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新后的`__init__()`方法：
- en: '**alien_invasion.py**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We create a group to hold the fleet of aliens, and we call `_create_fleet()`,
    which we’re about to write.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个组来存放外星舰队，并调用我们即将编写的`_create_fleet()`方法。
- en: 'Here’s the new `_create_fleet()` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的`_create_fleet()`方法：
- en: '**alien_invasion.py**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this method, we’re creating one instance of `Alien` and then adding it to
    the group that will hold the fleet. The alien will be placed in the default upper-left
    area of the screen.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们创建了一个`Alien`实例，然后将其添加到存放舰队的组中。外星人将被放置在屏幕的默认左上角区域。
- en: 'To make the alien appear, we need to call the group’s `draw()` method in `_update_screen()`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让外星人出现，我们需要在`_update_screen()`中调用该组的`draw()`方法：
- en: '**alien_invasion.py**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you call `draw()` on a group, Pygame draws each element in the group at
    the position defined by its `rect` attribute. The `draw()` method requires one
    argument: a surface on which to draw the elements from the group. [Figure 13-2](#figure13-2)
    shows the first alien on the screen.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在一个组上调用`draw()`时，Pygame会在由该组的`rect`属性定义的位置绘制组内的每个元素。`draw()`方法需要一个参数：一个表面，在该表面上绘制组中的元素。[图13-2](#figure13-2)展示了屏幕上出现的第一个外星人。
- en: '![](image_fi/502703c13/f13002.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c13/f13002.png)'
- en: 'Figure 13-2: The first alien appears.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2：第一个外星人出现。
- en: Now that the first alien appears correctly, we’ll write the code to draw an
    entire fleet.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第一个外星人正确出现了，我们将编写代码来绘制整个舰队。
- en: Building the Alien Fleet
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立外星舰队
- en: To draw a fleet, we need to figure out how to fill the upper portion of the
    screen with aliens, without overcrowding the game window. There are a number of
    ways to accomplish this goal. We’ll approach it by adding aliens across the top
    of the screen, until there’s no space left for a new alien. Then we’ll repeat
    this process, as long as we have enough vertical space to add a new row.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制一支舰队，我们需要弄清楚如何在屏幕的上半部分填充外星人，而不让游戏窗口变得过于拥挤。实现这个目标有多种方法。我们将通过在屏幕顶部从左到右添加外星人，直到没有空间再添加新的外星人为止。然后，只要我们有足够的垂直空间再添加一行外星人，我们就会重复这个过程。
- en: Creating a Row of Aliens
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一行外星人
- en: 'Now we’re ready to generate a full row of aliens. To make a full row, we’ll
    first make a single alien so we have access to the alien’s width. We’ll place
    an alien on the left side of the screen and then keep adding aliens until we run
    out of space:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备生成完整的一排外星人。为了生成完整的一排，首先我们需要制作一个单独的外星人，以便获取外星人的宽度。我们将一个外星人放在屏幕的左侧，然后继续添加外星人，直到没有足够的空间为止：
- en: '**alien_invasion.py**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We get the alien’s width from the first alien we created, and then define a
    variable called `current_x` ❶. This refers to the horizontal position of the next
    alien we intend to place on the screen. We initially set this to one alien width,
    to offset the first alien in the fleet from the left edge of the screen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第一个创建的外星人中获取外星人的宽度，然后定义一个变量`current_x` ❶。它表示我们打算放置下一个外星人时的水平位置。我们最初将其设置为一个外星人的宽度，以便将舰队中的第一个外星人与屏幕的左边缘偏移。
- en: 'Next, we begin the `while` loop ❷; we’re going to keep adding aliens *while*
    there’s enough room to place one. To determine whether there’s room to place another
    alien, we’ll compare `current_x` to some maximum value. A first attempt at defining
    this loop might look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始`while`循环 ❷；我们将继续添加外星人，*只要*有足够的空间放置一个外星人。为了确定是否还有空间放置另一个外星人，我们将`current_x`与某个最大值进行比较。定义这个循环的第一次尝试可能看起来像这样：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This seems like it might work, but it would place the final alien in the row
    at the far-right edge of the screen. So we add a little margin on the right side
    of the screen. As long as there’s at least two alien widths’ worth of space at
    the right edge of the screen, we enter the loop and add another alien to the fleet.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能有效，但它会将最后一个外星人放置在屏幕的最右边。因此，我们在屏幕右侧添加了一些边距。只要屏幕右边至少有两个外星人宽度的空间，我们就会进入循环并向舰队中添加另一个外星人。
- en: 'Whenever there’s enough horizontal space to continue the loop, we want to do
    two things: create an alien at the correct position, and define the horizontal
    position of the next alien in the row. We create an alien and assign it to `new_alien`
    ❸. Then we set the precise horizontal position to the current value of `current_x`
    ❹. We also position the alien’s `rect` at this same *x*-value, and add the new
    alien to the group `self.aliens`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有足够的水平空间继续循环时，我们需要做两件事：在正确的位置创建一个外星人，并定义这一排中下一个外星人的水平位置。我们创建一个外星人并将其分配给`new_alien`
    ❸。然后我们将精确的水平位置设置为`current_x`的当前值 ❹。我们还将外星人的`rect`位置设置为这个相同的 *x* 值，并将新外星人添加到`self.aliens`组中。
- en: Finally, we increment the value of `current_x` ❺. We add two alien widths to
    the horizontal position, to move past the alien we just added and to leave some
    space between the aliens as well. Python will re-evaluate the condition at the
    start of the `while` loop and decide if there’s room for another alien. When there’s
    no room left, the loop will end, and we should have a full row of aliens.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们增加`current_x`的值 ❺。我们将水平位置增加两个外星人宽度，以便跳过刚刚添加的外星人，并且在外星人之间留出一些空隙。Python会在`while`循环开始时重新评估条件，并决定是否还有足够的空间放置另一个外星人。当没有空间时，循环结束，我们应该已经有了一整排外星人。
- en: When you run *Alien Invasion* now, you should see the first row of aliens appear,
    as in [Figure 13-3](#figure13-3).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行 *Alien Invasion* 时，你应该能看到第一排外星人出现，正如[图 13-3](#figure13-3)所示。
- en: '![](image_fi/502703c13/f13003.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c13/f13003.png)'
- en: 'Figure 13-3: The first row of aliens'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-3：第一排外星人
- en: Refactoring _create_fleet()
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构 `_create_fleet()`
- en: 'If the code we’ve written so far was all we needed to create a fleet, we’d
    probably leave `_create_fleet()` as is. But we have more work to do, so let’s
    clean up the method a bit. We’ll add a new helper method, `_create_alien()`, and
    call it from `_create_fleet()`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到目前为止我们编写的代码足够用来创建一个舰队，我们可能会保持`_create_fleet()`不变。但我们还有更多工作要做，所以我们稍微清理一下这个方法。我们将添加一个新的辅助方法`_create_alien()`，并在`_create_fleet()`中调用它：
- en: '**alien_invasion.py**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The method `_create_alien()` requires one parameter in addition to `self`:
    the *x*-value that specifies where the alien should be placed ❶. The code in the
    body of `_create_alien()` is the same code that was in `_create_fleet()`, except
    we use the parameter name `x_position` in place of `current_x`. This refactoring
    will make it easier to add new rows and create an entire fleet.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`_create_alien()`除了`self`外，还需要一个参数：指定外星人放置位置的 *x* 值 ❶。`_create_alien()`方法中的代码与`_create_fleet()`中的代码相同，只是我们将参数名`x_position`替换了`current_x`。这种重构使得添加新的一排并创建整个舰队变得更加简单。
- en: Adding Rows
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新的一排
- en: To finish the fleet, we’ll keep adding more rows until we run out of room. We’ll
    use a nested loop—we’ll wrap another `while` loop around the current one. The
    inner loop will place aliens horizontally in a row by focusing on the aliens’
    *x*-values. The outer loop will place aliens vertically by focusing on the *y*-values.
    We’ll stop adding rows when we get near the bottom of the screen, leaving enough
    space for the ship and some room to start firing at the aliens.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成舰队的创建，我们将不断添加更多的行，直到没有空间为止。我们将使用嵌套循环——在当前的`while`循环外再包裹一个循环。内层循环通过关注外星人的*
    x *坐标，将外星人横向放置在一行中。外层循环通过关注* y *坐标，将外星人纵向放置。我们将在接近屏幕底部时停止添加行，留出足够的空间给飞船并留有一些空间来开始向外星人开火。
- en: 'Here’s how to nest the two `while` loops in `_create_fleet()`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在`_create_fleet()`中嵌套两个`while`循环的：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ll need to know the alien’s height in order to place rows, so we grab the
    alien’s width and height using the `size` attribute of an alien `rect` ❶. A `rect`’s
    `size` attribute is a tuple containing its width and height.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道外星人的高度，以便放置行，所以我们通过外星人`rect`的`size`属性来获取外星人的宽度和高度 ❶。一个`rect`的`size`属性是一个包含其宽度和高度的元组。
- en: Next, we set the initial *x*- and *y*-values for the placement of the first
    alien in the fleet ❷. We place it one alien width in from the left and one alien
    height down from the top. Then we define the `while` loop that controls how many
    rows are placed onto the screen ❸. As long as the *y*-value for the next row is
    less than the screen height, minus three alien heights, we’ll keep adding rows.
    (If this doesn’t leave the right amount of space, we can adjust it later.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为舰队中第一个外星人的放置设置初始的* x *和* y *坐标 ❷。我们将其放置在离左边一外星人宽度的位置，并向下放置一个外星人高度的距离。然后我们定义一个`while`循环来控制有多少行外星人被放置到屏幕上
    ❸。只要下一行的* y *坐标小于屏幕高度减去三倍外星人高度，我们就会继续添加行。（如果这没有留下足够的空间，我们可以稍后调整。）
- en: We call `_create_alien()`, and pass it the *y*-value as well as its *x*-position
    ❹. We’ll modify `_create_alien()` in a moment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`_create_alien()`并传递* y *坐标以及其* x *位置 ❹。稍后我们会修改`_create_alien()`方法。
- en: Notice the indentation of the last two lines of code ❺. They’re inside the outer
    `while` loop, but outside the inner `while` loop. This block runs after the inner
    loop is finished; it runs once after each row is created. After each row has been
    added, we reset the value of `current_x` so the first alien in the next row will
    be placed at the same position as the first alien in the previous rows. Then we
    add two alien heights to the current value of `current_y`, so the next row will
    be placed further down the screen. Indentation is really important here; if you
    don’t see the correct fleet when you run *alien_invasion.py* at the end of this
    section, check the indentation of all the lines in these nested loops.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后两行代码的缩进 ❺。它们位于外层`while`循环内，但在内层`while`循环外。这段代码在内层循环完成后运行；每添加一行后它就执行一次。每添加一行后，我们重置`current_x`的值，以便下一行的第一个外星人放置在与上一行的第一个外星人相同的位置。然后我们将`current_y`的当前值加上两个外星人高度，这样下一行就会放得更低。缩进在这里非常重要；如果在本节末尾运行`alien_invasion.py`时看不到正确的舰队，请检查这些嵌套循环中所有行的缩进。
- en: 'We need to modify `_create_alien()` to set the vertical position of the alien
    correctly:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`_create_alien()`方法来正确设置外星人的垂直位置：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We modify the definition of the method to accept the *y*-value for the new alien,
    and we set the vertical position of the `rect` in the body of the method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改方法的定义，使其接受新外星人的* y *坐标，并在方法体内设置`rect`的垂直位置。
- en: When you run the game now, you should see a full fleet of aliens, as shown in
    [Figure 13-4](#figure13-4).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行游戏时，你应该能看到一个完整的外星人舰队，如[图 13-4](#figure13-4)所示。
- en: '![](image_fi/502703c13/f13004.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c13/f13004.png)'
- en: 'Figure 13-4: The full fleet appears.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-4：完整的舰队出现了。
- en: In the next section, we’ll make the fleet move!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将让舰队开始移动！
- en: Making the Fleet Move
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让舰队移动
- en: Now let’s make the fleet of aliens move to the right across the screen until
    it hits the edge, and then make it drop a set amount and move in the other direction.
    We’ll continue this movement until all aliens have been shot down, one collides
    with the ship, or one reaches the bottom of the screen. Let’s begin by making
    the fleet move to the right.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让外星人舰队向右移动，直到碰到屏幕边缘，然后向下移动一定的距离并朝相反方向移动。我们将继续这个移动，直到所有外星人被击败、其中一个与飞船碰撞，或者某个外星人到达屏幕底部。我们先从让舰队向右移动开始。
- en: Moving the Aliens Right
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让外星人向右移动
- en: 'To move the aliens, we’ll use an `update()` method in *alien.py*, which we’ll
    call for each alien in the group of aliens. First, add a setting to control the
    speed of each alien:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移动外星人，我们将在*alien.py*中使用一个`update()`方法，这个方法将会对外星人群体中的每个外星人进行调用。首先，添加一个设置来控制每个外星人的速度：
- en: '**settings.py**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then use this setting to implement `update()` in *alien.py*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用此设置来实现*alien.py*中的`update()`方法：
- en: '**alien.py**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien.py**'
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We create a `settings` parameter in `__init__()` so we can access the alien’s
    speed in `update()`. Each time we update an alien’s position, we move it to the
    right by the amount stored in `alien_speed`. We track the alien’s exact position
    with the `self.x` attribute, which can hold float values ❶. We then use the value
    of `self.x` to update the position of the alien’s `rect` ❷.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`__init__()`中创建了一个`settings`参数，这样我们就可以在`update()`中访问外星人的速度。每次更新外星人位置时，我们都将其向右移动，移动的距离由`alien_speed`存储。我们通过`self.x`属性跟踪外星人确切的位置，`self.x`可以存储浮动值❶。然后，我们使用`self.x`的值来更新外星人`rect`的位置❷。
- en: 'In the main `while` loop, we already have calls to update the ship and bullet
    positions. Now we’ll add a call to update the position of each alien as well:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`while`循环中，我们已经有了更新飞船和子弹位置的调用。现在我们将添加一个调用来更新每个外星人的位置：
- en: '**alien_invasion.py**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’re about to write some code to manage the movement of the fleet, so we create
    a new method called `_update_aliens()`. We update the aliens’ positions after
    the bullets have been updated, because we’ll soon be checking to see whether any
    bullets hit any aliens.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将编写一些代码来管理舰队的移动，因此我们创建了一个名为`_update_aliens()`的新方法。在子弹更新之后，我们会更新外星人的位置，因为我们很快就会检查是否有子弹击中外星人。
- en: 'Where you place this method in the module is not critical. But to keep the
    code organized, I’ll place it just after `_update_bullets()` to match the order
    of method calls in the `while` loop. Here’s the first version of `_update_aliens()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你将此方法放置在模块中的位置并不关键。但为了保持代码的组织性，我会将它放在`_update_bullets()`方法之后，以便与`while`循环中的方法调用顺序一致。以下是`_update_aliens()`的第一个版本：
- en: '**alien_invasion.py**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `update()` method on the `aliens` group, which calls each alien’s
    `update()` method. When you run *Alien Invasion* now, you should see the fleet
    move right and disappear off the side of the screen.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`aliens`组上使用`update()`方法，这将调用每个外星人的`update()`方法。现在运行*Alien Invasion*时，你应该会看到舰队向右移动并消失在屏幕的一侧。
- en: Creating Settings for Fleet Direction
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建舰队方向的设置
- en: 'Now we’ll create the settings that will make the fleet move down the screen
    and to the left when it hits the right edge of the screen. Here’s how to implement
    this behavior:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建设置，使得当舰队撞到屏幕右边缘时，舰队会向下和向左移动。以下是实现这种行为的方法：
- en: '**settings.py**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The setting `fleet_drop_speed` controls how quickly the fleet drops down the
    screen each time an alien reaches either edge. It’s helpful to separate this speed
    from the aliens’ horizontal speed so you can adjust the two speeds independently.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`fleet_drop_speed`控制每次外星人到达任何一侧时，舰队下移的速度。将这个速度与外星人的水平速度分开是有帮助的，这样你就可以独立调整这两个速度。
- en: To implement the setting `fleet_direction`, we could use a text value such as
    `'left'` or `'right'`, but we’d end up with `if`-`elif` statements testing for
    the fleet direction. Instead, because we only have two directions to deal with,
    let’s use the values 1 and −1 and switch between them each time the fleet changes
    direction. (Using numbers also makes sense because moving right involves adding
    to each alien’s *x*-coordinate value, and moving left involves subtracting from
    each alien’s *x*-coordinate value.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现`fleet_direction`设置，我们可以使用类似`'left'`或`'right'`的文本值，但那样我们最终会得到测试舰队方向的`if`-`elif`语句。相反，因为我们只有两个方向要处理，我们使用值`1`和`-1`，每次舰队改变方向时交换它们。（使用数字也更有意义，因为向右移动涉及到增加每个外星人的*x*坐标值，而向左移动则是从每个外星人的*x*坐标值中减去。）
- en: Checking Whether an Alien Has Hit the Edge
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查外星人是否撞到边缘
- en: 'We need a method to check whether an alien is at either edge, and we need to
    modify `update()` to allow each alien to move in the appropriate direction. This
    code is part of the `Alien` class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个方法来检查外星人是否位于任一边缘，同时我们需要修改`update()`方法，以允许每个外星人向适当的方向移动。这段代码是`Alien`类的一部分：
- en: '**alien.py**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien.py**'
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can call the new method `check_edges()` on any alien to see whether it’s
    at the left or right edge. The alien is at the right edge if the `right` attribute
    of its `rect` is greater than or equal to the `right` attribute of the screen’s
    `rect`. It’s at the left edge if its `left` value is less than or equal to 0 ❶.
    Rather than put this conditional test in an `if` block, we put the test directly
    in the `return` statement. This method will return `True` if the alien is at the
    right or left edge, and `False` if it is not at either edge.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对任何外星人调用新的`check_edges()`方法，查看它是否位于左侧或右侧边缘。如果外星人的`rect`的`right`属性大于或等于屏幕`rect`的`right`属性，则它位于右边缘。如果它的`left`值小于或等于0
    ❶，则它位于左边缘。我们没有把这个条件判断放在`if`语句块中，而是直接把判断放在了`return`语句中。这个方法会在外星人位于右边缘或左边缘时返回`True`，否则返回`False`。
- en: We modify the method `update()` to allow motion to the left or right by multiplying
    the alien’s speed by the value of `fleet_direction` ❷. If `fleet_direction` is
    1, the value of `alien_speed` will be added to the alien’s current position, moving
    the alien to the right; if `fleet_direction` is −1, the value will be subtracted
    from the alien’s position, moving the alien to the left.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了`update()`方法，允许外星人向左或向右移动，方法是将外星人的速度乘以`fleet_direction`的值 ❷。如果`fleet_direction`为1，外星人的当前位置会加上`alien_speed`的值，外星人向右移动；如果`fleet_direction`为−1，值会从外星人的位置中减去，外星人向左移动。
- en: Dropping the Fleet and Changing Direction
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 舰队下降并改变方向
- en: When an alien reaches the edge, the entire fleet needs to drop down and change
    direction. Therefore, we need to add some code to `AlienInvasion` because that’s
    where we’ll check whether any aliens are at the left or right edge. We’ll make
    this happen by writing the methods `_check_fleet_edges()` and `_change_fleet_direction()`,
    and then modifying `_update_aliens()`. I’ll put these new methods after `_create_alien()`,
    but again, the placement of these methods in the class isn’t critical.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当外星人到达屏幕边缘时，整个舰队需要下降并改变方向。因此，我们需要在`AlienInvasion`中添加一些代码，因为我们将在这里检查是否有外星人处于左侧或右侧边缘。我们将通过编写`_check_fleet_edges()`和`_change_fleet_direction()`方法来实现这一点，然后修改`_update_aliens()`。我会把这些新方法放在`_create_alien()`之后，但方法在类中的位置并不重要。
- en: '**alien_invasion.py**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In `_check_fleet_edges()`, we loop through the fleet and call `check_edges()`
    on each alien ❶. If `check_edges()` returns `True`, we know an alien is at an
    edge and the whole fleet needs to change direction; so we call `_change_fleet_direction()`
    and break out of the loop ❷. In `_change_fleet_direction()`, we loop through all
    the aliens and drop each one using the setting `fleet_drop_speed` ❸; then we change
    the value of `fleet_direction` by multiplying its current value by −1\. The line
    that changes the fleet’s direction isn’t part of the `for` loop. We want to change
    each alien’s vertical position, but we only want to change the direction of the
    fleet once.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_check_fleet_edges()`中，我们遍历整个舰队，并对每个外星人调用`check_edges()` ❶。如果`check_edges()`返回`True`，我们就知道有外星人处于边缘，整个舰队需要改变方向；因此，我们调用`_change_fleet_direction()`并跳出循环
    ❷。在`_change_fleet_direction()`中，我们遍历所有外星人并使用`fleet_drop_speed`设置让它们下降 ❸；然后我们将`fleet_direction`的值乘以−1来改变方向。改变舰队方向的那一行代码不是`for`循环的一部分。我们希望改变每个外星人的垂直位置，但只希望改变舰队的方向一次。
- en: 'Here are the changes to `_update_aliens()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`_update_aliens()`的修改：
- en: '**alien_invasion.py**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve modified the method by calling `_check_fleet_edges()` before updating
    each alien’s position.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在更新每个外星人位置之前调用`_check_fleet_edges()`方法来修改了这个方法。
- en: When you run the game now, the fleet should move back and forth between the
    edges of the screen and drop down every time it hits an edge. Now we can start
    shooting down aliens and watch for any aliens that hit the ship or reach the bottom
    of the screen.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行游戏时，舰队应该会在屏幕的边缘之间来回移动，每次碰到边缘时就会下降。现在我们可以开始射击外星人，并观察任何碰到飞船或到达屏幕底部的外星人。
- en: Shooting Aliens
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射击外星人
- en: We’ve built our ship and a fleet of aliens, but when the bullets reach the aliens,
    they simply pass through because we aren’t checking for collisions. In game programming,
    *collisions* happen when game elements overlap. To make the bullets shoot down
    aliens, we’ll use the function `sprite.groupcollide()` to look for collisions
    between members of two groups.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建造了我们的飞船和一支外星人舰队，但当子弹击中外星人时，它们会直接穿透过去，因为我们没有检测碰撞。在游戏编程中，*碰撞*发生在游戏元素重叠时。为了让子弹击落外星人，我们将使用`sprite.groupcollide()`函数来检查两个组成员之间的碰撞。
- en: Detecting Bullet Collisions
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测子弹碰撞
- en: We want to know right away when a bullet hits an alien so we can make an alien
    disappear as soon as it’s hit. To do this, we’ll look for collisions immediately
    after updating the position of all the bullets.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在子弹击中外星人时立即得知，这样我们就能在外星人被击中时立即让它消失。为此，我们将在更新所有子弹的位置后，立即检查碰撞。
- en: The `sprite.groupcollide()` function compares the `rect`s of each element in
    one group with the `rect`s of each element in another group. In this case, it
    compares each bullet’s `rect` with each alien’s `rect` and returns a dictionary
    containing the bullets and aliens that have collided. Each key in the dictionary
    will be a bullet, and the corresponding value will be the alien that was hit.
    (We’ll also use this dictionary when we implement a scoring system in Chapter
    14.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`sprite.groupcollide()`函数将一个组中每个元素的`rect`与另一个组中每个元素的`rect`进行比较。在这种情况下，它将每颗子弹的`rect`与每个外星人的`rect`进行比较，并返回一个包含发生碰撞的子弹和外星人的字典。字典中的每个键将是一个子弹，而对应的值将是被击中的外星人。（我们将在第14章实现评分系统时使用这个字典。）'
- en: 'Add the following code to the end of `_update_bullets()` to check for collisions
    between bullets and aliens:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`_update_bullets()`的末尾，以检查子弹与外星人之间的碰撞：
- en: '**alien_invasion.py**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The new code we added compares the positions of all the bullets in `self.bullets`
    and all the aliens in `self.aliens`, and identifies any that overlap. Whenever
    the `rect`s of a bullet and alien overlap, `groupcollide()` adds a key-value pair
    to the dictionary it returns. The two `True` arguments tell Pygame to delete the
    bullets and aliens that have collided. (To make a high-powered bullet that can
    travel to the top of the screen, destroying every alien in its path, you could
    set the first Boolean argument to `False` and keep the second Boolean argument
    set to `True`. The aliens hit would disappear, but all bullets would stay active
    until they disappeared off the top of the screen.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的新代码比较了`self.bullets`中所有子弹和`self.aliens`中所有外星人的位置，并识别出任何重叠的部分。每当子弹和外星人的`rect`重叠时，`groupcollide()`会将一个键值对添加到它返回的字典中。两个`True`参数告诉Pygame删除已经碰撞的子弹和外星人。（要制作一颗可以穿越屏幕顶部并摧毁其路径上所有外星人的高能子弹，你可以将第一个布尔参数设置为`False`，并将第二个布尔参数保持为`True`。被击中的外星人会消失，但所有子弹会一直保持活动状态，直到它们消失在屏幕顶部。）
- en: When you run *Alien Invasion* now, aliens you hit should disappear. [Figure
    13-5](#figure13-5) shows a fleet that has been partially shot down.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行*外星人入侵*时，击中的外星人应该会消失。[图 13-5](#figure13-5)展示了一个部分被击落的舰队。
- en: '![](image_fi/502703c13/f13005.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c13/f13005.png)'
- en: 'Figure 13-5: We can shoot aliens!'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-5：我们可以击落外星人！
- en: Making Larger Bullets for Testing
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为测试制作更大的子弹
- en: You can test many features of *Alien Invasion* simply by running the game, but
    some features are tedious to test in the normal version of the game. For example,
    it’s a lot of work to shoot down every alien on the screen multiple times to test
    whether your code responds to an empty fleet correctly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行游戏来测试*外星人入侵*的许多功能，但某些功能在游戏的正常版本中测试起来很繁琐。例如，测试代码是否正确响应空舰队时，必须多次击落屏幕上的每个外星人，这是一项繁重的工作。
- en: To test particular features, you can change certain game settings to focus on
    a particular area. For example, you might shrink the screen so there are fewer
    aliens to shoot down or increase the bullet speed and give yourself lots of bullets
    at once.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试特定功能，你可以更改某些游戏设置以集中测试特定区域。例如，你可以缩小屏幕，使需要击落的外星人更少，或增加子弹速度并一次性给予自己许多子弹。
- en: My favorite change for testing *Alien Invasion* is to use really wide bullets
    that remain active even after they’ve hit an alien (see [Figure 13-6](#figure13-6)).
    Try setting `bullet_width` to 300, or even 3,000, to see how quickly you can shoot
    down the fleet!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我测试*外星人入侵*时最喜欢的更改是使用非常宽的子弹，即使它们击中外星人后仍保持活动状态（见[图 13-6](#figure13-6)）。试试将`bullet_width`设置为300，甚至3,000，看看你能多快击落舰队！
- en: '![](image_fi/502703c13/f13006.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c13/f13006.png)'
- en: 'Figure 13-6: Extra-powerful bullets make some aspects of the game easier to
    test.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-6：超强子弹使游戏中的某些方面更容易进行测试。
- en: Changes like these will help you test the game more efficiently and possibly
    spark ideas for giving players bonus powers. Just remember to restore the settings
    to normal when you’re finished testing a feature.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的更改将帮助你更高效地测试游戏，并可能激发为玩家提供额外能力的创意。只需记得在测试完某个功能后，将设置恢复到正常状态。
- en: Repopulating the Fleet
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新填充舰队
- en: 'One key feature of *Alien Invasion* is that the aliens are relentless: every
    time the fleet is destroyed, a new fleet should appear.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*外星入侵*的一个关键特点是外星人是无情的：每当舰队被摧毁时，新的舰队应当出现。'
- en: To make a new fleet of aliens appear after a fleet has been destroyed, we first
    check whether the `aliens` group is empty. If it is, we make a call to `_create_fleet()`.
    We’ll perform this check at the end of `_update_bullets()`, because that’s where
    individual aliens are destroyed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在舰队被摧毁后让新的外星舰队出现，我们首先检查`aliens`组是否为空。如果为空，我们会调用`_create_fleet()`。我们将在`_update_bullets()`的最后进行此检查，因为那是个别外星人被摧毁的地方。
- en: '**alien_invasion.py**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We check whether the `aliens` group is empty ❶. An empty group evaluates to
    `False`, so this is a simple way to check whether the group is empty. If it is,
    we get rid of any existing bullets by using the `empty()` method, which removes
    all the remaining sprites from a group ❷. We also call `_create_fleet()`, which
    fills the screen with aliens again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查`aliens`组是否为空 ❶。一个空的组会被评估为`False`，所以这是一种简单的方法来检查组是否为空。如果为空，我们通过使用`empty()`方法清除所有现有的子弹，该方法会从组中移除所有剩余的精灵
    ❷。我们还会调用`_create_fleet()`，重新填充屏幕上的外星人。
- en: Now a new fleet appears as soon as you destroy the current fleet.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦你摧毁当前舰队，新的舰队就会出现。
- en: Speeding Up the Bullets
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加速子弹
- en: If you’ve tried firing at the aliens in the game’s current state, you might
    find that the bullets aren’t traveling at the best speed for gameplay. They might
    be a little too slow or a little too fast. At this point, you can modify the settings
    to make the gameplay more interesting. Keep in mind that the game is going to
    get progressively faster, so don’t make the game too fast at the beginning.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试过在当前状态下向外星人开火，你可能会发现子弹的速度不适合游戏玩法。它们可能有些太慢，或者有些太快。此时，你可以修改设置，使游戏玩法更有趣。请记住，游戏会逐渐加速，所以开始时不要让游戏速度过快。
- en: 'We modify the speed of the bullets by adjusting the value of `bullet_speed`
    in *settings.py*. On my system, I’ll adjust the value of `bullet_speed` to 2.5,
    so the bullets travel a little faster:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调整*settings.py*中`bullet_speed`的值来修改子弹的速度。在我的系统上，我将`bullet_speed`的值调整为2.5，这样子弹会稍微快一点：
- en: '**settings.py**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The best value for this setting depends on your experience of the game, so find
    a value that works for you. You can adjust other settings as well.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置的最佳值取决于你对游戏的经验，因此需要找到适合你的值。你还可以调整其他设置。
- en: Refactoring _update_bullets()
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构_update_bullets()
- en: 'Let’s refactor `_update_bullets()` so it’s not doing so many different tasks.
    We’ll move the code for dealing with bullet-alien collisions to a separate method:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构`_update_bullets()`，让它不再做这么多不同的任务。我们将处理子弹和外星人碰撞的代码移到一个单独的方法中：
- en: '**alien_invasion.py**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’ve created a new method, `_check_bullet_alien_collisions()`, to look for
    collisions between bullets and aliens and to respond appropriately if the entire
    fleet has been destroyed. Doing so keeps `_update_bullets()` from growing too
    long and simplifies further development.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新方法`_check_bullet_alien_collisions()`，用来检查子弹和外星人之间的碰撞，并在整个舰队被摧毁时作出适当反应。这样做避免了`_update_bullets()`变得过长，并简化了后续的开发。
- en: Ending the Game
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束游戏
- en: What’s the fun and challenge in playing a game you can’t lose? If the player
    doesn’t shoot down the fleet quickly enough, we’ll have the aliens destroy the
    ship when they make contact. At the same time, we’ll limit the number of ships
    a player can use, and we’ll destroy the ship when an alien reaches the bottom
    of the screen. The game will end when the player has used up all their ships.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 玩一个无法失败的游戏有什么乐趣和挑战呢？如果玩家没有足够快地击落舰队，我们会让外星人摧毁飞船，当它们接触到飞船时。同时，我们会限制玩家可使用的飞船数量，当外星人到达屏幕底部时，飞船会被摧毁。游戏将在玩家用完所有飞船后结束。
- en: Detecting Alien-Ship Collisions
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测外星飞船碰撞
- en: 'We’ll start by checking for collisions between aliens and the ship so we can
    respond appropriately when an alien hits it. We’ll check for alien-ship collisions
    immediately after updating the position of each alien in `AlienInvasion`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从检查外星人和飞船之间的碰撞开始，以便在外星人撞击飞船时做出适当反应。我们会在更新每个外星人的位置后立即检查外星人-飞船碰撞，在`AlienInvasion`中执行：
- en: '**alien_invasion.py**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `spritecollideany()` function takes two arguments: a sprite and a group.
    The function looks for any member of the group that has collided with the sprite
    and stops looping through the group as soon as it finds one member that has collided
    with the sprite. Here, it loops through the group `aliens` and returns the first
    alien it finds that has collided with `ship`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`spritecollideany()`函数接受两个参数：一个精灵和一个组。该函数查找组中任何与精灵发生碰撞的成员，并在找到一个发生碰撞的成员后立即停止遍历组。在这里，它遍历`aliens`组，并返回第一个与`ship`发生碰撞的外星人。'
- en: 'If no collisions occur, `spritecollideany()` returns `None` and the `if` block
    won’t execute ❶. If it finds an alien that has collided with the ship, it returns
    that alien and the `if` block executes: it prints `Ship hit!!!` ❷. When an alien
    hits the ship, we’ll need to do a number of tasks: delete all remaining aliens
    and bullets, recenter the ship, and create a new fleet. Before we write code to
    do all this, we want to know that our approach to detecting alien-ship collisions
    works correctly. Writing a `print()` call is a simple way to ensure we’re detecting
    these collisions properly.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生碰撞，`spritecollideany()`将返回`None`，`if`语句块不会执行❶。如果它找到了与飞船发生碰撞的外星人，它将返回该外星人，`if`语句块将执行：打印`Ship
    hit!!!`❷。当外星人撞击飞船时，我们需要执行一些任务：删除所有剩余的外星人和子弹，重新定位飞船，并创建一个新的舰队。在编写代码之前，我们想确保我们检测外星人-飞船碰撞的方法是正确的。通过编写一个`print()`调用是确保我们正确检测碰撞的一种简单方法。
- en: Now when you run *Alien Invasion,* the message *Ship hit!!!* should appear in
    the terminal whenever an alien runs into the ship. When you’re testing this feature,
    set `fleet_drop_speed` to a higher value, such as 50 or 100, so the aliens reach
    your ship faster.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行*Alien Invasion*时，每当外星人撞到飞船时，终端中应该会显示消息*Ship hit!!!*。在测试此功能时，将`fleet_drop_speed`设置为更高的值，例如50或100，这样外星人会更快地到达飞船。
- en: Responding to Alien-Ship Collisions
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应外星人-飞船碰撞
- en: Now we need to figure out exactly what will happen when an alien collides with
    the ship. Instead of destroying the `ship` instance and creating a new one, we’ll
    count how many times the ship has been hit by tracking statistics for the game.
    Tracking statistics will also be useful for scoring.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要弄清楚当外星人和飞船发生碰撞时到底会发生什么。我们将通过追踪游戏的统计数据来计算飞船被击中的次数，而不是销毁`ship`实例并创建一个新的。追踪统计数据对于得分也很有用。
- en: 'Let’s write a new class, `GameStats`, to track game statistics, and let’s save
    it as *game_stats.py*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个新的类`GameStats`来跟踪游戏统计数据，并将其保存为*game_stats.py*：
- en: '**game_stats.py**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**game_stats.py**'
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We’ll make one `GameStats` instance for the entire time *Alien Invasion* is
    running, but we’ll need to reset some statistics each time the player starts a
    new game. To do this, we’ll initialize most of the statistics in the `reset_stats()`
    method, instead of directly in `__init__()`. We’ll call this method from `__init__()`
    so the statistics are set properly when the `GameStats` instance is first created
    ❶. But we’ll also be able to call `reset_stats()` anytime the player starts a
    new game. Right now we have only one statistic, `ships_left`, the value of which
    will change throughout the game.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*Alien Invasion*运行的整个过程中创建一个`GameStats`实例，但每次玩家开始新游戏时，我们需要重置一些统计数据。为此，我们将在`reset_stats()`方法中初始化大部分统计数据，而不是直接在`__init__()`中初始化。我们将在`__init__()`中调用此方法，以便在首次创建`GameStats`实例时正确设置统计数据❶。但我们也可以在玩家开始新游戏时随时调用`reset_stats()`。目前我们只有一个统计数据，`ships_left`，它的值会在整个游戏过程中发生变化。
- en: 'The number of ships the player starts with should be stored in *settings.py*
    as `ship_limit`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家起始的飞船数量应该保存在*settings.py*中，作为`ship_limit`：
- en: '**settings.py**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**settings.py**'
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to make a few changes in *alien_invasion.py* to create an instance
    of `GameStats`. First, we’ll update the `import` statements at the top of the
    file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在*alien_invasion.py*中做一些修改，以便创建一个`GameStats`实例。首先，我们将更新文件顶部的`import`语句：
- en: '**alien_invasion.py**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We import the `sleep()` function from the `time` module in the Python standard
    library, so we can pause the game for a moment when the ship is hit. We also import
    `GameStats`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Python标准库的`time`模块导入`sleep()`函数，这样当飞船被击中时，我们可以暂停游戏片刻。我们还导入了`GameStats`。
- en: 'We’ll create an instance of `GameStats` in `__init__()`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`__init__()`中创建一个`GameStats`实例：
- en: '**alien_invasion.py**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We make the instance after creating the game window but before defining other
    game elements, such as the ship.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建游戏窗口后，但在定义其他游戏元素（如飞船）之前创建实例。
- en: When an alien hits the ship, we’ll subtract 1 from the number of ships left,
    destroy all existing aliens and bullets, create a new fleet, and reposition the
    ship in the middle of the screen. We’ll also pause the game for a moment so the
    player can notice the collision and regroup before a new fleet appears.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当外星人撞击飞船时，我们会将剩余飞船数量减去1，销毁所有现有的外星人和子弹，创建一个新的舰队，并将飞船重新定位到屏幕中央。我们还会暂停游戏片刻，以便玩家能够注意到碰撞，并在新舰队出现之前重新集结。
- en: 'Let’s put most of this code in a new method called `_ship_hit()`. We’ll call
    this method from `_update_aliens()` when an alien hits the ship:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把大部分代码放在一个名为`_ship_hit()`的新方法中。当外星人撞击飞船时，我们会从`_update_aliens()`中调用这个方法：
- en: '**alien_invasion.py**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The new method `_ship_hit()` coordinates the response when an alien hits a ship.
    Inside `_ship_hit()`, the number of ships left is reduced by 1 ❶, after which
    we empty the groups `bullets` and `aliens` ❷.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法`_ship_hit()`协调外星人撞击飞船时的响应。在`_ship_hit()`中，剩余飞船的数量减少1❶，然后我们清空`bullets`和`aliens`两个组❷。
- en: Next, we create a new fleet and center the ship ❸. (We’ll add the method `center_ship()`
    to `Ship` in a moment.) Then we add a pause after the updates have been made to
    all the game elements but before any changes have been drawn to the screen, so
    the player can see that their ship has been hit ❹. The `sleep()` call pauses program
    execution for half a second, long enough for the player to see that the alien
    has hit the ship. When the `sleep()` function ends, code execution moves on to
    the `_update_screen()` method, which draws the new fleet to the screen.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的舰队并将飞船置于屏幕中央❸。（稍后我们会在`Ship`类中添加`center_ship()`方法。）然后，我们在更新所有游戏元素后但在任何更改绘制到屏幕之前添加一个暂停，以便玩家可以看到他们的飞船被撞击❹。`sleep()`调用会暂停程序执行半秒钟，足够让玩家看到外星人撞击飞船。当`sleep()`函数结束时，代码执行会转到`_update_screen()`方法，该方法将新的舰队绘制到屏幕上。
- en: 'In `_update_aliens()`, we replace the `print()` call with a call to `_ship_hit()`
    when an alien hits the ship:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_update_aliens()`中，当外星人撞击飞船时，我们将`print()`调用替换为对`_ship_hit()`的调用：
- en: '**alien_invasion.py**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s the new method `center_ship()`, which belongs in *ship.py*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的`center_ship()`方法，它属于*ship.py*：
- en: '**ship.py**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**ship.py**'
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We center the ship the same way we did in `__init__()`. After centering it,
    we reset the `self.x` attribute, which allows us to track the ship’s exact position.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以和`__init__()`中相同的方式将飞船居中。居中后，我们重置`self.x`属性，这样就可以跟踪飞船的准确位置。
- en: Run the game, shoot a few aliens, and let an alien hit the ship. The game should
    pause, and a new fleet should appear with the ship centered at the bottom of the
    screen again.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，射击几个外星人，让一个外星人撞击飞船。游戏应该暂停，并且一个新的舰队应该出现，飞船重新居中出现在屏幕底部。
- en: Aliens That Reach the Bottom of the Screen
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 到达屏幕底部的外星人
- en: 'If an alien reaches the bottom of the screen, we’ll have the game respond the
    same way it does when an alien hits the ship. To check when this happens, add
    a new method in *alien_invasion.py*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外星人到达屏幕底部，游戏会像外星人撞击飞船时那样做出响应。为了检查何时发生这种情况，请在*alien_invasion.py*中添加一个新方法：
- en: '**alien_invasion.py**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The method `_check_aliens_bottom()` checks whether any aliens have reached the
    bottom of the screen. An alien reaches the bottom when its `rect.bottom` value
    is greater than or equal to the screen’s height ❶. If an alien reaches the bottom,
    we call `_ship_hit()`. If one alien hits the bottom, there’s no need to check
    the rest, so we break out of the loop after calling `_ship_hit()`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`_check_aliens_bottom()`检查是否有外星人到达屏幕底部。当外星人的`rect.bottom`值大于或等于屏幕高度时，外星人就到达底部❶。如果外星人到达底部，我们调用`_ship_hit()`。如果一个外星人撞到底部，就不需要检查其他外星人，因此在调用`_ship_hit()`后，我们会跳出循环。
- en: 'We’ll call this method from `_update_aliens()`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`_update_aliens()`中调用这个方法：
- en: '**alien_invasion.py**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We call `_check_aliens_bottom()` after updating the positions of all the aliens
    and after looking for alien-ship collisions. Now a new fleet will appear every
    time the ship is hit by an alien or an alien reaches the bottom of the screen.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新所有外星人位置并检查外星人与飞船的碰撞后，我们调用`_check_aliens_bottom()`。现在每次飞船被外星人撞击或外星人到达屏幕底部时，都会出现一个新的舰队。
- en: Game Over!
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏结束！
- en: '*Alien Invasion* feels more complete now, but the game never ends. The value
    of `ships_left` just grows increasingly negative. Let’s add a `game_active` flag,
    so we can end the game when the player runs out of ships. We’ll set this flag
    at the end of the `__init__()` method in `AlienInvasion`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*外星人入侵*现在感觉更完整了，但游戏永远不会结束。`ships_left`的值会越来越负。让我们添加一个`game_active`标志，这样当玩家用尽船只时，我们就可以结束游戏。我们将在`AlienInvasion`类的`__init__()`方法末尾设置此标志：'
- en: '**alien_invasion.py**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we add code to `_ship_hit()` that sets `game_active` to `False` when the
    player has used up all their ships:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们向`_ship_hit()`中添加代码，当玩家用尽所有船只时，将`game_active`设置为`False`：
- en: '**alien_invasion.py**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Most of `_ship_hit()` is unchanged. We’ve moved all the existing code into an
    `if` block, which tests to make sure the player has at least one ship remaining.
    If so, we create a new fleet, pause, and move on. If the player has no ships left,
    we set `game_active` to `False`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ship_hit()`的大部分内容保持不变。我们将所有现有代码移动到了一个`if`语句块中，用于检查玩家是否至少剩下一个船只。如果有，我们创建一个新的舰队，暂停并继续。如果玩家没有剩余的船只，我们将`game_active`设置为`False`。'
- en: Identifying When Parts of the Game Should Run
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定游戏中哪些部分应该运行
- en: 'We need to identify the parts of the game that should always run and the parts
    that should run only when the game is active:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确定游戏中应该始终运行的部分以及仅在游戏处于活动状态时才运行的部分：
- en: '**alien_invasion.py**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**alien_invasion.py**'
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the main loop, we always need to call `_check_events()`, even if the game
    is inactive. For example, we still need to know if the user presses Q to quit
    the game or clicks the button to close the window. We also continue updating the
    screen so we can make changes to the screen while waiting to see whether the player
    chooses to start a new game. The rest of the function calls need to happen only
    when the game is active, because when the game is inactive, we don’t need to update
    the positions of game elements.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，我们始终需要调用`_check_events()`，即使游戏处于非活动状态。例如，我们仍然需要知道用户是否按下Q键退出游戏，或者是否点击了关闭窗口的按钮。我们还需要继续更新屏幕，以便在等待玩家选择是否开始新游戏时，我们可以对屏幕进行更改。其余的函数调用只有在游戏处于活动状态时才需要执行，因为当游戏不活动时，我们不需要更新游戏元素的位置。
- en: Now when you play *Alien Invasion*, the game should freeze when you’ve used
    up all your ships.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你玩*外星人入侵*时，当你用完所有船只后，游戏应该暂停。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to add a large number of identical elements
    to a game by creating a fleet of aliens. You used nested loops to create a grid
    of elements, and you made a large set of game elements move by calling each element’s
    `update()` method. You learned to control the direction of objects on the screen
    and to respond to specific situations, such as when the fleet reaches the edge
    of the screen. You detected and responded to collisions when bullets hit aliens
    and aliens hit the ship. You also learned how to track statistics in a game and
    use a `game_active` flag to determine when the game is over.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何通过创建外星人舰队将大量相同的元素添加到游戏中。你使用了嵌套循环创建了一个元素网格，并通过调用每个元素的`update()`方法使大量游戏元素移动。你学会了控制屏幕上物体的方向，并响应特定情况，例如舰队到达屏幕边缘时。你还检测并响应了子弹击中外星人和外星人撞击船只的碰撞。你还学会了如何跟踪游戏中的统计数据，并使用`game_active`标志来判断游戏是否结束。
- en: In the next and final chapter of this project, we’ll add a Play button so the
    player can choose when to start their first game and whether to play again when
    the game ends. We’ll speed up the game each time the player shoots down the entire
    fleet, and we’ll add a scoring system. The final result will be a fully playable
    game!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目的下一章，也是最后一章，我们将添加一个“播放”按钮，让玩家可以选择何时开始他们的第一局游戏，并在游戏结束时选择是否重新开始。每次玩家击败整个舰队时，我们将加速游戏，并且我们会添加一个计分系统。最终的结果将是一个完全可玩的游戏！
