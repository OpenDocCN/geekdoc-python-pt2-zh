- en: '[13](nsp-venkitachalam503045-0008.xhtml#rch13)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laser Audio Display with a Raspberry Pi
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 12](nsp-venkitachalam503045-0027.xhtml#ch12), you used a Pico, a
    tiny microcontroller, to generate musical tones. In this chapter, you’ll use a
    much more powerful embedded system, the Raspberry Pi, to produce interesting laser
    patterns based on audio signals.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The [previous chapter’s](nsp-venkitachalam503045-0027.xhtml#ch12) Pico had an
    RP2040 microcontroller with dual ARM Cortex-M0 processors running at speeds of
    up to 133 MHz, with 264KB of random access memory (RAM) and 2MB of nonvolatile
    storage on an external flash chip. The Raspberry Pi 3B+, in comparison, has a
    much more capable ARM Cortex-A53 processor operating at 1.4 GHz, with 1GB of RAM
    and storage of several gigabytes, depending on the SD card you use. While this
    still pales in comparison to a standard desktop or laptop computer, the Pi is
    nonetheless capable of running a Linux-based operating system and full-fledged
    Python, unlike the Pico.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll use Python on the Raspberry Pi to read an audio file
    in the WAV format, perform computations based on the real-time audio data, and
    use that data to adjust the speed and direction of rotation of two motors in a
    laser display rig. You’ll attach mirrors to the motors to reflect the beam from
    an inexpensive laser module, producing Spirograph-like patterns that change in
    response to the audio. You’ll also simultaneously stream the audio to a speaker
    so you can hear the WAV file playing as you watch your laser light show.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'This project will push your knowledge of Python further as you learn to use
    the Raspberry Pi. Here are some of the topics we’ll cover:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: • Generating interesting patterns with a laser and two rotating mirrors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Getting frequency information from a signal using the fast Fourier transform
    (FFT)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Computing FFTs using `numpy`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Reading audio from WAV files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Outputting audio data using `pyaudio`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Driving motors with a Raspberry Pi
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Toggling a laser module on/off with a metal-oxide-semiconductor field-effect
    transistor (MOSFET)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1501)'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll use a Raspberry Pi to work with the audio data and control the hardware.
    [Figure 13-1](nsp-venkitachalam503045-0028.xhtml#fig13-1) shows a block diagram
    of what you’ll create in this project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: A block diagram of the laser audio project'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi will use a WAV file in two ways. It will play the file through
    an attached speaker by way of `pyaudio`, while also analyzing the audio data in
    real time using a mathematical technique called a *fast Fourier transform (FFT)*.
    The Pi will use data from the FFT to drive the motors and laser via its general-purpose
    input/output (GPIO) pins, but to protect the Pi from damage, you won’t hook it
    up directly to these external components. Instead, you’ll connect it indirectly
    through a motor driver board and a MOSFET. Before you begin, let’s consider in
    more detail how some of these aspects of the project will work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[Generating Patterns with a Laser](nsp-venkitachalam503045-0008.xhtml#rbh1501)'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To generate the laser patterns in this project, you’ll use a laser module and
    two mirrors attached to the shafts of two small DC motors, as shown in [Figure
    13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2). Think of the laser as an intense
    beam of light that remains focused on a tiny point, even when projected over a
    large distance. This focus is possible because the beam is organized so that its
    waves travel in one direction only and are in phase with each other. If you shine
    the laser at the surface of a flat mirror (mirror A in [Figure 13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)),
    the reflection projected will remain a fixed point, even as the motor spins. Because
    the plane of reflection of the laser is perpendicular to the spinning axis of
    the motor, it’s as if the mirror isn’t rotating at all.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Now, say the mirror is attached at an angle relative to the motor shaft, as
    shown on the right of [Figure 13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)
    (mirror B). As the shaft rotates, the projected point will trace an ellipse, and
    if the motor is spinning fast enough, the viewer will perceive the moving dot
    as a continuous shape.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: The flat mirror (mirror A) reflects a single dot. The reflection
    off the slanted mirror (mirror B) creates a circle as the motor spins.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: What if both mirrors are slanted and you arrange them so that the point reflected
    off mirror A is projected onto mirror B? Now when motors A and B spin, the pattern
    created by the reflected point will be a combination of the two rotational movements
    of motors A and B, producing interesting patterns, as shown in [Figure 13-3](nsp-venkitachalam503045-0028.xhtml#fig13-3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: Reflecting laser light off two rotating, slanted mirrors produces
    interesting, complex patterns.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The exact patterns produced will depend on the speed and direction of rotation
    of the two motors, but they will be similar to the hypotrochoids produced by the
    Spirograph you explored in [Chapter 2](nsp-venkitachalam503045-0013.xhtml#ch02).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Motor Control
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll use the Raspberry Pi to control the speed and direction of your motors
    through a technique called *pulse width modulation (**PWM)*. This is a way to
    power a device (such as a motor) by sending digital pulses that switch on and
    off quickly, such that the device “sees” a continuous voltage. The signal sent
    to the device has a fixed frequency, but the fraction of time that the digital
    pulse is on, called the *duty cycle*, can vary. The duty cycle is expressed as
    a percentage. To illustrate, [Figure 13-4](nsp-venkitachalam503045-0028.xhtml#fig13-4)
    shows three signals with the same frequency but different duty cycles—25 percent,
    50 percent, and 75 percent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13004.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: PWM signals with different duty cycles'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The higher the duty cycle percentage, the longer the pulse is on for each cycle
    of the signal. The motor receiving the signal will perceive those longer pulses
    as a higher continuous voltage. By manipulating the duty cycle, you can thus provide
    varying power levels to the motors in this project, which will result in variations
    in motor speed and changes in the laser pattern.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: NOTE PWM has many applications beyond motor control. It could also be used,
    for example, to control the brightness of dimmable LEDs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Motors operate at a relatively high voltage, but the Raspberry Pi can handle
    only so much current before it’s damaged. You’ll be using a TB6612FNG motor driver
    breakout board, similar to the ones shown in [Figure 13-5](nsp-venkitachalam503045-0028.xhtml#fig13-5),
    to act as an intermediary between the Pi and the motors, keeping the Pi safe.
    Many variants of this board are available, and you can choose any one of them,
    as long as you’re careful to wire it up correctly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13005.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: TB6612FNG motor driver breakout printed circuit boards (PCBs)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The bottom of the breakout board should have pin information. It’s also a good
    idea to look at the TB6612FNG chip datasheet, which you can download from the
    internet. The *A* and *B* in the pin names denote the two motors. The IN pins
    control the direction of the motors, the 01 and 02 pins supply power to the motors,
    and the PWM pins use pulse width modulation to control the motor speeds. By writing
    to these pins, you can control both the direction and speed of rotation for each
    motor, which is exactly what you need for this project. We won’t go into the details
    of how this board works, but if you’re curious, you can start by reading up on
    an *H-bridge*, a common circuit design that uses MOSFETs to control motors.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: NOTE You could replace this breakout part with any motor control circuit you’re
    familiar with, as long as you modify the code appropriately.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Laser Module
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the laser, you’ll use an inexpensive laser module breakout PCB similar to
    the one shown in [Figure 13-6](nsp-venkitachalam503045-0028.xhtml#fig13-6).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13006.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: A laser module'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Different variants of laser modules are available. You want one with a 650 nanometer
    (nm) red laser that operates at 5 volts (V). (The 650 nm refers to the laser’s
    wavelength.) Be sure you understand the polarity and connections of this board
    before you use it for the project. Test it separately using a 5 V power supply.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有不同版本的激光模块。你需要一个工作在 5 伏（V）的 650 纳米（nm）红色激光模块。（650 nm 指的是激光的波长。）在使用该板进行项目之前，确保你了解它的极性和连接方式。使用
    5 V 电源单独测试它。
- en: MOSFET
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MOSFET
- en: To turn the laser module on and off using the Raspberry Pi, you’ll use an *N-channel
    MOSFET*, which you can think of as an electrically controlled switch. You can
    use almost any N-channel MOSFET for the project, but the BS170 is cheap and readily
    available. [Figure 13-7](nsp-venkitachalam503045-0028.xhtml#fig13-7) shows the
    pin numbering for the MOSFET, as well as how to connect it to the laser module
    and the Raspberry Pi.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用树莓派打开和关闭激光模块，你将使用*N-channel MOSFET*，你可以把它看作是一个电控开关。你可以使用几乎任何 N-channel MOSFET
    来完成这个项目，但 BS170 既便宜又容易获取。[图 13-7](nsp-venkitachalam503045-0028.xhtml#fig13-7)
    显示了 MOSFET 的引脚编号，以及如何将其连接到激光模块和树莓派。
- en: '![](images/nsp-venkitachalam503045-f13007.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13007.jpg)'
- en: 'Figure 13-7: BS170 MOSFET connections'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-7：BS170 MOSFET 连接图
- en: The 10 kΩ resistor “pulls” the gate pin of the MOSFET to the ground, so it isn’t
    triggered when the Raspberry Pi GPIO pin is in a floating state (for example,
    after a GPIO cleanup). When you send a HIGH to the GPIO, the MOSFET switch turns
    on, effectively connecting the laser module to VM and GND and powering it on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 10 kΩ 电阻将 MOSFET 的门引脚“拉”到地面，这样当树莓派 GPIO 引脚处于浮空状态时（例如，在 GPIO 清理后），它不会被触发。当你向
    GPIO 发送 HIGH 信号时，MOSFET 开关会打开，实际上将激光模块连接到 VM 和 GND，从而为其供电。
- en: Why do you need a MOSFET? Can’t you just connect the laser module directly to
    a GPIO pin of the Raspberry Pi? That’s not a great idea, because the MOSFET can
    take a lot more current than your Raspberry Pi. Using a MOSFET isolates your Pi
    from a situation that causes a current spike on the load. Better to burn your
    cheap MOSFET than your comparatively expensive Raspberry Pi! In general, the MOSFET
    trick is a good thing to remember whenever you want to control an external device
    with your Raspberry Pi.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要一个 MOSFET？不能直接将激光模块连接到树莓派的 GPIO 引脚吗？这个主意并不好，因为 MOSFET 能承受的电流远大于树莓派。使用 MOSFET
    可以将树莓派与负载电流激增的情况隔离开来。宁愿烧坏你便宜的 MOSFET，也不要烧坏你相对昂贵的树莓派！一般来说，每当你想用树莓派控制外部设备时，记得使用
    MOSFET 是一个好主意。
- en: '[Analyzing Audio with the Fast Fourier Transform](nsp-venkitachalam503045-0008.xhtml#rbh1502)'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用快速傅里叶变换分析音频](nsp-venkitachalam503045-0008.xhtml#rbh1502)'
- en: Because the ultimate goal in this project is to control motor speeds based on
    audio input, you need to be able to analyze the audio in real time. Recall from
    [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04) that tones from an acoustic
    instrument are a mix of several frequencies, or overtones. In fact, any sound
    can be decomposed into its constituent frequencies using a *Fourier transform*.
    When the Fourier transform is applied to digital signals, the result is called
    the *discrete Fourier transform (**DFT)* because digital signals are composed
    of many discrete samples. In this project, you’ll use Python to implement a *fast
    Fourier transform (FFT)* algorithm to compute the DFT. (Throughout this chapter,
    I’ll use *FFT* to refer to both the algorithm and the result.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个项目的最终目标是根据音频输入控制电机速度，你需要能够实时分析音频。回想一下[第 4 章](nsp-venkitachalam503045-0016.xhtml#ch04)，声学乐器发出的音调是多种频率或泛音的混合。事实上，任何声音都可以通过*傅里叶变换*分解成它的组成频率。当傅里叶变换应用于数字信号时，结果被称为*离散傅里叶变换（**DFT）*，因为数字信号是由许多离散样本组成的。在这个项目中，你将使用
    Python 实现一个*快速傅里叶变换（FFT）*算法来计算 DFT。（在本章中，我将使用*FFT* 来指代算法和结果。）
- en: '[Figure 13-8](nsp-venkitachalam503045-0028.xhtml#fig13-8) shows a simple example
    of an FFT. The top frame of the figure shows the waveform of a signal that combines
    just two sine waves. This plot is in the *time domain* because it’s showing how
    the signal’s amplitude varies over time. The bottom frame of the figure shows
    the FFT corresponding to that signal. The FFT is in the *frequency domain*; it’s
    showing what frequencies are present in the signal at a given moment in time.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13008.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-8: An audio signal containing multiple frequencies (top) and its
    corresponding FFT (bottom)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The wave in the top frame can be expressed by the following equation, which
    sums the two sine waves:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '*y*(*t*) = 4sin(2π10*t*) + 2.5sin(2π30*t*)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Notice the 4 and 10 in the expression for the first wave—4 is the amplitude
    of the wave, and 10 is the frequency (in hertz). Meanwhile, the second wave has
    an amplitude of 2.5 and a frequency of 30 Hz. Take a look at the FFT in the bottom
    frame of the figure and you’ll see it has two peaks, at 10 Hz and 30 Hz. The FFT
    has revealed the signal’s component frequencies. The FFT also identifies the relative
    amplitude of each frequency; the intensity of the first peak is about twice that
    of the second peak.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at a more realistic example. [Figure 13-9](nsp-venkitachalam503045-0028.xhtml#fig13-9)
    shows a complex audio signal in the top frame and the corresponding FFT in the
    bottom frame. Notice that the FFT contains many more peaks at a variety of intensities,
    indicating that the signal contains many more frequencies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13009.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-9: The FFT algorithm takes an amplitude signal (top) and computes
    its component frequencies (bottom).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: To compute an FFT, you need a set of samples. The choice of the number of samples
    is a bit arbitrary, but a small sample size wouldn’t give you a good picture of
    the signal’s frequency content and might also mean a higher computational load
    because you would need to compute more FFTs per second. On the other hand, a sample
    size that’s too large would average out the changes in the signal, so you wouldn’t
    be getting a “real-time” frequency response for the signal. For the purposes of
    this project, a sample size of 2,048 will work. At a sampling rate of 44,100 Hz,
    2,048 samples represent about 0.046 seconds of audio.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll use `numpy` to compute an FFT to split the audio data into its constituent
    frequencies, and then you’ll use that information to control the motors. First
    you’ll split the range of frequencies (in Hz) into three bands: [0, 100], [100,
    1000], and [1000, 2500]. You’ll compute an average amplitude level for each band,
    and each value will affect the motors and resulting laser pattern differently,
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: • Changes in the average amplitude of low frequencies will affect the speed
    of the first motor.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Changes in the average amplitude of middle frequencies will affect the speed
    of the second motor.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • When high frequencies peak above a certain threshold, the first motor will
    change direction.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these rules, the laser pattern will change in response to the audio signal.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1502)'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, you’ll use the following Python modules:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: • `RPi.GPIO` to set up PWM and control the output of the pins
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `time` for pausing between operations
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `wave` to read WAV files
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `pyaudio` to process and stream audio data
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `numpy` for FFT computations
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `argparse` to process command line arguments
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You’ll also need the following items to build the project:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: • One Raspberry Pi 3B+ or newer
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 5 V adapter to power the Raspberry Pi
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One powered speaker with AUX (line-in) input (most Bluetooth speakers have
    an AUX input these days)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One TB6612FNG motor breakout board
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One laser module breakout board
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 10 kΩ resistor
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One BS170 N-channel MOSFET or equivalent
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two DC motors like the ones used in a small toy, rated for 9 V
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two small mirrors, approximately 1 inch or less in diameter
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 3.7 V 18650 2000 mAh (3C) lithium-ion battery with holder (or use four
    AA batteries on a holder)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 3D-printed parts to fix the mirrors onto the motor shafts (optional)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One rectangular base, about 8 inches by 6 inches, to mount the hardware
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Some LEGO bricks to raise the motors and laser module off the base so the
    mirrors can spin freely
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • A hot glue gun
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Superglue to fix the mirrors to the motor shafts
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • A soldering iron
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • A breadboard
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Wires to make connections (single-core hookup wires with male pins on both
    sides work nicely)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Setting Up the Raspberry Pi](nsp-venkitachalam503045-0008.xhtml#rbh1503)'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To set up your Raspberry Pi, see [Appendix B](nsp-venkitachalam503045-0032.xhtml#appb).
    Follow the instructions in the appendix, and make sure you’ve installed the `numpy`
    and `pyaudio`Python packages required for this project. You’ll write code on the
    Raspberry Pi via a Secure Shell (SSH). You can set up Microsoft Visual Studio
    Code to work remotely on the Pi using an SSH from your laptop or desktop computer.
    This is also explained in [Appendix B](nsp-venkitachalam503045-0032.xhtml#appb).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[Constructing the Laser Display](nsp-venkitachalam503045-0008.xhtml#rbh1504)'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you hook up all the hardware, you should prepare the motors and the laser
    module for the laser display. The first order of business is to attach the mirrors
    to the motors. Each mirror has to be at a slight angle relative to the motor shaft.
    One way to do this would be to use hot glue. To attach the mirror, place it face
    down on a flat surface and put a drop of hot glue in the center. Carefully dip
    the motor shaft in the glue, keeping it at a slight angle to the perpendicular
    with respect to the mirror, until the glue hardens.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: A better way would be to use a motor flange with a slanted face to which you
    can easily stick the mirror. But where would you find such a part? You can make
    it yourself using 3D printing! [Figure 13-10(a)](nsp-venkitachalam503045-0028.xhtml#fig13-10)
    shows a 3D design I created using the free, open source program called OpenSCAD.
    You can download the design from this book’s GitHub repository. [Figure 13-10(b)](nsp-venkitachalam503045-0028.xhtml#fig13-10)
    shows the 3D printed parts. The mirror the laser strikes first will use the flange
    with the lesser tilt (5 degrees), and the second mirror will use the one with
    more tilt (10 degrees).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13010a.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: (a)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13010b.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: (b)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13-10: An OpenSCAD model (a) and 3D-printed flanges (b)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Print the flanges yourself if you have a 3D printer, or get them printed from
    a 3D printing service. (Either way, it will be inexpensive.) Once you have the
    parts, use superglue to attach the flanges to the motor shafts and the mirrors
    to the flanges. [Figure 13-11](nsp-venkitachalam503045-0028.xhtml#fig13-11) shows
    the fully assembled parts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13011.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-11: Attach the mirrors to each motor shaft at a slight angle.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: To test the assembly, spin the mirror with your hand while shining the laser
    module at it. You should find the reflection of the laser dot moves in an ellipse
    when projected on a flat surface. Do the same for the second mirror. It should
    create a wider ellipse because of the larger angle with respect to the motor shaft.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Aligning the Mirrors
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, align the laser module with the mirrors so that the laser reflects from
    mirror A to mirror B, as shown in [Figure 13-12](nsp-venkitachalam503045-0028.xhtml#fig13-12).
    Be sure that the reflected laser light from mirror A stays within the circumference
    of mirror B for mirror A’s entire range of rotation. (This will take some trial
    and error.) To test the arrangement, manually rotate mirror A. Also, be sure to
    position mirror B so that the light reflected from its surface will fall on a
    flat surface (like a wall) for the full range of rotation of both mirrors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13012.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-12: The alignment of the laser and the mirrors'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'NOTE As you tweak the alignment, you’ll need to keep the laser pointer on.
    You can do this by running the project code as follows: `python laser_audio.py
    --test_laser`. This command simply turns on the MOSFET controlling the laser module,
    as we’ll discuss later in the chapter.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re happy with the placement of the mirrors, hot-glue the laser module
    and the two motors with attached mirrors onto three identical blocks (LEGO blocks
    work great!) to raise them up so that the motors will be able to rotate freely.
    Next, place the blocks on the mounting board, and when you’re happy with their
    arrangement, mark the location of each by tracing their edge with a pencil. Then
    hot-glue the blocks onto the board. Or use a LEGO baseplate and simply attach
    the LEGO blocks to the baseplate.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Powering the Motors
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your motors didn’t come with wires attached to their terminals (most don’t),
    solder wires to both terminals, being sure to leave sufficient wire (say, 6 inches)
    so that you can attach the motors to the motor driver board. The motors can be
    powered by a 3.7 V lithium-ion battery, or a 4x AA battery pack.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[Hooking Up the Hardware](nsp-venkitachalam503045-0008.xhtml#rbh1505)'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now to hook up the hardware. You need to connect the Raspberry Pi, the motor
    driver board, the MOSFET, the laser module board, and the motors. The Raspberry
    Pi has a collection of GPIO pins for connecting to other hardware. To understand
    the pin layout, I highly recommend you visit the website [https://pinout.xyz](https://pinout.xyz/).
    It gives you a handy visual reference and explains the various pin functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: NOTE There are a few different conventions for referring to pin numbers on a
    Raspberry Pi. For this project, we’ll use the *BCM pin-numbering* convention.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 13-1](nsp-venkitachalam503045-0028.xhtml#tab13-1) lists the connections
    you need to make.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-1: Hardware Wiring Connections'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '| From | To |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi GPIO 12 | TB6612FNG PWMA |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi GPIO 13 | TB6612FNG PWMB |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi GPIO 7 | TB6612FNG AIN1 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi GPIO 8 | TB6612FNG AIN2 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi GPIO 5 | TB6612FNG BIN1 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi GPIO 6 | TB6612FNG BIN2 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi GPIO 22 | TB6612FNG STBY |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi GND | TB6612FNG GND |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi 3V3 | TB6612FNG VCC |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi GPIO 25 | BS170 GATE (also to GND via 10 kΩ resistor) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi GND | BS170 SOURCE |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| Laser module GND | BS170 DRAIN |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| Laser module VCC | Battery pack VCC (+) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| Battery pack GND (−) | TB6612FNG GND |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| Battery pack VCC (+) | TB6612FNG VM |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| Motor #1 connector #1 (polarity doesn’t matter) | TB6612FNG A01 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| Motor #1 connector #2 (polarity doesn’t matter) | TB6612FNG A02 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| Motor #2 connector #1 (polarity doesn’t matter) | TB6612FNG B01 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| Motor #2 connector #2 (polarity doesn’t matter) | TB6612FNG B02 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi 3.5 mm audio jack | AUX input of powered speaker |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '[Figure 13-13](nsp-venkitachalam503045-0028.xhtml#fig13-13) shows everything
    wired up.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13013.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-13: The completely wired-up laser display'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1503)'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for this project is in the file *laser_audio.py*. You’ll begin with
    some basic setup. Then you’ll define functions to operate and test the motors
    and laser, as well as a function to process audio data from a WAV file and control
    the motors based on that data. You’ll bring everything together and accept command
    line options through the `main()` function. To see the full program, skip ahead
    to [“The Complete Code”](nsp-venkitachalam503045-0028.xhtml#ah1507) on [page 305](nsp-venkitachalam503045-0028.xhtml#p305).
    You can also download the code at [https://github.com/mkvenkit/pp2e/tree/main/laser_audio](https://github.com/mkvenkit/pp2e/tree/main/laser_audio).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Up](nsp-venkitachalam503045-0008.xhtml#rbh1506)'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Start by importing the required modules:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `RPi.GPIO` module lets you use the pins of the Raspberry Pi. You’ll use
    the `time` module to put delays in your code, and you’ll use `argparse` to add
    command line arguments to the program. The `pyaudio` and `wave` modules will help
    you read data from WAV files and output an audio stream. Finally, you’ll use `numpy`
    to compute the FFT of the audio data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you initialize a few global variables:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code stores the pin numbers for all the Raspberry Pi pins used in the project.
    `PWMA`, `PWMB`, `AIN1`, `AIN2`, `BIN1`, `BIN2`, and `STBY` are pins that connect
    to the TB6612FNG motor driver. The `LASER` pin will connect to the gate of the
    MOSFET, which can turn the laser module on and off. Note that you’re using the
    BCM pin-numbering convention here.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue with a few more global variables:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here you initialize the variables `pwm_a` and `pwm_b` that will represent `PWM`
    objects, which you’ll use to control the motors. You set them to `None` here because
    it’s too early in the code to create the actual `PWM` objects. You also set `CHUNK`,
    the number of audio data samples you’ll read in from the WAV file at a time, and
    `N`, the number of samples you’ll use to compute the FFT.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'You finish setting up by initializing the GPIO pins. This is necessary to use
    the pins. Define a function `init_pins()` for this purpose:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First you indicate that `pwm_a` and `pwm_b` are global variables ❶, since you’ll
    be setting them inside this function. Then you set the pin mode to the BCM numbering
    convention ❷. Next, you put the pin variables you set earlier into a `pins` list
    so you can declare them all to be output pins with one call ❸. Finally, you create
    two `PWM` objects and assign them to your global `pwm_a` and `pwm_b` variables.
    The argument `100` is the frequency, in hertz, of the signal that will drive each
    motor. You’ll vary the duty cycles of those signals to control the motors’ speeds
    using pulse width modulation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling the Hardware](nsp-venkitachalam503045-0008.xhtml#rbh1507)'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You need some helper functions to control the laser module and the motors.
    Let’s look first at the function that toggles the laser module:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function takes a parameter `on` that will be a Boolean `True/False` value.
    You pass that parameter to the `GPIO.output()` method to set the `LASER` pin on
    (`True`) or off (`False`). This will trigger the MOSFET to turn the laser module
    on or off.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define a function `start_motors()` to turn the motors on at the start
    of the project:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First you set the `STBY` (standby) pin to `HIGH` ❶, which in effect turns on
    the motor driver. Then you set the `AIN1` and `AIN2` pins to `HIGH` ❷ and `LOW`
    ❸, respectively. This will cause motor A to spin in one direction. (Swapping the
    `HIGH/LOW` values between the two pins would cause the motor to spin in the opposite
    direction.) You do the same thing for motor B. Lastly, you use your `PWM` objects
    to set the speed of the motors ❹. You set the duty cycle (which correlates to
    the motor speed) to 10 percent, a relatively low value, since this is just an
    initializing call.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need a function to stop the motors from spinning at the end of the
    project. Here’s the definition:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To stop the motors from spinning, you first stop the PWM signals going to the
    `PWMA` ❶ and `PWMB` ❷ pins. Then you set the `AIN1`, `AIN2`, `BIN1`, and `BIN2`
    pins all to `HIGH`, which has the effect of “braking” each motor to a stop. Finally,
    you disable the motor driver by setting the `STBY` pin to `LOW` ❸. Standby mode
    saves power when the motors aren’t required to function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: You need one more helper function to set the speed and direction of both motors.
    You’ll use this function to adjust the motors based on your real-time audio analysis.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `set_motor_speed_dir()` function takes four parameters: `dca` and `dcb`
    determine the duty cycle for each motor, while `dira` and `dirb` are Booleans
    that set the motors’ direction of rotation. You use the `ChangeDutyCycle()` method
    to update the duty cycles (speeds) of the motors to the values passed into the
    function ❶. Then you attend to the motors’ directions. If `dira` is `True` ❷,
    you set pins `AIN1` and `AIN2` to `HIGH` and `LOW`, respectively, which will let
    motor A spin in one direction. However, if `dira` is `False` ❸, you set the pins
    the opposite way, which will spin the motor in the other direction. You do the
    same thing for motor B using the `dirb` parameter.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[Processing the Audio](nsp-venkitachalam503045-0008.xhtml#rbh1508)'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The heart of this project is the `process_audio()` function, which reads audio
    data from a WAV file, outputs an audio stream with `pyaudio`, analyzes the audio
    data by computing an FFT, and uses the resulting analysis to control the motors.
    We’ll look at the function in sections.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You start by using the `wave` module to open the audio file passed into the
    `process_audio()` function ❶. The `wave.open()` function returns a `Wave_read`
    object, which you’ll use to read data from the WAV file. You print out some information
    about the WAV file read in ❷: `SW` is the sample width in bytes, `NCh` is the
    number of channels in the audio, and `SR` is the sampling rate. To keep the project
    simple, you’ll support only single-channel, 16-bit WAV files as input. You check
    for these specs ❸, and if the input doesn’t match, you return from the function.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Next, you create the `PyAudio` object that you’ll use to stream data from the
    WAV file to the output ❹. Then you open a `pyaudio` output stream (as indicated
    by the `output=True` argument), configuring it to have the same sample width,
    number of channels, and sample rate as the WAV file ❺. For the Raspberry Pi, the
    default sound output is the 3.5 mm audio jack on the board. As long as your speaker
    is plugged into this jack, you’ll hear the sound output.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the next part of the function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here you read `CHUNK` samples from the WAV file into variable `data` ❶. Remember,
    you’ve set `CHUNK` to `2048`, and each sample is 2 bytes wide, so you’ll be reading
    a total of 2,048 16-bit values. You read only one chunk of data because of how
    the function’s main loop is structured, as you’ll see soon.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The `readframes()` method returns a `bytes` object, but you use the `numpy`
    library’s `frombuffer()` function to convert the `bytes` object into a `numpy`
    array of 16-bit integers called `buf` ❷. You store the sampling rate (the `wave`
    module calls it the *frame rate*) in variable `SR` ❸; you’ll need it later. Then
    you call the `start_motors()` and `laser_on()` functions, which we’ve already
    discussed, to get the motors and the laser module going.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Next, you enter the function’s main loop, which outputs the audio and performs
    the FFT. The loop works on one chunk of audio data at a time, which is why you
    read only a single chunk of data in the previous code listing. Notice that the
    loop occurs inside a `try` block. Later, you’ll write an `except` block to handle
    any problems that arise during the execution of the loop.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The main loop repeats until `data` is empty ❶, meaning you’ve gotten to the
    end of the WAV file. In the loop, you write the current chunk of data to the `pyaudio`
    output stream ❷. This will allow you to hear the WAV file you’re processing at
    the same time that you’re driving the motors. Then you check whether you have
    `N` samples in the current chunk of data to calculate the FFT ❸ (you set `N` to
    `2048`, the same as the chunk size, at the start of the code). This check is required
    because the last chunk of data read in may not have the full number of samples
    needed for the FFT. In that case, you’ll simply skip calculating the FFT and updating
    the motors, since the audio file is basically over anyway.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you load the audio data into a `numpy` array of 16-bit integers ❹. With
    the data in this format, computing the FFT is quite straightforward: you simply
    use the `rfft()` method from the `numpy.fft` module ❺. This method takes a signal
    composed of *real numbers* (like the audio data) and computes the FFT, which generally
    results in a set of *complex numbers*. You want to keep working with real numbers,
    however, so you use the `abs()` method to get the magnitudes of these complex
    numbers, which are real ❻. The `2.0/N` is a normalization factor you use to map
    the FFT values to the expected range.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing the loop, you extract the relevant information from the FFT to control
    the motors. To analyze the audio signal, you split the frequency range into three
    bands: 0 to 100 Hz (bass), 100 to 1,000 Hz (midrange), and 1,000 to 2,500 Hz (treble).
    You’re especially interested in the bass and midrange frequency bands, which roughly
    correspond to the beat and the vocals in a song, respectively. You compute the
    average amplitude value of the frequencies in each band by using the `numpy.``sum()`
    method and dividing the result by the number of frequencies in that band ❼. You
    store the three averages in a Python list.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that you’re doing two different things in the `while` loop: sending
    audio to the output and computing the FFT of the same audio. You’re able to do
    this and maintain the audio output because the `numpy` FFT computation is fast
    enough—it finishes before the current chunk of audio data has finished playing.
    Try an experiment: put a time delay right after FFT, and see what happens to the
    sound output!'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Now you need to convert the average amplitudes from the FFT into motor speeds
    and directions, still within the `while` loop started in the previous listing.
    The speeds need to be percentages, while the directions need to be `True/False`
    values.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First you take the value from the lowest frequency band, scale it by a factor
    of `5`, convert it to an integer, and use the modulus operator (`percent`) to
    ensure that the value lies within the [0, 60] range ❶. This value controls the
    speed of motor A. Then you add `100` to the value from the middle frequency band
    and again use the modulus operator to place it in the [0, 60] range ❷. This value
    controls the speed of motor B.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: NOTE It’s not a good idea to run the motors too fast at first, which is why
    this code limits the motors’ speeds to 60 percent. Once you’re confident the display
    is working, you can try increasing the speed threshold at ❶ and ❷.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: By default, you set `dira` to `False` to run motor A in one direction, but you
    switch to the other direction if the value from the highest frequency band crosses
    above a threshold of `0.1` ❸. Meanwhile, you keep motor B’s direction constant
    by setting `dirb` to `True`. Finally, you call your `set_motor_speed_dir()` function
    to run the motors at the speeds and directions you’ve calculated ❹.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: NOTE There’s no particularly elegant rule governing how you convert the FFT
    information to motor speeds and directions. The FFT values change constantly with
    the audio signal, so any method you come up with will change the laser pattern
    in response to the music. I arrived at the method described here through trial
    and error; I looked at FFT values while playing various types of music and chose
    calculations that produced a nice variety of patterns. I encourage you to play
    with the calculations and create your own conversions. There are no wrong answers
    here, as long as your method puts the motor speeds in the [0, 100] range (or less
    to avoid high speeds) and sets the directions to be `True` or `False`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the remainder of the `process_audio()` function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First you conclude the `while` loop by reading in the next chunk of audio data
    to be processed ❶. Recall that the `while` loop unfolds inside a `try` block.
    The `except` block ❷ catches any exceptions that may arise during the loop. For
    example, pressing CTRL-C while the program is running will throw an exception
    and halt the loop, as will any errors reading the data. You end by doing some
    cleanup in a `finally` block ❸ that will execute whether or not any exceptions
    are thrown. In this block, you stop the `pyaudio` output stream and close it,
    and you call your `stop_motors()` function to stop the motors from spinning.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[Testing the Motors](nsp-venkitachalam503045-0008.xhtml#rbh1509)'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For testing purposes, it would be useful to be able to manually set the speed
    and direction of the motors and view the resulting laser pattern. Here’s a `test_motors()`
    function that makes this possible:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You begin by turning on the laser ❶ and starting the motors ❷. Then you enter
    a loop to get information from the user. The loop prompts the user to enter four
    integer values ❸: `dca` and `dcb` are the duty cycles (speeds) for the motors
    (from 0 to 100), and `dira` and `dirb` are the motor directions (0 or 1). You
    wait for the input, and then parse it, using `split()` to divide the input string
    into separate strings based on whitespace and a list comprehension to convert
    each substring into an integer ❹. After a sanity check to ensure that you did,
    in fact, get four numbers as input, you run the motors using the provided values
    ❺.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: This runs in a loop, so you can try inputting various speed and direction values
    to see the result. Since the `while` loop is placed inside a `try` block, pressing
    CTRL-C will throw an exception and exit from the test when you’re ready. Then,
    in the `finally` block ❻, you stop the motors and turn the laser off.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[Putting It All Together](nsp-venkitachalam503045-0008.xhtml#rbh1510)'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As usual, the `main()` function takes in command line arguments and sets the
    project in motion. Let’s look at the command line arguments first:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here you follow the familiar pattern of creating an `ArgumentParser` object
    to parse command line arguments for the program ❶. The program will support three
    different command line arguments. The `--test_laser` option just turns the laser
    on and is useful when you’re building the motor and laser assembly. The `--test_motors`
    option is for testing the motors, and the `--wav_file` option lets you specify
    the WAV file to be read in for the laser audio display.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the rest of the `main()` function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You call the `init_pins()` function you defined earlier to initialize the Raspberry
    Pi’s GPIO pins ❶. Next, you go through and process the command line arguments.
    If the user typed in the `--test_laser` argument, `args.test_laser` will be set
    to `True`. You handle this case by turning on the laser and waiting for the user
    to press CTRL-C to terminate the loop ❷. Similarly, you handle the `--test_motors`
    option by calling `test_motors()` ❸. To start the laser audio display, the user
    needs to use the `--wav_file` command line argument. In this case ❹, you call
    the `process_audio()` function. Once again, all this is embedded in a `try` block,
    so when the user presses CTRL-C, you break out of the loop for any of the three
    modes. To finish, you turn the laser off ❺ and do a GPIO cleanup ❻ before exiting
    the program.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[Running the Laser Display](nsp-venkitachalam503045-0008.xhtml#rah1504)'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test the project, assemble the hardware, make sure the battery pack is connected,
    and position everything so the laser is projecting onto a flat surface such as
    a wall. Then use SSH to log in to your Raspberry Pi as discussed in [Appendix
    B](nsp-venkitachalam503045-0032.xhtml#appb) and run the program from a shell.
    I recommend testing the laser display part first by running the program in test
    mode.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: WARNING The project has high-speed spinning mirrors. Please wear appropriate
    eye protection or cover the setup with a transparent box before running the program
    to avoid injuries.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample run of the test mode:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can use this test to run both motors through various combinations of speeds
    and directions. You should see different laser patterns projected onto your wall
    as you change the values. To stop the program and the motors, press CTRL-C. Note
    that if you enter duty cycle (speed) values greater than 80, the motors will spin
    really fast. Be careful!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'If the test succeeds, you’re ready to move on to the real show. Copy a WAV
    file of your favorite music to the Raspberry Pi. Remember that to keep things
    simple, the program accepts only single-channel WAV files in 16-bit format. You
    can convert any audio file to this format using the free software Audacity. (A
    sample file is also available in the project’s GitHub repository.) When the audio
    file is in place, run the program as follows, substituting your desired filename
    after the `--wave_file` option:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should see the laser display produce lots of interesting patterns that change
    in time with the music, as shown in [Figure 13-14](nsp-venkitachalam503045-0028.xhtml#fig13-14).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13014.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-14: The complete wiring of the laser display and a pattern projected
    on the wall'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Try experimenting with different WAV files, or with different calculations for
    converting the FFT information to motor settings, to see how the visualization
    responds.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1505)'
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you upped your Python and hardware skills by building a fairly
    complex project. You learned how to control motors with Python, a Raspberry Pi,
    and a motor driver. You used `numpy` to compute the FFT of audio data, and you
    used `pyaudio` to stream audio output in real time. You even learned to control
    a laser using a MOSFET!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1506)'
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some ways you can modify this project:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The program used an arbitrary scheme to convert the FFT values into motor
    speed and direction data. Try changing this scheme. For example, experiment with
    different frequency bands and criteria for changing motor directions.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '2\. In this project, you converted frequency information gathered from the
    audio signal into motor speed and direction settings. Try making the motors move
    according to the overall “pulse” or volume of the music instead. For this, you
    can compute the *root* *mean square (RMS)* value of the amplitude of the signal.
    This computation is similar to the FFT calculation. Once you read in a chunk of
    audio data and put it into a `numpy` array `x`, you can compute the RMS value
    as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also, remember that the amplitude in your project was expressed as a 16-bit
    signed integer, which can have a maximum value of 32,768 (a useful number to keep
    in mind for normalization). Use this RMS amplitude in conjunction with the FFT
    to generate a greater variation of laser patterns.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3\. You know now that the frequency content, and hence the FFT of the audio
    data, changes in sync with the audio. Can you create a real-time visualization
    like the one shown in [Figure 13-15](nsp-venkitachalam503045-0028.xhtml#fig13-15),
    of both the audio data and the FFT as the audio plays through a speaker? This
    is intended to run on your computer, not your Raspberry Pi.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f13015.jpg)'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 13-15: A real-time FFT visualization'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here are a few hints to solve this problem:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ◦ Use `matplotlib` for plotting.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ◦ Use Python’s `multiprocessing` package so your music streaming output and
    plotting can happen simultaneously.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ◦ Use the `numpy.fft.``rfftfreq()` method to get the frequencies corresponding
    to the FFT values, for ease of plotting.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (The solution code for this experiment is in the book’s GitHub repository, but
    give it a shot yourself first!)
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah1507)'
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the complete Python code for this project:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
