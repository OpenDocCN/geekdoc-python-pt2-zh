- en: '[13](nsp-venkitachalam503045-0008.xhtml#rch13)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[13](nsp-venkitachalam503045-0008.xhtml#rch13)'
- en: Laser Audio Display with a Raspberry Pi
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用树莓派的激光音频显示
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: In [Chapter 12](nsp-venkitachalam503045-0027.xhtml#ch12), you used a Pico, a
    tiny microcontroller, to generate musical tones. In this chapter, you’ll use a
    much more powerful embedded system, the Raspberry Pi, to produce interesting laser
    patterns based on audio signals.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](nsp-venkitachalam503045-0027.xhtml#ch12)中，你使用了一个微型微控制器Pico来生成音乐音调。在本章中，你将使用功能更强大的嵌入式系统——树莓派，根据音频信号产生有趣的激光图案。
- en: The [previous chapter’s](nsp-venkitachalam503045-0027.xhtml#ch12) Pico had an
    RP2040 microcontroller with dual ARM Cortex-M0 processors running at speeds of
    up to 133 MHz, with 264KB of random access memory (RAM) and 2MB of nonvolatile
    storage on an external flash chip. The Raspberry Pi 3B+, in comparison, has a
    much more capable ARM Cortex-A53 processor operating at 1.4 GHz, with 1GB of RAM
    and storage of several gigabytes, depending on the SD card you use. While this
    still pales in comparison to a standard desktop or laptop computer, the Pi is
    nonetheless capable of running a Linux-based operating system and full-fledged
    Python, unlike the Pico.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章](nsp-venkitachalam503045-0027.xhtml#ch12)中的Pico使用了RP2040微控制器，配有双ARM Cortex-M0处理器，运行速度最高可达133
    MHz，具有264KB的随机存取内存（RAM）和2MB的外部闪存非易失存储。相比之下，树莓派3B+配备了更强大的ARM Cortex-A53处理器，主频为1.4
    GHz，具有1GB的RAM和根据所使用的SD卡存储几GB的存储空间。尽管与标准的桌面或笔记本计算机相比仍显不足，但树莓派依然能够运行基于Linux的操作系统和完整的Python，与Pico不同。'
- en: In this chapter, you’ll use Python on the Raspberry Pi to read an audio file
    in the WAV format, perform computations based on the real-time audio data, and
    use that data to adjust the speed and direction of rotation of two motors in a
    laser display rig. You’ll attach mirrors to the motors to reflect the beam from
    an inexpensive laser module, producing Spirograph-like patterns that change in
    response to the audio. You’ll also simultaneously stream the audio to a speaker
    so you can hear the WAV file playing as you watch your laser light show.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用树莓派上的Python来读取WAV格式的音频文件，基于实时音频数据进行计算，并利用这些数据调整激光显示装置中两个电机的旋转速度和方向。你将把镜子安装到电机上，通过一个廉价的激光模块反射激光束，产生类似螺旋图的图案，这些图案会根据音频的变化而变化。你还会同时将音频流传输到扬声器，让你在观看激光光秀时能听到WAV文件的播放。
- en: 'This project will push your knowledge of Python further as you learn to use
    the Raspberry Pi. Here are some of the topics we’ll cover:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将进一步扩展你对Python的理解，因为你将学习如何使用树莓派。以下是我们将要覆盖的一些主题：
- en: • Generating interesting patterns with a laser and two rotating mirrors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用激光和两个旋转镜子生成有趣的图案
- en: • Getting frequency information from a signal using the fast Fourier transform
    (FFT)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用快速傅里叶变换（FFT）获取信号的频率信息
- en: • Computing FFTs using `numpy`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`numpy`计算FFT
- en: • Reading audio from WAV files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 从WAV文件读取音频
- en: • Outputting audio data using `pyaudio`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`pyaudio`输出音频数据
- en: • Driving motors with a Raspberry Pi
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用树莓派驱动电机
- en: • Toggling a laser module on/off with a metal-oxide-semiconductor field-effect
    transistor (MOSFET)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用金属氧化物半导体场效应晶体管（MOSFET）切换激光模块的开/关
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1501)'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[工作原理](nsp-venkitachalam503045-0008.xhtml#rah1501)'
- en: You’ll use a Raspberry Pi to work with the audio data and control the hardware.
    [Figure 13-1](nsp-venkitachalam503045-0028.xhtml#fig13-1) shows a block diagram
    of what you’ll create in this project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用树莓派处理音频数据并控制硬件。[图13-1](nsp-venkitachalam503045-0028.xhtml#fig13-1)显示了你在这个项目中将创建的框图。
- en: '![](images/nsp-venkitachalam503045-f13001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13001.jpg)'
- en: 'Figure 13-1: A block diagram of the laser audio project'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1：激光音频项目的框图
- en: The Raspberry Pi will use a WAV file in two ways. It will play the file through
    an attached speaker by way of `pyaudio`, while also analyzing the audio data in
    real time using a mathematical technique called a *fast Fourier transform (FFT)*.
    The Pi will use data from the FFT to drive the motors and laser via its general-purpose
    input/output (GPIO) pins, but to protect the Pi from damage, you won’t hook it
    up directly to these external components. Instead, you’ll connect it indirectly
    through a motor driver board and a MOSFET. Before you begin, let’s consider in
    more detail how some of these aspects of the project will work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派将通过两种方式使用WAV文件。它将通过连接的扬声器通过`pyaudio`播放该文件，同时使用一种叫做*快速傅里叶变换（FFT）*的数学技术实时分析音频数据。树莓派将使用FFT的数据来驱动电机和激光，通过其通用输入输出（GPIO）引脚，但为了保护树莓派不受损害，你不会直接将其连接到这些外部组件上。相反，你将通过电机驱动板和MOSFET间接连接它。在你开始之前，让我们更详细地了解一下这些项目方面是如何运作的。
- en: '[Generating Patterns with a Laser](nsp-venkitachalam503045-0008.xhtml#rbh1501)'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[用激光生成图案](nsp-venkitachalam503045-0008.xhtml#rbh1501)'
- en: To generate the laser patterns in this project, you’ll use a laser module and
    two mirrors attached to the shafts of two small DC motors, as shown in [Figure
    13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2). Think of the laser as an intense
    beam of light that remains focused on a tiny point, even when projected over a
    large distance. This focus is possible because the beam is organized so that its
    waves travel in one direction only and are in phase with each other. If you shine
    the laser at the surface of a flat mirror (mirror A in [Figure 13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)),
    the reflection projected will remain a fixed point, even as the motor spins. Because
    the plane of reflection of the laser is perpendicular to the spinning axis of
    the motor, it’s as if the mirror isn’t rotating at all.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这个项目中生成激光图案，你将使用一个激光模块和两个附着在两个小直流电机轴上的镜子，如[图13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)所示。可以把激光看作是一束强烈的光束，即使在大距离上投射，它依然能够保持聚焦在一个微小的点上。这种聚焦得以实现，因为激光束是有序的，其波只沿一个方向传播，并且彼此相位一致。如果你将激光照射到平面镜的表面上（如[图13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)中的镜子A），即使电机旋转，反射出来的点也将保持固定。因为激光的反射平面是垂直于电机旋转轴的，就好像镜子根本没有旋转一样。
- en: Now, say the mirror is attached at an angle relative to the motor shaft, as
    shown on the right of [Figure 13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)
    (mirror B). As the shaft rotates, the projected point will trace an ellipse, and
    if the motor is spinning fast enough, the viewer will perceive the moving dot
    as a continuous shape.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设镜子相对于电机轴的角度是固定的，如[图13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)右侧所示（镜子B）。随着轴的旋转，投射出的点将描绘出一个椭圆，如果电机旋转得足够快，观察者将会看到一个连续的图形。
- en: '![](images/nsp-venkitachalam503045-f13002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13002.jpg)'
- en: 'Figure 13-2: The flat mirror (mirror A) reflects a single dot. The reflection
    off the slanted mirror (mirror B) creates a circle as the motor spins.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2：平面镜（镜子A）反射出一个点。倾斜镜（镜子B）的反射在电机旋转时形成一个圆形。
- en: What if both mirrors are slanted and you arrange them so that the point reflected
    off mirror A is projected onto mirror B? Now when motors A and B spin, the pattern
    created by the reflected point will be a combination of the two rotational movements
    of motors A and B, producing interesting patterns, as shown in [Figure 13-3](nsp-venkitachalam503045-0028.xhtml#fig13-3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个镜子都倾斜，并且你将它们排列成让从镜子A反射出来的点投射到镜子B上呢？现在，当A和B电机旋转时，反射点所形成的图案将是A和B电机两个旋转运动的结合，产生有趣的图案，如[图13-3](nsp-venkitachalam503045-0028.xhtml#fig13-3)所示。
- en: '![](images/nsp-venkitachalam503045-f13003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13003.jpg)'
- en: 'Figure 13-3: Reflecting laser light off two rotating, slanted mirrors produces
    interesting, complex patterns.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-3：激光光线从两个旋转的倾斜镜子反射，产生有趣而复杂的图案。
- en: The exact patterns produced will depend on the speed and direction of rotation
    of the two motors, but they will be similar to the hypotrochoids produced by the
    Spirograph you explored in [Chapter 2](nsp-venkitachalam503045-0013.xhtml#ch02).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的具体图案将取决于两个电机的旋转速度和方向，但它们将类似于你在[第2章](nsp-venkitachalam503045-0013.xhtml#ch02)中探索的由Spirograph生成的假圆线图案。
- en: Motor Control
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电机控制
- en: You’ll use the Raspberry Pi to control the speed and direction of your motors
    through a technique called *pulse width modulation (**PWM)*. This is a way to
    power a device (such as a motor) by sending digital pulses that switch on and
    off quickly, such that the device “sees” a continuous voltage. The signal sent
    to the device has a fixed frequency, but the fraction of time that the digital
    pulse is on, called the *duty cycle*, can vary. The duty cycle is expressed as
    a percentage. To illustrate, [Figure 13-4](nsp-venkitachalam503045-0028.xhtml#fig13-4)
    shows three signals with the same frequency but different duty cycles—25 percent,
    50 percent, and 75 percent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用树莓派通过一种叫做 *脉宽调制（PWM）* 的技术来控制电动机的速度和方向。这是一种通过发送快速开关的数字脉冲来为设备（如电动机）供电的方式，使得设备“看到”一个持续的电压。发送给设备的信号有固定的频率，但数字脉冲“开”状态的时间比例，即
    *占空比*，是可以变化的。占空比以百分比表示。为了说明，[图 13-4](nsp-venkitachalam503045-0028.xhtml#fig13-4)显示了三个频率相同但占空比不同的信号——分别为
    25%、50% 和 75%。
- en: '![](images/nsp-venkitachalam503045-f13004.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13004.jpg)'
- en: 'Figure 13-4: PWM signals with different duty cycles'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-4：具有不同占空比的 PWM 信号
- en: The higher the duty cycle percentage, the longer the pulse is on for each cycle
    of the signal. The motor receiving the signal will perceive those longer pulses
    as a higher continuous voltage. By manipulating the duty cycle, you can thus provide
    varying power levels to the motors in this project, which will result in variations
    in motor speed and changes in the laser pattern.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 占空比百分比越高，每个信号周期中脉冲的“开”时间就越长。接收信号的电动机会将这些更长的脉冲视为更高的持续电压。通过调整占空比，你可以为电动机提供不同的功率水平，从而实现电动机转速和激光模式的变化。
- en: NOTE PWM has many applications beyond motor control. It could also be used,
    for example, to control the brightness of dimmable LEDs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：PWM 除了在电动机控制中有应用外，还可以用于其他领域，例如控制可调光 LED 的亮度。
- en: Motors operate at a relatively high voltage, but the Raspberry Pi can handle
    only so much current before it’s damaged. You’ll be using a TB6612FNG motor driver
    breakout board, similar to the ones shown in [Figure 13-5](nsp-venkitachalam503045-0028.xhtml#fig13-5),
    to act as an intermediary between the Pi and the motors, keeping the Pi safe.
    Many variants of this board are available, and you can choose any one of them,
    as long as you’re careful to wire it up correctly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 电动机工作在相对较高的电压下，但树莓派只能处理一定量的电流，超过此限度会损坏。你将使用一个 TB6612FNG 电动机驱动拆解板，类似于[图 13-5](nsp-venkitachalam503045-0028.xhtml#fig13-5)中所示的板子，作为树莓派与电动机之间的中介，保护树莓派的安全。此板有许多不同的版本，你可以选择任何一个，只要确保正确连接。
- en: '![](images/nsp-venkitachalam503045-f13005.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13005.jpg)'
- en: 'Figure 13-5: TB6612FNG motor driver breakout printed circuit boards (PCBs)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-5：TB6612FNG 电动机驱动拆解 PCB（印刷电路板）
- en: The bottom of the breakout board should have pin information. It’s also a good
    idea to look at the TB6612FNG chip datasheet, which you can download from the
    internet. The *A* and *B* in the pin names denote the two motors. The IN pins
    control the direction of the motors, the 01 and 02 pins supply power to the motors,
    and the PWM pins use pulse width modulation to control the motor speeds. By writing
    to these pins, you can control both the direction and speed of rotation for each
    motor, which is exactly what you need for this project. We won’t go into the details
    of how this board works, but if you’re curious, you can start by reading up on
    an *H-bridge*, a common circuit design that uses MOSFETs to control motors.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 拆解板的底部应有引脚信息。查看 TB6612FNG 芯片的数据手册也是一个好主意，你可以从互联网下载。引脚名称中的 *A* 和 *B* 表示两个电动机。IN
    引脚控制电动机的方向，01 和 02 引脚为电动机提供电源，PWM 引脚使用脉宽调制控制电动机的转速。通过写入这些引脚，你可以控制每个电动机的旋转方向和速度，这正是你在这个项目中需要的功能。我们不会深入讲解该板的工作原理，但如果你感兴趣，可以先了解一下
    *H 桥*，这是一种常用的电路设计，利用 MOSFET 控制电动机。
- en: NOTE You could replace this breakout part with any motor control circuit you’re
    familiar with, as long as you modify the code appropriately.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以用任何你熟悉的电动机控制电路替代这个拆解部分，只要你适当修改代码即可。
- en: Laser Module
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 激光模块
- en: For the laser, you’ll use an inexpensive laser module breakout PCB similar to
    the one shown in [Figure 13-6](nsp-venkitachalam503045-0028.xhtml#fig13-6).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于激光器，你将使用一个廉价的激光模块拆解 PCB，类似于[图 13-6](nsp-venkitachalam503045-0028.xhtml#fig13-6)中所示的模块。
- en: '![](images/nsp-venkitachalam503045-f13006.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13006.jpg)'
- en: 'Figure 13-6: A laser module'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-6：激光模块
- en: Different variants of laser modules are available. You want one with a 650 nanometer
    (nm) red laser that operates at 5 volts (V). (The 650 nm refers to the laser’s
    wavelength.) Be sure you understand the polarity and connections of this board
    before you use it for the project. Test it separately using a 5 V power supply.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同型号的激光模块可供选择。你需要一个具有650纳米（nm）红色激光、并且在5伏（V）下工作的激光模块。（650 nm指的是激光的波长。）在使用这个模块进行项目之前，一定要了解这个电路板的极性和连接方式。使用5
    V电源单独测试它。
- en: MOSFET
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MOSFET
- en: To turn the laser module on and off using the Raspberry Pi, you’ll use an *N-channel
    MOSFET*, which you can think of as an electrically controlled switch. You can
    use almost any N-channel MOSFET for the project, but the BS170 is cheap and readily
    available. [Figure 13-7](nsp-venkitachalam503045-0028.xhtml#fig13-7) shows the
    pin numbering for the MOSFET, as well as how to connect it to the laser module
    and the Raspberry Pi.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过树莓派打开和关闭激光模块，你需要使用*N型MOSFET*，它可以被视为一个电控开关。几乎任何N型MOSFET都可以用于这个项目，但BS170便宜且容易获得。[图13-7](nsp-venkitachalam503045-0028.xhtml#fig13-7)显示了MOSFET的引脚编号，以及如何将其连接到激光模块和树莓派。
- en: '![](images/nsp-venkitachalam503045-f13007.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13007.jpg)'
- en: 'Figure 13-7: BS170 MOSFET connections'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-7：BS170 MOSFET连接
- en: The 10 kΩ resistor “pulls” the gate pin of the MOSFET to the ground, so it isn’t
    triggered when the Raspberry Pi GPIO pin is in a floating state (for example,
    after a GPIO cleanup). When you send a HIGH to the GPIO, the MOSFET switch turns
    on, effectively connecting the laser module to VM and GND and powering it on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 10 kΩ电阻“拉”MOSFET的栅极引脚到地，从而避免在树莓派GPIO引脚处于浮动状态时（例如，在GPIO清理后）触发MOSFET。当你向GPIO发送HIGH信号时，MOSFET开关打开，激光模块连接到VM和GND，并通电启动。
- en: Why do you need a MOSFET? Can’t you just connect the laser module directly to
    a GPIO pin of the Raspberry Pi? That’s not a great idea, because the MOSFET can
    take a lot more current than your Raspberry Pi. Using a MOSFET isolates your Pi
    from a situation that causes a current spike on the load. Better to burn your
    cheap MOSFET than your comparatively expensive Raspberry Pi! In general, the MOSFET
    trick is a good thing to remember whenever you want to control an external device
    with your Raspberry Pi.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要MOSFET？难道不能直接将激光模块连接到树莓派的GPIO引脚吗？那样做并不好，因为MOSFET能承受比树莓派更大的电流。使用MOSFET可以将树莓派与负载电流峰值的情况隔离开来。宁愿烧坏便宜的MOSFET，也不想烧坏相对较贵的树莓派！通常来说，每当你想通过树莓派控制外部设备时，记住MOSFET技巧是一个好主意。
- en: '[Analyzing Audio with the Fast Fourier Transform](nsp-venkitachalam503045-0008.xhtml#rbh1502)'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用快速傅里叶变换分析音频](nsp-venkitachalam503045-0008.xhtml#rbh1502)'
- en: Because the ultimate goal in this project is to control motor speeds based on
    audio input, you need to be able to analyze the audio in real time. Recall from
    [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04) that tones from an acoustic
    instrument are a mix of several frequencies, or overtones. In fact, any sound
    can be decomposed into its constituent frequencies using a *Fourier transform*.
    When the Fourier transform is applied to digital signals, the result is called
    the *discrete Fourier transform (**DFT)* because digital signals are composed
    of many discrete samples. In this project, you’ll use Python to implement a *fast
    Fourier transform (FFT)* algorithm to compute the DFT. (Throughout this chapter,
    I’ll use *FFT* to refer to both the algorithm and the result.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本项目的最终目标是根据音频输入控制电机速度，你需要能够实时分析音频。回忆一下[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)，来自声学乐器的音调是几种频率或泛音的混合。事实上，任何声音都可以使用*傅里叶变换*分解为其组成的频率。当傅里叶变换应用于数字信号时，结果被称为*离散傅里叶变换（**DFT）*，因为数字信号是由许多离散的采样点组成的。在这个项目中，你将使用Python实现*快速傅里叶变换（FFT）*算法来计算DFT。（在本章中，我将使用*FFT*来同时指代算法和结果。）
- en: '[Figure 13-8](nsp-venkitachalam503045-0028.xhtml#fig13-8) shows a simple example
    of an FFT. The top frame of the figure shows the waveform of a signal that combines
    just two sine waves. This plot is in the *time domain* because it’s showing how
    the signal’s amplitude varies over time. The bottom frame of the figure shows
    the FFT corresponding to that signal. The FFT is in the *frequency domain*; it’s
    showing what frequencies are present in the signal at a given moment in time.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-8](nsp-venkitachalam503045-0028.xhtml#fig13-8)展示了一个简单的FFT示例。图中的上框展示了一个结合了两个正弦波的信号波形。这个图是*时域图*，因为它展示了信号的幅度如何随时间变化。图中的下框展示了与该信号对应的FFT。FFT是在*频域图*中，它展示了信号在某一时刻包含的频率。'
- en: '![](images/nsp-venkitachalam503045-f13008.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13008.jpg)'
- en: 'Figure 13-8: An audio signal containing multiple frequencies (top) and its
    corresponding FFT (bottom)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-8：一个包含多个频率的音频信号（上图）及其对应的FFT（下图）
- en: 'The wave in the top frame can be expressed by the following equation, which
    sums the two sine waves:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上框中的波形可以通过以下方程表示，它将两个正弦波相加：
- en: '*y*(*t*) = 4sin(2π10*t*) + 2.5sin(2π30*t*)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*(*t*) = 4sin(2π10*t*) + 2.5sin(2π30*t*)'
- en: Notice the 4 and 10 in the expression for the first wave—4 is the amplitude
    of the wave, and 10 is the frequency (in hertz). Meanwhile, the second wave has
    an amplitude of 2.5 and a frequency of 30 Hz. Take a look at the FFT in the bottom
    frame of the figure and you’ll see it has two peaks, at 10 Hz and 30 Hz. The FFT
    has revealed the signal’s component frequencies. The FFT also identifies the relative
    amplitude of each frequency; the intensity of the first peak is about twice that
    of the second peak.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意第一个波形表达式中的4和10—4是波的幅度，10是频率（以赫兹为单位）。与此同时，第二个波形的幅度为2.5，频率为30赫兹。查看下框中的FFT图，你会看到它有两个峰，分别位于10赫兹和30赫兹。FFT揭示了信号的组成频率。FFT还标识了每个频率的相对幅度；第一个峰的强度大约是第二个峰的两倍。
- en: Now let’s look at a more realistic example. [Figure 13-9](nsp-venkitachalam503045-0028.xhtml#fig13-9)
    shows a complex audio signal in the top frame and the corresponding FFT in the
    bottom frame. Notice that the FFT contains many more peaks at a variety of intensities,
    indicating that the signal contains many more frequencies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个更实际的例子。[图13-9](nsp-venkitachalam503045-0028.xhtml#fig13-9)展示了一个复杂的音频信号，上框中是该信号，下框是对应的FFT。请注意，FFT包含了更多的峰值，并且强度各不相同，表明该信号包含了更多的频率。
- en: '![](images/nsp-venkitachalam503045-f13009.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13009.jpg)'
- en: 'Figure 13-9: The FFT algorithm takes an amplitude signal (top) and computes
    its component frequencies (bottom).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-9：FFT算法接受一个幅度信号（上图），并计算其组成频率（下图）。
- en: To compute an FFT, you need a set of samples. The choice of the number of samples
    is a bit arbitrary, but a small sample size wouldn’t give you a good picture of
    the signal’s frequency content and might also mean a higher computational load
    because you would need to compute more FFTs per second. On the other hand, a sample
    size that’s too large would average out the changes in the signal, so you wouldn’t
    be getting a “real-time” frequency response for the signal. For the purposes of
    this project, a sample size of 2,048 will work. At a sampling rate of 44,100 Hz,
    2,048 samples represent about 0.046 seconds of audio.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算FFT，你需要一组样本。样本数量的选择有些随意，但样本量太小无法有效展示信号的频率内容，而且可能意味着更高的计算负担，因为你每秒需要计算更多的FFT。另一方面，样本量过大会平均掉信号中的变化，因此你无法得到信号的“实时”频率响应。对于本项目，2,048的样本量是可行的。在44,100赫兹的采样率下，2,048个样本大约代表0.046秒的音频。
- en: 'You’ll use `numpy` to compute an FFT to split the audio data into its constituent
    frequencies, and then you’ll use that information to control the motors. First
    you’ll split the range of frequencies (in Hz) into three bands: [0, 100], [100,
    1000], and [1000, 2500]. You’ll compute an average amplitude level for each band,
    and each value will affect the motors and resulting laser pattern differently,
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`numpy`计算FFT，将音频数据拆分成其组成频率，然后利用这些信息来控制电机。首先，你将把频率范围（以赫兹为单位）分成三个频段：[0, 100]，[100,
    1000]，和[1000, 2500]。你将计算每个频段的平均幅度水平，每个值将以不同的方式影响电机和激光模式，具体如下：
- en: • Changes in the average amplitude of low frequencies will affect the speed
    of the first motor.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 低频的平均幅度变化将影响第一个电机的速度。
- en: • Changes in the average amplitude of middle frequencies will affect the speed
    of the second motor.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 中频的平均幅度变化将影响第二个电机的速度。
- en: • When high frequencies peak above a certain threshold, the first motor will
    change direction.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 当高频信号超过某个阈值时，第一个电机会改变方向。
- en: With these rules, the laser pattern will change in response to the audio signal.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些规则，激光图案将根据音频信号发生变化。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1502)'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah1502)'
- en: 'In this project, you’ll use the following Python modules:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用以下Python模块：
- en: • `RPi.GPIO` to set up PWM and control the output of the pins
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `RPi.GPIO`用于设置PWM并控制引脚输出
- en: • `time` for pausing between operations
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `time`用于操作之间的暂停
- en: • `wave` to read WAV files
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `wave`用于读取WAV文件
- en: • `pyaudio` to process and stream audio data
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `pyaudio`用于处理和流式传输音频数据
- en: • `numpy` for FFT computations
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `numpy`用于FFT计算
- en: • `argparse` to process command line arguments
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `argparse`用于处理命令行参数
- en: 'You’ll also need the following items to build the project:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要以下物品来构建这个项目：
- en: • One Raspberry Pi 3B+ or newer
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一块树莓派3B+或更新版本
- en: • One 5 V adapter to power the Raspberry Pi
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个5V适配器为树莓派供电
- en: • One powered speaker with AUX (line-in) input (most Bluetooth speakers have
    an AUX input these days)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个带AUX（线路输入）接口的有源扬声器（现在大多数蓝牙扬声器都配有AUX接口）
- en: • One TB6612FNG motor breakout board
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个TB6612FNG电机扩展板
- en: • One laser module breakout board
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个激光模块扩展板
- en: • One 10 kΩ resistor
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个10 kΩ电阻
- en: • One BS170 N-channel MOSFET or equivalent
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个BS170 N-channel MOSFET或同等产品
- en: • Two DC motors like the ones used in a small toy, rated for 9 V
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个9V额定的小型直流电机，如玩具中使用的电机
- en: • Two small mirrors, approximately 1 inch or less in diameter
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两面小镜子，直径大约为1英寸或更小
- en: • One 3.7 V 18650 2000 mAh (3C) lithium-ion battery with holder (or use four
    AA batteries on a holder)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个3.7V 18650 2000mAh（3C）锂电池及电池座（或者使用四个AA电池和电池座）
- en: • Two 3D-printed parts to fix the mirrors onto the motor shafts (optional)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个3D打印部件，用于将镜子固定在电机轴上（可选）
- en: • One rectangular base, about 8 inches by 6 inches, to mount the hardware
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个大约8英寸×6英寸的矩形底座，用于安装硬件
- en: • Some LEGO bricks to raise the motors and laser module off the base so the
    mirrors can spin freely
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一些乐高积木，用来将电机和激光模块抬离底座，以便镜子可以自由旋转
- en: • A hot glue gun
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个热熔胶枪
- en: • Superglue to fix the mirrors to the motor shafts
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 强力胶水，用于将镜子固定在电机轴上
- en: • A soldering iron
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个电烙铁
- en: • A breadboard
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一块面包板
- en: • Wires to make connections (single-core hookup wires with male pins on both
    sides work nicely)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 用于连接的电线（双头带公头引脚的单芯连接线效果很好）
- en: '[Setting Up the Raspberry Pi](nsp-venkitachalam503045-0008.xhtml#rbh1503)'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置树莓派](nsp-venkitachalam503045-0008.xhtml#rbh1503)'
- en: To set up your Raspberry Pi, see [Appendix B](nsp-venkitachalam503045-0032.xhtml#appb).
    Follow the instructions in the appendix, and make sure you’ve installed the `numpy`
    and `pyaudio`Python packages required for this project. You’ll write code on the
    Raspberry Pi via a Secure Shell (SSH). You can set up Microsoft Visual Studio
    Code to work remotely on the Pi using an SSH from your laptop or desktop computer.
    This is also explained in [Appendix B](nsp-venkitachalam503045-0032.xhtml#appb).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置你的树莓派，请参见[附录B](nsp-venkitachalam503045-0032.xhtml#appb)。按照附录中的说明操作，并确保你已安装本项目所需的`numpy`和`pyaudio`Python包。你将在树莓派上通过安全外壳（SSH）编写代码。你可以设置Microsoft
    Visual Studio Code，以便通过SSH从你的笔记本或台式机远程操作树莓派。这些内容在[附录B](nsp-venkitachalam503045-0032.xhtml#appb)中也有解释。
- en: '[Constructing the Laser Display](nsp-venkitachalam503045-0008.xhtml#rbh1504)'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[构建激光显示](nsp-venkitachalam503045-0008.xhtml#rbh1504)'
- en: Before you hook up all the hardware, you should prepare the motors and the laser
    module for the laser display. The first order of business is to attach the mirrors
    to the motors. Each mirror has to be at a slight angle relative to the motor shaft.
    One way to do this would be to use hot glue. To attach the mirror, place it face
    down on a flat surface and put a drop of hot glue in the center. Carefully dip
    the motor shaft in the glue, keeping it at a slight angle to the perpendicular
    with respect to the mirror, until the glue hardens.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接所有硬件之前，你应该准备好电机和激光模块用于激光显示。首要任务是将镜子安装到电机上。每个镜子必须相对于电机轴稍微有一个角度。可以使用热胶来实现这一点。将镜子倒放在平面上，并在中心滴上一滴热胶。小心地将电机轴浸入胶水中，保持电机轴相对于镜子有一个微小的倾斜角度，直到胶水硬化。
- en: A better way would be to use a motor flange with a slanted face to which you
    can easily stick the mirror. But where would you find such a part? You can make
    it yourself using 3D printing! [Figure 13-10(a)](nsp-venkitachalam503045-0028.xhtml#fig13-10)
    shows a 3D design I created using the free, open source program called OpenSCAD.
    You can download the design from this book’s GitHub repository. [Figure 13-10(b)](nsp-venkitachalam503045-0028.xhtml#fig13-10)
    shows the 3D printed parts. The mirror the laser strikes first will use the flange
    with the lesser tilt (5 degrees), and the second mirror will use the one with
    more tilt (10 degrees).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用一个带有倾斜面的小型电机法兰盘，方便将镜面固定在其上。但这种部件在哪里能找到呢？你可以使用3D打印技术自行制作！[图13-10(a)](nsp-venkitachalam503045-0028.xhtml#fig13-10)展示了我使用免费开源程序OpenSCAD创建的3D设计。你可以从本书的GitHub仓库下载该设计。[图13-10(b)](nsp-venkitachalam503045-0028.xhtml#fig13-10)展示了3D打印的零件。激光首先照射的镜面将使用倾斜较小的法兰盘（5度），第二面镜子将使用倾斜较大的法兰盘（10度）。
- en: '![](images/nsp-venkitachalam503045-f13010a.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13010a.jpg)'
- en: (a)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '![](images/nsp-venkitachalam503045-f13010b.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13010b.jpg)'
- en: (b)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: 'Figure 13-10: An OpenSCAD model (a) and 3D-printed flanges (b)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-10：OpenSCAD模型（a）和3D打印的法兰盘（b）
- en: Print the flanges yourself if you have a 3D printer, or get them printed from
    a 3D printing service. (Either way, it will be inexpensive.) Once you have the
    parts, use superglue to attach the flanges to the motor shafts and the mirrors
    to the flanges. [Figure 13-11](nsp-venkitachalam503045-0028.xhtml#fig13-11) shows
    the fully assembled parts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有3D打印机，可以自行打印法兰盘，或者通过3D打印服务进行打印。（无论哪种方式，成本都不高。）当你得到这些零件后，使用超级胶水将法兰盘固定在电机轴上，再将镜面固定在法兰盘上。[图13-11](nsp-venkitachalam503045-0028.xhtml#fig13-11)展示了完全组装好的零件。
- en: '![](images/nsp-venkitachalam503045-f13011.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13011.jpg)'
- en: 'Figure 13-11: Attach the mirrors to each motor shaft at a slight angle.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-11：将镜面以轻微的角度连接到每个电机轴上。
- en: To test the assembly, spin the mirror with your hand while shining the laser
    module at it. You should find the reflection of the laser dot moves in an ellipse
    when projected on a flat surface. Do the same for the second mirror. It should
    create a wider ellipse because of the larger angle with respect to the motor shaft.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 测试组装时，使用手转动镜面，同时将激光模块照射在镜面上。你应该能看到激光点在平面表面上形成椭圆形的反射轨迹。对第二面镜子做同样的测试。由于与电机轴的角度较大，它会形成一个更宽的椭圆。
- en: Aligning the Mirrors
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整镜面
- en: Next, align the laser module with the mirrors so that the laser reflects from
    mirror A to mirror B, as shown in [Figure 13-12](nsp-venkitachalam503045-0028.xhtml#fig13-12).
    Be sure that the reflected laser light from mirror A stays within the circumference
    of mirror B for mirror A’s entire range of rotation. (This will take some trial
    and error.) To test the arrangement, manually rotate mirror A. Also, be sure to
    position mirror B so that the light reflected from its surface will fall on a
    flat surface (like a wall) for the full range of rotation of both mirrors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将激光模块与镜子对准，使得激光从镜面A反射到镜面B，如[图13-12](nsp-venkitachalam503045-0028.xhtml#fig13-12)所示。确保镜面A反射出来的激光光束在镜面A旋转的整个范围内，始终保持在镜面B的圆周内。（这需要通过多次试验。）要测试这个设置，手动旋转镜面A。同时，确保将镜面B调整到适当位置，使得其表面反射出来的光线能够照射到一个平面表面（比如墙面），并覆盖两个镜子旋转的整个范围。
- en: '![](images/nsp-venkitachalam503045-f13012.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13012.jpg)'
- en: 'Figure 13-12: The alignment of the laser and the mirrors'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-12：激光与镜面的对准
- en: 'NOTE As you tweak the alignment, you’ll need to keep the laser pointer on.
    You can do this by running the project code as follows: `python laser_audio.py
    --test_laser`. This command simply turns on the MOSFET controlling the laser module,
    as we’ll discuss later in the chapter.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在调整对准时，你需要保持激光指示器开启。你可以通过以下方式运行项目代码来实现：`python laser_audio.py --test_laser`。此命令仅仅是开启控制激光模块的MOSFET，稍后在本章中我们会详细讨论。
- en: Once you’re happy with the placement of the mirrors, hot-glue the laser module
    and the two motors with attached mirrors onto three identical blocks (LEGO blocks
    work great!) to raise them up so that the motors will be able to rotate freely.
    Next, place the blocks on the mounting board, and when you’re happy with their
    arrangement, mark the location of each by tracing their edge with a pencil. Then
    hot-glue the blocks onto the board. Or use a LEGO baseplate and simply attach
    the LEGO blocks to the baseplate.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对镜子的放置感到满意，用热熔胶将激光模块和两个带镜子的电机固定到三个相同的模块（LEGO模块效果很好！），以将它们抬高，使电机能够自由旋转。接下来，将这些模块放在安装板上，当你对它们的布局满意时，用铅笔描摹出它们的位置。然后用热熔胶将模块固定到板上。或者你也可以使用
    LEGO 底板，只需将 LEGO 模块固定在底板上即可。
- en: Powering the Motors
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电机供电
- en: If your motors didn’t come with wires attached to their terminals (most don’t),
    solder wires to both terminals, being sure to leave sufficient wire (say, 6 inches)
    so that you can attach the motors to the motor driver board. The motors can be
    powered by a 3.7 V lithium-ion battery, or a 4x AA battery pack.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电机没有带接线（大多数电机都没有），请将线缆焊接到电机的两个端子上，并确保留下足够的线（大约6英寸），这样你就可以将电机连接到电机驱动板。电机可以通过3.7V锂电池或4节AA电池供电。
- en: '[Hooking Up the Hardware](nsp-venkitachalam503045-0008.xhtml#rbh1505)'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[连接硬件](nsp-venkitachalam503045-0008.xhtml#rbh1505)'
- en: Now to hook up the hardware. You need to connect the Raspberry Pi, the motor
    driver board, the MOSFET, the laser module board, and the motors. The Raspberry
    Pi has a collection of GPIO pins for connecting to other hardware. To understand
    the pin layout, I highly recommend you visit the website [https://pinout.xyz](https://pinout.xyz/).
    It gives you a handy visual reference and explains the various pin functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始连接硬件。你需要连接树莓派、电机驱动板、MOSFET、激光模块板和电机。树莓派有一组 GPIO 引脚，用于连接其他硬件。为了了解引脚布局，我强烈推荐你访问网站
    [https://pinout.xyz](https://pinout.xyz/)。它为你提供了一个方便的视觉参考，并解释了各种引脚的功能。
- en: NOTE There are a few different conventions for referring to pin numbers on a
    Raspberry Pi. For this project, we’ll use the *BCM pin-numbering* convention.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：树莓派上有几种不同的引脚编号约定。在这个项目中，我们将使用*BCM 引脚编号*约定。
- en: '[Table 13-1](nsp-venkitachalam503045-0028.xhtml#tab13-1) lists the connections
    you need to make.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[表13-1](nsp-venkitachalam503045-0028.xhtml#tab13-1)列出了你需要连接的各个部分。'
- en: 'Table 13-1: Hardware Wiring Connections'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-1：硬件接线连接
- en: '| From | To |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 从 | 到 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Raspberry Pi GPIO 12 | TB6612FNG PWMA |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 GPIO 12 | TB6612FNG PWMA |'
- en: '| Raspberry Pi GPIO 13 | TB6612FNG PWMB |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 GPIO 13 | TB6612FNG PWMB |'
- en: '| Raspberry Pi GPIO 7 | TB6612FNG AIN1 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 GPIO 7 | TB6612FNG AIN1 |'
- en: '| Raspberry Pi GPIO 8 | TB6612FNG AIN2 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 GPIO 8 | TB6612FNG AIN2 |'
- en: '| Raspberry Pi GPIO 5 | TB6612FNG BIN1 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 GPIO 5 | TB6612FNG BIN1 |'
- en: '| Raspberry Pi GPIO 6 | TB6612FNG BIN2 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 GPIO 6 | TB6612FNG BIN2 |'
- en: '| Raspberry Pi GPIO 22 | TB6612FNG STBY |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 GPIO 22 | TB6612FNG STBY |'
- en: '| Raspberry Pi GND | TB6612FNG GND |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 GND | TB6612FNG GND |'
- en: '| Raspberry Pi 3V3 | TB6612FNG VCC |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 3V3 | TB6612FNG VCC |'
- en: '| Raspberry Pi GPIO 25 | BS170 GATE (also to GND via 10 kΩ resistor) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 GPIO 25 | BS170 GATE（也通过10kΩ电阻连接到GND） |'
- en: '| Raspberry Pi GND | BS170 SOURCE |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 GND | BS170 SOURCE |'
- en: '| Laser module GND | BS170 DRAIN |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 激光模块 GND | BS170 DRAIN |'
- en: '| Laser module VCC | Battery pack VCC (+) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 激光模块 VCC | 电池组 VCC (+) |'
- en: '| Battery pack GND (−) | TB6612FNG GND |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 电池组 GND (−) | TB6612FNG GND |'
- en: '| Battery pack VCC (+) | TB6612FNG VM |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 电池组 VCC (+) | TB6612FNG VM |'
- en: '| Motor #1 connector #1 (polarity doesn’t matter) | TB6612FNG A01 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 电机 #1 连接器 #1（极性无关） | TB6612FNG A01 |'
- en: '| Motor #1 connector #2 (polarity doesn’t matter) | TB6612FNG A02 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 电机 #1 连接器 #2（极性无关） | TB6612FNG A02 |'
- en: '| Motor #2 connector #1 (polarity doesn’t matter) | TB6612FNG B01 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 电机 #2 连接器 #1（极性无关） | TB6612FNG B01 |'
- en: '| Motor #2 connector #2 (polarity doesn’t matter) | TB6612FNG B02 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 电机 #2 连接器 #2（极性无关） | TB6612FNG B02 |'
- en: '| Raspberry Pi 3.5 mm audio jack | AUX input of powered speaker |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派 3.5 mm 音频插孔 | 有源扬声器的 AUX 输入 |'
- en: '[Figure 13-13](nsp-venkitachalam503045-0028.xhtml#fig13-13) shows everything
    wired up.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-13](nsp-venkitachalam503045-0028.xhtml#fig13-13)显示了所有的接线情况。'
- en: '![](images/nsp-venkitachalam503045-f13013.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13013.jpg)'
- en: 'Figure 13-13: The completely wired-up laser display'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-13：完全接线的激光显示器
- en: Now let’s look at the code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看代码。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1503)'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1503)'
- en: The code for this project is in the file *laser_audio.py*. You’ll begin with
    some basic setup. Then you’ll define functions to operate and test the motors
    and laser, as well as a function to process audio data from a WAV file and control
    the motors based on that data. You’ll bring everything together and accept command
    line options through the `main()` function. To see the full program, skip ahead
    to [“The Complete Code”](nsp-venkitachalam503045-0028.xhtml#ah1507) on [page 305](nsp-venkitachalam503045-0028.xhtml#p305).
    You can also download the code at [https://github.com/mkvenkit/pp2e/tree/main/laser_audio](https://github.com/mkvenkit/pp2e/tree/main/laser_audio).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的代码位于文件*laser_audio.py*中。你将从一些基本的设置开始。接着，你将定义函数来操作和测试电机与激光，并定义一个函数来处理WAV文件中的音频数据，根据这些数据控制电机。最终你将把所有内容结合起来，并通过`main()`函数接受命令行选项。若要查看完整的程序，请跳至[“完整代码”](nsp-venkitachalam503045-0028.xhtml#ah1507)（第305页）。你也可以在[https://github.com/mkvenkit/pp2e/tree/main/laser_audio](https://github.com/mkvenkit/pp2e/tree/main/laser_audio)下载代码。
- en: '[Setting Up](nsp-venkitachalam503045-0008.xhtml#rbh1506)'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置](nsp-venkitachalam503045-0008.xhtml#rbh1506)'
- en: 'Start by importing the required modules:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入所需的模块：
- en: import RPi.GPIO as GPIO
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: import RPi.GPIO as GPIO
- en: import time
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: import argparse
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: import argparse
- en: import pyaudio
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: import pyaudio
- en: import wave
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: import wave
- en: import numpy as np
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: The `RPi.GPIO` module lets you use the pins of the Raspberry Pi. You’ll use
    the `time` module to put delays in your code, and you’ll use `argparse` to add
    command line arguments to the program. The `pyaudio` and `wave` modules will help
    you read data from WAV files and output an audio stream. Finally, you’ll use `numpy`
    to compute the FFT of the audio data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPi.GPIO`模块让你使用树莓派的引脚。你将使用`time`模块在代码中加入延迟，并使用`argparse`来为程序添加命令行参数。`pyaudio`和`wave`模块将帮助你读取WAV文件中的数据并输出音频流。最后，你将使用`numpy`来计算音频数据的FFT。'
- en: 'Next, you initialize a few global variables:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，初始化一些全局变量：
- en: define pin numbers
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义引脚号
- en: uses TB6612FNG motor driver pin naming
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TB6612FNG 电机驱动器引脚命名
- en: PWMA = 12
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: PWMA = 12
- en: PWMB = 13
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: PWMB = 13
- en: AIN1 = 7
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: AIN1 = 7
- en: AIN2 = 8
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: AIN2 = 8
- en: BIN1 = 5
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: BIN1 = 5
- en: BIN2 = 6
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: BIN2 = 6
- en: STBY = 22
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: STBY = 22
- en: LASER = 25
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: LASER = 25
- en: This code stores the pin numbers for all the Raspberry Pi pins used in the project.
    `PWMA`, `PWMB`, `AIN1`, `AIN2`, `BIN1`, `BIN2`, and `STBY` are pins that connect
    to the TB6612FNG motor driver. The `LASER` pin will connect to the gate of the
    MOSFET, which can turn the laser module on and off. Note that you’re using the
    BCM pin-numbering convention here.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码存储了项目中使用的所有树莓派引脚的引脚号。`PWMA`、`PWMB`、`AIN1`、`AIN2`、`BIN1`、`BIN2`和`STBY`是连接到TB6612FNG电机驱动器的引脚。`LASER`引脚将连接到MOSFET的门极，用于控制激光模块的开关。注意，这里使用的是BCM引脚编号方式。
- en: 'Continue with a few more global variables:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 继续定义更多全局变量：
- en: global PWM objects
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: global PWM 对象
- en: pwm_a = None
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_a = None
- en: pwm_b = None
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_b = None
- en: size of audio data read in
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取的音频数据大小
- en: CHUNK = 2048
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: CHUNK = 2048
- en: FFT size
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FFT大小
- en: N = CHUNK
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: N = CHUNK
- en: Here you initialize the variables `pwm_a` and `pwm_b` that will represent `PWM`
    objects, which you’ll use to control the motors. You set them to `None` here because
    it’s too early in the code to create the actual `PWM` objects. You also set `CHUNK`,
    the number of audio data samples you’ll read in from the WAV file at a time, and
    `N`, the number of samples you’ll use to compute the FFT.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你初始化了变量`pwm_a`和`pwm_b`，它们将表示`PWM`对象，你将用它们来控制电机。由于在代码中太早创建实际的`PWM`对象，所以在此将它们设置为`None`。你还设置了`CHUNK`，它是你从WAV文件中一次读取的音频数据样本数，以及`N`，它是你用于计算FFT的样本数。
- en: 'You finish setting up by initializing the GPIO pins. This is necessary to use
    the pins. Define a function `init_pins()` for this purpose:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过初始化GPIO引脚来完成设置。这是使用引脚所必需的。为此，定义一个`init_pins()`函数：
- en: 'def init_pins():'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'def init_pins():'
- en: '"""set up pins"""'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '"""设置引脚"""'
- en: ❶ global pwm_a, pwm_b
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ global pwm_a, pwm_b
- en: '# use BCM pin numbering'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用 BCM 引脚编号方式'
- en: ❷ GPIO.setmode(GPIO.BCM)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ GPIO.setmode(GPIO.BCM)
- en: '# put pins into a list'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将引脚放入列表'
- en: pins = [PWMA, PWMB, AIN1, AIN2, BIN1, BIN2, STBY, LASER]
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: pins = [PWMA, PWMB, AIN1, AIN2, BIN1, BIN2, STBY, LASER]
- en: '# set up pins as outputs'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置引脚为输出'
- en: ❸ GPIO.setup(pins, GPIO.OUT)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ GPIO.setup(pins, GPIO.OUT)
- en: '# set PWM'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置 PWM'
- en: pwm_a = GPIO.PWM(PWMA, 100)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_a = GPIO.PWM(PWMA, 100)
- en: pwm_b = GPIO.PWM(PWMB, 100)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_b = GPIO.PWM(PWMB, 100)
- en: First you indicate that `pwm_a` and `pwm_b` are global variables ❶, since you’ll
    be setting them inside this function. Then you set the pin mode to the BCM numbering
    convention ❷. Next, you put the pin variables you set earlier into a `pins` list
    so you can declare them all to be output pins with one call ❸. Finally, you create
    two `PWM` objects and assign them to your global `pwm_a` and `pwm_b` variables.
    The argument `100` is the frequency, in hertz, of the signal that will drive each
    motor. You’ll vary the duty cycles of those signals to control the motors’ speeds
    using pulse width modulation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明`pwm_a`和`pwm_b`是全局变量 ❶，因为你将在这个函数内部设置它们。然后，你将引脚模式设置为BCM编号规范 ❷。接下来，你将之前设置的引脚变量放入`pins`列表中，这样你就可以通过一次调用将它们都声明为输出引脚
    ❸。最后，你创建两个`PWM`对象，并将它们分配给全局的`pwm_a`和`pwm_b`变量。参数`100`是驱动每个电机的信号频率（单位是赫兹）。你将通过调整这些信号的占空比来控制电机的速度，使用的是脉宽调制技术。
- en: '[Controlling the Hardware](nsp-venkitachalam503045-0008.xhtml#rbh1507)'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[控制硬件](nsp-venkitachalam503045-0008.xhtml#rbh1507)'
- en: 'You need some helper functions to control the laser module and the motors.
    Let’s look first at the function that toggles the laser module:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一些辅助函数来控制激光模块和电机。我们先来看一下切换激光模块的函数：
- en: 'def laser_on(on):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'def laser_on(on):'
- en: '# pin 25 controls laser ctrl mosfet'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '# 引脚25控制激光控制MOSFET'
- en: GPIO.output(LASER, on)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(LASER, on)
- en: This function takes a parameter `on` that will be a Boolean `True/False` value.
    You pass that parameter to the `GPIO.output()` method to set the `LASER` pin on
    (`True`) or off (`False`). This will trigger the MOSFET to turn the laser module
    on or off.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个参数`on`，它是一个布尔值`True/False`。你将该参数传递给`GPIO.output()`方法，以设置`LASER`引脚为开（`True`）或关（`False`）。这将触发MOSFET来控制激光模块的开关。
- en: 'Next, define a function `start_motors()` to turn the motors on at the start
    of the project:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数`start_motors()`来在项目开始时启动电机：
- en: 'def start_motors():'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'def start_motors():'
- en: '"""start both motors"""'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '"""启动两个电机"""'
- en: '# enable driver chip'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启用驱动芯片'
- en: ❶ GPIO.output(STBY, GPIO.HIGH)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ GPIO.output(STBY, GPIO.HIGH)
- en: '# set motor direction for channel A'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置A通道的电机方向'
- en: ❷ GPIO.output(AIN1, GPIO.HIGH)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ GPIO.output(AIN1, GPIO.HIGH)
- en: ❸ GPIO.output(AIN2, GPIO.LOW)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ GPIO.output(AIN2, GPIO.LOW)
- en: '# set motor direction for channel B'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置B通道电机方向'
- en: GPIO.output(BIN1, GPIO.HIGH)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN1, GPIO.HIGH)
- en: GPIO.output(BIN2, GPIO.LOW)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN2, GPIO.LOW)
- en: '# set PWM for channel A'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置A通道的PWM'
- en: duty_cycle = 10
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: duty_cycle = 10
- en: ❹ pwm_a.start(duty_cycle)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ pwm_a.start(duty_cycle)
- en: '# set PWM for channel B'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置B通道的PWM'
- en: pwm_b.start(duty_cycle)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_b.start(duty_cycle)
- en: First you set the `STBY` (standby) pin to `HIGH` ❶, which in effect turns on
    the motor driver. Then you set the `AIN1` and `AIN2` pins to `HIGH` ❷ and `LOW`
    ❸, respectively. This will cause motor A to spin in one direction. (Swapping the
    `HIGH/LOW` values between the two pins would cause the motor to spin in the opposite
    direction.) You do the same thing for motor B. Lastly, you use your `PWM` objects
    to set the speed of the motors ❹. You set the duty cycle (which correlates to
    the motor speed) to 10 percent, a relatively low value, since this is just an
    initializing call.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将`STBY`（待机）引脚设置为`HIGH` ❶，这实际上会打开电机驱动器。然后，你将`AIN1`和`AIN2`引脚分别设置为`HIGH` ❷和`LOW`
    ❸。这将使电机A朝一个方向旋转。（交换这两个引脚的`HIGH/LOW`值会导致电机朝相反方向旋转。）对电机B做同样的操作。最后，你使用`PWM`对象来设置电机的速度
    ❹。你将占空比（与电机速度相关）设置为10%，这是一个相对较低的值，因为这只是一个初始化调用。
- en: 'You also need a function to stop the motors from spinning at the end of the
    project. Here’s the definition:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个函数来在项目结束时停止电机旋转。以下是该函数的定义：
- en: 'def stop_motors():'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'def stop_motors():'
- en: '"""stop both motors"""'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '"""停止两个电机"""'
- en: '# stop PWM'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '# 停止PWM'
- en: ❶ pwm_a.stop()
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pwm_a.stop()
- en: ❷ pwm_b.stop()
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ pwm_b.stop()
- en: '# brake A'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '# 刹车 A'
- en: GPIO.output(AIN1, GPIO.HIGH)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN1, GPIO.HIGH)
- en: GPIO.output(AIN2, GPIO.HIGH)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN2, GPIO.HIGH)
- en: '# brake B'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '# 刹车 B'
- en: GPIO.output(BIN1, GPIO.HIGH)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN1, GPIO.HIGH)
- en: GPIO.output(BIN2, GPIO.HIGH)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN2, GPIO.HIGH)
- en: '# disable driver chip'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '# 禁用驱动芯片'
- en: ❸ GPIO.output(STBY, GPIO.LOW)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ GPIO.output(STBY, GPIO.LOW)
- en: To stop the motors from spinning, you first stop the PWM signals going to the
    `PWMA` ❶ and `PWMB` ❷ pins. Then you set the `AIN1`, `AIN2`, `BIN1`, and `BIN2`
    pins all to `HIGH`, which has the effect of “braking” each motor to a stop. Finally,
    you disable the motor driver by setting the `STBY` pin to `LOW` ❸. Standby mode
    saves power when the motors aren’t required to function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了停止电机旋转，你首先停止传送到`PWMA` ❶和`PWMB` ❷引脚的PWM信号。然后，你将`AIN1`、`AIN2`、`BIN1`和`BIN2`引脚全部设置为`HIGH`，这样就能“刹车”每个电机直到停止。最后，你通过将`STBY`引脚设置为`LOW`
    ❸来禁用电机驱动器。待机模式可以在电机不需要运转时节省电力。
- en: You need one more helper function to set the speed and direction of both motors.
    You’ll use this function to adjust the motors based on your real-time audio analysis.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个辅助函数来设置两个电机的速度和方向。你将使用这个函数根据实时音频分析调整电机。
- en: 'def set_motor_speed_dir(dca, dcb, dira, dirb):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'def set_motor_speed_dir(dca, dcb, dira, dirb):'
- en: '"""set speed and direction of motors"""'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '"""设置电机的速度和方向"""'
- en: '# set duty cycle'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置占空比'
- en: ❶ pwm_a.ChangeDutyCycle(dca)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pwm_a.ChangeDutyCycle(dca)
- en: pwm_b.ChangeDutyCycle(dcb)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_b.ChangeDutyCycle(dcb)
- en: '# set direction A'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置方向 A'
- en: '❷ if dira:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ if dira:'
- en: GPIO.output(AIN1, GPIO.HIGH)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN1, GPIO.HIGH)
- en: GPIO.output(AIN2, GPIO.LOW)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN2, GPIO.LOW)
- en: '❸ else:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ else:'
- en: GPIO.output(AIN1, GPIO.LOW)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN1, GPIO.LOW)
- en: GPIO.output(AIN2, GPIO.HIGH)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN2, GPIO.HIGH)
- en: 'if dirb:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'if dirb:'
- en: GPIO.output(BIN1, GPIO.HIGH)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN1, GPIO.HIGH)
- en: GPIO.output(BIN2, GPIO.LOW)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN2, GPIO.LOW)
- en: 'else:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: GPIO.output(BIN1, GPIO.LOW)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN1, GPIO.LOW)
- en: GPIO.output(BIN2, GPIO.HIGH)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN2, GPIO.HIGH)
- en: 'The `set_motor_speed_dir()` function takes four parameters: `dca` and `dcb`
    determine the duty cycle for each motor, while `dira` and `dirb` are Booleans
    that set the motors’ direction of rotation. You use the `ChangeDutyCycle()` method
    to update the duty cycles (speeds) of the motors to the values passed into the
    function ❶. Then you attend to the motors’ directions. If `dira` is `True` ❷,
    you set pins `AIN1` and `AIN2` to `HIGH` and `LOW`, respectively, which will let
    motor A spin in one direction. However, if `dira` is `False` ❸, you set the pins
    the opposite way, which will spin the motor in the other direction. You do the
    same thing for motor B using the `dirb` parameter.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_motor_speed_dir()` 函数有四个参数：`dca` 和 `dcb` 决定了每个电机的占空比，而 `dira` 和 `dirb`
    是布尔值，设置电机的旋转方向。你使用 `ChangeDutyCycle()` 方法来更新电机的占空比（速度）到传入函数的值 ❶。然后你处理电机的方向。如果
    `dira` 为 `True` ❷，你将引脚 `AIN1` 和 `AIN2` 分别设置为 `HIGH` 和 `LOW`，这样电机 A 就会朝一个方向旋转。然而，如果
    `dira` 为 `False` ❸，你会反向设置引脚，使电机朝另一个方向旋转。对于电机 B，你使用 `dirb` 参数进行相同的设置。'
- en: '[Processing the Audio](nsp-venkitachalam503045-0008.xhtml#rbh1508)'
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[处理音频](nsp-venkitachalam503045-0008.xhtml#rbh1508)'
- en: The heart of this project is the `process_audio()` function, which reads audio
    data from a WAV file, outputs an audio stream with `pyaudio`, analyzes the audio
    data by computing an FFT, and uses the resulting analysis to control the motors.
    We’ll look at the function in sections.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的核心是 `process_audio()` 函数，它从 WAV 文件中读取音频数据，使用 `pyaudio` 输出音频流，通过计算 FFT 分析音频数据，并利用分析结果控制电机。我们将分段查看该函数。
- en: 'def process_audio(filename):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'def process_audio(filename):'
- en: print("opening {}...".format(filename))
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在打开 {}...".format(filename))
- en: '# open WAV file'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开 WAV 文件'
- en: ❶ wf = wave.open(filename, 'rb')
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ wf = wave.open(filename, 'rb')
- en: '# print audio details'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印音频详情'
- en: ❷ print("SW = {}, NCh = {}, SR = {}".format(wf.getsampwidth(),
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ print("SW = {}, NCh = {}, SR = {}".format(wf.getsampwidth(),
- en: wf.getnchannels(), wf.getframerate()))
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: wf.getnchannels(), wf.getframerate()))
- en: '# check for supported format'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查支持的格式'
- en: '❸ if wf.getsampwidth() != 2 or wf.getnchannels() != 1:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ if wf.getsampwidth() != 2 or wf.getnchannels() != 1:'
- en: print("Only single channel 16 bit WAV files are supported!")
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: print("仅支持单通道 16 位 WAV 文件！")
- en: wf.close()
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: wf.close()
- en: return
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: '# create PyAudio object'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建 PyAudio 对象'
- en: ❹ p = pyaudio.PyAudio()
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ p = pyaudio.PyAudio()
- en: '# open an output stream'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开输出流'
- en: ❺ stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),
- en: channels=wf.getnchannels(),
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: channels=wf.getnchannels(),
- en: rate=wf.getframerate(),
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: rate=wf.getframerate(),
- en: output=True)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: output=True)
- en: '# read first frame'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取第一帧'
- en: 'You start by using the `wave` module to open the audio file passed into the
    `process_audio()` function ❶. The `wave.open()` function returns a `Wave_read`
    object, which you’ll use to read data from the WAV file. You print out some information
    about the WAV file read in ❷: `SW` is the sample width in bytes, `NCh` is the
    number of channels in the audio, and `SR` is the sampling rate. To keep the project
    simple, you’ll support only single-channel, 16-bit WAV files as input. You check
    for these specs ❸, and if the input doesn’t match, you return from the function.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你从使用 `wave` 模块打开传递给 `process_audio()` 函数的音频文件开始 ❶。`wave.open()` 函数返回一个 `Wave_read`
    对象，你将使用它从 WAV 文件中读取数据。你会打印出一些读取的 WAV 文件信息 ❷：`SW` 是采样宽度（以字节为单位），`NCh` 是音频中的通道数，`SR`
    是采样率。为了保持项目简单，你只支持单通道、16 位的 WAV 文件作为输入。你会检查这些规格 ❸，如果输入不匹配，你会从函数中返回。
- en: Next, you create the `PyAudio` object that you’ll use to stream data from the
    WAV file to the output ❹. Then you open a `pyaudio` output stream (as indicated
    by the `output=True` argument), configuring it to have the same sample width,
    number of channels, and sample rate as the WAV file ❺. For the Raspberry Pi, the
    default sound output is the 3.5 mm audio jack on the board. As long as your speaker
    is plugged into this jack, you’ll hear the sound output.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你创建一个`PyAudio`对象，用于从WAV文件流式传输数据到输出 ❹。然后你打开一个`pyaudio`输出流（通过`output=True`参数指示），并将其配置为与WAV文件具有相同的采样宽度、通道数和采样率
    ❺。对于树莓派，默认的音频输出是板上的3.5毫米音频插孔。只要你的扬声器插入这个插孔，你就能听到声音输出。
- en: 'Here’s the next part of the function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是函数的下一部分：
- en: ❶ data = wf.readframes(CHUNK)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ data = wf.readframes(CHUNK)
- en: ❷ buf = np.frombuffer(data, dtype=np.int16)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ buf = np.frombuffer(data, dtype=np.int16)
- en: '# store sample rate'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '# 存储采样率'
- en: ❸ SR = wf.getframerate()
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ SR = wf.getframerate()
- en: '# start motors'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启动电机'
- en: start_motors()
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 启动电机()
- en: '# laser on'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '# 激光开'
- en: laser_on(True)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 激光开(True)
- en: Here you read `CHUNK` samples from the WAV file into variable `data` ❶. Remember,
    you’ve set `CHUNK` to `2048`, and each sample is 2 bytes wide, so you’ll be reading
    a total of 2,048 16-bit values. You read only one chunk of data because of how
    the function’s main loop is structured, as you’ll see soon.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你从WAV文件中读取`CHUNK`个样本到变量`data`中 ❶。记住，你已经将`CHUNK`设置为`2048`，每个样本占2个字节，所以你将读取共2048个16位值。由于函数的主循环结构，你一次只读取一个数据块，正如你在接下来的代码中看到的那样。
- en: The `readframes()` method returns a `bytes` object, but you use the `numpy`
    library’s `frombuffer()` function to convert the `bytes` object into a `numpy`
    array of 16-bit integers called `buf` ❷. You store the sampling rate (the `wave`
    module calls it the *frame rate*) in variable `SR` ❸; you’ll need it later. Then
    you call the `start_motors()` and `laser_on()` functions, which we’ve already
    discussed, to get the motors and the laser module going.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`readframes()`方法返回一个`bytes`对象，但你使用`numpy`库的`frombuffer()`函数将这个`bytes`对象转换为一个名为`buf`的16位整数的`numpy`数组
    ❷。你将采样率（`wave`模块称之为*帧率*）存储在变量`SR`中 ❸；稍后你将需要它。然后，你调用之前讨论过的`start_motors()`和`laser_on()`函数来启动电机和激光模块。'
- en: Next, you enter the function’s main loop, which outputs the audio and performs
    the FFT. The loop works on one chunk of audio data at a time, which is why you
    read only a single chunk of data in the previous code listing. Notice that the
    loop occurs inside a `try` block. Later, you’ll write an `except` block to handle
    any problems that arise during the execution of the loop.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你进入函数的主循环，循环输出音频并执行FFT。该循环一次处理一个音频数据块，这就是为什么在前面的代码中你只读取一个数据块的原因。请注意，循环发生在一个`try`块内。稍后，你将写一个`except`块来处理执行过程中可能出现的任何问题。
- en: '# read audio data from WAV file'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '# 从WAV文件读取音频数据'
- en: 'try:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试:'
- en: '# loop till there is no data to be read'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '# 循环直到没有数据可读取'
- en: '❶ while len(data) > 0:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ while len(data) > 0:'
- en: '# write stream to output'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将数据写入输出流'
- en: ❷ stream.write(data)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ stream.write(data)
- en: '# ensure enough samples for FFT'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '# 确保有足够的样本进行FFT'
- en: '❸ if len(buf) == N:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ if len(buf) == N:'
- en: ❹ buf = np.frombuffer(data, dtype=np.int16)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ buf = np.frombuffer(data, dtype=np.int16)
- en: '# do FFT'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '# 执行FFT'
- en: ❺ fft = np.fft.rfft(buf)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ fft = np.fft.rfft(buf)
- en: ❻ fft = np.abs(fft) * 2.0/N
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ fft = np.abs(fft) * 2.0/N
- en: '# calc levels'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算音量'
- en: '# get average of 3 frequency bands'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取3个频段的平均值'
- en: '# 0-100 Hz, 100-1000 Hz, and 1000-2500 Hz'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '# 0-100 Hz, 100-1000 Hz, 和 1000-2500 Hz'
- en: ❼ levels = [np.sum(fft[0:100])/100,
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ levels = [np.sum(fft[0:100])/100,
- en: np.sum(fft[100:1000])/900,
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: np.sum(fft[100:1000])/900,
- en: np.sum(fft[1000:2500])/1500]
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: np.sum(fft[1000:2500])/1500]
- en: The main loop repeats until `data` is empty ❶, meaning you’ve gotten to the
    end of the WAV file. In the loop, you write the current chunk of data to the `pyaudio`
    output stream ❷. This will allow you to hear the WAV file you’re processing at
    the same time that you’re driving the motors. Then you check whether you have
    `N` samples in the current chunk of data to calculate the FFT ❸ (you set `N` to
    `2048`, the same as the chunk size, at the start of the code). This check is required
    because the last chunk of data read in may not have the full number of samples
    needed for the FFT. In that case, you’ll simply skip calculating the FFT and updating
    the motors, since the audio file is basically over anyway.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环会一直重复，直到`data`为空 ❶，这意味着你已经处理到WAV文件的末尾。在循环中，你将当前的数据块写入`pyaudio`输出流 ❷。这样，你在驱动电机的同时也可以听到正在处理的WAV文件。接着，你检查当前数据块中是否有`N`个样本来计算FFT
    ❸（在代码开始时，你将`N`设置为`2048`，和数据块大小相同）。这个检查是必要的，因为最后读取的数据块可能没有足够的样本来进行FFT计算。如果是这种情况，你将跳过FFT计算和电机更新，因为音频文件基本上已经结束了。
- en: 'Next, you load the audio data into a `numpy` array of 16-bit integers ❹. With
    the data in this format, computing the FFT is quite straightforward: you simply
    use the `rfft()` method from the `numpy.fft` module ❺. This method takes a signal
    composed of *real numbers* (like the audio data) and computes the FFT, which generally
    results in a set of *complex numbers*. You want to keep working with real numbers,
    however, so you use the `abs()` method to get the magnitudes of these complex
    numbers, which are real ❻. The `2.0/N` is a normalization factor you use to map
    the FFT values to the expected range.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将音频数据加载到一个 `numpy` 数组中，数据类型为16位整数 ❹。使用这种格式的数据，计算 FFT 非常直接：你只需使用 `numpy.fft`
    模块中的 `rfft()` 方法 ❺。该方法接受由*实数*（例如音频数据）组成的信号，并计算 FFT，通常会得到一组*复数*。但是你需要继续使用实数，因此你使用
    `abs()` 方法来获得这些复数的幅值，它们是实数 ❻。`2.0/N` 是你用来将 FFT 值映射到期望范围的归一化因子。
- en: 'Continuing the loop, you extract the relevant information from the FFT to control
    the motors. To analyze the audio signal, you split the frequency range into three
    bands: 0 to 100 Hz (bass), 100 to 1,000 Hz (midrange), and 1,000 to 2,500 Hz (treble).
    You’re especially interested in the bass and midrange frequency bands, which roughly
    correspond to the beat and the vocals in a song, respectively. You compute the
    average amplitude value of the frequencies in each band by using the `numpy.``sum()`
    method and dividing the result by the number of frequencies in that band ❼. You
    store the three averages in a Python list.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 继续循环，你从 FFT 中提取相关信息来控制电机。为了分析音频信号，你将频率范围划分为三个频段：0 到 100 Hz（低音），100 到 1,000 Hz（中音），以及1,000
    到 2,500 Hz（高音）。你特别关注低音和中音频段，它们大致对应歌曲中的节奏和人声部分。你通过使用 `numpy.``sum()` 方法并将结果除以该频段中的频率数量来计算每个频段中频率的平均幅度值
    ❼。你将三个平均值存储在一个 Python 列表中。
- en: 'Notice that you’re doing two different things in the `while` loop: sending
    audio to the output and computing the FFT of the same audio. You’re able to do
    this and maintain the audio output because the `numpy` FFT computation is fast
    enough—it finishes before the current chunk of audio data has finished playing.
    Try an experiment: put a time delay right after FFT, and see what happens to the
    sound output!'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 `while` 循环中你正在做两件不同的事情：将音频发送到输出并计算相同音频的 FFT。你能够做到这一点并保持音频输出的持续播放，因为 `numpy`
    的 FFT 计算速度足够快——它在当前音频数据播放完之前就已经完成了。试试这个实验：在 FFT 后放一个时间延迟，看看声音输出会发生什么！
- en: Now you need to convert the average amplitudes from the FFT into motor speeds
    and directions, still within the `while` loop started in the previous listing.
    The speeds need to be percentages, while the directions need to be `True/False`
    values.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要将来自 FFT 的平均幅度值转换为电机的速度和方向，仍然是在之前列表中开始的 `while` 循环内。速度需要是百分比，而方向则需要是 `True/False`
    值。
- en: '# speed1'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '# speed1'
- en: ❶ dca = int(5*levels[0])  percent 60
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ dca = int(5*levels[0])  百分比 60
- en: '# speed2'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '# speed2'
- en: ❷ dcb = int(100 + levels[1])  percent 60
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ dcb = int(100 + levels[1])  百分比 60
- en: '# dir'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '# dir'
- en: dira = False
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: dira = False
- en: dirb = True
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: dirb = True
- en: '❸ if levels[2] > 0.1:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果 levels[2] > 0.1：
- en: dira = True
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: dira = True
- en: '# set motor direction and speed'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置电机方向和速度'
- en: ❹ set_motor_speed_dir(dca, dcb, dira, dirb)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ set_motor_speed_dir(dca, dcb, dira, dirb)
- en: First you take the value from the lowest frequency band, scale it by a factor
    of `5`, convert it to an integer, and use the modulus operator (`percent`) to
    ensure that the value lies within the [0, 60] range ❶. This value controls the
    speed of motor A. Then you add `100` to the value from the middle frequency band
    and again use the modulus operator to place it in the [0, 60] range ❷. This value
    controls the speed of motor B.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你取出最低频段的值，将其按 `5` 的倍数缩放，转换为整数，并使用取模运算符（`百分比`）确保该值位于[0, 60] 范围内 ❶。这个值控制电机
    A 的速度。然后，你将中频段的值加上 `100`，再次使用取模运算符将其置于[0, 60] 范围内 ❷。这个值控制电机 B 的速度。
- en: NOTE It’s not a good idea to run the motors too fast at first, which is why
    this code limits the motors’ speeds to 60 percent. Once you’re confident the display
    is working, you can try increasing the speed threshold at ❶ and ❷.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一开始让电机转得太快并不是一个好主意，这就是为什么这段代码将电机的速度限制在60 百分比。 一旦你确定显示正常工作，你可以尝试在❶和❷处增加速度阈值。
- en: By default, you set `dira` to `False` to run motor A in one direction, but you
    switch to the other direction if the value from the highest frequency band crosses
    above a threshold of `0.1` ❸. Meanwhile, you keep motor B’s direction constant
    by setting `dirb` to `True`. Finally, you call your `set_motor_speed_dir()` function
    to run the motors at the speeds and directions you’ve calculated ❹.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你将`dira`设置为`False`来让电机A朝一个方向运行，但如果最高频带的值超过`0.1`的阈值，❸你会切换到另一个方向。同时，你通过将`dirb`设置为`True`来保持电机B的方向不变。最后，你调用`set_motor_speed_dir()`函数，按照你计算出的速度和方向运行电机❹。
- en: NOTE There’s no particularly elegant rule governing how you convert the FFT
    information to motor speeds and directions. The FFT values change constantly with
    the audio signal, so any method you come up with will change the laser pattern
    in response to the music. I arrived at the method described here through trial
    and error; I looked at FFT values while playing various types of music and chose
    calculations that produced a nice variety of patterns. I encourage you to play
    with the calculations and create your own conversions. There are no wrong answers
    here, as long as your method puts the motor speeds in the [0, 100] range (or less
    to avoid high speeds) and sets the directions to be `True` or `False`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：没有特别优雅的规则来将FFT信息转换为电机的速度和方向。FFT值会随着音频信号不断变化，因此你提出的任何方法都会使激光图案根据音乐变化。我通过反复试验得出了这里描述的方法；在播放不同类型的音乐时，我观察了FFT值，并选择了那些产生有趣图案的计算方法。我鼓励你也尝试这些计算并创建你自己的转换方法。只要你把电机速度设置在[0,
    100]范围内（或者更低以避免高速度），并将方向设置为`True`或`False`，就没有错误的答案。
- en: 'Here’s the remainder of the `process_audio()` function:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`process_audio()`函数的其余部分：
- en: '# read next'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取下一个'
- en: ❶ data = wf.readframes(CHUNK)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ data = wf.readframes(CHUNK)
- en: '❷ except BaseException as err:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ except BaseException as err:'
- en: print("Unexpected {}, type={}".format(err, type(err)))
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: print("意外的{}, 类型={}".format(err, type(err)))
- en: '❸ finally:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ finally:'
- en: 'print("Finally: Pyaudio clean up...")'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: print("最终：Pyaudio清理...")
- en: stream.stop_stream()
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: stream.stop_stream()
- en: stream.close()
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: stream.close()
- en: '# stop motors'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '# 停止电机'
- en: stop_motors()
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: stop_motors()
- en: First you conclude the `while` loop by reading in the next chunk of audio data
    to be processed ❶. Recall that the `while` loop unfolds inside a `try` block.
    The `except` block ❷ catches any exceptions that may arise during the loop. For
    example, pressing CTRL-C while the program is running will throw an exception
    and halt the loop, as will any errors reading the data. You end by doing some
    cleanup in a `finally` block ❸ that will execute whether or not any exceptions
    are thrown. In this block, you stop the `pyaudio` output stream and close it,
    and you call your `stop_motors()` function to stop the motors from spinning.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你通过读取下一个音频数据块来结束`while`循环❶。记住，`while`循环是在`try`块内展开的。`except`块❷捕获循环过程中可能出现的任何异常。例如，在程序运行时按下CTRL-C会抛出异常并停止循环，读取数据时出现任何错误也会如此。最后，你在`finally`块❸中做一些清理工作，无论是否抛出异常，这个块都会执行。在这个块中，你停止`pyaudio`输出流并关闭它，同时调用`stop_motors()`函数来停止电机旋转。
- en: '[Testing the Motors](nsp-venkitachalam503045-0008.xhtml#rbh1509)'
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[测试电机](nsp-venkitachalam503045-0008.xhtml#rbh1509)'
- en: 'For testing purposes, it would be useful to be able to manually set the speed
    and direction of the motors and view the resulting laser pattern. Here’s a `test_motors()`
    function that makes this possible:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，能够手动设置电机的速度和方向，并查看结果激光图案会很有用。下面是一个使这一切成为可能的`test_motors()`函数：
- en: 'def test_motors():'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_motors():'
- en: '"""test motors by manually setting speed and direction"""'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过手动设置速度和方向测试电机"""'
- en: '# turn laser on'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开激光'
- en: ❶ laser_on(True)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ laser_on(True)
- en: '# start motors'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启动电机'
- en: ❷ start_motors()
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ start_motors()
- en: '# read user input'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取用户输入'
- en: 'try:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'while True:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: ❸ print("Enter dca dcb dira dirb (eg. 50 100 1 0):")
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ print("输入dca dcb dira dirb（例如50 100 1 0）：")
- en: '# read input'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取输入'
- en: str_in = input()
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: str_in = input()
- en: '# parse values'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析值'
- en: ❹ vals = [int(val) for val in str_in.split()]
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ vals = [int(val) for val in str_in.split()]
- en: '# sanity check'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '# 完整性检查'
- en: 'if len(vals) == 4:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(vals) == 4:'
- en: ❺ set_motor_speed_dir(vals[0], vals[1], vals[2], vals[3])
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ set_motor_speed_dir(vals[0], vals[1], vals[2], vals[3])
- en: 'else:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Input error!")
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: print("输入错误！")
- en: 'except:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: print("Exiting motor test!")
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: print("退出电机测试！")
- en: '❻ finally:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '❻ finally:'
- en: '# stop motors'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '# 停止电机'
- en: stop_motors()
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: stop_motors()
- en: '# turn laser off'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭激光'
- en: laser_on(False)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: laser_on(False)
- en: 'You begin by turning on the laser ❶ and starting the motors ❷. Then you enter
    a loop to get information from the user. The loop prompts the user to enter four
    integer values ❸: `dca` and `dcb` are the duty cycles (speeds) for the motors
    (from 0 to 100), and `dira` and `dirb` are the motor directions (0 or 1). You
    wait for the input, and then parse it, using `split()` to divide the input string
    into separate strings based on whitespace and a list comprehension to convert
    each substring into an integer ❹. After a sanity check to ensure that you did,
    in fact, get four numbers as input, you run the motors using the provided values
    ❺.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先通过开启激光 ❶ 和启动电机 ❷。然后进入一个循环，获取用户输入信息。循环会提示用户输入四个整数值 ❸：`dca`和`dcb`是电机的占空比（速度，范围0到100），`dira`和`dirb`是电机的方向（0或1）。你等待输入，然后解析输入，使用`split()`将输入字符串按空白分割成多个字符串，并使用列表推导将每个子串转换为整数
    ❹。在确保输入确实包含四个数字后，你使用提供的值来运行电机 ❺。
- en: This runs in a loop, so you can try inputting various speed and direction values
    to see the result. Since the `while` loop is placed inside a `try` block, pressing
    CTRL-C will throw an exception and exit from the test when you’re ready. Then,
    in the `finally` block ❻, you stop the motors and turn the laser off.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会在循环中运行，因此你可以尝试输入不同的速度和方向值来查看结果。由于`while`循环被放置在`try`块内，按CTRL-C时会抛出异常并退出测试，直到你准备好结束。然后，在`finally`块
    ❻ 中，你停止电机并关闭激光。
- en: '[Putting It All Together](nsp-venkitachalam503045-0008.xhtml#rbh1510)'
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[将一切整合在一起](nsp-venkitachalam503045-0008.xhtml#rbh1510)'
- en: 'As usual, the `main()` function takes in command line arguments and sets the
    project in motion. Let’s look at the command line arguments first:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，`main()`函数接受命令行参数并启动项目。我们先来看一下命令行参数：
- en: 'def main():'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '"""main calling function"""'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '"""主调用函数"""'
- en: '# set up args parser'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置参数解析器'
- en: ❶ parser = argparse.ArgumentParser(description="A laser audio display.")
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ parser = argparse.ArgumentParser(description="激光音频显示。")
- en: '# add arguments'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: parser.add_argument('--test_laser', action='store_true', required=False)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--test_laser', action='store_true', required=False)
- en: parser.add_argument('--test_motors', action='store_true', required=False)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--test_motors', action='store_true', required=False)
- en: parser.add_argument('--wav_file', dest='wav_file', required=False)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--wav_file', dest='wav_file', required=False)
- en: args = `parser`.`parse_args`()
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: args = `parser`.`parse_args`()
- en: Here you follow the familiar pattern of creating an `ArgumentParser` object
    to parse command line arguments for the program ❶. The program will support three
    different command line arguments. The `--test_laser` option just turns the laser
    on and is useful when you’re building the motor and laser assembly. The `--test_motors`
    option is for testing the motors, and the `--wav_file` option lets you specify
    the WAV file to be read in for the laser audio display.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你遵循了创建`ArgumentParser`对象的常见模式，用来解析程序的命令行参数 ❶。该程序支持三种不同的命令行参数。`--test_laser`选项只是开启激光，适用于你在构建电机和激光组件时。`--test_motors`选项用于测试电机，`--wav_file`选项让你指定要读取的WAV文件用于激光音频显示。
- en: 'Here’s the rest of the `main()` function:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`main()`函数的其余部分：
- en: '# initialize pins'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化引脚'
- en: ❶ init_pins()
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ init_pins()
- en: '# main loop'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '# 主循环'
- en: 'try:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: '❷ if args.test_laser:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ 如果 args.test_laser:'
- en: print("laser on...")
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: print("激光开启...")
- en: laser_on(True)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: laser_on(True)
- en: 'try:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: '# wait in a loop'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '# 循环等待'
- en: 'while True:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: time.sleep(0.1)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(0.1)
- en: 'except:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: '# turn laser off'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭激光'
- en: laser_on(False)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: laser_on(False)
- en: '❸ elif args.test_motors:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ elif args.test_motors:'
- en: print("testing motors...")
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: print("测试电机...")
- en: test_motors()
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: test_motors()
- en: '❹ elif args.wav_file:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ elif args.wav_file:'
- en: print("starting laser audio display...")
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: print("开始激光音频显示...")
- en: process_audio(args.wav_file)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: process_audio(args.wav_file)
- en: 'except (Exception) as e:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 'except (Exception) as e:'
- en: 'print("Exception: {}".format(e))'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("异常: {}".format(e))'
- en: print("Exiting.")
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: print("退出中。")
- en: '# turn laser off'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭激光'
- en: ❺ laser_on(False)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ laser_on(False)
- en: '# call at the end'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在最后调用'
- en: ❻ GPIO.cleanup()
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ GPIO.cleanup()
- en: print("Done.")
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: print("完成。")
- en: You call the `init_pins()` function you defined earlier to initialize the Raspberry
    Pi’s GPIO pins ❶. Next, you go through and process the command line arguments.
    If the user typed in the `--test_laser` argument, `args.test_laser` will be set
    to `True`. You handle this case by turning on the laser and waiting for the user
    to press CTRL-C to terminate the loop ❷. Similarly, you handle the `--test_motors`
    option by calling `test_motors()` ❸. To start the laser audio display, the user
    needs to use the `--wav_file` command line argument. In this case ❹, you call
    the `process_audio()` function. Once again, all this is embedded in a `try` block,
    so when the user presses CTRL-C, you break out of the loop for any of the three
    modes. To finish, you turn the laser off ❺ and do a GPIO cleanup ❻ before exiting
    the program.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用之前定义的`init_pins()`函数来初始化Raspberry Pi的GPIO引脚❶。接下来，你处理命令行参数。如果用户输入了`--test_laser`参数，则`args.test_laser`将被设置为`True`。你通过打开激光并等待用户按下CTRL-C来终止循环❷。类似地，你通过调用`test_motors()`来处理`--test_motors`选项❸。要启动激光音频显示，用户需要使用`--wav_file`命令行参数。在这种情况下❹，你调用`process_audio()`函数。再次强调，所有这些都嵌入在一个`try`代码块中，所以当用户按下CTRL-C时，任何三种模式下都可以退出循环。最后，你关闭激光❺并在退出程序之前进行GPIO清理❻。
- en: '[Running the Laser Display](nsp-venkitachalam503045-0008.xhtml#rah1504)'
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行激光显示](nsp-venkitachalam503045-0008.xhtml#rah1504)'
- en: To test the project, assemble the hardware, make sure the battery pack is connected,
    and position everything so the laser is projecting onto a flat surface such as
    a wall. Then use SSH to log in to your Raspberry Pi as discussed in [Appendix
    B](nsp-venkitachalam503045-0032.xhtml#appb) and run the program from a shell.
    I recommend testing the laser display part first by running the program in test
    mode.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试该项目，请组装硬件，确保电池组已连接，并将所有设备放置好，使激光投射到一个平坦的表面上，例如墙壁。然后，使用SSH登录到你的Raspberry Pi，如[附录B](nsp-venkitachalam503045-0032.xhtml#appb)中所讨论的，并从终端运行程序。我建议先通过在测试模式下运行程序来测试激光显示部分。
- en: WARNING The project has high-speed spinning mirrors. Please wear appropriate
    eye protection or cover the setup with a transparent box before running the program
    to avoid injuries.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：该项目包含高速旋转镜面。请佩戴适当的眼部防护装备，或在运行程序前用透明盒子覆盖设备，以避免受伤。
- en: 'Here’s a sample run of the test mode:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试模式的示例运行：
- en: $ `python laser_audio.py --test_motors`
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python laser_audio.py --test_motors`
- en: testing motors...
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 正在测试电机...
- en: 'Enter dca dcb dira dirb (eg. 50 100 1 0):'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 dca dcb dira dirb（例如：50 100 1 0）：
- en: '`30 40 0 1`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`30 40 0 1`'
- en: 'Enter dca dcb dira dirb (eg. 50 100 1 0):'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 dca dcb dira dirb（例如：50 100 1 0）：
- en: '`40 30 1 0`'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`40 30 1 0`'
- en: You can use this test to run both motors through various combinations of speeds
    and directions. You should see different laser patterns projected onto your wall
    as you change the values. To stop the program and the motors, press CTRL-C. Note
    that if you enter duty cycle (speed) values greater than 80, the motors will spin
    really fast. Be careful!
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此测试通过不同的速度和方向组合运行两个电机。当你改变数值时，你应该能看到不同的激光图案投射到墙上。要停止程序和电机，请按CTRL-C。注意，如果输入的占空比（速度）值超过80，电机会转得非常快。小心！
- en: 'If the test succeeds, you’re ready to move on to the real show. Copy a WAV
    file of your favorite music to the Raspberry Pi. Remember that to keep things
    simple, the program accepts only single-channel WAV files in 16-bit format. You
    can convert any audio file to this format using the free software Audacity. (A
    sample file is also available in the project’s GitHub repository.) When the audio
    file is in place, run the program as follows, substituting your desired filename
    after the `--wave_file` option:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试成功，你就可以继续进行实际展示。将你喜欢的音乐WAV文件复制到Raspberry Pi上。记住，为了简化操作，程序仅接受16位格式的单声道WAV文件。你可以使用免费软件Audacity将任何音频文件转换为此格式。（该项目的GitHub仓库中也提供了一个示例文件。）音频文件就位后，按如下方式运行程序，将你想要的文件名替换到`--wave_file`选项后：
- en: '`python3 laser_audio.py --wav_file bensound-allthat-16.wav`'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`python3 laser_audio.py --wav_file bensound-allthat-16.wav`'
- en: You should see the laser display produce lots of interesting patterns that change
    in time with the music, as shown in [Figure 13-14](nsp-venkitachalam503045-0028.xhtml#fig13-14).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到激光显示产生许多有趣的图案，这些图案随音乐的节奏变化，如[图13-14](nsp-venkitachalam503045-0028.xhtml#fig13-14)所示。
- en: '![](images/nsp-venkitachalam503045-f13014.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13014.jpg)'
- en: 'Figure 13-14: The complete wiring of the laser display and a pattern projected
    on the wall'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-14：激光显示的完整接线及投射到墙上的图案
- en: Try experimenting with different WAV files, or with different calculations for
    converting the FFT information to motor settings, to see how the visualization
    responds.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的WAV文件，或使用不同的计算方法将FFT信息转换为电机设置，看看可视化效果如何响应。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1505)'
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah1505)'
- en: In this chapter, you upped your Python and hardware skills by building a fairly
    complex project. You learned how to control motors with Python, a Raspberry Pi,
    and a motor driver. You used `numpy` to compute the FFT of audio data, and you
    used `pyaudio` to stream audio output in real time. You even learned to control
    a laser using a MOSFET!
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过构建一个相当复杂的项目提升了你的Python和硬件技能。你学会了如何使用Python、树莓派和电机驱动器来控制电机。你使用`numpy`计算音频数据的FFT，并且使用`pyaudio`实时流式传输音频输出。你甚至学会了使用MOSFET控制激光！
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1506)'
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah1506)'
- en: 'Here are some ways you can modify this project:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以修改这个项目的方法：
- en: 1\. The program used an arbitrary scheme to convert the FFT values into motor
    speed and direction data. Try changing this scheme. For example, experiment with
    different frequency bands and criteria for changing motor directions.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 该程序使用了一种任意方案将FFT值转换为电机速度和方向数据。试着改变这个方案。例如，实验不同的频段和改变电机方向的标准。
- en: '2\. In this project, you converted frequency information gathered from the
    audio signal into motor speed and direction settings. Try making the motors move
    according to the overall “pulse” or volume of the music instead. For this, you
    can compute the *root* *mean square (RMS)* value of the amplitude of the signal.
    This computation is similar to the FFT calculation. Once you read in a chunk of
    audio data and put it into a `numpy` array `x`, you can compute the RMS value
    as follows:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 在这个项目中，你将从音频信号中收集到的频率信息转换为电机速度和方向设置。试着让电机根据音乐的整体“脉冲”或音量来运动。为此，你可以计算信号幅度的*均方根（RMS）*值。这个计算类似于FFT计算。一旦你读取了一段音频数据并将其放入`numpy`数组`x`中，你可以通过以下方式计算RMS值：
- en: rms = np.sqrt(np.mean(x**2))
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: rms = np.sqrt(np.mean(x**2))
- en: Also, remember that the amplitude in your project was expressed as a 16-bit
    signed integer, which can have a maximum value of 32,768 (a useful number to keep
    in mind for normalization). Use this RMS amplitude in conjunction with the FFT
    to generate a greater variation of laser patterns.
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，记住你项目中的幅度是作为16位带符号整数表示的，最大值为32,768（在归一化时记住这个数字很有用）。结合FFT使用这个RMS幅度，可以生成更多变化的激光图案。
- en: 3\. You know now that the frequency content, and hence the FFT of the audio
    data, changes in sync with the audio. Can you create a real-time visualization
    like the one shown in [Figure 13-15](nsp-venkitachalam503045-0028.xhtml#fig13-15),
    of both the audio data and the FFT as the audio plays through a speaker? This
    is intended to run on your computer, not your Raspberry Pi.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 你现在知道了，音频数据的频率内容，因此其FFT，与音频同步变化。你能像[图13-15](nsp-venkitachalam503045-0028.xhtml#fig13-15)中所示的那样，创建一个实时的音频数据和FFT的可视化效果吗？这个可视化效果应该随着音频从扬声器播放而变化。这是为你的电脑设计的，而不是为树莓派设计的。
- en: '![](images/nsp-venkitachalam503045-f13015.jpg)'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13015.jpg)'
- en: 'Figure 13-15: A real-time FFT visualization'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13-15：实时FFT可视化
- en: 'Here are a few hints to solve this problem:'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一些提示，帮助你解决这个问题：
- en: ◦ Use `matplotlib` for plotting.
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ 使用`matplotlib`进行绘图。
- en: ◦ Use Python’s `multiprocessing` package so your music streaming output and
    plotting can happen simultaneously.
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ 使用Python的`multiprocessing`包，使你的音乐流输出和绘图可以同时进行。
- en: ◦ Use the `numpy.fft.``rfftfreq()` method to get the frequencies corresponding
    to the FFT values, for ease of plotting.
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ 使用`numpy.fft.rfftfreq()`方法来获取与FFT值对应的频率，方便绘图。
- en: (The solution code for this experiment is in the book’s GitHub repository, but
    give it a shot yourself first!)
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （本实验的解决方案代码可以在本书的GitHub仓库中找到，但先自己试试看！）
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah1507)'
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah1507)'
- en: 'Here’s the complete Python code for this project:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个项目的完整Python代码：
- en: '"""'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: laser_audio.py
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: laser_audio.py
- en: Creates a laser display that changes in time to music.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个随音乐变化的激光显示。
- en: Uses Python on a Raspberry Pi.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派上使用Python。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import RPi.GPIO as GPIO
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: import RPi.GPIO as GPIO
- en: import time
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: import argparse
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: import argparse
- en: import pyaudio
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: import pyaudio
- en: import wave
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: import wave
- en: import numpy as np
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: define pin numbers
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义引脚编号
- en: uses TB6612FNG motor driver pin naming
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TB6612FNG电机驱动器的引脚命名
- en: PWMA = 12
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: PWMA = 12
- en: PWMB = 13
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: PWMB = 13
- en: AIN1 = 7
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: AIN1 = 7
- en: AIN2 = 8
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: AIN2 = 8
- en: BIN1 = 5
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: BIN1 = 5
- en: BIN2 = 6
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: BIN2 = 6
- en: STBY = 22
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: STBY = 22
- en: LASER = 25
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: LASER = 25
- en: global PWM objects
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: global PWM objects
- en: pwm_a = None
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_a = None
- en: pwm_b = None
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_b = None
- en: size of audio data read in
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取的音频数据大小
- en: CHUNK = 2048
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: CHUNK = 2048
- en: FFT size
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FFT 大小
- en: N = CHUNK
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: N = CHUNK
- en: 'def init_pins():'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 'def init_pins():'
- en: '"""set up pins"""'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '"""设置引脚"""'
- en: global pwm_a, pwm_b
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: global pwm_a, pwm_b
- en: '# use BCM pin numbering'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '# 使用 BCM 引脚编号'
- en: GPIO.setmode(GPIO.BCM)
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.setmode(GPIO.BCM)
- en: '# put pins into a list'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将引脚放入列表'
- en: pins = [PWMA, PWMB, AIN1, AIN2, BIN1, BIN2, STBY, LASER]
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: pins = [PWMA, PWMB, AIN1, AIN2, BIN1, BIN2, STBY, LASER]
- en: '# set up pins as outputs'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置引脚为输出'
- en: GPIO.setup(pins, GPIO.OUT)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.setup(pins, GPIO.OUT)
- en: '# set PWM'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置 PWM'
- en: pwm_a = GPIO.PWM(PWMA, 100)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_a = GPIO.PWM(PWMA, 100)
- en: pwm_b = GPIO.PWM(PWMB, 100)
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_b = GPIO.PWM(PWMB, 100)
- en: 'def laser_on(on):'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 'def laser_on(on):'
- en: '"""turn laser MOSFET on/off"""'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '"""开关激光器 MOSFET"""'
- en: '# pin 25 controls laser ctrl mosfet'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '# 引脚 25 控制激光器 MOSFET'
- en: GPIO.output(LASER, on)
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(LASER, on)
- en: 'def test_motors():'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_motors():'
- en: '"""test motors by manually setting speed and direction"""'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过手动设置速度和方向测试电机"""'
- en: '# turn laser on'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开激光器'
- en: laser_on(True)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: laser_on(True)
- en: '# start motors'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启动电机'
- en: start_motors()
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: start_motors()
- en: '# read user input'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取用户输入'
- en: 'try:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: 'while True:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: print("Enter dca dcb dira dirb (eg. 50 100 1 0):")
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: print("请输入 dca dcb dira dirb（例如：50 100 1 0）：")
- en: '# read input'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取输入'
- en: str_in = input()
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: str_in = input()
- en: '# parse values'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析数值'
- en: vals = [int(val) for val in str_in.split()]
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: vals = [int(val) for val in str_in.split()]
- en: '# sanity check'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '# 完整性检查'
- en: 'if len(vals) == 4:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(vals) == 4:'
- en: set_motor_speed_dir(vals[0], vals[1], vals[2], vals[3])
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: set_motor_speed_dir(vals[0], vals[1], vals[2], vals[3])
- en: 'else:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print("Input error!")
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: print("输入错误！")
- en: 'except:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: print("Exiting motor test!")
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: print("退出电机测试！")
- en: 'finally:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 'finally:'
- en: '# stop motors'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '# 停止电机'
- en: stop_motors()
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: stop_motors()
- en: '# turn laser off'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭激光器'
- en: laser_on(False)
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: laser_on(False)
- en: 'def start_motors():'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 'def start_motors():'
- en: '"""start both motors"""'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '"""启动两个电机"""'
- en: '# enable driver chip'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启用驱动芯片'
- en: GPIO.output(STBY, GPIO.HIGH)
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(STBY, GPIO.HIGH)
- en: '# set motor direction for channel A'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置 A 通道的电机方向'
- en: GPIO.output(AIN1, GPIO.HIGH)
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN1, GPIO.HIGH)
- en: GPIO.output(AIN2, GPIO.LOW)
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN2, GPIO.LOW)
- en: '# set motor direction for channel B'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置 B 通道的电机方向'
- en: GPIO.output(BIN1, GPIO.HIGH)
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN1, GPIO.HIGH)
- en: GPIO.output(BIN2, GPIO.LOW)
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN2, GPIO.LOW)
- en: '# set PWM for channel A'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置 A 通道的 PWM'
- en: duty_cycle = 0
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: duty_cycle = 0
- en: pwm_a.start(duty_cycle)
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_a.start(duty_cycle)
- en: '# set PWM for channel B'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置 B 通道的 PWM'
- en: pwm_b.start(duty_cycle)
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_b.start(duty_cycle)
- en: 'def stop_motors():'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'def stop_motors():'
- en: '"""stop both motors"""'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '"""停止两个电机"""'
- en: '# stop PWM'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '# 停止 PWM'
- en: pwm_a.stop()
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_a.stop()
- en: pwm_b.stop()
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_b.stop()
- en: '# brake A'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '# 刹车 A'
- en: GPIO.output(AIN1, GPIO.HIGH)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN1, GPIO.HIGH)
- en: GPIO.output(AIN2, GPIO.HIGH)
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN2, GPIO.HIGH)
- en: '# brake B'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '# 刹车 B'
- en: GPIO.output(BIN1, GPIO.HIGH)
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN1, GPIO.HIGH)
- en: GPIO.output(BIN2, GPIO.HIGH)
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN2, GPIO.HIGH)
- en: '# disable driver chip'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '# 禁用驱动芯片'
- en: GPIO.output(STBY, GPIO.LOW)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(STBY, GPIO.LOW)
- en: 'def set_motor_speed_dir(dca, dcb, dira, dirb):'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 'def set_motor_speed_dir(dca, dcb, dira, dirb):'
- en: '"""set speed and direction of motors"""'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '"""设置电机的速度和方向"""'
- en: '# set duty cycle'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置占空比'
- en: pwm_a.ChangeDutyCycle(dca)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_a.ChangeDutyCycle(dca)
- en: pwm_b.ChangeDutyCycle(dcb)
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: pwm_b.ChangeDutyCycle(dcb)
- en: '# set direction A'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置 A 方向'
- en: 'if dira:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 'if dira:'
- en: GPIO.output(AIN1, GPIO.HIGH)
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN1, GPIO.HIGH)
- en: GPIO.output(AIN2, GPIO.LOW)
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN2, GPIO.LOW)
- en: 'else:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: GPIO.output(AIN1, GPIO.LOW)
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN1, GPIO.LOW)
- en: GPIO.output(AIN2, GPIO.HIGH)
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(AIN2, GPIO.HIGH)
- en: 'if dirb:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 'if dirb:'
- en: GPIO.output(BIN1, GPIO.HIGH)
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN1, GPIO.HIGH)
- en: GPIO.output(BIN2, GPIO.LOW)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN2, GPIO.LOW)
- en: 'else:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: GPIO.output(BIN1, GPIO.LOW)
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN1, GPIO.LOW)
- en: GPIO.output(BIN2, GPIO.HIGH)
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO.output(BIN2, GPIO.HIGH)
- en: 'def process_audio(filename):'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 'def process_audio(filename):'
- en: '"""reads WAV file, does FFT and controls motors"""'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '"""读取 WAV 文件，进行 FFT 并控制电机"""'
- en: print("opening {}...".format(filename))
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在打开 {}...".format(filename))
- en: '# open WAV file'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开 WAV 文件'
- en: wf = wave.open(filename, 'rb')
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: wf = wave.open(filename, 'rb')
- en: '# print audio details'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印音频详细信息'
- en: print("SW = {}, NCh = {}, SR = {}".format(wf.getsampwidth(),
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: print("SW = {}, NCh = {}, SR = {}".format(wf.getsampwidth(),
- en: wf.getnchannels(), wf.getframerate()))
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: wf.getnchannels(), wf.getframerate()))
- en: '# check for supported format'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查是否支持的格式'
- en: 'if wf.getsampwidth() != 2 or wf.getnchannels() != 1:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 'if wf.getsampwidth() != 2 or wf.getnchannels() != 1:'
- en: print("Only single channel 16 bit WAV files are supported!")
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: print("仅支持单声道 16 位 WAV 文件！")
- en: wf.close()
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: wf.close()
- en: return
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: '# create PyAudio object'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建 PyAudio 对象'
- en: p = pyaudio.PyAudio()
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: p = pyaudio.PyAudio()
- en: '# open an output stream'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开输出流'
- en: stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),
- en: channels=wf.getnchannels(),
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: channels=wf.getnchannels(),
- en: rate=wf.getframerate(),
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: rate=wf.getframerate(),
- en: output=True)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: output=True)
- en: '# read first frame'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取第一帧'
- en: data = wf.readframes(CHUNK)
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: data = wf.readframes(CHUNK)
- en: buf = np.frombuffer(data, dtype=np.int16)
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: buf = np.frombuffer(data, dtype=np.int16)
- en: '# store sample rate'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '# 存储采样率'
- en: SR = wf.getframerate()
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: SR = wf.getframerate()
- en: '# start motors'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启动马达  '
- en: start_motors()
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 'start_motors()  '
- en: '# laser on'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '# 激光开启  '
- en: laser_on(True)
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 'laser_on(True)  '
- en: '# read audio data from WAV file'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '# 从WAV文件读取音频数据  '
- en: 'try:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:  '
- en: '# loop till there is no data to be read'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '# 循环直到没有数据可读取  '
- en: 'while len(data) > 0:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 'while len(data) > 0:  '
- en: '# write stream to output'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将流写入输出  '
- en: stream.write(data)
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 'stream.write(data)  '
- en: '# ensure enough samples for FFT'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '# 确保FFT有足够的样本  '
- en: 'if len(buf) == N:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(buf) == N:  '
- en: buf = np.frombuffer(data, dtype=np.int16)
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 'buf = np.frombuffer(data, dtype=np.int16)  '
- en: '# do FFT'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '# 执行FFT  '
- en: fft = np.fft.rfft(buf)
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 'fft = np.fft.rfft(buf)  '
- en: fft = np.abs(fft) * 2.0/N
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 'fft = np.abs(fft) * 2.0/N  '
- en: '# calc levels'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算音量  '
- en: '# get average of 3 frequency bands'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取3个频段的平均值  '
- en: '# 0-100 Hz, 100-1000 Hz, and 1000-2500 Hz'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '# 0-100 Hz，100-1000 Hz，以及1000-2500 Hz  '
- en: levels = [np.sum(fft[0:100])/100,
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 'levels = [np.sum(fft[0:100])/100,  '
- en: np.sum(fft[100:1000])/900,
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 'np.sum(fft[100:1000])/900,  '
- en: np.sum(fft[1000:2500])/1500]
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 'np.sum(fft[1000:2500])/1500]  '
- en: '# speed1'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '# speed1  '
- en: dca = int(5*levels[0])  percent 60
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 'dca = int(5*levels[0])  百分比 60  '
- en: '# speed2'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '# speed2  '
- en: dcb = int(100 + levels[1])  percent 60
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 'dcb = int(100 + levels[1])  百分比 60  '
- en: '# dir'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '# dir  '
- en: dira = False
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 'dira = False  '
- en: dirb = True
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 'dirb = True  '
- en: 'if levels[2] > 0.1:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 'if levels[2] > 0.1:  '
- en: dira = True
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 'dira = True  '
- en: '# set motor direction and speed'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置马达的方向和速度  '
- en: set_motor_speed_dir(dca, dcb, dira, dirb)
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 'set_motor_speed_dir(dca, dcb, dira, dirb)  '
- en: '# read next'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取下一部分  '
- en: data = wf.readframes(CHUNK)
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 'data = wf.readframes(CHUNK)  '
- en: 'except BaseException as err:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 'except BaseException as err:  '
- en: print("Unexpected {}, type={}".format(err, type(err)))
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("意外的错误，类型={}".format(err, type(err)))  '
- en: 'finally:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 'finally:  '
- en: 'print("Finally: Pyaudio clean up...")'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("最后：Pyaudio 清理...")  '
- en: stream.stop_stream()
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 'stream.stop_stream()  '
- en: stream.close()
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 'stream.close()  '
- en: '# stop motors'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '# 停止马达  '
- en: stop_motors()
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 'stop_motors()  '
- en: '# close WAV file'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭WAV文件  '
- en: wf.close()
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 'wf.close()  '
- en: 'def main():'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():  '
- en: '"""main calling function"""'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '"""主函数调用"""  '
- en: '# set up args parser'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置参数解析器  '
- en: parser = argparse.ArgumentParser(description="A laser audio display.")
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 'parser = argparse.ArgumentParser(description="激光音频显示。")  '
- en: '# add arguments'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数  '
- en: parser.add_argument('--test_laser', action='store_true', required=False)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 'parser.add_argument(''--test_laser'', action=''store_true'', required=False)  '
- en: parser.add_argument('--test_motors', action='store_true', required=False)
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 'parser.add_argument(''--test_motors'', action=''store_true'', required=False)  '
- en: parser.add_argument('--wav_file', dest='wav_file', required=False)
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 'parser.add_argument(''--wav_file'', dest=''wav_file'', required=False)  '
- en: args = parser.parse_args()
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 'args = parser.parse_args()  '
- en: '# initialize pins'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化引脚  '
- en: init_pins()
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 'init_pins()  '
- en: '# main loop'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '# 主循环  '
- en: 'try:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:  '
- en: 'if args.test_laser:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.test_laser:  '
- en: print("laser on...")
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("激光开启...")  '
- en: laser_on(True)
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 'laser_on(True)  '
- en: 'try:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:  '
- en: '# wait in a loop'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '# 循环等待  '
- en: 'while True:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:  '
- en: time.sleep(1)
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 'time.sleep(1)  '
- en: 'except:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:  '
- en: '# turn laser off'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭激光  '
- en: laser_on(False)
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: laser_on(False)
- en: 'elif args.test_motors:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif args.test_motors:  '
- en: print("testing motors...")
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("测试马达...")  '
- en: test_motors()
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 'test_motors()  '
- en: 'elif args.wav_file:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif args.wav_file:  '
- en: print("starting laser audio display...")
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("开始激光音频显示...")  '
- en: process_audio(args.wav_file)
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 'process_audio(args.wav_file)  '
- en: 'except (Exception) as e:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 'except (Exception) as e:  '
- en: 'print("Exception: {}".format(e))'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("异常：{}".format(e))  '
- en: print("Exiting.")
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("退出。")  '
- en: '# turn laser off'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭激光  '
- en: laser_on(False)
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 'laser_on(False)  '
- en: '# call at the end'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最后调用  '
- en: GPIO.cleanup()
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 'GPIO.cleanup()  '
- en: print("Done.")
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("完成。")  '
- en: call main
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '调用 main  '
- en: 'if __name__ == ''__main__'':'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':  '
- en: main()
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 'main()  '
