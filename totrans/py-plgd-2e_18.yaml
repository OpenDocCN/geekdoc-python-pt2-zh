- en: '[13](nsp-venkitachalam503045-0008.xhtml#rch13)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[13](nsp-venkitachalam503045-0008.xhtml#rch13)'
- en: Laser Audio Display with a Raspberry Pi
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用树莓派显示激光音频
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: In [Chapter 12](nsp-venkitachalam503045-0027.xhtml#ch12), you used a Pico, a
    tiny microcontroller, to generate musical tones. In this chapter, you’ll use a
    much more powerful embedded system, the Raspberry Pi, to produce interesting laser
    patterns based on audio signals.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](nsp-venkitachalam503045-0027.xhtml#ch12)中，你使用了一个微型控制器Pico来生成音乐音调。在本章中，你将使用一个更强大的嵌入式系统——树莓派，根据音频信号生成有趣的激光图案。
- en: The [previous chapter’s](nsp-venkitachalam503045-0027.xhtml#ch12) Pico had an
    RP2040 microcontroller with dual ARM Cortex-M0 processors running at speeds of
    up to 133 MHz, with 264KB of random access memory (RAM) and 2MB of nonvolatile
    storage on an external flash chip. The Raspberry Pi 3B+, in comparison, has a
    much more capable ARM Cortex-A53 processor operating at 1.4 GHz, with 1GB of RAM
    and storage of several gigabytes, depending on the SD card you use. While this
    still pales in comparison to a standard desktop or laptop computer, the Pi is
    nonetheless capable of running a Linux-based operating system and full-fledged
    Python, unlike the Pico.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一章节](nsp-venkitachalam503045-0027.xhtml#ch12)的Pico配备了一个RP2040微控制器，拥有双核ARM
    Cortex-M0处理器，运行速度可达133 MHz，具有264KB的随机存取内存（RAM）和2MB的非易失性存储空间，存储在外部闪存芯片中。相比之下，树莓派3B+配备了一个更强大的ARM
    Cortex-A53处理器，运行速度为1.4 GHz，具有1GB的RAM，并根据使用的SD卡提供几GB的存储空间。虽然这与标准的桌面或笔记本电脑相比仍显得微不足道，但树莓派仍然能够运行基于Linux的操作系统和完整的Python环境，而不像Pico那样受限。'
- en: In this chapter, you’ll use Python on the Raspberry Pi to read an audio file
    in the WAV format, perform computations based on the real-time audio data, and
    use that data to adjust the speed and direction of rotation of two motors in a
    laser display rig. You’ll attach mirrors to the motors to reflect the beam from
    an inexpensive laser module, producing Spirograph-like patterns that change in
    response to the audio. You’ll also simultaneously stream the audio to a speaker
    so you can hear the WAV file playing as you watch your laser light show.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用树莓派上的Python读取WAV格式的音频文件，基于实时音频数据进行计算，并使用这些数据来调整激光显示设备中两个电机的旋转速度和方向。你将把镜子安装在电机上，反射来自便宜激光模块的光束，生成类似Spirograph的图案，这些图案会根据音频发生变化。你还将同时将音频流传输到扬声器，这样你就可以在观看激光灯光秀的同时听到WAV文件的播放。
- en: 'This project will push your knowledge of Python further as you learn to use
    the Raspberry Pi. Here are some of the topics we’ll cover:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将进一步拓展你对Python的理解，帮助你学习如何使用树莓派。以下是我们将要涉及的一些主题：
- en: • Generating interesting patterns with a laser and two rotating mirrors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用激光和两个旋转镜子生成有趣的图案
- en: • Getting frequency information from a signal using the fast Fourier transform
    (FFT)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用快速傅里叶变换（FFT）从信号中获取频率信息
- en: • Computing FFTs using `numpy`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`numpy`计算FFT
- en: • Reading audio from WAV files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 从WAV文件中读取音频
- en: • Outputting audio data using `pyaudio`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`pyaudio`输出音频数据
- en: • Driving motors with a Raspberry Pi
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用树莓派驱动电机
- en: • Toggling a laser module on/off with a metal-oxide-semiconductor field-effect
    transistor (MOSFET)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用金属氧化物半导体场效应晶体管（MOSFET）开关激光模块的开/关
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1501)'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[工作原理](nsp-venkitachalam503045-0008.xhtml#rah1501)'
- en: You’ll use a Raspberry Pi to work with the audio data and control the hardware.
    [Figure 13-1](nsp-venkitachalam503045-0028.xhtml#fig13-1) shows a block diagram
    of what you’ll create in this project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用树莓派处理音频数据并控制硬件。[图13-1](nsp-venkitachalam503045-0028.xhtml#fig13-1)显示了你将在本项目中创建的框图。
- en: '![](images/nsp-venkitachalam503045-f13001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13001.jpg)'
- en: 'Figure 13-1: A block diagram of the laser audio project'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1：激光音频项目的框图
- en: The Raspberry Pi will use a WAV file in two ways. It will play the file through
    an attached speaker by way of `pyaudio`, while also analyzing the audio data in
    real time using a mathematical technique called a *fast Fourier transform (FFT)*.
    The Pi will use data from the FFT to drive the motors and laser via its general-purpose
    input/output (GPIO) pins, but to protect the Pi from damage, you won’t hook it
    up directly to these external components. Instead, you’ll connect it indirectly
    through a motor driver board and a MOSFET. Before you begin, let’s consider in
    more detail how some of these aspects of the project will work.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派将以两种方式使用WAV文件。它将通过`pyaudio`将文件播放通过附加的扬声器，同时使用一种名为*快速傅里叶变换（FFT）*的数学技术实时分析音频数据。树莓派将利用FFT数据通过其通用输入/输出（GPIO）引脚驱动电动机和激光，但为了保护树莓派不受损坏，你不会直接将其连接到这些外部组件。相反，你将通过电动机驱动板和MOSFET间接连接它。在开始之前，让我们更详细地考虑一下这些项目方面的工作原理。
- en: '[Generating Patterns with a Laser](nsp-venkitachalam503045-0008.xhtml#rbh1501)'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[用激光生成图案](nsp-venkitachalam503045-0008.xhtml#rbh1501)'
- en: To generate the laser patterns in this project, you’ll use a laser module and
    two mirrors attached to the shafts of two small DC motors, as shown in [Figure
    13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2). Think of the laser as an intense
    beam of light that remains focused on a tiny point, even when projected over a
    large distance. This focus is possible because the beam is organized so that its
    waves travel in one direction only and are in phase with each other. If you shine
    the laser at the surface of a flat mirror (mirror A in [Figure 13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)),
    the reflection projected will remain a fixed point, even as the motor spins. Because
    the plane of reflection of the laser is perpendicular to the spinning axis of
    the motor, it’s as if the mirror isn’t rotating at all.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本项目中生成激光图案，你将使用一个激光模块和两个附着在两个小型直流电动机轴上的镜子，如[图13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)所示。可以把激光看作是一个强烈的光束，即使投射到很远的地方，它也会始终聚焦在一个微小的点上。这种聚焦之所以能实现，是因为激光束的波长是有序的，波的传播方向一致，且它们相位相同。如果你将激光照射到一个平面镜（[图13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)中的镜子A）的表面，反射出来的点将保持固定，即使电动机在旋转。由于激光的反射面垂直于电动机的旋转轴，所以即使镜子在旋转，反射的激光点看起来就像是镜子根本没有旋转。
- en: Now, say the mirror is attached at an angle relative to the motor shaft, as
    shown on the right of [Figure 13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)
    (mirror B). As the shaft rotates, the projected point will trace an ellipse, and
    if the motor is spinning fast enough, the viewer will perceive the moving dot
    as a continuous shape.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设镜子相对于电动机轴以一定角度附着，如[图13-2](nsp-venkitachalam503045-0028.xhtml#fig13-2)右侧所示（镜子B）。随着轴的旋转，投影点将描绘出一个椭圆形，如果电动机旋转得足够快，观察者将看到该移动点呈现为一个连续的形状。
- en: '![](images/nsp-venkitachalam503045-f13002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13002.jpg)'
- en: 'Figure 13-2: The flat mirror (mirror A) reflects a single dot. The reflection
    off the slanted mirror (mirror B) creates a circle as the motor spins.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2：平面镜（镜子A）反射一个点。倾斜镜子（镜子B）的反射随着电动机的旋转形成一个圆圈。
- en: What if both mirrors are slanted and you arrange them so that the point reflected
    off mirror A is projected onto mirror B? Now when motors A and B spin, the pattern
    created by the reflected point will be a combination of the two rotational movements
    of motors A and B, producing interesting patterns, as shown in [Figure 13-3](nsp-venkitachalam503045-0028.xhtml#fig13-3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个镜子都倾斜，并且你将它们排列，使得从镜子A反射的点投射到镜子B上呢？现在，当电动机A和B旋转时，反射点产生的图案将是电动机A和B两种旋转运动的组合，产生有趣的图案，如[图13-3](nsp-venkitachalam503045-0028.xhtml#fig13-3)所示。
- en: '![](images/nsp-venkitachalam503045-f13003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13003.jpg)'
- en: 'Figure 13-3: Reflecting laser light off two rotating, slanted mirrors produces
    interesting, complex patterns.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-3：通过两个旋转的倾斜镜子反射激光光线，会产生有趣且复杂的图案。
- en: The exact patterns produced will depend on the speed and direction of rotation
    of the two motors, but they will be similar to the hypotrochoids produced by the
    Spirograph you explored in [Chapter 2](nsp-venkitachalam503045-0013.xhtml#ch02).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的精确图案将取决于两个电动机的旋转速度和方向，但它们将类似于你在[第2章](nsp-venkitachalam503045-0013.xhtml#ch02)中探讨的由Spirograph生成的假极线。
- en: Motor Control
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电动机控制
- en: You’ll use the Raspberry Pi to control the speed and direction of your motors
    through a technique called *pulse width modulation (**PWM)*. This is a way to
    power a device (such as a motor) by sending digital pulses that switch on and
    off quickly, such that the device “sees” a continuous voltage. The signal sent
    to the device has a fixed frequency, but the fraction of time that the digital
    pulse is on, called the *duty cycle*, can vary. The duty cycle is expressed as
    a percentage. To illustrate, [Figure 13-4](nsp-venkitachalam503045-0028.xhtml#fig13-4)
    shows three signals with the same frequency but different duty cycles—25 percent,
    50 percent, and 75 percent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用树莓派通过一种叫做*脉宽调制（**PWM**）*的技术来控制电机的速度和方向。这是一种通过快速开关的数字脉冲来为设备（如电机）供电的方式，使得设备“看到”一个持续的电压。发送到设备的信号有固定的频率，但数字脉冲开启的时间比例（即*占空比*）是可变的。占空比以百分比表示。举例来说，[图
    13-4](nsp-venkitachalam503045-0028.xhtml#fig13-4)显示了三个频率相同但占空比不同的信号——分别是25%、50%和75%。
- en: '![](images/nsp-venkitachalam503045-f13004.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13004.jpg)'
- en: 'Figure 13-4: PWM signals with different duty cycles'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-4：具有不同占空比的PWM信号
- en: The higher the duty cycle percentage, the longer the pulse is on for each cycle
    of the signal. The motor receiving the signal will perceive those longer pulses
    as a higher continuous voltage. By manipulating the duty cycle, you can thus provide
    varying power levels to the motors in this project, which will result in variations
    in motor speed and changes in the laser pattern.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 占空比百分比越高，每个信号周期中脉冲打开的时间就越长。接收到信号的电机会将这些较长的脉冲感知为更高的持续电压。通过调节占空比，你可以为这个项目中的电机提供不同的功率，从而导致电机速度的变化和激光模式的变化。
- en: NOTE PWM has many applications beyond motor control. It could also be used,
    for example, to control the brightness of dimmable LEDs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：PWM在电机控制之外还有许多应用。例如，它还可以用于控制可调光LED的亮度。
- en: Motors operate at a relatively high voltage, but the Raspberry Pi can handle
    only so much current before it’s damaged. You’ll be using a TB6612FNG motor driver
    breakout board, similar to the ones shown in [Figure 13-5](nsp-venkitachalam503045-0028.xhtml#fig13-5),
    to act as an intermediary between the Pi and the motors, keeping the Pi safe.
    Many variants of this board are available, and you can choose any one of them,
    as long as you’re careful to wire it up correctly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 电机工作时电压较高，但树莓派只能承受有限的电流，超过这个电流就会被损坏。你将使用一个TB6612FNG电机驱动模块板，类似于[图 13-5](nsp-venkitachalam503045-0028.xhtml#fig13-5)中显示的那种，作为树莓派与电机之间的中介，确保树莓派的安全。市面上有许多这种模块的变种，你可以选择其中任何一种，只要小心正确接线即可。
- en: '![](images/nsp-venkitachalam503045-f13005.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13005.jpg)'
- en: 'Figure 13-5: TB6612FNG motor driver breakout printed circuit boards (PCBs)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-5：TB6612FNG电机驱动模块的印刷电路板（PCB）
- en: The bottom of the breakout board should have pin information. It’s also a good
    idea to look at the TB6612FNG chip datasheet, which you can download from the
    internet. The *A* and *B* in the pin names denote the two motors. The IN pins
    control the direction of the motors, the 01 and 02 pins supply power to the motors,
    and the PWM pins use pulse width modulation to control the motor speeds. By writing
    to these pins, you can control both the direction and speed of rotation for each
    motor, which is exactly what you need for this project. We won’t go into the details
    of how this board works, but if you’re curious, you can start by reading up on
    an *H-bridge*, a common circuit design that uses MOSFETs to control motors.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模块板的底部应该有引脚信息。查看TB6612FNG芯片的数据手册也是一个好主意，你可以从互联网上下载。引脚名称中的*A*和*B*表示两个电机。IN引脚控制电机的方向，01和02引脚为电机提供电源，而PWM引脚则使用脉宽调制来控制电机的速度。通过向这些引脚写入数据，你可以控制每个电机的旋转方向和速度，这正是这个项目所需要的。我们不会详细讲解这个模块的工作原理，但如果你感兴趣，可以从学习*H桥*开始，这是一种常见的电路设计，利用MOSFET控制电机。
- en: NOTE You could replace this breakout part with any motor control circuit you’re
    familiar with, as long as you modify the code appropriately.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以用任何你熟悉的电机控制电路来替换这个模块，只要你相应地修改代码即可。
- en: Laser Module
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 激光模块
- en: For the laser, you’ll use an inexpensive laser module breakout PCB similar to
    the one shown in [Figure 13-6](nsp-venkitachalam503045-0028.xhtml#fig13-6).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于激光，你将使用一个价格低廉的激光模块板，类似于[图 13-6](nsp-venkitachalam503045-0028.xhtml#fig13-6)中展示的那种。
- en: '![](images/nsp-venkitachalam503045-f13006.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13006.jpg)'
- en: 'Figure 13-6: A laser module'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-6：激光模块
- en: Different variants of laser modules are available. You want one with a 650 nanometer
    (nm) red laser that operates at 5 volts (V). (The 650 nm refers to the laser’s
    wavelength.) Be sure you understand the polarity and connections of this board
    before you use it for the project. Test it separately using a 5 V power supply.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有不同版本的激光模块。你需要一个工作在 5 伏（V）的 650 纳米（nm）红色激光模块。（650 nm 指的是激光的波长。）在使用该板进行项目之前，确保你了解它的极性和连接方式。使用
    5 V 电源单独测试它。
- en: MOSFET
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MOSFET
- en: To turn the laser module on and off using the Raspberry Pi, you’ll use an *N-channel
    MOSFET*, which you can think of as an electrically controlled switch. You can
    use almost any N-channel MOSFET for the project, but the BS170 is cheap and readily
    available. [Figure 13-7](nsp-venkitachalam503045-0028.xhtml#fig13-7) shows the
    pin numbering for the MOSFET, as well as how to connect it to the laser module
    and the Raspberry Pi.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用树莓派打开和关闭激光模块，你将使用*N-channel MOSFET*，你可以把它看作是一个电控开关。你可以使用几乎任何 N-channel MOSFET
    来完成这个项目，但 BS170 既便宜又容易获取。[图 13-7](nsp-venkitachalam503045-0028.xhtml#fig13-7)
    显示了 MOSFET 的引脚编号，以及如何将其连接到激光模块和树莓派。
- en: '![](images/nsp-venkitachalam503045-f13007.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13007.jpg)'
- en: 'Figure 13-7: BS170 MOSFET connections'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-7：BS170 MOSFET 连接图
- en: The 10 kΩ resistor “pulls” the gate pin of the MOSFET to the ground, so it isn’t
    triggered when the Raspberry Pi GPIO pin is in a floating state (for example,
    after a GPIO cleanup). When you send a HIGH to the GPIO, the MOSFET switch turns
    on, effectively connecting the laser module to VM and GND and powering it on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 10 kΩ 电阻将 MOSFET 的门引脚“拉”到地面，这样当树莓派 GPIO 引脚处于浮空状态时（例如，在 GPIO 清理后），它不会被触发。当你向
    GPIO 发送 HIGH 信号时，MOSFET 开关会打开，实际上将激光模块连接到 VM 和 GND，从而为其供电。
- en: Why do you need a MOSFET? Can’t you just connect the laser module directly to
    a GPIO pin of the Raspberry Pi? That’s not a great idea, because the MOSFET can
    take a lot more current than your Raspberry Pi. Using a MOSFET isolates your Pi
    from a situation that causes a current spike on the load. Better to burn your
    cheap MOSFET than your comparatively expensive Raspberry Pi! In general, the MOSFET
    trick is a good thing to remember whenever you want to control an external device
    with your Raspberry Pi.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要一个 MOSFET？不能直接将激光模块连接到树莓派的 GPIO 引脚吗？这个主意并不好，因为 MOSFET 能承受的电流远大于树莓派。使用 MOSFET
    可以将树莓派与负载电流激增的情况隔离开来。宁愿烧坏你便宜的 MOSFET，也不要烧坏你相对昂贵的树莓派！一般来说，每当你想用树莓派控制外部设备时，记得使用
    MOSFET 是一个好主意。
- en: '[Analyzing Audio with the Fast Fourier Transform](nsp-venkitachalam503045-0008.xhtml#rbh1502)'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用快速傅里叶变换分析音频](nsp-venkitachalam503045-0008.xhtml#rbh1502)'
- en: Because the ultimate goal in this project is to control motor speeds based on
    audio input, you need to be able to analyze the audio in real time. Recall from
    [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04) that tones from an acoustic
    instrument are a mix of several frequencies, or overtones. In fact, any sound
    can be decomposed into its constituent frequencies using a *Fourier transform*.
    When the Fourier transform is applied to digital signals, the result is called
    the *discrete Fourier transform (**DFT)* because digital signals are composed
    of many discrete samples. In this project, you’ll use Python to implement a *fast
    Fourier transform (FFT)* algorithm to compute the DFT. (Throughout this chapter,
    I’ll use *FFT* to refer to both the algorithm and the result.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个项目的最终目标是根据音频输入控制电机速度，你需要能够实时分析音频。回想一下[第 4 章](nsp-venkitachalam503045-0016.xhtml#ch04)，声学乐器发出的音调是多种频率或泛音的混合。事实上，任何声音都可以通过*傅里叶变换*分解成它的组成频率。当傅里叶变换应用于数字信号时，结果被称为*离散傅里叶变换（**DFT）*，因为数字信号是由许多离散样本组成的。在这个项目中，你将使用
    Python 实现一个*快速傅里叶变换（FFT）*算法来计算 DFT。（在本章中，我将使用*FFT* 来指代算法和结果。）
- en: '[Figure 13-8](nsp-venkitachalam503045-0028.xhtml#fig13-8) shows a simple example
    of an FFT. The top frame of the figure shows the waveform of a signal that combines
    just two sine waves. This plot is in the *time domain* because it’s showing how
    the signal’s amplitude varies over time. The bottom frame of the figure shows
    the FFT corresponding to that signal. The FFT is in the *frequency domain*; it’s
    showing what frequencies are present in the signal at a given moment in time.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-8](nsp-venkitachalam503045-0028.xhtml#fig13-8)展示了FFT的一个简单例子。图中的顶部框展示了一个由两个正弦波组成的信号波形。这个图是*时域图*，因为它展示了信号的振幅如何随时间变化。图中的底部框展示了该信号的FFT。FFT是*频域图*，它显示了在某一时刻信号中存在哪些频率。'
- en: '![](images/nsp-venkitachalam503045-f13008.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13008.jpg)'
- en: 'Figure 13-8: An audio signal containing multiple frequencies (top) and its
    corresponding FFT (bottom)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-8：包含多个频率的音频信号（顶部）及其对应的FFT（底部）
- en: 'The wave in the top frame can be expressed by the following equation, which
    sums the two sine waves:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部框中的波形可以通过以下方程表示，该方程将两个正弦波相加：
- en: '*y*(*t*) = 4sin(2π10*t*) + 2.5sin(2π30*t*)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*(*t*) = 4sin(2π10*t*) + 2.5sin(2π30*t*)'
- en: Notice the 4 and 10 in the expression for the first wave—4 is the amplitude
    of the wave, and 10 is the frequency (in hertz). Meanwhile, the second wave has
    an amplitude of 2.5 and a frequency of 30 Hz. Take a look at the FFT in the bottom
    frame of the figure and you’ll see it has two peaks, at 10 Hz and 30 Hz. The FFT
    has revealed the signal’s component frequencies. The FFT also identifies the relative
    amplitude of each frequency; the intensity of the first peak is about twice that
    of the second peak.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意表达式中第一个波的4和10——4是波的振幅，10是频率（单位赫兹）。而第二个波的振幅为2.5，频率为30赫兹。观察图中底部框的FFT，你会看到它有两个峰值，分别在10赫兹和30赫兹。FFT揭示了信号的组成频率。FFT还识别了每个频率的相对振幅；第一个峰的强度大约是第二个峰的两倍。
- en: Now let’s look at a more realistic example. [Figure 13-9](nsp-venkitachalam503045-0028.xhtml#fig13-9)
    shows a complex audio signal in the top frame and the corresponding FFT in the
    bottom frame. Notice that the FFT contains many more peaks at a variety of intensities,
    indicating that the signal contains many more frequencies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个更现实的例子。[图 13-9](nsp-venkitachalam503045-0028.xhtml#fig13-9)展示了顶部框中的复杂音频信号和底部框中的对应FFT。注意，FFT包含了更多的峰值，并且它们的强度各不相同，表明信号包含了更多的频率。
- en: '![](images/nsp-venkitachalam503045-f13009.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13009.jpg)'
- en: 'Figure 13-9: The FFT algorithm takes an amplitude signal (top) and computes
    its component frequencies (bottom).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-9：FFT算法获取一个振幅信号（顶部），并计算其组成的频率（底部）
- en: To compute an FFT, you need a set of samples. The choice of the number of samples
    is a bit arbitrary, but a small sample size wouldn’t give you a good picture of
    the signal’s frequency content and might also mean a higher computational load
    because you would need to compute more FFTs per second. On the other hand, a sample
    size that’s too large would average out the changes in the signal, so you wouldn’t
    be getting a “real-time” frequency response for the signal. For the purposes of
    this project, a sample size of 2,048 will work. At a sampling rate of 44,100 Hz,
    2,048 samples represent about 0.046 seconds of audio.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算FFT，你需要一组采样数据。选择采样数量有些任意，但样本太少不会给你信号频率内容的清晰图像，而且可能还会导致更高的计算负担，因为你需要每秒计算更多的FFT。另一方面，样本数量过大则会平滑信号的变化，因此你将无法得到信号的“实时”频率响应。对于本项目，2,048个样本是可行的。在44,100赫兹的采样率下，2,048个样本代表约0.046秒的音频。
- en: 'You’ll use `numpy` to compute an FFT to split the audio data into its constituent
    frequencies, and then you’ll use that information to control the motors. First
    you’ll split the range of frequencies (in Hz) into three bands: [0, 100], [100,
    1000], and [1000, 2500]. You’ll compute an average amplitude level for each band,
    and each value will affect the motors and resulting laser pattern differently,
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`numpy`来计算FFT，将音频数据分解为其组成的频率，然后利用这些信息来控制电机。首先，你将把频率范围（单位为赫兹）分为三个频段：[0, 100]、[100,
    1000]和[1000, 2500]。你将为每个频段计算一个平均振幅值，每个值将以不同的方式影响电机和最终的激光图案，具体如下：
- en: • Changes in the average amplitude of low frequencies will affect the speed
    of the first motor.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 低频率的平均振幅变化会影响第一个电机的速度。
- en: • Changes in the average amplitude of middle frequencies will affect the speed
    of the second motor.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 中频的平均振幅变化会影响第二个电机的速度。
- en: • When high frequencies peak above a certain threshold, the first motor will
    change direction.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 当高频率超过某个阈值时，第一个电机将改变方向。
- en: With these rules, the laser pattern will change in response to the audio signal.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些规则，激光图案会响应音频信号发生变化。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1502)'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah1502)'
- en: 'In this project, you’ll use the following Python modules:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用以下 Python 模块：
- en: • `RPi.GPIO` to set up PWM and control the output of the pins
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `RPi.GPIO` 用于设置 PWM 和控制引脚的输出
- en: • `time` for pausing between operations
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `time` 用于操作之间的暂停
- en: • `wave` to read WAV files
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `wave` 用于读取 WAV 文件
- en: • `pyaudio` to process and stream audio data
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `pyaudio` 用于处理和流式传输音频数据
- en: • `numpy` for FFT computations
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `numpy` 用于 FFT 计算
- en: • `argparse` to process command line arguments
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `argparse` 用于处理命令行参数
- en: 'You’ll also need the following items to build the project:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要以下物品来构建该项目：
- en: • One Raspberry Pi 3B+ or newer
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 Raspberry Pi 3B+ 或更新版本
- en: • One 5 V adapter to power the Raspberry Pi
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 5 V 适配器，用于为 Raspberry Pi 供电
- en: • One powered speaker with AUX (line-in) input (most Bluetooth speakers have
    an AUX input these days)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个带 AUX（线路输入）接口的有源扬声器（现在大多数蓝牙扬声器都有 AUX 输入）
- en: • One TB6612FNG motor breakout board
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 TB6612FNG 电机扩展板
- en: • One laser module breakout board
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个激光模块扩展板
- en: • One 10 kΩ resistor
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 10 kΩ 电阻
- en: • One BS170 N-channel MOSFET or equivalent
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 BS170 N-channel MOSFET 或等效元件
- en: • Two DC motors like the ones used in a small toy, rated for 9 V
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个 9 V 额定的小型玩具用直流电机
- en: • Two small mirrors, approximately 1 inch or less in diameter
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个小镜子，直径大约为 1 英寸或更小
- en: • One 3.7 V 18650 2000 mAh (3C) lithium-ion battery with holder (or use four
    AA batteries on a holder)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个 3.7 V 18650 2000 mAh（3C）锂离子电池和电池座（或者使用四节 AA 电池和电池座）
- en: • Two 3D-printed parts to fix the mirrors onto the motor shafts (optional)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个 3D 打印的零件，用于将镜子固定在电机轴上（可选）
- en: • One rectangular base, about 8 inches by 6 inches, to mount the hardware
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个大约 8 英寸 × 6 英寸的矩形底座，用于安装硬件
- en: • Some LEGO bricks to raise the motors and laser module off the base so the
    mirrors can spin freely
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一些 LEGO 积木，用于将电机和激光模块抬起，以便镜子可以自由旋转
- en: • A hot glue gun
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一把热熔胶枪
- en: • Superglue to fix the mirrors to the motor shafts
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 超级胶水用于将镜子固定到电机轴上
- en: • A soldering iron
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一把焊接铁
- en: • A breadboard
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个面包板
- en: • Wires to make connections (single-core hookup wires with male pins on both
    sides work nicely)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 用于连接的电线（双头公针单股连接线效果很好）
- en: '[Setting Up the Raspberry Pi](nsp-venkitachalam503045-0008.xhtml#rbh1503)'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置 Raspberry Pi](nsp-venkitachalam503045-0008.xhtml#rbh1503)'
- en: To set up your Raspberry Pi, see [Appendix B](nsp-venkitachalam503045-0032.xhtml#appb).
    Follow the instructions in the appendix, and make sure you’ve installed the `numpy`
    and `pyaudio`Python packages required for this project. You’ll write code on the
    Raspberry Pi via a Secure Shell (SSH). You can set up Microsoft Visual Studio
    Code to work remotely on the Pi using an SSH from your laptop or desktop computer.
    This is also explained in [Appendix B](nsp-venkitachalam503045-0032.xhtml#appb).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置你的 Raspberry Pi，请参见 [附录 B](nsp-venkitachalam503045-0032.xhtml#appb)。按照附录中的说明操作，确保已经安装了本项目所需的
    `numpy` 和 `pyaudio` Python 包。你将通过安全外壳（SSH）在 Raspberry Pi 上编写代码。你可以通过 SSH 将 Microsoft
    Visual Studio Code 设置为远程连接 Pi，操作可以在你的笔记本电脑或台式机上进行。这一点在 [附录 B](nsp-venkitachalam503045-0032.xhtml#appb)
    中也有说明。
- en: '[Constructing the Laser Display](nsp-venkitachalam503045-0008.xhtml#rbh1504)'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[构建激光显示](nsp-venkitachalam503045-0008.xhtml#rbh1504)'
- en: Before you hook up all the hardware, you should prepare the motors and the laser
    module for the laser display. The first order of business is to attach the mirrors
    to the motors. Each mirror has to be at a slight angle relative to the motor shaft.
    One way to do this would be to use hot glue. To attach the mirror, place it face
    down on a flat surface and put a drop of hot glue in the center. Carefully dip
    the motor shaft in the glue, keeping it at a slight angle to the perpendicular
    with respect to the mirror, until the glue hardens.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接所有硬件之前，你应该准备电机和激光模块用于激光显示。首先要做的是将镜子安装到电机上。每个镜子必须相对于电机轴稍微倾斜。可以使用热熔胶来完成这项工作。将镜子放在平坦的表面上，镜面朝下，在中心滴上一滴热熔胶。小心地将电机轴浸入胶水中，确保其相对于镜子垂直线有一个轻微的角度，直到胶水凝固。
- en: A better way would be to use a motor flange with a slanted face to which you
    can easily stick the mirror. But where would you find such a part? You can make
    it yourself using 3D printing! [Figure 13-10(a)](nsp-venkitachalam503045-0028.xhtml#fig13-10)
    shows a 3D design I created using the free, open source program called OpenSCAD.
    You can download the design from this book’s GitHub repository. [Figure 13-10(b)](nsp-venkitachalam503045-0028.xhtml#fig13-10)
    shows the 3D printed parts. The mirror the laser strikes first will use the flange
    with the lesser tilt (5 degrees), and the second mirror will use the one with
    more tilt (10 degrees).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用带有倾斜面的电机法兰，您可以轻松地将镜子粘贴到其上。但是，您在哪里能找到这样的部件呢？您可以使用3D打印自己制作！[图13-10(a)](nsp-venkitachalam503045-0028.xhtml#fig13-10)展示了我使用名为OpenSCAD的免费开源程序创建的3D设计。您可以从本书的GitHub仓库下载该设计。[图13-10(b)](nsp-venkitachalam503045-0028.xhtml#fig13-10)展示了3D打印的部件。激光首先照射到的镜子将使用倾斜较小的法兰（5度），而第二面镜子将使用倾斜较大的法兰（10度）。
- en: '![](images/nsp-venkitachalam503045-f13010a.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13010a.jpg)'
- en: (a)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (a)
- en: '![](images/nsp-venkitachalam503045-f13010b.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13010b.jpg)'
- en: (b)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: (b)
- en: 'Figure 13-10: An OpenSCAD model (a) and 3D-printed flanges (b)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-10：OpenSCAD模型（a）和3D打印法兰（b）
- en: Print the flanges yourself if you have a 3D printer, or get them printed from
    a 3D printing service. (Either way, it will be inexpensive.) Once you have the
    parts, use superglue to attach the flanges to the motor shafts and the mirrors
    to the flanges. [Figure 13-11](nsp-venkitachalam503045-0028.xhtml#fig13-11) shows
    the fully assembled parts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有3D打印机，可以自己打印法兰，或者从3D打印服务商那里打印。（无论哪种方式，都不会很贵。）一旦得到这些部件，使用强力胶将法兰固定到电机轴上，再将镜子粘贴到法兰上。[图13-11](nsp-venkitachalam503045-0028.xhtml#fig13-11)展示了完全组装好的部件。
- en: '![](images/nsp-venkitachalam503045-f13011.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13011.jpg)'
- en: 'Figure 13-11: Attach the mirrors to each motor shaft at a slight angle.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-11：将镜子以轻微的角度固定到每个电机轴上。
- en: To test the assembly, spin the mirror with your hand while shining the laser
    module at it. You should find the reflection of the laser dot moves in an ellipse
    when projected on a flat surface. Do the same for the second mirror. It should
    create a wider ellipse because of the larger angle with respect to the motor shaft.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试装配效果，用手旋转镜子，同时将激光模块对准它。您应该会发现，激光点的反射在平面表面上呈椭圆形移动。对第二面镜子也做相同的操作。由于相对于电机轴的角度较大，它应该会形成一个更宽的椭圆。
- en: Aligning the Mirrors
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 镜子对准
- en: Next, align the laser module with the mirrors so that the laser reflects from
    mirror A to mirror B, as shown in [Figure 13-12](nsp-venkitachalam503045-0028.xhtml#fig13-12).
    Be sure that the reflected laser light from mirror A stays within the circumference
    of mirror B for mirror A’s entire range of rotation. (This will take some trial
    and error.) To test the arrangement, manually rotate mirror A. Also, be sure to
    position mirror B so that the light reflected from its surface will fall on a
    flat surface (like a wall) for the full range of rotation of both mirrors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将激光模块与镜子对准，使激光从镜子A反射到镜子B，如[图13-12](nsp-venkitachalam503045-0028.xhtml#fig13-12)所示。确保从镜子A反射出来的激光光束在镜子A的整个旋转范围内都保持在镜子B的圆周内。（这将需要一些反复试验。）为了测试这一排列，手动旋转镜子A。同时，确保将镜子B放置好，使得其表面反射的光束在两个镜子旋转的整个范围内都会落到一个平面表面（如墙壁）上。
- en: '![](images/nsp-venkitachalam503045-f13012.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13012.jpg)'
- en: 'Figure 13-12: The alignment of the laser and the mirrors'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-12：激光与镜子的对准
- en: 'NOTE As you tweak the alignment, you’ll need to keep the laser pointer on.
    You can do this by running the project code as follows: `python laser_audio.py
    --test_laser`. This command simply turns on the MOSFET controlling the laser module,
    as we’ll discuss later in the chapter.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在调整对准时，您需要保持激光指示器开启。您可以通过运行以下项目代码来实现：`python laser_audio.py --test_laser`。这个命令只是开启控制激光模块的MOSFET，稍后我们会在本章中讨论这个问题。
- en: Once you’re happy with the placement of the mirrors, hot-glue the laser module
    and the two motors with attached mirrors onto three identical blocks (LEGO blocks
    work great!) to raise them up so that the motors will be able to rotate freely.
    Next, place the blocks on the mounting board, and when you’re happy with their
    arrangement, mark the location of each by tracing their edge with a pencil. Then
    hot-glue the blocks onto the board. Or use a LEGO baseplate and simply attach
    the LEGO blocks to the baseplate.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对镜子的放置感到满意，用热熔胶将激光模块和附加镜子的两个电机固定在三个相同的积木上（乐高积木非常适用！），将其抬高，以便电机能够自由旋转。接着，将这些积木放在安装板上，当你对它们的排列感到满意时，用铅笔勾画出它们的位置，然后将积木用热熔胶粘在板上。或者，使用乐高底板，并将乐高积木直接附加到底板上。
- en: Powering the Motors
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电机供电
- en: If your motors didn’t come with wires attached to their terminals (most don’t),
    solder wires to both terminals, being sure to leave sufficient wire (say, 6 inches)
    so that you can attach the motors to the motor driver board. The motors can be
    powered by a 3.7 V lithium-ion battery, or a 4x AA battery pack.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电机没有附带连接端子上的电线（大多数没有），请在两个端子上焊接电线，确保留下足够的电线（例如6英寸），以便将电机连接到电机驱动板。电机可以由3.7V锂电池或4节AA电池包供电。
- en: '[Hooking Up the Hardware](nsp-venkitachalam503045-0008.xhtml#rbh1505)'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[连接硬件](nsp-venkitachalam503045-0008.xhtml#rbh1505)'
- en: Now to hook up the hardware. You need to connect the Raspberry Pi, the motor
    driver board, the MOSFET, the laser module board, and the motors. The Raspberry
    Pi has a collection of GPIO pins for connecting to other hardware. To understand
    the pin layout, I highly recommend you visit the website [https://pinout.xyz](https://pinout.xyz/).
    It gives you a handy visual reference and explains the various pin functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始连接硬件。你需要将树莓派、电机驱动板、MOSFET、激光模块板和电机连接起来。树莓派拥有一系列GPIO引脚，可以连接到其他硬件。为了了解引脚布局，我强烈建议你访问网站[https://pinout.xyz](https://pinout.xyz/)。它提供了一个方便的视觉参考，并解释了各种引脚的功能。
- en: NOTE There are a few different conventions for referring to pin numbers on a
    Raspberry Pi. For this project, we’ll use the *BCM pin-numbering* convention.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有几种不同的惯例用于引用树莓派上的引脚编号。对于这个项目，我们将使用*BCM引脚编号*惯例。
- en: '[Table 13-1](nsp-venkitachalam503045-0028.xhtml#tab13-1) lists the connections
    you need to make.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[表13-1](nsp-venkitachalam503045-0028.xhtml#tab13-1)列出了你需要连接的各个接口。'
- en: 'Table 13-1: Hardware Wiring Connections'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-1：硬件接线连接
- en: '| From | To |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 从 | 到 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Raspberry Pi GPIO 12 | TB6612FNG PWMA |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派GPIO 12 | TB6612FNG PWMA |'
- en: '| Raspberry Pi GPIO 13 | TB6612FNG PWMB |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派GPIO 13 | TB6612FNG PWMB |'
- en: '| Raspberry Pi GPIO 7 | TB6612FNG AIN1 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派GPIO 7 | TB6612FNG AIN1 |'
- en: '| Raspberry Pi GPIO 8 | TB6612FNG AIN2 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派GPIO 8 | TB6612FNG AIN2 |'
- en: '| Raspberry Pi GPIO 5 | TB6612FNG BIN1 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派GPIO 5 | TB6612FNG BIN1 |'
- en: '| Raspberry Pi GPIO 6 | TB6612FNG BIN2 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派GPIO 6 | TB6612FNG BIN2 |'
- en: '| Raspberry Pi GPIO 22 | TB6612FNG STBY |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派GPIO 22 | TB6612FNG STBY |'
- en: '| Raspberry Pi GND | TB6612FNG GND |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派GND | TB6612FNG GND |'
- en: '| Raspberry Pi 3V3 | TB6612FNG VCC |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派3V3 | TB6612FNG VCC |'
- en: '| Raspberry Pi GPIO 25 | BS170 GATE (also to GND via 10 kΩ resistor) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派GPIO 25 | BS170栅极（也连接到GND通过10 kΩ电阻） |'
- en: '| Raspberry Pi GND | BS170 SOURCE |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派GND | BS170源极 |'
- en: '| Laser module GND | BS170 DRAIN |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 激光模块GND | BS170漏极 |'
- en: '| Laser module VCC | Battery pack VCC (+) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 激光模块VCC | 电池包VCC（+） |'
- en: '| Battery pack GND (−) | TB6612FNG GND |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 电池包GND（−） | TB6612FNG GND |'
- en: '| Battery pack VCC (+) | TB6612FNG VM |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 电池包VCC（+） | TB6612FNG VM |'
- en: '| Motor #1 connector #1 (polarity doesn’t matter) | TB6612FNG A01 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 电机#1连接器#1（极性无关） | TB6612FNG A01 |'
- en: '| Motor #1 connector #2 (polarity doesn’t matter) | TB6612FNG A02 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 电机#1连接器#2（极性无关） | TB6612FNG A02 |'
- en: '| Motor #2 connector #1 (polarity doesn’t matter) | TB6612FNG B01 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 电机#2连接器#1（极性无关） | TB6612FNG B01 |'
- en: '| Motor #2 connector #2 (polarity doesn’t matter) | TB6612FNG B02 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 电机#2连接器#2（极性无关） | TB6612FNG B02 |'
- en: '| Raspberry Pi 3.5 mm audio jack | AUX input of powered speaker |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 树莓派3.5毫米音频接口 | 带电扬声器的AUX输入 |'
- en: '[Figure 13-13](nsp-venkitachalam503045-0028.xhtml#fig13-13) shows everything
    wired up.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-13](nsp-venkitachalam503045-0028.xhtml#fig13-13)显示了所有的接线。'
- en: '![](images/nsp-venkitachalam503045-f13013.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13013.jpg)'
- en: 'Figure 13-13: The completely wired-up laser display'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-13：完全接线的激光显示器
- en: Now let’s look at the code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下代码。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1503)'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1503)'
- en: The code for this project is in the file *laser_audio.py*. You’ll begin with
    some basic setup. Then you’ll define functions to operate and test the motors
    and laser, as well as a function to process audio data from a WAV file and control
    the motors based on that data. You’ll bring everything together and accept command
    line options through the `main()` function. To see the full program, skip ahead
    to [“The Complete Code”](nsp-venkitachalam503045-0028.xhtml#ah1507) on [page 305](nsp-venkitachalam503045-0028.xhtml#p305).
    You can also download the code at [https://github.com/mkvenkit/pp2e/tree/main/laser_audio](https://github.com/mkvenkit/pp2e/tree/main/laser_audio).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的代码在文件*laser_audio.py*中。你将从一些基本的设置开始。然后，你将定义用于操作和测试电机与激光的函数，并定义一个用于处理WAV文件中音频数据并根据这些数据控制电机的函数。最后，你会将所有内容整合起来，并通过`main()`函数接收命令行选项。要查看完整程序，请跳到[“完整代码”](nsp-venkitachalam503045-0028.xhtml#ah1507)章节，[第305页](nsp-venkitachalam503045-0028.xhtml#p305)。你也可以在[https://github.com/mkvenkit/pp2e/tree/main/laser_audio](https://github.com/mkvenkit/pp2e/tree/main/laser_audio)下载代码。
- en: '[Setting Up](nsp-venkitachalam503045-0008.xhtml#rbh1506)'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置](nsp-venkitachalam503045-0008.xhtml#rbh1506)'
- en: 'Start by importing the required modules:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入所需的模块：
- en: '[PRE0]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `RPi.GPIO` module lets you use the pins of the Raspberry Pi. You’ll use
    the `time` module to put delays in your code, and you’ll use `argparse` to add
    command line arguments to the program. The `pyaudio` and `wave` modules will help
    you read data from WAV files and output an audio stream. Finally, you’ll use `numpy`
    to compute the FFT of the audio data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPi.GPIO`模块让你能够使用树莓派的引脚。你将使用`time`模块来在代码中添加延迟，并且使用`argparse`来为程序添加命令行参数。`pyaudio`和`wave`模块将帮助你从WAV文件中读取数据并输出音频流。最后，你将使用`numpy`来计算音频数据的FFT。'
- en: 'Next, you initialize a few global variables:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你初始化一些全局变量：
- en: '[PRE1]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code stores the pin numbers for all the Raspberry Pi pins used in the project.
    `PWMA`, `PWMB`, `AIN1`, `AIN2`, `BIN1`, `BIN2`, and `STBY` are pins that connect
    to the TB6612FNG motor driver. The `LASER` pin will connect to the gate of the
    MOSFET, which can turn the laser module on and off. Note that you’re using the
    BCM pin-numbering convention here.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码存储了项目中所有使用的树莓派引脚的编号。`PWMA`、`PWMB`、`AIN1`、`AIN2`、`BIN1`、`BIN2`和`STBY`是连接到TB6612FNG电机驱动器的引脚。`LASER`引脚将连接到MOSFET的门极，用来控制激光模块的开关。请注意，你在这里使用的是BCM引脚编号约定。
- en: 'Continue with a few more global variables:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 继续定义更多的全局变量：
- en: '[PRE2]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here you initialize the variables `pwm_a` and `pwm_b` that will represent `PWM`
    objects, which you’ll use to control the motors. You set them to `None` here because
    it’s too early in the code to create the actual `PWM` objects. You also set `CHUNK`,
    the number of audio data samples you’ll read in from the WAV file at a time, and
    `N`, the number of samples you’ll use to compute the FFT.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你初始化了`pwm_a`和`pwm_b`变量，它们将代表`PWM`对象，用于控制电机。由于在代码中此时创建实际的`PWM`对象还为时过早，所以你将它们设置为`None`。你还设置了`CHUNK`，即每次从WAV文件中读取的音频数据样本数量，以及`N`，即用于计算FFT的样本数量。
- en: 'You finish setting up by initializing the GPIO pins. This is necessary to use
    the pins. Define a function `init_pins()` for this purpose:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过初始化GPIO引脚来完成设置。这是使用引脚所必须的。为此，你定义了一个`init_pins()`函数：
- en: '[PRE3]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First you indicate that `pwm_a` and `pwm_b` are global variables ❶, since you’ll
    be setting them inside this function. Then you set the pin mode to the BCM numbering
    convention ❷. Next, you put the pin variables you set earlier into a `pins` list
    so you can declare them all to be output pins with one call ❸. Finally, you create
    two `PWM` objects and assign them to your global `pwm_a` and `pwm_b` variables.
    The argument `100` is the frequency, in hertz, of the signal that will drive each
    motor. You’ll vary the duty cycles of those signals to control the motors’ speeds
    using pulse width modulation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明`pwm_a`和`pwm_b`是全局变量❶，因为你将在这个函数内部设置它们。接着，你将引脚模式设置为BCM编号约定❷。然后，你将之前设置的引脚变量放入一个`pins`列表中，这样你可以通过一次调用将它们全部声明为输出引脚❸。最后，你创建两个`PWM`对象，并将它们分配给全局变量`pwm_a`和`pwm_b`。参数`100`是信号的频率，单位为赫兹，用于驱动每个电机。你将通过调整这些信号的占空比来控制电机的速度，使用脉宽调制。
- en: '[Controlling the Hardware](nsp-venkitachalam503045-0008.xhtml#rbh1507)'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[控制硬件](nsp-venkitachalam503045-0008.xhtml#rbh1507)'
- en: 'You need some helper functions to control the laser module and the motors.
    Let’s look first at the function that toggles the laser module:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一些辅助函数来控制激光模块和电机。首先让我们看看切换激光模块的函数：
- en: '[PRE4]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function takes a parameter `on` that will be a Boolean `True/False` value.
    You pass that parameter to the `GPIO.output()` method to set the `LASER` pin on
    (`True`) or off (`False`). This will trigger the MOSFET to turn the laser module
    on or off.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个参数`on`，它是一个布尔值`True/False`。你将该参数传递给`GPIO.output()`方法，以便设置`LASER`引脚为开（`True`）或关（`False`）。这将触发MOSFET开关，控制激光模块的开关。
- en: 'Next, define a function `start_motors()` to turn the motors on at the start
    of the project:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数`start_motors()`，在项目开始时启动电机：
- en: '[PRE5]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First you set the `STBY` (standby) pin to `HIGH` ❶, which in effect turns on
    the motor driver. Then you set the `AIN1` and `AIN2` pins to `HIGH` ❷ and `LOW`
    ❸, respectively. This will cause motor A to spin in one direction. (Swapping the
    `HIGH/LOW` values between the two pins would cause the motor to spin in the opposite
    direction.) You do the same thing for motor B. Lastly, you use your `PWM` objects
    to set the speed of the motors ❹. You set the duty cycle (which correlates to
    the motor speed) to 10 percent, a relatively low value, since this is just an
    initializing call.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将`STBY`（待机）引脚设置为`HIGH` ❶，这样实际上就打开了电机驱动器。然后，你将`AIN1`和`AIN2`引脚分别设置为`HIGH`
    ❷和`LOW` ❸。这将使电机A朝一个方向旋转。（如果交换这两个引脚的`HIGH/LOW`值，电机会朝相反方向旋转。）你对电机B执行相同的操作。最后，你使用`PWM`对象来设置电机的速度
    ❹。你将占空比（与电机速度相关）设置为10%，一个相对较低的值，因为这只是初始化调用。
- en: 'You also need a function to stop the motors from spinning at the end of the
    project. Here’s the definition:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个函数，在项目结束时停止电机旋转。下面是定义：
- en: '[PRE6]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To stop the motors from spinning, you first stop the PWM signals going to the
    `PWMA` ❶ and `PWMB` ❷ pins. Then you set the `AIN1`, `AIN2`, `BIN1`, and `BIN2`
    pins all to `HIGH`, which has the effect of “braking” each motor to a stop. Finally,
    you disable the motor driver by setting the `STBY` pin to `LOW` ❸. Standby mode
    saves power when the motors aren’t required to function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了停止电机旋转，你首先停止发送到`PWMA` ❶和`PWMB` ❷引脚的PWM信号。然后，你将`AIN1`、`AIN2`、`BIN1`和`BIN2`引脚都设置为`HIGH`，这会起到“刹车”的作用，迫使每个电机停下来。最后，你通过将`STBY`引脚设置为`LOW`
    ❸来禁用电机驱动器。待机模式可以在电机不需要运转时节省电力。
- en: You need one more helper function to set the speed and direction of both motors.
    You’ll use this function to adjust the motors based on your real-time audio analysis.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个辅助函数，用于设置两个电机的速度和方向。你将使用此函数，根据实时音频分析来调整电机。
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `set_motor_speed_dir()` function takes four parameters: `dca` and `dcb`
    determine the duty cycle for each motor, while `dira` and `dirb` are Booleans
    that set the motors’ direction of rotation. You use the `ChangeDutyCycle()` method
    to update the duty cycles (speeds) of the motors to the values passed into the
    function ❶. Then you attend to the motors’ directions. If `dira` is `True` ❷,
    you set pins `AIN1` and `AIN2` to `HIGH` and `LOW`, respectively, which will let
    motor A spin in one direction. However, if `dira` is `False` ❸, you set the pins
    the opposite way, which will spin the motor in the other direction. You do the
    same thing for motor B using the `dirb` parameter.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_motor_speed_dir()`函数接受四个参数：`dca`和`dcb`确定每个电机的占空比，而`dira`和`dirb`是布尔值，决定电机的旋转方向。你使用`ChangeDutyCycle()`方法来更新电机的占空比（速度），将传入函数的值
    ❶。然后，你调整电机的旋转方向。如果`dira`为`True` ❷，你将`AIN1`和`AIN2`引脚设置为`HIGH`和`LOW`，使电机A朝一个方向旋转。但是，如果`dira`为`False`
    ❸，你会将引脚设置为相反方向，使电机朝另一个方向旋转。你对电机B也执行相同的操作，使用`dirb`参数。'
- en: '[Processing the Audio](nsp-venkitachalam503045-0008.xhtml#rbh1508)'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[处理音频](nsp-venkitachalam503045-0008.xhtml#rbh1508)'
- en: The heart of this project is the `process_audio()` function, which reads audio
    data from a WAV file, outputs an audio stream with `pyaudio`, analyzes the audio
    data by computing an FFT, and uses the resulting analysis to control the motors.
    We’ll look at the function in sections.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的核心是`process_audio()`函数，它从WAV文件读取音频数据，通过`pyaudio`输出音频流，计算FFT来分析音频数据，并利用结果来控制电机。我们将分部分来看这个函数。
- en: '[PRE8]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You start by using the `wave` module to open the audio file passed into the
    `process_audio()` function ❶. The `wave.open()` function returns a `Wave_read`
    object, which you’ll use to read data from the WAV file. You print out some information
    about the WAV file read in ❷: `SW` is the sample width in bytes, `NCh` is the
    number of channels in the audio, and `SR` is the sampling rate. To keep the project
    simple, you’ll support only single-channel, 16-bit WAV files as input. You check
    for these specs ❸, and if the input doesn’t match, you return from the function.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你从使用 `wave` 模块打开传递给 `process_audio()` 函数的音频文件开始❶。`wave.open()` 函数返回一个 `Wave_read`
    对象，你将用它来读取 WAV 文件中的数据。你打印出关于读取到的 WAV 文件的一些信息❷：`SW` 是样本宽度（单位为字节），`NCh` 是音频的声道数，`SR`
    是采样率。为了简化项目，你只支持单声道、16 位的 WAV 文件作为输入。你检查这些规格❸，如果输入不符合要求，就从函数中返回。
- en: Next, you create the `PyAudio` object that you’ll use to stream data from the
    WAV file to the output ❹. Then you open a `pyaudio` output stream (as indicated
    by the `output=True` argument), configuring it to have the same sample width,
    number of channels, and sample rate as the WAV file ❺. For the Raspberry Pi, the
    default sound output is the 3.5 mm audio jack on the board. As long as your speaker
    is plugged into this jack, you’ll hear the sound output.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你创建一个 `PyAudio` 对象，用来将数据从 WAV 文件流式传输到输出❹。然后你打开一个 `pyaudio` 输出流（如 `output=True`
    参数所示），并将其配置为与 WAV 文件具有相同的样本宽度、声道数和采样率❺。对于树莓派，默认的音频输出是板上的 3.5 毫米音频插孔。只要你的扬声器插入该插孔，你就能听到音频输出。
- en: 'Here’s the next part of the function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数的下一部分：
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here you read `CHUNK` samples from the WAV file into variable `data` ❶. Remember,
    you’ve set `CHUNK` to `2048`, and each sample is 2 bytes wide, so you’ll be reading
    a total of 2,048 16-bit values. You read only one chunk of data because of how
    the function’s main loop is structured, as you’ll see soon.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你从 WAV 文件中读取 `CHUNK` 个样本到变量 `data` 中❶。记住，你已将 `CHUNK` 设置为 `2048`，每个样本是 2 字节宽，因此你将读取
    2,048 个 16 位值。由于函数主循环的结构，你一次只读取一个数据块，稍后你会看到具体实现。
- en: The `readframes()` method returns a `bytes` object, but you use the `numpy`
    library’s `frombuffer()` function to convert the `bytes` object into a `numpy`
    array of 16-bit integers called `buf` ❷. You store the sampling rate (the `wave`
    module calls it the *frame rate*) in variable `SR` ❸; you’ll need it later. Then
    you call the `start_motors()` and `laser_on()` functions, which we’ve already
    discussed, to get the motors and the laser module going.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`readframes()` 方法返回一个 `bytes` 对象，但你使用 `numpy` 库的 `frombuffer()` 函数将 `bytes`
    对象转换为一个名为 `buf` 的 16 位整数的 `numpy` 数组❷。你将采样率（`wave` 模块称之为 *帧率*）存储在变量 `SR` 中❸；稍后你会用到它。然后你调用
    `start_motors()` 和 `laser_on()` 函数，这两个函数我们之前已经讨论过，用来启动电动机和激光模块。'
- en: Next, you enter the function’s main loop, which outputs the audio and performs
    the FFT. The loop works on one chunk of audio data at a time, which is why you
    read only a single chunk of data in the previous code listing. Notice that the
    loop occurs inside a `try` block. Later, you’ll write an `except` block to handle
    any problems that arise during the execution of the loop.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你进入函数的主循环，该循环输出音频并执行 FFT。循环一次处理一个音频数据块，这就是为什么在前面的代码中你只读取一个数据块的原因。注意，循环是在一个
    `try` 块中进行的。稍后，你会写一个 `except` 块来处理在循环执行过程中出现的任何问题。
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The main loop repeats until `data` is empty ❶, meaning you’ve gotten to the
    end of the WAV file. In the loop, you write the current chunk of data to the `pyaudio`
    output stream ❷. This will allow you to hear the WAV file you’re processing at
    the same time that you’re driving the motors. Then you check whether you have
    `N` samples in the current chunk of data to calculate the FFT ❸ (you set `N` to
    `2048`, the same as the chunk size, at the start of the code). This check is required
    because the last chunk of data read in may not have the full number of samples
    needed for the FFT. In that case, you’ll simply skip calculating the FFT and updating
    the motors, since the audio file is basically over anyway.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环会一直重复，直到 `data` 为空❶，这意味着你已经读取到 WAV 文件的末尾。在循环中，你将当前的数据块写入 `pyaudio` 输出流❷。这将使你在处理
    WAV 文件的同时，能够听到它的声音，同时驱动电动机。然后你检查当前数据块是否有 `N` 个样本用于计算 FFT❸（你在代码开始时将 `N` 设置为 `2048`，与数据块大小相同）。这个检查是必要的，因为最后一个读取的数据块可能没有足够的样本来进行
    FFT。在这种情况下，你会跳过 FFT 的计算和电动机的更新，因为音频文件基本上已经结束了。
- en: 'Next, you load the audio data into a `numpy` array of 16-bit integers ❹. With
    the data in this format, computing the FFT is quite straightforward: you simply
    use the `rfft()` method from the `numpy.fft` module ❺. This method takes a signal
    composed of *real numbers* (like the audio data) and computes the FFT, which generally
    results in a set of *complex numbers*. You want to keep working with real numbers,
    however, so you use the `abs()` method to get the magnitudes of these complex
    numbers, which are real ❻. The `2.0/N` is a normalization factor you use to map
    the FFT values to the expected range.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将音频数据加载到一个`numpy`的16位整数数组中❹。在这种格式下，计算FFT非常简单：你只需要使用`numpy.fft`模块中的`rfft()`方法❺。这个方法接受由*实数*（如音频数据）组成的信号，并计算FFT，结果通常是一个*复数*的集合。然而，你希望继续使用实数，所以你使用`abs()`方法获取这些复数的幅度，它们是实数❻。`2.0/N`是一个归一化因子，用于将FFT值映射到预期的范围。
- en: 'Continuing the loop, you extract the relevant information from the FFT to control
    the motors. To analyze the audio signal, you split the frequency range into three
    bands: 0 to 100 Hz (bass), 100 to 1,000 Hz (midrange), and 1,000 to 2,500 Hz (treble).
    You’re especially interested in the bass and midrange frequency bands, which roughly
    correspond to the beat and the vocals in a song, respectively. You compute the
    average amplitude value of the frequencies in each band by using the `numpy.``sum()`
    method and dividing the result by the number of frequencies in that band ❼. You
    store the three averages in a Python list.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 继续循环，你从FFT中提取相关信息来控制电机。为了分析音频信号，你将频率范围分为三个频段：0到100 Hz（低音）、100到1,000 Hz（中音）和1,000到2,500
    Hz（高音）。你特别关注低音和中音频段，它们大致对应于歌曲中的节奏和人声部分。你使用`numpy.``sum()`方法计算每个频段中频率的平均幅度值，并将结果除以该频段中的频率数量❼。你将这三个平均值存储在Python列表中。
- en: 'Notice that you’re doing two different things in the `while` loop: sending
    audio to the output and computing the FFT of the same audio. You’re able to do
    this and maintain the audio output because the `numpy` FFT computation is fast
    enough—it finishes before the current chunk of audio data has finished playing.
    Try an experiment: put a time delay right after FFT, and see what happens to the
    sound output!'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`while`循环中你正在做两件不同的事：将音频发送到输出并计算相同音频的FFT。你能做到这一点并保持音频输出的连续性，因为`numpy`的FFT计算速度足够快——它会在当前音频数据播放完之前就计算完成。尝试一个实验：在FFT之后加入延时，看看音频输出会发生什么！
- en: Now you need to convert the average amplitudes from the FFT into motor speeds
    and directions, still within the `while` loop started in the previous listing.
    The speeds need to be percentages, while the directions need to be `True/False`
    values.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要将FFT的平均幅度转换为电机的速度和方向，仍然在之前列出的`while`循环中进行。速度需要是百分比，而方向则是`True/False`值。
- en: '[PRE11]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First you take the value from the lowest frequency band, scale it by a factor
    of `5`, convert it to an integer, and use the modulus operator (`percent`) to
    ensure that the value lies within the [0, 60] range ❶. This value controls the
    speed of motor A. Then you add `100` to the value from the middle frequency band
    and again use the modulus operator to place it in the [0, 60] range ❷. This value
    controls the speed of motor B.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你取最低频段的值，将其乘以`5`，转换为整数，然后使用取模运算符（`percent`）确保该值位于[0, 60]范围内❶。这个值控制电机A的速度。然后，你将中频段的值加上`100`，再使用取模运算符将其放置在[0,
    60]范围内❷。这个值控制电机B的速度。
- en: NOTE It’s not a good idea to run the motors too fast at first, which is why
    this code limits the motors’ speeds to 60 percent. Once you’re confident the display
    is working, you can try increasing the speed threshold at ❶ and ❷.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一开始不要让电机转速过快，这就是为什么这段代码将电机的速度限制在60% 的原因。一旦你确认显示屏正常工作，就可以尝试提高在❶和❷处的速度阈值。
- en: By default, you set `dira` to `False` to run motor A in one direction, but you
    switch to the other direction if the value from the highest frequency band crosses
    above a threshold of `0.1` ❸. Meanwhile, you keep motor B’s direction constant
    by setting `dirb` to `True`. Finally, you call your `set_motor_speed_dir()` function
    to run the motors at the speeds and directions you’ve calculated ❹.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你将`dira`设置为`False`以使电机A朝一个方向旋转，但如果来自最高频段的值超过`0.1`的阈值，则切换到另一个方向❸。与此同时，通过将`dirb`设置为`True`，你保持电机B的方向不变。最后，你调用`set_motor_speed_dir()`函数以按照你计算的速度和方向运行电机❹。
- en: NOTE There’s no particularly elegant rule governing how you convert the FFT
    information to motor speeds and directions. The FFT values change constantly with
    the audio signal, so any method you come up with will change the laser pattern
    in response to the music. I arrived at the method described here through trial
    and error; I looked at FFT values while playing various types of music and chose
    calculations that produced a nice variety of patterns. I encourage you to play
    with the calculations and create your own conversions. There are no wrong answers
    here, as long as your method puts the motor speeds in the [0, 100] range (or less
    to avoid high speeds) and sets the directions to be `True` or `False`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：没有特别优雅的规则来转换FFT信息以获取电机速度和方向。FFT 值随音频信号不断变化，因此您提出的任何方法都将根据音乐改变激光图案。我通过试验得出了这里描述的方法；我在播放各种类型的音乐时查看了FFT值，并选择了产生多种漂亮图案的计算方法。我鼓励您尝试使用这些计算并创建您自己的转换。在这里没有错误的答案，只要您的方法将电机速度设置在
    [0, 100] 范围内（或更低以避免高速度），并设置方向为 `True` 或 `False`。
- en: 'Here’s the remainder of the `process_audio()` function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `process_audio()` 函数的剩余部分：
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First you conclude the `while` loop by reading in the next chunk of audio data
    to be processed ❶. Recall that the `while` loop unfolds inside a `try` block.
    The `except` block ❷ catches any exceptions that may arise during the loop. For
    example, pressing CTRL-C while the program is running will throw an exception
    and halt the loop, as will any errors reading the data. You end by doing some
    cleanup in a `finally` block ❸ that will execute whether or not any exceptions
    are thrown. In this block, you stop the `pyaudio` output stream and close it,
    and you call your `stop_motors()` function to stop the motors from spinning.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过读取下一个要处理的音频数据块来结束 `while` 循环 ❶。请记住，`while` 循环位于 `try` 块内。`except` 块 ❷ 捕获循环期间可能出现的任何异常。例如，在程序运行时按下
    CTRL-C 将引发异常并停止循环，读取数据时发生任何错误也会停止循环。最后，在 `finally` 块 ❸ 中进行一些清理工作，无论是否抛出异常都会执行。在此块中，您停止
    `pyaudio` 输出流并关闭它，并调用 `stop_motors()` 函数停止电机旋转。
- en: '[Testing the Motors](nsp-venkitachalam503045-0008.xhtml#rbh1509)'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[测试电机](nsp-venkitachalam503045-0008.xhtml#rbh1509)'
- en: 'For testing purposes, it would be useful to be able to manually set the speed
    and direction of the motors and view the resulting laser pattern. Here’s a `test_motors()`
    function that makes this possible:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 出于测试目的，手动设置电机的速度和方向并查看生成的激光图案非常有用。这是一个 `test_motors()` 函数，可以实现这一点：
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You begin by turning on the laser ❶ and starting the motors ❷. Then you enter
    a loop to get information from the user. The loop prompts the user to enter four
    integer values ❸: `dca` and `dcb` are the duty cycles (speeds) for the motors
    (from 0 to 100), and `dira` and `dirb` are the motor directions (0 or 1). You
    wait for the input, and then parse it, using `split()` to divide the input string
    into separate strings based on whitespace and a list comprehension to convert
    each substring into an integer ❹. After a sanity check to ensure that you did,
    in fact, get four numbers as input, you run the motors using the provided values
    ❺.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先打开激光 ❶ 并启动电机 ❷。然后，您进入一个循环以从用户获取信息。该循环提示用户输入四个整数值 ❸：`dca` 和 `dcb` 是电机的占空比（速度）（从0到100），`dira`
    和 `dirb` 是电机方向（0或1）。等待输入，然后解析它，使用 `split()` 根据空格分割输入字符串，并使用列表推导将每个子字符串转换为整数 ❹。经过一些检查以确保确实得到了四个输入数字后，使用提供的值运行电机
    ❺。
- en: This runs in a loop, so you can try inputting various speed and direction values
    to see the result. Since the `while` loop is placed inside a `try` block, pressing
    CTRL-C will throw an exception and exit from the test when you’re ready. Then,
    in the `finally` block ❻, you stop the motors and turn the laser off.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数运行在一个循环中，所以您可以尝试输入各种速度和方向值来查看结果。由于 `while` 循环位于 `try` 块内，按下 CTRL-C 将引发异常，并在您准备好时退出测试。然后，在
    `finally` 块 ❻ 中，您停止电机并关闭激光。
- en: '[Putting It All Together](nsp-venkitachalam503045-0008.xhtml#rbh1510)'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[整合一切](nsp-venkitachalam503045-0008.xhtml#rbh1510)'
- en: 'As usual, the `main()` function takes in command line arguments and sets the
    project in motion. Let’s look at the command line arguments first:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`main()` 函数接受命令行参数并启动项目。首先让我们看看命令行参数：
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here you follow the familiar pattern of creating an `ArgumentParser` object
    to parse command line arguments for the program ❶. The program will support three
    different command line arguments. The `--test_laser` option just turns the laser
    on and is useful when you’re building the motor and laser assembly. The `--test_motors`
    option is for testing the motors, and the `--wav_file` option lets you specify
    the WAV file to be read in for the laser audio display.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您遵循了创建`ArgumentParser`对象以解析程序命令行参数的常见模式 ❶。程序将支持三种不同的命令行参数。`--test_laser`选项仅打开激光，当您在组装电机和激光器时非常有用。`--test_motors`选项用于测试电机，`--wav_file`选项让您指定要读取的激光音频显示的WAV文件。
- en: 'Here’s the rest of the `main()` function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`main()`函数的其余部分：
- en: '[PRE15]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You call the `init_pins()` function you defined earlier to initialize the Raspberry
    Pi’s GPIO pins ❶. Next, you go through and process the command line arguments.
    If the user typed in the `--test_laser` argument, `args.test_laser` will be set
    to `True`. You handle this case by turning on the laser and waiting for the user
    to press CTRL-C to terminate the loop ❷. Similarly, you handle the `--test_motors`
    option by calling `test_motors()` ❸. To start the laser audio display, the user
    needs to use the `--wav_file` command line argument. In this case ❹, you call
    the `process_audio()` function. Once again, all this is embedded in a `try` block,
    so when the user presses CTRL-C, you break out of the loop for any of the three
    modes. To finish, you turn the laser off ❺ and do a GPIO cleanup ❻ before exiting
    the program.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您调用之前定义的`init_pins()`函数来初始化Raspberry Pi的GPIO引脚 ❶。接下来，您会处理命令行参数。如果用户输入了`--test_laser`参数，则`args.test_laser`会被设置为`True`。通过打开激光并等待用户按CTRL-C终止循环来处理这个情况
    ❷。类似地，通过调用`test_motors()`来处理`--test_motors`选项 ❸。要启动激光音频显示，用户需要使用`--wav_file`命令行参数。在这种情况下
    ❹，您调用`process_audio()`函数。同样，所有这些都嵌套在`try`块中，这样当用户按CTRL-C时，您可以在三种模式中的任何一种中跳出循环。最后，您关闭激光
    ❺，并在退出程序前进行GPIO清理 ❻。
- en: '[Running the Laser Display](nsp-venkitachalam503045-0008.xhtml#rah1504)'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行激光显示](nsp-venkitachalam503045-0008.xhtml#rah1504)'
- en: To test the project, assemble the hardware, make sure the battery pack is connected,
    and position everything so the laser is projecting onto a flat surface such as
    a wall. Then use SSH to log in to your Raspberry Pi as discussed in [Appendix
    B](nsp-venkitachalam503045-0032.xhtml#appb) and run the program from a shell.
    I recommend testing the laser display part first by running the program in test
    mode.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试该项目，请组装硬件，确保电池组已连接，并将所有设备摆放到位，使激光投射到平面表面（如墙壁）上。然后，使用SSH登录到您的Raspberry Pi，按照[附录B](nsp-venkitachalam503045-0032.xhtml#appb)中的讨论，通过终端运行程序。我建议首先通过以测试模式运行程序来测试激光显示部分。
- en: WARNING The project has high-speed spinning mirrors. Please wear appropriate
    eye protection or cover the setup with a transparent box before running the program
    to avoid injuries.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：该项目包含高速旋转的镜面。运行程序前，请佩戴适当的眼部保护装备，或用透明盒子覆盖设备，以避免受伤。
- en: 'Here’s a sample run of the test mode:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试模式的示例运行：
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can use this test to run both motors through various combinations of speeds
    and directions. You should see different laser patterns projected onto your wall
    as you change the values. To stop the program and the motors, press CTRL-C. Note
    that if you enter duty cycle (speed) values greater than 80, the motors will spin
    really fast. Be careful!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此测试通过不同的速度和方向组合来运行两个电机。当您更改值时，应该能看到不同的激光图案投射到墙上。要停止程序和电机，请按CTRL-C。注意，如果您输入大于80的占空比（速度）值，电机会旋转得非常快，请小心！
- en: 'If the test succeeds, you’re ready to move on to the real show. Copy a WAV
    file of your favorite music to the Raspberry Pi. Remember that to keep things
    simple, the program accepts only single-channel WAV files in 16-bit format. You
    can convert any audio file to this format using the free software Audacity. (A
    sample file is also available in the project’s GitHub repository.) When the audio
    file is in place, run the program as follows, substituting your desired filename
    after the `--wave_file` option:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试成功，您就可以开始进行正式的展示了。将您最喜欢的音乐WAV文件复制到Raspberry Pi中。请记住，为了保持简单，程序只接受16位格式的单声道WAV文件。您可以使用免费的Audacity软件将任何音频文件转换为这种格式。（项目的GitHub仓库中也有一个示例文件。）当音频文件准备好后，按如下方式运行程序，在`--wave_file`选项后替换为您想要的文件名：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should see the laser display produce lots of interesting patterns that change
    in time with the music, as shown in [Figure 13-14](nsp-venkitachalam503045-0028.xhtml#fig13-14).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到激光显示产生许多有趣的图案，并随着音乐的变化而变化，如[图 13-14](nsp-venkitachalam503045-0028.xhtml#fig13-14)所示。
- en: '![](images/nsp-venkitachalam503045-f13014.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13014.jpg)'
- en: 'Figure 13-14: The complete wiring of the laser display and a pattern projected
    on the wall'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-14：激光显示的完整接线和投影到墙上的图案
- en: Try experimenting with different WAV files, or with different calculations for
    converting the FFT information to motor settings, to see how the visualization
    responds.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的WAV文件，或者使用不同的计算方法将FFT信息转换为电机设置，看看可视化效果如何变化。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1505)'
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah1505)'
- en: In this chapter, you upped your Python and hardware skills by building a fairly
    complex project. You learned how to control motors with Python, a Raspberry Pi,
    and a motor driver. You used `numpy` to compute the FFT of audio data, and you
    used `pyaudio` to stream audio output in real time. You even learned to control
    a laser using a MOSFET!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过构建一个相当复杂的项目提高了你的Python和硬件技能。你学会了如何使用Python、Raspberry Pi和电机驱动器控制电机。你使用`numpy`计算音频数据的FFT，并使用`pyaudio`实时流式传输音频输出。你甚至学会了如何使用MOSFET控制激光！
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1506)'
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah1506)'
- en: 'Here are some ways you can modify this project:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些修改这个项目的方法：
- en: 1\. The program used an arbitrary scheme to convert the FFT values into motor
    speed and direction data. Try changing this scheme. For example, experiment with
    different frequency bands and criteria for changing motor directions.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 程序使用了一种任意方案将FFT值转换为电机速度和方向数据。尝试更改这个方案。例如，尝试不同的频带和改变电机方向的标准。
- en: '2\. In this project, you converted frequency information gathered from the
    audio signal into motor speed and direction settings. Try making the motors move
    according to the overall “pulse” or volume of the music instead. For this, you
    can compute the *root* *mean square (RMS)* value of the amplitude of the signal.
    This computation is similar to the FFT calculation. Once you read in a chunk of
    audio data and put it into a `numpy` array `x`, you can compute the RMS value
    as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 在这个项目中，你将从音频信号中收集的频率信息转换为电机速度和方向设置。尝试让电机根据音乐的整体“脉冲”或音量来移动。为此，你可以计算信号幅度的*均方根（RMS）*值。这个计算类似于FFT计算。读取一块音频数据并将其放入`numpy`数组`x`后，你可以按如下方式计算RMS值：
- en: '[PRE18]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also, remember that the amplitude in your project was expressed as a 16-bit
    signed integer, which can have a maximum value of 32,768 (a useful number to keep
    in mind for normalization). Use this RMS amplitude in conjunction with the FFT
    to generate a greater variation of laser patterns.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，请记住，你项目中的幅度是以16位有符号整数表示的，最大值为32,768（这是一个有用的归一化参考值）。使用这个RMS幅度值与FFT一起生成更多变化的激光图案。
- en: 3\. You know now that the frequency content, and hence the FFT of the audio
    data, changes in sync with the audio. Can you create a real-time visualization
    like the one shown in [Figure 13-15](nsp-venkitachalam503045-0028.xhtml#fig13-15),
    of both the audio data and the FFT as the audio plays through a speaker? This
    is intended to run on your computer, not your Raspberry Pi.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 你现在知道，频率内容，因此音频数据的FFT，会随着音频的同步变化。你能否创建一个实时可视化，如[图 13-15](nsp-venkitachalam503045-0028.xhtml#fig13-15)所示，同时展示音频数据和FFT，并在音频通过扬声器播放时实时显示？这应该在你的计算机上运行，而不是在Raspberry
    Pi上。
- en: '![](images/nsp-venkitachalam503045-f13015.jpg)'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f13015.jpg)'
- en: 'Figure 13-15: A real-time FFT visualization'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13-15：实时FFT可视化
- en: 'Here are a few hints to solve this problem:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是解决这个问题的一些提示：
- en: ◦ Use `matplotlib` for plotting.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ 使用`matplotlib`进行绘图。
- en: ◦ Use Python’s `multiprocessing` package so your music streaming output and
    plotting can happen simultaneously.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ 使用Python的`multiprocessing`包，以便你的音乐流式输出和绘图可以同时进行。
- en: ◦ Use the `numpy.fft.``rfftfreq()` method to get the frequencies corresponding
    to the FFT values, for ease of plotting.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ◦ 使用`numpy.fft.``rfftfreq()`方法获取对应FFT值的频率，便于绘图。
- en: (The solution code for this experiment is in the book’s GitHub repository, but
    give it a shot yourself first!)
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （这个实验的解决代码可以在书本的 GitHub 仓库中找到，但先自己试试看！）
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah1507)'
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah1507)'
- en: 'Here’s the complete Python code for this project:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该项目的完整Python代码：
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
