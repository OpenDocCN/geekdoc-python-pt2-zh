- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: DIFFERENTIAL CALCULUS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微分学**
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: 'The discovery of “the calculus” by Sir Issac Newton, and separately by Gottfried
    Wilhelm Leibniz, was one of the greatest achievements in the history of mathematics.
    Calculus is typically split into two main parts: differential and integral. Differential
    calculus talks about rates of change and their relationships, embodied in the
    notion of the derivative. Integral calculus is concerned with things like the
    area under a curve.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 艾萨克·牛顿爵士和戈特弗里德·威廉·莱布尼茨分别发现的“微积分”，是数学史上最伟大的成就之一。微积分通常分为两大部分：微分学和积分学。微分学讨论的是变化率及其关系，体现在导数的概念中。积分学则关注像曲线下面积之类的内容。
- en: We don’t need integral calculus for deep learning, but we’ll use differential
    calculus often. For example, we use differential calculus to train neural networks;
    we adjust the weights of a neural network using gradient descent, which relies
    on derivatives calculated via the backpropagation algorithm.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习不需要积分学，但我们会经常使用微分学。例如，我们用微分学来训练神经网络；我们使用梯度下降法调整神经网络的权重，而梯度下降法依赖于通过反向传播算法计算的导数。
- en: The derivative will be the star of this chapter. We’ll begin by introducing
    the idea of slope and seeing how it leads to the notion of a derivative. We’ll
    then formally define the derivative and learn how to calculate derivatives of
    functions of one variable. After that, we’ll learn how to use derivatives to find
    the minima and maxima of functions. Next come partial derivatives, the derivatives
    with respect to a single variable for functions of more than one variable. We’ll
    use partial derivatives extensively in the backpropagation algorithm. We’ll conclude
    with gradients, which will introduce us to matrix calculus, the subject of [Chapter
    8](ch08.xhtml#ch08).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 导数将成为本章的重点。我们将从引入斜率的概念开始，并看到它如何引出导数的概念。接下来，我们将正式定义导数，并学习如何计算单变量函数的导数。然后，我们将学习如何使用导数来找到函数的最小值和最大值。接下来是偏导数，针对多变量函数的单变量导数。我们将在反向传播算法中广泛使用偏导数。最后，我们将介绍梯度，这将引出矩阵微积分，这是[第
    8 章](ch08.xhtml#ch08)的内容。
- en: Slope
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 坡度
- en: In algebra class, we learned all about lines. One way to define a line is the
    slope-intercept form,
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在代数课上，我们学习了关于直线的所有知识。定义一条直线的一种方式是使用斜率-截距形式，
- en: '*y* = *mx* + *b*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = *mx* + *b*'
- en: 'where *m* is the slope and *b* is the *y* intercept, the place where the line
    crosses the y-axis. We’re interested in the slope. If we know two points on the
    line, (*x*[1], *y*[1]) and (*x*[0], *y*[0]), we know the slope of the line:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *m* 是斜率，*b* 是 *y* 截距，即直线与 y 轴交点的位置。我们关注的是斜率。如果我们知道直线上的两个点，(*x*[1], *y*[1])
    和 (*x*[0], *y*[0])，我们就能知道这条直线的斜率：
- en: '![Image](Images/164equ01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/164equ01.jpg)'
- en: The *slope* tells us how much of a change in *y* we will get for any given change
    in *x* position. If the slope is positive, then a positive change in *x* leads
    to a positive change in *y*. On the other hand, a negative slope means that a
    positive change in *x* leads to a negative change in *y*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*斜率* 告诉我们，*x* 位置的任何变化将导致 *y* 变化多少。如果斜率为正，则 *x* 的正向变化会导致 *y* 的正向变化。相反，负斜率意味着
    *x* 的正向变化会导致 *y* 的负向变化。'
- en: The slope-intercept form of the line tells us that the slope is the proportionality
    constant between *x* and *y*. The intercept, *b*, is a constant offset. This means
    a change in *x* position from *x*[1] to *x*[0] leads to an *m*(*x*[1] − *x*[0])
    change in *y*. Slopes relate two things, telling us how changing one affects the
    other. We’ll get back to this idea several times in the book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 直线的斜率-截距形式告诉我们，斜率是 *x* 和 *y* 之间的比例常数。截距 *b* 是一个常数偏移。这意味着，*x* 位置从 *x*[1] 变化到
    *x*[0] 会导致 *m*(*x*[1] − *x*[0]) 的 *y* 变化。斜率将两个事物联系在一起，告诉我们改变一个事物如何影响另一个事物。我们将在本书的多次内容中回到这个概念。
- en: Now, let’s visualize this with some examples. [Figure 7-1](ch07.xhtml#ch07fig01)
    shows the plot of a curve and some lines that intersect it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一些例子来可视化这一点。[图 7-1](ch07.xhtml#ch07fig01)展示了一个曲线和一些与之相交的直线。
- en: '![image](Images/07fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/07fig01.jpg)'
- en: '*Figure 7-1: A curve with a secant line (*A*) and a tangent line (*B*)*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：一条曲线与一条割线 (*A*) 和一条切线 (*B*)*'
- en: The line labeled *A* crosses the curve at two points, *x*[1] and *x*[0]. A line
    passing between two points on a curve is called a *secant* line. The other line,
    *B*, just touches the curve at the point *x**[t]*. Lines that touch a curve at
    one point are called *tangent* lines. We’ll get back to secant lines in the next
    section, but, for now, notice that the tangent line has a particular slope at
    *x**[t]* and that a secant line becomes a tangent line as the distance between
    the points *x*[1] and *x*[0] goes toward zero.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 *A* 的线在两个点 *x*[1] 和 *x*[0] 处与曲线相交。通过曲线上两个点的线叫做 *割线*。另一条线 *B* 仅在点 *x**[t]*
    处与曲线相切。与曲线仅相切的线叫做 *切线*。我们将在下一节回到割线的讨论，但现在请注意，切线在 *x**[t]* 处有一个特定的斜率，并且当点 *x*[1]
    和 *x*[0] 之间的距离趋向于零时，割线会变成切线。
- en: Imagine that we move the point *x**[t]* from place to place along the curve;
    we can see that the slope of the tangent line at *x**[t]* would change with it.
    As we approach the minimum point of the curve, near *x* = 0.3, we see that the
    slope becomes more and more shallow. If we approach from the left, the slope is
    negative and becomes less and less negative. If we approach from the right, the
    slope is positive but becomes smaller and smaller. At the actual minimum point,
    near *x* = 0.3, the tangent line is horizontal, with a slope of zero. Similarly,
    if we approach the maximum of the curve, near *x* = −0.8, the slope also approaches
    zero.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将点 *x**[t]* 从曲线的一点移动到另一点；我们可以看到，切线在 *x**[t]* 处的斜率会随之变化。当我们接近曲线的最小点，接近 *x*
    = 0.3 时，我们会看到斜率变得越来越平缓。如果从左边接近，斜率是负的，且变得越来越不负。如果从右边接近，斜率是正的，但变得越来越小。在实际的最小点，接近
    *x* = 0.3 时，切线是水平的，斜率为零。类似地，如果我们接近曲线的最大值，接近 *x* = −0.8，斜率也会接近零。
- en: We can see that the tangent line tells us how the curve is changing at a point.
    As we’ll see later in the chapter, the fact that the slope of a tangent line is
    zero at the minima and maxima of a curve points us toward a method for finding
    these points. The points where the slope of the tangent line is zero are known
    as *stationary points*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，切线告诉我们曲线在某一点的变化情况。正如我们将在本章后面看到的那样，切线斜率在曲线的最小值和最大值处为零，这为我们提供了一种找到这些点的方法。切线斜率为零的点被称为
    *驻点*。
- en: Of course, to take advantage of the slope of the tangent line, we need to be
    able to find its value for any *x* on the curve. The next section will show us
    how.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了利用切线的斜率，我们需要能够找到曲线上任何 *x* 点的切线斜率。下一节将向我们展示如何做到这一点。
- en: Derivatives
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导数
- en: The previous section introduced the idea of secant and tangent lines and hinted
    that knowing the slope of the tangent line at any point on a curve is a potentially
    useful thing. The slope of the tangent line at a point *x* is known as the *derivative*
    at *x*. It tells us how the curve (function) is changing at the point *x*, that
    is, how the function value changes with an infinitesimal change in *x*. In this
    section, we’ll formally define the derivative and learn shortcut rules for calculating
    derivatives of functions of a single variable, *x*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节介绍了割线和切线的概念，并暗示了在曲线的任何一点上知道切线的斜率是一个潜在有用的知识。切线在某一点 *x* 的斜率被称为该点的 *导数*。它告诉我们曲线（函数）在点
    *x* 处是如何变化的，也就是说，函数值如何随着 *x* 的微小变化而变化。在这一节中，我们将正式定义导数，并学习计算单变量函数 *x* 导数的快捷规则。
- en: A Formal Definition
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个正式的定义
- en: A typical first-semester calculus course introduces you to derivatives through
    studying limits. I mentioned above how the slope of the secant line between two
    points on a curve becomes a tangent line when the points collapse on top of each
    other, and that’s one place where limits come into play.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一门典型的第一学期微积分课程通过研究极限来介绍导数。我在上文中提到过，当曲线上两点之间的割线斜率随着两点重合而变成切线时，极限就发挥了作用。
- en: For example, if *y* = *f*(*x*) is a curve, and we have two points on the curve,
    *x*[0] and *x*[1], then the slope, Δ*y*/Δ*x*, between these points is
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 *y* = *f*(*x*) 是一条曲线，并且我们有曲线上的两点 *x*[0] 和 *x*[1]，那么这两点之间的斜率，Δ*y*/Δ*x*，是
- en: '![Image](Images/07equ01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ01.jpg)'
- en: This is the *rise over run* you may remember learning in school. The *rise*,
    *Δy* = *y*[1] − *y*[0] = *f*(*x*[1]) − *f*(*x*[0]), is divided by the *run*, Δ*x*
    = *x*[1] − *x*[0]. We typically use Δ as a prefix to mean the change in some variable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可能在学校里学过的 *升除以跑*。*升*，Δy = *y*[1] − *y*[0] = *f*(*x*[1]) − *f*(*x*[0])，除以
    *跑*，Δ*x* = *x*[1] − *x*[0]。我们通常使用Δ作为前缀，表示某个变量的变化。
- en: If we define *h* = *x*[1] − *x*[0], we can rewrite [Equation 7.1](ch07.xhtml#ch07equ01)
    as
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义 *h* = *x*[1] − *x*[0]，我们可以将 [方程 7.1](ch07.xhtml#ch07equ01) 重写为
- en: '![Image](Images/166equ01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/166equ01.jpg)'
- en: since *x*[1] = *x*[0] + *h*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *x*[1] = *x*[0] + *h*。
- en: In this new form, we can find the slope of the tangent line at *x*[0] by letting
    *h* get closer and closer to zero, *h* → 0\. Letting a value approach another
    value is a *limit*. Letting *h* → 0 moves the two points we’re calculating the
    slope between closer and closer. This leads directly to the definition of the
    derivative
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种新形式下，我们可以通过让 *h* 趋近于零，*h* → 0，来找到 *x*[0] 处切线的斜率。让一个值趋近于另一个值叫做 *极限*。让 *h*
    → 0 就是将我们计算斜率的两个点越来越接近。这直接引出了导数的定义。
- en: '![Image](Images/07equ02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ02.jpg)'
- en: where *dy*/*dx* or *f′*(*x*) is used to represent the derivative of *f*(*x*).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *dy*/*dx* 或 *f′*(*x*) 用于表示 *f*(*x*) 的导数。
- en: Before we get into what the derivative means, let’s take a minute to discuss
    notation. Using *f*′(*x*) for the derivative follows Joseph-Louis Lagrange. Leibniz
    used *dy*/*dx* to mirror the notation for slope with Δ → *d*. If Δ*y* is a change
    in *y* between two points, *dy* is the infinitesimal change in *y* at a single
    point. Newton used yet another notation, ![Image](Images/166equ02.jpg), with the
    dot representing the derivative of *f*. Physicists often use Newton’s notation
    for the specific case of derivatives with respect to time. For example, if *f*(*t*)
    is the position of a particle as a function of time, *t*, then ![Image](Images/166equ03.jpg)
    is the derivative with respect to *t*, that is, how the position is changing in
    time. How a position changes in time is the speed (velocity if using vectors).
    You’ll see all of these notations in books. My preference is to preserve ![Image](Images/166equ02.jpg)
    for functions of time and use Lagrange’s *f*′(*x*) and Leibniz’s *dy*/*dx* interchangeably
    elsewhere.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨导数的含义之前，先花一点时间讨论符号。使用 *f*′(*x*) 表示导数的方式源自 Joseph-Louis Lagrange。Leibniz
    使用 *dy*/*dx* 来模仿斜率符号，其中 Δ → *d*。如果 Δ*y* 表示两点间 *y* 的变化，那么 *dy* 表示在某一点 *y* 的无穷小变化。Newton
    使用了另一种符号，![Image](Images/166equ02.jpg)，其中点代表 *f* 的导数。物理学家通常在涉及时间导数的特定情况下使用 Newton
    的符号。例如，如果 *f*(*t*) 是一个粒子随时间 *t* 变化的位置，则 ![Image](Images/166equ03.jpg) 是关于 *t*
    的导数，也就是位置随时间变化的情况。位置随时间的变化就是速度（如果使用向量则是速度）。你将在书籍中看到所有这些符号。我的偏好是，对于时间函数，保留 ![Image](Images/166equ02.jpg)，而在其他地方则交替使用
    Lagrange 的 *f*′(*x*) 和 Leibniz 的 *dy*/*dx*。
- en: Although [Equation 7.2](ch07.xhtml#ch07equ02) above is quite tedious and the
    bane of many beginning calculus students, at least until they hit integration,
    you could work with it if you had to. However, we won’t discuss integration at
    all in this book, so you can take a deep breath and relax.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上面的 [方程 7.2](ch07.xhtml#ch07equ02) 非常繁琐，是许多初学微积分的学生的痛苦，至少直到他们遇到积分之前，你还是可以在需要时使用它。然而，在本书中我们不会讨论积分，所以你可以深呼吸，放松一下。
- en: 'After the struggle with limits, calculus students are let in on a secret: a
    small set of rules will allow you to calculate virtually all derivatives *without*
    using limits. We’ll start by introducing these rules, one at a time with examples,
    and then, at the end of this section, we’ll put them all together in a form suitable
    for a T-shirt.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了极限的艰难之后，微积分学生会得到一个秘密：一小组规则将使你能够*不使用*极限计算几乎所有的导数。我们将逐一介绍这些规则，并通过示例进行讲解，最后，在本节结束时，我们将把它们结合起来，形成适合印在
    T 恤上的形式。
- en: However, before we dive into the rules, let’s spend a little more time discussing
    *what* the derivative is telling us. Above, I mentioned that how a position changes
    in time is given by the derivative. This is true of all derivatives; they tell
    us how something is changing with respect to how something else is changing. We
    even see this in Leibniz’s notation, *dy*/*dx*, how *dy* changes for a change
    in *dx*. The derivative at *x* tells us how the function is changing at *x*. As
    we’ll see, the derivative of *f*(*x*) is itself a new function of *x*. If we pick
    a specific *x*[0], then we know that *f*(*x*[0]) is the value of the function
    at *x*[0].
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们深入了解规则之前，让我们再花一点时间讨论 *导数* 传达给我们的含义。如上所述，我提到过位置随时间的变化由导数给出。这对于所有的导数都是适用的；它们告诉我们某个事物如何随另一个事物的变化而变化。我们甚至可以从
    Leibniz 的符号 *dy*/*dx* 中看到这一点，即 *dy* 随 *dx* 的变化情况。*x* 处的导数告诉我们函数在 *x* 处如何变化。正如我们将看到的，*f*(*x*)
    的导数本身就是 *x* 的新函数。如果我们选择一个特定的 *x*[0]，那么我们就知道 *f*(*x*[0]) 是函数在 *x*[0] 处的值。
- en: 'Similarly, if we know the derivative, then *f*′(*x*[0]) is how quickly, and
    in which direction, the function, *f*(*x*), is changing at *x*[0]. Consider the
    definition of speed as how the position changes with time. We even say it in words:
    my current speed is 30 mph—*miles per hour*—a change in position with respect
    to a change in time.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果我们知道导数，那么 *f*′(*x*[0]) 就是函数 *f*(*x*) 在 *x*[0] 处变化的速度和方向。可以将速度定义为位置随时间变化的量。我们甚至可以用话语表达：我的当前速度是
    30 英里每小时（*miles per hour*）——即位置相对于时间变化的速度。
- en: We’ll use derivatives like rates and see how changing one thing affects another.
    In the end, for deep learning, we want to know how changing the value of a parameter
    in a network will ultimately change the loss function, the error between what
    the network should have output and what it actually output.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用导数来表示速率，并观察改变一件事如何影响另一件事。最终，对于深度学习，我们希望了解改变网络中某个参数的值将如何最终改变损失函数，即网络实际输出与预期输出之间的误差。
- en: If *f*′(*x*) is a function of *x*, then we should be able to take the derivative
    of it. We call *f*′(*x*) the *first derivative*. Its derivative, which we denote
    as *f*′′(*x*), is the *second derivative*. In Leibniz’s notation, we write *d*²*y*/*dx*².
    The second derivative tells us how the first derivative is changing with respect
    to *x*. Physics helps here. The first derivative of the position as a function
    of time (*f*) is the *velocity*, ![Image](Images/167equ01.jpg)—how the position
    is changing with time. Therefore, the second derivative of the position, ![Image](Images/167equ02.jpg),
    which is the first derivative of the velocity, is how the velocity is changing
    with time. We call this the *acceleration*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *f*′(*x*) 是 *x* 的函数，那么我们应该能够对其进行微分。我们称 *f*′(*x*) 为 *一阶导数*。它的导数，记作 *f*′′(*x*)，就是
    *二阶导数*。在莱布尼茨符号中，我们写作 *d*²*y*/*dx*²。二阶导数告诉我们一阶导数如何随 *x* 变化。物理学在这里有所帮助。位置相对于时间的导数
    (*f*) 是 *速度*，![Image](Images/167equ01.jpg)——即位置随时间变化的速率。因此，位置的二阶导数，![Image](Images/167equ02.jpg)，是速度的一阶导数，表示速度随时间的变化。我们称之为
    *加速度*。
- en: In theory, there is no end to how many derivatives we can calculate. In reality,
    many functions ultimately end up with a derivative that is a constant value. Since
    a constant value doesn’t change, its derivative is zero.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，我们可以计算任意多的导数。而在实际中，许多函数最终会有一个常数值的导数。由于常数值不发生变化，因此它的导数为零。
- en: To sum up, the derivative of *f*(*x*) is another function, *f*′(*x*) or *dy*/*dx*,
    that tells us the slope of the line tangent to *f*(*x*) at every point. And, since
    *f*′(*x*) is a function of *x*, it also has a derivative, *f*′′(*x*) or *d*²*y*/*dx*²,
    the second derivative, telling us how *f*′(*x*) changes at each *x*, and so on.
    We’ll see below how to make use of first and second derivatives. For now, let’s
    learn the rules of *differentiation*, the act of calculating a derivative.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，*f*(*x*) 的导数是另一个函数，*f*′(*x*) 或 *dy*/*dx*，它告诉我们 *f*(*x*) 在每个点处的切线斜率。并且，由于
    *f*′(*x*) 是 *x* 的函数，它也有导数，即 *f*′′(*x*) 或 *d*²*y*/*dx*²，二阶导数，告诉我们 *f*′(*x*) 在每个
    *x* 处如何变化，依此类推。接下来我们将看到如何利用一阶和二阶导数。现在，让我们学习 *微分* 的规则，即计算导数的过程。
- en: Basic Rules
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基本规则
- en: 'We mentioned one rule in the previous section: that the derivative of a constant,
    *c*, is zero. So, we write'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们提到了一条规则：常数 *c* 的导数是零。所以我们写作
- en: '![Image](Images/167equ03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/167equ03.jpg)'
- en: 'where we’re using Leibniz’s notation in operator form: *d*/*dx*. Think of *d*/*dx*
    as something operating on what follows; it does this the same way that negation
    does: to negate *c*, we write *−c*; to differentiate *c*, we write ![Image](Images/167equ04.jpg).
    If our expression has no *x*, then we will treat it as a constant, and the derivative
    will be zero.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用了莱布尼茨符号表示法：*d*/*dx*。可以将 *d*/*dx* 看作是作用于后面的内容，它的作用方式类似于否定：要否定 *c*，我们写作
    *−c*；要对 *c* 进行微分，我们写作 ![Image](Images/167equ04.jpg)。如果我们的表达式中没有 *x*，我们就将其视为常数，其导数为零。
- en: The Power Rule
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 幂法则
- en: The derivative of a power of *x* uses the *power rule*,
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个幂函数的导数遵循 *幂法则*，
- en: '![Image](Images/168equ01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/168equ01.jpg)'
- en: 'where *a* is a constant and *n* is an exponent that doesn’t need to be an integer.
    Let’s see some examples:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *a* 是常数，*n* 是一个指数，且不需要是整数。让我们看一些例子：
- en: '![Image](Images/168equ02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/168equ02.jpg)'
- en: We often build algebraic expressions out of terms that are added and subtracted.
    Differentiation is a linear operator, so we can write
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常常将代数表达式构建为加减法项。微分是一个线性运算符，因此我们可以写作
- en: '![Image](Images/168equ03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/168equ03.jpg)'
- en: 'This means we calculate derivatives term by term. For example, with the set
    of rules we have so far, we now know how to calculate the derivative of a polynomial:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们逐项计算导数。例如，利用到目前为止我们掌握的规则，我们现在知道如何计算多项式的导数：
- en: '![Image](Images/168equ04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/168equ04.jpg)'
- en: In general, then,
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，公式是：
- en: '![Image](Images/169equ01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/169equ01.jpg)'
- en: where we see that the derivative of a polynomial of degree *n* is another polynomial
    of degree *n* − 1 and that any constant term in the original polynomial drops
    to zero.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到，阶数为 *n* 的多项式的导数是另一个阶数为 *n* − 1 的多项式，且原多项式中的常数项将变为零。
- en: The Product Rule
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 乘积法则
- en: 'Differentiation of functions multiplied together has its own rule, the *product
    rule*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 函数相乘的求导有其独特的规则，即*乘积法则*：
- en: '![Image](Images/169equ02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/169equ02.jpg)'
- en: 'The derivative of the product is the derivative of the first function times
    the second plus the derivative of the second times the first. Consider the following
    examples:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 乘积的导数是第一个函数的导数乘以第二个函数加上第二个函数的导数乘以第一个函数。考虑以下例子：
- en: '![Image](Images/169equ03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/169equ03.jpg)'
- en: The Quotient Rule
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 商法则
- en: 'The derivative of a function divided by another function follows the *quotient
    rule*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数除以另一个函数的导数遵循*商法则*：
- en: '![Image](Images/169equ04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/169equ04.jpg)'
- en: 'This leads to examples like these:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了像这样的例子：
- en: '![Image](Images/170equ01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/170equ01.jpg)'
- en: The Chain Rule
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 链式法则
- en: The next rule concerns the composition of functions. Two functions are composed
    when the output of one is used as the input to another. The *chain rule* applies
    to function compositions, and it’s of fundamental importance in the training of
    neural networks. The rule is
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个规则涉及函数的合成。当一个函数的输出作为另一个函数的输入时，就形成了函数的合成。*链式法则*适用于函数合成，并且在神经网络的训练中具有基础性的重要性。该规则是：
- en: '![Image](Images/170equ02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/170equ02.jpg)'
- en: We multiply the derivative of the outer function, using *g*(*x*) as the variable,
    by the derivative of the inner function with respect to *x*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将外部函数的导数（使用 *g*(*x*) 作为变量）乘以内层函数相对于 *x* 的导数。
- en: 'As a first example, consider the function *f*(*x*) = (*x*² + 2*x* + 3)². Is
    this the composition of two functions? It is. Let’s define *f*(*g*) = *g*² and
    *g*(*x*) = *x*² + 2*x* + 3\. Then, we can find *f*(*x*) by replacing every instance
    of *g* in *f*(*g*) with the definition of *g* in terms of *x*: *g*(*x*) = *x*²
    + 2*x* + 3\. This gives'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，考虑函数 *f*(*x*) = (*x*² + 2*x* + 3)²。 这是两个函数的合成吗？是的。我们可以定义 *f*(*g*) =
    *g*² 和 *g*(*x*) = *x*² + 2*x* + 3。然后，我们可以通过将 *f*(*g*) 中的每个 *g* 替换为 *g* 在 *x* 下的定义，来找到
    *f*(*x*)：*g*(*x*) = *x*² + 2*x* + 3。这样就得到了：
- en: '*f*(*x*) = *g*² = (*x*² + 2*x* + 3)²'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*) = *g*² = (*x*² + 2*x* + 3)²'
- en: which is, naturally, what we started with. To find *f*′(*x*), we first find
    *f*′(*g*), the derivative of *f* with respect to *g*, and then multiply by *g*′(*x*),
    the derivative of *g* with respect to *x*. As a final step, we replace references
    to *g* with its definition in terms of *x*. So, we calculate *f*′(*x*) as
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这自然就是我们最初的公式。为了找到 *f*′(*x*)，我们首先找到 *f*′(*g*)，即 *f* 对 *g* 的导数，然后乘以 *g*′(*x*)，即
    *g* 对 *x* 的导数。最后一步是将所有 *g* 替换为其在 *x* 下的定义。因此，我们计算 *f*′(*x*) 得到：
- en: '![Image](Images/170equ03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/170equ03.jpg)'
- en: We typically don’t explicitly call out *f*(*g*) and *g*(*x*), but mentally we
    work through the same process. Let’s see some more examples. In this one, we want
    to find
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不会明确写出 *f*(*g*) 和 *g*(*x*)，但在心里我们会按照相同的过程进行推导。让我们再看一些例子。在这个例子中，我们想要找到：
- en: '![Image](Images/171equ01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/171equ01.jpg)'
- en: If we use the chain rule, we see that we have *f*(*g*) = 2*g*² + 3 and *g*(*x*)
    = 4*x* − 5\. Therefore, we can write
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用链式法则，我们可以看到 *f*(*g*) = 2*g*² + 3 且 *g*(*x*) = 4*x* − 5。 因此，我们可以写成：
- en: '![Image](Images/171equ02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/171equ02.jpg)'
- en: where *f*′(*g*) = 2*g* and *g*′(*x*) = 4\. With some practice, we’d mentally
    picture the 4*x* − 5 of *f*(*x*) as its own variable (the substitution of *g*)
    and then remember to multiply the derivative of 4*x* − 5 when done. What if we
    didn’t see the composition? What if we expanded the entire function, *f*(*x*),
    and then took the derivative? We’d better get the answer we found above by using
    the chain rule. Let’s see . . .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *f*′(*g*) = 2*g* 且 *g*′(*x*) = 4。通过一些练习，我们会在心里将 *f*(*x*) 中的 4*x* − 5 看作是自己的变量（即
    *g* 的替代），并且记得在求导时乘上 4*x* − 5 的导数。如果我们没有看到合成呢？如果我们展开整个函数 *f*(*x*)，然后再求导呢？我们最好能得到使用链式法则时得到的答案。我们来看看……
- en: '![Image](Images/171equ03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/171equ03.jpg)'
- en: This is what we found above, so our application of the chain rule is correct.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前找到的结果，因此我们应用链式法则是正确的。
- en: Let’s look at another example. If ![Image](Images/171equ04.jpg), how should
    we think of calculating the derivative? If we look at the function as ![Image](Images/171equ05.jpg),
    with *u*(*x*) = 1 and *v*(*x*) = 3*x*², we can use the quotient rule and get the
    following.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。如果 ![图片](Images/171equ04.jpg)，我们应该如何考虑计算导数呢？如果我们把函数看作 ![图片](Images/171equ05.jpg)，其中
    *u*(*x*) = 1 和 *v*(*x*) = 3*x*²，我们可以使用商法则，得到如下结果。
- en: '![Image](Images/172equ01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/172equ01.jpg)'
- en: Here, we used a shorthand notation with *u* and *v* that drops the formal function
    of *x* notation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 *u* 和 *v* 的简写符号，省略了 *x* 的正式函数符号。
- en: We can also picture *f*(*x*) as (3*x*²)^(−1). If we think of it this way, we
    can apply the chain rule and power rule to get
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将 *f*(*x*) 想象为 (3*x*²)^(−1)。如果我们这样思考，我们可以应用链式法则和幂法则得到
- en: '![Image](Images/172equ02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/172equ02.jpg)'
- en: proving that sometimes there’s more than one way to calculate a derivative.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 证明了有时计算导数有不止一种方法。
- en: We presented the chain rule using Lagrange’s notation. Later in the chapter,
    we’ll see it again using Leibniz’s notation. Let’s move on now and present a set
    of rules for trigonometric functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用拉格朗日符号介绍了链式法则。稍后在本章中，我们将看到使用莱布尼茨符号的版本。现在让我们继续介绍一组三角函数的规则。
- en: Rules for Trigonometric Functions
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 三角函数规则
- en: 'The derivatives of the basic trigonometric functions are straightforward:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基本三角函数的导数是直接的：
- en: '![Image](Images/172equ03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/172equ03.jpg)'
- en: 'We can see the last rule is correct if we apply the basic differentiation rules
    to the definition of the tangent:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将基本的求导规则应用于切线的定义，可以看出最后一条规则是正确的：
- en: '![Image](Images/173equ01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/173equ01.jpg)'
- en: Remember that sec *x* = 1/ cos *x* and sin² *x* + cos² *x* = 1.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，sec *x* = 1/ cos *x* 且 sin² *x* + cos² *x* = 1。
- en: 'Let’s look at some examples using the new trig rules. We’ll start with one
    composing a function with a trig function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些例子来使用新的三角函数规则。我们从一个包含三角函数的复合函数开始：
- en: '![Image](Images/173equ02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/173equ02.jpg)'
- en: We can see that this is a composition of *f*(*g*) = sin(*g*) and *g*(*x*) =
    *x*³ − 3*x*, so we know we can apply the chain rule to get the derivative as *f*′(*g*)*g*′(*x*)
    with *f*′(*g*) = cos(*g*) and *g*′(*x*) = 3*x*² − 3\. The second line simplifies
    the answer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这是一个复合函数 *f*(*g*) = sin(*g*) 和 *g*(*x*) = *x*³ − 3*x*，因此我们知道可以应用链式法则得到导数，即
    *f*′(*g*)*g*′(*x*)，其中 *f*′(*g*) = cos(*g*) 和 *g*′(*x*) = 3*x*² − 3。第二行简化了答案。
- en: 'Let’s look at a more complicated composition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更复杂的复合函数：
- en: '![Image](Images/173equ03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/173equ03.jpg)'
- en: This time, we break up the composition as *f*(*g*) = *g*² and *g*(*x*) = sin(*x*³
    − 3*x*). However, *g*(*x*) is itself a composition of *g*(*u*) = sin(*u*) and
    *u*(*x*) = *x*³ − 3*x*, as we had in the previous example. So, the first step
    is to write the following.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将复合函数分解为 *f*(*g*) = *g*² 和 *g*(*x*) = sin(*x*³ − 3*x*)。然而，*g*(*x*) 本身是
    *g*(*u*) = sin(*u*) 和 *u*(*x*) = *x*³ − 3*x* 的复合函数，正如我们在前一个例子中所做的那样。所以，第一步是写出如下内容。
- en: '![Image](Images/174equ01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/174equ01.jpg)'
- en: The first line is the definition of the derivative of a composition. The second
    line substitutes the derivative of *f*(*g*), which is *2g*, and the third line
    replaces *g*(*x*) with sin(*x*³ − 3*x*). Now, we just need to find *g*′(*x*),
    which we can do by using the chain rule a second time with *g*(*u*) = sin *u*
    and *u*(*x*) = *x*³ − 3*x*, as we did for the example above. Doing this gives
    us *g*′(*x*) = cos(*x*³ − 3*x*)(3*x*² − 3), so now we know that *f*′(*x*) is
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是复合函数导数的定义。第二行代入了 *f*(*g*) 的导数，即 *2g*，第三行将 *g*(*x*) 替换为 sin(*x*³ − 3*x*)。现在，我们只需要找到
    *g*′(*x*)，我们可以通过第二次应用链式法则来做到这一点，令 *g*(*u*) = sin *u* 和 *u*(*x*) = *x*³ − 3*x*，正如上面的例子所示。这样我们得到
    *g*′(*x*) = cos(*x*³ − 3*x*)(3*x*² − 3)，所以现在我们知道 *f*′(*x*) 是
- en: '![Image](Images/174equ02.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/174equ02.jpg)'
- en: Let’s do one more example. This one will involve more than one trig function.
    We want to see how to calculate
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 再做一个例子。这次涉及多个三角函数。我们想看看如何计算
- en: '![Image](Images/174equ03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/174equ03.jpg)'
- en: 'As is often the case when working with trig functions, identities come into
    play. Here, we see that *f*(*x*) can be rewritten:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在处理三角函数时常见的那样，恒等式发挥了作用。在这里，我们看到 *f*(*x*) 可以重写为：
- en: '![Image](Images/174equ04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/174equ04.jpg)'
- en: Now the derivative uses the trig rules, the definition of the secant, the chain
    rule, and the product rule, as shown next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导数使用了三角函数规则、割线的定义、链式法则和乘积法则，如下所示。
- en: '![Image](Images/175equ01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/175equ01.jpg)'
- en: Let’s move on and look at derivatives of exponentials and logarithms.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看指数和对数的导数。
- en: Rules for Exponentials and Logarithms
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指数和对数法则
- en: 'The derivative of *e**^x*, where *e* is the base of the natural logarithm (*e*
    ≈ 2.718 . . .), is particularly simple. It is itself:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*e**^x* 的导数，其中 *e* 是自然对数的底数（*e* ≈ 2.718…），特别简单。它就是它本身：'
- en: '![Image](Images/175equ02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/175equ02.jpg)'
- en: When the argument is a function of *x*, this becomes
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当自变量是 *x* 的函数时，这变为
- en: '![Image](Images/07equ03.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ03.jpg)'
- en: If the derivative of *e^x* is *e^x*, what is the derivative of *a^x* when *a*
    is a real number other than *e*? To see the answer, we need to remember that *e^x*
    and ln *x*, the natural logarithm using base *e*, are inverse functions, so *e*^(ln*a*)
    = *a*. Then, we can write
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *e^x* 的导数是 *e^x*，那么当 *a* 是除 *e* 外的实数时，*a^x* 的导数是什么？为了看答案，我们需要记住，*e^x* 和 ln
    *x*（以 *e* 为底的自然对数）是反函数，所以 *e*^(ln*a*) = *a*。然后，我们可以写成
- en: '*a^x* = (*e*^(ln *a*))^(*x*) = *e^x*^(ln *a*)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*a^x* = (*e*^(ln *a*))^(*x*) = *e^x*^(ln *a*)'
- en: We know how to find the derivative of *e^x*^(ln*a*) from [Equation 7.3](ch07.xhtml#ch07equ03)
    above. It is
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何从上面的 [方程 7.3](ch07.xhtml#ch07equ03) 找到 *e^x*^(ln*a*) 的导数。它是
- en: '![Image](Images/175equ03.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/175equ03.jpg)'
- en: but *e x* ln *a* = *a^x*, so we have
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但 *e x* ln *a* = *a^x*，所以我们有
- en: '![Image](Images/175equ04.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/175equ04.jpg)'
- en: and, in general,
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，
- en: '![Image](Images/07equ04.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ04.jpg)'
- en: Notice, if *a* = *e*, we have ln(*e*) = 1, and [Equation 7.4](ch07.xhtml#ch07equ04)
    becomes [Equation 7.3](ch07.xhtml#ch07equ03).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果 *a* = *e*，我们有 ln(*e*) = 1，并且 [方程 7.4](ch07.xhtml#ch07equ04) 变成 [方程 7.3](ch07.xhtml#ch07equ03)。
- en: Let’s look now at the derivative of the natural log itself. It is
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下自然对数本身的导数。它是
- en: '![Image](Images/176equ01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/176equ01.jpg)'
- en: When the argument is a function of *x*, this becomes
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当自变量是 *x* 的函数时，这变为
- en: '![Image](Images/07equ05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ05.jpg)'
- en: 'You may be wondering: How do we find the derivative of a logarithm that uses
    a base other than *e*? For example, what is the derivative of log[10] *x*? To
    answer this question, we do something similar to what we did above for the derivative
    of *a**^x*. We write the logarithm of *x* for some base, *b*, in terms of the
    natural log, as'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：如何找到使用非 *e* 为底的对数的导数？例如，log[10] *x* 的导数是什么？为了回答这个问题，我们做一些类似于我们之前对 *a**^x*
    的导数所做的事情。我们把以某个底数 *b* 的对数写成自然对数的形式，如下：
- en: '![Image](Images/176equ02.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/176equ02.jpg)'
- en: Here, ln *b* is a constant that does not depend on *x*. Also, we now know how
    to find the derivative of ln *x*, so we see that the derivative of log*[b] x*
    must be
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，ln *b* 是一个常数，不依赖于 *x*。此外，我们现在知道如何找到 ln *x* 的导数，因此我们可以看到，log*[b] x* 的导数必须是
- en: '![Image](Images/176equ03.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/176equ03.jpg)'
- en: for any real number base *b* ≠ 1\. And, still more generally,
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何实数底数 *b* ≠ 1。并且，更一般地，
- en: '![Image](Images/07equ06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ06.jpg)'
- en: where, again, we notice that if *b* = *e*, we get ln *e* = 1, and [Equation
    7.6](ch07.xhtml#ch07equ06) becomes [Equation 7.5](ch07.xhtml#ch07equ05).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次注意到，如果 *b* = *e*，则得到 ln *e* = 1，并且 [方程 7.6](ch07.xhtml#ch07equ06) 变成了
    [方程 7.5](ch07.xhtml#ch07equ05)。
- en: With [Equation 7.6](ch07.xhtml#ch07equ06), we’ve reached the end of our rules
    for derivatives. Let’s now put them together in a single table we can refer back
    to throughout the remainder of the book. The result is [Table 7-1](ch07.xhtml#ch07tab01).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [方程 7.6](ch07.xhtml#ch07equ06)，我们已经完成了导数法则的总结。现在，让我们把它们合并成一个表格，供我们在书的其余部分中参考。结果是
    [表 7-1](ch07.xhtml#ch07tab01)。
- en: We know how to find derivatives now. I would encourage you to look for practice
    sheets with worked-out answers to convince yourself that you understand the rules
    and how to apply them. Let’s move on and look at how we can use derivatives to
    find the minima and maxima of functions. Finding minima is critical to the training
    of neural networks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何找到导数了。我鼓励你去找一些带有解答的练习题，以确保自己理解了这些法则以及如何应用它们。接下来，让我们继续看如何使用导数来寻找函数的最小值和最大值。寻找最小值对神经网络的训练至关重要。
- en: '**Table 7-1:** The Rules of Differentiation'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** 导数法则'
- en: '| **Type** | **Rule** |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **法则** |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Constants | ![Image](Images/177equ01.jpg) |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 常数 | ![Image](Images/177equ01.jpg) |'
- en: '| Powers | ![Image](Images/177equ02.jpg) |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 幂 | ![Image](Images/177equ02.jpg) |'
- en: '| Sums | ![Image](Images/177equ03.jpg) |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 和 | ![Image](Images/177equ03.jpg) |'
- en: '| Products | ![Image](Images/177equ04.jpg) |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 积 | ![Image](Images/177equ04.jpg) |'
- en: '| Quotients | ![Image](Images/177equ05.jpg) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 商 | ![Image](Images/177equ05.jpg) |'
- en: '| Chain | ![Image](Images/177equ06.jpg) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 链式法则 | ![Image](Images/177equ06.jpg) |'
- en: '| Trigonometry | ![Image](Images/177equ07.jpg) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 三角学 | ![Image](Images/177equ07.jpg) |'
- en: '| Exponents | ![Image](Images/177equ08.jpg) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 指数 | ![Image](Images/177equ08.jpg) |'
- en: '| Logarithms | ![Image](Images/177equ09.jpg) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 对数 | ![Image](Images/177equ09.jpg) |'
- en: Minima and Maxima of Functions
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数的最小值和最大值
- en: Earlier, I defined stationary points as places where the first derivative of
    a function is zero, that is, places where the slope of the tangent line is zero.
    We can use this information to decide if a particular point, call it *x[m]*, is
    a minimum or maximum of the function, *f*(*x*). If *x[m]* is a minimum, it is
    a low point of the function, where *f*(*x[m]*) is smaller than any point to the
    immediate left or right of *f (x[m]*). Similarly, if *f*(*x[m]*) is higher than
    any point to the immediate left or right, *f*(*x[m]*) is a maximum. We collectively
    refer to minima and maxima as *extrema* of *f*(*x*) (singular, *extremum*).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我定义了驻点是指函数的一阶导数为零的地方，也就是切线的斜率为零的地方。我们可以利用这些信息来判断一个特定点，假设它是 *x[m]*，是否是函数 *f*(*x*)
    的最小值或最大值。如果 *x[m]* 是最小值，那么它是函数的一个低点，其中 *f*(*x[m]*) 小于 *f*(*x*) 左右相邻点的值。类似地，如果
    *f*(*x[m]*) 大于左右相邻点的值，那么 *f*(*x[m]*) 是一个最大值。我们通常将最小值和最大值统称为 *f*(*x*) 的 *极值*（单数形式为
    *极值点*）。
- en: 'In terms of the derivative, a *minimum* is a place where the derivative of
    points immediately to the left of *x[m]* are negative, and derivatives of points
    directly to the right of *x[m]* are positive. *Maxima* are the reverse: derivatives
    to the left are positive, and derivatives to the right of *x[m]* are negative.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在导数的角度来看，*最小值*是指在 *x[m]* 左边的点的导数为负，而 *x[m]* 右边的点的导数为正的地方。*最大值*则相反：左边的导数为正，右边的导数为负。
- en: Look back at [Figure 7-1](ch07.xhtml#ch07fig01). There, we have a local maximum
    at about *x* = −0.8 and a local minimum at about *x* = 0.3\. Let’s say that the
    maximum is actually at *x[m]* = −0.8\. This is a maximum because if we look at
    any point *x[p]* in the vicinity of *x[m]*, *f*(*x[p]*) is less than *f*(*x[m]*).
    Likewise, if the minimum is at *x[m]* = 0.3, that’s because any point *x[p]* near
    it has *f*(*x[p]*) > *f*(*x[m]*). If we imagine the tangent line sliding along
    the graph, as it approaches *x* = −0.8, we see that the slope is positive but
    heading toward zero. If we move past *x* = −0.8, the slope is now negative. The
    reverse is true for the minimum at *x* = 0.3\. Tangent lines approaching from
    the left have negative slope, but once they’re past *x* = 0.3, the slope is positive.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [图 7-1](ch07.xhtml#ch07fig01)。在图中，我们有一个局部最大值大约在 *x* = −0.8 处，局部最小值大约在 *x*
    = 0.3 处。假设最大值实际上出现在 *x[m]* = −0.8 处。这是一个最大值，因为如果我们查看 *x[m]* 附近的任何点 *x[p]*，*f*(*x[p]*)
    都小于 *f*(*x[m]*)。同样，如果最小值出现在 *x[m]* = 0.3 处，那是因为其附近的任何点 *x[p]* 都有 *f*(*x[p]*) >
    *f*(*x[m]*)。如果我们想象切线沿着图像滑动，当它接近 *x* = −0.8 时，我们会看到斜率是正的，但正在趋向零。当我们越过 *x* = −0.8
    时，斜率变为负数。对于 *x* = 0.3 处的最小值，情况则相反。从左边接近的切线斜率为负，但一旦超过 *x* = 0.3，斜率变为正。
- en: You’ll read and hear the terms *global* and *local* applied to minima and maxima.
    The global minimum of *f*(*x*) is the lowest of all the minima of *f*(*x*), and
    the global maximum is the highest of all the maxima. Other minima and maxima,
    then, are considered local; they are effective over a particular region, but there
    are other minima that are lower or maxima that are higher. We should note that
    not all functions have minima or maxima. For example, a line, *f*(*x*) = *mx*
    + *b*, has no minima or maxima, because there are no points on the line that satisfy
    the requirements for either.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到并听到“*全局*”和“*局部*”这两个术语被应用于最小值和最大值。*f*(*x*) 的全局最小值是所有最小值中的最小值，而全局最大值是所有最大值中的最大值。其他的最小值和最大值则被视为局部的；它们仅在特定区域内有效，但还有其他更低的最小值或更高的最大值。我们需要注意的是，并非所有函数都有最小值或最大值。例如，直线
    *f*(*x*) = *mx* + *b* 没有最小值或最大值，因为直线上的任何点都不符合最小值或最大值的要求。
- en: So, if the first derivative, *f*′(*x*), is zero, we have a minimum or maximum,
    right? Not so fast. At other stationary points, the first derivative may be zero,
    but the remaining criteria for a minimum or maximum are not met. These points
    are often called *inflection points* or, if in multiple dimensions, *saddle points*.
    For example, consider *y* = *x*³. The first derivative is *y*′ = 3*x*², and the
    second derivative is *y*′′ = 6*x*. Both the first and second derivative are zero
    at *x* = 0\. However, as we can see in [Figure 7-2](ch07.xhtml#ch07fig02), the
    slope is positive to both the immediate left and immediate right of *x* = 0\.
    Therefore, the slope never switches from positive to negative or negative to positive,
    meaning *x* = 0 is not an extremum but is an inflection point.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果一阶导数 *f*′(*x*) 为零，我们是不是就得到了一个最小值或最大值呢？别急。在其他驻点处，一阶导数可能为零，但满足最小值或最大值的剩余条件并未满足。这些点通常被称为
    *拐点*，如果是多维的，则称为 *鞍点*。例如，考虑 *y* = *x*³。其一阶导数为 *y*′ = 3*x*²，二阶导数为 *y*′′ = 6*x*。在
    *x* = 0 处，一阶和二阶导数均为零。然而，正如我们在[图 7-2](ch07.xhtml#ch07fig02)中看到的，*x* = 0 处左右两侧的坡度都是正的。因此，坡度不会从正变负或从负变正，这意味着
    *x* = 0 不是极值点，而是一个拐点。
- en: '![image](Images/07fig02.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/07fig02.jpg)'
- en: '*Figure 7-2: A graph of y = x³ showing an inflection point at x = 0*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：y = x³ 的图像，显示在 x = 0 处的拐点*'
- en: Now assume that *x[s]* is a stationary point so that *f*′(*x[s]*) = 0\. If we
    pick two other points, *x[s−∊]* and *x[s+∊]*, one just to the left of *x[s]* and
    the other just to the right, for some very small ∊ (epsilon), we have four possibilities
    for the values of *f*′(*x[s]*[−∊]) and *f*′(*x[s]*[+∊]), shown in [Table 7-2](ch07.xhtml#ch07tab02).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设 *x[s]* 是一个驻点，因此 *f*′(*x[s]*) = 0。如果我们选择两个其他点，*x[s−∊]* 和 *x[s+∊]*，一个位于 *x[s]*
    左侧，另一个位于右侧，且 ∊（epsilon）非常小，我们有四种 *f*′(*x[s]*[−∊]) 和 *f*′(*x[s]*[+∊]) 的可能值，如[表
    7-2](ch07.xhtml#ch07tab02)所示。
- en: '**Table 7-2:** Identifying Stationary Points'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-2：识别驻点**'
- en: '| **Sign of *f’*(*x[s]* – ∊), *f’*(*x[s]* + ∊)** | **Type of stationary point
    at *x[s]* – ∊ < *x[s]* < *x[s]* + ∊** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **f′(*x[s]* – ∊), f′(*x[s]* + ∊) 的符号** | **驻点 *x[s]* 类型 – ∊ < *x[s]* < *x[s]*
    + ∊** |'
- en: '| --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| +, – | Maximum |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| +, – | 最大值 |'
- en: '| –, + | Minimum |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| –, + | 最小值 |'
- en: '| +, + | Neither |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| +, + | 既不是 |'
- en: '| –, – | Neither |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| –, – | 既不是 |'
- en: Therefore, the value of the first derivative at a candidate stationary point
    isn’t enough to tell us whether the point represents a minimum or maximum. We
    can look at the region around the candidate point to help us decide. We can also
    look at the value of *f*′′(*x*), the second derivative of *f*(*x*). If *x[s]*
    is a stationary point where *f*′(*x[s]*) = 0, the sign of *f*′′(*x[s]*) can tell
    us about what type of stationary point *x[s]* might be. If *f*′′(*x[s]*) < 0,
    then *x[s]* is a *maximum* of *f*(*x*). If *f*′′(*x[s]*) > 0, *x[s]* is a minimum.
    If *f*′′(*x[s]*) = 0, the second derivative isn’t helpful; we will need to explicitly
    test nearby points with the first derivative.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，候选驻点处的一阶导数值不足以告诉我们该点是极小值还是极大值。我们可以查看候选点周围的区域来帮助我们做出判断。我们还可以查看 *f*′′(*x*)，即
    *f*(*x*) 的二阶导数的值。如果 *x[s]* 是一个驻点，且 *f*′(*x[s]*) = 0，*f*′′(*x[s]*) 的符号可以告诉我们 *x[s]*
    可能是何种类型的驻点。如果 *f*′′(*x[s]*) < 0，那么 *x[s]* 是 *f*(*x*) 的一个 *最大值*。如果 *f*′′(*x[s]*)
    > 0，*x[s]* 是一个最小值。如果 *f*′′(*x[s]*) = 0，二阶导数无法提供帮助；我们需要通过一阶导数显式地测试附近的点。
- en: How do we find candidate stationary points in the first place? For algebraic
    functions, we solve *f*′(*x*) = 0; we find the solution set of all the *x* values
    that make the first derivative of *f*(*x*) zero. We then use the derivative tests
    to decide which are minima, maxima, or inflection points.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何找到候选的驻点呢？对于代数函数，我们解 *f*′(*x*) = 0；我们找到所有使得 *f*(*x*) 的一阶导数为零的 *x* 值的解集。然后，我们使用导数检验来决定这些点是最小值、最大值还是拐点。
- en: 'For many functions, we can find the solutions to *f*′(*x*) = 0 directly. For
    example, if *f*(*x*) = *x*³ − 2*x* + 4, we have *f*′(*x*) = 3*x*² − 2\. If we
    set this equal to zero, *3x*[2] − 2 = 0, and solve using the quadratic formula,
    we find that there are two stationary points: ![Image](Images/179equ01.jpg) and
    ![Image](Images/179equ02.jpg). The second derivative of *f*(*x*) is *f*′′(*x*)
    = 6*x*. The sign of *f*′′(*x*[0]) is negative; therefore, *x*[0] represents a
    maximum. And because the sign of *f*′′(*x*[1]) is positive, *x*[1] is a minimum.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多函数，我们可以直接找到 *f*′(*x*) = 0 的解。例如，如果 *f*(*x*) = *x*³ − 2*x* + 4，我们有 *f*′(*x*)
    = 3*x*² − 2。如果我们将其设为零，*3x*[2] − 2 = 0，并使用二次公式解出，我们会发现有两个驻点：![图片](Images/179equ01.jpg)
    和 ![图片](Images/179equ02.jpg)。*f*(*x*) 的二阶导数是 *f*′′(*x*) = 6*x*。*f*′′(*x*[0]) 的符号为负，因此
    *x*[0] 代表一个最大值。由于 *f*′′(*x*[1]) 的符号为正，*x*[1] 是一个最小值。
- en: We can see that the derivative tests are correct. The top of [Figure 7-3](ch07.xhtml#ch07fig03)
    shows us a plot of *f*(*x*) = *x*³ − 2*x* + 4, where *x*[0] is a maximum and *x*[1]
    is a minimum.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，导数测试是正确的。图[7-3](ch07.xhtml#ch07fig03)的顶部显示了 *f*(*x*) = *x*³ − 2*x* +
    4 的图像，其中 *x*[0] 是最大值，*x*[1] 是最小值。
- en: 'Let’s look at one more example. This time, we have *f*(*x*) = *x*⁵−2*x*³+*x*+2,
    the bottom plot of [Figure 7-3](ch07.xhtml#ch07fig03). We find the first derivative
    and set it to zero:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子。这次我们有 *f*(*x*) = *x*⁵−2*x*³+*x*+2，图[7-3](ch07.xhtml#ch07fig03)的底部图像。我们找到一阶导数并将其设为零：
- en: '*f*′(*x*) = 5*x*⁴ − 6*x*² + 1 = 0'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*′(*x*) = 5*x*⁴ − 6*x*² + 1 = 0'
- en: If we substitute *u* = *x*², we can solve for the roots of *f*′(*x*) by finding
    the roots of 5*u*²−6*u*+1 and setting those equal to *x*². Doing this gives us
    ![Image](Images/179equ03.jpg) and ![Image](Images/179equ04.jpg), so we have four
    stationary points. To test them, we can use the second derivative test. The second
    derivative is *f*′′(*x*) = 20*x*³ − 12*x*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们令 *u* = *x*²， 通过求解 5*u*²−6*u*+1 的根并将它们设为 *x*²，可以求出 *f*′(*x*) 的根。这样我们得到！[图片](Images/179equ03.jpg)
    和！[图片](Images/179equ04.jpg)，因此我们有四个驻点。为了测试这些驻点，我们可以使用二阶导数测试。二阶导数是 *f*′′(*x*) =
    20*x*³ − 12*x*。
- en: Substituting the stationary points into *f*′′ gives
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将驻点代入 *f*′′ 得到
- en: '![Image](Images/180equ01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/180equ01.jpg)'
- en: meaning *x*[0] is a maximum, *x*[1] is a minimum, *x*[2] is another maximum,
    and *x*[3] is a minimum. [Figure 7-3](ch07.xhtml#ch07fig03) again confirms our
    conclusions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 *x*[0] 是最大值，*x*[1] 是最小值，*x*[2] 是另一个最大值，*x*[3] 是最小值。图[7-3](ch07.xhtml#ch07fig03)再次确认了我们的结论。
- en: '![image](Images/07fig03.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig03.jpg)'
- en: '*Figure 7-3: Plots of f(x) = x³ – 2x + 4 (top) and x⁵ – 2x³ + x + 2 (bottom),
    with extrema marked*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：图像 f(x) = x³ – 2x + 4（上）和 x⁵ – 2x³ + x + 2（下），极值标记*'
- en: What if we can’t easily find the stationary points of a function? Perhaps we
    can’t solve the function algebraically, or maybe it can’t be expressed in closed
    form, meaning no finite set of operations represents it. A typical calculus course
    isn’t interested in these situations. Still, we need to be, because one way to
    think of a neural network is as a function approximator, one whose function can’t
    be expressed directly. Can we still profitably use our new knowledge of derivatives?
    The answer is yes, we can. We can use the derivative as a pointer to tell us how
    to move closer and closer to the extrema. This is what gradient descent does,
    and we’ll spend quite a bit of time discussing it later in the book.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法轻松找到一个函数的驻点该怎么办？也许我们无法代数解出该函数，或者它可能无法以封闭形式表示，即没有有限的运算集能表示它。典型的微积分课程不会关注这些情况。然而，我们需要关注这些问题，因为神经网络的一种思维方式是作为一个函数逼近器，它的函数不能直接表示。我们是否仍然可以有益地使用导数的知识呢？答案是肯定的，我们可以。我们可以利用导数作为指针，告诉我们如何不断接近极值点。这就是梯度下降法的作用，我们将在本书的后面部分详细讨论它。
- en: For now, however, let’s move on and examine functions of more than one variable
    and see what this does to the idea of a derivative.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前让我们继续前进，研究多变量函数，并看看这对导数的概念有什么影响。
- en: Partial Derivatives
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 偏导数
- en: So far, we’ve focused exclusively on functions of one variable, *x*. What happens
    to the notion of differentiation when we have functions of more than one variable,
    say, *f*(*x*, *y*), or *f*(*x*[0], *x*[1], *x*[2], . . . , *x[n]*)? To handle
    these cases, we’ll introduce the idea of a *partial derivative*. Note that, for
    clarity, we’ll use Leibniz’s notation in this section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于单变量函数，*x*。当我们有多个变量的函数时，例如 *f*(*x*, *y*)，或者 *f*(*x*[0], *x*[1],
    *x*[2], . . . , *x[n]*)，微分的概念会发生什么变化呢？为了处理这些情况，我们将引入*偏导数*的概念。注意，为了更清晰起见，在本节中我们将使用莱布尼茨符号。
- en: '[Equation 7.2](ch07.xhtml#ch07equ02) defined the derivative of *f*(*x*) with
    respect to *x*. If *x* is the only variable, why did we add the extra phrase “with
    respect to *x*”? Now we’ll find out why: the partial derivative with respect to
    one of the variables in the expression is found by holding all the other variables
    fixed. We treat them as if they were constants. Then we say we’re calculating
    the partial derivative with respect to the one not held fixed.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[方程 7.2](ch07.xhtml#ch07equ02) 定义了 *f*(*x*) 对 *x* 的导数。如果 *x* 是唯一的变量，为什么我们还要加上“关于
    *x*”这一额外的描述呢？现在我们来找出原因：表达式中关于某个变量的偏导数是通过将所有其他变量保持固定来求得的。我们将它们当作常数来处理。然后我们说我们正在计算相对于那个没有被固定的变量的偏导数。'
- en: 'Let’s look at an example. Let *f*(*x*, *y*) = *xy* + *x*/*y*. Then, we can
    calculate *two* partial derivatives, one with respect to *x* and the other with
    respect to *y*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。假设 *f*(*x*, *y*) = *xy* + *x*/*y*。然后，我们可以计算出两个偏导数，一个关于 *x*，另一个关于 *y*：
- en: '![Image](Images/181equ01.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/181equ01.jpg)'
- en: The rules of differentiation we learned earlier in the chapter still apply.
    Notice the *d* has changed to ∂. This indicates that the function, *f*, is of
    more than one variable. Also, see that when calculating the respective derivatives,
    we held the other variable fixed as if it were a parameter. As far as calculating
    partial derivatives, that’s all there is to it. Let’s see a few more examples
    to help you make the idea more concrete.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章早些时候学习的微分规则仍然适用。注意，*d* 已经变成了 ∂，这表示函数 *f* 是多变量函数。此外，在计算相应的导数时，我们保持其他变量不变，仿佛它们是参数。至于计算偏导数，就是这样。让我们看几个例子，帮助你更好地理解这个概念。
- en: 'If *f*(*x*, *y*, *z*) = *x*² + *y*² + *z*² + 3*xyz*, we can find three partial
    derivatives:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *f*(*x*, *y*, *z*) = *x*² + *y*² + *z*² + 3*xyz*，我们可以求出三个偏导数：
- en: '![Image](Images/182equ01.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/182equ01.jpg)'
- en: The other two variables are considered constant. This is why, for example, in
    the partial derivative with respect to *x*, *y*² and *z*² become 0, and 3*xyz*
    becomes *3yz*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个变量被视为常数。这就是为什么，例如，在关于 *x* 的偏导数中，*y*² 和 *z*²变成了0，而 3*xyz* 变成了 *3yz*。
- en: 'If ![Image](Images/182equ02.jpg), we have four partial derivatives:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ![Image](Images/182equ02.jpg)，我们有四个偏导数：
- en: '![Image](Images/182equ03.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/182equ03.jpg)'
- en: As a more complex example, consider *f*(*x*, *y*) = *e^(xy)* cos *x* sin *y*.
    The partial derivatives are listed next where we use the product rule in each
    case.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个更复杂的例子，考虑 *f*(*x*, *y*) = *e^(xy)* cos *x* sin *y*。以下列出了偏导数，在每种情况下我们都使用了乘积法则。
- en: '![Image](Images/183equ01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/183equ01.jpg)'
- en: Mixed Partial Derivatives
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 混合偏导数
- en: Just as with the derivative of a function of a single variable, we can take
    partial derivatives of a partial derivative. These are known as *mixed partials*.
    Additionally, we have more flexibility because we can change which variable we
    take the next partial derivative with respect to. For example, above, we saw that
    the partial derivative of ![Image](Images/183equ02.jpg) with respect to *z* is
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对单变量函数求导数一样，我们也可以对偏导数再求偏导数。这些被称为 *混合偏导数*。此外，我们还具有更多的灵活性，因为我们可以改变下一个偏导数所依赖的变量。例如，上面我们看到的
    *f* 关于 *z* 的偏导数是：
- en: '![Image](Images/183equ03.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/183equ03.jpg)'
- en: 'which is still a function of *x*, *y*, *z*, and *t*. Therefore, we can calculate
    second partial derivatives like so:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是 *x*、*y*、*z* 和 *t* 的函数。因此，我们可以像这样计算二阶偏导数：
- en: '![Image](Images/183equ04.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/183equ04.jpg)'
- en: 'I’ll explain the notation. We started with the partial derivative of *f* with
    respect to *z*, so we write ∂*f*/∂*z*. Then, from this starting point, we are
    taking other partial derivatives. So, if we want to denote the partial with respect
    to *x*, we think of it this way:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我来解释一下符号。我们从 *f* 关于 *z* 的偏导数开始，所以我们写 ∂*f*/∂*z*。然后，从这个起点出发，我们再继续求其他偏导数。所以，如果我们想表示关于
    *x* 的偏导数，我们可以这样理解：
- en: '![Image](Images/184equ01.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/184equ01.jpg)'
- en: where we can think of the partial derivative operator “multiplying” the “numerator”
    and “denominator” like a fraction. To be clear, however, these are not fractions;
    the notation has just inherited the flavor of a fraction from its slope origins.
    Still, if the mnemonic is helpful, then it’s helpful. For a second partial derivative,
    the variable it’s taken with respect to is on the left. Also, if the variables
    are the same, an exponent (of sorts) is used, as in ∂²*f*/∂*z*².
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将偏导数运算符“乘”以“分子”和“分母”像分数一样来理解。然而，明确地说，这些并不是分数；这种符号的用法继承了分数的形式，源自它的斜率表示。尽管如此，如果这个助记符有帮助，那么它就是有帮助的。对于二阶偏导数，与之相关的变量在左侧。此外，如果变量相同，使用一种类似指数的符号，如
    ∂²*f*/∂*z*²。
- en: The Chain Rule for Partial Derivatives
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 偏导数的链式法则
- en: To apply the chain rule to partial derivatives, we need to track all the variables.
    So, if we have *f*(*x*, *y*), where both *x* and *y* are functions of other variables,
    *x*(*r*, *s*) and *y*(*r*, *s*), then we can find the partials of *f* with respect
    to *r* and *s* by applying the chain rule for each variable, *x* and *y*. Specifically,
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要将链式法则应用于偏导数，我们需要跟踪所有变量。因此，如果我们有 *f*(*x*, *y*)，其中 *x* 和 *y* 都是其他变量的函数，即 *x*(*r*,
    *s*) 和 *y*(*r*, *s*)，那么我们可以通过对每个变量 *x* 和 *y* 应用链式法则，找到 *f* 对 *r* 和 *s* 的偏导数。具体来说，
- en: '![Image](Images/184equ02.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/184equ02.jpg)'
- en: As an example, let *f*(*x*, *y*) = *x*³+*y*³ with *x*(*r*, *s*) = 3*r*+2*s*
    and *y*(*r*, *s*) = *r*²−3*s*. Now find ∂*f*/∂*r* and ∂*f*/∂*s*. To find these
    partials, we’ll need to calculate six expressions,
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，设 *f*(*x*, *y*) = *x*³ + *y*³，且 *x*(*r*, *s*) = 3*r* + 2*s*，*y*(*r*,
    *s*) = *r*² − 3*s*。现在求 ∂*f*/∂*r* 和 ∂*f*/∂*s*。为了求这些偏导数，我们需要计算六个表达式，
- en: '![Image](Images/184equ03.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/184equ03.jpg)'
- en: so that the desired partials are
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所需的偏导数为
- en: '![Image](Images/185equ01.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/185equ01.jpg)'
- en: Just as with a function of a single variable, the chain rule for functions of
    more than one variable is recursive, such that if *r* and *s* were themselves
    functions of another variable, we could apply the chain rule one more time to
    find the partial of *f* with respect to that variable. For example, if we have
    *x*(*r*, *s*), *y*(*r*, *s*), with *r*(*w*), *s*(*w*), we find ∂*f*/∂*w* by using
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 就像单变量函数一样，针对多变量函数的链式法则是递归的，因此，如果 *r* 和 *s* 本身是另一个变量的函数，我们可以再次应用链式法则，找到 *f* 对该变量的偏导数。例如，如果我们有
    *x*(*r*, *s*)，*y*(*r*, *s*)，且 *r*(*w*)，*s*(*w*)，我们可以使用以下公式来求 ∂*f*/∂*w*，
- en: '![Image](Images/185equ02.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/185equ02.jpg)'
- en: In the end, we need to remember that ∂*f*/∂*w* tells us how *f* will change
    for a small change in *w*. We’ll use this fact during gradient descent.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们需要记住，∂*f*/∂*w* 告诉我们 *f* 会如何随着 *w* 的小变化而变化。我们将在梯度下降过程中使用这一事实。
- en: This section concerned itself with the mechanical calculation of partial derivatives.
    Let’s move on to explore more of the meaning behind these quantities. This will
    lead us to the idea of a gradient.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容关注的是偏导数的机械计算。接下来我们将继续探讨这些量背后的意义，这将引导我们进入梯度的概念。
- en: Gradients
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 梯度
- en: In [Chapter 8](ch08.xhtml#ch08), we will dive into the matrix calculus representation
    we use in deep learning. However, before we do that, we will conclude this chapter
    by introducing the idea of a *gradient*. The gradient builds on the derivatives
    we’ve been calculating. In short, the gradient tells us how a function of more
    than one variable is changing and the direction in which it is changing the most.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.xhtml#ch08)中，我们将深入探讨在深度学习中使用的矩阵微积分表示方法。然而，在此之前，我们将通过引入*梯度*的概念来总结本章内容。梯度是建立在我们已计算的导数基础上的。简而言之，梯度告诉我们一个多变量函数如何变化，以及它在哪个方向变化最快。
- en: Calculating the Gradient
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算梯度
- en: If we have *f*(*x*, *y*, *z*), we saw above how to calculate partial derivatives
    with respect to each of the variables. If we interpret the variables as positions
    on coordinate axes, we see that *f* is a function that returns a scalar, a single
    number, for any position in 3D space, (*x*, *y*, *z*). We could even go so far
    as to write *f*(***x***) where ***x*** = (*x*, *y*, *z*) to acknowledge that *f*
    is a function of a vector input. As in previous chapters, we’ll use lowercase
    bold letters to represent vectors, ***x***. Note, some people use ![Image](Images/xbar.jpg)
    to represent vectors.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有*f*(*x*，*y*，*z*)，我们上面已经看到如何计算关于每个变量的偏导数。如果我们将这些变量解释为坐标轴上的位置，我们就会发现*f*是一个函数，它为3D空间中的任何位置（*x*，*y*，*z*）返回一个标量，即单一数字。我们甚至可以写*f*(***x***)，其中***x***
    = (*x*，*y*，*z*)，以承认*f*是一个向量输入的函数。像前几章一样，我们将使用加粗的小写字母来表示向量，***x***。注意，有些人使用![Image](Images/xbar.jpg)来表示向量。
- en: We can write vectors horizontally, as a row vector, like in the previous paragraph,
    or vertically,
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将向量水平书写，作为行向量，就像前面那一段，或者垂直书写，
- en: '![Image](Images/186equ01.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/186equ01.jpg)'
- en: as a column vector, where we’ve also used square brackets instead of parentheses.
    Either notation is acceptable. Unless we’re intentionally sloppy, usually when
    we’re discussing a vector in code, we’ll assume that our vectors are column vectors.
    This means a vector is a matrix with *n* rows and one column, *n* × 1.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列向量，我们还使用了方括号而不是圆括号。两种表示方法都是可以接受的。除非我们故意疏忽，通常在讨论代码中的向量时，我们会假设向量是列向量。这意味着向量是一个具有*n*行和一列的矩阵，*n*
    × 1。
- en: A function that accepts a vector input and returns a single number as output
    is known as a *scalar field*. The canonical example of a scalar field is temperature.
    We can measure the temperature at any point in a room. We represent the location
    as a 3D vector relative to some chosen origin point, and the temperature is the
    value at that point, the average kinetic energy of the molecules in that region.
    We can also talk about functions that accept vectors as input and return a vector
    as output. These are known as *vector fields*. In both cases, the field part refers
    to the fact that, over some suitable domain, the function has a value for all
    inputs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接受向量输入并返回单一数字作为输出的函数称为*标量场*。标量场的经典例子是温度。我们可以在房间中的任何一个点测量温度。我们将位置表示为相对于某个选定原点的3D向量，温度则是该点的数值，即该区域分子平均动能的大小。我们还可以讨论那些接受向量作为输入并返回向量作为输出的函数。这些称为*向量场*。在这两种情况下，场部分指的是在某个适当的定义域上，函数对所有输入都有一个值。
- en: The gradient is the derivative of a function that accepts a vector as input.
    Mathematically, we represent the gradient as a generalization of the idea of partial
    derivatives to *n* dimensions. For example, in 3D space, we can write
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度是接受向量作为输入的函数的导数。从数学角度来看，我们将梯度表示为对*n*维的偏导数的推广。例如，在3D空间中，我们可以写
- en: '![Image](Images/187equ01.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/187equ01.jpg)'
- en: where the gradient operator, ▽, takes the partial derivative of *f* along each
    of its dimensions. The ▽ operator goes by multiple names, like *del*, *grad*,
    or *nabla*. We’ll use ▽ and call it *del* when we’re not simply saying “gradient
    operator.”
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 其中梯度算子▽对*f*的每个维度进行偏导数运算。▽算子有多个名字，如*del*、*grad*或*nabla*。当我们不单纯说“梯度算子”时，我们将使用▽并称其为*del*。
- en: In general, we can write
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们可以写
- en: '![Image](Images/07equ07.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ07.jpg)'
- en: 'Let’s parse [Equation 7.7](ch07.xhtml#ch07equ07). First, we have a function,
    *f*, that accepts a vector input, ***x***, and returns a scalar value. To this
    function, we apply the gradient operator:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解析一下[方程7.7](ch07.xhtml#ch07equ07)。首先，我们有一个函数*f*，它接受向量输入***x***并返回一个标量值。对这个函数应用梯度算子：
- en: '![Image](Images/187equ02.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/187equ02.jpg)'
- en: This returns a *vector* (***y***). The gradient operator turns the scalar output
    of *f* into a vector. Let’s spend some time thinking about what this means, what
    it’s telling us about the value of the scalar field at a given position in space.
    (We’ll use *space* when working with vectors, even if there’s no meaningful way
    to visualize the space. An analogy to 3D space is helpful but only goes so far;
    mathematically, the idea of space is more general.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个*向量*（***y***）。梯度算子将标量输出的*f*转换为一个向量。让我们花些时间思考这意味着什么，它在空间中的给定位置告诉我们标量场的值。（在处理向量时，我们会使用*空间*，即使没有一种有意义的方式去可视化这个空间。3D空间的类比有帮助，但也只是有限的；从数学角度看，空间的概念更为广泛。）
- en: As an example, consider a function in 2D space, *f*(***x***) = *f*(*x*, *y*)
    = *x*² + *xy* + *y*². The gradient of *f* is then
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑一个二维空间中的函数，*f*(***x***) = *f*(*x*, *y*) = *x*² + *xy* + *y*²。*f*的梯度是：
- en: '![Image](Images/07equ08.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ08.jpg)'
- en: Since *f* is a scalar field, every point on the 2D plane has a function value.
    This is the output of *f*(***x***) = *f*(*x*, *y*). So, we can plot *f* in 3D
    to show us a surface changing with position. The gradient, however, gives us a
    set of equations. These equations collectively tell us the direction and magnitude
    of the change in the function value at a point, ***x*** = (*x*, *y*).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*f*是标量场，二维平面上的每个点都有一个函数值。这就是*f*(***x***) = *f*(*x*, *y*)的输出。因此，我们可以在三维空间中绘制*f*，以展示随位置变化的曲面。然而，梯度则给出了我们一组方程。这些方程告诉我们在某一点***x***
    = (*x*, *y*)处，函数值变化的方向和大小。
- en: For a function of a single variable, there’s only one slope at each point. Look
    again at the tangent line of [Figure 7-1](ch07.xhtml#ch07fig01). At the point
    *x[t]*, there’s only one slope. The sign of the derivative at *x[t]* gives the
    direction of the slope, and the absolute value of the derivative gives the magnitude
    (steepness) of the slope.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单变量函数，每个点只有一个斜率。再看看[图 7-1](ch07.xhtml#ch07fig01)中的切线。在点*x[t]*，只有一个斜率。导数在*x[t]*处的符号表示斜率的方向，导数的绝对值表示斜率的大小（陡峭度）。
- en: 'However, once we change to more than one dimension, we have a bit of a conundrum.
    Instead of only one slope tangent to the function, we now have an infinite number.
    We can imagine a line tangent to the function at some point and that the line
    points in any direction we so desire. The slope of the line tells us how the function
    value is changing in that particular direction. We can find the value of this
    change from the *directional derivative*, the dot product between the gradient
    at the point under consideration and a unit vector in the direction we’re interested
    in:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们转向多于一个维度的情况，就会遇到一些困惑。我们不再只有一个与函数相切的斜率，而是有无数个。我们可以想象某个点上的切线，并且这条线可以指向我们想要的任何方向。切线的斜率告诉我们在这个特定方向上函数值的变化。我们可以通过*方向导数*来找到这种变化的值，方向导数是梯度与我们感兴趣方向的单位向量的点积：
- en: '*D**[u]**f*(***x***) ≡ ***u**• ▽f*(***x***) = ***u**^T*▽*f*(***x***) = ||***u***||||▽*f*(***x***)||
    cos *θ*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*D**[u]**f*(***x***) ≡ ***u**• ▽f*(***x***) = ***u**^T*▽*f*(***x***) = ||***u***||||▽*f*(***x***)||
    cos *θ*'
- en: where ***u*** is a unit vector in a particular direction, ▽*f*(***x***) is the
    gradient of the function at the point ***x***, and *θ* is the angle between them.
    The directional derivative is maximized when cos *θ* is maximized, and this happens
    at *θ* = 0\. Therefore, the direction of the maximum change in a function at any
    point is the gradient at that point.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，***u***是特定方向的单位向量，▽*f*(***x***)是点***x***处函数的梯度，*θ*是它们之间的夹角。当cos *θ*最大时，方向导数也达到最大，这发生在*θ*
    = 0时。因此，函数在任何点的最大变化方向是该点的梯度。
- en: As an example, let’s pick a point on the 2D plane, say ***x*** = (*x*, *y*)
    = (0.5, −0.4) with *f*(*x*, *y*) = *x*² + *xy* + *y*² from above. Then, the function
    value at ***x*** is *x*² + *xy* + *y*² = (0.5)² + (0.5)(−0.4) + (−0.4)² = 0.21,
    a scalar. However, the gradient at this point is
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们在二维平面上选一个点，假设***x*** = (*x*, *y*) = (0.5, −0.4)，并且有*f*(*x*, *y*) = *x*²
    + *xy* + *y*²。从上面的公式得出，点***x***处的函数值是 *x*² + *xy* + *y*² = (0.5)² + (0.5)(−0.4)
    + (−0.4)² = 0.21，这是一个标量。然而，这个点的梯度是：
- en: '![Image](Images/188equ01.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/188equ01.jpg)'
- en: Therefore, we now know that at the point (0.5, −0.4), the direction of the largest
    change in *f* is in the direction (0.6, −0.3) and has a magnitude of ![Image](Images/188equ02.jpg).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道，在点 (0.5, −0.4) 处，*f*的最大变化方向是 (0.6, −0.3)，其大小为 ![Image](Images/188equ02.jpg)。
- en: Visualizing the Gradient
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 梯度可视化
- en: Let’s make all of this less abstract. The top part of [Figure 7-4](ch07.xhtml#ch07fig04)
    shows a plot of *f*(*x*, *y*) = *x*² + *xy* + *y*² at selected points.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让这一切不那么抽象。[图 7-4](ch07.xhtml#ch07fig04)的上半部分显示了在选定点处的*f*(*x*, *y*) = *x*²
    + *xy* + *y*²的图形。
- en: '![image](Images/07fig04.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/07fig04.jpg)'
- en: '*Figure 7-4: A plot of x² + xy + y² (top) and a 2D projection of the associated
    gradient field (bottom)*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：x² + xy + y² 的绘图（上图）以及相关梯度场的二维投影（下图）*'
- en: 'The code to generate this plot is straightforward:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此图的代码很简单：
- en: import numpy as np
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: x = np.linspace(-1.0,1.0,50)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: x = np.linspace(-1.0,1.0,50)
- en: y = np.linspace(-1.0,1.0,50)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: y = np.linspace(-1.0,1.0,50)
- en: xx = []; yy = []; zz = []
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: xx = []; yy = []; zz = []
- en: 'for i in range (50):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range (50):'
- en: 'for j in range (50):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range (50):'
- en: xx.append(x[i])
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: xx.append(x[i])
- en: yy.append(y[j])
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: yy.append(y[j])
- en: zz.append(x[i]*x[i]+x[i]*y[j]+y[j]*y[j])
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: zz.append(x[i]*x[i]+x[i]*y[j]+y[j]*y[j])
- en: x = np.array(xx)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: x = np.array(xx)
- en: y = np.array(yy)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: y = np.array(yy)
- en: z = np.array(zz)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: z = np.array(zz)
- en: Here, we explicitly loop to generate the set of scatter plot points, x, y, and
    z, to clearly show what’s happening. First, we use NumPy to generate vectors of
    50 evenly spaced points [−1, 1] in x and y. Then we set up a double loop so that
    each x gets paired with each y to calculate the function value, z. Temporary lists
    xx, yy, and zz hold the triplets. Finally, we convert the lists to NumPy arrays
    for plotting.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们显式地使用循环生成散点图的点集 x, y 和 z，以清晰地展示发生的情况。首先，我们使用 NumPy 生成在 x 和 y 范围 [−1, 1]
    内均匀分布的 50 个点。然后，我们设置双重循环，使得每个 x 都与每个 y 配对，以计算函数值 z。临时列表 xx, yy 和 zz 保存这些三元组。最后，我们将这些列表转换为
    NumPy 数组以便绘图。
- en: The code to generate the scatter plot is
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 生成散点图的代码是
- en: from mpl_toolkits.mplot3d import Axes3D
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: from mpl_toolkits.mplot3d import Axes3D
- en: import matplotlib.pylab as plt
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pylab as plt
- en: fig = plt.figure()
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: fig = plt.figure()
- en: ax = fig.add_subplot(111, projection='3d')
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ax = fig.add_subplot(111, projection='3d')
- en: ax.scatter(x, y, z, marker='.', s=2, color='b')
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ax.scatter(x, y, z, marker='.', s=2, color='b')
- en: ax.view_init(30,20)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ax.view_init(30,20)
- en: plt.draw()
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: plt.draw()
- en: plt.show()
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: We first load the matplotlib extension for 3D plotting, and then we set the
    subplot for a 3D projection. The plot itself is made with ax.scatter, while ax.view_init
    and plt.draw rotate the plot to give us a better view of the shape of the function
    before showing it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先加载 matplotlib 的 3D 绘图扩展，然后设置 3D 投影的子图。图形本身是通过 ax.scatter 绘制的，而 ax.view_init
    和 plt.draw 则旋转图形，让我们更好地查看函数的形状，然后再展示图形。
- en: In the bottom part of [Figure 7-4](ch07.xhtml#ch07fig04), we see a vector plot
    of the gradient field for *x*² + *xy* + *y*². This plot shows the direction and
    relative magnitude of the gradient vector at a grid of points, (*x*, *y*). Recall,
    the gradient is a vector field, so each point on the *xy*-plane has an associated
    vector pointing in the direction of the greatest change in the function value.
    Mentally, we can see how the vector plot relates to the function plot in the top
    part of [Figure 7-4](ch07.xhtml#ch07fig04), where function values near (−1, −1)
    and (1, 1) are changing quickly, whereas for points near (0, 0) they’re changing
    slowly.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 7-4](ch07.xhtml#ch07fig04)的下半部分，我们看到一个关于 *x*² + *xy* + *y*²的梯度场的向量图。这个图展示了在网格点（*x*,
    *y*）上梯度向量的方向和相对大小。回想一下，梯度是一个向量场，因此 *xy* 平面上的每个点都有一个与之相关的向量，指向函数值变化最快的方向。从思维上讲，我们可以看到该向量图如何与[图
    7-4](ch07.xhtml#ch07fig04)上半部分的函数图相关，其中，靠近（−1, −1）和（1, 1）的函数值变化很快，而靠近（0, 0）的点变化较慢。
- en: The code to generate the vector field plot is
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 生成向量场图的代码是
- en: fig = plt.figure()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: fig = plt.figure()
- en: ax = fig.add_subplot(111)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ax = fig.add_subplot(111)
- en: x = np.linspace(-1.0,1.0,20)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: x = np.linspace(-1.0,1.0,20)
- en: y = np.linspace(-1.0,1.0,20)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: y = np.linspace(-1.0,1.0,20)
- en: xv, yv = np.meshgrid(x, y, indexing='ij', sparse=False)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: xv, yv = np.meshgrid(x, y, indexing='ij', sparse=False)
- en: dx = 2*xv + yv
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: dx = 2*xv + yv
- en: dy = 2*yv + xv
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: dy = 2*yv + xv
- en: ax.quiver(xv, yv, dx, dy, color='b')
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ax.quiver(xv, yv, dx, dy, color='b')
- en: plt.axis('equal')
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: plt.axis('equal')
- en: plt.show()
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: We first define the figure (fig) and subplot for 2D (no projection keyword).
    Then, we need a grid of points. Above, we looped to get this grid so we could
    understand what needed to be generated. Here, we use NumPy to generate the grid
    for us via np.meshgrid. Note, we pass np.meshgrid the same x and y vectors we
    had above to define the domain.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了图形（fig）和 2D 子图（没有 projection 关键字）。然后，我们需要一个网格点。上面我们通过循环获取了这个网格，以便了解需要生成什么。在这里，我们使用
    NumPy 通过 np.meshgrid 生成网格。注意，我们传递给 np.meshgrid 的 x 和 y 向量与上面一样，用于定义域。
- en: The next two lines are a direct implementation of the gradient of *f*, [Equation
    7.8](ch07.xhtml#ch07equ08). These are the vectors we want to plot, with dx and
    dy giving us the direction and magnitude, while xv and yv are the set of input
    points—400 total.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行代码是 *f* 的梯度，[公式 7.8](ch07.xhtml#ch07equ08)的直接实现。这些是我们要绘制的向量，dx 和 dy 给我们方向和大小，而
    xv 和 yv 是输入点的集合，共 400 个。
- en: The plot uses ax.quiver (since it plots arrows). The arguments are the grid
    of points (xv, yv) and associated *x* and *y* values of the vectors at those points
    (dx, dy). Finally, we ensure the axes are equal (plt.axis) to avoid warping the
    vector display, then show the plot.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 该图使用了 ax.quiver（因为它绘制了箭头）。参数是网格点（xv, yv）以及这些点上向量的 *x* 和 *y* 值（dx, dy）。最后，我们确保坐标轴是相等的（plt.axis），以避免向量显示变形，然后显示图像。
- en: We’ll conclude our introduction of gradients here. We’ll see them again throughout
    the remainder of the book, in the notation in [Chapter 8](ch08.xhtml#ch08) and
    the gradient descent discussions of [Chapter 11](ch11.xhtml#ch11).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此结束梯度的介绍。在本书的其余部分，我们会再次看到梯度，尤其是在[第8章](ch08.xhtml#ch08)的符号表示以及[第11章](ch11.xhtml#ch11)的梯度下降讨论中。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced the main concepts of differential calculus. We started
    with the notion of slope and learned the difference between secant and tangent
    lines for a function of a single variable. We then formally defined the derivative
    as the slope of a secant line as it approaches a single point. From there, we
    learned the basic rules of differentiation and saw how to apply them.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了微分学的主要概念。我们从斜率的概念开始，学习了割线和切线的区别，这些都是针对单变量函数的。接着，我们正式定义了导数为割线在接近单一点时的斜率。之后，我们学习了微分的基本规则，并了解了如何应用这些规则。
- en: Next, we learned about the minima and maxima of a function and how to find these
    points using derivatives. We then introduced partial derivatives as a way to calculate
    derivatives for functions of more than one variable. Partial derivatives then
    led us to the gradient, which turns a scalar field into a vector field and tells
    us the direction in which the function is changing the most. We calculated an
    example gradient in 2D and saw how to generate plots showing the relationship
    between the function and the gradient. We learned the crucial fact that the gradient
    of a function points in the direction of the maximum change in the function value
    at a point.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们了解了函数的极小值和极大值，以及如何使用导数找到这些点。然后，我们引入了偏导数，作为计算多变量函数导数的一种方法。偏导数进一步引导我们认识了梯度，梯度将标量场转换为向量场，并告诉我们函数变化最快的方向。我们计算了一个二维的梯度示例，并展示了如何生成图表，显示函数与梯度之间的关系。我们学到了一个关键事实：函数的梯度指向函数值在某一点变化最快的方向。
- en: Let’s continue our exploration of the math behind deep learning and move into
    the world of matrix calculus.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索深度学习背后的数学，并进入矩阵微积分的世界。
