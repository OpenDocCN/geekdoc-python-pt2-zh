- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: DIFFERENTIAL CALCULUS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微分学**
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: 'The discovery of “the calculus” by Sir Issac Newton, and separately by Gottfried
    Wilhelm Leibniz, was one of the greatest achievements in the history of mathematics.
    Calculus is typically split into two main parts: differential and integral. Differential
    calculus talks about rates of change and their relationships, embodied in the
    notion of the derivative. Integral calculus is concerned with things like the
    area under a curve.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 艾萨克·牛顿爵士和戈特弗里德·威廉·莱布尼茨分别发现了“微积分”，这是数学历史上最伟大的成就之一。微积分通常分为两大部分：微分学和积分学。微分学讨论的是变化率及其关系，体现在导数的概念中。积分学则关注曲线下的面积等问题。
- en: We don’t need integral calculus for deep learning, but we’ll use differential
    calculus often. For example, we use differential calculus to train neural networks;
    we adjust the weights of a neural network using gradient descent, which relies
    on derivatives calculated via the backpropagation algorithm.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习中我们不需要用到积分学，但微分学将会被频繁使用。例如，我们用微分学来训练神经网络；我们通过梯度下降法调整神经网络的权重，而梯度下降依赖于通过反向传播算法计算的导数。
- en: The derivative will be the star of this chapter. We’ll begin by introducing
    the idea of slope and seeing how it leads to the notion of a derivative. We’ll
    then formally define the derivative and learn how to calculate derivatives of
    functions of one variable. After that, we’ll learn how to use derivatives to find
    the minima and maxima of functions. Next come partial derivatives, the derivatives
    with respect to a single variable for functions of more than one variable. We’ll
    use partial derivatives extensively in the backpropagation algorithm. We’ll conclude
    with gradients, which will introduce us to matrix calculus, the subject of [Chapter
    8](ch08.xhtml#ch08).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 导数将是本章的核心。我们将首先介绍斜率的概念，看看它如何引出导数的概念。然后我们会正式定义导数，并学习如何计算单变量函数的导数。之后，我们将学习如何利用导数找出函数的最小值和最大值。接下来是偏导数，即针对多变量函数的单一变量的导数。我们将在反向传播算法中广泛使用偏导数。最后，我们将介绍梯度，进而引入矩阵微积分，这也是[第8章](ch08.xhtml#ch08)的内容。
- en: Slope
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 斜率
- en: In algebra class, we learned all about lines. One way to define a line is the
    slope-intercept form,
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在代数课上，我们学习了关于直线的所有内容。定义直线的一种方式是斜截式，
- en: '*y* = *mx* + *b*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = *mx* + *b*'
- en: 'where *m* is the slope and *b* is the *y* intercept, the place where the line
    crosses the y-axis. We’re interested in the slope. If we know two points on the
    line, (*x*[1], *y*[1]) and (*x*[0], *y*[0]), we know the slope of the line:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *m* 是斜率，*b* 是*y* 截距，即直线与 y 轴交点的位置。我们关注的是斜率。如果我们知道直线上的两个点（*x*[1], *y*[1]）和（*x*[0],
    *y*[0]），我们就知道直线的斜率：
- en: '![Image](Images/164equ01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/164equ01.jpg)'
- en: The *slope* tells us how much of a change in *y* we will get for any given change
    in *x* position. If the slope is positive, then a positive change in *x* leads
    to a positive change in *y*. On the other hand, a negative slope means that a
    positive change in *x* leads to a negative change in *y*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 斜率告诉我们，*x*位置的任何变化，会引起*y*的多少变化。如果斜率为正，那么*x*的正变化会导致*y*的正变化。另一方面，负斜率意味着*x*的正变化会导致*y*的负变化。
- en: The slope-intercept form of the line tells us that the slope is the proportionality
    constant between *x* and *y*. The intercept, *b*, is a constant offset. This means
    a change in *x* position from *x*[1] to *x*[0] leads to an *m*(*x*[1] − *x*[0])
    change in *y*. Slopes relate two things, telling us how changing one affects the
    other. We’ll get back to this idea several times in the book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 直线的斜截式告诉我们，斜率是*x*和*y*之间的比例常数。截距，*b*，是一个常数偏移量。这意味着，*x*从*x*[1]变到*x*[0]时，*y*的变化为*m*（*x*[1]
    − *x*[0]）。斜率关联了两件事，告诉我们改变一个变量如何影响另一个变量。我们将在本书中多次回到这个概念。
- en: Now, let’s visualize this with some examples. [Figure 7-1](ch07.xhtml#ch07fig01)
    shows the plot of a curve and some lines that intersect it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一些例子来形象化这一点。[图 7-1](ch07.xhtml#ch07fig01)显示了一个曲线和一些与其相交的直线。
- en: '![image](Images/07fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/07fig01.jpg)'
- en: '*Figure 7-1: A curve with a secant line (*A*) and a tangent line (*B*)*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：一条曲线及其割线（*A*）和切线（*B*）*'
- en: The line labeled *A* crosses the curve at two points, *x*[1] and *x*[0]. A line
    passing between two points on a curve is called a *secant* line. The other line,
    *B*, just touches the curve at the point *x**[t]*. Lines that touch a curve at
    one point are called *tangent* lines. We’ll get back to secant lines in the next
    section, but, for now, notice that the tangent line has a particular slope at
    *x**[t]* and that a secant line becomes a tangent line as the distance between
    the points *x*[1] and *x*[0] goes toward zero.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 *A* 的线与曲线在两点交叉，*x*[1] 和 *x*[0]。通过曲线上两点之间的连线称为 *割线*。另一条线，*B*，恰好在点 *x**[t]*
    触及曲线。与曲线在一个点上接触的线称为 *切线*。我们将在下一节回到割线，但现在请注意，切线在 *x**[t]* 处具有特定的斜率，而割线随着 *x*[1]
    和 *x*[0] 之间的距离趋向于零而变成切线。
- en: Imagine that we move the point *x**[t]* from place to place along the curve;
    we can see that the slope of the tangent line at *x**[t]* would change with it.
    As we approach the minimum point of the curve, near *x* = 0.3, we see that the
    slope becomes more and more shallow. If we approach from the left, the slope is
    negative and becomes less and less negative. If we approach from the right, the
    slope is positive but becomes smaller and smaller. At the actual minimum point,
    near *x* = 0.3, the tangent line is horizontal, with a slope of zero. Similarly,
    if we approach the maximum of the curve, near *x* = −0.8, the slope also approaches
    zero.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将点 *x**[t]* 从曲线上的一个位置移动到另一个位置；我们可以看到，*x**[t]* 处的切线斜率也会随着位置的变化而改变。当我们接近曲线的最小点，约在
    *x* = 0.3 处时，我们看到斜率变得越来越平缓。如果从左侧接近，斜率为负，并且变得越来越不负。如果从右侧接近，斜率为正，但变得越来越小。在实际的最小点，约在
    *x* = 0.3 处，切线是水平的，斜率为零。类似地，如果我们接近曲线的最大点，约在 *x* = −0.8 处，斜率也会接近零。
- en: We can see that the tangent line tells us how the curve is changing at a point.
    As we’ll see later in the chapter, the fact that the slope of a tangent line is
    zero at the minima and maxima of a curve points us toward a method for finding
    these points. The points where the slope of the tangent line is zero are known
    as *stationary points*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，切线告诉我们曲线在某点的变化情况。正如我们将在本章后面看到的那样，切线的斜率在曲线的最小值和最大值处为零，这将引导我们找到这些点的方法。切线斜率为零的点被称为
    *驻点*。
- en: Of course, to take advantage of the slope of the tangent line, we need to be
    able to find its value for any *x* on the curve. The next section will show us
    how.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要利用切线的斜率，我们需要能够求出曲线上任意 *x* 处切线的斜率。下一节将向我们展示如何做到这一点。
- en: Derivatives
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导数
- en: The previous section introduced the idea of secant and tangent lines and hinted
    that knowing the slope of the tangent line at any point on a curve is a potentially
    useful thing. The slope of the tangent line at a point *x* is known as the *derivative*
    at *x*. It tells us how the curve (function) is changing at the point *x*, that
    is, how the function value changes with an infinitesimal change in *x*. In this
    section, we’ll formally define the derivative and learn shortcut rules for calculating
    derivatives of functions of a single variable, *x*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节介绍了割线和切线的概念，并暗示了知道曲线在某一点的切线斜率可能是有用的。切线在 *x* 处的斜率被称为 *x* 处的 *导数*。它告诉我们曲线（函数）在
    *x* 处的变化情况，即函数值如何随着 *x* 的微小变化而变化。在这一节中，我们将正式定义导数，并学习计算单变量函数 *x* 导数的简化规则。
- en: A Formal Definition
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个正式的定义
- en: A typical first-semester calculus course introduces you to derivatives through
    studying limits. I mentioned above how the slope of the secant line between two
    points on a curve becomes a tangent line when the points collapse on top of each
    other, and that’s one place where limits come into play.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的第一学期微积分课程会通过研究极限来引入导数。我在上面提到过，曲线两点之间的割线的斜率会在两点重合时变成切线，而这正是极限发挥作用的地方。
- en: For example, if *y* = *f*(*x*) is a curve, and we have two points on the curve,
    *x*[0] and *x*[1], then the slope, Δ*y*/Δ*x*, between these points is
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 *y* = *f*(*x*) 是一条曲线，并且我们在曲线上有两个点，*x*[0] 和 *x*[1]，那么这两点之间的斜率，Δ*y*/Δ*x*，为
- en: '![Image](Images/07equ01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ01.jpg)'
- en: This is the *rise over run* you may remember learning in school. The *rise*,
    *Δy* = *y*[1] − *y*[0] = *f*(*x*[1]) − *f*(*x*[0]), is divided by the *run*, Δ*x*
    = *x*[1] − *x*[0]. We typically use Δ as a prefix to mean the change in some variable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你可能在学校里学过的 *升高比水平*（*rise over run*）。*升高*，*Δy* = *y*[1] − *y*[0] = *f*(*x*[1])
    − *f*(*x*[0])，除以 *水平*，Δ*x* = *x*[1] − *x*[0]。我们通常用 Δ 作为前缀来表示某个变量的变化。
- en: If we define *h* = *x*[1] − *x*[0], we can rewrite [Equation 7.1](ch07.xhtml#ch07equ01)
    as
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义 *h* = *x*[1] − *x*[0]，我们可以将 [方程 7.1](ch07.xhtml#ch07equ01) 重写为
- en: '![Image](Images/166equ01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/166equ01.jpg)'
- en: since *x*[1] = *x*[0] + *h*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *x*[1] = *x*[0] + *h*。
- en: In this new form, we can find the slope of the tangent line at *x*[0] by letting
    *h* get closer and closer to zero, *h* → 0\. Letting a value approach another
    value is a *limit*. Letting *h* → 0 moves the two points we’re calculating the
    slope between closer and closer. This leads directly to the definition of the
    derivative
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种新形式下，我们可以通过让 *h* 越来越接近零，即 *h* → 0，来找到 *x*[0] 处切线的斜率。让一个值逼近另一个值就是一个*极限*。让
    *h* → 0 就是让我们计算斜率的两点越来越接近。这直接导致了导数的定义。
- en: '![Image](Images/07equ02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07equ02.jpg)'
- en: where *dy*/*dx* or *f′*(*x*) is used to represent the derivative of *f*(*x*).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*dy*/*dx* 或 *f′*(*x*) 用来表示 *f*(*x*) 的导数。'
- en: Before we get into what the derivative means, let’s take a minute to discuss
    notation. Using *f*′(*x*) for the derivative follows Joseph-Louis Lagrange. Leibniz
    used *dy*/*dx* to mirror the notation for slope with Δ → *d*. If Δ*y* is a change
    in *y* between two points, *dy* is the infinitesimal change in *y* at a single
    point. Newton used yet another notation, ![Image](Images/166equ02.jpg), with the
    dot representing the derivative of *f*. Physicists often use Newton’s notation
    for the specific case of derivatives with respect to time. For example, if *f*(*t*)
    is the position of a particle as a function of time, *t*, then ![Image](Images/166equ03.jpg)
    is the derivative with respect to *t*, that is, how the position is changing in
    time. How a position changes in time is the speed (velocity if using vectors).
    You’ll see all of these notations in books. My preference is to preserve ![Image](Images/166equ02.jpg)
    for functions of time and use Lagrange’s *f*′(*x*) and Leibniz’s *dy*/*dx* interchangeably
    elsewhere.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论导数的含义之前，先花点时间讨论一下符号。使用 *f*′(*x*) 来表示导数是跟随 Joseph-Louis Lagrange 的做法。莱布尼茨使用
    *dy*/*dx* 来模仿斜率的符号，将 Δ → *d*。如果 Δ*y* 是两个点之间 *y* 的变化量，*dy* 则是单个点上 *y* 的微小变化。牛顿使用了另一种符号，![图片](Images/166equ02.jpg)，其中点表示
    *f* 的导数。物理学家通常使用牛顿的符号来表示关于时间的导数。例如，如果 *f*(*t*) 是粒子的位置关于时间 *t* 的函数，那么![图片](Images/166equ03.jpg)
    就是关于 *t* 的导数，也就是位置随时间的变化。位置随时间的变化即为速度（如果使用向量则为速度）。你在书籍中会看到所有这些符号。我的偏好是保留![图片](Images/166equ02.jpg)
    用于时间的函数，并在其他地方交替使用 Lagrange 的 *f*′(*x*) 和 Leibniz 的 *dy*/*dx*。
- en: Although [Equation 7.2](ch07.xhtml#ch07equ02) above is quite tedious and the
    bane of many beginning calculus students, at least until they hit integration,
    you could work with it if you had to. However, we won’t discuss integration at
    all in this book, so you can take a deep breath and relax.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上面的 [方程 7.2](ch07.xhtml#ch07equ02) 很繁琐，且是许多初学微积分学生的噩梦，至少直到他们遇到积分，但如果不得不使用它，你还是可以操作的。不过，在本书中我们不会讨论积分，所以你可以深呼吸，放松一下。
- en: 'After the struggle with limits, calculus students are let in on a secret: a
    small set of rules will allow you to calculate virtually all derivatives *without*
    using limits. We’ll start by introducing these rules, one at a time with examples,
    and then, at the end of this section, we’ll put them all together in a form suitable
    for a T-shirt.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在与极限的斗争之后，微积分学生会得到一个秘密：一小套规则将使你无需使用极限就能计算几乎所有的导数。我们将通过一个一个的例子介绍这些规则，然后，在本节的末尾，我们将把这些规则整合成一种适合印在
    T 恤上的形式。
- en: However, before we dive into the rules, let’s spend a little more time discussing
    *what* the derivative is telling us. Above, I mentioned that how a position changes
    in time is given by the derivative. This is true of all derivatives; they tell
    us how something is changing with respect to how something else is changing. We
    even see this in Leibniz’s notation, *dy*/*dx*, how *dy* changes for a change
    in *dx*. The derivative at *x* tells us how the function is changing at *x*. As
    we’ll see, the derivative of *f*(*x*) is itself a new function of *x*. If we pick
    a specific *x*[0], then we know that *f*(*x*[0]) is the value of the function
    at *x*[0].
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们深入讨论规则之前，让我们再花点时间讨论一下*导数*究竟在告诉我们什么。前面我提到，位置随时间的变化由导数给出。这对于所有的导数都是适用的；它们告诉我们某个事物如何随另一个事物的变化而变化。我们甚至可以在莱布尼茨的符号
    *dy*/*dx* 中看到这一点，它表示 *dy* 随 *dx* 变化的程度。*x* 处的导数告诉我们该点处函数是如何变化的。正如我们将看到的，*f*(*x*)
    的导数本身就是一个关于 *x* 的新函数。如果我们选择一个特定的 *x*[0]，那么我们知道 *f*(*x*[0]) 就是该点处函数的值。
- en: 'Similarly, if we know the derivative, then *f*′(*x*[0]) is how quickly, and
    in which direction, the function, *f*(*x*), is changing at *x*[0]. Consider the
    definition of speed as how the position changes with time. We even say it in words:
    my current speed is 30 mph—*miles per hour*—a change in position with respect
    to a change in time.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果我们知道导数，那么*f*′(*x*[0])表示函数*f*(*x*)在*x*[0]处变化的速度和方向。考虑速度的定义，即位置随时间变化的情况。我们甚至用语言来表达：我当前的速度是30英里每小时—*miles
    per hour*—即位置随时间的变化。
- en: We’ll use derivatives like rates and see how changing one thing affects another.
    In the end, for deep learning, we want to know how changing the value of a parameter
    in a network will ultimately change the loss function, the error between what
    the network should have output and what it actually output.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用导数来表示速率，看看改变一个变量如何影响另一个变量。最终，在深度学习中，我们希望了解在网络中改变一个参数的值将如何最终改变损失函数，即网络预期输出与实际输出之间的误差。
- en: If *f*′(*x*) is a function of *x*, then we should be able to take the derivative
    of it. We call *f*′(*x*) the *first derivative*. Its derivative, which we denote
    as *f*′′(*x*), is the *second derivative*. In Leibniz’s notation, we write *d*²*y*/*dx*².
    The second derivative tells us how the first derivative is changing with respect
    to *x*. Physics helps here. The first derivative of the position as a function
    of time (*f*) is the *velocity*, ![Image](Images/167equ01.jpg)—how the position
    is changing with time. Therefore, the second derivative of the position, ![Image](Images/167equ02.jpg),
    which is the first derivative of the velocity, is how the velocity is changing
    with time. We call this the *acceleration*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*f*′(*x*)是*x*的函数，那么我们应该能够对其求导。我们称*f*′(*x*)为*一阶导数*。它的导数，用*f*′′(*x*)表示，是*二阶导数*。在莱布尼茨符号中，我们写作*d*²*y*/*dx*²。二阶导数告诉我们一阶导数是如何随*x*变化的。物理学在这里提供了帮助。位置关于时间的函数*f*的一阶导数是*速度*，![Image](Images/167equ01.jpg)—即位置随时间的变化。因此，位置的二阶导数，![Image](Images/167equ02.jpg)，也就是速度的一阶导数，表示速度随时间的变化。我们称之为*加速度*。
- en: In theory, there is no end to how many derivatives we can calculate. In reality,
    many functions ultimately end up with a derivative that is a constant value. Since
    a constant value doesn’t change, its derivative is zero.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以计算任意多次导数。实际上，许多函数最终的导数是常数值。由于常数值不变化，它的导数为零。
- en: To sum up, the derivative of *f*(*x*) is another function, *f*′(*x*) or *dy*/*dx*,
    that tells us the slope of the line tangent to *f*(*x*) at every point. And, since
    *f*′(*x*) is a function of *x*, it also has a derivative, *f*′′(*x*) or *d*²*y*/*dx*²,
    the second derivative, telling us how *f*′(*x*) changes at each *x*, and so on.
    We’ll see below how to make use of first and second derivatives. For now, let’s
    learn the rules of *differentiation*, the act of calculating a derivative.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，*f*(*x*)的导数是另一个函数，*f*′(*x*)或*dy*/*dx*，它告诉我们在每一点上*f*(*x*)的切线斜率。而且，由于*f*′(*x*)是*x*的函数，它也有导数，*f*′′(*x*)或*d*²*y*/*dx*²，即第二导数，它告诉我们*f*′(*x*)在每个*x*处的变化情况，依此类推。我们将在下面看到如何利用一阶和二阶导数。目前，先学习*微分*规则，即计算导数的过程。
- en: Basic Rules
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基本规则
- en: 'We mentioned one rule in the previous section: that the derivative of a constant,
    *c*, is zero. So, we write'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中提到了一条规则：常数*c*的导数为零。所以，我们写作
- en: '![Image](Images/167equ03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/167equ03.jpg)'
- en: 'where we’re using Leibniz’s notation in operator form: *d*/*dx*. Think of *d*/*dx*
    as something operating on what follows; it does this the same way that negation
    does: to negate *c*, we write *−c*; to differentiate *c*, we write ![Image](Images/167equ04.jpg).
    If our expression has no *x*, then we will treat it as a constant, and the derivative
    will be zero.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用的是莱布尼茨符号的算子形式：*d*/*dx*。可以将*d*/*dx*看作是作用于后面的部分；它的作用方式与否定相同：要否定*c*，我们写作*−c*；要对*c*求导，我们写作![Image](Images/167equ04.jpg)。如果我们的表达式中没有*x*，那么我们将其视为常数，导数为零。
- en: The Power Rule
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 幂法则
- en: The derivative of a power of *x* uses the *power rule*,
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*的幂的导数使用*幂法则*，'
- en: '![Image](Images/168equ01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/168equ01.jpg)'
- en: 'where *a* is a constant and *n* is an exponent that doesn’t need to be an integer.
    Let’s see some examples:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*a*是常数，*n*是指数，不需要是整数。我们来看一些例子：
- en: '![Image](Images/168equ02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/168equ02.jpg)'
- en: We often build algebraic expressions out of terms that are added and subtracted.
    Differentiation is a linear operator, so we can write
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常通过加法和减法构建代数表达式。微分是一个线性算子，所以我们可以写作
- en: '![Image](Images/168equ03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/168equ03.jpg)'
- en: 'This means we calculate derivatives term by term. For example, with the set
    of rules we have so far, we now know how to calculate the derivative of a polynomial:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们逐项计算导数。例如，使用我们目前掌握的规则，我们现在知道如何计算一个多项式的导数：
- en: '![Image](Images/168equ04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/168equ04.jpg)'
- en: In general, then,
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，
- en: '![Image](Images/169equ01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/169equ01.jpg)'
- en: where we see that the derivative of a polynomial of degree *n* is another polynomial
    of degree *n* − 1 and that any constant term in the original polynomial drops
    to zero.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到一个多项式的导数是另一个次数为*n* − 1的多项式，并且原始多项式中的任何常数项都变为零。
- en: The Product Rule
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 乘积法则
- en: 'Differentiation of functions multiplied together has its own rule, the *product
    rule*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 函数相乘的微分有它自己的规则，*乘积法则*：
- en: '![Image](Images/169equ02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/169equ02.jpg)'
- en: 'The derivative of the product is the derivative of the first function times
    the second plus the derivative of the second times the first. Consider the following
    examples:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 乘积的导数是第一个函数的导数乘以第二个函数，加上第二个函数的导数乘以第一个函数。考虑以下例子：
- en: '![Image](Images/169equ03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/169equ03.jpg)'
- en: The Quotient Rule
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 商法则
- en: 'The derivative of a function divided by another function follows the *quotient
    rule*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数除以另一个函数的导数遵循*商法则*：
- en: '![Image](Images/169equ04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/169equ04.jpg)'
- en: 'This leads to examples like these:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了像这样的例子：
- en: '![Image](Images/170equ01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/170equ01.jpg)'
- en: The Chain Rule
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 链式法则
- en: The next rule concerns the composition of functions. Two functions are composed
    when the output of one is used as the input to another. The *chain rule* applies
    to function compositions, and it’s of fundamental importance in the training of
    neural networks. The rule is
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个规则涉及函数的复合。当一个函数的输出作为另一个函数的输入时，我们就得到了函数的复合。*链式法则*适用于函数的复合，并且在神经网络的训练中至关重要。该规则是
- en: '![Image](Images/170equ02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/170equ02.jpg)'
- en: We multiply the derivative of the outer function, using *g*(*x*) as the variable,
    by the derivative of the inner function with respect to *x*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将外函数的导数，使用*g*(*x*)作为变量，乘以内函数对*x*的导数。
- en: 'As a first example, consider the function *f*(*x*) = (*x*² + 2*x* + 3)². Is
    this the composition of two functions? It is. Let’s define *f*(*g*) = *g*² and
    *g*(*x*) = *x*² + 2*x* + 3\. Then, we can find *f*(*x*) by replacing every instance
    of *g* in *f*(*g*) with the definition of *g* in terms of *x*: *g*(*x*) = *x*²
    + 2*x* + 3\. This gives'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，考虑函数*f*(*x*) = (*x*² + 2*x* + 3)²。这是两个函数的复合吗？是的。让我们定义*f*(*g*) = *g*²
    和 *g*(*x*) = *x*² + 2*x* + 3。那么，我们可以通过将*f*(*g*)中的每个*g*实例替换为关于*x*的*g*定义来找到*f*(*x*)：*g*(*x*)
    = *x*² + 2*x* + 3。这就得到了
- en: '*f*(*x*) = *g*² = (*x*² + 2*x* + 3)²'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*) = *g*² = (*x*² + 2*x* + 3)²'
- en: which is, naturally, what we started with. To find *f*′(*x*), we first find
    *f*′(*g*), the derivative of *f* with respect to *g*, and then multiply by *g*′(*x*),
    the derivative of *g* with respect to *x*. As a final step, we replace references
    to *g* with its definition in terms of *x*. So, we calculate *f*′(*x*) as
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这自然是我们最初的目标。为了找到*f*′(*x*)，我们首先找到*f*′(*g*)，即*f*对*g*的导数，然后乘以*g*′(*x*)，即*g*对*x*的导数。最后一步，我们用关于*x*的*g*的定义来替换所有关于*g*的引用。所以，我们计算*f*′(*x*)为
- en: '![Image](Images/170equ03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/170equ03.jpg)'
- en: We typically don’t explicitly call out *f*(*g*) and *g*(*x*), but mentally we
    work through the same process. Let’s see some more examples. In this one, we want
    to find
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不会明确指出*f*(*g*)和*g*(*x*)，但在头脑中我们会经过相同的过程。让我们来看一些更多的例子。在这个例子中，我们想找到
- en: '![Image](Images/171equ01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/171equ01.jpg)'
- en: If we use the chain rule, we see that we have *f*(*g*) = 2*g*² + 3 and *g*(*x*)
    = 4*x* − 5\. Therefore, we can write
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用链式法则，我们可以看到我们有*f*(*g*) = 2*g*² + 3 和 *g*(*x*) = 4*x* − 5。 因此，我们可以写出
- en: '![Image](Images/171equ02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/171equ02.jpg)'
- en: where *f*′(*g*) = 2*g* and *g*′(*x*) = 4\. With some practice, we’d mentally
    picture the 4*x* − 5 of *f*(*x*) as its own variable (the substitution of *g*)
    and then remember to multiply the derivative of 4*x* − 5 when done. What if we
    didn’t see the composition? What if we expanded the entire function, *f*(*x*),
    and then took the derivative? We’d better get the answer we found above by using
    the chain rule. Let’s see . . .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*f*′(*g*) = 2*g* 和 *g*′(*x*) = 4。通过一些练习，我们可以在脑海中将4*x* − 5看作是*f*(*x*)的一个变量（即*g*的替代），然后记得在计算完成后乘以4*x*
    − 5的导数。如果我们没能看到复合函数呢？如果我们扩展整个函数*f*(*x*)，然后再求导呢？我们最好能得到使用链式法则得出的答案。让我们来看一看……
- en: '![Image](Images/171equ03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/171equ03.jpg)'
- en: This is what we found above, so our application of the chain rule is correct.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们上面找到的结果，所以我们应用链式法则是正确的。
- en: Let’s look at another example. If ![Image](Images/171equ04.jpg), how should
    we think of calculating the derivative? If we look at the function as ![Image](Images/171equ05.jpg),
    with *u*(*x*) = 1 and *v*(*x*) = 3*x*², we can use the quotient rule and get the
    following.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个新的例子。如果 ![Image](Images/171equ04.jpg)，我们应该如何考虑计算导数？如果我们把这个函数看作 ![Image](Images/171equ05.jpg)，其中
    *u*(*x*) = 1 和 *v*(*x*) = 3*x*²，我们可以使用商法则得到如下结果。
- en: '![Image](Images/172equ01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/172equ01.jpg)'
- en: Here, we used a shorthand notation with *u* and *v* that drops the formal function
    of *x* notation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了 *u* 和 *v* 的简写表示法，省略了 *x* 的正式函数符号。
- en: We can also picture *f*(*x*) as (3*x*²)^(−1). If we think of it this way, we
    can apply the chain rule and power rule to get
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将 *f*(*x*) 看作 (3*x*²)^(−1)。如果我们这样想，我们可以应用链式法则和幂法则得到
- en: '![Image](Images/172equ02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/172equ02.jpg)'
- en: proving that sometimes there’s more than one way to calculate a derivative.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 证明有时计算导数确实不止一种方法。
- en: We presented the chain rule using Lagrange’s notation. Later in the chapter,
    we’ll see it again using Leibniz’s notation. Let’s move on now and present a set
    of rules for trigonometric functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用拉格朗日符号表示了链式法则。在本章稍后的部分，我们将使用莱布尼茨符号再次看到它。现在让我们继续，介绍一组三角函数的法则。
- en: Rules for Trigonometric Functions
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 三角函数的法则
- en: 'The derivatives of the basic trigonometric functions are straightforward:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基本三角函数的导数是直接的：
- en: '![Image](Images/172equ03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/172equ03.jpg)'
- en: 'We can see the last rule is correct if we apply the basic differentiation rules
    to the definition of the tangent:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将基本微分法则应用到正切的定义上，可以看到最后一个法则是正确的：
- en: '![Image](Images/173equ01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/173equ01.jpg)'
- en: Remember that sec *x* = 1/ cos *x* and sin² *x* + cos² *x* = 1.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，sec *x* = 1/ cos *x* 和 sin² *x* + cos² *x* = 1。
- en: 'Let’s look at some examples using the new trig rules. We’ll start with one
    composing a function with a trig function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些使用新三角法则的例子。我们将从一个包含三角函数的复合函数开始：
- en: '![Image](Images/173equ02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/173equ02.jpg)'
- en: We can see that this is a composition of *f*(*g*) = sin(*g*) and *g*(*x*) =
    *x*³ − 3*x*, so we know we can apply the chain rule to get the derivative as *f*′(*g*)*g*′(*x*)
    with *f*′(*g*) = cos(*g*) and *g*′(*x*) = 3*x*² − 3\. The second line simplifies
    the answer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这是一个 *f*(*g*) = sin(*g*) 和 *g*(*x*) = *x*³ − 3*x* 的复合函数，所以我们知道可以应用链式法则得到导数，即
    *f*′(*g*)*g*′(*x*)，其中 *f*′(*g*) = cos(*g*) 和 *g*′(*x*) = 3*x*² − 3。第二行简化了答案。
- en: 'Let’s look at a more complicated composition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更复杂的复合函数：
- en: '![Image](Images/173equ03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/173equ03.jpg)'
- en: This time, we break up the composition as *f*(*g*) = *g*² and *g*(*x*) = sin(*x*³
    − 3*x*). However, *g*(*x*) is itself a composition of *g*(*u*) = sin(*u*) and
    *u*(*x*) = *x*³ − 3*x*, as we had in the previous example. So, the first step
    is to write the following.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们把复合函数拆分为 *f*(*g*) = *g*² 和 *g*(*x*) = sin(*x*³ − 3*x*)。然而，*g*(*x*) 本身是一个复合函数，*g*(*u*)
    = sin(*u*) 和 *u*(*x*) = *x*³ − 3*x*，就像我们在前面的例子中所做的那样。所以，第一步是写出如下式子。
- en: '![Image](Images/174equ01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/174equ01.jpg)'
- en: The first line is the definition of the derivative of a composition. The second
    line substitutes the derivative of *f*(*g*), which is *2g*, and the third line
    replaces *g*(*x*) with sin(*x*³ − 3*x*). Now, we just need to find *g*′(*x*),
    which we can do by using the chain rule a second time with *g*(*u*) = sin *u*
    and *u*(*x*) = *x*³ − 3*x*, as we did for the example above. Doing this gives
    us *g*′(*x*) = cos(*x*³ − 3*x*)(3*x*² − 3), so now we know that *f*′(*x*) is
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是复合函数的导数定义。第二行代入了 *f*(*g*) 的导数，即 *2g*，第三行用 sin(*x*³ − 3*x*) 替换了 *g*(*x*)。现在，我们只需要找到
    *g*′(*x*)，我们可以通过第二次使用链式法则来做到这一点，其中 *g*(*u*) = sin *u* 和 *u*(*x*) = *x*³ − 3*x*，正如我们在上面的例子中所做的那样。这样我们得到
    *g*′(*x*) = cos(*x*³ − 3*x*)(3*x*² − 3)，所以现在我们知道 *f*′(*x*) 是
- en: '![Image](Images/174equ02.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/174equ02.jpg)'
- en: Let’s do one more example. This one will involve more than one trig function.
    We want to see how to calculate
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个更多的例子。这个例子将涉及多个三角函数。我们想看看如何计算
- en: '![Image](Images/174equ03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/174equ03.jpg)'
- en: 'As is often the case when working with trig functions, identities come into
    play. Here, we see that *f*(*x*) can be rewritten:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在处理三角函数时经常出现的那样，恒等式起了作用。在这里，我们看到 *f*(*x*) 可以重写为：
- en: '![Image](Images/174equ04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/174equ04.jpg)'
- en: Now the derivative uses the trig rules, the definition of the secant, the chain
    rule, and the product rule, as shown next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，导数使用了三角函数法则、正割的定义、链式法则和乘积法则，如下所示。
- en: '![Image](Images/175equ01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/175equ01.jpg)'
- en: Let’s move on and look at derivatives of exponentials and logarithms.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看一下指数和对数的导数。
- en: Rules for Exponentials and Logarithms
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指数和对数的规则
- en: 'The derivative of *e**^x*, where *e* is the base of the natural logarithm (*e*
    ≈ 2.718 . . .), is particularly simple. It is itself:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*e^x*的导数，其中*e*是自然对数的底数（*e* ≈ 2.718...），是特别简单的。它就是它本身：'
- en: '![Image](Images/175equ02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/175equ02.jpg)'
- en: When the argument is a function of *x*, this becomes
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当自变量是*x*的函数时，这变成了
- en: '![Image](Images/07equ03.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ03.jpg)'
- en: If the derivative of *e^x* is *e^x*, what is the derivative of *a^x* when *a*
    is a real number other than *e*? To see the answer, we need to remember that *e^x*
    and ln *x*, the natural logarithm using base *e*, are inverse functions, so *e*^(ln*a*)
    = *a*. Then, we can write
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*e^x*的导数是*e^x*，那么当*a*是除*e*以外的实数时，*a^x*的导数是什么？要看答案，我们需要记住*e^x*和自然对数ln *x*，它们是以*e*为底的对数的反函数，所以*e*^(ln*a*)
    = *a*。然后，我们可以写出
- en: '*a^x* = (*e*^(ln *a*))^(*x*) = *e^x*^(ln *a*)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*a^x* = (*e*^(ln *a*))^(*x*) = *e^x*^(ln *a*)'
- en: We know how to find the derivative of *e^x*^(ln*a*) from [Equation 7.3](ch07.xhtml#ch07equ03)
    above. It is
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何从[方程7.3](ch07.xhtml#ch07equ03)中求出*e^x*^(ln*a*)的导数。它是
- en: '![Image](Images/175equ03.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/175equ03.jpg)'
- en: but *e x* ln *a* = *a^x*, so we have
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但是*e x* ln *a* = *a^x*，因此我们有
- en: '![Image](Images/175equ04.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/175equ04.jpg)'
- en: and, in general,
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 并且一般来说，
- en: '![Image](Images/07equ04.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ04.jpg)'
- en: Notice, if *a* = *e*, we have ln(*e*) = 1, and [Equation 7.4](ch07.xhtml#ch07equ04)
    becomes [Equation 7.3](ch07.xhtml#ch07equ03).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果*a* = *e*，我们得到ln(*e*) = 1，并且[方程7.4](ch07.xhtml#ch07equ04)变成[方程7.3](ch07.xhtml#ch07equ03)。
- en: Let’s look now at the derivative of the natural log itself. It is
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看自然对数本身的导数。它是
- en: '![Image](Images/176equ01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/176equ01.jpg)'
- en: When the argument is a function of *x*, this becomes
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当自变量是*x*的函数时，这变成了
- en: '![Image](Images/07equ05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ05.jpg)'
- en: 'You may be wondering: How do we find the derivative of a logarithm that uses
    a base other than *e*? For example, what is the derivative of log[10] *x*? To
    answer this question, we do something similar to what we did above for the derivative
    of *a**^x*. We write the logarithm of *x* for some base, *b*, in terms of the
    natural log, as'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：我们如何求一个以*e*以外的底数为基础的对数的导数？例如，log[10] *x*的导数是什么？为了回答这个问题，我们做的事情与上面求*a^x*的导数类似。我们将*
    x*的对数，底数为*b*，表示为自然对数的形式，如下所示
- en: '![Image](Images/176equ02.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/176equ02.jpg)'
- en: Here, ln *b* is a constant that does not depend on *x*. Also, we now know how
    to find the derivative of ln *x*, so we see that the derivative of log*[b] x*
    must be
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，ln *b*是一个常数，与*x*无关。此外，我们现在知道如何求ln *x*的导数，所以我们看到log*[b] x*的导数必须是
- en: '![Image](Images/176equ03.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/176equ03.jpg)'
- en: for any real number base *b* ≠ 1\. And, still more generally,
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何实数底数*b* ≠ 1。而且，更一般地，
- en: '![Image](Images/07equ06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ06.jpg)'
- en: where, again, we notice that if *b* = *e*, we get ln *e* = 1, and [Equation
    7.6](ch07.xhtml#ch07equ06) becomes [Equation 7.5](ch07.xhtml#ch07equ05).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次注意到，如果*b* = *e*，我们得到ln *e* = 1，并且[方程7.6](ch07.xhtml#ch07equ06)变成[方程7.5](ch07.xhtml#ch07equ05)。
- en: With [Equation 7.6](ch07.xhtml#ch07equ06), we’ve reached the end of our rules
    for derivatives. Let’s now put them together in a single table we can refer back
    to throughout the remainder of the book. The result is [Table 7-1](ch07.xhtml#ch07tab01).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在[方程7.6](ch07.xhtml#ch07equ06)中，我们已经总结了导数的规则。现在让我们将这些规则整理成一个表格，方便在本书剩余部分进行查阅。结果就是[表7-1](ch07.xhtml#ch07tab01)。
- en: We know how to find derivatives now. I would encourage you to look for practice
    sheets with worked-out answers to convince yourself that you understand the rules
    and how to apply them. Let’s move on and look at how we can use derivatives to
    find the minima and maxima of functions. Finding minima is critical to the training
    of neural networks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何求导了。我鼓励你寻找带有解答的练习题，以确保自己理解规则并知道如何应用它们。接下来我们来看一下如何利用导数来求函数的最小值和最大值。找到最小值对神经网络的训练至关重要。
- en: '**Table 7-1:** The Rules of Differentiation'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-1：** 求导规则'
- en: '| **Type** | **Rule** |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **规则** |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Constants | ![Image](Images/177equ01.jpg) |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 常数 | ![Image](Images/177equ01.jpg) |'
- en: '| Powers | ![Image](Images/177equ02.jpg) |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 幂 | ![Image](Images/177equ02.jpg) |'
- en: '| Sums | ![Image](Images/177equ03.jpg) |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 和式 | ![Image](Images/177equ03.jpg) |'
- en: '| Products | ![Image](Images/177equ04.jpg) |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 积 | ![Image](Images/177equ04.jpg) |'
- en: '| Quotients | ![Image](Images/177equ05.jpg) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 商 | ![Image](Images/177equ05.jpg) |'
- en: '| Chain | ![Image](Images/177equ06.jpg) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 链式法则 | ![Image](Images/177equ06.jpg) |'
- en: '| Trigonometry | ![Image](Images/177equ07.jpg) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 三角学 | ![Image](Images/177equ07.jpg) |'
- en: '| Exponents | ![Image](Images/177equ08.jpg) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 指数 | ![Image](Images/177equ08.jpg) |'
- en: '| Logarithms | ![Image](Images/177equ09.jpg) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 对数 | ![Image](Images/177equ09.jpg) |'
- en: Minima and Maxima of Functions
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数的极小值和极大值
- en: Earlier, I defined stationary points as places where the first derivative of
    a function is zero, that is, places where the slope of the tangent line is zero.
    We can use this information to decide if a particular point, call it *x[m]*, is
    a minimum or maximum of the function, *f*(*x*). If *x[m]* is a minimum, it is
    a low point of the function, where *f*(*x[m]*) is smaller than any point to the
    immediate left or right of *f (x[m]*). Similarly, if *f*(*x[m]*) is higher than
    any point to the immediate left or right, *f*(*x[m]*) is a maximum. We collectively
    refer to minima and maxima as *extrema* of *f*(*x*) (singular, *extremum*).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我定义了驻点作为函数的一阶导数为零的地方，即切线的斜率为零的地方。我们可以利用这个信息来判断一个特定的点，记作 *x[m]*，是否是函数 *f*(*x*)
    的极小值或极大值。如果 *x[m]* 是极小值，那么它是函数的最低点，在这个点上 *f*(*x[m]*) 小于 *f*(*x[m]*) 左右相邻点的值。类似地，如果
    *f*(*x[m]*) 高于 *f*(*x[m]*) 左右相邻点的值，那么 *f*(*x[m]*) 是极大值。我们统称极小值和极大值为 *f*(*x*) 的*极值*（单数形式为
    *极值点*）。
- en: 'In terms of the derivative, a *minimum* is a place where the derivative of
    points immediately to the left of *x[m]* are negative, and derivatives of points
    directly to the right of *x[m]* are positive. *Maxima* are the reverse: derivatives
    to the left are positive, and derivatives to the right of *x[m]* are negative.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从导数的角度看，*极小值* 是指 *x[m]* 左侧点的导数为负，而右侧点的导数为正。*极大值* 则相反：左侧的导数为正，右侧的导数为负。
- en: Look back at [Figure 7-1](ch07.xhtml#ch07fig01). There, we have a local maximum
    at about *x* = −0.8 and a local minimum at about *x* = 0.3\. Let’s say that the
    maximum is actually at *x[m]* = −0.8\. This is a maximum because if we look at
    any point *x[p]* in the vicinity of *x[m]*, *f*(*x[p]*) is less than *f*(*x[m]*).
    Likewise, if the minimum is at *x[m]* = 0.3, that’s because any point *x[p]* near
    it has *f*(*x[p]*) > *f*(*x[m]*). If we imagine the tangent line sliding along
    the graph, as it approaches *x* = −0.8, we see that the slope is positive but
    heading toward zero. If we move past *x* = −0.8, the slope is now negative. The
    reverse is true for the minimum at *x* = 0.3\. Tangent lines approaching from
    the left have negative slope, but once they’re past *x* = 0.3, the slope is positive.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 [图7-1](ch07.xhtml#ch07fig01)。在这里，我们大约在 *x* = −0.8 处有一个局部极大值，在 *x* = 0.3 处有一个局部极小值。假设最大值实际上在
    *x[m]* = −0.8 处。这个点是极大值，因为如果我们查看 *x[m]* 附近的任何点 *x[p]*，都会发现 *f*(*x[p]*) 小于 *f*(*x[m]*)。同样地，如果最小值在
    *x[m]* = 0.3 处，那是因为任何接近它的点 *x[p]* 都有 *f*(*x[p]*) > *f*(*x[m]*)。如果我们想象切线沿着图形滑动，当它接近
    *x* = −0.8 时，我们会看到斜率为正，但正朝向零。当我们越过 *x* = −0.8 时，斜率变为负数。最小值 *x* = 0.3 处则相反，左侧的切线斜率为负，但一旦越过
    *x* = 0.3，斜率变为正数。
- en: You’ll read and hear the terms *global* and *local* applied to minima and maxima.
    The global minimum of *f*(*x*) is the lowest of all the minima of *f*(*x*), and
    the global maximum is the highest of all the maxima. Other minima and maxima,
    then, are considered local; they are effective over a particular region, but there
    are other minima that are lower or maxima that are higher. We should note that
    not all functions have minima or maxima. For example, a line, *f*(*x*) = *mx*
    + *b*, has no minima or maxima, because there are no points on the line that satisfy
    the requirements for either.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你会读到和听到术语*全局*和*局部*应用于极小值和极大值。*f*(*x*)的全局极小值是所有极小值中最低的，而全局极大值是所有极大值中最高的。因此，其他极小值和极大值被视为局部的；它们在特定区域有效，但还有更低的极小值或更高的极大值。我们应该注意，并非所有的函数都有极小值或极大值。例如，直线
    *f*(*x*) = *mx* + *b* 就没有极小值或极大值，因为直线上的任何点都不满足极小值或极大值的要求。
- en: So, if the first derivative, *f*′(*x*), is zero, we have a minimum or maximum,
    right? Not so fast. At other stationary points, the first derivative may be zero,
    but the remaining criteria for a minimum or maximum are not met. These points
    are often called *inflection points* or, if in multiple dimensions, *saddle points*.
    For example, consider *y* = *x*³. The first derivative is *y*′ = 3*x*², and the
    second derivative is *y*′′ = 6*x*. Both the first and second derivative are zero
    at *x* = 0\. However, as we can see in [Figure 7-2](ch07.xhtml#ch07fig02), the
    slope is positive to both the immediate left and immediate right of *x* = 0\.
    Therefore, the slope never switches from positive to negative or negative to positive,
    meaning *x* = 0 is not an extremum but is an inflection point.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果一阶导数 *f*′(*x*) 为零，我们就有极小值或极大值，对吧？并不一定。在其他驻点处，尽管一阶导数为零，但判断极小值或极大值的其他条件并不满足。这些点通常被称为*拐点*，或者如果是在多维空间中，则称为*鞍点*。例如，考虑
    *y* = *x*³。其一阶导数为 *y*′ = 3*x*²，二阶导数为 *y*′′ = 6*x*。在 *x* = 0 时，第一和第二导数都为零。然而，正如我们在[图
    7-2](ch07.xhtml#ch07fig02)中看到的，*x* = 0 左右两侧的斜率都是正的。因此，斜率并没有从正变负或从负变正，意味着 *x* =
    0 不是极值点，而是拐点。
- en: '![image](Images/07fig02.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/07fig02.jpg)'
- en: '*Figure 7-2: A graph of y = x³ showing an inflection point at x = 0*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：显示 *x* = 0 处拐点的 *y* = *x*³ 图像*'
- en: Now assume that *x[s]* is a stationary point so that *f*′(*x[s]*) = 0\. If we
    pick two other points, *x[s−∊]* and *x[s+∊]*, one just to the left of *x[s]* and
    the other just to the right, for some very small ∊ (epsilon), we have four possibilities
    for the values of *f*′(*x[s]*[−∊]) and *f*′(*x[s]*[+∊]), shown in [Table 7-2](ch07.xhtml#ch07tab02).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设 *x[s]* 是一个驻点，所以 *f*′(*x[s]*) = 0。如果我们选择另外两个点，*x[s−∊]* 和 *x[s+∊]*，分别位于 *x[s]*
    左右两侧，且 ∊（ε）非常小，我们就可以得到四种可能的 *f*′(*x[s]*[−∊]) 和 *f*′(*x[s]*[+∊]) 的值，如[表 7-2](ch07.xhtml#ch07tab02)所示。
- en: '**Table 7-2:** Identifying Stationary Points'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-2：识别驻点**'
- en: '| **Sign of *f’*(*x[s]* – ∊), *f’*(*x[s]* + ∊)** | **Type of stationary point
    at *x[s]* – ∊ < *x[s]* < *x[s]* + ∊** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| ***f’*(*x[s]* – ∊), *f’*(*x[s]* + ∊) 的符号** | **驻点类型在 *x[s]* – ∊ < *x[s]*
    < *x[s]* + ∊ 时** |'
- en: '| --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| +, – | Maximum |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| +, – | 极大值 |'
- en: '| –, + | Minimum |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| –, + | 极小值 |'
- en: '| +, + | Neither |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| +, + | 既不是极小值也不是极大值 |'
- en: '| –, – | Neither |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| –, – | 既不是极小值也不是极大值 |'
- en: Therefore, the value of the first derivative at a candidate stationary point
    isn’t enough to tell us whether the point represents a minimum or maximum. We
    can look at the region around the candidate point to help us decide. We can also
    look at the value of *f*′′(*x*), the second derivative of *f*(*x*). If *x[s]*
    is a stationary point where *f*′(*x[s]*) = 0, the sign of *f*′′(*x[s]*) can tell
    us about what type of stationary point *x[s]* might be. If *f*′′(*x[s]*) < 0,
    then *x[s]* is a *maximum* of *f*(*x*). If *f*′′(*x[s]*) > 0, *x[s]* is a minimum.
    If *f*′′(*x[s]*) = 0, the second derivative isn’t helpful; we will need to explicitly
    test nearby points with the first derivative.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，候选驻点的一阶导数值不足以告诉我们该点是否为极小值或极大值。我们可以观察候选点周围的区域来帮助我们做出判断。我们还可以查看 *f*′′(*x*)，即
    *f*(*x*) 的二阶导数。如果 *x[s]* 是一个驻点且 *f*′(*x[s]*) = 0，那么 *f*′′(*x[s]*) 的符号可以告诉我们 *x[s]*
    可能是什么类型的驻点。如果 *f*′′(*x[s]*) < 0，那么 *x[s]* 是 *f*(*x*) 的*极大值*。如果 *f*′′(*x[s]*) >
    0，那么 *x[s]* 是极小值。如果 *f*′′(*x[s]*) = 0，二阶导数没有帮助；我们需要用一阶导数显式地测试附近的点。
- en: How do we find candidate stationary points in the first place? For algebraic
    functions, we solve *f*′(*x*) = 0; we find the solution set of all the *x* values
    that make the first derivative of *f*(*x*) zero. We then use the derivative tests
    to decide which are minima, maxima, or inflection points.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先如何找到候选的驻点呢？对于代数函数，我们解 *f*′(*x*) = 0；我们找到所有使得 *f*′(*x*) 为零的 *x* 值的解集。然后，我们使用导数检验来决定这些点是极小值、极大值还是拐点。
- en: 'For many functions, we can find the solutions to *f*′(*x*) = 0 directly. For
    example, if *f*(*x*) = *x*³ − 2*x* + 4, we have *f*′(*x*) = 3*x*² − 2\. If we
    set this equal to zero, *3x*[2] − 2 = 0, and solve using the quadratic formula,
    we find that there are two stationary points: ![Image](Images/179equ01.jpg) and
    ![Image](Images/179equ02.jpg). The second derivative of *f*(*x*) is *f*′′(*x*)
    = 6*x*. The sign of *f*′′(*x*[0]) is negative; therefore, *x*[0] represents a
    maximum. And because the sign of *f*′′(*x*[1]) is positive, *x*[1] is a minimum.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多函数，我们可以直接求解 *f*′(*x*) = 0。例如，如果 *f*(*x*) = *x*³ − 2*x* + 4，我们有 *f*′(*x*)
    = 3*x*² − 2。如果我们将其设为零，*3x*[2] − 2 = 0，并使用二次公式求解，我们发现有两个驻点：![Image](Images/179equ01.jpg)
    和 ![Image](Images/179equ02.jpg)。*f*(*x*) 的二阶导数是 *f*′′(*x*) = 6*x*。*f*′′(*x*[0])
    的符号为负，因此 *x*[0] 代表一个最大值。由于 *f*′′(*x*[1]) 的符号为正，*x*[1] 是一个最小值。
- en: We can see that the derivative tests are correct. The top of [Figure 7-3](ch07.xhtml#ch07fig03)
    shows us a plot of *f*(*x*) = *x*³ − 2*x* + 4, where *x*[0] is a maximum and *x*[1]
    is a minimum.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，导数测试是正确的。[图 7-3](ch07.xhtml#ch07fig03)的上部分显示了 *f*(*x*) = *x*³ − 2*x*
    + 4 的图，其中 *x*[0] 是一个最大值，*x*[1] 是一个最小值。
- en: 'Let’s look at one more example. This time, we have *f*(*x*) = *x*⁵−2*x*³+*x*+2,
    the bottom plot of [Figure 7-3](ch07.xhtml#ch07fig03). We find the first derivative
    and set it to zero:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。这次，我们有 *f*(*x*) = *x*⁵−2*x*³+*x*+2，见[图 7-3](ch07.xhtml#ch07fig03)的底部图。我们找到一阶导数并将其设为零：
- en: '*f*′(*x*) = 5*x*⁴ − 6*x*² + 1 = 0'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*′(*x*) = 5*x*⁴ − 6*x*² + 1 = 0'
- en: If we substitute *u* = *x*², we can solve for the roots of *f*′(*x*) by finding
    the roots of 5*u*²−6*u*+1 and setting those equal to *x*². Doing this gives us
    ![Image](Images/179equ03.jpg) and ![Image](Images/179equ04.jpg), so we have four
    stationary points. To test them, we can use the second derivative test. The second
    derivative is *f*′′(*x*) = 20*x*³ − 12*x*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们代入 *u* = *x*²，我们可以通过找到 5*u*²−6*u*+1 的根并将这些根设置为 *x*²来求解 *f*′(*x*) 的根。这样做得到！[Image](Images/179equ03.jpg)
    和 ![Image](Images/179equ04.jpg)，所以我们有四个驻点。为了测试它们，我们可以使用二阶导数测试。二阶导数是 *f*′′(*x*)
    = 20*x*³ − 12*x*。
- en: Substituting the stationary points into *f*′′ gives
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将驻点代入 *f*′′ 计算得出：
- en: '![Image](Images/180equ01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/180equ01.jpg)'
- en: meaning *x*[0] is a maximum, *x*[1] is a minimum, *x*[2] is another maximum,
    and *x*[3] is a minimum. [Figure 7-3](ch07.xhtml#ch07fig03) again confirms our
    conclusions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着 *x*[0] 是一个最大值，*x*[1] 是一个最小值，*x*[2] 是另一个最大值，*x*[3] 是一个最小值。[图 7-3](ch07.xhtml#ch07fig03)再次验证了我们的结论。
- en: '![image](Images/07fig03.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/07fig03.jpg)'
- en: '*Figure 7-3: Plots of f(x) = x³ – 2x + 4 (top) and x⁵ – 2x³ + x + 2 (bottom),
    with extrema marked*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：* f(x) = x³ – 2x + 4（上）和 x⁵ – 2x³ + x + 2（下）的图，标出极值'
- en: What if we can’t easily find the stationary points of a function? Perhaps we
    can’t solve the function algebraically, or maybe it can’t be expressed in closed
    form, meaning no finite set of operations represents it. A typical calculus course
    isn’t interested in these situations. Still, we need to be, because one way to
    think of a neural network is as a function approximator, one whose function can’t
    be expressed directly. Can we still profitably use our new knowledge of derivatives?
    The answer is yes, we can. We can use the derivative as a pointer to tell us how
    to move closer and closer to the extrema. This is what gradient descent does,
    and we’ll spend quite a bit of time discussing it later in the book.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法轻易找到一个函数的驻点怎么办？也许我们无法代数地求解该函数，或者可能它不能以封闭形式表示，也就是说没有有限的操作集来表示它。典型的微积分课程通常不会关注这些情况。然而，我们需要关注这些问题，因为一种看待神经网络的方式是将其视为一个函数逼近器，它的函数无法直接表示。我们还能利用我们新学到的导数知识吗？答案是肯定的，我们可以。我们可以使用导数作为指示器，告诉我们如何越来越接近极值。这正是梯度下降法的作用，我们将在本书后面花大量时间讨论它。
- en: For now, however, let’s move on and examine functions of more than one variable
    and see what this does to the idea of a derivative.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们继续研究多变量函数，并看看这对导数的概念有什么影响。
- en: Partial Derivatives
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 偏导数
- en: So far, we’ve focused exclusively on functions of one variable, *x*. What happens
    to the notion of differentiation when we have functions of more than one variable,
    say, *f*(*x*, *y*), or *f*(*x*[0], *x*[1], *x*[2], . . . , *x[n]*)? To handle
    these cases, we’ll introduce the idea of a *partial derivative*. Note that, for
    clarity, we’ll use Leibniz’s notation in this section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了一个变量的函数 *x*。当我们处理多个变量的函数时，*f*(*x*, *y*) 或 *f*(*x*[0], *x*[1], *x*[2],
    . . . , *x[n]*)，导数的概念会发生什么变化呢？为了处理这些情况，我们将引入*偏导数*的概念。请注意，为了清晰起见，本节将使用莱布尼茨符号。
- en: '[Equation 7.2](ch07.xhtml#ch07equ02) defined the derivative of *f*(*x*) with
    respect to *x*. If *x* is the only variable, why did we add the extra phrase “with
    respect to *x*”? Now we’ll find out why: the partial derivative with respect to
    one of the variables in the expression is found by holding all the other variables
    fixed. We treat them as if they were constants. Then we say we’re calculating
    the partial derivative with respect to the one not held fixed.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[方程 7.2](ch07.xhtml#ch07equ02) 定义了 *f*(*x*) 对 *x* 的导数。如果 *x* 是唯一的变量，为什么我们要加上“对
    *x* 的偏导数”这句话？现在我们来看看为什么：在这个表达式中，某个变量的偏导数是通过将其他变量视为常数并固定它们来求得的。然后我们说我们正在计算对那个未固定的变量的偏导数。'
- en: 'Let’s look at an example. Let *f*(*x*, *y*) = *xy* + *x*/*y*. Then, we can
    calculate *two* partial derivatives, one with respect to *x* and the other with
    respect to *y*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。设 *f*(*x*, *y*) = *xy* + *x*/*y*。然后，我们可以计算 *两个* 偏导数，一个是对 *x* 的偏导数，另一个是对
    *y* 的偏导数：
- en: '![Image](Images/181equ01.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/181equ01.jpg)'
- en: The rules of differentiation we learned earlier in the chapter still apply.
    Notice the *d* has changed to ∂. This indicates that the function, *f*, is of
    more than one variable. Also, see that when calculating the respective derivatives,
    we held the other variable fixed as if it were a parameter. As far as calculating
    partial derivatives, that’s all there is to it. Let’s see a few more examples
    to help you make the idea more concrete.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章之前学过的微分法则仍然适用。注意，*d* 已经变成了 ∂。这表示函数 *f* 是多变量的。同时，看到在计算相应的导数时，我们将其他变量视作常数参数。这就是偏导数的计算方法。接下来，我们来看一些例子，帮助你更好地理解这个概念。
- en: 'If *f*(*x*, *y*, *z*) = *x*² + *y*² + *z*² + 3*xyz*, we can find three partial
    derivatives:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *f*(*x*, *y*, *z*) = *x*² + *y*² + *z*² + 3*xyz*，我们可以得到三个部分导数：
- en: '![Image](Images/182equ01.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/182equ01.jpg)'
- en: The other two variables are considered constant. This is why, for example, in
    the partial derivative with respect to *x*, *y*² and *z*² become 0, and 3*xyz*
    becomes *3yz*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个变量被视为常数。这就是为什么例如在对 *x* 的部分导数中，*y*² 和 *z*² 变为 0，而 3*xyz* 变为 *3yz*。
- en: 'If ![Image](Images/182equ02.jpg), we have four partial derivatives:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ![Image](Images/182equ02.jpg)，我们有四个部分导数：
- en: '![Image](Images/182equ03.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/182equ03.jpg)'
- en: As a more complex example, consider *f*(*x*, *y*) = *e^(xy)* cos *x* sin *y*.
    The partial derivatives are listed next where we use the product rule in each
    case.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个更复杂的例子，考虑 *f*(*x*, *y*) = *e^(xy)* cos *x* sin *y*。接下来的部分导数列出了我们在每个情况下使用乘积法则。
- en: '![Image](Images/183equ01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/183equ01.jpg)'
- en: Mixed Partial Derivatives
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 混合偏导数
- en: Just as with the derivative of a function of a single variable, we can take
    partial derivatives of a partial derivative. These are known as *mixed partials*.
    Additionally, we have more flexibility because we can change which variable we
    take the next partial derivative with respect to. For example, above, we saw that
    the partial derivative of ![Image](Images/183equ02.jpg) with respect to *z* is
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就像单变量函数的导数一样，我们也可以对部分导数进行偏导数运算。这些称为*混合偏导数*。此外，我们有更多的灵活性，因为我们可以改变对哪一个变量进行下一步偏导数运算。例如，之前我们看到，*z*的部分导数是
- en: '![Image](Images/183equ03.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/183equ03.jpg)'
- en: 'which is still a function of *x*, *y*, *z*, and *t*. Therefore, we can calculate
    second partial derivatives like so:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是一个关于 *x*、*y*、*z* 和 *t* 的函数。因此，我们可以像这样计算第二阶部分导数：
- en: '![Image](Images/183equ04.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/183equ04.jpg)'
- en: 'I’ll explain the notation. We started with the partial derivative of *f* with
    respect to *z*, so we write ∂*f*/∂*z*. Then, from this starting point, we are
    taking other partial derivatives. So, if we want to denote the partial with respect
    to *x*, we think of it this way:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我来解释一下符号。我们从 *f* 对 *z* 的偏导数开始，所以我们写 ∂*f*/∂*z*。然后，从这个起点出发，我们进行其他部分导数运算。所以，如果我们想表示对
    *x* 的部分导数，我们可以这样理解：
- en: '![Image](Images/184equ01.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/184equ01.jpg)'
- en: where we can think of the partial derivative operator “multiplying” the “numerator”
    and “denominator” like a fraction. To be clear, however, these are not fractions;
    the notation has just inherited the flavor of a fraction from its slope origins.
    Still, if the mnemonic is helpful, then it’s helpful. For a second partial derivative,
    the variable it’s taken with respect to is on the left. Also, if the variables
    are the same, an exponent (of sorts) is used, as in ∂²*f*/∂*z*².
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以将偏导数算符看作“乘”上“分子”和“分母”，就像分数一样。然而，需要明确的是，这些并不是分数；符号只是继承了其斜率起源的分数风格。尽管如此，如果这种记忆法对你有帮助，那就有帮助。对于二阶偏导数，与其求导的变量位于左侧。如果变量相同，还会使用某种形式的指数，例如
    ∂²*f*/∂*z*²。
- en: The Chain Rule for Partial Derivatives
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 偏导数的链式法则
- en: To apply the chain rule to partial derivatives, we need to track all the variables.
    So, if we have *f*(*x*, *y*), where both *x* and *y* are functions of other variables,
    *x*(*r*, *s*) and *y*(*r*, *s*), then we can find the partials of *f* with respect
    to *r* and *s* by applying the chain rule for each variable, *x* and *y*. Specifically,
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将链式法则应用于偏导数，我们需要追踪所有变量。因此，如果我们有 *f*(*x*, *y*)，其中 *x* 和 *y* 都是其他变量的函数，*x*(*r*,
    *s*) 和 *y*(*r*, *s*)，那么我们可以通过分别应用链式法则来求出 *f* 对 *r* 和 *s* 的偏导数，具体如下，
- en: '![Image](Images/184equ02.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/184equ02.jpg)'
- en: As an example, let *f*(*x*, *y*) = *x*³+*y*³ with *x*(*r*, *s*) = 3*r*+2*s*
    and *y*(*r*, *s*) = *r*²−3*s*. Now find ∂*f*/∂*r* and ∂*f*/∂*s*. To find these
    partials, we’ll need to calculate six expressions,
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，设 *f*(*x*, *y*) = *x*³+*y*³，且 *x*(*r*, *s*) = 3*r*+2*s* 和 *y*(*r*, *s*)
    = *r*²−3*s*。现在求 ∂*f*/∂*r* 和 ∂*f*/∂*s*。为了求出这些偏导数，我们需要计算六个表达式，
- en: '![Image](Images/184equ03.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/184equ03.jpg)'
- en: so that the desired partials are
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这样所得到的偏导数是
- en: '![Image](Images/185equ01.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/185equ01.jpg)'
- en: Just as with a function of a single variable, the chain rule for functions of
    more than one variable is recursive, such that if *r* and *s* were themselves
    functions of another variable, we could apply the chain rule one more time to
    find the partial of *f* with respect to that variable. For example, if we have
    *x*(*r*, *s*), *y*(*r*, *s*), with *r*(*w*), *s*(*w*), we find ∂*f*/∂*w* by using
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 就像单变量函数一样，多变量函数的链式法则是递归的，因此，如果 *r* 和 *s* 本身是另一个变量的函数，我们可以再应用一次链式法则，找到关于该变量的
    *f* 的偏导数。例如，如果我们有 *x*(*r*, *s*)，*y*(*r*, *s*)，且 *r*(*w*)，*s*(*w*)，我们可以通过以下方式求出
    ∂*f*/∂*w*：
- en: '![Image](Images/185equ02.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/185equ02.jpg)'
- en: In the end, we need to remember that ∂*f*/∂*w* tells us how *f* will change
    for a small change in *w*. We’ll use this fact during gradient descent.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要记住 ∂*f*/∂*w* 告诉我们 *f* 如何因 *w* 的微小变化而变化。我们将在梯度下降中使用这个事实。
- en: This section concerned itself with the mechanical calculation of partial derivatives.
    Let’s move on to explore more of the meaning behind these quantities. This will
    lead us to the idea of a gradient.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本节关注的是偏导数的机械计算。让我们继续探索这些量背后的更多含义。这将引导我们到梯度的概念。
- en: Gradients
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 梯度
- en: In [Chapter 8](ch08.xhtml#ch08), we will dive into the matrix calculus representation
    we use in deep learning. However, before we do that, we will conclude this chapter
    by introducing the idea of a *gradient*. The gradient builds on the derivatives
    we’ve been calculating. In short, the gradient tells us how a function of more
    than one variable is changing and the direction in which it is changing the most.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.xhtml#ch08)中，我们将深入探讨深度学习中使用的矩阵微积分表示法。然而，在此之前，我们将通过引入*梯度*的概念来结束本章内容。梯度建立在我们之前计算的导数基础上。简而言之，梯度告诉我们一个多变量函数如何变化，以及它变化最快的方向。
- en: Calculating the Gradient
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算梯度
- en: If we have *f*(*x*, *y*, *z*), we saw above how to calculate partial derivatives
    with respect to each of the variables. If we interpret the variables as positions
    on coordinate axes, we see that *f* is a function that returns a scalar, a single
    number, for any position in 3D space, (*x*, *y*, *z*). We could even go so far
    as to write *f*(***x***) where ***x*** = (*x*, *y*, *z*) to acknowledge that *f*
    is a function of a vector input. As in previous chapters, we’ll use lowercase
    bold letters to represent vectors, ***x***. Note, some people use ![Image](Images/xbar.jpg)
    to represent vectors.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有 *f*(*x*, *y*, *z*)，我们上面已经展示了如何计算每个变量的偏导数。如果我们将这些变量解释为坐标轴上的位置，我们就能看出 *f*
    是一个返回标量（单一数值）的函数，这个数值适用于三维空间中的任意位置 (*x*, *y*, *z*)。我们甚至可以写作 *f*(***x***)，其中 ***x***
    = (*x*, *y*, *z*) 来表明 *f* 是一个向量输入的函数。像前几章一样，我们将使用加粗小写字母表示向量，***x***。注意，有些人使用 ![Image](Images/xbar.jpg)
    来表示向量。
- en: We can write vectors horizontally, as a row vector, like in the previous paragraph,
    or vertically,
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将向量横向写成行向量，像前一段那样，或者纵向写成列向量，
- en: '![Image](Images/186equ01.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/186equ01.jpg)'
- en: as a column vector, where we’ve also used square brackets instead of parentheses.
    Either notation is acceptable. Unless we’re intentionally sloppy, usually when
    we’re discussing a vector in code, we’ll assume that our vectors are column vectors.
    This means a vector is a matrix with *n* rows and one column, *n* × 1.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在列向量中，我们还使用了方括号而不是圆括号。两种表示法都是可以接受的。除非我们故意草率，通常在讨论代码中的向量时，我们会假设我们的向量是列向量。这意味着向量是一个
    *n* 行一列的矩阵，即 *n* × 1。
- en: A function that accepts a vector input and returns a single number as output
    is known as a *scalar field*. The canonical example of a scalar field is temperature.
    We can measure the temperature at any point in a room. We represent the location
    as a 3D vector relative to some chosen origin point, and the temperature is the
    value at that point, the average kinetic energy of the molecules in that region.
    We can also talk about functions that accept vectors as input and return a vector
    as output. These are known as *vector fields*. In both cases, the field part refers
    to the fact that, over some suitable domain, the function has a value for all
    inputs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接受向量输入并返回单一数值输出的函数称为 *标量场*。标量场的典型例子是温度。我们可以测量房间中任意一点的温度。我们将位置表示为相对于某个选定原点的三维向量，温度则是该点的值，即该区域分子平均动能的大小。我们也可以讨论接受向量作为输入并返回向量作为输出的函数，这些称为
    *矢量场*。在这两种情况下，场一词指的是在某个适当的定义域内，函数对所有输入都有值。
- en: The gradient is the derivative of a function that accepts a vector as input.
    Mathematically, we represent the gradient as a generalization of the idea of partial
    derivatives to *n* dimensions. For example, in 3D space, we can write
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度是接受向量作为输入的函数的导数。从数学上讲，我们将梯度表示为偏导数概念在 *n* 维空间中的推广。例如，在三维空间中，我们可以写作
- en: '![Image](Images/187equ01.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/187equ01.jpg)'
- en: where the gradient operator, ▽, takes the partial derivative of *f* along each
    of its dimensions. The ▽ operator goes by multiple names, like *del*, *grad*,
    or *nabla*. We’ll use ▽ and call it *del* when we’re not simply saying “gradient
    operator.”
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度算子 ▽ 对 *f* 在每个维度上的偏导数进行操作。▽ 算子有多个名字，如 *del*、*grad* 或 *nabla*。当我们不单纯说“梯度算子”时，我们将使用▽并称之为
    *del*。
- en: In general, we can write
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以写作
- en: '![Image](Images/07equ07.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ07.jpg)'
- en: 'Let’s parse [Equation 7.7](ch07.xhtml#ch07equ07). First, we have a function,
    *f*, that accepts a vector input, ***x***, and returns a scalar value. To this
    function, we apply the gradient operator:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解析一下 [方程 7.7](ch07.xhtml#ch07equ07)。首先，我们有一个函数 *f*，它接受一个向量输入 ***x***，并返回一个标量值。对这个函数，我们应用梯度算子：
- en: '![Image](Images/187equ02.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/187equ02.jpg)'
- en: This returns a *vector* (***y***). The gradient operator turns the scalar output
    of *f* into a vector. Let’s spend some time thinking about what this means, what
    it’s telling us about the value of the scalar field at a given position in space.
    (We’ll use *space* when working with vectors, even if there’s no meaningful way
    to visualize the space. An analogy to 3D space is helpful but only goes so far;
    mathematically, the idea of space is more general.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这会返回一个 *向量* (***y***)。梯度算子将 *f* 的标量输出转化为向量。让我们花些时间思考这意味着什么，它告诉我们关于标量场在给定位置的值的信息。（当我们处理向量时，我们会使用
    *空间* 一词，即使没有直观的方式去可视化这个空间。虽然三维空间的类比有帮助，但它的意义有限；在数学上，空间的概念更为广泛。）
- en: As an example, consider a function in 2D space, *f*(***x***) = *f*(*x*, *y*)
    = *x*² + *xy* + *y*². The gradient of *f* is then
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑一个二维空间中的函数，*f*(***x***) = *f*(*x*, *y*) = *x*² + *xy* + *y*²。此时，*f* 的梯度为
- en: '![Image](Images/07equ08.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/07equ08.jpg)'
- en: Since *f* is a scalar field, every point on the 2D plane has a function value.
    This is the output of *f*(***x***) = *f*(*x*, *y*). So, we can plot *f* in 3D
    to show us a surface changing with position. The gradient, however, gives us a
    set of equations. These equations collectively tell us the direction and magnitude
    of the change in the function value at a point, ***x*** = (*x*, *y*).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *f* 是一个标量场，二维平面上的每个点都有一个函数值。这就是 *f*(***x***) = *f*(*x*, *y*) 的输出。因此，我们可以在三维空间中绘制
    *f*，以展示它随位置变化的表面。然而，梯度则给出了一组方程。这些方程集体告诉我们在点 ***x*** = (*x*, *y*) 处，函数值变化的方向和大小。
- en: For a function of a single variable, there’s only one slope at each point. Look
    again at the tangent line of [Figure 7-1](ch07.xhtml#ch07fig01). At the point
    *x[t]*, there’s only one slope. The sign of the derivative at *x[t]* gives the
    direction of the slope, and the absolute value of the derivative gives the magnitude
    (steepness) of the slope.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单变量函数，每个点只有一个斜率。再看看[图7-1](ch07.xhtml#ch07fig01)中的切线。在 *x[t]* 处，只有一个斜率。导数的符号表示斜率的方向，而导数的绝对值表示斜率的大小（陡度）。
- en: 'However, once we change to more than one dimension, we have a bit of a conundrum.
    Instead of only one slope tangent to the function, we now have an infinite number.
    We can imagine a line tangent to the function at some point and that the line
    points in any direction we so desire. The slope of the line tells us how the function
    value is changing in that particular direction. We can find the value of this
    change from the *directional derivative*, the dot product between the gradient
    at the point under consideration and a unit vector in the direction we’re interested
    in:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们转到多维空间，就会遇到一些难题。我们不仅有一个斜率切线，而是有无数个。我们可以想象在某个点上有一条切线，并且这条线可以指向我们希望的任何方向。该线的斜率告诉我们函数值在特定方向上的变化。我们可以通过*方向导数*来计算这种变化，即该点处的梯度与我们感兴趣方向的单位向量之间的点积：
- en: '*D**[u]**f*(***x***) ≡ ***u**• ▽f*(***x***) = ***u**^T*▽*f*(***x***) = ||***u***||||▽*f*(***x***)||
    cos *θ*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*D**[u]**f*(***x***) ≡ ***u**• ▽f*(***x***) = ***u**^T*▽*f*(***x***) = ||***u***||||▽*f*(***x***)||
    cos *θ*'
- en: where ***u*** is a unit vector in a particular direction, ▽*f*(***x***) is the
    gradient of the function at the point ***x***, and *θ* is the angle between them.
    The directional derivative is maximized when cos *θ* is maximized, and this happens
    at *θ* = 0\. Therefore, the direction of the maximum change in a function at any
    point is the gradient at that point.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，***u*** 是一个特定方向上的单位向量，▽*f*(***x***) 是该点 ***x*** 处的函数梯度，*θ* 是它们之间的角度。当 cos
    *θ* 最大时，方向导数也最大，这发生在 *θ* = 0 时。因此，函数在任何点的最大变化方向就是该点的梯度方向。
- en: As an example, let’s pick a point on the 2D plane, say ***x*** = (*x*, *y*)
    = (0.5, −0.4) with *f*(*x*, *y*) = *x*² + *xy* + *y*² from above. Then, the function
    value at ***x*** is *x*² + *xy* + *y*² = (0.5)² + (0.5)(−0.4) + (−0.4)² = 0.21,
    a scalar. However, the gradient at this point is
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们选择二维平面上的一个点，比如 ***x*** = (*x*, *y*) = (0.5, −0.4)，并且根据上面给出的 *f*(*x*,
    *y*) = *x*² + *xy* + *y*²。此时，函数值在 ***x*** 处为 *x*² + *xy* + *y*² = (0.5)² + (0.5)(−0.4)
    + (−0.4)² = 0.21，这是一个标量值。然而，梯度在该点的值为
- en: '![Image](Images/188equ01.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/188equ01.jpg)'
- en: Therefore, we now know that at the point (0.5, −0.4), the direction of the largest
    change in *f* is in the direction (0.6, −0.3) and has a magnitude of ![Image](Images/188equ02.jpg).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道，在点 (0.5, −0.4) 处，*f* 的最大变化方向是 (0.6, −0.3) 方向，且其大小为 ![Image](Images/188equ02.jpg)。
- en: Visualizing the Gradient
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 梯度的可视化
- en: Let’s make all of this less abstract. The top part of [Figure 7-4](ch07.xhtml#ch07fig04)
    shows a plot of *f*(*x*, *y*) = *x*² + *xy* + *y*² at selected points.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这一切变得不那么抽象。[图7-4](ch07.xhtml#ch07fig04)的顶部展示了在选定点上，*f*(*x*, *y*) = *x*²
    + *xy* + *y*² 的图像。
- en: '![image](Images/07fig04.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/07fig04.jpg)'
- en: '*Figure 7-4: A plot of `x`² + `xy` + `y`² (top) and a 2D projection of the
    associated gradient field (bottom)*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：`x`² + `xy` + `y`² 的图像（顶部）以及相关梯度场的二维投影（底部）*'
- en: 'The code to generate this plot is straightforward:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此图的代码很简单：
- en: '[PRE0]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we explicitly loop to generate the set of scatter plot points, `x`, `y`,
    and `z`, to clearly show what’s happening. First, we use NumPy to generate vectors
    of 50 evenly spaced points [−1, 1] in `x` and `y`. Then we set up a double loop
    so that each `x` gets paired with each `y` to calculate the function value, `z`.
    Temporary lists `xx`, `yy`, and `zz` hold the triplets. Finally, we convert the
    lists to NumPy arrays for plotting.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明确地进行循环，生成散点图的`x`、`y`和`z`值，以清楚地展示发生了什么。首先，我们使用NumPy生成50个均匀分布的点，在`x`和`y`上定义范围[−1,
    1]。然后，我们设置双重循环，以便每个`x`与每个`y`配对计算函数值`z`。临时列表`xx`、`yy`和`zz`存储这些三元组。最后，我们将这些列表转换为NumPy数组，以便进行绘图。
- en: The code to generate the scatter plot is
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 生成散点图的代码是
- en: '[PRE1]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We first load the `matplotlib` extension for 3D plotting, and then we set the
    subplot for a 3D projection. The plot itself is made with `ax.scatter`, while
    `ax.view_init` and `plt.draw` rotate the plot to give us a better view of the
    shape of the function before showing it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先加载`matplotlib`扩展库来进行3D绘图，然后设置3D投影的子图。图形本身是通过`ax.scatter`生成的，而`ax.view_init`和`plt.draw`则旋转图形，以便在展示之前给我们更好的函数形状视图。
- en: In the bottom part of [Figure 7-4](ch07.xhtml#ch07fig04), we see a vector plot
    of the gradient field for *x*² + *xy* + *y*². This plot shows the direction and
    relative magnitude of the gradient vector at a grid of points, (*x*, *y*). Recall,
    the gradient is a vector field, so each point on the *xy*-plane has an associated
    vector pointing in the direction of the greatest change in the function value.
    Mentally, we can see how the vector plot relates to the function plot in the top
    part of [Figure 7-4](ch07.xhtml#ch07fig04), where function values near (−1, −1)
    and (1, 1) are changing quickly, whereas for points near (0, 0) they’re changing
    slowly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-4](ch07.xhtml#ch07fig04)的底部，我们可以看到函数*x*² + *xy* + *y*²的梯度场向量图。该图展示了在网格点（*x*，*y*）上梯度向量的方向和相对大小。回想一下，梯度是一个向量场，因此*xy*平面上的每个点都有一个指向函数值变化最快方向的向量。通过视觉上，我们可以看到梯度向量图与[图7-4](ch07.xhtml#ch07fig04)顶部函数图的关系，其中靠近（−1，−1）和（1，1）点的函数值变化很快，而靠近（0，0）点的函数值变化很慢。
- en: The code to generate the vector field plot is
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 生成向量场图的代码是
- en: '[PRE2]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We first define the figure (`fig`) and subplot for 2D (no `projection` keyword).
    Then, we need a grid of points. Above, we looped to get this grid so we could
    understand what needed to be generated. Here, we use NumPy to generate the grid
    for us via `np.meshgrid`. Note, we pass `np.meshgrid` the same `x` and `y` vectors
    we had above to define the domain.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义图形（`fig`）和2D子图（没有`projection`关键字）。然后，我们需要一组点的网格。上面我们通过循环获取这个网格，以便理解需要生成什么内容。在这里，我们通过`np.meshgrid`使用NumPy生成网格。请注意，我们传递给`np.meshgrid`的仍然是上面定义的`x`和`y`向量，用于定义域。
- en: The next two lines are a direct implementation of the gradient of *f*, [Equation
    7.8](ch07.xhtml#ch07equ08). These are the vectors we want to plot, with `dx` and
    `dy` giving us the direction and magnitude, while `xv` and `yv` are the set of
    input points—400 total.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行代码是对*f*的梯度的直接实现，[方程7.8](ch07.xhtml#ch07equ08)。这些是我们希望绘制的向量，其中`dx`和`dy`给出了方向和大小，而`xv`和`yv`是输入点的集合——总共400个。
- en: The plot uses `ax.quiver` (since it plots arrows). The arguments are the grid
    of points (`xv`, `yv`) and associated *x* and *y* values of the vectors at those
    points (`dx`, `dy`). Finally, we ensure the axes are equal (`plt.axis`) to avoid
    warping the vector display, then show the plot.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 该图使用`ax.quiver`（因为它绘制的是箭头）。参数是点的网格（`xv`、`yv`）以及在这些点上的向量的相关*x*和*y*值（`dx`、`dy`）。最后，我们确保坐标轴相等（`plt.axis`），以避免扭曲向量显示，然后展示图形。
- en: We’ll conclude our introduction of gradients here. We’ll see them again throughout
    the remainder of the book, in the notation in [Chapter 8](ch08.xhtml#ch08) and
    the gradient descent discussions of [Chapter 11](ch11.xhtml#ch11).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里结束对梯度的介绍。我们将在本书的剩余部分再次看到它们，包括在[第8章](ch08.xhtml#ch08)的符号表示和[第11章](ch11.xhtml#ch11)的梯度下降讨论中。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced the main concepts of differential calculus. We started
    with the notion of slope and learned the difference between secant and tangent
    lines for a function of a single variable. We then formally defined the derivative
    as the slope of a secant line as it approaches a single point. From there, we
    learned the basic rules of differentiation and saw how to apply them.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了微分学的主要概念。我们从斜率的概念开始，并学习了单变量函数的割线和切线的区别。然后我们正式定义了导数，即割线斜率趋近于一个点时的斜率。从这里开始，我们学习了微分的基本规则，并看到了如何应用它们。
- en: Next, we learned about the minima and maxima of a function and how to find these
    points using derivatives. We then introduced partial derivatives as a way to calculate
    derivatives for functions of more than one variable. Partial derivatives then
    led us to the gradient, which turns a scalar field into a vector field and tells
    us the direction in which the function is changing the most. We calculated an
    example gradient in 2D and saw how to generate plots showing the relationship
    between the function and the gradient. We learned the crucial fact that the gradient
    of a function points in the direction of the maximum change in the function value
    at a point.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了函数的极小值和极大值，以及如何通过导数找到这些点。然后我们引入了偏导数，作为计算多变量函数导数的一种方法。偏导数进一步引导我们进入梯度的概念，梯度将标量场转化为向量场，并告诉我们函数变化最剧烈的方向。我们在二维中计算了一个示例梯度，并展示了如何生成图形，显示函数与梯度之间的关系。我们学到了一个至关重要的事实：函数的梯度指向在某一点上函数值变化最快的方向。
- en: Let’s continue our exploration of the math behind deep learning and move into
    the world of matrix calculus.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索深度学习背后的数学，进入矩阵微积分的世界。
