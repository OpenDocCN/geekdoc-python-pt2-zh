<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="part">
<span class="PartNumber"><span epub:type="pagebreak" title="379" id="Page_379"/>Part IV</span><br/>
<span class="PartTitle">ADVANCED CONCEPTS</span></h1>
</header>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="381" id="Page_381"/>13</span><br/>
<span class="ChapterTitle">Inheritance and Mixins</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">Knowing when to use inheritance is even more important than knowing how. The technique is extraordinarily useful for some situations but fantastically ill-suited for most others, making it one of the more controversial topics in object-oriented programming. Syntactically, inheritance is simple to implement. Logistically, the issues surrounding it are so intricate and nuanced that it deserves a chapter of its own. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="382" id="Page_382"/>Theory Recap: Inheritance</h2>
<p class="BoxBodyFirst"><em>Inheritance</em> allows you to write classes that share common code, and often, a common interface. To understand how it works, recall my blueprint (class) analogy for building houses (objects) from <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>. Say you’ve now designed a three-bedroom variant, instead of the original two-bedroom form. Everything remains the same, but you’ve added a room to the side.</p>
<p>Now, if you improve the original blueprint to upgrade the wiring in the kitchen, you’ll want to see those changes in both the two-bedroom and the three-bedroom blueprints. However, you don’t want that third bedroom to appear on the blueprint for the two-bedroom house.</p>
<p>This is where inheritance comes into play. You can write a class called <code>House3B</code> that inherits from <code>House</code>. The <em>derived</em> class, <code>House3B</code>, is initially identical to the <em>base</em> class, <code>House</code>, but you can extend the derived class to contain additional methods and attributes, or even to <em>override</em> (replace) some of the methods of the base class. This is called an <em>is-a</em> relationship, because a <code>House3B</code> is a <code>House</code>.</p>
<h3>The SOLID Principles</h3>
<p class="BoxBodyFirst">Good object-oriented design follows five rules, represented by the acronym <em>SOLID</em>. These five principles are at the core of deciding when and how to use inheritance.</p>
<p>It’s critical to note, however, that you must apply your own common sense to these principles. It is absolutely possible to follow SOLID to the letter and still write horrendous, unmaintainable code! This doesn’t mean there’s anything wrong with the rules, only that you must apply your own common sense to all design decisions.</p>
<p>Let’s take a look at each of the SOLID principles, individually:</p>
<h4>S: Single-Responsibility Principle</h4>
<p class="BoxBodyFirst">Just like a function, a class should have a single, well-defined responsibility. The difference between the two is that a function <em>does</em> something, while a class <em>is</em> something. My own aphorism here is, “A class is defined by its constituent data.”</p>
<p>The essential point is to avoid writing <em>god classes</em>, which are classes that try to do many different things. God classes invite bugs, complicate maintenance, and obfuscate code structure.</p>
<h4>O: Open-Closed Principle</h4>
<p class="BoxBodyFirst">Once a class is being used in the source code at large, you should avoid changing it in ways that could affect its usage. The client code using your class shouldn’t need to change much, if at all, when you update the class.</p>
<p>Once your code has shipped, changing an object’s <em>interface</em>—the set of public methods and attributes that are used to interact with the class or <span epub:type="pagebreak" title="383" id="Page_383"/>object—should be avoided whenever possible. You must also be cautious about changing methods and attributes that derived classes directly rely upon. Instead, it is better to use inheritance to extend the class.</p>
<h4>L: Liskov Substitution Principle</h4>
<p class="BoxBodyFirst">When using inheritance, you must be able to substitute the derived class for the base class in usage, without changing the desired behavior of the program. This helps prevent surprises and logic errors. If there are significant changes in behavior between the base class and the derived class, you probably shouldn’t use inheritance; the derived class should be an altogether distinct base class, instead.</p>
<p>This does not imply that either the <em>interfaces</em> or the <em>implementations</em> have to be identical, especially in Python. A derived class may need to accept different arguments on methods than the base class does, but the same usage on both the base class and the derived class should produce similar observable behaviors or at least fail explicitly. It’s a bad surprise if a call to a method on a base class returns an integer and an identical call on a derived class returns a string.</p>
<h4>I: Interface Segregation Principle</h4>
<p class="BoxBodyFirst">In designing the interface of your class, think about the needs of the <em>client</em>, the end developer using your class, even if that client is future-you. Do not force the client to know about or work around parts of the interface that they won’t use.</p>
<p>For example, it would be a violation of the interface segregation principle to require every class defining a job for a printer to inherit from a complex <code>PrintScanFaxJob</code> base class. It would be better to write separate <code>PrintJob</code>, <code>ScanJob</code>, and <code>FaxJob</code> base classes, each with an interface fit for the single responsibility of that class.</p>
<h4>D: Dependency Inversion Principle</h4>
<p class="BoxBodyFirst">In object-oriented programming, you’ll have classes that depend on other classes, and this can sometimes result in a lot of repeated code. If you later discover that you need to swap out one of those classes or change implementation details, you’ll have to make the changes in each instance of the repeated code. This makes refactoring painful.</p>
<p>Instead, you can use <em>loose coupling</em>, which is the technique of ensuring that changes to one thing don’t break other areas of your code. For example, rather than class <code>A</code> depending directly on a specific class <code>B</code>, you can write a class that offers a single, abstract interface to serve as a bridge to <code>B</code>, as well as to the related classes <code>C</code> and <code>D</code> (if needed).</p>
<p>This SOLID principle is called the <em>Dependency Inversion Principle</em> because it is the reverse of how many people first think about object-oriented programming. Instead of a derived class inheriting behavior from a base class, both the base class and the derived class rely on an abstract interface.</p>
<p><span epub:type="pagebreak" title="384" id="Page_384"/>One way to achieve loose coupling is through <em>polymorphism</em>, wherein multiple classes with different behaviors and features offer a common interface. In this way, you can write simpler client code, such as a single function that works the same when working with different classes.</p>
<p>Polymorphism is often achieved with inheritance. For example, say you have a <code>Driver</code> class that interacts with a <code>Car</code> class. If you wanted <code>Driver</code> to also work with other vehicles, you could instead write a <code>Vehicle</code> class, from which <code>Car</code>, <code>Motorcycle</code>, <code>Boat</code>, and <code>Starship</code> all inherit. This way, since <code>Driver</code> interacts with <code>Vehicle</code>, it can automatically use any of those vehicle classes. (This approach works because of the Liskov Substitution Principle.)</p>
<p>Another approach to achieving loose coupling is through composition. When designing a user interface (UI), it’s common to have <em>controller</em> classes that provide an abstract interface to trigger common functionality, like displaying dialog boxes or updating the status bar. You don’t want to repeat the UI-controlling code throughout your project because of trivial differences, like different buttons on a dialog box. A controller class abstracts these implementation details out of the rest of your program, making them easier to use, maintain, and refactor. Changes to the implementation for a common functionality only need to occur in one place.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c09-0001">When to Use Inheritance</h2>
<p class="BodyFirst">Inheritance can quickly get out of hand, primarily because it feels clever. You must know when <em>not</em> to use it.</p>
<p>While many languages use inheritance and polymorphism to allow working with many different types of data, Python seldom has such a need. Instead, the language uses duck typing, accepting an argument on the sole merit of its interface. For example, Python does not force you to inherit from a particular base class to make your object an iterator; instead, it recognizes any object with the methods <code>__iter__()</code> and <code>__next__()</code> as an iterator.</p>
<p>Since a class is defined by its constituent data, inheritance should extend this definition. If two or more classes need to contain the same sort of data and provide the same interface, inheritance is likely justified.</p>
<p>For example, the built-in <code>BaseException</code> class contains several common attributes describing all exceptions. Other exceptions, such as <code>ValueError</code> and <code>RuntimeError</code>, contain the same data, justifying their inheriting from <code>BaseException</code>. The base class defines a common interface for interacting with this data. Derived classes extend the interface and attributes to serve their needs as necessary.</p>
<p>If you’re tempted to use inheritance purely to require the implementation of a particular interface in a derived class, or to allow extending a fairly complex interface, consider using <em>abstract base classes</em> instead. I’ll come back to that topic in <span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span>.</p>
<h3 id="h2-500920c09-0001"><span epub:type="pagebreak" title="385" id="Page_385"/>Crimes of Inheritance</h3>
<p class="BodyFirst">Remember: <b><i>decisions about object-oriented design must be based on the data being encapsulated</i></b>. Bearing that rule in mind will help you steer clear of many atrocities commonly seen in object-oriented code. There are many misuses of inheritance, and I’ll cover a few of the most egregious here.</p>
<p>One major inheritance anti-pattern is the <em>god class</em>, which lacks a single clear responsibility and instead stores or provides access to a large set of shared resources. A god class quickly becomes bloated and unmaintainable. It’s better to use class attributes to store anything that needs to be shared mutably between objects. Even a global variable is less of an anti-pattern than a god class.</p>
<p>Another inheritance anti-pattern is the <em>stub class</em>, which is a class that contains little to no data. Stub classes usually show up because the developer’s motivations for inheritance were based on minimizing repeated code, rather than a consideration of the encapsulated data. This creates a plethora of fairly useless objects with unclear purposes. Better ways exist to prevent repeated code, such as using ordinary functions from a module, instead of writing methods or employing composition. Methods, and thus common code, can be shared between classes with techniques like mixins and abstract base classes (<span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span>).</p>
<p>Mixins, which I’ll introduce later in this chapter, are really a form of composition that just happens to leverage Python’s inheritance mechanisms. They aren’t an exception to the rules.</p>
<p>The third reason for atrocious inheritance schemes is the devilish old desire to produce “clever” code. Inheritance is a nifty-looking hammer, but don’t use it to pound in screws. You get better architecture and fewer bugs with composition.</p>
<h2 id="h1-500920c09-0002">Basic Inheritance in Python</h2>
<p class="BodyFirst">Before I dive into the deeper mechanics of inheritance, I want to properly cover the basics.</p>
<p>I’ll use the popular personal task management technique of bullet journaling as an example. In real life, a <em>bullet journal </em>is a physical book made up of one or more <em>collections</em>, which are titled sets of items—bulleted tasks, events, and notes. There are different kinds of collections for different purposes. For an example of inheritance in Python, I’ll write some classes that emulate a bullet journal.</p>
<p>First, I will write a pared-down <code>Collection</code> class, which I’ll inherit from shortly. Remember, a class should be crafted around its data, not its behavior. To keep the example small, I’ll mainly write stub functions, with little to no actual behavior.</p>
<pre><code>class Collection:

    def __init__(self, title, page_start, length=1):
        self.title = title
        self.page_start = page_start
<span epub:type="pagebreak" title="386" id="Page_386"/>        self.page_end = page_start + length – 1
        self.items = []

    def __str__(self):
        return self.title

    def expand(self, by):
        self.page_end += by

    def add_item(self, bullet, note, signifier=None):
        """Adds an item to the monthly log."""</code></pre>
<p class="CodeListingCaption"><a id="listing13-1">Listing 13-1</a>: <em>bullet_journal.py:1</em></p>
<p>By itself, a <code>Collection</code> in a bullet journal only needs three things: a title (<code>self.title</code>), its page numbers (<code>self.page_start</code> and <code>self.page_end</code>), and its items (<code>self.items</code>).</p>
<p>I add a <code>__str__()</code> special instance method for displaying the title when the collection is converted to a string. Implementing this method means I can directly <code>print()</code> a <code>Collection</code> object. I also offer two instance methods: <code>expand()</code>, for adding another page to the collection; and <code>add_item()</code>, for adding an entry to the collection. (I skipped writing the logic for this method for brevity.)</p>
<p>Next, I’ll write a class for the <code>MonthlyLog</code>, which is a specialized type of <code>Collection</code> for tracking events and items in the context of an entire month. It still has to have a title, page numbers, and a set of items. In addition, it needs to store events. Because it <em>extends</em> the data stored, inheritance is a good fit for this situation.</p>
<pre><code>class MonthlyLog(Collection):

    def __init__(self, month, year, page_start, length=2):
        <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> super().__init__( <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> f"{month} {year}", page_start, length)
        self.events = []

    def __str__(self):
        return f"{ <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> self.title} (Monthly Log)"

    def add_event(self, event, date=None):
        """Logs an event for the given date (today by default)."""</code></pre>
<p class="CodeListingCaption"><a id="listing13-2">Listing 13-2</a>: <em>bullet_journal.py:2</em></p>
<p>You will recall from <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> that, when instantiating a derived class, one must explicitly call the initializer of the base class. I do that here with <code>super().__init__()</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. I create the title from <code>month</code> and <code>year</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and I also pass the <code>page_start</code> and <code>length</code> arguments directly. The base class initializer creates these instance attributes, which will be accessible to the <code>MonthlyLog</code> object because it inherits from <code>Collection</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>
<p>I override the <code>__str__()</code> special instance method, this time appending <code>"(Monthly Log)"</code> to the collection title.</p>
<p><span epub:type="pagebreak" title="387" id="Page_387"/>I also define the instance method <code>add_event()</code> specifically for <code>MonthlyLog</code>, for logging events on the calendar view I would store in <code>self.events</code>. I won’t implement this calendar behavior here because it’s pretty involved and also irrelevant to the example.</p>
<p>Here’s one more derived class, <code>FutureLog</code>, which is a collection belonging to one of the next six months:</p>
<pre><code>class FutureLog(Collection):

    def __init__(self, start_month, page_start):
        super().__init__("Future Log", page_start, 4)
        self.start = start_month
        self.months = [start_month]  # TODO: Add other five months.

    def add_item(self, bullet, note, signifier=None, month=None):
        """Adds an item to the future log for the given month."""</code></pre>
<p class="CodeListingCaption"><a id="listing13-3">Listing 13-3</a>: <em>bullet_journal.py:3</em></p>
<p>The <code>FutureLog</code> class also inherits from <code>Collection</code>, with the added attribute <code>self.months</code>, which is a list of months. The class also has a predefined title and length, which I pass to the <code>Collection</code> initializer via <code>super.__init__()</code>, as I did in <code>MonthlyLog</code>.</p>
<p>I also override the instance method <code>add_item()</code> so it now accepts <code>month</code> in addition to the other arguments and so would store the <code>bullet</code>, note, and <code>signifier</code> in the appropriate month in <code>FutureLog</code>. The <code>month</code> parameter is optional, so I don’t violate the Liskov Substitution Principle. As before, I’ve skipped the implementation here to keep things moving along.</p>
<p>I want to briefly mention that, much like how I can check if an object is an instance of a class with <code>isinstance()</code>, I can check if a <em>class</em> is derived from another class with <code>issubclass()</code>:</p>
<pre><code>print(issubclass(FutureLog, Collection))  # prints True</code></pre>
<p>Here’s a very basic usage of my classes, in which I create a <code>FutureLog</code>, a <code>MonthlyLog</code>, and a <code>Collection</code>, adding some items to each:</p>
<pre><code>log = FutureLog('May 2023', 5)
log.add_item('June 2023', '.', 'Clean mechanical keyboard')
print(log)      # prints "Future Log"

monthly = MonthlyLog('April', '2023', 9)
monthly.add_event('Finally learned Python inheritance!')
monthly.add_item('.', 'Email Ben re: coffee meeting')
print(monthly)  # prints "April 2023 (Monthly Log)"

to_read = Collection("Books to Read", 17)
to_read.add_item('.', 'Anne of Avonlea')
print(to_read)  # prints "Books to Read"</code></pre>
<p class="CodeListingCaption"><a id="listing13-4">Listing 13-4</a>: <em>bullet_journal.py:4</em></p>
<p><span epub:type="pagebreak" title="388" id="Page_388"/>Because I wrote so many stub functions, this won’t do much, but the fact that it doesn’t fail at least proves what’s working. (Famous last words, I know.) A derived class has the same attributes and methods as its base class, but it can override any of those and add more.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note	</h2><p class="BoxBodyFirst">On rare occasions, you may encounter technical writings that refer to “new-style classes.” <em>Classes</em>, as they’re known today, were introduced in Python 2.2 and were originally called <em>new-style classes</em>. The far more limited “old” flavor of classes remained available until their removal in Python 3.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c09-0003">Multiple Inheritance</h2>
<p class="BodyFirst">When a class inherits from multiple base classes, it gains all of the attributes and methods of those base classes. This is known as <em>multiple inheritance</em>.</p>
<p>In languages that permit it, multiple inheritance can be a powerful tool, but one that presents many thorny challenges. I’ll therefore discuss how Python gets around many of these obstacles and what issues remain. As with normal inheritance, your decision about whether to use multiple inheritance should be based primarily on the data, rather than just on the desired functionality.</p>
<h3 id="h2-500920c09-0002">Method Resolution Order</h3>
<p class="BodyFirst">One potential issue with multiple inheritance occurs if more than one base class has a method of the same name. Suppose you have a class <code>Calzone</code>, which inherits from both <code>Pizza</code> and <code>Sandwich</code>, and both base classes provide a method<code> __str__()</code>. If I call <code>__str__()</code> on an instance of <code>Calzone</code>, Python must <em>resolve</em> which method to call, meaning it must decide which class’s <code>__str__()</code> method to execute. The rule the language uses to perform this resolution is called the <em>method resolution order</em>.</p>
<p>In this section, I’ll explain how Python determines the method resolution order. To check the method resolution order on a particular class, consult that class’s <code>__mro__</code> attribute.</p>
<p>Here are the classes for my <code>Calzone</code> multiple-inheritance scenario:</p>
<pre><code>class Food:
    def __str__(self):
        return "Yum, what is it?"


class Pizza(Food):
    def __str__(self):
        return "Piiiizzaaaaaa"


class Sandwich(Food):
    def __str__(self):
        return "Mmm, sammich."


<span epub:type="pagebreak" title="389" id="Page_389"/>class Calzone(Pizza, Sandwich):
    pass</code></pre>
<p class="CodeListingCaption"><a id="listing13-5">Listing 13-5</a>: <em>calzone.py:1</em></p>
<p>The classes <code>Pizza</code> and <code>Sandwich</code> are both derived from the <code>Food</code> class. A <code>Calzone</code> is considered both a type of <code>Pizza</code> and a type of <code>Sandwich</code>, so it inherits from both of those classes. The question is, what will be printed when this code runs?</p>
<pre><code>calzone = Calzone()
print(calzone)  # What gets printed??</code></pre>
<p class="CodeListingCaption"><a id="listing13-6">Listing 13-6</a>: <em>calzone.py:2</em></p>
<p>Which version of the <code>__str__()</code> special instance method is <code>Calzone</code> inheriting? Because both <code>Pizza</code> and <code>Sandwich</code> derive from <code>Food</code> and both override the special instance method <code>__str__()</code>, Python must resolve the ambiguity about which class’s implementation of <code>__str__()</code> to use when <code>Calzone.__str__()</code> is called.</p>
<p>The situation above is known in software development as the <em>diamond inheritance problem</em>, or sometimes more ominously as the “Deadly Diamond of Death” (cue scary thunder). It’s one of the nastier method resolution problems that arise with multiple inheritance.</p>
<p>Python solves the diamond inheritance problem with a straightforward approach: a technique known as the <em>C3 Method Resolution Order (C3 MRO)</em>, or more formally, the <em>C3 superclass linearization</em>. (Try saying that 10 times fast.) Python does this automatically, behind the scenes. You need only know how it functions so you can use it to your advantage.</p>
<p>In short, the C3 MRO involves generating a <em>superclass linearization</em>—a list of base classes each class inherits from—following a simple set of rules. The superclass linearization is the order in which classes are searched for the method being called.</p>
<p>To demonstrate this, here’s the linearization list of the first class, <code>Food</code>. In the (non-Python) notation here, <code>L[Food]</code> is the linearization of class <code>Food</code>.</p>
<pre><code>L[Food] = Food, object</code></pre>
<p>Like all classes in Python, <code>Food</code> inherits from the ubiquitous <code>object</code>, so the linearization is <code>Food, object</code>. In this linearization, <code>Food</code> is considered the <em>head</em>, meaning it’s the first item in the linearization list and thus the next class to be considered. The rest of the list is considered the <em>tail</em>. In this case, the tail is just one item: <code>object</code>.</p>
<p>The <code>Pizza</code> class inherits from <code>Food</code>. To do this, Python must look at the linearization of each class <code>Pizza</code> directly inherits from and consider each item in the linearization in turn.</p>
<p>In the following non-Python notation, I’m using <code>merge()</code> to indicate the linearizations from base classes I have yet to consider. By the time I’m done, <code>merge()</code> should be empty. Each linearization is wrapped in curly braces (<code>{ }</code>). <span epub:type="pagebreak" title="390" id="Page_390"/>The class being considered in each step is in <var>italics</var>, and a class that has just been added to the linearization on that step is in <code class="bold">bold</code>.</p>
<p>Using this notation, I can illustrate the linearization process for <code>Pizza</code>. The C3 MRO here will traverse the heads from left to right. In creating the superclass linearization for <code>Pizza</code>, the C3 MRO doesn’t care what methods each class has; it only cares where a class appears in the linearizations it is merging:</p>
<pre><code>L[Pizza] = merge(Pizza, {Food, object})</code></pre>
<p>Python first considers whether to add the leftmost head—the current class, <code>Pizza</code>—to the linearization:</p>
<pre><code>L[Pizza] = merge(<var>Pizza</var>, {Food, object})</code></pre>
<p>If a head class is not in any tail for any linearization being merged, it is added to the new linearization and removed from any other positions. Since <code>Pizza</code> doesn’t appear in any tail, it is added to the linearization.</p>
<p>Next, Python examines the new leftmost head, which is the head of the linearization that needs to be merged:</p>
<pre><code>L[Pizza] = <b>Pizza</b> + merge({<var>Food</var>, object})</code></pre>
<p>The <code>Food</code> class doesn’t appear in any tail, so it is added to the <code>Pizza</code> linearization and removed from the linearization being merged: </p>
<pre><code>L[Pizza] = Pizza + <b>Food</b> + merge({<var>object</var>})</code></pre>
<p>That means <code>object</code> is the new head of the linearization being merged. Python now considers this new head. Since <code>object</code> doesn’t appear in any tail—obviously, since the only linearization being merged no longer has a tail—it can be added to the new linearization:</p>
<pre><code>L[Pizza] = Pizza + Food + <b>object</b></code></pre>
<p>There is nothing left to merge. The linearization for <code>Pizza</code> is <code>Pizza</code>, <code>Food</code>, and <code>object</code>. The <code>Sandwich</code> class evaluates to nearly the same linearization:</p>
<pre><code>L[Sandwich]: Sandwich + Food + object</code></pre>
<p>This gets a little more complicated with multiple inheritance, so let’s consider the <code>Calzone</code> class. I will need to merge the linearizations of <code>Pizza</code> and <code>Sandwich</code>, in that particular order, matching the order of the classes in <code>Calzone</code>’s inheritance list (<a href="#listing13-5" id="listinganchor13-5">Listing 13-5</a>).</p>
<pre><code>L[Calzone] = merge(
    Calzone,
    {Pizza, Food, object},
    {Sandwich, Food, object}
)</code></pre>
<p><span epub:type="pagebreak" title="391" id="Page_391"/>The C3 MRO first inspects the leftmost head, <code>Calzone</code>:</p>
<pre><code>L[Calzone] = merge(
    <var>Calzone</var>,
    {Pizza, Food, object},
    {Sandwich, Food, object}
)</code></pre>
<p>Since <code>Calzone</code> doesn’t appear in any tail, it’s added to the new linearization:</p>
<pre><code>L[Calzone] = <b>Calzone</b> + merge(
    {<var>Pizza</var>, Food, object},
    {Sandwich, Food, object}
)</code></pre>
<p>The new leftmost head to be considered is <code>Pizza</code>. It, too, doesn’t appear in any tail, so it is also added to the new linearization.</p>
<pre><code>L[Calzone] = Calzone + <b>Pizza</b> + merge(
    {<em>Food</em>, object},
    {Sandwich, <var>Food</var>, object}
)</code></pre>
<p>When <code>Pizza</code> is removed from the linearizations being merged, <code>Food</code> becomes the new head of that first linearization. As it’s the new leftmost head, it’s considered next. However, <code>Food</code> also appears in the tail of the linearization headed by <code>Sandwich</code>, so it cannot be added to the linearization yet.</p>
<p>The next head is considered instead:</p>
<pre><code>L[Calzone] = Calzone + Pizza + merge(
    {Food, object},
    {<var>Sandwich</var>, Food, object}
)</code></pre>
<p><code>Sandwich</code> doesn’t appear in any tails, so it can be added to the new linearization and removed from the linearizations being merged. The C3 MRO goes back to considering the leftmost head, which is <code>Food</code>:</p>
<pre><code>L[Calzone] = Calzone + Pizza + <b>Sandwich</b> + merge(
    {<var>Food</var>, object},
    {<var>Food</var>, object}
)</code></pre>
<p>The <code>Food</code> class appears as the head of both linearizations being merged, but not in any tails, so it can be added. It is also removed from all linearizations to be merged.</p>
<pre><code>L[Calzone] = Calzone + Pizza + Sandwich + <b>Food</b> + merge(
    {<var>object</var>},
    {<var>object</var>}
)</code></pre>
<p><span epub:type="pagebreak" title="392" id="Page_392"/>This leaves only <code>object</code> as the head in each linearization to merge. Since it appears only as a head, not as a tail, it can be added.</p>
<pre><code>L[Calzone] = Calzone + Pizza + Sandwich + Food + <b>object</b></code></pre>
<p>There’s the finished superclass linearization for <code>Calzone</code>.</p>
<p>To think of that another way, the linearization process will always look for the next-nearest ancestor of the class being considered, as long as that ancestor is not being inherited by any ancestor not yet considered. For <code>Calzone</code>, the next-nearest ancestor is <code>Pizza</code>, which isn’t inherited by either <code>Sandwich</code> or <code>Food</code>. The <code>Sandwich</code> class is next, and only once both <code>Pizza</code> and <code>Sandwich</code> are accounted for can their common ancestor, <code>Food</code>, be added.</p>
<p>Bearing this in mind and revisiting that question of ambiguity from <a href="#listing13-6" id="listinganchor13-6">Listing 13-6</a>, repeated below, which version of <code>__str__()</code> gets called here?</p>
<pre><code>calzone = Calzone()
print(calzone)  # What gets printed??</code></pre>
<p>In order to determine which base class is providing the <code>__str__()</code> method being called, the superclass linearization for <code>Calzone</code> is consulted. According to the method resolution order, Python would first check <code>Calzone</code> for a <code>__str__()</code> method. Failing to find that, it checks <code>Pizza</code> next and finds the desired method. Sure enough, running this code, the output is as follows:</p>
<pre><code>Piiiizzaaaaaa</code></pre>
<h3 id="h2-500920c09-0003">Ensuring Consistent Method Resolution Order</h3>
<p class="BodyFirst">When using multiple inheritance, the order in which you specify base classes matters. Here, I’ll create a <code>PizzaSandwich</code> class, representing a sandwich where you use slices of pizza instead of bread:</p>
<pre><code>class PizzaSandwich(Sandwich, Pizza):
    pass


class CalzonePizzaSandwich(Calzone, PizzaSandwich):
    pass</code></pre>
<p class="CodeListingCaption"><a id="listing13-7">Listing 13-7</a>: <em>calzone.py:3a</em></p>
<p>The <code>PizzaSandwich</code> class derives from <code>(Sandwich, Pizza)</code>. Recall that <code>Calzone</code> inherits from <code>(Pizza, Sandwich)</code>. Both <code>PizzaSandwich</code> and <code>Calzone</code> have the same base classes, but they inherit from them in different orders. That means that <code>PizzaSandwich</code> has a slightly different linearization than <code>Calzone</code>:</p>
<pre><code>L[PizzaSandwich] = PizzaSandwich + Sandwich + Pizza + Food + object</code></pre>
<p><span epub:type="pagebreak" title="393" id="Page_393"/>If I went overboard and put a calzone between two slices of pizza, I’d get a <code>CalzonePizzaSandwich</code>, which inherits from <code>(Calzone, PizzaSandwich)</code>.</p>
<p>Since <code>Calzone</code> and <code>PizzaSandwich</code> inherit from the same base classes in different orders, what will happen when I try to resolve the <code>__str__()</code> method on <code>CalzonePizzaSandwich</code>? Here’s how the C3 MRO tries to solve that.</p>
<pre><code>L[CalzonePizzaSandwich] = merge(
    <var>CalzonePizzaSandwich</var>,
    {Calzone, Pizza, Sandwich, Food, object},
    {PizzaSandwich, Sandwich, Pizza, Food, object}
)</code></pre>
<p>The leftmost head, <code class="bold">CalzonePizzaSandwich</code>, is considered and added first, since it doesn’t appear in any tails:</p>
<pre><code>L[CalzonePizzaSandwich] = <b>CalzonePizzaSandwich</b> + merge(
    {<var>Calzone</var>, Pizza, Sandwich, Food, object},
    {PizzaSandwich, Sandwich, Pizza, Food, object}
)</code></pre>
<p>The new leftmost head, <code>Calzone</code>, is checked next and added.</p>
<pre><code>L[CalzonePizzaSandwich] = CalzonePizzaSandwich + <b>Calzone</b> + merge(
    {<var>Pizza</var>, Sandwich, Food, object},
    {PizzaSandwich, Sandwich, <var>Pizza</var>, Food, object}
)</code></pre>
<p>Next, the C3 MRO looks at <code>Pizza</code>, the new leftmost head. It skips this class for now, since <code>Pizza</code> appears in the tail of one of the lists.</p>
<p>Next, it considers the next head, <code>PizzaSandwich</code>:</p>
<pre><code>L[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + merge(
    {Pizza, Sandwich, Food, object},
    {<var>PizzaSandwich</var>, Sandwich, Pizza, Food, object}
)</code></pre>
<p>That class can be added, since it’s only a head. After adding <code>PizzaSandwich</code> to the new linearization and removing it from the linearizations to merge, the C3 MRO reconsiders the leftmost head:</p>
<pre><code>L[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + <b>PizzaSandwich</b> + merge(
    {<var>Pizza</var>, Sandwich, Food, object},
    {Sandwich, <var>Pizza</var>, Food, object}
)</code></pre>
<p><code>Pizza</code> is still not eligible to be added, since it’s still in the tail of the second linearization. The head of the next list, <code>Sandwich</code>, is considered next:</p>
<pre><code>L[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + PizzaSandwich + merge(
    {Pizza, <var>Sandwich</var>, Food, object},
    {<var>Sandwich</var>, Pizza, Food, object}
)</code></pre>
<p><span epub:type="pagebreak" title="394" id="Page_394"/>No dice! <code>Sandwich</code> appears in the tail of the first linearization being merged. Python cannot determine the method resolution order here because both heads in the last step, <code>Pizza</code> and <code>Sandwich</code>, are also in the tail of the other linearization. The <code>CalzonePizzaSandwich</code> class would cause Python to raise the following:</p>
<pre><code>TypeError: Cannot create a consistent method resolution</code></pre>
<p>The fix for this particular situation is trivial: I’d need to switch the order of base classes on <code>PizzaSandwich</code>, like this:</p>
<pre><code>class PizzaSandwich(<b>Pizza</b>, <b>Sandwich</b>):
    pass


class CalzonePizzaSandwich(Calzone, PizzaSandwich):
    pass</code></pre>
<p class="CodeListingCaption"><a id="listing13-8">Listing 13-8</a>: <em>calzone.py:3b</em></p>
<p>Now, the linearization of <code>CalzonePizzaSandwich</code> works:</p>
<pre><code>L[CalzonePizzaSandwich] = merge(
    <em>CalzonePizzaSandwich</em>,
    {Calzone, Pizza, Sandwich, Food, object},
    {PizzaSandwich, Pizza, Sandwich, Food, object}
)

L[CalzonePizzaSandwich] = <b>CalzonePizzaSandwich</b> + merge(
    {<var>Calzone</var>, Pizza, Sandwich, Food, object},
    {PizzaSandwich, Pizza, Sandwich, Food, object}
)

L[CalzonePizzaSandwich] = CalzonePizzaSandwich + <b>Calzone</b> + merge(
    {<var>Pizza</var>, Sandwich, Food, object},
    {PizzaSandwich, <var>Pizza</var>, Sandwich, Food, object}
)

L[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + merge(
    {Pizza, Sandwich, Food, object},
    {<var>PizzaSandwich</var>, Pizza, Sandwich, Food, object}
)

L[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + <b>PizzaSandwich</b> + merge(
    {<var>Pizza</var>, Sandwich, Food, object},
    {<var>Pizza</var>, Sandwich, Food, object}
)

L[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + PizzaSandwich + <b>Pizza</b> + merge(
    {<var>Sandwich</var>, Food, object},
    {<var>Sandwich</var>, Food, object}
)

<span epub:type="pagebreak" title="395" id="Page_395"/>L[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + PizzaSandwich + Pizza + <b>Sandwich</b> + merge(
    {<var>Food</var>, object},
    {<var>Food</var>, object}
)

L[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + PizzaSandwich + Pizza + Sandwich + <b>Food</b> + merge(
    {<var>object</var>},
    {<var>object</var>}
)

L[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + PizzaSandwich + Pizza + Sandwich + Food + <b>object</b></code></pre>
<p>When using multiple inheritance, pay close attention to the order in which you specify base classes.</p>
<p>Be aware that the fixes aren’t always trivial, like in my example here. As you can imagine, the problem is made worse when inheriting with three or more classes. I won’t go into these here, but know that understanding the C3 MRO is a major part of the solution. Raymond Hettinger outlines some other techniques and considerations in his article “Python’s super() considered super!” which you can read here: <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" class="LinkURL">https://rhettinger.wordpress.com/2011/05/26/super-considered-super/</a>.</p>
<p>To learn more about the C3 MRO, I recommend the article that accompanied the addition of this MRO to Python 2.3: <a href="https://www.python.org/download/releases/2.3/mro/" class="LinkURL">https://www.python.org/download/releases/2.3/mro/</a>.</p>
<p>Interestingly, aside from Python, only a handful of relatively obscure languages use the C3 MRO by default; Perl 5 and onward offers it optionally. It’s one of the relatively unique advantages of Python.</p>
<h3 id="h2-500920c09-0004">Explicit Resolution Order</h3>
<p class="BodyFirst">While you must always work out the correct inheritance order for your code to run, you can also explicitly call methods on the base classes you want:</p>
<pre><code>class PizzaSandwich(Pizza, Sandwich):
    pass


class CalzonePizzaSandwich(Calzone, PizzaSandwich):
    <b>def __str__(self):</b>
<b>        return Calzone.__str__(self)</b></code></pre>
<p class="CodeListingCaption"><a id="listing13-9">Listing 13-9</a>: <em>calzone.py:3c</em></p>
<p>This will ensure that <code>CalzonePizzaSandwich.__str__()</code> calls <code>Calzone.__str__()</code>, regardless of the method resolution order. You will notice that I have to pass <code>self</code> explicitly, since I’m calling the <code>__str__()</code> instance method on the <code>Calzone</code> class and not on an instance.</p>
<h3 id="h2-500920c09-0005"><span epub:type="pagebreak" title="396" id="Page_396"/>Resolving Base Class in Multiple Inheritance</h3>
<p class="BodyFirst">Another challenge with multiple inheritance is ensuring the initializers for all the base classes are called, with the right arguments passed to each. By default, if a class doesn’t declare its own initializer, Python will use the method resolution order to find one. Otherwise, if an initializer is declared by a derived class, it won’t implicitly call the base class initializers; that must be done explicitly.</p>
<p>Your first thought might be to use <code>super() </code>for this. Indeed, that can work, but only if you have planned it out in advance! The <code>super()</code> function looks at the next class (not the current class) in the superclass linearization for the instance. If you’re not expecting this, it can lead to some freaky and unexpected behavior or errors.</p>
<p>To demonstrate how this should be handled, I’ll add initializers on my first three classes:</p>
<pre><code>class Food:
    def __init__(self, <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> name):
        self.name = name


class Pizza(Food):
    def __init__(self, toppings):
        super().__init__("Pizza")
        self.toppings = toppings


class Sandwich(Food):
    def __init__(self, bread, fillings):
        super().__init__("Sandwich")
        self.bread = bread
        self.fillings = fillings</code></pre>
<p class="CodeListingCaption"><a id="listing13-10">Listing 13-10</a>: <em>make_calzone.py:1a</em></p>
<p>Because <code>Pizza</code> and <code>Sandwich</code> both inherit from <code>Food</code>, they need to call the initializer on <code>Food</code> via <code>super().__init__()</code> and pass the required argument, <code>name</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. All is working as expected.</p>
<p>But <code>Calzone</code> is trickier, since it needs to call <code>__init__()</code> on both <code>Pizza</code> <em>and</em> <code>Sandwich</code>. Calling <code>super()</code> only provides access to the first base class in the method resolution order, so this would still only call the initializer on <code>Pizza</code>:</p>
<pre><code>class Calzone(Pizza, Sandwich):
    def __init__(self, toppings):
        super().__init__(toppings)
        # what about Sandwich.__init__??</code>
<br/><br/>
<code># The usage...
pizza = Pizza(toppings="pepperoni")
sandwich = Sandwich(bread="rye", fillings="swiss")
<span epub:type="pagebreak" title="397" id="Page_397"/>calzone = Calzone("sausage")  # TypeError: __init__() missing 1 required positional argument: 'fillings'</code></pre>
<p class="CodeListingCaption"><a id="listing13-11">Listing 13-11</a>: <em>make_calzone.py:2a</em></p>
<p>The method resolution order on <code>Calzone</code> means that <code>super().__init__()</code> calls the initializer on <code>Pizza</code>. However, the call to <code>super().__init__()</code> in <code>Pizza.__init__()</code> (<a href="#listing13-10" id="listinganchor13-10">Listing 13-10</a>) will now try to call <code>__init__()</code> on the next class in the linearization for the <code>Calzone</code> instance. That is, <code>Pizza</code>’s initializer will now call <code>Sandwich.__init__()</code>. Unfortunately, it will pass the wrong arguments, and the code will throw a rather confusing <code>TypeError</code>, complaining about a missing argument.</p>
<p>The easiest way to handle initializers with multiple inheritance might seem to be to call the <code>Pizza</code> and <code>Sandwich</code> initializers directly and explicitly, like this:</p>
<pre><code>class Calzone(Pizza, Sandwich):
    def __init__(self, toppings):
        <b>Pizza.__init__(self, toppings)</b>
        <b>Sandwich.__init__(self, 'pizza crust', toppings)</b>

# The usage...
pizza = Pizza(toppings="pepperoni")
sandwich = Sandwich(bread="rye", fillings="swiss")
calzone = Calzone("sausage")</code></pre>
<p class="CodeListingCaption"><a id="listing13-12">Listing 13-12</a>: <em>make_calzone.py:2b</em></p>
<p>This doesn’t solve the problem because my use of <code>super()</code> in the base classes still doesn’t play well with the multiple inheritance. Also, if I were to change the base classes, or even just their names, I would also have to rewrite the <code>Calzone</code> initializer.</p>
<p>The preferred method is to still use <code>super()</code> and write the base classes of <code>Sandwich</code> and <code>Pizza</code> to be used <em>cooperatively</em>. This means their initializers, or any other instance methods meant to be used with <code>super()</code>, can work either alone or in the context of multiple inheritance.</p>
<p>For the initializers to work cooperatively, they must not make assumptions about what class will be called with <code>super()</code>. If I initialize <code>Pizza</code> by itself, then <code>super()</code> will refer to <code>Food</code>, but when <code>Pizza.__init__()</code> is accessed via <code>super()</code> from an instance of <code>Calzone</code>, it will refer to <code>Sandwich</code> instead. It all depends on the method resolution order on the instance (rather than the class).</p>
<p>Here, I’ll rewrite <code>Pizza</code> and <code>Sandwich</code> so their initializers are cooperative:</p>
<pre><code>class Food:
    def __init__(self, name):
        self.name = name


class Pizza(Food):
    <b>def __init__(self, toppings, name="Pizza", **kwargs):</b>
<span epub:type="pagebreak" title="398" id="Page_398"/>        <b>super().__init__(name=name, **kwargs)</b>
        self.toppings = toppings


class Sandwich(Food):
    <b>def __init__(self, bread, fillings, name="Sandwich", **kwargs):</b>
        <b>super().__init__(name=name, **kwargs)</b>
        self.bread = bread
        self.fillings = fillings</code></pre>
<p class="CodeListingCaption"><a id="listing13-13">Listing 13-13</a>: <em>make_calzone.py:1b</em></p>
<p>Both initializers will accept keyword arguments and must also accept any other unknown keyword arguments in the variadic parameter, <code>**kwargs</code>. This is important, as it will be impossible to know in advance all the arguments that may be passed up via <code>super().__init__()</code>.</p>
<p>Each initializer explicitly accepts the arguments it needs, and then it sends the rest up the method resolution order via <code>super().__init__()</code>. In both cases, however, I provide a default value for <code>name</code> for when <code>Pizza</code> or <code>Sandwich</code> is instantiated directly. I pass name up to the next initializer, along with all the leftover arguments (if any) in <code>**kwargs</code>.</p>
<p>To use these cooperative initializers, the new <code>Calzone</code> class looks like this:</p>
<pre><code>class Calzone(Pizza, Sandwich):
    def __init__(self, toppings):
        <b>super().__init__(</b>
<b>            toppings=toppings,</b>
<b>            bread='pizza crust',</b>
<b>            fillings=toppings,</b>
<b>            name='Calzone'</b>
<b>        )</b>
<b/>
# The usage...
pizza = Pizza(toppings="pepperoni")
sandwich = Sandwich(bread="rye", fillings="swiss")
calzone = Calzone("sausage")</code></pre>
<p class="CodeListingCaption"><a id="listing13-14">Listing 13-14</a>: <em>make_calzone.py:2</em><em>c</em></p>
<p>I only need one call to <code>super().__init__()</code>, which will point to <code>Pizza.__init__()</code>, due to the method resolution order. However, I pass all the arguments for all the initializers in the superclass linearization. I only use keyword arguments, each with a unique name, to ensure that every initializer can pick up what it needs, regardless of the method resolution order.</p>
<p><code>Pizza.__init__()</code> uses the <code>toppings</code> keyword argument and then passes the rest on. <code>Sandwich.__init__()</code> is next in the method resolution order, and it picks up <code>bread</code> and <code>fillings</code> before passing <code>name</code> up to the next class, <code>Food</code>. More importantly, this code will still work, even if I swap the order of <code>Pizza</code> and <code>Sandwich</code> in the inheritance list for <code>Calzone</code>.</p>
<p>As you can see from just that simple example, designing cooperative base classes requires some careful planning.</p>
<h2 id="h1-500920c09-0004"><span epub:type="pagebreak" title="399" id="Page_399"/>Mixins</h2>
<p class="BodyFirst">One particular upside of multiple inheritance is that you can work with mixins. A <em>mixin</em> is a special type of incomplete (and even invalid) class that contains functionality you might want to add to multiple other classes.</p>
<p>Typically, mixins are used to share common methods for logging, database connections, networking, authentication, and much more. Whenever you need to reuse the same methods (not just functions) across multiple classes, mixins are one of the best ways to accomplish that.</p>
<p>Mixins do use inheritance, but they are the exception to the rule that inheritance decisions should be based on data. Mixins essentially rely on a form of <em>composition</em> that happens to leverage the inheritance mechanism. A mixin seldom has its own attributes; instead, it often relies its on expectations about the attributes and methods of the classes that use it.</p>
<p>In case that’s making your brain hurt a bit, here’s an example.</p>
<p>Say I’m creating an application that relies on a <em>live</em> settings file that can be updated at any time. I’ll write multiple classes that need to grab information from this settings file. (In reality, I’m only writing one such class for the example. You can imagine the rest.)</p>
<p>First, I create the file <em>livesettings.ini</em>, which I’ll store in the same directory as the module I’m about to write. Here are contents of that <em>.ini</em> file:</p>
<pre><code>[MAGIC]
UserName = Jason
MagicNumber = 42</code></pre>
<p class="CodeListingCaption"><a id="listing13-15">Listing 13-15</a>: <em>livesettings.ini</em></p>
<p>Next is my mixin, which contains only the functionality for working with this settings file:</p>
<pre><code>import configparser
from pathlib import Path


class SettingsFileMixin:

    settings_path = Path('livesettings.ini')
    config = configparser.ConfigParser()

    def read_setting(self, key):
        self.config.read(self.settings_path)
        try:
            return self.config[self.settings_section][key]
        except KeyError:
            raise KeyError("Invalid section in settings file.")</code></pre>
<p class="CodeListingCaption"><a id="listing13-16">Listing 13-16</a>: <em>mixins.py:1</em></p>
<p>The class <code>SettingsFileMixin</code> is not a complete class by itself. It lacks an initializer and even refers to an instance attribute it doesn’t have, <code>self.settings_section</code>. This is okay, as mixins are never intended to be used by <span epub:type="pagebreak" title="400" id="Page_400"/>themselves. That missing attribute will need to be provided by any class that uses the mixin.</p>
<p>The mixin does have a couple of class attributes, <code>settings_path</code> and <code>config</code>. Most importantly, it has a <code>read_setting()</code> method, which reads a setting from the <em>.ini</em> file. This method uses the <code>configparser</code> module to read and return a setting specified by <code>key</code> from a particular section: <code>self.settings_section</code>, in the <em>.ini</em> file that the class attribute <code>settings_path</code> points to. If the section, the key, or even the file does not exist, the method will raise a <code>KeyError</code>.</p>
<p>Here’s a class that prints a greeting to the user. I want this class to acquire the username from the <em>livesetting.ini</em> file. To do that, I’ll have this new class use the mixin <code>SettingsFileMixin</code> by inheriting from it:</p>
<pre><code>class Greeter(SettingsFileMixin):

    def __init__(self, greeting):
        self.settings_section = 'MAGIC'
        self.greeting = greeting

    def __str__(self):
        try:
            name = self.read_setting('UserName')
        except KeyError:
            name = "user"
        return f"{self.greeting} {name}!"</code></pre>
<p class="CodeListingCaption"><a id="listing13-17">Listing 13-17</a>: <em>mixins.py:2</em></p>
<p>The <code>Greeter</code> class is initialized with a string to use as the greeting. In the initializer, I define that <code>self.settings_section</code> instance attribute upon which the <code>SettingsFileMixin</code> relies. (In a production-quality mixin, you’d document the necessity for this attribute.)</p>
<p>The <code>__str__()</code> instance method uses the <code>self.read_setting()</code> method from the mixin, as if it had been defined as part of this class.</p>
<p>The usefulness of this becomes obvious if I add another class, such as one that works with the <code>MagicNumber</code> value from <em>livesetting.ini</em>:</p>
<pre><code>class MagicNumberPrinter(SettingsFileMixin):

    def __init__(self, greeting):
        self.settings_section = 'MAGIC'

    def __str__(self):
        try:
            magic_number = self.read_setting('MagicNumber')
        except KeyError:
            magic_number = "unknown"
        return f"The magic number is {magic_number}!"</code></pre>
<p class="CodeListingCaption"><a id="listing13-18">Listing 13-18</a>: <em>mixins.py:3</em></p>
<p>I can have as many classes as I want read from <em>livesetting.ini</em> by having them inherit <code>SettingsFileMixin</code>. That mixin provides the single canonical <span epub:type="pagebreak" title="401" id="Page_401"/>source of that functionality in my project, so any improvements or bug fixes I make to the mixin will be picked up by all the classes that use it.</p>
<p>Here’s an example usage of my <code>Greeter</code> class:</p>
<pre><code>greeter = Greeter("Salutations,")
for i in range(100000):
    print(greeter)</code></pre>
<p class="CodeListingCaption"><a id="listing13-19">Listing 13-19</a>: <em>mixins.py:4</em></p>
<p>I run the <code>print()</code> statement in a loop to demonstrate the effects of changing the <code>livesettings.ini</code> file live.</p>
<p>If you’re trying this out along with the book, open the <em>.ini</em> file before starting the module and change <code>UserName</code> to yours, <em>but do not save the changes yet</em>. Now run the <em>mixins.py</em> module. Once it starts, save the changes to <em>livesettings.ini</em> and observe the change:</p>
<pre><code><var># --snip--</var>
Salutations, Jason!
Salutations, Jason!
Salutations, Jason!
Salutations, Bob!
Salutations, Bob!
Salutations, Bob!
<var># --snip--</var></code></pre>
<h2 id="h1-500920c09-0005">Wrapping Up</h2>
<p class="BodyFirst"><em>Inheritance</em> isn’t quite the dirty word in Python that it sometimes is in other languages. It provides the mechanism for extending classes and enforcing interfaces, resulting in clean and well-structured code in situations that would otherwise lead to spaghetti.</p>
<p>Multiple inheritance works well in Python, thanks to the C3 linearization method resolution order, which sidesteps most of the problems usually presented by the diamond inheritance problem. This, in turn, makes it possible to use mixins to add methods to classes.</p>
<p>With all these shiny, clever-looking tools, it is important to remember that inheritance in its many forms can also easily get out of hand. Before employing any of the tactics in this chapter, you should fully determine what problem you’re trying to solve. At the end of the day, your goal is to create readable, maintainable code. Although inheritance can detract from this when used wrong, if employed judiciously, these techniques can make your code significantly easier to read and maintain.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="403" id="Page_403"/>14</span><br/>
<span class="ChapterTitle">Metaclasses and ABCs</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">Python developers are well familiar with the mantra, “Everything is an object.” When looking at the class system in Python, however, this becomes a paradox: If everything is an object, then what is a class? The seemingly arcane answer to that question unlocks another powerful tool in the Python toolbox: abstract base classes, which are one way of outlining expected behaviors of a type when using duck typing.</p>
<p>In this chapter, I’ll be digging into metaclasses, abstract base classes, and how you can use them to write more maintainable classes.</p>
<h2 id="h1-500920c14-0001"><span epub:type="pagebreak" title="404" id="Page_404"/>Metaclasses</h2>
<p class="BodyFirst">Classes are instances of <em>metaclasses</em>, in the same way that objects are instances of classes. More precisely, every class is an instance of <code>type</code>, and <code>type</code> is a metaclass. Metaclasses allow you to override how a class is created.</p>
<p>To build on the analogy from <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>, just as a house can be constructed from a blueprint, the blueprint can be made from a template. A metaclass is that template. One template can be used to produce many different blueprints, and many different houses can be built from any one of those blueprints.</p>
<p>Before I go any further, a disclaimer is appropriate: you may reasonably go through your entire career without even once using metaclasses directly. By themselves, they’re almost certainly not the solution to whatever problem you’re thinking about using them for. Tim Peters summarizes this warning exceptionally well:</p>
<blockquote class="blockquote">
<p class="Blockquote">[Metaclasses] are deeper magic than 99% of users should ever worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).</p>
</blockquote>
<p>However, understanding metaclasses <em>does</em> help with comprehending other Python features, including abstract base classes. Django, a Python web framework, also makes frequent use of metaclasses internally. Rather than trying to contrive a somewhat believable usage for metaclasses, I’ll stick to the bare minimum to demonstrate how they work.</p><p/>
<h3 id="h2-500920c14-0001">Creating Classes with type</h3>
<p class="BodyFirst">You might have used the <code>type()</code> callable in the past to return the type of a value or object, like this:</p>
<pre><code>print(type("Hello"))    # prints "&lt;class 'str'&gt;"
print(type(123))        # prints "&lt;class 'int'&gt;"

class Thing: pass
print(type(Thing))      # prints "&lt;class 'type'&gt;"

something = Thing()
print(type(something))  # prints "&lt;class '__main__.Thing'&gt;"

print(type(type))       # prints "&lt;class 'type'&gt;"</code></pre>
<p class="CodeListingCaption"><a id="listing14-1">Listing 14-1</a>: <em>types.py</em></p>
<p>The <code>type()</code> callable is actually a metaclass, rather than a function, meaning it can be used to create classes the same way in which a class is used to create instances. Here’s an example of creating a class from <code>type()</code>:</p>
<pre><code><span epub:type="pagebreak" title="405" id="Page_405"/>Food = type('Food', (), {})</code></pre>
<p class="CodeListingCaption"><a id="listing14-2">Listing 14-2</a>: <em>classes_from_type.py:1</em></p>
<p>First, I create a class <code>Food</code>. It inherits from nothing and has no methods or attributes. I’m literally instantiating the metaclass. This is an effective equivalent to the code below:</p>
<pre><code>class Food: pass</code></pre>
<p>(In production code, I’d never define an empty base class, but doing so here is helpful for demonstration purposes.) Next, I’ll instantiate the <code>type</code> metaclass again to create another class, <code>Pizza</code>, which derives from <code>Food</code>:</p>
<pre><code>def __init__(obj, toppings):
    obj.toppings = toppings

Pizza = type( <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> 'Pizza', <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> (Food,), <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> {'name':'pizza', '__init__':__init__})</code></pre>
<p class="CodeListingCaption"><a id="listing14-3">Listing 14-3</a>: <em>classes_from_type.py:2</em></p>
<p>I define the function <code>__init__()</code>, which will be the initializer of the upcoming <code>Pizza</code> class. I named the first parameter <code>obj</code>, since this isn’t <em>actually</em> a member of a class yet.</p>
<p>Next, I create the <code>Pizza</code> class by calling <code>type()</code> and passing the name for the class <span class="CodeAnnotation" aria-label="annotation1">❶</span>, a tuple of base classes <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and a dictionary of methods and class attributes <span class="CodeAnnotation" aria-label="annotation3">❸</span>. This is where I pass the <code>__init__</code> function I wrote.</p>
<p>Here is the functional equivalent of the preceding:</p>
<pre><code>class Pizza(Food):
    name = pizza

    def __init__(self):
        self.toppings = toppings</code></pre>
<p>As you can see, the normal syntax for creating a class is a lot more readable and practical. The benefit of the <code>type</code> metaclass is that you can create classes somewhat dynamically during runtime, although there is seldom a practical reason to do so.</p>
<p>The familiar approach of creating a class with the <code>class</code> keyword is really just syntactic sugar for instantiating the <code>type</code> metaclass. Either way, the end result is the same, as this usage indicates:</p>
<pre><code>print(Pizza.name)                     # 'name' is a class attribute
pizza = Pizza(['sausage', 'garlic'])  # instantiate like normal
print(pizza.toppings)                 # prints "['sausage', 'garlic']"</code></pre>
<p class="CodeListingCaption"><a id="listing14-4">Listing 14-4</a>: <em>classes_from_type.py:2</em></p>
<h3 id="h2-500920c14-0002"><span epub:type="pagebreak" title="406" id="Page_406"/>Custom Metaclasses</h3>
<p class="BodyFirst">You can create a custom metaclass to use as a blueprint for classes. In this way, metaclasses are really only useful for modifying the deep internal behavior of how the language instantiates and works with the class.</p>
<p>A metaclass will often override the <code>__new__()</code> method, as this is the constructor method that governs the creation of the class. Here’s an example of this, via an admittedly pointless metaclass, <code>Gadget</code>:</p>
<pre><code>class Gadget(type):

    def __new__(self, name, bases, namespace):
        print(f"Creating a {name} gadget!")
        return super().__new__(self, name, bases, namespace)</code></pre>
<p class="CodeListingCaption"><a id="listing14-5">Listing 14-5</a>: <em>metaclass.py:1</em></p>
<p>The special method <code>__new__()</code> is what is called behind the scenes when you invoke <code>type()</code> or any other metaclass, such as you saw in <a href="#listing14-2" id="listinganchor14-2">Listing 14-2</a>. The <code>__new__()</code> method here prints a message that the class is being created, and it then invokes the <code>__new__()</code> method from the <code>type</code> base metaclass. This method is expected by the language to accept four arguments.</p>
<p>The first parameter here is <code>self</code>. The <code>__new__()</code> method is written as an instance method on the metaclass, because it is supposed to be a class method on any instance of this metaclass. If you’re feeling lost, read that a few times and let it sink in, remembering that a class is an instance of a metaclass.</p>
<p>Another special method often implemented by metaclasses is <code>__prepare__()</code>. Its purpose is to create the dictionary that stores all the methods and class attributes for the class being created (see <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>). Here’s one for my <code>Gadget</code> metaclass:</p>
<pre><code>    @classmethod
    def __prepare__(cls, name, bases):
        return {'color': 'white'}</code></pre>
<p class="CodeListingCaption"><a id="listing14-6">Listing 14-6</a>: <em>metaclass.py:2</em></p>
<p>The <code>@classmethod</code> decorator indicates that this method belongs to the metaclass itself, not to a class instantiated from this metaclass. (If your brain starts to overheat at this point, I highly recommend eating a scoop of ice cream.) The <code>__prepare__()</code> method also must accept two more parameters, conventionally named <code>name</code> and <code>bases</code>.</p>
<p>The <code>__prepare__()</code> special method returns the dictionary that stores all the attributes and methods on the class. In this case, I’m returning a dictionary that already has a value, so all classes created from the <code>Gadget</code> metaclass will have a <code>color</code> class attribute, with the value <code>'white'</code>.</p>
<p>Otherwise, I would just return an empty dictionary that each class can fill. In fact, I can omit the <code>__prepare__()</code>  method in that case; the <code>type</code> metaclass already provides this method via inheritance, and the Python interpreter is smart about handling a lack of a <code>__prepare__</code> method anyway.</p>
<p><span epub:type="pagebreak" title="407" id="Page_407"/>That’s it for the <code>Gadget</code> metaclass!</p>
<p>Now, I’ll create an ordinary class using the <code>Gadget</code> metaclass:</p>
<pre><code>class Thingamajig(metaclass=Gadget):
    def __init__(self, widget):
        self.widget = widget

    def frob(self):
        print(f"Frobbing {self.widget}.")</code></pre>
<p class="CodeListingCaption"><a id="listing14-7">Listing 14-7</a>: <em>metaclass.py:3</em></p>
<p>The interesting feature here is that I’ve specified the metaclass in the inheritance list using <code>metaclass=Gadget</code>.</p>
<p>The added behavior from the <code>Gadget</code> metaclass is present, as you can see from this example usage:</p>
<pre><code>thing = Thingamajig("button")  # also prints "Creating Thingamajig gadget!"
thing.frob()                   # prints "Frobbing button."

print(Thingamajig.color)       # prints "white"
print(thing.__class__)         # prints "&lt;class '__main__.Thingamajig'&gt;"</code></pre>
<p class="CodeListingCaption"><a id="listing14-8">Listing 14-8</a>: <em>metaclass.py:4</em></p>
<p>The <code>Thingamajig</code> class is instantiated, and I can use it in the same way as any other class, except for certain key differences: instantiating the class prints a message, and <code>Thingamajig</code> has a <code>color</code> class attribute with the default value <code>"white"</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA ALert</h2><p class="BoxBodyFirst">	Multiple inheritance gets tricky when metaclasses are involved. If class <code>C</code> inherits from classes <code>A</code> and <code>B</code>, the metaclass of <code>C</code> must be either the same as or a subclass of the metaclasses of <code>A</code> and <code>B</code>.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Those are the basic principles of creating and using metaclasses. If you are still tracking with me, congratulate yourself, as this is a difficult topic. </p>
<p>You may have observed that I could have implemented those same behaviors with <code>Gadget</code> and <code>Thingamajig</code> via ordinary inheritance, instead of mucking about with a custom metaclass, and you are absolutely right! The trouble is, it’s nearly impossible to think of good uses for metaclasses, so we always wind up contriving some awful example like the above, just to demonstrate <em>how</em> they work. As Tim Peters said, “The people who actually need them know with certainty that they need them, and don’t need an explanation about why.”</p>
<p>In my own work, I once used a metaclass to implement <code>__getattr__()</code> (discussed in <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>), which provides fallback behavior when a class attribute is not defined. A metaclass was undeniably the right solution to the problem. (Then my co-worker Patrick Viafore pointed out that I was also solving the wrong problem. Go figure.)</p>
<p>Metaclasses are also the best way to implement the singleton design pattern in Python, wherein you only ever have one instance of an object in <span epub:type="pagebreak" title="408" id="Page_408"/>existence. However, the singleton is almost never useful in Python, as you can accomplish the same thing with static methods.</p>
<p>There’s a reason Python developers have struggled to come up with viable examples for metaclasses for decades. Metaclasses are something you will seldom, if ever, use directly, except in that rare instance when you instinctively <em>know</em> it’s the right tool for the job.</p>
<h2 id="h1-500920c14-0002">Type Expectations with Duck Typing</h2>
<p class="BodyFirst">Metaclasses do enable the powerful concept of abstract base classes in Python. These allow you to codify expectations for a type in terms of their behaviors. Before I can explain abstract base classes, however, I need to unpack some important principles of duck typing in Python.</p>
<p>In <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>, I asserted that in Python, you do not need to use inheritance in order to write a function that accepts objects of different types as arguments. Python employs duck typing, meaning that instead of caring about an object’s <em>type</em>, it only expects an object to provide the needed interface. When working with duck typing, there are three ways of ensuring a particular argument has the necessary functionality: catching exceptions, testing for attributes, or checking for a particular interface.</p>
<h3 id="h2-500920c14-0003">EAFP: Catching Exceptions</h3>
<p class="BodyFirst">Back in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, I introduced the philosophy of <em>Easier to Ask Forgiveness than Permission (EAFP)</em>, which advocates raising an exception if an argument is missing functionality. This is ideal in situations where you’re providing the arguments yourself in your code, since unhandled exceptions will alert you to the places where the code needs to be improved.</p>
<p>However, it is unwise to use this technique anywhere an unhandled exception might evade detection until a user attempts to use the program in an unexpected or untested way. This consideration is known as <em>fail-fast</em>: a program in an erroneous state should fail as early in the call stack as possible, to reduce the chances of bugs evading detection.</p>
<h3 id="h2-500920c14-0004">LBYL: Checking for Attributes</h3>
<p class="BodyFirst">For more complex or brittle code, it may be better to adhere to the philosophy of <em>Look Before You Leap (LBYL)</em>, in which you check for the functionality you need on an argument or value before proceeding. There are two ways to do this. For situations where you rely on one or two methods on an object, you can use the <code>hasattr()</code> function to check for the methods, or even attributes, that you need.</p>
<p>However, using <code>hasattr()</code> isn’t necessarily as simple or clear as one might hope. Here’s an example of a function that multiplies every third element in the collection passed to it:</p>
<pre><code>def product_of_thirds(sequence):
    if not <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> hasattr(sequence, '__iter__'):
        raise ValueError("Argument must be iterable.")

<span epub:type="pagebreak" title="409" id="Page_409"/>    r = sequence[0]
    for i in sequence[1::3]:
        r *= i
    return r


print(product_of_thirds(range(1, 50)))  # prints '262134882788466688000'
print(product_of_thirds(False))         # raises TypeError</code></pre>
<p class="CodeListingCaption"><a id="listing14-9">Listing 14-9</a>: <em>product_of_thirds.py:1a</em></p>
<p>Right at the top of my <code>product_of_thirds</code> function, I use the <code>hasattr()</code> function to check that the argument sequence has an attribute named <code>__iter__</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This works because all methods are technically attributes. If the argument doesn’t have an attribute by that name, I raise an error.</p>
<p>However, this technique can be subtly wrong. For one thing, not everything that is iterable is necessarily subscriptable, and the code in <a href="#listing14-9" id="listinganchor14-9">Listing 14-9</a> is erroneously assuming that it is. Meanwhile, consider what would happen if I passed an instance of the following class to <code>product_of_thirds()</code>:</p>
<pre><code>class Nonsense:
    def __init__(self):
        self.__iter__ = self</code></pre>
<p>While this example is contrived, there is nothing stopping a developer from hackishly repurposing a name that is assumed to mean something else—yes, nasty things like this show up in real code. The result would cause the <code>hasattr()</code> test to pass anyway. The <code>hasattr()</code> function only checks that the object has <em>some</em> attribute with that name; it doesn’t concern itself with the attribute’s type or interface.</p>
<p>Second, one must be careful about making assumptions regarding what any single function will actually do. Building on my example in <a href="#listing14-9">Listing 14-9</a>, I might add the following logic to try to check that my sequence contained values that could be multiplied by one another:</p>
<pre><code>def product_of_thirds(sequence):
    if <b>(</b>
        not hasattr(sequence, '__iter__')
        <b>or not hasattr(sequence, '__getitem__'</b>
    <b>)</b>:
        raise TypeError("Argument must be iterable.")
<b>    elif not hasattr(sequence[0], '__mul__'):</b>
<b>        raise TypeError("Sequence elements must support multiplication.")</b>

    r = sequence[0]
    for i in sequence[1::3]:
        r *= i
    return r

# <var>--snip--</var>

<span epub:type="pagebreak" title="410" id="Page_410"/>print(product_of_thirds(range(1, 50)))  # prints '262134882788466688000'
<b>print(product_of_thirds("Foobarbaz"))   # raises WRONG TypeError</b></code></pre>
<p class="CodeListingCaption"><a id="listing14-10">Listing 14-10</a>: <em>product_of_thirds.py:1b</em></p>
<p>By checking for <code>__getitem__()</code> along with <code>__iter__()</code>, I know the object has to be subscriptable.</p>
<p>Still another problem is that a string object does implement <code>__mul__()</code> but doesn’t use it as expected. Trying to run this version of the code raises a <code>TypeError</code> when passing a string to <code>product_of_thirds()</code>, but with the wrong message:</p>
<pre><code>TypeError: can't multiply sequence by non-int of type 'str'</code></pre>
<p>Hmm, that’s not the message I specified. The problem is that the test failed to identify that the function logic—namely, multiplication between collection items—makes no sense on a string.</p>
<p>Third, sometimes inheritance itself can create situations where a <code>hasattr()</code> test result can be subtly wrong. For example, if you wanted to ensure that an object implemented the special method <code>__ge__</code> (for the <code>&gt;=</code> operator), you might expect this to work:</p>
<pre><code>if not hasattr(some_obj, '__ge__'):
    raise TypeError</code></pre>
<p>Unfortunately for this test, <code>__ge__</code> is implemented on the base class <code>object</code>, from which all classes inherit, so this test will <em>virtually never fail</em>, even when you expect it should.</p>
<p>All this is to say that while <code>hasattr()</code> is appropriate for extremely simple scenarios, as soon as your expectations about an argument’s type get complicated, you need a better way to look before leaping with duck typing.</p>
<h2 id="h1-500920c14-0003">Abstract Classes</h2>
<p class="BodyFirst">An <em>abstract base class (ABC)</em> allows you to specify particular interfaces that must be implemented by any class that inherits from the ABC. If the derived class does not provide the expected interface, the class instantiation will fail. This provides a more robust means of checking whether an object has particular traits, such as being iterable or subscriptable. In one sense, you can consider an ABC to be a sort of interface contract: the class agrees to implement the methods specified by the ABC.</p>
<p>ABCs cannot be directly instantiated; they can only be inherited by another class. Typically, an ABC only defines what methods are expected, and it leaves the actual implementation of those methods to the derived class. Under some circumstances, an ABC may provide the implementations of some methods.</p>
<p>You can use ABCs to check that your object actually implements an interface. This technique avoids the subtly wrong situation of a method being defined on some distant base class. If an ABC mandates that <code>__str__()</code> <span epub:type="pagebreak" title="411" id="Page_411"/>be implemented, any class that inherits from that ABC will be expected to implement <code>__str__()</code> itself, or else I won’t be able to instantiate the class; it will not matter that <code>object.__str__()</code> is valid.</p>
<p>A word of caution: Python’s concept of abstract base classes should not be compared to virtual and abstract inheritance in C++, Java, or other object-oriented languages. Despite some similarities, they work in fundamentally different ways. Treat them as separate concepts.</p>
<h3 id="h2-500920c14-0005">Built-in ABCs</h3>
<p class="BodyFirst">Python provides an ABC for iterators and a few other common interfaces, but it doesn’t <em>require</em> you to inherit from a particular base class to make your object an iterator. The distinction between an ABC and ordinary inheritance is that an ABC seldom provides the actual functionality—instead, inheriting from the ABC means the class is required to implement the expected methods.</p>
<p>The <code>collections.abc</code> and <code>numbers</code> modules contain nearly all of the built-in abstract classes, with a few others floating around <code>contextlib</code> (for <code>with</code> statements), <code>selectors</code>, and <code>asyncio</code>.</p>
<p>To demonstrate how ABCs fit into an LBYL strategy, I’ll rewrite the example I started in <a href="#listing14-10" id="listinganchor14-10">Listing 14-10</a>. I will use two ABCs to ensure the argument <code>sequence</code> has the interface my <code>product_of_thirds()</code> function expects:</p>
<pre><code><b>from collections.abc import Sequence</b>
<b>from numbers import Complex</b>


def product_of_thirds(sequence):
    <b>if not isinstance(sequence, Sequence):</b>
        raise TypeError("Argument must be a sequence.")
    <b>if not isinstance(sequence[0], Complex):</b>
        raise TypeError("Sequence elements must support multiplication.")

    r = sequence[0]
    for i in sequence[1::3]:
        r *= i
    return r


print(product_of_thirds(range(1, 50)))  # prints '262134882788466688000'
print(product_of_thirds("Foobarbaz"))   # raises TypeError</code></pre>
<p class="CodeListingCaption"><a id="listing14-11">Listing 14-11</a>: <em>product_of_thirds.py:1c</em></p>
<p>The implementation of the <code>product_of_thirds()</code> function expects the argument <code>sequence</code> to be a sequence, and thus an iterable—or else it wouldn’t work with the <code>for</code> loop—and its elements to support multiplication.</p>
<p>I check for an expected interface using <code>isinstance()</code> to find out if the given object is an instance of a class or an instance of a subclass thereof. I ensure that <code>sequence</code> itself is derived from <code>collections.abc.Sequence</code>, meaning it implements the <code>__iter__()</code> instance method.</p>
<p><span epub:type="pagebreak" title="412" id="Page_412"/>I also check the first element of the sequence to ensure it is derived from <code>numeric.Complex</code>, which implies (among other things) that it supports basic numeric operations, including multiplication. Although a string implements the special method <code>__mul__()</code>, it does <em>not</em> derive from <code>numeric.Complex</code>. It couldn’t reasonably do so, since it doesn’t support the rest of the expected mathematical operators and methods. Thus, it fails the test here, as it should.</p>
<h3 id="h2-500920c14-0006">Deriving from ABCs</h3>
<p class="BodyFirst">ABCs are useful for identifying which classes implement a particular interface, so it’s beneficial to consider which ABCs your own classes should inherit from, especially when you are writing a library for other Python developers to use.</p>
<p>To demonstrate this, I’ll rewrite my example from the end of <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> with custom iterable and iterator classes to use ABCs, thereby allowing the interface checking with <code>isinstance()</code>.</p>
<p>First, I need to import a few ABCs from the <code>collections.abc</code> module. I’ll explain why I’m importing these ABCs shortly, when I actually use them.</p>
<pre><code>from collections.abc import Container, Sized, Iterable, Iterator</code></pre>
<p class="CodeListingCaption"><a id="listing14-12">Listing 14-12</a>: <em>cafe_queue_</em><em>abc</em><em>.py:1a</em></p>
<p>Then, I’ll modify my <code>CafeQueue</code> class from the <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> example to use three abstract base classes that promise important components of the class’s functionality:</p>
<pre><code>class CafeQueue(<b>Container, Sized, Iterable</b>):

    def __init__(self):
        self._queue = []
        self._orders = {}
        self._togo = {}

    def __iter__(self):
        return CafeQueueIterator(self)

    def __len__(self):
        return len(self._queue)

    def __contains__(self, customer):
        return (customer in self._queue)

    def add_customer(self, customer, *orders, to_go=True):
        self._queue.append(customer)
        self._orders[customer] = tuple(orders)
        self._togo[customer] = to_go</code></pre>
<p class="CodeListingCaption"><a id="listing14-13">Listing 14-13</a>: <em>cafe_queue_</em><em>abc</em><em>.py:2a</em></p>
<p>I’ve made no changes to the implementation of this class, but I am now inheriting from three different ABCs, all of which come from the <code/><span epub:type="pagebreak" title="413" id="Page_413"/>collections.abc module. I selected these particular ABCs based on the methods I’m implementing on the class. The <code>CafeQueue</code> class implements <code>__iter__()</code> to work with iteration, so I inherit from the ABC <code>Iterable</code>. The <code>Container</code> ABC requires <code>__contains__()</code>, which allows <code>CafeQueue</code> to work with the <code>in</code> operator. The <code>Sized</code> ABC requires <code>__len__()</code>, which means <code>CafeQueue</code> objects work with <code>len()</code>. The functionality is the same as it was in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, but now, there is a reliable way of testing that this class supports iteration, <code>in</code>, and <code>len()</code>.</p>
<p>Because ABCs use metaclasses under the hood, they have the same problems with multiple inheritance that metaclasses do. I don’t have issues here because <code>type(Container)</code>, <code>type(Sized)</code>, and <code>type(Iterable)</code> are all instances of the <code>abc.ABCMeta</code> metaclass, but I wouldn’t be able to simultaneously inherit from an ABC or class that uses an altogether different metaclass.</p>
<p>I can achieve the same effect in a cleaner and simpler way by using the <code>Collection</code> ABC, which itself inherits from <code>Container</code>, <code>Sized</code>, and <code>Iterable</code>. This shortens the import line:</p>
<pre><code>from collections.abc import <b>Collection</b>, Iterator</code></pre>
<p class="CodeListingCaption"><a id="listing14-14">Listing 14-14</a>: <em>cafe_queue_abc.py:1b</em></p>
<p>More importantly, it cleans up the inheritance list on the <code>CafeQueue</code> class:</p>
<pre><code>class CafeQueue(<b>Collection</b>):

    def __init__(self):
        self._queue = []
        self._orders = {}
        self._togo = {}

    def __iter__(self):
        return CafeQueueIterator(self)

    def __len__(self):
        return len(self._queue)

    def __contains__(self, customer):
        return (customer in self._queue)

    def add_customer(self, customer, *orders, to_go=True):
        self._queue.append(customer)
        self._orders[customer] = tuple(orders)
        self._togo[customer] = to_go</code></pre>
<p class="CodeListingCaption"><a id="listing14-15">Listing 14-15</a>: <em>cafe_queue_abc.py:2b</em></p>
<p>This version is effectively identical to the previous one in <a href="#listing14-13" id="listinganchor14-13">Listing 14-13</a>.</p>
<p>Next, I adjust my <code>CafeQueueIterator</code> class from <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> to use the <code>Iterator</code> ABC:</p>
<pre><code>class CafeQueueIterator(<b>Iterator</b>):

    def __init__(self, iterable):
<span epub:type="pagebreak" title="414" id="Page_414"/>        self._iterable = iterable
        self._position = 0

    def __next__(self):
        if self._position &gt;= len(self._iterable):
            raise StopIteration

        customer = self._iterable._queue[self._position]
        orders = self._iterable._orders[customer]
        togo = self._iterable._togo[customer]

        self._position += 1

        return (customer, orders, togo)

    def __iter__(self):
        return self</code></pre>
<p class="CodeListingCaption"><a id="listing14-16">Listing 14-16</a>: <em>cafe_queue_</em><em>abc</em><em>.py:3</em></p>
<p>Once again, I haven’t changed the implementation from the version in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, except to inherit from <code>Iterator</code>. That ABC requires the <code>__next__()</code> method and inherits from <code>Iterable</code>, thereby also requiring <code>__iter__()</code>.</p>
<p>Here’s a revised usage of my <code>CafeQueue</code> class, to demonstrate ABCs at work:</p>
<pre><code>def serve_customers(queue):
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> if not isinstance(queue, Collection):
        raise TypeError("serve_next() requires a collection.")

    if not len(queue):
        print("Queue is empty.")
        return

    def brew(order):
        print(f"(Making {order}...)")

    for customer, orders, to_go in queue:
        for order in orders: brew(order)
        if to_go:
            print(f"Order for {customer}!")
        else:
            print(f"(Takes order to {customer})")


queue = CafeQueue()
queue.add_customer('Raquel', 'double macchiato', to_go=False)
queue.add_customer('Naomi', 'large mocha, skim')
queue.add_customer('Anmol', 'mango lassi')

serve_customers(queue)</code></pre>
<p class="CodeListingCaption"><a id="listing14-17">Listing 14-17</a>: <em>cafe_queue_</em><em>abc</em><em>.py:4a</em></p>
<p><span epub:type="pagebreak" title="415" id="Page_415"/>In the <code>serve_customers()</code> function, I check that the <code>queue</code> argument is an instance of a class inheriting from the <code>Collection</code> ABC before proceeding <span class="CodeAnnotation" aria-label="annotation1">❶</span>, as the function logic is relying on both <code>len()</code> and iteration.</p>
<p>Running this code produces what you’d expect:</p>
<pre><code>(Making double macchiato...)
(Takes order to Raquel)
(Making large mocha, skim...)
Order for Naomi!
(Making mango lassi...)
Order for Anmol!</code></pre>
<p>Although there are no functional changes to the example, ABCs contribute two advantages. First, anyone using my classes can check their functionality through the standard library ABCs. Second, and perhaps more important, it’s an insurance policy against one of these special methods the code relies on being accidentally removed from a class.</p>
<h3 id="h2-500920c14-0007">Implementing Custom ABCs</h3>
<p class="BodyFirst">There often isn’t a preexisting abstract base class for everything you need, so you’ll need to write your own. You can make a class an ABC by having it inherit from <code>abc.ABC</code> or another ABC <em>and</em> giving it at least one method marked with the <code>@abstractmethod</code> decorator.</p>
<p>For my <code>CafeQueue</code> example, I’ll create a custom ABC to define a queue of customers. The rest of my code will expect a queue of customers to have certain methods and behaviors, so I’ll use the ABC to codify those expectations up front:</p>
<pre><code>from collections.abc import Collection, Iterator
<b>from abc import abstractmethod</b>


<b>class CustomerQueue(Collection):</b>

<b>    @abstractmethod</b>
<b>    def add_customer(self, customer): pass</b>

<b>    @property</b>
<b>    @abstractmethod</b>
<b>    def first(self): pass</b></code></pre>
<p class="CodeListingCaption"><a id="listing14-18">Listing 14-18</a>: <em>cafe_queue_abc.py:1c</em></p>
<p>I make the <code>CustomerQueue</code> class inherit from <code>Collection</code> so its own derived classes must implement <code>__iter__()</code>, <code>__len__()</code>, and <code>__contains__()</code>, and so <code>CustomerQueue</code> indirectly inherits from <code>ABC</code> via <code>Collection</code>. Then, I add two additional abstract methods—<code>add_customer()</code> and the property <code>first()</code>—each marked with the <code>@abstractmethod</code> decorator, which I imported from <code>abc</code>. Any class that inherits from <code>CustomerQueue</code> must implement that property and those methods.</p>
<p><span epub:type="pagebreak" title="416" id="Page_416"/>Before Python 3.3, if you wanted to require some types of methods in an abstract class, you had to use special decorators like <code>@abstractproperty</code>, <code>@abstractclassmethod</code>, and <code>@abstractstaticmethod</code>. You’ll still see code like that, but thankfully, that’s no longer necessary; instead, as long as <code>@abstractmethod</code> is the innermost decorator, you can use the usual method decorators, like <code>@property</code>.</p>
<p>While I can add abstract methods to require derived classes to have particular instance methods, class methods, static methods, and even properties, I <em>cannot</em> require derived classes to have particular instance attributes. ABCs are intended to specify <em>interfaces</em>, not data.</p>
<p>None of my abstract methods need implementations here, although I could write default implementations to be explicitly called via <code>super()</code>.</p>
<p>I can now update my <code>CafeQueue</code> class to inherit from this new <code>CustomerQueue</code> ABC:</p>
<pre><code>class CafeQueue(<b>CustomerQueue</b>):

    def __init__(self):
        self._queue = []
        self._orders = {}
        self._togo = {}

    def __iter__(self):
        return CafeQueueIterator(self)

    def __len__(self):
        return len(self._queue)

    def __contains__(self, customer):
        return (customer in self._queue)

    def add_customer(self, customer, *orders, to_go=True):
        self._queue.append(customer)
        self._orders[customer] = tuple(orders)
        self._togo[customer] = to_go

<b>    @property</b>
<b>    def first(self):</b>
<b>        return self._queue[0]</b></code></pre>
<p class="CodeListingCaption"><a id="listing14-19">Listing 14-19</a>: <em>cafe_queue_abc.py:2c</em></p>
<p>I need to add the required property, <code>first()</code>, which, in my case, I use to peek at the name of the first person in line. If I don’t add this property, running the code would produce an error like this:</p>
<pre><code>TypeError: Can't instantiate abstract class CafeQueue with abstract method first</code></pre>
<p>Since I have implemented <code>first()</code>, I don’t need to worry about that error occurring.</p>
<p><span epub:type="pagebreak" title="417" id="Page_417"/>I’ll also update the <code>serve_customers()</code> function to require a <code>CustomerQueue</code>, rather than a <code>Collection</code>. I can do this here because <code>CustomerQueue</code> inherits from <code>Collection</code>, so any class that inherits from <code>CustomerQueue</code> will also satisfy the interface of <code>Collection</code>.</p>
<pre><code>def serve_customers(queue):
    if not isinstance(queue, <b>CustomerQueue</b>):
        raise TypeError(<b>"serve_next() requires a customer queue."</b>)

    if not len(queue):
        print("Queue is empty.")
        return

    def brew(order):
        print(f"(Making {order}...)")

    for customer, orders, to_go in queue:
        for order in orders: brew(order)
        if to_go:
            print(f"Order for {customer}!")
        else:
            print(f"(Takes order to {customer})")


queue = CafeQueue()
queue.add_customer('Raquel', 'double macchiato', to_go=False)
queue.add_customer('Naomi', 'large mocha, skim')
queue.add_customer('Anmol', 'mango lassi')

<b>print(f"The first person in line is {queue.first}.")</b>
serve_customers(queue)</code></pre>
<p class="CodeListingCaption"><a id="listing14-20">Listing 14-20</a>: <em>cafe_queue_</em><em>abc</em><em>.py:4b</em></p>
<p>In addition to testing whether <code>queue</code> is an instance of a class that inherits from <code>CustomerQueue</code>, I use the <code>queue.first</code> property toward the end, to test it out.</p>
<p>Running that code still produces the expected output:</p>
<pre><code>The first person in line is Raquel.
(Making double macchiato...)
(Takes order to Raquel)
(Making large mocha, skim...)
Order for Naomi!
(Making mango lassi...)
Order for Anmol!</code></pre>
<p>Aside from being able to check who is first in line, the functionality here hasn’t changed from prior versions of this example. As before, using ABCs here ensures that <code>CafeQueue</code> implements all the functionality the rest of my code depends on. If part of the expected interface is missing, the code will fail right away, instead of mid-execution.</p>
<h2 id="h1-500920c14-0004"><span epub:type="pagebreak" title="418" id="Page_418"/>Virtual Subclasses</h2>
<p class="BodyFirst">As you start relying on custom abstract classes, you may reach a conundrum: you might require an argument to be an instance of a class derived from your custom ABC, and yet, you may want to somehow allow instances of certain preexisting classes to be used as well. For example, you cannot modify the built-in <code>list</code> class just to report that it satisfies some interface you specified in a custom ABC.</p>
<p><em>Virtual subclassing</em> allows you to cause an ABC to report certain classes as being derived, even if they aren’t. This allows you to indicate particular built-in and third-party classes as fulfilling the interface outlined by one of your custom ABCs.</p>
<p>This works because calling <code>isinstance(Derived, Base)</code> or <code>issubclass(Derived, Base)</code> first checks for and calls the method <code>Base.__instancecheck__(Derived)</code> or <code>Base._subclasscheck__(Derived)</code>, respectively. Otherwise, <code>Derived.__isinstance__(Base)</code> or <code>Derived.__issubclass__(Base)</code> is called.</p>
<p>A critical limitation of virtual subclassing is that you’re bypassing the interface enforcement and instead reporting that <em>you</em> have verified that a particular class satisfies the interface. You can make any class a virtual subclass of ABC, but it’s entirely your own responsibility to ensure it has the expected interface.</p>
<h3 id="h2-500920c14-0008">Setting Up the Example</h3>
<p class="BodyFirst">I’ll first create an example of a custom ABC that doesn’t use virtual subclassing, but where virtual subclassing can be helpful. Say that I’m creating a library of super-useful functions all related to palindromes, and I want to ensure I’m working with objects that implement certain methods: specifically, <code>__reversed__()</code>, <code>__iter__()</code>, and <code>__str__()</code>. I don’t want to require any further methods, since I’ll write a custom class for working with a sentence palindrome, which is more complex than a word palindrome. Unfortunately, there isn’t a built-in ABC that supports all those methods and <em>only</em> those.</p>
<p>There are different forms of palindromes, and I want to be able to interact with them all in the same way. This is why I create the custom <code>Palindromable</code> ABC:</p>
<pre><code>from abc import ABC, abstractmethod


class Palindromable(ABC):

    @abstractmethod
    def __reversed__(self): pass

    @abstractmethod
    def __iter__(self): pass

    @abstractmethod
    def __str__(self): pass</code></pre>
<p class="CodeListingCaption"><a id="listing14-21">Listing 14-21</a>: <em>palindrome_check.py:1</em></p>
<p><span epub:type="pagebreak" title="419" id="Page_419"/>The <code>Palindromable</code> ABC class doesn’t expand on any other ABC, so I only inherit from <code>abc.ABC</code>. With this ABC, I require the three methods I mentioned.</p>
<p>I now build a special <code>LetterPalindrome</code> class that interprets a string as a letter-based palindrome or sentence palindrome. This class inherits from the ABC <code>Palindromable</code>:</p>
<pre><code>class LetterPalindrome(Palindromable):

    def __init__(self, string):
        self._raw = string
        self._stripped = ''.join(filter(str.isalpha, string.lower()))

    def __str__(self):
        return self._raw

    def __iter__(self):
        return self._stripped.__iter__()

    def __reversed__(self):
        return reversed(self._stripped)</code></pre>
<p class="CodeListingCaption"><a id="listing14-22">Listing 14-22</a>: <em>palindrome_check.py:2</em></p>
<p>The initializer of <code>LetterPalindrome</code> accepts a string, strips out any non-letters, and converts it to all lowercase, thereby allowing it to check whether it’s a palindrome by reversing it and comparing it to the original.</p>
<p>Although I’m omitting it for reasons of space, I could also create a <code>WordPalindrome</code> class, which similarly accepts a string but reverses it word by word, instead of letter by letter.</p>
<p>I also implement all three required methods. Remember that, because the ABC mandates a <code>__str__()</code> method, I <em>must</em> implement it here. It doesn’t matter that one of the base classes—namely, <code>object</code>—has implemented <code>__str__()</code>; the <code>ABC</code> overwrote it as an abstract method, forcing me to reimplement it.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2><p class="BoxBodyFirst">	This gets tricky as soon as multiple inheritance gets involved, so be mindful of the method resolution order. If <code>class X(ABC)</code> has an abstract method <code>foo()</code> and <code>class Y</code> provides method <code>foo()</code>, then while <code>class Z(X, Y)</code> will need to reimplement <code>foo()</code>, <code>class Z(Y, X)</code> will <b><i>not</i></b><var class="bold">!</var></p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Below is my function for checking whether something is a palindrome. This function doesn’t care about the form of the palindrome; it just returns <code>True</code> as long as comparing the iterable to its reverse matches, item for item:</p>
<pre><code>def check_palindrome(sequence):

    if not isinstance(sequence, Palindromable):
        raise TypeError("Cannot check for palindrome on that type.")

    for c, r in zip(sequence, reversed(sequence)):
        if c != r:
<span epub:type="pagebreak" title="420" id="Page_420"/>            print(f"NON-PALINDROME: {sequence}")
            return False
    print(f"PALINDROME: {sequence}")
    return True</code></pre>
<p class="CodeListingCaption"><a id="listing14-23">Listing 14-23</a>: <em>palindrome_check.py:3</em></p>
<p>Before doing anything, I check that <code>sequence</code> is an instance of a class derived from <code>Palindromable</code>. If it is, I iteratively compare the items on sequence and its reversed form, indirectly relying on <code>sequence.__iter__()</code> and <code>sequence.__reversed__()</code>. In addition, I print a result onto the screen, indirectly using <code>sequence.__str__()</code>.</p>
<p>If I passed this function an instance of any class that lacked those three methods, this code wouldn’t make sense, and I would fail-fast with an exception. The particular strength of abstract base classes is that they aid in safely and effectively utilizing a form of duck typing. As long as a class can be used in a certain manner, it satisfies the ABC and nothing else matters.</p>
<p>I’ll try out my palindrome checker so far by instantiating a couple of <code>LetterPalindrome</code> instances and passing them to <code>check_palindrome()</code>:</p>
<pre><code>canal = LetterPalindrome("A man, a plan, a canal - Panama!")
print(check_palindrome(canal))   # prints 'True'

bolton = LetterPalindrome("Bolton")
print(check_palindrome(bolton))  # prints ′False'</code></pre>
<p class="CodeListingCaption"><a id="listing14-24">Listing 14-24</a>: <em>palindrome_check.py:4</em></p>
<p>Running that code outputs what I expect:</p>
<pre><code>PALINDROME: A man, a plan, a canal - Panama!
True
NON-PALINDROME: Bolton
False</code></pre>
<h3 id="h2-500920c14-0009">Using Virtual Subclassing</h3>
<p class="BodyFirst">Because my <code>check_palindrome()</code> function expects a class that inherits from my <code>Palindromable</code> ABC, that function would fail to work with some built-in classes, like lists, which could be palindromic in their own right. Instead, trying to pass a list to <code>check_palindrome()</code> fails with a <code>TypeError</code>:</p>
<pre><code>print(check_palindrome([1, 2, 3, 2, 1]))  # raises TypeError</code></pre>
<p class="CodeListingCaption"><a id="listing14-25">Listing 14-25</a>: <em>palindrome_check.py:5a</em></p>
<p>The code fails because <code>list</code> isn’t derived from <code>Palindromable</code>. I can’t reasonably go back and edit Python’s <code>list</code> class (nor should I try). Instead, I can make <code>list</code> a virtual subclass of <code>Palindromable</code>.</p>
<p><span epub:type="pagebreak" title="421" id="Page_421"/>There are two ways of accomplishing this. The easiest is to register any class with an ABC by using the <code>register()</code> method, like this:</p>
<pre><code><b>Palindromable.register(list)</b>
print(check_palindrome([1, 2, 3, 2, 1]))  # prints 'True'</code></pre>
<p class="CodeListingCaption"><a id="listing14-26">Listing 14-26</a>: <em>palindrome_check.py:5b</em></p>
<p>That revised version works now because <code>list</code> is a virtual subclass of <code>Palindromable</code>. Instead of changing the <code>list</code> class to actually inherit from the <code>Palindromable</code> ABC, I have the ABC claim that <code>list</code> is among its derived classes.</p>
<p>However, this only applies to <code>list</code> so far. If I tried to pass a tuple to <code>check_palindrome()</code>, which should also work, it similarly fails. Sure, I could register <code>tuple</code> the same as I did with <code>list</code>, but it would be a pain to have to register every imaginable compatible class as a virtual subclass of <code>Palindromable</code>.</p>
<p>Anything could be considered a valid virtual subclass of <code>Palindromable</code>, as long as it implements the required methods and was <em>ordered</em> (so that the elements can be reversed reliably) and <em>finite</em>. Thinking it through, any class that is ordered would probably also be subscriptable via <code>__getitem__()</code>, and if it were finite, it would have a <code>__len__()</code> method as well. The built-in ABC <code>collections.abc.Sequence</code> mandates both of these methods, in addition to <code>__iter__()</code> and <code>__reversed__()</code>.</p>
<p>I can make <code>Sequence</code> a virtual subclass of <code>Palindromable</code>, thereby making any class that inherits from <code>Sequence</code> also a virtual subclass of <code>Palindromable</code>. I do that like this:</p>
<pre><code><b>from collections.abc import Sequence  # This should be at the top of the file</b>

#<var> --snip--</var>

Palindromable.register(<b>Sequence</b>)
print(check_palindrome([1, 2, 3, 2, 1]))  # prints 'True'</code></pre>
<p class="CodeListingCaption"><a id="listing14-27">Listing 14-27</a>: <em>palindrome_check.py:5c</em></p>
<p>Now I can use list, tuple, and any other class that inherits from <code>collections.abc.Sequence</code> with <code>check_palindrome()</code>.</p>
<p>If my rules for what qualifies as a <code>Palindromable</code> get any more complicated, as they often will in real life, I’ll need to either add more calls to <code>Palindromable.register()</code> or find another technique altogether. To deal with these potential complications, I can implement a special class method on the ABC called <code>__subclasshook__()</code>, which is called by <code>__subclasscheck__()</code> and augments the subclass checking behavior.</p>
<pre><code>from abc import ABC, abstractmethod
from collections.abc import Sequence

class Palindromable(ABC):

    @abstractmethod
<span epub:type="pagebreak" title="422" id="Page_422"/>    def __reversed__(self): pass

    @abstractmethod
    def __iter__(self): pass

    @abstractmethod
    def __str__(self): pass

    <b>@classmethod</b>
<b>    def __subclasshook__(cls, C):</b>
<b>        if issubclass(C, Sequence):</b>
<b>            return True</b>
<b>        return NotImplemented</b></code></pre>
<p class="CodeListingCaption"><a id="listing14-28">Listing 14-28</a>: <em>palindrome_check.py:1d</em></p>
<p>The logic for the <code>__subclasshook__()</code> class method can be as simple or complex as I need it to be, and in this case, it’s extraordinarily simple. In any case, <code>__subclasshook__()</code> must return <code>True</code> if <code>C</code> should be considered a subclass of the <code>Palindromable</code> ABC, <code>False</code> if it definitely shouldn’t, and <code>NotImplemented</code> otherwise. This last part is important! When <code>__subclasshook__()</code> returns <code>NotImplemented</code>, it causes <code>__subclasscheck__()</code> to then check if <code>C</code> is an actual subclass, rather than a virtual one. If I returned <code>False</code> at the end of the method, it would cause my <code>LetterPalindrome</code> class to no longer be considered a subclass of <code>Palindromable</code>.</p>
<p>Unlike with most special methods, Python doesn’t require me to implement <code>__subclasscheck__()</code> directly, because that would mean I had to reimplement all the complicated subclass checking logic.</p>
<p>With this change made, I no longer need to register <code>list</code> and <code>Sequence</code> as virtual subclasses:</p>
<pre><code>print(check_palindrome([1, 2, 3, 2, 1]))               # prints ′True′
print(check_palindrome((1, 2, 3, 2, 1)))               # prints ′True′

print(check_palindrome('racecar'))                     # prints 'True'
print(check_palindrome('race car'))                    # prints 'False'
print(check_palindrome(LetterPalindrome('race car')))  # prints 'True'

print(check_palindrome({1, 2, 3, 2, 1}))               # raises TypeError</code></pre>
<p class="CodeListingCaption"><a id="listing14-29">Listing 14-29</a>: <em>palindrome_check.py:5d</em></p>
<p>As you can see, <code>check_palindrome()</code> now works with <code>list</code>, <code>tuple</code>, and <code>str</code>, in addition to <code>LetterPalindrome</code>.</p>
<p>Meanwhile, passing a <code>set</code> to <code>check_palindrome()</code> fails, which makes sense, because a set is unordered and cannot be reliably reversed.</p>
<p>Such is the beauty of duck typing with ABCs! I am able to write fail-fast code using a LBYL strategy, but I don’t have to specify every conceivable class that would work with that code. Instead, by creating a <code>Palindromable</code> abstract base class and adding <code>collections.abc.Sequence</code> as a virtual subclass, I’ve made my function work with practically any class that implements the needed interface.</p>
<h2 id="h1-500920c14-0005"><span epub:type="pagebreak" title="423" id="Page_423"/>Wrapping Up</h2>
<p class="BodyFirst">Metaclasses are the mysterious “blueprints” from which classes are instantiated, in the same way classes are the blueprints for objects. Although seldom used by themselves, metaclasses allow you to override or extend how a class is created.</p>
<p>You can use abstract base classes, or ABCs, to mandate and then check for a specific interface on a class.</p>
<p>None of this means you shouldn’t use the type hints I mentioned back in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>. When it comes to enforcing a particular interface from a user perspective, annotations are going to be quite useful in clarifying how your code should be used. The purpose of ABCs and subclass checks is to make code that fails fast in situations where it cannot hope to succeed, especially when it may fail in subtle or unpredictable ways. Duck typing, inheritance, and type hints are complementary concepts. How they intersect in your code depends on you.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="425" id="Page_425"/>15</span><br/>
<span class="ChapterTitle">Introspection and Generics</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro"><em>Introspection</em> is the ability of code to access information about itself at runtime and respond accordingly. As an interpreted language, Python excels at introspection. By understanding how Python inspects objects, you can uncover a number of patterns for improving and optimizing your code.</p>
<p>In this chapter, I’ll cover special attributes, which make this introspection possible. By making use of these special attributes, I’ll cover generic functions, descriptors, and slots, and I’ll even build an (effectively) immutable class. Then, while on the topic of code running itself, I’ll touch on the dangers of arbitrary execution.</p>
<h2 id="h1-500920c15-0001"><span epub:type="pagebreak" title="426" id="Page_426"/>Special Attributes</h2>
<p class="BodyFirst">Python achieves introspection primarily by storing important information in <em>special attributes</em> on the different objects in use. These special attributes give Python runtime knowledge about names, project structure, relationships between objects, and more.</p>
<p>Like special methods, all special attributes start and end with a double underscore (<code>__</code>).</p>
<p>You’ve already seen several of these special attributes in preceding chapters, like the special attribute <code>__name__</code>, which contains the name of the module being executed, except on the entry point module, where it has the value <code>"__main__"</code>:</p>
<pre><code>if __name__ == "__main__":
    main()</code></pre>
<p>There is also the special attribute <code>__file__</code>, which contains the absolute path to the current module and can be used to find files in a package:</p>
<pre><code>from pathlib import Path

path = Path(__file__) / Path("../resources/about.txt")
with path.open() as file:
    about = file.read()</code></pre>
<p>In both cases, Python is able to access information about the structure of the project at runtime. That’s introspection at work.</p>
<p>I’ll introduce the various special attributes as I need them in this chapter. As a handy reference, I’ve listed all the special attributes in Python in <span class="xref" itemid="xref_target_Appendix A">Appendix A</span>.</p>
<h2 id="h1-500920c15-0002">Inside Object Attribute Access: The __dict__ Special Attribute</h2>
<p class="BodyFirst">To write introspective code, you must understand how Python stores the names and values of attributes. Every class and every object has an instance of the special attribute <code>__dict__</code>, which is a dictionary that stores attributes and methods. Much of the behavior relating to object attribute access depends on which dictionary—the one on the class or the one on the instance—contains a particular attribute or method. This is actually more complicated than you might expect.</p>
<p>Consider the following simple class structure defining a <code>Llama</code> as a<code> Quadruped</code>:</p>
<pre><code>class Quadruped:
    leg_count = 4

    def __init__(self, species):
        self.species = species


<span epub:type="pagebreak" title="427" id="Page_427"/>class Llama(Quadruped):
    """A quadruped that lives in large rivers."""
    dangerous = True

    def __init__(self):
        self.swimming = False
        super().__init__("llama")

    def warn(self):
        if self.swimming:
            print("Cuidado, llamas!")

    @classmethod
    def feed(cls):
        print("Eats honey with beak.")</code></pre>
<p class="CodeListingCaption"><a id="listing15-1">Listing 15-1</a>: <em>llama.py:1</em></p>
<p>The <code>Quadruped</code> and <code>Llama</code> classes here are designed specifically to demonstrate attribute access, so please overlook the violations of good object design here.</p>
<p>Let’s inspect the <code>__dict__</code> special attributes for the instance and two classes we created, to learn where Python stores everything:</p>
<pre><code>llama = Llama()

from pprint import pprint

print("Instance __dict__:")
pprint(llama.__dict__)

print("\nLlama class __dict__:")
pprint(Llama.__dict__)

print("\nQuadruped class __dict__")
pprint(Quadruped.__dict__)</code></pre>
<p class="CodeListingCaption"><a id="listing15-2">Listing 15-2</a>: <em>llama.py:2a</em></p>
<p>I’m using the <code>pprint</code> module and function to <em>pretty-print</em> the dictionaries, meaning I see each key-value pair in the dictionary on its own line. Pretty printing is useful for displaying complex collections in a more readable way. The output for this code shows the contents of the <code>__dict__</code> special attributes:</p>
<pre><code>Instance __dict__:
{ <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> 'species': 'llama', 'swimming': False}

Llama class __dict__:
mappingproxy({'__doc__': 'A quadruped that lives in large rivers.',
              '__init__': &lt;function Llama.__init__ at 0x7f191b6170d0&gt;,
              '__module__': '__main__',
              'dangerous': True,
              'feed': &lt;classmethod object at 0x7f191b619d60&gt;,
              <span class="CodeAnnotationCode" aria-label="annotation"><span class="CodeAnnotation"/></span><span epub:type="pagebreak" title="428" id="Page_428"/>2 'warn': &lt;function Llama.warn at 0x7f191b617160&gt;})

Quadruped class __dict__
mappingproxy({'__dict__': &lt;attribute '__dict__' of 'Quadruped' objects&gt;,
              '__doc__': None,
              '__init__': &lt;function Quadruped.__init__ at 0x7f191b617040&gt;,
              '__module__': '__main__',
              '__weakref__': &lt;attribute '__weakref__' of 'Quadruped' objects&gt;,

              <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> 'leg_count': 4})</code></pre>
<p>You might be surprised at where some things are located. The instance attributes of <code>species</code> and <code>swimming</code> are found on the instance itself <span class="CodeAnnotation" aria-label="annotation1">❶</span>, but all the instance methods are stored on the class (rather than the instance) <span class="CodeAnnotation" aria-label="annotation2">❷</span>, along with the class attributes and custom class methods. <code>Quadruped.__dict__</code> stores the <code>Quadruped</code> class attribute <code>leg_count</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2><p class="BoxBodyFirst">	Nearly all the inherited special methods are stored in the <code>__dict__</code> attribute of the universal base class, <code>object</code>, but the output of that is so impractically long that I’ve chosen to omit it here. You can look yourself if you’re curious, via <code>pprint(object.__dict__)</code>.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>Another oddity is that the class <code>__dict__</code> attribute is actually of type <code>mappingproxy</code>, a special class defined in <code>types.MappingProxyType</code>. Technical details aside, it’s effectively a read-only view of a dictionary. The class’s <code>__dict__</code> attribute is this <code>MappingProxyType</code>, but the instance’s <code>__dict__ </code>attribute is just an ordinary dictionary. Because of this, however, you cannot directly modify a class <code>__dict__</code> special attribute.</p>
<p>Lastly, although it’s impractical to depict here, all the special attributes and methods of the class itself are defined in the <em>metaclass’s</em> <code>__dict__</code> attribute. In most cases, including here, you can see that with <code>pprint(type.__dict__)</code>.</p>
<p>You can see there are some complex rules regarding where any given attribute or method is stored. Although I can directly access any class or instance attribute or method through the right <code>__dict__</code> special attribute, actually performing that lookup correctly is non-trivial. Python provides a better way.</p>
<h3 id="h2-500920c15-0001">Listing Attributes</h3>
<p class="BodyFirst">There are two functions built for the purpose of inspecting the <code>__dict__</code> attribute of any class or instance: <code>vars()</code> and <code>dir()</code>.</p>
<p>The <code>vars()</code> function prints the <code>__dict__</code> attribute for the given object or class, like this:</p>
<pre><code>llama = Llama()

from pprint import pprint

print("Instance __dict__:")
pprint(<b>vars(llama)</b>)

print("\nLlama class __dict__:")
<span epub:type="pagebreak" title="429" id="Page_429"/>pprint(<b>vars(Llama)</b>)

print("\nQuadruped class __dict__")
pprint(<b>vars(Quadruped)</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing15-3">Listing 15-3</a>: <em>llama.py:2b</em></p>
<p>The output of this code should be identical to that for <a href="#listing15-2" id="listinganchor15-2">Listing 15-2</a>.</p>
<p>Running <code>vars()</code> without any argument inside a class, object, or function prints out the <code>__dict__</code> for the current scope. Outside the scope of any objects, functions, and classes, it prints a dictionary representing the local symbol table. If you want the local or global symbol table as a dictionary, you can also run <code>locals()</code> or <code>globals()</code>, respectively. Be warned that you should never attempt to modify local or global values using the dictionaries returned from these functions.</p>
<p>The <code>dir()</code> built-in function returns a list of all names (but not values) in the current scope or the scope of the given object or class. By default, <code>dir()</code> compiles that list using the <code>__dict__</code> attributes, and it will also include names from the base classes. You can override this behavior by writing your own <code>__dir__()</code> method, which you might do if you’ve modified your class in other ways, to handle names that aren’t actually attributes.</p>
<p>In practice, these four functions—<code>vars()</code>, <code>locals()</code>, <code>globals()</code>, and <code>dir()</code>—are usually only useful when you’re working in the interactive prompt, or else during debugging.</p>
<h3 id="h2-500920c15-0002">Getting an Attribute</h3>
<p class="BodyFirst">To access an attribute, say <code>leg_count</code> or <code>swimming</code>, I’d ordinarily use the dot operator (<code>.</code>), like this:</p>
<pre><code>print(llama.swimming)   # prints 'False'
print(Llama.leg_count)  # prints '4'</code></pre>
<p class="CodeListingCaption"><a id="listing15-4">Listing 15-4</a>: <em>llama.py:3a</em></p>
<p>The dot operator on a class or object is syntactic sugar for the built-in function <code>getattr()</code>. Here are the equivalent function calls:</p>
<pre><code>print(<b>getattr(llama, 'swimming')</b>)   # prints 'False'
print(<b>getattr(Llama, 'leg_count')</b>)  # prints '4'</code></pre>
<p class="CodeListingCaption"><a id="listing15-5">Listing 15-5</a>: <em>llama.py:3b</em></p>
<p>In both cases, I pass two arguments to <code>getattr()</code>: the object I’m searching on, followed by the name I’m searching for as a string.</p>
<p>Behind the scenes, the <code>getattr()</code> function employs two special methods: <code>__getattribute__()</code>, which handles the complex lookup logic, and <code>__getattr__()</code>, which the user can optionally implement to further extend the behavior of the <code>getattr()</code> function on a class.</p>
<p>Ultimately, either <code>object.__getattribute__()</code> or <code>type.__getattribute__() </code>is involved in searching on an instance or class, respectively. Even if this special method is reimplemented by a derived class or metaclass, that <span epub:type="pagebreak" title="430" id="Page_430"/>reimplementation will have to explicitly call <code>object.__getattribute__()</code> or <code>type.__getattribute__()</code> to avoid infinite recursion. This is just as well, as it would be no small matter to correctly reimplement all the behavior of <code>__getattribute__()</code>.</p>
<p>The <code>__getattribute__()</code> special method works by searching through the <code>__dict__</code> objects on the instances and classes, following the method resolution order. If it doesn’t find the attribute it’s searching for, it raises an <code>AttributeError</code>. From there, <code>getattr()</code> will check whether the special method <code>__getattr__()</code> has been defined—that’s the special user-defined method used as a fallback for attribute lookup when <code>__getattribute__()</code> fails. If <code>__getattr__()</code> has been defined, it is called by <code>getattr()</code> as a last step.</p>
<p>Here, I’ll use <code>__getattribute__()</code> directly:</p>
<pre><code>print(<b>object.__getattribute__(llama, 'swimming')</b>)  # prints 'False'
print(<b>type.__getattribute__(Llama, 'leg_count')</b>)   # prints '4'</code></pre>
<p class="CodeListingCaption"><a id="listing15-6">Listing 15-6</a>: <em>llama.py:3c</em></p>
<p>Objects and metaclasses both have a <code>__dict__</code> special attribute, which is used to store all other attributes by name. This is why you can add attributes to an object or class arbitrarily, even from outside the class definition. (There’s an alternative means of storing attributes, which I’ll return to later.)</p>
<p>Here is a rough reimplementation of the <code>getattr()</code> function, demonstrating how <code>__getattribute__()</code> and <code>__gettattr__()</code> are actually used in attribute lookups:</p>
<pre><code>llama = Llama()

<b>try:</b>
    print(object.__getattribute__(llama, 'swimming'))
<b>except AttributeError as e:</b>
<b>    try:</b>
<b>        __getattr__ = object.__getattribute__(llama, '__getattr__')</b>
<b>    except AttributeError:</b>
<b>        raise e</b>
<b>    else:</b>
<b>        print(__getattr__(llama, 'swimming'))</b>

<b>try:</b>
    print(type.__getattribute__(Llama, 'leg_count'))
<b>except AttributeError as e:</b>
<b>    try:</b>
<b>        __getattr__ = type.__getattribute__(Llama, '__getattr__')</b>
<b>    except AttributeError:</b>
<b>        raise e</b>
<b>    print(__getattr__(Llama, 'leg_count'))</b></code></pre>
<p class="CodeListingCaption"><a id="listing15-7">Listing 15-7</a>: <em>llama.py:3d</em></p>
<p>While this is not identical to what’s really happening in <code>getattr()</code>, it’s close enough to understand what’s going on. In the first block, I’m accessing <code>llama.swimming</code>, and in the second, <code>Llama.leg_count</code>. In both cases, I start <span epub:type="pagebreak" title="431" id="Page_431"/>by calling the appropriate <code>__getattribute__()</code> special method in a <code>try</code> clause. If an <code>AttributeError</code> is raised, I next check if <code>__getattr__()</code> has been implemented; this, too, is done with <code>__getattribute__()</code>. If <code>__getattr__()</code> does exist, it’s called to perform a fallback attribute check, but if it doesn’t, the original <code>AttributeError</code> is raised again.</p>
<p>Whew! That’s a lot of work. Thankfully, Python hides all this complexity from us. To access an attribute or method, use the dot operator if you know the name of what you’re looking for in advance, or use <code>getattr()</code> to perform lookups at runtime, using a string for the name:</p>
<pre><code># Either of these works!
print(llama.swimming)              # prints 'False'
print(getattr(Llama, 'leg_count')  # prints '4'</code></pre>
<p class="CodeListingCaption"><a id="listing15-8">Listing 15-8</a>: <em>llama.py:3e</em></p>
<p>As for overriding the normal behavior, <code>__getattr__()</code> is usually the only one of the two special methods involved that you should ever implement. One common use of <code>__getattr__()</code> is to provide a default value for attributes that don’t exist. As a rule, you should leave <code>__getattribute__()</code> alone.</p>
<h3 id="h2-500920c15-0003">Checking for an Attribute</h3>
<p class="BodyFirst">To check for the existence of an attribute, use the <code>hasattr()</code> function, like this:</p>
<pre><code>if hasattr(llama, 'larger_than_frogs'):
    print("¡Las llamas son más grandes que las ranas!")</code></pre>
<p class="CodeListingCaption"><a id="listing15-9">Listing 15-9</a>: <em>llama.py:4a</em></p>
<p>Behind the scenes, <code>hasattr()</code> calls <code>getattr()</code> in a try statement, similar to if I had done this:</p>
<pre><code>try:
    getattr(llama, 'larger_than_frogs')
except AttributeError:
    pass
else:
    print("¡Las llamas son más grandes que las ranas!")</code></pre>
<p class="CodeListingCaption"><a id="listing15-10">Listing 15-10</a>: <em>llama.py:4b</em></p>
<h3 id="h2-500920c15-0004">Setting an Attribute</h3>
<p class="BodyFirst">Setting an attribute isn’t quite as involved as accessing one. The <code>setattr()</code> function relies on the <code>__setattr__()</code> special method. By default, setting an attribute to a value should always work. Here, I set the instance attribute <code>larger_than_frogs</code> on <code>llama</code> to <code>True</code>:</p>
<pre><code>setattr(llama, 'larger_than_frogs', True)
print(llama.larger_than_frogs)  # prints 'True'

<span epub:type="pagebreak" title="432" id="Page_432"/>setattr(Llama, 'leg_count', 3)
print(Llama.leg_count)          # prints '3'</code></pre>
<p class="CodeListingCaption"><a id="listing15-11">Listing 15-11</a>: <em>llama.py:5a</em></p>
<p>I pass three arguments to <code>setattr()</code>: the object or class to change the attribute on, the attribute name as a string, and the new value. The <code>setattr()</code> method completely ignores inheritance and the method resolution order; it is only concerned with modifying the <code>__dict__</code> on the specified object or class. If the attribute exists on that <code>__dict__</code>, the method alters it; otherwise, the method creates a new attribute on the <code>__dict__</code>.</p>
<p>Behind the scenes, <code>setattr()</code> relies on the special method <code>__setattr__()</code>, and the code in <a href="#listing15-11" id="listinganchor15-11">Listing 15-11</a> is effectively doing the following:</p>
<pre><code><b>object.__setattr__(</b>llama, 'larger_than_frogs', True<b>)</b>
print(llama.larger_than_frogs)    # prints 'True'

<b>type.__setattr__(</b>Llama, 'leg_count', 3<b>)</b>
print(Llama.leg_count)            # prints '3'</code></pre>
<p class="CodeListingCaption"><a id="listing15-12">Listing 15-12</a>: <em>llama.py:5b</em></p>
<p>That, in turn, modifies <code>llama.__dict__</code> and <code>Llama.__dict__</code>, respectively. There’s one funny detail here: while I could have modified <code>llama.__dict__</code> manually, <code>Llama.__dict__</code> is a <code>mappingproxy</code>, meaning it is read-only for everyone and everything <em>except</em> <code>type.__setattr__()</code>, which alone knows the secret to modifying the data represented in a <code>mappingproxy</code>. (Seriously, it’s not even documented.)</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA ALERT</h2><p class="BoxBodyFirst">	Accessing an attribute follows the method resolution order. Setting an attribute does <em>not</em>. Misunderstanding this behavior can lead to many bugs.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>When setting an attribute, either via <code>setattr()</code> or the dot operator, pay careful attention to whether you are modifying an existing class attribute or merely shadowing it with an instance attribute. Accidental shadowing creates all sorts of bad surprises, as we’ve seen before. Here’s what I mean:</p>
<pre><code>setattr(llama, 'dangerous', False)  # uh oh, shadowing!
print(llama.dangerous)              # prints 'False', looks OK?
print(Llama.dangerous)              # prints 'True', still dangerous!!</code></pre>
<p class="CodeListingCaption"><a id="listing15-13">Listing 15-13</a>: <em>llama.py:6a</em></p>
<p>In my call to <code>setattr()</code> here, I’m adding the key <code>'dangerous'</code> to the instance’s special attribute <code>llama.__dict__</code>, ignoring altogether the existence of the same key on the class’s special attribute, <code>Llama.__dict__</code>. The print statements demonstrate the resulting shadowing.</p>
<p>Unexpected shadowing is not a problem particular to <code>setattr()</code> but exists with any assignment to an attribute:</p>
<pre><code><span epub:type="pagebreak" title="433" id="Page_433"/><b>llama.dangerous = False  # same problem</b>
print(llama.dangerous)   # prints 'False', looks OK?
print(Llama.dangerous)   # prints 'True', still dangerous!!</code></pre>
<p class="CodeListingCaption"><a id="listing15-14">Listing 15-14</a>: <em>llama.py:6b</em></p>
<p>To ensure I don’t shadow class attributes with instance attributes, I must be careful to only modify class attributes on the class, never on an instance thereof:</p>
<pre><code><b>Llama.dangerous = False  # this is better</b>
print(llama.dangerous)   # prints 'False', looks OK?
print(Llama.dangerous)   # prints 'False', we are safe now</code></pre>
<p class="CodeListingCaption"><a id="listing15-15">Listing 15-15</a>: <em>llama.py:6c</em></p>
<p>To control how an object handles assignment to its attributes, you can reimplement the <code>__setattr__()</code> special method yourself. Use caution here, too. Your implementation of <code>__setattr__()</code> can actually <em>prevent</em> attributes from working altogether if it never modifies the <code>__dict__</code> special attribute and never calls <code>object.__setattr__()</code> (or <code>type.__setattr__()</code>, when working with class attributes).</p>
<h3 id="h2-500920c15-0005">Deleting an Attribute</h3>
<p class="BodyFirst">The <code>delattr()</code> method deletes attributes. It relies on the <code>__delattr__()</code> special method and works in the same manner as <code>setattr()</code>, except that it returns an <code>AttributeError</code> if the requested attribute doesn’t exist.</p>
<p>Normally, you would use the <code>del</code> operator for this purpose, like this:</p>
<pre><code>print(llama.larger_than_frogs)  # prints 'True'
del llama.larger_than_frogs
print(llama.larger_than_frogs)  # raises AttributeError</code></pre>
<p class="CodeListingCaption"><a id="listing15-16">Listing 15-16</a>: <em>llama.py:7a</em></p>
<p>This is the same as calling <code>delattr()</code> directly, like so:</p>
<pre><code>print(llama.larger_than_frogs)  # prints 'True'
delattr(llama, 'larger_than_frogs')
print(llama.larger_than_frogs)  # raises AttributeError</code></pre>
<p class="CodeListingCaption"><a id="listing15-17">Listing 15-17</a>: <em>llama.py:7b</em></p>
<p>The <code>delattr()</code> function invokes <code>__delattr__()</code> the same way that <code>setattr()</code> invokes <code>__setattr__()</code>. If you want to control the deletion of attributes, you can reimplement <code>__delattr__()</code>, although you should use the same caution when altering this special method as with <code>__setattr__()</code>.</p>
<h2 id="h1-500920c15-0003">Function Attributes</h2>
<p class="BodyFirst">If all objects can have attributes, and if functions are objects, then surely, functions can have attributes. This is indeed the case, but they don’t work in the way you might think.</p>
<p><span epub:type="pagebreak" title="434" id="Page_434"/>In practice, you will rarely need to use function attributes directly. They’re mainly useful for enabling other patterns and techniques to work. These tasks border “deep magic” territory, whence we find metaclasses (<span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span>). </p>
<p>Interestingly, function attributes were originally added to Python purely because they looked like they <em>should</em> exist. Libraries could already abuse <code>__docstring__</code> to hack in an approximation of function attribute behavior anyway. Meanwhile, other developers were trying to approximate function attributes by creating classes that consisted purely of class attributes and a <code>__call__()</code> method, a technique that has a fair bit of performance overhead compared to a normal function with attributes.</p>
<p>Thus, the Python developers reasoned, “Well, if they’re going to do it anyway, we might as well provide a formal and obvious mechanism for it.”</p>
<h3 id="h2-500920c15-0006">The Wrong Way to Use Function Attributes</h3>
<p class="BodyFirst">To demonstrate function attributes and their pitfalls, consider the following example, in which I initially use function attributes incorrectly. This code defines a multiplier function that stores one of its operands in a function attribute. I’ll get to why this entire technique is a bad idea in a moment.</p>
<p>In this example, <code>multiplier()</code> multiplies the argument <code>n</code> by the value <code>factor</code> and prints the result:</p>
<pre><code>def multiplier(n):
    factor = 0
    print(n * factor)


<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> multiplier.factor = 3
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> multiplier(2)             # prints 0
print(multiplier.factor)  # prints 3</code></pre>
<p class="CodeListingCaption"><a id="listing15-18">Listing 15-18</a>: <em>function_attribute.py:1a</em></p>
<p>In the usage, I incorrectly attempt to change the value of <code>factor</code> to <code>3</code> by assigning the value to a function attribute <span class="CodeAnnotation" aria-label="annotation1">❶</span>. As you can see, the output of the function call is <code>0</code>, proving this did not work as expected <span class="CodeAnnotation" aria-label="annotation2">❷</span>, as the local-scope variable is still <code>0</code>. Yet, if I inspect <code>multiplier.factor</code>, this function attribute’s value is indeed <code>3</code>. What happened?</p>
<p>The problem is that function attributes are not the same thing as local-scope variables, but rather exist inside the <code>multiplier</code> object’s <code>__dict__</code> attribute. If I print this <code>__dict__</code> attribute, you can see that it includes the <code>multiplier.factor</code> attribute:</p>
<pre><code>def multiplier(n):
    factor = 0
    print(n * factor)


<b>print(multiplier.__dict__)  # prints {}</b>
<span epub:type="pagebreak" title="435" id="Page_435"/>multiplier.factor = 3
<b>print(multiplier.__dict__)  # prints {'factor': 3}</b></code></pre>
<p class="CodeListingCaption"><a id="listing15-19">Listing 15-19</a>: <em>function_attribute.py:1b</em></p>
<p>What’s more, I cannot access function attributes within the function by name only, as I tried to do with the print call in the <code>multiplier()</code> function. The only way to access the function attributes is through <code>getattr()</code>, either directly or via the dot operator, like this:</p>
<pre><code>def multiplier(n):
    print(n * <b>multiplier.factor</b>)


print(multiplier.__dict__)  # prints {}
multiplier.factor = 3
print(multiplier.__dict__)  # prints {'factor': 3}
<b>multiplier(2)               # prints 6</b></code></pre>
<p class="CodeListingCaption"><a id="listing15-20">Listing 15-20</a>: <em>function_attribute.py:1c</em></p>
<p>As you can see, the multiplication operation now succeeds.</p>
<p>There’s still another technical problem with this code: if I fail to assign an initial value to <code>multiplier.factor</code>, the call to <code>multiplier()</code> in <a href="#listing15-20" id="listinganchor15-20">Listing 15-20</a> will fail. I can correct this problem by having the <code>multiplier()</code> function define a default value for that function attribute, if it is undefined.</p>
<p>Here’s the final working version:</p>
<pre><code>def multiplier(n):
<b>    if not hasattr(multiplier, 'factor'):</b>
<b>        multiplier.factor = 0</b>
    print(n * multiplier.factor)


<b>multiplier(2)               # prints 0</b>
print(multiplier.__dict__)  # prints {<b>'factor': 0</b>}
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> multiplier.factor = 3
print(multiplier.__dict__)  # prints {'factor': 3}
multiplier(2)               # prints 6</code></pre>
<p class="CodeListingCaption"><a id="listing15-21">Listing 15-21</a>: <em>function_attribute.py:1d</em></p>
<p>At the top of <code>multiplier()</code>, I check whether the <code>factor</code> function attribute has been defined. If it hasn’t, I set it to a default value of <code>0</code>. Then, by changing the function attribute externally <span class="CodeAnnotation" aria-label="annotation1">❶</span>, I can change the behavior of the function.</p>
<p>As I’ve said from the start, though, this is only a simple example to demonstrate how function attributes work. My usage is not even remotely Pythonic!</p>
<h3 id="h2-500920c15-0007">Mutability and Function Attributes</h3>
<p class="BodyFirst">You’ll recall from <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span> that functions should be <em>stateless</em>. Given what the function is designed to do, one may reasonably expect that <code/><span epub:type="pagebreak" title="436" id="Page_436"/>multiplier(2) will return the same value every time. That premise has been violated because <code>multiplier()</code> stores state in its function attributes. Changing <code>multiplier.factor</code> will change the value returned by <code>multiplier(2)</code>.</p>
<p>In other words, <em>function attributes are attributes on a mutable object</em>. This is a logic error waiting to bite you! Consider the following simplistic example, where I try to change a function attribute on one function and it changes elsewhere, too:</p>
<pre><code>def skit():
    print(skit.actor)

skit.actor = "John Cleese"
skit()    # prints "John Cleese"

sketch = skit
sketch()  # prints "John Cleese"
sketch.actor = "Eric Idle"
sketch()  # prints "Eric Idle"

skit()    # prints "Eric Idle"...yikes!</code></pre>
<p class="CodeListingCaption"><a id="listing15-22">Listing 15-22</a>: <em>bad_function_attribute.py</em></p>
<p>When I assign <code>sketch</code> to <code>skit</code>, I’m binding <code>sketch</code> to the same mutable function object as <code>skit</code>. When I then assign a new value to the function attribute <code>sketch.actor</code>, it is the same as assigning it to the function attribute <code>skit.actor</code>; it’s an attribute on the same function object. If you’re familiar with the troubles with mutable objects, such as lists passed as arguments, that behavior may not look surprising, especially packed into a dozen-line example. However, imagine this being scattered into a production code base of thousands of lines. This could be a horrible bug to attempt to locate and resolve.</p>
<p>As to my <code>multiplier()</code> function (<a href="#listing15-21" id="listinganchor15-21">Listing 15-21</a>), if I really needed to be able to provide a <code>factor</code> in some manner other than as an argument, I’d write that function as a closure instead. That way, each callable would be, itself, stateless. (See <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span> for more on that topic.)</p>
<p>If you do need to use function attributes, you should be careful to only modify them in ways that are clear, predictable, and easy to debug. One possible usage is to employ a decorator to provide a default value up front to a callable, and to never change that value at any point during the execution of the program. While a similar outcome can be achieved with a closure, using a decorator places the extension immediately before the definition of the function. This leaves the attribute open to inspection, something that is squarely impossible with a parameter in a closure.</p>
<h2 id="h1-500920c15-0004">Descriptors</h2>
<p class="BodyFirst"><em>Descriptors</em> are objects with <em>binding behavior</em>, meaning that they control how the objects are used as attributes. You can think of a descriptor as a property, whose getter, setter, and deleter methods are encapsulated in a class with the data those methods work with.</p>
<p><span epub:type="pagebreak" title="437" id="Page_437"/>For example, you could have a <code>Book</code> descriptor that contains a book’s title, author, publisher, and publication year. When the descriptor is used as an attribute, all this information could be assigned directly via a string, and the descriptor could parse the information out of that string.</p>
<p>All methods, including static and class methods, as well as the <code>super()</code> function (discussed in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>), are actually descriptor objects. Properties are descriptors behind the scenes, too. Properties are only defined in the context of the class using them, while descriptors can be defined outside of the class and reused. This is similar to the difference between lambdas, which are defined where they’re used, and functions, which are defined separately from their usage.</p>
<h3 id="h2-500920c15-0008">The Descriptor Protocol</h3>
<p class="BodyFirst">An object is a descriptor if it implements at least one of the three special methods in the <em>descriptor protocol</em>: <code>__get__()</code>, <code>__set__()</code>, or <code>__delete__()</code>. If the object only implements <code>__get__()</code>, it is a <em>non-data descriptor</em>, which is typically used for methods behind the scenes. If it also implements <code>__set__()</code> and/or <code>__delete__()</code>, it’s a <em>data descriptor</em>, which is what properties are an example of.</p>
<p>This matters to the <em>lookup chain</em> used by <code>object.__getattribute__()</code> and <code>type.__getattribute__()</code>. The lookup chain determines where Python searches for an attribute, and in what order. Data descriptors get first priority, followed by ordinary attributes stored on the object’s <code>__dict__</code>, then non-data descriptors, and finally any attributes on the class and its base classes. This means that a data descriptor named <code>foo</code> will shadow, or even prevent the creation of, an attribute by the same name. Similarly, an attribute named <code>update</code> will shadow a method (non-data descriptor) named <code>update()</code>.</p>
<p>A <em>read-only data descriptor</em> would still have <code>__set__()</code> defined, but that method would only raise an <code>AttributeError</code>. This is important for the descriptor to be considered a data descriptor in the lookup chain.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note	</h2><p class="BoxBodyFirst">You could also write a valid descriptor with only <code>__set__()</code> and <code>__delete__()</code>, or even just one of those two methods. However, there are few, if any, practical uses for this. </p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>Descriptors also have a <code>__set_name__()</code> method, which is called when the descriptor is bound to a name. I’ll demonstrate this later in this section.</p>
<h3 id="h2-500920c15-0009">Writing a Descriptor Class (the Slightly Wrong Way)</h3>
<p class="BodyFirst">While it is possible to write a descriptor class as a property on a class, you’d normally write a separate descriptor class to reduce code repetition. This can be useful if you want to use the descriptor in multiple unrelated classes, or if you want several instances of the same descriptor in the same instance.</p>
<p>As an example, I’ll write a descriptor class that stores details about a book. I want to parse these details out of a string following the APA 7 <span epub:type="pagebreak" title="438" id="Page_438"/>citation format. Here’s the first part of that descriptor class. Be advised, there is a logical error in this code, which I’ll cover shortly:</p>
<pre><code>import re


class Book:
    pattern = re.compile(r'(.+)\((\d+)\)\. (.+)\. (.+)\..*')

    def __set__(self, instance, value):
        matches = self.pattern.match(value)
        if not matches:
            raise ValueError("Book data must be specified in APA 7 format.")
        self.author = matches.group(1)
        self.year = matches.group(2)
        self.title = matches.group(3)
        self.publisher = matches.group(4)</code></pre>
<p class="CodeListingCaption"><a id="listing15-23">Listing 15-23</a>: <em>book_club.py:1a</em></p>
<p>This class is a data descriptor (instead of a non-data descriptor) because it defines <code>__set__()</code>. (I’ll define <code>__get__()</code> in <a href="#listing15-24" id="listinganchor15-24">Listing 15-24</a>.) When the descriptor is an attribute of another class, a value can be assigned directly to that attribute, and the <code>__set__()</code> method is called. This method accepts exactly three arguments: <code>self</code>, the object to access on (<code>instance</code>), and the value being assigned to the descriptor (<code>value</code>).</p>
<p>Within <code>__set__()</code>, I use a regular expression that I precompiled and stored in the class attribute pattern to extract the author, title, year, and publisher from the string passed to the value parameter. These extracted values are stored in instance attributes. If value is not a string that matches the expectations of the regular expression, a <code>ValueError</code> is raised.</p>
<p>For this to be a descriptor, I must also provide a <code>__get__()</code> method in the <code>Book</code> descriptor class:</p>
<pre><code>    def __get__(self, instance, owner=None):
        try:
            return f"'{self.title}' by {self.author}"
        except AttributeError:
            return "nothing right now"</code></pre>
<p class="CodeListingCaption"><a id="listing15-24">Listing 15-24</a>: <em>book_club.py:2a</em></p>
<p>When the descriptor is accessed as an attribute, this <code>__get__()</code> method is called, returning a new string containing the book’s title and author. If the expected attributes haven’t been defined, I return a string <code>"nothing right now"</code> instead of re-raising the <code>AttributeError</code>.</p>
<p>The <code>__get__()</code> method must accept the arguments <code>self</code> and <code>instance</code>, just like <code>__set__()</code> does, as well as the optional argument <code>owner</code>, which specifies which class the descriptor belongs to. When <code>owner</code> is set to the default value of <code>None</code>, the owning class is considered to be the same as <code>type(instance)</code>.</p>
<p>You’ll notice that the <code>Book</code> class has no <code>__init__()</code> method. Although a descriptor class <em>may</em> have an initializer if desired, you should not use it to <span epub:type="pagebreak" title="439" id="Page_439"/>initialize instance attributes as you would with an ordinary class. This is because only one instance of the descriptor is shared between all classes that use it, so all instance attributes will be shared, too. In fact, this unexpected behavior has already set me up for a problem in the example I’m crafting. Stay tuned.</p>
<h3 id="h2-500920c15-0010">Using a Descriptor</h3>
<p class="BodyFirst">A descriptor only exhibits its binding behavior when used as an attribute in another class. To demonstrate this, I’ll define a <code>BookClub</code> class, which will use the <code>Book</code> descriptor class to keep track of what book the club is currently reading:</p>
<pre><code>class BookClub:
    reading = Book()

    def __init__(self, name):
        self.name = name
        self.members = []

    def new_member(self, member):
        self.members.append(member)
        print(
            "===== - - - - - - - - - =====",
            f"Welcome to the {self.name} Book Club, {member}!",
            f"We are reading {self.reading}",
            "===== - - - - - - - - - =====",
            sep='\n'
        )</code></pre>
<p class="CodeListingCaption"><a id="listing15-25">Listing 15-25</a>: <em>book_club.py:3a</em></p>
<p>I put the <code>Book</code> descriptor to work by binding an instance of <code>Book</code> to the class attribute <code>reading</code>. I also defined a <code>new_member()</code> method for adding new members to the book club and welcoming them with information about the book the club is currently reading.</p>
<p>There’s one important detail here: <em>the descriptor must be a class attribute!</em> Otherwise, all of the descriptor behavior will be ignored, and assignment will merely rebind the attribute to the value being assigned. This isn’t too surprising if you think of where else descriptors show up: all methods and properties are declared at class scope, rather than as names on <code>self</code> (instance attributes).</p>
<p>Given that the descriptor is a class attribute with attributes of its own, a problem emerges when using the <code>BookClub</code> class. I’ll demonstrate by creating two new book clubs: <code>mystery_lovers</code> and <code>lattes_and_lit</code>:</p>
<pre><code>mystery_lovers = BookClub("Mystery Lovers")
lattes_and_lit = BookClub("Lattes and Lit")

mystery_lovers.reading = (
    "McDonald, J. C. (2019). "
    "Noah Clue, P.I. AJ Charleson Publishing."
<span epub:type="pagebreak" title="440" id="Page_440"/>)
lattes_and_lit.reading = (
    "Christie, A. (1926). "
    "The Murder of Roger Ackroyd. William Collins &amp; Sons."
)

print(mystery_lovers.reading)  # prints "'The Murder of Roger Ackroyd..."
print(lattes_and_lit.reading)  # prints "'The Murder of Roger Ackroyd..."</code></pre>
<p class="CodeListingCaption"><a id="listing15-26">Listing 15-26</a>: <em>book_club.py:4</em></p>
<p>The first club is reading a mystery novel from some weird programmer guy, so I assign a string containing the appropriately formatted book information to the <code>reading</code> attribute of <code>mystery_lovers</code>. This assignment is invoking the <code>__set__()</code> method on the <code>Book</code> data descriptor object bound to <code>reading</code>.</p>
<p>Meanwhile, the folks in the <code>lattes_and_lit</code> club are reading a classic Agatha Christie novel, so I assign the appropriate book information to <code>lattes_and_lit.reading</code>.</p>
<p>However, since <code>reading</code> is a class attribute, this second assignment changes what both clubs are reading, as you can see from the <code>print()</code> statements. How do I fix that?</p>
<h3 id="h2-500920c15-0011">Writing a Descriptor Class the Right Way</h3>
<p class="BodyFirst">While the <code>reading</code> descriptor must be a class attribute on <code>BookClub</code>, I can modify the descriptor class by storing attributes on the class instance it exists on:</p>
<pre><code>class Book:
    pattern = re.compile(r'(.+)\((\d+)\)\. (.+)\. (.+)\..*')

    def __set__(self, instance, value):
        matches = self.pattern.match(value)
        if not matches:
            raise ValueError("Book data must be specified in APA 7 format.")
        <b>instance</b>.author = matches.group(1)
        <b>instance</b>.year = matches.group(2)
        <b>instance</b>.title = matches.group(3)
        <b>instance</b>.publisher = matches.group(4)</code></pre>
<p class="CodeListingCaption"><a id="listing15-27">Listing 15-27</a>: <em>book_club.py:1b</em></p>
<p>Instead of having the <code>Book</code> descriptor store its own attributes, it should store them on the instance it is a member of, accessed via the <code>instance</code> argument.</p>
<p>Since I’m defining attributes on the instance, I provide a <code>__delete__()</code> method as well, so deleting the <code>Book</code> descriptor via the <code>reading</code> attribute on a <code>BookClub</code> instance will work appropriately:</p>
<pre><code>    def __get__(self, instance, owner=None):
        try:
            return f"'{<b>instance</b>.title}' by {<b>instance</b>.author}"
        except AttributeError:
<span epub:type="pagebreak" title="441" id="Page_441"/>            return "nothing right now"

    <b>def __delete__(self, instance):</b>
<b>        del instance.author</b>
<b>        del instance.year</b>
<b>        del instance.title</b>
<b>        del instance.publisher</b></code></pre>
<p class="CodeListingCaption"><a id="listing15-28">Listing 15-28</a>: <em>book_club.py:2b</em></p>
<p>If I hadn’t defined this, calling <code>del</code> on the reading attribute would have raised an exception.</p>
<p>With the descriptor’s data safely stored on the appropriate owning instances, I find that the usage from earlier now works as expected:</p>
<pre><code>mystery_lovers = BookClub("Mystery Lovers")
lattes_and_lit = BookClub("Lattes and Lit")

mystery_lovers.reading = (
    "McDonald, J. C. (2019). "
    "Noah Clue, P.I. AJ Charleson Publishing."
)
lattes_and_lit.reading = (
    "Christie, A. (1926). "
    "The Murder of Roger Ackroyd. William Collins &amp; Sons."
)

print(mystery_lovers.reading)  # prints "'Noah Clue, P.I...."
print(lattes_and_lit.reading)  # prints "'The Murder of Roger Ackroyd..."</code></pre>
<p class="CodeListingCaption"><a id="listing15-29">Listing 15-29</a>: <em>book_club.py:4</em></p>
<p>Here’s a little more usage of this <code>BookClub</code> class, demonstrating calling <code>del</code> on the descriptor and adding a new member:</p>
<pre><code>del lattes_and_lit.reading

lattes_and_lit.new_member("Jaime")

lattes_and_lit.reading = (
    "Hillerman, T. (1973). "
    "Dance Hall Of The Dead. Harper and Row."
)

lattes_and_lit.new_member("Danny")</code></pre>
<p class="CodeListingCaption"><a id="listing15-30">Listing 15-30</a>: <em>book_club.py:5</em></p>
<p>I clear the current book so that the Lattes and Lit book club isn’t reading anything right now. This calls the <code>reading.__del__()</code> method. Then, I add a new member, Jaime; the <code>new_member()</code> method will print out a welcome message announcing what the club is reading, which is currently nothing.</p>
<p>Next, I choose a book to be read by the club by assigning a string to the <code>reading</code> attribute; this calls <code>reading.__set__()</code>.</p>
<p><span epub:type="pagebreak" title="442" id="Page_442"/>Finally, I add one more member via <code>new_member()</code>, which once again prints out a welcome message and the current book.</p>
<p>Here’s the complete output of that usage:</p>
<pre><code>===== - - - - - - - - - =====
Welcome to the Lattes and Lit Book Club, Jaime!
We are reading nothing right now.
===== - - - - - - - - - =====
Welcome to the Lattes and Lit Book Club, Danny!
We are reading 'Dance Hall Of The Dead' by Hillerman, T.</code></pre>
<h3 id="h2-500920c15-0012">Using Multiple Descriptors in the Same Class</h3>
<p class="BodyFirst">There’s one remaining problem with my design: the descriptor looks for the attributes <code>title</code>, <code>author</code>, and the like on the instance, so multiple <code>Book</code> descriptors on the same <code>BookClub</code> instance would mutate these same values repeatedly.</p>
<p>Consider if a book club wanted to track both their current selection and the book they’re reading next:</p>
<pre><code>class BookClub:
    reading = Book()
    <b>reading_next = Book()</b>

    # <var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing15-31">Listing 15-31</a>: <em>book_club.py:3b</em></p>
<p>To demonstrate, I’ll assign different books to the <code>reading</code> and <code>reading_next</code> descriptors. Logically, those two descriptors should behave separately, but that’s not what happens:</p>
<pre><code>mystery_lovers.reading = (
    "McDonald, J. C. (2019). "
    "Noah Clue, P.I. AJ Charleson Publishing."
)

mystery_lovers.reading_next = (
    "Chesterton, G.K. (1911). The Innocence of Father Brown. "
    "Cassell and Company, Ltd."
)
print(f"Now: {mystery_lovers.reading}")
print(f"Next: {mystery_lovers.reading_next}")</code></pre>
<p class="CodeListingCaption"><a id="listing15-32">Listing 15-32</a>: <em>book_club.py:6</em></p>
<p>This code outputs the following:</p>
<pre><code>Now: 'The Innocence of Father Brown' by Chesterton, G.K. 
Next: 'The Innocence of Father Brown' by Chesterton, G.K.</code></pre>
<p><span epub:type="pagebreak" title="443" id="Page_443"/>That’s wrong: the club is supposed to be reading <em>Noah Clue, P.I.</em> right now and <em>The Innocence of Father Brown</em> later. The trouble is, both the <code>reading</code> and <code>reading_later</code> descriptors are storing their data in the same instance attributes on <code>mystery_lovers</code>.</p>
<p>To get around that, I should instead store the desired attributes with the namespace of the descriptor it relates to, creating names like <code>reading.author</code> and <code>reading_later.title</code>. That requires a couple of additional methods on the descriptor, for a start:</p>
<pre><code>import re

class Book:
    pattern = re.compile(r'(.+)\((\d+)\)\. (.+)\. (.+)\..*')

    <b>def __set_name__(self, owner, name):</b>
<b>        self.name = name</b>

    <b>def attr(self, attr):</b>
<b>        return f"{self.name}.{attr}"</b>

    def __set__(self, instance, value):
        matches = self.pattern.match(value)
        if not matches:
            raise ValueError("Book data must be specified in APA 7 format.")
        <b>setattr(</b>instance<b>, self.attr('</b>author<b>'),</b> matches.group(1)<b>)</b>
        <b>setattr(</b>instance<b>, self.attr('</b>year<b>'),</b> matches.group(2)<b>)</b>
        <b>setattr(</b>instance<b>, self.attr('</b>title<b>'),</b> matches.group(3)<b>)</b>
        <b>setattr(</b>instance<b>, self.attr('</b>publisher<b>'),</b> matches.group(4)<b>)</b></code></pre>
<p class="CodeListingCaption"><a id="listing15-33">Listing 15-33</a>: <em>book_club.py:1c</em></p>
<p>The <code>__set_name__()</code> special method is called when the descriptor is first bound to a name on the owning class. In this case, I’m using it to store the name the descriptor is bound to.</p>
<p>I define another method that I’ve chosen to name <code>attr()</code>, where I attach the namespace of the descriptor’s name to the beginning of the requested name. As a result, calling <code>attr('title')</code> on a descriptor bound to <code>reading</code> would return <code>reading.title</code>.</p>
<p>I implement this behavior throughout the <code>__set__()</code> method by using the <code>setattr()</code> function, to assign a value to the given attribute on <code>instance</code>.</p>
<p>I must similarly modify <code>__get__()</code> and <code>__delete__()</code>:</p>
<pre><code>    def __get__(self, instance, owner=None):
        try:
            <b>title = getattr(instance, self.attr('title'))</b>
            <b>author = getattr(instance, self.attr('author'))</b>
        except AttributeError:
            return "nothing right now"
        <b>return f"{title} by {author}"</b>

    def __delete__(self, instance):
        <b>delattr(</b>instance<b>, self.attr('</b>author<b>'))</b>
        <b>delattr(</b>instance<b>, self.attr('</b>year<b>'))</b>
<span epub:type="pagebreak" title="444" id="Page_444"/>        <b>delattr(</b>instance<b>, self.attr('</b>title<b>'))</b>
        <b>delattr(</b>instance<b>, self.attr('</b>publisher<b>'))</b></code></pre>
<p class="CodeListingCaption"><a id="listing15-34">Listing 15-34</a>: <em>book_club.py:2c</em></p>
<p>Here, I’m using <code>getattr()</code> and <code>delattr()</code> to respectively access and delete the given attributes, as composed by <code>self.attr()</code>, on <code>instance</code>.</p>
<p>Rerunning the usage in <a href="#listing15-32" id="listinganchor15-32">Listing 15-32</a>, I get the following:</p>
<pre><code>Now: 'Noah Clue, P.I.' by McDonald, J.C. 
Next: 'The Innocence of Father Brown' by Chesterton, G.K.</code></pre>
<p>The two descriptors are storing their attributes separately. This can be confirmed by printing out the names of all the attributes on the <code>mystery_lovers</code> object:</p>
<pre><code>import pprint
pprint.pprint(dir(mystery_lovers))</code></pre>
<p class="CodeListingCaption"><a id="listing15-35">Listing 15-35</a>: <em>book_club.py:7</em></p>
<p>This produces the following:</p>
<pre><code>['__class__',
# <var>--snip--</var>
 'reading',
 'reading.author',
 'reading.publisher',
 'reading.title',
 'reading.year',
 'reading_next',
 'reading_next.author',
 'reading_next.publisher',
 'reading_next.title',
 'reading_next.year']</code></pre>
<h2 id="h1-500920c15-0005">Slots</h2>
<p class="BodyFirst">There’s one downside to the fact that all attributes are stored and accessed on a dictionary: a dictionary collection has significant performance and memory overhead. Ordinarily, this is a reasonable tradeoff, given all the versatility that this approach makes possible.</p>
<p>If you need to improve performance of your class, you can use <em>slots</em> to predeclare the attributes you want. Accessing an attribute on a slot is faster than accessing one on a dictionary, and it reduces the memory taken up by the attributes.</p>
<p>Switching your class to use slots instead of an instance <code>__dict__</code> is as simple as adding the <code>__slots__</code> class attribute, which is a tuple of valid attribute <span epub:type="pagebreak" title="445" id="Page_445"/>names. This list should contain names of instance attributes, not methods or class attributes (which are stored on the class <code>__dict__</code>).</p>
<p>For example, here’s a class for storing data about chemical elements:</p>
<pre><code>class Element:
    __slots__ = (
        'name',
        'number',
        'symbol',
        'family',
        'iupac_num',
    )</code></pre>
<p class="CodeListingCaption"><a id="listing15-36">Listing 15-36</a>: <em>element.py:1a</em></p>
<p>The <code>__slots__</code> tuple contains five names. These will be the only valid instance attribute names on an <code>Element</code> instance, and working with these attributes will be faster than when using <code>__dict__</code>. Notice that none of the methods have to be listed in <code>__slots__</code>; only the instance attribute names do. What’s more, the slots must never conflict with any names elsewhere on the class (with two exceptions, mentioned shortly).</p>
<h3 id="h2-500920c15-0013">Binding Attribute Names to Values</h3>
<p class="BodyFirst">Although the attribute names are declared in <code>__slots__</code>, they don’t have a value (not even <code>None</code>) until they’re bound to values in the usual manner, such as within <code>__init__()</code>:</p>
<pre><code>    def __init__(self, symbol, number, name, family, numeration):
        self.symbol = symbol.title()
        self.number = number
        self.name = name.lower()
        self.family = family.lower()
        self.iupac_num = numeration

    def __str__(self):
        return f"{self.symbol} ({self.name}): {self.number}"</code></pre>
<p class="CodeListingCaption"><a id="listing15-37">Listing 15-37</a>: <em>element.py:2</em></p>
<p>Here, I’ve added my initializer, as well as a function for converting the instance to a string.</p>
<p>From the outside, the class seems to behave the same as a typical class, although if I were to measure the performance, it would be improved:</p>
<pre><code>oxygen = Element('O', 8, 'oxygen', 'non-metals', 16)
iron = Element('Fe', 26, 'iron', 'transition metal', 8)

print(oxygen)  # prints 'O (Oxygen): 8'
print(iron)    # prints 'Fe (Iron): 26'</code></pre>
<p class="CodeListingCaption"><a id="listing15-38">Listing 15-38</a>: <em>element.py:3a</em></p>
<h3 id="h2-500920c15-0014"><span epub:type="pagebreak" title="446" id="Page_446"/>Using Arbitrary Attributes with Slots</h3>
<p class="BodyFirst">The <code>__slots__</code> attribute completely takes over attribute storage from the instance <code>__dict__</code>, preventing <code>__dict__</code> from even being created for the instance, as you can see here:</p>
<pre><code>iron.atomic_mass = 55.845  # raises AttributeError</code></pre>
<p class="CodeListingCaption"><a id="listing15-39">Listing 15-39</a>: <em>element.py:4a</em></p>
<p> However, if I want the benefits of <code>__slots__</code> for the primary attributes, while still allowing additional attributes to be defined later, I only need to add <code>__dict__</code> to <code>__slots__</code>, like this:</p>
<pre><code>class Element:
    __slots__ = (
        'name',
        'number',
        'symbol',
        'family',
        'iupac_num',
        <b>'__dict__',</b>
        <b>'__weakref__',</b>
    )</code></pre>
<p class="CodeListingCaption"><a id="listing15-40">Listing 15-40</a>: <em>element.py:1b</em></p>
<p>The <code>__dict__</code> special attribute is one of the two exceptions to the rule that slots must not conflict with class attribute names. The other exception is _<code>_weakref__</code>, which you would add to <code>__slots__</code> if you wanted your slotted class to support weak references or references to a value that don’t increase the reference count or block garbage collection during their lifetime. I want both arbitrary attributes and weak references for <code>Element</code> instances, so I add the names to <code>__slots__</code>.</p>
<p>With this one change, the code in <a href="#listing15-39" id="listinganchor15-39">Listing 15-39</a> works correctly, instead of raising an <code>AttributeError</code>. This technique will diminish the space savings normally afforded by slots, but you will still have the performance gains on all slotted names.</p>
<h3 id="h2-500920c15-0015">Slots and Inheritance</h3>
<p class="BodyFirst">Slots have some important effects on inheritance. First, you should only declare any given slot once in an inheritance tree. If I were to derive a class from <code>Element</code>, I should not redeclare any of the slots. Doing so would bloat the size of the derived class because all the slots are declared on each instance, even if some of the base class’s slots are shadowed by the derived class’s slots.</p>
<p>Second, you cannot inherit from multiple parents classes with non-empty slots. If you need to use slots in multiple inheritance scenarios, the best approach is to ensure that the base classes have only an empty tuple assigned to <code>__slots__</code>. That way, you can make the derived class use <code>__dict__</code>, <code>__slots__</code>, or both.</p>
<h2 id="h1-500920c15-0006"><span epub:type="pagebreak" title="447" id="Page_447"/>Immutable Classes</h2>
<p class="BodyFirst">Technically, there’s no formal mechanism for creating an immutable class. This fact can make it unfortunately tricky to implement a hashable class, since the <code>__hash__()</code> method must produce a hash value that never changes during the instance’s lifetime, according to the documentation.</p>
<p>Although you cannot create a truly immutable class, you can get close enough that the fact it’s technically mutable doesn’t matter. Consider the core trait of an immutable object: once its attributes have been initially set, those attributes can never be modified by any means, nor can additional attributes be added. This is why all immutable objects are hashable. The most obvious way to emulate an immutable class (at least in my view), and the one that gives you the most control, is implemented using slots.</p>
<p>I want to make the <code>Element</code> class from earlier into an immutable class, and a hashable one at that. To accomplish that, I need to do the following:</p>
<ul>
<li>Implement all attributes as <code>__slots__</code>.</li>
<li>Restrict adding further attributes by omitting <code>__dict__</code> from <code>__slots__</code>.</li>
<li>Allow the creation of weak references by including <code>__weakref__</code> in <code>__slots__ </code>(not strictly necessary, but helpful enough in some use cases to be good practice).</li>
<li>Implement <code>__setattr__()</code> and <code>__delattr__()</code> to prevent modifying or deleting existing attributes.</li>
<li>Implement <code>__hash__()</code> to make instances hashable.</li>
<li>Implement <code>__eq__()</code> and <code>__gt__()</code> to make instances comparable.</li>
</ul>
<p>I’ll start by defining the <code>__slots__</code>, as before:</p>
<pre><code>class Element:
    __slots__ = (
        'name',
        'number',
        'symbol',
        '__weakref__',
    )

    def __init__(self, symbol, number, name):
        self.symbol = symbol.title()
        self.number = number
        self.name = name.lower()</code></pre>
<p class="CodeListingCaption"><a id="listing15-41">Listing 15-41</a>: <em>element_immutable.py:1</em></p>
<p>If I wanted to store additional attributes about elements, I could use a dictionary to associate <code>Element</code> keys with instances of some other mutable object as values that contain the rest of the data. For brevity, I won’t do that here.</p>
<p>I’ll add the special methods for converting to string, for hashing, and for comparing between <code>Element</code> instances:</p>
<pre><code>    def __repr__(self):
        return f"{self.symbol} ({self.name}): {self.number}"

<span epub:type="pagebreak" title="448" id="Page_448"/>    def __str__(self):
        return self.symbol

    def __hash__(self):
        return hash(self.symbol)

    def __eq__(self, other):
        return self.symbol == other.symbol

    def __lt__(self, other):
        return self.symbol &lt; other.symbol

    def __le__(self, other):
        return self.symbol &lt;= other.symbol</code></pre>
<p class="CodeListingCaption"><a id="listing15-42">Listing 15-42</a>: <em>element_immutable.py:2</em></p>
<p>In all these cases, I’m using <code>self.symbol</code> as the key attribute. Remember that <code>__eq__()</code>, <code>__lt__()</code>, and <code>__le__()</code> correspond to the equals (<code>==</code>), less-than (<code>&lt;</code>), and less-than-or-equals (<code>&lt;=</code>) operators, respectively. Not equals (<code>!=</code>), greater than (<code>&gt;</code>), and greater than or equals (<code>&gt;=</code>) are mirrors of these three, respectively, so I typically only need to implement one special method in each pair.</p>
<p>For objects of this class to be immutable, I have to prevent any modification of its attributes. However, I can’t just make <code>__setattr__()</code> do nothing, as it’s needed for initial assignment of values as well. Instead, I write this method to only allow assignment to uninitialized attributes:</p>
<pre><code>    def __setattr__(self, name, value):
        if hasattr(self, name):
            raise AttributeError(
                f"'{type(self)}' object attribute '{name}' is read-only"
            )
        object.__setattr__(self, name, value)</code></pre>
<p class="CodeListingCaption"><a id="listing15-43">Listing 15-43</a>: <em>element_immutable.py:3</em></p>
<p>If the attribute already exists on the instance, I raise an <code>AttributeError</code>. The message here is designed to exactly match the one raised by modifying an attribute on any true immutable class.</p>
<p>Because I’m using slots, I don’t need to worry about new attributes being added, so long as <code>__dict__</code> is not specified on <code>__slots__</code>.</p>
<p>If the attribute doesn’t already exist, I use <code>object.__setattr__()</code> to assign the value to that attribute. I cannot just call the <code>setattr()</code> function, or I’ll get infinite recursion.</p>
<p>I also must define <code>__delattr__()</code> to prevent deletion of an attribute:</p>
<pre><code>    def __delattr__(self, name):
        raise AttributeError(
            f"'{type(self)}' object attribute ′{name}' is read-only"
        )</code></pre>
<p class="CodeListingCaption"><a id="listing15-44">Listing 15-44</a>: <em>element_immutable.py:4</em></p>
<p><span epub:type="pagebreak" title="449" id="Page_449"/>The <code>__delattr__()</code> method is simpler to implement, as I don’t ever want to allow deleting an attribute from an immutable instance. Thus, any use of <code>del</code> on an attribute of this class raises an <code>AttributeError</code>.</p>
<p>This class now behaves as immutable, as you can see from the usage:</p>
<pre><code>oxygen = Element('O', 8, 'oxygen')
iron = Element('Fe', 26, 'iron')

print(oxygen)              # prints O
print(f"{iron!r}")         # prints Fe (Iron): 26

iron.atomic_mass = 55.845  # raises AttributeError
iron.symbol = "Ir"         # raises AttributeError
del iron.symbol            # raises AttributeError</code></pre>
<p class="CodeListingCaption"><a id="listing15-45">Listing 15-45</a>: <em>element_immutable.py:5</em></p>
<p>Some Python developers will happily point out that one can bypass the simulated immutability of the <code>Element</code> class by calling <code>__setattr__()</code> on the object directly:</p>
<pre><code><code>object.__setattr__(iron, 'symbol', 'Ir')</code></code></pre>
<p>While this indeed modifies the <code>iron.symbol</code> attribute, this nasty hack is a straw man argument against the pattern. No code outside of the class itself should ever call <code>__setattr__()</code>; Python and its standard library certainly never will.</p>
<p><em>Python does not pretend to be Java!</em> While it’s possible to bypass safety barriers—as is possible with most things in the Python language—if someone employs such an irrational and dirty hack, they deserve whatever bugs they’ve got coming to them. The hope of preventing such deliberate abuses does not justify the complexity and fragility of other immutability techniques, like inheriting from tuple, simulating objects with <code>namedtuple</code>, and so forth. If you want an immutable object, use <code>__slots__</code> and <code>__setattr__()</code>.</p>
<p>Alternatively, you can achieve something functionally similar with the <code>@dataclasses.dataclass(frozen=True)</code> class decorator, which is provided by the <em>dataclasses</em> module in the standard library. Dataclasses have some differences from normal classes, so if you want to use them, see the documentation at <a href="https://docs.python.org/3/library/dataclasses.html" class="LinkURL">https://docs.python.org/3/library/dataclasses.html</a>.</p>
<h2 id="h1-500920c15-0007">Single-Dispatch Generic Functions</h2>
<p class="BodyFirst">By now, you’re probably used to the idea of duck typing and its implications for function design. However, every now and then, you’ll need a function to behave differently for parameters of different types. In Python, as in most languages, you can write <em>generic functions</em> to adapt to parameter types.</p>
<p>Generic functions in Python are made possible by two decorators from the <em>functools</em> standard library module: <code>@singledispatch</code> and <code>@singledispatchmethod</code>. Both of these decorators create a <em>single-dispatch generic function</em>, which can switch between multiple function implementations, based on the type of <span epub:type="pagebreak" title="450" id="Page_450"/>the first parameter (when using <code>@singledispatch</code>) or the first parameter that isn’t <code>self</code> or <code>cls</code> (when using <code>@singledispatchmethod</code>). This is the only difference between the two decorators.</p>
<p>As an example, I’ll expand on my <code>Element</code> class from earlier. I want to be able to compare <code>Element</code> instances to each other, as well as to a string containing an element symbol or an integer representing an element number. Instead of writing one big function with an <code>if</code> statement that checks the argument against <code>isinstance()</code>, I can use single-dispatch generic functions.</p>
<p>I’ll begin by adding two <code>import</code> statements before the <code>Element</code> class definition to get the <code>@singledispatchmethod</code> and <code>@overload</code> decorators:</p>
<pre><code><b>from functools import singledispatchmethod</b>
<b>from typing import overload</b>

class Element:
  # <var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing15-46">Listing 15-46</a>: <em>element_generic.py:1</em></p>
<p>There are three slightly different ways to write a single-dispatch generic function, which I’ll cover in a moment. These techniques all work regardless of whether you’re using <code>@singledispatch</code> or <code>@singledispatchmethod</code>, except that the second decorator allows you to have <code>self</code> or <code>cls</code> as the first argument, which is why I use it here.</p>
<p>Regardless of which technique is used, the <code>__eq__()</code> method must be declared first. This first version of the method should be the most type-dynamic version, since it’ll be used as the fallback.</p>
<pre><code>    @singledispatchmethod
    def __eq__(self, other):
        return self.symbol == other.symbol</code></pre>
<p class="CodeListingCaption"><a id="listing15-47">Listing 15-47</a>: <em>element_generic.py:2</em></p>
<p>This method is declared with the <code>@singledispatchmethod</code> decorator, but it is otherwise the same as if it were an ordinary implementation of the <code>__eq__()</code> instance method.</p>
<p>The <code>@singledispatchmethod</code> decorator must be the outermost (first) decorator for it to work with other decorators, such as <code>@classmethod</code>. The <code>@singledispatch</code> decorator can typically exist anywhere in the stack of decorators, although you’re best off ensuring it’s first, to avoid surprises and because consistency is helpful.</p>
<h3 id="h2-500920c15-0016">Registering Single-Dispatch Functions with Type Hints</h3>
<p class="BodyFirst">My single-dispatch <code>__eq__()</code> method above still accepts any type. I want to add versions based on the type of the first argument. One way to do that is by registering them with the automatically created <code>@__eq__.register</code> <span epub:type="pagebreak" title="451" id="Page_451"/>decorator. In this case, I’ll create two more versions of the function: one that works with a string argument and another that works with either an integer or a floating-point number argument:</p>
<pre><code>    @__eq__.register
    def _(self, other: str):
        return self.symbol == other

    @overload
    def _(self, other: float):
        ...
    @__eq__.register
    def _(self, other: int):
        return self.number == other</code></pre>
<p class="CodeListingCaption"><a id="listing15-48">Listing 15-48</a>: <em>element_generic.py:3</em></p>
<p>The first of these methods accepts a string argument. The first parameter, the one being switched on, is annotated with a type hint for the expected type, which is a string (<code>str</code>) in this first case.</p>
<p>The second method here accepts either an integer or a float, and it is made possible with the <code>@typing.overload</code> decorator. When type hinting, you can mark one or more function headings with <code>@overload</code>, to indicate that they overload an upcoming function or method with the same name. The <em>Ellipsis</em> (<code>...</code>) is used in place of the suite of the overloaded method, so it can instead share the suite of the method below it. The function or method not decorated with <code>@overload</code> must come immediately after all the overloaded versions thereof.</p>
<p>Every single dispatch method conventionally has an underscore (<code>_</code>) as a name, to avoid undesired shadowing. The fact that they shadow each other won’t matter, since they’re being wrapped and registered, and thus, they won’t need to be bound to names themselves.</p>
<p>When the <code>__eq__()</code> method is called, the type of the first parameter is checked. If it matches the type annotation for any of the registered methods, that method is used. Otherwise, the fallback method, the one marked with the <code>@singledispatchmethod</code> decorator, is called instead.</p>
<h3 id="h2-500920c15-0017">Registering Single-Dispatch Functions with Explicit Type</h3>
<p class="BodyFirst">You can also achieve the same result without type annotations. In this case, instead of type hinting, I pass the expected type of the first non-<code>self</code> parameter to the <code>register()</code> decorator. I’ll use this technique to define my <code>__lt__() </code>method:</p>
<pre><code>    @singledispatchmethod
    def __lt__(self, other):
        return self.symbol &lt; other.symbol

    @__lt__.register(str)
    def _(self, other):
<span epub:type="pagebreak" title="452" id="Page_452"/>        return self.symbol &lt; other

    @__lt__.register(int)
    @__lt__.register(float)
    def _(self, other):
        return self.number &lt; other</code></pre>
<p class="CodeListingCaption"><a id="listing15-49">Listing 15-49</a>: <em>element_generic.py:4</em></p>
<p> As before, the first version is the most dynamic, the second accepts a string, and the third accepts either an integer or a floating-point number.</p>
<p>Although it’s not seen in this example, your single-dispatch function can accept as many arguments as you need and even different arguments on the different functions, but you can only switch method definitions on the data type of the first parameter.</p>
<h3 id="h2-500920c15-0018">Registering Single-Dispatch Functions with the register() Method</h3>
<p class="BodyFirst">The third way to register to a single-dispatch function is to call <code>register()</code> as a method, rather than as a decorator, and directly pass any callable to it. I’ll use this technique with the <code>__le__()</code> method.</p>
<pre><code>    @singledispatchmethod
    def __le__(self, other):
        return self.symbol &lt;= other.symbol

    __le__.register(str, lambda self, other: self.symbol &lt;= other)

    __le__.register(int, lambda self, other: self.number &lt;= other)
    __le__.register(float, lambda self, other: self.number &lt;= other)</code></pre>
<p class="CodeListingCaption"><a id="listing15-50">Listing 15-50</a>: <em>element_generic.py:5</em></p>
<p>In this case, I define the generic single-dispatch method first, and then I directly register lambdas for handling strings, integers, and floating-point numbers. I could pass <em>any</em> callable in place of that lambda, whether it be a previously defined function, a callable, or anything else that accepts the appropriate argument.</p>
<p>Of these three techniques, I like the lambdas the best for these basic operator special methods, since they have less boilerplate. Otherwise, for more involved functions, I prefer to work with type annotations instead.</p>
<h2 id="h1-500920c15-0008">Using the Element Class</h2>
<p class="BodyFirst">I’ve put a lot of work into this <code>Element</code> class, making it immutable and allowing the comparison of instances to strings and numbers. The benefits of all this work are apparent in the usage of the class, which I’ll demonstrate by writing a <code>Compound</code> class to represent chemical compounds:</p>
<pre><code>class Compound:

    def __init__(self, name):
<span epub:type="pagebreak" title="453" id="Page_453"/>        self.name = name.title()
        self.components = {}

    def add_element(self, element, count):
        try:
            self.components[element] += count
        except KeyError:
            self.components[element] = count

    def __str__(self):
        s = ""
        formula = self.components.copy()
        # Hill system
        if 'C' in formula.keys():
            s += f"C{formula['C']}"
            del formula['C']
            if 1 in formula.keys():
                s += f"H{formula['H']}"
                del formula['H']
        for element, count in sorted(formula.items()):
            s += f"{element.symbol}{count if count &gt; 1 else ''}"
        # substitute subscript digits for normal digits
        s = s.translate(str.maketrans("0123456789", "<sub>₀₁₂₃₄₅₆₇₈₉</sub>"))
        return s

    def __repr__(self):
        return f"{self.name}: {self}"</code></pre>
<p class="CodeListingCaption"><a id="listing15-51">Listing 15-51</a>: <em>element_generic.py:6</em></p>
<p>I’ll wager you could read through that code and understand everything going on. In short, this class allows me to instantiate a chemical compound with a name and add elements to the compound. Because <code>Element</code> is hashable and immutable, I can safely use <code>Element</code> instances as dictionary keys.</p>
<p>Because I can compare <code>Element</code> instances, either to strings representing element symbols or to integers representing element numbers, I can fairly easily implement the Hill system for outputting an empirical chemical formula for the compound.</p>
<p>Here’s the <code>Compound</code> class in use:</p>
<pre><code>hydrogen = Element('H', 1, 'hydrogen')
carbon = Element('C', 6, 'carbon')
oxygen = Element('O', 8, 'oxygen')
iron = Element('Fe', 26, 'iron')

rust = Compound("iron oxide")
rust.add_element(oxygen, count=3)
rust.add_element(iron, count=2)
print(f"{rust!r}")     # prints 'Iron Oxide: Fe₂O₃'

aspirin = Compound("acetylsalicylic acid")
aspirin.add_element(hydrogen, 8)
aspirin.add_element(oxygen, 4)
aspirin.add_element(carbon, 9)
<span epub:type="pagebreak" title="454" id="Page_454"/>print(f"{aspirin!r}")  # prints 'Acetylsalicylic Acid: C₉H₈O₄'

water = Compound("water")
water.add_element(hydrogen, 2)
water.add_element(oxygen, 1)
print(f"{water!r}")    # prints 'Water: H₂O'</code></pre>
<p class="CodeListingCaption"><a id="listing15-52">Listing 15-52</a>: <em>element_generic.py:7</em></p>
<p>I define four <code>Element</code> objects: <code>hydrogen</code>, <code>carbon</code>, <code>oxygen</code>, and <code>iron</code>. Then I use these to construct three <code>Compound</code> instances: <code>rust</code>, <code>aspirin</code>, and <code>water</code>. I print each <code>Compound</code> using the canonical string representation (from <code>__repr__()</code>) via the <code>!r</code> formatting flag.</p>
<p>As you can see, the <code>Compound</code> class and its usage are quite simple and clean, all because I designed <code>Element</code> with slots, <code>__setattr__()</code>, and single-dispatch generic functions.</p>
<h2 id="h1-500920c15-0009">Arbitrary Execution</h2>
<p class="BodyFirst">Introspection also enables <em>arbitrary execution</em>, whereby strings can be directly executed as Python code. To this end, there are some built-in functions that you will encounter sooner or later and that may appeal to your inner hacker: <code>eval()</code>, <code>compile()</code>, and <code>exec()</code>. Yet hidden dangers lurk.</p>
<p>Here’s a contrived little version of how this can go very wrong:</p>
<pre><code>with open('input.dat', 'r') as file:
    nums = [value.strip() for value in file if value]

for num in nums:
    expression = f"{num} // 2 + 2"
    try:
        answer = eval(expression)
    except (NameError, ValueError, TypeError, SyntaxError) as e:
        print(e)
    finally:
        code = "print('The answer is', answer)"
        obj = compile(code, '&lt;string&gt;', mode='exec')
        exec(obj)</code></pre>
<p class="CodeListingCaption"><a id="listing15-53">Listing 15-53</a>: <em>arbitrary.py</em></p>
<p>I read all the lines in from a file, <em>input.dat</em>, which I naively assume will contain only mathematical expressions.</p>
<p>For each line I read from <em>input.dat</em>, I compose a string containing a Python expression, which I bind to <code>expression</code>. Then I pass that string to the <code>eval()</code> built-in function, which evaluates it as a Python expression and converts it to a value that I bind to <code>answer</code>.</p>
<p>For the sake of demonstration, I compose a string containing a line of Python code, bound to <code>code</code>. I could execute it immediately as Python code by passing the string to the <code>exec()</code> built-in function. Instead, I compile it into a Python code object using <code>compile()</code>, and then I run that code <span epub:type="pagebreak" title="455" id="Page_455"/>object using <code>exec()</code>. This approach is slower for a single use but faster for code being called repeatedly. Again, I only have it here to demonstrate the technique.</p>
<p>The problem here is that arbitrary execution is a major security risk, especially as soon as it involves data provided from an external source, such as a file or user input. I’m expecting my <em>input.dat</em> to look something like this:</p>
<pre><code>40
(30 + 7)
9 * 3
0xAA &amp; 0xBB
80</code></pre>
<p class="CodeListingCaption"><a id="listing15-54">Listing 15-54</a>: <em>input.dat:1a</em></p>
<p>These values produce some neat, safe-looking output:</p>
<pre><code>The answer is 22
The answer is 20
The answer is 15
The answer is 10
The answer is 42</code></pre>
<p>The danger here is a potential security threat. What would happen if an attacker somehow modified <em>input.dat</em> to look like this?</p>
<pre><code>40
(30 + 7)
9 * 3
0xAA &amp; 0xBB
80
exec('import os') or os.system('echo \"`whoami` is DOOMED\"') == 0 or 1</code></pre>
<p class="CodeListingCaption"><a id="listing15-55">Listing 15-55</a>: <em>input.dat:1b</em></p>
<p>What would happen if I ran that code on a POSIX system, such as Linux?</p>
<pre><code>The answer is 22
The answer is 20
The answer is 15
The answer is 10
The answer is 42
jason is DOOMED
The answer is True</code></pre>
<p>That <code>jason is DOOMED</code> message should make your blood run cold, as that was <em>not</em> from a print statement; it was produced by a shell command executed directly on the operating system. This is known as a <em>code injection attack</em>, and it can lead to some pretty horrific security issues. (I’ll revisit security in <span class="xref" itemid="xref_target_Chapter 19">Chapter 19</span><span class="xref" itemid="xref_target_"/>.)</p>
<p>There are many clever and esoteric ways to inject code into a string being passed to <code>eval()</code>, <code>compile()</code>, or <code>exec()</code>. As a result, although these functions may look like the key to some truly brilliant Python code, they’re almost <span epub:type="pagebreak" title="456" id="Page_456"/>always best left alone. If you really, really need something like <code>eval()</code>, you should almost certainly use <code>ast.literal_eval()</code> instead, although it is unable to evaluate with operators (and thus, it cannot work with my <em>input.dat</em>). There are rare, advanced techniques that use <code>eval()</code>, <code>compile()</code>, or <code>exec()</code> safely, but that involve ensuring those functions can only ever receive <em>trusted</em> data, as opposed to external data, which is <em>untrusted</em>.</p>
<p>To learn more about how dangerous <code>eval()</code> (and <code>exec()</code>, by extension) is, check out Ned Batchelder’s article, <em>Eval really is dangerous: </em><a href="https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html" class="LinkURL">https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html.</a> The discussion in the comments is also insightful.</p>
<p>Some of my cleverness-loving readers will have noticed <code>os.system()</code> can be used to execute shell commands. This, too, should seldom (if ever) be employed. Use the <code>subprocess</code> module instead: <a href="https://docs.python.org/3/library/subprocess.html" class="LinkURL">https://docs.python.org/3/library/subprocess.html</a>.</p>
<h2 id="h1-500920c15-0010">Wrapping Up</h2>
<p class="BodyFirst">Classes and class instances store their attributes inside of special dictionaries, and this one detail empowers Python to know a lot about the internal composition of objects during runtime.</p>
<p>Descriptors—the magic behind properties, methods, and many other tricks—can be used to make your code easier to maintain. Slots unlock performance and enable you to write effectively immutable classes. Single-dispatch generic functions bring the versatility of overloaded functions to dynamic typing.</p>
<p>Python certainly looks magical at first blush, but it freely unlocks the backstage door and lets us in on all its illusions and secrets. By knowing how the tricks work, you, too, can write elegant classes and libraries that feel, well, dead simple to use.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="457" id="Page_457"/>16</span><br/>
<span class="ChapterTitle">Asynchrony and Concurrency</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">You know the situation: you have to finish that TPS report for your boss, fix a bug that shipped to production, and figure out which of your co-workers borrowed your stapler (it’s Jeff again, isn’t it?), all before day’s end. How will you get it all done? You can’t make copies of yourself—and even if you could, the line for the copier is out the door—so you tackle these tasks with <em>concurrency</em>.</p>
<p>It’s the same in Python. If your program needs to wait on user input, send data over a network, and crunch numbers, all while still updating the user interface, you can handle these tasks concurrently, thus improving your program’s responsiveness. </p>
<p>There are two options for achieving concurrency in Python: either threading (see <span class="xref" itemid="xref_target_Chapter 17">Chapter 17</span>), wherein the operating system manages the multitasking, or asynchrony, where Python handles it. This chapter focuses on the latter.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="458" id="Page_458"/>Theory Recap: Concurrency</h2>
<p class="BoxBodyFirst">Concurrency is the programming equivalent of multitasking: rapidly dividing a program’s singular attention between multiple tasks. It is not the same as <em>parallelism</em>, wherein multiple tasks occur simultaneously (see <span class="xref" itemid="xref_target_Chapter 17">Chapter 17</span>). A program that uses concurrency is limited to one system process, and that process can only do one thing at a time in most implementations of Python.</p>
<p>Revisiting the busy-workday example, you can write the TPS report and shake down Jeff for your stapler, but not at the same time. Even if you called Jeff into your cubicle to talk to him while you filled out the TPS report, you would be dividing your attention between the two tasks, however short the periods of focus might be. While a casual observer might conclude you are doing two things at the same time, you are really just oscillating between the different tasks.</p>
<p>This has an important implication: <em>concurrency</em> <em>does not actually speed up execution time</em>. All told, you still need to spend 10 minutes filling out the TPS report and another five interrogating Jeff. The two tasks together will take 15 minutes, whether you finish your report before talking to Jeff or divide your attention between the two. In fact, because of the additional effort it takes to switch between tasks, it may take longer when employing concurrency. The same is true in programming. These tasks are effectively <em>CPU-bound</em>, because their speed is limited by your brain’s abilities, which are analogous to the speed of the CPU. Concurrency is not helpful with CPU-bound tasks.</p>
<p>Concurrency is chiefly useful when dealing with <em>IO-bound</em> tasks, such as receiving a file over a network or waiting for a user to click a button. For example, imagine you have to laminate several copies of the meeting agenda for reasons known only to management. Each lamination job takes a couple of minutes, during which time, you’re sitting and listening to the whine of the laminator. Your effort and attention are not required. Not a very good use of time, is it? This is an IO-bound task because your speed is limited primarily by waiting for the finished laminated page (the output). Now say you employ concurrency by starting a page in the laminator and then walking away and turning the office upside-down for your stapler. Every couple of minutes, you check the laminator, perhaps feed another page through, and then resume your search. By the time you’ve found your beloved stapler in Martha’s desk drawer (sorry, Jeff!), you have also finished laminating the agendas for the meeting.</p>
<p>Concurrency is also useful for improving the <em>perceived responsiveness</em> of your program: even while the program performs a particularly long or heavy task, such as a complicated data analysis, it can respond to user input or update a progress bar. In reality, no single task is happening faster than before, but the program doesn’t hang.</p>
<p>Lastly, concurrency is useful for performing a task at regular intervals, such as saving a temporary file every five minutes, regardless of what the rest of the program is doing.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c16-0001"><span epub:type="pagebreak" title="459" id="Page_459"/>Asynchrony in Python</h2>
<p class="BodyFirst">As mentioned, there are two ways to achieve concurrency in Python. <em>Threading</em>, also known as <em>pre-emptive multitasking</em>, involves letting the operating system manage the multitasking by running each task in a single flow of execution called a <em>thread</em>. These multiple threads still share the same system <em>process</em>, which is an instance of a running computer program. If you open the system monitor on your computer, you can see a list of running processes on your machine. Any one of those processes can have multiple threads.</p>
<p>Traditional threading has a number of pitfalls, which is why I’ll come back to it in <span class="xref" itemid="xref_target_Chapter 17">Chapter 17</span>. The alternative is <em>asynchrony</em>, also known as <em>cooperative multitasking</em>. It is the easiest way to achieve concurrency in Python—but that doesn’t make it easy! The operating system only sees your code as running in a single process, with a single thread; it is Python itself that manages the multitasking, with some help from you, thereby sidestepping some of the issues that crop up with threading. Still, writing good asynchronous code in Python requires some forethought and planning. </p>
<p>It’s important to keep in mind that asynchrony is not parallelism. In Python, a mechanism called the <em>Global Interpreter Lock (GIL)</em> ensures that any single Python process is constrained to a single CPU core, regardless of how many cores are available to the system. For this reason, parallelism cannot be achieved with either asynchrony or threading. This may sound like a design flaw, but efforts to eliminate the GIL from CPython have proven more technically challenging than imagined, and the results have had poorer performance thus far. As of this writing, progress has all but stalled on the most prominent of these efforts, Larry Hastings’s Gilectomy. The GIL makes things run smoother in Python.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2><p class="BoxBodyFirst">	There are a few other ways around the GIL, such as Python extensions, because they are written in C and executed in compiled machine code. Anytime your logic leaves the Python interpreter, it also goes beyond the jurisdiction of the GIL and becomes capable of running in parallel. I won’t go into this further in this book, save mentioning a few extensions that do this in <span class="xref" itemid="xref_target_Chapter 21">Chapter 21</span>.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>Asynchrony was originally possible in Python through third-party libraries, like Twisted. Later, Python 3.5 added syntax and functionality for natively achieving asynchrony. These features did not become stable until Python 3.7; as a result, many articles and online discussions about asynchrony are profoundly out-of-date. Your best source of information is always the official documentation. I’ve done my best to be up-to-date with Python 3.10.</p>
<p>Python makes asynchrony possible with two keywords borrowed from the C# language: <code>async</code> and <code>await</code>, as well as a special type of coroutine. (Many other languages implement similar syntax; these include JavaScript, Dart, and Scala.) Asynchronous execution is managed and run by an <em>event </em><span epub:type="pagebreak" title="460" id="Page_460"/>loop, which is responsible for the multitasking. Python provides the <em>asyncio</em> module in the standard library for this purpose, and we’ll use it in this chapter’s examples. </p>
<p>It’s worth noting that at the time of this writing, <code>asyncio</code> is dauntingly complicated beyond basic usage, even to some Python experts. For that reason, I’ll stick to the essential concepts universal to asynchrony and avoid explaining or using <code>asyncio</code> any more than is absolutely unavoidable. Most of what you’ll see are just plain asynchrony techniques; I’ll call out the exceptions.</p>
<p>When you’re ready to go further into this topic of asynchrony, pick up either the Trio or Curio library. Both are written to be user-friendly. They’re well documented, with the beginner in mind, and they regularly provide design cues to <code>asyncio</code>’s developers. Armed with the knowledge from this chapter, you should be able to learn either of those libraries from their documentation.</p>
<p><em>Curio</em> was developed by David Beazley, an expert in Python and concurrency, with the goal of making asynchrony in Python more approachable. The official documentation can be found at <a href="https://curio.readthedocs.io/" class="LinkURL">https://curio.readthedocs.io/</a>. That main page also has links to a number of excellent talks on Python asynchronous programming, including several talks that guide you through writing your <em>own</em> asynchrony module (although you likely won’t ever need to do this).</p>
<p><em>Trio</em> is based on Curio, and it furthers the library’s goals of simplicity and usability. As of this writing, it’s considered somewhat experimental, but it is still stable enough to use in production. Python developers most often recommend using Trio. Find the official documentation at <a href="https://trio.readthedocs.io/en/stable/" class="LinkURL">https://trio.readthedocs.io/en/stable/</a>.</p>
<p>Earlier in this section, I mentioned the <em>Twisted</em> library, which added asynchronous behavior to Python some 20 years before asynchrony was added to the core language. It uses a number of dated patterns, rather than the modern asynchronous workflow model, but it’s still an active and viable library with many use cases. A number of popular libraries use it under the hood. Learn more at <a href="https://twistedmatrix.com/" class="LinkURL">https://twistedmatrix.com/</a>.</p>
<p>The <code>asyncio</code> official documentation can be found at <a href="https://docs.python.org/3/library/asyncio.html" class="LinkURL">https://docs.python.org/3/library/asyncio.html</a>. I recommend digging into <code>asyncio</code> in more detail only once you’re comfortable with asynchronous programming via either Trio or Curio, as well as with the analogous concepts of threading (<span class="xref" itemid="xref_target_Chapter 17">Chapter 17</span>). Your grasp of the concepts and patterns of asynchrony and concurrency will help you make sense of the <code>asyncio</code> documentation.</p>
<p>In the midst of all this, remember that asynchrony is still in its relative infancy, both in Python and in the field of computer science as a whole. The asynchronous workflow model first appeared in the F# language in 2007, based on concepts introduced in Haskell around 1999 and several papers from the early 1990s. By contrast, the related concept of threading dates to the late 1960s. Many problems in asynchrony still don’t have clear or established solutions. Who knows—you might be the first to solve one of them!</p>
<h2 id="h1-500920c16-0002"><span epub:type="pagebreak" title="461" id="Page_461"/>The Example Scenario: Collatz Game, Synchronous Version</h2>
<p class="BodyFirst">To properly demonstrate how these concepts work, I’ll create a small program that would benefit from concurrency. Because of the complexity of the issues at hand, I’ll focus entirely on this one example for this chapter and the next, so you can get used to the working details.</p>
<p>I’ll start with a <em>synchronous</em> working version, so you’ll have a solid idea of what I’m doing. The complexity of this example will demonstrate some of the common issues involved in concurrency. Simplicity is the enemy of effectiveness for examples with these concepts.</p>
<p>For the example, I’ll play with a strange phenomenon in math known as the <em>Collatz conjecture</em>, which works like this:</p>
<ol class="decimal">
<li value="1">Start with any positive integer <em>n</em>.</li>
<li value="2">If <em>n</em> is even, the next term in the sequence should be <code>n / 2</code>.</li>
<li value="3">If <em>n</em> is odd, the next term in the sequence should be <code>3 * n + 1</code>.</li>
<li value="4">If <em>n</em> is <code>1</code>, stop.</li>
</ol>
<p>Even if you start with a fantastically large number, you’ll always wind up at <code>1</code> after relatively few steps. Starting with <code>942,488,749,153,153</code>, for example, the Collatz sequence arrives at <code>1</code> in only 1,863 steps.</p>
<p>There are all sorts of things you can do with the Collatz conjecture. For this example, I’ll create a simple game that challenges the user to guess how many Collatz sequences have a particular length. I’ll restrict the range of starting numbers to integers between <code>2</code> and <code>100,000</code> (which I can also represent as <code>10**5</code>).</p>
<p>For example, exactly 782 starting numbers will yield Collatz sequences with a length of exactly 42 values. To play the game in the example, the user would enter 42 (the target length) and then guess how many starting numbers would produce Collatz sequences of the target length. If the user guessed 782, they’d win. (Okay, yes, it’s a lousy game premise, but it works for demonstrating concurrency.)</p>
<p>At the top of my module, I’ll define a constant, <code>BOUND</code>, for the maximum starting number. Counting zeros in constants is an invitation to error, so I’ll define 100,000 as a power of 10 instead:</p>
<pre><code>BOUND = 10**5</code></pre>
<p class="CodeListingCaption"><a id="listing16-1">Listing 16-1</a>: <em>collatz_sync.py:1</em></p>
<p>Next is the function for finding the number of steps in a single Collatz sequence:</p>
<pre><code>def collatz(n):
    steps = 0
    while n &gt; 1:
        if n % 2:
            n = n * 3 + 1
        else:
            n = n / 2
<span epub:type="pagebreak" title="462" id="Page_462"/>        steps += 1
    return steps</code></pre>
<p class="CodeListingCaption"><a id="listing16-2">Listing 16-2</a>: <em>collatz_sync.py:2</em></p>
<p>Nothing should surprise you here. This function follows the rules for calculating a Collatz sequence and returns the number of steps it took to reach <code>1</code>.</p>
<p>I need another function for tracking how many times a target sequence length is met:</p>
<pre><code>def length_counter(target):
    count = 0
    for i in range(2, BOUND):
        if collatz(i) == target:
            count += 1
    return count</code></pre>
<p class="CodeListingCaption"><a id="listing16-3">Listing 16-3</a>: <em>collatz_sync.py:3</em></p>
<p>This function runs <code>collatz()</code> on every possible starting integer from <code>2</code> to <code>BOUND</code> and counts how many times a Collatz sequence had exactly <code>target</code> steps. It returns this count at the end.</p>
<p>Next, I create a function for getting a positive integer from the user, which I’ll need to do a couple of times in the program run, first to get the desired Collatz target length, and second to get the user’s guess of how many starting values produce Collatz sequences of the target length:</p>
<pre><code>def get_input(prompt):
    while True:
        n = input(prompt)
        try:
            n = int(n)
        except ValueError:
            print("Value must be an integer.")
            continue
        if n &lt;= 0:
            print("Value must be positive.")
        else:
            return n</code></pre>
<p class="CodeListingCaption"><a id="listing16-4">Listing 16-4</a>: <em>collatz_sync.py:4</em></p>
<p>This function should also look pretty familiar by now. I get a string from the user with <code>input()</code>, attempt to convert it to an integer, and ensure that integer is not negative. If anything goes wrong, I display a message for the user and let them try again.</p>
<p>Tying it all together is the main function:</p>
<pre><code>def main():
    print("Collatz Sequence Counter")

    target = get_input("Collatz sequence length to search for: ")
    print(f"Searching in range 1-{BOUND}...")

<span epub:type="pagebreak" title="463" id="Page_463"/>    count = length_counter(target)
    guess = get_input("How many times do you think it will appear? ")

    if guess == count:
        print("Exactly right! I'm amazed.")
    elif abs(guess - count) &lt; 100:
        print(f"You're close! It was {count}.")
    else:
        print(f"Nope. It was {count}.")</code></pre>
<p class="CodeListingCaption"><a id="listing16-5">Listing 16-5</a>: <em>collatz_sync.py:5</em></p>
<p>I display the name of the program and ask the user to enter a target sequence length to search for. I perform the search for the sequence length with <code>length_counter()</code> and bind the result to <code>count</code>. Next, I get the user’s guess, which I bind to <code>guess</code>, and compare it to <code>count</code>, giving the user some feedback on how close their guess was.</p>
<p>Lastly, I need to execute the main function:</p>
<pre><code>if __name__ == "__main__":
    main()</code></pre>
<p class="CodeListingCaption"><a id="listing16-6">Listing 16-6</a>: <em>collatz_sync.py:6</em></p>
<p>All in all, I’ve stuck with syntax and patterns you should be familiar with by now. But running this module shows why the program could do with some concurrency:</p>
<pre><code>Collatz Sequence Counter
Collatz sequence length to search for: <var>42</var>
Searching in range 1-100000...</code></pre>
<p>At this point, the program hangs for several seconds, before continuing:</p>
<pre><code>How many times do you think it will appear? <var>456</var>
Nope. It was 782.</code></pre>
<p>It works, but it doesn’t feel particularly responsive. What’s more, if I were to increase the value of <code>BOUND</code> by even one exponential value, to <code>10**6</code>, the delay would increase dramatically; on my system, it went from 7 to 63 seconds!</p>
<p>Thankfully, there are a number of ways I could make this program feel more responsive. Over the next two chapters, I’ll point these out to you and implement the changes.</p>
<h2 id="h1-500920c16-0003">Asynchrony</h2>
<p class="BodyFirst">Let’s see how asynchrony can help my Collatz program. First, notice that the several-second delay on running <code>length_counter()</code> is <em>CPU-bound</em>, as it relates to how long it takes the CPU to perform the math. That delay will remain until I apply parallelism in the next chapter.</p>
<p><span epub:type="pagebreak" title="464" id="Page_464"/>But there’s another source of delay in this program: the user. The program has to wait for an indefinite period of time until the user enters a valid number. This part of the program is <em>IO-bound</em>, because it is limited by the response time of something external, such as user input, a network response, or another program, rather than the working speed of the CPU.</p>
<p>I can improve the program’s <em>perceived responsiveness</em>, how fast it seems to the user, by running the math concurrently with waiting for the user’s guess. The calculations themselves won’t actually happen any faster, but my users probably won’t realize that: they’ll be focusing on entering a guess while Python is running that heavy-duty math.</p>
<p>I’ll use the built-in <code>asyncio</code> module to work with asynchrony in Python, so I import it at the start of my program:</p>
<pre><code>import asyncio

BOUND = 10**5</code></pre>
<p class="CodeListingCaption"><a id="listing16-7">Listing 16-7</a>: <em>collatz_async.py:1a</em></p>
<p>As in <a href="#listing16-1" id="listinganchor16-1">Listing 16-1</a>, I’m defining my <code>BOUND</code> constant here. Now I can begin rewriting my code to be asynchronous.</p>
<h3 id="h2-500920c16-0001">Native Coroutines</h3>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>, I introduced simple coroutines, which are based on generators. Simple coroutines run until they hit a <code>yield</code> statement and then wait for data to be sent to the coroutine object with the <code>send()</code> method.</p>
<p>I’ll make my game’s code asynchronous by turning some of my program’s functions into <em>native coroutines</em>. Also called <em>coroutine functions</em>, native coroutines build on the idea of simple coroutines: instead of waiting for data to be sent, they can be paused and resumed at specific places to achieve multitasking. In the rest of this chapter, I use the terms <em>coroutine function</em> and <em>native coroutine</em> somewhat interchangeably. Be advised that when most Python developers refer to coroutines, they almost always mean native coroutines, although it never hurts to clarify.</p>
<p>You declare a native coroutine by placing the <code>async</code> keyword in front of the definition, like this:</p>
<pre><code>async def some_function():
    # ...</code></pre>
<p>However, don’t get the idea that to implement asynchrony, you only need to put the <code>async</code> keyword in front of all your function definitions. This is only the first of many steps toward making the code asynchronous.</p>
<p>When called, a coroutine function returns a native coroutine object, which is a special kind of object called an <em>awaitable</em>. These are callables that can pause and resume mid-execution. Awaitables must be called using the <code>await</code> keyword, which acts much like <code>yield from</code>. Here, I use the <code>await</code> keyword to call the awaitable coroutine function <code>some_function()</code>:</p>
<pre><code><span epub:type="pagebreak" title="465" id="Page_465"/>await some_function()</code></pre>
<p>There’s another catch: the <code>await</code> keyword can only be used within an awaitable. When a native coroutine reaches an <code>await</code>, it pauses execution until the called awaitable is finished.</p>
<p/>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2><p class="BoxBodyFirst">	Although you won’t see it in these examples, you can pass a native coroutine to a function to be called later, perhaps after some other task has been completed. When used this way, the native coroutine being passed is called a <em>callback</em>.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>A function should only be turned into a coroutine function when it calls another awaitable, performs an IO-bound task, or is specifically intended to run concurrently with another awaitable. In the Collatz game, I’ll need to make some decisions about which functions to turn into coroutine functions and which to leave as ordinary functions.</p>
<p>To begin with, consider the synchronous <code>collatz()</code> function:</p>
<pre><code>def collatz(start):
    steps = 0
    n = start
    while n &gt; 1:
        if n % 2:
            n = n * 3 + 1
        else:
            n = n / 2
        steps += 1
    return steps</code></pre>
<p class="CodeListingCaption"><a id="listing16-8">Listing 16-8</a>: <em>collatz_async.py:2</em></p>
<p>This function will always return almost instantly, so it neither needs to call an awaitable nor run concurrently with another awaitable. It can remain as a normal function.</p>
<p>Meanwhile, <code>length_counter()</code> is labor intensive and CPU-bound. I want it to run concurrently with the code that waits for the user to input a guess, so it’s a good candidate for a coroutine function. I’ll rewrite the synchronous version from <a href="#listing16-3" id="listinganchor16-3">Listing 16-3</a>:</p>
<pre><code><b>async</b> def length_counter(target):
    count = 0
    for i in range(2, BOUND):
        if collatz(i) == target:
            count += 1
        <b>await asyncio.sleep(0)</b>
    return count</code></pre>
<p class="CodeListingCaption"><a id="listing16-9">Listing 16-9</a>: <em>collatz_async.py:3</em></p>
<p><span epub:type="pagebreak" title="466" id="Page_466"/>I turn this function into a coroutine function with <code>async</code> and use <code>await asyncio.sleep(0)</code> to tell Python where the coroutine function can pause and let something else work. If I don’t <code>await</code> something in the coroutine function, it will never be paused, which would defeat the purpose of making it a coroutine function in the first place. (Trio, Curio, and <code>asyncio</code> all offer a <code>sleep()</code> awaitable.)</p>
<p>I also want to turn the IO-bound <code>get_input()</code> function into a coroutine function, as the very nature of waiting for user input involves the ability to pause and resume. This first version of the coroutine function doesn’t yet await anything else; I’ll revisit that in a bit.</p>
<pre><code><b>async</b> def get_input(prompt):
    while True:
        n = input(prompt)
        try:
            n = int(n)
        except ValueError:
            print("Value must be an integer.")
            continue
        if n &lt;= 0:
            print("Value must be positive.")
        else:
            return n</code></pre>
<p class="CodeListingCaption"><a id="listing16-10">Listing 16-10</a>: <em>collatz_async.py:4a</em></p>
<p>There’s one critical limitation to <code>await</code>: it can only be called from within an awaitable, such as a coroutine function. I want to call <code>get_input()</code> from <code>main()</code>, so <code>main()</code> must also be a coroutine function, as you’ll see in <a href="#listing16-11" id="listinganchor16-11">Listing 16-11</a>.</p>
<p>Behind the scenes, native coroutines are still used in a strikingly similar manner to simple coroutines. Because <code>length_counter()</code> is a coroutine function, I can force it to be executed manually (and synchronously) the same as I would a simple coroutine. This is just a side example that runs the coroutine function synchronously:</p>
<pre><code>f = length_counter(100)
while True:
    try:
        f.send(None)
    except StopIteration as e:
        print(e)  # prints '255'
        break</code></pre>
<p>I wouldn’t ever use this approach in production, as coroutine functions need to be run in a special way to be useful.</p>
<h3 id="h2-500920c16-0002">Tasks</h3>
<p class="BodyFirst">Now that <code>get_input()</code> and <code>length_counter()</code> are coroutine functions, I must call them using the <code>await</code> keyword. There are two different ways to invoke <span epub:type="pagebreak" title="467" id="Page_467"/>them, depending on how I want them to be run: by directly awaiting them or by scheduling them as <em>tasks</em>, which are special objects that run coroutine functions without blocking.</p>
<p>Both approaches require turning the Collatz example’s <code>main()</code> function into a coroutine function, so I’ll begin by doing that:</p>
<pre><code><b>async</b> def main():
    print("Collatz Sequence Counter")

    target = <b>await </b>get_input("Collatz sequence length to search for: ")
    print(f"Searching in range 1-{BOUND}")

    <b>length_counter_task = asyncio.create_task(length_counter(target))</b>
<b>    guess_task = asyncio.create_task(</b>
<b>        get_input("How many times do you think it will appear? ")</b>
<b>    )</b>
<b/>
<b>    count = await length_counter_task</b>
<b>    guess = await guess_task</b>

    if guess == count:
        print("Exactly right! I'm amazed.")
    elif abs(guess-count) &lt; 100:
        print(f"You're close! It was {count}.")
    else:
        print(f"Nope. It was {count}.")</code></pre>
<p class="CodeListingCaption"><a id="listing16-11">Listing 16-11</a>: <em>collatz_async.py:5a</em></p>
<p>Deciding how to call each awaitable requires some thought. First, before I can do anything else, I need to know what Collatz sequence length the user wants to search for. I call the <code>get_input()</code> coroutine function with the <code>await</code> keyword. Calling the coroutine function like this will block the program while literally awaiting the user input. This blocking is acceptable here, since we can’t do any math calculations (or, really, anything else) without that initial user input.</p>
<p>Once I have the input, I can start the calculation in <code>length_counter()</code>, which I want to run concurrently with getting the user guess via another call to <code>get_input()</code>. To do this, I schedule the native coroutines as tasks. Always schedule a <code>Task</code> object rather than instantiating it directly. <code>Here</code>, I use <code>asyncio.create_task()</code> to schedule a task.</p>
<p>The two native coroutines are now scheduled to run as soon as there’s an opening, that is, as soon as <code>main()</code> is awaiting something. I relinquish the <code>main()</code> coroutine function’s control of execution by calling <code>await</code> on one of my tasks—at the moment, it doesn’t matter which—thereby allowing another task to have a turn. Because both tasks are already scheduled, they’ll take turns until <code>length_counter_task</code> returns the value returned by the <code>length_counter()</code> coroutine function. Then the program waits on the other task, <code>guess_task</code>, until it, too, returns a value. Depending on how quickly the user entered input, <code>guess_task</code> may have been waiting to return a value even while <code>length_counter_task</code> was still running.</p>
<p><span epub:type="pagebreak" title="468" id="Page_468"/>The Trio and Curio libraries have tasks, just like <code>asyncio</code> does, although they’re created a little differently. Consult the documentation for those libraries to learn more.</p>
<h3 id="h2-500920c16-0003">The Event Loop</h3>
<p class="BodyFirst">At this point, it may seem like I’ve coded myself into a corner: coroutine functions and other awaitables must be called with <code>await</code>, but only coroutine functions can contain the <code>await</code> keyword. How can I start this program?</p>
<p>The <em>event loop</em> is the heart of asynchrony. It manages the multitasking between awaitables and provides the means of calling the first awaitable in the stack. Every asynchrony module provides an event loop mechanism. You can even write your own if you’re feeling brave. In this example, I’ll employ the default event loop provided by <code>asyncio</code>, like this:</p>
<pre><code>if __name__ == "__main__":
    <b>loop = </b><span class="CodeAnnotationCode" aria-label="annotation1">❶</span> <b>asyncio.get_event_loop()</b>
  <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> <b>loop.run_until_complete(main())</b></code></pre>
<p class="CodeListingCaption"><a id="listing16-12">Listing 16-12</a>: <em>collatz_async.py:6a</em></p>
<p>I acquire an event loop<code> </code><span class="CodeAnnotation" aria-label="annotation1">❶</span> and bind it to the name <code>loop</code>. An event loop object has a number of methods for controlling execution; in this case, I use <code>loop.run_until_complete()</code> to schedule and run the <code>main()</code> coroutine function <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p>Since this is the most common way to start an event loop, it’s not surprising that <code>asyncio</code> provides a shorter equivalent way to use the default event loop:</p>
<pre><code>if __name__ == "__main__":
    <b>asyncio.run(main())</b></code></pre>
<p class="CodeListingCaption"><a id="listing16-13">Listing 16-13</a>: <em>collatz_async.py:6b</em></p>
<p>I can now run my module, and it works.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2><p class="BoxBodyFirst">	According to <code>asyncio</code> maintainer Andrew Svetlov, the development team is in the process of improving on <code>asyncio</code>’s flawed design, including how event loops are used. If you’re reading this book in the future, perhaps using Python 3.12 or later, there’s a very good chance the above example code here is no longer the recommended approach. See the documentation!</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Alternative asynchrony modules offer some important additional mechanisms for handling multiple tasks: Curio has <code>TaskGroup</code>, while Trio has (and requires use of) <code>Nursery</code>. See the documentation for those libraries to learn more. The <code>asyncio</code> module has no analogous structures yet, and implementing them is decidedly non-trivial.</p>
<p>If you run this code, you’ll notice a remaining problem: <em>collatz_async.py</em> still hangs in the same place it did before! That’s not very practical.</p>
<h3 id="h2-500920c16-0004"><span epub:type="pagebreak" title="469" id="Page_469"/>Making It (Actually) Asynchronous</h3>
<p class="BodyFirst">The code isn’t yet behaving concurrently because of this line from <code>get_input()</code> in <a href="#listing16-10" id="listinganchor16-10">Listing 16-10</a>, which I warned you about earlier:</p>
<pre><code>        n = input(prompt)</code></pre>
<p>No matter how I write the rest of the program, <code>input()</code> is an IO-bound blocking function, so it will hog the process until the user inputs something, such as their guess. It doesn’t know how to take turns.</p>
<p>To get user input asynchronously, I must use a coroutine function equivalent to <code>input()</code>. There’s nothing of the sort in the standard library, but the third-party library <code>aioconsole</code> provides an asynchronous equivalent for <code>input()</code>, among a few other functions. I’ll need to install this package to my virtual environment.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2><p class="BoxBodyFirst">	Getting input from the <code>stdin</code> stream asynchronously is a harder problem than it appears, and it hasn’t yet been fully solved. Creating a unified-streams API is extraordinary difficult! If you’re using a different asynchronous programming library, like Trio or Curio, you’re in for quite a challenge. This is the only reason I’m using <code>asyncio</code> for the example: <code>aioconsole</code> provides a limited but effective workaround for the problem, but it’s only compatible with <code>asyncio</code>.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Once it’s installed, I import the <code>ainput</code> coroutine function I need:</p>
<pre><code>import asyncio
<b>from aioconsole import ainput</b>

BOUND = 10**5</code></pre>
<p class="CodeListingCaption"><a id="listing16-14">Listing 16-14</a>: <em>collatz_async.py:1b</em></p>
<p>The <code>ainput</code> coroutine function works exactly like the built-in function <code>input()</code>, except that it’s an awaitable, so it will periodically relinquish control of the process, allowing other awaitables to run.</p>
<p>Conventionally, asynchronous equivalents to standard library functions and modules are prepended with an <code>a</code> (for <code>async</code>). This is helpful to know because there’s not much in the way of documentation for <code>aioconsole</code>, as of this writing. With any library of this sort, assume this naming convention and identical usage to the standard library equivalent, unless otherwise informed by documentation.</p>
<p>I adjust my <code>get_input()</code> coroutine function to use <code>ainput</code>:</p>
<pre><code>async def get_input(prompt):
    while True:
        n = <b>await ainput</b>(prompt)
        try:
            n = int(n)
        except ValueError:
            print("Value must be an integer.")
            continue
<span epub:type="pagebreak" title="470" id="Page_470"/>        if n &lt;= 0:
            print("Value must be positive.")
        else:
            return n</code></pre>
<p class="CodeListingCaption"><a id="listing16-15">Listing 16-15</a>: <em>collatz_async.py:4b</em></p>
<p>Now, if I run the module, it works asynchronously. If I take more than a couple of seconds to input a valid guess, the results are printed immediately after I press <span class="Caps">enter</span>. In contrast, if I input a valid guess immediately, the delay from the CPU-bound task can still be observed. As mentioned before, concurrency only improves the perceived responsiveness of the program, not the execution speed.</p>
<h2 id="h1-500920c16-0004">Scheduling and Asynchronous Execution Flow</h2>
<p class="BodyFirst">When you’re used to the execution flow of ordinary synchronous code, asynchrony can take more than a little bit of getting used to. To help reinforce the principles I’ve introduced, I’ll break down the call stack of the complete <em>collatz_async.py</em> file.</p>
<p>At the outset of execution, I start the event loop:</p>
<pre><code>asyncio.run(main())</code></pre>
<p>This schedules the <code>main()</code> coroutine function as a task, which I’ll refer to as <code>main</code> throughout this section. Because it’s the only task scheduled, the event loop runs it immediately.</p>
<p>Next, the code needs some user input before it can logically do anything, so I <code>await</code> the return value of the coroutine function <code>get_input()</code>:</p>
<pre><code>    target = await get_input("Collatz sequence length to search for: ")</code></pre>
<p>The <code>await</code> statement causes the <code>main</code> task to relinquish control to the event loop so something else can run. The coroutine function <code>get_input()</code> is scheduled as an event in the background, it runs, and the value is returned and assigned to <code>target</code>. With that fulfilled, the <code>main</code> task proceeds.</p>
<p>Next, I schedule the <code>get_input()</code> coroutine function as a task to get the user’s guess:</p>
<pre><code>    guess_task = asyncio.create_task(
        get_input("How many times do you think it will appear? ")
    )</code></pre>
<p>The task bound to <code>guess_task</code> is scheduled, but it does not immediately start. The <code>main</code> task still has control, and it hasn’t relinquished it yet.</p>
<p>I also schedule the <code>length_counter()</code> coroutine function in the same manner:</p>
<pre><code>    length_counter_task = asyncio.create_task(length_counter(target))</code></pre>
<p><span epub:type="pagebreak" title="471" id="Page_471"/>Now, <code>length_counter_task</code> is scheduled to run at some point in the future.</p>
<p>Next, this line is executed in the <code>main</code> task:</p>
<pre><code>    count = await length_counter_task</code></pre>
<p>This code causes <code>main</code> to relinquish control to the event loop, in that it pauses and waits for <code>length_counter_task</code> to have a value for return. The event loop now has control.</p>
<p>The next scheduled task in the queue is <code>guess_task</code>, so that’s started next. The <code>get_input()</code> coroutine function runs up to the following line:</p>
<pre><code>        n = await ainput(prompt)</code></pre>
<p>Now, <code>get_input()</code> is waiting on another awaitable, <code>ainput()</code>, which is scheduled. Control is handed back to the event loop, which runs the next scheduled task, <code>length_counter_task</code>. The <code>length_counter()</code> coroutine function is started, and it runs up to its <code>await</code> command before returning control to the event loop.</p>
<p>Perhaps the user hasn’t yet input anything—only a few milliseconds have passed, after all—so the event loop checks in with <code>main</code> and <code>guess_task</code>, which are both still waiting. The event loop again checks <code>length_counter_task</code>, which does some more work before pausing again. Then, the event loop checks back with <code>ainput</code> to see if the user has entered anything yet.</p>
<p>Execution continues in this manner until something finishes.</p>
<p>Bear in mind that <code>await</code> isn’t a magical keyword that <em>itself</em> returns control to the event loop. Rather, some non-trivial logic under the hood determines which task is run next, but I won’t go into that here, in the interests of time and sanity.</p>
<p>Once the <code>length_counter_task</code> has completed and is ready to return a value, the <code>await</code> in <code>main</code> is fulfilled, and that returned value is assigned to <code>count</code>. The next line in the <code>main()</code> coroutine function is run:</p>
<pre><code>guess = await guess_task</code></pre>
<p>For the purposes of this example, suppose the <code>guess_task</code> isn’t done yet. The <code>main</code> task must wait some more, so it hands control back to the event loop, which now checks in on <code>guess_task</code>—still waiting—before checking on <code>ainput</code>. Notice it doesn’t need to check on <code>length_counter_task</code> anymore, as that task is completed.</p>
<p>Once the user enters something, <code>ainput</code> has a value to return. The event loop checks in with the still-waiting <code>main</code> task and then allows <code>guess_task</code> to store the returned value from its await in <code>n</code> and continue its execution. There are no more <code>await</code> statements in the <code>get_input()</code> coroutine function, so aside from the event loop looking in on the napping <code>main</code> task, <code>guess_task</code> is able to return a value. With its <code>await</code> fulfilled and no other tasks in the queue, <code>main</code> is given priority again, and it finishes up.</p>
<p>There’s an important rule here: the order in which concurrent tasks complete is never guaranteed! As you’ll see in the next chapter, this can lead to some interesting problems.</p>
<h3 id="h2-500920c16-0005"><span epub:type="pagebreak" title="472" id="Page_472"/>Simplifying the Code</h3>
<p class="BodyFirst">I can use the <code>asyncio.gather()</code> coroutine function instead of the prior method to run two tasks concurrently. This won’t change the functionality of the program at all from what I’m already doing, but it will make the code cleaner:</p>
<pre><code>async def main():
    print("Collatz Sequence Counter")

    target = await get_input("Collatz sequence length to search for: ")
    print(f"Searching in range 1-{BOUND}")

    <b>(guess, count) = await asyncio.gather(</b>
        <b>get_input("How many times do you think it will appear? "),</b>
        <b>length_counter(target)</b>
    <b>)</b>

    if guess == count:
        print("Exactly right! I'm amazed.")
    elif abs(guess-count) &lt; 100:
        print(f"You're close! It was {count}.")
    else:
        print(f"Nope. It was {count}.")</code></pre>
<p class="CodeListingCaption"><a id="listing16-16">Listing 16-16</a>: <em>collatz_async.py:5b</em></p>
<p>I pass the awaitables I want to run to <code>asyncio.gather()</code> in the order I want their values returned. While <code>asyncio.gather()</code> will create and schedule tasks for all native coroutines passed to it, remember not to depend on the order in which tasks will be started and run. The return values from the native coroutines are packed into a list, which is then returned from <code>asyncio.gather()</code>. In this case, I unpack the two values from the list into <code>guess</code> and <code>count</code>. The outcome is the same as that of <a href="#listing16-11">Listing 16-11</a>.</p>
<h2 id="h1-500920c16-0005">Asynchronous Iteration</h2>
<p class="BodyFirst">Iterators work with asynchrony much the same as functions do: only iterators marked as <code>async </code>support the pause-and-resume behavior. By default, looping on an iterator is blocking, unless there’s an explicit <code>await</code> somewhere in the suite. This particular feature of asynchrony has evolved quite a lot in the last several versions of Python and has only achieved some modicum of API stability in 3.7, so older code you may find will likely use outdated techniques.</p>
<p>To demonstrate this behavior, I’ll rework my Collatz example to use an asynchronously iterable class, instead of a coroutine function. Understand that this technique is overpowered for this use case. In production code, I’d have stuck with the simpler native coroutine and saved the asynchronous iterator class for more complex logic.</p>
<p><span epub:type="pagebreak" title="473" id="Page_473"/>All the new concepts below are part of the core Python language and not from <code>asyncio</code>. I start simply enough by creating a <code>Collatz</code> class, setting the bound and starting values as before:</p>
<pre><code>import asyncio
from aioconsole import ainput

BOUND = 10**5


class Collatz:

    def __init__(self):
        self.start = 2</code></pre>
<p class="CodeListingCaption"><a id="listing16-17">Listing 16-17</a>: <em>collatz_aiter.py:1</em></p>
<p>Next, I’ll write a new coroutine function that will contain all the logic for counting the steps in a single Collatz sequence. This really isn’t much of a coroutine function, as it lacks a <code>yield</code>, but this approach will be convenient for the example:</p>
<pre><code>    async def count_steps(self, start_value):
        steps = 0
        n = start_value
        while n &gt; 1:
            if n % 2:
                n = n * 3 + 1
            else:
                n = n // 2
            steps += 1
        return steps</code></pre>
<p class="CodeListingCaption"><a id="listing16-18">Listing 16-18</a>: <em>collatz_aiter.py:2</em></p>
<p>For an object to be an ordinary, synchronous iterator, it needs to implement the special methods <code>__iter__()</code> and <code>__next__()</code>. Similarly, to be an <em>asynchronous iterator</em>, it must implement the special methods <code>__aiter__()</code> and <code>__anext__()</code>. You can define an <em>asynchronous iterable</em> in the same manner, by implementing <code>__aiter__()</code>.</p>
<p>Here, I define the two special methods necessary to make Collatz an asynchronous iterator:</p>
<pre><code>    def __aiter__(self):
        return self

    async def __anext__(self):
        steps = await self.count_steps(self.start)
        self.start += 1
        if self.start == BOUND:
            raise StopAsyncIteration
        return steps</code></pre>
<p class="CodeListingCaption"><a id="listing16-19">Listing 16-19</a>: <em>collatz_aiter.py:3</em></p>
<p><span epub:type="pagebreak" title="474" id="Page_474"/>The <code>__aiter__()</code> method must return an asynchronous iterator object, which is just <code>self</code> in this case. You will notice that this method is not made awaitable with <code>async</code>. It must be directly callable.</p>
<p>The <code>__anext__()</code> special method has a couple of differences from <code>__next__()</code>. First and most importantly, it is marked <code>async</code>, making it awaitable. Otherwise, iterating over the iterator object would be blocking. Second, when there are no more values to iterate over, I raise <code>StopAsyncIteration</code>, instead of <code>StopIteration</code>, as with ordinary iterators.</p>
<p>In my <code>__anext__()</code> coroutine function, I also chose to include an <code>await</code> statement, which allows the coroutine function to pause if necessary and hand control back to the event loop. (Here, I really only do this to demonstrate that it’s possible, especially since asynchronous iterators are particularly useful when a single iterative step is time consuming. However, since the execution time of the coroutine function is so brief in this example, I could have omitted it, as the mere usage of the asynchronous iterator involves an <code>await</code> under the hood.)</p>
<p>In my <code>length_counter()</code> coroutine function, I must use an <code>async for</code> to iterate over the asynchronous iterator:</p>
<pre><code>async def length_counter(target):
    count = 0
    async for steps in <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> Collatz():
        if steps == target:
            count += 1
    return count</code></pre>
<p class="CodeListingCaption"><a id="listing16-20">Listing 16-20</a>: <em>collatz_aiter.py:4</em></p>
<p>The <code>async for</code> compound statement is specifically for iterating over an asynchronous iterator, which in this case is a <code>Collatz</code> instance <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<p>If you want to understand what’s happening under the hood here, take a look at the equivalent logic for the <code>async for</code> loop in the context of this function:</p>
<pre><code>async def length_counter(target):
    count = 0
    <b>iter = Collatz().__aiter__()</b>
<b>    running = True</b>
<b>    while running:</b>
<b>        try:</b>
<b>            steps = await iter.__anext__()</b>
<b>        except StopAsyncIteration:</b>
<b>            running = False</b>
<b>        else:</b>
<b>            if steps == target:</b>
<b>                count += 1</b>
    return count</code></pre>
<p>Notice the use of the <code>await</code> keyword when calling <code>__anext__()</code> on the iterator. An <code>async for</code> loop will hand control back to the event loop on each iteration, but if a single iteration were to take a long time, I’d need the <span epub:type="pagebreak" title="475" id="Page_475"/>additional <code>await</code> statements in the <code>__anext__()</code> coroutine function to keep it from blocking.</p>
<p>As for the rest of this version of my code, I’m reusing Listings 16-16 and 16-13. The output and behavior are the same as before.</p>
<p>As I mentioned, asynchronous iterators are definitely overpowered for my Collatz example. Most of the time, asynchronous iterators are only useful if iteration is either IO-blocking or computationally heavy enough to justify some sort of progress indicator, or perhaps for concurrency with another IO-blocking task.</p>
<h2 id="h1-500920c16-0006">Asynchronous Context Managers</h2>
<p class="BodyFirst">Context managers must also be written in a specific way to have them work with asynchrony. An asynchronous context manager has the special coroutine functions <code>__aenter__()</code> and <code>__aexit__()</code>, instead of the usual <code>__enter__()</code> and <code>__exit__()</code> special methods. Typically, you’d only write an asynchronous context manager if you needed to await something in <code>__aenter__()</code> or <code>__aexit__()</code>, such as a network connection.</p>
<p>An asynchronous context manager is used with <code>async with</code>, instead of <code>with</code>, but using it is otherwise the same as working with a regular context manager.</p>
<h2 id="h1-500920c16-0007">Asynchronous Generators</h2>
<p class="BodyFirst">You can also create <em>asynchronous generators</em>, which are identical in all manners to ordinary generators (discussed in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>), except for being compatible with asynchrony. They were introduced in Python 3.6 via PEP 525.</p>
<p>You define an asynchronous generator with <code>async def</code> but use <code>yield</code> statements as with regular generators. As these generators are asynchronous, you can use <code>await</code>, <code>async for</code>, and <code>async with</code> in their suites as needed. When the asynchronous generator is called as normal (without <code>await</code>), it produces an <em>asynchronous generator iterator</em>, which can be used just as you would an asynchronous iterator.</p>
<h2 id="h1-500920c16-0008">Other Asynchrony Concepts</h2>
<p class="BodyFirst">There are quite a number of other tools in your asynchrony toolkit: locks, pools, events, futures, and the like. Most of these concepts are borrowed from the older and considerably better-documented technique of threading, which I’ll cover in <span class="xref" itemid="xref_target_Chapter 17">Chapter 17</span>. The main reason I’ve skipped over these concepts in this chapter is that the exact usage of each one varies between asynchrony modules. If you’ve done any amount of work in concurrency before, you’ve also noticed that I skipped some important problems, including race conditions and deadlocks. I’ll introduce these issues in the next chapter as well.</p>
<p><span epub:type="pagebreak" title="476" id="Page_476"/>One other advanced concept relating to asynchrony that you should be aware of is <em>context variables</em>, or <code>contextvars</code>. These allow you to store different values in variables depending on a context, meaning two different tasks can work with the same apparent variables but in fact retrieve entirely distinct values. If you want to learn more about context variables, see the official documentation at <a href="https://docs.python.org/3/library/contextvars.html" class="LinkURL">https://docs.python.org/3/library/contextvars.html</a>. (The analogous threading concept is <em>thread-local storage</em>, which I won’t cover in this book.)</p>
<p>Anyone considering a dive into asynchrony should push onward into the next chapter, as the same problems experienced in threading and traditional concurrency can creep into asynchronous programming. The exact solutions vary from one asynchrony library to the next and may even require a bit of trailblazing. If you want to excel at asynchrony, become comfortable with threading, even if you never plan on using threads in production.</p>
<h2 id="h1-500920c16-0009">Wrapping Up</h2>
<p class="BodyFirst">The distinction between concurrency and asynchrony can be bewildering at first, so here’s a quick recap. Concurrency improves your program’s perceived responsiveness by allowing the code to do something else while waiting on an IO-bound process. It does not make your code faster, and it thus isn’t useful for CPU-bound processes where the delays come from the code itself. Asynchrony is a relatively new way of achieving concurrency entirely within the code, without needing to resort to the more complex techniques.</p>
<p>In Python, asynchronous programming is achieved with the <code>async</code>/<code>await</code> model, which introduces two keywords. Roughly, <code>async</code> means, “This structure can be used asynchronously,” and <code>await</code> means, “I’m waiting for a value, so you can do something else now, if you like.” The <code>await</code> keyword can only be used inside of a native coroutine (also known as a coroutine function), which is a function declared with <code>async def</code>.</p>
<p>Asynchronous programming primarily consists of writing native coroutines and either awaiting them with <code>await</code> or scheduling them as tasks. The order in which current tasks will complete is never guaranteed.</p>
<p>Ultimately, asynchrony relies on an event loop to manage the execution of native coroutines and concurrent tasks. The Python standard library includes <code>asyncio</code> for this purpose, although this module is sometimes considered quite complex and obtuse. There are some much more intuitive alternatives, especially Trio. Alternatively, you could write your own custom event loop that’s fit to your particular purpose, if you’re feeling brave.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="477" id="Page_477"/>17</span><br/>
<span class="ChapterTitle">Threading and Parallelism</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">Before the advent of asynchrony in Python, you had two options to improve the responsiveness of your program: <em>threading</em> and <em>multiprocessing</em>. Although the two concepts are often seen as related, and even interchangeable in some languages, they couldn’t be more different in Python.</p>
<p><em>Threading</em> is a means of achieving concurrency, which is useful in working around IO-blocking tasks, wherein the code is limited by the speed of something external, like user input, the network, or another program. It is not useful by itself for working around CPU-blocking tasks, wherein the magnitude of processing is the cause of code slowdowns.</p>
<p><em>Parallelism</em> is a technique used to deal with CPU-blocking tasks, by running different tasks at the same time on separate CPU cores. <em>Multiprocessing</em> is the way we accomplish parallelism in Python. It was introduced to the language in Python 2.6.</p>
<p>Concurrency and parallelism are often essential when programming user interfaces, scheduling events, working with networks, and performing labor-intensive tasks in code.</p>
<p><span epub:type="pagebreak" title="478" id="Page_478"/>Unsurprisingly, there is a lot to threading and multiprocessing, far beyond the conceivable scope of this book. This chapter will anchor you in the core concepts of concurrency and parallelism in Python. From there, you can consult the official documentation: <a href="https://docs.python.org/3/library/concurrency.html" class="LinkURL">https://docs.python.org/3/library/concurrency.html</a>. I’ll assume you have already read <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>, as I’ll be reworking the Collatz example I introduced throughout that chapter.</p>
<h2 id="h1-500920c17-0001">Threading</h2>
<p class="BodyFirst">A single sequence of instructions in a program is called a <em>thread of execution</em>, which is usually just referred to as a <em>thread</em>. Any Python program not written with concurrency or multiprocessing is contained within a single thread.<em> Multithreading</em>, typically just called <em>threading</em>, achieves concurrency by running multiple threads simultaneously in the same <em>process</em>, which is an instance of a running computer program.</p>
<p>In Python, only one thread can run at a time within a single process, so multiple threads have to take turns. Threading is also known as preemptive multitasking, because the operating system is <em>preempting</em>, or seizing control from, one running thread to give another thread a turn. This contrasts with asynchrony, also known as cooperative multitasking, wherein a particular task voluntarily gives up control.</p>
<p>While threading is mediated by the operating system, your code is responsible for starting the threads and managing the data they share. This is not a simple task, and a large portion of this chapter will focus on the difficulties of sharing data between threads.</p>
<h3 id="h2-500920c17-0001">Concurrency vs. Parallelism</h3>
<p class="BodyFirst">Although they are often confused, concurrency and parallelism are not the same thing! According to Go co-creator Rob Pike, <em>concurrency</em> is the composition of multiple tasks, while <em>parallelism</em> involves running multiple tasks at the same time. Parallelism can be brought in as part of a concurrent solution, but you should first understand the concurrent design of your code before you invite multiprocessing to the party. (I highly recommend watching Pike’s talk “Concurrency is not Parallelism” from the Heroku Waza conference: <a href="https://blog.golang.org/waza-talk/" class="LinkURL">https://blog.golang.org/waza-talk/</a>.)</p>
<p>In many programming languages, threading also achieves parallelism as a side effect of the language and system architecture. This is part of the reason why many confuse concurrency with parallelism. However, Python’s Global Interpreter Lock prevents this implicit parallelism, since any Python process is constrained to run on a single CPU core. </p>
<h3 id="h2-500920c17-0002">Basic Threading</h3>
<p class="BodyFirst">In Python, the <code>threading</code>, <code>concurrent.futures</code>, and <code>queue</code> modules provide all the classes, functions, and tools you’ll need to work with threading. I’ll use all three in this chapter.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2><span epub:type="pagebreak" title="479" id="Page_479"/>Pedantic Note	</h2><p class="BoxBodyFirst">The <code>threading</code> module actually uses the <code>_thread</code> module, which provides the low-level primitives for threading. While you should nearly always stick with the <code>threading</code> and <code>concurrent.futures</code> modules, which are easier to use by far, <code>_thread</code> may be of use to you if you’re doing something particularly advanced. See its documentation at <a href="https://docs.python.org/3/library/_thread.html" class="LinkURL">https://docs.python.org/3/library/_thread.html</a>.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>To use threading effectively, first identify the IO-bound tasks in your code and isolate each such task behind a single function call. This design will make it easier to thread individual tasks later.</p>
<p>In the case of my Collatz example from <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>, the function <code>get_input()</code> is IO-bound, since it waits on input from the user. The rest of the code is not IO-bound, so it can run synchronously. I want to run <code>get_input()</code> on a separate thread, so it can run concurrently with the rest of the program.</p>
<p>If you’re coding along with me, open a fresh copy of <em>collatz_sync.py</em> (Listings 16-1 through 16-6) in your code editor. In <a href="#listing17-1" id="listinganchor17-1">Listing 17-1</a>, I have the original synchronous version of the <code>collatz()</code> and <code>length_counter()</code> methods. I import the <code>threading</code> module at the top, as I’ll be using functions from that module throughout this version of my program:</p>
<pre><code><b>import threading</b>

BOUND = 10**5


def collatz(n):
    steps = 0
    while n &gt; 1:
        if n % 2:
            n = n * 3 + 1
        else:
            n = n // 2
        steps += 1
    return steps


def length_counter(target):
    count = 0
    for i in range(2, BOUND):
        if collatz(i) == target:
            count += 1
    return count</code></pre>
<p class="CodeListingCaption"><a id="listing17-1">Listing 17-1</a>: <em>collatz_threaded.py:1</em></p>
<p>I need to iron out one little wrinkle in my prior design as I introduce threading: a function being run in a separate thread cannot return a value to the caller, but all my original functions return values. I therefore need a different solution for passing those values around.</p>
<p><span epub:type="pagebreak" title="480" id="Page_480"/>The naive solution would be to create some sort of central location where the threaded function can store its data, and the most quick-and-dirty way to accomplish this is with a global name:</p>
<pre><code><b>guess = None</b>


def get_input(prompt):
    <b>global guess</b>
    while True:
        n = input(prompt)
        try:
            n = int(n)
        except ValueError:
            print("Value must be an integer.")
            continue
        if n &lt;= 0:
            print("Value must be positive.")
        else:
            <b>guess = n</b>
            return n</code></pre>
<p class="CodeListingCaption"><a id="listing17-2">Listing 17-2</a>: <em>collatz_threaded.py:2a</em></p>
<p>The <code>get_input()</code> function stores its return value in the new global name <code>guess</code> and then returns directly anyway.</p>
<p>Okay, yes, that design is repulsively non-Pythonic for this use case, and I’ll build a cleaner solution a bit later, but it’ll do for the moment. However, this version is analogous to a real-world pattern that <em>can</em> be Pythonic: you may need to allow threads to store data in a central, shared location, such as a database.</p>
<p>Now for the interesting part. I need to thread the function call—namely, <code>get_input()</code>—that I want to execute concurrently:</p>
<pre><code>def main():
    print("Collatz Sequence Counter")

    target = get_input("Collatz sequence length to search for: ")
    print(f"Searching in range 1-{BOUND}...")

<b>    t_guess = threading.Thread(</b>
<b>        target=get_input,</b>
<b>        args=("How many times do you think it will appear? ",)</b>
<b>    )</b>
<b>    t_guess.start()</b>

    count = length_counter(target)

    <b>t_guess.join()</b>

    if guess == count:
        print("Exactly right! I'm amazed.")
    elif abs(guess - count) &lt; 100:
<span epub:type="pagebreak" title="481" id="Page_481"/>        print(f"You're close! It was {count}.")
    else:
        print(f"Nope. It was {count}.")


if __name__ == "__main__":
    main()</code></pre>
<p class="CodeListingCaption"><a id="listing17-3">Listing 17-3</a>: <em>collatz_threaded.py:3a</em></p>
<p>The program can’t do anything until it gets the target value from the user, so I call <code>get_input()</code> the ordinary (synchronous) way the first time.</p>
<p>I want the <em>second</em> call to <code>get_input()</code>, wherein the user enters their guess, to run concurrently with the CPU-intensive Collatz calcuations. To run this concurrently, I create a thread with <code>threading.Thread()</code>. I pass the function to run in the thread to the <code>target=</code> keyword argument of <code>Thread()</code>. Any arguments that must be passed to the function being threaded have to be passed as a tuple to <code>args=</code>. (Note the trailing comma in the code above!) When the thread starts, it will call <code>get_input()</code> and pass it the arguments specified in <code>args=</code>. In this case, I am threading the call to <code>get_input()</code> and passing the input prompt message as a string.</p>
<p>I bind the thread object I created to <code>t_guess</code> and then start it in the background with <code>t_guess.start()</code>, so my code can continue as normal without waiting for the <code>get_input()</code> function to return.</p>
<p>Now I can start the CPU-intensive step of calling <code>length_counter()</code> synchronously. While I could thread this, too, there’s no point, as my program can’t really do anything else until <code>length_counter()</code> returns a value. Threads are quite a bit more expensive than asynchronous tasks, in terms of performance overhead for creating them. Therefore, you should only create threads when they provide a direct benefit to your program’s performance or perceived responsiveness.</p>
<p>Once <code>length_counter()</code> has finished, the program really can’t do anything more until the thread for <code>get_input()</code> is done working and has stored its return value in <code>guess</code>. I <em>join</em> the thread with <code>t_guess.join()</code>, meaning the code will wait for the thread to finish its work before continuing. If the thread is already done, the call to <code>t_guess.join()</code> it will immediately return.</p>
<p>From there, the program carries on as normal. If you run this complete program, you’ll find it has the same behavior as the asynchronous version in <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>: the calculations happen while the program waits on the user to input their guess.</p>
<h3 id="h2-500920c17-0003">Timeouts</h3>
<p class="BodyFirst">Notice that the program hangs while waiting for a thread to finish up. For <a href="#listing17-3" id="listinganchor17-3">Listing 17-3</a>, this is perfectly safe, as any delay in this scenario would come from the user being slow about entering a value. However, you would be justified in being a bit wary of this indefinite suspension. If your thread is IO-bound from using a network connection or another system process, an unexpected error might cause the thread to never return! Your program <span epub:type="pagebreak" title="482" id="Page_482"/>would hang indefinitely, without an explanation or error message, until the operating system reports to your bewildered user, <code>The program has stopped responding</code>.</p>
<p>To help mitigate this issue, you can introduce a <em>timeout</em>. This specifies the maximum time until the program gives up waiting on a thread to join, after which, it carries on with or without it.</p>
<p>To demonstrate this, I’ll annoy my Collatz game user by making the program a bit impatient. (Yes, this is an absolutely terrible game design choice, but it’s better than dragging you through a fresh example, right?)</p>
<pre><code>def main():
    # <var>--snip--</var>

    t_guess = threading.Thread(
        target=get_input,
        args=("How many times do you think it will appear? ",),
        <b>daemon=True</b>
    )
    t_guess.start()

    count = length_counter(target)

    t_guess.join(<b>timeout=1.5</b>)
    <b>if t_guess.is_alive():</b>
<b>        print("\nYou took too long to respond!")</b>
<b>        return</b>

    # <var>--snip--</var>

if __name__ == "__main__":
    main()</code></pre>
<p class="CodeListingCaption"><a id="listing17-4">Listing 17-4</a>: <em>collatz_threaded.py:3b</em></p>
<p>I pass the <code>timeout=1.5</code> keyword argument to <code>join()</code> to specify that, once the <code>join()</code> statement is reached, the program should only wait for one and a half seconds before continuing, regardless of whether the thread has finished. In effect, this means the user only has one and a half seconds to enter their answer.</p>
<p>Bear in mind, if the <code>join()</code> times out, it doesn’t actually affect the thread at all. It’s still running in the background. The main program just doesn’t wait around for it anymore.</p>
<p>To determine whether a timeout has occurred, I check whether the thread is still alive. If it is, I complain to the user and quit the program.</p>
<h3 id="h2-500920c17-0004">Daemonic Threads</h3>
<p class="BodyFirst">Another consideration is that exiting the main thread will <em>not</em> terminate the other threads. In <a href="#listing17-4" id="listinganchor17-4">Listing 17-4</a>, if I timed out waiting for the <code>t_guess</code> thread, even when I reached the return statement, ending the main flow of <span epub:type="pagebreak" title="483" id="Page_483"/>execution, that <code>t_guess</code> thread would keep running in the background indefinitely. That’s a problem, especially as the user would expect the program to have quit in its entirety.</p>
<p>Even so, Python deliberately supplies no obvious way of killing a thread, because doing so can result in some horrible effects, including utterly mangling your program state. However, without a way to abort the thread, it would hang forever after the complaint, and entering data would then do nothing. Once again, if the hanging thread were due to something like a network error, then either your program would go unresponsive, or the waiting thread would keep running in the background long after the main program was closed.</p>
<p>To mitigate this here, I make my thread <em>daemonic</em>, meaning I tie its lifespan to the lifespan of the process (the main program). When the main thread ends, all the associated daemonic threads are killed as well.</p>
<p>I define a thread as daemonic when I create it, by specifying the keyword argument <code>daemon=True</code>, as I did in <a href="#listing17-4">Listing 17-4</a>. Now, when I exit the main program, the thread is aborted too.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2><p class="BoxBodyFirst">	You have to be <em>extremely careful</em> about daemonic threads! Because they abort abruptly when your program does, they don’t finish their work or clean up after themselves. This can leave files and database connections open, changes partially written, and all manner of nasty things. Only make a thread daemonic if you are absolutely certain it’s safe to suddenly abort it <em>anytime</em>.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c17-0005">Futures and Executors</h3>
<p class="BodyFirst">That quick-and-dirty global-name technique for passing things around is less than ideal for this example, largely because global names are too easily shadowed or improperly mutated. On the other hand, I don’t want to introduce side effects into my <code>get_input()</code> function by passing some mutable collection to store the data in instead. I need a more resilient way to return a value from the thread.</p>
<p>This is possible, thanks to <em>futures</em>, which are sometimes known as promises or delays in other languages. A future is an object that will contain a value at some point in the future but can be passed around like a normal object, even before it contains that value.</p>
<p>Carrying on with our current example, I import the <code>concurrent.futures</code> module that provides futures. Futures also provide a way to create threads directly, so I no longer need the <code>threading</code> module.</p>
<pre><code><b>import concurrent.futures</b>

BOUND = 10**5

def collatz(n):
    # <var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing17-5">Listing 17-5</a>: <em>collatz_threaded.py:1b</em></p>
<p><span epub:type="pagebreak" title="484" id="Page_484"/>In this version, I won’t be needing the global name <code>guess</code> for storing the return value from <code>get_input()</code>, so I’ll just remove the two lines that use it:</p>
<pre><code>def get_input(prompt):
    while True:
        n = input(prompt)
        try:
            n = int(n)
        except ValueError:
            print("Value must be an integer.")
            continue
        if n &lt;= 0:
            print("Value must be positive.")
        else:
            return n</code></pre>
<p class="CodeListingCaption"><a id="listing17-6">Listing 17-6</a>: <em>collatz_threaded.py:2b</em></p>
<p>The function now looks like the synchronous version, although it will still work with threading via futures.</p>
<p>In my main method, I start the thread with a <code>ThreadPoolExecutor</code> object. This is a type of <em>executor</em>—an object that creates and manages threads:</p>
<pre><code>def main():
    print("Collatz Sequence Counter")

    # <var>--snip--</var>

    <b>executor = concurrent.futures.ThreadPoolExecutor()</b>
    <b>future_guess = executor.submit(</b>
<b>        get_input,</b>
<b>        "How many times do you think it will appear? "</b>
<b>    )</b>

    <b>count = length_counter(target)</b>
    <b>guess = future_guess.result()</b>
    <b>executor.shutdown()</b>

    # <var>--snip--</var>


if __name__ == "__main__":
    main()</code></pre>
<p class="CodeListingCaption"><a id="listing17-7">Listing 17-7</a>: <em>collatz_threaded.py:3c</em></p>
<p>I create a new <code>ThreadPoolExecutor</code> and bind it to the name <code>executor</code>. This name is conventional for thread pools and other executors. Then, I create a new thread in that pool with <code>executor.submit()</code>, passing the function to be threaded, as well as all its arguments. Unlike when I’m instantiating from a <code>threading.Thread</code> object, I do <em>not</em> need to wrap the arguments in a tuple.</p>
<p><span epub:type="pagebreak" title="485" id="Page_485"/>The call to <code>executor.submit()</code> returns a future, which I bind to the name <code>future_guess</code>. The future object will eventually contain the value returned by <code>get_input()</code>, but at the moment, it’s nothing more than a promise.</p>
<p>From here, I continue as normal, running those heavy calculations via <code>length_counter()</code>.</p>
<p>Once that’s done, I get the final value of the future with <code>future_guess.result()</code>. Like when joining a thread, this will hang until the thread returns a value.</p>
<p>After all the threads managed by the executor are done, I need to tell the executor to clean up after itself, which I accomplish with <code>executor.shutdown()</code>. This is safe to call, even before the threads are finished, as it will shut down the executor once all threads are finished. Once you’ve called <code>shutdown()</code> on an executor, attempting to start new threads with it will raise a <code>RuntimeError</code>.</p>
<p>A <code>with</code> statement can automatically shut down an executor in the same way it can automatically close files. This is useful, in case you forget to shut down your executor.</p>
<pre><code>def main():
    print("Collatz Sequence Counter")

    # <var>--snip--</var>

    <b>with concurrent.futures.ThreadPoolExecutor() as executor:</b>
        future_guess = executor.submit(
            get_input,
            "How many times do you think it will appear? "
        )

        count = length_counter(target)

    guess = future_guess.result()

    # <var>--snip--</var>

if __name__ == "__main__":
    main()</code></pre>
<p class="CodeListingCaption"><a id="listing17-8">Listing 17-8</a>: <em>collatz_threaded.py:3d</em></p>
<p>The call to <code>executor.shutdown()</code> occurs automatically at the end of the <code>with</code> statement. Any statements that should run concurrently with the thread(s) must be in the suite of the <code>with</code>, as it won’t be possible for main control flow to leave the <code>with</code> statement until all the threads are finished.</p>
<p>In this case, I chose to retrieve the result of the future after the thread pool has been shut down, outside of the <code>with</code> statement. This order isn’t strictly necessary,  but it doesn’t hurt, since the thread pool’s preceding shutdown also implies the thread is done, so there will be no waiting to retrieve from the future.</p>
<h3 id="h2-500920c17-0006"><span epub:type="pagebreak" title="486" id="Page_486"/>Timeouts with Futures</h3>
<p class="BodyFirst">The <code>result()</code> method on a future accepts a <code>timeout=</code> keyword argument, just as <code>join()</code> does on a <code>Thread</code> object. Unlike with <code>Thread</code> objects, you can determine if a timeout has occurred by catching the <code>concurrent.futures.TimeoutError</code> exception. However, this isn’t as simple as it seems. While you can time out on waiting, there remains the problem of stopping the hanging thread.</p>
<p>Here’s an example, although you probably shouldn’t run this, as it will hang forever:</p>
<pre><code>    count = length_counter(target)
    try:
        guess = future_guess.result(timeout=1.5)
    except concurrent.futures.TimeoutError:
        print("\nYou took too long to respond!")
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> executor.shutdown(wait=False, cancel_futures=True)
        return  # hangs forever!
    else:
        executor.shutdown()</code></pre>
<p>The trouble is, executors do not properly support daemonic threads and do not support them at all as of Python 3.9. Executors also do not offer any mechanism for canceling a thread that is already running. In handling the <code>TimeoutError</code> above, I cancel any threads that haven’t started yet<code> </code><span class="CodeAnnotation" aria-label="annotation1">❶</span>, but once a thread has been started by an executor, it cannot be stopped externally without some horrible and inexcusable hackery.</p>
<p>If a thread started by an executor might need to abort under some circumstances, you would need to plan ahead and write custom code for the thread to handle its own timeout internally. This is easier said than done, and in the case of <code>get_input()</code>, it is non-trivial and even approaches impossible. To create a timeout for user input, I have to stick with the thread-based technique.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Theory Recap: Thread Safety</h2>
<p class="BoxBodyFirst">According to developer Eiríkr Åsheim, “Some people, when confronted with a problem, think, ‘I know, I’ll use multithreading.’ Nothhw tpe yawrve o oblems [<em>sic</em>].”</p>
<p>The joke here is that, in threading, you can never predict what order the threads will finish in. You have to be prepared for this. When your code is guaranteed to work correctly with threading, it is said to be <em>thread safe</em>. Thread-safe code is straightforward enough to write in a small, well-contained example like Collatz, but larger systems often contain some sneaky thread safety issues that are an utter nightmare to debug.</p>
<p>Asynchrony, which I introduced back in <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>, is less prone to the issues I’ll describe in this section, but it is not immune! Whether you’re working with <code>async</code>/<code>await</code>, threads, or multiprocessing, be mindful of the issues that can arise with concurrency.</p>
<p><span epub:type="pagebreak" title="487" id="Page_487"/>As you’ve seen so far, threads need to pass return values and other data between one another during execution. There are really only three ways to reliably move data around between threads: <em>shared state</em>, <em>futures</em>, or <em>passing messages</em>.</p>
<p>Passing messages is considered the safest technique of the three, but it requires careful planning and may involve some significant overhead. Futures, which I used earlier, are another reliable option in specific situations. There are some pitfalls with futures that I’ll come back to.</p>
<p>Shared state, of which the global name in <a href="#listing17-2" id="listinganchor17-2">Listing 17-2</a> is an example, is the easiest-looking technique, and it has plenty of use cases. Shared state may consist of global names, mutable values, databases, streams, and files. Although it looks easy to implement, shared state is the most treacherous of the three options, because it is prone to <em>race conditions</em>. Race conditions can be particularly difficult to understand if you’re new to threading, so here’s a fairly robust real-world example.</p>
<p>Consider a shared data source in an office, such as a whiteboard list of supplies needed. Anyone can add new items to the list. To save the secretary time, the office has a tradition: if someone is going out for lunch, they can also pick up some of the items on the way back, using their company credit card. In an effort to ensure that items are not forgotten, there’s one rule: you can’t erase something from the board until you return with that item.</p>
<p>Jess is heading out for lunch at her favorite sushi place, which is right next to the office supply store, so she makes a note to herself to buy the five boxes of paperclips Peter needs for his quarterly report. A few minutes later, Vaidehi leaves to get a sandwich and decides to get something while she’s out: the five boxes of paperclips. Meanwhile, Ben does the same thing while checking out the new food truck, and so does Lisa as she heads out for a coffee break. When everyone comes back from lunch, a confused Peter is greeted with 20 boxes of paperclips on his desk!</p>
<p>The problem is that Jess, Vaidehi, Ben, and Lisa were all operating concurrently (actually, in parallel), and because of the delay between reading and updating the data on the whiteboard, none of them could have known that someone else was getting the paperclips. What’s worse, without a fair bit of detective work, it’ll be hard to know why Peter is now making a kilometer-long paperclip chain and pondering how to better manage that pesky whiteboard.</p>
<p>Race conditions can crop up when you least expect them. In the analogy, the confusion arose because there were two indivisible steps that needed to take place in sequence: reading the board and updating the board.</p>
<p>There are two different locking strategies the team can employ to prevent a race condition. The first is <em>coarse-grained locking</em>: when Jess decides to get something, she writes her name along the side of the board, thereby <em>acquiring</em> <em>a lock</em> on the board. As long as her name is there, she is the only person who can edit the whiteboard, with no exceptions! Jess “owns” the whiteboard for the <span epub:type="pagebreak" title="488" id="Page_488"/>moment. When she returns from lunch, perhaps with a bottle of correction fluid that Jacob requested, she erases her name from the whiteboard, <em>releasing</em> it for anyone else to lock.</p>
<p>Coarse-grained locking often negatively impacts performance. Nobody else could get any of the items on the whiteboard during their lunch.</p>
<p>The alternative strategy is <em>fine-grained locking</em>: Jess writes her initials next to the “correction fluid” item on the whiteboard, meaning that particular item is locked. More items can still be added to the whiteboard, and other items can be claimed and locked, but only Jess can purchase the correction fluid or update that item. When she returns to the office, she erases the item and must also release the lock by erasing her name from the board.</p>
<p>Closely related to the topic of thread safety is <em>reentrancy</em>. A reentrant function can be paused mid-execution while being called again concurrently, without any odd effects. This can be violated if a function depends on a shared resource remaining unmodified for the entire operation.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c17-0002">Race Conditions</h2>
<p class="BodyFirst">Race conditions are particularly hard to detect because a single line of code may hide many steps. For example, consider something as seemingly innocuous as incrementing an integer bound to a global name:</p>
<pre><code>count = 0

def increment():
    global count
    count += 1</code></pre>
<p class="CodeListingCaption"><a id="listing17-9">Listing 17-9</a>: <em>increment.py:1a</em></p>
<p>The augmented addition operator <code>+=</code> is not <em>atomic</em>, meaning it consists of multiple instructions under the hood. You can see this by disassembling the <code>increment()</code> function with the <code>dis</code> module:</p>
<pre><code><b>import dis</b>

count = 0

def increment():
    global count
    count += 1

<b>dis.dis(increment)</b></code></pre>
<p class="CodeListingCaption"><a id="listing17-10">Listing 17-10</a>: <em>increment.py:1b</em></p>
<p><span epub:type="pagebreak" title="489" id="Page_489"/>Running <a href="#listing17-10" id="listinganchor17-10">Listing 17-10</a> produces the following output:</p>
<pre><code>  7           0 LOAD_GLOBAL              0 (count)
              2 LOAD_CONST               1 (1)
              4 INPLACE_ADD
              6 STORE_GLOBAL             0 (count)
              8 LOAD_CONST               0 (None)
             10 RETURN_VALUE</code></pre>
<p>The 7 in the leftmost column tells us that the bytecode here corresponds to the line <code>7</code> in the Python code, which is <code>count += 1</code>. All of these Python bytecode instructions, except the last two, take place on that one line of code! The value of <code>count</code> is read, the value <code>1</code> is added, and then the new value is stored. These three steps (across five instructions) must take place in uninterrupted succession. But consider what would happen if two threads both called <code>increment()</code> at the same time, as illustrated in <a href="#table17-1" id="tableanchor17-1">Table 17-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table17-1">Table 17-1</a>: Model of Race Condition with Two Threads</p></figcaption>
<table id="table-500920c17-0001" border="1">
<thead>
<tr>
<td><b/></td>
<td><b>Thread A</b></td>
<td><b><code class="bold">count</code> (global)</b></td>
<td><b>Thread B</b></td>
<td><b/></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td>← Read</td>
<td><code>0</code></td>
<td><em>(Waiting)</em></td>
<td/>
</tr>
<tr>
<td><code>1</code></td>
<td>Increment</td>
<td><code>0</code></td>
<td><em>(Waiting)</em></td>
<td/>
</tr>
<tr>
<td><code>1</code></td>
<td><em>(Waiting)</em></td>
<td><code>0</code></td>
<td>Read →</td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>1</code></td>
<td>Write →</td>
<td><code>1</code></td>
<td><em>(Waiting)</em></td>
<td><code>0</code></td>
</tr>
<tr>
<td/>
<td><em>(Done)</em></td>
<td><code>1</code></td>
<td>Increment</td>
<td><code>1</code></td>
</tr>
<tr>
<td/>
<td/>
<td><code>1</code></td>
<td>← Write</td>
<td><code>1</code></td>
</tr>
<tr>
<td/>
<td/>
<td><code>1</code></td>
<td><em>(Done)</em></td>
<td/>
</tr>
</tbody>
</table>
</figure>
<p>Although two separate threads are supposed to increment the global <code>count</code> value, Thread B has read the value <code>0</code> from the global count before Thread A has a chance to write its updated value.</p>
<p>The worst thing about a race condition is that there is no such thing as a <code>RaceConditionError</code> exception that can be raised. There’s no error message and no linter error. Nothing is going to tell you that a race condition is happening—you can only determine it with some in-depth detective work. Since there’s no way to predict when threads will pause and resume, a race condition can hide in plain sight for ages until the perfect conditions arise for it to manifest. This accounts for a terrifying number of “can’t reproduce” bug reports.</p>
<h3 id="h2-500920c17-0007">A Race Condition Example</h3>
<p class="BodyFirst">To demonstrate thread safety techniques, I’m going to rather uselessly thread the Collatz calculations. As mentioned before, concurrency will actually <em>slow down</em> CPU-bound tasks further. However, the threading pattern I’m about <span epub:type="pagebreak" title="490" id="Page_490"/>to apply would be useful if the functions involved had only been IO-bound. I’ll also use this scenario to demonstrate multiple concurrency techniques, although some of them are ill-suited to the situation. Roll with it.</p>
<p>To reliably demonstrate a race condition, I will need to create a class to serve as a counter. I’ll use this counter, instead of a normal integer, for storing global shared state between different threads working on the Collatz calculation. Again, this would be nonsense in real life, but it ensures I can reliably reproduce a race condition for demonstration purposes:</p>
<pre><code>import concurrent.futures
import functools
import time

BOUND = 10**5

class Counter:
    count = 0

    @classmethod
    def increment(cls):
        new = cls.count + 1
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> time.sleep(0.1)  # forces the problem
        cls.count = new

    @classmethod
    def get(cls):
        return cls.count

    @classmethod
    def reset(cls):
        cls.count = 0</code></pre>
<p class="CodeListingCaption"><a id="listing17-11">Listing 17-11</a>: <em>collatz_pool.py:1a</em></p>
<p>The likelihood of a race condition increases the more time there is between sequential steps in a process, like between reading and updating data. By slipping that <code>time.sleep()</code> call into the <code>increment()</code> class method <span class="CodeAnnotation" aria-label="annotation1">❶</span>, I increase the time between calculating and storing the new count, and I thus practically guarantee the race condition will manifest.</p>
<p>Now, I’ll thread my <code>collatz()</code> function for this example and have it accept a target number as an argument. Every time the Collatz sequence generated by the function has the target number of values, I increment the <code>Counter</code> instead of returning a value:</p>
<pre><code>def collatz(<b>target, </b>n):
    steps = 0
    while n &gt; 1:
        if n % 2:
            n = n * 3 + 1
        else:
            n = n // 2
        steps += 1

<span epub:type="pagebreak" title="491" id="Page_491"/>    <b>if steps == target:</b>
<b>        Counter.increment()</b></code></pre>
<p class="CodeListingCaption"><a id="listing17-12">Listing 17-12</a>: <em>collatz_pool.py:2a</em></p>
<p>The situation is now prime for a race condition. Now, I only need to dispatch multiple threads—and my problem is aliiiiive! (Cue thunder and evil laughter.)</p>
<p>In the next section, I’ll make some adjustments to the code, merely to create the race condition I’m trying to demonstrate. Understand that the problem isn’t the threading technique itself. The code in the next section is valid. It’s the code in Listings 17-11 and 17-12 that contains the real problem, and I’ll come back around to fixing it in a little while.</p>
<h3 id="h2-500920c17-0008">Creating Multiple Threads with ThreadPoolExecutor</h3>
<p class="BodyFirst">To demonstrate the race condition, I will first do away with the <code>for</code> loop in my original <code>length_counter()</code> method and replace it with a <code>ThreadPoolExecutor</code>. This will allow me to dispatch a new thread for each individual Collatz sequence calculation:</p>
<pre><code>def length_counter(target):
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> Counter.reset()
    with concurrent.futures.ThreadPoolExecutor( <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> max_workers=5) as executor:
        func = <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> functools.partial(collatz, target)
      <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> executor.map(func, range(2, BOUND))
    return Counter.get()</code></pre>
<p class="CodeListingCaption"><a id="listing17-13">Listing 17-13</a>: <em>collatz_pool.py:3a</em></p>
<p>I start by resetting the <code>Counter</code> to <code>0</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. I define a <code>ThreadPoolExecutor</code> in a <code>with</code> statement, and I specify that it may run a maximum of five threads (also known as <em>workers</em>) at once <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p>For this arbitrary example, I pulled this maximum of five workers out of thin air. The maximum number of workers you permit can have a significant impact on your program’s performance: too few workers won’t improve responsiveness enough, but too many can bloat overhead. When using threading, it’s worth doing a bit of trial and error to find the sweet spot!</p>
<p>I need to pass two arguments to the function <code>collatz()</code>: the target number of steps (<code>target</code>) and the sequence’s starting value (<code>n</code>). The target value never changes, but each value for <code>n</code> comes from an iterable, <code>range(2, BOUND)</code>.</p>
<p>The <code>executor.map()</code> method can dispatch multiple threads iteratively. However, this method is only able to pass a single value, provided by an iterable, to the given function. Since I’m trying to dispatch my <code>collatz()</code> function, which accepts two arguments, I need another way to handle the first argument. To accomplish this, I generate a callable object with <code>functools.partial()</code>, with the <code>target</code> argument effectively passed in advance <span class="CodeAnnotation" aria-label="annotation3">❸</span>. I bind this callable object to <code>func</code>.</p>
<p>The <code>executor.map()</code> method uses the <code>range()</code> iterable to provide the values for the remaining <code>collatz()</code> argument via <code>func</code> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Each resulting <span epub:type="pagebreak" title="492" id="Page_492"/>function call will take place in a separate worker thread. The rest of this program is the same as in Listings 17-6 and 17-8.</p>
<p>If you run this code as is, you’ll see that nasty race condition at work:</p>
<pre><code>Collatz Sequence Counter
Collatz sequence length to search for: 123
Searching in range 1-100000...
How many times do you think it will appear? 210
Nope. It was 43.</code></pre>
<p>My guess of <code>210</code> should be exactly right, but the race condition interfered so badly that the calculated result was wildly inaccurate. If you run this on your computer or update the <code>time.sleep()</code> duration, you might get a completely different number, maybe even coincidentally the right number at times. That unpredictability is why race conditions are so hard to debug.</p>
<p>Now that I’ve finished creating the problem, I can begin to fix it.</p>
<h2 id="h1-500920c17-0003">Locks</h2>
<p class="BodyFirst">A <em>lock</em> can prevent race conditions by ensuring that only one thread can access a shared resource or perform an operation at a time. Any thread that wants to access a resource has to lock it first. If the resource already has a lock on it, the thread must wait until that lock is released.</p>
<p>I can resolve the race condition in the Collatz example by adding a lock to <code>Counter.increment()</code>:</p>
<pre><code>import concurrent.futures
<b>import threading</b>
import functools
import time

BOUND = 10**5


class Counter:
    count = 0
    <b>_lock = </b><span class="CodeAnnotationCode" aria-label="annotation1">❶</span> <b>threading.Lock()</b>

    @classmethod
    def increment(cls):
      <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> <b>cls._lock.acquire()</b>
        new = cls.count + 1
        time.sleep(0.1)
        cls.count = new
      <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> <b>cls._lock.release()</b>

    # <var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing17-14">Listing 17-14</a>: <em>collatz_pool.py:1b</em></p>
<p>I create a new <code>Lock</code> object, which in this case, I bind to a class attribute, <code>_lock</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Every time <code>Counter.increment()</code> is called, the thread will try to <em>acquire</em> <span epub:type="pagebreak" title="493" id="Page_493"/>(take ownership of) the lock with the lock’s <code>acquire()</code> method <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If another thread has ownership of the lock, any other call to <code>acquire()</code> will hang until that owning thread releases the lock. Once a thread acquires the lock, it can continue as before. </p>
<p>A thread must also <em>release</em> the lock, via the lock’s <code>release()</code> method, as soon as possible after finishing work with the protected resource, so other threads can continue <span class="CodeAnnotation" aria-label="annotation3">❸</span>. <em>Every lock that is acquired must be released</em>.</p>
<p>Because of this requirement, locks are also context managers. Instead of manually calling <code>acquire()</code> and <code>release()</code> on my <code>Lock</code>, I can handle both implicitly via a <code>with</code>, like this:</p>
<pre><code>    # <var>--snip--</var>
    
    @classmethod
    def increment(cls):
        <b>with cls._lock:</b>
            new = cls.count + 1
            time.sleep(0.1)
            cls.count = new

    # <var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing17-15">Listing 17-15</a>: <em>collatz_pool.py:1c</em></p>
<p>The <code>with</code> statement will acquire and release the lock automatically.</p>
<p>There’s nothing inherently magical about a <code>Lock</code>; it’s merely a glorified boolean value. Any thread can acquire an unowned <code>Lock</code>, and any thread can release a <code>Lock</code>, regardless of owner. You must ensure any code that would be prone to a race condition is hemmed in by the lock acquisition and release. Nothing prevents you from breaking the rules, but debugging such violations can be fraught with danger, or at least considerable annoyance.</p>
<h2 id="h1-500920c17-0004">Deadlock, Livelock, and Starvation</h2>
<p class="BodyFirst">A <em>deadlock</em> situation occurs when the combined current status of your locks causes all your threads to wait, with no way forward. You can visualize a deadlock as two cars moving toward each other and blocking each other from crossing a one-lane bridge.</p>
<p>The similar <em>livelock</em> situation occurs when threads keep infinitely repeating the same interactions, instead of merely waiting, which also results in no real progress. Have you ever had a conversation with a significant other to the effect of “Where do you want to eat?” “I don’t care, where do you want to eat?” If so, you have experienced a real-world example of livelock. Both threads perform work involved in waiting for or deferring to one another, but neither thread gets anywhere.</p>
<p>Deadlocks and livelocks will usually cause your program to go unresponsive, often without any messages or errors to suggest why. Whenever you’re using locks, you must be extraordinarily careful to foresee and prevent deadlock and livelock scenarios.</p>
<p><span epub:type="pagebreak" title="494" id="Page_494"/>To prevent deadlock and livelock, one must be mindful of potential circular wait conditions, in which two or more threads are all mutually waiting on one another to release resources. Because these are hard to depict believably in a code example, I’ll illustrate a common circular wait condition in <a href="#figure17-1" id="figureanchor17-1">Figure 17-1</a>.</p>
<figure>
<img src="Images/f17001.png" class="" alt="" width="325" height="172"/>
<figcaption><p><a id="figure17-1">Figure 17-1</a>: Deadlock between two processes</p></figcaption>
</figure>
<p>Threads A and B both require access to shared Resources X and Y at the same time. Thread A acquires a lock on Resource X, while Thread B concurrently acquires a lock on Resource Y. Now, Thread A is waiting on Lock B, and Thread B is waiting on Lock A. They’re deadlocked.</p>
<p>The right way to resolve a deadlock or livelock will always depend on your particular situation, but you have a couple of tools at your disposal. First, you can specify a <code>timeout=</code> on the lock’s <code>acquire()</code> method; if the call times out, it will return <code>False</code>. In the situation in <a href="#figure17-1">Figure 17-1</a>, if either thread encountered such a timeout, it could then release any locks it held, thereby allowing the other thread to proceed.</p>
<p>Second, any thread can release a lock, so you can forcibly break the deadlock if necessary. If Thread A recognizes a deadlock, it could release Thread B’s lock on Resource Y and proceed anyway, thereby breaking the deadlock. The difficulty with this method is that you risk breaking a lock even if you’re <em>not</em> in deadlock, which creates a race condition.</p>
<p>Locks are not the only culprits in a deadlock or livelock scenario. <em>Starvation</em> occurs when a thread is stuck waiting for a future or to join a thread, especially to acquire some data or resource it needs, but that thread or future never returns for some reason. This can even occur if two or more futures or threads wind up waiting for one another to complete.</p>
<p>A thread can even deadlock itself! If a single thread tries to acquire a <code>Lock</code> twice in a row without releasing it first, then it is stuck waiting for itself to release the lock it’s waiting on! If there’s any risk of this situation arising, you can use <code>threading.RLock</code>, instead of a <code>threading.Lock</code>. With an <code>RLock</code>, a single thread can acquire the same lock multiple times without deadlocking, and only the thread that acquired the lock may release it. While you still must release as many times as you acquire, a thread cannot directly deadlock itself with an <code>RLock</code>.</p>
<p>There is one catch: because an <code>RLock</code> may only be released by the owning thread, it’s much harder to break a multithread deadlock with an <code>RLock</code> than with an ordinary <code>Lock</code>.</p>
<h2 id="h1-500920c17-0005"><span epub:type="pagebreak" title="495" id="Page_495"/>Passing Messages with Queue</h2>
<p class="BodyFirst">You can sidestep the risk of race conditions and deadlocks by <em>passing messages</em>, at the cost of a bit more memory overhead. This is safer than using futures or a shared data source. Anytime futures don’t work for your situation, your default strategy for exchanging and collating data with multiple threads should be to have those threads pass messages.</p>
<p>You would typically pass messages between threads with a queue. One or more threads can push data to the queue, and one or more other threads can pull data from the queue. This is analogous to a waiter passing written orders to a kitchen in a restaurant. Neither the sender nor the receiver needs to wait on the other, unless the message queue is full or empty.</p>
<p>Python’s standard library includes the <code>queue</code> module, which provides collections that already implement thread safety and proper locking, thus negating the risk of deadlocks. Alternatively, you can use <code>collections.deque</code> in the same way for passing messages, because that collection has atomic operations like <code>append()</code> and <code>popleft()</code>, which make locking unnecessary.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2><p class="BoxBodyFirst">	Technically, a queue would still require a shared object, but it’s considered different from other shared objects. The queue is a pipeline for passing pieces of data in <em>one</em> direction, as opposed to an object where all the threads update the same shared canonical data.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>I’ll update my <em>collatz_pool.py</em> example to pass results from worker threads back to the main thread via a queue, rather than using a shared object.</p>
<pre><code>import concurrent.futures
import functools
<b>import queue</b>

BOUND = 10**5</code></pre>
<p class="CodeListingCaption"><a id="listing17-16">Listing 17-16</a>: <em>collatz_pool.py:1d</em></p>
<p>I import the <code>queue</code> module and remove that pesky <code>Counter</code>.</p>
<p>Next, I’ll adjust my <code>collatz()</code> function to push the results onto the queue:</p>
<pre><code>def collatz(<b>results</b>, n):
    steps = 0
    while n &gt; 1:
        if n % 2:
            n = n * 3 + 1
        else:
            n = n // 2
        steps += 1
    <b>results.put(steps)</b></code></pre>
<p class="CodeListingCaption"><a id="listing17-17">Listing 17-17</a>: <em>collatz_pool.py:2b</em></p>
<p><span epub:type="pagebreak" title="496" id="Page_496"/>I accept a <code>queue.Queue</code> object on the <code>results</code> parameter, and I add an item to that collection via <code>results.put()</code>.</p>
<p>My design decisions here are deliberate. Data should only flow in one direction via the queue, either input to the worker threads or output from the worker threads. Most design patterns involving queues react to the queue being empty, non-empty, or full, rather than to the contents of the data. If you try to create a queue for moving multiple types of data, it’s all too easy to create a starvation or infinite loop situation.</p>
<p>In this case, the worker threads running <code>collatz()</code> will push their output data to the queue, and <code>length_counter()</code> will pull that data in from the queue. If I had needed two-way communication, I would have implemented a second queue to handle data flow in the other direction.</p>
<p>Each worker thread running <code>collatz()</code> must also have a dedicated queue for storing results, lest concurrent calls mix up their results. To do this, I pass the queue as an argument, instead of binding it to a global name. Although this technically violates the “no side effects” principle, it’s acceptable because the queue is intended purely as a data transfer medium.</p>
<p>Here’s my updated <code>length_counter()</code> method, using the queue:</p>
<pre><code>def length_counter(target):
    <b>results = queue.Queue()</b>
    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        func = functools.partial(collatz, <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> <b>results</b>)
        executor.map(func, range(2, BOUND))
    <b>results = list(results.queue)</b>
    return <b>results.count(target)</b></code></pre>
<p class="CodeListingCaption"><a id="listing17-18">Listing 17-18</a>: <em>collatz_pool.py:3b</em></p>
<p>I create the queue object and pass it to each of the workers <span class="CodeAnnotation" aria-label="annotation1">❶</span> in the same way I passed <code>target</code> in <a href="#listing17-13" id="listinganchor17-13">Listing 17-13</a>. The workers will append the length of each generated Collatz sequence to the queue. Once they’re all done, I convert the <code>results</code> queue to a list and return the number of times the target appears in that queue.</p>
<h2 id="h1-500920c17-0006">Futures with Multiple Workers</h2>
<p class="BodyFirst">As I mentioned before, you can also solve deadlocks with futures. In fact, that’s the best option for avoiding a deadlock in this multithreaded Collatz example. Futures have little risk of deadlocking, as long as you avoid having multiple threads waiting on futures from one another.</p>
<p>I’m revising my deadlock example further, to implement futures. I only need to import the <code>concurrent.futures</code> module to use this technique:</p>
<pre><code>import concurrent.futures

BOUND = 10**5</code></pre>
<p class="CodeListingCaption"><a id="listing17-19">Listing 17-19</a>: <em>collatz_</em><em>pool.py:1e</em></p>
<p><span epub:type="pagebreak" title="497" id="Page_497"/>I can also restore my <code>collatz()</code> method to its original form, where I am only returning a single value:</p>
<pre><code>def collatz(n):
    steps = 0
    while n &gt; 1:
        if n % 2:
            n = n * 3 + 1
        else:
            n = n // 2
        steps += 1
    <b>return steps</b></code></pre>
<p class="CodeListingCaption"><a id="listing17-20">Listing 17-20</a>: <em>collatz_pool.py:2c</em></p>
<p>The <code>executor.map()</code> method returns an iterable of futures, which I can use to collect the return values from the worker threads:</p>
<pre><code>def length_counter(target):
    <b>count = 0</b>
    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        <b>for result in </b>executor.map(collatz, range(2, BOUND))<b>:</b>
            <b>if result == target:</b>
<b>                count += 1</b>
    <b>return count</b></code></pre>
<p class="CodeListingCaption"><a id="listing17-21">Listing 17-21</a>: <em>collatz_pool.py:3c</em></p>
<p>I iterate over each of the values returned by <code>executor.map()</code> and count how many of those values match the target. The <code>executor.map()</code> method is essentially a threaded drop-in replacement for the built-in <code>map()</code> function; while the input processing order is not guaranteed, the output order is. With most other techniques, you cannot rely on the order in which values are returned.</p>
<p>This is the cleanest approach of all, with minimal overhead.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Theory Recap: Parallelism</h2>
<p class="BoxBodyFirst"><em>Parallelism</em> is true multitasking, wherein multiple tasks are performed at the same time. It’s heavily leveraged in the field of <em>high-performance computing (HPC)</em>, where extraordinarily processing-intensive tasks are broken down so that they may be completed in a reasonable span of time. In parallelism, when the primary process is busy, the task is moved to a separate process running on a separate CPU core, leaving the primary process and CPU core free to do other work. This only works when there are multiple CPU cores, as any one CPU core can only work on one task at a time.</p>
<p>To use an analogy borrowed from real life, say you need to make a dozen copies of a memo for distribution around the office. The copy machine (analogous to the CPU) is slow, so the line of employees (processes) waiting to use it is very long. You have other things to do, so you ask your co-worker Sangarshanan <span epub:type="pagebreak" title="498" id="Page_498"/>to handle it for you, since he’s got some free time. The task (making copies) is moved to a separate process (Sangarshanan), leaving the primary process (you) free to do other work. When he’s done with the copies, he leaves them in your cubicle for you to pick up at your leisure.</p>
<p>Parallelism is useful with a <em>CPU-bound </em>task, because it’s primarily limited by how quickly the CPU can work. Just as the employees in line in the analogy are limited by the speed of the copy machine, CPU-bound tasks are limited by the speed of the CPU.</p>
<p>One important limitation of parallelism is that processes should not share resources! While there are techniques that allow you to bypass this limitation, they’re fraught with peril. Instead, each resource is only accessed and used by one process at a time, and processes pass messages back and forth to communicate in their own timing. This way, it will not matter in what order the processes run or which ones are running concurrently, as both of those things are unpredictable in parallelism anyway.</p>
<p>Parallelism is a fairly involved technique, with a lot of hidden pitfalls that can be difficult to debug. As a result, it should be reserved for projects that have enough significant CPU-bound tasks to justify the added complexity. If it’s a matter of preventing the user interface from freezing, concurrency (likely via asynchrony) is the better option.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c17-0007">Achieving Parallelism with Multiprocessing</h2>
<p class="BodyFirst">Since Python 2.6, parallelism is possible via <em>multiprocessing</em>, wherein parallel tasks are handled by entirely separate system processes, each with its own dedicated instance of the Python interpreter. Multiprocessing bypasses the limitations imposed by Python’s Global Interpreter Lock (GIL), since each process has its own Python interpreter, and thus its own GIL. This allows a single Python program to employ parallelism. A computer can run these multiple processes simultaneously by distributing them among different CPU cores, to be worked on at the same time. How processes are divided up among cores is the prerogative of the operating system.</p>
<p>Remember that multiprocessing has performance costs of its own, so merely adding it to your code will not automatically make everything faster. Improving performance requires dedicated thought and work. As with threading and asynchrony, you must carefully consider your code’s design when implementing multiprocessing. You’ll see these principles in action shortly.</p>
<p>Multiprocessing in Python follows a very similar structure to threading. <code>Process</code> objects are used exactly like <code>Thread</code> objects. The <code>multiprocessing</code> module also provides classes like <code>Queue</code> and <code>Event</code>, which are analogous to their threading-based cousins but specifically designed for multiprocessing. The <code>concurrent.futures</code> module provides <code>ProcessPoolExecutor</code>, which looks and acts much the same as <code>ThreadPoolExecutor</code> and makes it possible to use futures.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2><span epub:type="pagebreak" title="499" id="Page_499"/>GOTCHA Alert</h2><p class="BoxBodyFirst">	Multiprocessing seldom works in the interactive interpreter, because <code>__main__</code> must be importable by subprocesses. You will need to run the code from a module or package instead.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c17-0009">Pickling Data</h3>
<p class="BodyFirst">Some Python developers recoil at the thought of using <code>multiprocessing</code> for one reason: it uses <code>pickle</code> behind the scenes. If you recall from <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>, <code>pickle</code> is extraordinarily slow and insecure as a data serialization format, so much so that Pythonistas avoid it like the plague, with good reason.</p>
<p>Even so, <code>pickle</code> does work reasonably well in the context of multiprocessing. First, we don’t need to worry about <code>pickle</code> being insecure, because it is being used to transfer data directly between active processes started and managed by your code, so that data is considered trusted. Second, many of <code>pickle</code>’s performance issues are offset by the tangible performance gains afforded by parallelism and the fact that the serialized data is never being written to a file, which is itself a CPU-intensive task.</p>
<p>Moreover, because <code>pickle</code> is used in multiprocessing, it is still actively maintained and improved; Python 3.8 saw the implementation of <code>pickle</code> protocol 5. You typically don’t need to worry about <code>pickle</code> when using multiprocessing; it’s merely an implementation detail most of the time.</p>
<p>It is important to remember that data must be <em>picklable</em>, meaning it can be serialized by the <code>pickle</code> protocol, for it to be passed between processes. According to the documentation, you can pickle the following data types:</p>
<ol class="none">
<li><code>None</code></li>
<li><code>True</code> and <code>False</code></li>
<li>Integers</li>
<li>Floating-point numbers</li>
<li>Complex numbers</li>
<li>Strings</li>
<li>Bytes-like objects</li>
<li>Tuples, lists, sets, and dictionaries only containing picklable objects</li>
<li>Functions (<em>but not lambdas</em>) at global scope</li>
<li>Classes at global scope, with additional requirements</li>
</ol>
<p>For a class to be picklable, all of its instance attributes must be picklable and stored in the instance <code>__dict__</code> attribute. When a class is pickled, methods and class attributes are omitted, along with anything else in the class <code>__dict__</code> attribute. Alternatively, if a class uses slots or otherwise cannot fulfill this criteria, you can make it picklable by implementing the special instance method <code>__getstate__()</code>, which should return a picklable object. Typically, this would be a dictionary of picklable attributes. If the method returns <code>False</code>, it signals the class as unpicklable.</p>
<p>You can also implement the special instance method <code>__setstate__(state)</code>, which accepts an unpickled object, which you would unpack into the instance <span epub:type="pagebreak" title="500" id="Page_500"/>attributes as appropriate. This is a more time-consuming approach, but it’s a good way around the restrictions. If you don’t define this method, one will be created automatically that accepts a dictionary and assigns it directly to the instance’s <code>__dict__</code> attribute.</p>
<p>If you’re going to work a lot with picklable data, especially in the context of multithreading, it may be helpful to see the official documentation for the <code>pickle</code> module: <a href="https://docs.python.org/3/library/pickle.html" class="LinkURL">https://docs.python.org/3/library/pickle.html</a>.</p>
<h3 id="h2-500920c17-0010">Speed Considerations and ProcessPoolExecutor</h3>
<p class="BodyFirst">Multiprocessing gets around the GIL, allowing the code to use multiple processes, so you might assume it will speed up that CPU-bound activity of calculating the Collatz sequences. Let’s test out that idea.</p>
<p>Continuing from the previous example, I can make use of multiprocessing by swapping my <code>ThreadPoolExecutor</code> to a <code>ProcessPoolExecutor</code>. I can reuse Listings 17-19 and 17-20 (not shown below) and modify <a href="#listing17-21" id="listinganchor17-21">Listing 17-21</a> to look like this:</p>
<pre><code>def length_counter(target):
    count = 0
    with concurrent.futures.<b>ProcessPoolExecutor()</b> as executor:
        for result in executor.map(collatz, range(2, BOUND)):
            if result == target:
                count += 1
    return count</code></pre>
<p class="CodeListingCaption"><a id="listing17-22">Listing 17-22</a>: <em>collatz_multi.py:3a</em></p>
<p>All I needed to do was to replace <code>ThreadPoolExecutor</code> with <code>ProcessPoolExecutor</code>. Here, I didn’t specify <code>max_workers</code> on the <code>ProcessPoolExecutor</code>, so it defaults to one worker per processor core on the machine. I happen to be on an 8-core machine, so when I run this code on my machine, the <code>ProcessPoolExecutor</code> will default to a <code>max_workers</code> value of 8. Your machine may be different.</p>
<p>I’m still using Listings 17-6 and 17-8 for the rest of the program, which threads the IO-bound task of getting user input. There’s no sense in using multiprocessing to handle an IO-bound task.</p>
<p>If I run this program, however, it is actually the slowest version yet! My computer has an Intel i7 8-core processor, but it took a whopping <em>21 seconds</em> to get the results. The version with the <code>ThreadPoolExecutor</code> and futures (<a href="#listing17-18" id="listinganchor17-18">Listing 17-18</a>) took 8 seconds, and the version that didn’t thread the calculations at all (<a href="#listing17-1">Listing 17-1</a>) took less than 3 seconds.</p>
<p>Rest assured, the code is indeed creating multiple <em>subprocesses</em>—separate processes linked to the main process—and bypassing the GIL. The problem is, subprocesses themselves are extremely expensive to create and manage! The overhead of multiprocessing is outweighing any performance gains I might have.</p>
<p>Alternatively, I could drop the threading on the IO-bound task and instead move the CPU-bound task out to a single subprocess. However, <span epub:type="pagebreak" title="501" id="Page_501"/>that results in roughly the same performance as seen with threading alone, negating the point of multiprocessing here.</p>
<p>One cannot simply throw parallelism at a problem and expect the code to run faster. Effective multiprocessing requires planning. In order to take proper advantage of multiprocessing, I need to give each subprocess a reasonable amount of work to do. As you’ve seen, if I create too many subprocesses, the overhead of the multiprocessing nullifies any performance gains. If I create too few, there will be little to no difference from running it on a single subprocess.</p>
<p>I don’t want to create a new subprocess for each call to <code>collatz()</code>, as I did before—a hundred thousand subprocesses is a huge strain on the system resources! Instead, I’ll divide those among four separate subprocesses, each of which performs a quarter of the work. I can do this by <em>chunking</em>: defining how much of the work is given to a single subprocess:</p>
<pre><code>def length_counter(target):
    count = 0
    with concurrent.futures.ProcessPoolExecutor() as executor:
        for result in executor.map(
            collatz,
            range(2, BOUND)<b>,</b>
            <b>chunksize=BOUND//4</b>
        ):
            if result == target:
                count += 1
    return count</code></pre>
<p class="CodeListingCaption"><a id="listing17-23">Listing 17-23</a>: <em>collatz_multi.py:3b</em></p>
<p>Within the <code>executor.map()</code> method, I use the keyword argument <code>chunksize</code> to specify that roughly one-quarter of the values being passed should go to each subprocess.</p>
<p>When I run the code, I find this version to be the fastest yet! With a <code>BOUND = 10**5</code>, it completes almost instantaneously. If I increase <code>BOUND</code> to <code>10**6</code>, this version takes 5 seconds, versus 16 seconds for the final version of <em>collatz_threaded.py</em>. I can play with the chunking to find the ideal value, which is indeed <code>4</code>; any higher value in this scenario won’t make the program run faster than 5 seconds, and a value smaller than <code>4</code> is slower.</p>
<p>By carefully applying parallelism, I can bypass the GIL and speed up CPU-bound tasks.</p>
<h2 id="h1-500920c17-0008">The Producer/Consumer Problem</h2>
<p class="BodyFirst">In parallelism and concurrency, one often classifies threads or processes as either <em>producers</em>, which provide data, or <em>consumers</em>, which intake that data and process it. It’s possible for a thread or process to be both a producer and a consumer. The <em>producer/consumer problem</em> is a common situation in which one or more producers provide data, which is then processed by one or more consumers. The producers and consumers are working independently of one <span epub:type="pagebreak" title="502" id="Page_502"/>another, at potentially different speeds. The producer might produce values faster than the consumers can process them, or the consumers might process the data faster than it is produced. The challenge is preventing the queue of data being processed from getting too full, lest the consumers wait forever because they don’t know whether the producer is slow or finished.</p>
<p>I’ll model the producer/consumer problem with the Collatz example, merely so I don’t need to build up a brand-new example. I’ll have one producer provide the starting values of the Collatz sequences, and I’ll have four consumers working in parallel to generate the sequences from those starting values and to determine how many have the target number of steps. (In practice, this pattern is overkill for something as simple as the Collatz example.)</p>
<p>At first blush, this program seems like it should be easy to write: create a queue, fill it with the starting values, and then start four subprocesses on the executor to take values out of that queue. In practice, there are a few problems that need to be solved.</p>
<p>First, I cannot wait until the producer has produced all the values before processing. If I tried to pack all the values into the queue at once, I’d have a whopping 3.8 MiB if I set my <code>BOUND</code> to <code>10**7</code>; real-world examples of the producer-consumer problem can involve gigabytes or terabytes of data. Instead, the producer should provide more values only when there’s space in the queue for them.</p>
<p>Second, the consumers need to know the difference between the queue being empty because the values are exhausted and the queue being empty because the producer is working on adding more. If something goes wrong to prevent values being added—or, conversely, if something prevents the consumers from processing values—then the code should be able to handle that error gracefully, rather than waiting forever for something to happen. Similarly, when the program is ready to end, each thread or subprocess should clean up after itself—closing files and streams, for example—rather than aborting abruptly.</p>
<p>Third, and perhaps hardest to implement, producers and consumers must be reentrant. In other words, if a consumer is paused mid-execution and another consumer is started before the first is resumed, the two consumers should not interfere with one another. Otherwise, they may be in danger of deadlocking (or livelocking) in subtle and unexpected ways.</p>
<h3 id="h2-500920c17-0011">Importing the Modules</h3>
<p class="BodyFirst">I’m going to need quite a few modules to accomplish this program:</p>
<pre><code>import concurrent.futures
import multiprocessing
import queue
import itertools
import signal
import time

BOUND = 10**5</code></pre>
<p class="CodeListingCaption"><a id="listing17-24">Listing 17-24</a>: <em>collatz_producer_consumer.py:1</em></p>
<p><span epub:type="pagebreak" title="503" id="Page_503"/>As before, the <code>concurrent.futures</code> module allows me to work with both threads and processes. The <code>multiprocessing</code> module provides the parallelism-specific versions of concurrency classes, including <code>multiprocessing.Queue</code> and <code>multiprocessing.Event</code>. The <code>queue</code> module provides the exceptions related to <code>Queue</code>. I’ll also need <code>repeat</code> from <code>itertools</code> when dispatching consumers in my particular use case.</p>
<p>The <code>signal</code> module, which may be new to you, allows me to asynchronously monitor for and respond to process control signals coming from the operating system. This is important to ensuring that all my subprocesses shut down cleanly. I’ll come back to this in a moment.</p>
<h3 id="h2-500920c17-0012">Monitoring the Queue</h3>
<p class="BodyFirst">I need two shared objects from the <code>multiprocessing</code> module for the producer/consumer model to work. The <code>Queue</code> stores the data being passed from producer to consumer, and <code>Event</code> signals when no more data will be added to the <code>Queue</code> by the producer.</p>
<pre><code>in_queue = multiprocessing.Queue(100)
exit_event = multiprocessing.Event()</code></pre>
<p class="CodeListingCaption"><a id="listing17-25">Listing 17-25</a>: <em>collatz_producer_consumer.py:2</em></p>
<p>I’m using global names for these two objects because, unlike with threads, you cannot pass shared objects via arguments when dispatching subprocesses.</p>
<p>The producer subprocess will fill the queue with starting values, and the consumer subprocesses will read from it. The <code>multiprocessing.Queue</code> class has atomic <code>put()</code> and <code>get()</code> methods, like <code>queue.Queue</code>, so it isn’t prone to race conditions. I pass the argument <code>100</code> to the <code>Queue</code> initializer here, which sets the queue to hold a maximum of <code>100</code> items. The maximum is somewhat arbitrary; you should experiment for your use cases.</p>
<p>The <code>exit_event</code> object is an <em>event</em>, a special flag that processes can monitor and react to. In this case, the event signals either that the producer will be adding no more values to the queue, or that the program itself has been aborted. The <code>threading</code> module provides an analogous <code>Event</code> object for concurrency.</p>
<p>You’ll see both of these at work shortly.</p>
<h3 id="h2-500920c17-0013">Subprocess Cleanup</h3>
<p class="BodyFirst">It is each subprocess’s duty to clean up after itself and shut down properly. When the producer is finished producing data, the consumers need to process the remaining data in the queue and then clean themselves up. Similarly, if the main program is aborted, the subprocesses must all be informed so they can shut themselves down.</p>
<p>To handle both of these situations, I’ll write my consumer and producer functions to monitor and respond to <code>exit_event</code>.</p>
<pre><code><span epub:type="pagebreak" title="504" id="Page_504"/>def exit_handler(signum, frame):
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> exit_event.set()


signal.signal(<span class="CodeAnnotationCode" aria-label="annotation2">❷</span> signal.SIGINT, exit_handler)
signal.signal(<span class="CodeAnnotationCode" aria-label="annotation3">❸</span> signal.SIGTERM, exit_handler)</code></pre>
<p class="CodeListingCaption"><a id="listing17-26">Listing 17-26</a>: <em>collatz_producer_consumer.py:3</em></p>
<p>I define an <em>event handler function</em>, <code>exit_handler()</code>, which is designed to respond to operating system events. The event handler function must accept two arguments: the <em>signal number</em> that corresponds to a particular system event and the current <em>stack frame</em>, which is roughly the current location and scope in the code. Both values will be provided automatically, so there’s no need to worry about figuring out what they should be.</p>
<p>The <code>exit_handler()</code> function will set <code>exit_event</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Later, I’ll write my processes to clean up and shut down in response to <code>exit_event</code>.</p>
<p>I attach the handler to the two signals I want to monitor: <code>signal.SIGTERM</code> occurs when the main process terminates <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and <code>signal.SIGINT</code> occurs when it is interrupted, such as with <span class="Caps">Ctrl</span>-<span class="Caps">C</span> on POSIX systems <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>
<h3 id="h2-500920c17-0014">Consumers</h3>
<p class="BodyFirst">Here’s my usual <code>collatz()</code> function, as well as my consumer function:</p>
<pre><code>def collatz(n):
    steps = 0
    while n &gt; 1:
        if n % 2:
            n = n * 3 + 1
        else:
            n = n // 2
        steps += 1
    return steps


def collatz_consumer(target):
    count = 0
    while True:
        if not in_queue.empty():
            try:
                n = in_queue.get( <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> timeout=1)
            except queue.Empty:
                return count

            if collatz(n) == target:
                count += 1

        if exit_event.is_set():
            return count</code></pre>
<p class="CodeListingCaption"><a id="listing17-27">Listing 17-27</a>: <em>collatz_producer_consumer.py:4</em></p>
<p><span epub:type="pagebreak" title="505" id="Page_505"/>The <code>collatz_consumer()</code> function accepts one argument: the <code>target</code> it is looking for. It loops infinitely, until explicitly exited with a <code>return</code> statement.</p>
<p>On each iteration, the consumer function checks whether the shared queue, <code>in_queue</code>, has anything in it. If it does, the function attempts to get the next item from the queue with <code>in_queue.get()</code>, which waits until there’s an item in the queue. I provide a <code>timeout</code> of one second <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which is important to prevent deadlocks and to give the subprocess an opportunity to check and respond to events. One second is more than ample time for my producer process to put a new item into the queue. If <code>in_queue.get()</code> times out, the exception <code>queue.Empty</code> is raised, and I exit the subprocess immediately.</p>
<p>If the consumer is able to get a value from the queue, it runs the value through <code>collatz()</code>, checks the returned value against <code>target</code>, and updates <code>count</code> accordingly.</p>
<p>Finally, I check if <code>exit_event</code> is set; if it is, I return <code>count</code>, ending the subprocess cleanly.</p>
<h3 id="h2-500920c17-0015">Checking for an Empty Queue</h3>
<p class="BodyFirst">If you look at the documentation for <code>multiprocessing.Queue.empty()</code> (<code>queue.empty()</code> in <a href="#listing17-27" id="listinganchor17-27">Listing 17-27</a>) and similar methods, there’s a rather ominous statement:</p>
<blockquote class="blockquote">
<p class="Blockquote">Because of multithreading/multiprocessing semantics, this is not reliable.</p>
</blockquote>
<p>This does not mean you cannot use the <code>empty()</code> method. The “unreliability” has to do with the dynamics I’ve already described at work in concurrency. By the time the subprocess determines that the queue is empty via the <code>empty()</code> method, it might <em>not</em> be empty anymore, since the producer is operating in parallel. This is okay, however. There’s no harm in another iteration passing if the timing is off.</p>
<p>This dynamic really only becomes treacherous if you rely on <code>empty()</code> to ensure you can <code>put()</code> a new item in the queue. The queue might be filled up before the subprocess even reaches <code>put()</code>, even if it’s the next statement. The same is true of checking <code>full()</code> before calling <code>get()</code>. That’s why I invert the logic and check that the queue <em>is not</em> empty, while still wrapping the <code>get()</code> statement in a <code>try</code> clause.</p>
<h3 id="h2-500920c17-0016">Producers</h3>
<p class="BodyFirst">Enough about the consumer. It’s time to put some values in that queue with the producer. The producer function for the Collatz example pushes values to the queue when there’s an empty spot to do so:</p>
<pre><code>def range_producer():
    for n in range(2, BOUND):
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> if exit_event.is_set():
            return
        try:
          <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> in_queue.put(n, timeout=1)
<span epub:type="pagebreak" title="506" id="Page_506"/>        except queue.Full:
          <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> exit_event.set()
            return

    while True:
        time.sleep(0.05)
        if in_queue.empty():
            exit_event.set()
            return</code></pre>
<p class="CodeListingCaption"><a id="listing17-28">Listing 17-28</a>: <em>collatz_producer_consumer.py:5</em></p>
<p>In addition to pushing values to the queue when it isn’t full, the producer function always checks if <code>exit_event</code> is set, so it can exit cleanly as soon as possible <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<p>I next try to put a value on the queue with <code>put()</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In this particular example, if the operation takes more than a second, I want it to time out and thus indicate that the consumers have deadlocked or crashed in some way. If there’s a timeout, the <code>queue.Full</code> exception is raised, and I set the <code>exit_event</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span> and end the subprocess. Bear in mind, each situation will have its own ideal timeouts, which you’ll have to figure out for yourself. It’s better to have too long a timeout, rather than one that’s too short.</p>
<p>If the loop reaches its end without a timeout, I don’t want to set the <code>exit_event</code> right away, as that might cause the consumers to quit too early and not process some waiting items. Instead, I loop infinitely, checking whether the queue is empty. I can rely on the <code>empty()</code> method here to inform me when the consumers are finished processing the data, since this is the only producer adding values to the queue. On each iteration here, I also sleep for a few milliseconds, so the producer doesn’t chew through processing power while it waits. Once the queue is empty, I set the <code>exit_event</code>. Then I exit the function, ending the subprocess.</p>
<h3 id="h2-500920c17-0017">Starting the Processes</h3>
<p class="BodyFirst">Now that I have written my producers and consumers, it’s time to dispatch them. I’ll run the producer and all four consumers as subprocesses, which I start with a <code>ProcessPoolExecutor</code>:</p>
<pre><code>def length_counter(target):
    with concurrent.futures.ProcessPoolExecutor() as executor:
        executor.submit( <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> range_producer)
        results = <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> executor.map(
            collatz_consumer,
          <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> itertools.repeat(target, 4)
        )

    return <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> sum(results)</code></pre>
<p class="CodeListingCaption"><a id="listing17-29">Listing 17-29</a>: <em>collatz_producer_consumer.py:6</em></p>
<p>I submit my producer function from <a href="#listing17-28" id="listinganchor17-28">Listing 17-28</a>, <code>range_producer()</code>, to a single subprocess <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<p><span epub:type="pagebreak" title="507" id="Page_507"/>I use <code>executor.map()</code> as a convenient way to dispatch multiple consumer subprocesses <span class="CodeAnnotation" aria-label="annotation2">❷</span>, but I don’t need to iteratively provide any data, which is the usual purpose of <code>map()</code>. Since that function requires an iterable as its second argument, I use <code>itertools.repeat()</code> to create an iterator providing exactly four copies of the value <code>target</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The values in this iterable will be mapped to four separate subprocesses.</p>
<p>Finally, I collect and sum all the counts returned by the finished consumer subprocesses via <code>results</code> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Because this statement is outside of the <code>with</code> statement’s suite, it will only run once the producer subprocess and all four consumer subprocesses have exited.</p>
<p>I’ve designed my code architecture to work with a single producer. If I wanted more than one producer subprocess, I would need to refactor the code.</p>
<p>As before, I’m using Listings 17-6 and 17-8 for the rest of the program, which will still be threaded.</p>
<h3 id="h2-500920c17-0018">Performance Results</h3>
<p class="BodyFirst">Running the code in <a href="#listing17-29" id="listinganchor17-29">Listing 17-29</a> is a bit slower than running the version in <a href="#listing17-23" id="listinganchor17-23">Listing 17-23</a>—five seconds on my machine for a <code>BOUND</code> of <code>10**5</code>, versus the nearly instant return of the previous version—but you can see that it works as expected:</p>
<pre><code>Collatz Sequence Counter
Collatz sequence length to search for: 128
Searching in range 1-100000...
How many times do you think it will appear? 608
Exactly right! I'm amazed.</code></pre>
<p>I chose <code>128</code> as my test target, as that’s the length of the Collatz sequence starting with the value <code>10**5</code>, which was the last value provided. This allowed me to confirm that the consumer subprocesses didn’t exit before the queue was empty. There are 608 Collatz sequences that are 128 steps long, and that is what is reported after a few seconds.</p>
<p>Be aware that the design of this particular code isn’t necessarily going to work for your producer/consumer scenario. You will need to carefully consider how messages and data are passed, how events are set and checked, and how subprocesses (or threads, for that matter) clean up after themselves. I highly recommend reading “Things I Wish They Told Me About Multiprocessing in Python” by Pamela McA’Nulty: <a href="https://www.cloudcity.io/blog/2019/02/27/things-i-wish-they-told-me-about-multiprocessing-in-python/" class="LinkURL">https://www.cloudcity.io/blog/2019/02/27/things-i-wish-they-told-me-about-multiprocessing-in-python/</a>.</p>
<h3 id="h2-500920c17-0019">Logging with Multiprocessing</h3>
<p class="BodyFirst">There’s one piece of multiprocessing that I’ve chosen to skip over. Normally, when working with multiple processes, you’d use a logging system that includes timestamps and unique identifiers for processes. This is extraordinarily helpful in debugging parallelized code, especially as most other debugging tools will not work across processes. Logging will allow you to <span epub:type="pagebreak" title="508" id="Page_508"/>see the status of different processes at any given moment in time, so you can tell which ones are working, which are waiting, and which have crashed. I’ll cover logging in general in <span class="xref" itemid="xref_target_Chapter 19">Chapter 19</span>, and you can fit it to your purposes.</p>
<h2 id="h1-500920c17-0009">Wrapping Up</h2>
<p class="BodyFirst">There are many helpful tools for threading and multiprocessing that I simply didn’t have the opportunity to cover here. Now that you have a grasp of the fundamentals of concurrency and parallelism in Python, I highly recommend skimming through the official documentation for the modules I’ve been using, as well as two I’ve skipped:</p>
<p class="ListHead"><b><code class="bold">concurrent.futures</code></b></p>
<p class="ListBody"><a href="https://docs.python.org/3/library/concurrent.futures.html" class="LinkURL">https://docs.python.org/3/library/concurrent.futures.html</a></p>
<p class="ListHead"><b><code class="bold">queue</code></b></p>
<p class="ListBody"><a href="https://docs.python.org/3/library/queue.html" class="LinkURL">https://docs.python.org/3/library/queue.html</a></p>
<p class="ListHead"><b><code class="bold">multiprocessing</code></b></p>
<p class="ListBody"><a href="https://docs.python.org/3/library/multiprocessing.html" class="LinkURL">https://docs.python.org/3/library/multiprocessing.html</a></p>
<p class="ListHead"><b><code class="bold">sched</code></b></p>
<p class="ListBody"><a href="https://docs.python.org/3/library/sched.html" class="LinkURL">https://docs.python.org/3/library/sched.html</a></p>
<p class="ListHead"><b><code class="bold">subprocess</code></b></p>
<p class="ListBody"><a href="https://docs.python.org/3/library/subprocess.html" class="LinkURL">https://docs.python.org/3/library/subprocess.html</a></p>
<p class="ListHead"><b><code class="bold">_thread</code></b></p>
<p class="ListBody"><a href="https://docs.python.org/3/library/_thread.html" class="LinkURL">https://docs.python.org/3/library/_thread.html</a></p>
<p class="ListHead"><b><code class="bold">threading</code></b></p>
<p class="ListBody"><a href="https://docs.python.org/3/library/threading.html" class="LinkURL">https://docs.python.org/3/library/threading.html</a></p><br/>
<p>Remember also that asynchrony libraries have analogous structures and patterns for nearly everything in threading, including locks, events, pools, and futures. Most of the time, if you can thread it, you can write it asynchronously.</p>
<p>In summary, there are three primary ways to multitask in Python: asynchrony (<span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>), threading, and multiprocessing. Asynchrony and threading are both for working with IO-bound tasks, while multiprocessing is for speeding up CPU-bound tasks.</p>
<p>Even so, remember that concurrency and parallelism are not magic bullets! They can improve your program’s responsiveness and, at least in the case of multiprocessing, speed up execution times, but always at the cost of added complexity and the risk of some pretty snarly bugs. They demand careful planning and code architecture, and it’s easy to get their usage wrong. I spent considerable time writing, testing, debugging, and fighting <span epub:type="pagebreak" title="509" id="Page_509"/>with the Collatz examples until I got them right—more so than with any other examples in this book! Even now, you may discover flaws in the design that I overlooked.</p>
<p>Concurrency and parallelism are essential when programming user interfaces, scheduling events, and performing labor-intensive tasks in code. Even so, there’s often nothing wrong with old-fashioned synchronous code. If you don’t need the extra power, then avoid the extra complexity.</p>
<p>For further understanding, you may want to look up other concurrency and parallelism patterns, such as the <code>subprocess</code> module, job queues like <code>celery</code>, and even external operating system utilities like <code>xargs -P</code> and <code>systemd</code>. There is far more to this than can fit into one chapter. Always carefully research the options for your particular situation.</p>
</section>
</div></body></html>