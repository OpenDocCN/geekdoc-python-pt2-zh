- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: SENDING SUPER-SECRET MESSAGES WITH A BOOK CIPHER
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用书籍密码发送超级机密信息
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: '*The Key to Rebecca* is a critically acclaimed best-selling novel by Ken Follett.
    Set in Cairo in World War II and based on actual events, it tells the story of
    a Nazi spy and the British intelligence officer who pursued him. The title refers
    to the spy’s cipher system, which used the famous gothic novel *Rebecca*, written
    by Daphne du Maurier, as a key. *Rebecca* is considered one of the greatest novels
    of the 20th century, and the Germans really did use it as a code book during the
    war.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 《*Rebecca的密码*》是肯·福莱特（Ken Follett）创作的一本广受好评的畅销小说。故事背景设定在二战时期的开罗，基于真实事件，讲述了一名纳粹间谍和一名追捕他的英国情报官员的故事。书名指的是间谍使用的密码系统，它以达芙妮·杜穆里埃（Daphne
    du Maurier）所著的著名哥特式小说《*Rebecca*》为密钥。*Rebecca*被认为是20世纪最伟大的小说之一，德国人确实在战争期间将它作为密码书使用。
- en: The Rebecca cipher is a variation of the *one-time pad*, an unbreakable encryption
    technique that requires a key that is at least the same size as the message being
    sent. Both the sender and receiver have a copy of the pad, and after one use,
    the top sheet is ripped off and discarded.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Rebecca密码是*一次性密钥*的一种变体，一种无法破解的加密技术，它需要一个与所发送的信息大小至少相同的密钥。发送方和接收方各自持有一份密钥本，使用一次后，最上面的一张纸会被撕掉并丢弃。
- en: One-time pads provide absolute, perfect security—uncrackable even by a quantum
    computer! Despite this, the pads have several practical drawbacks that prevent
    widespread use. Key among these are the need to securely transport and deliver
    the pads to the sender and receiver, the need to safely store them, and the difficulty
    in manually encoding and decoding the messages.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密钥提供绝对的、完美的安全性——即使是量子计算机也无法破解！尽管如此，密钥本仍有一些实际缺点，阻碍了它的广泛使用。其中最主要的是需要安全地传输和交付密钥本给发送方和接收方，存储它们的安全性，以及手动编码和解码消息的难度。
- en: In the *The Key to Rebecca*, both parties must know the encryption rules and
    have the same edition of the book to use the cipher. In this chapter, you’ll transfer
    the manual method described in the book into a more secure—and easier to use—digital
    technique. In the process, you’ll get to work with useful functions from the Python
    Standard Library, the collections module, and the random module. You’ll also learn
    a little more about Unicode, a standard used to ensure that characters, such as
    letters and numbers, are universally compatible across all platforms, devices,
    and applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在《*Rebecca的密码*》中，双方必须了解加密规则并且拥有相同版本的书籍才能使用该密码。在本章中，你将把书中描述的手动方法转化为一种更安全且更易于使用的数字技术。在这个过程中，你将使用到Python标准库、collections模块和random模块中的一些有用函数。你还将稍微了解一下Unicode标准，这个标准确保了字母、数字等字符在所有平台、设备和应用中都能普遍兼容。
- en: '**The One-Time Pad**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一次性密钥**'
- en: A one-time pad is basically an ordered stack of sheets printed with truly random
    numbers, usually in groups of five ([Figure 4-1](ch04.xhtml#ch04fig1)). To make
    them easy to conceal, the pads tend to be small and may require a powerful magnifying
    glass to read. Despite being old-school, one-time pads produce the most secure
    ciphers in the world, as every letter is encrypted with a unique key. As a result,
    cryptanalysis techniques, such as frequency analysis, simply can’t work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密钥本质上是一个有序的纸张堆，每张纸上印有真正随机的数字，通常以五个一组的方式排列（见[图 4-1](ch04.xhtml#ch04fig1)）。为了方便隐藏，这些密钥本通常很小，可能需要一只强力放大镜才能读取。尽管这种方法显得有些老派，但一次性密钥产生的密码是世界上最安全的，因为每个字母都使用一个唯一的密钥进行加密。因此，密码分析技术，如频率分析，根本无法奏效。
- en: '![Image](../images/fig04_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig04_01.jpg)'
- en: 'Figure 4-1: Example of a one-time pad sheet'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1：一次性密钥纸张示例
- en: To encrypt a message with the one-time pad in [Figure 4-1](ch04.xhtml#ch04fig1),
    start by assigning each letter of the alphabet a two-digit number. *A* equals
    01, *B* equals 02, and so on, as shown in the following table.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用[图 4-1](ch04.xhtml#ch04fig1)中的一次性密钥加密消息，首先为字母表中的每个字母分配一个两位数字。*A*等于01，*B*等于02，以此类推，如下表所示。
- en: '![Image](../images/table_page_78_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/table_page_78_01.jpg)'
- en: 'Next, convert the letters in your short message into numbers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将你的简短信息中的字母转换成数字：
- en: '![Image](../images/table_page_79_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/table_page_79_01.jpg)'
- en: Starting at the upper left of the one-time pad sheet and reading left to right,
    assign a number pair (*key*) to each letter and add it to the number value of
    the letter. You’ll want to work with base 10 number pairs, so if your sum is greater
    than 100, use modular arithmetic to truncate the value to the last two digits
    (103 becomes 03). The numbers in shaded cells in the following diagrams are the
    result of modular arithmetic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从一次性密码本页的左上角开始，按从左到右的顺序，为每个字母分配一个数字对（*密钥*），并将其加到该字母的数字值上。你将使用基数为10的数字对，因此，如果你的和大于100，则使用模运算将结果截断为最后两位数字（103变为03）。下图中阴影单元格内的数字就是模运算的结果。
- en: '![Image](../images/table_page_79_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/table_page_79_02.jpg)'
- en: The last row in this diagram represents the ciphertext. Note that KITTY, duplicated
    in the plaintext, is not repeated in the ciphertext. Each encryption of KITTY
    is unique.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此图中的最后一行表示密文。请注意，在明文中重复的“KITTY”在密文中并未重复。每次加密“KITTY”都是唯一的。
- en: To decrypt the ciphertext back to plaintext, the recipient uses the same sheet
    from their identical one-time pad. They place their number pairs below the ciphertext
    pairs and subtract. When this results in a negative number, they use modular subtraction
    (adding 100 to the ciphertext value before subtracting). They finish by converting
    the resulting number pairs back to letters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要将密文解密回明文，接收方使用与其相同的密码本页。他们将自己的数字对放在密文对下方，然后进行减法运算。当减法结果为负数时，使用模运算（在减法前将密文值加上100）。最后，他们将结果数字对转换回字母。
- en: '![Image](../images/table_page_79_03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/table_page_79_03.jpg)'
- en: 'To ensure that no keys are repeated, the number of letters in the message can’t
    exceed the number of keys on the pad. This forces the use of short messages, which
    have the advantage of being easier to encrypt and decrypt and which offer a cryptanalyst
    fewer opportunities to decipher the message. Some other guidelines include the
    following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保没有重复的密钥，消息中的字母数不能超过密码本上的密钥数。这就要求使用简短的消息，简短的消息有一个优点，就是更容易加密和解密，而且提供给密码分析员的破解机会更少。其他一些指导原则包括：
- en: Spell out numbers (for example, TWO for 2).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数字写出（例如，2写作TWO）。
- en: End sentences with an *X* in place of a period (for example, CALL AT NOONX).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用*X*代替句号结束句子（例如，CALL AT NOONX）。
- en: Spell out any other punctuation that can’t be avoided (for example, COMMA).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将无法避免的其他标点符号写出来（例如，逗号）。
- en: End the plaintext message with *XX*.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以*XX*结束明文消息。
- en: '**The Rebecca Cipher**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**丽贝卡密码**'
- en: In the novel *The Key to Rebecca*, the Nazi spy uses a variant of the one-time
    pad. Identical editions of the novel *Rebecca* are purchased in Portugal. Two
    are retained by the spy; the other two are given to Field Marshal Rommel’s staff
    in North Africa. The encrypted messages are sent by radio on a pre-determined
    frequency. No more than one message is sent per day and always at midnight.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在小说*《丽贝卡的钥匙》*中，纳粹间谍使用了一种变体的一次性密码本。葡萄牙购买了相同版本的小说*《丽贝卡》*。其中两本由间谍保留，另两本交给北非的隆美尔元帅的工作人员。加密消息通过预定频率的无线电发送。每天最多发送一条消息，并且总是在午夜。
- en: To use the key, the spy would take the current date—say, May 28, 1942—and add
    the day to the year (28 + 42 = 70). This would determine which page of the novel
    to use as a one-time pad sheet. Because May is the fifth month, every fifth word
    in a sentence would be discounted. Because the Rebecca cipher was meant to be
    used only during a relatively short period in 1942, the spy didn’t have to worry
    about repetitions in the calendar causing repetition in the keys.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用密钥，间谍需要获取当前日期——比如1942年5月28日——然后将当天的日期与年份相加（28 + 42 = 70）。这将决定使用哪一页小说作为一次性密码本。因为5月是第五个月，因此每个句子中的每第五个单词将被忽略。由于《丽贝卡密码》是计划仅在1942年相对短时间内使用，间谍不必担心日历中的重复会导致密钥的重复。
- en: 'The spy’s first message was the following: HAVE ARRIVED. CHECKING IN. ACKNOWLEDGE.
    Beginning at the top of [page 70](ch03.xhtml#page_70), he read along until he
    found the letter *H*. It was the 10th character, discounting every 5th letter.
    The 10th letter of the alphabet is *J*, so he used this in his ciphertext to represent
    *H*. The next letter, *A*, was found three letters after *H*, so it was encoded
    using the third letter of the alphabet, *C*. This continued until the full message
    was encrypted. For rare letters like *X* or *Z*, author Ken Follett states that
    special rules were applied but does not describe them.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍的第一条消息如下：HAVE ARRIVED. CHECKING IN. ACKNOWLEDGE。 从[第70页](ch03.xhtml#page_70)开始，他沿着页面读，直到找到字母*H*。它是第10个字符，忽略每第五个字母。字母表中的第10个字母是*J*，因此他在密文中使用这个字母代表*H*。接下来的字母*A*在*H*之后三个字母的位置找到，因此用字母表中的第三个字母*C*进行编码。这种方式一直持续，直到整个消息被加密。对于像*X*或*Z*这样的稀有字母，作者Ken
    Follett表示应用了特殊规则，但没有详细描述这些规则。
- en: 'Using a book in this manner had a distinct advantage over a true one-time pad.
    To quote Follett, “A pad was unmistakably for the purpose of encipherment, but
    a book looked quite innocent.” A disadvantage remained, however: the process of
    encryption and decryption is tedious and potentially error prone. Let’s see if
    we can remedy this using Python!'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用书籍相较于真正的一次性密钥有明显的优势。引用福尔特的话，“密钥本身显然是为了加密目的，但书籍看起来十分无辜。”然而，仍然有一个缺点：加密和解密的过程繁琐且可能出错。让我们看看能否使用Python解决这个问题！
- en: '**Project #6: The Digital Key to Rebecca**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #6：Rebecca的数字密钥**'
- en: 'Turning the Rebecca technique into a digital program offers several advantages
    over a one-time pad:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将《Rebecca》技巧转化为数字程序，相较于一次性密钥有几个优势：
- en: The encoding and decoding processes become fast and error-free.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码和解码过程变得快速且无误。
- en: Longer messages can be sent.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以发送更长的消息。
- en: Periods, commas, and even spaces can be directly encrypted.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 句号、逗号甚至空格都可以直接加密。
- en: Rare letters, like *z*, can be chosen from anywhere in the book.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像*z*这样的稀有字母可以从书中的任何地方选择。
- en: The code book can be hidden among thousands of ebooks on a hard drive or in
    the cloud.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码书可以隐藏在硬盘或云端数千本电子书中。
- en: The last item is important. In the novel, the British intelligence officer finds
    a copy of *Rebecca* at a captured German outpost. Through simple deductive reasoning
    he recognizes it as a substitute for a one-time pad. With a digital approach,
    this would have been much more difficult. In fact, the novel could be kept on
    a small, easily concealed device such as an SD card. This would make it similar
    to a one-time pad, which is often no bigger than a postage stamp.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项是非常重要的。在小说中，英国情报官员在一个被俘的德军前哨中发现了《Rebecca》的副本。通过简单的推理，他认出了它是一次性密钥的替代品。然而，如果是数字方法，这将更加困难。事实上，这本小说可以保存在一个小而易于隐藏的设备中，比如SD卡。这使得它与一次性密钥相似，一次性密钥通常不大于邮票。
- en: 'A digital approach does have one disadvantage, however: the program is a *discoverable*
    item. Whereas a spy could simply memorize the rules for a one-time pad, with a
    digital approach the rules must be ensconced in the software. This weakness can
    be minimized by writing the program so that it looks innocent—or at least cryptic—and
    having it request input from the user for the message and the name of the code
    book.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数字方法确实有一个缺点：程序是*可发现*的。虽然间谍可以简单地记住一次性密钥的规则，但在数字方法中，规则必须嵌入到软件中。通过编写看似无辜——或者至少是神秘——的程序，并让它请求用户输入消息和密码书的名称，可以最大限度地减少这个弱点。
- en: THE OBJECTIVE
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Write a Python program that encrypts and decrypts messages using a digital novel
    as a one-time pad.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，使用数字小说作为一次性密钥加密和解密信息。
- en: '***The Strategy***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: Unlike the spy, you won’t need all the rules used in the novel, and many wouldn’t
    work anyway. If you’ve ever used any kind of ebook, you know that page numbers
    are meaningless. Changes to screen sizes and text sizes render all such page numbers
    nonunique. And because you can choose letters from anywhere in the book, you don’t
    necessarily need special rules for rare letters or for discounting numbers in
    a count.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与间谍不同，你不需要小说中所有的规则，许多规则实际上根本无法使用。如果你曾使用过任何形式的电子书，你会知道页码是没有意义的。屏幕大小和文字大小的变化使得所有页码都不再唯一。而且因为你可以从书中的任何地方选择字母，你不一定需要为稀有字母或忽略计数中的数字设置特别的规则。
- en: So, you don’t need to focus on perfectly reproducing the Rebecca cipher. You
    just need to produce something similar and, ideally, better.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你不需要完美地再现《Rebecca》密码。你只需生成类似的东西，最好是更好。
- en: Luckily, Python *iterables*, such as lists and tuples, use numerical indexes
    to keep track of every single item within them. By loading a novel as a list,
    you can use these indexes as unique starting keys for each character. You can
    then shift the indexes based on the day of the year, emulating the spy’s methodology
    in *The Key to Rebecca*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python的*可迭代对象*，比如列表和元组，使用数字索引来跟踪其中的每一项。通过将小说加载为列表，你可以利用这些索引作为每个字符的独特起始密钥。然后，你可以根据年份的天数来移动索引，模拟《Rebecca的关键》中间谍的加密方法。
- en: Unfortunately, *Rebecca* is not yet in the public domain. In its place, we’ll
    substitute the text file of Sir Arthur Conan Doyle’s *The Lost World* that you
    used in [Chapter 2](ch02.xhtml). This novel contains 51 distinct characters that
    occur 421,545 times, so you can randomly choose indexes with little chance of
    duplication. This means you can use the whole book as a one-time pad each time
    you encrypt a message, rather than restrict yourself to a tiny collection of numbers
    on a single one-time pad sheet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，《Rebecca》目前还未进入公有领域。作为替代，我们将使用你在[第二章](ch02.xhtml)中使用的亚瑟·柯南·道尔爵士的《失落的世界》文本文件。这本小说包含51个独特字符，出现了421,545次，因此你可以随机选择索引，几乎不必担心重复。这意味着你可以每次加密时都使用整本书作为一次性密钥，而不必局限于单张一次性密钥表上的少量数字。
- en: '**NOTE**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can download and use a digital version of Rebecca if you want. I just
    can’t provide you with a copy for free!*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你愿意，你可以下载并使用《Rebecca》的数字版。我只是不能免费提供给你！*'
- en: Because you’ll be reusing the book, you’ll need to worry about both *message-to-message*
    and *in-message* duplication of keys. The longer the message, the more material
    the cryptanalyst can study, and the easier it is to crack the code. And if each
    message is sent with the same encryption key, all the intercepted messages can
    be treated as a single large message.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你会重复使用这本书，你需要考虑到*消息对消息*和*信息内*的密钥重复问题。消息越长，密码分析员可以研究的材料越多，破解代码就越容易。如果每条消息都使用相同的加密密钥，所有拦截到的消息就可以视为一条大消息。
- en: For the message-to-message problem, you can imitate the spy and shift the index
    numbers by the day of the year, using a range of 1 to 366 to account for leap
    years. In this scheme, February 1 would be 32\. This will effectively turn the
    book into a new one-time pad sheet each time, as different keys will be used for
    the same characters. Shifting, by one or more increments, resets all the indexes
    and essentially “tears off” the previous sheet. And unlike a one-time pad, you
    don’t have to bother with disposing of a piece of paper!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息对消息的问题，你可以模仿间谍并根据年份的天数来移动索引数字，使用1到366的范围来考虑闰年。在这个方案中，2月1日将是32。这样，每次加密时，书籍就会变成一个全新的一次性密钥表，因为相同字符会使用不同的密钥。移动一个或多个增量会重置所有索引，实际上是“撕掉”了之前的密钥表。与一次性密钥不同，你不必担心丢弃一张纸！
- en: For the in-message duplication problem, you can run a check before transmitting
    the message. It’s unlikely but possible for the program to pick the same letter
    twice during encryption and thus use the same index twice. Duplicate indexes are
    basically repeating keys, and these can help a cryptanalyst break your code. So,
    if duplicate indexes are found, you can rerun the program or reword the message.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于信息内重复的问题，在传输消息之前，你可以先进行检查。虽然这种情况不太可能发生，但程序在加密过程中有可能选取相同的字母两次，从而使用相同的索引两次。重复的索引基本上是重复的密钥，这会帮助密码分析员破译你的代码。所以，如果发现有重复的索引，你可以重新运行程序或重新措辞消息。
- en: You’ll also need similar rules to those used in *The Key to Rebecca*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要类似于《Rebecca的关键》中的规则。
- en: Both parties need identical digital copies of *The Lost World*.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双方需要拥有相同的*失落的世界*数字副本。
- en: Both parties need to know how to shift the indexes.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双方需要知道如何移动索引。
- en: Keep messages as short as possible.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量保持信息简洁。
- en: Spell out numbers.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请写出数字。
- en: '***The Encryption Code***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加密代码***'
- en: The following *rebecca.py* code will take a message and return an encrypted
    or plaintext version, as specified by the user. The message can be typed in or
    downloaded from the book’s website. You’ll also need the *lost.txt* text file
    in the same folder as the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的*rebecca.py*代码会接收一条消息，并根据用户的要求返回加密或明文版本。消息可以直接输入，或从书籍网站下载。你还需要一个名为*lost.txt*的文本文件，放在与代码相同的文件夹中。
- en: For clarity, you’ll use variable names like *ciphertext*, *encrypt*, *message*,
    and so on. If you were a real spy, however, you’d avoid incriminating terms in
    case the enemy got their hands on your laptop.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，你将使用 *ciphertext*、*encrypt*、*message* 等变量名。不过，如果你真是一个间谍，恐怕你会避免使用那些可能暴露身份的术语，免得敌人拿到你的笔记本。
- en: '**Importing Modules and Defining the main() Function**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块并定义 main() 函数**'
- en: '[Listing 4-1](ch04.xhtml#ch04list1) imports modules and defines the main()
    function, used to run the program. This function will ask for user input, call
    the functions needed to encrypt or decrypt text, check for duplicate keys, and
    print the ciphertext or plaintext.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-1](ch04.xhtml#ch04list1) 导入了模块并定义了 main() 函数，用于运行程序。该函数会请求用户输入，调用所需的加密或解密函数，检查是否有重复的键，并打印出密文或明文。'
- en: Whether you define main() at the start or end of a program is a matter of choice.
    Sometimes it provides a good, easily readable summary of the whole program. Other
    times it may feel out of place, like the cart before the horse. From Python’s
    perspective, it won’t matter where you place it so long as you call the function
    at the end.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 是否在程序的开始或结束定义 main() 函数取决于个人选择。有时候，它可以作为整个程序的一个简洁、易读的总结。其他时候，它可能显得不合时宜，就像“倒马车”一样。从
    Python 的角度来看，只要在程序结束时调用该函数，放置的位置并不重要。
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-1: Importing modules and defining the main() function'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-1：导入模块并定义 main() 函数
- en: Start by importing sys and os, two modules that let you interface with the operating
    system; then the random module; and then defaultdict and Counter from the collections
    module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从导入 sys 和 os 开始，它们是两个让你能够与操作系统交互的模块；然后是 random 模块；接着是从 collections 模块导入 defaultdict
    和 Counter。
- en: The collections module is part of the Python Standard Library and includes several
    container data types. You can use defaultdict to build a dictionary on the fly.
    If defaultdict encounters a missing key, it will supply a default value rather
    than throw an error. You’ll use it to build a dictionary of the characters in
    *The Lost World* and their corresponding index values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: collections 模块是 Python 标准库的一部分，包含了多个容器数据类型。你可以使用 defaultdict 来动态构建字典。如果 defaultdict
    遇到缺失的键，它会提供默认值，而不是抛出错误。你将使用它来构建 *《失落的世界》* 中的字符字典及其对应的索引值。
- en: A Counter is a dictionary subclass for counting hashable objects. Elements are
    stored as dictionary keys, and their counts are stored as dictionary values. You’ll
    use this to check your ciphertext and ensure no indexes are duplicated.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Counter 是字典的子类，用于计数可哈希的对象。元素作为字典的键存储，其计数值作为字典的值存储。你将使用它来检查密文，并确保没有重复的索引。
- en: At this point, you begin the definition of the main() function. The function
    starts by asking the user for the message to encrypt or decrypt. For maximum security,
    the user should type this in. The program then asks the user to specify whether
    they want encryption or decryption. Once the user chooses, the program asks for
    the shift value. The shift value represents the day of the year, over the inclusive
    and consecutive range of 1 to 366\. Next, ask for the infile, which will be *lost.txt*,
    the digital version of *The Lost World* ➊.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点，你开始定义 main() 函数。该函数首先会请求用户输入要加密或解密的消息。为了最大限度地提高安全性，用户应该手动输入此消息。接着，程序询问用户是要进行加密还是解密。一旦用户做出选择，程序会请求输入移位值。移位值代表一年中的日期，范围为
    1 到 366（包括）。接下来，程序会要求输入 infile，这将是 *lost.txt*，即 *《失落的世界》* 的数字版 ➊。
- en: Before proceeding, the program checks that the file exists. It uses the operating
    system module’s path.exists() method and passes it the infile variable. If the
    file doesn’t exist or if the path and/or filename is incorrect, the program lets
    the user know, uses the file=sys.stderr option to color the message “error red”
    in the Python shell, and terminates the program with sys.exit(1). The 1 is used
    to flag that the program terminated with an error, as opposed to a clean termination.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，程序会检查文件是否存在。它使用操作系统模块的 path.exists() 方法，并传入 infile 变量。如果文件不存在或路径和/或文件名不正确，程序会告知用户，使用
    file=sys.stderr 选项在 Python Shell 中将“错误”消息显示为红色，并使用 sys.exit(1) 终止程序。1 用于标记程序因错误终止，而非正常终止。
- en: Next, you call some functions that you’ll define later. The first function loads
    the *lost.txt* file as a string named text, which includes nonletter characters
    such as spaces and punctuation. The second builds a dictionary of the characters
    and their corresponding indexes, with the shift value applied.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你会调用一些稍后定义的函数。第一个函数将*lost.txt*文件加载为一个名为text的字符串，其中包括空格和标点等非字母字符。第二个函数构建一个字符及其对应索引的字典，并应用移位值。
- en: Now you start a conditional to evaluate the process being used. As I mentioned,
    we’re using incriminating terms like *encrypt* and *decrypt* for clarity. You’d
    want to disguise these for real espionage work. If the user has chosen to encrypt,
    call the function that encrypts the message with the character dictionary. When
    the function returns, the program has encrypted the message. But don’t assume
    it worked as planned! You need to check that it decrypted correctly and that no
    keys are duplicated. To do this, you start a series of quality control steps.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你开始使用条件判断来评估正在使用的处理过程。正如我之前提到的，为了清晰起见，我们使用了*加密*和*解密*这样的术语。在真正的间谍工作中，你会希望掩盖这些术语。如果用户选择了加密，则调用该函数，使用字符字典加密消息。当该函数返回时，程序已成功加密消息。但不要认为它一定如预期般工作！你需要检查它是否能正确解密，并确保没有重复的键。为此，你将开始一系列质量控制步骤。
- en: First, you check for duplicate keys ➋. If this function returns True, instruct
    the user to try again, change the message, or change the book to something other
    than *The Lost World*. For each character in the message, you’ll use the char_dict
    and choose an index at random. Even with hundreds or even thousands of indexes
    for each character, you may still choose the same index more than once for a given
    character.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你检查是否有重复的键 ➋。如果此函数返回True，提示用户重试、更改消息，或将书籍换成其他书籍，而不是*失落的世界*。对于消息中的每个字符，你将使用char_dict并随机选择一个索引。即使每个字符有数百甚至数千个索引，你也可能会为某个字符多次选择相同的索引。
- en: Rerunning the program with slightly different parameters, as listed earlier,
    should fix this, unless you have a long message with a lot of low-frequency characters.
    Handling this rare case may require rewording the message or finding a larger
    manuscript than *The Lost World*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用稍有不同参数重新运行程序，应该能够解决这个问题，除非你的消息很长且包含大量低频字符。处理这种罕见情况可能需要重新措辞消息，或者找一本比*失落的世界*更大的手稿。
- en: '**NOTE**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Python’s random module does not produce truly random numbers but rather pseudorandom
    numbers that can be predicted. Any cipher using pseudorandom numbers can potentially
    be cracked by a cryptanalyst. For maximum security when generating random numbers,
    you should use Python’s os.urandom() function.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python的random模块并不会产生真正的随机数，而是产生可以预测的伪随机数。任何使用伪随机数的密码系统都有可能被密码分析师破解。为了在生成随机数时获得最大安全性，应该使用Python的os.urandom()函数。*'
- en: Now, print the contents of the character dictionary so you can see how many
    times the various characters occur in the novel ➌. This will help guide what you
    put in messages, though *The Lost World* contains a healthy helping of useful
    characters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打印字符字典的内容，这样你可以看到各种字符在小说中出现的次数 ➌。这将帮助你指导信息的编写，尽管*失落的世界*中包含了大量有用的字符。
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To generate this table, you use Python’s Format Specification Mini-Language
    (*[https://docs.python.org/3/library/string.html#formatspec](https://docs.python.org/3/library/string.html#formatspec)*)
    to print headers for the three columns. The number in curly brackets denotes how
    many characters should be in the string, and the greater-than sign designates
    right justification.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这个表格，你使用Python的格式规范迷你语言（*[https://docs.python.org/3/library/string.html#formatspec](https://docs.python.org/3/library/string.html#formatspec)*)来打印三个列的标题。大括号中的数字表示字符串中应包含的字符数，而大于号表示右对齐。
- en: The program then loops through the keys in the character dictionary and prints
    them using the same column width and justification. It prints the character, its
    Unicode value, and the number of times it occurs in the text.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后程序遍历字符字典中的键，并使用相同的列宽和对齐方式打印它们。它打印字符、字符的Unicode值，以及它在文本中出现的次数。
- en: You use repr() to print the key. This built-in function returns a string containing
    a printable representation of an object. That is, it returns all information about
    the object in a format useful for debugging and development purposes. This allows
    you to explicitly print characters like newline (\n) and space. The index range
    [1:-1] excludes the quotes on both sides of the output string.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 repr() 来打印键。这个内建函数返回一个字符串，包含对象的可打印表示形式。也就是说，它返回关于对象的所有信息，以便调试和开发使用的格式。这允许你显式地打印像换行符
    (\n) 和空格这样的字符。索引范围 [1:-1] 排除了输出字符串两边的引号。
- en: The ord() built-in function returns an integer representing the Unicode code
    point for a character. Computers deal only with numbers, so they must assign a
    number to every possible character, such as *%*, 5, ![Image](../images/icon1.jpg),
    or *A*. The *Unicode Standard* ensures that every character, no matter what platform,
    device, application, or language, has a unique number and is universally compatible.
    By showing the user the Unicode values, the program lets the user pick up on anything
    strange happening with a text file, such as the same letter showing up as multiple
    distinct characters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ord() 内建函数返回一个整数，表示字符的 Unicode 代码点。计算机只能处理数字，因此必须为每个可能的字符分配一个数字，例如 *%*、5、![Image](../images/icon1.jpg)
    或 *A*。*Unicode 标准* 确保每个字符，不论平台、设备、应用程序或语言，都有一个唯一的数字，并且具有普遍兼容性。通过向用户展示 Unicode
    值，程序使用户能够察觉文本文件中发生的任何异常情况，例如同一个字母以多个不同的字符形式出现。
- en: For the third column, you get the length of each dictionary key. This will represent
    the number of times that character appears in the novel. The program then prints
    the number of distinct characters and the total of all characters in the text.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三列，你获取每个字典键的长度。它表示该字符在小说中出现的次数。程序然后打印出不同字符的数量以及文本中所有字符的总数。
- en: Finally, you finish the encryption process by printing the ciphertext, and then
    the decrypted plaintext, as a check. To decipher the message, the program loops
    through each item in the ciphertext and uses the item as an index for text ➍,
    subtracting the shift value, which was added earlier. When you print the results,
    the program uses end='' in place of the default newline, so each character isn’t
    on a separate line.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你通过打印密文和解密后的明文来完成加密过程，以便检查。为了破译消息，程序遍历密文中的每个项，并使用该项作为文本 ➍ 的索引，减去之前添加的移位值。当你打印结果时，程序使用
    end='' 替代默认的换行符，因此每个字符不会显示在单独的一行。
- en: The main() function ends with a conditional statement to check whether process
    == 'decrypt'. If the user chooses to decrypt the message, the program calls the
    decrypt() function and then prints the decrypted plaintext. Note that you could
    simply use else here, but I chose to use elif for clarity and readability.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: main() 函数以一个条件语句结束，用于检查 `process == 'decrypt'`。如果用户选择解密消息，程序将调用 decrypt() 函数，然后打印解密后的明文。请注意，你可以在这里简单地使用
    else，但我选择使用 elif 以提高清晰度和可读性。
- en: '**Loading a File and Making a Dictionary**'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**加载文件并创建字典**'
- en: '[Listing 4-2](ch04.xhtml#ch04list2) defines functions to load a text file and
    make a dictionary of characters in the file and their corresponding indexes.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-2](ch04.xhtml#ch04list2) 定义了用于加载文本文件并创建文件中字符及其对应索引的字典的函数。'
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-2: Defining the load_file() and make_dict() functions'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-2：定义 load_file() 和 make_dict() 函数
- en: This listing begins by defining a function to load a text file as a string.
    Using with to open the file ensures it will close automatically when the function
    ends.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单开始时定义了一个函数，用于将文本文件加载为字符串。使用 with 打开文件确保文件在函数结束时自动关闭。
- en: 'Some users may get an error, such as the following one, when loading text files:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用户在加载文本文件时，可能会遇到类似以下的错误：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, try modifying the open function by adding the encoding and errors
    arguments.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，尝试通过添加编码（encoding）和错误（errors）参数来修改 open 函数。
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more on this issue, see [page 35](ch02.xhtml#page_35) in [Chapter 2](ch02.xhtml).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个问题的更多信息，请参见 [第 35 页](ch02.xhtml#page_35) 中的 [第 2 章](ch02.xhtml)。
- en: After opening the file, read it to a string and convert all the text to lower-
    case. Then return the string.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件后，将文件内容读取为一个字符串，并将所有文本转换为小写字母。然后返回该字符串。
- en: The next step is to turn the string into a dictionary. Define a function that
    takes this string and the shift value as arguments ➊. The program creates a char_dict
    variable using defaultdict(). This variable will be a dictionary. The program
    then passes the type constructor for list to defaultdict(), as you want the dictionary
    values to be a list of indexes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将字符串转换为字典。定义一个函数，接受这个字符串和移位值作为参数 ➊。程序使用 `defaultdict()` 创建一个 `char_dict`
    变量。这个变量将是一个字典。然后，程序将列表的类型构造函数传递给 `defaultdict()`，因为你希望字典的值是包含索引的列表。
- en: With defaultdict(), whenever an operation encounters an item that isn’t already
    in the dictionary, a function named default_factory() is called with no arguments,
    and the output is used as the value. Any key that doesn’t exist gets the value
    returned by default_factory, and no KeyError is raised.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `defaultdict()` 时，每当一个操作遇到字典中尚不存在的项时，名为 `default_factory()` 的函数将被调用且不带参数，其输出将作为该项的值。任何不存在的键都会获得由
    `default_factory` 返回的值，而且不会抛出 `KeyError`。
- en: If you tried to make the dictionary on the fly without the handy collections
    module, you’d get the KeyError, as shown in the next example.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图在没有方便的 `collections` 模块的情况下动态创建字典，你将得到 `KeyError`，如下例所示。
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The built-in enumerate() function acts as an automatic counter, so you can easily
    get the index for each character in the string derived from *The Lost World*.
    The keys in char_dict are characters, and the characters can occur thousands of
    times within text. So, the dictionary values are lists that hold the indexes for
    all these character occurrences. By adding the shift value to the index when it
    is appended to a value list, you ensure that the indexes will be unique for each
    message ➋.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `enumerate()` 函数充当自动计数器，因此你可以轻松获取从 *失落的世界* 中提取的字符串中每个字符的索引。`char_dict` 中的键是字符，而这些字符在文本中可能出现成千上万次。因此，字典的值是保存所有这些字符出现位置的索引列表。当将移位值添加到索引并将其附加到值列表时，你可以确保每个消息的索引都是唯一的
    ➋。
- en: Finish the function by returning the character dictionary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回字符字典来结束函数。
- en: '**Encrypting the Message**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**加密消息**'
- en: '[Listing 4-3](ch04.xhtml#ch04list3) defines a function to encrypt the message.
    The resulting ciphertext will be a list of indexes.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-3](ch04.xhtml#ch04list3) 定义了一个加密消息的函数。生成的密文将是一个索引列表。'
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-3: Defining a function to encrypt the plaintext message'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-3：定义一个加密明文消息的函数
- en: The encrypt() function will take the message and char_dict as arguments. Start
    it by creating an empty list to hold the ciphertext. Next, start looping through
    the characters in message and converting them to lowercase to match the characters
    in char_dict.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`encrypt()` 函数将把消息和 `char_dict` 作为参数传入。首先，通过创建一个空列表来存储密文。接着，开始遍历消息中的字符并将它们转换为小写，以匹配
    `char_dict` 中的字符。'
- en: If the number of indexes associated with the character is greater than 1, the
    program uses the random.choice() method to choose one of the character’s indexes
    at random ➊.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与字符关联的索引数量大于 1，程序将使用 `random.choice()` 方法随机选择该字符的一个索引 ➊。
- en: If a character occurs only once in char_dict, random.choice() will throw an
    error. To handle this, the program uses a conditional and hardwires the choice
    of the index, which will be at position [0].
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符在 `char_dict` 中仅出现一次，`random.choice()` 会抛出一个错误。为了解决这个问题，程序使用条件语句，并硬编码选择索引的方式，索引将位于位置
    [0]。
- en: If the character doesn’t exist in *The Lost World*, it won’t be in the dictionary,
    so use a conditional to check for this ➋. If it evaluates to True, print an alert
    for the user and use continue to return to the start of the loop without choosing
    an index. Later, when the quality control steps run on the ciphertext, a space
    will appear in the decrypted plaintext where this character should be.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符在 *失落的世界* 中不存在，它也不会出现在字典中，因此使用条件语句检查此情况 ➋。如果评估为 True，则打印警告信息，并使用 `continue`
    返回循环的开始，而不选择索引。稍后，当质量控制步骤在密文上运行时，解密后的明文中将会出现一个空格，表示该字符的位置。
- en: If continue is not called, then the program appends the index to the encrypted
    list. When the loop ends, you return the list to end the function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有调用 `continue`，那么程序将把索引添加到加密列表中。当循环结束时，你会返回该列表以结束函数。
- en: 'To see how this works, let’s look at the first message the Nazi spy sends in
    *The Key to Rebecca*, shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解其工作原理，我们来看看纳粹间谍在 *Rebecca的钥匙* 中发送的第一条消息，示例如下：
- en: HAVE ARRIVED. CHECKING IN. ACKNOWLEDGE.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 已到达。正在检查。确认。
- en: 'Using this message and a shift value of 70 yielded the following randomly generated
    ciphertext:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个消息和 70 的移位值生成了以下随机生成的密文：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Your results may differ due to the stochastic nature of the algorithm.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于算法的随机性，你的结果可能会有所不同。
- en: '**Decrypting the Message**'
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**解密消息**'
- en: '[Listing 4-4](ch04.xhtml#ch04list4) defines a function to decrypt the ciphertext.
    The user will copy and paste the ciphertext when asked for input by the main()
    function.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-4](ch04.xhtml#ch04list4) 定义了一个函数来解密密文。用户会在 main() 函数提示输入时复制并粘贴密文。'
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 4-4: Defining a function to decrypt the plaintext message'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-4：定义一个函数来解密明文消息
- en: The listing starts by defining a function named decrypt() with the message,
    the novel (text), and the shift value as parameters. Of course, the message will
    be in ciphertext form, consisting of a list of numbers representing shifted indexes.
    You immediately create an empty string to hold the decrypted plaintext.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例首先定义了一个名为 decrypt() 的函数，参数包括消息、正文（文本）和位移值。当然，消息将是密文形式，由表示位移索引的数字列表组成。你立即创建一个空字符串来存储解密后的明文。
- en: Most people will copy and paste the ciphertext when prompted for input by the
    main() function. This input may or may not contain the square brackets that came
    with the list. And because the user entered the ciphertext using the input() function,
    the results are a *string*. To convert the indexes to integers that can be shifted,
    you first need to remove the nondigit characters. Do this using the string replace()
    and split() methods, while also using list comprehension to return a list. List
    comprehension is a shorthand way to execute loops in Python.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人会在 main() 函数提示输入时复制并粘贴密文。此输入可能包含或不包含列表中的方括号。而且，由于用户是通过 input() 函数输入密文，因此结果是一个
    *字符串*。为了将索引转换为可以进行位移的整数，首先需要删除非数字字符。可以使用字符串的 replace() 和 split() 方法，同时利用列表推导式返回一个列表。列表推导式是
    Python 中执行循环的简洁方式。
- en: To use replace(), you pass it the character you want replaced followed by the
    character used to replace it. In this case, use a space for the replacement. Note
    that you can “string” these together with dot notation, handling the commas and
    brackets all in one go. How cool is that?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 replace()，你需要传入你想要替换的字符，后跟用于替换的字符。在这种情况下，使用空格进行替换。注意，你可以通过点符号将它们“串联”在一起，一次性处理逗号和方括号。是不是很酷？
- en: Next, start looping through the indexes. The program converts the current index
    from a string to an integer so you can subtract the shift value that was applied
    during encryption. You use the index to access the character list and get the
    corresponding character. Then you add the character to the plaintext string and
    return plaintext when the loop ends.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，开始遍历索引。程序将当前的索引从字符串转换为整数，以便你可以减去在加密时应用的位移值。你使用索引访问字符列表并获取相应的字符。然后将字符添加到明文字符串中，并在循环结束时返回明文。
- en: '**Checking for Failure and Calling the main() Function**'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查失败并调用 main() 函数**'
- en: '[Listing 4-5](ch04.xhtml#ch04list5) defines a function to check the ciphertext
    for duplicate indexes (keys) and finishes the program by calling the main() function.
    If the function discovers duplicate indexes, the encryption might have been compromised,
    and the main() function will tell the user how to fix it before terminating.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-5](ch04.xhtml#ch04list5) 定义了一个函数来检查密文中的重复索引（密钥），并通过调用 main() 函数结束程序。如果该函数发现重复的索引，可能是加密已被破坏，main()
    函数会告诉用户如何修复它，然后终止程序。'
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 4-5: Defining a function to check for duplicate indexes and calling
    main()'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-5：定义一个函数检查重复的索引并调用 main()
- en: This listing defines a function named check_for_fail() that takes the ciphertext
    as an argument. It checks to see whether any of the indexes in the ciphertext
    are repeated. Remember, the one-time pad approach works because every key is unique;
    thus, every index in the ciphertext should be unique.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码列出了一个名为 check_for_fail() 的函数，它接受密文作为参数。它会检查密文中的任何索引是否有重复。记住，一次性密码本的方法之所以有效，是因为每个密钥都是唯一的；因此，密文中的每个索引应该是唯一的。
- en: 'To look for repeats, the program uses Counter again. It employs list comprehension
    to build a list containing all the duplicate indexes. Here, k stands for (dictionary)
    key, and v stands for (dictionary) value. Since Counter produces a dictionary
    of counts for each key, what you’re saying here is this: For every key-value pair
    in a dictionary made from the ciphertext, create a list of all the keys that occur
    more than once. If there are duplicates, append the corresponding key to the check
    list.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查找重复项，程序再次使用了Counter。它使用列表推导式构建一个包含所有重复索引的列表。这里，k代表（字典）键，v代表（字典）值。由于Counter生成每个键的计数字典，你可以理解为：对于从密文生成的字典中的每个键值对，创建一个包含所有出现超过一次的键的列表。如果有重复项，就将相应的键添加到检查列表中。
- en: Now all you need to do is get the length of check. If it is greater than zero,
    the encryption is compromised, and the program returns True.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要做的就是获取检查的长度。如果它大于零，则表示加密已被破解，程序将返回True。
- en: The program ends with the boilerplate code to call the program as a module or
    in stand-alone mode.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 程序以调用程序作为模块或独立模式的样板代码结束。
- en: '***Sending Messages***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***发送消息***'
- en: The following message is based on a passage from *The Key to Rebecca*. You can
    find it in the downloadable *Chapter_4* folder as *allied_attack_plan.txt*. As
    a test, try sending it with a shift of 70\. Use your operating system’s Select
    All, Copy, and Paste commands to transfer the text when asked for input. If it
    doesn’t pass the check_for_fail() test, run it again!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下消息摘自*《Rebecca的关键》*。你可以在可下载的*Chapter_4*文件夹中找到它，文件名为*allied_attack_plan.txt*。作为测试，尝试用70的位移发送它。当请求输入时，使用操作系统的全选、复制和粘贴命令来传输文本。如果它未通过check_for_fail()测试，重新运行一次！
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The nice thing about this technique is that you can use proper punctuation,
    at least if you type the message into the interpreter window. Text copied in from
    outside may need to be stripped of the newline character (such as \r\n or \n),
    placed wherever the carriage return was used.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技术的好处在于你可以使用适当的标点符号，至少如果你将消息输入到解释器窗口中。通过外部复制的文本可能需要去除换行符（例如\r\n或\n），并将其放置在回车符出现的地方。
- en: Of course, only characters that occur in *The Lost World* can be encrypted.
    The program will warn you of exceptions and then replace missing characters with
    a space.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，只有*《失落的世界》*中的字符可以被加密。程序会警告你出现异常的情况，然后用空格替代缺失的字符。
- en: To be sneaky, you don’t want to save plaintext or ciphertext messages to a file.
    Cutting and pasting from the shell is the way to go. Just remember to copy something
    new when you’re finished so you don’t leave incriminating evidence on your clipboard!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持隐秘，你不想将明文或密文消息保存到文件中。从终端复制和粘贴是最好的方法。只需记得在完成后复制一些新的内容，以免在剪贴板上留下可疑证据！
- en: If you want to get fancy, you can copy and paste text to the clipboard straight
    from Python using pyperclip, written by Al Sweigart. You can learn more at *[https://pypi.org/project/pyperclip/](https://pypi.org/project/pyperclip/)*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更花哨一些，可以使用Al Sweigart编写的pyperclip库，直接从Python复制和粘贴文本到剪贴板。你可以在*[https://pypi.org/project/pyperclip/](https://pypi.org/project/pyperclip/)*了解更多信息。
- en: '**Summary**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you got to work with defaultdict and Counter from the collections
    module; choice() from the random module; and replace(), enumerate(), ord(), and
    repr() from the Python Standard Library. The result was an encryption program,
    based on the one-time pad technique, that produces unbreakable ciphertext.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了使用collections模块中的defaultdict和Counter；random模块中的choice()；以及Python标准库中的replace()、enumerate()、ord()和repr()。最终，制作出了一个基于一次性密码本技术的加密程序，能够生成无法破解的密文。
- en: '**Further Reading**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*The Key to Rebecca* (Penguin Random House, 1980), by Ken Follett, is an exciting
    novel noted for its depth of historical detail, accurate descriptions of Cairo
    in World War II, and thrilling espionage storyline.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*《Rebecca的关键》（Penguin Random House, 1980）*，作者肯·福雷特，是一本令人兴奋的小说，以其深刻的历史细节、对二战期间开罗的准确描绘以及扣人心弦的间谍故事情节而著称。'
- en: '*The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography*
    (Anchor, 2000), by Simon Singh, is an interesting review of cryptography through
    the ages, including a discussion of the one-time pad.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*《密码书：从古埃及到量子密码学的秘密科学》*（Anchor, 2000），作者西蒙·辛格，是一本有趣的密码学历史回顾，包括对一次性密码本的讨论。'
- en: If you enjoy working with ciphers, check out *Cracking Codes with Python* (No
    Starch Press, 2018), by Al Sweigart. Aimed at beginners in both cryptography and
    Python programming, this book covers many cipher types, including reverse, Caesar,
    transposition, substitution, affine, and Vigenère.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢破解密码，可以查看 *Cracking Codes with Python*（No Starch Press, 2018），作者 Al Sweigart。该书面向密码学和
    Python 编程初学者，涵盖了许多密码类型，包括反向密码、凯撒密码、换位密码、替换密码、仿射密码和维吉尼亚密码。
- en: '*Impractical Python Projects: Playful Programming Activities to Make You Smarter*(No
    Starch Press, 2019), by Lee Vaughan, includes additional ciphers such as the Union
    route cipher, the rail fence cipher, and the Trevanion null cipher as well as
    a technique for writing with invisible electronic ink.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*Impractical Python Projects: Playful Programming Activities to Make You Smarter*（No
    Starch Press, 2019），由 Lee Vaughan 著，书中包括额外的密码，例如联合路由密码、铁路栅栏密码和特雷瓦尼恩空密码，以及用隐形电子墨水写作的技巧。'
- en: '**Practice Project: Charting the Characters**'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：字符图表**'
- en: If you have matplotlib installed (see “Installing the Python Libraries” on [page
    6](ch01.xhtml#page_6)), you can visually represent the available characters in
    *The Lost World*, along with their frequency of occurrence, using a bar chart.
    This can complement the shell printout of each character and its count currently
    used in the *rebecca.py* program.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了 matplotlib（请参见[第6页](ch01.xhtml#page_6)的“安装 Python 库”），你可以使用条形图将《失落的世界》中的可用字符及其出现频率可视化。这可以补充当前在
    *rebecca.py* 程序中使用的每个字符及其计数的 shell 输出。
- en: The internet is rife with example code for matplotlib plots, so just search
    for *make a simple bar chart matplotlib*. You’ll want to sort the counts in descending
    order before plotting.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上充斥着关于 matplotlib 图表的示例代码，所以只需搜索 *制作简单的条形图 matplotlib*。在绘制之前，您需要先按降序排序计数。
- en: The mnemonic for remembering the most common letters in English is “etaoin.”
    If you plot in descending order, you’ll see that *The Lost World* dataset is no
    exception ([Figure 4-2](ch04.xhtml#ch04fig2))!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 记住英语中最常见字母的助记符是“etaoin”。如果按降序绘图，你会发现 *失落的世界* 数据集也不例外（[图 4-2](ch04.xhtml#ch04fig2)）！
- en: '![Image](../images/fig04_02.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig04_02.jpg)'
- en: 'Figure 4-2: Frequency of occurrence of characters in the digital version of
    The Lost World'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2：在《失落的世界》数字版中字符出现的频率
- en: Note that the most common character is a space. This makes it easy to encrypt
    spaces, further confounding any cryptanalysis!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最常见的字符是空格。这使得加密空格变得容易，进一步困扰任何密码分析！
- en: You can find a solution, *practice_barchart.py*, in the appendix and on the
    book’s website.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附录和书籍网站上找到解决方案 *practice_barchart.py*。
- en: '**Practice Project: Sending Secrets the WWII Way**'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：第二次世界大战时期的秘密通信**'
- en: According to the Wikipedia article on *Rebecca* (*[https://en.wikipedia.org/wiki/Rebecca_(novel](https://en.wikipedia.org/wiki/Rebecca_(novel))*),
    the Germans in North Africa in World War II really did attempt to use the novel
    as the key to a book code. Rather than encode the message letter by letter, sentences
    would be made using single words in the book, referred to by page number, line,
    and position in the line.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科上关于 *Rebecca* 的文章（*[https://en.wikipedia.org/wiki/Rebecca_(novel](https://en.wikipedia.org/wiki/Rebecca_(novel))），二战期间德国人确实尝试使用这本小说作为书码的关键。与其逐字编码消息，不如使用书中的单词来构成句子，按页码、行号和行内位置来引用。
- en: 'Copy and edit the *rebecca.py* program so that it uses words rather than letters.
    To get you started, here’s how to load the text file as a list of words, rather
    than characters, using list comprehension:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并编辑 *rebecca.py* 程序，使其使用单词而不是字母。为了帮助你入门，这里有一种使用列表推导式将文本文件作为单词列表加载的方法，而不是字符：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output should look like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该像这样：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that all punctuation, including apostrophes, has been removed. Messages
    will need to follow this convention.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有标点符号，包括撇号，已被去除。消息需要遵循这一惯例。
- en: You’ll also need to handle words, such as proper names and place names, that
    don’t occur in *The Lost World*. One approach would be a “first-letter mode” where
    the recipient uses only the first letter of each word between flags. The flags
    should be commonly occurring words, like *a* and *the*, doubled. Alternate their
    use to make it easier to identify the start and end flags. In this case, *a a*
    indicates the start of first-letter mode, and *the the* indicates the end. For
    example, to handle the phrase *Sidi Muftah with ten tanks*, first run it straight
    up to identify missing words.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要处理《失落的世界》中未出现的单词，比如专有名词和地名。一种方法是使用“首字母模式”，在这种模式下，接收者只使用标志之间每个单词的首字母。标志应该是常见的单词，比如*a*和*the*，并且重复使用它们，以便更容易识别开始和结束的标志。在这种情况下，*a
    a*表示首字母模式的开始，*the the*表示结束。例如，要处理短语*Sidi Muftah with ten tanks*，首先将其直接运行以识别缺失的单词。
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the missing words identified, reword the message to spell them using first-letter
    mode. I’ve highlighted the first letters in gray in the following snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别出缺失的单词后，请重新措辞消息并使用首字母模式拼写它们。我在以下代码片段中将首字母标记为灰色：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are 1,864 occurrences of *a* and 4,442 of *the* in *The Lost World*. If
    you stick to short messages, you shouldn’t duplicate keys. Otherwise, you may
    need to use multiple flag characters or disable the check-for-fail() function
    and accept some duplicates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在《失落的世界》中，*a*出现了1,864次，*the*出现了4,442次。如果你坚持使用简短的消息，就不应该重复键。否则，你可能需要使用多个标志字符，或者禁用check-for-fail()函数并接受一些重复项。
- en: Feel free to come up with your own method for handling problem words. As consummate
    planners, the Germans surely had *something* in mind or they wouldn’t have considered
    a book code in the first place!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 随意提出自己的方法来处理问题单词。作为精通规划的德国人，他们肯定有*某种*想法，否则他们根本不会考虑使用书籍密码！
- en: You can find a simple first-letter solution, *practice_WWII_words.py*, in the
    appendix or online at *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附录中找到一个简单的首字母解决方案，*practice_WWII_words.py*，或者在线访问* [https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)
    *。
