- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SENDING SUPER-SECRET MESSAGES WITH A BOOK CIPHER
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*The Key to Rebecca* is a critically acclaimed best-selling novel by Ken Follett.
    Set in Cairo in World War II and based on actual events, it tells the story of
    a Nazi spy and the British intelligence officer who pursued him. The title refers
    to the spy’s cipher system, which used the famous gothic novel *Rebecca*, written
    by Daphne du Maurier, as a key. *Rebecca* is considered one of the greatest novels
    of the 20th century, and the Germans really did use it as a code book during the
    war.'
  prefs: []
  type: TYPE_NORMAL
- en: The Rebecca cipher is a variation of the *one-time pad*, an unbreakable encryption
    technique that requires a key that is at least the same size as the message being
    sent. Both the sender and receiver have a copy of the pad, and after one use,
    the top sheet is ripped off and discarded.
  prefs: []
  type: TYPE_NORMAL
- en: One-time pads provide absolute, perfect security—uncrackable even by a quantum
    computer! Despite this, the pads have several practical drawbacks that prevent
    widespread use. Key among these are the need to securely transport and deliver
    the pads to the sender and receiver, the need to safely store them, and the difficulty
    in manually encoding and decoding the messages.
  prefs: []
  type: TYPE_NORMAL
- en: In the *The Key to Rebecca*, both parties must know the encryption rules and
    have the same edition of the book to use the cipher. In this chapter, you’ll transfer
    the manual method described in the book into a more secure—and easier to use—digital
    technique. In the process, you’ll get to work with useful functions from the Python
    Standard Library, the collections module, and the random module. You’ll also learn
    a little more about Unicode, a standard used to ensure that characters, such as
    letters and numbers, are universally compatible across all platforms, devices,
    and applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**The One-Time Pad**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A one-time pad is basically an ordered stack of sheets printed with truly random
    numbers, usually in groups of five ([Figure 4-1](ch04.xhtml#ch04fig1)). To make
    them easy to conceal, the pads tend to be small and may require a powerful magnifying
    glass to read. Despite being old-school, one-time pads produce the most secure
    ciphers in the world, as every letter is encrypted with a unique key. As a result,
    cryptanalysis techniques, such as frequency analysis, simply can’t work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: Example of a one-time pad sheet'
  prefs: []
  type: TYPE_NORMAL
- en: To encrypt a message with the one-time pad in [Figure 4-1](ch04.xhtml#ch04fig1),
    start by assigning each letter of the alphabet a two-digit number. *A* equals
    01, *B* equals 02, and so on, as shown in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/table_page_78_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, convert the letters in your short message into numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/table_page_79_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Starting at the upper left of the one-time pad sheet and reading left to right,
    assign a number pair (*key*) to each letter and add it to the number value of
    the letter. You’ll want to work with base 10 number pairs, so if your sum is greater
    than 100, use modular arithmetic to truncate the value to the last two digits
    (103 becomes 03). The numbers in shaded cells in the following diagrams are the
    result of modular arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/table_page_79_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last row in this diagram represents the ciphertext. Note that KITTY, duplicated
    in the plaintext, is not repeated in the ciphertext. Each encryption of KITTY
    is unique.
  prefs: []
  type: TYPE_NORMAL
- en: To decrypt the ciphertext back to plaintext, the recipient uses the same sheet
    from their identical one-time pad. They place their number pairs below the ciphertext
    pairs and subtract. When this results in a negative number, they use modular subtraction
    (adding 100 to the ciphertext value before subtracting). They finish by converting
    the resulting number pairs back to letters.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/table_page_79_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To ensure that no keys are repeated, the number of letters in the message can’t
    exceed the number of keys on the pad. This forces the use of short messages, which
    have the advantage of being easier to encrypt and decrypt and which offer a cryptanalyst
    fewer opportunities to decipher the message. Some other guidelines include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Spell out numbers (for example, TWO for 2).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End sentences with an *X* in place of a period (for example, CALL AT NOONX).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spell out any other punctuation that can’t be avoided (for example, COMMA).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End the plaintext message with *XX*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Rebecca Cipher**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the novel *The Key to Rebecca*, the Nazi spy uses a variant of the one-time
    pad. Identical editions of the novel *Rebecca* are purchased in Portugal. Two
    are retained by the spy; the other two are given to Field Marshal Rommel’s staff
    in North Africa. The encrypted messages are sent by radio on a pre-determined
    frequency. No more than one message is sent per day and always at midnight.
  prefs: []
  type: TYPE_NORMAL
- en: To use the key, the spy would take the current date—say, May 28, 1942—and add
    the day to the year (28 + 42 = 70). This would determine which page of the novel
    to use as a one-time pad sheet. Because May is the fifth month, every fifth word
    in a sentence would be discounted. Because the Rebecca cipher was meant to be
    used only during a relatively short period in 1942, the spy didn’t have to worry
    about repetitions in the calendar causing repetition in the keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'The spy’s first message was the following: HAVE ARRIVED. CHECKING IN. ACKNOWLEDGE.
    Beginning at the top of [page 70](ch03.xhtml#page_70), he read along until he
    found the letter *H*. It was the 10th character, discounting every 5th letter.
    The 10th letter of the alphabet is *J*, so he used this in his ciphertext to represent
    *H*. The next letter, *A*, was found three letters after *H*, so it was encoded
    using the third letter of the alphabet, *C*. This continued until the full message
    was encrypted. For rare letters like *X* or *Z*, author Ken Follett states that
    special rules were applied but does not describe them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a book in this manner had a distinct advantage over a true one-time pad.
    To quote Follett, “A pad was unmistakably for the purpose of encipherment, but
    a book looked quite innocent.” A disadvantage remained, however: the process of
    encryption and decryption is tedious and potentially error prone. Let’s see if
    we can remedy this using Python!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #6: The Digital Key to Rebecca**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Turning the Rebecca technique into a digital program offers several advantages
    over a one-time pad:'
  prefs: []
  type: TYPE_NORMAL
- en: The encoding and decoding processes become fast and error-free.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Longer messages can be sent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Periods, commas, and even spaces can be directly encrypted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rare letters, like *z*, can be chosen from anywhere in the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code book can be hidden among thousands of ebooks on a hard drive or in
    the cloud.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last item is important. In the novel, the British intelligence officer finds
    a copy of *Rebecca* at a captured German outpost. Through simple deductive reasoning
    he recognizes it as a substitute for a one-time pad. With a digital approach,
    this would have been much more difficult. In fact, the novel could be kept on
    a small, easily concealed device such as an SD card. This would make it similar
    to a one-time pad, which is often no bigger than a postage stamp.
  prefs: []
  type: TYPE_NORMAL
- en: 'A digital approach does have one disadvantage, however: the program is a *discoverable*
    item. Whereas a spy could simply memorize the rules for a one-time pad, with a
    digital approach the rules must be ensconced in the software. This weakness can
    be minimized by writing the program so that it looks innocent—or at least cryptic—and
    having it request input from the user for the message and the name of the code
    book.'
  prefs: []
  type: TYPE_NORMAL
- en: THE OBJECTIVE
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that encrypts and decrypts messages using a digital novel
    as a one-time pad.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Strategy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike the spy, you won’t need all the rules used in the novel, and many wouldn’t
    work anyway. If you’ve ever used any kind of ebook, you know that page numbers
    are meaningless. Changes to screen sizes and text sizes render all such page numbers
    nonunique. And because you can choose letters from anywhere in the book, you don’t
    necessarily need special rules for rare letters or for discounting numbers in
    a count.
  prefs: []
  type: TYPE_NORMAL
- en: So, you don’t need to focus on perfectly reproducing the Rebecca cipher. You
    just need to produce something similar and, ideally, better.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Python *iterables*, such as lists and tuples, use numerical indexes
    to keep track of every single item within them. By loading a novel as a list,
    you can use these indexes as unique starting keys for each character. You can
    then shift the indexes based on the day of the year, emulating the spy’s methodology
    in *The Key to Rebecca*.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, *Rebecca* is not yet in the public domain. In its place, we’ll
    substitute the text file of Sir Arthur Conan Doyle’s *The Lost World* that you
    used in [Chapter 2](ch02.xhtml). This novel contains 51 distinct characters that
    occur 421,545 times, so you can randomly choose indexes with little chance of
    duplication. This means you can use the whole book as a one-time pad each time
    you encrypt a message, rather than restrict yourself to a tiny collection of numbers
    on a single one-time pad sheet.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can download and use a digital version of Rebecca if you want. I just
    can’t provide you with a copy for free!*'
  prefs: []
  type: TYPE_NORMAL
- en: Because you’ll be reusing the book, you’ll need to worry about both *message-to-message*
    and *in-message* duplication of keys. The longer the message, the more material
    the cryptanalyst can study, and the easier it is to crack the code. And if each
    message is sent with the same encryption key, all the intercepted messages can
    be treated as a single large message.
  prefs: []
  type: TYPE_NORMAL
- en: For the message-to-message problem, you can imitate the spy and shift the index
    numbers by the day of the year, using a range of 1 to 366 to account for leap
    years. In this scheme, February 1 would be 32\. This will effectively turn the
    book into a new one-time pad sheet each time, as different keys will be used for
    the same characters. Shifting, by one or more increments, resets all the indexes
    and essentially “tears off” the previous sheet. And unlike a one-time pad, you
    don’t have to bother with disposing of a piece of paper!
  prefs: []
  type: TYPE_NORMAL
- en: For the in-message duplication problem, you can run a check before transmitting
    the message. It’s unlikely but possible for the program to pick the same letter
    twice during encryption and thus use the same index twice. Duplicate indexes are
    basically repeating keys, and these can help a cryptanalyst break your code. So,
    if duplicate indexes are found, you can rerun the program or reword the message.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need similar rules to those used in *The Key to Rebecca*.
  prefs: []
  type: TYPE_NORMAL
- en: Both parties need identical digital copies of *The Lost World*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both parties need to know how to shift the indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep messages as short as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spell out numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***The Encryption Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following *rebecca.py* code will take a message and return an encrypted
    or plaintext version, as specified by the user. The message can be typed in or
    downloaded from the book’s website. You’ll also need the *lost.txt* text file
    in the same folder as the code.
  prefs: []
  type: TYPE_NORMAL
- en: For clarity, you’ll use variable names like *ciphertext*, *encrypt*, *message*,
    and so on. If you were a real spy, however, you’d avoid incriminating terms in
    case the enemy got their hands on your laptop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing Modules and Defining the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 4-1](ch04.xhtml#ch04list1) imports modules and defines the main()
    function, used to run the program. This function will ask for user input, call
    the functions needed to encrypt or decrypt text, check for duplicate keys, and
    print the ciphertext or plaintext.'
  prefs: []
  type: TYPE_NORMAL
- en: Whether you define main() at the start or end of a program is a matter of choice.
    Sometimes it provides a good, easily readable summary of the whole program. Other
    times it may feel out of place, like the cart before the horse. From Python’s
    perspective, it won’t matter where you place it so long as you call the function
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: Importing modules and defining the main() function'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing sys and os, two modules that let you interface with the operating
    system; then the random module; and then defaultdict and Counter from the collections
    module.
  prefs: []
  type: TYPE_NORMAL
- en: The collections module is part of the Python Standard Library and includes several
    container data types. You can use defaultdict to build a dictionary on the fly.
    If defaultdict encounters a missing key, it will supply a default value rather
    than throw an error. You’ll use it to build a dictionary of the characters in
    *The Lost World* and their corresponding index values.
  prefs: []
  type: TYPE_NORMAL
- en: A Counter is a dictionary subclass for counting hashable objects. Elements are
    stored as dictionary keys, and their counts are stored as dictionary values. You’ll
    use this to check your ciphertext and ensure no indexes are duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you begin the definition of the main() function. The function
    starts by asking the user for the message to encrypt or decrypt. For maximum security,
    the user should type this in. The program then asks the user to specify whether
    they want encryption or decryption. Once the user chooses, the program asks for
    the shift value. The shift value represents the day of the year, over the inclusive
    and consecutive range of 1 to 366\. Next, ask for the infile, which will be *lost.txt*,
    the digital version of *The Lost World* ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, the program checks that the file exists. It uses the operating
    system module’s path.exists() method and passes it the infile variable. If the
    file doesn’t exist or if the path and/or filename is incorrect, the program lets
    the user know, uses the file=sys.stderr option to color the message “error red”
    in the Python shell, and terminates the program with sys.exit(1). The 1 is used
    to flag that the program terminated with an error, as opposed to a clean termination.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you call some functions that you’ll define later. The first function loads
    the *lost.txt* file as a string named text, which includes nonletter characters
    such as spaces and punctuation. The second builds a dictionary of the characters
    and their corresponding indexes, with the shift value applied.
  prefs: []
  type: TYPE_NORMAL
- en: Now you start a conditional to evaluate the process being used. As I mentioned,
    we’re using incriminating terms like *encrypt* and *decrypt* for clarity. You’d
    want to disguise these for real espionage work. If the user has chosen to encrypt,
    call the function that encrypts the message with the character dictionary. When
    the function returns, the program has encrypted the message. But don’t assume
    it worked as planned! You need to check that it decrypted correctly and that no
    keys are duplicated. To do this, you start a series of quality control steps.
  prefs: []
  type: TYPE_NORMAL
- en: First, you check for duplicate keys ➋. If this function returns True, instruct
    the user to try again, change the message, or change the book to something other
    than *The Lost World*. For each character in the message, you’ll use the char_dict
    and choose an index at random. Even with hundreds or even thousands of indexes
    for each character, you may still choose the same index more than once for a given
    character.
  prefs: []
  type: TYPE_NORMAL
- en: Rerunning the program with slightly different parameters, as listed earlier,
    should fix this, unless you have a long message with a lot of low-frequency characters.
    Handling this rare case may require rewording the message or finding a larger
    manuscript than *The Lost World*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python’s random module does not produce truly random numbers but rather pseudorandom
    numbers that can be predicted. Any cipher using pseudorandom numbers can potentially
    be cracked by a cryptanalyst. For maximum security when generating random numbers,
    you should use Python’s os.urandom() function.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, print the contents of the character dictionary so you can see how many
    times the various characters occur in the novel ➌. This will help guide what you
    put in messages, though *The Lost World* contains a healthy helping of useful
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To generate this table, you use Python’s Format Specification Mini-Language
    (*[https://docs.python.org/3/library/string.html#formatspec](https://docs.python.org/3/library/string.html#formatspec)*)
    to print headers for the three columns. The number in curly brackets denotes how
    many characters should be in the string, and the greater-than sign designates
    right justification.
  prefs: []
  type: TYPE_NORMAL
- en: The program then loops through the keys in the character dictionary and prints
    them using the same column width and justification. It prints the character, its
    Unicode value, and the number of times it occurs in the text.
  prefs: []
  type: TYPE_NORMAL
- en: You use repr() to print the key. This built-in function returns a string containing
    a printable representation of an object. That is, it returns all information about
    the object in a format useful for debugging and development purposes. This allows
    you to explicitly print characters like newline (\n) and space. The index range
    [1:-1] excludes the quotes on both sides of the output string.
  prefs: []
  type: TYPE_NORMAL
- en: The ord() built-in function returns an integer representing the Unicode code
    point for a character. Computers deal only with numbers, so they must assign a
    number to every possible character, such as *%*, 5, ![Image](../images/icon1.jpg),
    or *A*. The *Unicode Standard* ensures that every character, no matter what platform,
    device, application, or language, has a unique number and is universally compatible.
    By showing the user the Unicode values, the program lets the user pick up on anything
    strange happening with a text file, such as the same letter showing up as multiple
    distinct characters.
  prefs: []
  type: TYPE_NORMAL
- en: For the third column, you get the length of each dictionary key. This will represent
    the number of times that character appears in the novel. The program then prints
    the number of distinct characters and the total of all characters in the text.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you finish the encryption process by printing the ciphertext, and then
    the decrypted plaintext, as a check. To decipher the message, the program loops
    through each item in the ciphertext and uses the item as an index for text ➍,
    subtracting the shift value, which was added earlier. When you print the results,
    the program uses end='' in place of the default newline, so each character isn’t
    on a separate line.
  prefs: []
  type: TYPE_NORMAL
- en: The main() function ends with a conditional statement to check whether process
    == 'decrypt'. If the user chooses to decrypt the message, the program calls the
    decrypt() function and then prints the decrypted plaintext. Note that you could
    simply use else here, but I chose to use elif for clarity and readability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading a File and Making a Dictionary**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 4-2](ch04.xhtml#ch04list2) defines functions to load a text file and
    make a dictionary of characters in the file and their corresponding indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-2: Defining the load_file() and make_dict() functions'
  prefs: []
  type: TYPE_NORMAL
- en: This listing begins by defining a function to load a text file as a string.
    Using with to open the file ensures it will close automatically when the function
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some users may get an error, such as the following one, when loading text files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, try modifying the open function by adding the encoding and errors
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For more on this issue, see [page 35](ch02.xhtml#page_35) in [Chapter 2](ch02.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: After opening the file, read it to a string and convert all the text to lower-
    case. Then return the string.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to turn the string into a dictionary. Define a function that
    takes this string and the shift value as arguments ➊. The program creates a char_dict
    variable using defaultdict(). This variable will be a dictionary. The program
    then passes the type constructor for list to defaultdict(), as you want the dictionary
    values to be a list of indexes.
  prefs: []
  type: TYPE_NORMAL
- en: With defaultdict(), whenever an operation encounters an item that isn’t already
    in the dictionary, a function named default_factory() is called with no arguments,
    and the output is used as the value. Any key that doesn’t exist gets the value
    returned by default_factory, and no KeyError is raised.
  prefs: []
  type: TYPE_NORMAL
- en: If you tried to make the dictionary on the fly without the handy collections
    module, you’d get the KeyError, as shown in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The built-in enumerate() function acts as an automatic counter, so you can easily
    get the index for each character in the string derived from *The Lost World*.
    The keys in char_dict are characters, and the characters can occur thousands of
    times within text. So, the dictionary values are lists that hold the indexes for
    all these character occurrences. By adding the shift value to the index when it
    is appended to a value list, you ensure that the indexes will be unique for each
    message ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Finish the function by returning the character dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encrypting the Message**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 4-3](ch04.xhtml#ch04list3) defines a function to encrypt the message.
    The resulting ciphertext will be a list of indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-3: Defining a function to encrypt the plaintext message'
  prefs: []
  type: TYPE_NORMAL
- en: The encrypt() function will take the message and char_dict as arguments. Start
    it by creating an empty list to hold the ciphertext. Next, start looping through
    the characters in message and converting them to lowercase to match the characters
    in char_dict.
  prefs: []
  type: TYPE_NORMAL
- en: If the number of indexes associated with the character is greater than 1, the
    program uses the random.choice() method to choose one of the character’s indexes
    at random ➊.
  prefs: []
  type: TYPE_NORMAL
- en: If a character occurs only once in char_dict, random.choice() will throw an
    error. To handle this, the program uses a conditional and hardwires the choice
    of the index, which will be at position [0].
  prefs: []
  type: TYPE_NORMAL
- en: If the character doesn’t exist in *The Lost World*, it won’t be in the dictionary,
    so use a conditional to check for this ➋. If it evaluates to True, print an alert
    for the user and use continue to return to the start of the loop without choosing
    an index. Later, when the quality control steps run on the ciphertext, a space
    will appear in the decrypted plaintext where this character should be.
  prefs: []
  type: TYPE_NORMAL
- en: If continue is not called, then the program appends the index to the encrypted
    list. When the loop ends, you return the list to end the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, let’s look at the first message the Nazi spy sends in
    *The Key to Rebecca*, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: HAVE ARRIVED. CHECKING IN. ACKNOWLEDGE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this message and a shift value of 70 yielded the following randomly generated
    ciphertext:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Your results may differ due to the stochastic nature of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decrypting the Message**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 4-4](ch04.xhtml#ch04list4) defines a function to decrypt the ciphertext.
    The user will copy and paste the ciphertext when asked for input by the main()
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-4: Defining a function to decrypt the plaintext message'
  prefs: []
  type: TYPE_NORMAL
- en: The listing starts by defining a function named decrypt() with the message,
    the novel (text), and the shift value as parameters. Of course, the message will
    be in ciphertext form, consisting of a list of numbers representing shifted indexes.
    You immediately create an empty string to hold the decrypted plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: Most people will copy and paste the ciphertext when prompted for input by the
    main() function. This input may or may not contain the square brackets that came
    with the list. And because the user entered the ciphertext using the input() function,
    the results are a *string*. To convert the indexes to integers that can be shifted,
    you first need to remove the nondigit characters. Do this using the string replace()
    and split() methods, while also using list comprehension to return a list. List
    comprehension is a shorthand way to execute loops in Python.
  prefs: []
  type: TYPE_NORMAL
- en: To use replace(), you pass it the character you want replaced followed by the
    character used to replace it. In this case, use a space for the replacement. Note
    that you can “string” these together with dot notation, handling the commas and
    brackets all in one go. How cool is that?
  prefs: []
  type: TYPE_NORMAL
- en: Next, start looping through the indexes. The program converts the current index
    from a string to an integer so you can subtract the shift value that was applied
    during encryption. You use the index to access the character list and get the
    corresponding character. Then you add the character to the plaintext string and
    return plaintext when the loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking for Failure and Calling the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 4-5](ch04.xhtml#ch04list5) defines a function to check the ciphertext
    for duplicate indexes (keys) and finishes the program by calling the main() function.
    If the function discovers duplicate indexes, the encryption might have been compromised,
    and the main() function will tell the user how to fix it before terminating.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-5: Defining a function to check for duplicate indexes and calling
    main()'
  prefs: []
  type: TYPE_NORMAL
- en: This listing defines a function named check_for_fail() that takes the ciphertext
    as an argument. It checks to see whether any of the indexes in the ciphertext
    are repeated. Remember, the one-time pad approach works because every key is unique;
    thus, every index in the ciphertext should be unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'To look for repeats, the program uses Counter again. It employs list comprehension
    to build a list containing all the duplicate indexes. Here, k stands for (dictionary)
    key, and v stands for (dictionary) value. Since Counter produces a dictionary
    of counts for each key, what you’re saying here is this: For every key-value pair
    in a dictionary made from the ciphertext, create a list of all the keys that occur
    more than once. If there are duplicates, append the corresponding key to the check
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: Now all you need to do is get the length of check. If it is greater than zero,
    the encryption is compromised, and the program returns True.
  prefs: []
  type: TYPE_NORMAL
- en: The program ends with the boilerplate code to call the program as a module or
    in stand-alone mode.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sending Messages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following message is based on a passage from *The Key to Rebecca*. You can
    find it in the downloadable *Chapter_4* folder as *allied_attack_plan.txt*. As
    a test, try sending it with a shift of 70\. Use your operating system’s Select
    All, Copy, and Paste commands to transfer the text when asked for input. If it
    doesn’t pass the check_for_fail() test, run it again!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The nice thing about this technique is that you can use proper punctuation,
    at least if you type the message into the interpreter window. Text copied in from
    outside may need to be stripped of the newline character (such as \r\n or \n),
    placed wherever the carriage return was used.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, only characters that occur in *The Lost World* can be encrypted.
    The program will warn you of exceptions and then replace missing characters with
    a space.
  prefs: []
  type: TYPE_NORMAL
- en: To be sneaky, you don’t want to save plaintext or ciphertext messages to a file.
    Cutting and pasting from the shell is the way to go. Just remember to copy something
    new when you’re finished so you don’t leave incriminating evidence on your clipboard!
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get fancy, you can copy and paste text to the clipboard straight
    from Python using pyperclip, written by Al Sweigart. You can learn more at *[https://pypi.org/project/pyperclip/](https://pypi.org/project/pyperclip/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you got to work with defaultdict and Counter from the collections
    module; choice() from the random module; and replace(), enumerate(), ord(), and
    repr() from the Python Standard Library. The result was an encryption program,
    based on the one-time pad technique, that produces unbreakable ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The Key to Rebecca* (Penguin Random House, 1980), by Ken Follett, is an exciting
    novel noted for its depth of historical detail, accurate descriptions of Cairo
    in World War II, and thrilling espionage storyline.'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography*
    (Anchor, 2000), by Simon Singh, is an interesting review of cryptography through
    the ages, including a discussion of the one-time pad.'
  prefs: []
  type: TYPE_NORMAL
- en: If you enjoy working with ciphers, check out *Cracking Codes with Python* (No
    Starch Press, 2018), by Al Sweigart. Aimed at beginners in both cryptography and
    Python programming, this book covers many cipher types, including reverse, Caesar,
    transposition, substitution, affine, and Vigenère.
  prefs: []
  type: TYPE_NORMAL
- en: '*Impractical Python Projects: Playful Programming Activities to Make You Smarter*(No
    Starch Press, 2019), by Lee Vaughan, includes additional ciphers such as the Union
    route cipher, the rail fence cipher, and the Trevanion null cipher as well as
    a technique for writing with invisible electronic ink.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Charting the Characters**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have matplotlib installed (see “Installing the Python Libraries” on [page
    6](ch01.xhtml#page_6)), you can visually represent the available characters in
    *The Lost World*, along with their frequency of occurrence, using a bar chart.
    This can complement the shell printout of each character and its count currently
    used in the *rebecca.py* program.
  prefs: []
  type: TYPE_NORMAL
- en: The internet is rife with example code for matplotlib plots, so just search
    for *make a simple bar chart matplotlib*. You’ll want to sort the counts in descending
    order before plotting.
  prefs: []
  type: TYPE_NORMAL
- en: The mnemonic for remembering the most common letters in English is “etaoin.”
    If you plot in descending order, you’ll see that *The Lost World* dataset is no
    exception ([Figure 4-2](ch04.xhtml#ch04fig2))!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: Frequency of occurrence of characters in the digital version of
    The Lost World'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the most common character is a space. This makes it easy to encrypt
    spaces, further confounding any cryptanalysis!
  prefs: []
  type: TYPE_NORMAL
- en: You can find a solution, *practice_barchart.py*, in the appendix and on the
    book’s website.
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Sending Secrets the WWII Way**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to the Wikipedia article on *Rebecca* (*[https://en.wikipedia.org/wiki/Rebecca_(novel](https://en.wikipedia.org/wiki/Rebecca_(novel))*),
    the Germans in North Africa in World War II really did attempt to use the novel
    as the key to a book code. Rather than encode the message letter by letter, sentences
    would be made using single words in the book, referred to by page number, line,
    and position in the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy and edit the *rebecca.py* program so that it uses words rather than letters.
    To get you started, here’s how to load the text file as a list of words, rather
    than characters, using list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that all punctuation, including apostrophes, has been removed. Messages
    will need to follow this convention.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to handle words, such as proper names and place names, that
    don’t occur in *The Lost World*. One approach would be a “first-letter mode” where
    the recipient uses only the first letter of each word between flags. The flags
    should be commonly occurring words, like *a* and *the*, doubled. Alternate their
    use to make it easier to identify the start and end flags. In this case, *a a*
    indicates the start of first-letter mode, and *the the* indicates the end. For
    example, to handle the phrase *Sidi Muftah with ten tanks*, first run it straight
    up to identify missing words.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the missing words identified, reword the message to spell them using first-letter
    mode. I’ve highlighted the first letters in gray in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are 1,864 occurrences of *a* and 4,442 of *the* in *The Lost World*. If
    you stick to short messages, you shouldn’t duplicate keys. Otherwise, you may
    need to use multiple flag characters or disable the check-for-fail() function
    and accept some duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to come up with your own method for handling problem words. As consummate
    planners, the Germans surely had *something* in mind or they wouldn’t have considered
    a book code in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: You can find a simple first-letter solution, *practice_WWII_words.py*, in the
    appendix or online at *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  prefs: []
  type: TYPE_NORMAL
