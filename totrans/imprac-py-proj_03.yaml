- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SOLVING ANAGRAMS**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An *anagram* is a word formed by rearranging the letters of another word. For
    example, *Elvis* yields the eerie trio *evils*, *lives*, and *veils*. Does this
    mean Elvis still lives but veils his evil existence? In the book *Harry Potter
    and the Chamber of Secrets*, “I am Lord Voldemort” is an anagram of the evil wizard’s
    real name, Tom Marvolo Riddle. “Lord Earldom Vomit” is also an anagram of Tom
    Marvolo Riddle, but author J.K. Rowling had the good sense to pass on that one.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, first you’ll find all the anagrams for a given word or name.
    Then, you’ll write a program that lets a user interactively build an anagram phrase
    from their own name. Finally, you’ll play computer wizard and see what it takes
    to extract “I am Lord Voldemort” from “Tom Marvolo Riddle.”
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #4: Finding Single-Word Anagrams**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll start by analyzing simple single-word anagrams and figuring out how to
    identify them programmatically. Having accomplished this, you’ll be ready to take
    on anagram phrases in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  prefs: []
  type: TYPE_NORMAL
- en: Use Python and a dictionary file to find all the single-word anagrams for a
    given English word or single name. You can read instructions for finding and loading
    dictionary files at the start of [Chapter 2](ch02.xhtml#ch02).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Strategy and Pseudocode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'More than 600 newspapers and 100 internet sites carry an anagram game called
    *Jumble*. Created in 1954, it’s now the most recognized word-scramble game in
    the world. *Jumble* can be really frustrating, but finding anagrams is almost
    as easy as finding palindromes—you just need to know the common characteristic
    of all anagrams: they must have the same number of the same letters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying an Anagram**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Python doesn’t contain a built-in anagram operator, but you can easily write
    one. For the projects in this chapter, you’ll load the dictionary file from [Chapter
    2](ch02.xhtml#ch02) as a list of strings. So the program needs to verify that
    two strings are anagrams of each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. *Pots* is an anagram of *stop*, and you can verify
    that *stop* and *pots* have the same number of letters with the len() function.
    But there’s no way for Python to know whether two strings have the same number
    of any single character—at least not without converting the strings to another
    data structure or using a counting function. So, instead of looking at these two
    words simply as strings, you can represent them as two lists containing single-character
    strings. Create these lists in a shell, like IDLE, and name them word and anagram,
    as I’ve done here:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word = list(''stop'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word'
  prefs: []
  type: TYPE_NORMAL
- en: '[''s'', ''t'', ''o'', ''p'']'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> anagram = list(''pots'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> anagram'
  prefs: []
  type: TYPE_NORMAL
- en: '[''p'', ''o'', ''t'', ''s'']'
  prefs: []
  type: TYPE_NORMAL
- en: These two lists match our description of an anagram pair; that is, they contain
    the same number of the same letters. But if you try to equate them with the comparison
    operator ==, the result is False.
  prefs: []
  type: TYPE_NORMAL
- en: '>>> anagram == word'
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the operator (==) considers two lists equivalent only if
    they have the same number of the same list items and those items occur in the
    same order. You can easily solve this problem with the built-in function sorted(),
    which can take a list as an argument and reorder its contents alphabetically.
    So, if you call sorted() twice—once for each of the lists—and then compare the
    sorted lists, they will be equivalent. In other words, == returns True.
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word = sorted(word)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word'
  prefs: []
  type: TYPE_NORMAL
- en: '[''o'', ''p'', ''s'', ''t'']'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> anagram = sorted(anagram)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> anagram'
  prefs: []
  type: TYPE_NORMAL
- en: '[''o'', ''p'', ''s'', ''t'']'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> anagram == word'
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs: []
  type: TYPE_NORMAL
- en: You can also pass a string to sorted() to create a sorted list like the ones
    in the preceding code snippet. This will be useful for converting the words from
    the dictionary file into sorted lists of single-character strings.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to verify that you’ve found an anagram, let’s design the
    script in its entirety—from loading a dictionary and prompting the user for a
    word (or name) to searching for and printing all the anagrams.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Pseudocode**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Remember that planning with pseudocode will help you spot potential issues and
    spotting those issues early will save you time. The following pseudocode should
    help you better understand the script we’ll write in the next section, *anagrams.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Load digital dictionary file as a list of words
  prefs: []
  type: TYPE_NORMAL
- en: Accept a word from user
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty list to hold anagrams
  prefs: []
  type: TYPE_NORMAL
- en: Sort the user-word
  prefs: []
  type: TYPE_NORMAL
- en: 'Loop through each word in the word list:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the word
  prefs: []
  type: TYPE_NORMAL
- en: 'if word sorted is equal to user-word sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: Append word to anagrams list
  prefs: []
  type: TYPE_NORMAL
- en: Print anagrams list
  prefs: []
  type: TYPE_NORMAL
- en: The script will start by loading words from a dictionary file into a list as
    strings. Before you loop through the dictionary in search of anagrams, you need
    to know which word you want anagrams of, and you need a place to store anagrams
    when you find them. So, first ask the user to input a word and then create an
    empty list to store the anagrams. Once the program has looped through every word
    in the dictionary, it will print that list of anagrams.
  prefs: []
  type: TYPE_NORMAL
- en: '***Anagram-Finder Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 3-1](ch03.xhtml#ch03list1) loads a dictionary file, accepts a word
    or name *specified within the program*, and finds all the anagrams in the dictionary
    file for that word or name. You’ll also need the dictionary-loading code from
    [Chapter 2](ch02.xhtml#ch02). You can download these from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *anagrams.py* and *load_dictionary.py*, respectively. Keep both files in the
    same folder. You can use the same dictionary file you used in [Chapter 2](ch02.xhtml#ch02)
    or download another one (see [Table 2-1](ch02.xhtml#ch02tab1) on [page 20](ch02.xhtml#page_20)
    for suggestions).'
  prefs: []
  type: TYPE_NORMAL
- en: '*anagrams.py*'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import load_dictionary
  prefs: []
  type: TYPE_NORMAL
- en: ➋ word_list = load_dictionary.load('2of4brif.txt')
  prefs: []
  type: TYPE_NORMAL
- en: ➌ anagram_list = []
  prefs: []
  type: TYPE_NORMAL
- en: '# input a SINGLE word or SINGLE name below to find its anagram(s):'
  prefs: []
  type: TYPE_NORMAL
- en: ➍ name = 'Foster'
  prefs: []
  type: TYPE_NORMAL
- en: print("Input name = {}".format (name))
  prefs: []
  type: TYPE_NORMAL
- en: ➎ name = name.lower()
  prefs: []
  type: TYPE_NORMAL
- en: print("Using name = {}".format(name))
  prefs: []
  type: TYPE_NORMAL
- en: '# sort name & find anagrams'
  prefs: []
  type: TYPE_NORMAL
- en: ➏ name_sorted = sorted(name)
  prefs: []
  type: TYPE_NORMAL
- en: '➐ for word in word_list:'
  prefs: []
  type: TYPE_NORMAL
- en: word = word.lower()
  prefs: []
  type: TYPE_NORMAL
- en: 'if word != name:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if sorted(word) == name_sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: anagram_list.append(word)
  prefs: []
  type: TYPE_NORMAL
- en: '# print out list of anagrams'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '➑ if len(anagram_list) == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print("You need a larger dictionary or a new name!")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: ➒ print("Anagrams =", *anagram_list, sep='\n')
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-1: Given a word (or name) and a dictionary file, this program searches
    for and prints a list of anagrams.*'
  prefs: []
  type: TYPE_NORMAL
- en: You start by importing the load_dictionary module you created in [Chapter 2](ch02.xhtml#ch02)
    ➊. This module will open a dictionary text file and, with its load() function,
    load all the words into a list ➋. The **.txt* file you use may be different, depending
    on which dictionary file you downloaded (see “[Finding and Opening a Dictionary](ch02.xhtml#lev33)”
    on [page 20](ch02.xhtml#page_20)).
  prefs: []
  type: TYPE_NORMAL
- en: Next, create an empty list, called anagram_list, to hold any anagrams you find
    ➌. Have the user add a *single* word, such as their first name ➍. This doesn’t
    have to be a proper name, but we’ll refer to it as name in the code to distinguish
    it from a dictionary word. Print this name so the user can see what was entered.
  prefs: []
  type: TYPE_NORMAL
- en: The next line anticipates a problematic user action. People tend to type their
    name with an uppercase first letter, but dictionary files may not include uppercase
    letters, and that matters to Python. So, first convert all letters to lowercase
    with the .lower() string method ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Now sort the name ➏. As mentioned previously, you can pass sorted() a string
    as well as a list.
  prefs: []
  type: TYPE_NORMAL
- en: With the input sorted alphabetically in a list, it’s time to find anagrams.
    Start a loop through each word in the dictionary word list ➐. To be safe, convert
    the word to lowercase, as comparison operations are case-sensitive. After the
    conversion, compare the word to the unsorted name, because a word can’t be an
    anagram of itself. Next, sort the dictionary word and compare it to the sorted
    name. If it passes, append that dictionary word to anagram_list.
  prefs: []
  type: TYPE_NORMAL
- en: Now display the results. First, check whether the anagram list is empty. If
    it is, print a whimsical reply so you don’t just leave the user hanging ➑. If
    the program found at least one anagram, print the list using the splat (*) operator.
    Remember from [Chapter 2](ch02.xhtml#ch02) that splat lets you print each member
    of a list on a separate line ➒.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is example output for this program, using the input name *Foster*:'
  prefs: []
  type: TYPE_NORMAL
- en: Input name = Foster
  prefs: []
  type: TYPE_NORMAL
- en: Using name = foster
  prefs: []
  type: TYPE_NORMAL
- en: Anagrams =
  prefs: []
  type: TYPE_NORMAL
- en: forest
  prefs: []
  type: TYPE_NORMAL
- en: fortes
  prefs: []
  type: TYPE_NORMAL
- en: softer
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to use another input, change the value of the name variable in
    the source code. As an exercise, try to adjust the code so that the user is prompted
    to input the name (or word); you can do this with the input() function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #5: Finding Phrase Anagrams**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous project, you took a single name or word and rearranged all the
    letters to find single-word anagrams. Now you will derive multiple words from
    a name. The words in these *phrase anagrams* form only part of the input name,
    and you will need several words to exhaust the available letters.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that lets a user interactively build an anagram phrase
    from the letters in their name.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Strategy and Pseudocode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The very best phrase anagrams are those that describe some well-known characteristic
    or action associated with the name bearer. For example, the letters in Clint Eastwood
    can be rearranged to form *old west action*, Alec Guinness yields *genuine class*,
    Madam Curie produces *radium came*, George Bush gives *he bugs Gore*, and Statue
    of Liberty contains *built to stay free*. My own name yields *a huge navel*, which
    is not really one of my characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you may see a strategic challenge ahead: how does a computer
    handle contextual content? The folks at IBM who invented Watson seem to know,
    but for the rest of us, that boulder is a little hard to lift.'
  prefs: []
  type: TYPE_NORMAL
- en: The *brute-force method* is a common approach used in online anagram generators.
    These algorithms take a name and return lots of random anagram phrases (generally,
    100s to 10,000+). Most of the returned phrases are nonsense, and scrolling through
    hundreds of these can be a chore.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to acknowledge that humans are best at contextual
    issues and write a program that helps the human work through the problem. The
    computer can take the initial name and provide words that can be made from some
    (or all) the letters in it; the user can then choose a word that “makes sense.”
    The program will then recalculate the word choices from the remaining letters
    in the name, repeating the process until every letter is used or the possible
    word choices are exhausted. This design plays to the strengths of both participants.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need a simple interface that prompts the user to input the initial name,
    displays potential word choices, and displays any remaining letters. The program
    will also need to keep track of the growing anagram phrase and let the user know
    when every letter has been used. There will likely be lots of failed attempts,
    so the interface should allow the user to restart the process at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Since anagrams have the same number of the same letters, another way to identify
    them is to count individual letters. If you think of your name as a collection
    of letters, then a word can be built from your name if (1) all its letters occur
    in your name and (2) they occur *at the same frequency or less*. Obviously, if
    *e* occurs three times in a word and twice in your name, the word can’t be derived
    from your name. So, if the collection of letters that make up a word is not a
    subset of the collection of letters in your name, then that word cannot be part
    of your name anagram.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Counter to Tally Letters**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Fortunately for us, Python ships with a module named collections that includes
    several container data types. One of these types, Counter, counts the occurrences
    of an item. Python stores the items as dictionary keys and the counts as dictionary
    values. For example, the following code snippet counts how many of each bonsai
    tree type is in a list.
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from collections import Counter'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ >>> my_bonsai_trees = ['maple', 'oak', 'elm', 'maple', 'elm', 'elm', 'elm',
    'elm']
  prefs: []
  type: TYPE_NORMAL
- en: ➋ >>> count = Counter(my_bonsai_trees)
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(count)'
  prefs: []
  type: TYPE_NORMAL
- en: '➌ Counter({''elm'': 5, ''maple'': 2, ''oak'': 1})'
  prefs: []
  type: TYPE_NORMAL
- en: The my_bonsai_trees list contains multiples of the same type of tree ➊. Counter
    tallies up the trees ➋ and creates an easy-to-reference dictionary ➌. Note that
    the print() function is optional and is used here for clarity. Entering count,
    alone, will also display the dictionary contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use Counter, instead of the sorted() method, to find single-word anagrams.
    Rather than two sorted lists, the output will be two dictionaries, which can also
    be directly compared with ==. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> name = ''foster'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word = ''forest'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> name_count = Counter(name)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(name_count)'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ Counter({''f'': 1, ''t'': 1, ''e'': 1, ''o'': 1, ''r'': 1, ''s'': 1})'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word_count = Counter(word)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(word_count)'
  prefs: []
  type: TYPE_NORMAL
- en: '➋ Counter({''f'': 1, ''t'': 1, ''o'': 1, ''e'': 1, ''r'': 1, ''s'': 1})'
  prefs: []
  type: TYPE_NORMAL
- en: 'Counter produces a dictionary for each word that maps each letter in the word
    to the number of times it occurs ➊➋. The dictionaries are unsorted, but despite
    the lack of sorting, Python correctly identifies each dictionary as being equal
    if the dictionaries contain the same letters and the same counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if word_count == name_count:'
  prefs: []
  type: TYPE_NORMAL
- en: print("It's a match!")
  prefs: []
  type: TYPE_NORMAL
- en: It's a match!
  prefs: []
  type: TYPE_NORMAL
- en: A Counter gives you a wonderful way to find words that “fit” in a name. If the
    count for each letter in a word is less than or equal to the count for the same
    letter in the name, then the word can be derived from the name!
  prefs: []
  type: TYPE_NORMAL
- en: '**The Pseudocode**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We’ve now made two important design decisions: (1) let the user interactively
    build their anagram one word at a time and (2) use the Counter method to find
    anagrams. This is enough to start thinking about high-level pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: Load a dictionary file
  prefs: []
  type: TYPE_NORMAL
- en: Accept a name from user
  prefs: []
  type: TYPE_NORMAL
- en: Set limit = length of name
  prefs: []
  type: TYPE_NORMAL
- en: Start empty list to hold anagram phrase
  prefs: []
  type: TYPE_NORMAL
- en: 'While length of phrase < limit:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate list of dictionary words that fit in name
  prefs: []
  type: TYPE_NORMAL
- en: Present words to user
  prefs: []
  type: TYPE_NORMAL
- en: Present remaining letters to user
  prefs: []
  type: TYPE_NORMAL
- en: Present current phrase to user
  prefs: []
  type: TYPE_NORMAL
- en: Ask user to input word or start over
  prefs: []
  type: TYPE_NORMAL
- en: 'If user input can be made from remaining letters:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept choice of new word or words from user
  prefs: []
  type: TYPE_NORMAL
- en: Remove letters in choice from letters in name
  prefs: []
  type: TYPE_NORMAL
- en: Return choice and remaining letters in name
  prefs: []
  type: TYPE_NORMAL
- en: 'If choice is not a valid selection:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask user for new choice or let user start over
  prefs: []
  type: TYPE_NORMAL
- en: Add choice to phrase and show to user
  prefs: []
  type: TYPE_NORMAL
- en: Generate new list of words and repeat process
  prefs: []
  type: TYPE_NORMAL
- en: 'When phrase length equals limit value:'
  prefs: []
  type: TYPE_NORMAL
- en: Display final phrase
  prefs: []
  type: TYPE_NORMAL
- en: Ask user to start over or to exit
  prefs: []
  type: TYPE_NORMAL
- en: '**Divvying Up the Work**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As procedural code becomes more complex, it becomes necessary to encapsulate
    much of it in functions. This makes it easier to manage input and output, perform
    recursion, and read the code.
  prefs: []
  type: TYPE_NORMAL
- en: A *main function* is where a program starts its execution, and enables high-level
    organization, such as managing all the bits and pieces of the code, including
    dealing with the user. In the phrase anagram program, the main function will wrap
    all the “worker bee” functions, take *most* of the user input, keep track of the
    growing anagram phrase, determine when the phrase is complete, and show the user
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketching out the tasks and their flow with pencil and paper is a great way
    to figure out what you want to do and where (like “graphical pseudocode”). [Figure
    3-1](ch03.xhtml#ch03fig1) is a flowchart with function assignments highlighted.
    In this case, three functions should be sufficient: main(), find_anagrams(), and
    process_choice().'
  prefs: []
  type: TYPE_NORMAL
- en: The main() function’s primary task is to set the letter count limit and manage
    the while loop responsible for the general phrase anagram build. The find_anagrams()
    function will take the current collection of letters remaining in a name and return
    all possible words that can be made from those letters. The words are then displayed
    for the user, along with the current phrase, which is “owned” and displayed by
    the main() function. Then, the process_choice() function prompts the user to start
    over or choose a word for the anagram phrase. If the user makes a choice, this
    function determines whether the letters in the choice are available. If they aren’t,
    the user is prompted to choose again or start over. If the user makes a valid
    choice, the letters in the user’s choice are removed from the list of remaining
    letters, and both the choice and list of leftovers are returned. The main() function
    adds the returned choice to the existing phrase. If the limit is reached, the
    completed phrase anagram is displayed, and the user is asked to start over or
    exit.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you ask for the initial name in the *global* scope, rather than in
    the main() function. This allows the user to start over fresh at any time without
    having to re-enter their name. For now, if the user wants to choose a brand-new
    name, they’ll have to exit the program and start over. In [Chapter 9](ch09.xhtml#ch09),
    you’ll use a menu system that lets users completely reset what they’re doing without
    exiting.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0043-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Flowchart for finding phrase anagrams with function assignments
    highlighted*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Anagram Phrase Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The code in this section takes a name from a user and helps them build an anagram
    phrase of that name. You can download the entire script from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *phrase_anagrams.py*. You’ll also need to download the *load_dictionary.py*
    program. Save both files in the same folder. You can use the same dictionary file
    you used in “[Project #4: Finding Single-Word Anagrams](ch03.xhtml#lev50)” on
    [page 36](ch03.xhtml#page_36).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Up and Finding Anagrams**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-2](ch03.xhtml#ch03list2) imports the modules that *phrase_anagrams.py*
    uses, loads a dictionary file, asks the user for an input name, and defines the
    find_anagrams() function, which does most of the work related to finding anagrams.'
  prefs: []
  type: TYPE_NORMAL
- en: '*phrase_anagrams.py,* part 1'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import sys
  prefs: []
  type: TYPE_NORMAL
- en: from collections import Counter
  prefs: []
  type: TYPE_NORMAL
- en: import load_dictionary
  prefs: []
  type: TYPE_NORMAL
- en: ➋ dict_file = load_dictionary.load('2of4brif.txt')
  prefs: []
  type: TYPE_NORMAL
- en: '# ensure "a" & "I" (both lowercase) are included'
  prefs: []
  type: TYPE_NORMAL
- en: dict_file.append('a')
  prefs: []
  type: TYPE_NORMAL
- en: dict_file.append('i')
  prefs: []
  type: TYPE_NORMAL
- en: dict_file = sorted(dict_file)
  prefs: []
  type: TYPE_NORMAL
- en: '➌ ini_name = input("Enter a name: ")'
  prefs: []
  type: TYPE_NORMAL
- en: '➍ def find_anagrams(name, word_list):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Read name & dictionary file & display all anagrams IN name."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➎ name_letter_map = Counter(name)
  prefs: []
  type: TYPE_NORMAL
- en: anagrams = []
  prefs: []
  type: TYPE_NORMAL
- en: '➏ for word in word_list:'
  prefs: []
  type: TYPE_NORMAL
- en: ➐ test = ''
  prefs: []
  type: TYPE_NORMAL
- en: ➑ word_letter_map = Counter(word.lower())
  prefs: []
  type: TYPE_NORMAL
- en: '➒ for letter in word:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if word_letter_map[letter] <= name_letter_map[letter]:'
  prefs: []
  type: TYPE_NORMAL
- en: test += letter
  prefs: []
  type: TYPE_NORMAL
- en: 'if Counter(test) == word_letter_map:'
  prefs: []
  type: TYPE_NORMAL
- en: anagrams.append(word)
  prefs: []
  type: TYPE_NORMAL
- en: ➓ print(*anagrams, sep='\n')
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: print("Remaining letters = {}".format(name))
  prefs: []
  type: TYPE_NORMAL
- en: print("Number of remaining letters = {}".format(len(name)))
  prefs: []
  type: TYPE_NORMAL
- en: print("Number of remaining (real word) anagrams = {}".format(len(anagrams)))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-2: Imports modules, loads dictionary, and defines the* find_anagrams()
    *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the import statements ➊, using the recommended order of Python Standard
    Library, third-party modules, and then locally developed modules. You need sys
    for coloring specific outputs red in the IDLE window and for letting the user
    exit the program with a keystroke. You’ll use Counter to help identify anagrams
    of the input name.
  prefs: []
  type: TYPE_NORMAL
- en: Next load the dictionary file using the imported module ➋. The filename argument
    should be the filename of the dictionary you’re using. Because some dictionary
    files omit *a* and *I*, append these (if needed), and sort the list so that they
    can be found at the proper alphabetical locations, rather than at the end of the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Now get a name from the user and assign it to the variable ini_name (or “initial
    name”) ➌. You’ll derive a name variable from this initial name, and name will
    be progressively changed as the user builds up the name anagram. Preserving the
    initial name as a separate variable will let you reset everything if the user
    wants to start over or try again.
  prefs: []
  type: TYPE_NORMAL
- en: The next block of code is find_anagrams() ➍, the function for finding anagrams
    in the name. The parameters for this function consist of a name and a word list.
    The function starts by using Counter to count the number of times a given letter
    appears in the name and then assigns the count to the variable name_letter_map
    ➎; Counter uses a dictionary structure with the letter as the key and the count
    as the value. The function then creates an empty list to hold the anagrams and
    starts a for loop through each word in the dictionary file ➏.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop starts by creating an empty string called test ➐. Use this variable
    to accumulate all the letters in the word that “fit” in name. Then make a Counter
    for the current word, as you did for name, and call it word_letter_map ➑. Loop
    through the letters in word ➒, checking that the count of each letter is the same
    as, or less than, the count in name. If the letter meets this condition, then
    it is added to the test string. Since some letters might get rejected, end the
    loop by running Counter on test and comparing it to word_letter_map. If they match,
    append the word to the anagrams list.
  prefs: []
  type: TYPE_NORMAL
- en: The function ends by displaying the list of words, using the splat operator
    with print, along with some statistics for the user ➓. Note that find_anagrams()
    doesn’t return anything. This is where the human interaction part comes in. The
    program will continue to run, but nothing will happen until the user chooses a
    word from the displayed list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing the User’s Choice**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-3](ch03.xhtml#ch03list3) defines process_choice(), the function
    in *phrase_anagrams.py* that takes the user’s choice of word (or words), checks
    it against the remaining letters in the name variable, and returns acceptable
    choices—along with any leftover letters—to the main() function. Like main(), this
    function gets to talk directly to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: '*phrase_anagrams.py,* part 2'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def process_choice(name):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Check user choice for validity, return choice & leftover letters."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: '➋ choice = input(''\nMake a choice else Enter to start over or # to end: '')'
  prefs: []
  type: TYPE_NORMAL
- en: 'if choice == '''':'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif choice == ''#'':'
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ candidate = ''.join(choice.lower().split())
  prefs: []
  type: TYPE_NORMAL
- en: ➍ left_over_list = list(name)
  prefs: []
  type: TYPE_NORMAL
- en: '➎ for letter in candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if letter in left_over_list:'
  prefs: []
  type: TYPE_NORMAL
- en: left_over_list.remove(letter)
  prefs: []
  type: TYPE_NORMAL
- en: '➏ if len(name) - len(left_over_list) == len(candidate):'
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Won't work! Make another choice!", file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: ➐ name = ''.join(left_over_list)  # makes display more readable
  prefs: []
  type: TYPE_NORMAL
- en: ➑ return choice, name
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-3: Defines the* process_choice() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining the function with one parameter called name ➊. The first time
    the program is run, this parameter will be the same as the ini_name variable—the
    full name entered by the user when the program starts up. After the user has chosen
    a word (or words) to use in the anagram phrase, it will represent the remaining
    letters in the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the function with a while loop that will run until the user makes a valid
    choice and then get input from the user ➋. The user has a choice of entering one
    or more words from the current anagram list, pressing ENTER to start over, or
    pressing # to quit. Use #, rather than a word or letter, so that it can’t be confused
    for a valid choice.'
  prefs: []
  type: TYPE_NORMAL
- en: If the user makes a choice, the string is assigned to the variable candidate,
    stripped of whitespace, and converted to all lowercase ➌. This is so it can be
    directly compared to the name variable. After that, a list is built from the name
    variable to hold any remaining letters ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Now begin a loop to subtract the letters used in candidate ➎. If a chosen letter
    is present in the list, it’s removed.
  prefs: []
  type: TYPE_NORMAL
- en: If the user entered a word that isn’t in the displayed list, or entered multiple
    words, a letter may not be present in the list. To check for this, subtract the
    leftover letters from name and, if the result is the number of letters in candidate,
    determine that the input is valid and break out of the while loop ➏. Otherwise,
    display a warning and color it red for those using the IDLE window. The while
    loop will keep prompting the user until an acceptable choice is made.
  prefs: []
  type: TYPE_NORMAL
- en: If all the letters in the user’s choice pass the test, the list of leftovers
    is converted back into a string and used to update the name variable ➐. Converting
    the list into a string isn’t strictly necessary, but it keeps the name variable
    type consistent and lets you display the remaining letters in a clearly readable
    format without the need for additional print arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Finish by returning both the user’s choice and the string of remaining letters
    (name) to the main() function ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-4](ch03.xhtml#ch03list4) defines the main() function in *phrase_anagrams.py*.
    This function wraps the previous functions, runs a while loop, and determines
    when the user has successfully created an anagram phrase.'
  prefs: []
  type: TYPE_NORMAL
- en: '*phrase_anagrams.py,* part 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Help user build anagram phrase from their name."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ name = ''.join(ini_name.lower().split())
  prefs: []
  type: TYPE_NORMAL
- en: name = name.replace('-', '')
  prefs: []
  type: TYPE_NORMAL
- en: ➋ limit = len(name)
  prefs: []
  type: TYPE_NORMAL
- en: phrase = ''
  prefs: []
  type: TYPE_NORMAL
- en: running = True
  prefs: []
  type: TYPE_NORMAL
- en: '➌ while running:'
  prefs: []
  type: TYPE_NORMAL
- en: ➍ temp_phrase = phrase.replace(' ', '')
  prefs: []
  type: TYPE_NORMAL
- en: '➎ if len(temp_phrase) < limit:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Length of anagram phrase = {}".format(len(temp_phrase)))
  prefs: []
  type: TYPE_NORMAL
- en: ➏ find_anagrams(name, dict_file)
  prefs: []
  type: TYPE_NORMAL
- en: print("Current anagram phrase =", end=" ")
  prefs: []
  type: TYPE_NORMAL
- en: print(phrase, file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: ➐ choice, name = process_choice(name)
  prefs: []
  type: TYPE_NORMAL
- en: phrase += choice + ' '
  prefs: []
  type: TYPE_NORMAL
- en: '➑ elif len(temp_phrase) == limit:'
  prefs: []
  type: TYPE_NORMAL
- en: print("\n*****FINISHED!!!*****\n")
  prefs: []
  type: TYPE_NORMAL
- en: print("Anagram of name =", end=" ")
  prefs: []
  type: TYPE_NORMAL
- en: print(phrase, file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: ➒ try_again = input('\n\nTry again? (Press Enter else "n" to quit)\n ')
  prefs: []
  type: TYPE_NORMAL
- en: 'if try_again.lower() == "n":'
  prefs: []
  type: TYPE_NORMAL
- en: running = False
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: '➓ if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-4: Defines and calls* main() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: The first order of business is to turn the ini_name variable into a continuous
    string of lowercase characters with no whitespace ➊. Remember, case matters to
    Python, so convert all strings to lowercase wherever they occur; that way, comparisons
    will work as intended. Python also recognizes spaces as characters, so you need
    to remove these, as well as hyphens in hyphenated names, before doing any letter
    counts. By declaring this new name variable, you preserve the initial name in
    case the user wants to start over. Only name will be altered in the process_choice()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, get the length of the name ➋ to use as a limit in the while loop. This
    will let you know when the anagram phrase has used all the letters in the name
    and it’s time to end the loop. Do this outside the while loop to ensure you are
    using the full initial name. Then assign a variable to hold the anagram phrase
    and set a running variable to True to control the while loop.
  prefs: []
  type: TYPE_NORMAL
- en: Now begins the big loop that lets you iterate over the name and build an anagram
    phrase ➌. First, prepare a string to hold the growing phrase and strip it of whitespace
    ➍. Spaces will count as letters and throw off the operator when the length of
    the phrase is compared to the limit variable. Next, make the comparison, and if
    the length of the phrase is less than the limit, display the current length of
    the phrase as a prelude to engaging with the user ➎.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to put the other functions to work. Call find_anagrams() ➏ and pass
    it the name and dictionary file to get the list of anagrams in the name. At the
    bottom of the displayed list, show the user the current phrase. Use the print()
    function’s end parameter to display two print statements on the same line. This
    way, you can use a red font on the phrase in the IDLE window to distinguish it
    from all the other information in the display.
  prefs: []
  type: TYPE_NORMAL
- en: Next, call the process_choice() function ➐ to get the user’s word choice and
    add it to the growing anagram phrase. This also gets the updated version of the
    name variable so that the program can use it again in the while loop in the event
    that the phrase isn’t complete.
  prefs: []
  type: TYPE_NORMAL
- en: If the length of the phrase is equal to the limit variable ➑, the name anagram
    is complete. Let the user know they’re finished and present the phrase using red
    font. Note that you don’t have a conditional for the length of the phrase being
    greater than the limit variable. That’s because the process_choice() function
    is already handling this outcome (choosing more letters than are available would
    not pass the validation criterion).
  prefs: []
  type: TYPE_NORMAL
- en: The main() function ends by asking the user whether they want to try again.
    If they type n, the program ends; if they press ENTER, the main() function is
    called again ➒. As stated earlier, the only way for the user to change the initial
    name is to exit and relaunch the program.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of the main() function, end with the standard two lines for calling
    the main() function when the program is not imported as a module ➓.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running an Example Session**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this section, I’ve included an example interactive session, using *phrase_anagrams.py*
    and the name *Bill Bo*. Bold font indicates user input, and italic bold font indicates
    where red font is used in the display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a name: Bill Bo'
  prefs: []
  type: TYPE_NORMAL
- en: Length of anagram phrase = 0
  prefs: []
  type: TYPE_NORMAL
- en: bib
  prefs: []
  type: TYPE_NORMAL
- en: bill
  prefs: []
  type: TYPE_NORMAL
- en: blob
  prefs: []
  type: TYPE_NORMAL
- en: bob
  prefs: []
  type: TYPE_NORMAL
- en: boil
  prefs: []
  type: TYPE_NORMAL
- en: boll
  prefs: []
  type: TYPE_NORMAL
- en: i
  prefs: []
  type: TYPE_NORMAL
- en: ill
  prefs: []
  type: TYPE_NORMAL
- en: lib
  prefs: []
  type: TYPE_NORMAL
- en: lilo
  prefs: []
  type: TYPE_NORMAL
- en: lo
  prefs: []
  type: TYPE_NORMAL
- en: lob
  prefs: []
  type: TYPE_NORMAL
- en: oi
  prefs: []
  type: TYPE_NORMAL
- en: oil
  prefs: []
  type: TYPE_NORMAL
- en: Remaining letters = billbo
  prefs: []
  type: TYPE_NORMAL
- en: Number of remaining letters = 6
  prefs: []
  type: TYPE_NORMAL
- en: Number of remaining (real word) anagrams = 14
  prefs: []
  type: TYPE_NORMAL
- en: Current anagram phrase =
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a choice else Enter to start over or # to end: ill'
  prefs: []
  type: TYPE_NORMAL
- en: Length of anagram phrase = 3
  prefs: []
  type: TYPE_NORMAL
- en: bob
  prefs: []
  type: TYPE_NORMAL
- en: Remaining letters = bbo
  prefs: []
  type: TYPE_NORMAL
- en: Number of remaining letters = 3
  prefs: []
  type: TYPE_NORMAL
- en: Number of remaining (real word) anagrams = 1
  prefs: []
  type: TYPE_NORMAL
- en: Current anagram phrase = ill
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a choice else Enter to start over or # to end: Bob'
  prefs: []
  type: TYPE_NORMAL
- en: '***** FINISHED!!! *****'
  prefs: []
  type: TYPE_NORMAL
- en: Anagram of name = ill Bob
  prefs: []
  type: TYPE_NORMAL
- en: Try again? (Press Enter else "n" to quit)
  prefs: []
  type: TYPE_NORMAL
- en: The number of anagrams found depends on the dictionary file you use. If you’re
    having a hard time building anagram phrases, try using a larger dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #6: Finding Voldemort: The Gallic Gambit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Did you ever wonder how Tom Riddle came up with the anagram “I am Lord Voldemort”?
    Did he put quill to parchment or just wave a wand? Could the magic of Python have
    helped?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s pretend for a moment that you’re the professor of computer wizardry at
    Hogwarts, and Tom Riddle, school prefect and model student, has come to you for
    help. Using your *phrase_anagrams.py* spell from the previous section, he could
    find *I am Lord* in the very first list of anagrams, much to his delight. But
    the remaining letters, *tmvoordle*, yield only trivial words like *dolt*, *drool*,
    *looter*, and *lover*. Riddle would not be pleased.
  prefs: []
  type: TYPE_NORMAL
- en: 'In hindsight, the problem is apparent: *Voldemort* is French and won’t be found
    in any English dictionary file. *Vol de la mort* means “flight of death” in French,
    so Voldemort is loosely “death flight.” But Riddle is 100 percent English, and
    so far, you have been working with English. Without reverse engineering, you have
    no more reason to suddenly switch out your English dictionary for a French one
    than you have to use Dutch, German, Italian, or Spanish.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You *could* try randomly shuffling the remaining letters and seeing what falls
    out. Unfortunately, the number of possible combinations is the factorial of the
    number of letters divided by the factorial of the number of repeats (*o* occurs
    twice): 9! / 2! = 181,440\. If you were to scroll through all those permutations,
    taking only one second to review each, it would take you over two days to complete
    the list! And if you asked Tom Riddle to do this, he would probably use you to
    make a horcrux!'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I would like to explore two logical paths ahead. One I call the
    “Gallic Gambit” and the other the “British Brute-Force.” We’ll look at the first
    one here and the second one in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: Marvolo *is clearly a* fabricated word *used to make the Voldemort anagram work.
    J.K. Rowling could have gained additional latitude by using* Thomas *for* Tom
    *or by leaving off the* Lord *or* I am *parts. Tricks like these are used when
    the book is translated into non-English languages. In some languages, one or both
    names may need to be changed. In French, the anagram is “I am Voldemort.” In Norwegian,
    “Voldemort the Great.” In Dutch, “My name is Voldemort.” In others, like Chinese,
    the anagram can’t be used at all!*
  prefs: []
  type: TYPE_NORMAL
- en: 'Tom Riddle was obsessed with beating death, and if you go looking for death
    in *tmvoordle*, you will find both the old French *morte* (as in the famous book
    *Le Morte d’Arthur* by Sir Thomas Malory) and the modern French *mort*. Removing
    *mort* leaves *vodle*, five letters with a very manageable number of permutations.
    In fact, you can easily find *volde* right in the interpreter window:'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ >>> from itertools import permutations
  prefs: []
  type: TYPE_NORMAL
- en: '>>> name = ''vodle'''
  prefs: []
  type: TYPE_NORMAL
- en: ➋ >>> perms = [''.join(i) for i in permutations(name)]
  prefs: []
  type: TYPE_NORMAL
- en: ➌ >>> print(len(perms))
  prefs: []
  type: TYPE_NORMAL
- en: '120'
  prefs: []
  type: TYPE_NORMAL
- en: ➍ >>> print(perms)
  prefs: []
  type: TYPE_NORMAL
- en: '[''vodle'', ''vodel'', ''volde'', ''voled'', ''voedl'', ''voeld'', ''vdole'',
    ''vdoel'','
  prefs: []
  type: TYPE_NORMAL
- en: '''vdloe'', ''vdleo'', ''vdeol'', ''vdelo'', ''vlode'', ''vloed'', ''vldoe'',
    ''vldeo'','
  prefs: []
  type: TYPE_NORMAL
- en: '''vleod'', ''vledo'', ''veodl'', ''veold'', ''vedol'', ''vedlo'', ''velod'',
    ''veldo'','
  prefs: []
  type: TYPE_NORMAL
- en: '''ovdle'', ''ovdel'', ''ovlde'', ''ovled'', ''ovedl'', ''oveld'', ''odvle'',
    ''odvel'','
  prefs: []
  type: TYPE_NORMAL
- en: '''odlve'', ''odlev'', ''odevl'', ''odelv'', ''olvde'', ''olved'', ''oldve'',
    ''oldev'','
  prefs: []
  type: TYPE_NORMAL
- en: '''olevd'', ''oledv'', ''oevdl'', ''oevld'', ''oedvl'', ''oedlv'', ''oelvd'',
    ''oeldv'','
  prefs: []
  type: TYPE_NORMAL
- en: '''dvole'', ''dvoel'', ''dvloe'', ''dvleo'', ''dveol'', ''dvelo'', ''dovle'',
    ''dovel'','
  prefs: []
  type: TYPE_NORMAL
- en: '''dolve'', ''dolev'', ''doevl'', ''doelv'', ''dlvoe'', ''dlveo'', ''dlove'',
    ''dloev'','
  prefs: []
  type: TYPE_NORMAL
- en: '''dlevo'', ''dleov'', ''devol'', ''devlo'', ''deovl'', ''deolv'', ''delvo'',
    ''delov'','
  prefs: []
  type: TYPE_NORMAL
- en: '''lvode'', ''lvoed'', ''lvdoe'', ''lvdeo'', ''lveod'', ''lvedo'', ''lovde'',
    ''loved'','
  prefs: []
  type: TYPE_NORMAL
- en: '''lodve'', ''lodev'', ''loevd'', ''loedv'', ''ldvoe'', ''ldveo'', ''ldove'',
    ''ldoev'','
  prefs: []
  type: TYPE_NORMAL
- en: '''ldevo'', ''ldeov'', ''levod'', ''levdo'', ''leovd'', ''leodv'', ''ledvo'',
    ''ledov'','
  prefs: []
  type: TYPE_NORMAL
- en: '''evodl'', ''evold'', ''evdol'', ''evdlo'', ''evlod'', ''evldo'', ''eovdl'',
    ''eovld'','
  prefs: []
  type: TYPE_NORMAL
- en: '''eodvl'', ''eodlv'', ''eolvd'', ''eoldv'', ''edvol'', ''edvlo'', ''edovl'',
    ''edolv'','
  prefs: []
  type: TYPE_NORMAL
- en: '''edlvo'', ''edlov'', ''elvod'', ''elvdo'', ''elovd'', ''elodv'', ''eldvo'',
    ''eldov'']'
  prefs: []
  type: TYPE_NORMAL
- en: '>>>'
  prefs: []
  type: TYPE_NORMAL
- en: ➎ >>> print(*perms, sep='\n')
  prefs: []
  type: TYPE_NORMAL
- en: vodle
  prefs: []
  type: TYPE_NORMAL
- en: vodel
  prefs: []
  type: TYPE_NORMAL
- en: volde
  prefs: []
  type: TYPE_NORMAL
- en: voled
  prefs: []
  type: TYPE_NORMAL
- en: voedl
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing permutations from itertools ➊. The itertools module is a
    group of functions in the Python Standard Library that create iterators for efficient
    looping. You generally think of permutations of *numbers*, but the itertools version
    works on *elements* in an iterable, which includes letters.
  prefs: []
  type: TYPE_NORMAL
- en: After entering the name or, in this case, the remaining letters in the name,
    use list comprehension to create a list of permutations of the name ➋. Join each
    element in a permutation so each item in the final list will be a unique permutation
    of *vodle*. Using join yields the new name as an element, 'vodle', versus a hard-to-read
    tuple of single-character elements,('v', 'o', 'd', 'l', 'e').
  prefs: []
  type: TYPE_NORMAL
- en: Get the length of the permutations as a check; that way, you can confirm that
    it is, indeed, the factorial of 5 ➌. At the end, no matter how you print it ➍➎,
    *volde* is easy to find.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #7: Finding Voldemort: The British Brute-Force**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s assume Tom Riddle is bad at anagrams (or French). He doesn’t recognize
    *mort* or *morte*, and you’re back to shuffling the remaining nine letters thousands
    and thousands of times, looking for a combination of letters that he would find
    pleasing.
  prefs: []
  type: TYPE_NORMAL
- en: On the bright side, this is a more interesting problem programmatically than
    the interactive solution you just saw. You just need to whittle down all the permutations
    using some form of filtering.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  prefs: []
  type: TYPE_NORMAL
- en: Reduce the number of anagrams of *tmvoordle* to a manageable number that will
    still contain *Voldemort*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Strategy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Per the *Oxford English Dictionary, 2nd Edition*, there are 171,476 English
    words currently in use, which is fewer than the total number of permutations in
    *tmvoordle*! Regardless of the language, you can surmise that most of the anagrams
    generated by the permutations() function are nonsense.
  prefs: []
  type: TYPE_NORMAL
- en: 'With *cryptography*, the science of codes and ciphers, you can safely eliminate
    many useless, unpronounceable combinations, such as *ldtmvroeo*, and you won’t
    even have to inspect them visually. Cryptographers have long studied languages
    and compiled statistics on recurring patterns of words and letters. We can use
    many cryptanalytical techniques for this project, but let’s focus on three: consonant-vowel
    mapping, trigram frequency, and digram frequency.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering with Consonant-Vowel Mapping**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *consonant-vowel map* (*c-v map*) simply replaces the letters in a word with
    a *c* or a *v*, as appropriate. *Riddle*, for example, becomes *cvcccv*. You can
    write a program that goes through a dictionary file and creates c-v maps for each
    word. By default, impossible combinations, like *ccccccvvv*, will be excluded.
    You can further exclude membership by removing words with c-v maps that are *possible*
    but that have a low frequency of occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: C-v maps are fairly inclusive, but that’s good. An option for *Riddle* at this
    point is to make up a new proper name, and proper names don’t have to be words
    that occur in a dictionary. So you don’t want to be *too* exclusive early in the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering with Trigrams**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since the initial filter needs a relatively wide aperture, you’ll need to filter
    again at a lower level to safely remove more anagrams from the permutations. *Trigrams*
    are triplets comprising three consecutive letters. It should come as no surprise
    that the most common trigram in English is the word *the*, followed closely by
    *and* and *ing*. At the other end of the scale are trigrams like *zvq*.
  prefs: []
  type: TYPE_NORMAL
- en: You can find statistics on the frequency of occurrence of trigrams online at
    sites like *[http://norvig.com/ngrams/count_3l.txt](http://norvig.com/ngrams/count_3l.txt)*.
    For any group of letters, like *tmvoordle*, you can generate and use a list of
    the least common trigrams to further reduce the number of permutations. For this
    project, you can use the *least-likely_trigrams.txt* file, downloadable from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    This text file contains the trigrams in *tmvoordle* that occur in the bottom 10
    percent of trigrams in the English language, based on frequency of occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering with Digrams**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Digrams* (also called *bigrams*) are letter pairs. Commonly occurring digrams
    in English include *an*, *st*, and *er*. On the other hand, you rarely see pairs
    like *kg*, *vl*, or *oq*. You can find statistics on the frequency of occurrence
    of digrams at websites such as *[https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html](https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html)*
    and *[http://practicalcryptography.com/](http://practicalcryptography.com/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](ch03.xhtml#ch03tab1) was built from the *tmvoordle* collection
    of letters and a 60,000-word English dictionary file. The letters along the left
    side of the chart are the starting letters for the digrams; those along the top
    represent the end letter. For example, to find *vo*, start with the *v* on the
    left and read across to the column beneath the *o*. For the digrams found in *tmvoordle*,
    *vo* occurs only 0.8 percent of the time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Relative Frequency of Digrams from the Letters *tmvoordle* in
    a 60,000-Word Dictionary (Black Squares Indicate No Occurrences)'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **d** | **e** | **l** | **m** | **o** | **r** | **t** | **v** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **d** |  | 3.5% | 0.5% | 0.1% | 1.7% | 0.5% | 0.0% | 0.1% |'
  prefs: []
  type: TYPE_TB
- en: '| **e** | 6.6% |  | 2.3% | 1.4% | 0.7% | 8.9% | 2.0% | 0.6% |'
  prefs: []
  type: TYPE_TB
- en: '| **l** | 0.4% | 4.4% |  | 0.1% | 4.2% | 0.0% | 0.4% | 0.1% |'
  prefs: []
  type: TYPE_TB
- en: '| **m** | 0.0% | 2.2% | 0.0% |  | 2.8% | 0.0% | 0.0% | 0.0% |'
  prefs: []
  type: TYPE_TB
- en: '| **o** | 1.5% | 0.5% | 3.7% | 3.2% | 5.3% | 7.1% | 2.4% | 1.4% |'
  prefs: []
  type: TYPE_TB
- en: '| **r** | 0.9% | 6.0% | 0.4% | 0.7% | 5.7% |  | 1.3% | 0.3% |'
  prefs: []
  type: TYPE_TB
- en: '| **t** | 0.0% | 6.2% | 0.6% | 0.1% | 3.6% | 2.3% |  | 0.0% |'
  prefs: []
  type: TYPE_TB
- en: '| **v** | 0.0% | 2.5% | 0.0% | 0.0% | 0.8% | 0.0% | 0.0% |  |'
  prefs: []
  type: TYPE_TB
- en: Assuming you’re looking for “English-like” letter combinations, you can use
    frequency maps like this to exclude letter pairs that are unlikely to occur. Think
    of it as a “digram sieve” that lets only the unshaded squares pass.
  prefs: []
  type: TYPE_NORMAL
- en: To be safe, just exclude digrams that occur less than 0.1 percent of the time.
    I’ve shaded these in black. Notice that it would be very easy to eliminate the
    required *vo* pairing in *Voldemort*, if you cut too close to the bone!
  prefs: []
  type: TYPE_NORMAL
- en: You can design your filter to be even more selective by tagging digrams that
    are unlikely to occur at the start of a word. For example, while it’s not unusual
    for the digram *lm* to occur *within* a word (as in *almanac* and *balmy*), you’ll
    need a lot of luck finding a word that *starts* with *lm*. You don’t need cryptography
    to find these digrams; just try to pronounce them! Some starting-point choices
    for these are shaded gray in [Table 3-2](ch03.xhtml#ch03tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Update of [Table 3-1](ch03.xhtml#ch03tab1), Where Gray-Shaded
    Squares Indicate Digrams Unlikely to Occur at the Start of a Word'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **d** | **e** | **l** | **m** | **o** | **r** | **t** | **v** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **d** |  | 3.5% | 0.5% | 0.1% | 1.7% | 0.5% | 0.0% | 0.1% |'
  prefs: []
  type: TYPE_TB
- en: '| **e** | 6.6% |  | 2.3% | 1.4% | 0.7% | 8.9% | 2.0% | 0.6% |'
  prefs: []
  type: TYPE_TB
- en: '| **l** | 0.4% | 4.4% |  | 0.1% | 4.2% | 0.0% | 0.4% | 0.1% |'
  prefs: []
  type: TYPE_TB
- en: '| **m** | 0.0% | 2.2% | 0.0% |  | 2.8% | 0.0% | 0.0% | 0.0% |'
  prefs: []
  type: TYPE_TB
- en: '| **o** | 1.5% | 0.5% | 3.7% | 3.2% | 5.3% | 7.1% | 2.4% | 1.4% |'
  prefs: []
  type: TYPE_TB
- en: '| **r** | 0.9% | 6.0% | 0.4% | 0.7% | 5.7% |  | 1.3% | 0.3% |'
  prefs: []
  type: TYPE_TB
- en: '| **t** | 0.0% | 6.2% | 0.6% | 0.1% | 3.6% | 2.3% |  | 0.0% |'
  prefs: []
  type: TYPE_TB
- en: '| **v** | 0.0% | 2.5% | 0.0% | 0.0% | 0.8% | 0.0% | 0.0% |  |'
  prefs: []
  type: TYPE_TB
- en: 'You now have three filters you can use on the 181,440 permutations of *tmvoordle*:
    c-v maps, trigrams, and digrams. As a final filter, you should give the user the
    option of viewing only anagrams that start with a given letter. This will let
    the user divide the remaining anagrams into more manageable “chunks,” or focus
    on the more intimidating-sounding anagrams, like those that begin with *v*!'
  prefs: []
  type: TYPE_NORMAL
- en: '***The British Brute-Force Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The upcoming code generates permutations of *tmvoordle* and passes them through
    the filters just described. It then gives the user the option to view either all
    the permutations or only those starting with a given letter.
  prefs: []
  type: TYPE_NORMAL
- en: You can download all the programs you’ll need from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    The code in this section is one script named *voldemort_british.py*. You’ll also
    need the *load_dictionary.py* program in the same folder, along with the same
    dictionary file you used for the projects earlier in this chapter. Finally, you’ll
    need a new file named *least-likely_trigrams.txt*, a text file of trigrams with
    a low frequency of occurrence in English. Download all these files into the same
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-5](ch03.xhtml#ch03list5) imports the modules that *voldemort_british.py*
    needs and defines its main() function. In the *phrase_anagrams.py* program, you
    defined the main() function at the end of the code. Here we put it at the start.
    The advantage is that you can see what the function is doing—how it’s running
    the program—from the start. The disadvantage is that you don’t know what any of
    the helper functions do yet.'
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 1'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import sys
  prefs: []
  type: TYPE_NORMAL
- en: from itertools import permutations
  prefs: []
  type: TYPE_NORMAL
- en: from collections import Counter
  prefs: []
  type: TYPE_NORMAL
- en: import load_dictionary
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Load files, run filters, allow user to view anagrams by 1st letter."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ name = 'tmvoordle'
  prefs: []
  type: TYPE_NORMAL
- en: name = name.lower()
  prefs: []
  type: TYPE_NORMAL
- en: ➍ word_list_ini = load_dictionary.load('2of4brif.txt')
  prefs: []
  type: TYPE_NORMAL
- en: trigrams_filtered = load_dictionary.load('least-likely_trigrams.txt')
  prefs: []
  type: TYPE_NORMAL
- en: ➎ word_list = prep_words(name, word_list_ini)
  prefs: []
  type: TYPE_NORMAL
- en: filtered_cv_map = cv_map_words(word_list)
  prefs: []
  type: TYPE_NORMAL
- en: filter_1 = cv_map_filter(name, filtered_cv_map)
  prefs: []
  type: TYPE_NORMAL
- en: filter_2 = trigram_filter(filter_1, trigrams_filtered)
  prefs: []
  type: TYPE_NORMAL
- en: filter_3 = letter_pair_filter(filter_2)
  prefs: []
  type: TYPE_NORMAL
- en: view_by_letter(name, filter_3)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-5: Imports modules and defines the* main() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing modules you’ve used in the previous projects ➊. Now define
    the main() function ➋. The name variable is a string of the remaining letters
    *tmvoordle* ➌. Set it to lowercase to guard against a user input error. Next,
    use the load_dictionary module to load your dictionary file and the trigrams file
    as lists ➍. Your dictionary filename may be different from that shown.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, call all the various functions in order ➎. I’ll describe each of these
    functions momentarily, but basically, you need to prepare the word list, prepare
    the c-v maps, apply the three filters, and let the user view all the anagrams
    at once or view a subset based on the anagram’s first letter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparing the Word List**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-6](ch03.xhtml#ch03list6) prepares the word list by including just
    the words that have as many letters as in the name variable (in this case, nine).
    You should also ensure that all the words are lowercase, to be consistent.'
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 2'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def prep_words(name, word_list_ini):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Prep word list for finding anagrams."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ print("length initial word_list = {}".format(len(word_list_ini)))
  prefs: []
  type: TYPE_NORMAL
- en: len_name = len(name)
  prefs: []
  type: TYPE_NORMAL
- en: ➌ word_list = [word.lower() for word in word_list_ini
  prefs: []
  type: TYPE_NORMAL
- en: if len(word) == len_name]
  prefs: []
  type: TYPE_NORMAL
- en: ➍ print("length of new word_list = {}".format(len(word_list)))
  prefs: []
  type: TYPE_NORMAL
- en: ➎ return word_list
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-6: Creates lists of words that are equal in length to the* name
    *variable*'
  prefs: []
  type: TYPE_NORMAL
- en: Define the prep_words() function to take a name string and list of dictionary
    words as arguments ➊. I suggest that you print the lengths of your various word
    lists before and after they’ve gone through a filter; that way, you can track
    how much impact the filters are having. So print the length of the dictionary
    ➋. Assign a variable to hold the length of the name and then use list comprehension
    to create a new list by looping through the words in word_list_ini, keeping those
    whose length is the same as the number of letters in name, and converting them
    to lowercase ➌. Next, print the length of this new word list ➍, and finally, return
    this new list for use in the next function ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating the C-V Map**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You need to convert the prepared word list to a c-v map. Remember that you’re
    no longer interested in actual words in the dictionary; those have been reviewed
    and rejected. Your goal is to shuffle the remaining letters until they form something
    that resembles a proper noun.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-7](ch03.xhtml#ch03list7) defines a function that generates c-v maps
    for each word in word_list. The program, *voldemort_british.py*, will use the
    c-v map to judge whether a shuffled letter combination is reasonable based on
    consonant-vowel patterns in the English language.'
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 3'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def cv_map_words(word_list):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Map letters in words to consonants & vowels."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ vowels = 'aeiouy'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ cv_mapped_words = []
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for word in word_list:'
  prefs: []
  type: TYPE_NORMAL
- en: temp = ''
  prefs: []
  type: TYPE_NORMAL
- en: 'for letter in word:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if letter in vowels:'
  prefs: []
  type: TYPE_NORMAL
- en: temp += 'v'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: temp += 'c'
  prefs: []
  type: TYPE_NORMAL
- en: cv_mapped_words.append(temp)
  prefs: []
  type: TYPE_NORMAL
- en: '# determine number of UNIQUE c-v patterns'
  prefs: []
  type: TYPE_NORMAL
- en: ➎ total = len(set(cv_mapped_words))
  prefs: []
  type: TYPE_NORMAL
- en: '# target fraction to eliminate'
  prefs: []
  type: TYPE_NORMAL
- en: ➏ target = 0.05
  prefs: []
  type: TYPE_NORMAL
- en: '# get number of items in target fraction'
  prefs: []
  type: TYPE_NORMAL
- en: ➐ n = int(total * target)
  prefs: []
  type: TYPE_NORMAL
- en: ➑ count_pruned = Counter(cv_mapped_words).most_common(total - n)
  prefs: []
  type: TYPE_NORMAL
- en: ➒ filtered_cv_map = set()
  prefs: []
  type: TYPE_NORMAL
- en: 'for pattern, count in count_pruned:'
  prefs: []
  type: TYPE_NORMAL
- en: filtered_cv_map.add(pattern)
  prefs: []
  type: TYPE_NORMAL
- en: print("length filtered_cv_map = {}".format(len(filtered_cv_map)))
  prefs: []
  type: TYPE_NORMAL
- en: ➓ return filtered_cv_map
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-7: Generates c-v maps from the words in* word_list'
  prefs: []
  type: TYPE_NORMAL
- en: Define the cv_map_words() function to take the prepped word list as an argument
    ➊. Since consonants and vowels form a binary system, you can define the vowels
    with a string ➋. Create an empty list to hold the maps ➌. Then loop through the
    words and the letters in each word, converting the letters to either a *c* or
    *v* ➍. Use a variable called temp to accumulate the map; then append it to the
    list. Note that temp is reinitialized each time the loop repeats.
  prefs: []
  type: TYPE_NORMAL
- en: You want to know the frequency of occurrence of a given c-v map pattern (for
    example, *cvcv*), so you can remove those with a low likelihood of occurrence.
    Before calculating the frequency, you need to collapse your list down to unique
    c-v maps—as it is now, *cvcv* may be repeated many, many times. So, turn the cv_mapped_words
    list into a set, to remove duplicates, and get its length ➎. Now you can define
    a target percentage to eliminate, using fractional values ➏. Start with a low
    number like 0.05—equivalent to 5 percent—so you’re less likely to eliminate anagrams
    that can form usable proper names. Multiply this target value by the total length
    of the cv_mapped_words set and assign the result to the variable n ➐. Be sure
    to convert n to an integer; since it will represent a count value, it can’t be
    a float.
  prefs: []
  type: TYPE_NORMAL
- en: The Counter module data type has a handy method, most_common(), that will return
    the most common items in a list based on a *count* value that you provide; in
    this case, that value will be the length of the c-v map list, total, minus n.
    The value you pass most_common() must be an integer. If you pass the most_common()
    function the length of the list, it will return all the items in the list. If
    you subtract the count for the least likely 5 percent, you will effectively eliminate
    these c-v maps from the list ➑.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Counter returns a dictionary, but all you need are the final c-v maps,
    not their associated frequency counts. So initialize an empty set called filtered-cv-map
    ➒ and loop through each key-value pair in count_pruned(), adding only the key
    to the new set. Print the length of this set, so you can see the impact of the
    filter. Then finish by returning the filtered c-v map for use in the next function
    ➓.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the C-V Map Filter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-8](ch03.xhtml#ch03list8) applies the c-v map filter: anagrams are
    generated based on permutations of the letters in the name variable, and then
    the program converts them to c-v maps and compares those anagrams to the filtered
    c-v maps built with the cv_map_words() function. If an anagram’s c-v map is found
    in filtered_cv_map, then the program stores the anagram for the next filter.'
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 4'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def cv_map_filter(name, filtered_cv_map):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Remove permutations of words based on unlikely cons-vowel combos."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ perms = {''.join(i) for i in permutations(name)}
  prefs: []
  type: TYPE_NORMAL
- en: print("length of initial permutations set = {}".format(len(perms)))
  prefs: []
  type: TYPE_NORMAL
- en: vowels = 'aeiouy'
  prefs: []
  type: TYPE_NORMAL
- en: ➌ filter_1 = set()
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for candidate in perms:'
  prefs: []
  type: TYPE_NORMAL
- en: temp = ''
  prefs: []
  type: TYPE_NORMAL
- en: 'for letter in candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if letter in vowels:'
  prefs: []
  type: TYPE_NORMAL
- en: temp += 'v'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: temp += 'c'
  prefs: []
  type: TYPE_NORMAL
- en: '➎ if temp in filtered_cv_map:'
  prefs: []
  type: TYPE_NORMAL
- en: filter_1.add(candidate)
  prefs: []
  type: TYPE_NORMAL
- en: print("# choices after filter_1 = {}".format(len(filter_1)))
  prefs: []
  type: TYPE_NORMAL
- en: ➏ return filter_1
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-8: Defines* cv_map_filter() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the function cv_map_filter() to take two arguments: the name, followed
    by the set of c-v maps returned by cv_map_words() ➊. Use set comprehension and
    the permutations module to generate the set of permutations ➋. I described this
    process in “[Project #6: Finding Voldemort: The Gallic Gambit](ch03.xhtml#lev65)”
    on [page 49](ch03.xhtml#page_49). Use a set here to permit later use of set operations,
    like taking the difference between two filter sets. This also removes duplicates,
    as permutations treats each *o* as a separate item, and returns 9!, rather than
    9! / 2!. Note that permutations considers *tmv**o**ordle* and *tmvo**o**rdle*
    different strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now initialize an empty set to hold the contents of the first filter ➌ and
    begin looping through the permutations ➍. Use the term *candidate*, as most of
    these aren’t words but just strings of random letters. For each candidate, loop
    through the letters and map them to a *c* or a *v*, as you did with the cv_words()
    function. Check each c-v map, temp, for membership in filtered_cv_map. This is
    one reason for using sets: membership checks are very fast. If the candidate meets
    the condition, add it to filter_1 ➎. Finish by returning your new anagram set
    ➏.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the Trigram Filter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-9](ch03.xhtml#ch03list9) defines the trigram filter, which removes
    the permutations with unlikely three-letter triplets. It uses a text file derived
    from various cryptography websites that has been tailored to the letters in *tmvoordle*.
    This function will return only permutations that include one of these trigrams;
    the main() function will pass the new set to the next filter function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 5'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def trigram_filter(filter_1, trigrams_filtered):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Remove unlikely trigrams from permutations."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ filtered = set()
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for candidate in filter_1:'
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for triplet in trigrams_filtered:'
  prefs: []
  type: TYPE_NORMAL
- en: triplet = triplet.lower()
  prefs: []
  type: TYPE_NORMAL
- en: 'if triplet in candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: filtered.add(candidate)
  prefs: []
  type: TYPE_NORMAL
- en: ➎ filter_2 = filter_1 - filtered
  prefs: []
  type: TYPE_NORMAL
- en: print("# of choices after filter_2 = {}".format(len(filter_2)))
  prefs: []
  type: TYPE_NORMAL
- en: ➏ return filter_2
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-9: Defines the* trigram_filter() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters for the trigram filter include the output from the c-v map filter
    and the external list of unlikely trigrams, trigrams_filtered ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an empty set to hold permutations that contain one of the forbidden
    trigrams ➋. Then start another for loop that looks through the candidates that
    survived the last filter ➌. A nested for loop looks at each triplet in the trigrams
    list ➍. If the triplet is in the candidate, it is added to the filter.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use set operations to subtract the new filter from filter_1 ➎ and
    then return the difference for use with the next filter ➏.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the Digram Filter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-10](ch03.xhtml#ch03list10) defines the digram filter, which removes
    unlikely letter pairs. Some will trigger the filter if they occur anywhere within
    the permutation; others will do so only if they occur at the start of the permutation.
    The disallowed digrams are based on the shaded cells in [Table 3-2](ch03.xhtml#ch03tab2).
    The function returns the results of this filter for use in the final filter function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 6'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def letter_pair_filter(filter_2):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Remove unlikely letter-pairs from permutations."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ filtered = set()
  prefs: []
  type: TYPE_NORMAL
- en: ➌ rejects = ['dt', 'lr', 'md', 'ml', 'mr', 'mt', 'mv',
  prefs: []
  type: TYPE_NORMAL
- en: '''td'', ''tv'', ''vd'', ''vl'', ''vm'', ''vr'', ''vt'']'
  prefs: []
  type: TYPE_NORMAL
- en: ➍ first_pair_rejects = ['ld', 'lm', 'lt', 'lv', 'rd',
  prefs: []
  type: TYPE_NORMAL
- en: '''rl'', ''rm'', ''rt'', ''rv'', ''tl'', ''tm'']'
  prefs: []
  type: TYPE_NORMAL
- en: '➎ for candidate in filter_2:'
  prefs: []
  type: TYPE_NORMAL
- en: '➏ for r in rejects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if r in candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: filtered.add(candidate)
  prefs: []
  type: TYPE_NORMAL
- en: '➐ for fp in first_pair_rejects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if candidate.startswith(fp):'
  prefs: []
  type: TYPE_NORMAL
- en: filtered.add(candidate)
  prefs: []
  type: TYPE_NORMAL
- en: ➑ filter_3 = filter_2 - filtered
  prefs: []
  type: TYPE_NORMAL
- en: print("# of choices after filter_3 = {}".format(len(filter_3)))
  prefs: []
  type: TYPE_NORMAL
- en: '➒ if ''voldemort'' in filter_3:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Voldemort found!", file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: ➓ return filter_3
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-10: Defines the* letter_pair_filter() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: This filter accepts the results of the previous filter as an argument ➊. An
    empty set is initialized to hold any discarded permutations ➋. Then two lists
    of rejected pairs are assigned to the variables rejects ➌ and first_pair_rejects
    ➍. Both lists were entered manually. The first represents cells shaded black in
    [Table 3-2](ch03.xhtml#ch03tab2); the second references cells shaded gray. Any
    permutation that contains a member of the first list—anywhere—will be discarded;
    permutations that *start with* a member of the second list will not be allowed.
    You can add or remove digrams to these lists to change how the filter behaves.
  prefs: []
  type: TYPE_NORMAL
- en: Begin looping through the permutations—continue to refer to these as “candidates,”
    as they aren’t necessarily words ➎. A nested for loop goes through the pairs in
    rejects, determines whether any are in candidate, and adds them to the filtered
    set ➏. A second nested for loop repeats this process for the first_pair_rejects
    ➐. Subtract filtered from the set returned from the previous function, filter_2
    ➑.
  prefs: []
  type: TYPE_NORMAL
- en: For fun *and* to ensure you haven’t filtered too far, check whether *voldemort*
    is included in filter_3 ➒ and print an announcement to highlight the discovery,
    using eye-catching red font for IDLE users. Then finish by returning the final
    filtered set ➓.
  prefs: []
  type: TYPE_NORMAL
- en: '**Letting the User Choose the Starting Letter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You don’t know ahead of time whether your filtering will be successful. You
    may still end up with thousands of permutations. Providing the option to look
    at only a subset of the output won’t reduce the overall number, but it will make
    it *psychologically* easier to face. [Listing 3-11](ch03.xhtml#ch03list11) adds,
    to *voldemort_british.py*, the ability to view a list of anagrams that begin with
    a certain input letter.
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 7'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def view_by_letter(name, filter_3):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Filter to anagrams starting with input letter."""'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ print("Remaining letters = {}".format(name))
  prefs: []
  type: TYPE_NORMAL
- en: '➌ first = input("select a starting letter or press Enter to see all: ")'
  prefs: []
  type: TYPE_NORMAL
- en: ➍ subset = []
  prefs: []
  type: TYPE_NORMAL
- en: '➎ for candidate in filter_3:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if candidate.startswith(first):'
  prefs: []
  type: TYPE_NORMAL
- en: subset.append(candidate)
  prefs: []
  type: TYPE_NORMAL
- en: ➏ print(*sorted(subset), sep='\n')
  prefs: []
  type: TYPE_NORMAL
- en: print("Number of choices starting with {} = {}".format(first, len(subset)))
  prefs: []
  type: TYPE_NORMAL
- en: ➐ try_again = input("Try again? (Press Enter else any other key to Exit):")
  prefs: []
  type: TYPE_NORMAL
- en: 'if try_again.lower() == '''':'
  prefs: []
  type: TYPE_NORMAL
- en: ➑ view_by_letter(name, filter_3)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: ➒ sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-11: Defines the* view_by_letter() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Define the view_by_letter() function to take both the name variable and filter_3
    as arguments ➊. You need the name so you can show the user the available letter
    choices on which to filter ➋. Get the user’s input on whether they want to see
    all the remaining permutations or just those beginning with a certain letter ➌.
    Then start an empty list to hold the latter subset ➍.
  prefs: []
  type: TYPE_NORMAL
- en: A for loop, with a conditional, checks whether a candidate starts with the chosen
    letter and appends those letters that pass to subset ➎. This list is printed with
    the splat operator ➏. Then the program asks the user whether they want to try
    again or exit ➐. If they press ENTER, then view_by_letter() is called, recursively,
    and runs again from the start ➑. Otherwise, the program exits ➒. Note that Python
    has a default recursion depth limit of 1,000, which we’ll ignore in this project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Back in the global space, [Listing 3-12](ch03.xhtml#ch03list12) completes the
    code by calling the main() function if the user runs the program in stand-alone
    mode versus importing into another program.
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 8'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-12: Calls the* main() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Example output from the completed program is shown below. After the program
    applies the third filter, there are 248 permutations remaining, of which a very
    manageable 73 start with *v*. I’ve omitted the printout of the permutations for
    brevity. As noted in the output, *voldemort* survives the filtering.
  prefs: []
  type: TYPE_NORMAL
- en: length initial word_list = 60388
  prefs: []
  type: TYPE_NORMAL
- en: length of new word_list = 8687
  prefs: []
  type: TYPE_NORMAL
- en: length filtered_cv_map = 234
  prefs: []
  type: TYPE_NORMAL
- en: length of initial permutations set = 181440
  prefs: []
  type: TYPE_NORMAL
- en: choices after filter_1 = 123120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: of choices after filter_2 = 674
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: of choices after filter_3 = 248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Voldemort found!
  prefs: []
  type: TYPE_NORMAL
- en: Remaining letters = tmvoordle
  prefs: []
  type: TYPE_NORMAL
- en: 'select a starting letter or Enter to see all: v'
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, another surviving permutation is *lovedmort*. Given how many
    people Voldemort killed—or had killed—this may be the most appropriate moniker
    of all.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you first wrote code that found the anagrams for a given word
    or name. You then expanded on this to find phrasal name anagrams, working interactively
    with the user. Finally, you employed cryptanalytical techniques to tease *Voldemort*
    out of almost 200,000 possible anagrams. Along the way, you applied useful functionality
    in the collections and itertools modules.
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Jumble* website is *[http://www.jumble.com/](http://www.jumble.com/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find some representative online anagram generators at the following
    sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[http://wordsmith.org/anagram/](http://wordsmith.org/anagram/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[https://www.dcode.fr/anagram-generator](https://www.dcode.fr/anagram-generator)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[http://www.wordplays.com/anagrammer/](http://www.wordplays.com/anagrammer/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More anagram programs are found in *Think Python, 2nd Edition* (O’Reilly, 2015)
    by Allen Downey.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cracking Codes with Python* (No Starch Press, 2017) by Al Sweigart provides
    more code for computing word patterns, such as those used for filtering in the
    *voldemort_british.py* program.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Finding Digrams**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You *could* comb through cryptography websites looking for frequency statistics,
    or you could derive them for yourself. Write a Python program that finds all the
    digrams in *tmvoordle* and then counts their frequency of occurrence in a dictionary
    file. Be sure to test your code on words like *volvo*, so you don’t overlook repeating
    digrams in the same word. You can find a solution in the appendix or download
    *count_digrams_practice.py* from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Automatic Anagram Generator**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the online anagram generators I just referenced in “Further Reading”
    and write a Python program that mimics one of these. Your program should automatically
    generate phrase anagrams from an input name and display a subset (for example,
    the first 500) for the user to review.
  prefs: []
  type: TYPE_NORMAL
