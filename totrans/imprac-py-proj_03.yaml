- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: SOLVING ANAGRAMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决字谜**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: An *anagram* is a word formed by rearranging the letters of another word. For
    example, *Elvis* yields the eerie trio *evils*, *lives*, and *veils*. Does this
    mean Elvis still lives but veils his evil existence? In the book *Harry Potter
    and the Chamber of Secrets*, “I am Lord Voldemort” is an anagram of the evil wizard’s
    real name, Tom Marvolo Riddle. “Lord Earldom Vomit” is also an anagram of Tom
    Marvolo Riddle, but author J.K. Rowling had the good sense to pass on that one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*字谜* 是通过重新排列另一个单词的字母所形成的单词。例如，*Elvis* 会产生令人毛骨悚然的三重奏 *evils*、*lives* 和 *veils*。这是否意味着
    Elvis 仍然活着，但隐藏了他邪恶的存在？在《哈利·波特与密室》一书中，“I am Lord Voldemort” 是邪恶巫师的真名 Tom Marvolo
    Riddle 的字谜。“Lord Earldom Vomit” 也是 Tom Marvolo Riddle 的字谜，但作者 J.K. Rowling 明智地选择了放弃这个版本。'
- en: In this chapter, first you’ll find all the anagrams for a given word or name.
    Then, you’ll write a program that lets a user interactively build an anagram phrase
    from their own name. Finally, you’ll play computer wizard and see what it takes
    to extract “I am Lord Voldemort” from “Tom Marvolo Riddle.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，首先你将找到一个给定单词或名称的所有字谜。然后，你将编写一个程序，允许用户通过交互式方式从他们自己的名字构建一个字谜短语。最后，你将扮演计算机巫师，看看如何从“Tom
    Marvolo Riddle”提取出“I am Lord Voldemort”。
- en: '**Project #4: Finding Single-Word Anagrams**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #4：查找单词字谜**'
- en: You’ll start by analyzing simple single-word anagrams and figuring out how to
    identify them programmatically. Having accomplished this, you’ll be ready to take
    on anagram phrases in the following section.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从分析简单的单词字谜开始，并研究如何通过编程来识别它们。完成这一部分后，你将准备好在接下来的部分处理中处理字谜短语。
- en: '**THE OBJECTIVE**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use Python and a dictionary file to find all the single-word anagrams for a
    given English word or single name. You can read instructions for finding and loading
    dictionary files at the start of [Chapter 2](ch02.xhtml#ch02).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 和字典文件查找给定英语单词或单个名称的所有单词字谜。你可以在 [第二章](ch02.xhtml#ch02) 的开始部分找到查找和加载字典文件的说明。
- en: '***The Strategy and Pseudocode***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: 'More than 600 newspapers and 100 internet sites carry an anagram game called
    *Jumble*. Created in 1954, it’s now the most recognized word-scramble game in
    the world. *Jumble* can be really frustrating, but finding anagrams is almost
    as easy as finding palindromes—you just need to know the common characteristic
    of all anagrams: they must have the same number of the same letters.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 超过600家报纸和100个互联网网站都开展了一种名为 *Jumble* 的字谜游戏。该游戏创立于1954年，现在是全球最知名的文字混排游戏。*Jumble*
    可能会让人感到非常沮丧，但找出字谜几乎和找回回文一样简单——你只需要知道所有字谜的共同特征：它们必须包含相同数量的相同字母。
- en: '**Identifying an Anagram**'
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**识别字谜**'
- en: Python doesn’t contain a built-in anagram operator, but you can easily write
    one. For the projects in this chapter, you’ll load the dictionary file from [Chapter
    2](ch02.xhtml#ch02) as a list of strings. So the program needs to verify that
    two strings are anagrams of each other.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有内置的字谜运算符，但你可以轻松编写一个。在本章的项目中，你将从 [第二章](ch02.xhtml#ch02) 加载字典文件作为字符串列表。因此，程序需要验证两个字符串是否是彼此的字谜。
- en: 'Let’s look at an example. *Pots* is an anagram of *stop*, and you can verify
    that *stop* and *pots* have the same number of letters with the len() function.
    But there’s no way for Python to know whether two strings have the same number
    of any single character—at least not without converting the strings to another
    data structure or using a counting function. So, instead of looking at these two
    words simply as strings, you can represent them as two lists containing single-character
    strings. Create these lists in a shell, like IDLE, and name them word and anagram,
    as I’ve done here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。*Pots* 是 *stop* 的字谜，你可以通过 len() 函数验证 *stop* 和 *pots* 是否包含相同数量的字母。但
    Python 无法知道两个字符串是否具有相同数量的某个字符——至少在不将字符串转换为其他数据结构或使用计数函数的情况下是无法做到的。因此，除了将这两个单词简单地看作字符串之外，你还可以将它们表示为包含单个字符字符串的两个列表。在像
    IDLE 这样的 Shell 中创建这些列表，并将它们命名为 word 和 anagram，正如我在这里所做的那样：
- en: '>>> word = list(''stop'')'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word = list(''stop'')'
- en: '>>> word'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word'
- en: '[''s'', ''t'', ''o'', ''p'']'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[''s'', ''t'', ''o'', ''p'']'
- en: '>>> anagram = list(''pots'')'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram = list(''pots'')'
- en: '>>> anagram'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram'
- en: '[''p'', ''o'', ''t'', ''s'']'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[''p'', ''o'', ''t'', ''s'']'
- en: These two lists match our description of an anagram pair; that is, they contain
    the same number of the same letters. But if you try to equate them with the comparison
    operator ==, the result is False.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个列表与我们对字谜对的描述相符；也就是说，它们包含相同数量的相同字母。但是，如果你试图用比较运算符 == 来比较它们，结果是 False。
- en: '>>> anagram == word'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram == word'
- en: 'False'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: The problem is that the operator (==) considers two lists equivalent only if
    they have the same number of the same list items and those items occur in the
    same order. You can easily solve this problem with the built-in function sorted(),
    which can take a list as an argument and reorder its contents alphabetically.
    So, if you call sorted() twice—once for each of the lists—and then compare the
    sorted lists, they will be equivalent. In other words, == returns True.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于运算符 (==) 仅在两个列表具有相同数量的相同元素并且这些元素按相同顺序出现时，才会认为它们是相等的。你可以通过内置函数 sorted() 来轻松解决这个问题，该函数可以将列表作为参数并按字母顺序重新排列其内容。因此，如果你对两个列表分别调用
    sorted() 并比较排序后的列表，它们将是相等的。换句话说，== 返回 True。
- en: '>>> word = sorted(word)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word = sorted(word)'
- en: '>>> word'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word'
- en: '[''o'', ''p'', ''s'', ''t'']'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[''o'', ''p'', ''s'', ''t'']'
- en: '>>> anagram = sorted(anagram)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram = sorted(anagram)'
- en: '>>> anagram'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram'
- en: '[''o'', ''p'', ''s'', ''t'']'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[''o'', ''p'', ''s'', ''t'']'
- en: '>>> anagram == word'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram == word'
- en: 'True'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: You can also pass a string to sorted() to create a sorted list like the ones
    in the preceding code snippet. This will be useful for converting the words from
    the dictionary file into sorted lists of single-character strings.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将一个字符串传递给 sorted() 来创建一个排序后的列表，就像前面的代码片段一样。这对于将字典文件中的单词转换为排序后的单字符字符串列表非常有用。
- en: Now that you know how to verify that you’ve found an anagram, let’s design the
    script in its entirety—from loading a dictionary and prompting the user for a
    word (or name) to searching for and printing all the anagrams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何验证是否找到字谜，我们来设计完整的脚本——从加载字典并提示用户输入一个单词（或名称），到查找并打印所有字谜。
- en: '**Using Pseudocode**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用伪代码**'
- en: Remember that planning with pseudocode will help you spot potential issues and
    spotting those issues early will save you time. The following pseudocode should
    help you better understand the script we’ll write in the next section, *anagrams.py*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用伪代码进行规划可以帮助你发现潜在的问题，提前发现这些问题将节省你大量时间。以下伪代码应帮助你更好地理解我们将在下一节中编写的脚本 *anagrams.py*。
- en: Load digital dictionary file as a list of words
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字字典文件加载为一个单词列表
- en: Accept a word from user
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接受用户输入的单词
- en: Create an empty list to hold anagrams
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空列表来存储字谜
- en: Sort the user-word
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 排序用户输入的单词
- en: 'Loop through each word in the word list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历单词列表中的每个单词：
- en: Sort the word
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 排序单词
- en: 'if word sorted is equal to user-word sorted:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果排序后的单词与用户输入的排序单词相同：
- en: Append word to anagrams list
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词添加到字谜列表
- en: Print anagrams list
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打印字谜列表
- en: The script will start by loading words from a dictionary file into a list as
    strings. Before you loop through the dictionary in search of anagrams, you need
    to know which word you want anagrams of, and you need a place to store anagrams
    when you find them. So, first ask the user to input a word and then create an
    empty list to store the anagrams. Once the program has looped through every word
    in the dictionary, it will print that list of anagrams.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先会从字典文件加载单词到一个字符串列表中。在遍历字典查找字谜之前，你需要知道你想要查找字谜的单词是什么，并且需要一个地方来存储找到的字谜。因此，首先请用户输入一个单词，然后创建一个空列表来存储字谜。一旦程序遍历了字典中的每个单词，它将打印该字谜列表。
- en: '***Anagram-Finder Code***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字谜查找器代码***'
- en: '[Listing 3-1](ch03.xhtml#ch03list1) loads a dictionary file, accepts a word
    or name *specified within the program*, and finds all the anagrams in the dictionary
    file for that word or name. You’ll also need the dictionary-loading code from
    [Chapter 2](ch02.xhtml#ch02). You can download these from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *anagrams.py* and *load_dictionary.py*, respectively. Keep both files in the
    same folder. You can use the same dictionary file you used in [Chapter 2](ch02.xhtml#ch02)
    or download another one (see [Table 2-1](ch02.xhtml#ch02tab1) on [page 20](ch02.xhtml#page_20)
    for suggestions).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-1](ch03.xhtml#ch03list1) 加载字典文件，接受程序中*指定的*单词或名称，并为该单词或名称在字典文件中查找所有字谜。你还需要
    [第 2 章](ch02.xhtml#ch02) 中的字典加载代码。你可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载它们，分别命名为 *anagrams.py* 和 *load_dictionary.py*。请将这两个文件保存在同一文件夹中。你可以使用 [第 2 章](ch02.xhtml#ch02)
    中使用的字典文件，或者下载另一个字典文件（有关建议，请参见 [表 2-1](ch02.xhtml#ch02tab1)，位于 [第 20 页](ch02.xhtml#page_20)）。'
- en: '*anagrams.py*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*anagrams.py*'
- en: ➊ import load_dictionary
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import load_dictionary
- en: ➋ word_list = load_dictionary.load('2of4brif.txt')
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ word_list = load_dictionary.load('2of4brif.txt')
- en: ➌ anagram_list = []
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ anagram_list = []
- en: '# input a SINGLE word or SINGLE name below to find its anagram(s):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在下面输入一个单词或单一名称来查找其字谜：'
- en: ➍ name = 'Foster'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ name = 'Foster'
- en: print("Input name = {}".format (name))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: print("输入名称 = {}".format (name))
- en: ➎ name = name.lower()
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ name = name.lower()
- en: print("Using name = {}".format(name))
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: print("使用 name = {}".format(name))
- en: '# sort name & find anagrams'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '# 排序 name 并查找变位词'
- en: ➏ name_sorted = sorted(name)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ name_sorted = sorted(name)
- en: '➐ for word in word_list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ 遍历 word_list 中的每个单词：
- en: word = word.lower()
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: word = word.lower()
- en: 'if word != name:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'if word != name:'
- en: 'if sorted(word) == name_sorted:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'if sorted(word) == name_sorted:'
- en: anagram_list.append(word)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: anagram_list.append(word)
- en: '# print out list of anagrams'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印出变位词列表'
- en: print()
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: '➑ if len(anagram_list) == 0:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ if len(anagram_list) == 0:'
- en: print("You need a larger dictionary or a new name!")
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: print("你需要一个更大的字典或换个名字！")
- en: 'else:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: ➒ print("Anagrams =", *anagram_list, sep='\n')
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ print("变位词 =", *anagram_list, sep='\n')
- en: '*Listing 3-1: Given a word (or name) and a dictionary file, this program searches
    for and prints a list of anagrams.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-1：给定一个单词（或名字）和一个字典文件，程序会搜索并打印一个变位词列表。*'
- en: You start by importing the load_dictionary module you created in [Chapter 2](ch02.xhtml#ch02)
    ➊. This module will open a dictionary text file and, with its load() function,
    load all the words into a list ➋. The **.txt* file you use may be different, depending
    on which dictionary file you downloaded (see “[Finding and Opening a Dictionary](ch02.xhtml#lev33)”
    on [page 20](ch02.xhtml#page_20)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先导入在 [第2章](ch02.xhtml#ch02) 中创建的 load_dictionary 模块 ➊。这个模块将打开一个字典文本文件，并通过它的
    load() 函数将所有单词加载到一个列表中 ➋。你使用的 **.txt* 文件可能不同，这取决于你下载的字典文件（见 “[查找和打开字典](ch02.xhtml#lev33)”
    在 [第20页](ch02.xhtml#page_20)）。
- en: Next, create an empty list, called anagram_list, to hold any anagrams you find
    ➌. Have the user add a *single* word, such as their first name ➍. This doesn’t
    have to be a proper name, but we’ll refer to it as name in the code to distinguish
    it from a dictionary word. Print this name so the user can see what was entered.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个空列表，名为 anagram_list，用于保存你找到的任何变位词 ➌。让用户添加一个 *单独* 的单词，比如他们的名字 ➍。这不一定是一个专有名词，但为了与字典中的单词区分开，我们将在代码中称之为
    name。打印这个名字，以便用户看到输入的内容。
- en: The next line anticipates a problematic user action. People tend to type their
    name with an uppercase first letter, but dictionary files may not include uppercase
    letters, and that matters to Python. So, first convert all letters to lowercase
    with the .lower() string method ➎.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码考虑到可能出现的问题。人们倾向于输入首字母大写的名字，但字典文件可能不包含大写字母，而 Python 是区分大小写的。因此，首先使用 .lower()
    字符串方法将所有字母转换为小写 ➎。
- en: Now sort the name ➏. As mentioned previously, you can pass sorted() a string
    as well as a list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对名称进行排序 ➏。前面提到过，你可以将 sorted() 应用于字符串和列表。
- en: With the input sorted alphabetically in a list, it’s time to find anagrams.
    Start a loop through each word in the dictionary word list ➐. To be safe, convert
    the word to lowercase, as comparison operations are case-sensitive. After the
    conversion, compare the word to the unsorted name, because a word can’t be an
    anagram of itself. Next, sort the dictionary word and compare it to the sorted
    name. If it passes, append that dictionary word to anagram_list.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的名称按字母顺序排列在列表中，现在是时候查找变位词了。通过字典单词列表中的每个单词开始循环 ➐。为了安全起见，将单词转换为小写，因为比较操作是区分大小写的。转换后，将该单词与未排序的名称进行比较，因为一个单词不能是它自己的变位词。接下来，对字典中的单词进行排序，并将其与已排序的名称进行比较。如果匹配，则将该字典单词添加到
    anagram_list 中。
- en: Now display the results. First, check whether the anagram list is empty. If
    it is, print a whimsical reply so you don’t just leave the user hanging ➑. If
    the program found at least one anagram, print the list using the splat (*) operator.
    Remember from [Chapter 2](ch02.xhtml#ch02) that splat lets you print each member
    of a list on a separate line ➒.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显示结果。首先，检查变位词列表是否为空。如果为空，打印一个幽默的回复，避免让用户空等 ➑。如果程序找到了至少一个变位词，使用 splat (*) 操作符打印列表。记住，[第2章](ch02.xhtml#ch02)中提到过，splat
    让你将列表中的每个成员打印在单独的一行上 ➒。
- en: 'The following is example output for this program, using the input name *Foster*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用输入名称 *Foster* 的程序示例输出：
- en: Input name = Foster
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的名字 = Foster
- en: Using name = foster
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 name = foster
- en: Anagrams =
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 变位词 =
- en: forest
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: forest
- en: fortes
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: fortes
- en: softer
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: softer
- en: If you’d like to use another input, change the value of the name variable in
    the source code. As an exercise, try to adjust the code so that the user is prompted
    to input the name (or word); you can do this with the input() function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用另一个输入，可以更改源代码中 name 变量的值。作为练习，尝试调整代码，使用户被提示输入名字（或单词）；你可以通过 input() 函数实现这一点。
- en: '**Project #5: Finding Phrase Anagrams**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #5：查找短语变位词**'
- en: In the previous project, you took a single name or word and rearranged all the
    letters to find single-word anagrams. Now you will derive multiple words from
    a name. The words in these *phrase anagrams* form only part of the input name,
    and you will need several words to exhaust the available letters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个项目中，你使用一个名字或单词并重新排列所有字母，找到单词字谜。现在你将从一个名字中衍生出多个单词。这些*短语字谜*中的单词仅构成输入名字的一部分，你需要多个单词才能用尽所有字母。
- en: '**THE OBJECTIVE**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write a Python program that lets a user interactively build an anagram phrase
    from the letters in their name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，允许用户通过名字中的字母互动地构建一个字谜短语。
- en: '***The Strategy and Pseudocode***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略和伪代码***'
- en: The very best phrase anagrams are those that describe some well-known characteristic
    or action associated with the name bearer. For example, the letters in Clint Eastwood
    can be rearranged to form *old west action*, Alec Guinness yields *genuine class*,
    Madam Curie produces *radium came*, George Bush gives *he bugs Gore*, and Statue
    of Liberty contains *built to stay free*. My own name yields *a huge navel*, which
    is not really one of my characteristics.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的短语字谜是那些描述与名字持有者相关的某种著名特征或行为的。例如，Clint Eastwood中的字母可以重新排列形成*old west action*，Alec
    Guinness可以得到*genuine class*，Madam Curie可以得到*radium came*，George Bush可以得到*he bugs
    Gore*，而自由女神像包含*built to stay free*。我自己的名字可以得到*a huge navel*，不过那其实并不是我的特征之一。
- en: 'At this point, you may see a strategic challenge ahead: how does a computer
    handle contextual content? The folks at IBM who invented Watson seem to know,
    but for the rest of us, that boulder is a little hard to lift.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，你可能会遇到一个战略性挑战：计算机如何处理上下文内容？发明了Watson的IBM公司似乎知道答案，但对于我们其他人来说，这块巨石有点难以搬动。
- en: The *brute-force method* is a common approach used in online anagram generators.
    These algorithms take a name and return lots of random anagram phrases (generally,
    100s to 10,000+). Most of the returned phrases are nonsense, and scrolling through
    hundreds of these can be a chore.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*暴力破解法*是在线字谜生成器中常用的一种方法。这些算法接受一个名字并返回许多随机的字谜短语（通常是100个到10,000个以上）。大部分返回的短语都是无意义的，浏览这些无数的短语可能会变得非常繁琐。'
- en: An alternative approach is to acknowledge that humans are best at contextual
    issues and write a program that helps the human work through the problem. The
    computer can take the initial name and provide words that can be made from some
    (or all) the letters in it; the user can then choose a word that “makes sense.”
    The program will then recalculate the word choices from the remaining letters
    in the name, repeating the process until every letter is used or the possible
    word choices are exhausted. This design plays to the strengths of both participants.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是承认人类在处理上下文问题上最为擅长，并编写一个帮助人类解决问题的程序。计算机可以接受初始的名字并提供可以从其中的某些（或所有）字母组成的单词；然后用户可以选择一个“合适”的单词。程序随后将根据名字中剩余的字母重新计算单词选择，重复该过程，直到所有字母都被使用完或所有可能的单词选择用尽。这个设计充分发挥了两者的优势。
- en: You’ll need a simple interface that prompts the user to input the initial name,
    displays potential word choices, and displays any remaining letters. The program
    will also need to keep track of the growing anagram phrase and let the user know
    when every letter has been used. There will likely be lots of failed attempts,
    so the interface should allow the user to restart the process at any time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个简单的界面，提示用户输入初始的名字，显示潜在的单词选择，并展示剩余的字母。程序还需要跟踪逐渐增长的字谜短语，并在每个字母被使用时提醒用户。可能会有很多失败的尝试，所以界面应允许用户随时重新开始。
- en: Since anagrams have the same number of the same letters, another way to identify
    them is to count individual letters. If you think of your name as a collection
    of letters, then a word can be built from your name if (1) all its letters occur
    in your name and (2) they occur *at the same frequency or less*. Obviously, if
    *e* occurs three times in a word and twice in your name, the word can’t be derived
    from your name. So, if the collection of letters that make up a word is not a
    subset of the collection of letters in your name, then that word cannot be part
    of your name anagram.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字谜由相同数量的相同字母组成，另一种识别字谜的方法是统计每个字母的数量。如果你把你的名字看作是一个字母集合，那么如果（1）一个单词的所有字母都出现在你的名字中，并且（2）它们出现的频率与名字中相同或更少，那么这个单词就可以从你的名字中构建出来。显然，如果*e*在一个单词中出现了三次，而在你的名字中出现了两次，那么这个单词不能从你的名字中得出。因此，如果构成一个单词的字母集合不是你名字中字母集合的子集，那么这个单词就不能是你名字字谜的一部分。
- en: '**Using Counter to Tally Letters**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用计数器统计字母**'
- en: Fortunately for us, Python ships with a module named collections that includes
    several container data types. One of these types, Counter, counts the occurrences
    of an item. Python stores the items as dictionary keys and the counts as dictionary
    values. For example, the following code snippet counts how many of each bonsai
    tree type is in a list.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 附带了一个名为 collections 的模块，其中包含几个容器数据类型。其中一种类型，Counter，可以统计项目出现的次数。Python
    将这些项目存储为字典的键，计数存储为字典的值。例如，下面的代码片段统计列表中每种盆栽树类型的数量。
- en: '>>> from collections import Counter'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from collections import Counter'
- en: ➊ >>> my_bonsai_trees = ['maple', 'oak', 'elm', 'maple', 'elm', 'elm', 'elm',
    'elm']
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> my_bonsai_trees = ['maple', 'oak', 'elm', 'maple', 'elm', 'elm', 'elm',
    'elm']
- en: ➋ >>> count = Counter(my_bonsai_trees)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> count = Counter(my_bonsai_trees)
- en: '>>> print(count)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(count)'
- en: '➌ Counter({''elm'': 5, ''maple'': 2, ''oak'': 1})'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ Counter({''elm'': 5, ''maple'': 2, ''oak'': 1})'
- en: The my_bonsai_trees list contains multiples of the same type of tree ➊. Counter
    tallies up the trees ➋ and creates an easy-to-reference dictionary ➌. Note that
    the print() function is optional and is used here for clarity. Entering count,
    alone, will also display the dictionary contents.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: my_bonsai_trees 列表包含相同类型树木的多个实例 ➊。Counter 会统计树木的数量 ➋ 并创建一个易于参考的字典 ➌。请注意，print()
    函数是可选的，这里用于增加清晰度。单独输入 count 也会显示字典内容。
- en: 'You can use Counter, instead of the sorted() method, to find single-word anagrams.
    Rather than two sorted lists, the output will be two dictionaries, which can also
    be directly compared with ==. Here’s an example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Counter 来代替 sorted() 方法查找单词的变位词。与两个排序过的列表不同，输出将是两个字典，它们也可以直接通过 == 进行比较。以下是一个示例：
- en: '>>> name = ''foster'''
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> name = ''foster'''
- en: '>>> word = ''forest'''
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word = ''forest'''
- en: '>>> name_count = Counter(name)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> name_count = Counter(name)'
- en: '>>> print(name_count)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(name_count)'
- en: '➊ Counter({''f'': 1, ''t'': 1, ''e'': 1, ''o'': 1, ''r'': 1, ''s'': 1})'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ Counter({''f'': 1, ''t'': 1, ''e'': 1, ''o'': 1, ''r'': 1, ''s'': 1})'
- en: '>>> word_count = Counter(word)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word_count = Counter(word)'
- en: '>>> print(word_count)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(word_count)'
- en: '➋ Counter({''f'': 1, ''t'': 1, ''o'': 1, ''e'': 1, ''r'': 1, ''s'': 1})'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ Counter({''f'': 1, ''t'': 1, ''o'': 1, ''e'': 1, ''r'': 1, ''s'': 1})'
- en: 'Counter produces a dictionary for each word that maps each letter in the word
    to the number of times it occurs ➊➋. The dictionaries are unsorted, but despite
    the lack of sorting, Python correctly identifies each dictionary as being equal
    if the dictionaries contain the same letters and the same counts:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Counter 会为每个单词生成一个字典，将单词中的每个字母映射到其出现的次数 ➊➋。这些字典是无序的，但尽管没有排序，Python 仍然能正确识别两个字典是否相等，只要它们包含相同的字母和相同的计数：
- en: '>>> if word_count == name_count:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if word_count == name_count:'
- en: print("It's a match!")
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: print("匹配成功！")
- en: It's a match!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配成功！
- en: A Counter gives you a wonderful way to find words that “fit” in a name. If the
    count for each letter in a word is less than or equal to the count for the same
    letter in the name, then the word can be derived from the name!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Counter 提供了一种绝妙的方式来查找“适配”名称的单词。如果单词中每个字母的计数小于或等于名称中相同字母的计数，那么该单词可以从名称中派生出来！
- en: '**The Pseudocode**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**伪代码**'
- en: 'We’ve now made two important design decisions: (1) let the user interactively
    build their anagram one word at a time and (2) use the Counter method to find
    anagrams. This is enough to start thinking about high-level pseudocode:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经做出了两个重要的设计决策：（1）让用户逐个单词地互动构建他们的变位词，（2）使用 Counter 方法来查找变位词。这足以开始思考高级伪代码：
- en: Load a dictionary file
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 加载字典文件
- en: Accept a name from user
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接受用户输入的名称
- en: Set limit = length of name
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 设置限制 = 名称的长度
- en: Start empty list to hold anagram phrase
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个空列表来存储变位词短语
- en: 'While length of phrase < limit:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当短语长度 < 限制时：
- en: Generate list of dictionary words that fit in name
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 生成符合名称的字典单词列表
- en: Present words to user
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户展示单词
- en: Present remaining letters to user
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户展示剩余字母
- en: Present current phrase to user
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户展示当前短语
- en: Ask user to input word or start over
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户输入单词或重新开始
- en: 'If user input can be made from remaining letters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入可以从剩余字母中构成：
- en: Accept choice of new word or words from user
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接受用户的新单词或单词组合选择
- en: Remove letters in choice from letters in name
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从名称中的字母中移除选择的字母
- en: Return choice and remaining letters in name
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 返回选择和名称中剩余的字母
- en: 'If choice is not a valid selection:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择无效：
- en: Ask user for new choice or let user start over
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户是否选择新的词语或重新开始
- en: Add choice to phrase and show to user
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将选择添加到短语并显示给用户
- en: Generate new list of words and repeat process
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 生成新的单词列表并重复该过程
- en: 'When phrase length equals limit value:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当短语长度等于限制值时：
- en: Display final phrase
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显示最终短语
- en: Ask user to start over or to exit
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户是否重新开始或退出
- en: '**Divvying Up the Work**'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分配任务**'
- en: As procedural code becomes more complex, it becomes necessary to encapsulate
    much of it in functions. This makes it easier to manage input and output, perform
    recursion, and read the code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序代码变得越来越复杂，将其中许多部分封装成函数变得必要。这使得管理输入和输出、执行递归以及阅读代码变得更加容易。
- en: A *main function* is where a program starts its execution, and enables high-level
    organization, such as managing all the bits and pieces of the code, including
    dealing with the user. In the phrase anagram program, the main function will wrap
    all the “worker bee” functions, take *most* of the user input, keep track of the
    growing anagram phrase, determine when the phrase is complete, and show the user
    the result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*主函数*是程序开始执行的地方，它启用了高级组织，如管理代码的所有部分，包括与用户的交互。在字谜短语程序中，主函数将包装所有“工作函数”，接受*大部分*的用户输入，跟踪增长中的字谜短语，确定短语何时完成，并向用户显示结果。'
- en: 'Sketching out the tasks and their flow with pencil and paper is a great way
    to figure out what you want to do and where (like “graphical pseudocode”). [Figure
    3-1](ch03.xhtml#ch03fig1) is a flowchart with function assignments highlighted.
    In this case, three functions should be sufficient: main(), find_anagrams(), and
    process_choice().'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 用铅笔和纸画出任务和流程图是搞清楚你想做什么以及做在哪里的好方法（类似“图形伪代码”）。[图 3-1](ch03.xhtml#ch03fig1)是一个带有功能分配的流程图。在这种情况下，三个函数应该足够：main()、find_anagrams()和process_choice()。
- en: The main() function’s primary task is to set the letter count limit and manage
    the while loop responsible for the general phrase anagram build. The find_anagrams()
    function will take the current collection of letters remaining in a name and return
    all possible words that can be made from those letters. The words are then displayed
    for the user, along with the current phrase, which is “owned” and displayed by
    the main() function. Then, the process_choice() function prompts the user to start
    over or choose a word for the anagram phrase. If the user makes a choice, this
    function determines whether the letters in the choice are available. If they aren’t,
    the user is prompted to choose again or start over. If the user makes a valid
    choice, the letters in the user’s choice are removed from the list of remaining
    letters, and both the choice and list of leftovers are returned. The main() function
    adds the returned choice to the existing phrase. If the limit is reached, the
    completed phrase anagram is displayed, and the user is asked to start over or
    exit.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: main()函数的主要任务是设置字母计数限制，并管理负责构建通用字谜短语的while循环。find_anagrams()函数将获取当前名称中剩余字母的集合，并返回可以由这些字母组成的所有可能的单词。然后，单词将显示给用户，并显示当前的短语，该短语由main()函数“拥有”和显示。接着，process_choice()函数会提示用户重新开始或选择一个字谜短语。如果用户做出选择，函数将检查选择中的字母是否可用。如果不可用，用户将被提示重新选择或重新开始。如果用户做出有效选择，所选字母将从剩余字母列表中移除，并返回选择和剩余字母列表。main()函数将返回的选择添加到现有短语中。如果达到限制，完成的字谜短语将被显示，并询问用户是否重新开始或退出。
- en: Note that you ask for the initial name in the *global* scope, rather than in
    the main() function. This allows the user to start over fresh at any time without
    having to re-enter their name. For now, if the user wants to choose a brand-new
    name, they’ll have to exit the program and start over. In [Chapter 9](ch09.xhtml#ch09),
    you’ll use a menu system that lets users completely reset what they’re doing without
    exiting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您需要在*全局*作用域中请求初始名称，而不是在main()函数中。这使得用户可以随时重新开始，而无需重新输入姓名。现在，如果用户想选择一个全新的名字，他们需要退出程序并重新开始。在[第9章](ch09.xhtml#ch09)中，您将使用菜单系统，允许用户在不退出的情况下完全重置他们的操作。
- en: '![image](../images/f0043-01.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0043-01.jpg)'
- en: '*Figure 3-1: Flowchart for finding phrase anagrams with function assignments
    highlighted*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：带有功能分配的字谜短语查找流程图*'
- en: '***The Anagram Phrase Code***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字谜短语编码***'
- en: 'The code in this section takes a name from a user and helps them build an anagram
    phrase of that name. You can download the entire script from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *phrase_anagrams.py*. You’ll also need to download the *load_dictionary.py*
    program. Save both files in the same folder. You can use the same dictionary file
    you used in “[Project #4: Finding Single-Word Anagrams](ch03.xhtml#lev50)” on
    [page 36](ch03.xhtml#page_36).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '这一部分代码接受用户输入的名字，并帮助他们构建这个名字的字谜短语。你可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载整个脚本，文件名为 *phrase_anagrams.py*。你还需要下载 *load_dictionary.py* 程序，并将这两个文件保存在同一文件夹中。你可以使用在
    “[项目 #4: 查找单词字谜](ch03.xhtml#lev50)”（第 36 页）中使用的字典文件。'
- en: '**Setting Up and Finding Anagrams**'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置和查找字谜**'
- en: '[Listing 3-2](ch03.xhtml#ch03list2) imports the modules that *phrase_anagrams.py*
    uses, loads a dictionary file, asks the user for an input name, and defines the
    find_anagrams() function, which does most of the work related to finding anagrams.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-2](ch03.xhtml#ch03list2) 导入 *phrase_anagrams.py* 使用的模块，加载字典文件，要求用户输入名字，并定义了
    find_anagrams() 函数，这个函数完成了大部分与字谜查找相关的工作。'
- en: '*phrase_anagrams.py,* part 1'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*phrase_anagrams.py,* 第一部分'
- en: ➊ import sys
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import sys
- en: from collections import Counter
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: from collections import Counter
- en: import load_dictionary
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: import load_dictionary
- en: ➋ dict_file = load_dictionary.load('2of4brif.txt')
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ dict_file = load_dictionary.load('2of4brif.txt')
- en: '# ensure "a" & "I" (both lowercase) are included'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '# 确保包含 "a" 和 "I"（两者均为小写）'
- en: dict_file.append('a')
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: dict_file.append('a')
- en: dict_file.append('i')
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: dict_file.append('i')
- en: dict_file = sorted(dict_file)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: dict_file = sorted(dict_file)
- en: '➌ ini_name = input("Enter a name: ")'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ ini_name = input("请输入名字：")
- en: '➍ def find_anagrams(name, word_list):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ def find_anagrams(name, word_list):'
- en: '"""Read name & dictionary file & display all anagrams IN name."""'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '"""读取名字和字典文件，并显示名字中的所有字谜。"""'
- en: ➎ name_letter_map = Counter(name)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ name_letter_map = Counter(name)
- en: anagrams = []
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: anagrams = []
- en: '➏ for word in word_list:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ for word in word_list:'
- en: ➐ test = ''
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ test = ''
- en: ➑ word_letter_map = Counter(word.lower())
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ word_letter_map = Counter(word.lower())
- en: '➒ for letter in word:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '➒ for letter in word:'
- en: 'if word_letter_map[letter] <= name_letter_map[letter]:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'if word_letter_map[letter] <= name_letter_map[letter]:'
- en: test += letter
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: test += letter
- en: 'if Counter(test) == word_letter_map:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'if Counter(test) == word_letter_map:'
- en: anagrams.append(word)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: anagrams.append(word)
- en: ➓ print(*anagrams, sep='\n')
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ➓ print(*anagrams, sep='\n')
- en: print()
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: print("Remaining letters = {}".format(name))
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: print("剩余字母 = {}".format(name))
- en: print("Number of remaining letters = {}".format(len(name)))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: print("剩余字母的数量 = {}".format(len(name)))
- en: print("Number of remaining (real word) anagrams = {}".format(len(anagrams)))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: print("剩余（真实单词）字谜的数量 = {}".format(len(anagrams)))
- en: '*Listing 3-2: Imports modules, loads dictionary, and defines the* find_anagrams()
    *function*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-2：导入模块，加载字典，并定义* find_anagrams() *函数*'
- en: Start with the import statements ➊, using the recommended order of Python Standard
    Library, third-party modules, and then locally developed modules. You need sys
    for coloring specific outputs red in the IDLE window and for letting the user
    exit the program with a keystroke. You’ll use Counter to help identify anagrams
    of the input name.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从导入语句 ➊ 开始，按照推荐的顺序导入 Python 标准库、第三方模块和本地开发的模块。你需要 sys 来在 IDLE 窗口中将特定的输出显示为红色，并允许用户通过按键退出程序。你将使用
    Counter 来帮助识别输入名字的字谜。
- en: Next load the dictionary file using the imported module ➋. The filename argument
    should be the filename of the dictionary you’re using. Because some dictionary
    files omit *a* and *I*, append these (if needed), and sort the list so that they
    can be found at the proper alphabetical locations, rather than at the end of the
    list.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来使用导入的模块加载字典文件 ➋。文件名参数应该是你正在使用的字典文件名。由于有些字典文件省略了*a*和*I*，需要将这两个字母（如果需要）附加到列表中，并对列表进行排序，以确保它们出现在正确的字母位置，而不是列表的末尾。
- en: Now get a name from the user and assign it to the variable ini_name (or “initial
    name”) ➌. You’ll derive a name variable from this initial name, and name will
    be progressively changed as the user builds up the name anagram. Preserving the
    initial name as a separate variable will let you reset everything if the user
    wants to start over or try again.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在获取用户输入的名字并将其分配给变量 ini_name（或“初始名字”） ➌。你将根据这个初始名字推导出一个名字变量，并在用户构建字谜时逐步修改名字。将初始名字保存在一个单独的变量中，允许你在用户想要重新开始或再次尝试时重置所有内容。
- en: The next block of code is find_anagrams() ➍, the function for finding anagrams
    in the name. The parameters for this function consist of a name and a word list.
    The function starts by using Counter to count the number of times a given letter
    appears in the name and then assigns the count to the variable name_letter_map
    ➎; Counter uses a dictionary structure with the letter as the key and the count
    as the value. The function then creates an empty list to hold the anagrams and
    starts a for loop through each word in the dictionary file ➏.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块是 find_anagrams() ➍，这是用于查找姓名中的字谜的函数。此函数的参数包括一个姓名和一个单词列表。函数开始时使用 Counter
    来计算给定字母在姓名中出现的次数，然后将该计数分配给变量 name_letter_map ➎；Counter 使用字典结构，将字母作为键，计数作为值。然后，函数创建一个空列表来保存字谜，并开始对字典文件中的每个单词进行
    for 循环 ➏。
- en: The for loop starts by creating an empty string called test ➐. Use this variable
    to accumulate all the letters in the word that “fit” in name. Then make a Counter
    for the current word, as you did for name, and call it word_letter_map ➑. Loop
    through the letters in word ➒, checking that the count of each letter is the same
    as, or less than, the count in name. If the letter meets this condition, then
    it is added to the test string. Since some letters might get rejected, end the
    loop by running Counter on test and comparing it to word_letter_map. If they match,
    append the word to the anagrams list.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环首先创建一个名为 test ➐ 的空字符串。使用这个变量来累积所有在 name 中“匹配”的字母。然后为当前单词创建一个 Counter，就像对
    name 做的一样，命名为 word_letter_map ➑。遍历 word 中的字母 ➒，检查每个字母的计数是否与 name 中的计数相同或更少。如果字母满足这个条件，则将其添加到
    test 字符串中。由于某些字母可能被拒绝，结束循环时运行 Counter 对 test 进行计数，并与 word_letter_map 比较。如果它们匹配，则将该单词附加到
    anagrams 列表中。
- en: The function ends by displaying the list of words, using the splat operator
    with print, along with some statistics for the user ➓. Note that find_anagrams()
    doesn’t return anything. This is where the human interaction part comes in. The
    program will continue to run, but nothing will happen until the user chooses a
    word from the displayed list.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 函数最后通过使用打印的 splat 操作符显示单词列表，并附带一些用户统计信息 ➓。请注意，find_anagrams() 不返回任何值。这是与人类交互的部分。程序将继续运行，但在用户从显示的列表中选择一个单词之前，什么也不会发生。
- en: '**Processing the User’s Choice**'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**处理用户选择**'
- en: '[Listing 3-3](ch03.xhtml#ch03list3) defines process_choice(), the function
    in *phrase_anagrams.py* that takes the user’s choice of word (or words), checks
    it against the remaining letters in the name variable, and returns acceptable
    choices—along with any leftover letters—to the main() function. Like main(), this
    function gets to talk directly to the user.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 3-3](ch03.xhtml#ch03list3) 定义了 process_choice()，这是 *phrase_anagrams.py*
    中的函数，用于获取用户选择的单词（或多个单词），并与 name 变量中的剩余字母进行匹配，返回可接受的选择——以及任何剩余的字母——给 main() 函数。与
    main() 类似，该函数可以直接与用户进行交互。'
- en: '*phrase_anagrams.py,* part 2'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*phrase_anagrams.py，* 第 2 部分'
- en: '➊ def process_choice(name):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def process_choice(name):'
- en: '"""Check user choice for validity, return choice & leftover letters."""'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '"""检查用户选择的有效性，返回选择和剩余字母。"""'
- en: 'while True:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: '➋ choice = input(''\nMake a choice else Enter to start over or # to end: '')'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ choice = input(''\n做出选择，否则按 Enter 重新开始，或者按 # 结束：'')'
- en: 'if choice == '''':'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 choice == ''：
- en: main()
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: 'elif choice == ''#'':'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: elif choice == '#'：
- en: sys.exit()
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'else:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: ➌ candidate = ''.join(choice.lower().split())
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ candidate = ''.join(choice.lower().split())
- en: ➍ left_over_list = list(name)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ left_over_list = list(name)
- en: '➎ for letter in candidate:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 对于 candidate 中的字母：
- en: 'if letter in left_over_list:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字母在 left_over_list 中：
- en: left_over_list.remove(letter)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: left_over_list.remove(letter)
- en: '➏ if len(name) - len(left_over_list) == len(candidate):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ 如果 len(name) - len(left_over_list) == len(candidate)：
- en: break
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 退出循环
- en: 'else:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print("Won't work! Make another choice!", file=sys.stderr)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: print("无法工作！做出另一个选择！", file=sys.stderr)
- en: ➐ name = ''.join(left_over_list)  # makes display more readable
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ name = ''''.join(left_over_list)  # 使显示更易读'
- en: ➑ return choice, name
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ 返回 choice 和 name
- en: '*Listing 3-3: Defines the* process_choice() *function*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-3：定义了* process_choice() *函数*'
- en: Start by defining the function with one parameter called name ➊. The first time
    the program is run, this parameter will be the same as the ini_name variable—the
    full name entered by the user when the program starts up. After the user has chosen
    a word (or words) to use in the anagram phrase, it will represent the remaining
    letters in the name.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义一个名为 name ➊ 的函数参数。程序首次运行时，该参数将与 ini_name 变量相同——即程序启动时用户输入的完整姓名。在用户选择一个（或多个）用于字谜短语的单词之后，它将表示姓名中剩余的字母。
- en: 'Start the function with a while loop that will run until the user makes a valid
    choice and then get input from the user ➋. The user has a choice of entering one
    or more words from the current anagram list, pressing ENTER to start over, or
    pressing # to quit. Use #, rather than a word or letter, so that it can’t be confused
    for a valid choice.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '从一个 while 循环开始，直到用户做出有效选择，然后获取用户输入 ➋。用户可以选择输入当前字谜列表中的一个或多个单词，按 ENTER 重新开始，或按
    # 退出。使用 # 而不是单词或字母，这样就不会与有效选择混淆。'
- en: If the user makes a choice, the string is assigned to the variable candidate,
    stripped of whitespace, and converted to all lowercase ➌. This is so it can be
    directly compared to the name variable. After that, a list is built from the name
    variable to hold any remaining letters ➍.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户做出了选择，字符串会被分配给候选变量，去除空格并转换为全小写 ➌。这样它就可以直接与 name 变量进行比较。接下来，会从 name 变量构建一个列表，用于保存剩余的字母
    ➍。
- en: Now begin a loop to subtract the letters used in candidate ➎. If a chosen letter
    is present in the list, it’s removed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始一个循环，从候选字母 ➎ 中减去已经使用的字母。如果所选字母存在于列表中，就将其移除。
- en: If the user entered a word that isn’t in the displayed list, or entered multiple
    words, a letter may not be present in the list. To check for this, subtract the
    leftover letters from name and, if the result is the number of letters in candidate,
    determine that the input is valid and break out of the while loop ➏. Otherwise,
    display a warning and color it red for those using the IDLE window. The while
    loop will keep prompting the user until an acceptable choice is made.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了一个不在显示列表中的单词，或者输入了多个单词，可能会有字母不在列表中。为了检查这一点，可以从 name 中减去剩余字母，如果结果等于候选字母的数量，就可以确定输入有效并跳出
    while 循环 ➏。否则，显示警告并为使用 IDLE 窗口的用户将其标红。while 循环会一直提示用户，直到做出可接受的选择。
- en: If all the letters in the user’s choice pass the test, the list of leftovers
    is converted back into a string and used to update the name variable ➐. Converting
    the list into a string isn’t strictly necessary, but it keeps the name variable
    type consistent and lets you display the remaining letters in a clearly readable
    format without the need for additional print arguments.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户的选择中的所有字母都通过测试，那么剩余字母的列表会被转换回字符串，并用来更新 name 变量 ➐。将列表转换成字符串并非严格必要，但它可以保持
    name 变量的类型一致，并且让你以清晰易读的格式显示剩余字母，而无需额外的打印参数。
- en: Finish by returning both the user’s choice and the string of remaining letters
    (name) to the main() function ➑.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后将用户选择的字母和剩余字母（name 字符串）一起返回到 main() 函数 ➑。
- en: '**Defining the main() Function**'
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义 main() 函数**'
- en: '[Listing 3-4](ch03.xhtml#ch03list4) defines the main() function in *phrase_anagrams.py*.
    This function wraps the previous functions, runs a while loop, and determines
    when the user has successfully created an anagram phrase.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-4](ch03.xhtml#ch03list4) 定义了 *phrase_anagrams.py* 中的 main() 函数。这个函数封装了之前的函数，运行一个
    while 循环，并判断用户是否成功创建了一个字谜短语。'
- en: '*phrase_anagrams.py,* part 3'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*phrase_anagrams.py*，第 3 部分'
- en: 'def main():'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '"""Help user build anagram phrase from their name."""'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '"""帮助用户从他们的名字中构建字谜短语。"""'
- en: ➊ name = ''.join(ini_name.lower().split())
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ name = ''.join(ini_name.lower().split())
- en: name = name.replace('-', '')
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: name = name.replace('-', '')
- en: ➋ limit = len(name)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ limit = len(name)
- en: phrase = ''
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: phrase = ''
- en: running = True
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: running = True
- en: '➌ while running:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ while running:'
- en: ➍ temp_phrase = phrase.replace(' ', '')
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ temp_phrase = phrase.replace(' ', '')
- en: '➎ if len(temp_phrase) < limit:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ if len(temp_phrase) < limit:'
- en: print("Length of anagram phrase = {}".format(len(temp_phrase)))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: print("字谜短语的长度 = {}".format(len(temp_phrase)))
- en: ➏ find_anagrams(name, dict_file)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ find_anagrams(name, dict_file)
- en: print("Current anagram phrase =", end=" ")
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: print("当前字谜短语 =", end=" ")
- en: print(phrase, file=sys.stderr)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: print(phrase, file=sys.stderr)
- en: ➐ choice, name = process_choice(name)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ choice, name = process_choice(name)
- en: phrase += choice + ' '
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: phrase += choice + ' '
- en: '➑ elif len(temp_phrase) == limit:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ elif len(temp_phrase) == limit:'
- en: print("\n*****FINISHED!!!*****\n")
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: print("\n*****完成！！！*****\n")
- en: print("Anagram of name =", end=" ")
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: print("名字的字谜 =", end=" ")
- en: print(phrase, file=sys.stderr)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: print(phrase, file=sys.stderr)
- en: print()
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: ➒ try_again = input('\n\nTry again? (Press Enter else "n" to quit)\n ')
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ try_again = input('\n\n再试一次吗？（按 Enter 否则输入 "n" 退出）\n ')
- en: 'if try_again.lower() == "n":'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'if try_again.lower() == "n":'
- en: running = False
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: running = False
- en: sys.exit()
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'else:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: main()
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '➓ if __name__ == ''__main__'':'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '➓ if __name__ == ''__main__'':'
- en: main()
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 3-4: Defines and calls* main() *function*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-4：定义并调用* main() *函数*'
- en: The first order of business is to turn the ini_name variable into a continuous
    string of lowercase characters with no whitespace ➊. Remember, case matters to
    Python, so convert all strings to lowercase wherever they occur; that way, comparisons
    will work as intended. Python also recognizes spaces as characters, so you need
    to remove these, as well as hyphens in hyphenated names, before doing any letter
    counts. By declaring this new name variable, you preserve the initial name in
    case the user wants to start over. Only name will be altered in the process_choice()
    function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是将ini_name变量转化为一个不带空格的小写字母连续字符串 ➊。记住，Python对大小写敏感，因此需要将所有字符串转换为小写，这样比较时才会按预期工作。Python也将空格视为字符，因此你需要删除空格以及连字符中的连字符，然后再进行字母计数。通过声明这个新名称变量，你可以保留原始名称，以防用户想要重新开始。只有name会在process_choice()函数中被修改。
- en: Next, get the length of the name ➋ to use as a limit in the while loop. This
    will let you know when the anagram phrase has used all the letters in the name
    and it’s time to end the loop. Do this outside the while loop to ensure you are
    using the full initial name. Then assign a variable to hold the anagram phrase
    and set a running variable to True to control the while loop.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，获取名称的长度 ➋，将其作为while循环的限制条件。这可以让你知道，当字谜短语使用完所有名称中的字母时，是时候结束循环了。将这一操作放在while循环外，以确保你使用的是完整的初始名称。然后，分配一个变量来保存字谜短语，并将一个运行变量设置为True，以控制while循环。
- en: Now begins the big loop that lets you iterate over the name and build an anagram
    phrase ➌. First, prepare a string to hold the growing phrase and strip it of whitespace
    ➍. Spaces will count as letters and throw off the operator when the length of
    the phrase is compared to the limit variable. Next, make the comparison, and if
    the length of the phrase is less than the limit, display the current length of
    the phrase as a prelude to engaging with the user ➎.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始一个大循环，允许你遍历名称并构建字谜短语 ➌。首先，准备一个字符串来保存正在增长的短语，并去除其中的空格 ➍。空格会被算作字母，在与限制变量比较短语长度时会干扰操作。接下来，进行比较，如果短语的长度小于限制，则显示当前短语的长度，作为与用户互动的前奏
    ➎。
- en: It’s time to put the other functions to work. Call find_anagrams() ➏ and pass
    it the name and dictionary file to get the list of anagrams in the name. At the
    bottom of the displayed list, show the user the current phrase. Use the print()
    function’s end parameter to display two print statements on the same line. This
    way, you can use a red font on the phrase in the IDLE window to distinguish it
    from all the other information in the display.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让其他函数开始工作了。调用find_anagrams() ➏并传入名称和字典文件，以获取名称中的字谜列表。在显示的列表底部，向用户展示当前的短语。使用print()函数的end参数，将两个打印语句显示在同一行。这样，你可以在IDLE窗口中使用红色字体显示短语，以便与显示中的其他信息区分开来。
- en: Next, call the process_choice() function ➐ to get the user’s word choice and
    add it to the growing anagram phrase. This also gets the updated version of the
    name variable so that the program can use it again in the while loop in the event
    that the phrase isn’t complete.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用process_choice()函数 ➐来获取用户的单词选择，并将其添加到正在增长的字谜短语中。这还会获取更新后的名称变量，以便程序在while循环中再次使用它，如果短语未完成的话。
- en: If the length of the phrase is equal to the limit variable ➑, the name anagram
    is complete. Let the user know they’re finished and present the phrase using red
    font. Note that you don’t have a conditional for the length of the phrase being
    greater than the limit variable. That’s because the process_choice() function
    is already handling this outcome (choosing more letters than are available would
    not pass the validation criterion).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果短语的长度等于限制变量 ➑，则字谜完成。告知用户他们已经完成，并以红色字体展示该短语。注意，你没有为短语长度大于限制变量设置条件。因为process_choice()函数已经处理了这个结果（选择比可用字母更多的字母将不符合验证标准）。
- en: The main() function ends by asking the user whether they want to try again.
    If they type n, the program ends; if they press ENTER, the main() function is
    called again ➒. As stated earlier, the only way for the user to change the initial
    name is to exit and relaunch the program.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: main()函数的结尾会询问用户是否想再试一次。如果他们输入n，程序结束；如果他们按下ENTER键，main()函数将再次被调用 ➒。如前所述，用户唯一改变初始名称的方式是退出并重新启动程序。
- en: Outside of the main() function, end with the standard two lines for calling
    the main() function when the program is not imported as a module ➓.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在main()函数之外，当程序没有作为模块导入时，使用标准的两行代码来调用main()函数 ➓。
- en: '**Running an Example Session**'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行示例会话**'
- en: In this section, I’ve included an example interactive session, using *phrase_anagrams.py*
    and the name *Bill Bo*. Bold font indicates user input, and italic bold font indicates
    where red font is used in the display.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我提供了一个示例互动会话，使用*phrase_anagrams.py*和名字*Bill Bo*。粗体表示用户输入，斜体粗体表示显示中使用红色字体的部分。
- en: 'Enter a name: Bill Bo'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个名字：Bill Bo
- en: Length of anagram phrase = 0
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 字谜短语长度 = 0
- en: bib
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: bib
- en: bill
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: bill
- en: blob
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: blob
- en: bob
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: bob
- en: boil
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: boil
- en: boll
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: boll
- en: i
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: i
- en: ill
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ill
- en: lib
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: lib
- en: lilo
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: lilo
- en: lo
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: lo
- en: lob
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: lob
- en: oi
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: oi
- en: oil
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: oil
- en: Remaining letters = billbo
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余字母 = billbo
- en: Number of remaining letters = 6
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余字母数量 = 6
- en: Number of remaining (real word) anagrams = 14
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的（真实单词）字谜数量 = 14
- en: Current anagram phrase =
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当前字谜短语 =
- en: 'Make a choice else Enter to start over or # to end: ill'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '请选择，否则按 Enter 重新开始，或按 # 结束：ill'
- en: Length of anagram phrase = 3
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 字谜短语长度 = 3
- en: bob
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: bob
- en: Remaining letters = bbo
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余字母 = bbo
- en: Number of remaining letters = 3
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余字母数量 = 3
- en: Number of remaining (real word) anagrams = 1
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的（真实单词）字谜数量 = 1
- en: Current anagram phrase = ill
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当前字谜短语 = ill
- en: 'Make a choice else Enter to start over or # to end: Bob'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '请选择，否则按 Enter 重新开始，或按 # 结束：Bob'
- en: '***** FINISHED!!! *****'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '***** 完成！！！ *****'
- en: Anagram of name = ill Bob
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 名字的字谜 = ill Bob
- en: Try again? (Press Enter else "n" to quit)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次？（按 Enter，否则按“n”退出）
- en: The number of anagrams found depends on the dictionary file you use. If you’re
    having a hard time building anagram phrases, try using a larger dictionary.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 找到的字谜数量取决于你使用的词典文件。如果你很难构建字谜短语，试着使用一个更大的词典。
- en: '**Project #6: Finding Voldemort: The Gallic Gambit**'
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #6：寻找伏地魔：高卢策略**'
- en: Did you ever wonder how Tom Riddle came up with the anagram “I am Lord Voldemort”?
    Did he put quill to parchment or just wave a wand? Could the magic of Python have
    helped?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有想过汤姆·里德尔是怎么想到字谜“I am Lord Voldemort”的？他是不是拿起羽毛笔写在羊皮纸上，或者只是挥动魔杖？Python的魔力是不是也帮了忙？
- en: Let’s pretend for a moment that you’re the professor of computer wizardry at
    Hogwarts, and Tom Riddle, school prefect and model student, has come to you for
    help. Using your *phrase_anagrams.py* spell from the previous section, he could
    find *I am Lord* in the very first list of anagrams, much to his delight. But
    the remaining letters, *tmvoordle*, yield only trivial words like *dolt*, *drool*,
    *looter*, and *lover*. Riddle would not be pleased.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是霍格沃茨的计算机魔法学教授，汤姆·里德尔，学校的学生会长和模范生，来找你求助。利用你在上一节中使用的*phrase_anagrams.py*咒语，他可以在第一个字谜列表中找到*I
    am Lord*，这让他非常高兴。但剩下的字母，*tmvoordle*，只会得到像*dolt*、*drool*、*looter*和*lover*这样的无聊单词。里德尔可不高兴。
- en: 'In hindsight, the problem is apparent: *Voldemort* is French and won’t be found
    in any English dictionary file. *Vol de la mort* means “flight of death” in French,
    so Voldemort is loosely “death flight.” But Riddle is 100 percent English, and
    so far, you have been working with English. Without reverse engineering, you have
    no more reason to suddenly switch out your English dictionary for a French one
    than you have to use Dutch, German, Italian, or Spanish.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 回过头来看，问题就很明显了：*Voldemort*是法语词，不会出现在任何英文词典文件中。*Vol de la mort*在法语中意味着“死亡之翼”，所以Voldemort大致可以理解为“死亡飞行”。但里德尔是百分之百的英国人，到目前为止，你一直在使用英语。除非进行逆向工程，否则你没有理由突然用法语词典替换你的英语词典，就像你没有理由用荷兰语、德语、意大利语或西班牙语一样。
- en: 'You *could* try randomly shuffling the remaining letters and seeing what falls
    out. Unfortunately, the number of possible combinations is the factorial of the
    number of letters divided by the factorial of the number of repeats (*o* occurs
    twice): 9! / 2! = 181,440\. If you were to scroll through all those permutations,
    taking only one second to review each, it would take you over two days to complete
    the list! And if you asked Tom Riddle to do this, he would probably use you to
    make a horcrux!'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你*可以*尝试随机打乱剩余字母，看看会得到什么。不幸的是，可能的组合数量是字母数的阶乘除以重复字母的阶乘（*o*出现了两次）：9! / 2! = 181,440。如果你要浏览所有这些排列，每次查看一秒钟，完成整个列表将需要超过两天！如果你让汤姆·里德尔来做这件事，他可能会用你来做分灵体！
- en: At this point, I would like to explore two logical paths ahead. One I call the
    “Gallic Gambit” and the other the “British Brute-Force.” We’ll look at the first
    one here and the second one in the next section.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我想探索两个逻辑路径。一个我称之为“高卢策略”，另一个是“英国蛮力法”。我们将在这里看看第一个，第二个将在下一节中探讨。
- en: '**NOTE**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Marvolo *is clearly a* fabricated word *used to make the Voldemort anagram work.
    J.K. Rowling could have gained additional latitude by using* Thomas *for* Tom
    *or by leaving off the* Lord *or* I am *parts. Tricks like these are used when
    the book is translated into non-English languages. In some languages, one or both
    names may need to be changed. In French, the anagram is “I am Voldemort.” In Norwegian,
    “Voldemort the Great.” In Dutch, “My name is Voldemort.” In others, like Chinese,
    the anagram can’t be used at all!*
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Marvolo *显然是一个* 编造的词 *用于使伏地魔的变音起作用。J.K.罗琳本可以通过使用* Thomas *代替* Tom *或去掉* Lord
    *或* I am *部分来获得更多的自由度。类似的技巧通常在书籍翻译成非英语语言时使用。在某些语言中，可能需要更改一个或两个名字。在法语中，变音是“我是伏地魔”。在挪威语中，是“伟大的伏地魔”。在荷兰语中，“我的名字是伏地魔”。在其他语言中，如中文，根本无法使用这个变音！*
- en: 'Tom Riddle was obsessed with beating death, and if you go looking for death
    in *tmvoordle*, you will find both the old French *morte* (as in the famous book
    *Le Morte d’Arthur* by Sir Thomas Malory) and the modern French *mort*. Removing
    *mort* leaves *vodle*, five letters with a very manageable number of permutations.
    In fact, you can easily find *volde* right in the interpreter window:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Tom Riddle 对战胜死亡充满痴迷，如果你在 *tmvoordle* 中寻找死亡，你将找到古老的法语 *morte*（如在托马斯·马洛里的名著《亚瑟王之死》中）和现代法语
    *mort*。去掉 *mort* 就剩下 *vodle*，五个字母排列的组合数非常可控。事实上，你可以在解释器窗口中轻松找到 *volde*：
- en: ➊ >>> from itertools import permutations
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> from itertools import permutations
- en: '>>> name = ''vodle'''
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> name = ''vodle'''
- en: ➋ >>> perms = [''.join(i) for i in permutations(name)]
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> perms = [''.join(i) for i in permutations(name)]
- en: ➌ >>> print(len(perms))
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> print(len(perms))
- en: '120'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '120'
- en: ➍ >>> print(perms)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ >>> print(perms)
- en: '[''vodle'', ''vodel'', ''volde'', ''voled'', ''voedl'', ''voeld'', ''vdole'',
    ''vdoel'','
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[''vodle'', ''vodel'', ''volde'', ''voled'', ''voedl'', ''voeld'', ''vdole'',
    ''vdoel'','
- en: '''vdloe'', ''vdleo'', ''vdeol'', ''vdelo'', ''vlode'', ''vloed'', ''vldoe'',
    ''vldeo'','
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '''vdloe'', ''vdleo'', ''vdeol'', ''vdelo'', ''vlode'', ''vloed'', ''vldoe'',
    ''vldeo'','
- en: '''vleod'', ''vledo'', ''veodl'', ''veold'', ''vedol'', ''vedlo'', ''velod'',
    ''veldo'','
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '''vleod'', ''vledo'', ''veodl'', ''veold'', ''vedol'', ''vedlo'', ''velod'',
    ''veldo'','
- en: '''ovdle'', ''ovdel'', ''ovlde'', ''ovled'', ''ovedl'', ''oveld'', ''odvle'',
    ''odvel'','
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '''ovdle'', ''ovdel'', ''ovlde'', ''ovled'', ''ovedl'', ''oveld'', ''odvle'',
    ''odvel'','
- en: '''odlve'', ''odlev'', ''odevl'', ''odelv'', ''olvde'', ''olved'', ''oldve'',
    ''oldev'','
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '''odlve'', ''odlev'', ''odevl'', ''odelv'', ''olvde'', ''olved'', ''oldve'',
    ''oldev'','
- en: '''olevd'', ''oledv'', ''oevdl'', ''oevld'', ''oedvl'', ''oedlv'', ''oelvd'',
    ''oeldv'','
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '''olevd'', ''oledv'', ''oevdl'', ''oevld'', ''oedvl'', ''oedlv'', ''oelvd'',
    ''oeldv'','
- en: '''dvole'', ''dvoel'', ''dvloe'', ''dvleo'', ''dveol'', ''dvelo'', ''dovle'',
    ''dovel'','
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '''dvole'', ''dvoel'', ''dvloe'', ''dvleo'', ''dveol'', ''dvelo'', ''dovle'',
    ''dovel'','
- en: '''dolve'', ''dolev'', ''doevl'', ''doelv'', ''dlvoe'', ''dlveo'', ''dlove'',
    ''dloev'','
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '''dolve'', ''dolev'', ''doevl'', ''doelv'', ''dlvoe'', ''dlveo'', ''dlove'',
    ''dloev'','
- en: '''dlevo'', ''dleov'', ''devol'', ''devlo'', ''deovl'', ''deolv'', ''delvo'',
    ''delov'','
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '''dlevo'', ''dleov'', ''devol'', ''devlo'', ''deovl'', ''deolv'', ''delvo'',
    ''delov'','
- en: '''lvode'', ''lvoed'', ''lvdoe'', ''lvdeo'', ''lveod'', ''lvedo'', ''lovde'',
    ''loved'','
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '''lvode'', ''lvoed'', ''lvdoe'', ''lvdeo'', ''lveod'', ''lvedo'', ''lovde'',
    ''loved'','
- en: '''lodve'', ''lodev'', ''loevd'', ''loedv'', ''ldvoe'', ''ldveo'', ''ldove'',
    ''ldoev'','
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '''lodve'', ''lodev'', ''loevd'', ''loedv'', ''ldvoe'', ''ldveo'', ''ldove'',
    ''ldoev'','
- en: '''ldevo'', ''ldeov'', ''levod'', ''levdo'', ''leovd'', ''leodv'', ''ledvo'',
    ''ledov'','
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '''ldevo'', ''ldeov'', ''levod'', ''levdo'', ''leovd'', ''leodv'', ''ledvo'',
    ''ledov'','
- en: '''evodl'', ''evold'', ''evdol'', ''evdlo'', ''evlod'', ''evldo'', ''eovdl'',
    ''eovld'','
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '''evodl'', ''evold'', ''evdol'', ''evdlo'', ''evlod'', ''evldo'', ''eovdl'',
    ''eovld'','
- en: '''eodvl'', ''eodlv'', ''eolvd'', ''eoldv'', ''edvol'', ''edvlo'', ''edovl'',
    ''edolv'','
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '''eodvl'', ''eodlv'', ''eolvd'', ''eoldv'', ''edvol'', ''edvlo'', ''edovl'',
    ''edolv'','
- en: '''edlvo'', ''edlov'', ''elvod'', ''elvdo'', ''elovd'', ''elodv'', ''eldvo'',
    ''eldov'']'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '''edlvo'', ''edlov'', ''elvod'', ''elvdo'', ''elovd'', ''elodv'', ''eldvo'',
    ''eldov'']'
- en: '>>>'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: ➎ >>> print(*perms, sep='\n')
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ >>> print(*perms, sep='\n')
- en: vodle
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: vodle
- en: vodel
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: vodel
- en: volde
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: volde
- en: voled
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: voled
- en: voedl
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: voedl
- en: --snip--
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: Start by importing permutations from itertools ➊. The itertools module is a
    group of functions in the Python Standard Library that create iterators for efficient
    looping. You generally think of permutations of *numbers*, but the itertools version
    works on *elements* in an iterable, which includes letters.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从 itertools ➊ 导入 permutations。itertools 模块是 Python 标准库中的一组函数，用于创建高效循环的迭代器。你通常会想到数字的排列，但
    itertools 版本适用于可迭代对象中的*元素*，其中包括字母。
- en: After entering the name or, in this case, the remaining letters in the name,
    use list comprehension to create a list of permutations of the name ➋. Join each
    element in a permutation so each item in the final list will be a unique permutation
    of *vodle*. Using join yields the new name as an element, 'vodle', versus a hard-to-read
    tuple of single-character elements,('v', 'o', 'd', 'l', 'e').
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入名字或在这个案例中，名字中剩余的字母后，使用列表推导式来创建名字的排列列表 ➋。通过连接排列中的每个元素，这样最终列表中的每个项目将是 *vodle*
    的一个唯一排列。使用 join 生成的新名字元素是 'vodle'，而不是一个难以阅读的包含单个字符的元组（'v', 'o', 'd', 'l', 'e'）。
- en: Get the length of the permutations as a check; that way, you can confirm that
    it is, indeed, the factorial of 5 ➌. At the end, no matter how you print it ➍➎,
    *volde* is easy to find.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 获取排列的长度作为检查；这样，你可以确认它确实是5的阶乘 ➌。最后，无论你如何打印 ➍➎，*volde* 都容易找到。
- en: '**Project #7: Finding Voldemort: The British Brute-Force**'
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #7：寻找Voldemort：英国的暴力破解法**'
- en: Now let’s assume Tom Riddle is bad at anagrams (or French). He doesn’t recognize
    *mort* or *morte*, and you’re back to shuffling the remaining nine letters thousands
    and thousands of times, looking for a combination of letters that he would find
    pleasing.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设Tom Riddle不擅长解字谜（或法语）。他不认识*mort*或*morte*，于是你又得将剩下的九个字母进行数千次、数万次的排列，寻找一个他会喜欢的字母组合。
- en: On the bright side, this is a more interesting problem programmatically than
    the interactive solution you just saw. You just need to whittle down all the permutations
    using some form of filtering.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，从编程的角度来看，这比你刚刚看到的交互式解决方案要有趣得多。你只需要使用某种形式的过滤器，将所有排列过滤掉。
- en: '**THE OBJECTIVE**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Reduce the number of anagrams of *tmvoordle* to a manageable number that will
    still contain *Voldemort*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将*tmvoordle*的字谜数量减少到一个可管理的数字，仍然包含*Voldemort*。
- en: '***Strategy***'
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: Per the *Oxford English Dictionary, 2nd Edition*, there are 171,476 English
    words currently in use, which is fewer than the total number of permutations in
    *tmvoordle*! Regardless of the language, you can surmise that most of the anagrams
    generated by the permutations() function are nonsense.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*牛津英语词典第二版*，目前使用中的英语单词有171,476个，远少于*tmvoordle*中的排列总数！无论哪种语言，你都可以推测，*permutations()*函数生成的大多数字谜组合都是无意义的。
- en: 'With *cryptography*, the science of codes and ciphers, you can safely eliminate
    many useless, unpronounceable combinations, such as *ldtmvroeo*, and you won’t
    even have to inspect them visually. Cryptographers have long studied languages
    and compiled statistics on recurring patterns of words and letters. We can use
    many cryptanalytical techniques for this project, but let’s focus on three: consonant-vowel
    mapping, trigram frequency, and digram frequency.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*密码学*，即研究编码和密码的科学，你可以安全地排除许多无用的、难以发音的组合，比如*ldtmvroeo*，而且你甚至不需要目视检查它们。密码学家长期研究语言，并汇编了关于单词和字母重复模式的统计数据。我们可以在这个项目中使用许多密码分析技术，但让我们集中讨论三种：辅音-元音映射、三元组频率和二元组频率。
- en: '**Filtering with Consonant-Vowel Mapping**'
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过辅音-元音映射过滤**'
- en: A *consonant-vowel map* (*c-v map*) simply replaces the letters in a word with
    a *c* or a *v*, as appropriate. *Riddle*, for example, becomes *cvcccv*. You can
    write a program that goes through a dictionary file and creates c-v maps for each
    word. By default, impossible combinations, like *ccccccvvv*, will be excluded.
    You can further exclude membership by removing words with c-v maps that are *possible*
    but that have a low frequency of occurrence.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*辅音-元音映射*（*c-v映射*）简单地用*c*或*v*替换单词中的字母。例如，*Riddle*变成*cvcccv*。你可以编写一个程序，遍历字典文件，并为每个单词创建c-v映射。默认情况下，不可能的组合（如*ccccccvvv*）会被排除。你还可以通过移除那些*可能*但出现频率低的字词的c-v映射来进一步排除成员。'
- en: C-v maps are fairly inclusive, but that’s good. An option for *Riddle* at this
    point is to make up a new proper name, and proper names don’t have to be words
    that occur in a dictionary. So you don’t want to be *too* exclusive early in the
    process.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 辅音-元音映射相对全面，但这很好。此时，*Riddle* 的一个选项是创造一个新的专有名词，专有名词不一定是字典中的词。因此，你不希望在过程的早期就排除得*太*严格。
- en: '**Filtering with Trigrams**'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通过三元组过滤**'
- en: Since the initial filter needs a relatively wide aperture, you’ll need to filter
    again at a lower level to safely remove more anagrams from the permutations. *Trigrams*
    are triplets comprising three consecutive letters. It should come as no surprise
    that the most common trigram in English is the word *the*, followed closely by
    *and* and *ing*. At the other end of the scale are trigrams like *zvq*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 由于初步过滤需要一个相对较宽的筛选范围，因此你需要在较低层次上再次进行过滤，以安全地去除更多来自排列的字谜。*三元组*是由三个连续字母组成的三重组合。毫不奇怪，英语中最常见的三元组是单词*the*，紧随其后的是*and*和*ing*。另一端的三元组则是像*zvq*这样的组合。
- en: You can find statistics on the frequency of occurrence of trigrams online at
    sites like *[http://norvig.com/ngrams/count_3l.txt](http://norvig.com/ngrams/count_3l.txt)*.
    For any group of letters, like *tmvoordle*, you can generate and use a list of
    the least common trigrams to further reduce the number of permutations. For this
    project, you can use the *least-likely_trigrams.txt* file, downloadable from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    This text file contains the trigrams in *tmvoordle* that occur in the bottom 10
    percent of trigrams in the English language, based on frequency of occurrence.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在像 *[http://norvig.com/ngrams/count_3l.txt](http://norvig.com/ngrams/count_3l.txt)*
    这样的网站上找到三元组出现频率的统计数据。对于任何字母组合，比如 *tmvoordle*，你可以生成并使用一个最不常见的三元组列表来进一步减少排列的数量。对于这个项目，你可以使用
    *least-likely_trigrams.txt* 文件，下载地址是 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。这个文本文件包含了
    *tmvoordle* 中出现频率排名在英语中最低10%的三元组。
- en: '**Filtering with Digrams**'
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用二元组进行过滤**'
- en: '*Digrams* (also called *bigrams*) are letter pairs. Commonly occurring digrams
    in English include *an*, *st*, and *er*. On the other hand, you rarely see pairs
    like *kg*, *vl*, or *oq*. You can find statistics on the frequency of occurrence
    of digrams at websites such as *[https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html](https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html)*
    and *[http://practicalcryptography.com/](http://practicalcryptography.com/)*.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*二元组*（也叫 *大二元组*）是字母对。在英语中常见的二元组包括 *an*、*st* 和 *er*。而像 *kg*、*vl* 或 *oq* 这样的组合则很少见。你可以在像
    *[https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html](https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html)*
    和 *[http://practicalcryptography.com/](http://practicalcryptography.com/)* 这样的网站上找到二元组出现频率的统计数据。'
- en: '[Table 3-1](ch03.xhtml#ch03tab1) was built from the *tmvoordle* collection
    of letters and a 60,000-word English dictionary file. The letters along the left
    side of the chart are the starting letters for the digrams; those along the top
    represent the end letter. For example, to find *vo*, start with the *v* on the
    left and read across to the column beneath the *o*. For the digrams found in *tmvoordle*,
    *vo* occurs only 0.8 percent of the time.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](ch03.xhtml#ch03tab1) 是从 *tmvoordle* 字母组合和一个60,000词的英语词典文件构建的。图表左侧的字母代表二元组的起始字母，而顶部的字母则代表结束字母。例如，要查找
    *vo*，从左侧的 *v* 开始，然后读取位于 *o* 下面的列。对于 *tmvoordle* 中的二元组，*vo* 的出现频率仅为0.8%。'
- en: '**Table 3-1:** Relative Frequency of Digrams from the Letters *tmvoordle* in
    a 60,000-Word Dictionary (Black Squares Indicate No Occurrences)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 来自 *tmvoordle* 字母组合在60,000词字典中的二元组相对频率（黑色方块表示没有出现）'
- en: '|  | **d** | **e** | **l** | **m** | **o** | **r** | **t** | **v** |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|  | **d** | **e** | **l** | **m** | **o** | **r** | **t** | **v** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **d** |  | 3.5% | 0.5% | 0.1% | 1.7% | 0.5% | 0.0% | 0.1% |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **d** |  | 3.5% | 0.5% | 0.1% | 1.7% | 0.5% | 0.0% | 0.1% |'
- en: '| **e** | 6.6% |  | 2.3% | 1.4% | 0.7% | 8.9% | 2.0% | 0.6% |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **e** | 6.6% |  | 2.3% | 1.4% | 0.7% | 8.9% | 2.0% | 0.6% |'
- en: '| **l** | 0.4% | 4.4% |  | 0.1% | 4.2% | 0.0% | 0.4% | 0.1% |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **l** | 0.4% | 4.4% |  | 0.1% | 4.2% | 0.0% | 0.4% | 0.1% |'
- en: '| **m** | 0.0% | 2.2% | 0.0% |  | 2.8% | 0.0% | 0.0% | 0.0% |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **m** | 0.0% | 2.2% | 0.0% |  | 2.8% | 0.0% | 0.0% | 0.0% |'
- en: '| **o** | 1.5% | 0.5% | 3.7% | 3.2% | 5.3% | 7.1% | 2.4% | 1.4% |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **o** | 1.5% | 0.5% | 3.7% | 3.2% | 5.3% | 7.1% | 2.4% | 1.4% |'
- en: '| **r** | 0.9% | 6.0% | 0.4% | 0.7% | 5.7% |  | 1.3% | 0.3% |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **r** | 0.9% | 6.0% | 0.4% | 0.7% | 5.7% |  | 1.3% | 0.3% |'
- en: '| **t** | 0.0% | 6.2% | 0.6% | 0.1% | 3.6% | 2.3% |  | 0.0% |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| **t** | 0.0% | 6.2% | 0.6% | 0.1% | 3.6% | 2.3% |  | 0.0% |'
- en: '| **v** | 0.0% | 2.5% | 0.0% | 0.0% | 0.8% | 0.0% | 0.0% |  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| **v** | 0.0% | 2.5% | 0.0% | 0.0% | 0.8% | 0.0% | 0.0% |  |'
- en: Assuming you’re looking for “English-like” letter combinations, you can use
    frequency maps like this to exclude letter pairs that are unlikely to occur. Think
    of it as a “digram sieve” that lets only the unshaded squares pass.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在寻找“类似英语”的字母组合，你可以使用像这样的频率图来排除不太可能出现的字母对。可以将其视为一个“二元组筛网”，只允许未被遮挡的方格通过。
- en: To be safe, just exclude digrams that occur less than 0.1 percent of the time.
    I’ve shaded these in black. Notice that it would be very easy to eliminate the
    required *vo* pairing in *Voldemort*, if you cut too close to the bone!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，只排除那些出现频率低于0.1%的二元组。我已将这些用黑色遮罩标出。注意，如果你削减得太严格，可能会轻易排除掉 *Voldemort* 中所需的
    *vo* 字母组合！
- en: You can design your filter to be even more selective by tagging digrams that
    are unlikely to occur at the start of a word. For example, while it’s not unusual
    for the digram *lm* to occur *within* a word (as in *almanac* and *balmy*), you’ll
    need a lot of luck finding a word that *starts* with *lm*. You don’t need cryptography
    to find these digrams; just try to pronounce them! Some starting-point choices
    for these are shaded gray in [Table 3-2](ch03.xhtml#ch03tab2).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过标记那些不太可能出现在单词开头的二元组来使过滤器更具选择性。例如，虽然 *lm* 这一二元组在单词中出现（如 *almanac* 和 *balmy*）并不罕见，但你需要相当大的运气才能找到一个以
    *lm* 开头的单词。你无需依赖密码学来识别这些二元组；只需尝试发音即可！这些起始点的选择在 [表 3-2](ch03.xhtml#ch03tab2) 中以灰色阴影显示。
- en: '**Table 3-2:** Update of [Table 3-1](ch03.xhtml#ch03tab1), Where Gray-Shaded
    Squares Indicate Digrams Unlikely to Occur at the Start of a Word'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-2：** 更新版 [表 3-1](ch03.xhtml#ch03tab1)，灰色阴影方块表示不太可能出现在单词开头的二元组'
- en: '|  | **d** | **e** | **l** | **m** | **o** | **r** | **t** | **v** |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|  | **d** | **e** | **l** | **m** | **o** | **r** | **t** | **v** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **d** |  | 3.5% | 0.5% | 0.1% | 1.7% | 0.5% | 0.0% | 0.1% |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| **d** |  | 3.5% | 0.5% | 0.1% | 1.7% | 0.5% | 0.0% | 0.1% |'
- en: '| **e** | 6.6% |  | 2.3% | 1.4% | 0.7% | 8.9% | 2.0% | 0.6% |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| **e** | 6.6% |  | 2.3% | 1.4% | 0.7% | 8.9% | 2.0% | 0.6% |'
- en: '| **l** | 0.4% | 4.4% |  | 0.1% | 4.2% | 0.0% | 0.4% | 0.1% |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| **l** | 0.4% | 4.4% |  | 0.1% | 4.2% | 0.0% | 0.4% | 0.1% |'
- en: '| **m** | 0.0% | 2.2% | 0.0% |  | 2.8% | 0.0% | 0.0% | 0.0% |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| **m** | 0.0% | 2.2% | 0.0% |  | 2.8% | 0.0% | 0.0% | 0.0% |'
- en: '| **o** | 1.5% | 0.5% | 3.7% | 3.2% | 5.3% | 7.1% | 2.4% | 1.4% |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| **o** | 1.5% | 0.5% | 3.7% | 3.2% | 5.3% | 7.1% | 2.4% | 1.4% |'
- en: '| **r** | 0.9% | 6.0% | 0.4% | 0.7% | 5.7% |  | 1.3% | 0.3% |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| **r** | 0.9% | 6.0% | 0.4% | 0.7% | 5.7% |  | 1.3% | 0.3% |'
- en: '| **t** | 0.0% | 6.2% | 0.6% | 0.1% | 3.6% | 2.3% |  | 0.0% |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| **t** | 0.0% | 6.2% | 0.6% | 0.1% | 3.6% | 2.3% |  | 0.0% |'
- en: '| **v** | 0.0% | 2.5% | 0.0% | 0.0% | 0.8% | 0.0% | 0.0% |  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| **v** | 0.0% | 2.5% | 0.0% | 0.0% | 0.8% | 0.0% | 0.0% |  |'
- en: 'You now have three filters you can use on the 181,440 permutations of *tmvoordle*:
    c-v maps, trigrams, and digrams. As a final filter, you should give the user the
    option of viewing only anagrams that start with a given letter. This will let
    the user divide the remaining anagrams into more manageable “chunks,” or focus
    on the more intimidating-sounding anagrams, like those that begin with *v*!'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有三个可以用于 181,440 种 *tmvoordle* 排列组合的过滤器：c-v 映射、三元组和二元组。作为最终过滤器，你应该给用户提供仅查看以给定字母开头的字谜的选项。这将使用户能够将剩余的字谜分成更易管理的“块”，或者专注于那些听起来更具挑战性的字谜，比如那些以
    *v* 开头的字谜。
- en: '***The British Brute-Force Code***'
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***英国式暴力破解代码***'
- en: The upcoming code generates permutations of *tmvoordle* and passes them through
    the filters just described. It then gives the user the option to view either all
    the permutations or only those starting with a given letter.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 即将呈现的代码生成 *tmvoordle* 的排列组合，并通过刚才描述的过滤器。然后，它为用户提供选择，可以查看所有排列组合，或者仅查看以给定字母开头的排列组合。
- en: You can download all the programs you’ll need from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    The code in this section is one script named *voldemort_british.py*. You’ll also
    need the *load_dictionary.py* program in the same folder, along with the same
    dictionary file you used for the projects earlier in this chapter. Finally, you’ll
    need a new file named *least-likely_trigrams.txt*, a text file of trigrams with
    a low frequency of occurrence in English. Download all these files into the same
    folder.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载所有需要的程序。该章节中的代码是一个名为 *voldemort_british.py* 的脚本。你还需要同一文件夹中的 *load_dictionary.py*
    程序，以及本章之前项目中使用的相同字典文件。最后，你还需要一个名为 *least-likely_trigrams.txt* 的新文件，这是一个包含低频三元组的文本文件。将这些文件都下载到同一文件夹中。
- en: '**Defining the main() Function**'
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义 main() 函数**'
- en: '[Listing 3-5](ch03.xhtml#ch03list5) imports the modules that *voldemort_british.py*
    needs and defines its main() function. In the *phrase_anagrams.py* program, you
    defined the main() function at the end of the code. Here we put it at the start.
    The advantage is that you can see what the function is doing—how it’s running
    the program—from the start. The disadvantage is that you don’t know what any of
    the helper functions do yet.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-5](ch03.xhtml#ch03list5) 导入了 *voldemort_british.py* 需要的模块，并定义了其 main()
    函数。在 *phrase_anagrams.py* 程序中，你将 main() 函数放在代码的最后。而在这里，我们将它放在了开始部分。这样做的好处是你可以从一开始就看到该函数的作用——它是如何运行程序的。缺点是你还不知道任何辅助函数的作用。'
- en: '*voldemort_british.py,* part 1'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*voldemort_british.py*，第 1 部分'
- en: ➊ import sys
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import sys
- en: from itertools import permutations
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: from itertools import permutations
- en: from collections import Counter
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: from collections import Counter
- en: import load_dictionary
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: import load_dictionary
- en: '➋ def main():'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def main():'
- en: '"""Load files, run filters, allow user to view anagrams by 1st letter."""'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '"""加载文件，运行过滤器，允许用户按首字母查看字谜。"""'
- en: ➌ name = 'tmvoordle'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ name = 'tmvoordle'
- en: name = name.lower()
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: name = name.lower()
- en: ➍ word_list_ini = load_dictionary.load('2of4brif.txt')
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ word_list_ini = load_dictionary.load('2of4brif.txt')
- en: trigrams_filtered = load_dictionary.load('least-likely_trigrams.txt')
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: trigrams_filtered = load_dictionary.load('least-likely_trigrams.txt')
- en: ➎ word_list = prep_words(name, word_list_ini)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ word_list = prep_words(name, word_list_ini)
- en: filtered_cv_map = cv_map_words(word_list)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: filtered_cv_map = cv_map_words(word_list)
- en: filter_1 = cv_map_filter(name, filtered_cv_map)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: filter_1 = cv_map_filter(name, filtered_cv_map)
- en: filter_2 = trigram_filter(filter_1, trigrams_filtered)
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: filter_2 = trigram_filter(filter_1, trigrams_filtered)
- en: filter_3 = letter_pair_filter(filter_2)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: filter_3 = letter_pair_filter(filter_2)
- en: view_by_letter(name, filter_3)
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: view_by_letter(name, filter_3)
- en: '*Listing 3-5: Imports modules and defines the* main() *function*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-5：导入模块并定义* main() *函数*'
- en: Start by importing modules you’ve used in the previous projects ➊. Now define
    the main() function ➋. The name variable is a string of the remaining letters
    *tmvoordle* ➌. Set it to lowercase to guard against a user input error. Next,
    use the load_dictionary module to load your dictionary file and the trigrams file
    as lists ➍. Your dictionary filename may be different from that shown.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入你在之前项目中使用过的模块 ➊。然后定义 main() 函数 ➋。name 变量是剩余字母的字符串 *tmvoordle* ➌。将其转换为小写，以防用户输入错误。接下来，使用
    load_dictionary 模块加载你的字典文件和三元组文件作为列表 ➍。你的字典文件名可能与此不同。
- en: Finally, call all the various functions in order ➎. I’ll describe each of these
    functions momentarily, but basically, you need to prepare the word list, prepare
    the c-v maps, apply the three filters, and let the user view all the anagrams
    at once or view a subset based on the anagram’s first letter.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照顺序调用所有不同的函数 ➎。稍后我会逐一描述这些函数，但基本上，你需要准备词汇列表、准备 c-v 映射、应用三个过滤器，并让用户查看所有的字谜，或者基于字谜的首字母查看部分字谜。
- en: '**Preparing the Word List**'
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**准备词汇列表**'
- en: '[Listing 3-6](ch03.xhtml#ch03list6) prepares the word list by including just
    the words that have as many letters as in the name variable (in this case, nine).
    You should also ensure that all the words are lowercase, to be consistent.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-6](ch03.xhtml#ch03list6)通过只包括与 name 变量（此例中为九个字母）长度相同的单词来准备词汇列表。你还应该确保所有单词都是小写，以保持一致性。'
- en: '*voldemort_british.py,* part 2'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*voldemort_british.py,* 第 2 部分'
- en: '➊ def prep_words(name, word_list_ini):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def prep_words(name, word_list_ini):'
- en: '"""Prep word list for finding anagrams."""'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '"""准备字词列表以寻找字谜。"""'
- en: ➋ print("length initial word_list = {}".format(len(word_list_ini)))
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ print("初始 word_list 长度 = {}".format(len(word_list_ini)))
- en: len_name = len(name)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: len_name = len(name)
- en: ➌ word_list = [word.lower() for word in word_list_ini
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ word_list = [word.lower() for word in word_list_ini]
- en: if len(word) == len_name]
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: if len(word) == len_name]
- en: ➍ print("length of new word_list = {}".format(len(word_list)))
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ print("新 word_list 长度 = {}".format(len(word_list)))
- en: ➎ return word_list
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ return word_list
- en: '*Listing 3-6: Creates lists of words that are equal in length to the* name
    *variable*'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-6：创建与* name *变量长度相等的单词列表*'
- en: Define the prep_words() function to take a name string and list of dictionary
    words as arguments ➊. I suggest that you print the lengths of your various word
    lists before and after they’ve gone through a filter; that way, you can track
    how much impact the filters are having. So print the length of the dictionary
    ➋. Assign a variable to hold the length of the name and then use list comprehension
    to create a new list by looping through the words in word_list_ini, keeping those
    whose length is the same as the number of letters in name, and converting them
    to lowercase ➌. Next, print the length of this new word list ➍, and finally, return
    this new list for use in the next function ➎.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 prep_words() 函数，接受 name 字符串和字典单词列表作为参数 ➊。我建议在单词列表经过过滤前后打印它们的长度；这样你可以追踪过滤器的影响程度。所以，先打印字典的长度
    ➋。然后，定义一个变量来保存 name 的长度，并使用列表推导创建一个新列表，遍历 word_list_ini 中的单词，保留与 name 长度相同的单词，并将它们转换为小写
    ➌。接着，打印这个新词汇列表的长度 ➍，最后返回这个新列表供下一个函数使用 ➎。
- en: '**Generating the C-V Map**'
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成 C-V 映射**'
- en: You need to convert the prepared word list to a c-v map. Remember that you’re
    no longer interested in actual words in the dictionary; those have been reviewed
    and rejected. Your goal is to shuffle the remaining letters until they form something
    that resembles a proper noun.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将准备好的单词列表转换为一个 c-v 映射。记住，你不再关注字典中的实际单词；这些单词已经被审核并被拒绝。你的目标是将剩余的字母打乱，直到它们形成类似于专有名词的东西。
- en: '[Listing 3-7](ch03.xhtml#ch03list7) defines a function that generates c-v maps
    for each word in word_list. The program, *voldemort_british.py*, will use the
    c-v map to judge whether a shuffled letter combination is reasonable based on
    consonant-vowel patterns in the English language.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-7](ch03.xhtml#ch03list7) 定义了一个函数，该函数为 word_list 中的每个单词生成 c-v 映射。程序 *voldemort_british.py*
    将使用 c-v 映射来判断一个打乱的字母组合是否符合英语语言中辅音-元音的模式。'
- en: '*voldemort_british.py,* part 3'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*voldemort_british.py,* 第 3 部分'
- en: '➊ def cv_map_words(word_list):'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def cv_map_words(word_list):'
- en: '"""Map letters in words to consonants & vowels."""'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将单词中的字母映射到辅音和元音。"""'
- en: ➋ vowels = 'aeiouy'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ vowels = 'aeiouy'
- en: ➌ cv_mapped_words = []
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ cv_mapped_words = []
- en: '➍ for word in word_list:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ for word in word_list:'
- en: temp = ''
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: temp = ''
- en: 'for letter in word:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 'for letter in word:'
- en: 'if letter in vowels:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 'if letter in vowels:'
- en: temp += 'v'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: temp += 'v'
- en: 'else:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: temp += 'c'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: temp += 'c'
- en: cv_mapped_words.append(temp)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: cv_mapped_words.append(temp)
- en: '# determine number of UNIQUE c-v patterns'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '# 确定唯一 c-v 模式的数量'
- en: ➎ total = len(set(cv_mapped_words))
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ total = len(set(cv_mapped_words))
- en: '# target fraction to eliminate'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '# 需要消除的目标分数'
- en: ➏ target = 0.05
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ target = 0.05
- en: '# get number of items in target fraction'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取目标分数中的项数'
- en: ➐ n = int(total * target)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ n = int(total * target)
- en: ➑ count_pruned = Counter(cv_mapped_words).most_common(total - n)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ count_pruned = Counter(cv_mapped_words).most_common(total - n)
- en: ➒ filtered_cv_map = set()
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ filtered_cv_map = set()
- en: 'for pattern, count in count_pruned:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 'for pattern, count in count_pruned:'
- en: filtered_cv_map.add(pattern)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: filtered_cv_map.add(pattern)
- en: print("length filtered_cv_map = {}".format(len(filtered_cv_map)))
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: print("filtered_cv_map 的长度 = {}".format(len(filtered_cv_map)))
- en: ➓ return filtered_cv_map
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ➓ return filtered_cv_map
- en: '*Listing 3-7: Generates c-v maps from the words in* word_list'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-7：从* word_list *中的单词生成 c-v 映射*'
- en: Define the cv_map_words() function to take the prepped word list as an argument
    ➊. Since consonants and vowels form a binary system, you can define the vowels
    with a string ➋. Create an empty list to hold the maps ➌. Then loop through the
    words and the letters in each word, converting the letters to either a *c* or
    *v* ➍. Use a variable called temp to accumulate the map; then append it to the
    list. Note that temp is reinitialized each time the loop repeats.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 cv_map_words() 函数，将准备好的单词列表作为参数 ➊。由于辅音和元音构成了一个二元系统，你可以用一个字符串来定义元音 ➋。创建一个空列表来存放映射
    ➌。然后，遍历单词和每个单词中的字母，将字母转换为 *c* 或 *v* ➍。使用一个名为 temp 的变量来积累映射；然后将其添加到列表中。请注意，每次循环重复时，temp
    都会被重新初始化。
- en: You want to know the frequency of occurrence of a given c-v map pattern (for
    example, *cvcv*), so you can remove those with a low likelihood of occurrence.
    Before calculating the frequency, you need to collapse your list down to unique
    c-v maps—as it is now, *cvcv* may be repeated many, many times. So, turn the cv_mapped_words
    list into a set, to remove duplicates, and get its length ➎. Now you can define
    a target percentage to eliminate, using fractional values ➏. Start with a low
    number like 0.05—equivalent to 5 percent—so you’re less likely to eliminate anagrams
    that can form usable proper names. Multiply this target value by the total length
    of the cv_mapped_words set and assign the result to the variable n ➐. Be sure
    to convert n to an integer; since it will represent a count value, it can’t be
    a float.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道给定的 c-v 映射模式（例如，*cvcv*）的出现频率，以便你可以去除那些出现概率低的模式。在计算频率之前，你需要将列表折叠为唯一的 c-v
    映射——因为现在 *cvcv* 可能会重复多次。所以，将 cv_mapped_words 列表转换为集合，以去除重复项，并获取其长度 ➎。现在，你可以定义一个目标百分比来消除它们，使用分数值
    ➏。从一个小数字开始，比如 0.05——相当于 5%——这样你不太可能去除那些能形成可用专有名词的字谜。将这个目标值乘以 cv_mapped_words 集合的总长度，并将结果赋值给变量
    n ➐。确保将 n 转换为整数；因为它将表示一个计数值，不能是浮动数。
- en: The Counter module data type has a handy method, most_common(), that will return
    the most common items in a list based on a *count* value that you provide; in
    this case, that value will be the length of the c-v map list, total, minus n.
    The value you pass most_common() must be an integer. If you pass the most_common()
    function the length of the list, it will return all the items in the list. If
    you subtract the count for the least likely 5 percent, you will effectively eliminate
    these c-v maps from the list ➑.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: Counter模块的数据类型有一个方便的方法most_common()，它将根据你提供的*count*值返回列表中最常见的项；在这种情况下，这个值将是c-v映射列表的长度total减去n。你传给most_common()的值必须是一个整数。如果你传入列表的长度，它会返回列表中的所有项。如果你减去最不可能的5%的计数，你将有效地从列表中删除这些c-v映射
    ➑。
- en: Remember, Counter returns a dictionary, but all you need are the final c-v maps,
    not their associated frequency counts. So initialize an empty set called filtered-cv-map
    ➒ and loop through each key-value pair in count_pruned(), adding only the key
    to the new set. Print the length of this set, so you can see the impact of the
    filter. Then finish by returning the filtered c-v map for use in the next function
    ➓.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Counter返回一个字典，但你只需要最终的c-v映射，而不需要它们的关联频率计数。因此，初始化一个名为filtered-cv-map的空集合
    ➒，并遍历count_pruned()中的每个键值对，只将键添加到新集合中。打印此集合的长度，以便你查看过滤器的效果。然后通过返回过滤后的c-v映射以便在下一个函数中使用
    ➓。
- en: '**Defining the C-V Map Filter**'
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义C-V映射过滤器**'
- en: '[Listing 3-8](ch03.xhtml#ch03list8) applies the c-v map filter: anagrams are
    generated based on permutations of the letters in the name variable, and then
    the program converts them to c-v maps and compares those anagrams to the filtered
    c-v maps built with the cv_map_words() function. If an anagram’s c-v map is found
    in filtered_cv_map, then the program stores the anagram for the next filter.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[列出3-8](ch03.xhtml#ch03list8)应用了c-v映射过滤器：根据名称变量中字母的排列生成字谜，然后程序将其转换为c-v映射，并将这些字谜与使用cv_map_words()函数构建的过滤c-v映射进行比较。如果字谜的c-v映射在filtered_cv_map中找到，程序则将字谜存储以供下一个过滤器使用。'
- en: '*voldemort_british.py,* part 4'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '*voldemort_british.py*，第4部分'
- en: '➊ def cv_map_filter(name, filtered_cv_map):'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def cv_map_filter(name, filtered_cv_map):'
- en: '"""Remove permutations of words based on unlikely cons-vowel combos."""'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '"""根据不太可能的辅音-元音组合去除单词的排列。"""'
- en: ➋ perms = {''.join(i) for i in permutations(name)}
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ perms = {''.join(i) for i in permutations(name)}
- en: print("length of initial permutations set = {}".format(len(perms)))
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: print("初始排列集的长度 = {}".format(len(perms)))
- en: vowels = 'aeiouy'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: vowels = 'aeiouy'
- en: ➌ filter_1 = set()
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ filter_1 = set()
- en: '➍ for candidate in perms:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ for candidate in perms:'
- en: temp = ''
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: temp = ''
- en: 'for letter in candidate:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 'for letter in candidate:'
- en: 'if letter in vowels:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 'if letter in vowels:'
- en: temp += 'v'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: temp += 'v'
- en: 'else:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: temp += 'c'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: temp += 'c'
- en: '➎ if temp in filtered_cv_map:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ if temp in filtered_cv_map:'
- en: filter_1.add(candidate)
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: filter_1.add(candidate)
- en: print("# choices after filter_1 = {}".format(len(filter_1)))
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: print("# 过滤器1后的选择数量 = {}".format(len(filter_1)))
- en: ➏ return filter_1
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ return filter_1
- en: '*Listing 3-8: Defines* cv_map_filter() *function*'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出3-8：定义* cv_map_filter() *函数*'
- en: 'Define the function cv_map_filter() to take two arguments: the name, followed
    by the set of c-v maps returned by cv_map_words() ➊. Use set comprehension and
    the permutations module to generate the set of permutations ➋. I described this
    process in “[Project #6: Finding Voldemort: The Gallic Gambit](ch03.xhtml#lev65)”
    on [page 49](ch03.xhtml#page_49). Use a set here to permit later use of set operations,
    like taking the difference between two filter sets. This also removes duplicates,
    as permutations treats each *o* as a separate item, and returns 9!, rather than
    9! / 2!. Note that permutations considers *tmv**o**ordle* and *tmvo**o**rdle*
    different strings.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '定义函数cv_map_filter()，接受两个参数：名称，接着是cv_map_words()返回的c-v映射集 ➊。使用集合推导式和permutations模块生成排列集
    ➋。我在“[项目 #6: 找到伏地魔：高卢策略](ch03.xhtml#lev65)”的[第49页](ch03.xhtml#page_49)中描述了这个过程。在这里使用集合，以便后续可以进行集合操作，比如求两个过滤集之间的差集。这样也能去除重复项，因为permutations将每个*o*视为独立项，返回9!，而不是9!
    / 2!。请注意，permutations认为*tmv**o**ordle*和*tmvo**o**rdle*是不同的字符串。'
- en: 'Now initialize an empty set to hold the contents of the first filter ➌ and
    begin looping through the permutations ➍. Use the term *candidate*, as most of
    these aren’t words but just strings of random letters. For each candidate, loop
    through the letters and map them to a *c* or a *v*, as you did with the cv_words()
    function. Check each c-v map, temp, for membership in filtered_cv_map. This is
    one reason for using sets: membership checks are very fast. If the candidate meets
    the condition, add it to filter_1 ➎. Finish by returning your new anagram set
    ➏.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在初始化一个空集合来保存第一个过滤器的内容 ➌，并开始遍历排列 ➍。使用术语 *candidate*，因为这些大多数并不是单词，而只是随机字母的字符串。对于每个候选项，遍历字母并将它们映射为
    *c* 或 *v*，就像你在 cv_words() 函数中所做的那样。检查每个 c-v 映射，temp，是否存在于 filtered_cv_map 中。这就是使用集合的一个原因：成员检查非常快速。如果候选项符合条件，将其添加到
    filter_1 ➎。最后返回你新的变位集合 ➏。
- en: '**Defining the Trigram Filter**'
  id: totrans-471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义三元组过滤器**'
- en: '[Listing 3-9](ch03.xhtml#ch03list9) defines the trigram filter, which removes
    the permutations with unlikely three-letter triplets. It uses a text file derived
    from various cryptography websites that has been tailored to the letters in *tmvoordle*.
    This function will return only permutations that include one of these trigrams;
    the main() function will pass the new set to the next filter function.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-9](ch03.xhtml#ch03list9) 定义了三元组过滤器，它移除包含不太可能出现的三字母三元组的排列。它使用了一个来源于多个密码学网站的文本文件，已针对
    *tmvoordle* 中的字母进行定制。这个函数只会返回包含这些三元组的排列；main() 函数会将新的集合传递给下一个过滤函数。'
- en: '*voldemort_british.py,* part 5'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '*voldemort_british.py,* 第 5 部分'
- en: '➊ def trigram_filter(filter_1, trigrams_filtered):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def trigram_filter(filter_1, trigrams_filtered):'
- en: '"""Remove unlikely trigrams from permutations."""'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '"""移除排列中的不太可能出现的三元组。"""'
- en: ➋ filtered = set()
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ filtered = set()
- en: '➌ for candidate in filter_1:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ for candidate in filter_1:'
- en: '➍ for triplet in trigrams_filtered:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ for triplet in trigrams_filtered:'
- en: triplet = triplet.lower()
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: triplet = triplet.lower()
- en: 'if triplet in candidate:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 'if triplet in candidate:'
- en: filtered.add(candidate)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: filtered.add(candidate)
- en: ➎ filter_2 = filter_1 - filtered
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ filter_2 = filter_1 - filtered
- en: print("# of choices after filter_2 = {}".format(len(filter_2)))
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: print("# of choices after filter_2 = {}".format(len(filter_2)))
- en: ➏ return filter_2
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ return filter_2
- en: '*Listing 3-9: Defines the* trigram_filter() *function*'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-9：定义了* trigram_filter() *函数*'
- en: Parameters for the trigram filter include the output from the c-v map filter
    and the external list of unlikely trigrams, trigrams_filtered ➊.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 三元组过滤器的参数包括来自 c-v 映射过滤器的输出以及外部的不可行三元组列表，trigrams_filtered ➊。
- en: Initialize an empty set to hold permutations that contain one of the forbidden
    trigrams ➋. Then start another for loop that looks through the candidates that
    survived the last filter ➌. A nested for loop looks at each triplet in the trigrams
    list ➍. If the triplet is in the candidate, it is added to the filter.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个空集合来保存包含其中一个禁用三元组的排列 ➋。然后开始另一个 for 循环，查看通过上一个过滤器 ➌ 的候选项。一个嵌套的 for 循环查看三元组列表中的每个三元组
    ➍。如果三元组出现在候选项中，它将被添加到过滤器中。
- en: Now you can use set operations to subtract the new filter from filter_1 ➎ and
    then return the difference for use with the next filter ➏.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用集合操作从 filter_1 ➎ 中减去新的过滤器，然后返回差异以供下一个过滤器 ➏ 使用。
- en: '**Defining the Digram Filter**'
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义二元组过滤器**'
- en: '[Listing 3-10](ch03.xhtml#ch03list10) defines the digram filter, which removes
    unlikely letter pairs. Some will trigger the filter if they occur anywhere within
    the permutation; others will do so only if they occur at the start of the permutation.
    The disallowed digrams are based on the shaded cells in [Table 3-2](ch03.xhtml#ch03tab2).
    The function returns the results of this filter for use in the final filter function.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-10](ch03.xhtml#ch03list10) 定义了二元组过滤器，它移除不太可能出现的字母对。如果字母对出现在排列的任何位置，它们将触发过滤器；有些仅在排列开始时触发。禁用的二元组基于[表
    3-2](ch03.xhtml#ch03tab2)中的阴影单元格。该函数返回该过滤器的结果，用于最终的过滤函数。'
- en: '*voldemort_british.py,* part 6'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '*voldemort_british.py,* 第 6 部分'
- en: '➊ def letter_pair_filter(filter_2):'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def letter_pair_filter(filter_2):'
- en: '"""Remove unlikely letter-pairs from permutations."""'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '"""移除排列中的不太可能出现的字母对。"""'
- en: ➋ filtered = set()
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ filtered = set()
- en: ➌ rejects = ['dt', 'lr', 'md', 'ml', 'mr', 'mt', 'mv',
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ rejects = ['dt', 'lr', 'md', 'ml', 'mr', 'mt', 'mv',
- en: '''td'', ''tv'', ''vd'', ''vl'', ''vm'', ''vr'', ''vt'']'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '''td'', ''tv'', ''vd'', ''vl'', ''vm'', ''vr'', ''vt'']'
- en: ➍ first_pair_rejects = ['ld', 'lm', 'lt', 'lv', 'rd',
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ first_pair_rejects = ['ld', 'lm', 'lt', 'lv', 'rd',
- en: '''rl'', ''rm'', ''rt'', ''rv'', ''tl'', ''tm'']'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '''rl'', ''rm'', ''rt'', ''rv'', ''tl'', ''tm'']'
- en: '➎ for candidate in filter_2:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ for candidate in filter_2:'
- en: '➏ for r in rejects:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ for r in rejects:'
- en: 'if r in candidate:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 'if r in candidate:'
- en: filtered.add(candidate)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: filtered.add(candidate)
- en: '➐ for fp in first_pair_rejects:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ for fp in first_pair_rejects:'
- en: 'if candidate.startswith(fp):'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 'if candidate.startswith(fp):'
- en: filtered.add(candidate)
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: filtered.add(candidate)
- en: ➑ filter_3 = filter_2 - filtered
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ filter_3 = filter_2 - filtered
- en: print("# of choices after filter_3 = {}".format(len(filter_3)))
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: print("过滤后 filter_3 中的选择数量 = {}".format(len(filter_3)))
- en: '➒ if ''voldemort'' in filter_3:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ 如果 'voldemort' 在 filter_3 中：
- en: print("Voldemort found!", file=sys.stderr)
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: print("找到了伏地魔！", file=sys.stderr)
- en: ➓ return filter_3
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: ➓ 返回 filter_3
- en: '*Listing 3-10: Defines the* letter_pair_filter() *function*'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-10：定义了* letter_pair_filter() *函数*'
- en: This filter accepts the results of the previous filter as an argument ➊. An
    empty set is initialized to hold any discarded permutations ➋. Then two lists
    of rejected pairs are assigned to the variables rejects ➌ and first_pair_rejects
    ➍. Both lists were entered manually. The first represents cells shaded black in
    [Table 3-2](ch03.xhtml#ch03tab2); the second references cells shaded gray. Any
    permutation that contains a member of the first list—anywhere—will be discarded;
    permutations that *start with* a member of the second list will not be allowed.
    You can add or remove digrams to these lists to change how the filter behaves.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 该过滤器接受前一个过滤器的结果作为参数 ➊。初始化一个空集合，用于保存任何被丢弃的排列 ➋。然后将两个被拒绝的配对列表赋值给变量 rejects ➌ 和
    first_pair_rejects ➍。这两个列表是手动输入的。第一个表示 [表 3-2](ch03.xhtml#ch03tab2) 中被涂黑的单元格；第二个表示被涂灰的单元格。任何包含第一个列表成员的排列——无论在哪里——都将被丢弃；以第二个列表成员开头的排列将不被允许。你可以向这些列表中添加或移除二元组，以改变过滤器的行为。
- en: Begin looping through the permutations—continue to refer to these as “candidates,”
    as they aren’t necessarily words ➎. A nested for loop goes through the pairs in
    rejects, determines whether any are in candidate, and adds them to the filtered
    set ➏. A second nested for loop repeats this process for the first_pair_rejects
    ➐. Subtract filtered from the set returned from the previous function, filter_2
    ➑.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 开始循环遍历排列——继续称其为“候选项”，因为它们不一定是单词 ➎。一个嵌套的 for 循环遍历 rejects 中的配对，确定是否有任何配对在候选项中，并将其添加到过滤集
    ➏。第二个嵌套的 for 循环重复此过程处理 first_pair_rejects ➐。将 filtered 从上一个函数返回的集合 filter_2 中减去
    ➑。
- en: For fun *and* to ensure you haven’t filtered too far, check whether *voldemort*
    is included in filter_3 ➒ and print an announcement to highlight the discovery,
    using eye-catching red font for IDLE users. Then finish by returning the final
    filtered set ➓.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩*并且*确保你没有过滤得太远，检查 filter_3 ➒ 是否包含 *voldemort*，并打印一条公告突出显示这个发现，使用引人注目的红色字体供
    IDLE 用户查看。然后通过返回最终的过滤集 ➓ 来结束。
- en: '**Letting the User Choose the Starting Letter**'
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**让用户选择起始字母**'
- en: You don’t know ahead of time whether your filtering will be successful. You
    may still end up with thousands of permutations. Providing the option to look
    at only a subset of the output won’t reduce the overall number, but it will make
    it *psychologically* easier to face. [Listing 3-11](ch03.xhtml#ch03list11) adds,
    to *voldemort_british.py*, the ability to view a list of anagrams that begin with
    a certain input letter.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法预知你的过滤是否会成功。你可能最终还是会得到成千上万的排列。提供只查看输出子集的选项不会减少总体数量，但它会在*心理上*使你更容易面对。[列表 3-11](ch03.xhtml#ch03list11)
    为 *voldemort_british.py* 添加了查看以某个输入字母开头的变位词列表的功能。
- en: '*voldemort_british.py,* part 7'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '*voldemort_british.py,* 第 7 部分'
- en: '➊ def view_by_letter(name, filter_3):'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def view_by_letter(name, filter_3):'
- en: '"""Filter to anagrams starting with input letter."""'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '"""过滤以输入字母开头的变位词。"""'
- en: ➋ print("Remaining letters = {}".format(name))
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ print("剩余字母 = {}".format(name))
- en: '➌ first = input("select a starting letter or press Enter to see all: ")'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ first = input("选择一个起始字母，或者按 Enter 查看所有：")
- en: ➍ subset = []
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ subset = []
- en: '➎ for candidate in filter_3:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ for candidate in filter_3:'
- en: 'if candidate.startswith(first):'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 'if candidate.startswith(first):'
- en: subset.append(candidate)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: subset.append(candidate)
- en: ➏ print(*sorted(subset), sep='\n')
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ print(*sorted(subset), sep='\n')
- en: print("Number of choices starting with {} = {}".format(first, len(subset)))
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: print("以 {} 开头的选择数量 = {}".format(first, len(subset)))
- en: ➐ try_again = input("Try again? (Press Enter else any other key to Exit):")
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ try_again = input("再试一次吗？（按 Enter，或按其他任意键退出）：")
- en: 'if try_again.lower() == '''':'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 'if try_again.lower() == '''':'
- en: ➑ view_by_letter(name, filter_3)
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ view_by_letter(name, filter_3)
- en: 'else:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: ➒ sys.exit()
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ sys.exit()
- en: '*Listing 3-11: Defines the* view_by_letter() *function*'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-11：定义了* view_by_letter() *函数*'
- en: Define the view_by_letter() function to take both the name variable and filter_3
    as arguments ➊. You need the name so you can show the user the available letter
    choices on which to filter ➋. Get the user’s input on whether they want to see
    all the remaining permutations or just those beginning with a certain letter ➌.
    Then start an empty list to hold the latter subset ➍.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 view_by_letter() 函数，将 name 变量和 filter_3 作为参数 ➊。你需要该名称，以便可以向用户展示可供选择的字母，以便进行过滤
    ➋。获取用户的输入，询问他们是否想查看所有剩余的排列，还是只查看以某个字母开头的排列 ➌。然后，启动一个空列表来保存后者的子集 ➍。
- en: A for loop, with a conditional, checks whether a candidate starts with the chosen
    letter and appends those letters that pass to subset ➎. This list is printed with
    the splat operator ➏. Then the program asks the user whether they want to try
    again or exit ➐. If they press ENTER, then view_by_letter() is called, recursively,
    and runs again from the start ➑. Otherwise, the program exits ➒. Note that Python
    has a default recursion depth limit of 1,000, which we’ll ignore in this project.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 for 循环，带有条件判断，检查候选字母是否以选定字母开头，并将符合条件的字母附加到子集 ➎ 中。然后，使用 splat 操作符 ➏ 打印该列表。接着，程序会询问用户是否想再试一次或者退出
    ➐。如果他们按下回车键，则会递归调用 view_by_letter() 并重新从头开始运行 ➑。否则，程序退出 ➒。请注意，Python 默认的递归深度限制为
    1000，我们在本项目中忽略这一限制。
- en: '**Running the main() Function**'
  id: totrans-536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行 main() 函数**'
- en: Back in the global space, [Listing 3-12](ch03.xhtml#ch03list12) completes the
    code by calling the main() function if the user runs the program in stand-alone
    mode versus importing into another program.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局空间中，[列表 3-12](ch03.xhtml#ch03list12)通过在用户以独立模式运行程序时调用 main() 函数，完成了代码，如果是导入到另一个程序，则不调用。
- en: '*voldemort_british.py,* part 8'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '*voldemort_british.py,* 第 8 部分'
- en: 'if __name__ == ''__main__'':'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == ''__main__'':'
- en: main()
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 3-12: Calls the* main() *function*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-12：调用 main() 函数*'
- en: Example output from the completed program is shown below. After the program
    applies the third filter, there are 248 permutations remaining, of which a very
    manageable 73 start with *v*. I’ve omitted the printout of the permutations for
    brevity. As noted in the output, *voldemort* survives the filtering.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 完成程序的示例输出如下所示。在程序应用第三个过滤器后，剩下 248 个排列，其中 73 个以 *v* 开头，数量非常可管理。为了简洁起见，我省略了排列的打印输出。如输出所示，*voldemort*
    在过滤后依然存在。
- en: length initial word_list = 60388
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 初始 word_list 的长度 = 60388
- en: length of new word_list = 8687
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 word_list 长度 = 8687
- en: length filtered_cv_map = 234
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 经过过滤的 cv_map 长度 = 234
- en: length of initial permutations set = 181440
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 初始排列集合的长度 = 181440
- en: choices after filter_1 = 123120
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经过 filter_1 的选择数 = 123120
- en: of choices after filter_2 = 674
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经过 filter_2 的选择数 = 674
- en: of choices after filter_3 = 248
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经过 filter_3 的选择数 = 248
- en: Voldemort found!
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: Voldemort 找到了！
- en: Remaining letters = tmvoordle
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余字母 = tmvoordle
- en: 'select a starting letter or Enter to see all: v'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个起始字母或按回车键查看所有选项：v
- en: Interestingly, another surviving permutation is *lovedmort*. Given how many
    people Voldemort killed—or had killed—this may be the most appropriate moniker
    of all.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，另一个存活下来的排列是 *lovedmort*。考虑到伏地魔杀害了多少人——或者说是让别人杀害——这个名字可能是最合适的称号。
- en: '**Summary**'
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you first wrote code that found the anagrams for a given word
    or name. You then expanded on this to find phrasal name anagrams, working interactively
    with the user. Finally, you employed cryptanalytical techniques to tease *Voldemort*
    out of almost 200,000 possible anagrams. Along the way, you applied useful functionality
    in the collections and itertools modules.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你首先编写了一个程序来找到给定单词或名称的字谜。然后，你在此基础上扩展了功能，找到了短语名称的字谜，和用户进行交互。最后，你使用了密码分析技术，从近
    200,000 个可能的字谜中提取了 *Voldemort*。在这个过程中，你应用了 collections 和 itertools 模块中的有用功能。
- en: '**Further Reading**'
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: The *Jumble* website is *[http://www.jumble.com/](http://www.jumble.com/)*.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '*Jumble* 网站是 *[http://www.jumble.com/](http://www.jumble.com/)*'
- en: 'You can find some representative online anagram generators at the following
    sites:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下网站找到一些代表性的在线字谜生成器：
- en: '*[http://wordsmith.org/anagram/](http://wordsmith.org/anagram/)*'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[http://wordsmith.org/anagram/](http://wordsmith.org/anagram/)*'
- en: '*[https://www.dcode.fr/anagram-generator](https://www.dcode.fr/anagram-generator)*'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[https://www.dcode.fr/anagram-generator](https://www.dcode.fr/anagram-generator)*'
- en: '*[http://www.wordplays.com/anagrammer/](http://www.wordplays.com/anagrammer/)*'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[http://www.wordplays.com/anagrammer/](http://www.wordplays.com/anagrammer/)*'
- en: More anagram programs are found in *Think Python, 2nd Edition* (O’Reilly, 2015)
    by Allen Downey.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的字谜程序可以在 Allen Downey 的 *Think Python, 2nd Edition*（O'Reilly，2015）中找到。
- en: '*Cracking Codes with Python* (No Starch Press, 2017) by Al Sweigart provides
    more code for computing word patterns, such as those used for filtering in the
    *voldemort_british.py* program.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '*用Python破解密码*（No Starch Press，2017）由Al Sweigart编写，提供了更多用于计算单词模式的代码，例如用于在*voldemort_british.py*程序中进行过滤的代码。'
- en: '**Practice Project: Finding Digrams**'
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：寻找双字母组合**'
- en: You *could* comb through cryptography websites looking for frequency statistics,
    or you could derive them for yourself. Write a Python program that finds all the
    digrams in *tmvoordle* and then counts their frequency of occurrence in a dictionary
    file. Be sure to test your code on words like *volvo*, so you don’t overlook repeating
    digrams in the same word. You can find a solution in the appendix or download
    *count_digrams_practice.py* from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 你*可以*浏览加密学网站寻找频率统计数据，或者自己计算这些数据。编写一个Python程序，找到*tmvoordle*中的所有双字母组合，并计算它们在字典文件中出现的频率。一定要测试你的代码，使用像*volvo*这样的单词，避免忽略同一单词中的重复双字母组合。你可以在附录中找到解决方案，或从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载*count_digrams_practice.py*。
- en: '**Challenge Project: Automatic Anagram Generator**'
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：自动字谜生成器**'
- en: Look at the online anagram generators I just referenced in “Further Reading”
    and write a Python program that mimics one of these. Your program should automatically
    generate phrase anagrams from an input name and display a subset (for example,
    the first 500) for the user to review.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我在“进一步阅读”中提到的在线字谜生成器，并编写一个Python程序，模拟其中一个字谜生成器。你的程序应当从输入的名字自动生成短语字谜，并展示一部分（例如前500个）供用户查看。
