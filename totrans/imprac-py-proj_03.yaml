- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: SOLVING ANAGRAMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决字谜**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: An *anagram* is a word formed by rearranging the letters of another word. For
    example, *Elvis* yields the eerie trio *evils*, *lives*, and *veils*. Does this
    mean Elvis still lives but veils his evil existence? In the book *Harry Potter
    and the Chamber of Secrets*, “I am Lord Voldemort” is an anagram of the evil wizard’s
    real name, Tom Marvolo Riddle. “Lord Earldom Vomit” is also an anagram of Tom
    Marvolo Riddle, but author J.K. Rowling had the good sense to pass on that one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*字谜* 是通过重新排列另一个单词的字母所形成的单词。例如，*Elvis* 会产生令人毛骨悚然的三重奏 *evils*、*lives* 和 *veils*。这是否意味着
    Elvis 仍然活着，但隐藏了他邪恶的存在？在《哈利·波特与密室》一书中，“I am Lord Voldemort” 是邪恶巫师的真名 Tom Marvolo
    Riddle 的字谜。“Lord Earldom Vomit” 也是 Tom Marvolo Riddle 的字谜，但作者 J.K. Rowling 明智地选择了放弃这个版本。'
- en: In this chapter, first you’ll find all the anagrams for a given word or name.
    Then, you’ll write a program that lets a user interactively build an anagram phrase
    from their own name. Finally, you’ll play computer wizard and see what it takes
    to extract “I am Lord Voldemort” from “Tom Marvolo Riddle.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，首先你将找到一个给定单词或名称的所有字谜。然后，你将编写一个程序，允许用户通过交互式方式从他们自己的名字构建一个字谜短语。最后，你将扮演计算机巫师，看看如何从“Tom
    Marvolo Riddle”提取出“I am Lord Voldemort”。
- en: '**Project #4: Finding Single-Word Anagrams**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #4：查找单词字谜**'
- en: You’ll start by analyzing simple single-word anagrams and figuring out how to
    identify them programmatically. Having accomplished this, you’ll be ready to take
    on anagram phrases in the following section.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从分析简单的单词字谜开始，并研究如何通过编程来识别它们。完成这一部分后，你将准备好在接下来的部分处理中处理字谜短语。
- en: '**THE OBJECTIVE**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use Python and a dictionary file to find all the single-word anagrams for a
    given English word or single name. You can read instructions for finding and loading
    dictionary files at the start of [Chapter 2](ch02.xhtml#ch02).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 和字典文件查找给定英语单词或单个名称的所有单词字谜。你可以在 [第二章](ch02.xhtml#ch02) 的开始部分找到查找和加载字典文件的说明。
- en: '***The Strategy and Pseudocode***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: 'More than 600 newspapers and 100 internet sites carry an anagram game called
    *Jumble*. Created in 1954, it’s now the most recognized word-scramble game in
    the world. *Jumble* can be really frustrating, but finding anagrams is almost
    as easy as finding palindromes—you just need to know the common characteristic
    of all anagrams: they must have the same number of the same letters.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 超过600家报纸和100个互联网网站都开展了一种名为 *Jumble* 的字谜游戏。该游戏创立于1954年，现在是全球最知名的文字混排游戏。*Jumble*
    可能会让人感到非常沮丧，但找出字谜几乎和找回回文一样简单——你只需要知道所有字谜的共同特征：它们必须包含相同数量的相同字母。
- en: '**Identifying an Anagram**'
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**识别字谜**'
- en: Python doesn’t contain a built-in anagram operator, but you can easily write
    one. For the projects in this chapter, you’ll load the dictionary file from [Chapter
    2](ch02.xhtml#ch02) as a list of strings. So the program needs to verify that
    two strings are anagrams of each other.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有内置的字谜运算符，但你可以轻松编写一个。在本章的项目中，你将从 [第二章](ch02.xhtml#ch02) 加载字典文件作为字符串列表。因此，程序需要验证两个字符串是否是彼此的字谜。
- en: 'Let’s look at an example. *Pots* is an anagram of *stop*, and you can verify
    that *stop* and *pots* have the same number of letters with the len() function.
    But there’s no way for Python to know whether two strings have the same number
    of any single character—at least not without converting the strings to another
    data structure or using a counting function. So, instead of looking at these two
    words simply as strings, you can represent them as two lists containing single-character
    strings. Create these lists in a shell, like IDLE, and name them word and anagram,
    as I’ve done here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。*Pots* 是 *stop* 的字谜，你可以通过 len() 函数验证 *stop* 和 *pots* 是否包含相同数量的字母。但
    Python 无法知道两个字符串是否具有相同数量的某个字符——至少在不将字符串转换为其他数据结构或使用计数函数的情况下是无法做到的。因此，除了将这两个单词简单地看作字符串之外，你还可以将它们表示为包含单个字符字符串的两个列表。在像
    IDLE 这样的 Shell 中创建这些列表，并将它们命名为 word 和 anagram，正如我在这里所做的那样：
- en: '>>> word = list(''stop'')'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word = list(''stop'')'
- en: '>>> word'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word'
- en: '[''s'', ''t'', ''o'', ''p'']'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[''s'', ''t'', ''o'', ''p'']'
- en: '>>> anagram = list(''pots'')'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram = list(''pots'')'
- en: '>>> anagram'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram'
- en: '[''p'', ''o'', ''t'', ''s'']'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[''p'', ''o'', ''t'', ''s'']'
- en: These two lists match our description of an anagram pair; that is, they contain
    the same number of the same letters. But if you try to equate them with the comparison
    operator ==, the result is False.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个列表与我们对字谜对的描述相符；也就是说，它们包含相同数量的相同字母。但是，如果你试图用比较运算符 == 来比较它们，结果是 False。
- en: '>>> anagram == word'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram == word'
- en: 'False'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: The problem is that the operator (==) considers two lists equivalent only if
    they have the same number of the same list items and those items occur in the
    same order. You can easily solve this problem with the built-in function sorted(),
    which can take a list as an argument and reorder its contents alphabetically.
    So, if you call sorted() twice—once for each of the lists—and then compare the
    sorted lists, they will be equivalent. In other words, == returns True.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于运算符 (==) 仅在两个列表具有相同数量的相同元素并且这些元素按相同顺序出现时，才会认为它们是相等的。你可以通过内置函数 sorted() 来轻松解决这个问题，该函数可以将列表作为参数并按字母顺序重新排列其内容。因此，如果你对两个列表分别调用
    sorted() 并比较排序后的列表，它们将是相等的。换句话说，== 返回 True。
- en: '>>> word = sorted(word)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word = sorted(word)'
- en: '>>> word'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word'
- en: '[''o'', ''p'', ''s'', ''t'']'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[''o'', ''p'', ''s'', ''t'']'
- en: '>>> anagram = sorted(anagram)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram = sorted(anagram)'
- en: '>>> anagram'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram'
- en: '[''o'', ''p'', ''s'', ''t'']'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[''o'', ''p'', ''s'', ''t'']'
- en: '>>> anagram == word'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> anagram == word'
- en: 'True'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: You can also pass a string to sorted() to create a sorted list like the ones
    in the preceding code snippet. This will be useful for converting the words from
    the dictionary file into sorted lists of single-character strings.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将一个字符串传递给 sorted() 来创建一个排序后的列表，就像前面的代码片段一样。这对于将字典文件中的单词转换为排序后的单字符字符串列表非常有用。
- en: Now that you know how to verify that you’ve found an anagram, let’s design the
    script in its entirety—from loading a dictionary and prompting the user for a
    word (or name) to searching for and printing all the anagrams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何验证是否找到字谜，我们来设计完整的脚本——从加载字典并提示用户输入一个单词（或名称），到查找并打印所有字谜。
- en: '**Using Pseudocode**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用伪代码**'
- en: Remember that planning with pseudocode will help you spot potential issues and
    spotting those issues early will save you time. The following pseudocode should
    help you better understand the script we’ll write in the next section, *anagrams.py*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用伪代码进行规划可以帮助你发现潜在的问题，提前发现这些问题将节省你大量时间。以下伪代码应帮助你更好地理解我们将在下一节中编写的脚本 *anagrams.py*。
- en: Load digital dictionary file as a list of words
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字字典文件加载为一个单词列表
- en: Accept a word from user
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接受用户输入的单词
- en: Create an empty list to hold anagrams
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空列表来存储字谜
- en: Sort the user-word
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 排序用户输入的单词
- en: 'Loop through each word in the word list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历单词列表中的每个单词：
- en: Sort the word
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 排序单词
- en: 'if word sorted is equal to user-word sorted:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果排序后的单词与用户输入的排序单词相同：
- en: Append word to anagrams list
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词添加到字谜列表
- en: Print anagrams list
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打印字谜列表
- en: The script will start by loading words from a dictionary file into a list as
    strings. Before you loop through the dictionary in search of anagrams, you need
    to know which word you want anagrams of, and you need a place to store anagrams
    when you find them. So, first ask the user to input a word and then create an
    empty list to store the anagrams. Once the program has looped through every word
    in the dictionary, it will print that list of anagrams.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先会从字典文件加载单词到一个字符串列表中。在遍历字典查找字谜之前，你需要知道你想要查找字谜的单词是什么，并且需要一个地方来存储找到的字谜。因此，首先请用户输入一个单词，然后创建一个空列表来存储字谜。一旦程序遍历了字典中的每个单词，它将打印该字谜列表。
- en: '***Anagram-Finder Code***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字谜查找器代码***'
- en: '[Listing 3-1](ch03.xhtml#ch03list1) loads a dictionary file, accepts a word
    or name *specified within the program*, and finds all the anagrams in the dictionary
    file for that word or name. You’ll also need the dictionary-loading code from
    [Chapter 2](ch02.xhtml#ch02). You can download these from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *anagrams.py* and *load_dictionary.py*, respectively. Keep both files in the
    same folder. You can use the same dictionary file you used in [Chapter 2](ch02.xhtml#ch02)
    or download another one (see [Table 2-1](ch02.xhtml#ch02tab1) on [page 20](ch02.xhtml#page_20)
    for suggestions).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-1](ch03.xhtml#ch03list1) 加载字典文件，接受程序中*指定的*单词或名称，并为该单词或名称在字典文件中查找所有字谜。你还需要
    [第 2 章](ch02.xhtml#ch02) 中的字典加载代码。你可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载它们，分别命名为 *anagrams.py* 和 *load_dictionary.py*。请将这两个文件保存在同一文件夹中。你可以使用 [第 2 章](ch02.xhtml#ch02)
    中使用的字典文件，或者下载另一个字典文件（有关建议，请参见 [表 2-1](ch02.xhtml#ch02tab1)，位于 [第 20 页](ch02.xhtml#page_20)）。'
- en: '*anagrams.py*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*anagrams.py*'
- en: ➊ import load_dictionary
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import load_dictionary
- en: ➋ word_list = load_dictionary.load('2of4brif.txt')
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ word_list = load_dictionary.load('2of4brif.txt')
- en: ➌ anagram_list = []
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ anagram_list = []
- en: '# input a SINGLE word or SINGLE name below to find its anagram(s):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '# 在下面输入一个单词或单一名称来查找其字谜：'
- en: ➍ name = 'Foster'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ name = 'Foster'
- en: print("Input name = {}".format (name))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: print("输入名称 = {}".format (name))
- en: ➎ name = name.lower()
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ name = name.lower()
- en: print("Using name = {}".format(name))
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: print("使用 name = {}".format(name))
- en: '# sort name & find anagrams'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '# 排序 name 并查找变位词'
- en: ➏ name_sorted = sorted(name)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ name_sorted = sorted(name)
- en: '➐ for word in word_list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ 遍历 word_list 中的每个单词：
- en: word = word.lower()
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: word = word.lower()
- en: 'if word != name:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'if word != name:'
- en: 'if sorted(word) == name_sorted:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'if sorted(word) == name_sorted:'
- en: anagram_list.append(word)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: anagram_list.append(word)
- en: '# print out list of anagrams'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印出变位词列表'
- en: print()
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: '➑ if len(anagram_list) == 0:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ if len(anagram_list) == 0:'
- en: print("You need a larger dictionary or a new name!")
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: print("你需要一个更大的字典或换个名字！")
- en: 'else:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: ➒ print("Anagrams =", *anagram_list, sep='\n')
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ print("变位词 =", *anagram_list, sep='\n')
- en: '*Listing 3-1: Given a word (or name) and a dictionary file, this program searches
    for and prints a list of anagrams.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-1：给定一个单词（或名字）和一个字典文件，程序会搜索并打印一个变位词列表。*'
- en: You start by importing the load_dictionary module you created in [Chapter 2](ch02.xhtml#ch02)
    ➊. This module will open a dictionary text file and, with its load() function,
    load all the words into a list ➋. The **.txt* file you use may be different, depending
    on which dictionary file you downloaded (see “[Finding and Opening a Dictionary](ch02.xhtml#lev33)”
    on [page 20](ch02.xhtml#page_20)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先导入在 [第2章](ch02.xhtml#ch02) 中创建的 load_dictionary 模块 ➊。这个模块将打开一个字典文本文件，并通过它的
    load() 函数将所有单词加载到一个列表中 ➋。你使用的 **.txt* 文件可能不同，这取决于你下载的字典文件（见 “[查找和打开字典](ch02.xhtml#lev33)”
    在 [第20页](ch02.xhtml#page_20)）。
- en: Next, create an empty list, called anagram_list, to hold any anagrams you find
    ➌. Have the user add a *single* word, such as their first name ➍. This doesn’t
    have to be a proper name, but we’ll refer to it as name in the code to distinguish
    it from a dictionary word. Print this name so the user can see what was entered.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个空列表，名为 anagram_list，用于保存你找到的任何变位词 ➌。让用户添加一个 *单独* 的单词，比如他们的名字 ➍。这不一定是一个专有名词，但为了与字典中的单词区分开，我们将在代码中称之为
    name。打印这个名字，以便用户看到输入的内容。
- en: The next line anticipates a problematic user action. People tend to type their
    name with an uppercase first letter, but dictionary files may not include uppercase
    letters, and that matters to Python. So, first convert all letters to lowercase
    with the .lower() string method ➎.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码考虑到可能出现的问题。人们倾向于输入首字母大写的名字，但字典文件可能不包含大写字母，而 Python 是区分大小写的。因此，首先使用 .lower()
    字符串方法将所有字母转换为小写 ➎。
- en: Now sort the name ➏. As mentioned previously, you can pass sorted() a string
    as well as a list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对名称进行排序 ➏。前面提到过，你可以将 sorted() 应用于字符串和列表。
- en: With the input sorted alphabetically in a list, it’s time to find anagrams.
    Start a loop through each word in the dictionary word list ➐. To be safe, convert
    the word to lowercase, as comparison operations are case-sensitive. After the
    conversion, compare the word to the unsorted name, because a word can’t be an
    anagram of itself. Next, sort the dictionary word and compare it to the sorted
    name. If it passes, append that dictionary word to anagram_list.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的名称按字母顺序排列在列表中，现在是时候查找变位词了。通过字典单词列表中的每个单词开始循环 ➐。为了安全起见，将单词转换为小写，因为比较操作是区分大小写的。转换后，将该单词与未排序的名称进行比较，因为一个单词不能是它自己的变位词。接下来，对字典中的单词进行排序，并将其与已排序的名称进行比较。如果匹配，则将该字典单词添加到
    anagram_list 中。
- en: Now display the results. First, check whether the anagram list is empty. If
    it is, print a whimsical reply so you don’t just leave the user hanging ➑. If
    the program found at least one anagram, print the list using the splat (*) operator.
    Remember from [Chapter 2](ch02.xhtml#ch02) that splat lets you print each member
    of a list on a separate line ➒.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显示结果。首先，检查变位词列表是否为空。如果为空，打印一个幽默的回复，避免让用户空等 ➑。如果程序找到了至少一个变位词，使用 splat (*) 操作符打印列表。记住，[第2章](ch02.xhtml#ch02)中提到过，splat
    让你将列表中的每个成员打印在单独的一行上 ➒。
- en: 'The following is example output for this program, using the input name *Foster*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用输入名称 *Foster* 的程序示例输出：
- en: Input name = Foster
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的名字 = Foster
- en: Using name = foster
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 name = foster
- en: Anagrams =
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 变位词 =
- en: forest
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: forest
- en: fortes
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: fortes
- en: softer
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: softer
- en: If you’d like to use another input, change the value of the name variable in
    the source code. As an exercise, try to adjust the code so that the user is prompted
    to input the name (or word); you can do this with the input() function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用另一个输入，可以更改源代码中 name 变量的值。作为练习，尝试调整代码，使用户被提示输入名字（或单词）；你可以通过 input() 函数实现这一点。
- en: '**Project #5: Finding Phrase Anagrams**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #5：查找短语变位词**'
- en: In the previous project, you took a single name or word and rearranged all the
    letters to find single-word anagrams. Now you will derive multiple words from
    a name. The words in these *phrase anagrams* form only part of the input name,
    and you will need several words to exhaust the available letters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个项目中，你使用一个名字或单词并重新排列所有字母，找到单词字谜。现在你将从一个名字中衍生出多个单词。这些*短语字谜*中的单词仅构成输入名字的一部分，你需要多个单词才能用尽所有字母。
- en: '**THE OBJECTIVE**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write a Python program that lets a user interactively build an anagram phrase
    from the letters in their name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，允许用户通过名字中的字母互动地构建一个字谜短语。
- en: '***The Strategy and Pseudocode***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略和伪代码***'
- en: The very best phrase anagrams are those that describe some well-known characteristic
    or action associated with the name bearer. For example, the letters in Clint Eastwood
    can be rearranged to form *old west action*, Alec Guinness yields *genuine class*,
    Madam Curie produces *radium came*, George Bush gives *he bugs Gore*, and Statue
    of Liberty contains *built to stay free*. My own name yields *a huge navel*, which
    is not really one of my characteristics.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的短语字谜是那些描述与名字持有者相关的某种著名特征或行为的。例如，Clint Eastwood中的字母可以重新排列形成*old west action*，Alec
    Guinness可以得到*genuine class*，Madam Curie可以得到*radium came*，George Bush可以得到*he bugs
    Gore*，而自由女神像包含*built to stay free*。我自己的名字可以得到*a huge navel*，不过那其实并不是我的特征之一。
- en: 'At this point, you may see a strategic challenge ahead: how does a computer
    handle contextual content? The folks at IBM who invented Watson seem to know,
    but for the rest of us, that boulder is a little hard to lift.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，你可能会遇到一个战略性挑战：计算机如何处理上下文内容？发明了Watson的IBM公司似乎知道答案，但对于我们其他人来说，这块巨石有点难以搬动。
- en: The *brute-force method* is a common approach used in online anagram generators.
    These algorithms take a name and return lots of random anagram phrases (generally,
    100s to 10,000+). Most of the returned phrases are nonsense, and scrolling through
    hundreds of these can be a chore.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*暴力破解法*是在线字谜生成器中常用的一种方法。这些算法接受一个名字并返回许多随机的字谜短语（通常是100个到10,000个以上）。大部分返回的短语都是无意义的，浏览这些无数的短语可能会变得非常繁琐。'
- en: An alternative approach is to acknowledge that humans are best at contextual
    issues and write a program that helps the human work through the problem. The
    computer can take the initial name and provide words that can be made from some
    (or all) the letters in it; the user can then choose a word that “makes sense.”
    The program will then recalculate the word choices from the remaining letters
    in the name, repeating the process until every letter is used or the possible
    word choices are exhausted. This design plays to the strengths of both participants.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是承认人类在处理上下文问题上最为擅长，并编写一个帮助人类解决问题的程序。计算机可以接受初始的名字并提供可以从其中的某些（或所有）字母组成的单词；然后用户可以选择一个“合适”的单词。程序随后将根据名字中剩余的字母重新计算单词选择，重复该过程，直到所有字母都被使用完或所有可能的单词选择用尽。这个设计充分发挥了两者的优势。
- en: You’ll need a simple interface that prompts the user to input the initial name,
    displays potential word choices, and displays any remaining letters. The program
    will also need to keep track of the growing anagram phrase and let the user know
    when every letter has been used. There will likely be lots of failed attempts,
    so the interface should allow the user to restart the process at any time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个简单的界面，提示用户输入初始的名字，显示潜在的单词选择，并展示剩余的字母。程序还需要跟踪逐渐增长的字谜短语，并在每个字母被使用时提醒用户。可能会有很多失败的尝试，所以界面应允许用户随时重新开始。
- en: Since anagrams have the same number of the same letters, another way to identify
    them is to count individual letters. If you think of your name as a collection
    of letters, then a word can be built from your name if (1) all its letters occur
    in your name and (2) they occur *at the same frequency or less*. Obviously, if
    *e* occurs three times in a word and twice in your name, the word can’t be derived
    from your name. So, if the collection of letters that make up a word is not a
    subset of the collection of letters in your name, then that word cannot be part
    of your name anagram.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字谜由相同数量的相同字母组成，另一种识别字谜的方法是统计每个字母的数量。如果你把你的名字看作是一个字母集合，那么如果（1）一个单词的所有字母都出现在你的名字中，并且（2）它们出现的频率与名字中相同或更少，那么这个单词就可以从你的名字中构建出来。显然，如果*e*在一个单词中出现了三次，而在你的名字中出现了两次，那么这个单词不能从你的名字中得出。因此，如果构成一个单词的字母集合不是你名字中字母集合的子集，那么这个单词就不能是你名字字谜的一部分。
- en: '**Using Counter to Tally Letters**'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用计数器统计字母**'
- en: Fortunately for us, Python ships with a module named collections that includes
    several container data types. One of these types, Counter, counts the occurrences
    of an item. Python stores the items as dictionary keys and the counts as dictionary
    values. For example, the following code snippet counts how many of each bonsai
    tree type is in a list.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 附带了一个名为 collections 的模块，其中包含几个容器数据类型。其中一种类型，Counter，可以统计项目出现的次数。Python
    将这些项目存储为字典的键，计数存储为字典的值。例如，下面的代码片段统计列表中每种盆栽树类型的数量。
- en: '>>> from collections import Counter'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from collections import Counter'
- en: ➊ >>> my_bonsai_trees = ['maple', 'oak', 'elm', 'maple', 'elm', 'elm', 'elm',
    'elm']
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> my_bonsai_trees = ['maple', 'oak', 'elm', 'maple', 'elm', 'elm', 'elm',
    'elm']
- en: ➋ >>> count = Counter(my_bonsai_trees)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> count = Counter(my_bonsai_trees)
- en: '>>> print(count)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(count)'
- en: '➌ Counter({''elm'': 5, ''maple'': 2, ''oak'': 1})'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ Counter({''elm'': 5, ''maple'': 2, ''oak'': 1})'
- en: The my_bonsai_trees list contains multiples of the same type of tree ➊. Counter
    tallies up the trees ➋ and creates an easy-to-reference dictionary ➌. Note that
    the print() function is optional and is used here for clarity. Entering count,
    alone, will also display the dictionary contents.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: my_bonsai_trees 列表包含相同类型树木的多个实例 ➊。Counter 会统计树木的数量 ➋ 并创建一个易于参考的字典 ➌。请注意，print()
    函数是可选的，这里用于增加清晰度。单独输入 count 也会显示字典内容。
- en: 'You can use Counter, instead of the sorted() method, to find single-word anagrams.
    Rather than two sorted lists, the output will be two dictionaries, which can also
    be directly compared with ==. Here’s an example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Counter 来代替 sorted() 方法查找单词的变位词。与两个排序过的列表不同，输出将是两个字典，它们也可以直接通过 == 进行比较。以下是一个示例：
- en: '>>> name = ''foster'''
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> name = ''foster'''
- en: '>>> word = ''forest'''
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word = ''forest'''
- en: '>>> name_count = Counter(name)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> name_count = Counter(name)'
- en: '>>> print(name_count)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(name_count)'
- en: '➊ Counter({''f'': 1, ''t'': 1, ''e'': 1, ''o'': 1, ''r'': 1, ''s'': 1})'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ Counter({''f'': 1, ''t'': 1, ''e'': 1, ''o'': 1, ''r'': 1, ''s'': 1})'
- en: '>>> word_count = Counter(word)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> word_count = Counter(word)'
- en: '>>> print(word_count)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(word_count)'
- en: '➋ Counter({''f'': 1, ''t'': 1, ''o'': 1, ''e'': 1, ''r'': 1, ''s'': 1})'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ Counter({''f'': 1, ''t'': 1, ''o'': 1, ''e'': 1, ''r'': 1, ''s'': 1})'
- en: 'Counter produces a dictionary for each word that maps each letter in the word
    to the number of times it occurs ➊➋. The dictionaries are unsorted, but despite
    the lack of sorting, Python correctly identifies each dictionary as being equal
    if the dictionaries contain the same letters and the same counts:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Counter 会为每个单词生成一个字典，将单词中的每个字母映射到其出现的次数 ➊➋。这些字典是无序的，但尽管没有排序，Python 仍然能正确识别两个字典是否相等，只要它们包含相同的字母和相同的计数：
- en: '>>> if word_count == name_count:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if word_count == name_count:'
- en: print("It's a match!")
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: print("匹配成功！")
- en: It's a match!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配成功！
- en: A Counter gives you a wonderful way to find words that “fit” in a name. If the
    count for each letter in a word is less than or equal to the count for the same
    letter in the name, then the word can be derived from the name!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Counter 提供了一种绝妙的方式来查找“适配”名称的单词。如果单词中每个字母的计数小于或等于名称中相同字母的计数，那么该单词可以从名称中派生出来！
- en: '**The Pseudocode**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**伪代码**'
- en: 'We’ve now made two important design decisions: (1) let the user interactively
    build their anagram one word at a time and (2) use the Counter method to find
    anagrams. This is enough to start thinking about high-level pseudocode:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经做出了两个重要的设计决策：（1）让用户逐个单词地互动构建他们的变位词，（2）使用 Counter 方法来查找变位词。这足以开始思考高级伪代码：
- en: Load a dictionary file
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 加载字典文件
- en: Accept a name from user
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接受用户输入的名称
- en: Set limit = length of name
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 设置限制 = 名称的长度
- en: Start empty list to hold anagram phrase
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个空列表来存储变位词短语
- en: 'While length of phrase < limit:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当短语长度 < 限制时：
- en: Generate list of dictionary words that fit in name
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 生成符合名称的字典单词列表
- en: Present words to user
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户展示单词
- en: Present remaining letters to user
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户展示剩余字母
- en: Present current phrase to user
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户展示当前短语
- en: Ask user to input word or start over
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户输入单词或重新开始
- en: 'If user input can be made from remaining letters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入可以从剩余字母中构成：
- en: Accept choice of new word or words from user
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接受用户的新单词或单词组合选择
- en: Remove letters in choice from letters in name
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从名称中的字母中移除选择的字母
- en: Return choice and remaining letters in name
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 返回选择和名称中剩余的字母
- en: 'If choice is not a valid selection:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择无效：
- en: Ask user for new choice or let user start over
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户是否选择新的词语或重新开始
- en: Add choice to phrase and show to user
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将选择添加到短语并显示给用户
- en: Generate new list of words and repeat process
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 生成新的单词列表并重复该过程
- en: 'When phrase length equals limit value:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当短语长度等于限制值时：
- en: Display final phrase
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显示最终短语
- en: Ask user to start over or to exit
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 询问用户是否重新开始或退出
- en: '**Divvying Up the Work**'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分配任务**'
- en: As procedural code becomes more complex, it becomes necessary to encapsulate
    much of it in functions. This makes it easier to manage input and output, perform
    recursion, and read the code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序代码变得越来越复杂，将其中许多部分封装成函数变得必要。这使得管理输入和输出、执行递归以及阅读代码变得更加容易。
- en: A *main function* is where a program starts its execution, and enables high-level
    organization, such as managing all the bits and pieces of the code, including
    dealing with the user. In the phrase anagram program, the main function will wrap
    all the “worker bee” functions, take *most* of the user input, keep track of the
    growing anagram phrase, determine when the phrase is complete, and show the user
    the result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*主函数*是程序开始执行的地方，它启用了高级组织，如管理代码的所有部分，包括与用户的交互。在字谜短语程序中，主函数将包装所有“工作函数”，接受*大部分*的用户输入，跟踪增长中的字谜短语，确定短语何时完成，并向用户显示结果。'
- en: 'Sketching out the tasks and their flow with pencil and paper is a great way
    to figure out what you want to do and where (like “graphical pseudocode”). [Figure
    3-1](ch03.xhtml#ch03fig1) is a flowchart with function assignments highlighted.
    In this case, three functions should be sufficient: main(), find_anagrams(), and
    process_choice().'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 用铅笔和纸画出任务和流程图是搞清楚你想做什么以及做在哪里的好方法（类似“图形伪代码”）。[图 3-1](ch03.xhtml#ch03fig1)是一个带有功能分配的流程图。在这种情况下，三个函数应该足够：main()、find_anagrams()和process_choice()。
- en: The main() function’s primary task is to set the letter count limit and manage
    the while loop responsible for the general phrase anagram build. The find_anagrams()
    function will take the current collection of letters remaining in a name and return
    all possible words that can be made from those letters. The words are then displayed
    for the user, along with the current phrase, which is “owned” and displayed by
    the main() function. Then, the process_choice() function prompts the user to start
    over or choose a word for the anagram phrase. If the user makes a choice, this
    function determines whether the letters in the choice are available. If they aren’t,
    the user is prompted to choose again or start over. If the user makes a valid
    choice, the letters in the user’s choice are removed from the list of remaining
    letters, and both the choice and list of leftovers are returned. The main() function
    adds the returned choice to the existing phrase. If the limit is reached, the
    completed phrase anagram is displayed, and the user is asked to start over or
    exit.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: main()函数的主要任务是设置字母计数限制，并管理负责构建通用字谜短语的while循环。find_anagrams()函数将获取当前名称中剩余字母的集合，并返回可以由这些字母组成的所有可能的单词。然后，单词将显示给用户，并显示当前的短语，该短语由main()函数“拥有”和显示。接着，process_choice()函数会提示用户重新开始或选择一个字谜短语。如果用户做出选择，函数将检查选择中的字母是否可用。如果不可用，用户将被提示重新选择或重新开始。如果用户做出有效选择，所选字母将从剩余字母列表中移除，并返回选择和剩余字母列表。main()函数将返回的选择添加到现有短语中。如果达到限制，完成的字谜短语将被显示，并询问用户是否重新开始或退出。
- en: Note that you ask for the initial name in the *global* scope, rather than in
    the main() function. This allows the user to start over fresh at any time without
    having to re-enter their name. For now, if the user wants to choose a brand-new
    name, they’ll have to exit the program and start over. In [Chapter 9](ch09.xhtml#ch09),
    you’ll use a menu system that lets users completely reset what they’re doing without
    exiting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您需要在*全局*作用域中请求初始名称，而不是在main()函数中。这使得用户可以随时重新开始，而无需重新输入姓名。现在，如果用户想选择一个全新的名字，他们需要退出程序并重新开始。在[第9章](ch09.xhtml#ch09)中，您将使用菜单系统，允许用户在不退出的情况下完全重置他们的操作。
- en: '![image](../images/f0043-01.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0043-01.jpg)'
- en: '*Figure 3-1: Flowchart for finding phrase anagrams with function assignments
    highlighted*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：带有功能分配的字谜短语查找流程图*'
- en: '***The Anagram Phrase Code***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字谜短语编码***'
- en: 'The code in this section takes a name from a user and helps them build an anagram
    phrase of that name. You can download the entire script from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *phrase_anagrams.py*. You’ll also need to download the *load_dictionary.py*
    program. Save both files in the same folder. You can use the same dictionary file
    you used in “[Project #4: Finding Single-Word Anagrams](ch03.xhtml#lev50)” on
    [page 36](ch03.xhtml#page_36).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Up and Finding Anagrams**'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-2](ch03.xhtml#ch03list2) imports the modules that *phrase_anagrams.py*
    uses, loads a dictionary file, asks the user for an input name, and defines the
    find_anagrams() function, which does most of the work related to finding anagrams.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '*phrase_anagrams.py,* part 1'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import sys
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: from collections import Counter
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: import load_dictionary
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: ➋ dict_file = load_dictionary.load('2of4brif.txt')
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '# ensure "a" & "I" (both lowercase) are included'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: dict_file.append('a')
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: dict_file.append('i')
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: dict_file = sorted(dict_file)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '➌ ini_name = input("Enter a name: ")'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '➍ def find_anagrams(name, word_list):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '"""Read name & dictionary file & display all anagrams IN name."""'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: ➎ name_letter_map = Counter(name)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: anagrams = []
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '➏ for word in word_list:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: ➐ test = ''
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: ➑ word_letter_map = Counter(word.lower())
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '➒ for letter in word:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'if word_letter_map[letter] <= name_letter_map[letter]:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: test += letter
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'if Counter(test) == word_letter_map:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: anagrams.append(word)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: ➓ print(*anagrams, sep='\n')
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: print("Remaining letters = {}".format(name))
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: print("Number of remaining letters = {}".format(len(name)))
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: print("Number of remaining (real word) anagrams = {}".format(len(anagrams)))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-2: Imports modules, loads dictionary, and defines the* find_anagrams()
    *function*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Start with the import statements ➊, using the recommended order of Python Standard
    Library, third-party modules, and then locally developed modules. You need sys
    for coloring specific outputs red in the IDLE window and for letting the user
    exit the program with a keystroke. You’ll use Counter to help identify anagrams
    of the input name.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Next load the dictionary file using the imported module ➋. The filename argument
    should be the filename of the dictionary you’re using. Because some dictionary
    files omit *a* and *I*, append these (if needed), and sort the list so that they
    can be found at the proper alphabetical locations, rather than at the end of the
    list.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Now get a name from the user and assign it to the variable ini_name (or “initial
    name”) ➌. You’ll derive a name variable from this initial name, and name will
    be progressively changed as the user builds up the name anagram. Preserving the
    initial name as a separate variable will let you reset everything if the user
    wants to start over or try again.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The next block of code is find_anagrams() ➍, the function for finding anagrams
    in the name. The parameters for this function consist of a name and a word list.
    The function starts by using Counter to count the number of times a given letter
    appears in the name and then assigns the count to the variable name_letter_map
    ➎; Counter uses a dictionary structure with the letter as the key and the count
    as the value. The function then creates an empty list to hold the anagrams and
    starts a for loop through each word in the dictionary file ➏.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块是 find_anagrams() ➍，这是用于查找姓名中的字谜的函数。此函数的参数包括一个姓名和一个单词列表。函数开始时使用 Counter
    来计算给定字母在姓名中出现的次数，然后将该计数分配给变量 name_letter_map ➎；Counter 使用字典结构，将字母作为键，计数作为值。然后，函数创建一个空列表来保存字谜，并开始对字典文件中的每个单词进行
    for 循环 ➏。
- en: The for loop starts by creating an empty string called test ➐. Use this variable
    to accumulate all the letters in the word that “fit” in name. Then make a Counter
    for the current word, as you did for name, and call it word_letter_map ➑. Loop
    through the letters in word ➒, checking that the count of each letter is the same
    as, or less than, the count in name. If the letter meets this condition, then
    it is added to the test string. Since some letters might get rejected, end the
    loop by running Counter on test and comparing it to word_letter_map. If they match,
    append the word to the anagrams list.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环首先创建一个名为 test ➐ 的空字符串。使用这个变量来累积所有在 name 中“匹配”的字母。然后为当前单词创建一个 Counter，就像对
    name 做的一样，命名为 word_letter_map ➑。遍历 word 中的字母 ➒，检查每个字母的计数是否与 name 中的计数相同或更少。如果字母满足这个条件，则将其添加到
    test 字符串中。由于某些字母可能被拒绝，结束循环时运行 Counter 对 test 进行计数，并与 word_letter_map 比较。如果它们匹配，则将该单词附加到
    anagrams 列表中。
- en: The function ends by displaying the list of words, using the splat operator
    with print, along with some statistics for the user ➓. Note that find_anagrams()
    doesn’t return anything. This is where the human interaction part comes in. The
    program will continue to run, but nothing will happen until the user chooses a
    word from the displayed list.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 函数最后通过使用打印的 splat 操作符显示单词列表，并附带一些用户统计信息 ➓。请注意，find_anagrams() 不返回任何值。这是与人类交互的部分。程序将继续运行，但在用户从显示的列表中选择一个单词之前，什么也不会发生。
- en: '**Processing the User’s Choice**'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**处理用户选择**'
- en: '[Listing 3-3](ch03.xhtml#ch03list3) defines process_choice(), the function
    in *phrase_anagrams.py* that takes the user’s choice of word (or words), checks
    it against the remaining letters in the name variable, and returns acceptable
    choices—along with any leftover letters—to the main() function. Like main(), this
    function gets to talk directly to the user.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 3-3](ch03.xhtml#ch03list3) 定义了 process_choice()，这是 *phrase_anagrams.py*
    中的函数，用于获取用户选择的单词（或多个单词），并与 name 变量中的剩余字母进行匹配，返回可接受的选择——以及任何剩余的字母——给 main() 函数。与
    main() 类似，该函数可以直接与用户进行交互。'
- en: '*phrase_anagrams.py,* part 2'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*phrase_anagrams.py，* 第 2 部分'
- en: '➊ def process_choice(name):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def process_choice(name):'
- en: '"""Check user choice for validity, return choice & leftover letters."""'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '"""检查用户选择的有效性，返回选择和剩余字母。"""'
- en: 'while True:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: '➋ choice = input(''\nMake a choice else Enter to start over or # to end: '')'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ choice = input(''\n做出选择，否则按 Enter 重新开始，或者按 # 结束：'')'
- en: 'if choice == '''':'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 choice == ''：
- en: main()
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: 'elif choice == ''#'':'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: elif choice == '#'：
- en: sys.exit()
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'else:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: ➌ candidate = ''.join(choice.lower().split())
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ candidate = ''.join(choice.lower().split())
- en: ➍ left_over_list = list(name)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ left_over_list = list(name)
- en: '➎ for letter in candidate:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 对于 candidate 中的字母：
- en: 'if letter in left_over_list:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字母在 left_over_list 中：
- en: left_over_list.remove(letter)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: left_over_list.remove(letter)
- en: '➏ if len(name) - len(left_over_list) == len(candidate):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ 如果 len(name) - len(left_over_list) == len(candidate)：
- en: break
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 退出循环
- en: 'else:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print("Won't work! Make another choice!", file=sys.stderr)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: print("无法工作！做出另一个选择！", file=sys.stderr)
- en: ➐ name = ''.join(left_over_list)  # makes display more readable
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ name = ''''.join(left_over_list)  # 使显示更易读'
- en: ➑ return choice, name
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ 返回 choice 和 name
- en: '*Listing 3-3: Defines the* process_choice() *function*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-3：定义了* process_choice() *函数*'
- en: Start by defining the function with one parameter called name ➊. The first time
    the program is run, this parameter will be the same as the ini_name variable—the
    full name entered by the user when the program starts up. After the user has chosen
    a word (or words) to use in the anagram phrase, it will represent the remaining
    letters in the name.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义一个名为 name ➊ 的函数参数。程序首次运行时，该参数将与 ini_name 变量相同——即程序启动时用户输入的完整姓名。在用户选择一个（或多个）用于字谜短语的单词之后，它将表示姓名中剩余的字母。
- en: 'Start the function with a while loop that will run until the user makes a valid
    choice and then get input from the user ➋. The user has a choice of entering one
    or more words from the current anagram list, pressing ENTER to start over, or
    pressing # to quit. Use #, rather than a word or letter, so that it can’t be confused
    for a valid choice.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: If the user makes a choice, the string is assigned to the variable candidate,
    stripped of whitespace, and converted to all lowercase ➌. This is so it can be
    directly compared to the name variable. After that, a list is built from the name
    variable to hold any remaining letters ➍.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Now begin a loop to subtract the letters used in candidate ➎. If a chosen letter
    is present in the list, it’s removed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: If the user entered a word that isn’t in the displayed list, or entered multiple
    words, a letter may not be present in the list. To check for this, subtract the
    leftover letters from name and, if the result is the number of letters in candidate,
    determine that the input is valid and break out of the while loop ➏. Otherwise,
    display a warning and color it red for those using the IDLE window. The while
    loop will keep prompting the user until an acceptable choice is made.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: If all the letters in the user’s choice pass the test, the list of leftovers
    is converted back into a string and used to update the name variable ➐. Converting
    the list into a string isn’t strictly necessary, but it keeps the name variable
    type consistent and lets you display the remaining letters in a clearly readable
    format without the need for additional print arguments.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Finish by returning both the user’s choice and the string of remaining letters
    (name) to the main() function ➑.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-4](ch03.xhtml#ch03list4) defines the main() function in *phrase_anagrams.py*.
    This function wraps the previous functions, runs a while loop, and determines
    when the user has successfully created an anagram phrase.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '*phrase_anagrams.py,* part 3'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '"""Help user build anagram phrase from their name."""'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: ➊ name = ''.join(ini_name.lower().split())
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: name = name.replace('-', '')
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: ➋ limit = len(name)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: phrase = ''
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: running = True
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '➌ while running:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: ➍ temp_phrase = phrase.replace(' ', '')
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '➎ if len(temp_phrase) < limit:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: print("Length of anagram phrase = {}".format(len(temp_phrase)))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: ➏ find_anagrams(name, dict_file)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: print("Current anagram phrase =", end=" ")
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: print(phrase, file=sys.stderr)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: ➐ choice, name = process_choice(name)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: phrase += choice + ' '
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '➑ elif len(temp_phrase) == limit:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: print("\n*****FINISHED!!!*****\n")
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: print("Anagram of name =", end=" ")
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: print(phrase, file=sys.stderr)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: ➒ try_again = input('\n\nTry again? (Press Enter else "n" to quit)\n ')
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'if try_again.lower() == "n":'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: running = False
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '➓ if __name__ == ''__main__'':'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-4: Defines and calls* main() *function*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The first order of business is to turn the ini_name variable into a continuous
    string of lowercase characters with no whitespace ➊. Remember, case matters to
    Python, so convert all strings to lowercase wherever they occur; that way, comparisons
    will work as intended. Python also recognizes spaces as characters, so you need
    to remove these, as well as hyphens in hyphenated names, before doing any letter
    counts. By declaring this new name variable, you preserve the initial name in
    case the user wants to start over. Only name will be altered in the process_choice()
    function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Next, get the length of the name ➋ to use as a limit in the while loop. This
    will let you know when the anagram phrase has used all the letters in the name
    and it’s time to end the loop. Do this outside the while loop to ensure you are
    using the full initial name. Then assign a variable to hold the anagram phrase
    and set a running variable to True to control the while loop.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Now begins the big loop that lets you iterate over the name and build an anagram
    phrase ➌. First, prepare a string to hold the growing phrase and strip it of whitespace
    ➍. Spaces will count as letters and throw off the operator when the length of
    the phrase is compared to the limit variable. Next, make the comparison, and if
    the length of the phrase is less than the limit, display the current length of
    the phrase as a prelude to engaging with the user ➎.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to put the other functions to work. Call find_anagrams() ➏ and pass
    it the name and dictionary file to get the list of anagrams in the name. At the
    bottom of the displayed list, show the user the current phrase. Use the print()
    function’s end parameter to display two print statements on the same line. This
    way, you can use a red font on the phrase in the IDLE window to distinguish it
    from all the other information in the display.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Next, call the process_choice() function ➐ to get the user’s word choice and
    add it to the growing anagram phrase. This also gets the updated version of the
    name variable so that the program can use it again in the while loop in the event
    that the phrase isn’t complete.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: If the length of the phrase is equal to the limit variable ➑, the name anagram
    is complete. Let the user know they’re finished and present the phrase using red
    font. Note that you don’t have a conditional for the length of the phrase being
    greater than the limit variable. That’s because the process_choice() function
    is already handling this outcome (choosing more letters than are available would
    not pass the validation criterion).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The main() function ends by asking the user whether they want to try again.
    If they type n, the program ends; if they press ENTER, the main() function is
    called again ➒. As stated earlier, the only way for the user to change the initial
    name is to exit and relaunch the program.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Outside of the main() function, end with the standard two lines for calling
    the main() function when the program is not imported as a module ➓.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '**Running an Example Session**'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In this section, I’ve included an example interactive session, using *phrase_anagrams.py*
    and the name *Bill Bo*. Bold font indicates user input, and italic bold font indicates
    where red font is used in the display.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a name: Bill Bo'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Length of anagram phrase = 0
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: bib
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: bill
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: blob
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: bob
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: boil
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: boll
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: i
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: ill
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: lib
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: lilo
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: lo
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: lob
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: oi
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: oil
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Remaining letters = billbo
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Number of remaining letters = 6
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Number of remaining (real word) anagrams = 14
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Current anagram phrase =
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a choice else Enter to start over or # to end: ill'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Length of anagram phrase = 3
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: bob
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Remaining letters = bbo
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Number of remaining letters = 3
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Number of remaining (real word) anagrams = 1
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Current anagram phrase = ill
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a choice else Enter to start over or # to end: Bob'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '***** FINISHED!!! *****'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Anagram of name = ill Bob
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Try again? (Press Enter else "n" to quit)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The number of anagrams found depends on the dictionary file you use. If you’re
    having a hard time building anagram phrases, try using a larger dictionary.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #6: Finding Voldemort: The Gallic Gambit**'
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Did you ever wonder how Tom Riddle came up with the anagram “I am Lord Voldemort”?
    Did he put quill to parchment or just wave a wand? Could the magic of Python have
    helped?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Let’s pretend for a moment that you’re the professor of computer wizardry at
    Hogwarts, and Tom Riddle, school prefect and model student, has come to you for
    help. Using your *phrase_anagrams.py* spell from the previous section, he could
    find *I am Lord* in the very first list of anagrams, much to his delight. But
    the remaining letters, *tmvoordle*, yield only trivial words like *dolt*, *drool*,
    *looter*, and *lover*. Riddle would not be pleased.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'In hindsight, the problem is apparent: *Voldemort* is French and won’t be found
    in any English dictionary file. *Vol de la mort* means “flight of death” in French,
    so Voldemort is loosely “death flight.” But Riddle is 100 percent English, and
    so far, you have been working with English. Without reverse engineering, you have
    no more reason to suddenly switch out your English dictionary for a French one
    than you have to use Dutch, German, Italian, or Spanish.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'You *could* try randomly shuffling the remaining letters and seeing what falls
    out. Unfortunately, the number of possible combinations is the factorial of the
    number of letters divided by the factorial of the number of repeats (*o* occurs
    twice): 9! / 2! = 181,440\. If you were to scroll through all those permutations,
    taking only one second to review each, it would take you over two days to complete
    the list! And if you asked Tom Riddle to do this, he would probably use you to
    make a horcrux!'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I would like to explore two logical paths ahead. One I call the
    “Gallic Gambit” and the other the “British Brute-Force.” We’ll look at the first
    one here and the second one in the next section.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Marvolo *is clearly a* fabricated word *used to make the Voldemort anagram work.
    J.K. Rowling could have gained additional latitude by using* Thomas *for* Tom
    *or by leaving off the* Lord *or* I am *parts. Tricks like these are used when
    the book is translated into non-English languages. In some languages, one or both
    names may need to be changed. In French, the anagram is “I am Voldemort.” In Norwegian,
    “Voldemort the Great.” In Dutch, “My name is Voldemort.” In others, like Chinese,
    the anagram can’t be used at all!*
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Tom Riddle was obsessed with beating death, and if you go looking for death
    in *tmvoordle*, you will find both the old French *morte* (as in the famous book
    *Le Morte d’Arthur* by Sir Thomas Malory) and the modern French *mort*. Removing
    *mort* leaves *vodle*, five letters with a very manageable number of permutations.
    In fact, you can easily find *volde* right in the interpreter window:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: ➊ >>> from itertools import permutations
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '>>> name = ''vodle'''
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: ➋ >>> perms = [''.join(i) for i in permutations(name)]
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: ➌ >>> print(len(perms))
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '120'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: ➍ >>> print(perms)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[''vodle'', ''vodel'', ''volde'', ''voled'', ''voedl'', ''voeld'', ''vdole'',
    ''vdoel'','
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '''vdloe'', ''vdleo'', ''vdeol'', ''vdelo'', ''vlode'', ''vloed'', ''vldoe'',
    ''vldeo'','
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '''vleod'', ''vledo'', ''veodl'', ''veold'', ''vedol'', ''vedlo'', ''velod'',
    ''veldo'','
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '''ovdle'', ''ovdel'', ''ovlde'', ''ovled'', ''ovedl'', ''oveld'', ''odvle'',
    ''odvel'','
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '''odlve'', ''odlev'', ''odevl'', ''odelv'', ''olvde'', ''olved'', ''oldve'',
    ''oldev'','
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '''olevd'', ''oledv'', ''oevdl'', ''oevld'', ''oedvl'', ''oedlv'', ''oelvd'',
    ''oeldv'','
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '''dvole'', ''dvoel'', ''dvloe'', ''dvleo'', ''dveol'', ''dvelo'', ''dovle'',
    ''dovel'','
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '''dolve'', ''dolev'', ''doevl'', ''doelv'', ''dlvoe'', ''dlveo'', ''dlove'',
    ''dloev'','
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '''dlevo'', ''dleov'', ''devol'', ''devlo'', ''deovl'', ''deolv'', ''delvo'',
    ''delov'','
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '''lvode'', ''lvoed'', ''lvdoe'', ''lvdeo'', ''lveod'', ''lvedo'', ''lovde'',
    ''loved'','
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '''lodve'', ''lodev'', ''loevd'', ''loedv'', ''ldvoe'', ''ldveo'', ''ldove'',
    ''ldoev'','
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '''ldevo'', ''ldeov'', ''levod'', ''levdo'', ''leovd'', ''leodv'', ''ledvo'',
    ''ledov'','
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '''evodl'', ''evold'', ''evdol'', ''evdlo'', ''evlod'', ''evldo'', ''eovdl'',
    ''eovld'','
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '''eodvl'', ''eodlv'', ''eolvd'', ''eoldv'', ''edvol'', ''edvlo'', ''edovl'',
    ''edolv'','
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '''edlvo'', ''edlov'', ''elvod'', ''elvdo'', ''elovd'', ''elodv'', ''eldvo'',
    ''eldov'']'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '>>>'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: ➎ >>> print(*perms, sep='\n')
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: vodle
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: vodel
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: volde
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: voled
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: voedl
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing permutations from itertools ➊. The itertools module is a
    group of functions in the Python Standard Library that create iterators for efficient
    looping. You generally think of permutations of *numbers*, but the itertools version
    works on *elements* in an iterable, which includes letters.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: After entering the name or, in this case, the remaining letters in the name,
    use list comprehension to create a list of permutations of the name ➋. Join each
    element in a permutation so each item in the final list will be a unique permutation
    of *vodle*. Using join yields the new name as an element, 'vodle', versus a hard-to-read
    tuple of single-character elements,('v', 'o', 'd', 'l', 'e').
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Get the length of the permutations as a check; that way, you can confirm that
    it is, indeed, the factorial of 5 ➌. At the end, no matter how you print it ➍➎,
    *volde* is easy to find.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #7: Finding Voldemort: The British Brute-Force**'
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s assume Tom Riddle is bad at anagrams (or French). He doesn’t recognize
    *mort* or *morte*, and you’re back to shuffling the remaining nine letters thousands
    and thousands of times, looking for a combination of letters that he would find
    pleasing.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: On the bright side, this is a more interesting problem programmatically than
    the interactive solution you just saw. You just need to whittle down all the permutations
    using some form of filtering.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Reduce the number of anagrams of *tmvoordle* to a manageable number that will
    still contain *Voldemort*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '***Strategy***'
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Per the *Oxford English Dictionary, 2nd Edition*, there are 171,476 English
    words currently in use, which is fewer than the total number of permutations in
    *tmvoordle*! Regardless of the language, you can surmise that most of the anagrams
    generated by the permutations() function are nonsense.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'With *cryptography*, the science of codes and ciphers, you can safely eliminate
    many useless, unpronounceable combinations, such as *ldtmvroeo*, and you won’t
    even have to inspect them visually. Cryptographers have long studied languages
    and compiled statistics on recurring patterns of words and letters. We can use
    many cryptanalytical techniques for this project, but let’s focus on three: consonant-vowel
    mapping, trigram frequency, and digram frequency.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering with Consonant-Vowel Mapping**'
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *consonant-vowel map* (*c-v map*) simply replaces the letters in a word with
    a *c* or a *v*, as appropriate. *Riddle*, for example, becomes *cvcccv*. You can
    write a program that goes through a dictionary file and creates c-v maps for each
    word. By default, impossible combinations, like *ccccccvvv*, will be excluded.
    You can further exclude membership by removing words with c-v maps that are *possible*
    but that have a low frequency of occurrence.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: C-v maps are fairly inclusive, but that’s good. An option for *Riddle* at this
    point is to make up a new proper name, and proper names don’t have to be words
    that occur in a dictionary. So you don’t want to be *too* exclusive early in the
    process.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering with Trigrams**'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since the initial filter needs a relatively wide aperture, you’ll need to filter
    again at a lower level to safely remove more anagrams from the permutations. *Trigrams*
    are triplets comprising three consecutive letters. It should come as no surprise
    that the most common trigram in English is the word *the*, followed closely by
    *and* and *ing*. At the other end of the scale are trigrams like *zvq*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: You can find statistics on the frequency of occurrence of trigrams online at
    sites like *[http://norvig.com/ngrams/count_3l.txt](http://norvig.com/ngrams/count_3l.txt)*.
    For any group of letters, like *tmvoordle*, you can generate and use a list of
    the least common trigrams to further reduce the number of permutations. For this
    project, you can use the *least-likely_trigrams.txt* file, downloadable from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    This text file contains the trigrams in *tmvoordle* that occur in the bottom 10
    percent of trigrams in the English language, based on frequency of occurrence.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering with Digrams**'
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Digrams* (also called *bigrams*) are letter pairs. Commonly occurring digrams
    in English include *an*, *st*, and *er*. On the other hand, you rarely see pairs
    like *kg*, *vl*, or *oq*. You can find statistics on the frequency of occurrence
    of digrams at websites such as *[https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html](https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html)*
    and *[http://practicalcryptography.com/](http://practicalcryptography.com/)*.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](ch03.xhtml#ch03tab1) was built from the *tmvoordle* collection
    of letters and a 60,000-word English dictionary file. The letters along the left
    side of the chart are the starting letters for the digrams; those along the top
    represent the end letter. For example, to find *vo*, start with the *v* on the
    left and read across to the column beneath the *o*. For the digrams found in *tmvoordle*,
    *vo* occurs only 0.8 percent of the time.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Relative Frequency of Digrams from the Letters *tmvoordle* in
    a 60,000-Word Dictionary (Black Squares Indicate No Occurrences)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **d** | **e** | **l** | **m** | **o** | **r** | **t** | **v** |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| **d** |  | 3.5% | 0.5% | 0.1% | 1.7% | 0.5% | 0.0% | 0.1% |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| **e** | 6.6% |  | 2.3% | 1.4% | 0.7% | 8.9% | 2.0% | 0.6% |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| **l** | 0.4% | 4.4% |  | 0.1% | 4.2% | 0.0% | 0.4% | 0.1% |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| **m** | 0.0% | 2.2% | 0.0% |  | 2.8% | 0.0% | 0.0% | 0.0% |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| **o** | 1.5% | 0.5% | 3.7% | 3.2% | 5.3% | 7.1% | 2.4% | 1.4% |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| **r** | 0.9% | 6.0% | 0.4% | 0.7% | 5.7% |  | 1.3% | 0.3% |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| **t** | 0.0% | 6.2% | 0.6% | 0.1% | 3.6% | 2.3% |  | 0.0% |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| **v** | 0.0% | 2.5% | 0.0% | 0.0% | 0.8% | 0.0% | 0.0% |  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: Assuming you’re looking for “English-like” letter combinations, you can use
    frequency maps like this to exclude letter pairs that are unlikely to occur. Think
    of it as a “digram sieve” that lets only the unshaded squares pass.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: To be safe, just exclude digrams that occur less than 0.1 percent of the time.
    I’ve shaded these in black. Notice that it would be very easy to eliminate the
    required *vo* pairing in *Voldemort*, if you cut too close to the bone!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: You can design your filter to be even more selective by tagging digrams that
    are unlikely to occur at the start of a word. For example, while it’s not unusual
    for the digram *lm* to occur *within* a word (as in *almanac* and *balmy*), you’ll
    need a lot of luck finding a word that *starts* with *lm*. You don’t need cryptography
    to find these digrams; just try to pronounce them! Some starting-point choices
    for these are shaded gray in [Table 3-2](ch03.xhtml#ch03tab2).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Update of [Table 3-1](ch03.xhtml#ch03tab1), Where Gray-Shaded
    Squares Indicate Digrams Unlikely to Occur at the Start of a Word'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **d** | **e** | **l** | **m** | **o** | **r** | **t** | **v** |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
- en: '| **d** |  | 3.5% | 0.5% | 0.1% | 1.7% | 0.5% | 0.0% | 0.1% |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: '| **e** | 6.6% |  | 2.3% | 1.4% | 0.7% | 8.9% | 2.0% | 0.6% |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
- en: '| **l** | 0.4% | 4.4% |  | 0.1% | 4.2% | 0.0% | 0.4% | 0.1% |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
- en: '| **m** | 0.0% | 2.2% | 0.0% |  | 2.8% | 0.0% | 0.0% | 0.0% |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
- en: '| **o** | 1.5% | 0.5% | 3.7% | 3.2% | 5.3% | 7.1% | 2.4% | 1.4% |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
- en: '| **r** | 0.9% | 6.0% | 0.4% | 0.7% | 5.7% |  | 1.3% | 0.3% |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
- en: '| **t** | 0.0% | 6.2% | 0.6% | 0.1% | 3.6% | 2.3% |  | 0.0% |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '| **v** | 0.0% | 2.5% | 0.0% | 0.0% | 0.8% | 0.0% | 0.0% |  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: 'You now have three filters you can use on the 181,440 permutations of *tmvoordle*:
    c-v maps, trigrams, and digrams. As a final filter, you should give the user the
    option of viewing only anagrams that start with a given letter. This will let
    the user divide the remaining anagrams into more manageable “chunks,” or focus
    on the more intimidating-sounding anagrams, like those that begin with *v*!'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '***The British Brute-Force Code***'
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The upcoming code generates permutations of *tmvoordle* and passes them through
    the filters just described. It then gives the user the option to view either all
    the permutations or only those starting with a given letter.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: You can download all the programs you’ll need from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    The code in this section is one script named *voldemort_british.py*. You’ll also
    need the *load_dictionary.py* program in the same folder, along with the same
    dictionary file you used for the projects earlier in this chapter. Finally, you’ll
    need a new file named *least-likely_trigrams.txt*, a text file of trigrams with
    a low frequency of occurrence in English. Download all these files into the same
    folder.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-5](ch03.xhtml#ch03list5) imports the modules that *voldemort_british.py*
    needs and defines its main() function. In the *phrase_anagrams.py* program, you
    defined the main() function at the end of the code. Here we put it at the start.
    The advantage is that you can see what the function is doing—how it’s running
    the program—from the start. The disadvantage is that you don’t know what any of
    the helper functions do yet.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 1'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import sys
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: from itertools import permutations
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: from collections import Counter
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: import load_dictionary
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def main():'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '"""Load files, run filters, allow user to view anagrams by 1st letter."""'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: ➌ name = 'tmvoordle'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: name = name.lower()
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: ➍ word_list_ini = load_dictionary.load('2of4brif.txt')
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: trigrams_filtered = load_dictionary.load('least-likely_trigrams.txt')
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: ➎ word_list = prep_words(name, word_list_ini)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: filtered_cv_map = cv_map_words(word_list)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: filter_1 = cv_map_filter(name, filtered_cv_map)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: filter_2 = trigram_filter(filter_1, trigrams_filtered)
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: filter_3 = letter_pair_filter(filter_2)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: view_by_letter(name, filter_3)
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-5: Imports modules and defines the* main() *function*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing modules you’ve used in the previous projects ➊. Now define
    the main() function ➋. The name variable is a string of the remaining letters
    *tmvoordle* ➌. Set it to lowercase to guard against a user input error. Next,
    use the load_dictionary module to load your dictionary file and the trigrams file
    as lists ➍. Your dictionary filename may be different from that shown.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Finally, call all the various functions in order ➎. I’ll describe each of these
    functions momentarily, but basically, you need to prepare the word list, prepare
    the c-v maps, apply the three filters, and let the user view all the anagrams
    at once or view a subset based on the anagram’s first letter.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparing the Word List**'
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-6](ch03.xhtml#ch03list6) prepares the word list by including just
    the words that have as many letters as in the name variable (in this case, nine).
    You should also ensure that all the words are lowercase, to be consistent.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 2'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def prep_words(name, word_list_ini):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '"""Prep word list for finding anagrams."""'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: ➋ print("length initial word_list = {}".format(len(word_list_ini)))
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: len_name = len(name)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: ➌ word_list = [word.lower() for word in word_list_ini
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: if len(word) == len_name]
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: ➍ print("length of new word_list = {}".format(len(word_list)))
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: ➎ return word_list
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-6: Creates lists of words that are equal in length to the* name
    *variable*'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Define the prep_words() function to take a name string and list of dictionary
    words as arguments ➊. I suggest that you print the lengths of your various word
    lists before and after they’ve gone through a filter; that way, you can track
    how much impact the filters are having. So print the length of the dictionary
    ➋. Assign a variable to hold the length of the name and then use list comprehension
    to create a new list by looping through the words in word_list_ini, keeping those
    whose length is the same as the number of letters in name, and converting them
    to lowercase ➌. Next, print the length of this new word list ➍, and finally, return
    this new list for use in the next function ➎.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating the C-V Map**'
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You need to convert the prepared word list to a c-v map. Remember that you’re
    no longer interested in actual words in the dictionary; those have been reviewed
    and rejected. Your goal is to shuffle the remaining letters until they form something
    that resembles a proper noun.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-7](ch03.xhtml#ch03list7) defines a function that generates c-v maps
    for each word in word_list. The program, *voldemort_british.py*, will use the
    c-v map to judge whether a shuffled letter combination is reasonable based on
    consonant-vowel patterns in the English language.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 3'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def cv_map_words(word_list):'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '"""Map letters in words to consonants & vowels."""'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: ➋ vowels = 'aeiouy'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: ➌ cv_mapped_words = []
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for word in word_list:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: temp = ''
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'for letter in word:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'if letter in vowels:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: temp += 'v'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: temp += 'c'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: cv_mapped_words.append(temp)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '# determine number of UNIQUE c-v patterns'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: ➎ total = len(set(cv_mapped_words))
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '# target fraction to eliminate'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: ➏ target = 0.05
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '# get number of items in target fraction'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: ➐ n = int(total * target)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: ➑ count_pruned = Counter(cv_mapped_words).most_common(total - n)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: ➒ filtered_cv_map = set()
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'for pattern, count in count_pruned:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: filtered_cv_map.add(pattern)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: print("length filtered_cv_map = {}".format(len(filtered_cv_map)))
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: ➓ return filtered_cv_map
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-7: Generates c-v maps from the words in* word_list'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Define the cv_map_words() function to take the prepped word list as an argument
    ➊. Since consonants and vowels form a binary system, you can define the vowels
    with a string ➋. Create an empty list to hold the maps ➌. Then loop through the
    words and the letters in each word, converting the letters to either a *c* or
    *v* ➍. Use a variable called temp to accumulate the map; then append it to the
    list. Note that temp is reinitialized each time the loop repeats.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: You want to know the frequency of occurrence of a given c-v map pattern (for
    example, *cvcv*), so you can remove those with a low likelihood of occurrence.
    Before calculating the frequency, you need to collapse your list down to unique
    c-v maps—as it is now, *cvcv* may be repeated many, many times. So, turn the cv_mapped_words
    list into a set, to remove duplicates, and get its length ➎. Now you can define
    a target percentage to eliminate, using fractional values ➏. Start with a low
    number like 0.05—equivalent to 5 percent—so you’re less likely to eliminate anagrams
    that can form usable proper names. Multiply this target value by the total length
    of the cv_mapped_words set and assign the result to the variable n ➐. Be sure
    to convert n to an integer; since it will represent a count value, it can’t be
    a float.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: The Counter module data type has a handy method, most_common(), that will return
    the most common items in a list based on a *count* value that you provide; in
    this case, that value will be the length of the c-v map list, total, minus n.
    The value you pass most_common() must be an integer. If you pass the most_common()
    function the length of the list, it will return all the items in the list. If
    you subtract the count for the least likely 5 percent, you will effectively eliminate
    these c-v maps from the list ➑.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Counter returns a dictionary, but all you need are the final c-v maps,
    not their associated frequency counts. So initialize an empty set called filtered-cv-map
    ➒ and loop through each key-value pair in count_pruned(), adding only the key
    to the new set. Print the length of this set, so you can see the impact of the
    filter. Then finish by returning the filtered c-v map for use in the next function
    ➓.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the C-V Map Filter**'
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-8](ch03.xhtml#ch03list8) applies the c-v map filter: anagrams are
    generated based on permutations of the letters in the name variable, and then
    the program converts them to c-v maps and compares those anagrams to the filtered
    c-v maps built with the cv_map_words() function. If an anagram’s c-v map is found
    in filtered_cv_map, then the program stores the anagram for the next filter.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 4'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def cv_map_filter(name, filtered_cv_map):'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '"""Remove permutations of words based on unlikely cons-vowel combos."""'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: ➋ perms = {''.join(i) for i in permutations(name)}
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: print("length of initial permutations set = {}".format(len(perms)))
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: vowels = 'aeiouy'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: ➌ filter_1 = set()
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for candidate in perms:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: temp = ''
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'for letter in candidate:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'if letter in vowels:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: temp += 'v'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: temp += 'c'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '➎ if temp in filtered_cv_map:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: filter_1.add(candidate)
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: print("# choices after filter_1 = {}".format(len(filter_1)))
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: ➏ return filter_1
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-8: Defines* cv_map_filter() *function*'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the function cv_map_filter() to take two arguments: the name, followed
    by the set of c-v maps returned by cv_map_words() ➊. Use set comprehension and
    the permutations module to generate the set of permutations ➋. I described this
    process in “[Project #6: Finding Voldemort: The Gallic Gambit](ch03.xhtml#lev65)”
    on [page 49](ch03.xhtml#page_49). Use a set here to permit later use of set operations,
    like taking the difference between two filter sets. This also removes duplicates,
    as permutations treats each *o* as a separate item, and returns 9!, rather than
    9! / 2!. Note that permutations considers *tmv**o**ordle* and *tmvo**o**rdle*
    different strings.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Now initialize an empty set to hold the contents of the first filter ➌ and
    begin looping through the permutations ➍. Use the term *candidate*, as most of
    these aren’t words but just strings of random letters. For each candidate, loop
    through the letters and map them to a *c* or a *v*, as you did with the cv_words()
    function. Check each c-v map, temp, for membership in filtered_cv_map. This is
    one reason for using sets: membership checks are very fast. If the candidate meets
    the condition, add it to filter_1 ➎. Finish by returning your new anagram set
    ➏.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the Trigram Filter**'
  id: totrans-471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-9](ch03.xhtml#ch03list9) defines the trigram filter, which removes
    the permutations with unlikely three-letter triplets. It uses a text file derived
    from various cryptography websites that has been tailored to the letters in *tmvoordle*.
    This function will return only permutations that include one of these trigrams;
    the main() function will pass the new set to the next filter function.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 5'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def trigram_filter(filter_1, trigrams_filtered):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '"""Remove unlikely trigrams from permutations."""'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: ➋ filtered = set()
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for candidate in filter_1:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '➍ for triplet in trigrams_filtered:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: triplet = triplet.lower()
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'if triplet in candidate:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: filtered.add(candidate)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: ➎ filter_2 = filter_1 - filtered
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: print("# of choices after filter_2 = {}".format(len(filter_2)))
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: ➏ return filter_2
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-9: Defines the* trigram_filter() *function*'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Parameters for the trigram filter include the output from the c-v map filter
    and the external list of unlikely trigrams, trigrams_filtered ➊.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an empty set to hold permutations that contain one of the forbidden
    trigrams ➋. Then start another for loop that looks through the candidates that
    survived the last filter ➌. A nested for loop looks at each triplet in the trigrams
    list ➍. If the triplet is in the candidate, it is added to the filter.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use set operations to subtract the new filter from filter_1 ➎ and
    then return the difference for use with the next filter ➏.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the Digram Filter**'
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-10](ch03.xhtml#ch03list10) defines the digram filter, which removes
    unlikely letter pairs. Some will trigger the filter if they occur anywhere within
    the permutation; others will do so only if they occur at the start of the permutation.
    The disallowed digrams are based on the shaded cells in [Table 3-2](ch03.xhtml#ch03tab2).
    The function returns the results of this filter for use in the final filter function.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 6'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def letter_pair_filter(filter_2):'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '"""Remove unlikely letter-pairs from permutations."""'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: ➋ filtered = set()
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: ➌ rejects = ['dt', 'lr', 'md', 'ml', 'mr', 'mt', 'mv',
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '''td'', ''tv'', ''vd'', ''vl'', ''vm'', ''vr'', ''vt'']'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: ➍ first_pair_rejects = ['ld', 'lm', 'lt', 'lv', 'rd',
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '''rl'', ''rm'', ''rt'', ''rv'', ''tl'', ''tm'']'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '➎ for candidate in filter_2:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '➏ for r in rejects:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 'if r in candidate:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: filtered.add(candidate)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '➐ for fp in first_pair_rejects:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'if candidate.startswith(fp):'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: filtered.add(candidate)
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: ➑ filter_3 = filter_2 - filtered
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: print("# of choices after filter_3 = {}".format(len(filter_3)))
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '➒ if ''voldemort'' in filter_3:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: print("Voldemort found!", file=sys.stderr)
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: ➓ return filter_3
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-10: Defines the* letter_pair_filter() *function*'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: This filter accepts the results of the previous filter as an argument ➊. An
    empty set is initialized to hold any discarded permutations ➋. Then two lists
    of rejected pairs are assigned to the variables rejects ➌ and first_pair_rejects
    ➍. Both lists were entered manually. The first represents cells shaded black in
    [Table 3-2](ch03.xhtml#ch03tab2); the second references cells shaded gray. Any
    permutation that contains a member of the first list—anywhere—will be discarded;
    permutations that *start with* a member of the second list will not be allowed.
    You can add or remove digrams to these lists to change how the filter behaves.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Begin looping through the permutations—continue to refer to these as “candidates,”
    as they aren’t necessarily words ➎. A nested for loop goes through the pairs in
    rejects, determines whether any are in candidate, and adds them to the filtered
    set ➏. A second nested for loop repeats this process for the first_pair_rejects
    ➐. Subtract filtered from the set returned from the previous function, filter_2
    ➑.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: For fun *and* to ensure you haven’t filtered too far, check whether *voldemort*
    is included in filter_3 ➒ and print an announcement to highlight the discovery,
    using eye-catching red font for IDLE users. Then finish by returning the final
    filtered set ➓.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '**Letting the User Choose the Starting Letter**'
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You don’t know ahead of time whether your filtering will be successful. You
    may still end up with thousands of permutations. Providing the option to look
    at only a subset of the output won’t reduce the overall number, but it will make
    it *psychologically* easier to face. [Listing 3-11](ch03.xhtml#ch03list11) adds,
    to *voldemort_british.py*, the ability to view a list of anagrams that begin with
    a certain input letter.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 7'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def view_by_letter(name, filter_3):'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '"""Filter to anagrams starting with input letter."""'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: ➋ print("Remaining letters = {}".format(name))
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '➌ first = input("select a starting letter or press Enter to see all: ")'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: ➍ subset = []
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '➎ for candidate in filter_3:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'if candidate.startswith(first):'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: subset.append(candidate)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: ➏ print(*sorted(subset), sep='\n')
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: print("Number of choices starting with {} = {}".format(first, len(subset)))
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: ➐ try_again = input("Try again? (Press Enter else any other key to Exit):")
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'if try_again.lower() == '''':'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: ➑ view_by_letter(name, filter_3)
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: ➒ sys.exit()
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-11: Defines the* view_by_letter() *function*'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: Define the view_by_letter() function to take both the name variable and filter_3
    as arguments ➊. You need the name so you can show the user the available letter
    choices on which to filter ➋. Get the user’s input on whether they want to see
    all the remaining permutations or just those beginning with a certain letter ➌.
    Then start an empty list to hold the latter subset ➍.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: A for loop, with a conditional, checks whether a candidate starts with the chosen
    letter and appends those letters that pass to subset ➎. This list is printed with
    the splat operator ➏. Then the program asks the user whether they want to try
    again or exit ➐. If they press ENTER, then view_by_letter() is called, recursively,
    and runs again from the start ➑. Otherwise, the program exits ➒. Note that Python
    has a default recursion depth limit of 1,000, which we’ll ignore in this project.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the main() Function**'
  id: totrans-536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Back in the global space, [Listing 3-12](ch03.xhtml#ch03list12) completes the
    code by calling the main() function if the user runs the program in stand-alone
    mode versus importing into another program.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 8'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-12: Calls the* main() *function*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Example output from the completed program is shown below. After the program
    applies the third filter, there are 248 permutations remaining, of which a very
    manageable 73 start with *v*. I’ve omitted the printout of the permutations for
    brevity. As noted in the output, *voldemort* survives the filtering.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: length initial word_list = 60388
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: length of new word_list = 8687
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: length filtered_cv_map = 234
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: length of initial permutations set = 181440
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: choices after filter_1 = 123120
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: of choices after filter_2 = 674
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: of choices after filter_3 = 248
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Voldemort found!
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Remaining letters = tmvoordle
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: 'select a starting letter or Enter to see all: v'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, another surviving permutation is *lovedmort*. Given how many
    people Voldemort killed—or had killed—this may be the most appropriate moniker
    of all.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you first wrote code that found the anagrams for a given word
    or name. You then expanded on this to find phrasal name anagrams, working interactively
    with the user. Finally, you employed cryptanalytical techniques to tease *Voldemort*
    out of almost 200,000 possible anagrams. Along the way, you applied useful functionality
    in the collections and itertools modules.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Jumble* website is *[http://www.jumble.com/](http://www.jumble.com/)*.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find some representative online anagram generators at the following
    sites:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '*[http://wordsmith.org/anagram/](http://wordsmith.org/anagram/)*'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[https://www.dcode.fr/anagram-generator](https://www.dcode.fr/anagram-generator)*'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[http://www.wordplays.com/anagrammer/](http://www.wordplays.com/anagrammer/)*'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More anagram programs are found in *Think Python, 2nd Edition* (O’Reilly, 2015)
    by Allen Downey.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '*Cracking Codes with Python* (No Starch Press, 2017) by Al Sweigart provides
    more code for computing word patterns, such as those used for filtering in the
    *voldemort_british.py* program.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Finding Digrams**'
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You *could* comb through cryptography websites looking for frequency statistics,
    or you could derive them for yourself. Write a Python program that finds all the
    digrams in *tmvoordle* and then counts their frequency of occurrence in a dictionary
    file. Be sure to test your code on words like *volvo*, so you don’t overlook repeating
    digrams in the same word. You can find a solution in the appendix or download
    *count_digrams_practice.py* from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Automatic Anagram Generator**'
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the online anagram generators I just referenced in “Further Reading”
    and write a Python program that mimics one of these. Your program should automatically
    generate phrase anagrams from an input name and display a subset (for example,
    the first 500) for the user to review.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
