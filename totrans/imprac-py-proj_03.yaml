- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: SOLVING ANAGRAMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决字谜**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: An *anagram* is a word formed by rearranging the letters of another word. For
    example, *Elvis* yields the eerie trio *evils*, *lives*, and *veils*. Does this
    mean Elvis still lives but veils his evil existence? In the book *Harry Potter
    and the Chamber of Secrets*, “I am Lord Voldemort” is an anagram of the evil wizard’s
    real name, Tom Marvolo Riddle. “Lord Earldom Vomit” is also an anagram of Tom
    Marvolo Riddle, but author J.K. Rowling had the good sense to pass on that one.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*字谜* 是通过重新排列另一个单词的字母形成的单词。例如，*Elvis* 产生了令人毛骨悚然的三重奏 *evils*、*lives* 和 *veils*。这是否意味着
    Elvis 仍然活着，但隐藏了他邪恶的存在？在《哈利·波特与密室》一书中，“I am Lord Voldemort” 是邪恶巫师真名 Tom Marvolo
    Riddle 的字谜。 “Lord Earldom Vomit” 也是 Tom Marvolo Riddle 的字谜，但作者 J.K. Rowling 很有眼光地放弃了这个版本。'
- en: In this chapter, first you’ll find all the anagrams for a given word or name.
    Then, you’ll write a program that lets a user interactively build an anagram phrase
    from their own name. Finally, you’ll play computer wizard and see what it takes
    to extract “I am Lord Voldemort” from “Tom Marvolo Riddle.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将首先找到给定单词或姓名的所有字谜。然后，你将编写一个程序，让用户可以交互式地从自己的名字构建字谜短语。最后，你将成为计算机巫师，看看如何从
    “Tom Marvolo Riddle” 中提取 “I am Lord Voldemort”。
- en: '**Project #4: Finding Single-Word Anagrams**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #4：查找单词字谜**'
- en: You’ll start by analyzing simple single-word anagrams and figuring out how to
    identify them programmatically. Having accomplished this, you’ll be ready to take
    on anagram phrases in the following section.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从分析简单的单词字谜开始，并搞清楚如何通过编程来识别它们。完成这个任务后，你就准备好在接下来的章节中处理字谜短语了。
- en: '**THE OBJECTIVE**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Use Python and a dictionary file to find all the single-word anagrams for a
    given English word or single name. You can read instructions for finding and loading
    dictionary files at the start of [Chapter 2](ch02.xhtml#ch02).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 和字典文件查找给定英语单词或单一姓名的所有单词字谜。你可以在 [第 2 章](ch02.xhtml#ch02) 开头阅读查找和加载字典文件的说明。
- en: '***The Strategy and Pseudocode***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: 'More than 600 newspapers and 100 internet sites carry an anagram game called
    *Jumble*. Created in 1954, it’s now the most recognized word-scramble game in
    the world. *Jumble* can be really frustrating, but finding anagrams is almost
    as easy as finding palindromes—you just need to know the common characteristic
    of all anagrams: they must have the same number of the same letters.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 超过 600 家报纸和 100 个网站都有一个叫做 *Jumble* 的字谜游戏。该游戏创建于 1954 年，现在是世界上最受欢迎的字谜游戏。*Jumble*
    可能会非常让人沮丧，但找字谜几乎像找回文一样简单——你只需要知道所有字谜的共同特点：它们必须包含相同数量的相同字母。
- en: '**Identifying an Anagram**'
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**识别字谜**'
- en: Python doesn’t contain a built-in anagram operator, but you can easily write
    one. For the projects in this chapter, you’ll load the dictionary file from [Chapter
    2](ch02.xhtml#ch02) as a list of strings. So the program needs to verify that
    two strings are anagrams of each other.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有内建的字谜运算符，但你可以很容易地编写一个。在本章的项目中，你将从 [第 2 章](ch02.xhtml#ch02) 加载字典文件作为字符串列表。因此，程序需要验证两个字符串是否为彼此的字谜。
- en: 'Let’s look at an example. *Pots* is an anagram of *stop*, and you can verify
    that *stop* and *pots* have the same number of letters with the `len()` function.
    But there’s no way for Python to know whether two strings have the same number
    of any single character—at least not without converting the strings to another
    data structure or using a counting function. So, instead of looking at these two
    words simply as strings, you can represent them as two lists containing single-character
    strings. Create these lists in a shell, like IDLE, and name them `word` and `anagram`,
    as I’ve done here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。*Pots* 是 *stop* 的字谜，你可以通过 `len()` 函数验证 *stop* 和 *pots* 的字母数相同。但 Python
    无法知道两个字符串是否有相同数量的单个字符——至少在不将字符串转换为其他数据结构或使用计数函数的情况下无法知道。所以，与其简单地将这两个单词视为字符串，不如将它们表示为包含单个字符字符串的两个列表。你可以在
    shell 中（例如 IDLE）创建这些列表，并将它们命名为 `word` 和 `anagram`，正如我在这里所做的那样：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These two lists match our description of an anagram pair; that is, they contain
    the same number of the same letters. But if you try to equate them with the comparison
    operator `==`, the result is `False`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个列表符合我们对字谜对的描述；也就是说，它们包含相同数量的相同字母。但如果你尝试用比较运算符 `==` 将它们相等，结果会是 `False`。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The problem is that the operator (`==`) considers two lists equivalent only
    if they have the same number of the same list items and those items occur in the
    same order. You can easily solve this problem with the built-in function `sorted()`,
    which can take a list as an argument and reorder its contents alphabetically.
    So, if you call `sorted()` twice—once for each of the lists—and then compare the
    sorted lists, they will be equivalent. In other words, `==` returns `True`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于运算符（`==`）仅在两个列表具有相同数量的相同项且这些项按相同顺序排列时，才会认为它们是等价的。你可以通过内置函数`sorted()`轻松解决这个问题，它可以接受一个列表作为参数，并按字母顺序重新排序其内容。因此，如果你分别对这两个列表调用`sorted()`，然后比较排序后的列表，它们将是等价的。换句话说，`==`会返回`True`。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can also pass a string to `sorted()` to create a sorted list like the ones
    in the preceding code snippet. This will be useful for converting the words from
    the dictionary file into sorted lists of single-character strings.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个字符串传递给`sorted()`函数来创建一个排序后的列表，类似于前面的代码片段。这对将字典文件中的单词转换为排序后的单字符字符串列表非常有用。
- en: Now that you know how to verify that you’ve found an anagram, let’s design the
    script in its entirety—from loading a dictionary and prompting the user for a
    word (or name) to searching for and printing all the anagrams.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何验证是否找到一个变位词，让我们设计整个脚本——从加载字典和提示用户输入单词（或名字）到搜索并打印所有的变位词。
- en: '**Using Pseudocode**'
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用伪代码**'
- en: Remember that planning with pseudocode will help you spot potential issues and
    spotting those issues early will save you time. The following pseudocode should
    help you better understand the script we’ll write in the next section, *anagrams.py*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用伪代码进行规划可以帮助你发现潜在的问题，早期发现问题可以节省时间。以下的伪代码应有助于你更好地理解我们将在下一节中编写的脚本*anagrams.py*。
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The script will start by loading words from a dictionary file into a list as
    strings. Before you loop through the dictionary in search of anagrams, you need
    to know which word you want anagrams of, and you need a place to store anagrams
    when you find them. So, first ask the user to input a word and then create an
    empty list to store the anagrams. Once the program has looped through every word
    in the dictionary, it will print that list of anagrams.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将首先从字典文件中加载单词到一个字符串列表中。在开始遍历字典查找变位词之前，你需要知道你想要查找变位词的单词，并且需要一个地方来存储找到的变位词。所以，首先要求用户输入一个单词，然后创建一个空列表来存储变位词。一旦程序遍历完字典中的每个单词，它将打印出变位词列表。
- en: '***Anagram-Finder Code***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***变位词查找器代码***'
- en: '[Listing 3-1](ch03.xhtml#ch03list1) loads a dictionary file, accepts a word
    or name *specified within the program*, and finds all the anagrams in the dictionary
    file for that word or name. You’ll also need the dictionary-loading code from
    [Chapter 2](ch02.xhtml#ch02). You can download these from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *anagrams.py* and *load_dictionary.py*, respectively. Keep both files in the
    same folder. You can use the same dictionary file you used in [Chapter 2](ch02.xhtml#ch02)
    or download another one (see [Table 2-1](ch02.xhtml#ch02tab1) on [page 20](ch02.xhtml#page_20)
    for suggestions).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-1](ch03.xhtml#ch03list1)加载一个字典文件，接受程序中*指定的*单词或名字，并查找该单词或名字在字典文件中的所有变位词。你还需要在[第二章](ch02.xhtml#ch02)中获取字典加载的代码。你可以从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载这两个文件，分别为*anagrams.py*和*load_dictionary.py*。请将这两个文件保存在同一文件夹内。你可以使用在[第二章](ch02.xhtml#ch02)中使用的相同字典文件，或者下载另一个文件（有关建议，请参见[表格
    2-1](ch02.xhtml#ch02tab1)，位于[第20页](ch02.xhtml#page_20)）。'
- en: '*anagrams.py*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*anagrams.py*'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 3-1: Given a word (or name) and a dictionary file, this program searches
    for and prints a list of anagrams.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-1：给定一个单词（或名字）和一个字典文件，该程序会搜索并打印出一个包含所有变位词的列表。*'
- en: You start by importing the `load_dictionary` module you created in [Chapter
    2](ch02.xhtml#ch02) ➊. This module will open a dictionary text file and, with
    its `load()` function, load all the words into a list ➋. The **.txt* file you
    use may be different, depending on which dictionary file you downloaded (see “[Finding
    and Opening a Dictionary](ch02.xhtml#lev33)” on [page 20](ch02.xhtml#page_20)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你从导入你在[第二章](ch02.xhtml#ch02)中创建的`load_dictionary`模块开始 ➊。这个模块将打开一个字典文本文件，并通过其`load()`函数将所有单词加载到一个列表中
    ➋。你使用的**.txt**文件可能不同，具体取决于你下载了哪个字典文件（参见[“查找并打开字典”](ch02.xhtml#lev33)，位于[第20页](ch02.xhtml#page_20)）。
- en: Next, create an empty list, called `anagram_list`, to hold any anagrams you
    find ➌. Have the user add a *single* word, such as their first name ➍. This doesn’t
    have to be a proper name, but we’ll refer to it as `name` in the code to distinguish
    it from a dictionary `word`. Print this name so the user can see what was entered.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个空列表，命名为`anagram_list`，用于存储找到的任何字谜 ➌。让用户添加一个*单独的*单词，例如他们的名字 ➍。这不一定是一个正式的名字，但我们将在代码中称其为`name`，以便与字典中的`word`区分开。打印这个名字，以便用户能看到输入了什么内容。
- en: The next line anticipates a problematic user action. People tend to type their
    name with an uppercase first letter, but dictionary files may not include uppercase
    letters, and that matters to Python. So, first convert all letters to lowercase
    with the `.lower()` string method ➎.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行预见到了一个可能出现的问题用户行为。人们往往会输入以大写字母开头的名字，但字典文件可能不包括大写字母，而这对Python来说是有影响的。因此，首先使用`.lower()`字符串方法将所有字母转换为小写
    ➎。
- en: Now sort the name ➏. As mentioned previously, you can pass `sorted()` a string
    as well as a list.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对名字进行排序 ➏。如前所述，你可以将`sorted()`传递给一个字符串，而不仅仅是一个列表。
- en: With the input sorted alphabetically in a list, it’s time to find anagrams.
    Start a loop through each word in the dictionary word list ➐. To be safe, convert
    the word to lowercase, as comparison operations are case-sensitive. After the
    conversion, compare the word to the unsorted name, because a word can’t be an
    anagram of itself. Next, sort the dictionary word and compare it to the sorted
    name. If it passes, append that dictionary word to `anagram_list`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输入按字母顺序排列在列表中后，接下来是查找字谜。开始遍历字典单词列表中的每个单词 ➐。为了安全起见，将单词转换为小写字母，因为比较操作是区分大小写的。转换后，将单词与未排序的名称进行比较，因为一个单词不能是它自己的字谜。接下来，对字典单词进行排序，并与排序后的名称进行比较。如果匹配，则将该字典单词添加到`anagram_list`中。
- en: Now display the results. First, check whether the anagram list is empty. If
    it is, print a whimsical reply so you don’t just leave the user hanging ➑. If
    the program found at least one anagram, print the list using the splat (`*`) operator.
    Remember from [Chapter 2](ch02.xhtml#ch02) that splat lets you print each member
    of a list on a separate line ➒.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在显示结果。首先，检查字谜列表是否为空。如果为空，打印一个俏皮的回复，这样就不会让用户空等 ➑。如果程序找到了至少一个字谜，则使用拆包（`*`）操作符打印列表。记住在[第2章](ch02.xhtml#ch02)中提到的，拆包让你将列表中的每个成员打印在单独的一行
    ➒。
- en: 'The following is example output for this program, using the input name *Foster*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该程序的示例输出，使用输入名字*Foster*：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you’d like to use another input, change the value of the `name` variable
    in the source code. As an exercise, try to adjust the code so that the user is
    prompted to input the name (or word); you can do this with the `input()` function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用其他输入，可以在源代码中更改`name`变量的值。作为练习，尝试调整代码，使程序提示用户输入名字（或单词）；你可以使用`input()`函数实现这一点。
- en: '**Project #5: Finding Phrase Anagrams**'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#5：寻找短语字谜**'
- en: In the previous project, you took a single name or word and rearranged all the
    letters to find single-word anagrams. Now you will derive multiple words from
    a name. The words in these *phrase anagrams* form only part of the input name,
    and you will need several words to exhaust the available letters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个项目中，你将一个名字或单词的字母重新排列，找到单一单词的字谜。现在，你将从一个名字中推导出多个单词。这些*短语字谜*只包含输入名称的一部分字母，因此你需要几个单词来用尽所有字母。
- en: '**THE OBJECTIVE**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write a Python program that lets a user interactively build an anagram phrase
    from the letters in their name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，让用户通过互动从名字中的字母构建字谜短语。
- en: '***The Strategy and Pseudocode***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: The very best phrase anagrams are those that describe some well-known characteristic
    or action associated with the name bearer. For example, the letters in Clint Eastwood
    can be rearranged to form *old west action*, Alec Guinness yields *genuine class*,
    Madam Curie produces *radium came*, George Bush gives *he bugs Gore*, and Statue
    of Liberty contains *built to stay free*. My own name yields *a huge navel*, which
    is not really one of my characteristics.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最棒的短语字谜是那些描述与名字拥有者相关的著名特征或行为的。例如，“Clint Eastwood”的字母可以重新排列形成*old west action*，“Alec
    Guinness”可以变成*genuine class*，“Madam Curie”变为*radium came*，“George Bush”变为*he bugs
    Gore*，而“Statue of Liberty”则包含*built to stay free*。我自己的名字重新排列后得出*a huge navel*，这其实并不是我的特点。
- en: 'At this point, you may see a strategic challenge ahead: how does a computer
    handle contextual content? The folks at IBM who invented Watson seem to know,
    but for the rest of us, that boulder is a little hard to lift.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到此时，你可能会看到一个战略性的挑战：计算机如何处理上下文内容？发明了Watson的IBM团队似乎知道答案，但对于我们其他人来说，这块巨石有点难以搬动。
- en: The *brute-force method* is a common approach used in online anagram generators.
    These algorithms take a name and return lots of random anagram phrases (generally,
    100s to 10,000+). Most of the returned phrases are nonsense, and scrolling through
    hundreds of these can be a chore.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*暴力破解法*是在线异位词生成器中常用的一种方法。这些算法接收一个名字并返回大量随机的异位词短语（通常是100个到1万多个）。大多数返回的短语是无意义的，滚动浏览这些内容可能是件繁琐的事。'
- en: An alternative approach is to acknowledge that humans are best at contextual
    issues and write a program that helps the human work through the problem. The
    computer can take the initial name and provide words that can be made from some
    (or all) the letters in it; the user can then choose a word that “makes sense.”
    The program will then recalculate the word choices from the remaining letters
    in the name, repeating the process until every letter is used or the possible
    word choices are exhausted. This design plays to the strengths of both participants.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是认识到人类在处理上下文问题时最为擅长，因此编写一个程序帮助人类解决问题。计算机可以获取初始名称并提供从其中一些（或所有）字母组成的单词；然后用户可以选择一个“合适”的单词。程序随后将根据名称中剩余字母重新计算单词选项，直到每个字母都被使用或所有可能的单词选项耗尽。这个设计发挥了双方的优势。
- en: You’ll need a simple interface that prompts the user to input the initial name,
    displays potential word choices, and displays any remaining letters. The program
    will also need to keep track of the growing anagram phrase and let the user know
    when every letter has been used. There will likely be lots of failed attempts,
    so the interface should allow the user to restart the process at any time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个简单的界面，提示用户输入初始名称，展示潜在的单词选项，并显示剩余的字母。程序还需要跟踪正在生成的异位词短语，并在每个字母都被使用时通知用户。由于很可能会有许多失败的尝试，所以界面应该允许用户随时重新开始过程。
- en: Since anagrams have the same number of the same letters, another way to identify
    them is to count individual letters. If you think of your name as a collection
    of letters, then a word can be built from your name if (1) all its letters occur
    in your name and (2) they occur *at the same frequency or less*. Obviously, if
    *e* occurs three times in a word and twice in your name, the word can’t be derived
    from your name. So, if the collection of letters that make up a word is not a
    subset of the collection of letters in your name, then that word cannot be part
    of your name anagram.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异位词具有相同数量的相同字母，另一种识别异位词的方法是统计每个字母的出现次数。如果你将你的名字看作一个字母集合，那么一个单词可以由你的名字构成，当且仅当（1）该单词的所有字母都出现在你的名字中，并且（2）它们的出现频率相同或更少。显然，如果*e*在一个单词中出现三次，而在你的名字中出现两次，那么这个单词不能由你的名字衍生出来。因此，如果构成一个单词的字母集合不是你名字中字母集合的子集，那么这个单词就不能是你名字的异位词。
- en: '**Using Counter to Tally Letters**'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用Counter来统计字母**'
- en: Fortunately for us, Python ships with a module named `collections` that includes
    several container data types. One of these types, `Counter`, counts the occurrences
    of an item. Python stores the items as dictionary keys and the counts as dictionary
    values. For example, the following code snippet counts how many of each bonsai
    tree type is in a list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python自带了一个名为`collections`的模块，其中包含了几种容器数据类型。其中一种类型，`Counter`，用于统计项的出现次数。Python将这些项存储为字典的键，将计数存储为字典的值。例如，下面的代码片段统计了在一个列表中每种盆栽树的数量。
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `my_bonsai_trees` list contains multiples of the same type of tree ➊. `Counter`
    tallies up the trees ➋ and creates an easy-to-reference dictionary ➌. Note that
    the `print()` function is optional and is used here for clarity. Entering `count`,
    alone, will also display the dictionary contents.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_bonsai_trees`列表包含了多种相同类型的树木 ➊。`Counter`统计这些树木 ➋，并创建一个便于引用的字典 ➌。请注意，`print()`函数是可选的，这里使用它是为了清晰展示。单独输入`count`也会显示字典内容。'
- en: 'You can use `Counter`, instead of the `sorted()` method, to find single-word
    anagrams. Rather than two sorted lists, the output will be two dictionaries, which
    can also be directly compared with `==`. Here’s an example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Counter`，而不是`sorted()`方法，来查找单词异位词。输出将是两个字典，而不是两个排序后的列表，这两个字典也可以直接用`==`进行比较。下面是一个示例：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Counter` produces a dictionary for each word that maps each letter in the
    word to the number of times it occurs ➊➋. The dictionaries are unsorted, but despite
    the lack of sorting, Python correctly identifies each dictionary as being equal
    if the dictionaries contain the same letters and the same counts:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 为每个单词生成一个字典，将单词中的每个字母映射到它出现的次数➊➋。这些字典是无序的，但尽管没有排序，Python 仍能正确识别相同字母和相同计数的字典是相等的：'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A `Counter` gives you a wonderful way to find words that “fit” in a name. If
    the count for each letter in a word is less than or equal to the count for the
    same letter in the name, then the word can be derived from the name!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 提供了一种很棒的方式来查找在名称中“适配”的单词。如果一个单词中每个字母的计数小于或等于该字母在名称中出现的计数，那么这个单词就可以从该名称中派生出来！'
- en: '**The Pseudocode**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**伪代码**'
- en: 'We’ve now made two important design decisions: (1) let the user interactively
    build their anagram one word at a time and (2) use the `Counter` method to find
    anagrams. This is enough to start thinking about high-level pseudocode:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在做出了两个重要的设计决策：（1）让用户交互式地每次构建一个字谜；（2）使用 `Counter` 方法来查找字谜。这足以开始思考高层次的伪代码：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Divvying Up the Work**'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分配工作**'
- en: As procedural code becomes more complex, it becomes necessary to encapsulate
    much of it in functions. This makes it easier to manage input and output, perform
    recursion, and read the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 随着过程性代码变得越来越复杂，有必要将大部分代码封装到函数中。这使得管理输入和输出、执行递归以及阅读代码变得更加容易。
- en: A *main function* is where a program starts its execution, and enables high-level
    organization, such as managing all the bits and pieces of the code, including
    dealing with the user. In the phrase anagram program, the main function will wrap
    all the “worker bee” functions, take *most* of the user input, keep track of the
    growing anagram phrase, determine when the phrase is complete, and show the user
    the result.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*主函数* 是程序开始执行的地方，并且使得高层次的组织变得可能，例如管理代码的各个部分，包括处理用户。在短语字谜程序中，主函数将包装所有“工作蜂”函数，处理*大部分*用户输入，跟踪逐渐生成的字谜短语，确定短语何时完成，并向用户显示结果。'
- en: 'Sketching out the tasks and their flow with pencil and paper is a great way
    to figure out what you want to do and where (like “graphical pseudocode”). [Figure
    3-1](ch03.xhtml#ch03fig1) is a flowchart with function assignments highlighted.
    In this case, three functions should be sufficient: `main()`, `find_anagrams()`,
    and `process_choice()`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 用铅笔和纸草拟任务及其流程是一个很好的方法，可以帮助你理清想做什么以及在哪里做（类似于“图形伪代码”）。[图 3-1](ch03.xhtml#ch03fig1)
    是一个流程图，突出显示了函数分配。在这种情况下，三个函数应该足够：`main()`、`find_anagrams()` 和 `process_choice()`。
- en: The `main()` function’s primary task is to set the letter count limit and manage
    the `while` loop responsible for the general phrase anagram build. The `find_anagrams()`
    function will take the current collection of letters remaining in a name and return
    all possible words that can be made from those letters. The words are then displayed
    for the user, along with the current phrase, which is “owned” and displayed by
    the `main()` function. Then, the `process_choice()` function prompts the user
    to start over or choose a word for the anagram phrase. If the user makes a choice,
    this function determines whether the letters in the choice are available. If they
    aren’t, the user is prompted to choose again or start over. If the user makes
    a valid choice, the letters in the user’s choice are removed from the list of
    remaining letters, and both the choice and list of leftovers are returned. The
    `main()` function adds the returned choice to the existing phrase. If the limit
    is reached, the completed phrase anagram is displayed, and the user is asked to
    start over or exit.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数的主要任务是设置字母计数限制并管理负责通用短语字谜构建的 `while` 循环。`find_anagrams()` 函数将获取名称中剩余的当前字母集合，并返回可以由这些字母组成的所有可能单词。然后，单词将显示给用户，并且当前的短语由
    `main()` 函数“拥有”并显示。接着，`process_choice()` 函数提示用户重新开始或选择一个字谜单词。如果用户做出选择，这个函数将判断所选字母是否可用。如果不可用，用户将被提示重新选择或重新开始。如果用户做出有效选择，所选字母将从剩余字母列表中移除，并且返回所选字和剩余字母列表。`main()`
    函数将返回的选择添加到现有的短语中。如果达到限制，完成的短语字谜将显示出来，用户将被询问是否重新开始或退出。'
- en: Note that you ask for the initial name in the *global* scope, rather than in
    the `main()` function. This allows the user to start over fresh at any time without
    having to re-enter their name. For now, if the user wants to choose a brand-new
    name, they’ll have to exit the program and start over. In [Chapter 9](ch09.xhtml#ch09),
    you’ll use a menu system that lets users completely reset what they’re doing without
    exiting.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你在 *全局* 范围内请求初始名称，而不是在 `main()` 函数中。这让用户可以随时重新开始，而无需重新输入他们的名称。目前，如果用户想选择一个全新的名称，他们必须退出程序并重新开始。在[第
    9 章](ch09.xhtml#ch09)，你将使用一个菜单系统，允许用户完全重置他们的操作而无需退出。
- en: '![image](../images/f0043-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0043-01.jpg)'
- en: '*Figure 3-1: Flowchart for finding phrase anagrams with function assignments
    highlighted*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：带有函数分配高亮的短语字谜流程图*'
- en: '***The Anagram Phrase Code***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字谜短语代码***'
- en: 'The code in this section takes a name from a user and helps them build an anagram
    phrase of that name. You can download the entire script from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *phrase_anagrams.py*. You’ll also need to download the *load_dictionary.py*
    program. Save both files in the same folder. You can use the same dictionary file
    you used in “[Project #4: Finding Single-Word Anagrams](ch03.xhtml#lev50)” on
    [page 36](ch03.xhtml#page_36).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '本节的代码从用户那里获取一个名称，并帮助他们构建该名称的字谜短语。你可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载整个脚本，保存为 *phrase_anagrams.py*。你还需要下载 *load_dictionary.py* 程序。将这两个文件保存在同一文件夹中。你可以使用在
    “[项目 #4：寻找单词字谜](ch03.xhtml#lev50)” 中使用的同一个字典文件，位于 [第 36 页](ch03.xhtml#page_36)。'
- en: '**Setting Up and Finding Anagrams**'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置和查找字谜**'
- en: '[Listing 3-2](ch03.xhtml#ch03list2) imports the modules that *phrase_anagrams.py*
    uses, loads a dictionary file, asks the user for an input name, and defines the
    `find_anagrams()` function, which does most of the work related to finding anagrams.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-2](ch03.xhtml#ch03list2) 导入了 *phrase_anagrams.py* 使用的模块，加载了一个字典文件，询问用户输入一个名称，并定义了
    `find_anagrams()` 函数，该函数完成了大部分与寻找字谜相关的工作。'
- en: '*phrase_anagrams.py,* part 1'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*phrase_anagrams.py,* 第 1 部分'
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 3-2: Imports modules, loads dictionary, and defines the* find_anagrams()
    *function*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-2：导入模块，加载字典，并定义* find_anagrams() *函数*'
- en: Start with the `import` statements ➊, using the recommended order of Python
    Standard Library, third-party modules, and then locally developed modules. You
    need `sys` for coloring specific outputs red in the IDLE window and for letting
    the user exit the program with a keystroke. You’ll use `Counter` to help identify
    anagrams of the input name.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `import` 语句 ➊ 开始，按照推荐的顺序导入 Python 标准库、第三方模块，然后是本地开发的模块。你需要 `sys` 来在 IDLE 窗口中将特定的输出显示为红色，并让用户通过按键退出程序。你将使用
    `Counter` 来帮助识别输入名称的字谜。
- en: Next load the dictionary file using the imported module ➋. The filename argument
    should be the filename of the dictionary you’re using. Because some dictionary
    files omit *a* and *I*, append these (if needed), and sort the list so that they
    can be found at the proper alphabetical locations, rather than at the end of the
    list.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用导入的模块 ➋ 加载字典文件。文件名参数应为你正在使用的字典的文件名。由于一些字典文件省略了 *a* 和 *I*，如果需要，可以将它们附加到字典中，并对列表进行排序，以便它们出现在正确的字母顺序位置，而不是出现在列表的末尾。
- en: Now get a name from the user and assign it to the variable `ini_name` (or “initial
    name”) ➌. You’ll derive a `name` variable from this initial name, and `name` will
    be progressively changed as the user builds up the name anagram. Preserving the
    initial name as a separate variable will let you reset everything if the user
    wants to start over or try again.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从用户那里获取一个名称，并将其分配给变量 `ini_name`（或“初始名称”） ➌。你将从这个初始名称派生出 `name` 变量，并随着用户逐步构建名称字谜，`name`
    变量会不断变化。将初始名称保留为一个单独的变量将允许你在用户希望重新开始或再试一次时重置一切。
- en: The next block of code is `find_anagrams()` ➍, the function for finding anagrams
    in the name. The parameters for this function consist of a name and a word list.
    The function starts by using `Counter` to count the number of times a given letter
    appears in the name and then assigns the count to the variable `name_letter_map`
    ➎; `Counter` uses a dictionary structure with the letter as the key and the count
    as the value. The function then creates an empty list to hold the anagrams and
    starts a `for` loop through each word in the dictionary file ➏.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块是 `find_anagrams()` ➍，用于在 `name` 中查找变位词的函数。该函数的参数包括一个 `name` 和一个单词列表。函数通过使用
    `Counter` 来计算名字中给定字母出现的次数，并将计数分配给变量 `name_letter_map` ➎；`Counter` 使用字典结构，字母作为键，计数作为值。然后，函数创建一个空列表来保存变位词，并开始
    `for` 循环遍历字典文件中的每个单词 ➏。
- en: The `for` loop starts by creating an empty string called `test` ➐. Use this
    variable to accumulate all the letters in the `word` that “fit” in `name`. Then
    make a `Counter` for the current word, as you did for `name`, and call it `word_``letter``_map`
    ➑. Loop through the letters in `word` ➒, checking that the count of each letter
    is the same as, or less than, the count in `name`. If the letter meets this condition,
    then it is added to the test string. Since some letters might get rejected, end
    the loop by running `Counter` on `test` and comparing it to `word_letter_map`.
    If they match, append the word to the anagrams list.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环从创建一个名为 `test` 的空字符串开始 ➐。使用这个变量累积 `word` 中“适合” `name` 的所有字母。然后为当前单词创建一个
    `Counter`，就像你为 `name` 所做的那样，并称其为 `word_``letter``_map` ➑。遍历 `word` 中的字母 ➒，检查每个字母的计数是否与
    `name` 中的计数相同或更少。如果字母满足这个条件，则将其添加到 `test` 字符串中。由于某些字母可能会被拒绝，所以通过对 `test` 运行 `Counter`
    并将其与 `word_letter_map` 进行比较来结束循环。如果它们匹配，则将该单词追加到变位词列表中。'
- en: The function ends by displaying the list of words, using the splat operator
    with `print`, along with some statistics for the user ➓. Note that `find_``anagrams()`
    doesn’t return anything. This is where the human interaction part comes in. The
    program will continue to run, but nothing will happen until the user chooses a
    word from the displayed list.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 函数以使用 `print` 和带有分散运算符的单词列表结尾，并为用户提供一些统计信息 ➓。请注意，`find_``anagrams()` 不返回任何内容。这是人际交互部分的地方。程序将继续运行，但在用户选择列表中的一个单词之前不会发生任何事情。
- en: '**Processing the User’s Choice**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**处理用户的选择**'
- en: '[Listing 3-3](ch03.xhtml#ch03list3) defines `process_choice()`, the function
    in *phrase_anagrams.py* that takes the user’s choice of word (or words), checks
    it against the remaining letters in the `name` variable, and returns acceptable
    choices—along with any leftover letters—to the `main()` function. Like `main()`,
    this function gets to talk directly to the user.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-3](ch03.xhtml#ch03list3) 定义了 `process_choice()` 函数，位于 *phrase_anagrams.py*
    中，它接收用户选择的单词（或多个单词），检查它们与 `name` 变量中剩余的字母是否匹配，并将可接受的选择（连同任何剩余的字母）返回给 `main()`
    函数。像 `main()` 一样，这个函数可以直接与用户交互。'
- en: '*phrase_anagrams.py,* part 2'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*phrase_anagrams.py,* 第二部分'
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 3-3: Defines the* process_choice() *function*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-3：定义了* `process_choice()` *函数*'
- en: Start by defining the function with one parameter called `name` ➊. The first
    time the program is run, this parameter will be the same as the `ini_name` variable—the
    full name entered by the user when the program starts up. After the user has chosen
    a word (or words) to use in the anagram phrase, it will represent the remaining
    letters in the name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从定义只有一个名为 `name` 的参数的函数开始 ➊。第一次运行程序时，这个参数将与 `ini_name` 变量相同，即用户启动程序时输入的完整姓名。用户选择用于变位词短语的单词（或多个单词）后，它将表示姓名中剩余的字母。
- en: 'Start the function with a `while` loop that will run until the user makes a
    valid choice and then get input from the user ➋. The user has a choice of entering
    one or more words from the current anagram list, pressing ENTER to start over,
    or pressing # to quit. Use #, rather than a word or letter, so that it can’t be
    confused for a valid choice.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '使用一个 `while` 循环开始函数，直到用户做出有效选择为止，并从用户那里获取输入 ➋。用户可以选择从当前变位词列表中输入一个或多个单词，按 ENTER
    重新开始，或按 # 退出。使用 # 而不是单词或字母，以避免与有效选择混淆。'
- en: If the user makes a choice, the string is assigned to the variable `candidate`,
    stripped of whitespace, and converted to all lowercase ➌. This is so it can be
    directly compared to the `name` variable. After that, a list is built from the
    `name` variable to hold any remaining letters ➍.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户做出选择，将字符串赋给变量 `candidate`，去除空白并转换为全小写 ➌。这样可以直接与 `name` 变量进行比较。之后，从 `name`
    变量中构建一个列表以保存任何剩余的字母 ➍。
- en: Now begin a loop to subtract the letters used in `candidate` ➎. If a chosen
    letter is present in the list, it’s removed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始一个循环，减去 `candidate` ➎ 中使用的字母。如果选中的字母存在于列表中，它将被移除。
- en: If the user entered a word that isn’t in the displayed list, or entered multiple
    words, a letter may not be present in the list. To check for this, subtract the
    leftover letters from `name` and, if the result is the number of letters in `candidate`,
    determine that the input is valid and break out of the `while` loop ➏. Otherwise,
    display a warning and color it red for those using the IDLE window. The `while`
    loop will keep prompting the user until an acceptable choice is made.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了一个不在显示列表中的单词，或输入了多个单词，可能会导致某些字母不在列表中。为检查这一点，可以从 `name` 中减去剩余字母，如果结果与
    `candidate` 中字母的数量相等，则认为输入有效，并跳出 `while` 循环 ➏。否则，显示警告并将其标红，以便在使用 IDLE 窗口的用户看到。`while`
    循环将继续提示用户，直到做出有效选择。
- en: If all the letters in the user’s choice pass the test, the list of leftovers
    is converted back into a string and used to update the `name` variable ➐. Converting
    the list into a string isn’t strictly necessary, but it keeps the `name` variable
    type consistent and lets you display the remaining letters in a clearly readable
    format without the need for additional `print` arguments.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户选择的所有字母都通过了测试，剩余字母的列表将被转换回字符串，并用于更新 `name` 变量 ➐。将列表转换为字符串并非绝对必要，但这样可以保持
    `name` 变量类型一致，并且使你能够清晰地显示剩余字母，无需额外的 `print` 参数。
- en: Finish by returning both the user’s choice and the string of remaining letters
    (`name`) to the `main()` function ➑.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将用户的选择和剩余字母的字符串（`name`）一起返回给 `main()` 函数 ➑。
- en: '**Defining the main() Function**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义 main() 函数**'
- en: '[Listing 3-4](ch03.xhtml#ch03list4) defines the `main()` function in *phrase_anagrams.py*.
    This function wraps the previous functions, runs a `while` loop, and determines
    when the user has successfully created an anagram phrase.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[列出 3-4](ch03.xhtml#ch03list4) 定义了 *phrase_anagrams.py* 中的 `main()` 函数。这个函数封装了之前的函数，运行一个
    `while` 循环，并决定用户何时成功创建字谜短语。'
- en: '*phrase_anagrams.py,* part 3'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*phrase_anagrams.py，* 第 3 部分'
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 3-4: Defines and calls* main() *function*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 3-4：定义并调用* main() *函数*'
- en: The first order of business is to turn the `ini_name` variable into a continuous
    string of lowercase characters with no whitespace ➊. Remember, case matters to
    Python, so convert all strings to lowercase wherever they occur; that way, comparisons
    will work as intended. Python also recognizes spaces as characters, so you need
    to remove these, as well as hyphens in hyphenated names, before doing any letter
    counts. By declaring this new `name` variable, you preserve the initial name in
    case the user wants to start over. Only `name` will be altered in the `process_choice()`
    function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是将 `ini_name` 变量转化为一个连续的小写字母字符串，并且没有空格 ➊。记住，大小写对 Python 很重要，因此需要在每次出现字符串时都转换为小写；这样，比较才能按预期工作。Python
    还将空格视为字符，所以在进行字母计数之前，需要移除空格和连字符。通过声明这个新的 `name` 变量，你可以保留初始名称，以防用户想要重新开始。只有 `name`
    会在 `process_choice()` 函数中被修改。
- en: Next, get the length of the name ➋ to use as a limit in the `while` loop. This
    will let you know when the anagram phrase has used all the letters in the name
    and it’s time to end the loop. Do this outside the `while` loop to ensure you
    are using the full initial name. Then assign a variable to hold the anagram phrase
    and set a `running` variable to `True` to control the `while` loop.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，获取名称 ➋ 的长度，用作 `while` 循环的限制。这将帮助你确定当字谜短语使用完名称中的所有字母时，应该结束循环。在 `while` 循环外执行此操作，以确保你使用的是完整的初始名称。然后，分配一个变量来保存字谜短语，并将
    `running` 变量设置为 `True`，以控制 `while` 循环。
- en: Now begins the big loop that lets you iterate over the name and build an anagram
    phrase ➌. First, prepare a string to hold the growing phrase and strip it of whitespace
    ➍. Spaces will count as letters and throw off the operator when the length of
    the phrase is compared to the `limit` variable. Next, make the comparison, and
    if the length of the phrase is less than the limit, display the current length
    of the phrase as a prelude to engaging with the user ➎.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始一个大的循环，让你遍历名称并构建字谜短语 ➌。首先，准备一个字符串来保存增长中的短语，并去除空格 ➍。空格会被计算为字母，并在与 `limit`
    变量比较短语长度时引起偏差。接下来，进行比较，如果短语的长度小于限制，显示当前短语的长度，作为与用户互动的序曲 ➎。
- en: It’s time to put the other functions to work. Call `find_anagrams()` ➏ and pass
    it the name and dictionary file to get the list of anagrams in the name. At the
    bottom of the displayed list, show the user the current phrase. Use the `print()`
    function’s `end` parameter to display two `print` statements on the same line.
    This way, you can use a red font on the phrase in the IDLE window to distinguish
    it from all the other information in the display.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让其他函数发挥作用了。调用`find_anagrams()` ➏并传入姓名和字典文件，以获取姓名中的字谜列表。在显示的列表底部，向用户展示当前的短语。使用`print()`函数的`end`参数，将两个`print`语句显示在同一行。这样，你可以在IDLE窗口中使用红色字体显示短语，将其与显示中的其他信息区分开来。
- en: Next, call the `process_choice()` function ➐ to get the user’s word choice and
    add it to the growing anagram phrase. This also gets the updated version of the
    `name` variable so that the program can use it again in the `while` loop in the
    event that the phrase isn’t complete.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用`process_choice()`函数 ➐获取用户的单词选择，并将其添加到逐步完成的字谜短语中。这还会获取更新后的`name`变量，以便程序在短语未完成时可以在`while`循环中再次使用它。
- en: If the length of the phrase is equal to the `limit` variable ➑, the name anagram
    is complete. Let the user know they’re finished and present the phrase using red
    font. Note that you don’t have a conditional for the length of the phrase being
    greater than the `limit` variable. That’s because the `process_choice()` function
    is already handling this outcome (choosing more letters than are available would
    not pass the validation criterion).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果短语的长度等于`limit`变量 ➑，那么姓名的字谜就完成了。让用户知道他们完成了，并用红色字体显示该短语。请注意，你没有为短语长度大于`limit`变量的情况设置条件。这是因为`process_choice()`函数已经处理了这种情况（选择的字母多于可用字母时会未通过验证标准）。
- en: The `main()` function ends by asking the user whether they want to try again.
    If they type `n`, the program ends; if they press ENTER, the `main()` function
    is called again ➒. As stated earlier, the only way for the user to change the
    initial name is to exit and relaunch the program.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数通过询问用户是否想要再试一次来结束。如果用户输入`n`，程序结束；如果按下ENTER键，`main()`函数将再次被调用 ➒。如前所述，用户更改初始姓名的唯一方法是退出并重新启动程序。'
- en: Outside of the `main()` function, end with the standard two lines for calling
    the `main()` function when the program is not imported as a module ➓.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数外，结束时使用标准的两行代码来调用`main()`函数，当程序未作为模块导入时 ➓。
- en: '**Running an Example Session**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行示例会话**'
- en: In this section, I’ve included an example interactive session, using *phrase_anagrams.py*
    and the name *Bill Bo*. Bold font indicates user input, and italic bold font indicates
    where red font is used in the display.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我包含了一个示例互动会话，使用*phrase_anagrams.py*和姓名*Bill Bo*。粗体字体表示用户输入，斜体粗体字体表示在显示中使用红色字体的地方。
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The number of anagrams found depends on the dictionary file you use. If you’re
    having a hard time building anagram phrases, try using a larger dictionary.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 找到的字谜数量取决于你使用的字典文件。如果你在构建字谜短语时遇到困难，可以尝试使用更大的字典。
- en: '**Project #6: Finding Voldemort: The Gallic Gambit**'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #6：寻找伏地魔：高卢策略**'
- en: Did you ever wonder how Tom Riddle came up with the anagram “I am Lord Voldemort”?
    Did he put quill to parchment or just wave a wand? Could the magic of Python have
    helped?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有想过汤姆·里德尔是怎么想出字谜“I am Lord Voldemort”的？他是不是拿起羽毛笔写在羊皮纸上，还是只是挥舞了一下魔杖？Python的魔力是否也有所帮助？
- en: Let’s pretend for a moment that you’re the professor of computer wizardry at
    Hogwarts, and Tom Riddle, school prefect and model student, has come to you for
    help. Using your *phrase_anagrams.py* spell from the previous section, he could
    find *I am Lord* in the very first list of anagrams, much to his delight. But
    the remaining letters, *tmvoordle*, yield only trivial words like *dolt*, *drool*,
    *looter*, and *lover*. Riddle would not be pleased.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是霍格沃茨的计算机魔法教授，汤姆·里德尔，学校的学长和模范学生，来找你寻求帮助。使用你在前一部分中提到的*phrase_anagrams.py*法术，他能够在第一个字谜列表中找到*I
    am Lord*，令他非常高兴。但剩下的字母*tmvoordle*只生成了像*dolt*、*drool*、*looter*和*lover*这样的琐碎单词。里德尔一定不太高兴。
- en: 'In hindsight, the problem is apparent: *Voldemort* is French and won’t be found
    in any English dictionary file. *Vol de la mort* means “flight of death” in French,
    so Voldemort is loosely “death flight.” But Riddle is 100 percent English, and
    so far, you have been working with English. Without reverse engineering, you have
    no more reason to suddenly switch out your English dictionary for a French one
    than you have to use Dutch, German, Italian, or Spanish.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 回头看，问题很明显：*伏地魔*是法语词，无法在任何英语词典中找到。*Vol de la mort*在法语中意味着“死亡之翼”，因此伏地魔可以 loosely
    理解为“死亡飞行”。但Riddle是百分之百的英语名字，而到目前为止，你一直在使用英语。除非进行逆向工程，否则你没有理由突然将英语词典换成法语词典，就像你没有理由去用荷兰语、德语、意大利语或西班牙语一样。
- en: 'You *could* try randomly shuffling the remaining letters and seeing what falls
    out. Unfortunately, the number of possible combinations is the factorial of the
    number of letters divided by the factorial of the number of repeats (*o* occurs
    twice): 9! / 2! = 181,440\. If you were to scroll through all those permutations,
    taking only one second to review each, it would take you over two days to complete
    the list! And if you asked Tom Riddle to do this, he would probably use you to
    make a horcrux!'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你*可以*尝试随机打乱剩余的字母，看看能得到什么。遗憾的是，可能的组合数是字母的阶乘除以重复字母的阶乘（*o*出现两次）：9! / 2! = 181,440。如果你要浏览所有这些排列，每个排列只花一秒钟时间，那么完成整个列表将需要超过两天！如果你让Tom
    Riddle来做这件事，他可能会用你来做魂器！
- en: At this point, I would like to explore two logical paths ahead. One I call the
    “Gallic Gambit” and the other the “British Brute-Force.” We’ll look at the first
    one here and the second one in the next section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我想探讨两条逻辑路径。其一我称之为“高卢战略”，另一条是“英国蛮力法”。我们将在这里讨论第一条，第二条将在下一节讨论。
- en: '**NOTE**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Marvolo *is clearly a* fabricated word *used to make the Voldemort anagram work.
    J.K. Rowling could have gained additional latitude by using* Thomas *for* Tom
    *or by leaving off the* Lord *or* I am *parts. Tricks like these are used when
    the book is translated into non-English languages. In some languages, one or both
    names may need to be changed. In French, the anagram is “I am Voldemort.” In Norwegian,
    “Voldemort the Great.” In Dutch, “My name is Voldemort.” In others, like Chinese,
    the anagram can’t be used at all!*
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Marvolo *显然是一个*人为创造的词*，用来使伏地魔的字谜成立。J.K. Rowling本可以通过使用*Thomas*代替*Tom*，或者省略*Lord*或*I
    am*部分，获得更多的自由。在书籍翻译成非英语语言时，常常使用这样的技巧。在某些语言中，一个或两个名字可能需要更改。在法语中，字谜是“I am Voldemort”。在挪威语中是“Voldemort
    the Great”。在荷兰语中是“My name is Voldemort”。在其他语言中，如中文，根本无法使用字谜！*
- en: 'Tom Riddle was obsessed with beating death, and if you go looking for death
    in *tmvoordle*, you will find both the old French *morte* (as in the famous book
    *Le Morte d’Arthur* by Sir Thomas Malory) and the modern French *mort*. Removing
    *mort* leaves *vodle*, five letters with a very manageable number of permutations.
    In fact, you can easily find *volde* right in the interpreter window:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Tom Riddle痴迷于战胜死亡，如果你在*tmvoordle*中寻找死亡，你会发现既有古老的法语词*morte*（就像在托马斯·马洛里的著名书籍《亚瑟王之死》中的用法），也有现代法语词*mort*。去除*mort*后，剩下的就是*vodle*，五个字母，排列组合的数量非常可控。事实上，你可以轻松地在解释器窗口中找到*volde*：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Start by importing `permutations` from `itertools` ➊. The `itertools` module
    is a group of functions in the Python Standard Library that create iterators for
    efficient looping. You generally think of permutations of *numbers*, but the `itertools`
    version works on *elements* in an iterable, which includes letters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从`itertools` ➊模块导入`permutations`开始。`itertools`模块是Python标准库中的一组函数，用于创建高效的迭代器。你通常会想到数字的排列，但`itertools`的版本是针对可迭代对象中的*元素*，其中包括字母。
- en: After entering the name or, in this case, the remaining letters in the name,
    use list comprehension to create a list of permutations of the name ➋. Join each
    element in a permutation so each item in the final list will be a unique permutation
    of *vodle*. Using `join` yields the new name as an element, `'vodle'`, versus
    a hard-to-read tuple of single-character elements,`('v', 'o', 'd', 'l', 'e')`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输入名字或在此情况下，输入名字中的剩余字母后，使用列表推导创建名字的排列列表 ➋。将排列中的每个元素连接在一起，使得最终列表中的每一项都将是*vodle*的一个独特排列。使用`join`生成的新名字作为一个元素是，'vodle'，而不是一个难以阅读的单字符元组，`('v',
    'o', 'd', 'l', 'e')`。
- en: Get the length of the permutations as a check; that way, you can confirm that
    it is, indeed, the factorial of 5 ➌. At the end, no matter how you print it ➍➎,
    *volde* is easy to find.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 获取排列的长度作为一个检查点；这样你可以确认它确实是5的阶乘 ➌。最后，无论你以何种方式打印它 ➍➎，*volde*都很容易找到。
- en: '**Project #7: Finding Voldemort: The British Brute-Force**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #7：寻找伏地魔：英国暴力破解法**'
- en: Now let’s assume Tom Riddle is bad at anagrams (or French). He doesn’t recognize
    *mort* or *morte*, and you’re back to shuffling the remaining nine letters thousands
    and thousands of times, looking for a combination of letters that he would find
    pleasing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设 Tom Riddle 不擅长字谜（或者法语）。他无法识别 *mort* 或 *morte*，于是你又回到了将剩余的九个字母反复排列数千次，寻找一个他认为令人愉悦的字母组合。
- en: On the bright side, this is a more interesting problem programmatically than
    the interactive solution you just saw. You just need to whittle down all the permutations
    using some form of filtering.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从积极的一面来看，这是一个比你刚才看到的交互式解决方案更有趣的问题。你只需要通过某种形式的筛选，缩小所有排列的范围。
- en: '**THE OBJECTIVE**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Reduce the number of anagrams of *tmvoordle* to a manageable number that will
    still contain *Voldemort*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *tmvoordle* 的字谜数量减少到一个可以管理的数字，这个数字仍然包含 *Voldemort*。
- en: '***Strategy***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: Per the *Oxford English Dictionary, 2nd Edition*, there are 171,476 English
    words currently in use, which is fewer than the total number of permutations in
    *tmvoordle*! Regardless of the language, you can surmise that most of the anagrams
    generated by the `permutations()` function are nonsense.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据《牛津英语词典，第2版》，目前使用中的英语单词有171,476个，这比 *tmvoordle* 中的所有排列还要少！不论是哪种语言，你可以推测，通过
    `permutations()` 函数生成的大多数字谜都是无意义的。
- en: 'With *cryptography*, the science of codes and ciphers, you can safely eliminate
    many useless, unpronounceable combinations, such as *ldtmvroeo*, and you won’t
    even have to inspect them visually. Cryptographers have long studied languages
    and compiled statistics on recurring patterns of words and letters. We can use
    many cryptanalytical techniques for this project, but let’s focus on three: consonant-vowel
    mapping, trigram frequency, and digram frequency.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *密码学*，即密码和加密的科学，你可以安全地排除许多无用的、无法发音的组合，例如 *ldtmvroeo*，而无需目视检查它们。密码学家长期研究语言，并编制了关于单词和字母重复模式的统计数据。我们可以使用许多密码分析技术来完成这个项目，但让我们集中于三种技术：辅音-元音映射、三元组频率和二元组频率。
- en: '**Filtering with Consonant-Vowel Mapping**'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用辅音-元音映射进行筛选**'
- en: A *consonant-vowel map* (*c-v map*) simply replaces the letters in a word with
    a *c* or a *v*, as appropriate. *Riddle*, for example, becomes *cvcccv*. You can
    write a program that goes through a dictionary file and creates c-v maps for each
    word. By default, impossible combinations, like *ccccccvvv*, will be excluded.
    You can further exclude membership by removing words with c-v maps that are *possible*
    but that have a low frequency of occurrence.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *辅音-元音映射*（*c-v 映射*）简单地将单词中的字母替换为 *c* 或 *v*，根据需要。例如，*Riddle* 变成 *cvcccv*。你可以编写一个程序，遍历字典文件并为每个单词创建
    c-v 映射。默认情况下，不可能的组合，如 *ccccccvvv*，将被排除。你还可以通过移除那些 c-v 映射是 *可能的*，但出现频率很低的单词，进一步排除成员。
- en: C-v maps are fairly inclusive, but that’s good. An option for *Riddle* at this
    point is to make up a new proper name, and proper names don’t have to be words
    that occur in a dictionary. So you don’t want to be *too* exclusive early in the
    process.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: C-v 映射相当全面，但这是好事。目前，*Riddle* 的一个选择是创造一个新的专有名词，专有名词不一定需要出现在字典中。所以，刚开始的时候你不想过于*排外*。
- en: '**Filtering with Trigrams**'
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用三元组进行筛选**'
- en: Since the initial filter needs a relatively wide aperture, you’ll need to filter
    again at a lower level to safely remove more anagrams from the permutations. *Trigrams*
    are triplets comprising three consecutive letters. It should come as no surprise
    that the most common trigram in English is the word *the*, followed closely by
    *and* and *ing*. At the other end of the scale are trigrams like *zvq*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于初始筛选器需要较宽的视野，你将需要在较低的层级再次进行筛选，以安全地从排列中移除更多的字谜。*三元组*是由三个连续字母组成的三连词。毫不奇怪，英语中最常见的三元组是单词
    *the*，紧随其后的是 *and* 和 *ing*。在另一端，像 *zvq* 这样的三元组则极为罕见。
- en: You can find statistics on the frequency of occurrence of trigrams online at
    sites like *[http://norvig.com/ngrams/count_3l.txt](http://norvig.com/ngrams/count_3l.txt)*.
    For any group of letters, like *tmvoordle*, you can generate and use a list of
    the least common trigrams to further reduce the number of permutations. For this
    project, you can use the *least-likely_trigrams.txt* file, downloadable from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    This text file contains the trigrams in *tmvoordle* that occur in the bottom 10
    percent of trigrams in the English language, based on frequency of occurrence.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering with Digrams**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Digrams* (also called *bigrams*) are letter pairs. Commonly occurring digrams
    in English include *an*, *st*, and *er*. On the other hand, you rarely see pairs
    like *kg*, *vl*, or *oq*. You can find statistics on the frequency of occurrence
    of digrams at websites such as *[https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html](https://www.math.cornell.edu/~mec/2003-2004/cryptography/subs/digraphs.html)*
    and *[http://practicalcryptography.com/](http://practicalcryptography.com/)*.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](ch03.xhtml#ch03tab1) was built from the *tmvoordle* collection
    of letters and a 60,000-word English dictionary file. The letters along the left
    side of the chart are the starting letters for the digrams; those along the top
    represent the end letter. For example, to find *vo*, start with the *v* on the
    left and read across to the column beneath the *o*. For the digrams found in *tmvoordle*,
    *vo* occurs only 0.8 percent of the time.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Relative Frequency of Digrams from the Letters *tmvoordle* in
    a 60,000-Word Dictionary (Black Squares Indicate No Occurrences)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **d** | **e** | **l** | **m** | **o** | **r** | **t** | **v** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| **d** |  | 3.5% | 0.5% | 0.1% | 1.7% | 0.5% | 0.0% | 0.1% |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| **e** | 6.6% |  | 2.3% | 1.4% | 0.7% | 8.9% | 2.0% | 0.6% |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| **l** | 0.4% | 4.4% |  | 0.1% | 4.2% | 0.0% | 0.4% | 0.1% |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| **m** | 0.0% | 2.2% | 0.0% |  | 2.8% | 0.0% | 0.0% | 0.0% |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| **o** | 1.5% | 0.5% | 3.7% | 3.2% | 5.3% | 7.1% | 2.4% | 1.4% |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| **r** | 0.9% | 6.0% | 0.4% | 0.7% | 5.7% |  | 1.3% | 0.3% |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| **t** | 0.0% | 6.2% | 0.6% | 0.1% | 3.6% | 2.3% |  | 0.0% |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| **v** | 0.0% | 2.5% | 0.0% | 0.0% | 0.8% | 0.0% | 0.0% |  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: Assuming you’re looking for “English-like” letter combinations, you can use
    frequency maps like this to exclude letter pairs that are unlikely to occur. Think
    of it as a “digram sieve” that lets only the unshaded squares pass.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: To be safe, just exclude digrams that occur less than 0.1 percent of the time.
    I’ve shaded these in black. Notice that it would be very easy to eliminate the
    required *vo* pairing in *Voldemort*, if you cut too close to the bone!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: You can design your filter to be even more selective by tagging digrams that
    are unlikely to occur at the start of a word. For example, while it’s not unusual
    for the digram *lm* to occur *within* a word (as in *almanac* and *balmy*), you’ll
    need a lot of luck finding a word that *starts* with *lm*. You don’t need cryptography
    to find these digrams; just try to pronounce them! Some starting-point choices
    for these are shaded gray in [Table 3-2](ch03.xhtml#ch03tab2).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Update of [Table 3-1](ch03.xhtml#ch03tab1), Where Gray-Shaded
    Squares Indicate Digrams Unlikely to Occur at the Start of a Word'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **d** | **e** | **l** | **m** | **o** | **r** | **t** | **v** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| **d** |  | 3.5% | 0.5% | 0.1% | 1.7% | 0.5% | 0.0% | 0.1% |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| **e** | 6.6% |  | 2.3% | 1.4% | 0.7% | 8.9% | 2.0% | 0.6% |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| **l** | 0.4% | 4.4% |  | 0.1% | 4.2% | 0.0% | 0.4% | 0.1% |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| **m** | 0.0% | 2.2% | 0.0% |  | 2.8% | 0.0% | 0.0% | 0.0% |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| **o** | 1.5% | 0.5% | 3.7% | 3.2% | 5.3% | 7.1% | 2.4% | 1.4% |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| **r** | 0.9% | 6.0% | 0.4% | 0.7% | 5.7% |  | 1.3% | 0.3% |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| **t** | 0.0% | 6.2% | 0.6% | 0.1% | 3.6% | 2.3% |  | 0.0% |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| **v** | 0.0% | 2.5% | 0.0% | 0.0% | 0.8% | 0.0% | 0.0% |  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: 'You now have three filters you can use on the 181,440 permutations of *tmvoordle*:
    c-v maps, trigrams, and digrams. As a final filter, you should give the user the
    option of viewing only anagrams that start with a given letter. This will let
    the user divide the remaining anagrams into more manageable “chunks,” or focus
    on the more intimidating-sounding anagrams, like those that begin with *v*!'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '***The British Brute-Force Code***'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The upcoming code generates permutations of *tmvoordle* and passes them through
    the filters just described. It then gives the user the option to view either all
    the permutations or only those starting with a given letter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: You can download all the programs you’ll need from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    The code in this section is one script named *voldemort_british.py*. You’ll also
    need the *load_dictionary.py* program in the same folder, along with the same
    dictionary file you used for the projects earlier in this chapter. Finally, you’ll
    need a new file named *least-likely_trigrams.txt*, a text file of trigrams with
    a low frequency of occurrence in English. Download all these files into the same
    folder.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-5](ch03.xhtml#ch03list5) imports the modules that *voldemort_british.py*
    needs and defines its `main()` function. In the *phrase_anagrams.py* program,
    you defined the `main()` function at the end of the code. Here we put it at the
    start. The advantage is that you can see what the function is doing—how it’s running
    the program—from the start. The disadvantage is that you don’t know what any of
    the helper functions do yet.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 1'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 3-5: Imports modules and defines the* main() *function*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing modules you’ve used in the previous projects ➊. Now define
    the `main()` function ➋. The `name` variable is a string of the remaining letters
    *tmvoordle* ➌. Set it to lowercase to guard against a user input error. Next,
    use the `load_dictionary` module to load your dictionary file and the trigrams
    file as lists ➍. Your dictionary filename may be different from that shown.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Finally, call all the various functions in order ➎. I’ll describe each of these
    functions momentarily, but basically, you need to prepare the word list, prepare
    the c-v maps, apply the three filters, and let the user view all the anagrams
    at once or view a subset based on the anagram’s first letter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparing the Word List**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-6](ch03.xhtml#ch03list6) prepares the word list by including just
    the words that have as many letters as in the `name` variable (in this case, nine).
    You should also ensure that all the words are lowercase, to be consistent.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 2'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 3-6: Creates lists of words that are equal in length to the* name
    *variable*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Define the `prep_words()` function to take a name string and list of dictionary
    words as arguments ➊. I suggest that you print the lengths of your various word
    lists before and after they’ve gone through a filter; that way, you can track
    how much impact the filters are having. So print the length of the dictionary
    ➋. Assign a variable to hold the length of the name and then use list comprehension
    to create a new list by looping through the words in `word_list_ini`, keeping
    those whose length is the same as the number of letters in `name`, and converting
    them to lowercase ➌. Next, print the length of this new word list ➍, and finally,
    return this new list for use in the next function ➎.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating the C-V Map**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You need to convert the prepared word list to a c-v map. Remember that you’re
    no longer interested in actual words in the dictionary; those have been reviewed
    and rejected. Your goal is to shuffle the remaining letters until they form something
    that resembles a proper noun.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-7](ch03.xhtml#ch03list7) defines a function that generates c-v maps
    for each word in `word_list`. The program, *voldemort_british.py*, will use the
    c-v map to judge whether a shuffled letter combination is reasonable based on
    consonant-vowel patterns in the English language.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 3'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 3-7: Generates c-v maps from the words in* word_list'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Define the `cv_map_words()` function to take the prepped word list as an argument
    ➊. Since consonants and vowels form a binary system, you can define the vowels
    with a string ➋. Create an empty list to hold the maps ➌. Then loop through the
    words and the letters in each word, converting the letters to either a *c* or
    *v* ➍. Use a variable called `temp` to accumulate the map; then append it to the
    list. Note that `temp` is reinitialized each time the loop repeats.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: You want to know the frequency of occurrence of a given c-v map pattern (for
    example, *cvcv*), so you can remove those with a low likelihood of occurrence.
    Before calculating the frequency, you need to collapse your list down to unique
    c-v maps—as it is now, *cvcv* may be repeated many, many times. So, turn the `cv_mapped_words`
    list into a set, to remove duplicates, and get its length ➎. Now you can define
    a target percentage to eliminate, using fractional values ➏. Start with a low
    number like `0.05`—equivalent to 5 percent—so you’re less likely to eliminate
    anagrams that can form usable proper names. Multiply this target value by the
    total length of the `cv_mapped_words` set and assign the result to the variable
    `n` ➐. Be sure to convert `n` to an integer; since it will represent a count value,
    it can’t be a float.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The `Counter` module data type has a handy method, `most_common()`, that will
    return the most common items in a list based on a *count* value that you provide;
    in this case, that value will be the length of the c-v map list, `total`, minus
    `n`. The value you pass `most_common()` must be an integer. If you pass the `most_common()`
    function the length of the list, it will return all the items in the list. If
    you subtract the count for the least likely 5 percent, you will effectively eliminate
    these c-v maps from the list ➑.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Remember, `Counter` returns a dictionary, but all you need are the final c-v
    maps, not their associated frequency counts. So initialize an empty set called
    `filtered-cv-map` ➒ and loop through each key-value pair in `count_pruned()`,
    adding only the key to the new set. Print the length of this set, so you can see
    the impact of the filter. Then finish by returning the filtered c-v map for use
    in the next function ➓.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the C-V Map Filter**'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-8](ch03.xhtml#ch03list8) applies the c-v map filter: anagrams are
    generated based on permutations of the letters in the `name` variable, and then
    the program converts them to c-v maps and compares those anagrams to the filtered
    c-v maps built with the `cv_map_words()` function. If an anagram’s c-v map is
    found in `filtered_cv_map`, then the program stores the anagram for the next filter.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 4'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 3-8: Defines* cv_map_filter() *function*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the function `cv_map_filter()` to take two arguments: the name, followed
    by the set of c-v maps returned by `cv_map_words()` ➊. Use set comprehension and
    the `permutations` module to generate the set of permutations ➋. I described this
    process in “[Project #6: Finding Voldemort: The Gallic Gambit](ch03.xhtml#lev65)”
    on [page 49](ch03.xhtml#page_49). Use a set here to permit later use of set operations,
    like taking the difference between two filter sets. This also removes duplicates,
    as `permutations` treats each *o* as a separate item, and returns 9!, rather than
    9! / 2!. Note that `permutations` considers *tmv**o**ordle* and *tmvo**o**rdle*
    different strings.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Now initialize an empty set to hold the contents of the first filter ➌ and
    begin looping through the permutations ➍. Use the term *candidate*, as most of
    these aren’t words but just strings of random letters. For each candidate, loop
    through the letters and map them to a *c* or a *v*, as you did with the `cv_words()`
    function. Check each c-v map, `temp`, for membership in `filtered_cv_map`. This
    is one reason for using sets: membership checks are very fast. If the candidate
    meets the condition, add it to `filter_1` ➎. Finish by returning your new anagram
    set ➏.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the Trigram Filter**'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-9](ch03.xhtml#ch03list9) defines the trigram filter, which removes
    the permutations with unlikely three-letter triplets. It uses a text file derived
    from various cryptography websites that has been tailored to the letters in *tmvoordle*.
    This function will return only permutations that include one of these trigrams;
    the `main()` function will pass the new set to the next filter function.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 5'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 3-9: Defines the* trigram_filter() *function*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Parameters for the trigram filter include the output from the c-v map filter
    and the external list of unlikely trigrams, `trigrams_filtered` ➊.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an empty set to hold permutations that contain one of the forbidden
    trigrams ➋. Then start another `for` loop that looks through the candidates that
    survived the last filter ➌. A nested `for` loop looks at each triplet in the trigrams
    list ➍. If the triplet is in the candidate, it is added to the filter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use set operations to subtract the new filter from `filter_1` ➎
    and then return the difference for use with the next filter ➏.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the Digram Filter**'
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 3-10](ch03.xhtml#ch03list10) defines the digram filter, which removes
    unlikely letter pairs. Some will trigger the filter if they occur anywhere within
    the permutation; others will do so only if they occur at the start of the permutation.
    The disallowed digrams are based on the shaded cells in [Table 3-2](ch03.xhtml#ch03tab2).
    The function returns the results of this filter for use in the final filter function.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 6'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 3-10: Defines the* letter_pair_filter() *function*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: This filter accepts the results of the previous filter as an argument ➊. An
    empty set is initialized to hold any discarded permutations ➋. Then two lists
    of rejected pairs are assigned to the variables `rejects` ➌ and `first_pair_rejects`
    ➍. Both lists were entered manually. The first represents cells shaded black in
    [Table 3-2](ch03.xhtml#ch03tab2); the second references cells shaded gray. Any
    permutation that contains a member of the first list—anywhere—will be discarded;
    permutations that *start with* a member of the second list will not be allowed.
    You can add or remove digrams to these lists to change how the filter behaves.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Begin looping through the permutations—continue to refer to these as “candidates,”
    as they aren’t necessarily words ➎. A nested `for` loop goes through the pairs
    in `rejects`, determines whether any are in `candidate`, and adds them to the
    `filtered` set ➏. A second nested `for` loop repeats this process for the `first_pair_rejects`
    ➐. Subtract `filtered` from the set returned from the previous function, `filter_2`
    ➑.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: For fun *and* to ensure you haven’t filtered too far, check whether *voldemort*
    is included in `filter_3` ➒ and print an announcement to highlight the discovery,
    using eye-catching red font for IDLE users. Then finish by returning the final
    filtered set ➓.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '**Letting the User Choose the Starting Letter**'
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You don’t know ahead of time whether your filtering will be successful. You
    may still end up with thousands of permutations. Providing the option to look
    at only a subset of the output won’t reduce the overall number, but it will make
    it *psychologically* easier to face. [Listing 3-11](ch03.xhtml#ch03list11) adds,
    to *voldemort_british.py*, the ability to view a list of anagrams that begin with
    a certain input letter.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 7'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 3-11: Defines the* view_by_letter() *function*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Define the `view_by_letter()` function to take both the `name` variable and
    `filter_3` as arguments ➊. You need the name so you can show the user the available
    letter choices on which to filter ➋. Get the user’s input on whether they want
    to see all the remaining permutations or just those beginning with a certain letter
    ➌. Then start an empty list to hold the latter subset ➍.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop, with a conditional, checks whether a candidate starts with the
    chosen letter and appends those letters that pass to `subset` ➎. This list is
    printed with the splat operator ➏. Then the program asks the user whether they
    want to try again or exit ➐. If they press ENTER, then `view_by_letter()` is called,
    recursively, and runs again from the start ➑. Otherwise, the program exits ➒.
    Note that Python has a default recursion depth limit of 1,000, which we’ll ignore
    in this project.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the main() Function**'
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Back in the global space, [Listing 3-12](ch03.xhtml#ch03list12) completes the
    code by calling the `main()` function if the user runs the program in stand-alone
    mode versus importing into another program.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '*voldemort_british.py,* part 8'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 3-12: Calls the* main() *function*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Example output from the completed program is shown below. After the program
    applies the third filter, there are 248 permutations remaining, of which a very
    manageable 73 start with *v*. I’ve omitted the printout of the permutations for
    brevity. As noted in the output, *voldemort* survives the filtering.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Interestingly, another surviving permutation is *lovedmort*. Given how many
    people Voldemort killed—or had killed—this may be the most appropriate moniker
    of all.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you first wrote code that found the anagrams for a given word
    or name. You then expanded on this to find phrasal name anagrams, working interactively
    with the user. Finally, you employed cryptanalytical techniques to tease *Voldemort*
    out of almost 200,000 possible anagrams. Along the way, you applied useful functionality
    in the `collections` and `itertools` modules.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Jumble* website is *[http://www.jumble.com/](http://www.jumble.com/)*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find some representative online anagram generators at the following
    sites:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '*[http://wordsmith.org/anagram/](http://wordsmith.org/anagram/)*'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[https://www.dcode.fr/anagram-generator](https://www.dcode.fr/anagram-generator)*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[http://www.wordplays.com/anagrammer/](http://www.wordplays.com/anagrammer/)*'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More anagram programs are found in *Think Python, 2nd Edition* (O’Reilly, 2015)
    by Allen Downey.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '*Cracking Codes with Python* (No Starch Press, 2017) by Al Sweigart provides
    more code for computing word patterns, such as those used for filtering in the
    *voldemort_british.py* program.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Finding Digrams**'
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You *could* comb through cryptography websites looking for frequency statistics,
    or you could derive them for yourself. Write a Python program that finds all the
    digrams in *tmvoordle* and then counts their frequency of occurrence in a dictionary
    file. Be sure to test your code on words like *volvo*, so you don’t overlook repeating
    digrams in the same word. You can find a solution in the appendix or download
    *count_digrams_practice.py* from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Automatic Anagram Generator**'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the online anagram generators I just referenced in “Further Reading”
    and write a Python program that mimics one of these. Your program should automatically
    generate phrase anagrams from an input name and display a subset (for example,
    the first 500) for the user to review.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
