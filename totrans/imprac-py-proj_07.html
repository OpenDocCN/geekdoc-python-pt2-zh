<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_125"/><strong><span class="big">7</span><br/>BREEDING GIANT RATS WITH GENETIC ALGORITHMS</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent"><em>Genetic algorithms</em> are general-purpose optimization programs designed to solve complex problems. Invented in the 1970s, they belong to the class of <em>evolutionary algorithms</em>, so named because they mimic the Darwinian process of natural selection. They are especially useful when little is known about a problem, when you’re dealing with a nonlinear problem, or when searching for brute-force-type solutions in a large search space. Best of all, they are easy algorithms to grasp and implement.</p>
<p class="indent">In this chapter, you’ll use genetic algorithms to breed a race of super-rats that can terrorize the world. After that, you’ll switch sides and help James Bond crack a high-tech safe in a matter of seconds. These two projects should give you a good appreciation for the mechanics and power of genetic algorithms.</p>
<h3 class="h3" id="lev148"><span epub:type="pagebreak" id="page_126"/><strong>Finding the Best of All Possible Solutions</strong></h3>
<p class="noindent">Genetic algorithms <em>optimize</em>, which means that they select the best solution (with regard to some criteria) from a set of available alternatives. For example, if you’re looking for the fastest route to drive from New York to Los Angeles, a genetic algorithm will never suggest you fly. It can choose only from within an allowed set of conditions that <em>you</em> provide. As optimizers, these algorithms are faster than traditional methods and can avoid premature convergence to a suboptimal answer. In other words, they efficiently search the solution space yet do so thoroughly enough to avoid picking a good answer when a better one is available.</p>
<p class="indent">Unlike <em>exhaustive</em> search engines, which use pure brute force, genetic algorithms don’t try every possible solution. Instead, they continuously grade solutions and then use them to make “informed guesses” going forward. A simple example is the “warmer-colder” game, where you search for a hidden item as someone tells you whether you are getting warmer or colder based on your proximity or search direction. Genetic algorithms use a fitness function, analogous to natural selection, to discard “colder” solutions and build on the “warmer” ones. The basic process is as follows:</p>
<ol>
<li class="noindent">Randomly generate a population of solutions.</li>
<li class="noindent">Measure the fitness of each solution.</li>
<li class="noindent">Select the best (warmest) solutions and discard the rest.</li>
<li class="noindent">Cross over (recombine) elements in the best solutions to make new solutions.</li>
<li class="noindent">Mutate a small number of elements in the solutions by changing their value.</li>
<li class="noindent">Return to step 2 and repeat.</li>
</ol>
<p class="indent">The select–cross over–mutate loop continues until it reaches a <em>stop condition</em>, like finding a known answer, finding a “good enough” answer (based on a minimum threshold), completing a set number of iterations, or reaching a time deadline. Because these steps closely resemble the process of evolution, complete with survival of the fittest, the terminology used with genetic algorithms is often more biological than computational.</p>
<h3 class="h3a" id="lev149"><strong>Project #13: Breeding an Army of Super-Rats</strong></h3>
<p class="noindent">Here’s your chance to be a mad scientist with a secret lab full of boiling beakers, bubbling test tubes, and machines that go “BZZZTTT.” So pull on some black rubber gloves and get busy turning nimble trash-eating scavengers into massive man-eating monsters.</p>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_127"/><strong>THE OBJECTIVE</strong></p>
<p class="spara">Use a genetic algorithm to simulate breeding rats to an average weight of 110 pounds.</p>
</div>
<h4 class="h4" id="lev150"><strong><em>Strategy</em></strong></h4>
<p class="noindent">Your dream is to breed a race of rats the size of bullmastiffs (we’ve already established that you’re mad). You’ll start with <em>Rattus norvegicus</em>, the brown rat, then add some artificial sweeteners, some atomic radiation from the 1950s, a lot of patience, and a pinch of Python, but no genetic engineering—you’re old-school, baby! The rats will grow from less than a pound to a terrifying 110 pounds, about the size of a female bullmastiff (see <a href="ch07.xhtml#ch07fig1">Figure 7-1</a>).</p>
<div class="image"><a id="ch07fig1"/><img src="../images/f0127-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 7-1: Size comparison of a brown rat, a female bullmastiff, and a human</em></p>
<p class="indent">Before you embark on such a huge undertaking, it’s prudent to simulate the results in Python. And you’ve drawn up something better than a plan—you’ve drawn some graphical pseudocode (see <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>).</p>
<div class="image"><span epub:type="pagebreak" id="page_128"/><a id="ch07fig2"/><img src="../images/f0128-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 7-2: Genetic algorithm approach to breeding super-rats</em></p>
<p class="indent">The process shown in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a> outlines how a genetic algorithm works. Your goal is to produce a population of rats with an average weight of 110 pounds from an initial population weighing much less than that. Going forward, each population (or <em>generation</em>) of rats represents a candidate solution to the problem. Like any animal breeder, you cull undesirable males and females, which you humanely send to—for you <em>Austin Powers</em> fans—an evil petting zoo. You then mate and breed the remaining rats, a process known as <em>crossover</em> in genetic programming.</p>
<p class="indent"><span epub:type="pagebreak" id="page_129"/>The offspring of the remaining rats will be essentially the same size as their parents, so you need to mutate a few. While mutation is rare and usually results in a neutral-to-nonbeneficial trait (low weight, in this case), sometimes you’ll successfully produce a bigger rat.</p>
<p class="indent">The whole process then becomes a big repeating loop, whether done organically or programmatically, making me wonder whether we really <em>are</em> just virtual beings in an alien simulation. At any rate, the end of the loop—the stop condition—is when the rats reach the desired size or you just can’t stand dealing with rats anymore.</p>
<p class="indent">For input to your simulation, you’ll need some statistics. Use the metric system since you’re a scientist, mad or not. You already know that the average weight of a female bullmastiff is 50,000 grams, and you can find useful rat statistics in <a href="ch07.xhtml#ch07tab1">Table 7-1</a>.</p>
<p class="tabcap" id="ch07tab1"><strong>Table 7-1:</strong> Brown Rat Weight and Breeding Statistics</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Parameter</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Published values</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Minimum weight</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">200 grams</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Average weight (female)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">250 grams</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Average weight (male)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">300–350 grams</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Maximum weight</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">600 grams*</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Number of pups per litter</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">8–12</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Litters per year</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">4–13</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Life span (wild, captivity)</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">1–3 years, 4–6 years</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b" colspan="2"><p class="taba">*Exceptional individuals may reach 1,000 grams in captivity.</p></td>
</tr>
</tbody>
</table>
<p class="indent">Because both domestic and wild brown rats exist, there may be wide variation in some of the stats. Rats in captivity tend to be better cared for than wild rats, so they weigh more, breed more, and have more pups. So you can choose from the higher end when a range is available. For this project, start with the assumptions in <a href="ch07.xhtml#ch07tab2">Table 7-2</a>.</p>
<p class="tabcap" id="ch07tab2"><strong>Table 7-2:</strong> Input Assumptions for the Super-Rats Genetic Algorithm</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Variable and value</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Comments</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>GOAL = 50000</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Target weight in grams (female bullmastiff)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>NUM_RATS = 20</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Total number of <em>adult</em> rats your lab can support</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>INITIAL_MIN_WT = 200</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Minimum weight of adult rat, in grams, in initial population</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>INITIAL_MAX_WT = 600</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Maximum weight of adult rat, in grams, in initial population</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>INITIAL_MODE_WT = 300</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Most common adult rat weight, in grams, in initial population</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>MUTATE_ODDS = 0.01</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Probability of a mutation occurring in a rat</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>MUTATE_MIN = 0.5</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Scalar on rat weight of least beneficial mutation</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>MUTATE_MAX = 1.2</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Scalar on rat weight of most beneficial mutation</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>LITTER_SIZE = 8</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Number of pups per pair of mating rats</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>LITTERS_PER_YEAR = 10</code></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Number of litters per year per pair of mating rats</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>GENERATION_LIMIT = 500</code></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Generational cutoff to stop breeding program</p></td>
</tr>
</tbody>
</table>
<p class="indent"><span epub:type="pagebreak" id="page_130"/>Since rats breed so frequently, you shouldn’t have to factor in life span. Even though you will retain some of the parents from a previous generation, they will be culled out quickly as their offspring increase in weight from generation to generation.</p>
<h4 class="h4" id="lev151"><strong><em>The Super-Rats Code</em></strong></h4>
<p class="noindent">The <em>super_rats.py</em> code follows the general workflow in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>. You can also download the code from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<h5 class="h5" id="lev152"><strong>Entering the Data and Assumptions</strong></h5>
<p class="noindent"><a href="ch07.xhtml#ch07list1">Listing 7-1</a>, in the global space at the start of the program, imports modules and assigns the statistics, scalars, and assumptions in <a href="ch07.xhtml#ch07tab2">Table 7-2</a> as constants. Once the program is complete and working, feel free to experiment with the values in that table and see how they affect your results.</p>
<p class="margin"><em>super_rats.py,</em> part 1</p>
<pre><span class="ent">➊</span> import time<br/>   import random<br/>   import statistics<br/><br/><span class="ent">➋</span> # CONSTANTS (weights in grams)<br/><span class="ent">➌</span> GOAL = 50000<br/>   NUM_RATS = 20<br/>   INITIAL_MIN_WT = 200<br/>   INITIAL_MAX_WT = 600<br/>   INITIAL_MODE_WT = 300<br/>   MUTATE_ODDS = 0.01<br/>   MUTATE_MIN = 0.5<br/>   MUTATE_MAX = 1.2<br/>   LITTER_SIZE = 8<br/>   LITTERS_PER_YEAR = 10<br/>   GENERATION_LIMIT = 500<br/><br/>   # ensure even-number of rats for breeding pairs:<br/><span class="ent">➍</span> if NUM_RATS % 2 != 0:<br/>       NUM_RATS += 1</pre>
<p class="listing" id="ch07list1"><em>Listing 7-1: Imports modules and assigns constants</em></p>
<p class="indent">Start by importing the <code>time</code>, <code>random</code>, and <code>statistics</code> modules <span class="ent">➊</span>. You’ll use the <code>time</code> module to record the runtime of your genetic algorithm. It’s interesting to time genetic algorithms, if only to be awed by how quickly they can find a solution.</p>
<p class="indent">The <code>random</code> module will satisfy the stochastic needs of the algorithm, and you’ll use the <code>statistics</code> module to get mean values. This is a weak use for <code>statistics</code>, but I want you to be aware of the module, since it can be quite handy.</p>
<p class="indent">Next, assign the input variables described in <a href="ch07.xhtml#ch07tab2">Table 7-2</a> and be sure to note that the units are grams <span class="ent">➋</span>. Use uppercase letters for the names, as these represent constants <span class="ent">➌</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_131"/>Right now, we’re going to assume the use of breeding <em>pairs</em>, so check that the user input an even number of rats and, if not, add a rat <span class="ent">➍</span>. Later, in “<a href="ch07.xhtml#lev167">Challenge Projects</a>” on <a href="ch07.xhtml#page_144">page 144</a>, you’ll get to experiment with alternative gender distributions.</p>
<h5 class="h5" id="lev153"><strong>Initializing the Population</strong></h5>
<p class="noindent"><a href="ch07.xhtml#ch07list2">Listing 7-2</a> is the program’s shopping representative. It goes to a pet shop and picks out the rats for an initial breeding population. Since you want mating pairs, it should choose an even number of rats. And since you can’t afford one of those fancy volcano lairs with unlimited space, you’ll need to maintain a constant number of adult rats through each generation—though the number can swell temporarily to accommodate litters. Remember, the rats will need more and more space as they grow to the size of big dogs!</p>
<p class="margin"><em>super_rats.py,</em> part 2</p>
<pre><span class="ent">➊</span> def populate(num_rats, min_wt, max_wt, mode_wt):<br/>       """Initialize a population with a triangular distribution of weights."""<br/>    <span class="ent">➋</span> return [int(random.triangular(min_wt, max_wt, mode_wt))\<br/>               for i in range(num_rats)]</pre>
<p class="listing" id="ch07list2"><em>Listing 7-2: Defines the function that creates the initial rat population</em></p>
<p class="indent">The <code>populate()</code> function needs to know the amount of adult rats you want, the minimum and maximum weights for the rats, and the most commonly occurring weight <span class="ent">➊</span>. Note that all of these arguments will use constants found in the global space. You don’t have to pass these as arguments for the function to access them. But I do so here and in the functions that follow, for clarity and because local variables are accessed more efficiently.</p>
<p class="indent">You’ll use the four arguments above with the <code>random</code> module, which includes different types of distributions. You’ll use a triangular distribution here, because it gives you firm control of the minimum and maximum sizes and lets you model skewness in the statistics.</p>
<p class="indent">Because brown rats exist both in the wild and in captivity—in zoos, labs, and as pets—their weights are skewed to the high side. Wild rats tend to be smaller as their lives are nasty, brutish, and short, though lab rats may contest that point! Use list comprehension to loop through the number of rats and assign each one a weight. Bundle it all together with the <code>return</code> statement <span class="ent">➋</span>.</p>
<h5 class="h5" id="lev154"><strong>Measuring the Fitness of the Population</strong></h5>
<p class="noindent">Measuring the fitness of the rats is a two-step process. First, grade the whole population by comparing the average weight of all the rats to the bullmastiff target. Then, grade each individual rat. Only rats whose weight ranks in the upper <em>n</em> percent, as determined by the <code>NUM_RATS</code> variable, get to breed again. Although the average weight of the population is a valid fitness measurement, its primary role here is to determine whether it’s time to stop looping and declare success.</p>
<p class="indent"><span epub:type="pagebreak" id="page_132"/><a href="ch07.xhtml#ch07list3">Listing 7-3</a> defines the <code>fitness()</code> and <code>select()</code> functions, which together form the measurement portion of your genetic algorithm.</p>
<p class="margin"><em>super_rats.py,</em> part 3</p>
<pre><span class="ent">➊</span> def fitness(population, goal):<br/>       """Measure population fitness based on an attribute mean vs target."""<br/>       ave = statistics.mean(population)<br/>       return ave / goal<br/><br/><span class="ent">➋</span> def select(population, to_retain):<br/>       """Cull a population to retain only a specified number of members."""<br/>    <span class="ent">➌</span> sorted_population = sorted(population)<br/>    <span class="ent">➍</span> to_retain_by_sex = to_retain//2<br/>    <span class="ent">➎</span> members_per_sex = len(sorted_population)//2<br/>    <span class="ent">➏</span> females = sorted_population[:members_per_sex]<br/>       males = sorted_population[members_per_sex:]<br/>    <span class="ent">➐</span> selected_females = females[-to_retain_by_sex:]<br/>       selected_males = males[-to_retain_by_sex:]<br/>    <span class="ent">➑</span> return selected_males, selected_females</pre>
<p class="listing" id="ch07list3"><em>Listing 7-3: Defines the measurement step of the genetic algorithm</em></p>
<p class="indent">Define a function to grade the fitness of the current generation <span class="ent">➊</span>. Use the <code>statistics</code> module to get the mean of the population and return this value divided by the target weight. When this value is equal to or greater than 1, you’ll know it’s time to stop breeding.</p>
<p class="indent">Next, define a function that culls a population of rats, based on weight, down to the <code>NUM_RATS</code> value, represented here by the <code>to_retain</code> parameter <span class="ent">➋</span>. It will also take a <code>population</code> argument, which will be the parents of each generation.</p>
<p class="indent">Now, sort the population so you can distinguish large from small <span class="ent">➌</span>. Take the number of rats you want to retain and divide it by 2 using floor division so that the result is an integer <span class="ent">➍</span>. Do this step so you can keep the biggest male and female rats. If you choose only the largest rats in the population, you will theoretically be choosing only males. You obtain the total members of the current population, by sex, by dividing the <code>sorted_population</code> by 2, again using floor division <span class="ent">➎</span>.</p>
<p class="indent">Male rats tend to be larger than females, so make two simplifying assumptions: first, assume that exactly half of the population is female and, second, that the largest female rat is no heavier than the smallest male rat. This means that the first half of the sorted population list represents females and the last half represents males. Then create two new lists by splitting <code>sorted_population</code> in half, taking the bottom half for females <span class="ent">➏</span> and the upper half for males. Now all that’s left to do is take the biggest rats from the end of each of these lists <span class="ent">➐</span>—using negative slicing—and return them <span class="ent">➑</span>. These two lists contain the parents of the next generation.</p>
<p class="indent">The first time you run this function, all it will do is sort the rats by sex, as the initial number of rats already equals the <code>NUM_RATS</code> constant. After that, the incoming population argument will include both parents and children, and its value will exceed <code>NUM_RATS</code>.</p>
<h5 class="h5" id="lev155"><span epub:type="pagebreak" id="page_133"/><strong>Breeding a New Generation</strong></h5>
<p class="noindent"><a href="ch07.xhtml#ch07list4">Listing 7-4</a> defines the program’s “crossover” step, which means it breeds the next generation. A key assumption is that the weight of every child will be greater than or equal to the weight of the mother and less than or equal to the weight of the father. Exceptions to that rule will be handled in the “mutation” function.</p>
<p class="margin"><em>super_rats.py,</em> part 4</p>
<pre><span class="ent">➊</span> def breed(males, females, litter_size):<br/>       """Crossover genes among members (weights) of a population."""<br/>    <span class="ent">➋</span> random.shuffle(males)<br/>       random.shuffle(females)<br/>    <span class="ent">➌</span> children = []<br/>    <span class="ent">➍</span> for male, female in zip(males, females):<br/>        <span class="ent">➎</span> for child in range(litter_size):<br/>            <span class="ent">➏</span> child = random.randint(female, male)<br/>            <span class="ent">➐</span> children.append(child)<br/>    <span class="ent">➑</span> return children</pre>
<p class="listing" id="ch07list4"><em>Listing 7-4: Defines the function that breeds a new generation of rats</em></p>
<p class="indent">The <code>breed()</code> function takes as arguments the lists of weights of selected males and females returned from the <code>select()</code> function along with the size of a litter <span class="ent">➊</span>. Next, randomly shuffle the two lists <span class="ent">➋</span>, because you sorted them in the <code>select()</code> function and iterating over them without shuffling would result in the smallest male being paired with the smallest female, and so on. You need to allow for love and romance; the largest male may be drawn to the most petite female!</p>
<p class="indent">Start an empty list to hold their children <span class="ent">➌</span>. Now for the hanky-panky. Go through the shuffled lists using <code>zip()</code> to pair a male and female from each list <span class="ent">➍</span>. Each pair of rats can have multiple children, so start another loop that uses the litter size as a range <span class="ent">➎</span>. The litter size is a constant, called <code>LITTER_SIZE</code>, that you provided in the input parameters, so if the value is <code>8</code>, you’ll get eight children.</p>
<p class="indent">For each child, choose a weight at random between the mother’s and father’s weights <span class="ent">➏</span>. Note that you don’t need to use <code>male</code> + 1, because <code>randint()</code> uses <em>all</em> the numbers in the supplied range. Note also that the two values can be the same, but the first value (the mother’s weight) can never be larger than the second (the father’s weight). This is another reason for the simplifying assumption that females must be no larger than the smallest male. End the loop by appending each child to the list of children <span class="ent">➐</span>, then return <code>children</code> <span class="ent">➑</span>.</p>
<h5 class="h5" id="lev156"><strong>Mutating the Population</strong></h5>
<p class="noindent">A small percentage of the children should experience mutations, and most of these should result in traits that are nonbeneficial. That means lower-than-expected weights, including “runts” that would not survive. But every so often, a beneficial mutation will result in a heavier rat.</p>
<p class="indent"><span epub:type="pagebreak" id="page_134"/><a href="ch07.xhtml#ch07list5">Listing 7-5</a> defines the <code>mutate()</code> function, which applies the mutation assumptions you supplied in the list of constants. After <code>mutate()</code> is called, it will be time to check the fitness of the new population and start the loop over if the target weight hasn’t been reached.</p>
<p class="margin"><em>super_rats.py,</em> part 5</p>
<pre><span class="ent">➊</span> def mutate(children, mutate_odds, mutate_min, mutate_max):<br/>       """Randomly alter rat weights using input odds &amp; fractional changes."""<br/>    <span class="ent">➋</span> for index, rat in enumerate(children):<br/>           if mutate_odds &gt;= random.random():<br/>            <span class="ent">➌</span> children[index] = round(rat * random.uniform(mutate_min,<br/>                                                            mutate_max))<br/>       return children</pre>
<p class="listing" id="ch07list5"><em>Listing 7-5: Defines the function that mutates a small portion of the population</em></p>
<p class="indent">The function needs the list of children, the odds of a mutation occurring, and the minimum and maximum impacts of a mutation <span class="ent">➊</span>. The impacts are scalars that you’ll apply to the weight of a rat. In your list of constants at the start of the program (and in <a href="ch07.xhtml#ch07tab2">Table 7-2</a>), they are skewed to the minimum side, as most mutations do not result in beneficial traits.</p>
<p class="indent">Loop through the list of children and use <code>enumerate()</code>—a handy built-in function that acts as an automatic counter—to get an index <span class="ent">➋</span>. Then use the <code>random()</code> method to generate a random number between 0 and 1 and compare it to the odds of a mutation occurring.</p>
<p class="indent">If the <code>mutate_odds</code> variable is greater than or equal to the randomly generated number, the rat (weight) at that index is mutated. Choose a mutation value from a uniform distribution defined by the minimum and maximum mutation values; this basically selects a value at random from the min-max range. As these values are skewed to the minimum, the outcome is more likely to be a loss in weight than a gain. Multiply the current weight by this mutation scalar and round it to an integer <span class="ent">➌</span>. Finish by returning the mutated <code>children</code> list.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>With regard to the validity of mutation statistics, you can find studies that suggest beneficial mutations are very rare and others that suggest they are more common than we realize. The breeding of dogs has shown that achieving drastic variations in size (for example, Chihuahuas vs. Great Danes) doesn’t require millions of years of evolution. In a famous 20th-century study, Russian geneticist Dmitry Belyayev started with 130 silver foxes and, over a 40-year period, succeeded in achieving dramatic physiological changes by simply selecting the tamest foxes in each generation.</em></p>
</div>
<h5 class="h5" id="lev157"><strong>Defining the main() Function</strong></h5>
<p class="noindent"><a href="ch07.xhtml#ch07list6">Listing 7-6</a> defines the <code>main()</code> function, which manages the other functions and determines when you’ve met the stop condition. It will also display all the important results.</p>
<p class="margin"><em>super_rats.py,</em> part 6</p>
<pre>def main():<br/>    """Initialize population, select, breed, and mutate, display results."""<br/> <span class="ent">➊</span> generations = 0<br/><br/><span epub:type="pagebreak" id="page_135"/> <span class="ent">➋</span> parents = populate(NUM_RATS, INITIAL_MIN_WT, INITIAL_MAX_WT,<br/>                       INITIAL_MODE_WT)<br/>    print("initial population weights = {}".format(parents))<br/>    popl_fitness = fitness(parents, GOAL)<br/>    print("initial population fitness = {}".format(popl_fitness))<br/>    print("number to retain = {}".format(NUM_RATS))<br/><br/> <span class="ent">➌</span> ave_wt = []<br/><br/> <span class="ent">➍</span> while popl_fitness &lt; 1 and generations &lt; GENERATION_LIMIT:<br/>        selected_males, selected_females = select(parents, NUM_RATS)<br/>        children = breed(selected_males, selected_females, LITTER_SIZE)<br/>        children = mutate(children, MUTATE_ODDS, MUTATE_MIN, MUTATE_MAX)<br/>     <span class="ent">➎</span> parents = selected_males + selected_females + children<br/>        popl_fitness = fitness(parents, GOAL)<br/>     <span class="ent">➏</span> print("Generation {} fitness = {:.4f}".format(generations,<br/>                                                      popl_fitness))<br/>     <span class="ent">➐</span> ave_wt.append(int(statistics.mean(parents)))<br/>        generations += 1<br/> <span class="ent">➑</span> print("average weight per generation = {}".format(ave_wt))<br/>    print("\nnumber of generations = {}".format(generations))<br/>    print("number of years = {}".format(int(generations / LITTERS_PER_YEAR)))</pre>
<p class="listing" id="ch07list6"><em>Listing 7-6: Defines the</em> <span class="codeitalic">main()</span> <em>function</em></p>
<p class="indent">Start the function by initializing an empty list to hold the number of generations. You’ll eventually use this to figure out how many years it took to achieve your goal <span class="ent">➊</span>.</p>
<p class="indent">Next, call the <code>populate()</code> function <span class="ent">➋</span> and immediately print the results. Then, get the fitness of your initial population and print this along with the number of rats to retain each generation, which is the <code>NUM_RATS</code> constant.</p>
<p class="indent">For fun, initialize a list to hold the average weight of each generation so you can view it at the end <span class="ent">➌</span>. If you plot these weights against the number of years, you’ll see that the trend is exponential.</p>
<p class="indent">Now, start the big genetic loop of select-mate-mutate. This is in the form of a <code>while</code> loop, with the stop conditions being either reaching the target weight or reaching a large number of generations without achieving the target weight <span class="ent">➍</span>. Note that after mutating the children, you need to combine them with their parents to make a new <code>parents</code> list <span class="ent">➎</span>. It takes the pups about five weeks to mature and start breeding, but you can account for this by adjusting the <code>LITTERS_PER_YEAR</code> constant down from the maximum possible value (see <a href="ch07.xhtml#ch07tab1">Table 7-1</a>), as we’ve done here.</p>
<p class="indent">At the end of each loop, display the results of the <code>fitness()</code> function to four decimal places so you can monitor the algorithm and ensure it is progressing as expected <span class="ent">➏</span>. Get the average weight of the generation, append it to the <code>ave_wt</code> list <span class="ent">➐</span>, and then advance the generation count by 1.</p>
<p class="indent">Complete the <code>main()</code> function by displaying the list of average weights per generation, the number of generations, and the number of years—calculated using the <code>LITTERS_PER_YEAR</code> variable <span class="ent">➑</span>.</p>
<h5 class="h5" id="lev158"><span epub:type="pagebreak" id="page_136"/>Running the main() Function</h5>
<p class="noindent">Finish up with the familiar conditional statement for running the program either stand-alone or as a module. Get the ending time and print how long it took the program to run. The performance information should print only when the module is run in stand-alone mode, so be sure to place it under the <code>if</code> clause. See <a href="ch07.xhtml#ch07list7">Listing 7-7</a>.</p>
<p class="margin"><em>super_rats.py,</em> part 7</p>
<pre>if __name__ == '__main__':<br/>    start_time = time.time()<br/>    main()<br/>    end_time = time.time()<br/>    duration = end_time - start_time<br/>    print("\nRuntime for this program was {} seconds.".format(duration))</pre>
<p class="listing" id="ch07list7"><em>Listing 7-7: Runs the</em> <span class="codeitalic">main()</span> <em>function and</em> <span class="codeitalic">time</span> <em>module if the program isn’t imported</em></p>
<h4 class="h4" id="lev159"><strong><em>Summary</em></strong></h4>
<p class="noindent">With the parameters in <a href="ch07.xhtml#ch07tab2">Table 7-2</a>, the <em>super_rats.py</em> program will take about two seconds to run. On average, it will take the rats about 345 generations, or 34.5 years, to reach the target weight of 110 pounds. That’s a long time for a mad scientist to stay mad! But armed with your program, you can look for ways to reduce the time to target.</p>
<p class="indent"><em>Sensitivity studies</em> work by making multiple changes to a <em>single</em> variable and judging the results. You should take care in the event some variables are dependent on one another. And since the results are stochastic (random), you should make multiple runs with each parameter change in order to capture the range of possible outcomes.</p>
<p class="indent">Two things you can control in your breeding program are the number of breeding rats (<code>NUM_RATS</code>) and the odds of a mutation occurring (<code>MUTATE_ODDS</code>). The mutation odds are influenced by factors like diet and exposure to radiation. If you change these variables one at a time and rerun <em>super_rats.py</em>, you can judge the impact of each variable on the project timeline.</p>
<p class="indent">An immediate observation is that, if you start with small values for each variable and slowly increase them, you get dramatic initial results (see <a href="ch07.xhtml#ch07fig3">Figure 7-3</a>). After that, both curves decline rapidly and flatten out in a classic example of diminishing returns. The point where each curve flattens is the key to optimally saving money and reducing work.</p>
<p class="indent">For example, you get very little benefit from retaining more than about 300 rats. You’d just be feeding and caring for a lot of superfluous rats. Likewise, trying to boost the odds of a mutation above 0.3 gains you little.</p>
<p class="indent">With charts like these, it’s easy to plan a path forward. The horizontal dotted line marked “Baseline” represents the average result of using the input in <a href="ch07.xhtml#ch07tab2">Table 7-2</a>. You can potentially reduce this time by over 10 years just by retaining 50 rats rather than 20. You should also focus on increasing the number of beneficial mutations. This will be more rewarding, but riskier and harder to control.</p>
<div class="image"><span epub:type="pagebreak" id="page_137"/><a id="ch07fig3"/><img src="../images/f0137-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 7-3: Impact of two parameters on the time required to reach the target weight</em></p>
<p class="indent">If you rerun the simulation using 50 rats and bumping the odds of mutation up to 0.05, you can theoretically complete the project in 14 years, an improvement of 246 percent over the initial baseline. Now <em>that’s</em> optimization!</p>
<p class="indent">Breeding super-rats was a fun and simple way to understand the basics of genetic algorithms. But to truly appreciate their power, you need to attempt something harder. You need a brute-force problem that’s too big to brute-force, and the next project is that kind of problem.</p>
<h3 class="h3a" id="lev160"><strong>Project #14: Cracking a High-Tech Safe</strong></h3>
<p class="noindent">You are Q, and James Bond has a problem. He has to attend an elegant dinner party at a villain’s mansion, slip away to the man’s private office, and crack his wall safe. Child’s play for 007, except for one thing: it’s a Humperdink BR549 digital safe that takes 10 digits, yielding 10 billion possible combinations. And the lock wheels don’t start turning until <em>after</em> all the numbers have been entered. There’ll be no putting a stethoscope to this safe and slowly turning a dial!</p>
<p class="indent">As Q, you already have an autodialer device that can brute-force its way through all possible solutions, but Bond simply won’t have time to use it. Here’s why.</p>
<p class="indent">A combination lock should really be called a <em>permutation</em> lock, because it requires <em>ordered</em> combinations, which are, by definition, permutations. More specifically, locks rely on <em>permutations with repetition</em>. For example, a valid—though insecure—combination could be 999999999.</p>
<p class="indent">You used the <code>itertools</code> module’s <code>permutations()</code> iterator when working with anagrams in <a href="ch03.xhtml#ch03">Chapter 3</a> and in “<a href="ch04.xhtml#lev106">Practice Projects</a>” on <a href="ch04.xhtml#page_87">page 87</a> in <a href="ch04.xhtml#ch04">Chapter 4</a>, but that won’t help here because <code>permutations()</code> returns permutations <em>without</em> repetition. To generate the right kind of permutation for a lock, you need to use <code>itertools</code>’s <code>product()</code> iterator, which calculates the Cartesian product from multiple sets of numbers:</p>
<pre><span epub:type="pagebreak" id="page_138"/>&gt;&gt;&gt; <span class="codestrong1">from itertools import product</span><br/>&gt;&gt;&gt; <span class="codestrong1">combo = (1, 2)</span><br/>&gt;&gt;&gt; <span class="codestrong1">for perm in product(combo, repeat=2):</span><br/><span class="codestrong1">    print(perm)</span><br/>(1, 1)<br/>(1, 2)<br/>(2, 1)<br/>(2, 2)</pre>
<p class="indent">The optional <code>repeat</code> keyword argument lets you take the product of an iterable multiplied by itself, as you need to do in this case. Note that the <code>product()</code> function returns all the possible combinations, whereas the <code>permutations()</code> function would return only <code>(1, 2)</code> and <code>(2, 1)</code>. You can read more about <code>product()</code> at <em><a href="https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing">https://docs.python.org/3.6/library/itertools.html#itertools.product.Listing</a></em>.</p>
<p class="indent"><a href="ch07.xhtml#ch07list8">Listing 7-8</a> is a Python program, called <em>brute_force_cracker.py</em>, that uses <code>product()</code> to brute-force its way to the right combination:</p>
<p class="margin"><em>brute_force_cracker.py</em></p>
<pre><span class="ent">➊</span> import time<br/>   from itertools import product<br/><br/>   start_time = time.time()<br/><br/><span class="ent">➋</span> combo = (9, 9, 7, 6, 5, 4, 3)<br/><br/>   # use Cartesian product to generate permutations with repetition<br/><span class="ent">➌</span> for perm in product([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], repeat=len(combo)):<br/>    <span class="ent">➍</span> if perm == combo:<br/>           print("Cracked! {} {}".format(combo, perm))<br/><br/>   end_time = time.time()<br/><span class="ent">➎</span> print("\nRuntime for this program was {} seconds.".format<br/>         (end_time - start_time))</pre>
<p class="listing" id="ch07list8"><em>Listing 7-8: Uses a brute-force method to find a safe’s combination</em></p>
<p class="indent">Import <code>time</code> and the <code>product</code> iterator from <code>itertools</code> <span class="ent">➊</span>. Get the start time, and then enter the safe combination as a tuple <span class="ent">➋</span>. Next use <code>product()</code>, which returns tuples of all the permutations with repetition for a given sequence. The sequence contains all the valid single-digit entries (0–9). You should set the <code>repeat</code> argument to the number of digits in the combination <span class="ent">➌</span>. Compare each result to the combination and print <code>"Cracked!"</code> if they match, along with the combination and matching permutation <span class="ent">➍</span>. Finish by displaying the runtime <span class="ent">➎</span>.</p>
<p class="indent">This works great for combinations up to eight digits long. After that, the wait becomes increasingly uncomfortable. <a href="ch07.xhtml#ch07tab3">Table 7-3</a> is a record of runtimes for the program versus number of digits in the combination.</p>
<p class="tabcap" id="ch07tab3"><span epub:type="pagebreak" id="page_139"/><strong>Table 7-3:</strong> Runtimes Versus Digits in Combination (2.3 GHz Processor)</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Number of digits</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Runtime in seconds</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">5</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0.035</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">6</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">0.147</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">7</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">1.335</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">8</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">12.811</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">9</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">133.270</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba">10</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">1396.955</p></td>
</tr>
</tbody>
</table>
<p class="indent">Notice that adding a number to the combination increases the runtime by an order of magnitude. This is an exponential increase. With 9 digits, you’d wait over 2 minutes for an answer. With 10 digits, over 20 minutes! That’s a long time for Bond to take an unnoticed “bathroom break.”</p>
<p class="indent">Fortunately, you’re Q, and you know about genetic algorithms. All you need is some way to judge the fitness of each candidate combination. Options include monitoring fluctuations in power consumption, measuring time delays in operations, and listening for sounds. Let’s assume use of a sound-amplifying tool, along with a tool to prevent lockouts after a few incorrect combinations have been entered. Because of the safeguards in the BR549 safe, a sound tool can initially tell you only <em>how many</em> digits are correct, not <em>which</em> digits, but with very little time, your algorithm can zero in on the solution.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Use a genetic algorithm to quickly find a safe’s combination in a large search space.</p>
</div>
<h4 class="h4" id="lev161"><strong><em>Strategy</em></strong></h4>
<p class="noindent">The strategy here is straightforward. You’ll generate a sequence of 10 numbers at random and compare it to the real combination, grading the result based on matches; in the real world, you’d find the number of matches using the sound detector clamped to the door of the safe. You then change one value in your solution and compare again. If another match is found, you throw away the old sequence and move forward with the new; otherwise, you keep the old sequence and try again.</p>
<p class="indent">Since one solution completely replaces the other, this represents 100 percent crossover of genetic material, so you are essentially using just selection and mutation. Selection plus mutation alone generates a robust <em>hill-climbing</em> algorithm. Hill climbing is an optimization technique that starts with an arbitrary solution and changes (mutates) a single value in the solution. If the result is an improvement, the new solution is kept and the process repeats.</p>
<p class="indent"><span epub:type="pagebreak" id="page_140"/>A problem with hill climbing is that the algorithm can get stuck in <em>local</em> minima or maxima and not find the optimal <em>global</em> value. Imagine you are looking for the lowest value in the wavelike function in <a href="ch07.xhtml#ch07fig4">Figure 7-4</a>. The current best guess is marked by the large black dot. If the magnitude of the change you are making (mutation) is too small to “escape” the local trough, the algorithm won’t find the true low point. From the algorithm’s point of view, because every direction results in a worse answer, it must have found the true answer. So it prematurely converges on a solution.</p>
<div class="image"><a id="ch07fig4"/><img src="../images/f0140-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 7-4: Example of a hill-climbing algorithm “stuck” in a local minimum</em></p>
<p class="indent">Using crossover in genetic algorithms helps to avoid premature convergence problems, as does allowing for relatively large mutations. Because you’re not worried about honoring biological realism here, the mutation space can encompass every possible value in the combination. That way you can’t get stuck, and hill climbing is an acceptable approach.</p>
<h4 class="h4" id="lev162"><strong><em>The Safecracker Code</em></strong></h4>
<p class="noindent">The <em>safe_cracker.py</em> code takes a combination of <em>n</em> digits and uses hill climbing to reach the combination from a random starting point. The code can be downloaded from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<h5 class="h5" id="lev163"><strong>Setting Up and Defining the fitness() Function</strong></h5>
<p class="noindent"><a href="ch07.xhtml#ch07list9">Listing 7-9</a> imports the necessary modules and defines the <code>fitness()</code> function.</p>
<p class="margin"><em>safe_cracker.py,</em> part 1</p>
<pre><span class="ent">➊</span> import time<br/>   from random import randint, randrange<br/><br/><span class="ent">➋</span> def fitness(combo, attempt):<br/>       """Compare items in two lists and count number of matches."""<br/>       grade = 0<br/>    <span class="ent">➌</span> for i, j in zip(combo, attempt):<br/><span epub:type="pagebreak" id="page_141"/>           if i == j:<br/>               grade += 1<br/>       return grade</pre>
<p class="listing" id="ch07list9"><em>Listing 7-9: Imports modules and defines the</em> <span class="codeitalic">fitness()</span> <em>function</em></p>
<p class="indent">After importing some familiar modules <span class="ent">➊</span>, define a <code>fitness()</code> function that takes the true combination and an attempted solution as arguments <span class="ent">➋</span>. Name a variable <code>grade</code> and set it to <code>0</code>. Then use <code>zip()</code> to iterate through each element in the combination and your attempt <span class="ent">➌</span>. If they’re the same, add 1 to <code>grade</code> and return it. Note that you aren’t recording the index that matches, just that the function has found a match. This emulates output from the sound detection device. All it can tell you initially is how many lock wheels turned, not their locations.</p>
<h5 class="h5" id="lev164"><strong>Defining and Running the main() Function</strong></h5>
<p class="noindent">Since this is a short and simple program, most of the algorithm is run in the <code>main()</code> function, <a href="ch07.xhtml#ch07list10">Listing 7-10</a>, rather than in multiple functions.</p>
<p class="margin"><em>safe_cracker.py,</em> part 2</p>
<pre>def main():<br/>
    """Use hill-climbing algorithm to solve lock combination."""<br/>
 <span class="ent">➊</span> combination = '6822858902'<br/>
    print("Combination = {}".format(combination))<br/>
    # convert combination to list:<br/>
 <span class="ent">➋</span> combo = [int(i) for i in combination]<br/>
<br/>
    # generate guess &amp; grade fitness:<br/>
 <span class="ent">➌</span> best_attempt = [0] * len(combo)<br/>
    best_attempt_grade = fitness(combo, best_attempt)<br/>
<br/>
 <span class="ent">➍</span> count = 0<br/>
<br/>
    # evolve guess<br/>
 <span class="ent">➎</span> while best_attempt != combo:<br/>
        # crossover<br/>
     <span class="ent">➏</span> next_try = best_attempt[:]<br/>
<br/>
        # mutate<br/>
        lock_wheel = randrange(0, len(combo))<br/>
     <span class="ent">➐</span> next_try[lock_wheel] = randint(0, 9)<br/>
<br/>
        # grade &amp; select<br/>
     <span class="ent">➑</span> next_try_grade = fitness(combo, next_try)<br/>
        if next_try_grade &gt; best_attempt_grade:<br/>
            best_attempt = next_try[:]<br/>
            best_attempt_grade = next_try_grade<br/>
        print(next_try, best_attempt)<br/>
        count += 1<br/>
<br/>
    print()<br/>
 <span class="ent">➒</span> print("Cracked! {}".format(best_attempt), end=' ')<br/>
    print("in {} tries!".format(count))<br/>
<span epub:type="pagebreak" id="page_142"/>if __name__ == '__main__':<br/>
    start_time = time.time()<br/>
    main()<br/>
    end_time = time.time()<br/>
    duration = end_time - start_time<br/>
 <span class="ent">➓</span> print("\nRuntime for this program was {:.5f} seconds.".format(duration))</pre>
<p class="listing" id="ch07list10"><em>Listing 7-10: Defines the</em> <span class="codeitalic">main()</span> <em>function and runs and times the program if it hasn’t been imported</em></p>
<p class="indent">Provide the true combination as a variable <span class="ent">➊</span> and use list comprehension to convert it into a list for convenience going forward <span class="ent">➋</span>. Generate a list of zeros equal in length to the combination and name it <code>best_attempt</code> <span class="ent">➌</span>. At this point, any combination is as good as any other. You should retain this name—<code>best_attempt</code>—because you need to preserve only the best solution as you climb the hill. Once you’ve generated the initial attempt, grade it with the <code>fitness()</code> function and then assign the value to a variable, called <code>best_attempt_grade</code>.</p>
<p class="indent">Start a <code>count</code> variable at zero. The program will use this variable to record how many attempts it took to crack the code <span class="ent">➍</span>.</p>
<p class="indent">Now, start a <code>while</code> loop that continues until you’ve found the combination <span class="ent">➎</span>. Assign a <em>copy</em> of <code>best_attempt</code> to a <code>next_try</code> variable <span class="ent">➏</span>. You copy it so you don’t run into aliasing problems; when you alter an element in <code>next_try</code>, you don’t want to accidentally change <code>best_attempt</code>, because you may continue to use it in the event <code>next_try</code> fails the fitness test.</p>
<p class="indent">It’s now time to mutate the copy. Each digit in the combination turns a lock wheel in the safe, so name a variable <code>lock_wheel</code> and randomly set it equal to an index location in the combination. This represents the location of the single element to change in this iteration. Next, randomly choose a digit and use it to replace the value at the location indexed by <code>lock_wheel</code> <span class="ent">➐</span>.</p>
<p class="indent">Grade <code>next_try</code>, and if it’s fitter than the previous attempt, reset both <code>best_attempt</code> and <code>best_attempt_grade</code> to the new values <span class="ent">➑</span>. Otherwise, <code>best_attempt</code> will remain unchanged for the next iteration. Print both <code>next_try</code> and <code>best_attempt</code>, side by side, so you can scroll through the attempts when the program ends and see how they evolved. Finish the loop by advancing the counter.</p>
<p class="indent">When the program finds the combination, display the <code>best_attempt</code> value and the number of tries it took to find it <span class="ent">➒</span>. Remember, the <code>end=' '</code> argument prevents a carriage return at the end of the printed line and places a space between the end of the current line and the beginning of the next line.</p>
<p class="indent">Complete the program with the conditional statement for running <code>main()</code> stand-alone and display the runtime to five decimal places <span class="ent">➓</span>. Note that the timing code comes after the conditional, and thus will not run if the program is imported as a module.</p>
<h4 class="h4" id="lev165"><span epub:type="pagebreak" id="page_143"/><strong><em>Summary</em></strong></h4>
<p class="noindent">The last few lines of output from the <em>safe_cracker.py</em> program are shown here. I’ve omitted most of the evolving comparisons for brevity. The run was for a 10-digit combination.</p>
<pre>[6, 8, 6, 2, 0, 5, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]<br/>[6, 8, 2, 2, 0, 9, 8, 9, 0, 0] [6, 8, 2, 2, 0, 5, 8, 9, 0, 0]<br/>[6, 8, 2, 2, 8, 5, 8, 9, 0, 0] [6, 8, 2, 2, 8, 5, 8, 9, 0, 0]<br/>[6, 8, 2, 2, 8, 5, 8, 9, 0, 2] [6, 8, 2, 2, 8, 5, 8, 9, 0, 2]<br/><br/>Cracked! [6, 8, 2, 2, 8, 5, 8, 9, 0, 2] in 78 tries!<br/><br/>Runtime for this program was 0.69172 seconds.</pre>
<p class="indent">Ten billion possible combinations, and the program found a solution in only 78 tries and in less than a second. Even James Bond would be impressed with that.</p>
<p class="indent">That does it for genetic algorithms. You’ve used an example workflow to breed gigantic rodents, then trimmed it to hill climb through a brute-force problem in no time flat. If you want to continue to play digital Darwin and experiment with genetic algorithms, a long list of example applications can be found on Wikipedia (<em><a href="https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications">https://en.wikipedia.org/wiki/List_of_genetic_algorithm_applications</a></em>). Examples include:</p>
<ul>
<li class="noindent">Modeling global temperature changes</li>
<li class="noindent">Container-loading optimization</li>
<li class="noindent">Delivery vehicle–routing optimization</li>
<li class="noindent">Groundwater-monitoring networks</li>
<li class="noindent">Learning robot behavior</li>
<li class="noindent">Protein folding</li>
<li class="noindent">Rare-event analysis</li>
<li class="noindent">Code breaking</li>
<li class="noindent">Clustering for fit functions</li>
<li class="noindent">Filtering and signal processing</li>
</ul>
<h3 class="h3" id="lev166"><strong>Further Reading</strong></h3>
<p class="noindent"><em>Genetic Algorithms with Python</em> (Amazon Digital Services LLC, 2016) by Clinton Sheppard is a beginner-level introduction to genetic algorithms using Python. It is available in paperback or as an inexpensive ebook from <em><a href="https://leanpub.com/genetic_algorithms_with_python/">https://leanpub.com/genetic_algorithms_with_python/</a></em>.</p>
<h3 class="h3" id="lev167"><span epub:type="pagebreak" id="page_144"/><strong>Challenge Projects</strong></h3>
<p class="noindent">Continue to breed super-rats and crack super-safes with these suggested projects. As usual with challenge projects, you’re on your own; no solutions are provided.</p>
<h4 class="h4" id="lev168"><strong><em>Building a Rat Harem</em></strong></h4>
<p class="noindent">Since a single male rat can mate with multiple females, there is no need to have an equal number of male and female rats. Rewrite the <em>super_rats.py</em> code to accommodate a variable number of male and female individuals. Then rerun the program with the same total number of rats as before, but use 4 males and 16 females. How does this impact the number of years required to reach the target weight of 50,000 grams?</p>
<h4 class="h4" id="lev169"><strong><em>Creating a More Efficient Safecracker</em></strong></h4>
<p class="noindent">As currently written, when a lock wheel match is found by the <em>safe_cracker.py</em> code, that match is not explicitly preserved. As long as the <code>while</code> loop is running, there’s nothing to stop a correct match from being stochastically overwritten. Alter the code so that the indexes for correct guesses are excluded from future changes. Do timing comparisons between the two versions of the code to judge the impact of the change.</p>
</body></html>