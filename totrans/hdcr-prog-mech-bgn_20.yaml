- en: '15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '15'
- en: STRUCTURAL MODELS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模型
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: In this part of the book, we’ll focus on solving truss structures. Truss structures
    are used to support the roof of industrial warehouses (see [Figure 15-1](ch15.xhtml#ch15fig1))
    and long-span bridges. This is a real engineering problem that is a good example
    of building an application that reads data from a file, builds a model out of
    that data, solves a system of linear equations, and presents the results graphically
    in a diagram.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们将重点解决桁架结构问题。桁架结构用于支撑工业仓库的屋顶（见[图 15-1](ch15.xhtml#ch15fig1)）以及大跨度桥梁。这是一个实际的工程问题，作为构建一个应用程序的好例子，程序可以从文件中读取数据，基于这些数据构建模型，求解线性方程组，并通过图表呈现结果。
- en: 'Since solving truss structures is a big topic, we’ll break it down into several
    chapters. This first one will give you a rough introduction to the basics of mechanics
    of materials; it’s not meant to explain the concepts from scratch but should serve
    as a refresher. Once we’ve gone through the basics, we’ll implement two classes
    to model truss structures: nodes and bars. As we’ve seen in earlier chapters,
    the first step of solving a problem in code is to have a set of primitives that
    represent the entities involved in the solution.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解决桁架结构问题是一个庞大的课题，我们将其分解成几章内容。第一章将为你粗略介绍材料力学的基础知识；这并不是从零开始解释概念，而是作为一种复习。当我们掌握了基础知识后，我们将实现两个类来模拟桁架结构：节点和杆件。正如我们在前面的章节中看到的，解决一个问题的第一步是拥有一组基本元素来表示解决方案中涉及的实体。
- en: '![Image](../images/15fig01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig01.jpg)'
- en: '*Figure 15-1: A warehouse roof is a good example of a truss structure.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-1：仓库屋顶是桁架结构的一个典型例子。*'
- en: '**Solving Structural Problems**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**解决结构问题**'
- en: 'Let’s begin with a few definitions. A *structure* is a set of resistant elements
    built to withstand the external application of loads, as well as their own weight.
    A *truss structure* is a structure in which the resistant elements are bars joined
    by pins in both ends, and the external forces are applied only where those bars
    join: at the nodes.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先来定义几个术语。*结构*是由一系列抗力构件组成，用于承受外部负荷的作用及其自身的重量。*桁架结构*是一种由两端通过销钉连接的杆件构成的结构，外部力仅作用于这些杆件连接的地方，即节点。
- en: 'When working out a structural problem, we’re most interested in two things.
    First, can the bars of the structure handle the forces acting on them and avoid
    collapse? Second, how big are the displacements of the structure once it’s deformed
    under the action of the external loads? The first is an obvious concern: if any
    of the bars in the structure break, the structure may collapse, which could have
    catastrophic consequences (think: collapsing warehouse roofs or bridges). Our
    analysis should make sure this never happens.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决结构问题时，我们最关心的两件事是：第一，结构中的杆件能否承受作用在其上的力并避免坍塌？第二，当结构在外力作用下变形时，其位移有多大？第一个问题显而易见：如果结构中的任何杆件断裂，结构可能会坍塌，造成灾难性的后果（例如：仓库屋顶或桥梁坍塌）。我们的分析应该确保这种情况永远不会发生。
- en: The second concern is less obvious, but important nevertheless. If a structure
    is deformed enough for the naked eye to notice, even if the structure is safe
    and won’t collapse, people around or below it may get anxious. Think about how
    you would feel if you saw your living room’s ceiling noticeably curved. Keeping
    the deformation of the structure between some limits impacts the comfort of its
    users.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题不那么显而易见，但同样重要。如果一个结构发生了足够明显的变形，哪怕结构本身是安全的，不会坍塌，周围或下面的人可能会感到不安。想象一下，如果你看到客厅的天花板明显弯曲，你会有什么感觉。将结构的变形限制在一定范围内对其使用者的舒适度有着重要影响。
- en: 'The solution we’re after should include the amount of stress on each bar, as
    well as the global displacements of the structure. We’ll code up the actual solution
    in the next chapter; here, we’ll define the solution model. We can expect our
    solution model to include these two quantities: the amount of mechanical stress
    on each bar and the node displacements.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要寻找的解决方案应该包括每根杆件上的应力大小，以及结构的整体位移。在下一章，我们将编写实际的解决方案代码；在这里，我们将定义解决方案模型。我们可以预计，解决方案模型将包括这两个量：每根杆件上的机械应力和节点位移。
- en: Before we can do that, though, we’ll need to dive into the world of structural
    analysis. Be prepared to write lots of code. We’re about to solve a serious engineering
    problem, so the payoff for our hard work will be high.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能进行分析之前，我们需要深入研究结构分析的世界。准备好编写大量代码吧。我们将要解决一个重大的工程问题，因此我们辛苦工作的回报将是巨大的。
- en: '**Structural Member Internal Forces**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结构构件内力**'
- en: Let’s begin by quickly recapping how elastic bodies respond to the application
    of external forces. This is a topic typically taught in mechanics of materials,
    a classic subject in mechanical engineering courses. If you’ve extensively studied
    this subject, feel free to skip this section or browse through it as a refresher.
    If not, this section is for you. Your mechanics knowledge should be enough to
    follow the text, but we can’t possibly cover everything in detail. You can refer
    to [3], one of my all-time favorites on the subject. Books on statics also cover
    this topic with some detail. I recommend you take a look at [9] or [11].
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下弹性体如何对外力的作用做出反应。这是材料力学中通常会讲授的一个主题，是机械工程课程中的经典内容。如果你已经深入学习过这个主题，可以跳过这一部分，或者快速浏览一下作为复习。如果没有，这一部分就是为你准备的。你所掌握的力学知识应该足够理解本文的内容，但我们不可能详细覆盖所有内容。你可以参考[3]，这是我个人非常喜欢的书籍之一。静力学相关的书籍也有一定程度的讲解，推荐你阅读[9]或[11]。
- en: '***Elastic Bodies Subject to External Forces***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***受外力作用的弹性体***'
- en: 'Let’s use an I beam as an example of an elastic body and apply an external
    system of balanced forces to it. These are forces whose sum equals zero: ![Image](../images/f00389-p1.jpg).
    [Figure 15-2](ch15.xhtml#ch15fig2) shows the beam.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 I 型梁作为弹性体的例子，并对其施加一个外部平衡力系统。这些力的总和为零： ![Image](../images/f00389-p1.jpg)。[图
    15-2](ch15.xhtml#ch15fig2) 显示了梁的样子。
- en: '![Image](../images/15fig02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig02.jpg)'
- en: '*Figure 15-2: A beam subject to external forces*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：受外力作用的梁*'
- en: 'When external forces are applied to this elastic body, its atoms will fight
    back in an attempt to preserve the relative distances between themselves. If the
    external loads want to separate the atoms, they’ll try to hold each other tighter.
    If they’re pushed together, they’ll try not to get too close. This “fighting back”
    makes up the *internal forces*: forces inside the body itself that exist in response
    to the application of external forces.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当外部力作用于这个弹性体时，它的原子会反抗，以保持它们之间的相对距离。如果外部载荷试图分开这些原子，它们会尽量把彼此拉得更紧。如果它们被推在一起，它们会尽量避免靠得太近。这种“反抗”构成了*内力*：在体内存在的力，是对外力施加作用的反应。
- en: To study the effects of these forces on the body, let’s take our beam from [Figure
    15-2](ch15.xhtml#ch15fig2) and virtually cut it with a plane, like in [Figure
    15-3](ch15.xhtml#ch15fig3).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究这些力对物体的影响，我们可以以[图 15-2](ch15.xhtml#ch15fig2)中的梁为例，虚拟地用一个平面将其切割，如同[图 15-3](ch15.xhtml#ch15fig3)中所示。
- en: '![Image](../images/15fig03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig03.jpg)'
- en: '*Figure 15-3: A section of a beam subject to external forces*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-3：受外力作用的梁的横截面*'
- en: Let’s remove the right chunk of the beam and analyze what happens in the left
    part’s cross section. Since the entire beam was in static equilibrium before we
    cut it, the left chunk should be in static equilibrium as well. To preserve this
    equilibrium, we must account for the distribution of internal forces that the
    now removed right chunk exerted on the left one. These forces appear because the
    atoms in the left chunk have been separated from their neighbors in the right
    chunk. The force that pulled them together needs to be added to the cut section
    so that the atoms stay in the same equilibrium state as before.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去掉梁的右侧部分，分析左侧部分的横截面发生了什么。由于整个梁在我们切割之前是静力平衡的，因此左侧部分也应当保持静力平衡。为了保持这个平衡，我们必须考虑右侧被去除的部分对左侧部分施加的内力分布。这些力的出现是因为左侧部分的原子已被从与右侧部分的邻近原子中分离开。拉紧它们的力需要加到切割的部分上，以保持原子的平衡状态不变。
- en: These forces are distributed over the whole cut surface and represented in [Figure
    15-4](ch15.xhtml#ch15fig4).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些力分布在整个切割面上，并在[图 15-4](ch15.xhtml#ch15fig4)中表示。
- en: '![Image](../images/15fig04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig04.jpg)'
- en: '*Figure 15-4: Analyzing equilibrium in a section*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：分析截面中的平衡*'
- en: The distribution of forces over an area is referred to as *stress*. The net
    effect of the stress can be substituted with an equivalent system of a resulting
    force ![Image](../images/Rvictor_caps.jpg) and moment ![Image](../images/mvictor.jpg).
    Each of the components of this equivalent force and moment produces a different
    effect on the beam. Let’s break the components down.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 力在某一面积上的分布被称为 *应力*。应力的净效应可以用一个等效系统来代替，其中包括一个结果力 ![Image](../images/Rvictor_caps.jpg)
    和一个力矩 ![Image](../images/mvictor.jpg)。这个等效力和力矩的每个分量对梁产生不同的效果。让我们来分解这些分量。
- en: '***Axial and Shear Forces***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***轴向力和剪切力***'
- en: The equivalent internal force ![Image](../images/Rvictor_caps.jpg) can be broken
    down into an equivalent system of two forces, one that is normal to the section,
    ![Image](../images/RNvictorit_Cap.jpg), and one tangent to it, ![Image](../images/Rtvictorit_Cap.jpg)
    (see [Figure 15-5](ch15.xhtml#ch15fig5)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 等效内力 ![Image](../images/Rvictor_caps.jpg) 可以分解为两个力的等效系统，一个垂直于截面 ![Image](../images/RNvictorit_Cap.jpg)，另一个平行于截面
    ![Image](../images/Rtvictorit_Cap.jpg)（参见[图15-5](ch15.xhtml#ch15fig5)）。
- en: '![Image](../images/15fig05.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig05.jpg)'
- en: '*Figure 15-5: Equivalent internal forces in the section of a beam*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-5：梁截面内的等效内力*'
- en: If the elastic body has a prismatic shape (one of its sides is considerably
    longer than the other two) and we cut a section normal to its directrix, the resulting
    normal force ![Image](../images/RNvictorit_Cap.jpg) we obtain is referred to as
    the *axial force*. The name reflects the fact that this force is aligned with
    the prism’s main axis or directrix. Prismatic bodies are common in structural
    analysis; beams and columns are good examples.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果弹性体具有棱柱形状（其中一边远长于其他两边），并且我们切割与其直线方向垂直的截面，那么得到的法向力 ![Image](../images/RNvictorit_Cap.jpg)
    就被称为 *轴向力*。这个名称反映了该力与棱柱的主轴或直线方向对齐。棱柱体在结构分析中很常见；梁和柱就是很好的例子。
- en: The axial force can either elongate or compress the body. An axial force that
    pulls the body apart is called a *tension force*, whereas one that compresses
    it is known as a *compression force*. [Figure 15-6](ch15.xhtml#ch15fig6) shows
    two prismatic bodies subject to these forces.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 轴向力可以拉长或压缩物体。拉伸物体的轴向力称为 *拉力*，而压缩物体的轴向力则被称为 *压力*。[图15-6](ch15.xhtml#ch15fig6)展示了受到这些力作用的两个棱柱体。
- en: '![Image](../images/15fig06.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig06.jpg)'
- en: '*Figure 15-6: Tension and compression forces*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-6：拉力与压力*'
- en: 'The *shear force* is the force tangent to the cross section (see [Figure 15-7](ch15.xhtml#ch15fig7))
    and thus can be further decomposed into two components: ![Image](../images/rtxvictor_cap.jpg)
    and ![Image](../images/rtyvictor_cap.jpg) (see the diagram on the right of [Figure
    15-5](ch15.xhtml#ch15fig5)). These two components have the same effect: they try
    to shear the body apart. [Figure 15-7](ch15.xhtml#ch15fig7) shows the effect of
    shearing forces applied to a prismatic body.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*剪切力* 是作用在截面上的切向力（参见[图15-7](ch15.xhtml#ch15fig7)），因此可以进一步分解为两个分量：![Image](../images/rtxvictor_cap.jpg)
    和 ![Image](../images/rtyvictor_cap.jpg)（参见[图15-5](ch15.xhtml#ch15fig5)右侧的示意图）。这两个分量具有相同的效果：它们试图剪切物体。
    [图15-7](ch15.xhtml#ch15fig7)展示了剪切力作用在棱柱体上的效果。'
- en: '![Image](../images/15fig07.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig07.jpg)'
- en: '*Figure 15-7: Shear force*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-7：剪切力*'
- en: In summary, the equivalent internal force in a cross section of the body may
    have a normal component that either elongates or compresses it; it may also have
    a tangent component that shears it. These are the two ways internal forces can
    produce deformations on a body.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，物体截面的等效内力可能具有一个法向分量，该分量可以拉长或压缩物体；它还可能具有一个切向分量，该分量使物体发生剪切。这是内力对物体产生变形的两种方式。
- en: '***Bending and Torsional Moments***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***弯曲和扭转力矩***'
- en: We studied the possible effects of the resulting internal force on a given cross
    section. What effects does the resulting moment produce? As you can see in [Figure
    15-8](ch15.xhtml#ch15fig8), the resulting moment ![Image](../images/mvictor.jpg)
    can be decomposed into a moment normal to the cross section, ![Image](../images/mnvictorit_cap.jpg),
    and a moment tangent to it, ![Image](../images/mtvictorit_cap.jpg).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了由此产生的内力对给定截面的可能影响。那么，产生的力矩会有什么效果呢？如[图15-8](ch15.xhtml#ch15fig8)所示，产生的力矩
    ![Image](../images/mvictor.jpg) 可以分解为垂直于截面的力矩 ![Image](../images/mnvictorit_cap.jpg)
    和与截面切线方向平行的力矩 ![Image](../images/mtvictorit_cap.jpg)。
- en: '![Image](../images/15fig08.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig08.jpg)'
- en: '*Figure 15-8: Equivalent internal moments in the section of a beam*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-8：梁截面内的等效内力矩*'
- en: These moments bend the body in arbitrary ways, but if we choose a prismatic
    body and cut it normal to its directrix (the same thing that we did with the forces),
    the moments we obtain have a predictable and well-defined effect. The moment normal
    to the surface, ![Image](../images/mnvictorit_cap.jpg), generates a torsional
    (twisting) effect on the prism and thus receives the name of *torsional moment*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些力矩以任意方式弯曲物体，但如果我们选择一个棱柱体并沿着其主轴方向切割（与我们之前对力的处理方式相同），那么我们得到的力矩会有可预测且明确的效果。垂直于表面的力矩，![Image](../images/mnvictorit_cap.jpg)，会对棱柱体产生扭转（旋转）效应，因此被称为*扭转力矩*。
- en: 'Once again, the moment tangent to the section can be further broken down into
    two subcomponents: ![Image](../images/mtxvictorit_cap.jpg) and ![Image](../images/mtyvictorit_cap.jpg)
    (see the right illustration in [Figure 15-8](ch15.xhtml#ch15fig8)). These two
    moments have a similar effect: they bend the prism and hence are called *bending
    moments*. [Figure 15-9](ch15.xhtml#ch15fig9) illustrates this effect.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，垂直于截面的力矩可以进一步分解为两个子分量：![Image](../images/mtxvictorit_cap.jpg) 和 ![Image](../images/mtyvictorit_cap.jpg)（见[图
    15-8](ch15.xhtml#ch15fig8)右侧插图）。这两个力矩的效果相似：它们会使棱柱体发生弯曲，因此被称为*弯曲力矩*。[图 15-9](ch15.xhtml#ch15fig9)展示了这一效果。
- en: '![Image](../images/15fig09.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig09.jpg)'
- en: '*Figure 15-9: Bending moment*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-9：弯矩*'
- en: To summarize, the equivalent internal moment on a cross section of the body
    may have a normal component that tends to twist it around its directrix (the torsional
    moment) and may also have two tangent moments that tend to bend the prism (the
    bending moments).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，物体横截面上的等效内部力矩可能包含一个会绕其主轴扭转的法向分量（即扭转力矩），也可能有两个切向力矩，它们倾向于弯曲棱柱体（即弯曲力矩）。
- en: Let’s now analyze in detail how prismatic bars behave when subject to axial
    forces. Then, we’ll see how, by using a group of these resistant prisms, we can
    build structures that can withstand the application of heavy loads.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来详细分析棱柱形杆件在轴向力作用下的行为。然后，我们将看到如何利用一组这些抗力棱柱体，构建能够承受重载荷的结构。
- en: '**Tension and Compression**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**拉力与压缩力**'
- en: 'Let’s focus our analysis on axial forces: those aligned with the axis of a
    prismatic resistant body. As we’ll see in the next section, the structures we’ll
    solve are made of only prismatic elements (bars) subject to axial forces.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将分析重点放在轴向力上：即沿着棱柱体抗力体轴线方向的力。如我们在下一节所见，我们解决的结构仅由受轴向力作用的棱柱形元素（杆件）组成。
- en: '***Hooke’s Law***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***胡克定律***'
- en: It’s been experimentally proven that within some limits, the elongation of a
    prismatic bar is proportional to the axial force applied to it. This linear relation
    is known as *Hooke’s law*. Let’s suppose a bar with length *l* and cross section
    *A* is subject to a pair of external forces ![Image](../images/fvictorit.jpg)
    and –![Image](../images/fvictorit.jpg), like in [Figure 15-10](ch15.xhtml#ch15fig10).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实验已证明，在一定范围内，棱柱体杆件的伸长量与施加的轴向力成正比。这个线性关系被称为*胡克定律*。假设一根长度为*l*、截面为*A*的杆件，受一对外力作用，力的大小分别为![Image](../images/fvictorit.jpg)和–![Image](../images/fvictorit.jpg)，如[图
    15-10](ch15.xhtml#ch15fig10)所示。
- en: '![Image](../images/15fig10.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig10.jpg)'
- en: '*Figure 15-10: A bar subject to axial forces*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-10：受轴向力作用的杆件*'
- en: '[Equation 15.1](ch15.xhtml#ch15eqa01) gives Hooke’s law.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[公式 15.1](ch15.xhtml#ch15eqa01)给出了胡克定律。'
- en: '![Image](../images/15eqa01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15eqa01.jpg)'
- en: In this equation,
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，
- en: '*δ*    is the total elongation of the bar.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*δ*    是杆件的总伸长量。'
- en: '*F*    is the ![Image](../images/fvictorit.jpg) force’s magnitude.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*    是![Image](../images/fvictorit.jpg)力的大小。'
- en: '*E*    is the proportionality constant or Young’s modulus, which is specific
    to the material.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*    是比例常数或杨氏模量，它是材料特有的。'
- en: Hooke’s law states that the total elongation *δ* of a bar subject to a pair
    of external forces is (1) directly proportional to the magnitude of the forces
    and the bar’s length and is (2) inversely proportional to its cross section and
    Young’s modulus. The longer a bar or the stronger the force applied is, the greater
    the elongation produced will be. Conversely, the bigger the cross section values
    are or Young’s modulus is, the smaller the elongation will be.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 胡克定律指出，受一对外力作用的杆件的总伸长量*δ*，（1）与力的大小和杆件的长度成正比，并且（2）与其横截面和杨氏模量成反比。杆件越长或施加的力越大，伸长量就越大。相反，横截面值或杨氏模量越大，伸长量则越小。
- en: Recall that when a force is distributed over an area, the intensity of such
    force per unit area is known as *stress*. Stress is usually denoted by the Greek
    letter *σ* (see [Equation 15.2](ch15.xhtml#ch15eqa02)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当力分布在一个面积上时，单位面积上的力强度被称为*应力*。应力通常用希腊字母*σ*表示（参见[方程式 15.2](ch15.xhtml#ch15eqa02)）。
- en: '![Image](../images/15eqa02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/15eqa02.jpg)'
- en: By convention, the stress is positive for tensile forces and negative for compression
    forces. The stress is a useful quantity in mechanical design; it’s used to determine
    whether a given component (in a structure or machine, for example) will break
    down during operation. The stress values a given material can undergo before failure
    are well studied.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，拉伸力的应力为正，压缩力的应力为负。应力在机械设计中是一个有用的量；它用于判断给定部件（例如结构或机器中的部件）在运行中是否会断裂。给定材料在失效前能承受的应力值已被充分研究。
- en: We define *strain* as the elongation per unit length, a dimensionless quantity
    denoted by the Greek letter *ϵ* (see [Equation 15.3](ch15.xhtml#ch15eqa03)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义*应变*为单位长度的伸长，是一个无量纲的量，表示为希腊字母*ϵ*（参见[方程式 15.3](ch15.xhtml#ch15eqa03)）。
- en: '![Image](../images/15eqa03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/15eqa03.jpg)'
- en: Using the equations for the stress and strain, Hooke’s law from [Equation 15.1](ch15.xhtml#ch15eqa01)
    can be rewritten as shown in [Equation 15.4](ch15.xhtml#ch15eqa04).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应力和应变的方程，胡克定律可以从[方程式 15.1](ch15.xhtml#ch15eqa01)重新写成[方程式 15.4](ch15.xhtml#ch15eqa04)所示的形式。
- en: '![Image](../images/15eqa04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/15eqa04.jpg)'
- en: Interestingly, by introducing stress and strain, the relation between the external
    actions applied to a resistant body (forces) and their effects (elongations) no
    longer depends on the area or length of the body. We’ve effectively removed all
    dimensional parameters from the equation. The proportionality constant in [Equation
    15.4](ch15.xhtml#ch15eqa04) (*E*) is Young’s modulus, which is a characteristic
    of materials. For structural steels, for example, *E* is around 200 GPa, that
    is, 200 ⋅ 10⁹ *Pa*. We can therefore predict the mechanical behavior of bodies
    by applying experimental results obtained for the material in use. To do this,
    we use *stress-strain diagrams*, which plot the stress versus the strain for a
    given material.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，通过引入应力和应变，外部作用力（力）与其效果（伸长）之间的关系不再依赖于物体的面积或长度。我们实际上已从方程中去除了所有维度参数。[方程式 15.4](ch15.xhtml#ch15eqa04)中的比例常数（*E*）是杨氏模量，这是材料的一个特性。例如，对于结构钢，*E*约为200
    GPa，即200 ⋅ 10⁹ *Pa*。因此，我们可以通过应用针对所用材料获得的实验结果来预测物体的机械行为。为此，我们使用*应力-应变图*，它绘制了给定材料的应力与应变的关系。
- en: '***Stress-Strain Diagrams***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应力-应变图***'
- en: Stress-strain diagrams plot the stress versus the strain for a given material
    and are obtained by performing tension or compression tests (see [3] for more
    details). We use these diagrams to predict the behavior of resistant bodies made
    of the same material. Recall that since we introduced the quantities stress and
    strain, every dimensional term has disappeared from Hooke’s equation, meaning
    that once we’ve experimentally determined the strain and stress a material undergoes
    under a given load, we can use those results for any bodies made of the same material,
    regardless of their shape or size.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 应力-应变图绘制了给定材料的应力与应变的关系，并通过进行拉伸或压缩试验获得（更多详情请参见[3]）。我们利用这些图表预测由相同材料制成的抗力体的行为。回想一下，自从我们引入了应力和应变这两个量后，胡克定律中的所有维度项都已经消失，这意味着一旦我们通过实验确定了材料在特定载荷下所经历的应力和应变，就可以将这些结果应用于任何由相同材料制成的物体，无论它们的形状或大小如何。
- en: '[Figure 15-11](ch15.xhtml#ch15fig11) is a plot of the approximate stress-strain
    diagram for structural steels. Note this graph is not to scale.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-11](ch15.xhtml#ch15fig11)是结构钢的近似应力-应变图。注意，该图并非按比例绘制。'
- en: '![Image](../images/15fig11.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/15fig11.jpg)'
- en: '*Figure 15-11: The stress-strain diagram for structural steel*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-11：结构钢的应力-应变图*'
- en: This diagram has an initial linear region that holds up to a given stress value
    known as the *proportional limit*, depicted by point A. For stress values greater
    than the proportionality limit, the stress-strain relation is no longer linear.
    The proportional limit is typically between 210 MPa and 350 MPa for structural
    steels—three orders of magnitude smaller than Young’s modulus. This region is
    modeled by Hooke’s law and the linear relation *σ* = *Eϵ*. We’ll center our analysis
    here.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该图有一个初始的线性区域，能够承受一个已知的应力值，称为*比例极限*，由点A表示。对于大于比例极限的应力值，应力-应变关系不再是线性的。比例极限通常在结构钢的210
    MPa到350 MPa之间—比杨氏模量小三个数量级。这个区域由胡克定律建模，线性关系为*σ* = *Eϵ*。我们将在这里集中分析。
- en: With a small stress increment after A, the proportional limit, we reach point
    B, the *yield stress* or *yield strength*. After the yield stress, big elongations
    happen without an increase in the stress. This phenomenon is called the *yielding*
    of the material.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在点A之后，即比例极限，通过一个小的应力增量，我们到达了点B，*屈服应力*或*屈服强度*。在屈服应力之后，尽管应力不再增加，材料却会发生较大的伸长。这个现象被称为材料的*屈服*。
- en: After a noticeable amount of strain, we reach point C, and the material appears
    to harden. The stress must continue to increase to reach point D, which is the
    maximum amount of stress structural steel can withstand. We call this stress value
    the *ultimate stress* or *ultimate strength*. From this point, the material will
    acquire bigger strains with a reduction in the stress value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了明显的应变后，我们到达了点C，材料似乎开始硬化。应力必须继续增加，直到达到点D，这是结构钢能够承受的最大应力。我们将这个应力值称为*极限应力*或*极限强度*。从这个点开始，材料会在应力值减小的情况下承受更大的应变。
- en: The point E is where the material fractures. The amount of strain the material
    can take before it fractures can be called the *fracture strain*. This is the
    point of complete mechanical failure, but if you think about it, after the ultimate
    stress is reached (point D), it’s likely that the material will fracture anyway.
    The ultimate stress is typically used as the maximum value of stress a given material
    can absorb before failure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 点E是材料发生断裂的地方。材料在断裂前能承受的应变量可以称为*断裂应变*。这是完全的机械失效点，但如果你仔细想想，达到极限应力（点D）后，材料很可能会发生断裂。极限应力通常作为材料在失效前能够承受的最大应力值。
- en: Now that we have a good understanding of how resistant bodies respond to tensile
    stresses, let’s look at truss structures.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对承受拉伸应力的承重体的反应有了很好的理解，让我们来看一下桁架结构。
- en: '**Plane Trusses**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**平面桁架**'
- en: 'There are many structural typologies, but we’ll focus our analysis on the simplest
    of them: plane trusses.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类型有很多种，但我们将重点分析其中最简单的一种：平面桁架。
- en: A *plane truss* structure is a structure contained in a plane whose resistant
    bodies are bars subject only to axial forces and whose own weight can be ignored.
    There are two conditions that allow this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*平面桁架*结构是指位于一个平面内的结构，其承重体为仅受轴向力作用的杆件，并且其自重可以忽略。使其成为平面桁架的有两个条件。'
- en: Bars must be joined by pins at their ends.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杆件的端部必须通过铰接销连接。
- en: External loads must always be applied to nodes.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部载荷必须始终作用于节点。
- en: A *node* is the point where several bar ends meet. Nodes join bar ends together
    in frictionless unions, meaning the rotation of the bars around the node is not
    constrained.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*节点*是多个杆件端点相交的地方。节点将杆件端部通过无摩擦的连接连接在一起，这意味着杆件绕节点的旋转不受限制。'
- en: 'Plane trusses are made of triangles: three bars pinned at their ends. The triangle
    is the simplest rigid frame; bars joined to form a polygon of four or more sides
    form nonrigid frames. [Figure 15-12](ch15.xhtml#ch15fig12) shows how a plane truss
    made of four bars can be moved from its original position and thus isn’t considered
    rigid. Simply by adding a new bar and creating two subtriangles, the structure
    becomes rigid.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 平面桁架由三角形构成：三根杆件在其端部铰接。三角形是最简单的刚性框架；连接成四边形或更多边形的杆件形成的是非刚性框架。[图 15-12](ch15.xhtml#ch15fig12)展示了由四根杆件组成的平面桁架如何从原始位置移动，因此不被认为是刚性的。通过增加一根新的杆件并形成两个子三角形，结构变得刚性。
- en: '![Image](../images/15fig12.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/15fig12.jpg)'
- en: '*Figure 15-12: Example of a polygonal plane truss*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-12：多边形平面桁架示例*'
- en: '[Figure 15-13](ch15.xhtml#ch15fig13) is an example of a plane truss. The structure
    is made of eight nodes (N1, N2, . . . , N8) and thirteen bars. Nodes 1 and 5 have
    external supports or constraints applied. Nodes 6, 7, and 8 have external loads
    applied to them.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-13](ch15.xhtml#ch15fig13)是一个平面桁架的示例。该结构由八个节点（N1、N2、...、N8）和十三根杆件组成。节点1和节点5有外部支撑或约束。节点6、7和8承受外部载荷。'
- en: '![Image](../images/15fig13.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig13.jpg)'
- en: '*Figure 15-13: A plane truss structure*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-13：平面桁架结构*'
- en: '[Figure 15-14](ch15.xhtml#ch15fig14) is the diagram resulting from the structural
    analysis of the plane truss described in [Figure 15-13](ch15.xhtml#ch15fig13).
    It was produced by the very application we’ll build in this part of the book.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-14](ch15.xhtml#ch15fig14)是通过对[图 15-13](ch15.xhtml#ch15fig13)中描述的平面桁架进行结构分析得到的图示。它是通过我们将在本书这一部分构建的应用程序生成的。'
- en: '![Image](../images/15fig14.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig14.jpg)'
- en: '*Figure 15-14: A plane truss structure solution diagram*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-14：平面桁架结构解答图*'
- en: In this diagram, we can appreciate the structure’s deformed geometry because
    it has been scaled to be noticeable. Node displacements tend to be very small
    (around two orders of magnitude smaller than the dimension of the structural bars),
    so a diagram depicting the nonscaled node displacements may be hard to tell apart
    from the original geometry.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图示中，我们可以看到结构的变形几何形状，因为它已经被缩放到足够显眼。节点的位移通常非常小（大约是结构杆件尺寸的两个数量级），因此没有缩放的节点位移图示可能难以与原始几何形状区分开来。
- en: 'You’ll notice there’s a lot of information in [Figure 15-14](ch15.xhtml#ch15fig14).
    Every bar is labeled with the stress it’s subject to, though the font size of
    the labels in this figure is small, so the labels may not be easy to read. Positive
    numbers are tension stresses, and negative are compression. The bars are also
    colored in green or red depending on the load they’re subject to: green for tension
    and red for compression. Since the book is printed in black and white, you won’t
    be able to tell the colors apart, but once you’ve developed the complete application,
    you’ll produce the figure with your own code and will be able to explore all the
    details in it.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在[图 15-14](ch15.xhtml#ch15fig14)中有很多信息。每根杆件都标注了它所承受的应力，尽管图中的标签字体较小，因此可能不容易阅读。正数表示拉伸应力，负数表示压缩应力。杆件也根据它们所承受的载荷以绿色或红色进行着色：绿色表示拉伸，红色表示压缩。由于本书是黑白印刷的，你无法分辨颜色，但一旦你开发完成应用程序，你将使用自己的代码生成图形，并能够探索其中的所有细节。
- en: 'Let’s now study the mechanical response of the bars that make up plane trusses.
    They have an interesting particularity we’ve already mentioned: they develop axial
    stresses only.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们研究一下组成平面桁架的杆件的机械响应。它们有一个我们之前提到的有趣特性：它们只会产生轴向应力。
- en: '**Two-Force Members**'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**双力构件**'
- en: As we’ve already discussed, plane truss bars are pinned at their ends, and loads
    are always applied at the nodes; because of this, the bars are subject only to
    axial forces. We can apply an external force only to the ends of the bar, using
    the contact of the pinned joint with the node. Because these unions are frictionless,
    they can only transmit forces to bars and just in the direction of the bar’s directrix.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，平面桁架杆件的端部是铰接的，载荷总是施加在节点上；因此，杆件仅承受轴向力。我们只能在杆件的端部施加外力，通过铰接接头与节点的接触。由于这些接头是无摩擦的，它们只能沿杆件的主方向传递力。
- en: '[Figure 15-15](ch15.xhtml#ch15fig15) shows how an external force applied to
    a node is transferred to the bars. These forces are aligned with the bars’ directrices
    and thus produce axial stresses only.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-15](ch15.xhtml#ch15fig15)展示了外力如何通过节点传递到杆件上。这些力与杆件的主方向对齐，因此只会产生轴向应力。'
- en: '![Image](../images/15fig15.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig15.jpg)'
- en: '*Figure 15-15: The transmission of forces in a node*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-15：节点中力的传递*'
- en: Since bars have two pinned ends where external forces are applied, they are
    subject to two forces. To be in equilibrium, such a body requires the two forces
    to be collinear, equal in magnitude and with opposite directions. In the case
    of a bar (a long prismatic body), these two forces have to be in the direction
    of the bar’s directrix ([Figure 15-16](ch15.xhtml#ch15fig16)) and, hence, produce
    axial stresses only. We call these bars with two collinear forces applied *two-force
    members* (see [Figure 15-16](ch15.xhtml#ch15fig16)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于杆两端均有固定点并施加外力，因此它们受两个力的作用。为了保持平衡，身体需要这两个力共线，大小相等且方向相反。在杆（一个长的棱柱体）的情况下，这两个力必须沿着杆的主方向（见[图
    15-16](ch15.xhtml#ch15fig16)）作用，因此只会产生轴向应力。我们将这些施加有两个共线力的杆称为 *双力构件*（见[图 15-16](ch15.xhtml#ch15fig16)）。
- en: '![Image](../images/15fig16.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig16.jpg)'
- en: '*Figure 15-16: A two-force member*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-16：一个双力构件*'
- en: The forces applied to the bar in [Figure 15-16](ch15.xhtml#ch15fig16) are labeled
    ![Image](../images/fvictorit.jpg) and –![Image](../images/fvictorit.jpg) to signify
    that the two forces must be equal in magnitude and point in opposite directions.
    In this case, the forces would produce tension stresses on the bar.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 15-16](ch15.xhtml#ch15fig16)中施加在杆上的力标记为 ![Image](../images/fvictorit.jpg)
    和 –![Image](../images/fvictorit.jpg)，表示这两个力的大小相等并且方向相反。在这种情况下，力会在杆上产生拉伸应力。
- en: Thanks to Hooke’s law, we know how materials respond to the external application
    of loads. We’ve also explored two-force members, and we’ve seen that the bars
    in plane trusses are two-force members. Let’s now derive a set of equations to
    relate these two forces with the displacements they produce on such two-force
    members.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了霍克定律，我们知道材料如何响应外部荷载的作用。我们还探讨了双力构件，并且看到平面桁架中的杆是双力构件。现在我们来推导一组方程，将这两个力与它们在这种双力构件上产生的位移关联起来。
- en: '**Stiffness Matrices in Global Coordinates**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**全局坐标系中的刚度矩阵**'
- en: 'Going back to the original formulation of Hooke’s law in [Equation 15.1](ch15.xhtml#ch15eqa01),
    we can isolate the force term to get the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[方程 15.1](ch15.xhtml#ch15eqa01)中霍克定律的原始公式，我们可以将力项隔离，得到以下结果：
- en: '![Image](../images/f0397-01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0397-01.jpg)'
- en: Here, the term ![Image](../images/f00397-p1.jpg) is the bar’s proportionality
    constant relating the force applied, *F*, with the elongation it produces, *δ*.
    This term also receives the name *stiffness*. As you can see, the stiffness depends
    on the bar’s Young’s modulus (*E*), which is material dependent, and geometry
    (*A* and *l*).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，术语 ![Image](../images/f00397-p1.jpg) 是杆的比例常数，它将施加的力 *F* 与其产生的伸长 *δ* 相关联。这个术语也称为
    *刚度*。如你所见，刚度依赖于杆的杨氏模量 (*E*)，它是材料特性，和几何形状 (*A* 和 *l*)。
- en: 'Now look at the bar in [Figure 15-17](ch15.xhtml#ch15fig17). If we consider
    a local system of reference whose x-axis is aligned with the bar directrix, this
    bar has two *degrees of freedom (DOF)*, in other words, two different ways it
    can independently move. These are the displacements in the local x-axis of both
    nodes, denoted by ![Image](../images/f00397-p2.jpg) and ![Image](../images/f00397-p3.jpg).
    Each node has a force applied: *F*[1] and *F*[2].'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看[图 15-17](ch15.xhtml#ch15fig17)中的杆。如果我们考虑一个局部坐标系，其 x 轴与杆的主方向对齐，则该杆具有两个 *自由度（DOF）*，换句话说，它有两种不同的独立运动方式。这些是两个节点在局部
    x 轴上的位移，分别用 ![Image](../images/f00397-p2.jpg) 和 ![Image](../images/f00397-p3.jpg)
    表示。每个节点都有一个施加的力：*F*[1] 和 *F*[2]。
- en: '**NOTE**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A note on the nomenclature: we’ll use primes to label DOFs referred to by
    the bar’s local system of coordinates. For example,* ![Image](../images/ui1victor.jpg)
    *refers to the* x *displacement of the node 1 referred to the bar’s local system
    of reference:* (x^′,y^′)*. By contrast, nonprime values, such as* u[1]*, are referred
    to the global system of reference:* (x,y).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名法说明：我们将使用撇号来标记杆局部坐标系中参考的自由度（DOF）。例如，*![Image](../images/ui1victor.jpg)*
    指的是节点 1 在杆局部坐标系中的 x 位移：(x^′,y^′)*。相比之下，没有撇号的值，如* u[1]*，是指全球坐标系的参考：(x,y)。*'
- en: '![Image](../images/15fig17.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig17.jpg)'
- en: '*Figure 15-17: A bar with two degrees of freedom*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-17：具有两个自由度的杆*'
- en: 'Using the previous equation, we can relate the force in each node to the displacements
    ![Image](../images/f00397-p2.jpg) and ![Image](../images/f00397-p3.jpg) like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的方程，我们可以将每个节点的力与位移 ![Image](../images/f00397-p2.jpg) 和 ![Image](../images/f00397-p3.jpg)
    关联起来，如下所示：
- en: '![Image](../images/f0398-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0398-01.jpg)'
- en: The two equations above can be written in matrix notation ([Equation 15.5](ch15.xhtml#ch15eqa05)),
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个方程可以用矩阵表示法写出 ([方程 15.5](ch15.xhtml#ch15eqa05))，
- en: '![Image](../images/15eqa05.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15eqa05.jpg)'
- en: where [*k*^′] is referred to as the local *stiffness matrix* for the bar. This
    stiffness matrix relates the displacements in the two nodes of the bar with the
    external forces applied to them, all in the bar’s local system of reference. Using
    this local system of reference, the bar has only two degrees of freedom, which
    are the displacements of each of the two nodes in the local x-axis direction (![Image](../images/f00397-p2.jpg)
    and ![Image](../images/f00397-p3.jpg)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，[*k*^′] 被称为杆件的局部*刚度矩阵*。这个刚度矩阵将杆件两节点的位移与施加在它们上的外力联系起来，所有内容都在杆件的局部参考系中。使用这个局部参考系，杆件只有两个自由度，即每个节点在局部
    x 轴方向上的位移 (![Image](../images/f00397-p2.jpg) 和 ![Image](../images/f00397-p3.jpg))。
- en: Let’s now consider a bar rotated with respect to the global system of coordinates.
    Take [Figure 15-18](ch15.xhtml#ch15fig18) as an example. This bar has its own
    local system of reference (*x*^′, *y*^′), which forms an angle of *θ* with respect
    to the global system of reference (*x,y*).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来考虑一个相对于全局坐标系旋转的杆件。以 [图 15-18](ch15.xhtml#ch15fig18) 为例。该杆件有自己的局部参考系 (*x*^′,
    *y*^′)，它与全局参考系 (*x, y*) 形成一个角度 *θ*。
- en: '![Image](../images/15fig18.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig18.jpg)'
- en: '*Figure 15-18: A bar’s local reference frame*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-18：杆件的局部参考系*'
- en: 'From the global system of reference’s perspective, each node of the bar has
    two degrees of freedom: each node can move in both the x and y directions. Projected
    in this system of reference, the four DOFs are *u*[1], *v*[1], *u*[2], and *v*[2].'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从全局参考系的角度来看，杆件的每个节点有两个自由度：每个节点可以在 x 和 y 方向上移动。在这个参考系下，四个自由度分别是 *u*[1]、*v*[1]、*u*[2]
    和 *v*[2]。
- en: To transform the bar’s local stiffness matrix [*k*^′] into a global [*k*] stiffness
    matrix, we have to apply a transformation matrix. We can find such a matrix by
    breaking down the local displacements ![Image](../images/f00397-p2.jpg) and ![Image](../images/f00397-p3.jpg)
    into their global components. [Figure 15-19](ch15.xhtml#ch15fig19) shows this
    operation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将杆件的局部刚度矩阵 [*k*^′] 转换为全局的 [*k*] 刚度矩阵，我们必须应用一个变换矩阵。我们可以通过将局部位移 ![Image](../images/f00397-p2.jpg)
    和 ![Image](../images/f00397-p3.jpg) 分解为它们的全局分量来找到这样一个矩阵。 [图 15-19](ch15.xhtml#ch15fig19)
    展示了这个操作。
- en: '![Image](../images/15fig19.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig19.jpg)'
- en: '*Figure 15-19: The local displacement projections*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-19：局部位移投影*'
- en: 'Let’s find a mathematical expression to compute the global displacements based
    on their local counterparts:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来找一个数学表达式，通过它来计算基于局部位移的全局位移：
- en: '![Image](../images/f0399-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0399-01.jpg)'
- en: Written in its matrix form, it looks like
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以矩阵形式写出，它的形式如下：
- en: '![Image](../images/f0399-02.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0399-02.jpg)'
- en: where [*L*] is the transformation matrix. To compute the global stiffness matrix
    from the local [*k*^′], we can use the following equation (refer to [2] or [10]
    for the details on how to derive this expression),
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，[*L*] 是变换矩阵。为了从局部的 [*k*^′] 计算全局刚度矩阵，我们可以使用以下方程（有关如何推导这个表达式的详细信息，请参见 [2] 或
    [10]）。
- en: '[*k*] = [*L*]^′[*k*]^′[*L*]'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[*k*] = [*L*]^′[*k*]^′[*L*]'
- en: which, shortening the notation to *c* = cos*θ* and *s* = sin*θ*, yields [Equation
    15.6](ch15.xhtml#ch15eqa06).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简化符号为 *c* = cos*θ* 和 *s* = sin*θ*，得到 [方程 15.6](ch15.xhtml#ch15eqa06)。
- en: '![Image](../images/15eqa06.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15eqa06.jpg)'
- en: We now have a system of equations that relates the external forces applied to
    a bar’s nodes to their displacements in global coordinates (see [Equation 15.7](ch15.xhtml#ch15eqa07)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个方程组，它将施加在杆件节点上的外力与它们在全局坐标系中的位移联系起来（参见 [方程 15.7](ch15.xhtml#ch15eqa07)）。
- en: '![Image](../images/15eqa07.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15eqa07.jpg)'
- en: Let’s now use this knowledge to start building our structural model in code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们利用这些知识开始在代码中构建我们的结构模型。
- en: '**Original Structure Model**'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**原始结构模型**'
- en: 'In our *Mechanics* project, create a new Python package named *structures*.
    In *structures*, create another package: *model*. Here’s where we’ll define the
    classes that make up the structural model. Create another package in *structures*
    named *solution*. This is where we’ll have the classes that model the resolved
    structure. Also create a *tests* folder in *structures* to contain the unit tests
    we’ll develop. Your project’s structure should look something like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的*力学*项目中，创建一个新的 Python 包，命名为*structures*。在*structures*中，再创建一个包：*model*。在这里我们将定义构成结构模型的类。再在*structures*中创建一个名为*solution*的包。在这里，我们将定义模拟已解析结构的类。还需要在*structures*中创建一个*tests*文件夹，包含我们将要开发的单元测试。你项目的结构应当是这样的：
- en: Mechanics
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 力学
- en: '|- apps'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 应用'
- en: '|- eqs'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|- eqs'
- en: '|- geom2d'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|- graphic'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|- graphic'
- en: '|- structures'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 结构'
- en: '|    |- model'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- model'
- en: '|    |   |- __init__.py'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |   |- __init__.py'
- en: '|    |- solution'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- solution'
- en: '|    |   |- __init__.py'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |   |- __init__.py'
- en: '|    |- tests'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- tests'
- en: '|    |   |- __init__.py'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |   |- __init__.py'
- en: '|    |- __init__.py'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- __init__.py'
- en: '|- utils'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|- 工具'
- en: The next step is to create a class that represents structural nodes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个表示结构节点的类。
- en: '***The Node Class***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***节点类***'
- en: Create a new file in *model* named *node.py* and enter the code in [Listing
    15-1](ch15.xhtml#ch15lis1). This is the basic definition for a structural node.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在*model*中创建一个新文件，命名为*node.py*，并输入[列表 15-1](ch15.xhtml#ch15lis1)中的代码。这是结构节点的基本定义。
- en: '[PRE0]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 15-1: Structure node class*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-1：结构节点类*'
- en: In this listing, we define the new class StrNode. This class defines an id,
    which will serve to identify each of its instances.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们定义了新的类 StrNode。这个类定义了一个 id，用来标识它的每个实例。
- en: 'Note that the parameter passed to the constructor uses an underscore: _id ➊.
    Python already has an id global function defined, so if we named our parameter
    the same (instead of using the underscore), we’d be shadowing the global id function
    definition inside the constructor. This means id wouldn’t refer to Python’s function
    inside the constructor but to our passed-in value instead. Although we’re not
    using Python’s id function inside this class’s constructor, we’ll try to avoid
    shadowing global functions.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，传递给构造函数的参数使用了下划线：_id ➊。Python 已经定义了一个名为 id 的全局函数，因此如果我们将参数命名为 id（而不是使用下划线），我们就会在构造函数内覆盖这个全局
    id 函数的定义。这意味着 id 在构造函数中不再指代 Python 的函数，而是指代我们传入的值。虽然我们在这个类的构造函数中并没有使用 Python 的
    id 函数，但我们会尽量避免覆盖全局函数。
- en: The StrNode also includes an instance of the Point class that determines the
    node’s position and a list of loads applied to the node with a default value of
    None. The structure may have quite a few nodes without external loads applied
    to them; thus, we make the loads argument optional (and provide a default value
    of None). When the loads argument is None, we assign the self.loads attribute
    an empty list ([]) ➋.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: StrNode 还包含一个 Point 类的实例，用来确定节点的位置，并且包含一个默认值为 None 的加载列表。结构可能有很多节点没有外部加载，因此我们将加载参数设为可选（并提供默认值
    None）。当加载参数为 None 时，我们将 self.loads 属性赋为空列表（[]） ➋。
- en: 'You might be wondering how the or operator works in ➋:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道或运算符在 ➋ 中是如何工作的：
- en: '[PRE1]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The or operator returns the first “truthy” value from its operands or None.
    Take a look at the following examples:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 或运算符返回其操作数中第一个“真实”的值或 None。看以下示例：
- en: '[PRE2]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you might have guessed, in a boolean context, None is evaluated as “falsy.”
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，在布尔上下文中，None 被评估为“假”。
- en: 'There are two more attributes that we have to pass the constructor; these are
    given a default value in the constructor: dx_constrained and dy_constrained. These
    attributes determine whether the displacements in the x and y directions are externally
    constrained. We initialize them as False, which means the node isn’t externally
    constrained unless we say otherwise.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个属性我们需要传递给构造函数，它们在构造函数中有默认值：dx_constrained 和 dy_constrained。这些属性决定了在 x 和
    y 方向上的位移是否受到外部约束。我们将它们初始化为 False，这意味着节点不会受到外部约束，除非我们明确指出。
- en: 'We’ve defined two properties in the class: loads_count and net_load. The first,
    loads_count, simply returns the length of the loads list.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类中定义了两个属性：loads_count 和 net_load。第一个属性 loads_count 只是返回 loads 列表的长度。
- en: '**NOTE**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you remember the law of Demeter from [Chapter 5](ch05.xhtml#ch05), anyone
    from outside the* StrNode *class who wants to know the number of loads applied
    to the node should be able to ask* StrNode *directly. But asking* StrNode *to
    return the list of loads and then use the* len *function to get its length would
    violate this important principle.*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你记得[第五章](ch05.xhtml#ch05)中的德梅特法则，任何想要知道施加在节点上的载荷数量的外部人员，都应该能直接向* StrNode
    *类询问。但如果让* StrNode *返回载荷列表，再使用* len *函数来获取其长度，就会违反这一重要原则。*'
- en: 'The net_load property uses reduce to compute the sum of all the loads ➌. Note
    that we’re passing in a third argument to the reduce function: Vector(0, 0). This
    third argument is the initial value for the reduction. In the perfectly valid
    case that the list of loads is empty, we’ll return this initial value. Otherwise,
    the first step in the reduction process will combine this initial value with the
    list’s first item. If we didn’t provide an initial value, reducing the loads list
    would raise the following error:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: net_load 属性使用 reduce 来计算所有载荷的总和 ➌。注意，我们向 reduce 函数传递了第三个参数：Vector(0, 0)。这个第三个参数是归约的初始值。在载荷列表为空的完全有效的情况下，我们将返回这个初始值。否则，归约过程的第一步将把这个初始值与列表的第一个元素结合起来。如果没有提供初始值，减少载荷列表将引发以下错误：
- en: '[PRE3]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we’ll add a method to add loads to the node’s list of loads; enter the
    method in [Listing 15-2](ch15.xhtml#ch15lis2).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个方法来向节点的载荷列表中添加载荷；在[列表 15-2](ch15.xhtml#ch15lis2)中输入该方法。
- en: '[PRE4]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 15-2: Adding loads to the node*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-2：向节点添加载荷*'
- en: Lastly, let’s implement the equality comparison for the StrNode class. There
    are a few attributes in the class, but we’ll consider two nodes equal only if
    they are located at equal positions in the plane. This comparison deems overlapping
    nodes to be equal, regardless of their other attributes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来实现 StrNode 类的相等性比较。类中有一些属性，但我们认为只有当两个节点在平面上的位置相同时，它们才是相等的。这个比较将认为重叠的节点是相等的，而不管它们的其他属性。
- en: If we want nodes in a structure to be truly unique, we could rely on an equality
    comparison that compares all of the attributes of a node, including the list of
    loads and external constraints. In our case, we’re interested only in making sure
    that we have no overlapping nodes, though. If we included more fields in the equality
    check, it could happen that two overlapping nodes (nodes with the same position)
    were evaluated as different because they have a different list of loads. We’d
    be allowing two overlapping nodes to exist in the structure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望结构中的节点是真正唯一的，可以依赖于一个相等性比较，比较节点的所有属性，包括载荷列表和外部约束。在我们的情况下，我们只关心确保没有重叠的节点。如果我们在相等性检查中包括更多的字段，可能会发生两个重叠的节点（具有相同位置）被评估为不同的，因为它们有不同的载荷列表。这样我们就会允许两个重叠的节点在结构中共存。
- en: Enter the __eq__ method implementation in [Listing 15-3](ch15.xhtml#ch15lis3).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 15-3](ch15.xhtml#ch15lis3)中输入 __eq__ 方法的实现。
- en: '[PRE5]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 15-3: Nodes equality*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-3：节点相等性*'
- en: Our StrNode class is now ready! [Listing 15-4](ch15.xhtml#ch15lis4) contains
    the resulting StrNode class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 StrNode 类现在准备好了！[列表 15-4](ch15.xhtml#ch15lis4)包含了最终的 StrNode 类。
- en: '[PRE6]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 15-4: Node class result*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-4：节点类结果*'
- en: Let’s now implement a class to represent structural bars.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现一个类来表示结构杆件。
- en: '***The Bar Class***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***杆件类***'
- en: 'Structural bars are defined between two nodes modeled by the StrNode class.
    Bars need to store values for the two resistant properties required for the stiffness
    matrix calculation ([Equation 15.6](ch15.xhtml#ch15eqa06)): the Young’s modulus
    and cross section.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 结构杆件是由两个由 StrNode 类建模的节点之间定义的。杆件需要存储计算刚度矩阵所需的两个抗性属性的值（[方程 15.6](ch15.xhtml#ch15eqa06)）：杨氏模量和截面。
- en: '**Implementing the Bar Class**'
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实现杆件类**'
- en: In *model* create a new file named *bar.py* and enter the initial definition
    for the StrBar class ([Listing 15-5](ch15.xhtml#ch15lis5)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *model* 中创建一个名为 *bar.py* 的新文件，并输入 StrBar 类的初始定义（[列表 15-5](ch15.xhtml#ch15lis5)）。
- en: '[PRE7]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 15-5: Structure bar class*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-5：结构杆件类*'
- en: 'In this listing we define the StrBar class with five attributes: the ID that
    serves as identifier, the start and end nodes, the cross section value, and the
    Young’s modulus value. These are passed in to the constructor and stored inside
    the class.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表中，我们定义了 StrBar 类，包含五个属性：作为标识符的 ID，起始节点和终止节点，截面值，以及杨氏模量值。这些值传递给构造函数并存储在类中。
- en: 'We also define two properties using the @property decorator: geometry and length.
    The geometry of the bar is a segment going from the start node position to the
    end node position, and the length of the bar is this segment’s length.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 @property 装饰器定义了两个属性：geometry 和 length。杆件的几何形状是一个从起始节点位置到结束节点位置的线段，杆件的长度就是这个线段的长度。
- en: The last thing we need to implement is a method to compute the bar’s stiffness
    matrix in global coordinates as defined in [Equation 15.6](ch15.xhtml#ch15eqa06).
    Enter the method in [Listing 15-6](ch15.xhtml#ch15lis6).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一件事是一个方法，用来计算杆件在全局坐标系中的刚度矩阵，正如[方程 15.6](ch15.xhtml#ch15eqa06)所定义的那样。在[清单
    15-6](ch15.xhtml#ch15lis6)中输入该方法。
- en: '[PRE8]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 15-6: Bar stiffness matrix in global coordinates*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-6：全局坐标系中的杆件刚度矩阵*'
- en: 'Don’t forget to import Matrix, shown here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了导入 Matrix，如下所示：
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ve added the global_stiffness_matrix method. This method creates a 4 × 4
    matrix and sets its values to the appropriate stiffness terms as given in [Equation
    15.6](ch15.xhtml#ch15eqa06) and repeated here for convenience:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 global_stiffness_matrix 方法。该方法创建一个 4 × 4 的矩阵，并将其值设置为适当的刚度项，正如[方程 15.6](ch15.xhtml#ch15eqa06)中所给出的，并为方便起见在此重复：
- en: '![Image](../images/f0406-01.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0406-01.jpg)'
- en: To compute each of the values, we first get the bar geometry’s direction vector
    and get its sine and cosine. Because every term in [*k*] is multiplied by ![Image](../images/f00397-p1.jpg),
    we compute it and store the result in the eal variable. From the sixteen terms
    in the matrix, there are really only three different values we need to compute.
    These are stored in c2_eal, s2_eal, and sc_eal, and they are later referenced
    in the set_data method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算每个值，我们首先获取杆件几何形状的方向向量，并计算它的正弦和余弦。由于 [*k*] 中的每一项都乘以 ![Image](../images/f00397-p1.jpg)，我们计算它并将结果存储在
    eal 变量中。矩阵中的十六个项实际上只有三个不同的值需要计算。这些值分别存储在 c2_eal、s2_eal 和 sc_eal 中，后续会在 set_data
    方法中引用。
- en: '**Testing the Bar Class**'
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试 Bar 类**'
- en: The stiffness matrix computation is core to our structural analysis problem;
    a bug in this code would result in completely incorrect results, like, for instance,
    huge deformations in the bars. Let’s add a unit test to make sure all the terms
    in the stiffness matrix are computed correctly. We first need to create a new
    test file in the *structures/tests* directory named *bar_test.py*. In the file,
    enter the code in [Listing 15-7](ch15.xhtml#ch15lis7).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 刚度矩阵的计算是我们结构分析问题的核心；如果这段代码有 bug，会导致完全错误的结果，比如，杆件出现巨大的变形。让我们添加一个单元测试，确保刚度矩阵中的所有项都能正确计算。我们首先需要在
    *structures/tests* 目录中创建一个新的测试文件，命名为 *bar_test.py*。在文件中输入[清单 15-7](ch15.xhtml#ch15lis7)中的代码。
- en: '[PRE10]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 15-7: Testing the bar’s stiffness matrix*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-7：测试杆件的刚度矩阵*'
- en: 'In this test we create a bar with nodes located at (0, 0) and (2, 1), a section
    of ![Image](../images/f00407-p1.jpg), and a Young’s modulus of 5\. We chose these
    numbers so all the values in the expected stiffness matrix would be integers,
    which makes it convenient for us to write the assertion, particularly in this
    case: ![Image](../images/f00407-p2.jpg), ![Image](../images/f00407-p3.jpg), and
    ![Image](../images/f00407-p4.jpg).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们创建了一根节点位于 (0, 0) 和 (2, 1) 之间的杆件，截面如 ![Image](../images/f00407-p1.jpg)，杨氏模量为
    5。我们选择这些数字是为了让期望的刚度矩阵中的所有值都是整数，这样可以方便我们编写断言，特别是在这个情况下：![Image](../images/f00407-p2.jpg)，![Image](../images/f00407-p3.jpg)，和
    ![Image](../images/f00407-p4.jpg)。
- en: You can run the test from the IDE by clicking the green play button or from
    the shell.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击绿色播放按钮或从终端运行测试。
- en: '[PRE11]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should produce the following output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE12]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Your StrBar class should look similar to [Listing 15-8](ch15.xhtml#ch15lis8).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 StrBar 类应该与[清单 15-8](ch15.xhtml#ch15lis8)类似。
- en: '[PRE13]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 15-8: Bar class result*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-8：Bar 类结果*'
- en: 'We need one last class to bundle nodes and bars together: the structure itself.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要最后一个类来将节点和杆件组合在一起：结构本身。
- en: '***The Structure Class***'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Structure 类***'
- en: Create a new Python file named *structure.py* in *structures/model* and enter
    the Structure class’s code ([Listing 15-9](ch15.xhtml#ch15lis9)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *structures/model* 中创建一个新的 Python 文件，命名为 *structure.py*，并输入 Structure 类的代码([清单
    15-9](ch15.xhtml#ch15lis9))。
- en: '[PRE14]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 15-9: Structure class*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-9：Structure 类*'
- en: This class is quite simple at the moment, but in a later chapter, we’ll write
    the code responsible for assembling the structure’s global stiffness matrix, generating
    the system of equations, solving it, and creating the solution. For now, all the
    class does is store a list of nodes and a list of bars passed in to the constructor,
    along with a few computations that deal with the number of items it holds.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类目前非常简单，但在后续章节中，我们将编写代码来组装结构的全局刚度矩阵，生成方程组，求解它，并创建解。现在，这个类仅存储传递给构造函数的节点列表和杆件列表，以及一些处理其包含项数量的计算。
- en: 'The loads_count property sums the load count from every node. To accomplish
    this, we pass a lambda function as the first argument to the reduce function.
    This lambda takes two arguments: the current count of loads and the next node
    in the self.__nodes list. This reduction requires an initial value (which is the
    third argument, the 0), which we add the first node’s count to. Without this initial
    value, the reduction couldn’t take place, because the reduce function wouldn’t
    know what value the lambda’s first parameter, count, had for the first iteration.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: loads_count 属性会计算每个节点的荷载总数。为了实现这一点，我们将一个 lambda 函数作为第一个参数传递给 reduce 函数。这个 lambda
    函数有两个参数：当前的荷载计数和 self.__nodes 列表中的下一个节点。这个归约操作需要一个初始值（即第三个参数 0），我们将第一个节点的计数值加到它上面。如果没有这个初始值，归约操作将无法进行，因为
    reduce 函数不知道 lambda 的第一个参数 count 在第一次迭代时的值。
- en: We now have the complete model that defines the structure!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了完整的模型来定义结构！
- en: '***Creating a Structure from the Python Shell***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从 Python Shell 创建结构***'
- en: Let’s try to construct the truss structure in [Figure 15-20](ch15.xhtml#ch15fig20)
    using our model classes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们的模型类构建[图 15-20](ch15.xhtml#ch15fig20)中的桁架结构。
- en: '![Image](../images/15fig20.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/15fig20.jpg)'
- en: '*Figure 15-20: Example truss structure*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-20：示例桁架结构*'
- en: 'To define the structure, first import the following classes in the Python shell:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义结构，首先在 Python shell 中导入以下类：
- en: '[PRE15]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then enter the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后输入以下代码：
- en: '[PRE16]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, creating the model for a truss structure in code is a piece
    of cake. In any case, we’ll most often load the model from an external definition
    file, as we’ll learn in [Chapter 17](ch17.xhtml#ch17). Working an example by hand,
    nevertheless, is a great exercise to understand how our model classes work.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在代码中创建桁架结构的模型非常简单。无论如何，我们最常见的做法是从外部定义文件加载模型，正如我们将在[第 17 章](ch17.xhtml#ch17)中学到的那样。然而，手动操作一个例子是理解我们模型类如何工作的一个很好的练习。
- en: 'To finish this chapter, let’s create the model for the structure’s solution:
    the classes that will store the node displacements and bar stresses.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一章，让我们创建结构解算模型：存储节点位移和杆件应力的类。
- en: '**The Structure Solution Model**'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结构解算模型**'
- en: We’ll tackle resolving the structure in the next chapter, but we’ll prepare
    the classes to store the solution values here. For now, let’s imagine we have
    the resolution algorithm ready and require the solution classes to store the solution’s
    data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章解决结构的解算问题，但在这里我们会准备类来存储解算值。现在，假设我们已经准备好了求解算法，需要使用解算类来存储解算的数据。
- en: When we resolve a structure, we first obtain the node displacements in global
    coordinates. From the new positions of the structure’s nodes, we can compute all
    the rest (strains, stresses, and reaction values). We need a new class to represent
    displaced nodes, which are similar to the nodes we’ve just defined using the StrNode
    class, but with the addition of a displacement vector.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解算一个结构时，首先获得节点在全局坐标系中的位移。通过结构节点的新位置，我们可以计算出其余的所有数据（如应变、应力和反作用力值）。我们需要一个新类来表示位移节点，这些节点类似于我们刚刚使用
    StrNode 类定义的节点，只是多了一个位移向量。
- en: 'These node displacements will elongate or compress the structure’s bars. Remember
    that bars develop strains and stresses, which are their mechanical response to
    being extended or compressed. The strain and stress values are important pieces
    of data in the structural solution: they’ll determine whether the structure can
    withstand the loads applied to it.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点位移会使结构的杆件发生拉伸或压缩。记住，杆件会产生应变和应力，这是它们对拉伸或压缩的机械反应。应变和应力值是结构解算中的重要数据，它们将决定结构是否能够承受施加的荷载。
- en: We’ll create a new class to represent the solution bars as well. This class
    will reference the displaced nodes and compute the strain and stress values.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个新类来表示解算的杆件。这个类将引用位移后的节点，并计算应变和应力值。
- en: '***The Solution Nodes***'
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解法节点***'
- en: Let’s create the class that represents nodes in the structure’s solution. In
    the *structures/solution* package, create a new file named *node.py* and enter
    the code in [Listing 15-10](ch15.xhtml#ch15lis10).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个表示结构解法中节点的类。在 *structures/solution* 包中，创建一个名为 *node.py* 的新文件，并输入[列表 15-10](ch15.xhtml#ch15lis10)中的代码。
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 15-10: Solution node class*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-10：解法节点类*'
- en: This listing declares the StrNodeSolution class. As you can see, this class’s
    constructor gets passed the original node and its displacement vector in global
    coordinates—that’s all we need. The original node is kept private to the class
    (__original_node), but some of its properties are exposed. For example, the id
    property ➊ simply returns the original node’s ID, and the same goes for loads.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码段声明了 StrNodeSolution 类。如你所见，该类的构造函数接受原始节点及其在全局坐标系中的位移向量——这就是我们所需要的。原始节点被设置为类的私有属性
    (__original_node)，但它的一些属性被暴露出来。例如，id 属性 ➊ 仅返回原始节点的 ID，加载（loads）也是如此。
- en: 'The original_pos property ➋ returns the original node’s position: the position
    before applying the displacement obtained as part of the structure’s resolution.
    The naming here is important, as we’ll shortly add another property to expose
    the new position of the node after being displaced.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: original_pos 属性 ➋ 返回原始节点的位置：即在应用作为结构解法一部分获得的位移之前的位置。这里的命名很重要，因为我们稍后将添加另一个属性，用于暴露节点在被位移后的新位置。
- en: The is_constrained property ➌ checks whether the original node had any of its
    degrees of freedom (the displacement in x or y) externally constrained. We’ll
    use this information to know whether a reaction force needs to be computed for
    the node or not. *Reaction forces* are those external forces exerted by the supports
    or constraints in a node. We want to know the magnitude of the force a support
    absorbs to properly design and dimension this support.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: is_constrained 属性 ➌ 检查原始节点是否有任何自由度（在 x 或 y 方向上的位移）被外部约束。我们将使用此信息来确定是否需要为节点计算反作用力。*反作用力*是支撑或约束在节点上施加的外力。我们需要知道支撑所承受的力的大小，以便正确设计和确定支撑的尺寸。
- en: 'Lastly, we have three properties related to the external loads: loads ➍, is_loaded
    ➎, and net_load ➏. The first simply returns the original node’s list of forces.
    We’ll use this information when drawing the solution to a vector image like in
    [Figure 15-14](ch15.xhtml#ch15fig14). Property is_loaded lets us know whether
    the node has any load applied. This property will be handy when we need to check
    which solution nodes have a load applied to them to draw those loads to the result
    diagram. Property net_load returns the original node’s net load, which we’ll use
    to compute the reaction force in the node.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有三个与外部载荷相关的属性：loads ➍、is_loaded ➎ 和 net_load ➏。第一个属性仅返回原始节点的力的列表。我们将在绘制像[图
    15-14](ch15.xhtml#ch15fig14)那样的向量图时使用此信息。属性 is_loaded 让我们知道节点是否施加了任何载荷。这个属性在我们需要检查哪些解法节点上施加了载荷并将这些载荷绘制到结果图中时非常有用。属性
    net_load 返回原始节点的净载荷，我们将使用它来计算节点的反作用力。
- en: '**Displaced Position**'
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**位移位置**'
- en: Let’s include the displaced position as a property. Since displacements tend
    to be orders of magnitude smaller than the structure’s dimensions, we’ll want
    to include a method that scales the displacement vector to plot the resulting
    deformed geometry. This ensures that we’ll be able to tell the deformed geometry
    apart from the original geometry in the resulting diagram.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将位移位置作为一个属性。由于位移通常比结构的尺寸小几个数量级，我们希望包含一个方法来缩放位移向量，以便绘制出变形后的几何图形。这确保了我们能够在结果图中区分变形后的几何图形与原始几何图形。
- en: Enter the code shown in [Listing 15-11](ch15.xhtml#ch15lis11) in the StrNodeSolution
    class.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表 15-11](ch15.xhtml#ch15lis11)中的代码输入到 StrNodeSolution 类中。
- en: '[PRE18]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 15-11: Solution node displacement*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-11：解法节点位移*'
- en: The displaced_pos method returns the position of the original node after applying
    the global_disp vector to it. The displaced_pos_scaled method does something similar,
    but with a scale value that will allow us to increase the displacement’s size.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: displaced_pos 方法返回在应用全局位移向量后，原始节点的位置。displaced_pos_scaled 方法做类似的事情，但带有一个缩放值，允许我们增加位移的大小。
- en: '**The End Result**'
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**最终结果**'
- en: If you’ve followed along, your StrNodeSolution class should look like [Listing
    15-12](ch15.xhtml#ch15lis12).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照步骤操作，你的 StrNodeSolution 类应该与[列表 15-12](ch15.xhtml#ch15lis12)中显示的一样。
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 15-12: Solution node class result*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-12：解法节点类结果*'
- en: Let’s now implement the bar’s solution class.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现杆的解类。
- en: '***The Solution Bars***'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解杆***'
- en: Knowing the displacements of a bar’s nodes is all we need to compute its strain
    and axial stress. We’ll explain why this is as we develop the StrBarSolution class.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 知道杆的节点位移是我们计算其应变和轴向应力所需的全部。我们将在开发 `StrBarSolution` 类时解释为什么如此。
- en: Create a new file in *structures/solution* named *bar.py* and enter the code
    in [Listing 15-13](ch15.xhtml#ch15lis13).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *structures/solution* 目录下创建一个新文件，命名为 *bar.py*，并输入 [Listing 15-13](ch15.xhtml#ch15lis13)
    中的代码。
- en: '[PRE20]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 15-13: Solution bar class*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-13: 解杆类*'
- en: The StrBarSolution class is initialized with the original bar and the two solution
    nodes. In the constructor, we check that we got the correct solution nodes passed
    in by comparing their IDs with the original bar nodes’ IDs. If we detect a wrong
    node is being passed, we raise a ValueError that will halt execution. If we continued
    executing the program, the results would be incorrect because the solution bar
    would be linked with nodes it wasn’t connected to in the original definition of
    the structure. This will prevent us from making mistakes when constructing the
    structure’s solution classes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`StrBarSolution` 类使用原始杆和两个解节点进行初始化。在构造函数中，我们通过将解节点的 ID 与原始杆节点的 ID 进行比较，检查是否传入了正确的解节点。如果检测到传入了错误的节点，我们将引发
    `ValueError`，并终止程序执行。如果继续执行，结果将是错误的，因为解杆将与原始定义中未连接的节点相连。这将防止我们在构建结构的解类时犯错误。'
- en: The class also defines the id, cross_section, and young_mod properties. These
    simply return the original bar’s values.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还定义了 `id`、`cross_section` 和 `young_mod` 属性。这些属性只是返回原始杆的值。
- en: '**Elongation, Stress, and Strain**'
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**伸长、应力与应变**'
- en: Let’s now work out the strain and stress values one step at a time. The stress
    can be derived from the strain (using [Equation 15.4](ch15.xhtml#ch15eqa04)),
    so we’ll start with the strain. The strain is the bar’s elongation per unit of
    length (see [Equation 15.3](ch15.xhtml#ch15eqa03)), so we need to find out this
    elongation value. For this, we first want to know both the bar’s original and
    resulting geometries. Enter the properties shown in [Listing 15-14](ch15.xhtml#ch15lis14).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们一步一步地计算应变和应力。应力可以通过应变推导出来（使用 [Equation 15.4](ch15.xhtml#ch15eqa04)），所以我们从应变开始。应变是杆的每单位长度的伸长（见
    [Equation 15.3](ch15.xhtml#ch15eqa03)），因此我们需要找出这个伸长值。为此，我们首先要了解杆的原始几何形状和结果几何形状。输入
    [Listing 15-14](ch15.xhtml#ch15lis14) 中显示的属性。
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 15-14: Solution bar geometry*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-14: 解杆几何形状*'
- en: The original geometry was already a property in StrBar. The final geometry is
    also a segment, this time between the displaced start and end nodes. It’s important
    to understand that since the bars of a truss structure are two-force members,
    they’re only subject to axial forces. Thus, the directrix of the bars will always
    remain a straight segment. [Figure 15-21](ch15.xhtml#ch15fig21) depicts the original
    bar and the deformed bar that results when displacing the position of the original
    nodes ![Image](../images/u1victorit.jpg) and ![Image](../images/u2victorit.jpg).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 原始几何形状已经是 `StrBar` 类中的一个属性。最终几何形状也是一个线段，这次是位移后的起始节点和结束节点之间的线段。需要理解的是，由于桁架结构的杆是二力构件，它们只受轴向力的作用。因此，杆的导线将始终保持为一条直线。[Figure
    15-21](ch15.xhtml#ch15fig21) 描绘了原始杆和由于位移原始节点位置而产生的变形杆 ![Image](../images/u1victorit.jpg)
    和 ![Image](../images/u2victorit.jpg)。
- en: '![Image](../images/15fig21.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig21.jpg)'
- en: '*Figure 15-21: A bar’s length increment*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 15-21: 杆的长度增量*'
- en: 'Assuming the original bar had a length of *l*[*o*] and that *l*[*f*] is the
    final length, the elongation of the bar is simply *Δl* = *l*[*f*] *– l*[*o*].
    The elongation value will be positive if the bar stretches and negative if it
    compresses. Note that this agrees with our stress sign convention: positive for
    tension and negative for compression. Enter the properties in [Listing 15-15](ch15.xhtml#ch15lis15).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 假设原始杆的长度为 *l*[*o*]，*l*[*f*] 是最终长度，则杆的伸长简单地为 *Δl* = *l*[*f*] – *l*[*o*]。如果杆被拉伸，则伸长值为正；如果杆被压缩，则为负。请注意，这与我们的应力符号约定一致：拉伸为正，压缩为负。输入
    [Listing 15-15](ch15.xhtml#ch15lis15) 中的属性。
- en: '[PRE22]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 15-15: Solution bar length*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-15: 解杆长度*'
- en: Now that we know the bar’s elongation, we can easily compute the strain and
    also the stress. Enter the strain and stress properties in the StrBarSolution
    class as in [Listing 15-16](ch15.xhtml#ch15lis16).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了杆的伸长，可以轻松地计算应变和应力。在 `StrBarSolution` 类中输入应变和应力属性，如 [Listing 15-16](ch15.xhtml#ch15lis16)
    中所示。
- en: '[PRE23]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 15-16: Bar strain and stress*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Finally! As you can see, the strain, given by [Equation 15.3](ch15.xhtml#ch15eqa03),
    is the quotient between the bar’s elongation and the original length. With the
    strain value we can obtain the stress by simple multiplication with the material’s
    Young’s modulus. This is Hooke’s law as formulated in [Equation 15.4](ch15.xhtml#ch15eqa04).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal Forces**'
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To compute the reaction forces, we’ll use the static equilibrium condition
    in each of the nodes: the net force in a node is always zero. In this sum of forces,
    every bar that is connected to the node exerts a force equal in value and opposite
    in direction to its internal force (this is illustrated in [Figure 15-23](ch15.xhtml#ch15fig23)).
    This internal force is computed as the bar’s stress times its cross section (see
    [Equation 15.2](ch15.xhtml#ch15eqa02)).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: We need both the magnitude and the direction of the internal force in each of
    the bar’s nodes, because, if you recall, for this two-force member to be in equilibrium,
    the forces in both ends need to have equal magnitude and opposite directions.
    Let’s see how we’d go about doing this.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Enter the code in [Listing 15-17](ch15.xhtml#ch15lis17).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 15-17: Bar internal force*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we first define the internal_force_value property, which yields
    the magnitude, positive or negative, of the internal force computed according
    to [Equation 15.2](ch15.xhtml#ch15eqa02).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the force_in_node method, which, given either the start or end node
    of the bar, returns the force vector in that node. The magnitude of the force
    vector is internal_force_value in both cases. It’s the direction that changes
    depending on the passed-in node.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Our sign convention is that tension forces are considered positive and compression
    forces negative. If we choose the direction of the internal force to be positive
    in each of the nodes, the force vector will always have the correct direction.
    This is because later we’ll give it a length of internal_force_value, which is
    negative for a compressing force, and, as you know, assigning a negative length
    to one of our Vector instances reverses its direction.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Look back at the code. If the passed-in node is the start node ➊, the force
    vector is created to go from the end node’s final position to the start’s. Then,
    the resulting vector is scaled according to internal_force_value.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, if the passed-in node is the end node ➋, the force vector is the
    opposite, but the scaling part remains the same.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if the passed-in node is neither of the two bar nodes, we raise an error.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '**Bar Has Node?**'
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re almost done with the bar solution class; we just need two more methods,
    and our class will be ready. The first one checks whether any node in the structure
    is one of the end nodes in the bar. We’ll use this method to draw the results.
    Enter the method in [Listing 15-18](ch15.xhtml#ch15lis18).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 15-18: Bar has node?*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need a method to generate the bar’s final geometry but with a scale
    applied to the displacements.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个方法来生成条形的最终几何图形，但要对位移应用缩放。
- en: '**Scaled Final Geometry**'
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**比例最终几何图形**'
- en: If you remember, we already implemented a method in the StrNodeSolution class
    that yields its position with a scale applied to the displacement. Let’s harness
    this implementation to build the segment representing the deformed bar’s geometry
    with a scale applied. Enter the code in [Listing 15-19](ch15.xhtml#ch15lis19).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们已经在StrNodeSolution类中实现了一个方法，它返回带有位移缩放的节点位置。让我们利用这个实现来构建表示变形条形几何图形的段，并对其应用缩放。输入[列表
    15-19](ch15.xhtml#ch15lis19)中的代码。
- en: '[PRE26]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 15-19: Bar scaled geometry*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-19: 条形比例几何图形*'
- en: The final_geometry_scaling_displacement method returns a segment whose end points
    are the bar nodes’ final positions with a scale applied to the displacement vector.
    This is the segment we’ll draw to the result plot to visualize how the original
    bar got displaced from its original position.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: final_geometry_scaling_displacement方法返回一个段，其端点是条形节点在应用位移缩放后的位置。我们将在结果图上绘制这个段，以可视化原始条形如何从其原始位置发生位移。
- en: Again, because the displacements are fairly small compared to the size of the
    structure itself, we’ll want to scale the node displacements so we can clearly
    see how the structure gets deformed in the solution diagram.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，因为与结构本身的大小相比，位移相对较小，所以我们希望对节点位移进行缩放，以便清楚地看到结构在解图中如何变形。
- en: '**The End Result**'
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**最终结果**'
- en: If you followed along, your StrBarSolution should look like [Listing 15-20](ch15.xhtml#ch15lis20).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟着操作，那么你的StrBarSolution应该像[列表 15-20](ch15.xhtml#ch15lis20)一样。
- en: '[PRE27]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 15-20: Solution bar class result*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-20: 解条形类结果*'
- en: 'There’s one last class we want to define: the structure solution.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个最后需要定义的类：结构解。
- en: '***The Structure Solution***'
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结构解***'
- en: Just as we had a class for the original structure model, we want a class representing
    the structure’s solution. The goal of this class is to put the solution nodes
    and bars together.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为原始结构模型定义了一个类一样，我们也想为结构的解定义一个类。这个类的目的是将解的节点和条形组合在一起。
- en: Create a new file in the *structures/solution* folder named *structure.py*.
    In the file, enter the basic definition for the class ([Listing 15-21](ch15.xhtml#ch15lis21)).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在*structures/solution*文件夹中创建一个名为*structure.py*的新文件。在文件中输入类的基本定义（[列表 15-21](ch15.xhtml#ch15lis21)）。
- en: '[PRE28]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 15-21: Structure solution class*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-21: 结构解类*'
- en: The StructureSolution class is initialized with the list of nodes and bars that
    make up the solution. This is similar to the original structure’s definition.
    But because we’re using this class to generate results—reports and diagrams—we’ll
    need some additional attributes.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: StructureSolution类通过节点和条形的列表初始化，这些节点和条形构成了解。这与原始结构的定义类似。但由于我们使用这个类来生成结果——报告和图表——所以我们需要一些额外的属性。
- en: '**Structure Rectangular Bounds**'
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**结构矩形边界**'
- en: When plotting the structural analysis results, we’ll want to know how much space
    we need to draw the complete structure. Knowing the rectangular bounds of the
    entire structure will allow us to compute the viewBox for the SVG plot later.
    Let’s compute these bounds and add in some margin as well (see [Figure 15-22](ch15.xhtml#ch15fig22))
    so that there’s some extra room for drawing things like the arrows that represent
    loads.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制结构分析结果时，我们需要知道绘制完整结构所需的空间。了解整个结构的矩形边界将帮助我们稍后计算SVG图形的viewBox。让我们先计算这些边界并添加一些边距（参见[图
    15-22](ch15.xhtml#ch15fig22)），这样可以为绘制如表示荷载的箭头等元素留出额外的空间。
- en: '![Image](../images/15fig22.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/15fig22.jpg)'
- en: '*Figure 15-22: Bounding a structure*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-22: 结构的边界*'
- en: In the class, enter the bounds_rect method ([Listing 15-22](ch15.xhtml#ch15lis22)).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中，输入bounds_rect方法（[列表 15-22](ch15.xhtml#ch15lis22)）。
- en: '[PRE29]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 15-22: Structure graphical bounds*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-22: 结构图形边界*'
- en: We first import the make_rect_containing_with_margin function. We implemented
    this function in [Part II](part02.xhtml#part02) of the book; it creates a Rect
    primitive containing all the passed-in points, along with some margin.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入make_rect_containing_with_margin函数。我们在本书的[第二部分](part02.xhtml#part02)中实现了这个函数，它创建一个包含所有传入点的矩形原始图形，并带有一些边距。
- en: The bounds_rect method we’ve written initializes the d_pos variable as a list
    with all the structure nodes’ displaced positions and passes it to the function,
    which generates the rectangle. Note that we’re using the scaled version of the
    displacements to make sure the rectangular bounds contain all the nodes in the
    positions where they’ll be drawn.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '**Node Reaction Forces**'
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Lastly, because the StructureSolution class has access to all the nodes and
    bars of the structure, it will be in charge of calculating the reaction forces
    for each of the nodes. The StrNodeSolution class couldn’t do this computation
    itself, as it doesn’t have access to the list of bars that meet in that node.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Now how do we go about computing the reaction force in a node? Let’s suppose
    we have a node like that in [Figure 15-23](ch15.xhtml#ch15fig23). Two bars, bar
    1 and bar 2, meet in this node and are subject to internal forces ![Image](../images/f1victorit.jpg)
    and ![Image](../images/f2victorit.jpg), respectively. An external load ![Image](../images/qvictorit.jpg)
    is applied to the node as well. This node is externally constrained, and ![Image](../images/Rvictor_caps.jpg)
    is the reaction force we’re after.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/15fig23.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-23: The reaction forces in a node*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: From these quantities, only ![Image](../images/Rvictor_caps.jpg) is unknown.
    The bar internal forces, ![Image](../images/f1victorit.jpg) and ![Image](../images/f2victorit.jpg),
    are computed using the force_in_node method we implemented in [Listing 15-17](ch15.xhtml#ch15lis17),
    and the external load ![Image](../images/qvictorit.jpg) is given as part of the
    problem’s statement.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Provided the node is under static equilibrium, the following condition must
    be held.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0424-01.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: You may have noticed that in this condition the bar forces appear with a negative
    sign. Those are the reaction forces the node receives from the bars’ forces, in
    accordance with Newton’s third law. If a bar is subject to a pair of forces that
    compress it, the bar pulls the node toward itself. On the other hand, if a bar
    tends to expand, it’ll push the nodes away from itself.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: We can easily isolate ![Image](../images/Rvictor_caps.jpg) from the previous
    equation,
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0424-02.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: or in a more generic fashion ([Equation 15.8](ch15.xhtml#ch15eqa08)),
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/15eqa08.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: where ![Image](../images/f00424-p1.jpg) is the sum of all bar forces, and ![Image](../images/f00424-p2.jpg)
    is the sum of all external loads applied to the node (the node’s net load).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement this in our class. Enter the code in [Listing 15-23](ch15.xhtml#ch15lis23).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 15-23: Node reaction force*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve defined the reaction_for_node method, which, given a node, computes its
    reaction force. Don’t forget that reaction forces exist only for those nodes that
    have external supports or constraints. That’s in fact the first thing we check
    ➊: if the node is not constrained, we return a zero vector (meaning no reaction
    force).'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The second step is to search for all bars in the structure that are linked to
    the passed-in node and get their internal forces in that given node ➋. We do this
    using a list comprehension that iterates through all the bars in the structure,
    filtering those that pass the bar.has_node(node) test and finally mapping each
    of them to its internal force in the given node. This is the ![Image](../images/f00424-p1.jpg)
    in [Equation 15.8](ch15.xhtml#ch15eqa08).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Next, we append the net external load to the forces list if the node is externally
    loaded ➌. Note that the net load received from the node appears with a negative
    sign in [Equation 15.8](ch15.xhtml#ch15eqa08), which is why we call the opposite
    method on it. Also note that we don’t need to sum these loads (as the ![Image](../images/f00424-p2.jpg)
    in [Equation 15.8](ch15.xhtml#ch15eqa08) suggests) because the StrNodeSolution
    class already does that for us and provides us with the net load.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, all the forces in the list are summed using the reduce function with
    the operator.add operator ➍.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '**The End Result**'
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For your reference, [Listing 15-24](ch15.xhtml#ch15lis24) shows the complete
    StructureSolution class implementation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 15-24: Structure solution class result*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to unit test this class to make sure we haven’t made any mistakes.
    Nevertheless, to test it, we need to learn about an advanced testing technique:
    mocking. We’ll be exploring this topic in the next chapter, so we’ll come back
    to this implementation.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We started this chapter reviewing some mechanics of materials topics such as
    the internal forces developed by elastic bodies as a response to being externally
    loaded. We introduced the concepts of stress and strain, both central to structural
    analysis. We were particularly interested in the axial stresses developed in prismatic
    bodies, as those are crucial in plane truss structures, the focus of this part
    of the book.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: We then took a look at plane trusses and their particularities and formulated
    the relation between forces and displacements on a bar using the concept of a
    stiffness matrix. As we’ll see in the next chapter, these matrices play a crucial
    role in the resolution of the structure.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we implemented the structure’s modeling classes: StrNode, StrBar, and
    Structure. We implemented the structure’s solution classes as well: StrNodeSolution,
    StrBarSolution, and StructureSolution. These two sets of classes represent the
    structure as originally designed and the structure solution, including the stress
    value for each bar and the displacements of every node. We’ll cover how we go
    from the original definition to the solution in the next chapter.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了结构的建模类：StrNode、StrBar 和 Structure。我们还实现了结构的求解类：StrNodeSolution、StrBarSolution
    和 StructureSolution。这两组类分别表示原始设计的结构和结构求解，包括每根杆件的应力值和每个节点的位移。我们将在下一章中介绍如何从原始定义到求解的过程。
