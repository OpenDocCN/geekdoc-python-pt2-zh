# 7

优先队列和堆

![](img/chapterart.png)

*优先队列*是一类数据结构，用于根据每个项目的得分顺序检索项目。与第四章中的栈和队列仅依赖于数据插入顺序不同，优先队列使用一个额外的信息来确定检索顺序——即项目的优先级。正如我们将看到的，这一新信息使得我们能够进一步适应数据，并且在许多其他有用的应用中，允许我们首先处理紧急请求。

例如，假设你所在的社区开了一家新的咖啡店，名为动态选择咖啡。你充满兴奋地走进店里，看到有 10 种你从未尝试过的咖啡豆。在尝试之前，你花了一个小时仔细分析每个新品牌的相对优缺点，依据他们那不太充足的菜单描述，最终列出了一份咖啡的排名清单。你从排名最前的咖啡中挑选了最有前景的一个品牌，购买后带回家享受体验。

第二天，你再次回到动态选择咖啡店，准备尝试你清单上的第二项，结果发现他们在菜单上又新增了两款咖啡。当你问咖啡师为什么做出这个改变时，他们指向店铺的标牌，上面解释道，动态选择咖啡提供的咖啡种类会不断扩展，他们的目标是最终提供超过一千种咖啡品种。你既感到兴奋又有些害怕。每天你都需要优先排列这些新咖啡，并将它们插入到你的清单中，以便知道接下来该尝试哪一款。

从优先级列表中检索项目的任务在计算机程序中经常出现：给定一个项目列表和相关的优先级，我们如何高效地按优先级顺序检索下一个项目？通常，我们需要在一个动态的环境中进行此类检索，因为新项目会不断出现。我们可能需要根据优先级选择处理哪个网络数据包，在拼写检查中根据常见的拼写错误提供最佳建议，或者在最佳优先搜索中选择下一个选项。在现实生活中，我们可能会使用自己的心理优先队列来决定接下来要执行的紧急任务、要观看的电影，或是在拥挤的急诊室中首先看哪个病人。一旦开始留意，优先级检索无处不在。

在这一章中，我们介绍了优先队列，它是一类用于从一组数据中检索按优先级排序的项目的数据结构，接着讨论了实现这一实用工具的最常见数据结构：堆。堆使得优先队列的核心操作变得极为高效。

## 优先队列

优先队列存储一组项，并允许用户轻松检索优先级最高的项。它们是动态的，允许插入和检索交替进行。我们需要能够从优先级任务列表中添加和移除项目。如果我们被迫使用固定数据结构，作者可能会花费一天的时间在他的静态列表上反复执行最高优先级任务“获取早晨咖啡”。如果在完成任务后无法移除该任务，它将一直停留在作者的列表顶部。虽然这样可能会使一天过得愉快，但不太可能会富有成效。

在最基本的形式中，优先队列支持一些主要操作：

+   添加一个项及其关联的优先级分数。

+   查找优先级最高的项（如果队列为空则返回 null）。

+   移除优先级最高的项（如果队列为空则返回 null）。

我们还可以添加其他有用的功能，允许我们检查优先队列是否为空，或者返回当前存储的项数。

我们根据手头的问题设置项的优先级。在某些情况下，优先级值可能很明显，或者由算法决定。例如，在处理网络请求时，每个数据包可能附带一个明确的优先级，或者我们可能选择先处理最旧的请求。然而，决定优先处理什么并不是一件简单的事情。当决定优先尝试哪种品牌的咖啡时，我们可能想根据价格、可得性或咖啡因含量来设定优先级——这取决于我们打算如何使用我们的优先队列。

使用像排序链表或排序数组这样的原始数据结构实现优先队列是可行的，但并不理想，我们会根据优先级将新项添加到列表中。图 7-1 展示了将值 21 添加到排序链表中的示例。

![排序链表在添加第八个元素后，元素按递减顺序排列。链表头部的值为 50，尾部的值为 9。值 21 被插入在值 28 和值 15 之间。](img/f07001.png)

图 7-1：将元素（21）添加到表示优先队列的排序链表中

排序链表将最高优先级的项放在列表的前面，便于查找。实际上，在这种情况下，无论优先队列的长度如何，查找都需要常数时间——我们只需查看第一个元素。不幸的是，添加新元素可能会很昂贵。每次添加新项时，我们可能需要遍历整个列表，这样的操作需要的时间与优先队列的长度成正比。

作者使用了一个现实世界的排序列表方法来整理他的冰箱，按照从前到后的顺序存放物品，顺序依据的是过期日期的升序。最接近过期的物品总是优先级最高的。获取正确的物品很容易——只需拿起最前面的那一件。这个方案特别适用于存放牛奶或咖啡用的奶油：没有人愿意在早晨朦胧的时刻花时间查看过期日期。然而，将新物品插入到旧物品后面可能需要时间，并且需要进行麻烦的移位操作。

类似地，我们也可以将优先队列维护在一个 *未排序* 的链表或数组中。新添加的元素非常简单——只需将元素附加到列表的末尾，如图 7-2 所示。

![未排序的数组，在添加第八个元素之前和之后的对比。值 21 在值 39 后添加到未排序数组的末尾。](img/f07002.png)

图 7-2：将一个元素（21）添加到表示优先队列的未排序数组中

不幸的是，我们现在在查找下一个元素时需要付出较高的代价。我们必须扫描整个列表，以确定哪个元素的优先级最高。如果我们要移除它，还需要将所有元素移位以填补空缺。这种方法就像扫描作者冰箱中的所有食物，找出哪个快要过期。对于冰箱里只有几盒牛奶来说，这可能能奏效，但想象一下在一个大型超市中挑选每一件食品或饮料的开销。

将优先队列实现为排序列表，可能比使用未排序列表更有效，或者反之，这取决于我们计划如何使用优先队列。如果添加操作比查找操作更常见，我们倾向于使用未排序列表。如果查找操作更常见，我们应该承担保持元素排序的代价。在冰箱的例子中，查找操作要更常见——我们使用一盒牛奶的频率远高于购买新的一盒，因此保持牛奶的排序是值得的。挑战出现在添加操作和查找操作都很常见的情况；优先执行某一操作将导致整体效率低下，因此我们需要一种平衡两者开销的方法。一个巧妙的数据结构，堆，帮助我们解决了这个问题。

## 最大堆

*最大堆* 是一种二叉树的变体，它在节点和其子节点之间保持特殊的顺序关系。具体来说，最大堆根据 *最大堆属性* 存储元素，该属性规定树中任意节点的值都大于或等于其子节点的值。为了简便起见，我们在本章接下来的部分中会常常使用更通用的术语 *堆* 和 *堆属性* 来指代最大堆和最大堆属性。

图 7-3 展示了一个按照最大堆属性组织的二叉树的表示。

![堆的二叉树以最大元素（99）为根节点，根节点有两个子节点 67 和 97。对于任何节点，左子节点和右子节点的值都小于或等于该节点的值。](img/f07003.png)

图 7-3：堆的二叉树表示

除了子节点的优先级低于父节点之外，左子节点和右子节点之间没有特别的偏好或排序。为了进行比较，可以想象一个精英咖啡爱好者的指导计划——“咖啡知识提升协会”。每个会员（节点）同意指导最多两个其他咖啡爱好者（子节点）。唯一的条件是每个被指导者的咖啡知识不能超过导师——否则，指导关系就毫无意义。

计算机科学家 J. W. J. Williams 最初发明了堆作为新排序算法——堆排序的一个组成部分，我们将在本章稍后讨论它。然而，他意识到堆是一种对于其他任务也非常有用的数据结构。最大堆的简单结构使其能够高效地支持优先队列所需的操作：（1）允许用户高效查找最大元素，（2）删除最大元素，以及（3）添加任意元素。

堆通常被形象化为树，但通常为了效率起见使用数组来实现。在本章中，我们并行展示这两种表示方式，以帮助读者在它们之间建立心理联系。然而，使用数组进行实现并不是必需的。

在基于数组的实现中，数组中的每个元素对应树中的一个节点，根节点位于索引 1（我们跳过索引 0，以便与堆的常见约定保持一致）。子节点的索引是相对于父节点的索引定义的，因此位于索引*i*的节点，其子节点位于索引 2*i*和 2*i* + 1。例如，位于索引 2 的节点，其子节点位于索引 2 × 2 = 4 和索引 2 × 2 + 1 = 5，如图 7-4 所示。

![堆同时作为数组和树表示，箭头指示每个节点在数组中的位置。根节点 98 对应数组中的第一个元素，节点的两个子节点 95 和 50 分别是数组中的第二和第三个元素。](img/f07004.png)

图 7-4：堆的位置对应索引位置。

类似地，我们计算一个节点父节点的索引为`Floor(i/2)`。这种索引方式使得算法可以轻松地根据父节点的索引计算子节点的索引，反之亦然。

根节点总是对应于最大堆中的最大值。由于我们将根节点存储在数组中的固定位置（索引=1），因此我们可以始终在常数时间内找到这个最大值。它只是一个数组查找操作。因此，数据本身的布局就解决了优先队列所需的一个操作。

由于我们将在优先队列中添加和移除任意元素，为了避免不断地调整数组大小，我们希望预先分配一个足够大的数组，以容纳我们预期添加的元素数量。还记得第三章中提到的，动态调整数组大小可能非常昂贵，需要我们创建一个新数组并复制值，这样会浪费堆的宝贵效率。相反，我们可以最初分配一个较大的数组，跟踪数组中最后一个填充元素的索引，并将该索引称为数组的虚拟末尾。这样，我们只需通过更新最后一个元素的索引，就可以轻松地追加新元素。

```py
Heap {
    Array: array
    Integer: array_size
    Integer: last_index
}
```

当然，整体分配的代价是可能未使用的内存块，如果我们的堆没有像预期那样增长。

使用数组表示基于树的数据结构本身就是一个有趣的步骤。我们可以使用紧凑数组和数学映射来表示堆，而不依赖指针，从而使得堆的存储占用更少的内存。通过维护一个从节点索引到其子节点的映射，我们可以在没有指针的情况下重新创建一个基于树的数据结构。正如我们下面所看到的，基于数组的表示对于堆是可行的，因为该数据结构始终保持一个几乎完整和平衡的树。这导致了一个没有空隙的紧凑数组。虽然我们也可以使用相同的数组表示其他树，如二叉搜索树，但这些数据结构通常会有空隙，并且需要非常大的（可能大部分是空的）数组来存储具有深度分支的树。

### 向堆中添加元素

当向堆中添加新元素时，我们必须确保结构保持堆的属性。就像你不会让一位装饰性的将军向一名新任中尉报告一样，你也不会把一个优先级高的堆节点放在一个优先级低的节点下。我们必须将元素添加到堆的树结构中，确保所有在新节点下的元素的优先级小于或等于新节点的优先级。同样，新添加的节点上方的所有节点优先级应该大于或等于新节点的优先级。

堆的数组实现的部分巧妙之处在于，它在以紧凑数组存储节点的同时，保持了这一属性。在之前的章节中，将节点添加到数组的中间是很昂贵的，需要我们将后面的条目向下移动。幸运的是，我们不需要每次添加新元素到堆时支付这个线性成本。相反，我们通过首先打破堆的属性，然后沿着树的单个分支交换元素来恢复堆的属性。

换句话说，为了将新元素添加到堆中，我们将它添加到树底层的第一个空位。如果这个新值大于其父节点的值，我们就将它冒泡到树的上层，直到它小于或等于其父节点，恢复堆的性质。堆本身的结构使我们能够高效地完成这一操作。在堆的数组实现中，这对应于将新元素添加到数组的末尾并将其向前交换。

请参见图 7-5，它展示了堆在每一步中作为数组和树的结构。图 7-5(a)显示了新元素添加之前的堆。在图 7-5(b)中，我们将新元素 85 添加到数组的末尾，实际上将它插入到树的底部。在图 7-5(c)中的第一次比较后，我们将新元素与其父节点交换，因为 85 大于 50。交换操作如图 7-5(d)所示。在第二次比较中，如图 7-5(e)所示，发现新节点已经处于正确的位置：98 大于 85，因此不需要将新节点与其父节点再次交换。图 7-5(f)显示了添加完成后的堆。

![我们从图 7-4 中的数组开始。节点 85 被添加到数组的末尾，然后被冒泡到正确的位置。我们首先将 85 与它的父节点 50 进行比较，并交换它们。在下一步，我们将 85 与它的新父节点 98 进行比较，并保持顺序。](img/f07005.png)

图 7-5：向堆中添加元素（85）

实现这个加法的代码使用一个单一的`WHILE`循环来逐层向上遍历堆，直到它到达根节点或找到一个比新节点值大或相等的父节点：

```py
HeapInsert(Heap: heap, Type: value):
  ❶ IF heap.last_index == heap.array_size - 1:
        Increase Heap size.

 ❷ heap.last_index = heap.last_index + 1
    heap.array[heap.last_index] = value

    # Swap the new node up the heap.
  ❸ Integer: current = heap.last_index
    Integer: parent = Floor(current / 2)
  ❹ WHILE parent >= 1 AND (heap.array[parent] < 
                           heap.array[current]):
      ❺ Type: temp = heap.array[parent]
        heap.array[parent] = heap.array[current]
        heap.array[current] = temp
        current = parent
        parent = Floor(current / 2)
```

由于我们使用数组来存储堆，代码首先检查数组中是否还有足够的空间来添加新元素❶。如果没有，它会增加堆的大小，可能会采用第三章中描述的数组扩展技术。接下来，代码将新元素附加到数组的末尾，并更新最后一个元素的位置❷。`WHILE`循环从刚刚添加的元素❸开始，通过将当前值与其父节点的值进行比较❹，逐层向上遍历堆，并在必要时进行交换❺。循环在以下两种情况之一终止：我们要么到达堆的顶部（`parent == 0`），要么找到了一个大于或等于子节点的父节点。

我们可以将这个过程比作一个设计奇特但高效的包裹分发中心，如图 7-6 所示。员工们使用堆的性质，将包裹整齐地排列在地面上：在最前面的排里，有一个优先级最高的包裹，它是下一个要发货的包裹。其后有两个优先级较低的包裹。再往后，每个包裹后面都有两个包裹（这一排总共有四个包裹），确保每对包裹的优先级都小于或等于它们前面的包裹。随着每一新排的增加，包裹的数量翻倍，排列从仓库前部向后扩展。每个包裹最多有两个优先级较低或相同的包裹坐在它后面，且最多只有一个优先级更高或相同的包裹在它前面。仓库地面上画有矩形框，帮助指示每一排可能放置包裹的位置。

![展示仓库地面上排列的包裹图示，第一排一个包裹，第二排两个包裹，第三排四个包裹，第四排八个包裹。第五排是最后一排，未完全填满。](img/f07006.png)

图 7-6：作为堆结构组织的仓库地面

新包裹从仓库后部搬进来。每个送货员都会嘟囔着一些关于奇怪排序方案的话，松了口气，因为至少他们不需要将包裹搬到最前面，然后将包裹放到最前面空闲的位置，迅速离开。随后，仓库员工迅速开始行动，将新包裹的优先级与其前面紧挨着的包裹进行比较（忽略该排其他的包裹）。如果他们发现优先级倒置，就交换这两个包裹。否则，他们将包裹保持在原地。这一过程会持续进行，直到新包裹占据了合适的优先级位置，且其前面的包裹优先级更高或相同。由于包裹很重并且分布较广，员工们通过在每排最多只进行一次比较和交换来减少工作量。他们从不在同一排内重新排列包裹。毕竟，没人愿意不必要地移动箱子。

直观地看，我们可以发现堆的添加操作并不特别昂贵。在最坏的情况下，我们可能需要将新节点交换到树的根部，但这仅意味着交换数组中一小部分的值。按照设计，堆是*平衡*二叉树：我们在插入节点到下一级之前，先填满树的完整一层。由于完全二叉树中每一层的节点数是前一层的两倍，因此添加操作在最坏情况下需要 log2 次交换。这比维持一个已排序列表所需的最坏情况 *N* 次交换要好得多。

### 从堆中移除最高优先级的元素

在优先队列中查找并移除最高优先级元素是一个核心操作，它允许我们按优先级顺序处理项目。也许我们在存储一系列待处理的网络请求，并希望处理最高优先级的请求。或者我们可能在运营一个急诊室，想要优先处理最紧急的病人。在这两种情况下，我们都希望从优先队列中移除该元素，以便接着提取下一个最高优先级的元素。

为了移除最高优先级的节点，我们必须先打破，然后恢复堆的性质。请参考图 7-7 中的示例。我们首先通过与树中最低层的最后一个节点交换位置来移除最高优先级的节点（图 7-7(b)），有效地将最后一个元素作为新的根节点。然而，这种将新根节点“晋升”到最高位置的操作几乎注定会经不起考验。在数组实现中，这相当于交换数组中的第一个元素和最后一个元素。这一交换填补了删除第一个元素后，数组前端产生的空缺，从而保持了数组的紧凑性。

接下来，原本的最大值 98（目前是树中的最后一个元素）按照图 7-7(c)所示被删除。我们现在已经删除了正确的节点，但在此过程中可能破坏了堆的性质。我们可能将一个低优先级的包裹移动到了仓库的最前面。

![节点 98 通过先与最后一个元素（23）交换位置被移除。新根节点通过与其两个子节点中的较大者交换，逐步向下沉降。在第一步中，节点 23 与 95 和 50 进行比较，然后与 95 交换位置。](img/f07007.png)

图 7-7：从堆中移除最高优先级元素

为了修复堆的性质，我们从新的（错误的）根节点 23 开始，沿着树向下走，在每一层恢复堆的性质。错误放置的包裹被一层一层地移动到仓库的后面，正好与新增包裹一层一层向前移动相反。诚然，这一遍历过程没有将紧急包裹推到队首那样令人兴奋，但这是为了堆结构的完整性。在每一层，我们将正在移动的包裹的优先级与其两个子节点的优先级进行比较（即下一行中的两个包裹，图 7-7(d)）。如果它比任何一个子节点都小，我们就将新的根节点向后移动，通过与其两个子节点中较大的那个交换位置来恢复堆的性质（图 7-7(e)）。这表示包裹的更高优先级的继任者向前移动，取代它的位置。

向下交换在没有更大的子节点时终止。图 7-7(f)展示了当前节点处于正确位置时的比较。堆属性已恢复，所有节点都满足它们相对的位置。图 7-7(g)展示了移除完成后的最终堆。

在固定根节点的位置时，我们沿着树向下遍历，检查并恢复仅在我们进行交换的后代分支上的堆属性。无需检查另一分支，因为我们没有做任何破坏堆属性的操作。再次说明，这意味着在最坏的情况下，我们需要进行 log2 次交换。

这是移除最大元素的代码：

```py
HeapRemoveMax(Heap: heap):
  ❶ IF heap.last_index == 0:
        return null

    # Swap out the root for the last element and shrink heap.  
  ❷ Type: result = heap.array[1]
    heap.array[1] = heap.array[heap.last_index]
    heap.array[heap.last_index] = null
    heap.last_index = heap.last_index - 1

    # Bubble the new root down.
    Integer: i = 1
  ❸ WHILE i <= heap.last_index:
        Integer: swap = i
      ❹ IF 2*i <= heap.last_index AND (heap.array[swap] < 
                                       heap.array[2*i]):
            swap = 2*i
      ❺ IF 2*i+1 <= heap.last_index AND (heap.array[swap] <
                                         heap.array[2*i+1]):
            swap = 2*i+1

      ❻ IF i != swap:
            Type: temp = heap.array[i]
            heap.array[i] = heap.array[swap]
            heap.array[swap] = temp
            i = swap
        ELSE:
            break
    return result
```

这段代码首先检查堆是否为空❶。如果为空，则没有元素可返回。然后，代码将第一个元素（`index == 1`）与最后一个元素（`index == heap.last_index`）交换，破坏堆属性以准备移除最大元素❷。接着，代码使用`WHILE`循环，通过一系列比较向下遍历堆，修复堆属性❸。在每次迭代中，代码将当前值与两个子节点进行比较，必要时与较大的子节点交换❻。我们需要添加额外的检查❹❺，以确保代码仅将当前值与现有子节点进行比较。我们不希望它尝试与数组的最后有效索引之后的条目进行比较。当遍历到底部或没有发生交换时（通过`break`语句），循环终止。

### 存储辅助信息

很多时候，我们需要堆为每个条目存储额外的信息。例如，在我们的任务列表中，我们需要存储关于任务的信息，而不仅仅是它们的优先级。如果我们不知道任务的具体内容，仅仅知道优先级=99 的任务下一个需要做，也没有帮助。我们还不如手动扫描原始列表。

扩展堆以存储复合数据结构或对象（如`TaskRecord`）很简单：

```py
TaskRecord {
    Float: Priority
    String: TaskName
    String: Instructions
    String: PersonWhoWillYellIfThisIsNotDone
    Boolean: Completed
}
```

我们修改了之前的代码，以根据这个复合记录的优先级字段进行比较。我们可以通过直接修改代码来实现这一点（例如在`HeapInsert`函数中）：

```py
 WHILE parent >= 1 AND (heap.array[parent].priority < 
                             heap.array[current].priority):
```

然而，这要求我们可能需要将堆实现专门化为特定的复合数据结构。一个更清晰的方法是添加一个特定于复合数据结构的辅助函数，例如：

```py
IsLessThan(Type: a, Type: b):
  return a.priority < b.priority
```

我们会在`HeapInsert`代码中使用这个函数，而不是使用数学的小于号：

```py
 WHILE parent >= 1 AND IsLessThan(heap.array[parent], 
                                     heap.array[current]):
```

同样，我们将修改`HeapRemoveMax`函数中的比较，使其使用辅助函数。

```py
 IF 2*i <= heap.last_index AND IsLessThan(heap.array[swap],
                                                 heap.array[2*i]):
            swap = 2*i
        IF 2*i+1 <= heap.last_index AND IsLessThan(heap.array[swap],
                                                   heap.array[2*i+1]):
            swap = 2*i+1
```

这些小的变化使我们能够从复合数据结构构建堆。只要我们能够定义一个`IsLessThan`函数来排序元素，就可以为它们构建一个高效的优先队列。

## 更新优先级

一些使用场景可能要求动态行为的另一种模式：允许算法更新优先队列中元素的优先级。考虑一个书店数据库，通过每本书被顾客请求的数量来确定优先补货的书籍。系统首先构建一个堆，并利用它来确定下一步要订购的书籍。然而，在一篇流行的博客文章指出数据结构在计算思维中的重要性之后，书店突然看到顾客请求有关数据结构的书籍的数量激增。它的优先队列必须能够应对这一突如其来的变化。

为了满足这一需求，我们采用与添加和移除时相同的方法。当我们更改某个元素的值时，我们需要检查是提高优先级还是降低优先级。如果我们是在增加元素的值，则需要将该元素“冒泡”到最大堆中，以恢复堆的性质。同样地，如果我们是在降低元素的值，则让它“下沉”到最大堆中，直到到达正确的位置。

```py
UpdateValue(Heap: heap, Integer: index, Float: value):
    Type: old_value = heap.array[index]
    heap.array[index] = value

    IF old_value < value:
        Bubble the element up the heap using the
        procedure from inserting new elements 
        (swapping with parent).
    ELSE:
        Drop the element down the heap using the
        procedure from removing the max element 
        (swapping with the larger child).
```

我们甚至可以将代码提取出来，使得“冒泡”或“下沉”的操作能够复用，以便在更新时与添加或移除最大值时使用相同的代码。

那么，如何找到我们要更新的元素呢？如前所述，堆并不是为了查找特定元素而优化的。如果我们除了元素的值外对其没有其他信息，我们可能需要搜索数组的相当一部分才能找到它。通常，我们可以通过使用一个辅助数据结构，例如哈希表（第十章讨论），来解决这个问题，将元素的键映射到堆中的元素。在本节的示例中，我们假设程序已经有该元素的当前索引。

## 最小堆

到目前为止，我们一直关注的是最大堆，它利用树中任何节点的值都大于（或等于）其子节点的值这一特性。*最小堆*是堆的一种变体，便于找到值最小的元素。在最小堆中，树的根节点是最小值，从而使我们能够轻松找到最低得分的元素。例如，我们可能不仅仅按照优先级对网络数据包进行排序，而是希望按到达时间进行排序，先处理到达时间较早的包，再处理较晚接收的包。更重要的是，如果我们咖啡架上的空间用完了，我们就需要移除我们最不喜欢的品牌。在一番内心深处的痛苦辩论后，我们决定不通过丢弃一架盘子或碗来扩展咖啡存储空间，而是选择丢掉排名最低的咖啡。我们查阅每种咖啡的可享受评分，并选择其中分数最低的。

理论上，我们可以通过仅仅将值取反来继续使用最大堆。然而，一个更清晰的策略是对堆属性做一个小的调整，直接解决问题。*最小堆属性*是树中任何节点的值都小于（或等于）其子节点的值。一个最小堆的示例如图 7-8 所示。当我们插入新元素时，得分最低的元素会上浮到层级结构的顶部。同样，我们总是提取并返回得分最低的元素。

![一个最小堆的示意图，既表示为数组，也表示为树形结构，箭头指示每个节点在数组中的位置。根节点 10 对应数组中的第一个元素。该节点的两个子节点 23 和 17 分别是数组中的第二和第三个元素。](img/f07008.png)

图 7-8：最小堆的位置对应于索引位置。

当然，最小堆中添加和删除元素的算法需要相应地进行修改。对于插入，我们将`WHILE`循环中的比较函数更改为检查父节点值是否大于当前值：

```py
MinHeapInsert(MinHeap: heap, Type: value):
    IF heap.last_index == heap.array_size - 1:
 Increase Heap size.

    heap.last_index = heap.last_index + 1
    heap.array[heap.last_index] = value

    # Swap the new node up the heap.
    Integer: current = heap.last_index
    Integer: parent = Floor(current / 2)
  ❶ WHILE parent >= 1 AND (heap.array[parent] > 
                           heap.array[current]):
        Type: temp = heap.array[parent]
        heap.array[parent] = heap.array[current]
        heap.array[current] = temp
        current = parent
        parent = Floor(current / 2)
```

大部分代码与插入最大堆时的代码相同。唯一的变化是，在比较节点与其父节点时，将`<`替换为`>` ❶。

我们在删除操作中也做了类似的更改：

```py
MinHeapRemoveMin(Heap: heap):
    IF heap.last_index == 0:
        return null

    # Swap out the root for the last element and shrink heap.  
    Type: result = heap.array[1]
    heap.array[1] = heap.array[heap.last_index]
    heap.array[heap.last_index] = null
    heap.last_index = heap.last_index - 1

    # Bubble the new root down.
    Integer: i = 1
    WHILE i <= heap.last_index:
        Integer: swap = i
      ❶ IF 2*i <= heap.last_index AND (heap.array[swap] > 
                                       heap.array[2*i]):
            swap = 2*i
      ❷ IF 2*i+1 <= heap.last_index AND (heap.array[swap] >
                                         heap.array[2*i+1]):
            swap = 2*i+1

        IF i != swap:
            Type: temp = heap.array[i]
            heap.array[i] = heap.array[swap]
            heap.array[swap] = temp
            i = swap
        ELSE:
            break
    return result
```

在这里，唯一的变化是，在确定是否交换节点时，将`<`替换为`>` ❶ ❷。

## 堆排序

堆是一种强大的数据结构，广泛应用于计算机科学任务，不仅限于实现优先队列和高效地返回优先级列表中的下一个项。另一种有趣的视角是，通过堆以及数据结构的一般视角，看到它们所启用的新算法。J. W. J. Williams 最初在设计一种新的排序数组算法时提出了堆：*堆排序*。

正如其名称所示，堆排序是一种使用堆数据结构对项列表进行排序的算法。输入是一个未排序的数组。输出是一个包含相同元素的数组，但按照*递减*的排序顺序（对于最大堆）。堆排序的核心包括两个阶段：

1.  从所有项构建一个最大堆

1.  从堆中提取所有项，按递减排序顺序，并将它们存储到数组中

就这么简单。

这是堆排序的代码：

```py
Heapsort(Array: unsorted):
    Integer: N = length(unsorted)
    Heap: tmp_heap = Heap of size N
    Array: result = array of size N      

    Integer: j = 0
  ❶ WHILE j < N:
        HeapInsert(tmp_heap, unsorted[j])
        j = j + 1

    j = 0
  ❷ WHILE j < N:
        result[j] = HeapRemoveMax(tmp_heap)
        j = j + 1
    return result
```

这段代码包含两个`WHILE`循环。第一个循环将每个项插入到临时堆中 ❶。第二个循环使用`HeapRemoveMax`函数移除最大元素，并将其添加到数组中的下一个位置 ❷。另外，我们可以实现堆排序，通过使用最小堆和`HeapRemoveMin`以*递增*的排序顺序生成答案。

假设我们想要按递减顺序排序以下数组：`[46, 35, 9, 28, 61, 8, 38, 40]`。我们首先将这些值逐个插入到堆中。图 7-9 展示了插入后的最终数组排列（以及相应的树形表示）。请记住，我们总是从数组的末尾开始插入新元素，然后将它们交换到前面，直到堆的性质被恢复。在图 7-9 中，箭头表示新元素通过数组的路径，直到它达到最终位置。树形表示也有展示，阴影表示已被修改的节点。

![一张插图展示了堆排序第一阶段中的八次插入过程，包括数组和树的表示。46、35、9 和 28 在没有交换的情况下被插入。当 61 插入到树的顶部和数组的前端时，它首先与 35 交换位置，然后与 46 交换，成为新的根节点。](img/f07009.png)

图 7-9：堆排序的第一阶段，其中未排序的数组中的元素一个一个地被添加到堆中

我们通过单次插入的最坏情况运行时间来界定创建堆的运行时间。正如我们在本章早些时候看到的那样，在最坏情况下，将一个新元素插入到包含*N*个元素的堆中，所需时间与 log2 成比例。因此，构建一个包含*N*个元素的堆时，最坏情况的运行时间是与*N*log2 成比例的。

现在我们已经构建了堆，接下来进入第二阶段，逐个提取每个元素，如图 7-10 所示。

![一张插图展示了堆排序第二阶段中每次移除元素的过程，包括数组和树的表示。在第一次移除中，节点 61 被移除，46 被交换到它的位置，40 被交换到 46 原来的位置，28 被提升到 40 原来的位置。](img/f07010.png)

图 7-10：堆排序的第二阶段，其中最大元素在每次迭代中被重复从堆中移除

我们按照优先级递减的顺序逐个从堆中移除元素。这就是产生递减排序顺序的原因。在每一步中，根节点被提取出来，堆中的最后一个元素被交换到根节点的位置，然后新的根节点下沉，直到恢复堆的性质。图中展示了每次迭代结束时数组（以及相应的树形表示）的状态。图中的箭头和阴影节点表示过度提升的节点在堆中的下降过程。当我们提取元素时，会直接将它们添加到存储结果的数组中。一旦堆被清空，我们就丢弃它，它已经完成了它的任务。

与插入操作类似，我们可以将最坏情况下的运行时间界定为与*N*log2 成正比。每次提取最多需要 log2 的时间来恢复堆的性质，而我们需要提取所有*N*个元素以得到排序后的列表。因此，堆排序算法的总最坏情况下的运行时间与*N*log2 成正比。

## 为什么这很重要

堆是一种简单的二叉树变种，它允许一组不同的高效计算操作。通过将二叉查找树的性质改为堆的性质，我们可以改变数据结构的行为，并支持一组不同的操作。

新元素的添加和最大元素的删除都要求我们最多遍历树的顶部和底部之间的路径。由于我们可以通过仅在底部添加一层新节点来大致翻倍堆中的节点数量，甚至大型堆也能保证操作迅速。以这种方式翻倍节点数量只会使插入和删除操作增加一个额外的迭代！此外，这两个操作还保证了树保持平衡，从而使得未来的操作保持高效。

然而，总是存在权衡：从二叉查找树的性质转变为堆的性质后，我们将无法高效地查找特定的值。优化一种操作集常常会妨碍我们优化其他操作。我们需要仔细考虑如何使用数据，并相应地设计其结构。
