<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header0401" class="chapter" epub:type="chapter" id="ch04" role="doc-chapter">
<header id="header0401">
<h1 class="cn"><span aria-label=" Page 58. " class="page" epub:type="pagebreak" id="p58" role="doc-pagebreak"/><span aria-label=" Page 59. " class="page" epub:type="pagebreak" id="p59" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch04">4</a></h1>
<h1 class="ct">Musical Overtones with Karplus-Strong</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">One of the main characteristics of any musical sound is its pitch, or <span class="idx" data-term="frequency"/><span class="idx" data-level1="frequency" data-term="sound"/><i>frequency</i>. This is the sound’s number of vibrations per second in hertz (Hz). For example, the fourth string of an acoustic guitar produces a D note with a frequency of 146.83 Hz. You can approximate this sound by creating a <span class="idx" data-term="sine wave"/>sine wave with a frequency of 146.83 Hz on a computer, as shown in <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#fig4-1">Figure 4-1</a>.</p>
<p>Unfortunately, if you play this sine wave on your computer, it won’t sound anything like a guitar. Nor will it sound like a piano, or any other real-world musical instrument for that matter. What makes a computer sound so different from a musical instrument when playing the same note?</p>
<figure class="figure" id="fig4-1">
<p class="fig"><span aria-label=" Page 60. " class="page" epub:type="pagebreak" id="p60" role="doc-pagebreak"/><img alt="" height="427" src="images/nsp-venkitachalam503045-f04001.jpg" style="width:95%; height:auto;" width="878"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 4-1:</span> A sine wave at 146.83 Hz</p>
</figcaption>
</figure>
<p>When you pluck a string on a <span class="idx" data-term="guitar"/>guitar, the instrument produces a mix of frequencies with varying intensity. The sound is most intense when the note is first struck, and the intensity dies off over time. In the case of plucking a guitar’s D string, the dominant frequency you hear, called the <span class="idx" data-level1="fundamental" data-term="frequency"/><span class="idx" data-level1="fundamental frequency" data-term="sound"/><i>fundamental frequency</i>, is 146.83 Hz, but the sound also contains certain multiples of that frequency called <span class="idx" data-term="overtones"/><span class="idx" data-level1="overtones" data-term="sound"/><i>overtones</i>. In fact, the sound of any note on any instrument is composed of a fundamental frequency and overtones, and it’s the combination of these different frequencies at different intensities that makes a guitar sound like a guitar, a piano sound like a piano, and so on. By contrast, a pure sine wave generated by a computer contains only a fundamental frequency, and no overtones.</p>
<p>You can see the evidence of overtones in <i>spectral plots</i>, like the one in <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#fig4-2">Figure 4-2</a> representing the D string of a guitar. A spectral plot shows all the frequencies present in a sound at a particular moment in time, as well as the intensity of those frequencies. Notice that there are many different peaks in the spectral plot shown in the figure, telling us that there are many frequencies present in the sound of the guitar’s D string being plucked. Near the far left of the plot, the highest peak represents the fundamental frequency. The other peaks, representing the overtones, are less intense, but they still contribute to the quality of the sound.</p>
<figure class="figure" id="fig4-2">
<p class="fig"><span aria-label=" Page 61. " class="page" epub:type="pagebreak" id="p61" role="doc-pagebreak"/><img alt="" height="665" src="images/nsp-venkitachalam503045-f04002.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 4-2:</span> A spectral plot of the note D3 played on a guitar</p>
</figcaption>
</figure>
<p>As you can see, to simulate the sound of a plucked string instrument on the computer, you need to be able to generate both the fundamental frequency and the overtones. The trick is to use the Karplus-Strong algorithm. In this project, you’ll generate five guitar-like notes of a musical scale (a series of related notes) using the Karplus-Strong algorithm. You’ll visualize the algorithm used to generate these notes and save the sounds as WAV files. You’ll also create a way to play them at random and learn how to do the following:</p>
<ul style="list-style-type:none">
<li class="blf">• Implement a ring buffer using the Python <code>deque</code> class.</li>
<li class="bl">• Use <code>numpy</code> arrays.</li>
<li class="bl">• Play WAV files using <code>pyaudio</code>.</li>
<li class="bl">• Plot a graph using <code>matplotlib</code>.</li>
<li class="bll">• Play the pentatonic musical scale.</li>
</ul>
<section>
<h2 class="ah" id="ah0601"><span aria-label=" Page 62. " class="page" epub:type="pagebreak" id="p62" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0601">How It Works</a></h2>
<p class="paft">Imagine a string tied down at both ends, like a string on a guitar. When you pluck this string, it vibrates for a while, making a sound, and then settles back down to its resting position. At any given point in time while the string is vibrating, different parts of the string will be at different displacements from their resting position. These displacements can also be thought of as amplitudes of the sound wave produced by the vibrating string. The <span class="idx" data-term="Karplus-Strong algorithm"/>Karplus-Strong algorithm is a series of steps for generating and updating a series of these displacement or amplitude values to represent the motion of a wave along a plucked string. Play back those values as a WAV file and you get a pretty convincing simulation of a plucked string sound.</p>
<p>The Karplus-Strong algorithm stores displacement values in a <i>ring buffer</i> (also known as a <i>circular buffer</i>), a fixed-length buffer (just an array of values) that wraps around itself. In other words, when you reach the end of the buffer, the next element you access will be the first element in the buffer. (See <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#bh0604">“Implementing the Ring Buffer with deque”</a> on <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#p66">page 66</a> for more about ring buffers.)</p>
<p>The length (<i>N</i>) of the ring buffer is related to the <span class="idx" data-level1="fundamental" data-term="frequency"/>fundamental frequency of the note you want to simulate according to the equation <i>N</i> = <i>S</i>/<i>f</i>, where <i>S</i> is the sampling rate (more on this later) and <i>f</i> is the frequency. At the start of the simulation, the buffer is filled with random values in the range [−0.5, 0.5], which you might think of as representing the random displacement of a string when it’s first plucked. As the simulation progresses, the values are updated according to the steps of the Karplus-Strong algorithm, which we’ll outline next.</p>
<p>In addition to the ring buffer, you’ll use a <i>samples buffer</i> to store the intensity of the sound at any particular time. This buffer represents the final sound data, and it’s built up based on the values in the ring buffer. The length of the samples buffer and the sampling rate determine the length of the sound clip.</p>
<section>
<h3 class="bh" id="bh0601"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0601">The Simulation</a></h3>
<p class="paft">During each time step in the simulation, a value from the ring buffer is stored in the samples buffer, and then the values in the ring buffer are updated in a kind of feedback scheme, as shown in <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#fig4-3">Figure 4-3</a>. Once the samples buffer is full, you write its contents to a WAV file so the simulated note can be played back as audio. For each time step of the simulation, you follow these steps, which together make up the Karplus-Strong algorithm:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Store the first value from the ring buffer in the samples buffer.</li>
<li class="nl">2. Calculate the average of the first two elements in the ring buffer.</li>
<li class="nl">3. Multiply this average value by an attenuation factor (in this case, 0.995).</li>
<li class="nl">4. Append this value to the end of the ring buffer.</li>
<li class="nll">5. Remove the first element of the ring buffer.</li>
</ol>
<figure class="figure" id="fig4-3">
<p class="fig"><span aria-label=" Page 63. " class="page" epub:type="pagebreak" id="p63" role="doc-pagebreak"/><img alt="" height="555" src="images/nsp-venkitachalam503045-f04003.jpg" style="width:95%; height:auto;" width="1005"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 4-3:</span> A ring buffer and the Karplus-Strong algorithm</p>
</figcaption>
</figure>
<p>This feedback scheme is designed to simulate a wave traveling through a vibrating string. The numbers in the ring buffer represent the energy of the wave at each point on the string. According to physics, the fundamental frequency of a vibrating string is inversely proportional to its length. Since we’re interested in generating sounds of a certain frequency, we choose a ring buffer length inversely proportional to the desired frequency (this is the <i>N</i> = <i>S</i>/<i>f</i> formula mentioned earlier). The averaging that happens in step 2 of the algorithm acts as a <span class="idx" data-level1="low-pass filter" data-term="Karplus-Strong algorithm"/><i>low-pass filter</i> that cuts off higher frequencies and allows lower frequencies through, thereby eliminating higher <span class="idx" data-term="harmonics"/>harmonics (that is, larger multiples of the fundamental frequency) because you’re mainly interested in the fundamental frequency. The attenuation factor in step 3 simulates the loss of energy as the wave travels back and forth along the string. This corresponds to the fading of the sound over time.</p>
<p>The samples buffer that you add to in step 1 of the simulation represents the <span class="idx" data-term="amplitude"/><span class="idx" data-level1="amplitude" data-term="sound"/>amplitude of the generated sound over time. Storing the attenuated values at the end of the ring buffer (step 4) and removing the first item from the ring buffer (step 5) ensures that a steady stream of gradually attenuating values will be passed to the samples buffer to build up the simulated sound.</p>
<p>Let’s look at a simple example of the Karplus-Strong algorithm in action. <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#tab4-1">Table 4-1</a> represents a ring buffer at two consecutive time steps. Each value in the ring buffer represents the amplitude of the sound, which is the same as the displacement of a point on a plucked string from its rest position. The buffer has five elements, and they are initially filled with some numbers.</p>
<table id="tab4-1">
<caption>
<p class="th"><span class="thn">Table 4-1:</span> A Ring Buffer at Two Time Steps in the Karplus-Strong Algorithm</p>
</caption>
<tbody>
<tr>
<th scope="row">
<p class="trhd">Time step 1</p>
</th>
<td>
<p class="td">0.1</p>
</td>
<td>
<p class="td">−0.2</p>
</td>
<td>
<p class="td">0.3</p>
</td>
<td>
<p class="td">0.6</p>
</td>
<td>
<p class="td">−0.5</p>
</td>
</tr>
<tr>
<th scope="row">
<p class="trhd">Time step 2</p>
</th>
<td>
<p class="td">−0.2</p>
</td>
<td>
<p class="td">0.3</p>
</td>
<td>
<p class="td">0.6</p>
</td>
<td>
<p class="td">−0.5</p>
</td>
<td>
<p class="td">−0.04975</p>
</td>
</tr>
</tbody>
</table>
<p>As you go from time step 1 to time step 2, you apply the Karplus-Strong algorithm as follows. The first value in the first row, 0.1, is removed, and all subsequent values from time step 1 are added in the same order to the <span aria-label=" Page 64. " class="page" epub:type="pagebreak" id="p64" role="doc-pagebreak"/>second row, which represents time step 2. The last value in time step 2 is the attenuated average of the first and second values of time step 1, which is calculated as 0.995 × ((0.1 + −0.2) ÷ 2) = −0.04975.</p>
</section>
<section>
<h3 class="bh" id="bh0602"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0602"><span class="idx" data-term="WAV file format (begin)"/>The WAV File Format</a></h3>
<p class="paft">The <i>Waveform Audio File Format (WAV)</i> is used to store audio data. This format is convenient for small audio projects because it’s simple and doesn’t require you to worry about complicated compression techniques.</p>
<p>In its simplest form, a WAV file consists of a series of values, where each value represents the amplitude of the stored sound at a given point in time. Each value is allotted a fixed number of bits, called the <span class="idx" data-level1="sound" data-term="resolution"/><i>resolution</i>. You’ll use 16-bit resolution in this project. WAV files also have a set <span class="idx" data-term="sampling rate"/><i>sampling rate</i>, which is the number of times the audio is <i>sampled</i>, or read, every second. In this project, you use a sampling rate of 44,100 Hz, the rate used in audio CDs. In sum, when you generate a WAV file simulating the sound of a plucked string, it will contain 44,100 16-bit values for every second of audio.</p>
<p>For this project, you’ll be using Python’s <code>wave</code> module, which includes methods for working with WAV files. To get a feel for how it works, let’s generate a five-second audio clip of a 220 Hz sine wave using Python. First you represent a <span class="idx" data-term="sine wave"/>sine wave using this formula:</p>
<div class="equation">
<p class="eq"><i>A</i> = sin(2π<i>ft</i>)</p>
</div>
<p>Here, <i>A</i> is the amplitude of the wave, <i>f</i> is the frequency, and <i>t</i> is the current time index. Now you rewrite this equation as follows:</p>
<div class="equation">
<p class="eq"><i>A</i> = sin(2π<i>fi</i>/<i>R</i>)</p>
</div>
<p>In this equation, <i>i</i> is the index of the sample, and <i>R</i> is the sampling rate. Using these two equations, you can <span class="idx" data-level1="creating" data-term="WAV file format"/>create a five-second WAV file for a 200 Hz sine wave as follows. (This code is available in <i>sine.py</i> in the chapter’s GitHub repository.)</p>
<div class="codeline">
<p class="clf">import numpy as np</p>
<p class="cl">import <span class="idx" data-term="wave module"/>wave, math</p>
<p class="clf">sRate = 44100</p>
<p class="cl">nSamples = sRate * 5</p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ x = np.<span class="idx" data-level1="arrange" data-term="numpy module"/>arange(nSamples)/float(sRate)</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ vals = np.<span class="idx" data-level1="sin" data-term="numpy module"/>sin(2.0*math.pi*220.0*x)</p>
<p class="cl2"><!--<ccust1>3</ccust1>-->❸ data = np.array(vals*32767, 'int16').tostring()</p>
<p class="cl">file = wave.open('sine220.wav', 'wb')</p>
<p class="cl2"><!--<ccust1>4</ccust1>-->❹ file.setparams((1, 2, sRate, nSamples, 'NONE', 'uncompressed'))</p>
<p class="cl2"><!--<ccust1>5</ccust1>-->❺ file.writeframes(data)</p>
<p class="cll">file.close()</p>
</div>
<p>You create a <code>numpy</code> array of numbers from <code>0</code> to <code>nSamples − 1</code> and divide those numbers by the sample rate to get the time value, in seconds, when each sample of the audio clip is taken <!--<ccust1>1</ccust1>-->❶. This array represents the <i>i</i>/<i>R</i> portion of the sine wave equation discussed earlier. Next, you use the array to <span aria-label=" Page 65. " class="page" epub:type="pagebreak" id="p65" role="doc-pagebreak"/>create a second <code>numpy</code> array, this one containing sine wave amplitude values, again following the sine wave equation <!--<ccust1>2</ccust1>-->❷. The <code>numpy</code> array is a fast and convenient way to apply functions such as the <code>sin()</code> function to many values at once.</p>
<p>The computed sine wave values in the range [−1, 1] are scaled to <span class="idx" data-term="16-bit"/>16-bit values and converted to a string so they can be written to a WAV file <!--<ccust1>3</ccust1>-->❸. Then you set the parameters for the WAV file; in this case, it’s a single-channel (mono), 2-byte (16-bit), uncompressed format <!--<ccust1>4</ccust1>-->❹. Finally, you write the data to the file <!--<ccust1>5</ccust1>-->❺. <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#fig4-4">Figure 4-4</a> shows the generated <i>sine220.wav</i> file in <span class="idx" data-term="Audacity"/>Audacity, a free audio editor. As expected, you see a sine wave of frequency 220 Hz, and when you play the file, you hear a 220 Hz tone for five seconds. (Note that you need to use the Zoom tool in Audacity to see the sine wave as shown in <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#fig4-4">Figure 4-4</a>.)</p>
<figure class="figure" id="fig4-4">
<p class="fig"><img alt="" height="432" src="images/nsp-venkitachalam503045-f04004.jpg" style="width:95%; height:auto;" width="1018"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 4-4:</span> A sine wave at 220 Hz<span class="idx" data-term="WAV file format (end)"/>, zoomed in</p>
</figcaption>
</figure>
<p>In your project, once you’ve filled the samples buffer with audio data, you’ll write it to a WAV file using the same pattern illustrated in <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#fig4-4">Figure 4-4</a>.</p>
</section>
<section>
<h3 class="bh" id="bh0603"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0603">The <span class="idx" data-term="pentatonic scale"/>Minor Pentatonic Scale</a></h3>
<p class="paft">A <i>musical scale</i> is a series of notes in increasing or decreasing pitch (frequency). Often, all notes in a piece of music are chosen from a particular scale. A <i>musical interval</i> is the difference between two pitches. A <span class="idx" data-term="semitones"/><i>semitone</i> is a basic building block of a scale and is the smallest musical interval in Western music. A <span class="idx" data-term="tones"/><span class="idx" data-level1="tone" data-term="musical scale"/><i>tone</i> is twice the length of a semitone. The <span class="idx" data-term="major scale"/><span class="idx" data-level1="major" data-term="musical scale"/><i>major scale</i>, one of the most common musical scales, is defined by the interval pattern <i>tone-tone-semitone-tone-tone-tone-semitone</i>.</p>
<p>We’ll briefly go into the pentatonic scale here, since you’ll be generating musical notes in that scale. This section will explain the source of the frequency numbers used in the final program to generate notes with the Karplus-Strong algorithm. The <span class="idx" data-level1="pentatonic" data-term="musical scale"/><i>pentatonic scale</i> is a five-note musical scale. A variant of this scale is the <i>minor pentatonic scale</i>, which is defined by the interval pattern <i>(tone+semitone)-tone-tone-(tone+semitone)-tone</i>. Thus, the C minor pentatonic scale consists of the notes C, E-flat, F, G, and B-flat. <span aria-label=" Page 66. " class="page" epub:type="pagebreak" id="p66" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0016.xhtml#tab4-2">Table 4-2</a> lists the frequencies of the five notes of a C minor pentatonic scale that you’ll generate using the Karplus-Strong algorithm. (Here, C4 designates C in the fourth octave of a piano, or <i>middle C</i>, by convention.)</p>
<table id="tab4-2">
<caption>
<p class="th"><span class="thn">Table 4-2:</span> Notes in a <span class="idx" data-term="minor pentatonic scale"/><span class="idx" data-level1="minor pentatonic" data-term="musical scale"/>Minor Pentatonic Scale</p>
</caption>
<thead>
<tr>
<th scope="col">
<p class="tch">Note</p>
</th>
<th scope="col">
<p class="tch">Frequency (Hz)</p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p class="td">C4</p>
</td>
<td>
<p class="td">261.6</p>
</td>
</tr>
<tr>
<td>
<p class="td">E-flat</p>
</td>
<td>
<p class="td">311.1</p>
</td>
</tr>
<tr>
<td>
<p class="td">F</p>
</td>
<td>
<p class="td">349.2</p>
</td>
</tr>
<tr>
<td>
<p class="td">G</p>
</td>
<td>
<p class="td">392.0</p>
</td>
</tr>
<tr>
<td>
<p class="td">B-flat</p>
</td>
<td>
<p class="td">466.2</p>
</td>
</tr>
</tbody>
</table>
<p>One aspect of this project will be stringing together random sequences of notes to create melodies. One of the reasons we’re focusing on a minor pentatonic scale is that the notes of this scale sound pleasing no matter what order they’re played in. Thus, the scale is particularly conducive to generating random melodies in a way that other scales, such as a major scale, are not.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah0602"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0602">Requirements</a></h2>
<p class="paft">In this project, you’ll use the Python <code>wave</code> module to create audio files in the WAV format. To implement the Karplus-Strong algorithm, you’ll use the <span class="idx" data-term="deque class"/><code>deque</code> class from the Python <code>collections</code> module as a ring buffer and a <code>numpy</code> array as a samples buffer. You’ll also use <code>matplotlib</code> to visualize the simulated guitar string, and you’ll play back the WAV files with the <span class="idx" data-term="pygame module"/><code>pyaudio</code> module.</p>
</section>
<section>
<h2 class="ah" id="ah0603"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0603">The Code</a></h2>
<p class="paft">Now let’s develop the various pieces of code required to implement the Karplus-Strong algorithm and then put them together for the complete program. To see the full project code, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#ah0607">“The Complete Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#p74">page 74</a>. You can also download the code from the book’s GitHub repository at <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/karplus">https://github.com/mkvenkit/pp2e/tree/main/karplus</a>.</p>
<section>
<h3 class="bh" id="bh0604"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0604">Implementing the Ring Buffer with deque</a></h3>
<p class="paft">Recall from earlier that the Karplus-Strong algorithm uses a ring buffer to generate a musical note. You’ll implement the ring buffer using a <span class="idx" data-term="deque container"/><code>deque</code> container (pronounced “deck”), which is part of Python’s <span class="idx" data-term="collections module"/><code>collections</code> module of specialized container data types. You can insert and remove elements from the beginning (head) or end (tail) of a <code>deque</code> (see <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#fig4-5">Figure 4-5</a>). This insertion and removal process is a <span class="idx" data-level1="0(1)" data-term="algorithmic complexity"/><code>O(1)</code>, or a “<span class="idx" data-term="constant time"/><span class="idx" data-level1="constant time" data-term="algorithmic complexity"/>constant time” operation, which means it takes the same amount of time regardless of how big the <code>deque</code> container gets.</p>
<figure class="figure" id="fig4-5">
<p class="fig"><span aria-label=" Page 67. " class="page" epub:type="pagebreak" id="p67" role="doc-pagebreak"/><img alt="" height="242" src="images/nsp-venkitachalam503045-f04005.jpg" style="width:95%; height:auto;" width="700"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 4-5:</span> <span class="idx" data-term="ring buffer"/>A ring buffer implemented using <code>deque</code></p>
</figcaption>
</figure>
<p>The following code shows an example of how you would use <span class="idx" data-level1="example" data-term="deque"/><code>deque</code> in Python:</p>
<div class="codeline">
<p class="clf">&gt;&gt;&gt; <code class="b">from collections import deque</code></p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ &gt;&gt;&gt; <code class="b">d = deque(range(10), maxlen=10)</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">print(d)</code></p>
<p class="cl">deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ &gt;&gt;&gt; <code class="b">d.append(10)</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">print(d)</code></p>
<p class="cll">deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], maxlen=10)</p>
</div>
<p>You create the <code>deque</code> container by passing in a list created with the <code>range()</code> function <!--<ccust1>1</ccust1>-->❶. You also specify the maximum length <code>maxlen</code> of the <code>deque</code> as <code>10</code>. Next, you append the element <code>10</code> to the end of the <code>deque</code> container <!--<ccust1>2</ccust1>-->❷. When you then print the <code>deque</code>, you can see that <code>10</code> has been appended to the end of the <code>deque</code>, while the first element, <code>0</code>, has automatically been removed to maintain the <code>deque</code> container’s maximum length of 10 elements. This scheme will allow you to simultaneously implement steps 4 and 5 of the Karplus-Strong algorithm—adding a new value at the end of the ring buffer while removing the first value.</p>
</section>
<section>
<h3 class="bh" id="bh0605"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0605">Implementing the Karplus-Strong Algorithm</a></h3>
<p class="paft">You’ll now implement the Karplus-Strong algorithm in the <code>generateNote()</code> function, using a <code>deque</code> container to implement the ring buffer and a <code>numpy</code> array to implement the samples buffer. In the same function, you’ll also visualize the algorithm using <code>matplotlib</code>. The plot will show how the amplitudes of the plucked string change over time, in effect showing how the string moves as it vibrates.</p>
<p>You begin with some setup:</p>
<div class="codeline">
<p class="clf"># initialize plotting</p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ fig, ax = plt.subplots(1)</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ line, = ax.plot([], [])</p>
<p class="clf">def generateNote(freq):</p>
<p class="cl">    """generate note using Karplus-Strong algorithm"""</p>
<p class="cl">    nSamples = 44100</p>
<p class="cl">    sampleRate = 44100</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ N = int(sampleRate/freq)</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ if gShowPlot:</p>
<p class="cl">        # set axis</p>
<p class="cl">        ax.set_xlim([0, N])</p>
<p class="cl"><span aria-label=" Page 68. " class="page" epub:type="pagebreak" id="p68" role="doc-pagebreak"/>        ax.set_ylim([-1.0, 1.0])</p>
<p class="cl">        line.set_xdata(np.arange(0, N))</p>
<p class="clf">    # initialize ring buffer</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)</p>
<p class="cl">    # init samples buffer</p>
<p class="cll">  <!--<ccust1>6</ccust1>-->❻ samples = np.array([0]*nSamples, 'float32')</p>
</div>
<p>First you create a <code>matplotlib</code> figure <!--<ccust1>1</ccust1>-->❶ and a line plot <!--<ccust1>2</ccust1>-->❷, which you’ll fill with data. Then you begin the <code>generateNote()</code> function definition, which takes the frequency of the note to be generated as a parameter. You set the number of samples in the sound clip and the sample rate to both be 44,100, which means the resulting clip will be one second long. Then you divide the sample rate by the desired frequency to set the length <code>N</code> of the Karplus-Strong ring buffer <!--<ccust1>3</ccust1>-->❸. If the <code>gShowPlot</code> flag is set <!--<ccust1>4</ccust1>-->❹, you initialize the x and y range of the plot and initialize the x values to <code>[0, ... N-1]</code> using the <code>arange()</code> function.</p>
<p>You next initialize the ring buffer as a <code>deque</code> container with random numbers in the range [−0.5, 0.5], setting the maximum length of the <code>deque</code> to <code>N</code> <!--<ccust1>5</ccust1>-->❺. You also initialize the samples buffer as a <code>numpy</code> array of floats <!--<ccust1>6</ccust1>-->❻. You set the length of the array to be the number of samples the sound clip will contain.</p>
<p>Next comes the heart of the <code>generateNote()</code> function, where you implement the steps of the Karplus-Strong algorithm and create the visualization:</p>
<div class="codeline">
<p class="clf">    for i in range(nSamples):</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ samples[i] = buf[0]</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ avg = 0.995*0.5*(buf[0] + buf[1])</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ buf.append(avg)</p>
<p class="cl">        # plot of flag set</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ if gShowPlot:</p>
<p class="cl">            if i % 1000 == 0:</p>
<p class="cl">                line.set_ydata(buf)</p>
<p class="cl">                fig.canvas.draw()</p>
<p class="cl">                fig.canvas.flush_events()</p>
<p class="clf">    # samples to 16-bit to string</p>
<p class="cl">    # max value is 32767 for 16-bit</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ samples = np.array(samples * 32767, 'int16')</p>
<p class="cll">  <!--<ccust1>6</ccust1>-->❻ return samples.tobytes()</p>
</div>
<p>Here you iterate over each element in the samples buffer and carry out the steps of the Karplus-Strong algorithm. With each iteration, you copy the first element in the ring buffer to the samples buffer <!--<ccust1>1</ccust1>-->❶. Then you perform the low-pass filtering and attenuation by averaging the first two elements in the ring buffer and multiplying the result by 0.995 <!--<ccust1>2</ccust1>-->❷. This attenuated value is appended to the end of the ring buffer <!--<ccust1>3</ccust1>-->❸. Since the <code>deque</code> representing the ring buffer has a maximum length, the <code>append()</code> operation also removes the first element from the buffer.</p>
<p><span aria-label=" Page 69. " class="page" epub:type="pagebreak" id="p69" role="doc-pagebreak"/>The <code>samples</code> array is converted into a <span class="idx" data-term="16-bit"/>16-bit format by multiplying each value by 32,767 <!--<ccust1>5</ccust1>-->❺ (a 16-bit signed integer can take values only from −32,768 to 32,767, and 0.5 × 65,534 = 32,767). Then the array is converted to a byte representation for the <code>wave</code> module, which you’ll use to save this data to a file <!--<ccust1>6</ccust1>-->❻.</p>
<p>As the algorithm is running, you visualize how the ring buffer evolves <!--<ccust1>4</ccust1>-->❹. For every thousand samples, you update the <code>matplotlib</code> graph with the values in the ring buffer, and this shows how the data changes with time.</p>
</section>
<section>
<h3 class="bh" id="bh0606"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0606">Writing a <span class="idx" data-level1="writing" data-term="WAV file format"/>WAV File</a></h3>
<p class="paft">Once you have the audio data, you can write it to a WAV file using the Python <code>wave</code> module. Define a <code>writeWAVE()</code> function to carry this out:</p>
<div class="codeline">
<p class="clf">def writeWAVE(fname, data):</p>
<p class="cl">    # open file</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ file = wave.open(fname, 'wb')</p>
<p class="cl">    # WAV file parameters</p>
<p class="cl">    nChannels = 1</p>
<p class="cl">    sampleWidth = 2</p>
<p class="cl">    frameRate = 44100</p>
<p class="cl">    nFrames = 44100</p>
<p class="cl">    # set parameters</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ file.setparams((nChannels, sampleWidth, frameRate, nFrames,</p>
<p class="cl">                    'NONE', 'noncompressed'))</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ file.writeframes(data)</p>
<p class="cll">    file.close()</p>
</div>
<p>You create a WAV file <!--<ccust1>1</ccust1>-->❶ and set its parameters using a single-channel, 16-bit, noncompressed format <!--<ccust1>2</ccust1>-->❷. Then you write the data to the file <!--<ccust1>3</ccust1>-->❸.</p>
</section>
<section>
<h3 class="bh" id="bh0607"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0607"><span class="idx" data-level1="playing" data-term="WAV file format"/>Playing WAV Files with pyaudio</a></h3>
<p class="paft">Now you’ll use the Python <span class="idx" data-term="pygame module"/><code>pyaudio</code> module to play the <span class="idx" data-level1="playing" data-term="WAV file format"/>WAV files generated by the algorithm. <code>pyaudio</code> is a high-performance, low-level library that gives you access to sound devices on a computer. For convenience, you encapsulate the code in a <code>NotePlayer</code> class, as shown here:</p>
<div class="codeline">
<p class="clf">class NotePlayer:</p>
<p class="cl">    # constructor</p>
<p class="cl">    def __init__(self):</p>
<p class="cl">        # init pyaudio</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ self.pa = pyaudio.PyAudio()</p>
<p class="cl">        # open stream</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.stream = self.pa.open(</p>
<p class="cl">                format=pyaudio.paInt16,</p>
<p class="cl">                channels=1,</p>
<p class="cl">                rate=44100,</p>
<p class="cl">                output=True)</p>
<p class="cl">        # dictionary of notes</p>
<p class="cll">      <!--<ccust1>3</ccust1>-->❸ self.notes = []</p>
</div>
<p><span aria-label=" Page 70. " class="page" epub:type="pagebreak" id="p70" role="doc-pagebreak"/>In the <code>NotePlayer</code> class’s constructor, you first create the <code>PyAudio</code> object that you’ll use to play the WAV file <!--<ccust1>1</ccust1>-->❶. Then you open a 16-bit single-channel <code>PyAudio</code> output stream <!--<ccust1>2</ccust1>-->❷. You also create an empty list that you’ll later fill with filenames of the five pentatonic note WAV files <!--<ccust1>3</ccust1>-->❸.</p>
<p>In Python, when all references to an object have been deleted, the object is destroyed by a process called <i>garbage collection</i>. At that time, the object’s <code>__del__()</code> method, also known as a <i>destructor</i>, is called, if one is defined. Here’s the <code>NotePlayer</code> class’s destructor:</p>
<div class="codeline">
<p class="clf">def __del__(self):</p>
<p class="cl">    # destructor</p>
<p class="cl">    self.stream.stop_stream()</p>
<p class="cl">    self.stream.close()</p>
<p class="cll">    self.pa.terminate()</p>
</div>
<p>This method ensures that the <code>PyAudio</code> stream is cleaned up when the <code>NotePlayer</code> object is destroyed. Failing to provide a <code>__del__()</code> method for a class can cause problems when objects are repeatedly created and destroyed, since some system-wide resources (like <code>pyaudio</code> in this case) may not be cleaned up properly.</p>
<p>The remaining methods of the <code>NotePlayer</code> class are devoted to building up a list of possible notes and playing them. First, here’s the <code>add()</code> method, which is used to add a WAV filename to the class:</p>
<div class="codeline">
<p class="clf">def add(self, fileName):</p>
<p class="cll">    self.notes.append(fileName)</p>
</div>
<p>The method takes a filename corresponding to one of the generated WAV files as a parameter and adds it to the <code>notes</code> list you initialized in the class’s constructor. The class will draw on this list when it wants to play a WAV file.</p>
<p>Next, let’s look at the <code>play()</code> method used to play a note:</p>
<div class="codeline">
<p class="clf">def play(self, fileName):</p>
<p class="cl">    try:</p>
<p class="cl">        print("playing " + fileName)</p>
<p class="cl">        # open WAV file</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ wf = wave.open(fileName, 'rb')</p>
<p class="cl">        # read a chunk</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ data = wf.readframes(CHUNK)</p>
<p class="cl">        # read rest</p>
<p class="cl">        while data != b'':</p>
<p class="cl">          <!--<ccust1>3</ccust1>-->❸ self.stream.write(data)</p>
<p class="cl">          <!--<ccust1>4</ccust1>-->❹ data = wf.readframes(CHUNK)</p>
<p class="cl">        # clean up</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ wf.close()</p>
<p class="cl">    except BaseException as err:</p>
<p class="cl">      <!--<ccust1>6</ccust1>-->❻ print(f"Exception! {err=}, {type(err)=}.\nExiting.")</p>
<p class="cll">        exit(0)</p>
</div>
<p>Here you open the desired WAV file using Python’s <code>wave</code> module <!--<ccust1>1</ccust1>-->❶. Then you read <code>CHUNK</code> frames (defined globally as 1,024 in this case) from <span aria-label=" Page 71. " class="page" epub:type="pagebreak" id="p71" role="doc-pagebreak"/>the file into <code>data</code> <!--<ccust1>2</ccust1>-->❷. Next, within a <code>while</code> loop, you write the contents of <code>data</code> to the <code>PyAudio</code> output stream <!--<ccust1>3</ccust1>-->❸ and read the next chunk of data from the WAV file <!--<ccust1>4</ccust1>-->❹. Writing to the output stream has the effect of playing the audio through the default audio device of your computer, which is typically a speaker. You read the data in chunks to maintain the sample rate at the output side. If the chunks are too large and you take too much time in between reading and writing, the audio won’t sound right.</p>
<p>The <code>while</code> loop continues for as long as there’s more data to read—that is, until <code>data</code> is empty. At that point, you close the WAV file object <!--<ccust1>5</ccust1>-->❺. You handle any exceptions that may happen during the playback process (for example, the user pressing <span class="sm">CTRL</span>-C) by printing the error <!--<ccust1>6</ccust1>-->❻ and exiting the program.</p>
<p>Finally, the <code>NotePlayer</code> class’s <code>playRandom()</code> method picks a random note from the five notes you’ve generated and plays it:</p>
<div class="codeline">
<p class="clf">def playRandom(self):</p>
<p class="cl">    """play a random note"""</p>
<p class="cl">    index = random.randint(0, len(self.notes)-1)</p>
<p class="cl">    note = self.notes[index]</p>
<p class="cll">    self.play(note)</p>
</div>
<p>The method selects a random WAV filename from the <code>notes</code> list and passes that filename to the <code>play()</code> method to be played.</p>
</section>
<section>
<h3 class="bh" id="bh0608"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0608">Creating Notes and Parsing Arguments</a></h3>
<p class="paft">Now let’s look at the program’s <code>main()</code> function, which creates the notes and handles various command line options to play the notes:</p>
<div class="codeline">
<p class="clf">def main():</p>
<p class="cl">--<code class="i">snip</code>--</p>
<p class="cl">    parser = argparse.ArgumentParser(description="Generating sounds with</p>
<p class="cl">                                               Karplus-Strong Algorithm")</p>
<p class="cl">    # add arguments</p>
<p class="cl">    parser.add_argument('--display', action='store_true', required=False)</p>
<p class="cl">    parser.add_argument('--play', action='store_true', required=False)</p>
<p class="cl">    args = parser.parse_args()</p>
<p class="clf">    # show plot if flag set</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ if args.display:</p>
<p class="cl">        gShowPlot = True</p>
<p class="cl">        plt.show(block=False)</p>
<p class="clf">    # create note player</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ nplayer = NotePlayer()</p>
<p class="clf">    print('creating notes...')</p>
<p class="cl">    for name, freq in list(pmNotes.items()):</p>
<p class="cl">        fileName = name + '.wav'</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ if not os.path.exists(fileName) or args.display:</p>
<p class="cl">            data = generateNote(freq)</p>
<p class="cl">            print('creating ' + fileName + '...')</p>
<p class="cl"><span aria-label=" Page 72. " class="page" epub:type="pagebreak" id="p72" role="doc-pagebreak"/>            writeWAVE(fileName, data)</p>
<p class="cl">        else:</p>
<p class="cl">            print('fileName already created. skipping...')</p>
<p class="clf">        # add note to player</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ nplayer.add(name + '.wav')</p>
<p class="clf">        # play note if display flag set</p>
<p class="cl">        if args.display:</p>
<p class="cl">          <!--<ccust1>5</ccust1>-->❺ nplayer.play(name + '.wav')</p>
<p class="cl">            time.sleep(0.5)</p>
<p class="clf">    # play a random tune</p>
<p class="cl">    if args.play:</p>
<p class="cl">        while True:</p>
<p class="cl">            try:</p>
<p class="cl">              <!--<ccust1>6</ccust1>-->❻ nplayer.playRandom()</p>
<p class="cl">                # rest - 1 to 8 beats</p>
<p class="cl">              <!--<ccust1>7</ccust1>-->❼ rest = np.<span class="idx" data-level1="random" data-term="numpy module"/>random.choice([1, 2, 4, 8], 1,</p>
<p class="cl">                                        p=[0.15, 0.7, 0.1, 0.05])</p>
<p class="cl">                time.<span class="idx" data-level1="sleep" data-term="time module"/>sleep(0.25*rest[0])</p>
<p class="cl">            except KeyboardInterrupt:</p>
<p class="cll">                exit()</p>
</div>
<p>First you set up some command line options for the program using <span class="idx" data-term="argparse module"/><code>argparse</code>, as discussed in earlier projects. The <code>--display</code> option will play each of the five notes in turn, while visualizing each note’s waveform using <code>matplotlib</code>. The <code>--play</code> option generates a random melody using the five notes.</p>
<p>If the <code>--display</code> command line option was used <!--<ccust1>1</ccust1>-->❶, you set up a <code>matplotlib</code> plot to show how the waveform evolves during the Karplus-Strong algorithm. The <code>plt.show(block=False)</code> call ensures that the <span class="idx" data-term="matplotlib"/><code>matplotlib</code> display method doesn’t block. This way, when you call this function, it will return immediately and go on to the next statement. This is the behavior you need, since you’re manually updating the plot every frame.</p>
<p>You next create an instance of the <code>NotePlayer</code> class <!--<ccust1>2</ccust1>-->❷. Then you generate WAV files of the five notes in the C minor pentatonic scale. The frequencies for the notes are defined in the global dictionary <code>pmNotes</code>, which looks like this:</p>
<div class="codeline">
<p class="cls">pmNotes = {'C4': 262, 'Eb': 311, 'F': 349, 'G': 391, 'Bb': 466}</p>
</div>
<p>To generate the notes, you iterate through the dictionary, first constructing a filename for the note using the dictionary key plus the <i>.wav</i> extension—for example, <i>C4.wav</i>. You use the <code>os.path.</code><span class="idx" data-level1="path" data-term="os module"/><code>exists()</code> method to see whether the WAV file for a particular note has been created <!--<ccust1>3</ccust1>-->❸. If so, you skip the computation for that note. (This is a handy optimization if you’re running this program several times.) Otherwise, you generate the note using the <code>generateNote()</code> and <code>writeWAVE()</code> functions you defined earlier. <span aria-label=" Page 73. " class="page" epub:type="pagebreak" id="p73" role="doc-pagebreak"/>Once the note is computed and the WAV file created, you add the note’s filename to the <code>NotePlayer</code> object’s list of notes <!--<ccust1>4</ccust1>-->❹, and then you play the note if the <code>--display</code> command line option is used <!--<ccust1>5</ccust1>-->❺.</p>
<p>If the <code>--play</code> option is used, the <code>playRandom()</code> method in <code>NotePlayer</code> repeatedly plays a note at random from the five notes <!--<ccust1>6</ccust1>-->❻. For a note sequence to sound even remotely musical, you need to add rests between the notes played, so you use the <code>random.</code><span class="idx" data-level1="choice" data-term="random module"/><code>choice()</code> method from <code>numpy</code> to choose a random rest interval <!--<ccust1>7</ccust1>-->❼. This method also lets you choose the probability of the rest interval, which you set so that a two-beat rest is the most probable and an eight-beat rest the least probable. Try changing these values to create your own style of random music!</p>
</section>
</section>
<section>
<h2 class="ah" id="ah0604"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0604">Running the Plucked String Simulation</a></h2>
<p class="paft">To run the code for this project, enter this in a command shell:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python ks.py --display</code></p>
</div>
<p>As you can see in <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#fig4-6">Figure 4-6</a>, the <code>matplotlib</code> plot shows how the Karplus-Strong algorithm converts the initial random displacements to create waves of the desired frequency.</p>
<figure class="figure" id="fig4-6">
<p class="fig"><img alt="" height="552" src="images/nsp-venkitachalam503045-f04006.jpg" style="width:95%; height:auto;" width="636"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 4-6:</span> A sample run of the plucked string simulation</p>
</figcaption>
</figure>
<p>Now try playing a random sequence of notes using this command:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python ks.py --play</code></p>
</div>
<p>This should play a random note sequence using the generated WAV files of the pentatonic musical scale.</p>
</section>
<section>
<h2 class="ah" id="ah0605"><span aria-label=" Page 74. " class="page" epub:type="pagebreak" id="p74" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0605">Summary</a></h2>
<p class="paft">In this project, you used the Karplus-Strong algorithm to simulate the sound of plucked strings and played notes from generated WAV files. You learned how to implement the Karplus-Strong algorithm using a <code>deque</code> container as a ring buffer. You also learned about the WAV file format and how to play WAV files using <code>pyaudio</code>, as well as how to use <code>matplotlib</code> to visualize a vibrating string. You even learned about the pentatonic musical scale!</p>
</section>
<section>
<h2 class="ah" id="ah0606"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0606">Experiments!</a></h2>
<p class="paft">Here are some ideas for experiments:</p>
<ol style="list-style-type:none">
<li class="nlf">1. I’ve stated that the Karplus-Strong algorithm creates realistic plucked string sounds by generating overtones as well as the fundamental frequency of the note. But how do you know it’s working? By creating spectral plots of your WAV files, like the one in <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#fig4-2">Figure 4-2</a>. You can use the free program Audacity to do this. Open one of the WAV files in <span class="idx" data-term="Audacity"/>Audacity, and select <b>Analyze‣Plot</b> <span class="idx" data-term="spectral plot"/><b>Spectrum</b>. You should see that the sound contains many frequencies.</li>
<li class="nl">2. Use the techniques you learned in this chapter to create a method that replicates the sound of two strings of different frequencies vibrating together. Remember, the Karplus-Strong algorithm produces a ring buffer full of sound amplitude values. You can combine two sounds by adding their amplitudes together.</li>
<li class="nl">3. Replicate the sound of two strings vibrating together, as described in the previous experiment, but add a time delay between the first and second string plucks.</li>
<li class="nl">4. Write a method to read music from a text file and generate musical notes. Then play the music using these notes. You can use a format where the note names are followed by integer rest time intervals, like this: C4 1 F4 2 G4 1 . . .</li>
</ol>
</section>
<section>
<h2 class="ah" id="ah0607"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0607">The Complete Code</a></h2>
<p class="paft">Here’s the complete code for this project:</p>
<div class="codeline">
<p class="clf">"""</p>
<p class="cl">ks.py</p>
<p class="clf">Uses the Karplus-Strong algorithm to generate musical notes</p>
<p class="cl">in a pentatonic scale.</p>
<p class="clf">Author: Mahesh Venkitachalam</p>
<p class="cl">"""</p>
<p class="clf">import sys, os</p>
<p class="cl">import time, random</p>
<p class="cl"><span aria-label=" Page 75. " class="page" epub:type="pagebreak" id="p75" role="doc-pagebreak"/>import wave, argparse</p>
<p class="cl">import numpy as np</p>
<p class="cl">from collections import deque</p>
<p class="cl">import matplotlib</p>
<p class="cl"># to fix graph display issues on macOS</p>
<p class="cl">matplotlib.use('TkAgg')</p>
<p class="cl">from matplotlib import pyplot as plt</p>
<p class="cl">import pyaudio</p>
<p class="clf"># show plot of algorithm in action?</p>
<p class="cl">gShowPlot = False</p>
<p class="clf"># notes of a pentatonic minor scale</p>
<p class="cl"># piano C4-E(b)-F-G-B(b)-C5</p>
<p class="cl">pmNotes = {'C4': 262, 'Eb': 311, 'F': 349, 'G':391, 'Bb':466}</p>
<p class="clf">CHUNK = 1024</p>
<p class="clf"># initialize plotting</p>
<p class="cl">fig, ax = plt.subplots(1)</p>
<p class="cl">line, = ax.plot([], [])</p>
<p class="clf"># write out WAV file</p>
<p class="cl">def writeWAVE(fname, data):</p>
<p class="cl">    """write data to WAV file"""</p>
<p class="cl">    # open file</p>
<p class="cl">    file = wave.open(fname, 'wb')</p>
<p class="cl">    # WAV file parameters</p>
<p class="cl">    nChannels = 1</p>
<p class="cl">    sampleWidth = 2</p>
<p class="cl">    frameRate = 44100</p>
<p class="cl">    nFrames = 44100</p>
<p class="cl">    # set parameters</p>
<p class="cl">    file.setparams((nChannels, sampleWidth, frameRate, nFrames,</p>
<p class="cl">                    'NONE', 'noncompressed'))</p>
<p class="cl">    file.writeframes(data)</p>
<p class="cl">    file.close()</p>
<p class="clf">def generateNote(freq):</p>
<p class="cl">    """generate note using Karplus-Strong algorithm"""</p>
<p class="cl">    nSamples = 44100</p>
<p class="cl">    sampleRate = 44100</p>
<p class="cl">    N = int(sampleRate/freq)</p>
<p class="clf">    if gShowPlot:</p>
<p class="cl">        # set axis</p>
<p class="cl">        ax.set_xlim([0, N])</p>
<p class="cl">        ax.set_ylim([-1.0, 1.0])</p>
<p class="cl">        line.set_xdata(np.arange(0, N))</p>
<p class="clf">    # initialize ring buffer</p>
<p class="cl">    buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)</p>
<p class="cl">    # init sample buffer</p>
<p class="cl">    samples = np.array([0]*nSamples, 'float32')</p>
<p class="cl">    for i in range(nSamples):</p>
<p class="cl"><span aria-label=" Page 76. " class="page" epub:type="pagebreak" id="p76" role="doc-pagebreak"/>        samples[i] = buf[0]</p>
<p class="cl">        avg = 0.995*0.5*(buf[0] + buf[1])</p>
<p class="cl">        buf.append(avg)</p>
<p class="cl">        # plot of flag set</p>
<p class="cl">        if gShowPlot:</p>
<p class="cl">            if i % 1000 == 0:</p>
<p class="cl">                line.set_ydata(buf)</p>
<p class="cl">                fig.canvas.draw()</p>
<p class="cl">                fig.canvas.flush_events()</p>
<p class="clf">    # samples to 16-bit to string</p>
<p class="cl">    # max value is 32767 for 16-bit</p>
<p class="cl">    samples = np.array(samples * 32767, 'int16')</p>
<p class="cl">    return samples.tobytes()</p>
<p class="clf"># play a WAV file</p>
<p class="cl">class NotePlayer:</p>
<p class="cl">    # constructor</p>
<p class="cl">    def __init__(self):</p>
<p class="cl">        # init pyaudio</p>
<p class="cl">        self.pa = pyaudio.PyAudio()</p>
<p class="cl">        # open stream</p>
<p class="cl">        self.stream = self.pa.open(</p>
<p class="cl">                format=pyaudio.paInt16,</p>
<p class="cl">                channels=1,</p>
<p class="cl">                rate=44100,</p>
<p class="cl">                output=True)</p>
<p class="cl">        # dictionary of notes</p>
<p class="cl">        self.notes = []</p>
<p class="cl">    def __del__(self):</p>
<p class="cl">        # destructor</p>
<p class="cl">        self.stream.stop_stream()</p>
<p class="cl">        self.stream.close()</p>
<p class="cl">        self.pa.terminate()</p>
<p class="clf">    # add a note</p>
<p class="cl">    def add(self, fileName):</p>
<p class="cl">        self.notes.append(fileName)</p>
<p class="cl">    # play a note</p>
<p class="cl">    def play(self, fileName):</p>
<p class="cl">        try:</p>
<p class="cl">            print("playing " + fileName)</p>
<p class="cl">            # open WAV file</p>
<p class="cl">            wf = wave.open(fileName, 'rb')</p>
<p class="cl">            # read a chunk</p>
<p class="cl">            data = wf.readframes(CHUNK)</p>
<p class="cl">            # read rest</p>
<p class="cl">            while data != b'':</p>
<p class="cl">                self.stream.write(data)</p>
<p class="cl">                data = wf.readframes(CHUNK)</p>
<p class="cl">            # clean up</p>
<p class="cl">            wf.close()</p>
<p class="cl">        except BaseException as err:</p>
<p class="cl"><span aria-label=" Page 77. " class="page" epub:type="pagebreak" id="p77" role="doc-pagebreak"/>            print(f"Exception! {err=}, {type(err)=}.\nExiting.")</p>
<p class="cl">            exit(0)</p>
<p class="clf">    def playRandom(self):</p>
<p class="cl">        """play a random note"""</p>
<p class="cl">        index = random.randint(0, len(self.notes)-1)</p>
<p class="cl">        note = self.notes[index]</p>
<p class="cl">        self.play(note)</p>
<p class="clf"># main() function</p>
<p class="cl">def main():</p>
<p class="cl">    # declare global var</p>
<p class="cl">    global gShowPlot</p>
<p class="clf">    parser = argparse.ArgumentParser(description="Generating sounds with</p>
<p class="cl">                                              Karplus-Strong Algorithm.")</p>
<p class="cl">    # add arguments</p>
<p class="cl">    parser.add_argument('--display', action='store_true', required=False)</p>
<p class="cl">    parser.add_argument('--play', action='store_true', required=False)</p>
<p class="cl">    args = parser.parse_args()</p>
<p class="clf">    # show plot if flag set</p>
<p class="cl">    if args.display:</p>
<p class="cl">        gShowPlot = True</p>
<p class="cl">        # plt.ion()</p>
<p class="cl">        plt.show(block=False)</p>
<p class="clf">    # create note player</p>
<p class="cl">    nplayer = NotePlayer()</p>
<p class="clf">    print('creating notes...')</p>
<p class="cl">    for name, freq in list(pmNotes.items()):</p>
<p class="cl">        fileName = name + '.wav'</p>
<p class="cl">        if not os.path.exists(fileName) or args.display:</p>
<p class="cl">            data = generateNote(freq)</p>
<p class="cl">            print('creating ' + fileName + '...')</p>
<p class="cl">            writeWAVE(fileName, data)</p>
<p class="cl">        else:</p>
<p class="cl">            print('fileName already created. skipping...')</p>
<p class="clf">        # add note to player</p>
<p class="cl">        nplayer.add(name + '.wav')</p>
<p class="clf">        # play note if display flag set</p>
<p class="cl">        if args.display:</p>
<p class="cl">            nplayer.play(name + '.wav')</p>
<p class="cl">            time.sleep(0.5)</p>
<p class="clf">    # play a random tune</p>
<p class="cl">    if args.play:</p>
<p class="cl">        while True:</p>
<p class="cl">            try:</p>
<p class="cl">                nplayer.playRandom()</p>
<p class="cl"><span aria-label=" Page 78. " class="page" epub:type="pagebreak" id="p78" role="doc-pagebreak"/>                # rest - 1 to 8 beats</p>
<p class="cl">                rest = np.random.choice([1, 2, 4, 8], 1,</p>
<p class="cl">                                        p=[0.15, 0.7, 0.1, 0.05])</p>
<p class="cl">                time.sleep(0.25*rest[0])</p>
<p class="cl">            except KeyboardInterrupt:</p>
<p class="cl">                exit()</p>
<p class="clf"># call main</p>
<p class="cl">if __name__ == '__main__':</p>
<p class="cl">    main()</p>
</div>
</section>
</section>
</div></body></html>