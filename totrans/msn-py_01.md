## **1**

**你的第一次太空行走**

![image](img/common01.jpg)

欢迎加入太空军团。你的任务是建立人类在火星上的第一个前哨站。多年来，世界上最伟大的科学家们一直在派遣机器人进行近距离研究。很快，你也将踏上这片尘土飞扬的表面。

前往火星的旅行通常需要六到八个月，具体取决于地球和火星的对齐方式。在旅途中，飞船有可能会撞上流星体和其他太空垃圾。如果发生任何损坏，你需要穿上宇航服，走到气闸处，然后进入太空修复，类似于图 1-1 中的宇航员。

在本章中，你将通过使用 Python 让角色在屏幕上移动，来进行一次太空行走。你将启动第一个 Python 程序，并学习一些你在本书后面创建太空站时所需要的基础 Python 指令。你还将学习如何通过重叠图像来创造深度感，这在我们稍后创建 3D 版本的*Escape*游戏时（从第三章开始的第一个房间模型）将非常有用。

![image](img/fig1-1.jpg)

*图 1-1：2010 年，NASA 宇航员 Rick Mastracchio 进行 26 分钟的太空行走，由宇航员 Clayton Anderson 拍摄。这次太空行走是在国际空间站外进行的，目的是更换冷却液罐。*

如果你还没有安装 Python 和 Pygame Zero（Windows 用户），请参阅“安装软件”第 3 页的内容。你还需要本章的*Escape*游戏文件。“下载游戏文件”在第 7 页说明了如何下载和解压这些文件。

### **启动 Python 编辑器**

正如我在引言中提到的，在本书中我们将使用 Python 编程语言。编程语言提供了一种为计算机编写指令的方法。我们的指令将告诉计算机如何执行某些操作，例如响应按键或显示图像。我们还将使用 Pygame Zero，它为 Python 提供了一些处理声音和图像的额外指令。

Python 附带了 IDLE 编辑器，我们将使用该编辑器来创建 Python 程序。由于你已经安装了 Python，IDLE 现在应该也已安装在你的计算机上。接下来的部分将根据你使用的计算机类型解释如何启动 IDLE。

#### **在 Windows 10 中启动 IDLE**

在 Windows 10 中启动 IDLE，请按照以下步骤操作：

1.  点击屏幕底部的 Cortana 搜索框，并在框中输入 Python。

1.  点击**IDLE**以打开它。

1.  当 IDLE 运行时，右键点击屏幕底部任务栏中的图标并固定它。以后你可以通过单击从任务栏直接运行它。

#### **在 Windows 8 中启动 IDLE**

在 Windows 8 中启动 IDLE，请按照以下步骤操作：

1.  将鼠标移到屏幕右上角，显示出魅力条。

1.  点击搜索图标，在框中输入 Python。

1.  点击**IDLE**以打开它。

1.  启动 IDLE 后，右击屏幕底部任务栏中的其图标并将其固定。以后你可以通过单击它来运行 IDLE。

#### **在 Raspberry Pi 上启动 IDLE**

在 Raspberry Pi 上启动 IDLE，请按照以下步骤操作：

1.  点击屏幕左上角的“程序”菜单。

1.  找到“编程”类别。

1.  点击 Python 3（IDLE）图标。Raspberry Pi 上安装了 Python 2 和 Python 3，但本书中的大多数程序只在 Python 3 上运行。

### **介绍 Python Shell**

启动 IDLE 时，你应该看到 Python 的*Shell*，如图 1-2 所示。这个窗口是你可以给 Python 输入指令并立即看到计算机回应的地方。三个箭头（`>>>`）被称为*提示符*，它们告诉你 Python 已经准备好接受指令了。

![image](img/fig1-2.jpg)

*图 1-2：Python Shell*

那么，让我们给 Python 一些任务吧！

#### **显示文本**

对于我们的第一个指令，让我们告诉 Python 在屏幕上显示文本。输入以下内容并按回车：

```py
>>> print("Prepare for launch!")
```

当你输入时，文本的颜色会发生变化。一开始是黑色的，但一旦 Python 识别出一个命令，比如 `print`，文本就会变色。

图 1-3 显示了你刚刚输入的指令的不同部分。紫色的单词 `print` 是一个*内建函数*，它是 Python 中始终可用的众多指令之一。`print()` 函数会在屏幕上显示你放在*括号*（圆括号）之间的信息。函数括号之间的信息就是该函数的*参数*。

![image](img/fig1-3.jpg)

*图 1-3：你第一个指令的不同部分*

在我们的第一个指令中，`print()` 函数的参数是一个*字符串*，程序员通常称之为一段文本。（字符串可以包含数字，但它们被当作字母处理，所以你不能用字符串中的数字做运算。）双引号（`" "`）表示字符串的开始和结束。你在双引号之间输入的任何内容都会是绿色，双引号本身也会是绿色的。

颜色不仅仅是让屏幕更加亮眼：它们还突出显示了指令的不同部分，帮助你找出错误。例如，如果你的最后一个括号是绿色的，这意味着你忘记了字符串的闭合双引号。

如果你正确输入了指令，计算机将显示以下文本：

```py
Prepare for launch!
```

显示为绿色的字符串现在在屏幕上显示为蓝色。所有的*输出*（计算机提供给你的信息）都以蓝色显示。如果你的命令没有成功，检查你是否做了以下操作：

1.  正确拼写了 `print`。如果拼写正确，它将显示为紫色（见图 1-3）。

1.  使用了两个括号。其他类型的括号将无法工作。

1.  使用了两个双引号。不要使用两个撇号（`''`）代替双引号（`"`）。尽管双引号包含两个符号，它在键盘上其实是一个符号。在美国键盘上，双引号位于字母中间行的右侧，必须与 SHIFT 键一起使用。在英国键盘上，双引号位于 2 键上。

如果你在双引号之间输入的文本有错误，指令仍然会运行，但计算机会显示你输入的内容。例如，试试这个：

```py
>>> print("Prepare for lunch!")
```

如果现在你打错了字符串也没关系，但以后在书中输入字符串或指令时要小心。错误往往会导致程序无法正常工作，而且在更长的程序中，即使有颜色编码，也很难追踪到错误。

**训练任务 #1**

你能输入一个新的指令来输出你的名字吗？（你可以在每章结尾的“任务总结”部分找到训练任务的答案。）

#### **输出和使用数字**

到目前为止，你已经使用`print()`函数输出了一个字符串，但它也可以进行计算并输出一个数字。输入以下代码：

```py
>>> print(4 + 1)
```

计算机应输出数字`5`，即`4 + 1`的结果。与字符串不同，数字和计算不需要加引号。但是，你仍然需要使用括号来标记你想要提供给`print()`函数的信息的开始和结束。

如果你在`4 + 1`周围加上引号会发生什么？试试看！结果是计算机输出`"4 + 1"`，因为它不会把 4 和 1 当作数字来处理。相反，它把参数当作字符串处理。你要求它输出`"4 + 1"`，它就会准确地做出这个输出！

```py
>>> print(4 + 1)
5
>>> print("4 + 1")
4 + 1
```

只有在你不加引号时，Python 才会进行计算。在你的程序中，你将经常使用`print()`函数。

### **介绍脚本模式**

Shell 非常适合快速计算和简短的指令。但对于更长的指令集，比如游戏，创建程序要容易得多。*程序*是可重复执行的一组指令，我们保存它们，以便随时运行并在需要时修改，而无需重新输入。我们将使用 IDLE 的*脚本模式*来编写程序。当你在脚本模式下输入指令时，它们不会像在 shell 中那样立即运行。

使用顶部菜单中的菜单，选择**文件**，然后选择**新建文件**，以打开一个空白的新窗口，如图 1-4 所示。窗口顶部的标题栏会显示*未命名*，直到你保存并命名文件。保存文件后，标题栏将显示文件的名称。从现在开始，我们在编写 Python 代码时几乎总是使用脚本模式。

![image](img/fig1-4.jpg)

*图 1-4：Python 脚本模式*

当你在脚本模式中输入指令时，可以使用鼠标或箭头键来更改、添加和删除指令，这样更容易修正错误并构建程序。从 第四章 开始，我们将通过逐步添加并测试每个新部分来构建 *Escape* 游戏。

**提示**

如果你不确定自己是在 shell 模式还是脚本模式窗口中，看看顶部的标题栏。Shell 显示的是 *Python Shell*。脚本模式窗口显示的是 *Untitled* 或你程序的名称。

### **创建星空背景**

我们将编写的第一个程序将显示星空背景图像，这是我们将用作 *太空行走* 程序的太空背景。该图像位于 *escape* 文件夹中的 *images* 文件夹中。首先在 IDLE 中的新空白窗口中输入 Listing 1-1。

**注意**

*在本书中，我将使用圆圈中的数字（例如：* ➊*）来引用解释中的不同代码部分，这样你可以更容易地跟随。在程序中不要输入这些数字。当你在文本中看到圆圈中的数字时，回到程序列表中查看我所提到的程序部分。*

Listing 1-1 是一个简短的程序，但在你输入时有几个细节需要注意：`def`语句 ➍ 需要在其行末加上冒号，接下来的行 ➎ 需要以四个空格开始。当你在 `def` 行末添加冒号并按下 ENTER 时，IDLE 会自动在下一行的开头添加四个空格。

*listing1-1.py*

```py
➊ # Spacewalk
   # by Sean McManus
   # www.sean.co.uk / www.nostarch.com

➋ WIDTH = 800
   HEIGHT = 600
➌ player_x = 600
   player_y = 350

➍ def draw():
➎     screen.blit(images.backdrop, (0, 0))
```

*Listing 1-1：在 Pygame Zero 中查看星空背景。*

选择屏幕顶部的 **文件** 菜单，然后选择 **保存**（从现在开始，我们将使用类似于 **文件** ▸ **保存** 的菜单选择简写）。在保存对话框中，将你的程序命名为 *listing1-1.py*。你需要将文件保存在你在介绍部分设置的 *escape* 文件夹中。这样，它就与本书的 *images* 文件夹位于同一文件夹，Pygame Zero 在运行程序时就能找到图像。保存文件后，你的 *escape* 文件夹现在应该包含 *listing1-1.py* 文件和 *images* 文件夹，如 图 1-5 所示（以及 *listings* 和 *sounds* 文件夹）。

![image](img/fig1-5.jpg)

*图 1-5：你的新 Python 程序和* images *文件夹应该存储在同一位置。*

我将简要解释*listing1-1.py*程序是如何工作的，但首先让我们运行程序，以便我们可以欣赏星空背景。程序需要一些来自 Pygame Zero 的指令来管理图像，因此为了使用这些指令，我们需要使用`pgzrun`指令运行程序。每当我们在 Python 程序中使用 Pygame Zero 的指令时，都需要使用`pgzrun`来运行。

我们将在计算机的命令行中输入这些内容，就像我们在介绍中运行*Escape*游戏时所做的那样。首先，回顾一下“运行游戏”，并按照第 9 页上的说明，从你的*escape*文件夹中打开计算机的命令行终端。然后在命令行中运行以下指令：

```py
pgzrun listing1-1.py
```

**紧急警报**

*不要在 IDLE 中输入这个指令：一定要在你的 Windows 或 Raspberry Pi 命令行中输入。介绍中展示了如何操作。*

如果一切按计划进行，你应该能看到太空的壮丽景象，如图 1-6 所示。

![image](img/fig1-6.jpg)

*图 1-6：星空。星空图像由 NASA/JPL-Caltech/UCLA 提供，显示的是星团 NGC 2259。*

**使用我的示例列表**

如果你无法使本书中的程序工作，你可以使用我的示例程序。例如，你可以使用我的*listing1-1.py*示例，并修改它以便快速制作自己的*listing1-2.py*，以便继续跟随下去。

你可以在*escape*文件夹中的*listings*文件夹找到我的程序。只需在 Windows 或 Raspberry Pi 桌面上打开*listings*文件夹，找到你需要的列表，复制它，然后将其粘贴到*escape*文件夹中。然后在 IDLE 中打开复制的列表，并按照书中的下一步继续操作。当你查看文件夹时，你应该能够看到 Python 文件和*images*文件夹在同一个位置（参见图 1-5）。

#### **到目前为止理解程序**

本书中你将看到的大部分指令在任何 Python 程序中都能使用。例如，`print()`函数始终可用。为了制作本书中的程序，我们还使用了 Pygame Zero。它为 Python 添加了一些新函数和功能，用于创建游戏，特别是在屏幕显示和声音方面。列表 1-1 介绍了我们从 Pygame Zero 中获得的第一组指令，用于设置游戏窗口并绘制星空。

让我们更仔细地看一下*listing1-1.py*程序是如何工作的。

前几行程序是*注释* ➊。当你使用`#`符号时，Python 会忽略该行中`#`符号后的所有内容，该行会显示为红色。注释帮助你和其他阅读程序的人理解程序的功能及其工作原理。

接下来，程序需要存储一些信息。程序几乎总是需要存储程序使用的信息或稍后需要引用的信息。例如，在许多游戏中，计算机需要跟踪分数和玩家在屏幕上的位置。由于这些细节会随着程序的运行而变化（或*波动*），它们存储在一个叫做*变量*的东西中。变量是你给某个信息（无论是数字还是文本）起的名字。

要创建一个变量，你可以使用如下指令：

```py
variable_name = value
```

**注意**

*以斜体显示的代码术语是占位符，将被填充。你应该用你自己的变量名代替* variable_name*。*

例如，以下指令将数字 500 存入变量 `score` 中：

```py
score = 500
```

你可以几乎随意为你的变量命名。然而，为了让你的程序更容易编写和理解，你应该选择能够描述每个变量内部信息的变量名。请注意，你不能使用 Python 本身用于语言的名称作为变量名，例如 `print`。

**紧急警告**

*Python 区分大小写，这意味着它对变量是否使用大写或小写字母非常严格。事实上，它将* score*、* SCORE* 和 *Score* 视为三个完全不同的变量。确保你完全照搬我的示例程序，否则它们可能无法正常工作。*

清单 1-1 开始时创建了一些变量。Pygame Zero 使用 `WIDTH` 和 `HEIGHT` 变量 ➋ 来设置游戏窗口在屏幕上的大小。我们的窗口比它高，因此 `WIDTH` 的值（`800`）比 `HEIGHT` 的值（`600`）大。

注意，我们将这些变量拼写为大写字母。变量名中的大写字母告诉我们它们是 *常量*。常量是一种特殊类型的变量，其值在设定后不应该改变。大写字母有助于其他查看程序的程序员理解，不应该让程序中的其他部分修改这些变量。

`player_x` 和 `player_y` 变量 ➌ 会存储你在执行太空行走时在屏幕上的位置。在本章后面，我们将使用这些变量来绘制你的屏幕位置。

然后，我们使用 `def()` 语句 ➍ 来定义一个函数。一个 *函数* 是一组指令，你可以在程序中需要它们时运行它们。你已经见过一个内置函数 `print()`。我们将在这个程序中创建一个名为 `draw()` 的函数，Pygame Zero 会在屏幕变化时使用它来绘制屏幕显示。

我们使用关键字 `def` ➍ 来定义一个函数，后跟我们选择的函数名称、空括号和冒号。有时，你会使用函数的括号来传递该函数所需的信息，正如你将在本书后面看到的那样。

然后，我们需要为函数提供指令，告诉它应该做什么。为了告诉 Python 哪些指令属于这个函数，我们通过缩进四个空格来标明它们。Pygame Zero 中的 `screen.blit()` 指令 ➎ 会在屏幕上绘制一张图片。在括号中，我们告诉它绘制哪张图片以及绘制的位置，像这样：

```py
screen.blit(images.image_name, (x, y) )
```

从 *images* 文件夹中，我们将使用 *backdrop.jpg* 文件，它是星空背景。在我们的 *listing1-1.py* 程序中，我们将它称为 `images.backdrop`。我们不需要使用文件的 *.jpg* 扩展名，因为我们使用 Pygame Zero 来处理图像，而 Pygame Zero 不要求使用扩展名。此外，程序知道图像所在的位置，因为所有图像必须保存在 *images* 文件夹中，以便 Pygame Zero 可以找到它们。

我们将图像放置在屏幕的 `(0, 0)` 位置➌，这里是屏幕的左上角。第一个数字，称为 *x 位置*，告诉 `screen.blit()` 指令我们希望图像距离左边缘多远；第二个数字，称为 *y 位置*，描述我们希望图像离上边缘多远。*x* 位置从窗口的左边缘 0 开始，到右边缘的 799（因为我们的窗口宽度是 800 像素）。类似地，*y* 位置从窗口的顶部 0 开始，到底部的 599（参见图 1-6）。

对于屏幕上的位置，我们使用 *元组*，它只是一些数字或字符串放在括号内，例如 `(0, 0)`。在元组中，数字之间用逗号分隔，另外为了可读性，还可以加上空格。

关于元组，你需要知道的最重要的事情是要小心标点符号。因为元组使用括号，而我们将这个元组放在 `screen.blit()` 的括号内，所以这里有两组括号。因此，你需要在元组的值周围加上括号，但也需要在元组之后关闭 `screen.blit()` 的括号。

### **停止你的 Pygame Zero 程序**

类似于太空，你的 Pygame Zero 程序将一直运行下去。要停止它，可以点击游戏窗口右上角的关闭按钮（参见图 1-6）。你也可以通过按 CTRL-C 在输入 `pgzrun` 指令的命令行窗口中关闭程序。

**红色警报**

*不要关闭命令行窗口。否则，你将不得不重新打开它才能运行另一个 Pygame Zero 程序。如果不小心关闭了它，请参考 “运行游戏” 章节，在 第 9 页 中重新打开它。*

### **添加行星和宇宙飞船**

让我们把火星和宇宙飞船显示出来。在 IDLE 中，将清单 1-2 中的最后两行添加到现有的 *listing 1-1.py* 程序中。

**注意**

*我会在代码清单中使用* --snip-- *来表示我省略了一些代码，通常是因为这些代码在之前已经重复出现过。我还会将重复的代码以灰色显示，这样你就能更清楚地看到你需要添加的新代码。不要再次添加重复的代码！*

在以下代码中，我省略了注释和变量设置，以节省空间并使你更容易看到新增的代码。但确保你将这些指令保留在程序中。只需在最后添加两行新代码。

*listing1-2.py*

```py
--snip--
def draw():
    screen.blit(images.backdrop, (0, 0))
    screen.blit(images.mars, (50, 50))
    screen.blit(images.ship, (130, 150))
```

*清单 1-2：添加火星和飞船*

将你的更新程序保存为*listing1-2.py*，方法是选择**文件** ▸ **另存为**。通过切换回命令行窗口并输入命令`pgzrun listing1-2.py`来运行程序。图 1-7 展示了现在屏幕应该呈现的效果，红色的行星和位于其上方的宇宙飞船。

![image](img/fig1-7.jpg)

*图 1-7：火星和宇宙飞船。火星的图像是 1991 年由哈勃太空望远镜拍摄的。*

**注意**

*如果你的程序没有按预期运行，请检查所有的* screen.blit() *指令前是否有四个空格，并且它们是否对齐。*

新的第一条指令将图片*mars.jpg*放置在位置(50, 50)，也就是屏幕的左上角附近。第二条新指令将宇宙飞船放置在(130, 150)位置。在这两种情况下，使用的坐标都是图像的左上角位置。

#### **改变视角：飞到行星后面**

现在让我们看看如何让宇宙飞船飞到行星后面。按示例 1-3 中所示的方式，在 IDLE 中交换最后两条指令的顺序。为此，选中其中一行，按 CTRL-X 剪切它，点击新的一行，按 CTRL-V 粘贴到那里。你也可以使用屏幕顶部“编辑”菜单中的剪切和粘贴选项。

*listing1-3.py*

```py
--snip--
def draw():
    screen.blit(images.backdrop, (0, 0))
    screen.blit(images.ship, (130, 150))
    screen.blit(images.mars, (50, 50))
```

*示例 1-3：交换行星和宇宙飞船指令的顺序*

如果你之前的程序仍在运行，请现在关闭它。将你的新程序保存为*listing1-3.py*，并通过命令行输入`pgzrun listing1-3.py`来运行它。你应该看到宇宙飞船现在位于行星后面，如图 1-8 所示。如果没有，确保你运行了正确的文件（*listing1-3.py*），然后检查程序中的指令是否正确。

宇宙飞船之所以会在行星后面，是因为图像是按程序中的绘制顺序添加到屏幕上的。在我们更新后的程序中，我们先绘制星空，再绘制宇宙飞船，最后绘制火星。每一张新图像都会显示在前一张图像的上方。如果两张图像重叠，最后绘制的图像会出现在先前绘制的图像前面。

![image](img/fig1-8.jpg)

*图 1-8：宇宙飞船现在位于行星后面。*

**训练任务 #2**

你能将程序中的一条绘图指令移到其他位置，使行星和宇宙飞船消失吗？如果不确定该做什么，可以通过移动绘图指令来进行实验，看看保存程序并重新运行后会产生什么效果。

确保你在`draw()`函数内保持绘图指令的对齐，并且每条指令前有四个空格。当你完成实验后，再次将示例 1-3 中的指令恢复，使宇宙飞船和火星重新出现在屏幕上。

#### **太空漫步！**

现在是时候从飞船底部爬出来，开始你的太空行走了。编辑你的程序，使其与 Listing 1-4 匹配。但一定要保持之前没有显示在这里的变量指令与之前相同。将更新后的程序保存为*listing1-4.py*。

*listing1-4.py*

```py
   --snip--
   def draw():
       screen.blit(images.backdrop, (0, 0))
       screen.blit(images.mars, (50, 50))
➊     screen.blit(images.astronaut, (player_x, player_y))
➋     screen.blit(images.ship, (550, 300))

➌ def game_loop():
➍     global player_x, player_y
➎     if keyboard.right:
➏         player_x += 5
➐     elif keyboard.left:
           player_x -= 5
➑     elif keyboard.up:
           player_y -= 5
       elif keyboard.down:
           player_y += 5

➒ clock.schedule_interval(game_loop, 0.03)
```

*Listing 1-4: 添加太空行走指令*

在这个代码段中，我们添加了一个新的指令➊，用于在`player_x`和`player_y`变量指定的位置绘制宇航员图像，这些变量在 Listing 1-1 中已经设置。正如你所看到的，我们可以用这些变量名代替数字来表示宇航员的位置。程序将在每次绘制宇航员时，使用这些变量中存储的当前数字来确定宇航员的位置。

注意，程序中图像的绘制顺序已经改变，现在是背景、火星、宇航员和飞船。确保你修改`screen.blit()`指令的顺序，以与此列表匹配。

宇航员开始时与飞船重叠。由于宇航员在飞船之前绘制，因此宇航员看起来是从飞船下方（后面）出现的。我们还将飞船的位置➋更改到了屏幕的右下角。这为宇航员飞向行星提供了空间。

通过输入`pgzrun listing1-4.py`运行程序。现在你应该能够使用方向键自由移动，身穿航天服，穿越太空，如图 1-9 所示。你会发现自己飞在宇宙飞船后面，但在火星和星空之前。我们绘制图像的顺序创造了一个简单的深度错觉。当我们在第三章开始绘制空间站时，我们将使用这种绘制技巧来创建每个房间的 3D 视角。我们将从后到前绘制房间，以创造深度感。

![image](img/fig1-9.jpg)

*图 1-9：你从飞船中走出来，开始太空行走。*

**训练任务 #3**

你能编辑代码，将飞船和宇航员移动到屏幕的右上角吗？你需要更改`player_x`和`player_y`的起始值，以及飞船绘制的位置。确保在程序开始时，玩家是“在”（实际上是在）飞船内部的。你也可以尝试其他位置。这是熟悉屏幕位置的好方法。如果需要，可以参考图 1-6。

#### **理解太空行走代码**

太空行走的代码 Listing 1-4 很有趣，因为它允许你通过键盘控制程序的部分内容，这在*逃脱*游戏中至关重要。让我们看看最终的太空行走程序是如何工作的。

我们在之前的列表基础上进行扩展，添加了一个名为 `game_loop()` 的新函数 ➌。这个函数的任务是当你按下箭头键时，改变 `player_x` 和 `player_y` 变量的值。改变这些变量的值可以移动宇航员角色，因为这些变量决定了宇航员在屏幕上的位置。

在继续之前，我们需要了解两种不同类型的变量。在函数内部改变的变量通常属于该函数，无法被其他函数使用。它们被称为*局部变量*，它们能够有效地防止程序的不同部分意外干扰，从而避免错误的发生。

但是在太空漫步的列表中，我们需要 `draw()` 和 `game_loop()` 函数都使用相同的 `player_x` 和 `player_y` 变量，所以它们需要是*全局变量*，程序的任何部分都可以使用它们。我们在程序的开始部分设置全局变量，放在任何函数之外。

为了告诉 Python `game_loop()` 函数需要使用并修改我们在该函数外部设置的全局变量，我们使用 `global` 命令 ➍。我们把它放在函数的开头，并列出我们想要作为全局变量使用的变量。这样做就像是覆盖了一个安全功能，该功能阻止你修改那些在函数内部没有创建的变量。在 `draw()` 函数中，我们不需要使用 `global`，因为 `draw()` 函数不需要修改那些变量，它只需要查看这些变量的内容。

我们通过 `if` 命令告诉程序使用键盘控制。通过这一指令，我们告诉 Python 仅在某些条件满足时执行某些操作。我们使用四个空格来缩进属于 `if` 命令的指令。这意味着这些指令在 Listing 1-4 中总共缩进了八个空格，因为它们也在 `game_loop()` 函数内部。只有在 `if` 命令后面的条件为真时，这些指令才会执行。如果条件不成立，那么属于 `if` 命令的指令将被跳过。

这样使用空格来表示哪些指令属于同一组可能看起来有些奇怪，尤其是如果你曾经使用过其他编程语言的话，但这种方式使得程序更容易阅读。其他语言通常需要用括号来包围这类指令集合，而 Python 则保持简单。

我们使用 `if` 命令来检查是否按下了右箭头键 ➎。如果按下了，我们通过加 5 来改变 `player_x` 的值 ➏，将宇航员图像向右移动。符号 `+=` 意味着*增加*，因此下面的这一行将 `player_x` 变量中的数字增加了 5：

```py
player_x += 5
```

同样，`-=` 意味着*减少*，因此下面的指令将 `player_x` 中的数字减少了 5：

```py
player_x -= 5
```

如果右箭头键没有被按下，我们检查左箭头键是否被按下。如果是，程序将从`player_x`值中减去 5，向左移动宇航员的位置。为此，我们使用`elif`命令➐，它是“else if”的缩写。你可以把*else*理解为这里的*否则*。用通俗的语言来说，这部分程序意味着：“如果按下右箭头键，向*x*位置加 5。否则，如果按下左箭头键，向*x*位置减 5。”然后我们使用`elif`以同样的方式检查上下箭头键的按下，并改变*y*位置来上下移动宇航员。`draw()`函数使用`player_x`和`player_y`变量表示宇航员的位置，因此更改这些变量中的数字会使宇航员在屏幕上移动。

**提示**

如果你将➑处的`elif`命令改为`if`命令，程序将允许你在移动左右的同时，也能上下移动，实现对角线行走。虽然在太空行走程序中这样做很有趣，但我们稍后会使用类似的代码来移动太空站，那样看起来不自然。

最后一条指令➒设置`game_loop()`函数每 0.03 秒运行一次，使用 Pygame Zero 中的时钟，这样程序就会不断检查你的按键并频繁更改你的位置变量。注意，在这里你不需要在`game_loop`后加上括号。这条指令没有缩进，因为它不属于任何函数。当程序启动时，它会按照列表中从上到下的顺序运行那些不在任何函数中的指令。因此，程序的最后一行是设置完变量后首先运行的指令之一。这一行启动了`game_loop()`函数的运行。

`draw()`函数会在每次需要更新屏幕时自动运行。这是 Pygame Zero 的一个特点。

**训练任务 #4**

让我们为太空服安装一些新的推进器。你能想出如何让宇航员在上下方向上的移动比在左右方向上更快吗？每次按下上下方向键时，太空服应该移动得比按下左右方向键时更多。

在进行太空行走并完成任何必要的修理时，享受令人叹为观止的景色。我们将在第二章重新集合，在那里你将学习一些帮助你在太空中保持安全的程序。

### **你准备好飞行了吗？**

勾选以下框以确认你已经掌握了本章的关键知识。如果你对某个内容不确定，可以翻回本章再看一遍。

![图片](img/box.jpg) 你可以使用 IDLE 的脚本模式来创建一个可以保存、编辑并重新运行的程序。通过选择**文件** ▸ **新建文件**进入脚本模式，或者选择**文件** ▸ **打开**来编辑现有文件。

![图片](img/box.jpg)  字符串是代码中的文本片段。双引号标记字符串的起始和结束。字符串可以包含数字，但它们被视为字母。

![图片](img/box.jpg)  变量存储信息，可以是数字或字符串。

![图片](img/box.jpg)  `print()` 函数在屏幕上输出信息。您可以用它来处理字符串、数字、计算结果或变量的值。

![图片](img/box.jpg)  程序中的 `#` 符号表示注释。Python 忽略 `#` 后同一行的任何内容，注释对您和与您分享代码的其他人都很有用。

![图片](img/box.jpg)  使用 `WIDTH` 和 `HEIGHT` 变量设置游戏窗口的大小。

![图片](img/box.jpg)  要运行 Pygame Zero 程序，请从包含 Python 程序的文件夹中打开命令行，然后在命令行中输入 `pgzrun` 文件名`.py`。

![图片](img/box.jpg)  函数是一组指令，您可以在需要时运行它们。Pygame Zero 使用 `draw()` 函数来绘制或更新游戏屏幕。

![图片](img/box.jpg)  使用 `screen.blit``(`images`.`image_name`, (`x`,` y`))` 在屏幕上的位置 (*x*, *y*) 绘制一幅图像。x 和 y 轴从左上角的 0 开始编号。

![图片](img/box.jpg)  *元组* 是一组用括号括起来的数字或字符串，用逗号分隔。元组的内容一经设置后程序无法更改。

![图片](img/box.jpg)  要结束 Pygame Zero 程序，点击窗口的关闭按钮或在命令行窗口中按下 CTRL-C。

![图片](img/box.jpg)  如果图像重叠，程序中最后绘制的图像将显示在最前面。

![图片](img/box.jpg)  `elif` 命令是“else if”的缩写。使用它来组合 `if` 条件，以便只能运行一个指令集。在我们的程序中，我们用它来阻止玩家同时在两个方向上移动。

![图片](img/box.jpg)  如果我们想在一个函数中更改变量并在另一个函数中使用它，需要使用 *全局变量*。我们在函数外设置它，并在函数内使用 `global` 关键字来更改该变量。

![图片](img/box.jpg)  我们可以使用 Pygame Zero 中的时钟功能定期运行函数。

![图片](img/f0031-01.jpg)
