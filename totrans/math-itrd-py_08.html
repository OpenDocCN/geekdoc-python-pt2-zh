<html><head></head><body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_103"/><span class="big">6</span><br/>CREATING OSCILLATIONS WITH TRIGONOMETRY</h2>&#13;
<p class="epigraph"><em>I’ve got an oscillating fan at my house. The fan goes back and forth. It looks like the fan is saying “No.” So I like to ask it questions that a fan would say “No” to. “Do you keep my hair in place? Do you keep my documents in order? Do you have three settings? Liar!” My fan lied to me.—Mitch Hedberg</em></p>&#13;
<div class="image"><img alt="image" src="../images/fintro-01.jpg"/></div>&#13;
<p class="intro"><em>Trigonometry</em> literally means the study of triangles. Specifically, it is the study of right triangles and the special ratios that exist between their sides. Judging from what’s taught in a traditional trigonometry class, though, you’d think that’s where it ends. <a href="ch06.xhtml#ch06fig1">Figure 6-1</a> shows just one part of a typical trigonometry homework assignment.</p>&#13;
<span epub:type="pagebreak" id="page_104"/>&#13;
<div class="image"><a id="ch06fig1"/><img alt="image" src="../images/f104-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-1: Question after question in traditional trig class on unknown sides in triangles</em></p>&#13;
<p class="indent">This is the kind of task most people remember from their trigonometry class, where solving for unknown sides in a triangle is a common assignment. <em>But this is seldom how trig functions are used in reality</em>. The more common uses of trig functions such as sine and cosine are for oscillating motion, like water, light, and sound waves. Suppose you take your graphing code from <em>grid.pyde</em> in <a href="ch04.xhtml#ch04">Chapter 4</a> and change the function to the following:</p>&#13;
<pre><span class="pd_green1">def</span> f(x):<br/>    <span class="pd_lime">return</span> <span class="pd_blue1">sin</span>(x)</pre>&#13;
<p class="indent">In this case, you’d get this output shown in <a href="ch06.xhtml#ch06fig2">Figure 6-2</a>.</p>&#13;
<div class="image"><a id="ch06fig2"/><img alt="image" src="../images/f104-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-2: A sine wave</em></p>&#13;
<p class="indent">The values on the x-axis are the radians, the input of the sine function. The y-axis is the output. If you put <code>sin(1)</code> into your calculator or the Python <span epub:type="pagebreak" id="page_105"/>shell, you’ll get out a long decimal starting with 0.84. . . . That’s the height of the curve when x = 1. It’s almost at the top of the curve in <a href="ch06.xhtml#ch06fig2">Figure 6-2</a>. Put <code>sin(3)</code> into the calculator and you’ll get 0.14. . . . On the curve, you can see it’s almost on the x-axis when x = 3. Enter any other values for x, and the output should follow this up-and-down pattern, <em>oscillating</em> between 1 and –1. The wave takes just over six units to make a complete wave, or one <em>wavelength</em>, which we also call the <em>period</em> of the function. The period of the sine function is 2π, or 6.28 radians in Processing and Python. In school, you won’t go any further than drawing lots of waves like this. But in this chapter, you’ll use sine, cosine, and tangent to simulate oscillating motion in real time. You’ll also use trigonometry to make some interesting, dynamic, interactive sketches in Processing. The main trig functions are shown in <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>.</p>&#13;
<div class="image"><a id="ch06fig3"/><img alt="image" src="../images/f105-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-3: The ratios of the sides of a right triangle</em></p>&#13;
<p class="indent">We’ll use trig functions to generate polygons of any number of sides as well as stars with any (odd) number of prongs. After that, you’ll create a sine wave from a point rotating around a circle. You’ll draw Spirograph- and harmonograph-type designs, which require trig functions. You’ll also oscillate a wave of colorful points in and out of a circle!</p>&#13;
<p class="indent">Let’s start by discussing how using trig functions is going to make transforming, rotating, and oscillating shapes much easier than before.</p>&#13;
<h3 class="h3" id="ch06_1">USING TRIGONOMETRY FOR ROTATIONS AND OSCILLATIONS</h3>&#13;
<p class="noindent">First of all, sines and cosines make rotations a cinch. In <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>, sin A is expressed as the opposite side divided by the hypotenuse, or side a divided by side c:</p>&#13;
<div class="image"><img alt="image" src="../images/e105-01.jpg"/></div>&#13;
<p class="indent">Solve this for side a, and you get the hypotenuse times the sine of A:</p>&#13;
<p class="center">a = c Sin A</p>&#13;
<p class="indent">Therefore, the y-coordinate of a point can be expressed as the distance from the origin times the sine of the angle the point makes with the <span epub:type="pagebreak" id="page_106"/>horizontal. Imagine a circle with radius r, the hypotenuse of the triangle, rotating around the point at (0,0), as shown in <a href="ch06.xhtml#ch06fig4">Figure 6-4</a>.</p>&#13;
<div class="image"><a id="ch06fig4"/><img alt="image" src="../images/f106-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-4: Polar form of coordinates of a point</em></p>&#13;
<p class="indent">To rotate a point, we’re going to keep the radius of the circle constant and simply vary theta, the angle. The computer is going to do the hard part of recalculating all the positions of the point by multiplying the radius r by the cosine or sine of the angle theta! We also need to remember that sine and cosine expect radian input, not degrees. Fortunately, you’ve already learned how easy it is to use Processing’s built-in <code>radians()</code> and <code>degrees()</code> functions to convert to whatever units we want.</p>&#13;
<h3 class="h3" id="ch06_2">WRITING FUNCTIONS TO DRAW POLYGONS</h3>&#13;
<p class="noindent">Thinking about vertices as points that rotate around a center makes creating polygons very easy. Recall that a polygon is a many-sided figure; a <em>regular polygon</em> is made by connecting a certain number of points equally spaced around a circle. Remember how much geometry we needed to know to draw an equilateral triangle in <a href="ch05.xhtml#ch05">Chapter 5</a>? With trigonometry functions helping us with rotations, all we have to do to draw polygons is use <a href="ch06.xhtml#ch06fig4">Figure 6-4</a> to create a polygon function.</p>&#13;
<p class="indent">Open a new sketch in Processing and save it as <em>polygon.pyde</em>. Then enter the code in <a href="ch06.xhtml#ch06list1">Listing 6-1</a> to make a polygon using by the <code>vertex()</code> function.</p>&#13;
<pre><span class="pd_g1"><em>polygon.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">beginShape</span>()<br/>    <span class="pd_blue1">vertex</span>(100,100)<br/>    <span class="pd_blue1">vertex</span>(100,200)<br/>    <span class="pd_blue1">vertex</span>(200,200)<br/>    <span class="pd_blue1">vertex</span>(200,100)<br/>    <span class="pd_blue1">vertex</span>(150,50)<br/>    <span class="pd_blue1">endShape</span>(<span class="pd_olive">CLOSE</span>)</pre>&#13;
<p class="listing" id="ch06list1"><em>Listing 6-1: Drawing a polygon using <code>vertex()</code></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_107"/>We could always draw polygons using <code>line()</code>, but once we connect all the lines, we couldn’t fill in the shape with color. The Processing functions <code>beginShape()</code> and <code>endShape()</code> define any shape we want by using the <code>vertex()</code> function to say where the points of the shape should be. This lets us create as many vertices as we want.</p>&#13;
<p class="indent">We always start the shape with <code>beginShape()</code>, list all the points on the shape by sending them to the <code>vertex()</code> function, and finally end the shape with <code>endShape()</code>. If we put <code>CLOSE</code> inside the <code>endShape()</code> function, the program will connect the last vertex with the first vertex.</p>&#13;
<p class="indent">When you run this code, you should see something like <a href="ch06.xhtml#ch06fig5">Figure 6-5</a>.</p>&#13;
<div class="image"><a id="ch06fig5"/><img alt="image" src="../images/f107-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-5: A house-shaped polygon made from vertices</em></p>&#13;
<p class="indent">However, it’s laborious to enter more than four or five points manually. It would be great if we could just rotate a single point around another point using a loop. Let’s try that next.</p>&#13;
<h4 class="h4" id="ch06_1_1">DRAWING A HEXAGON WITH LOOPS</h4>&#13;
<p class="noindent">Let’s use a <code>for</code> loop to create six vertices of a hexagon using the code in <a href="ch06.xhtml#ch06list2">Listing 6-2</a>.</p>&#13;
<pre><span class="pd_g1"><em>polygon.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    <span class="pd_blue1">beginShape</span>()<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(6):<br/>        <span class="pd_blue1">vertex</span>(100,100)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(60))<br/>    <span class="pd_blue1">endShape</span>(<span class="pd_olive">CLOSE</span>)</pre>&#13;
<p class="listing" id="ch06list2"><em>Listing 6-2: Trying to use <code>rotate()</code> inside a <code>for</code> loop</em></p>&#13;
<p class="indent">However, you’ll find out that if you run this code, you get a blank screen! You can’t use the <code>rotate()</code> function inside a shape because this function spins the entire coordinate system. This is <em>precisely</em> why we need the sine and cosine notation you saw in <a href="ch06.xhtml#ch06fig4">Figure 6-4</a> to rotate the vertices!</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06fig6">Figure 6-6</a> shows how the expression <code>(r*cos(60*i),r*sin(60*i))</code> creates each vertex of a hexagon. When i = 0, the angle in the parentheses will be 0 degrees; when i = 1, the angle will be 60 degrees; and so on.</p>&#13;
<span epub:type="pagebreak" id="page_108"/>&#13;
<div class="image"><a id="ch06fig6"/><img alt="image" src="../images/f108-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-6: Using sines and cosines to rotate a point around the center</em></p>&#13;
<p class="indent">To re-create this hexagon in code, we have to create a variable, <code>r</code>, that represents the distance from the center of rotation to each vertex, which won’t change. The only thing we need to change is the number of degrees in the <code>sin()</code> and <code>cos()</code> functions, which are all multiples of 60. Generally, it can be written like this:</p>&#13;
<pre><span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(6):<br/>    <span class="pd_blue1">vertex</span>(r*<span class="pd_blue1">cos</span>(60*i),r*<span class="pd_blue1">sin</span>(60*i))</pre>&#13;
<p class="indent">First, we make <code>i</code> go from 0 to 5 so that every vertex will be a multiple of 60 (0, 60, 120, and so on), as shown in <a href="ch06.xhtml#ch06fig7">Figure 6-7</a>. Let’s change <code>r</code> to 100 and convert the degree numbers to radians so the code looks like <a href="ch06.xhtml#ch06list3">Listing 6-3</a>.</p>&#13;
<pre><span class="pd_g1"><em>polygon.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    <span class="pd_blue1">beginShape</span>()<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(6):<br/>        <span class="pd_blue1">vertex</span>(100*<span class="pd_blue1">cos</span>(<span class="pd_blue1">radians</span>(60*i)),<br/>               100*<span class="pd_blue1">sin</span>(<span class="pd_blue1">radians</span>(60*i)))<br/>    <span class="pd_blue1">endShape</span>(<span class="pd_olive">CLOSE</span>)</pre>&#13;
<p class="listing" id="ch06list3"><em>Listing 6-3: Drawing a hexagon</em></p>&#13;
<div class="image"><a id="ch06fig7"/><img alt="image" src="../images/f108-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-7: A hexagon built with a <code>vertex()</code> function and a <code>for</code> loop</em></p>&#13;
<p class="indent">Now that we’ve set <code>r</code> equal to 100 and converted the degrees to radians, when we run this code, we should see a hexagon like in <a href="ch06.xhtml#ch06fig7">Figure 6-7</a>.</p>&#13;
<p class="indent">In fact, we could create a function to make <em>any</em> polygon this way!</p>&#13;
<span epub:type="pagebreak" id="page_109"/>&#13;
<h4 class="h4" id="ch06_1_2">DRAWING AN EQUILATERAL TRIANGLE</h4>&#13;
<p class="noindent">Now let’s make an equilateral triangle using this function. <a href="ch06.xhtml#ch06list4">Listing 6-4</a> shows a simpler way to make an equilateral triangle using looping instead of using square roots like we did in <a href="ch05.xhtml#ch05">Chapter 5</a>.</p>&#13;
<pre><span class="pd_g1"><em>polygon.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    polygon(3,100) <span class="pd_gray">#3 sides, vertices 100 units from the center</span><br/><br/><span class="pd_green1">def</span> polygon(sides,sz):<br/>    <span class="pd_purple">'''draws a polygon given the number</span><br/><span class="pd_purple">    of sides and length from the center'''</span><br/>    <span class="pd_blue1">beginShape</span>()<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(sides):<br/>    step = <span class="pd_blue1">radians</span>(360/sides)<br/>        <span class="pd_blue1">vertex</span>(sz*<span class="pd_blue1">cos</span>(i * step),<br/>               sz*<span class="pd_blue1">sin</span>(i * step))<br/>    <span class="pd_blue1">endShape</span>(<span class="pd_olive">CLOSE</span>)</pre>&#13;
<p class="listing" id="ch06list4"><em>Listing 6-4: Drawing an equilateral triangle</em></p>&#13;
<p class="indent">In this example, we create a <code>polygon()</code> function that draws a polygon given the number of sides (<code>sides</code>) and the size of the polygon (<code>sz</code>). The rotation for each vertex is 360 divided by <code>sides</code>. For our hexagon, we rotate by 60 degrees because there are six sides to a hexagon (360 / 6 = 60). The line <code>polygon(3,100)</code> calls the polygon function and passes two inputs: 3 for the number of sides and 100 for the distance from the center to the vertices.</p>&#13;
<p class="indent">Run this code and you should get what’s shown in <a href="ch06.xhtml#ch06fig8">Figure 6-8</a>.</p>&#13;
<div class="image"><a id="ch06fig8"/><img alt="image" src="../images/f109-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-8: An equilateral triangle!</em></p>&#13;
<p class="indent">Now making regular polygons of any number of sides should be a breeze. No square roots necessary! <a href="ch06.xhtml#ch06fig9">Figure 6-9</a> shows some sample polygons you can make using the <code>polygon()</code> function.</p>&#13;
<span epub:type="pagebreak" id="page_110"/>&#13;
<div class="image"><a id="ch06fig9"/><img alt="image" src="../images/f110-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-9: All the polygons you want!</em></p>&#13;
<p class="indent">Try updating the numbers in <code>polygon(3,100)</code> to see how the polygons change shape!</p>&#13;
<h3 class="h3" id="ch06_3">MAKING SINE WAVES</h3>&#13;
<p class="noindent">Like Mitch Hedberg’s fan at the beginning of the chapter, sines and cosines are for rotating and oscillating. Sine and cosine functions make waves when the height of a point on a circle is measured over time. To make this more concrete, let’s create a circle to visualize making sine waves by putting a point (shown as a red ellipse) on the circumference of the circle. As this point travels around the circle, its height over time will draw out a sine wave.</p>&#13;
<p class="indent">Start a new Processing sketch and save it as <em>CircleSineWave.pyde</em>. Create a big circle on the left side of the screen, like in <a href="ch06.xhtml#ch06fig10">Figure 6-10</a>. Try it yourself before looking at the code.</p>&#13;
<div class="image"><a id="ch06fig10"/><img alt="image" src="../images/f110-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-10: The start of the sine wave sketch</em></p>&#13;
<span epub:type="pagebreak" id="page_111"/>&#13;
<p class="indent">Listing 6-5 shows the code to make the sketch of a red point on the circumference of a big circle.</p>&#13;
<pre><span class="pd_g1"><em>CircleSineWave.pyde</em></span><br/>r1 = 100 <span class="pd_gray">#radius of big circle</span><br/>r2 = 10  <span class="pd_gray">#radius of small circle</span><br/>t = 0 <span class="pd_gray">#time variable</span><br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(200)<br/>    <span class="pd_gray">#move to left-center of screen</span><br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/4,<span class="pd_raspberry">height</span>/2)<br/>    <span class="pd_blue1">noFill</span>() <span class="pd_gray">#don't color in the circle</span><br/>    <span class="pd_blue1">stroke</span>(0) <span class="pd_gray">#black outline</span><br/>    <span class="pd_blue1">ellipse</span>(0,0,2*r1,2*r1)<br/><br/>    <span class="pd_gray">#circling ellipse:</span><br/>    <span class="pd_blue1">fill</span>(255,0,0) <span class="pd_gray">#red</span><br/>    y = r1*<span class="pd_blue1">sin</span>(t)<br/>    x = r1*<span class="pd_blue1">cos</span>(t)<br/>    <span class="pd_blue1">ellipse</span>(x,y,r2,r2)</pre>&#13;
<p class="listing" id="ch06list5"><em>Listing 6-5: Our circle and the point</em></p>&#13;
<p class="indent">First, we declare variables for the radii of the circles, and we use <code>t</code> to represent the time it takes to make the point move. In <code>draw()</code>, we set the background to <code>gray(200)</code>, translated to the center of the screen, and draw the big circle with radius <code>r1</code>. Next, we draw the circling ellipse by using our polar coordinates for x and y.</p>&#13;
<p class="indent">To make the ellipse rotate around the circle, all we have to do is vary the number inside the trig functions (in this case, <code>t</code>). At the end of the <code>draw()</code> function, we simply make the time variable go up by a little bit, like this:</p>&#13;
<pre>    t += 0.05</pre>&#13;
<p class="indent">If you try to run this code right now, you’ll get an error message about <code>local variable 't' referenced before assignment</code>. Python functions have local variables, but we want the <code>draw()</code> function to use the global time variable <code>t</code>. Therefore, we have to add the following line to the beginning of the <code>draw()</code> function:</p>&#13;
<pre><span class="pd_blue1">global</span> t</pre>&#13;
<p class="indent">Now you’ll see a red ellipse traveling along the circumference of the circle, as in <a href="ch06.xhtml#ch06fig11">Figure 6-11</a>.</p>&#13;
<span epub:type="pagebreak" id="page_112"/>&#13;
<div class="image"><a id="ch06fig11"/><img alt="image" src="../images/f112-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-11: The red ellipse travels along the circumference of the big circle</em>.</p>&#13;
<p class="indent">Now we need to choose a place over to the right of the screen to start drawing the wave. We’ll extend a green line from the red ellipse to, say, x = 200. Add these lines to your <code>draw()</code> function right before <code>t += 0.05</code>. The full code for drawing the sine wave should look like <a href="ch06.xhtml#ch06list6">Listing 6-6</a>.</p>&#13;
<pre><span class="pd_g1"><em>CircleSineWave.pyde</em></span><br/>r1 = 100 <span class="pd_gray">#radius of big circle</span><br/>r2 = 10  <span class="pd_gray">#radius of small circle</span><br/>t = 0 <span class="pd_gray">#time variable</span><br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_green1">global</span> t<br/>    <span class="pd_blue1">background</span>(200)<br/>    <span class="pd_gray">#move to left-center of screen</span><br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/4,<span class="pd_raspberry">height</span>/2)<br/>    <span class="pd_blue1">noFill</span>() <span class="pd_gray">#don't color in the circle</span><br/>    <span class="pd_blue1">stroke</span>(0) <span class="pd_gray">#black outline</span><br/>    <span class="pd_blue1">ellipse</span>(0,0,2*r1,2*r1)<br/>    <span class="pd_gray">#circling ellipse:</span><br/>    <span class="pd_blue1">fill</span>(255,0,0) <span class="pd_gray">#red</span><br/>    y = r1*<span class="pd_blue1">sin</span>(t)<br/>    x = r1*<span class="pd_blue1">cos</span>(t)<br/>    <span class="pd_blue1">ellipse</span>(x,y,r2,r2)<br/>    <span class="pd_blue1">stroke</span>(0,255,0) <span class="pd_gray">#green for the line</span><br/>    <span class="pd_blue1">line</span>(x,y,200,y)<br/>    <span class="pd_blue1">fill</span>(0,255,0) <span class="pd_gray">#green for the ellipse</span><br/>    <span class="pd_blue1">ellipse</span>(200,y,10,10)<br/><br/>    t += 0.05</pre>&#13;
<p class="listing" id="ch06list6"><em>Listing 6-6: Adding a line to draw the wave</em></p>&#13;
<p class="indent">Here, we draw a green line on the same height (y-value) as the rotating red ellipse. This green line stays parallel to the horizontal, so as the <span epub:type="pagebreak" id="page_113"/>red ellipse goes up and down, the green ellipse will be at the same height. When you run your program, you’ll see something like <a href="ch06.xhtml#ch06fig12">Figure 6-12</a>.</p>&#13;
<div class="image"><a id="ch06fig12"/><img alt="image" src="../images/f113-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-12: Getting ready to draw the wave!</em></p>&#13;
<p class="indent">You can see that we’ve added a green ellipse that only measures how far up and down the red ellipse moves, nothing else.</p>&#13;
<h4 class="h4" id="ch06_1_3">LEAVING A TRAIL</h4>&#13;
<p class="noindent">Now we want the green ellipse to leave a trail to show its height over time. Leaving a trail really means that we save all the heights and display them—every loop. To save a bunch of things, like numbers, letters, words, points, and so on, we need a <em>list</em>. Add this line to the variables we declared at the beginning of the program, before the <code>setup()</code> function:</p>&#13;
<pre>circleList = []</pre>&#13;
<p class="indent">This creates an empty list in which we’ll save the locations of the green ellipse. Add the <code>circleList</code> variable to the <code>global</code> line in the <code>draw()</code> function:</p>&#13;
<pre><span class="pd_blue1">global</span> t, circleList</pre>&#13;
<p class="indent">After we calculate x and y in the <code>draw()</code> function, we need to add the y-coordinate to the <code>circleList</code>, but there are a couple of different ways to do this. You already know the <code>append()</code> function, but this adds the point at the end of the list. We could use Python’s <code>insert()</code> function to put the new points at the beginning of the list, like so:</p>&#13;
<pre>circleList.insert(0,y)</pre>&#13;
<p class="indent">However, the list is going to get bigger every loop. We could limit its length to 250 by adding the new value to the first 249 items already in the list, as shown in <a href="ch06.xhtml#ch06list7">Listing 6-7</a>.</p>&#13;
<pre>    <span class="pd_gray">y = r1*sin(t)</span><br/>    <span class="pd_gray">x = r1*cos(t)</span><br/>    <span class="pd_gray">#add point to list:</span><br/>    circleList = [y] + circleList[:249]</pre>&#13;
<p class="listing" id="ch06list7"><em>Listing 6-7: Adding a point to a list and limiting the list to 250 points</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_114"/>The new line of code concatenates the list containing the y-value we just calculated and the first 249 items in the <code>circleList</code>. That 250-point list now becomes the new <code>circleList</code>.</p>&#13;
<p class="indent">At the end of the <code>draw()</code> function (before incrementing <code>t</code>), we’ll put in a loop that iterates over all the elements of the <code>circleList</code> and draws a new ellipse, to look like the green ellipse is leaving a trail. This is shown in <a href="ch06.xhtml#ch06list8">Listing 6-8</a>.</p>&#13;
<pre>    <span class="pd_gray">#loop over circleList to leave a trail:</span><br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(<span class="pd_blue1">len</span>(circleList)):<br/>        <span class="pd_gray">#small circle for trail:</span><br/>        <span class="pd_blue1">ellipse</span>(200+i,circleList[i],5,5)</pre>&#13;
<p class="listing" id="ch06list8"><em>Listing 6-8: Looping over the circle list and drawing an ellipse at each point in the list</em></p>&#13;
<p class="indent">This code uses a loop, with <code>i</code> going up from 0 to the length of the <code>circleList</code> and drawing an ellipse for each point in the list. The x-value starts at 200 and is incremented by whatever value <code>i</code> is. The y-value of the ellipse is the y-value we saved to the <code>circleList</code>.</p>&#13;
<p class="indent">When you run this, you’ll see something like <a href="ch06.xhtml#ch06fig13">Figure 6-13</a>.</p>&#13;
<div class="image"><a id="ch06fig13"/><img alt="image" src="../images/f114-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-13: A sine wave!</em></p>&#13;
<p class="indent">You can see the wave being drawn out, leaving a green trail.</p>&#13;
<h4 class="h4" id="ch06_1_4">USING PYTHON’S BUILT-IN ENUMERATE() FUNCTION</h4>&#13;
<p class="noindent">You can also draw an ellipse at each point in the list using Python’s built-in <code>enumerate()</code> function. It’s a handy and more “Pythonic” way of keeping track of the index and value of the items in a list. To see this in action, open a new file in IDLE and enter the code in <a href="ch06.xhtml#ch06list9">Listing 6-9</a>.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">myList = [</span><span class="pd_green">"I"</span><span class="codestrong1">,</span><span class="pd_green">"love"</span><span class="codestrong1">,</span><span class="pd_green">"using"</span><span class="codestrong1">,</span><span class="pd_green">"Python"</span><span class="codestrong1">]</span><br/>&gt;&gt;&gt; <span class="pd_orange">for</span> <span class="codestrong1">index, value</span> <span class="pd_orange">in</span><span class="codestrong1"/> <span class="pd_purple">enumerate</span><span class="codestrong1">(myList):</span><br/>        <span class="pd_purple">print</span><span class="codestrong1">(index,value)</span><br/><br/><span class="pd_blue">0 I</span><br/><span class="pd_blue">1 love</span><br/><span class="pd_blue">2 using</span><br/><span class="pd_blue">3 Python</span></pre>&#13;
<p class="listing" id="ch06list9"><em>Listing 6-9: Learning to use Python’s <code>enumerate()</code> function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_115"/>You’ll notice there are two variables (index and value) instead of just one (<code>i</code>). To use the <code>enumerate()</code> function in your circle list, you can use two variables to keep track of the iterator (<code>i</code>, the index) and the circle (<code>c</code>, the value), like in <a href="ch06.xhtml#ch06list10">Listing 6-10</a>.</p>&#13;
<pre>    <span class="pd_gray">#loop over circleList to leave a trail:</span><br/>    <span class="pd_lime">for</span> i,c <span class="pd_green1">in</span> enumerate(circleList):<br/>        <span class="pd_gray">#small circle for trail:</span><br/>        <span class="pd_blue1">ellipse</span>(200+i,c,5,5)</pre>&#13;
<p class="listing" id="ch06list10"><em>Listing 6-10: Using <code>enumerate()</code> to get the index and the value of every item in a list</em></p>&#13;
<p class="indent">The final code should look like what you see in <a href="ch06.xhtml#ch06list11">Listing 6-11</a>.</p>&#13;
<pre><span class="pd_g1"><em>CircleSineWave.pyde</em></span><br/>r1 = 100 <span class="pd_gray">#radius of big circle</span><br/>r2 = 10  <span class="pd_gray">#radius of small circle</span><br/>t = 0 <span class="pd_gray">#time variable</span><br/>circleList = []<br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_green1">global</span> t, circleList<br/>    <span class="pd_blue1">background</span>(200)<br/>    <span class="pd_gray">#move to left-center of screen</span><br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/4,<span class="pd_raspberry">height</span>/2)<br/>    <span class="pd_blue1">noFill</span>() <span class="pd_gray">#don't color in the circle</span><br/>    <span class="pd_blue1">stroke</span>(0) <span class="pd_gray">#black outline</span><br/>    <span class="pd_blue1">ellipse</span>(0,0,2*r1,2*r1)<br/>    <span class="pd_gray">#circling ellipse:</span><br/>    <span class="pd_blue1">fill</span>(255,0,0) <span class="pd_gray">#red</span><br/>    y = r1*<span class="pd_blue1">sin</span>(t)<br/>    x = r1*<span class="pd_blue1">cos</span>(t)<br/>    <span class="pd_gray">#add point to list:</span><br/>    circleList = [y] + circleList[:245]<br/>    <span class="pd_blue1">ellipse</span>(x,y,r2,r2)<br/>    <span class="pd_blue1">stroke</span>(0,255,0) <span class="pd_gray">#green for the line</span><br/>    <span class="pd_blue1">line</span>(x,y,200,y)<br/>    <span class="pd_blue1">fill</span>(0,255,0) <span class="pd_gray">#green for the ellipse</span><br/>    <span class="pd_blue1">ellipse</span>(200,y,10,10)<br/><span epub:type="pagebreak" id="page_116"/>&#13;
    <span class="pd_gray">#loop over circleList to leave a trail:</span><br/>    <span class="pd_lime">for</span> i,c <span class="pd_green1">in</span> enumerate(circleList):<br/>        <span class="pd_gray">#small circle for trail:</span><br/>        <span class="pd_blue1">ellipse</span>(200+i,c,5,5)<br/><br/>    t += 0.05</pre>&#13;
<p class="listing" id="ch06list11"><em>Listing 6-11: The final code for the</em> CircleSineWave.pyde <em>sketch</em></p>&#13;
<p class="indent">This is the animation that’s usually shown to beginning trig students, and you’ve made your own version!</p>&#13;
<h3 class="h3" id="ch06_4">CREATING A SPIROGRAPH PROGRAM</h3>&#13;
<p class="noindent">Now that you know how to rotate circles and leave trails, let’s make a Spirograph-type model! <em>Spirograph</em> is a toy that’s made up of two overlapping circular gears that slide against each other. The gears have holes you can put pens and pencils through to draw cool, curvy designs. Many people played with Spirograph as kids, drawing the designs by hand. But we can make Spirograph-type designs using a computer and the sine and cosine code you just learned.</p>&#13;
<p class="indent">First, start a new sketch in Processing called <em>spirograph.pyde</em>. Then add the code in <a href="ch06.xhtml#ch06list12">Listing 6-12</a>.</p>&#13;
<pre><span class="pd_g1"><em>spirograph.pyde</em></span><br/>r1 = 300.0 <span class="pd_gray">#radius of big circle</span><br/>r2 = 175.0 <span class="pd_gray">#radius of circle 2</span><br/>r3 = 5.0   <span class="pd_gray">#radius of drawing "dot"</span><br/><span class="pd_gray">#location of big circle:</span><br/>x1 = 0<br/>y1 = 0<br/>t = 0 <span class="pd_gray">#time variable</span><br/>points = [] <span class="pd_gray">#empty list to put points in</span><br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_green1">global</span> r1,r2,x1,y1,t<br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">noFill</span>()<br/>    <span class="pd_gray">#big circle</span><br/>    <span class="pd_blue1">stroke</span>(0)<br/>    <span class="pd_blue1">ellipse</span>(x1,y1,2*r1,2*r1)</pre>&#13;
<p class="listing" id="ch06list12"><em>Listing 6-12: Getting our big circle on the screen</em></p>&#13;
<p class="indent">We first put a big circle in the middle of the screen and create variables for the big circle, and then we put a smaller circle on its circumference, like the discs in a Spirograph set.</p>&#13;
<h4 class="h4" id="ch06_1_5"><span epub:type="pagebreak" id="page_117"/>DRAWING THE SMALLER CIRCLE</h4>&#13;
<p class="noindent">Let’s place the smaller circle on the circumference of the big circle, as in <a href="ch06.xhtml#ch06fig14">Figure 6-14</a>.</p>&#13;
<div class="image"><a id="ch06fig14"/><img alt="image" src="../images/f117-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-14: The two circles</em></p>&#13;
<p class="indent">Next, we’ll make the smaller circle rotate around “inside” the bigger circle, just like a Spirograph gear. Update the code in <a href="ch06.xhtml#ch06list12">Listing 6-12</a> with the code in <a href="ch06.xhtml#ch06list13">Listing 6-13</a> to draw the second circle.</p>&#13;
<pre><span class="pd_gray">    #big circle</span><br/><span class="pd_gray">    stroke(0)</span><br/><span class="pd_gray">    ellipse(x1,y1,2*r1,2*r1)</span><br/><br/>    <span class="pd_gray">#circle 2</span><br/>    x2 = (r1 - r2)<br/>    y2 = 0<br/>    <span class="pd_blue1">ellipse</span>(x2,y2,2*r2,2*r2)</pre>&#13;
<p class="listing" id="ch06list13"><em>Listing 6-13: Adding the smaller circle</em></p>&#13;
<p class="indent">To make the smaller circle rotate around inside the bigger circle, we need to add the sine and cosine parts to the location of “circle 2” so it’ll oscillate.</p>&#13;
<h4 class="h4" id="ch06_1_6">ROTATING THE SMALLER CIRCLE</h4>&#13;
<p class="noindent">Finally, at the very end of the <code>draw()</code> function, we have to increment our time variable, <code>t</code>, as in <a href="ch06.xhtml#ch06list14">Listing 6-14</a>.</p>&#13;
<pre><span class="pd_gray">    #big circle</span><br/>    <span class="pd_gray">stroke(0)</span><br/>    <span class="pd_gray">ellipse(x1,y1,2*r1,2*r1)</span><br/><span epub:type="pagebreak" id="page_118"/>&#13;
<br/>    <span class="pd_gray">#circle 2</span><br/>    x2 = (r1 - r2)*<span class="pd_blue1">cos</span>(t)<br/>    y2 = (r1 - r2)*<span class="pd_blue1">sin</span>(t)<br/>    <span class="pd_gray">ellipse(x2,y2,2*r2,2*r2)</span><br/>    t += 0.05</pre>&#13;
<p class="listing" id="ch06list14"><em>Listing 6-14: The code to make the circle rotate</em></p>&#13;
<p class="indent">This means circle 2 will oscillate up and down, and left and right, in a circular path inside the big circle. Run the code, and you should see circle 2 spinning nicely! But how about that hole on the gear where the pen sits and draws the trail? We’ll create a third ellipse to represent that point. Its location will be the second circle’s center plus the difference of the radii. The code for the “drawing dot” is shown in <a href="ch06.xhtml#ch06list15">Listing 6-15</a>.</p>&#13;
<pre>    <span class="pd_gray">#drawing dot</span><br/>    x3 = x2+(r2 - r3)*<span class="pd_blue1">cos</span>(t)<br/>    y3 = y2+(r2 - r3)*<span class="pd_blue1">sin</span>(t)<br/>    <span class="pd_blue1">fill</span>(255,0,0)<br/>    <span class="pd_blue1">ellipse</span>(x3,y3,2*r3,2*r3)</pre>&#13;
<p class="listing" id="ch06list15"><em>Listing 6-15: Adding the drawing dot</em></p>&#13;
<p class="indent">When you run this code, you’ll see the drawing dot right on the edge of circle 2, rotating as if circle 2 were sliding along circle 1’s circumference. Circle 3 (the drawing dot) has to be a certain proportion between the center of circle 2 and its circumference, so we need to introduce a proportion variable (<code>prop</code>) before the <code>setup()</code> function. Be sure to declare it as a global variable at the beginning of the <code>draw()</code> function, as you see in <a href="ch06.xhtml#ch06list16">Listing 6-16</a>.</p>&#13;
<pre>prop = 0.9<br/><em>--snip--</em><br/><br/><span class="pd_green1">global</span> r1,r2,x1,y1,t,prop<br/><em>--snip--</em><br/><br/>x3 = x2+prop*(r2 - r3)*<span class="pd_blue1">cos</span>(t)<br/>y3 = y2+prop*(r2 - r3)*<span class="pd_blue1">sin</span>(t)</pre>&#13;
<p class="listing" id="ch06list16"><em>Listing 6-16: Adding the proportion variable</em></p>&#13;
<p class="indent">Now we have to figure out how fast the drawing dot rotates. It only takes a little algebra to prove its angular velocity (how fast it spins around) is the ratio of the size of the big circle to the little circle. Note that the negative sign means the dot spins in the opposite direction. Change the <code>x3</code> and <code>y3</code> lines in the <code>draw()</code> function to this:</p>&#13;
<pre>x3 = x2+prop*(r2 - r3)*<span class="pd_blue1">cos</span>(-((r1-r2)/r2)*t)<br/>y3 = y2+prop*(r2 - r3)*<span class="pd_blue1">sin</span>(-((r1-r2)/r2)*t)</pre>&#13;
<span epub:type="pagebreak" id="page_119"/>&#13;
<p class="indent">All that’s left is to save the dot <code>(x3,y3)</code> to a <code>points</code> list and draw lines between the points, just like we did in the wave sketch. Add the <code>points</code> list to the global line:</p>&#13;
<pre><span class="pd_green1">global</span> r1,r2,x1,y1,t,prop,points</pre>&#13;
<p class="indent">After drawing the third ellipse, put the points into a list. This is the same procedure we used in <em>CircleSineWave.pyde</em> earlier in the chapter. Finally, go through the list and draw lines between the points, as in <a href="ch06.xhtml#ch06list17">Listing 6-17</a>.</p>&#13;
<pre><span class="pd_gray">    fill(255,0,0)</span><br/>    <span class="pd_gray">ellipse</span><span class="pd_gray">(x3,y3,2*r3,2*r3)</span><br/>    <span class="pd_gray">#add points to list</span><br/>    points = [[x3, y3]] + points[:2000]<br/>    <span class="pd_lime">for</span> i,p <span class="pd_green1">in</span> enumerate(points): <span class="pd_gray">#go through the points list</span><br/>        <span class="pd_lime">if</span> i &lt; <span class="pd_blue1">len</span>(points)-1: <span class="pd_gray">#up to the next to last point</span><br/>            <span class="pd_blue1">stroke</span>(255,0,0) <span class="pd_gray">#draw red lines between the points</span><br/>            <span class="pd_blue1">line</span>(p[0],p[1],points[i+1][0],points[i+1][1])<br/><br/>    t += 0.05</pre>&#13;
<p class="listing" id="ch06list17"><em>Listing 6-17: Graphing the points in the Spirograph</em></p>&#13;
<p class="indent">We used a similar trick for adding the points to the list in the circular wave example. We concatenated a list with the current point in it to a list with 2000 of the items in the <code>circleList</code>. This automatically limits the number of points we’re saving to the points list. Run this code and watch the program draw a Spirograph, as shown in <a href="ch06.xhtml#ch06fig15">Figure 6-15</a>.</p>&#13;
<div class="image"><a id="ch06fig15"/><img alt="image" src="../images/f119-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-15: Drawing the Spirograph</em></p>&#13;
<p class="indent">You can change the size of the second circle (<code>r2</code>) and the position of the drawing dot (<code>prop</code>) to draw different designs. For example, the Spirograph in <a href="ch06.xhtml#ch06fig16">Figure 6-16</a> has <code>r2</code> equal to 105 and <code>prop</code> equal to 0.8.</p>&#13;
<span epub:type="pagebreak" id="page_120"/>&#13;
<div class="image"><a id="ch06fig16"/><img alt="image" src="../images/f120-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-16: Another Spirograph design, created by changing <code>r2</code> and <code>prop</code></em></p>&#13;
<p class="indent">So far, we’ve been making shapes oscillate up and down, or left and right, using sine and cosine, but what about making shapes oscillate in two different directions? We’ll try that next.</p>&#13;
<h3 class="h3" id="ch06_5">MAKING HARMONOGRAPHS</h3>&#13;
<p class="noindent">In the 1800s, there was an invention called the <em>harmonograph</em> that was a table connected to two pendulums. When the pendulums swung, the attached pen would draw on a piece of paper. As the pendulums swung back and forth and died down (<em>decayed</em>), the patterns would change in interesting ways, as illustrated in <a href="ch06.xhtml#ch06fig17">Figure 6-17</a>.</p>&#13;
<div class="image"><a id="ch06fig17"/><img alt="image" src="../images/f120-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-17: Harmonograph machine and design</em></p>&#13;
<span epub:type="pagebreak" id="page_121"/>&#13;
<p class="indent">Using programming and a few equations, we can model how a harmonograph draws its patterns. The equations to model the oscillation of one pendulum are</p>&#13;
<div class="image"><img alt="image" src="../images/e121-01.jpg"/></div>&#13;
<p class="indent">In these equations, <em>x</em> and <em>y</em> represent the horizontal and vertical displacement left/right and up/down distance) of the pen, respectively. Variable <em>a</em> is the amplitude (size) of the motion, <em>f</em> is the frequency of the pendulum, <em>t</em> is the elapsed time, <em>p</em> is the phase shift, e is the base of the natural logarithms (it’s a constant, around 2.7), and <em>d</em> is the decay factor (how fast the pendulum slows down). The time variable, <em>t</em>, will of course be the same in both of these equations, but all the other variables can be different: the left/right frequency can be different from the up/down frequency, for example.</p>&#13;
<h4 class="h4" id="ch06_1_7">WRITING THE HARMONOGRAPH PROGRAM</h4>&#13;
<p class="noindent">Let’s create a Python-Processing sketch that models the movement of a pendulum. Create a new Processing sketch and call it <em>harmonograph.pyde</em>. The initial code is shown in <a href="ch06.xhtml#ch06list18">Listing 6-18</a>.</p>&#13;
<pre><span class="pd_g1"><em>harmonograph.pyde</em></span><br/>t = 0<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    <span class="pd_blue1">noStroke</span>()<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>      <span class="pd_green1">global</span> t<br/>    <span class="ent">➊</span> a1,a2 = 100,200 <span class="pd_gray">#amplitudes</span><br/>      f1,f2 = 1,2 <span class="pd_gray">#frequencies</span><br/>      p1,p2 = 0,<span class="pd_olive">PI</span>/2 <span class="pd_gray">#phase shifts</span><br/>      d1,d2 = 0.02,0.02 <span class="pd_gray">#decay constants</span><br/>      <span class="pd_blue1">background</span>(255)<br/>      <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    <span class="ent">➋</span> x = a1*<span class="pd_blue1">cos</span>(f1*t + p1)*<span class="pd_blue1">exp</span>(-d1*t) <br/>      y = a2*<span class="pd_blue1">cos</span>(f2*t + p2)*<span class="pd_blue1">exp</span>(-d2*t)<br/>      <span class="pd_blue1">fill</span>(0) <span class="pd_gray">#black</span><br/>      <span class="pd_blue1">ellipse</span>(x,y,5,5)<br/>      t += .1</pre>&#13;
<p class="listing" id="ch06list18"><em>Listing 6-18: The initial code for the harmonograph sketch</em></p>&#13;
<p class="indent">This is just the usual <code>setup()</code> and <code>draw()</code> functions with a time variable (<code>t</code>) and values for the amplitude (<code>a1,a2</code>), frequency (<code>f1,f2</code>), phase shift (<code>p1,p2</code>), and decay constants (<code>d1,d2</code>).</p>&#13;
<p class="indent">Then, starting at <span class="ent">➊</span>, we define a bunch of variables to plug into the two formulas for the location of the harmonograph drawing pen. The <code>x =</code> and <code>y =</code> lines <span class="ent">➋</span> use those variables and calculate the coordinates for the ellipse.</p>&#13;
<span epub:type="pagebreak" id="page_122"/>&#13;
<p class="indent">Now run this code, and you should see the circle moving, but what is it drawing? We need to put the points in a list and then graph all the points in the list. Right after declaring the <code>t</code> variable, create a list called <code>points</code>. The code so far is shown in <a href="ch06.xhtml#ch06list19">Listing 6-19</a>.</p>&#13;
<pre><span class="pd_g1"><em>harmonograph.pyde</em></span><br/>t = 0<br/>points = []<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    <span class="pd_blue1">noStroke</span>()<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_green1">global</span> t,points<br/>    a1,a2 = 100,200<br/>    f1,f2 = 1,2<br/>    p1,p2 = 0,<span class="pd_olive">PI</span>/2<br/>    d1,d2 = 0.02,0.02<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    x = a1*<span class="pd_blue1">cos</span>(f1*t + p1)*<span class="pd_blue1">exp</span>(-d1*t)<br/>    y = a2*<span class="pd_blue1">cos</span>(f2*t + p2)*<span class="pd_blue1">exp</span>(-d2*t)<br/>    <span class="pd_gray">#save location to points List</span><br/>    points.<span class="pd_blue1">append</span>([x,y])<br/>    <span class="pd_gray">#go through points list and draw lines between them</span><br/>    <span class="pd_lime">for</span> i,p <span class="pd_green1">in</span> enumerate(points):<br/>        <span class="pd_blue1">stroke</span>(0) <span class="pd_gray">#black</span><br/>        <span class="pd_lime">if</span> i &lt; <span class="pd_blue1">len</span>(points) - 1:<br/>            <span class="pd_blue1">line</span>(p[0],p[1],points[i+1][0],points[i+1][1])<br/>    t += .1</pre>&#13;
<p class="listing" id="ch06list19"><em>Listing 6-19: The code to draw a harmonograph using lines between points</em></p>&#13;
<div class="image"><a id="ch06fig18"/><img alt="image" src="../images/f122-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-18: The harmonograph</em></p>&#13;
<p class="indent">We start by defining the <code>points</code> list at the top of the file and adding points to the global variables in the <code>draw()</code> function. After calculating where <code>x</code> and <code>y</code> are, we add the line to add the point <code>[x,y]</code> to the <code>points</code> list. Finally, we go through the <code>points</code> list and draw a line from each point to the next one. Then we use Python’s <code>enumerate()</code> function and stop one point before the last one. This is so we don’t get an error message telling us the index is out of range when it tries to draw a line from the last point to the next one. Now when we run the code, we see the dot leave a trail behind it, as in <a href="ch06.xhtml#ch06fig18">Figure 6-18</a>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_123"/>Notice if you comment out the decay part of the formulas, like this, the program will simply draw over the same lines:</p>&#13;
<pre>    x = a1*<span class="pd_blue1">cos</span>(f1*t + p1)<span class="pd_gray">#*exp(-d1*t)</span><br/>    y = a2*<span class="pd_blue1">cos</span>(f2*t + p2)<span class="pd_gray">#*exp(-d2*t)</span></pre>&#13;
<p class="indent">The decay models the gradual decrease in a pendulum’s maximum amplitude, and it’s what creates the “scalloped” effect of so many harmonograph images. The first few times it’s cool to watch the code draw the design, but it takes a while. What if we could fill the <code>points</code> list all at once?</p>&#13;
<h4 class="h4" id="ch06_1_8">FILLING THE LIST INSTANTLY</h4>&#13;
<p class="noindent">Instead of drawing the whole list at every frame, let’s come up with a way to fill the list instantly. We can cut the whole harmonograph code out of the <code>draw()</code> function and paste it into its own function, like in <a href="ch06.xhtml#ch06list20">Listing 6-20</a>.</p>&#13;
<pre><span class="pd_green1">def</span> harmonograph(t):<br/>    a1,a2 = 100,200<br/>    f1,f2 = 1,2<br/>    p1,p2 = <span class="pd_olive">PI</span>/6,<span class="pd_olive">PI</span>/2<br/>    d1,d2 = 0.02,0.02<br/>    x = a1*<span class="pd_blue1">cos</span>(f1*t + p1)*<span class="pd_blue1">exp</span>(-d1*t)<br/>    y = a2*<span class="pd_blue1">cos</span>(f2*t + p2)*<span class="pd_blue1">exp</span>(-d2*t)<br/>    <span class="pd_lime">return</span> [x,y]</pre>&#13;
<p class="listing" id="ch06list20"><em>Listing 6-20: Separating out the <code>harmonograph()</code> function</em></p>&#13;
<p class="indent">Now in the <code>draw()</code> function, you just need a loop where you add a bunch of points for values of <code>t</code>, as in <a href="ch06.xhtml#ch06list21">Listing 6-21</a>.</p>&#13;
<pre><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    points = []<br/>    t = 0<br/>    <span class="pd_lime">while</span> t &lt; 1000:<br/>        points.<span class="pd_blue1">append</span>(harmonograph(t))<br/>        t += 0.01<br/><br/>    <span class="pd_gray">#go through points list and draw lines between them</span><br/>    <span class="pd_lime">for</span> i,p <span class="pd_green1">in</span> enumerate(points):<br/>        <span class="pd_blue1">stroke</span>(0) <span class="pd_gray">#black</span><br/>        <span class="pd_lime">if</span> i &lt; len(points) - 1:<br/>            <span class="pd_blue1">line</span>(p[0],p[1],points[i+1][0],points[i+1][1])</pre>&#13;
<p class="listing" id="ch06list21"><em>Listing 6-21: The new <code>draw()</code> function, which calls the <code>harmonograph()</code> function</em></p>&#13;
<p class="indent">Run this code and you’ll instantly see a complete harmonograph! Because we changed the size of the ellipses and the phase shifts, this one looks different, as you can see in <a href="ch06.xhtml#ch06fig19">Figure 6-19</a>. Change each of the values yourself and see how this changes the design!</p>&#13;
<span epub:type="pagebreak" id="page_124"/>&#13;
<div class="image"><a id="ch06fig19"/><img alt="image" src="../images/f124-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-19: Using a different formula to make the harmonograph</em></p>&#13;
<h4 class="h4" id="ch06_1_9">TWO PENDULUMS ARE BETTER THAN ONE</h4>&#13;
<p class="noindent">We can add another pendulum to make more complicated designs by adding another term to each formula, like this:</p>&#13;
<pre>    x = a1*<span class="pd_blue1">cos</span>(f1*t + p1)*<span class="pd_blue1">exp</span>(-d1*t) + a3*<span class="pd_blue1">cos</span>(f3*t + p3)*<span class="pd_blue1">exp</span>(-d3*t)<br/>    y = a2*<span class="pd_blue1">sin</span>(f2*t + p2)*<span class="pd_blue1">exp</span>(-d2*t) + a4*<span class="pd_blue1">sin</span>(f4*t + p4)*<span class="pd_blue1">exp</span>(-d4*t)</pre>&#13;
<p class="indent">All this does is add identical code to each line, with a few numbers changed, to simulate more than one pendulum in each direction. Of course, you have to create more variables and give them values. In <a href="ch06.xhtml#ch06list22">Listing 6-22</a> are my suggestions for copying one of the designs I found at <em><a href="http://www.walkingrandomly.com/?p=151">http://www.walkingrandomly.com/?p=151</a></em>.</p>&#13;
<pre><span class="pd_green1">def</span> harmonograph(t):<br/>    a1=a2=a3=a4 = 100<br/>    f1,f2,f3,f4 = 2.01,3,3,2<br/>    p1,p2,p3,p4 = -<span class="pd_olive">PI</span>/2,0,-<span class="pd_olive">PI</span>/16,0<br/>    d1,d2,d3,d4 = 0.00085,0.0065,0,0<br/>    x = a1*<span class="pd_blue1">cos</span>(f1*t + p1)*<span class="pd_blue1">exp</span>(-d1*t) + a3*<span class="pd_blue1">cos</span>(f3*t + p3)*<span class="pd_blue1">exp</span>(-d3*t)<br/>    y = a2*<span class="pd_blue1">sin</span>(f2*t + p2)*<span class="pd_blue1">exp</span>(-d2*t) + a4*<span class="pd_blue1">sin</span>(f4*t + p4)*<span class="pd_blue1">exp</span>(-d4*t)<br/>    <span class="pd_lime">return</span> [x,y]</pre>&#13;
<p class="listing" id="ch06list22"><em>Listing 6-22: The harmonograph code for the design in <a href="ch06.xhtml#ch06fig20">Figure 6-20</a></em></p>&#13;
<p class="indent">In <a href="ch06.xhtml#ch06list22">Listing 6-22</a>, all we changed were the constants for <code>a</code>, <code>f</code>, <code>p</code>, and <code>d</code> to make a completely different design. If you add <code>stroke(255,0,0)</code> to the code before drawing the lines, you’ll make the lines red, as shown in <a href="ch06.xhtml#ch06fig20">Figure 6-20</a>.</p>&#13;
<span epub:type="pagebreak" id="page_125"/>&#13;
<div class="image"><a id="ch06fig20"/><img alt="image" src="../images/f125-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 6-20: A complete harmonograph!</em></p>&#13;
<p class="indent">Listing 6-23 shows the final code for <em>harmonograph.pyde</em>.</p>&#13;
<pre><span class="pd_g1"><em>harmonograph.pyde</em></span><br/>t = 0<br/>points = []<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    <span class="pd_blue1">noStroke</span>()<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    points = []<br/>    t = 0<br/>    <span class="pd_lime">while</span> t &lt; 1000:<br/>        points.<span class="pd_blue1">append</span>(harmonograph(t))<br/>        t += 0.01<br/>    <span class="pd_gray">#go through points list and draw lines between them</span><br/>    <span class="pd_lime">for</span> i,p <span class="pd_green1">in</span> enumerate(points):<br/>        <span class="pd_blue1">stroke</span>(255,0,0) <span class="pd_gray">#red</span><br/>        <span class="pd_lime">if</span> i &lt; <span class="pd_blue1">len</span>(points) - 1:<br/>            <span class="pd_blue1">line</span>(p[0],p[1],points[i+1][0],points[i+1][1])<br/><br/><span class="pd_green1">def</span> harmonograph(t):<br/>    a1=a2=a3=a4 = 100<br/>    f1,f2,f3,f4 = 2.01,3,3,2<br/>    p1,p2,p3,p4 = -<span class="pd_olive">PI</span>/2,0,-<span class="pd_olive">PI</span>/16,0<br/>    d1,d2,d3,d4 = 0.00085,0.0065,0,0<br/>    x = a1*<span class="pd_blue1">cos</span>(f1*t + p1)*<span class="pd_blue1">exp</span>(-d1*t) + a3*<span class="pd_blue1">cos</span>(f3*t + p3)*<span class="pd_blue1">exp</span>(-d3*t)<br/>    y = a2*<span class="pd_blue1">sin</span>(f2*t + p2)*<span class="pd_blue1">exp</span>(-d2*t) + a4*<span class="pd_blue1">sin</span>(f4*t + p4)*<span class="pd_blue1">exp</span>(-d4*t)<br/>    <span class="pd_lime">return</span> [x,y]</pre>&#13;
<p class="listing" id="ch06list23"><em>Listing 6-23: The final code for the harmonograph sketch</em></p>&#13;
<span epub:type="pagebreak" id="page_126"/>&#13;
<h3 class="h3" id="ch06_6">SUMMARY</h3>&#13;
<p class="noindent">Students in trigonometry class have to solve for unknown side lengths or angle measurements in triangles. But now you know the <em>real</em> use of sines and cosines is to rotate and transform points and shapes to make Spirograph and harmonograph designs! In this chapter, you saw how useful it is to save points to a list and then loop through the list to draw lines between the points. We also revisited some Python tools like <code>enumerate()</code> and <code>vertex()</code>.</p>&#13;
<p class="indent">In the next chapter, we’ll use sines and cosines and the rotation ideas you learned in this chapter to invent a whole new kind of number! We’ll also rotate and transform grids using these new numbers, and we’ll create complex (pun intended) works of art using the locations of pixels!</p>&#13;
</body></html>