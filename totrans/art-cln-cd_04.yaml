- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Write Clean and Simple Code
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写干净且简洁的代码
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Clean code* is code that’s easy to read, understand, and change. It is minimal
    and concise, as long as those attributes do not interfere with readability. While
    writing clean code is more an art than a science, the software engineering industry
    has agreed on multiple principles that, if followed, will help you write *cleaner*
    code. In this chapter, you’ll learn 17 principles for how to write clean code
    that will significantly improve your productivity and combat the problem of complexity.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*干净的代码*是易于阅读、理解和修改的代码。它简洁且简明扼要，只要这些特性不妨碍可读性。虽然编写干净的代码更多是一种艺术而非科学，但软件工程行业已经达成一致，提出了多项原则，如果遵循这些原则，将帮助你编写*更干净*的代码。在本章中，你将学习17个编写干净代码的原则，它们将显著提高你的生产力并解决复杂性问题。'
- en: You may wonder about the difference between *clean* and *simple* code. These
    two concepts are closely interrelated because clean code tends to be simple and
    simple code tends to be clean. But it’s possible to encounter complex code that
    is still clean. Simplicity concerns the avoidance of complexity. Clean code goes
    one step further and also concerns itself with managing unavoidable complexity—for
    instance, through the effective use of comments and standards.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道*干净*代码和*简洁*代码之间的区别。这两个概念紧密相关，因为干净的代码往往是简洁的，简洁的代码往往是干净的。但也有可能遇到复杂的代码，它仍然是干净的。简洁性关注的是避免复杂性，而干净的代码则更进一步，关注如何管理不可避免的复杂性——例如，通过有效使用注释和标准。
- en: Why Write Clean Code?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要编写干净的代码？
- en: In the previous chapters, you learned that complexity is the number one public
    enemy for any code project. You’ve learned that simplicity increases your productivity,
    your motivation, and the maintainability of your codebase. In this chapter, we’ll
    carry this concept a step further and show you how to write clean code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学到了复杂性是任何代码项目的头号公敌。你还学到了简洁性能够提高你的生产力、动机以及代码库的可维护性。在本章中，我们将进一步扩展这个概念，并展示如何编写干净的代码。
- en: Clean code is easier to understand for both your future self and your fellow
    coders, since people are more likely to add to clean code and the potential for
    collaboration will increase. Consequently, clean code can significantly reduce
    a project’s costs. As Robert C. Martin points out in his book *Clean Code* (Prentice
    Hall, 2008), coders spend the vast majority of their time reading old code in
    order to write new code. If the old code is easy to read, this will speed the
    process considerably.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 干净的代码更容易被未来的自己和其他同事理解，因为人们更可能为干净的代码做出贡献，协作的潜力也会增加。因此，干净的代码可以显著降低项目成本。正如Robert
    C. Martin在他的书《Clean Code》（Prentice Hall，2008）中所指出的，程序员花费绝大多数时间阅读旧代码，以便编写新代码。如果旧代码易于阅读，那么这一过程将大大加速。
- en: Indeed, the ratio of time spent reading versus writing is well over 10 to 1\.
    We are constantly reading old code as part of the effort to write new code. [Therefore,]
    making it easy to read makes it easier to write.
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确实，阅读与编写代码的时间比例远远超过10:1。我们在编写新代码的过程中，持续不断地阅读旧代码。[因此，]使代码易于阅读，也使得编写代码变得更容易。
- en: If we take this ratio literally, this relationship is visualized in [Figure
    4-1](#figure4-1). The x-axis corresponds to the number of lines written in a given
    code project. The y-axis corresponds to the time to write one additional line
    of code. In general, the more code you’ve already written in one project, the
    more time it takes to write an additional line of code. This is true for both
    clean and dirty code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们字面理解这个比例，这个关系在[图4-1](#figure4-1)中得到了可视化。x轴对应于在一个代码项目中编写的行数，y轴对应于编写一行额外代码所需的时间。一般来说，项目中已编写的代码越多，写一行额外代码所需的时间就越长。这对于干净代码和脏代码都适用。
- en: Say you’ve written *n* lines of code, and you add the *n* + 1st line of code.
    Adding this line may potentially affect all previously written lines. It may,
    for example, have a small performance penalty, which impacts the overall project.
    It may use a variable defined somewhere else. It may introduce a bug (with probability
    *c*), and to find that bug, you must search the whole project. That means your
    expected time—and therefore, costs—per line of code is *c * T*(*n*) for a steadily
    increasing time function *T* with increasing input *n*. Adding a line may also
    force you to write additional lines of code to ensure backward compatibility.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经写了*n*行代码，并且你添加了第*n* + 1行代码。添加这一行可能会影响所有之前写的代码行。它可能会带来小的性能损失，从而影响整个项目。它可能会使用在其他地方定义的变量。它可能会引入一个bug（概率为*c*），要找到这个bug，你必须搜索整个项目。这意味着你每行代码的预期时间——因此，成本——是*c
    * T*(*n*)，其中时间函数*T*随着输入*n*的增加而稳定增长。添加一行代码还可能迫使你编写额外的代码行，以确保向后兼容性。
- en: 'Lengthier code may introduce many other complications, but you get the point:
    the more code you’ve written, the more the additional complexity will slow your
    progress.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更长的代码可能会引入许多其他复杂性，但你已经明白了这个要点：你写的代码越多，额外的复杂性就越大，这会减慢你的进度。
- en: '![Line graph with “Lines of code written” on the x-axis and “Time per additional
    line” on the y-axis. The “quick and dirty code” rapidly increases in time per
    line and the “Thoughtful and clean code” line maintains a steady rate.](image_fi/502185c04/f04001.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![折线图，横轴为“编写的代码行数”，纵轴为“每增加一行的时间”。“快速而脏的代码”在每行所需的时间迅速增加，而“深思熟虑的干净代码”则保持平稳的速率。](image_fi/502185c04/f04001.png)'
- en: 'Figure 4-1: Clean code improves the scalability and maintainability of your
    codebase.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1：干净的代码提高了代码库的可扩展性和可维护性。
- en: '[Figure 4-1](#figure4-1) also shows the difference between writing dirty and
    clean code. Dirty code is less time-consuming in the short term and for small
    code projects—if there were no benefits to writing dirty code, nobody would do
    it! If you cram all your functionality into a 100-line code script, you don’t
    need to invest a lot of time thinking about and restructuring your project. Problems
    begin to arise only as you add more code: as your monolithic code file grows from
    100 to 1,000 lines, it’ll be less efficient than code developed using a more thoughtful
    approach in which you structure the code logically in different modules, classes,
    or files.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-1](#figure4-1) 同样展示了写脏代码与干净代码之间的差异。脏代码在短期内和小型代码项目中消耗的时间较少——如果写脏代码没有好处，没人会去做！如果你将所有功能压缩到一个100行的代码脚本中，你就不需要投入大量时间思考和重构你的项目。问题只有在你添加更多代码时才会出现：随着你的单一代码文件从100行增长到1000行，它的效率将不如采用更有思考性的方式，按照逻辑结构将代码分成不同模块、类或文件来开发的代码。'
- en: 'As a rule of thumb: always write thoughtful and clean code. The additional
    costs for rethinking, refactoring, and restructuring will pay back many times
    over for any non-trivial project. The stakes can sometimes be quite high: in 1962
    the National Aeronautics and Space Administration (NASA) attempted to send a spacecraft
    to Venus, but a tiny bug—the omission of a hyphen in the source code—caused the
    engineers to issue a self-destruct command, which resulted in the loss of a rocket
    worth more than $18 million at the time. If the code had been cleaner, the engineers
    may have caught the error before the launch.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一条经验法则是：总是编写深思熟虑且干净的代码。重新思考、重构和重整代码的额外成本将在任何非琐碎项目中带来多倍的回报。有时，赌注可能相当高：1962年，美国国家航空航天局（NASA）尝试将一艘航天器送往金星，但由于源代码中缺少一个连字符，一个微小的bug导致工程师发出了自毁命令，最终导致一枚价值超过1800万美元的火箭损失。如果代码更干净，工程师可能会在发射前发现这个错误。
- en: Whether or not you’re doing rocket science, the philosophy of carefully crafting
    your programming will carry you further in life. Simple code also facilitates
    scaling your project to more programmers and more features because fewer coders
    will be scared off by the project’s complexity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否在做火箭科学，精心编写程序的理念都能让你在人生中走得更远。简洁的代码也有利于将项目扩展到更多程序员和更多功能，因为较少的程序员会被项目的复杂性吓跑。
- en: So, let’s learn how to write clean and simple code, shall we?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来学习如何编写简洁干净的代码吧！
- en: 'Writing Clean Code: The Principles'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写干净代码：原则
- en: I learned to write clean code the hard way when I was developing a distributed
    graph-processing system from scratch as part of my doctoral research. If you’ve
    ever written a distributed application—where two processes residing on different
    computers interact with each other via messages—you know that the complexity can
    quickly become overwhelming. My code grew to thousands of lines, and bugs popped
    up frequently. I didn’t make any progress for weeks at a time; it was very frustrating.
    The concepts were convincing in theory, but somehow they didn’t work in my implementation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我在从零开始开发一个分布式图处理系统作为博士研究的一部分时，以一种非常艰难的方式学会了编写干净的代码。如果你曾经编写过分布式应用程序——两个进程分别驻留在不同的计算机上，通过消息互相通信——你就知道这种复杂性可以迅速变得让人不堪重负。我的代码增长到几千行，错误频繁出现。好几个星期我都没有任何进展；这让我感到非常沮丧。理论上的概念很有说服力，但不知为何它们在我的实现中并没有奏效。
- en: Finally, after a month or so working full-time on the codebase without seeing
    any encouraging progress, I decided to simplify the codebase radically. Among
    other changes, I started to use libraries instead of coding functionality myself.
    I removed code blocks that I had commented out for a possible later use. I renamed
    variables and functions. I structured the code in logical units and created new
    classes instead of cramming everything into a “God” class. After a week or so,
    not only was my code more readable and understandable for other researchers, it
    was also more efficient and less buggy. My frustration morphed into enthusiasm—clean
    code had rescued my research project!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在大约一个月的时间里，我全职工作在代码库上，却没有看到任何令人鼓舞的进展，于是我决定彻底简化代码库。除了其他改动，我开始使用现成的库，而不是自己编写功能。我删除了那些曾经注释掉、可能以后会用到的代码块。我重命名了变量和函数。我将代码结构化成逻辑单元，并创建了新类，而不是将所有东西塞进一个“上帝”类中。大约一周后，我的代码不仅对于其他研究人员来说更加易读和易懂，而且也更加高效，出错率更低。我的沮丧转变为热情——干净的代码救了我的研究项目！
- en: 'Improving your codebase and reducing complexity is called *refactoring*, and
    it must be a scheduled and crucial element of your software development process
    if you want to write clean and simple code. Writing clean code is mainly about
    keeping two things in mind: knowing the best ways to build your code from the
    ground up and going back to make revisions periodically. I’ll cover some important
    techniques for keeping your code clean in the following 17 principles. While each
    principle covers a unique strategy to write cleaner code, some of the principles
    overlap, but I felt like combining the overlapping principles would reduce clarity
    and actionability. With this out of the way, let’s get started with the first
    one!'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 改进代码库并减少复杂性叫做*重构*，如果你想编写干净简洁的代码，它必须成为你的软件开发过程中一个有计划且至关重要的环节。编写干净代码主要是记住两件事：知道从头开始构建代码的最佳方法，并定期回去进行修订。我将在接下来的17条原则中介绍一些保持代码干净的重要技巧。虽然每条原则涵盖了编写更干净代码的独特策略，但其中一些原则是重叠的，我觉得将重叠的原则合并会降低清晰度和可操作性。既然这些已经讲完，我们就开始第一个原则吧！
- en: 'Principle 1: Think About the Big Picture'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 1：思考大局
- en: 'If you work on a non-trivial project, you’ll likely end up with multiple files,
    modules, and libraries working together within the overall application. Your *software
    architecture* defines how your software elements interact. Good architectural
    decisions can initiate huge leaps of improvement in performance, maintainability,
    and usability. To build a good architecture, you’ll need to take a step back and
    think about the big picture. Decide on features that are needed in the first place.
    In Chapter 3 about building an MVP, you learned how to focus your project on the
    necessary features. If you do this, you save yourself a lot of work and the code
    will be a lot more clean per design. At this point, we assume you’ve already created
    your first application with multiple modules, files, and classes. How can you
    apply big-picture thinking to impose some order on the mess? Considering the following
    questions can give you some ideas on how to best make your code cleaner:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在做一个非简单项目，你很可能会遇到多个文件、模块和库在整体应用中一起工作。你的*软件架构*定义了软件元素如何相互作用。良好的架构决策可以带来巨大的性能、可维护性和可用性的提升。要建立一个好的架构，你需要退后一步，思考整体局面。首先决定需要的功能。在第3章关于构建最小可行产品（MVP）中，你学会了如何将项目聚焦于必要的功能。如果你这样做了，你会节省很多工作，并且代码会更加简洁有序。到这个阶段，我们假设你已经创建了第一个包含多个模块、文件和类的应用程序。你如何运用整体思维来给这些混乱的代码带来一些秩序？考虑以下问题可以给你一些关于如何清理代码的思路：
- en: Do you need all the separate files and modules, or can you consolidate some
    of them and reduce the interdependency of your code?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要所有独立的文件和模块吗，还是可以合并其中一些，减少代码之间的相互依赖？
- en: 'Can you divide a large and complicated file into two simpler ones? Note that
    there’s usually a sweet spot between two extremes: a large, monolithic code block
    that is completely unreadable or a myriad of small code blocks that are impossible
    to mentally keep track of. Neither is desirable, and most stages in between are
    better options. Think of it as an inverted U curve where the maximum represents
    the sweet spot between a few large code blocks and many small code blocks.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能将一个大而复杂的文件拆分成两个更简单的文件吗？请注意，通常在两种极端之间会有一个“甜点”区域：一个庞大、单一的代码块完全无法阅读，或者是无数个小代码块，你很难一一追踪。两者都不可取，而大多数介于两者之间的阶段会是更好的选择。可以将其视为一个倒U形曲线，最大值代表了少数大代码块和大量小代码块之间的甜点区域。
- en: Can you generalize code and turn it into a library to simplify the main application?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能将代码通用化并将其转化为库，从而简化主应用程序吗？
- en: Can you use existing libraries to get rid of many lines of code?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能使用现有的库来消除许多代码行吗？
- en: Can you use caching to avoid recomputing the same result over and over again?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能使用缓存来避免一次又一次地重新计算相同的结果吗？
- en: Can you use more straightforward and suitable algorithms that accomplish the
    same things as your current algorithms?
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能使用更直接和更合适的算法来实现与你当前算法相同的功能吗？
- en: Can you remove premature optimizations that don’t improve the overall performance?
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能去除那些不会提升整体性能的过早优化吗？
- en: Can you use another programming language that would be more suitable for the
    problem at hand?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能使用其他更适合当前问题的编程语言吗？
- en: Big-picture thinking is a time-efficient way to drastically reduce the complexity
    of your application as a whole. Sometimes it’s hard to implement those changes
    at later various stages of the process or because of collaborations that might
    interfere. In particular, this kind of high-level thinking can be difficult for
    applications with millions of lines of code, like the Windows operating system.
    However, you simply cannot afford to ignore these questions entirely because all
    the small tweaks combined cannot mitigate the adverse effects of wrong or lazy
    design choices. If you’re working in a small startup or just for yourself, you
    can usually make bold architectural decisions, such as changing the algorithm,
    swiftly. If you’re working in a big organization, you might not have as much flexibility.
    The bigger the application, the more likely you are to find easy fixes and low-hanging
    fruit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从大局思考是一种高效的方式，可以大幅度降低整个应用程序的复杂性。有时候，在后续的不同阶段实施这些改变会很困难，或者可能因为合作影响而无法进行。特别是，对于像
    Windows 操作系统这样有数百万行代码的应用程序，这种高层次的思维方式可能会变得很困难。然而，你绝对不能完全忽视这些问题，因为所有的小调整加起来也无法弥补错误或懒惰设计选择带来的负面影响。如果你在一个小型创业公司工作，或者仅仅为自己工作，你通常可以迅速做出大胆的架构决策，比如改变算法。如果你在一个大组织中工作，你的灵活性可能会小一些。应用程序越大，你越容易找到简单的修复和容易解决的问题。
- en: 'Principle 2: Stand on the Shoulders of Giants'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 2：站在巨人的肩膀上
- en: 'Reinventing the wheel is rarely valuable. Programming is a decades-old industry.
    The best coders in the world have provided us with a great legacy: a database
    of millions of fine-tuned and well-tested algorithms and code functions. Accessing
    the collective wisdom of millions of programmers is as simple as using a one-line
    import statement. There’s no reason not to use this superpower in your own projects.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 发明轮子很少是有价值的。编程已经是一个有几十年历史的行业。世界上最优秀的程序员为我们提供了伟大的遗产：一个包含数百万个精细调优和经过充分测试的算法和代码函数的数据库。访问数百万程序员的集体智慧，就像使用一行导入语句那么简单。在你自己的项目中，完全没有理由不利用这个超级能力。
- en: Using library code is likely to improve the efficiency of your code. Functions
    that have been used by thousands of coders tend to be much more optimized than
    your own. Furthermore, library calls are easier to understand and take less space
    in your code project than code you’ve written in yourself. For example, suppose
    you need a clustering algorithm to visualize clusters of customers. You can *stand
    on the shoulders of giants* by importing a well-tested clustering algorithm from
    an external library and passing your data into it. This is far more time-efficient
    than using your own code—it will implement the same functionality with fewer bugs,
    less space, and more performant code. Libraries are among the primary tools that
    master coders use to increase their productivity thousandfold.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用库代码可能会提高你的代码效率。已经被成千上万的程序员使用过的函数往往比你自己写的更加优化。而且，库函数调用通常比你自己编写的代码更容易理解，占用的代码空间也更少。例如，假设你需要一个聚类算法来可视化客户的聚类。你可以通过从外部库导入一个经过良好测试的聚类算法并将数据传入其中，*站在巨人的肩膀上*。这比使用你自己的代码更为高效——它将以更少的错误、更少的空间和更高效的代码实现相同的功能。库是高级程序员用来千倍提高生产力的主要工具之一。
- en: 'As an example of some library code that can save you time, here’s the two-liner
    that imports the KMeans module from the scikit-learn Python library to find two
    cluster centers on a given dataset stored in variable `X`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个能够节省时间的库代码示例，下面是从 scikit-learn Python 库中导入 KMeans 模块以在存储在变量 `X` 中的给定数据集上找到两个聚类中心的两行代码：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Implementing the KMeans algorithm on your own instead would take you several
    hours and likely more than 50 lines of code, cluttering your codebase so that
    all future code would become harder to implement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己实现 KMeans 算法，可能需要几个小时，且很可能需要超过 50 行代码，甚至会让你的代码库变得杂乱无章，使得未来的代码实现更加困难。
- en: 'Principle 3: Code for People, Not Machines'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 3：为人编程，而不是为机器编程
- en: You may think that the primary purpose of a piece of source code is to define
    what machines should do and how they should do it. Not so. The single purpose
    of a programming language such as Python is to help humans write code. Compilers
    do the heavy lifting and translate your high-level code to low-level code that
    is understandable by your machine. Yes, your code will eventually be run by a
    machine. But code is still written mainly by humans, and in today’s software development
    process, the code likely must pass many levels of human judgment before it is
    deployed. First and foremost, you’re writing code for people, not machines.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为源代码的主要目的是定义机器应该做什么以及如何做。其实并非如此。像Python这样的编程语言的唯一目的是帮助人类编写代码。编译器完成繁重的工作，将你写的高级代码翻译成机器能理解的低级代码。是的，你的代码最终会由机器执行。但代码仍然主要是由人编写的，在今天的软件开发过程中，代码很可能必须经过多层人类的判断才能被部署。最重要的是，你写代码是为了人，而不是机器。
- en: Always assume that others will read your source code. Imagine you moved to a
    new project and someone else had to take your place at the codebase. There are
    many ways to make their job easier and minimize frustration. First of all, use
    meaningful variable names so that readers can easily follow what a given line
    of code is intended to accomplish. [Listing 4-1](#listing4-1) shows an example
    of poorly chosen variable names.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总是假设别人会阅读你的源代码。想象一下，你转到一个新项目，其他人不得不接手你的代码库。为了让他们的工作更轻松，减少挫败感，有很多方法可以做到。首先，使用有意义的变量名，这样读者就能轻松理解每一行代码的意图。[列表
    4-1](#listing4-1)展示了一个使用不当变量名的例子。
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 4-1: Code that uses poorly chosen variable names'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：使用不恰当变量名的代码
- en: It’s difficult to guess what this code computes. [Listing 4-2](#listing4-2),
    on the other hand, is a semantically equivalent code that uses meaningful variable
    names.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 很难猜测这段代码计算了什么。[列表 4-2](#listing4-2)则是一个语义等效的代码，使用了有意义的变量名。
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-2: Code that uses meaningful variable names'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-2：使用有意义变量名的代码
- en: 'It’s much easier to understand what’s happening here: the variable names indicate
    how to calculate the value of an initial investment of 10,000 compounded over
    10 years, assuming an annual return of 10 percent.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里理解发生了什么要容易得多：变量名表明如何计算一个初始投资10000的价值，这笔投资在10年内复利增长，假设年回报率为10%。
- en: While we won’t go into every way to implement this principle here (though later
    principles will cover some approaches in more detail), it also manifests in other
    aspects that might clarify intent, such as indentation, whitespace, comments,
    and line lengths, among others. Clean code radically optimizes for human readability.
    As Martin Fowler, an international expert on software engineering and author of
    the popular book *Refactoring*, argues, “Any fool can write code that a computer
    can understand. Good programmers write code that humans can understand” (Addison-Wesley,
    1999).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里不会讨论实现这一原则的每一种方式（尽管后面的原则会更详细地讨论一些方法），但它也体现在其他可以明确意图的方面，例如缩进、空格、注释和行长度等。干净的代码极大地优化了人类可读性。正如软件工程国际专家、畅销书《重构》的作者**马丁·福勒**所言：“任何傻瓜都能写出计算机能理解的代码。优秀的程序员写的是人类能理解的代码”（Addison-Wesley，1999年）。
- en: 'Principle 4: Use the Right Names'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 4：使用正确的名称
- en: 'Relatedly, experienced coders have often agreed on a set of specific naming
    conventions for functions, function arguments, objects, methods, and variables,
    both implicit and explicit. Everybody benefits from adhering to these conventions:
    code becomes more readable, easier to understand, and less cluttered. If you violate
    these conventions, readers of your code are likely to assume that it was written
    by an inexperienced programmer and may not take your code seriously.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的，经验丰富的程序员通常会就函数、函数参数、对象、方法和变量的命名约定达成共识，无论是隐性还是显性。遵守这些约定对每个人都有好处：代码变得更易读、更易理解，也更简洁。如果你违反这些约定，阅读你代码的人很可能会认为这段代码是由一个没有经验的程序员写的，并可能不会认真对待你的代码。
- en: These conventions may differ from language to language. For example, by convention
    Java uses `camelCaseNaming` for naming variables, while Python uses `underscore_naming`
    for variables and functions. If you start using camel case in Python, it may confuse
    the reader. You don’t want your untraditional naming conventions to distract those
    reading your code. You want them to focus on what your code does, not on your
    coding style. As outlined by the *principle of least surprise*, there’s no value
    in surprising other coders by choosing unconventional variable names.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约定可能因编程语言而异。例如，按约定，Java使用 `camelCaseNaming` 来命名变量，而Python使用 `underscore_naming`
    来命名变量和函数。如果你在Python中使用驼峰命名法，可能会让读者感到困惑。你不希望你的非传统命名约定分散读者的注意力。你希望他们关注的是代码的功能，而不是你的编码风格。正如*最小惊讶原则*所述，通过选择不常见的变量名来让其他开发者感到惊讶没有任何价值。
- en: So, let’s dive into a list of naming rules you can consider when writing source
    code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来我们来看看在编写源代码时可以考虑的命名规则。
- en: Choose descriptive names Say you create a function to convert currencies from
    United States dollars (USD) to euros (EUR) in Python. Call it `usd_to_eur(amount)`
    rather than `f(x)`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择描述性名称 假设你创建了一个函数，用来将美元（USD）转换为欧元（EUR）。应该命名为 `usd_to_eur(amount)`，而不是 `f(x)`。
- en: Choose unambiguous names You may think that `dollar_to_euro(amount)` would be
    a good name for a currency conversion function. While it is better than `f(x)`,
    it’s worse than `usd_to_eur(amount)` because it introduces an unnecessary degree
    of ambiguity. Do you mean United States, Canadian, or Australian dollars? If you’re
    in the United States, the answer may be obvious to you, but an Australian coder
    may not know that the code is written in the United States and may assume a different
    output. Minimize these confusions!
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择不含歧义的名称 你可能会认为 `dollar_to_euro(amount)` 是一个不错的货币转换函数名。虽然它比 `f(x)` 更好，但它比 `usd_to_eur(amount)`
    差，因为它引入了不必要的歧义。你是指美元、加元，还是澳元？如果你在美国，答案可能对你来说很明显，但澳大利亚的开发者可能不知道代码是用美国的美元编写的，可能会假设不同的输出。尽量减少这些混淆！
- en: Use pronounceable names Most coders subconsciously read code by pronouncing
    it in their minds. If a variable name is unpronounceable, the problem of deciphering
    it takes attention and costs precious mental space. For example, the variable
    name `cstmr_lst` may be descriptive and unambiguous, but it’s not pronounceable.
    Choosing the variable name `customer_list` is well worth the additional space
    in your code.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用易读的名称 大多数开发者在阅读代码时，都会在脑中默读。如果一个变量名无法发音，那么解读它的过程就会占用注意力，消耗宝贵的脑力空间。例如，变量名 `cstmr_lst`
    可能很描述性且不含歧义，但它无法发音。选择变量名 `customer_list` 会让代码更容易理解，尽管它多占用了些空间。
- en: Use named constants, not magic numbers In your code, you may use the magic number
    0.9 multiple times as a factor to convert a sum in USD to a sum in EUR. However,
    the reader of your code—including your future self—has to think about the purpose
    of this number. It’s not self-explanatory. A far better way of handling the magic
    number 0.9 is to store it in an all-uppercase variable—used to indicate that it
    is a constant that doesn’t change—such as `CONVERSION_RATE = 0.9` and use it as
    a factor in your conversion computations. For example, you may then calculate
    your income in EUR as `income_euro = CONVERSION_RATE * income_usd`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命名常量，而非魔法数字 在你的代码中，你可能会多次使用魔法数字0.9作为因子，将美元金额转换为欧元金额。然而，代码的读者——包括未来的你——必须思考这个数字的目的。这个数字并不是自解释的。处理魔法数字0.9的一个更好的方法是将其存储在一个全大写的变量中——用来表示它是一个不会改变的常量——比如
    `CONVERSION_RATE = 0.9`，并在转换计算中使用它作为因子。例如，你可以通过 `income_euro = CONVERSION_RATE
    * income_usd` 来计算你的欧元收入。
- en: These are only a few naming rules. Beyond these quick tips, the best way to
    learn naming conventions is to study the well-crafted code of experts. Googling
    the relevant conventions (for example, “Python naming conventions”) is a good
    place to start. You might also read programming tutorials, join StackOverflow
    to query fellow coders, check out the GitHub code of open source projects, and
    join the Finxter blog community of ambitious coders who help each other grow their
    programming skills.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些命名规则。除了这些快速提示，学习命名约定的最佳方式是研究专家们精心编写的代码。搜索相关的命名约定（例如，“Python命名约定”）是一个很好的起点。你还可以阅读编程教程，加入StackOverflow向其他程序员请教，查看开源项目的GitHub代码，或者加入Finxter博客社区，与其他有抱负的程序员一起互相学习，提高编程技能。
- en: 'Principle 5: Adhere to Standards and Be Consistent'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则五：遵循标准并保持一致性
- en: Every programming language comes with an implicit or explicit set of rules on
    how to write clean code. If you are an active coder, these standards will always
    catch up with you eventually. However, you can speed the process by taking the
    time to study the code standard of the programming language you’re learning.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都会有一套隐式或显式的规则来指导如何编写整洁的代码。如果你是一个活跃的程序员，这些标准最终会成为你必须遵守的要求。然而，你可以通过花时间研究你正在学习的编程语言的代码标准来加速这一过程。
- en: 'For example, you can access the official Python style guide, PEP 8, at this
    link: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/).
    As with any style guide, PEP 8 defines the correct code layout and indentation;
    the method to set line breaks; the maximum number of characters in a line; the
    correct use of commenting; the formulation of your own function documentation;
    and the conventions for naming classes, variables, and functions. For instance,
    [Listing 4-3](#listing4-3) shows a positive example from PEP 8’s guidelines on
    the correct way to use different stylings and conventions. You use four spaces
    per indentation level, align function arguments consistently, use single whitespaces
    when listing comma-separated values in argument lists, and correctly name functions
    and variables by combining multiple words with the underscore:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以通过这个链接访问官方的 Python 风格指南 PEP 8：[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)。和任何风格指南一样，PEP
    8 定义了正确的代码布局和缩进方法；如何设置换行符；每行最大字符数；正确使用注释；编写函数文档的方法；以及命名类、变量和函数的约定。例如，[列表 4-3](#listing4-3)
    展示了 PEP 8 指南中的正面示例，展示了如何正确使用不同的样式和约定。你需要为每个缩进级别使用四个空格，始终对齐函数参数，在列出逗号分隔的参数列表时使用单个空格，并通过使用下划线将多个单词结合起来来正确命名函数和变量：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 4-3: Use of indentation, spacing, and naming in Python according to
    the PEP 8 standard'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-3：根据 PEP 8 标准在 Python 中使用缩进、空格和命名
- en: '[Listing 4-4](#listing4-4) shows the wrong way to do it. The arguments are
    not aligned, multiple words are not properly combined in variable and function
    names, argument lists are not properly separated by a single empty space, and
    indentation levels have only two or three empty spaces instead of four:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-4](#listing4-4) 展示了错误的做法。参数没有对齐，多个单词在变量和函数名称中没有正确结合，参数列表没有用单个空格正确分隔，缩进级别只有两个或三个空格，而不是四个：'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-4: Incorrect use of indentation, spacing, and naming in Python'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：在 Python 中错误使用缩进、空格和命名
- en: All readers of your code will expect you to adhere to the accepted standards.
    Anything else will result in confusion and frustration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有阅读你代码的人都会期望你遵循已接受的标准。否则会导致混淆和挫败感。
- en: Reading through style guides can be a tedious task, though. As a less boring
    way to learn conventions and standards, use linters and integrated development
    environments (IDEs) that tell you where and how you’ve made mistakes. In a weekend
    hackathon with my Finxter team, we created a tool called Pythonchecker.com that
    playfully helps you refactor your Python code from messy to super clean. For Python,
    one of the best projects in this regard is the *black* module for PyCharm. Similar
    tools exist for all major programming languages. Just search the net for *<Your
    Language> Linter* to find the best tools for your programming environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，阅读风格指南可能是一个乏味的任务。作为一种不那么枯燥的学习约定和标准的方法，使用能够告诉你在哪里以及如何犯错的代码检查工具（如 linters）和集成开发环境（IDEs）。在与我的
    Finxter 团队参加一个周末黑客马拉松时，我们创建了一个工具，叫做 Pythonchecker.com，它以有趣的方式帮助你将 Python 代码从凌乱的状态重构为超级整洁。对于
    Python，最好的相关项目之一是 PyCharm 的 *black* 模块。类似的工具适用于所有主要的编程语言。只需在网上搜索 *<Your Language>
    Linter*，就可以找到适合你编程环境的最佳工具。
- en: 'Principle 6: Use Comments'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 6：使用注释
- en: As mentioned earlier, when writing code for humans, not machines, you’ll need
    to use comments to help readers understand it. Consider the code without comments
    in [Listing 4-5](#listing4-5).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在为人类而不是机器编写代码时，你需要使用注释来帮助读者理解代码。考虑一下 [列表 4-5](#listing4-5) 中没有注释的代码。
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-5: Code without comments'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-5：没有注释的代码
- en: '[Listing 4-5](#listing4-5) analyzes a short text snippet from Shakespeare’s
    *Romeo and Juliet* using regular expressions. If you’re not familiar with regular
    expressions, you’ll probably struggle to understand what the code does. Even the
    meaningful variable names don’t help much.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-5](#listing4-5) 分析了莎士比亚的 *罗密欧与朱丽叶* 中的一段短文本，通过正则表达式进行处理。如果你不熟悉正则表达式，你可能会很难理解这段代码的作用。即使是有意义的变量名称也没多大帮助。'
- en: Let’s see if a few comments can resolve your confusion (see [Listing 4-6](#listing4-6)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个注释是否能够解决你的困惑（见 [Listing 4-6](#listing4-6)）。
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-6: Code with comments'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-6：带注释的代码
- en: The two short comments (❶ ❷) illuminate the purpose of the regular expression
    patterns `'\\bf\w+\\b'` and `'\\bl\w+\\b'`. I won’t dive deeply into regular expressions
    here, but the example shows how comments can help you get a rough understanding
    of other people’s code without understanding the syntactic sugar.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个简短的注释 (❶ ❷) 解释了正则表达式模式 `'\\bf\w+\\b'` 和 `'\\bl\w+\\b'` 的目的。我不会在这里深入探讨正则表达式，但这个例子展示了注释如何帮助你大致理解他人的代码，而无需理解那些语法糖。
- en: You can also use comments to abstract over blocks of code. For example, if you
    have five code lines that deal with updating customer information in a database,
    add a short comment before the block to explain this, as in [Listing 4-7](#listing4-7).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用注释来概括一段代码。例如，如果你有五行代码涉及更新数据库中的客户信息，在这段代码之前加上简短的注释来解释这一过程，像 [Listing 4-7](#listing4-7)
    中所示。
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-7: Commented blocks give an overview of the code.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-7：注释块概述了代码
- en: 'This shows how an online shop completes a customer order in two high-level
    steps: processing the next order ❶ and shipping the order ❷. The comments help
    you understand the purpose of the code quickly without needing to decipher each
    method call.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了一个在线商店如何通过两个高级步骤完成客户订单：处理下一个订单 ❶ 和发货 ❷。注释帮助你快速理解代码的目的，而不需要逐一解读每个方法调用。
- en: You can also use comments to warn programmers of potentially undesirable consequences.
    For example, [Listing 4-8](#listing4-8) alerts us that calling the function `ship_yacht()`
    will actually ship an expensive yacht to a customer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用注释提醒程序员潜在的不可取后果。例如，[Listing 4-8](#listing4-8) 提醒我们调用函数 `ship_yacht()`
    会将一艘昂贵的游艇发货给客户。
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 4-8: Comments as warnings'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-8：作为警告的注释
- en: You can employ comments in many more useful ways; they are not only about applying
    the standards correctly. Keep the principle *code for humans* at the top of your
    mind when writing comments, and you will be fine. As you read code from experienced
    programmers, you’ll absorb the unspoken rules effectively and almost automatically
    over time. Since you’re the expert on code you’ve written, helpful comments give
    outsiders a glimpse into your thinking. Don’t miss out on sharing your insights
    with other people!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以更多有用的方式使用注释；它们不仅仅是正确应用标准。当编写注释时，始终将“*为人类编写代码*”的原则放在心中，你就会做得很好。随着你阅读经验丰富程序员的代码，你会逐渐并几乎自动地吸收那些不言而喻的规则。因为你是自己编写代码的专家，帮助性的注释让外人能够一窥你的思路。别忘了与他人分享你的见解！
- en: 'Principle 7: Avoid Unnecessary Comments'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则7：避免不必要的注释
- en: That said, not all comments help readers understand code better. In some cases,
    comments actually reduce clarity and confuse the readers of a codebase. To write
    clean code, you should not only use valuable comments but also avoid unnecessary
    comments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，并不是所有的注释都能帮助读者更好地理解代码。在某些情况下，注释实际上会减少代码的清晰度，反而让代码库的读者感到困惑。为了编写干净的代码，你不仅要使用有价值的注释，还要避免不必要的注释。
- en: During my time as a computer science researcher, a skilled student of mine successfully
    applied for a job at Google. He told me that the Google headhunters had criticized
    his code style because he added too many unnecessary comments. Evaluating your
    comments is another way expert coders can ascertain whether you’re a beginner,
    intermediate, or expert coder yourself. Issues in the code, such as breaking style
    guides, being lazy or sloppy with comments, or writing non-idiomatic code for
    a given programming language, are called *code smells* that point to potential
    problems in the code, and expert coders can spot them a mile away.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我作为计算机科学研究员的期间，我的一位技术高超的学生成功地申请到了谷歌的工作。他告诉我，谷歌的猎头批评了他的代码风格，因为他添加了太多不必要的注释。评估你的注释是另一个专家级编码人员用来判断你是初学者、中级还是高级程序员的方式。代码中的问题，例如违反风格指南、懒惰或草率地写注释，或者为某个编程语言写出不符合习惯的代码，统称为*代码异味*，这些都会暴露出潜在的问题，专家级的程序员能一眼识别。
- en: How do you know which comments to leave out? In most cases, a comment is unnecessary
    if it is redundant. For example, if you’ve used meaningful variable names, the
    code often becomes self-explanatory and doesn’t require line-level comments. Let’s
    look at the code snippet with meaningful variable names in [Listing 4-9](#listing4-9).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如何判断哪些注释是多余的？通常情况下，如果注释是冗余的，那它就是不必要的。例如，如果你使用了有意义的变量名，代码通常可以自解释，不需要逐行注释。我们来看一下[清单4-9](#listing4-9)中使用有意义变量名的代码片段。
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 4-9: Code snippet with meaningful variable names'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-9：使用有意义变量名的代码片段
- en: It’s already clear that the code calculates your cumulative investment return
    for 10 years, assuming a 10 percent yield. For the sake of argument, let’s add
    some unnecessary comments in [Listing 4-10](#listing4-10).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已经很明确地计算了你在10年内的累计投资回报，假设收益率为10%。为了论证这一点，让我们在[清单4-10](#listing4-10)中添加一些不必要的注释。
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 4-10: Unnecessary comments'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-10：不必要的注释
- en: All comments in [Listing 4-10](#listing4-10) are redundant. Some would have
    been useful if you’d chosen less meaningful variable names, but explaining a variable
    named `yearly_return` with a comment about it representing the yearly return only
    adds unnecessary clutter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单4-10](#listing4-10)中的所有注释都是多余的。如果你选择了不太有意义的变量名，它们中的一些可能会有用，但用注释解释一个名为 `yearly_return`
    的变量（表示年回报）只会增加不必要的杂乱。'
- en: In general, you should use common sense to decide whether a comment is necessary,
    but here are some of the main guidelines.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你应该凭常识来判断注释是否必要，但以下是一些主要的指南。
- en: Don’t use inline comments These can be avoided entirely by choosing meaningful
    variable names.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要使用内联注释。通过选择有意义的变量名，这些注释完全可以避免。
- en: Don’t add obvious comments In [Listing 4-10](#listing4-10), the comment explaining
    the `for` loop statement is unnecessary. Every coder knows the `for` loop, so
    there is no additional value in adding the comment `# Go over each year` given
    the expression `for year in range(years)`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要添加显而易见的注释。在[清单4-10](#listing4-10)中，解释 `for` 循环语句的注释是多余的。每个程序员都知道 `for` 循环，因此给出注释
    `# 遍历每一年` 与表达式 `for year in range(years)` 一起并没有增加额外的价值。
- en: Don’t comment out old code; remove it We programmers often hang on to our beloved
    code snippets, even after we’ve (grudgingly) decided to remove them, by simply
    commenting them out. This kills your code’s readability! Always remove unnecessary
    code—for peace of mind, you can use a version history tool such as Git that saves
    earlier drafts of your project.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要注释掉旧代码；直接删除它。我们程序员常常在决定删除心爱的代码片段时，会仅仅将它们注释掉，尽管我们已经（不情愿地）决定移除它们。这会破坏代码的可读性！始终删除不必要的代码——为了心安理得，你可以使用版本历史工具（如Git）来保存项目的早期草稿。
- en: Use documentation functionality Many programming languages such as Python come
    with built-in documentation functionality that allows you to describe the purpose
    of each function, method, and class in your code. If each of these has only a
    single responsibility (as per Principle 10), it’s often enough to use the documentation
    instead of comments to describe what your code does.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文档功能，许多编程语言，如Python，内置了文档功能，可以让你描述代码中每个函数、方法和类的目的。如果这些内容各自只有单一责任（根据原则10），通常使用文档而非注释来描述代码功能已经足够。
- en: 'Principle 8: The Principle of Least Surprise'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则8：最小惊讶原则
- en: 'The principle of least surprise states that a component of a system should
    behave in the way most users expect it to behave. This principle is one of the
    golden rules when designing effective applications and user experience. For example,
    if you open the Google search engine, the cursor will place itself in the search
    input field so that you can start typing your search keyword right away, just
    as you would expect: no surprises.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最小惊讶原则指出，系统的一个组件应该以大多数用户预期的方式运行。这一原则是设计有效应用程序和用户体验的黄金法则之一。例如，当你打开Google搜索引擎时，光标会自动定位到搜索输入框，以便你可以立即开始输入搜索关键词，正如你所预期的那样：没有惊讶。
- en: Clean code also leverages this design principle. Say you write a currency converter
    that converts the user’s input from USD to Chinese renminbi. You store the user
    input in a variable. Which variable name is better suited, `user_input` or `var_x`?
    The principle of least surprise answers this question for you!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 干净的代码也遵循这个设计原则。假设你编写了一个货币转换器，将用户输入的美元金额转换为人民币。你将用户的输入存储在一个变量中。哪个变量名更合适，`user_input`
    还是 `var_x`？最小惊讶原则为你解答了这个问题！
- en: 'Principle 9: Don’t Repeat Yourself'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则9：不要重复自己
- en: '*Don’t repeat yourself (DRY)* is a widely recognized principle that recommends,
    intuitively enough, avoiding repetitive code. For example, take the Python code
    in [Listing 4-11](#listing4-11), which prints the same string five times to the
    shell.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要重复自己（DRY）*是一个广泛认可的原则，直观地建议避免重复代码。例如，考虑[列表4-11](#listing4-11)中的Python代码，它将相同的字符串五次打印到终端。'
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 4-11: Printing `hello world` five times'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-11：打印`hello world`五次
- en: Code that is much less repetitive is shown in [Listing 4-12](#listing4-12).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表4-12](#listing4-12)中展示的代码大大减少了重复。'
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 4-12: Reducing the repetition found in [Listing 4-11](#listing4-11)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-12：减少[列表4-11](#listing4-11)中的重复
- en: The code in [Listing 4-12](#listing4-12) will print `hello world` five times,
    just as [Listing 4-11](#listing4-11) does, but without redundancy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表4-12](#listing4-12)中的代码将打印`hello world`五次，就像[列表4-11](#listing4-11)所做的那样，但没有冗余。'
- en: Functions can also be a useful tool to reduce repetition. Say you need to convert
    miles into kilometers in multiple instances in your code, as in [Listing 4-13](#listing4-13).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以是减少重复的有用工具。假设你需要在代码的多个地方将英里转换为千米，如[列表4-13](#listing4-13)所示。
- en: First, you create a variable `miles` and convert it to kilometers by multiplying
    it by 1.60934\. Second, you convert 20 miles to kilometers by multiplying 20 by
    1.60934, and store the result in the variable `distance`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个变量`miles`并通过将其乘以1.60934将其转换为千米。其次，你通过将20乘以1.60934将20英里转换为千米，并将结果存储在变量`distance`中。
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 4-13: Converting miles to kilometers twice'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-13：将英里转换为千米两次
- en: You’ve used the same multiplication procedure twice by multiplying the miles
    value by the factor 1.60934 to convert miles to kilometers. DRY suggests that
    it would be better to write a function `miles_to_km(miles)` once, as in [Listing
    4-14](#listing4-14), rather than performing the same conversion explicitly in
    the code multiple times.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经通过将英里值乘以因子1.60934两次来完成英里到千米的转换。DRY建议，最好像[列表4-14](#listing4-14)中那样写一个`miles_to_km(miles)`函数，而不是在代码中多次显式执行相同的转换。
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 4-14: Using a function to convert miles to kilometers'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-14：使用函数将英里转换为千米
- en: This way, the code is easier to maintain. You could, for example, tweak the
    function to increase the conversion accuracy, and you would have to make the change
    in only one place. In [Listing 4-13](#listing4-13), you’d have to search the code
    for all instances to make that improvement. Applying the DRY principle also makes
    the code easier to understand for human readers. There’s little doubt about the
    purpose of the function `miles_to_km(20)`, but you may have to think harder about
    the purpose of the computation `20 * 1.60934`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，代码更易于维护。例如，你可以调整函数以提高转换的准确性，而只需要在一个地方进行更改。在[列表4-13](#listing4-13)中，你需要在整个代码中查找所有实例来进行改进。应用DRY原则还能使代码更容易被人类读者理解。`miles_to_km(20)`函数的用途几乎没有疑问，但你可能需要更费劲地思考`20
    * 1.60934`计算的目的。
- en: 'Violations of DRY are often abbreviated as WET: *we enjoy typing*, *write everything
    twice*, and *waste everyone’s time*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 违反DRY原则通常缩写为WET：*我们喜欢打字*，*重复写所有内容*，*浪费每个人的时间*。
- en: 'Principle 10: Single Responsibility Principle'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则10：单一职责原则
- en: The single responsibility principle means that every function should have one
    main task. It’s better to use many small functions than one big function accomplishing
    everything at the same time. The encapsulation of functionality reduces the overall
    code complexity.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则意味着每个函数应该有一个主要任务。使用许多小函数比使用一个同时完成所有任务的大函数更好。功能的封装减少了整体代码的复杂性。
- en: 'As a rule of thumb, every class and every function should have only one responsibility.
    Robert C. Martin, the inventor of this principle, defines a *responsibility* as
    a *reason to change*. His gold standard when defining a class and a function,
    thus, is to focus them on a single responsibility so that only the programmer
    who needs this single responsibility changed would request a change in the definition—and
    no other programmer with other responsibilities would even consider to issue a
    change request for the class when assuming, of course, that the code is correct.
    For example, a function that’s responsible for reading data from a database wouldn’t
    also be responsible for processing the data. Otherwise, the function would have
    two reasons to change: a change in the database model and a change in the processing
    requirements. If there are multiple reasons to change, multiple programmers may
    change the same class simultaneously. Your class has too many responsibilities
    and has become messy and cluttered.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，每个类和每个函数应该只有一个职责。这个原则的发明者 Robert C. Martin 将*职责*定义为*更改的理由*。因此，在定义一个类和一个函数时，他的黄金标准是让它们专注于单一职责，这样只有需要更改这个单一职责的程序员才会请求更改定义——而其他具有不同职责的程序员甚至不会考虑对类发出更改请求，当然，前提是代码是正确的。例如，负责从数据库读取数据的函数，不应该同时负责处理数据。否则，这个函数就有两个更改的理由：数据库模型的变化和处理需求的变化。如果有多个更改的理由，多个程序员可能会同时更改同一个类。你的类有太多职责，已经变得混乱不堪。
- en: Let’s consider a small Python example that may run on an ebook reader to model
    and manage a user’s reading experience ([Listing 4-15](#listing4-15)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个小的 Python 示例，它可以在电子书阅读器上运行，用于建模和管理用户的阅读体验（[Listing 4-15](#listing4-15)）。
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 4-15: Modeling the `B``ook` class while violating the single responsibility
    principle'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-15：建模 `Book` 类时违反单一职责原则
- en: 'The code in [Listing 4-15](#listing4-15) defines the class `Book` ❶ with four
    attributes: title, author, publisher, and the current page number. You define
    getter methods for the attributes ❷, along with some minimal functionality to
    move to the next page ❸, which may be called each time the user presses a button
    on the reading device. The function, `print_page()`, is responsible for printing
    the current page to the reading device ❹. This is only given as a stub and would
    be more complicated in the real world. Finally, you create a `Book` instance named
    `python_one_liners` ❺, and you access its attributes via a series of method calls
    and print statements in the last couple of lines. A real ebook reader implementation,
    for example, would call the methods `next_page()` and `print_page()` each time
    the user requests a new page when reading the book.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 4-15](#listing4-15) 中的代码定义了 `Book` 类 ❶，它有四个属性：标题、作者、出版商和当前页码。你为这些属性定义了
    getter 方法 ❷，并实现了一个最基本的功能来翻到下一页 ❸，这个功能可以在每次用户按下电子书阅读器上的按钮时调用。`print_page()` 函数负责将当前页打印到阅读设备上
    ❹。这只是一个占位符，在现实中会更加复杂。最后，你创建了一个名为 `python_one_liners` 的 `Book` 实例 ❺，并通过一系列方法调用和打印语句来访问它的属性。一个真实的电子书阅读器实现，比如，每当用户请求新的一页时，会调用
    `next_page()` 和 `print_page()` 方法。'
- en: 'While the code looks clean and simple, it violates the single responsibility
    principle: the class `Book` is responsible both for modeling data, such as the
    book content, and for printing the book to the device. Modeling and printing are
    two different functions but are encapsulated in a single class. You have multiple
    reasons to change. You may want to change the modeling of the book’s data: for
    example, you could use a database instead of a file-based input/output method.
    But you may also want to change the representation of the modeled data by, for
    example, using another book-formatting scheme on other types of screens.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码看起来简洁明了，但它违反了单一职责原则：`Book` 类既负责建模数据，如书籍内容，又负责将书籍打印到设备上。建模和打印是两个不同的功能，但它们被封装在一个类中。这就有了多个更改的理由。例如，你可能希望更改书籍数据的建模方式：比如，你可以使用数据库，而不是基于文件的输入/输出方法。但你也可能想改变建模数据的表现形式，比如使用另一种书籍格式化方案来适配不同类型的屏幕。
- en: Let’s fix this issue in [Listing 4-16](#listing4-16).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来解决[Listing 4-16](#listing4-16)中的问题。
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 4-16: Adhering to the single responsibility principle'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-16：遵循单一职责原则
- en: The code in [Listing 4-16](#listing4-16) accomplishes the same task, but it
    satisfies the single responsibility principle. You create both a `Book` ❶ and
    a `Printer` ❸ class. The `Book` class represents book metadata and the current
    page number ❷, while the `Printer` class is responsible for printing the book
    to the device. You pass the book for which you want to print the current page
    into the method `Printer.print_page()` ❹. This way, data modeling (*what is the
    data?*) and data presentation (*how is the data presented to the user?*) are decoupled,
    and the code becomes easier to maintain. For example, if you wanted to change
    the book data model by adding a new attribute `publishing_year`, you’d do it in
    the class `Book`. And if you wanted to reflect this change in the data presentation
    by providing readers this information as well, you’d do so in the class `Printer`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-16](#listing4-16)中的代码完成了相同的任务，但它满足了单一职责原则。你创建了`Book` ❶和`Printer` ❸类。`Book`类表示书籍元数据和当前页码
    ❷，而`Printer`类负责将书籍打印到设备上。你将要打印当前页码的书籍传入`Printer.print_page()`方法 ❹。这样，数据建模（*数据是什么？*）和数据呈现（*数据如何展示给用户？*）被解耦，代码变得更容易维护。例如，如果你想通过添加新属性`publishing_year`来更改书籍数据模型，你会在`Book`类中进行修改。而如果你想通过向读者提供此信息来反映数据呈现的变化，你会在`Printer`类中进行修改。'
- en: 'Principle 11: Test'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 11：测试
- en: Test-driven development is an integral part of modern software development.
    No matter how skilled you are, you will make mistakes in your code. In order to
    catch them, you’ll need to run periodic tests or build test-driven code in the
    first place. Every great software company employs multiple levels of testing before
    it ships the final product to the public, since it’s far better to discover errors
    internally than to learn about them from unhappy users.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是现代软件开发的重要组成部分。无论你的技能多么高超，你都会在代码中犯错。为了捕捉这些错误，你需要定期运行测试，或者一开始就编写测试驱动的代码。每个伟大的软件公司都会在发布最终产品之前进行多层次的测试，因为发现内部错误远远比从不满的用户那里得知它们要好得多。
- en: 'While there are no limitations to what types of tests you can perform to improve
    your software applications, these are the most common types:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有限制可以执行哪种类型的测试来改进你的软件应用程序，但以下是最常见的测试类型：
- en: Unit tests With unit tests, you write a separate application to check the correct
    input/output relationship for different inputs of each function in the application.
    The unit tests are usually applied at regular intervals—for example, each time
    a new software version is released. This reduces the likelihood that a software
    change will cause previously stable features to suddenly fail.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试 通过单元测试，你编写一个单独的应用程序，检查每个功能在不同输入下的正确输入/输出关系。单元测试通常定期进行—for example，每次发布新版本的软件时进行。这减少了软件更改导致先前稳定的功能突然失败的可能性。
- en: User acceptance tests These allow people in your target market to use your application
    in a controlled environment while you observe their behavior. You then ask them
    how they liked the application and how to improve it. These tests are usually
    deployed in the final phase of project development after extensive testing within
    the organization.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户验收测试 这些测试允许你的目标市场中的人们在受控环境下使用你的应用程序，同时你观察他们的行为。然后你询问他们对应用程序的看法以及如何改进。这些测试通常在项目开发的最后阶段进行，在组织内部进行过广泛的测试后进行。
- en: Smoke tests Smoke tests are rough tests designed to try to fail the application
    under development before the teams building the software give the application
    to the testing team. In other words, smoke tests are often deployed by the application-building
    team for quality assurance before handing the code to the testing teams. When
    the app passes the smoke test, it’s ready for the next round of testing.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冒烟测试 冒烟测试是粗略的测试，旨在尝试在软件开发团队将应用程序交给测试团队之前让其失败。换句话说，冒烟测试通常由应用程序构建团队在将代码交给测试团队之前进行质量保证。当应用程序通过了冒烟测试，它就准备好进行下一轮测试了。
- en: Performance tests Performance tests aim to show whether the application meets
    or even exceeds its users’ performance requirements rather than testing the actual
    functionality. For instance, before Netflix releases a new feature, it must test
    its website for page-loading time. If the new feature slows down the frontend
    too much, Netflix doesn’t release it, proactively avoiding a negative user experience.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 性能测试 性能测试的目的是展示应用程序是否符合甚至超出用户的性能需求，而不是测试实际功能。例如，在Netflix发布新功能之前，必须测试其网站的页面加载时间。如果新功能使前端变得过慢，Netflix就不会发布该功能，从而主动避免了负面用户体验。
- en: Scalability tests If your application becomes successful, you may have to handle
    1,000 requests per minute instead of the original 2 requests. A scalability test
    will show whether your application is scalable enough to handle that. Note that
    a performant application isn’t necessarily scalable and vice versa. For instance,
    a speed boat is very performant but doesn’t scale to thousands of people at a
    time!
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可扩展性测试 如果你的应用程序变得成功，你可能需要处理每分钟1,000个请求，而不是原本的2个请求。可扩展性测试将展示你的应用程序是否足够可扩展来处理这种情况。请注意，一个性能良好的应用程序不一定具备可扩展性，反之亦然。例如，一艘快艇性能非常好，但无法应付成千上万的人同时使用！
- en: Testing and refactoring will often reduce complexity and the number of errors
    in your code. However, be careful not to over-engineer (see Principle 14)—you
    need to test scenarios that can occur only in the real world. For example, testing
    whether the Netflix application can handle 100 billion streaming devices is unnecessary
    considering there are only 7 billion potential viewers on the planet.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和重构通常会减少代码的复杂性和错误数量。然而，要小心不要过度设计（见原则14）——你需要测试那些只会在现实世界中发生的场景。例如，测试Netflix应用程序是否能够处理1000亿个流媒体设备是没有必要的，因为地球上只有70亿潜在观众。
- en: 'Principle 12: Small Is Beautiful'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则12：小即是美
- en: '*Small code* is code that requires only a relatively small number of lines
    to accomplish a single specified task. Here’s an example of a small code function
    that reads an integer value from a user and ensures the input is indeed an integer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*小代码* 是指只需相对较少的行数就能完成单一特定任务的代码。以下是一个小代码函数的示例，该函数从用户处读取一个整数值并确保输入的确实是一个整数：'
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The code runs until the user types in an integer. Here’s an example run:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 代码会一直运行，直到用户输入一个整数。以下是一个示例运行：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By separating the logic of reading an integer value from a user, you can reuse
    the same function multiple times. But, more importantly, you’ve broken up the
    code into smaller units of functionality that are relatively easy to read and
    understand.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将读取整数值的逻辑与用户交互的逻辑分开，你可以多次重用相同的函数。但更重要的是，你将代码拆分成了较小的功能单元，这些单元相对容易阅读和理解。
- en: Instead, many beginner coders (or lazy intermediate coders) write large, monolithic
    code functions, or so-called *God objects*, that do everything in a centralized
    manner. These monolithic code blocks are a nightmare to maintain. For one thing,
    it’s easier for humans to understand one small code function at a time than to
    try to integrate a specific feature into a 10,000-line code block. You can potentially
    make far more mistakes in a large code block than in a few small functions and
    code blocks that you can then integrate with your existing codebase.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多初学者程序员（或懒惰的中级程序员）会编写大型的、单体的代码函数，或者所谓的*神对象*，这些函数以集中的方式完成所有工作。这些单体代码块维护起来是噩梦。首先，人类一次理解一个小的代码函数比尝试将某个特定功能集成到一个10,000行的代码块中要容易得多。在一个大型代码块中，你可能会犯更多的错误，而在几个小函数和代码块中，错误的可能性则较小，这些小函数和代码块可以与现有代码库集成。
- en: At the beginning of this chapter, [Figure 4-1](#figure4-1) showed that writing
    code becomes more time-consuming with each additional line, though writing clean
    code is much faster in the long run than writing dirty code. [Figure 4-2](#figure4-2)
    compares the time it takes to work with small code blocks versus monolithic code
    blocks. For large code blocks, the time it takes to add each additional line will
    increase superlinearly. If you stack multiple small code functions on top of each
    other, however, the time spent per additional line increases quasi-linearly. To
    best achieve this effect, you’ll need to be sure each code function is more or
    less independent of other code functions. You’ll learn more about this idea in
    the next principle, the Law of Demeter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时，[图4-1](#figure4-1)展示了编写代码时，每增加一行代码会使时间消耗更大，尽管从长远来看，编写清晰的代码比编写混乱的代码更快。[图4-2](#figure4-2)比较了使用小代码块与单体代码块时所需的时间。对于大型代码块，每增加一行代码所需的时间将超线性增加。然而，如果将多个小代码功能叠加在一起，每增加一行代码的时间则接近线性增长。为了最好地实现这一效果，必须确保每个代码功能彼此独立。你将在下一个原则中了解更多关于德梅特法则的内容。
- en: '![Line graph with “Lines of code written” on the x-axis and “Time per additional
    line” on the y-axis. The “Big monolithic code block” line rapidly increases in
    time per line, and the “many small code blocks” line maintains a steady rate.](image_fi/502185c04/f04002.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图表：横轴为“编写的代码行数”，纵轴为“每行所需时间”。“大型单体代码块”曲线随着每行代码时间的增加而快速上升，而“多个小代码块”曲线则保持稳定。](image_fi/502185c04/f04002.png)'
- en: 'Figure 4-2: With the Big Monolithic Code Block, time increases exponentially.
    With the Many Small Code Blocks, time increases quasi-linearly.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2：使用大型单体代码块时，时间呈指数增长；使用多个小代码块时，时间呈接近线性增长。
- en: 'Principle 13: The Law of Demeter'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则13：德梅特法则
- en: Dependencies are everywhere. When you import a library in your code, your code
    depends partially on the library’s functionality, but it will also have interdependencies
    within itself. In object-oriented programming, one function may depend on another
    function, one object on another object, and one class definition on another class
    definition.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系无处不在。当你在代码中导入一个库时，代码部分依赖于该库的功能，但它自身也会有内部依赖。在面向对象编程中，一个函数可能依赖于另一个函数，一个对象可能依赖于另一个对象，一个类定义可能依赖于另一个类定义。
- en: 'To write clean code, minimize the interdependency of your code elements by
    following the *Law of Demeter*, which was proposed in the late 1980s by Ian Holland,
    a software developer working on a software project named after Demeter, the Greek
    goddess of agriculture, growth, and fertility. The project group promoted the
    idea of “growing software” as opposed to simply building it. However, what became
    known as the Law of Demeter has little to do with these arguably more metaphysic
    ideas—it’s a practical approach of writing loosely coupled code in object-oriented
    programming. Here’s a concise quote explaining the Law of Demeter from the project
    group’s website, [http://ccs.neu.edu/home/lieber/what-is-demeter.html](http://ccs.neu.edu/home/lieber/what-is-demeter.html):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写清晰的代码，通过遵循*德梅特法则*，最小化代码元素之间的相互依赖性。该法则由软件开发者Ian Holland在1980年代末提出，他当时正在一个以农业、成长和生育的希腊女神德梅特命名的软件项目中工作。项目组提出了“软件成长”的理念，而不仅仅是构建软件。然而，后来被称为德梅特法则的内容，与这些更具形而上学性质的思想关系不大——它是面向对象编程中编写松耦合代码的一种实际方法。以下是该项目组网站上对德梅特法则的简明解释：[http://ccs.neu.edu/home/lieber/what-is-demeter.html](http://ccs.neu.edu/home/lieber/what-is-demeter.html)：
- en: 'An important concept of Demeter is to split software into at least two parts:
    The first part defines the objects. The second part defines the operations. The
    goal of Demeter is to maintain a loose coupling between the objects and the operations,
    so that one can make modifications to either without serious impact on the other.
    This cuts down significantly on maintenance time.'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 德梅特法则的一个重要概念是将软件划分为至少两部分：第一部分定义对象，第二部分定义操作。德梅特法则的目标是保持对象和操作之间的松耦合，以便可以在不严重影响另一部分的情况下修改其中任意一部分。这大大减少了维护时间。
- en: 'In other words, you should minimize the dependencies of your code objects.
    By reducing dependencies between code objects, you reduce the complexity of your
    code and, in turn, improve maintainability. One specific implication is that every
    object should call only its own methods or methods from adjacent objects rather
    than call methods of objects it obtains from calling a method of an adjacent object.
    For the sake of explanation, let’s define two objects A and B as *friends* if
    A calls a method provided by B. Simple. But what if B’s method returns a reference
    to object C? Now, object A may perform something like this: `B.method_of_B().method_of_C()`.
    This is called *chaining* of method calls—in our metaphor, you talk to a friend
    of your friend. The Law of Demeter says to *talk only to your immediate friends*,
    so it discourages this type of method chaining. This may sound confusing at first,
    so let’s dive into the practical example shown in [Figure 4-3](#figure4-3).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你应该尽量减少代码对象之间的依赖关系。通过减少代码对象之间的依赖，你减少了代码的复杂性，从而提高了可维护性。一个具体的含义是，每个对象应该只调用自己的方法或相邻对象的方法，而不是调用它通过调用相邻对象的方法获得的对象的方法。为了说明这一点，我们假设两个对象A和B是*朋友*，如果A调用了B提供的方法。很简单。但是，如果B的方法返回了一个指向C对象的引用呢？现在，A对象可能会执行类似这样的操作：`B.method_of_B().method_of_C()`。这就是所谓的*方法链式调用*——在我们的比喻中，你与朋友的朋友交谈。迪米特法则要求*仅与直接朋友沟通*，因此不鼓励这种方法链式调用。一开始可能会觉得有些混乱，所以让我们深入到[图
    4-3](#figure4-3)中展示的实际例子。
- en: '![Right side is a visual representation of a bad implementation of calculating
    price per coffee in the upcoming Listing 4-17, and the left side depicts a good
    implementation explored in Listing 4-18.](image_fi/502185c04/f04003.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![右侧是即将在清单 4-17 中展示的计算每杯咖啡价格的错误实现的可视化表示，左侧展示了清单 4-18 中探讨的正确实现。](image_fi/502185c04/f04003.png)'
- en: 'Figure 4-3: Law of Demeter: talking only to your friends to minimize dependencies'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3：迪米特法则：仅与朋友沟通，以最小化依赖关系
- en: '[Figure 4-3](#figure4-3) shows two object-oriented code projects that calculate
    the price per cup of coffee for a given person. One of the implementations violates
    the Law of Demeter, and the other one adheres to it. Let’s start with the negative
    example first in which you use method chaining in the `Person` class to talk to
    a stranger ❶ (see [Listing 4-17](#listing4-17)).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-3](#figure4-3)展示了两个面向对象的代码项目，这些项目计算给定人群的每杯咖啡价格。其中一个实现违反了迪米特法则，另一个则遵循该法则。我们先从负面示例开始，示例中在`Person`类中使用方法链式调用与陌生人沟通
    ❶（参见[清单 4-17](#listing4-17)）。'
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 4-17: Code that violates the Law of Demeter'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-17：违反迪米特法则的代码
- en: You create the method `price_per_cup()` that calculates the cost per cup of
    coffee based on the price of the coffee machine and the number of cups produced
    by this machine. The `Coffee_Cup` object collects information about the price
    of the coffee machine, which influences the price per cup, and passes it to the
    caller of the method `price_per_cup()` on the `Person` object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了方法`price_per_cup()`，该方法根据咖啡机的价格和该咖啡机生产的杯数来计算每杯咖啡的成本。`Coffee_Cup`对象收集有关咖啡机价格的信息，这影响每杯咖啡的价格，并将其传递给`Person`对象中调用`price_per_cup()`方法的调用者。
- en: The diagram on the left of [Figure 4-3](#figure4-3) shows a bad strategy for
    doing so. Let’s look at the step-by-step explanation of the corresponding code
    from [Listing 4-17](#listing4-17).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-3](#figure4-3)左侧的图表展示了一个不好的策略。让我们一步步解释来自[清单 4-17](#listing4-17)的相应代码。'
- en: The method `price_per_cup()` calls the method `Coffee_Cup.get_creator_machine()`
    to get a reference to the `Coffee_Machine` object that created the coffee.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法`price_per_cup()`调用方法`Coffee_Cup.get_creator_machine()`，以获取创建咖啡的`Coffee_Machine`对象的引用。
- en: The method `get_creator_machine()` returns an object reference to the `Coffee_Machine`
    object that has produced the cup’s contents.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法`get_creator_machine()`返回一个指向创建了这杯咖啡的`Coffee_Machine`对象的引用。
- en: The method `price_per_cup()` calls the method `Coffee_Machine.get_price()` on
    the `Coffee_Machine` object it just obtained from the previous `Coffee_Cup` method
    call.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法`price_per_cup()`调用从前一个`Coffee_Cup`方法调用中获得的`Coffee_Machine`对象上的方法`Coffee_Machine.get_price()`。
- en: The method `get_price()` returns the price of the machine.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法`get_price()`返回机器的价格。
- en: The method `price_per_cup()` calculates the depreciation per cup and uses this
    to estimate the price of a single cup. This is returned to the caller of the method.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法`price_per_cup()`计算每杯咖啡的折旧，并使用此信息估算单杯咖啡的价格。然后将结果返回给方法的调用者。
- en: 'This is a bad strategy because the class `Person` depends on two objects: `Coffee_Cup`
    and `Coffee_Machine` ❶. A programmer responsible for maintaining this class must
    know about both parent class definitions—any change in either of those may impact
    the `Person` class as well.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个糟糕的策略，因为`Person`类依赖于两个对象：`Coffee_Cup`和`Coffee_Machine` ❶。负责维护该类的程序员必须了解这两个父类的定义——任何其中一个的变化都可能影响到`Person`类。
- en: The Law of Demeter minimizes such dependencies. You can see a better way to
    model the same problem on the right in [Figure 4-3](#figure4-3) and in [Listing
    4-18](#listing4-18). In this code snippet, the `Person` class doesn’t talk to
    the `Machine` class directly—it doesn’t even need to be aware of its existence!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 德梅特法则最小化了这种依赖关系。你可以在右侧的[图4-3](#figure4-3)和[清单4-18](#listing4-18)中看到更好的方式来建模同一个问题。在这个代码片段中，`Person`类不直接与`Machine`类交互——它甚至不需要知道它的存在！
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 4-18: Code that adheres to the Law of Demeter by not talking to strangers'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-18：遵循德梅特法则的代码，不与陌生人交互
- en: 'Let’s examine this code in a step-by-step manner:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这段代码：
- en: The method `price_per_cup()` calls the method `Coffee_Cup.get_cost_per_cup()`
    to get the estimated price per cup.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法`price_per_cup()`调用方法`Coffee_Cup.get_cost_per_cup()`来获取每杯的估算价格。
- en: The method `get_cost_per_cup()`—before replying to the calling method—calls
    the method `Coffee_Machine.get_price()` to access the price of the machine.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法`get_cost_per_cup()`——在响应调用方法之前——调用方法`Coffee_Machine.get_price()`来获取机器的价格。
- en: The method `get_price()` returns the price information.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法`get_price()`返回价格信息。
- en: The method `get_cost_per_cup()` calculates the price per cup and returns it
    to the calling method `price_per_cup()`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法`get_cost_per_cup()`计算每杯的价格，并将其返回给调用方法`price_per_cup()`。
- en: The method `price_per_cup()` simply forwards this calculated value to its caller
    ❶.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法`price_per_cup()`只是将计算出的值传递给它的调用者 ❶。
- en: 'This is a better approach, because the class `Person` is now independent of
    the class `Coffee_Machine`. The total number of dependencies is reduced. For a
    project with hundreds of classes, reducing dependencies dramatically reduces the
    overall complexity of your application. Here’s the danger in terms of growing
    complexity for large applications: the number of potential dependencies grows
    superlinearly with the number of objects. Roughly speaking, a superlinear curve
    grows faster than a straight line. For example, doubling the number of objects
    can easily quadruple the number of dependencies (which equates to complexity).
    However, following the Law of Demeter can offset this trend by significantly reducing
    the number of dependencies. If every object talks to only *k* other objects and
    you have *n* objects, the total number of dependencies is bounded by *k*n*, which
    is a linear relationship if *k* is a constant. Thus, the Law of Demeter can mathematically
    help you gracefully scale your applications!'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好的方法，因为`Person`类现在独立于`Coffee_Machine`类。依赖关系的总数减少了。对于一个有数百个类的项目，减少依赖关系大大降低了应用程序的整体复杂性。对于大型应用程序，随着复杂度的增长，潜在的依赖关系数量呈超线性增长：大致来说，超线性曲线增长得比直线快。例如，双倍增加对象的数量可能会使依赖关系的数量增加四倍（也就是复杂度）。然而，遵循德梅特法则可以通过显著减少依赖关系的数量来抵消这一趋势。如果每个对象只与*k*个其他对象交互，且你有*n*个对象，那么依赖关系的总数受限于*k*n*，这是一个线性关系（如果*k*是常数）。因此，德梅特法则在数学上可以帮助你优雅地扩展应用程序！
- en: 'Principle 14: You Ain’t Gonna Need It'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则14：你根本不需要它
- en: This principle suggests that you should never implement code if you only *suspect*
    that you’ll need to use it someday in the future—because you ain’t gonna need
    it! Write code only if you’re 100 percent sure it’s necessary. Code for today’s
    needs and not tomorrow’s. If in the future you actually need the code you previously
    only suspected you needed, you can still implement the feature then. But in the
    meantime, you’ve saved many unnecessary lines of code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则建议你永远不要实现你仅仅是*怀疑*将来某一天可能会用到的代码——因为你根本不需要它！只有在你百分之百确定它是必要的时候才编写代码。为今天的需求编写代码，而不是明天的。如果将来你确实需要你之前仅仅怀疑过的代码，你仍然可以在那时实现该功能。但与此同时，你节省了很多不必要的代码行。
- en: 'It helps to think from first principles: the simplest and cleanest code is
    the empty file. Now, go from there—what do you *need* to add to that? In Chapter
    3, you learned about the MVP: code that is stripped of features to focus on the
    core functionality. If you minimize the number of features you pursue, you’ll
    obtain cleaner and simpler code than you could ever attain through refactoring
    methods or all other principles combined. Consider leaving out features that provide
    relatively little value compared to others. Opportunity costs are seldom measured
    but are often significant. You should really *need* a feature before you even
    consider implementing it.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于从基本原则出发思考：最简单、最干净的代码就是空文件。从那里开始——你*需要*添加什么？在第三章中，你学到了MVP：去除特性后的代码，专注于核心功能。如果你最小化所追求的特性数量，你将获得比通过重构方法或所有其他原则结合起来所能达到的更简洁、更清晰的代码。考虑剔除那些与其他特性相比，提供相对较少价值的特性。机会成本往往没有得到衡量，但通常是显著的。在考虑实现某个功能之前，你真的*需要*它。
- en: 'An implication of this is to avoid *overengineering*: creating a product that
    is more performant and robust or contains more features than needed. It adds unnecessary
    complexity, which should immediately ring your alarm bells.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点的一个含义是要避免*过度工程*：创建一个性能和健壮性更强或包含更多特性的产品，超出了实际需要。这增加了不必要的复杂性，这应当立刻引起警觉。
- en: For example, I’ve often encountered problems that could be solved within a few
    minutes using a naive algorithmic approach but, like many programmers, I refused
    to accept the minor limitations of these algorithms. Instead, I studied state-of-the-art
    clustering algorithms to eke out a few percentage points of clustering performance
    compared to the simple KMeans algorithm. These long-tail optimizations were incredibly
    costly—I had to spend 80 percent of the time to obtain 20 percent of the improvement.
    This would have been unavoidable if I’d *needed* that 20 percent and had no other
    way to get it, but in reality, I didn’t need to implement fancy clustering algorithms.
    A typical case of overengineering!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我常常遇到这样的问题，使用一种简单的算法方法可以在几分钟内解决，但像许多程序员一样，我拒绝接受这些算法的局限性。于是，我研究了最先进的聚类算法，试图比简单的KMeans算法获得几个百分点的聚类性能。这些尾部优化代价极高——我花了80%的时间，只获得了20%的提升。如果我*需要*这20%的提升，并且没有其他办法获取它，这种情况是不可避免的，但实际上，我并不需要实现复杂的聚类算法。这是过度工程的典型案例！
- en: 'Always go for the low-hanging fruit first. Use naive algorithms and straightforward
    methods to establish a benchmark, then analyze which new feature or performance
    optimization would yield superior results for the overall application. Think global,
    not local: focus on the big picture (as per Principle 1) rather than on small,
    time-consuming fixes.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 总是先从容易实现的部分入手。使用简单的算法和直接的方法建立基准，然后分析哪些新特性或性能优化能为整体应用带来更好的结果。要从全局出发，而不是局部：关注大局（如原则1所示），而非那些耗时的小修小补。
- en: 'Principle 15: Don’t Use Too Many Levels of Indentation'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则15：不要使用过多的缩进层级
- en: Most programming languages use text indentation to visualize the hierarchical
    structure of potentially nested conditional blocks, function definitions, or code
    loops. Overusing indentation, however, can decrease the readability of your code.
    [Listing 4-19](#listing4-19) shows an example of a code snippet with too many
    levels of indentation, which makes it hard to quickly understand.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言使用文本缩进来可视化可能嵌套的条件块、函数定义或代码循环的层级结构。然而，过度使用缩进会降低代码的可读性。[示例 4-19](#listing4-19)展示了一个代码片段，缩进层级过多，导致难以快速理解。
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 4-19: Too many levels of nested code blocks'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-19：嵌套代码块的层级过多
- en: If you now try to guess the output of this code snippet, you’ll find it’s actually
    difficult to trace. The code function `if_confusion(x, y)` performs relatively
    simple checks on variables `x` and `y`. However, it’s easy to get lost in the
    different levels of indentation. The code is not clean at all.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在试图猜测这段代码片段的输出，你会发现实际上很难追踪。代码函数`if_confusion(x, y)`对变量`x`和`y`进行了相对简单的检查。然而，在不同的缩进层级中，很容易迷失。代码根本不简洁。
- en: '[Listing 4-20](#listing4-20) shows how to write the same code more cleanly
    and simply.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-20](#listing4-20) 展示了如何更加简洁清晰地编写相同的代码。'
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 4-20: Fewer levels of nested code blocks'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-20：减少嵌套代码块的层级
- en: In [Listing 4-20](#listing4-20), we reduced indentation and nesting. You can
    now go over all checks and see what applies first to your two arguments `x` and
    `y`. Most coders will enjoy reading flat code much more than reading highly nested
    code—even if it comes at the expense of redundant checks; here, for example, `x>y`
    is checked multiple times.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 4-20](#listing4-20)中，我们减少了缩进和嵌套。现在，你可以检查所有条件，看看哪些条件首先适用于你的两个参数`x`和`y`。大多数程序员比起阅读高度嵌套的代码，更喜欢阅读扁平化的代码——即使这意味着冗余检查；例如，这里`x>y`就被检查了多次。
- en: 'Principle 16: Use Metrics'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则16：使用度量
- en: Use code quality metrics to track the complexity of your code over time. The
    ultimate, if informal, metric is known as the number of WTFs per minute, intended
    to measure your code readers’ frustration. The results will be low for clean and
    simple code and high for dirty, confusing code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码质量度量来跟踪你代码随时间变化的复杂性。最终的（虽然非正式的）度量标准被称为每分钟的 WTF 数，旨在衡量代码阅读者的挫败感。清晰简洁的代码其结果会很低，而脏乱复杂的代码结果则会很高。
- en: As a proxy for this hard-to-quantify standard, you can use established metrics
    such as the NPath complexity or cyclomatic complexity discussed in Chapter 1.
    For most IDEs, many online tools and plug-ins will automatically calculate the
    complexity as you write your source code. These include CyclomaticComplexity,
    which you can find by searching in the plug-ins section of JetBrains at [https://plugins.jetbrains.com/](https://plugins.jetbrains.com/).
    In my experience, the actual measure of complexity used is less important than
    being aware of the fact that you need to weed out complexity wherever you can.
    I highly recommend using these tools to help you write cleaner and simpler code.
    The return on your invested time will be phenomenal.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一难以量化标准的代理，你可以使用如第1章所讨论的 NPath复杂度或圈复杂度等已建立的度量标准。对于大多数IDE，许多在线工具和插件会在你编写源代码时自动计算复杂性。这些工具包括CyclomaticComplexity，你可以在
    JetBrains 的插件部分通过 [https://plugins.jetbrains.com/](https://plugins.jetbrains.com/)
    查找它。在我看来，实际使用的复杂性度量标准并不重要，关键是意识到你需要尽可能地去除复杂性。我强烈建议使用这些工具，帮助你编写更清晰、更简洁的代码。你投入的时间将获得极高的回报。
- en: 'Principle 17: Boy Scout Rule and Refactoring'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则17：童子军法则与重构
- en: 'The boy scout rule is simple: *leave the campground cleaner than you found
    it*. It’s a great rule to live and code by. Get into the habit of cleaning up
    every piece of code you encounter. This will not only improve the codebases you’re
    involved in and make your own life easier but also help you develop the sharp
    eye of a master coder who can evaluate source code quickly. As a bonus, it’ll
    help your team be more productive, and your colleagues will be grateful for your
    value-oriented attitude. Note that this shouldn’t violate the rule we stated earlier
    about avoiding premature optimization (overengineering). Spending time to clean
    up your code to reduce complexity is almost always efficient. Doing so will yield
    big dividends in reduced maintenance overhead, bugs, and cognitive demands. Put
    succinctly, overengineering is likely to *increase* complexity whereas cleaning
    up the code will *reduce* complexity.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 童子军法则很简单：*将营地保持得比你找到时更干净*。这是一个很好的生活和编码准则。养成清理每一段你遇到的代码的习惯。这不仅能改善你参与的代码库，让你自己的工作更轻松，还能帮助你培养像大师级程序员那样的敏锐眼光，快速评估源代码。额外的好处是，它能提高你团队的生产力，同事们也会感激你这种注重价值的态度。需要注意的是，这不应该违背我们之前提到的避免过早优化（过度工程化）的原则。花时间清理代码以减少复杂性几乎总是高效的。这样做将大大减少维护开销、bug和认知负担。简言之，过度工程化往往会*增加*复杂性，而清理代码则能*减少*复杂性。
- en: The process of improving your code is called *refactoring*. You could argue
    that refactoring is the overall method comprising every principle we’ve discussed
    here. As a great coder, you’ll incorporate many of the clean code principles from
    the beginning. Even then, however, you’ll still need to occasionally refactor
    your code to clean up any messes you’ve made. In particular, you should refactor
    your code before releasing any new features to keep the code clean.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 改进代码的过程被称为*重构*。你可以说，重构是包含我们讨论的每个原则的整体方法。作为一名优秀的程序员，你从一开始就会融入许多清洁代码的原则。然而，即便如此，你仍然需要偶尔重构代码，清理你所犯的任何错误。特别是，在发布任何新特性之前，你应该重构代码，以保持代码的整洁。
- en: There are many techniques for refactoring code. One is to explain your code
    to a colleague or have them look it over in order to discover any poor decisions
    you’ve made and had not noticed on your own. For example, you may have created
    two classes, `Cars` and `Trucks`, because you expected your application would
    need to model both. As you explain your code to your teammate, you realize that
    you don’t use the class `Trucks` very often—and when you do, you use methods that
    already exist in the `Car` class. Your colleague suggests creating a `Vehicle`
    class that handles all cars and trucks. This allows you to get rid of many lines
    of code immediately. This type of thinking can result in enormous improvements,
    since it will force you to account for your decisions and explain your project
    from a bird’s-eye view.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多重构代码的技巧。其中一种方法是向同事解释你的代码，或者让他们帮忙查看，以发现你可能没有注意到的糟糕决策。例如，你可能创建了两个类，`Cars`和`Trucks`，因为你预期你的应用程序需要同时建模这两者。当你向同事解释代码时，你意识到你并不经常使用`Trucks`类——而且当你使用它时，你用的方法已经存在于`Car`类中。你的同事建议创建一个`Vehicle`类，处理所有的汽车和卡车。这样，你就可以立即删除许多行代码。这种思考方式可以带来巨大的改善，因为它迫使你从宏观角度审视你的决策，并解释你的项目。
- en: If you’re an introverted coder, you can explain your code to a rubber duck instead—a
    technique known as *rubber duck debugging*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个内向的程序员，你可以改为向一只橡胶鸭解释你的代码——这是一种被称为*橡胶鸭调试*的技巧。
- en: Beyond speaking to your colleagues (or your rubber duck), you can use the other
    clean code principles listed here to quickly evaluate your code from time to time.
    When you do, you’ll likely discover some tweaks you can apply quickly to greatly
    reduce complexity by cleaning up your codebase. This integral part of your software
    development process will improve your results significantly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与同事（或橡胶鸭）交流外，你还可以利用这里列出的其他简洁代码原则，时不时地快速评估你的代码。当你这样做时，你很可能会发现一些可以快速应用的调整，从而通过清理代码库大幅度减少复杂性。这个软件开发过程中不可或缺的部分将显著提高你的成果。
- en: Conclusion
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you’ve learned 17 principles for how to write clean and simple
    code. You’ve learned that clean code reduces complexity and increases your productivity
    as well as the scalability and maintainability of your project. You’ve learned
    that you should use libraries wherever possible to reduce clutter and increase
    your code quality. You’ve learned that choosing meaningful names of variables
    and functions while adhering to standards is important to reduce friction for
    future readers of your code. You’ve learned to design functions to do one thing
    only. Reducing complexity and increasing scalability by minimizing dependencies
    (according to the Law of Demeter) can be done by avoiding direct and indirect
    method chaining. You’ve learned to comment code in a way that provides a valuable
    glimpse into your mind, but you’ve also learned to avoid unnecessary or trivial
    comments. And, most importantly, you’ve learned that the key to unlocking your
    clean code superpower is to code for humans, not machines.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了17条编写简洁清晰代码的原则。你了解了简洁代码如何减少复杂性，提高生产力，并增强项目的可扩展性和可维护性。你知道了在可能的情况下应使用库，以减少冗余并提高代码质量。你明白了选择有意义的变量和函数名称，并遵守标准，能有效减少未来阅读代码者的理解障碍。你学会了设计只做一件事的函数。通过最小化依赖（根据德梅特法则）来减少复杂性并提高可扩展性，可以通过避免直接和间接的方法链调用来实现。你学会了以一种能展现你思路的方式注释代码，但你也学会了避免不必要或琐碎的注释。最重要的是，你明白了释放简洁代码超级能力的关键是为人类编写代码，而不是为机器编写代码。
- en: You can gradually improve your clean code–writing skills by collaborating with
    great coders, reading their code on GitHub, and studying the best practices in
    your programming language. Integrate a linter that dynamically checks your code
    against those best practices into your programming environment. From time to time,
    revisit these clean code principles and check your current project against them.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过与优秀的程序员合作，阅读他们在GitHub上的代码，以及研究你所使用编程语言中的最佳实践，逐渐提高你的简洁代码编写技巧。将一个动态检查你代码是否符合最佳实践的代码审查工具（linter）集成到你的编程环境中。时不时地，回顾这些简洁代码的原则，并将其应用到你当前的项目中。
- en: 'In the next chapter, you’ll learn another principle of effective coding that
    goes beyond just writing clean code: premature optimization. You’ll be surprised
    by how much time and effort is wasted by programmers who haven’t yet figured out
    that *premature optimization is the root of all evil*!'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习另一个有效编码的原则，它不仅仅是写出干净的代码：过早优化。你会惊讶地发现，许多程序员在尚未意识到*过早优化是万恶之源*的情况下，浪费了大量的时间和精力。
