- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write Clean and Simple Code
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Clean code* is code that’s easy to read, understand, and change. It is minimal
    and concise, as long as those attributes do not interfere with readability. While
    writing clean code is more an art than a science, the software engineering industry
    has agreed on multiple principles that, if followed, will help you write *cleaner*
    code. In this chapter, you’ll learn 17 principles for how to write clean code
    that will significantly improve your productivity and combat the problem of complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder about the difference between *clean* and *simple* code. These
    two concepts are closely interrelated because clean code tends to be simple and
    simple code tends to be clean. But it’s possible to encounter complex code that
    is still clean. Simplicity concerns the avoidance of complexity. Clean code goes
    one step further and also concerns itself with managing unavoidable complexity—for
    instance, through the effective use of comments and standards.
  prefs: []
  type: TYPE_NORMAL
- en: Why Write Clean Code?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, you learned that complexity is the number one public
    enemy for any code project. You’ve learned that simplicity increases your productivity,
    your motivation, and the maintainability of your codebase. In this chapter, we’ll
    carry this concept a step further and show you how to write clean code.
  prefs: []
  type: TYPE_NORMAL
- en: Clean code is easier to understand for both your future self and your fellow
    coders, since people are more likely to add to clean code and the potential for
    collaboration will increase. Consequently, clean code can significantly reduce
    a project’s costs. As Robert C. Martin points out in his book *Clean Code* (Prentice
    Hall, 2008), coders spend the vast majority of their time reading old code in
    order to write new code. If the old code is easy to read, this will speed the
    process considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, the ratio of time spent reading versus writing is well over 10 to 1\.
    We are constantly reading old code as part of the effort to write new code. [Therefore,]
    making it easy to read makes it easier to write.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we take this ratio literally, this relationship is visualized in [Figure
    4-1](#figure4-1). The x-axis corresponds to the number of lines written in a given
    code project. The y-axis corresponds to the time to write one additional line
    of code. In general, the more code you’ve already written in one project, the
    more time it takes to write an additional line of code. This is true for both
    clean and dirty code.
  prefs: []
  type: TYPE_NORMAL
- en: Say you’ve written *n* lines of code, and you add the *n* + 1st line of code.
    Adding this line may potentially affect all previously written lines. It may,
    for example, have a small performance penalty, which impacts the overall project.
    It may use a variable defined somewhere else. It may introduce a bug (with probability
    *c*), and to find that bug, you must search the whole project. That means your
    expected time—and therefore, costs—per line of code is *c * T*(*n*) for a steadily
    increasing time function *T* with increasing input *n*. Adding a line may also
    force you to write additional lines of code to ensure backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lengthier code may introduce many other complications, but you get the point:
    the more code you’ve written, the more the additional complexity will slow your
    progress.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Line graph with “Lines of code written” on the x-axis and “Time per additional
    line” on the y-axis. The “quick and dirty code” rapidly increases in time per
    line and the “Thoughtful and clean code” line maintains a steady rate.](image_fi/502185c04/f04001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: Clean code improves the scalability and maintainability of your
    codebase.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-1](#figure4-1) also shows the difference between writing dirty and
    clean code. Dirty code is less time-consuming in the short term and for small
    code projects—if there were no benefits to writing dirty code, nobody would do
    it! If you cram all your functionality into a 100-line code script, you don’t
    need to invest a lot of time thinking about and restructuring your project. Problems
    begin to arise only as you add more code: as your monolithic code file grows from
    100 to 1,000 lines, it’ll be less efficient than code developed using a more thoughtful
    approach in which you structure the code logically in different modules, classes,
    or files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule of thumb: always write thoughtful and clean code. The additional
    costs for rethinking, refactoring, and restructuring will pay back many times
    over for any non-trivial project. The stakes can sometimes be quite high: in 1962
    the National Aeronautics and Space Administration (NASA) attempted to send a spacecraft
    to Venus, but a tiny bug—the omission of a hyphen in the source code—caused the
    engineers to issue a self-destruct command, which resulted in the loss of a rocket
    worth more than $18 million at the time. If the code had been cleaner, the engineers
    may have caught the error before the launch.'
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not you’re doing rocket science, the philosophy of carefully crafting
    your programming will carry you further in life. Simple code also facilitates
    scaling your project to more programmers and more features because fewer coders
    will be scared off by the project’s complexity.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s learn how to write clean and simple code, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing Clean Code: The Principles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I learned to write clean code the hard way when I was developing a distributed
    graph-processing system from scratch as part of my doctoral research. If you’ve
    ever written a distributed application—where two processes residing on different
    computers interact with each other via messages—you know that the complexity can
    quickly become overwhelming. My code grew to thousands of lines, and bugs popped
    up frequently. I didn’t make any progress for weeks at a time; it was very frustrating.
    The concepts were convincing in theory, but somehow they didn’t work in my implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after a month or so working full-time on the codebase without seeing
    any encouraging progress, I decided to simplify the codebase radically. Among
    other changes, I started to use libraries instead of coding functionality myself.
    I removed code blocks that I had commented out for a possible later use. I renamed
    variables and functions. I structured the code in logical units and created new
    classes instead of cramming everything into a “God” class. After a week or so,
    not only was my code more readable and understandable for other researchers, it
    was also more efficient and less buggy. My frustration morphed into enthusiasm—clean
    code had rescued my research project!
  prefs: []
  type: TYPE_NORMAL
- en: 'Improving your codebase and reducing complexity is called *refactoring*, and
    it must be a scheduled and crucial element of your software development process
    if you want to write clean and simple code. Writing clean code is mainly about
    keeping two things in mind: knowing the best ways to build your code from the
    ground up and going back to make revisions periodically. I’ll cover some important
    techniques for keeping your code clean in the following 17 principles. While each
    principle covers a unique strategy to write cleaner code, some of the principles
    overlap, but I felt like combining the overlapping principles would reduce clarity
    and actionability. With this out of the way, let’s get started with the first
    one!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 1: Think About the Big Picture'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you work on a non-trivial project, you’ll likely end up with multiple files,
    modules, and libraries working together within the overall application. Your *software
    architecture* defines how your software elements interact. Good architectural
    decisions can initiate huge leaps of improvement in performance, maintainability,
    and usability. To build a good architecture, you’ll need to take a step back and
    think about the big picture. Decide on features that are needed in the first place.
    In Chapter 3 about building an MVP, you learned how to focus your project on the
    necessary features. If you do this, you save yourself a lot of work and the code
    will be a lot more clean per design. At this point, we assume you’ve already created
    your first application with multiple modules, files, and classes. How can you
    apply big-picture thinking to impose some order on the mess? Considering the following
    questions can give you some ideas on how to best make your code cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: Do you need all the separate files and modules, or can you consolidate some
    of them and reduce the interdependency of your code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Can you divide a large and complicated file into two simpler ones? Note that
    there’s usually a sweet spot between two extremes: a large, monolithic code block
    that is completely unreadable or a myriad of small code blocks that are impossible
    to mentally keep track of. Neither is desirable, and most stages in between are
    better options. Think of it as an inverted U curve where the maximum represents
    the sweet spot between a few large code blocks and many small code blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you generalize code and turn it into a library to simplify the main application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you use existing libraries to get rid of many lines of code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you use caching to avoid recomputing the same result over and over again?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you use more straightforward and suitable algorithms that accomplish the
    same things as your current algorithms?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you remove premature optimizations that don’t improve the overall performance?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you use another programming language that would be more suitable for the
    problem at hand?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big-picture thinking is a time-efficient way to drastically reduce the complexity
    of your application as a whole. Sometimes it’s hard to implement those changes
    at later various stages of the process or because of collaborations that might
    interfere. In particular, this kind of high-level thinking can be difficult for
    applications with millions of lines of code, like the Windows operating system.
    However, you simply cannot afford to ignore these questions entirely because all
    the small tweaks combined cannot mitigate the adverse effects of wrong or lazy
    design choices. If you’re working in a small startup or just for yourself, you
    can usually make bold architectural decisions, such as changing the algorithm,
    swiftly. If you’re working in a big organization, you might not have as much flexibility.
    The bigger the application, the more likely you are to find easy fixes and low-hanging
    fruit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 2: Stand on the Shoulders of Giants'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Reinventing the wheel is rarely valuable. Programming is a decades-old industry.
    The best coders in the world have provided us with a great legacy: a database
    of millions of fine-tuned and well-tested algorithms and code functions. Accessing
    the collective wisdom of millions of programmers is as simple as using a one-line
    import statement. There’s no reason not to use this superpower in your own projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Using library code is likely to improve the efficiency of your code. Functions
    that have been used by thousands of coders tend to be much more optimized than
    your own. Furthermore, library calls are easier to understand and take less space
    in your code project than code you’ve written in yourself. For example, suppose
    you need a clustering algorithm to visualize clusters of customers. You can *stand
    on the shoulders of giants* by importing a well-tested clustering algorithm from
    an external library and passing your data into it. This is far more time-efficient
    than using your own code—it will implement the same functionality with fewer bugs,
    less space, and more performant code. Libraries are among the primary tools that
    master coders use to increase their productivity thousandfold.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of some library code that can save you time, here’s the two-liner
    that imports the KMeans module from the scikit-learn Python library to find two
    cluster centers on a given dataset stored in variable `X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the KMeans algorithm on your own instead would take you several
    hours and likely more than 50 lines of code, cluttering your codebase so that
    all future code would become harder to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 3: Code for People, Not Machines'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may think that the primary purpose of a piece of source code is to define
    what machines should do and how they should do it. Not so. The single purpose
    of a programming language such as Python is to help humans write code. Compilers
    do the heavy lifting and translate your high-level code to low-level code that
    is understandable by your machine. Yes, your code will eventually be run by a
    machine. But code is still written mainly by humans, and in today’s software development
    process, the code likely must pass many levels of human judgment before it is
    deployed. First and foremost, you’re writing code for people, not machines.
  prefs: []
  type: TYPE_NORMAL
- en: Always assume that others will read your source code. Imagine you moved to a
    new project and someone else had to take your place at the codebase. There are
    many ways to make their job easier and minimize frustration. First of all, use
    meaningful variable names so that readers can easily follow what a given line
    of code is intended to accomplish. [Listing 4-1](#listing4-1) shows an example
    of poorly chosen variable names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: Code that uses poorly chosen variable names'
  prefs: []
  type: TYPE_NORMAL
- en: It’s difficult to guess what this code computes. [Listing 4-2](#listing4-2),
    on the other hand, is a semantically equivalent code that uses meaningful variable
    names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-2: Code that uses meaningful variable names'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s much easier to understand what’s happening here: the variable names indicate
    how to calculate the value of an initial investment of 10,000 compounded over
    10 years, assuming an annual return of 10 percent.'
  prefs: []
  type: TYPE_NORMAL
- en: While we won’t go into every way to implement this principle here (though later
    principles will cover some approaches in more detail), it also manifests in other
    aspects that might clarify intent, such as indentation, whitespace, comments,
    and line lengths, among others. Clean code radically optimizes for human readability.
    As Martin Fowler, an international expert on software engineering and author of
    the popular book *Refactoring*, argues, “Any fool can write code that a computer
    can understand. Good programmers write code that humans can understand” (Addison-Wesley,
    1999).
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 4: Use the Right Names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relatedly, experienced coders have often agreed on a set of specific naming
    conventions for functions, function arguments, objects, methods, and variables,
    both implicit and explicit. Everybody benefits from adhering to these conventions:
    code becomes more readable, easier to understand, and less cluttered. If you violate
    these conventions, readers of your code are likely to assume that it was written
    by an inexperienced programmer and may not take your code seriously.'
  prefs: []
  type: TYPE_NORMAL
- en: These conventions may differ from language to language. For example, by convention
    Java uses `camelCaseNaming` for naming variables, while Python uses `underscore_naming`
    for variables and functions. If you start using camel case in Python, it may confuse
    the reader. You don’t want your untraditional naming conventions to distract those
    reading your code. You want them to focus on what your code does, not on your
    coding style. As outlined by the *principle of least surprise*, there’s no value
    in surprising other coders by choosing unconventional variable names.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s dive into a list of naming rules you can consider when writing source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Choose descriptive names Say you create a function to convert currencies from
    United States dollars (USD) to euros (EUR) in Python. Call it `usd_to_eur(amount)`
    rather than `f(x)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose unambiguous names You may think that `dollar_to_euro(amount)` would be
    a good name for a currency conversion function. While it is better than `f(x)`,
    it’s worse than `usd_to_eur(amount)` because it introduces an unnecessary degree
    of ambiguity. Do you mean United States, Canadian, or Australian dollars? If you’re
    in the United States, the answer may be obvious to you, but an Australian coder
    may not know that the code is written in the United States and may assume a different
    output. Minimize these confusions!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use pronounceable names Most coders subconsciously read code by pronouncing
    it in their minds. If a variable name is unpronounceable, the problem of deciphering
    it takes attention and costs precious mental space. For example, the variable
    name `cstmr_lst` may be descriptive and unambiguous, but it’s not pronounceable.
    Choosing the variable name `customer_list` is well worth the additional space
    in your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use named constants, not magic numbers In your code, you may use the magic number
    0.9 multiple times as a factor to convert a sum in USD to a sum in EUR. However,
    the reader of your code—including your future self—has to think about the purpose
    of this number. It’s not self-explanatory. A far better way of handling the magic
    number 0.9 is to store it in an all-uppercase variable—used to indicate that it
    is a constant that doesn’t change—such as `CONVERSION_RATE = 0.9` and use it as
    a factor in your conversion computations. For example, you may then calculate
    your income in EUR as `income_euro = CONVERSION_RATE * income_usd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are only a few naming rules. Beyond these quick tips, the best way to
    learn naming conventions is to study the well-crafted code of experts. Googling
    the relevant conventions (for example, “Python naming conventions”) is a good
    place to start. You might also read programming tutorials, join StackOverflow
    to query fellow coders, check out the GitHub code of open source projects, and
    join the Finxter blog community of ambitious coders who help each other grow their
    programming skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 5: Adhere to Standards and Be Consistent'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every programming language comes with an implicit or explicit set of rules on
    how to write clean code. If you are an active coder, these standards will always
    catch up with you eventually. However, you can speed the process by taking the
    time to study the code standard of the programming language you’re learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can access the official Python style guide, PEP 8, at this
    link: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/).
    As with any style guide, PEP 8 defines the correct code layout and indentation;
    the method to set line breaks; the maximum number of characters in a line; the
    correct use of commenting; the formulation of your own function documentation;
    and the conventions for naming classes, variables, and functions. For instance,
    [Listing 4-3](#listing4-3) shows a positive example from PEP 8’s guidelines on
    the correct way to use different stylings and conventions. You use four spaces
    per indentation level, align function arguments consistently, use single whitespaces
    when listing comma-separated values in argument lists, and correctly name functions
    and variables by combining multiple words with the underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-3: Use of indentation, spacing, and naming in Python according to
    the PEP 8 standard'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-4](#listing4-4) shows the wrong way to do it. The arguments are
    not aligned, multiple words are not properly combined in variable and function
    names, argument lists are not properly separated by a single empty space, and
    indentation levels have only two or three empty spaces instead of four:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-4: Incorrect use of indentation, spacing, and naming in Python'
  prefs: []
  type: TYPE_NORMAL
- en: All readers of your code will expect you to adhere to the accepted standards.
    Anything else will result in confusion and frustration.
  prefs: []
  type: TYPE_NORMAL
- en: Reading through style guides can be a tedious task, though. As a less boring
    way to learn conventions and standards, use linters and integrated development
    environments (IDEs) that tell you where and how you’ve made mistakes. In a weekend
    hackathon with my Finxter team, we created a tool called Pythonchecker.com that
    playfully helps you refactor your Python code from messy to super clean. For Python,
    one of the best projects in this regard is the *black* module for PyCharm. Similar
    tools exist for all major programming languages. Just search the net for *<Your
    Language> Linter* to find the best tools for your programming environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 6: Use Comments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, when writing code for humans, not machines, you’ll need
    to use comments to help readers understand it. Consider the code without comments
    in [Listing 4-5](#listing4-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-5: Code without comments'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-5](#listing4-5) analyzes a short text snippet from Shakespeare’s
    *Romeo and Juliet* using regular expressions. If you’re not familiar with regular
    expressions, you’ll probably struggle to understand what the code does. Even the
    meaningful variable names don’t help much.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see if a few comments can resolve your confusion (see [Listing 4-6](#listing4-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-6: Code with comments'
  prefs: []
  type: TYPE_NORMAL
- en: The two short comments (❶ ❷) illuminate the purpose of the regular expression
    patterns `'\\bf\w+\\b'` and `'\\bl\w+\\b'`. I won’t dive deeply into regular expressions
    here, but the example shows how comments can help you get a rough understanding
    of other people’s code without understanding the syntactic sugar.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use comments to abstract over blocks of code. For example, if you
    have five code lines that deal with updating customer information in a database,
    add a short comment before the block to explain this, as in [Listing 4-7](#listing4-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-7: Commented blocks give an overview of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows how an online shop completes a customer order in two high-level
    steps: processing the next order ❶ and shipping the order ❷. The comments help
    you understand the purpose of the code quickly without needing to decipher each
    method call.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use comments to warn programmers of potentially undesirable consequences.
    For example, [Listing 4-8](#listing4-8) alerts us that calling the function `ship_yacht()`
    will actually ship an expensive yacht to a customer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-8: Comments as warnings'
  prefs: []
  type: TYPE_NORMAL
- en: You can employ comments in many more useful ways; they are not only about applying
    the standards correctly. Keep the principle *code for humans* at the top of your
    mind when writing comments, and you will be fine. As you read code from experienced
    programmers, you’ll absorb the unspoken rules effectively and almost automatically
    over time. Since you’re the expert on code you’ve written, helpful comments give
    outsiders a glimpse into your thinking. Don’t miss out on sharing your insights
    with other people!
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 7: Avoid Unnecessary Comments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That said, not all comments help readers understand code better. In some cases,
    comments actually reduce clarity and confuse the readers of a codebase. To write
    clean code, you should not only use valuable comments but also avoid unnecessary
    comments.
  prefs: []
  type: TYPE_NORMAL
- en: During my time as a computer science researcher, a skilled student of mine successfully
    applied for a job at Google. He told me that the Google headhunters had criticized
    his code style because he added too many unnecessary comments. Evaluating your
    comments is another way expert coders can ascertain whether you’re a beginner,
    intermediate, or expert coder yourself. Issues in the code, such as breaking style
    guides, being lazy or sloppy with comments, or writing non-idiomatic code for
    a given programming language, are called *code smells* that point to potential
    problems in the code, and expert coders can spot them a mile away.
  prefs: []
  type: TYPE_NORMAL
- en: How do you know which comments to leave out? In most cases, a comment is unnecessary
    if it is redundant. For example, if you’ve used meaningful variable names, the
    code often becomes self-explanatory and doesn’t require line-level comments. Let’s
    look at the code snippet with meaningful variable names in [Listing 4-9](#listing4-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-9: Code snippet with meaningful variable names'
  prefs: []
  type: TYPE_NORMAL
- en: It’s already clear that the code calculates your cumulative investment return
    for 10 years, assuming a 10 percent yield. For the sake of argument, let’s add
    some unnecessary comments in [Listing 4-10](#listing4-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-10: Unnecessary comments'
  prefs: []
  type: TYPE_NORMAL
- en: All comments in [Listing 4-10](#listing4-10) are redundant. Some would have
    been useful if you’d chosen less meaningful variable names, but explaining a variable
    named `yearly_return` with a comment about it representing the yearly return only
    adds unnecessary clutter.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should use common sense to decide whether a comment is necessary,
    but here are some of the main guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t use inline comments These can be avoided entirely by choosing meaningful
    variable names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t add obvious comments In [Listing 4-10](#listing4-10), the comment explaining
    the `for` loop statement is unnecessary. Every coder knows the `for` loop, so
    there is no additional value in adding the comment `# Go over each year` given
    the expression `for year in range(years)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t comment out old code; remove it We programmers often hang on to our beloved
    code snippets, even after we’ve (grudgingly) decided to remove them, by simply
    commenting them out. This kills your code’s readability! Always remove unnecessary
    code—for peace of mind, you can use a version history tool such as Git that saves
    earlier drafts of your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use documentation functionality Many programming languages such as Python come
    with built-in documentation functionality that allows you to describe the purpose
    of each function, method, and class in your code. If each of these has only a
    single responsibility (as per Principle 10), it’s often enough to use the documentation
    instead of comments to describe what your code does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Principle 8: The Principle of Least Surprise'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The principle of least surprise states that a component of a system should
    behave in the way most users expect it to behave. This principle is one of the
    golden rules when designing effective applications and user experience. For example,
    if you open the Google search engine, the cursor will place itself in the search
    input field so that you can start typing your search keyword right away, just
    as you would expect: no surprises.'
  prefs: []
  type: TYPE_NORMAL
- en: Clean code also leverages this design principle. Say you write a currency converter
    that converts the user’s input from USD to Chinese renminbi. You store the user
    input in a variable. Which variable name is better suited, `user_input` or `var_x`?
    The principle of least surprise answers this question for you!
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 9: Don’t Repeat Yourself'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Don’t repeat yourself (DRY)* is a widely recognized principle that recommends,
    intuitively enough, avoiding repetitive code. For example, take the Python code
    in [Listing 4-11](#listing4-11), which prints the same string five times to the
    shell.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-11: Printing `hello world` five times'
  prefs: []
  type: TYPE_NORMAL
- en: Code that is much less repetitive is shown in [Listing 4-12](#listing4-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-12: Reducing the repetition found in [Listing 4-11](#listing4-11)'
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 4-12](#listing4-12) will print `hello world` five times,
    just as [Listing 4-11](#listing4-11) does, but without redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: Functions can also be a useful tool to reduce repetition. Say you need to convert
    miles into kilometers in multiple instances in your code, as in [Listing 4-13](#listing4-13).
  prefs: []
  type: TYPE_NORMAL
- en: First, you create a variable `miles` and convert it to kilometers by multiplying
    it by 1.60934\. Second, you convert 20 miles to kilometers by multiplying 20 by
    1.60934, and store the result in the variable `distance`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-13: Converting miles to kilometers twice'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve used the same multiplication procedure twice by multiplying the miles
    value by the factor 1.60934 to convert miles to kilometers. DRY suggests that
    it would be better to write a function `miles_to_km(miles)` once, as in [Listing
    4-14](#listing4-14), rather than performing the same conversion explicitly in
    the code multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-14: Using a function to convert miles to kilometers'
  prefs: []
  type: TYPE_NORMAL
- en: This way, the code is easier to maintain. You could, for example, tweak the
    function to increase the conversion accuracy, and you would have to make the change
    in only one place. In [Listing 4-13](#listing4-13), you’d have to search the code
    for all instances to make that improvement. Applying the DRY principle also makes
    the code easier to understand for human readers. There’s little doubt about the
    purpose of the function `miles_to_km(20)`, but you may have to think harder about
    the purpose of the computation `20 * 1.60934`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Violations of DRY are often abbreviated as WET: *we enjoy typing*, *write everything
    twice*, and *waste everyone’s time*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 10: Single Responsibility Principle'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The single responsibility principle means that every function should have one
    main task. It’s better to use many small functions than one big function accomplishing
    everything at the same time. The encapsulation of functionality reduces the overall
    code complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule of thumb, every class and every function should have only one responsibility.
    Robert C. Martin, the inventor of this principle, defines a *responsibility* as
    a *reason to change*. His gold standard when defining a class and a function,
    thus, is to focus them on a single responsibility so that only the programmer
    who needs this single responsibility changed would request a change in the definition—and
    no other programmer with other responsibilities would even consider to issue a
    change request for the class when assuming, of course, that the code is correct.
    For example, a function that’s responsible for reading data from a database wouldn’t
    also be responsible for processing the data. Otherwise, the function would have
    two reasons to change: a change in the database model and a change in the processing
    requirements. If there are multiple reasons to change, multiple programmers may
    change the same class simultaneously. Your class has too many responsibilities
    and has become messy and cluttered.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a small Python example that may run on an ebook reader to model
    and manage a user’s reading experience ([Listing 4-15](#listing4-15)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-15: Modeling the `B``ook` class while violating the single responsibility
    principle'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in [Listing 4-15](#listing4-15) defines the class `Book` ❶ with four
    attributes: title, author, publisher, and the current page number. You define
    getter methods for the attributes ❷, along with some minimal functionality to
    move to the next page ❸, which may be called each time the user presses a button
    on the reading device. The function, `print_page()`, is responsible for printing
    the current page to the reading device ❹. This is only given as a stub and would
    be more complicated in the real world. Finally, you create a `Book` instance named
    `python_one_liners` ❺, and you access its attributes via a series of method calls
    and print statements in the last couple of lines. A real ebook reader implementation,
    for example, would call the methods `next_page()` and `print_page()` each time
    the user requests a new page when reading the book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While the code looks clean and simple, it violates the single responsibility
    principle: the class `Book` is responsible both for modeling data, such as the
    book content, and for printing the book to the device. Modeling and printing are
    two different functions but are encapsulated in a single class. You have multiple
    reasons to change. You may want to change the modeling of the book’s data: for
    example, you could use a database instead of a file-based input/output method.
    But you may also want to change the representation of the modeled data by, for
    example, using another book-formatting scheme on other types of screens.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s fix this issue in [Listing 4-16](#listing4-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-16: Adhering to the single responsibility principle'
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 4-16](#listing4-16) accomplishes the same task, but it
    satisfies the single responsibility principle. You create both a `Book` ❶ and
    a `Printer` ❸ class. The `Book` class represents book metadata and the current
    page number ❷, while the `Printer` class is responsible for printing the book
    to the device. You pass the book for which you want to print the current page
    into the method `Printer.print_page()` ❹. This way, data modeling (*what is the
    data?*) and data presentation (*how is the data presented to the user?*) are decoupled,
    and the code becomes easier to maintain. For example, if you wanted to change
    the book data model by adding a new attribute `publishing_year`, you’d do it in
    the class `Book`. And if you wanted to reflect this change in the data presentation
    by providing readers this information as well, you’d do so in the class `Printer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 11: Test'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Test-driven development is an integral part of modern software development.
    No matter how skilled you are, you will make mistakes in your code. In order to
    catch them, you’ll need to run periodic tests or build test-driven code in the
    first place. Every great software company employs multiple levels of testing before
    it ships the final product to the public, since it’s far better to discover errors
    internally than to learn about them from unhappy users.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are no limitations to what types of tests you can perform to improve
    your software applications, these are the most common types:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests With unit tests, you write a separate application to check the correct
    input/output relationship for different inputs of each function in the application.
    The unit tests are usually applied at regular intervals—for example, each time
    a new software version is released. This reduces the likelihood that a software
    change will cause previously stable features to suddenly fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User acceptance tests These allow people in your target market to use your application
    in a controlled environment while you observe their behavior. You then ask them
    how they liked the application and how to improve it. These tests are usually
    deployed in the final phase of project development after extensive testing within
    the organization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Smoke tests Smoke tests are rough tests designed to try to fail the application
    under development before the teams building the software give the application
    to the testing team. In other words, smoke tests are often deployed by the application-building
    team for quality assurance before handing the code to the testing teams. When
    the app passes the smoke test, it’s ready for the next round of testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performance tests Performance tests aim to show whether the application meets
    or even exceeds its users’ performance requirements rather than testing the actual
    functionality. For instance, before Netflix releases a new feature, it must test
    its website for page-loading time. If the new feature slows down the frontend
    too much, Netflix doesn’t release it, proactively avoiding a negative user experience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scalability tests If your application becomes successful, you may have to handle
    1,000 requests per minute instead of the original 2 requests. A scalability test
    will show whether your application is scalable enough to handle that. Note that
    a performant application isn’t necessarily scalable and vice versa. For instance,
    a speed boat is very performant but doesn’t scale to thousands of people at a
    time!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing and refactoring will often reduce complexity and the number of errors
    in your code. However, be careful not to over-engineer (see Principle 14)—you
    need to test scenarios that can occur only in the real world. For example, testing
    whether the Netflix application can handle 100 billion streaming devices is unnecessary
    considering there are only 7 billion potential viewers on the planet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 12: Small Is Beautiful'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Small code* is code that requires only a relatively small number of lines
    to accomplish a single specified task. Here’s an example of a small code function
    that reads an integer value from a user and ensures the input is indeed an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The code runs until the user types in an integer. Here’s an example run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By separating the logic of reading an integer value from a user, you can reuse
    the same function multiple times. But, more importantly, you’ve broken up the
    code into smaller units of functionality that are relatively easy to read and
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, many beginner coders (or lazy intermediate coders) write large, monolithic
    code functions, or so-called *God objects*, that do everything in a centralized
    manner. These monolithic code blocks are a nightmare to maintain. For one thing,
    it’s easier for humans to understand one small code function at a time than to
    try to integrate a specific feature into a 10,000-line code block. You can potentially
    make far more mistakes in a large code block than in a few small functions and
    code blocks that you can then integrate with your existing codebase.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, [Figure 4-1](#figure4-1) showed that writing
    code becomes more time-consuming with each additional line, though writing clean
    code is much faster in the long run than writing dirty code. [Figure 4-2](#figure4-2)
    compares the time it takes to work with small code blocks versus monolithic code
    blocks. For large code blocks, the time it takes to add each additional line will
    increase superlinearly. If you stack multiple small code functions on top of each
    other, however, the time spent per additional line increases quasi-linearly. To
    best achieve this effect, you’ll need to be sure each code function is more or
    less independent of other code functions. You’ll learn more about this idea in
    the next principle, the Law of Demeter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Line graph with “Lines of code written” on the x-axis and “Time per additional
    line” on the y-axis. The “Big monolithic code block” line rapidly increases in
    time per line, and the “many small code blocks” line maintains a steady rate.](image_fi/502185c04/f04002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: With the Big Monolithic Code Block, time increases exponentially.
    With the Many Small Code Blocks, time increases quasi-linearly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 13: The Law of Demeter'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dependencies are everywhere. When you import a library in your code, your code
    depends partially on the library’s functionality, but it will also have interdependencies
    within itself. In object-oriented programming, one function may depend on another
    function, one object on another object, and one class definition on another class
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write clean code, minimize the interdependency of your code elements by
    following the *Law of Demeter*, which was proposed in the late 1980s by Ian Holland,
    a software developer working on a software project named after Demeter, the Greek
    goddess of agriculture, growth, and fertility. The project group promoted the
    idea of “growing software” as opposed to simply building it. However, what became
    known as the Law of Demeter has little to do with these arguably more metaphysic
    ideas—it’s a practical approach of writing loosely coupled code in object-oriented
    programming. Here’s a concise quote explaining the Law of Demeter from the project
    group’s website, [http://ccs.neu.edu/home/lieber/what-is-demeter.html](http://ccs.neu.edu/home/lieber/what-is-demeter.html):'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important concept of Demeter is to split software into at least two parts:
    The first part defines the objects. The second part defines the operations. The
    goal of Demeter is to maintain a loose coupling between the objects and the operations,
    so that one can make modifications to either without serious impact on the other.
    This cuts down significantly on maintenance time.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In other words, you should minimize the dependencies of your code objects.
    By reducing dependencies between code objects, you reduce the complexity of your
    code and, in turn, improve maintainability. One specific implication is that every
    object should call only its own methods or methods from adjacent objects rather
    than call methods of objects it obtains from calling a method of an adjacent object.
    For the sake of explanation, let’s define two objects A and B as *friends* if
    A calls a method provided by B. Simple. But what if B’s method returns a reference
    to object C? Now, object A may perform something like this: `B.method_of_B().method_of_C()`.
    This is called *chaining* of method calls—in our metaphor, you talk to a friend
    of your friend. The Law of Demeter says to *talk only to your immediate friends*,
    so it discourages this type of method chaining. This may sound confusing at first,
    so let’s dive into the practical example shown in [Figure 4-3](#figure4-3).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Right side is a visual representation of a bad implementation of calculating
    price per coffee in the upcoming Listing 4-17, and the left side depicts a good
    implementation explored in Listing 4-18.](image_fi/502185c04/f04003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: Law of Demeter: talking only to your friends to minimize dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-3](#figure4-3) shows two object-oriented code projects that calculate
    the price per cup of coffee for a given person. One of the implementations violates
    the Law of Demeter, and the other one adheres to it. Let’s start with the negative
    example first in which you use method chaining in the `Person` class to talk to
    a stranger ❶ (see [Listing 4-17](#listing4-17)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-17: Code that violates the Law of Demeter'
  prefs: []
  type: TYPE_NORMAL
- en: You create the method `price_per_cup()` that calculates the cost per cup of
    coffee based on the price of the coffee machine and the number of cups produced
    by this machine. The `Coffee_Cup` object collects information about the price
    of the coffee machine, which influences the price per cup, and passes it to the
    caller of the method `price_per_cup()` on the `Person` object.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram on the left of [Figure 4-3](#figure4-3) shows a bad strategy for
    doing so. Let’s look at the step-by-step explanation of the corresponding code
    from [Listing 4-17](#listing4-17).
  prefs: []
  type: TYPE_NORMAL
- en: The method `price_per_cup()` calls the method `Coffee_Cup.get_creator_machine()`
    to get a reference to the `Coffee_Machine` object that created the coffee.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `get_creator_machine()` returns an object reference to the `Coffee_Machine`
    object that has produced the cup’s contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `price_per_cup()` calls the method `Coffee_Machine.get_price()` on
    the `Coffee_Machine` object it just obtained from the previous `Coffee_Cup` method
    call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `get_price()` returns the price of the machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `price_per_cup()` calculates the depreciation per cup and uses this
    to estimate the price of a single cup. This is returned to the caller of the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a bad strategy because the class `Person` depends on two objects: `Coffee_Cup`
    and `Coffee_Machine` ❶. A programmer responsible for maintaining this class must
    know about both parent class definitions—any change in either of those may impact
    the `Person` class as well.'
  prefs: []
  type: TYPE_NORMAL
- en: The Law of Demeter minimizes such dependencies. You can see a better way to
    model the same problem on the right in [Figure 4-3](#figure4-3) and in [Listing
    4-18](#listing4-18). In this code snippet, the `Person` class doesn’t talk to
    the `Machine` class directly—it doesn’t even need to be aware of its existence!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-18: Code that adheres to the Law of Demeter by not talking to strangers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine this code in a step-by-step manner:'
  prefs: []
  type: TYPE_NORMAL
- en: The method `price_per_cup()` calls the method `Coffee_Cup.get_cost_per_cup()`
    to get the estimated price per cup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `get_cost_per_cup()`—before replying to the calling method—calls
    the method `Coffee_Machine.get_price()` to access the price of the machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `get_price()` returns the price information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `get_cost_per_cup()` calculates the price per cup and returns it
    to the calling method `price_per_cup()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `price_per_cup()` simply forwards this calculated value to its caller
    ❶.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a better approach, because the class `Person` is now independent of
    the class `Coffee_Machine`. The total number of dependencies is reduced. For a
    project with hundreds of classes, reducing dependencies dramatically reduces the
    overall complexity of your application. Here’s the danger in terms of growing
    complexity for large applications: the number of potential dependencies grows
    superlinearly with the number of objects. Roughly speaking, a superlinear curve
    grows faster than a straight line. For example, doubling the number of objects
    can easily quadruple the number of dependencies (which equates to complexity).
    However, following the Law of Demeter can offset this trend by significantly reducing
    the number of dependencies. If every object talks to only *k* other objects and
    you have *n* objects, the total number of dependencies is bounded by *k*n*, which
    is a linear relationship if *k* is a constant. Thus, the Law of Demeter can mathematically
    help you gracefully scale your applications!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 14: You Ain’t Gonna Need It'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle suggests that you should never implement code if you only *suspect*
    that you’ll need to use it someday in the future—because you ain’t gonna need
    it! Write code only if you’re 100 percent sure it’s necessary. Code for today’s
    needs and not tomorrow’s. If in the future you actually need the code you previously
    only suspected you needed, you can still implement the feature then. But in the
    meantime, you’ve saved many unnecessary lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It helps to think from first principles: the simplest and cleanest code is
    the empty file. Now, go from there—what do you *need* to add to that? In Chapter
    3, you learned about the MVP: code that is stripped of features to focus on the
    core functionality. If you minimize the number of features you pursue, you’ll
    obtain cleaner and simpler code than you could ever attain through refactoring
    methods or all other principles combined. Consider leaving out features that provide
    relatively little value compared to others. Opportunity costs are seldom measured
    but are often significant. You should really *need* a feature before you even
    consider implementing it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An implication of this is to avoid *overengineering*: creating a product that
    is more performant and robust or contains more features than needed. It adds unnecessary
    complexity, which should immediately ring your alarm bells.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, I’ve often encountered problems that could be solved within a few
    minutes using a naive algorithmic approach but, like many programmers, I refused
    to accept the minor limitations of these algorithms. Instead, I studied state-of-the-art
    clustering algorithms to eke out a few percentage points of clustering performance
    compared to the simple KMeans algorithm. These long-tail optimizations were incredibly
    costly—I had to spend 80 percent of the time to obtain 20 percent of the improvement.
    This would have been unavoidable if I’d *needed* that 20 percent and had no other
    way to get it, but in reality, I didn’t need to implement fancy clustering algorithms.
    A typical case of overengineering!
  prefs: []
  type: TYPE_NORMAL
- en: 'Always go for the low-hanging fruit first. Use naive algorithms and straightforward
    methods to establish a benchmark, then analyze which new feature or performance
    optimization would yield superior results for the overall application. Think global,
    not local: focus on the big picture (as per Principle 1) rather than on small,
    time-consuming fixes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 15: Don’t Use Too Many Levels of Indentation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most programming languages use text indentation to visualize the hierarchical
    structure of potentially nested conditional blocks, function definitions, or code
    loops. Overusing indentation, however, can decrease the readability of your code.
    [Listing 4-19](#listing4-19) shows an example of a code snippet with too many
    levels of indentation, which makes it hard to quickly understand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-19: Too many levels of nested code blocks'
  prefs: []
  type: TYPE_NORMAL
- en: If you now try to guess the output of this code snippet, you’ll find it’s actually
    difficult to trace. The code function `if_confusion(x, y)` performs relatively
    simple checks on variables `x` and `y`. However, it’s easy to get lost in the
    different levels of indentation. The code is not clean at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-20](#listing4-20) shows how to write the same code more cleanly
    and simply.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-20: Fewer levels of nested code blocks'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 4-20](#listing4-20), we reduced indentation and nesting. You can
    now go over all checks and see what applies first to your two arguments `x` and
    `y`. Most coders will enjoy reading flat code much more than reading highly nested
    code—even if it comes at the expense of redundant checks; here, for example, `x>y`
    is checked multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 16: Use Metrics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use code quality metrics to track the complexity of your code over time. The
    ultimate, if informal, metric is known as the number of WTFs per minute, intended
    to measure your code readers’ frustration. The results will be low for clean and
    simple code and high for dirty, confusing code.
  prefs: []
  type: TYPE_NORMAL
- en: As a proxy for this hard-to-quantify standard, you can use established metrics
    such as the NPath complexity or cyclomatic complexity discussed in Chapter 1.
    For most IDEs, many online tools and plug-ins will automatically calculate the
    complexity as you write your source code. These include CyclomaticComplexity,
    which you can find by searching in the plug-ins section of JetBrains at [https://plugins.jetbrains.com/](https://plugins.jetbrains.com/).
    In my experience, the actual measure of complexity used is less important than
    being aware of the fact that you need to weed out complexity wherever you can.
    I highly recommend using these tools to help you write cleaner and simpler code.
    The return on your invested time will be phenomenal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 17: Boy Scout Rule and Refactoring'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The boy scout rule is simple: *leave the campground cleaner than you found
    it*. It’s a great rule to live and code by. Get into the habit of cleaning up
    every piece of code you encounter. This will not only improve the codebases you’re
    involved in and make your own life easier but also help you develop the sharp
    eye of a master coder who can evaluate source code quickly. As a bonus, it’ll
    help your team be more productive, and your colleagues will be grateful for your
    value-oriented attitude. Note that this shouldn’t violate the rule we stated earlier
    about avoiding premature optimization (overengineering). Spending time to clean
    up your code to reduce complexity is almost always efficient. Doing so will yield
    big dividends in reduced maintenance overhead, bugs, and cognitive demands. Put
    succinctly, overengineering is likely to *increase* complexity whereas cleaning
    up the code will *reduce* complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: The process of improving your code is called *refactoring*. You could argue
    that refactoring is the overall method comprising every principle we’ve discussed
    here. As a great coder, you’ll incorporate many of the clean code principles from
    the beginning. Even then, however, you’ll still need to occasionally refactor
    your code to clean up any messes you’ve made. In particular, you should refactor
    your code before releasing any new features to keep the code clean.
  prefs: []
  type: TYPE_NORMAL
- en: There are many techniques for refactoring code. One is to explain your code
    to a colleague or have them look it over in order to discover any poor decisions
    you’ve made and had not noticed on your own. For example, you may have created
    two classes, `Cars` and `Trucks`, because you expected your application would
    need to model both. As you explain your code to your teammate, you realize that
    you don’t use the class `Trucks` very often—and when you do, you use methods that
    already exist in the `Car` class. Your colleague suggests creating a `Vehicle`
    class that handles all cars and trucks. This allows you to get rid of many lines
    of code immediately. This type of thinking can result in enormous improvements,
    since it will force you to account for your decisions and explain your project
    from a bird’s-eye view.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re an introverted coder, you can explain your code to a rubber duck instead—a
    technique known as *rubber duck debugging*.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond speaking to your colleagues (or your rubber duck), you can use the other
    clean code principles listed here to quickly evaluate your code from time to time.
    When you do, you’ll likely discover some tweaks you can apply quickly to greatly
    reduce complexity by cleaning up your codebase. This integral part of your software
    development process will improve your results significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned 17 principles for how to write clean and simple
    code. You’ve learned that clean code reduces complexity and increases your productivity
    as well as the scalability and maintainability of your project. You’ve learned
    that you should use libraries wherever possible to reduce clutter and increase
    your code quality. You’ve learned that choosing meaningful names of variables
    and functions while adhering to standards is important to reduce friction for
    future readers of your code. You’ve learned to design functions to do one thing
    only. Reducing complexity and increasing scalability by minimizing dependencies
    (according to the Law of Demeter) can be done by avoiding direct and indirect
    method chaining. You’ve learned to comment code in a way that provides a valuable
    glimpse into your mind, but you’ve also learned to avoid unnecessary or trivial
    comments. And, most importantly, you’ve learned that the key to unlocking your
    clean code superpower is to code for humans, not machines.
  prefs: []
  type: TYPE_NORMAL
- en: You can gradually improve your clean code–writing skills by collaborating with
    great coders, reading their code on GitHub, and studying the best practices in
    your programming language. Integrate a linter that dynamically checks your code
    against those best practices into your programming environment. From time to time,
    revisit these clean code principles and check your current project against them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you’ll learn another principle of effective coding that
    goes beyond just writing clean code: premature optimization. You’ll be surprised
    by how much time and effort is wasted by programmers who haven’t yet figured out
    that *premature optimization is the root of all evil*!'
  prefs: []
  type: TYPE_NORMAL
