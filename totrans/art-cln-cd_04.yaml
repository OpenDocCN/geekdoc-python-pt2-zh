- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Write Clean and Simple Code
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写干净且简洁的代码
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Clean code* is code that’s easy to read, understand, and change. It is minimal
    and concise, as long as those attributes do not interfere with readability. While
    writing clean code is more an art than a science, the software engineering industry
    has agreed on multiple principles that, if followed, will help you write *cleaner*
    code. In this chapter, you’ll learn 17 principles for how to write clean code
    that will significantly improve your productivity and combat the problem of complexity.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*干净的代码*是易于阅读、理解和修改的代码。它简洁且简明扼要，只要这些特性不妨碍可读性。虽然编写干净的代码更多是一种艺术而非科学，但软件工程行业已经达成一致，提出了多项原则，如果遵循这些原则，将帮助你编写*更干净*的代码。在本章中，你将学习17个编写干净代码的原则，它们将显著提高你的生产力并解决复杂性问题。'
- en: You may wonder about the difference between *clean* and *simple* code. These
    two concepts are closely interrelated because clean code tends to be simple and
    simple code tends to be clean. But it’s possible to encounter complex code that
    is still clean. Simplicity concerns the avoidance of complexity. Clean code goes
    one step further and also concerns itself with managing unavoidable complexity—for
    instance, through the effective use of comments and standards.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道*干净*代码和*简洁*代码之间的区别。这两个概念紧密相关，因为干净的代码往往是简洁的，简洁的代码往往是干净的。但也有可能遇到复杂的代码，它仍然是干净的。简洁性关注的是避免复杂性，而干净的代码则更进一步，关注如何管理不可避免的复杂性——例如，通过有效使用注释和标准。
- en: Why Write Clean Code?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要编写干净的代码？
- en: In the previous chapters, you learned that complexity is the number one public
    enemy for any code project. You’ve learned that simplicity increases your productivity,
    your motivation, and the maintainability of your codebase. In this chapter, we’ll
    carry this concept a step further and show you how to write clean code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学到了复杂性是任何代码项目的头号公敌。你还学到了简洁性能够提高你的生产力、动机以及代码库的可维护性。在本章中，我们将进一步扩展这个概念，并展示如何编写干净的代码。
- en: Clean code is easier to understand for both your future self and your fellow
    coders, since people are more likely to add to clean code and the potential for
    collaboration will increase. Consequently, clean code can significantly reduce
    a project’s costs. As Robert C. Martin points out in his book *Clean Code* (Prentice
    Hall, 2008), coders spend the vast majority of their time reading old code in
    order to write new code. If the old code is easy to read, this will speed the
    process considerably.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 干净的代码更容易被未来的自己和其他同事理解，因为人们更可能为干净的代码做出贡献，协作的潜力也会增加。因此，干净的代码可以显著降低项目成本。正如Robert
    C. Martin在他的书《Clean Code》（Prentice Hall，2008）中所指出的，程序员花费绝大多数时间阅读旧代码，以便编写新代码。如果旧代码易于阅读，那么这一过程将大大加速。
- en: Indeed, the ratio of time spent reading versus writing is well over 10 to 1\.
    We are constantly reading old code as part of the effort to write new code. [Therefore,]
    making it easy to read makes it easier to write.
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确实，阅读与编写代码的时间比例远远超过10:1。我们在编写新代码的过程中，持续不断地阅读旧代码。[因此，]使代码易于阅读，也使得编写代码变得更容易。
- en: If we take this ratio literally, this relationship is visualized in [Figure
    4-1](#figure4-1). The x-axis corresponds to the number of lines written in a given
    code project. The y-axis corresponds to the time to write one additional line
    of code. In general, the more code you’ve already written in one project, the
    more time it takes to write an additional line of code. This is true for both
    clean and dirty code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们字面理解这个比例，这个关系在[图4-1](#figure4-1)中得到了可视化。x轴对应于在一个代码项目中编写的行数，y轴对应于编写一行额外代码所需的时间。一般来说，项目中已编写的代码越多，写一行额外代码所需的时间就越长。这对于干净代码和脏代码都适用。
- en: Say you’ve written *n* lines of code, and you add the *n* + 1st line of code.
    Adding this line may potentially affect all previously written lines. It may,
    for example, have a small performance penalty, which impacts the overall project.
    It may use a variable defined somewhere else. It may introduce a bug (with probability
    *c*), and to find that bug, you must search the whole project. That means your
    expected time—and therefore, costs—per line of code is *c * T*(*n*) for a steadily
    increasing time function *T* with increasing input *n*. Adding a line may also
    force you to write additional lines of code to ensure backward compatibility.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Lengthier code may introduce many other complications, but you get the point:
    the more code you’ve written, the more the additional complexity will slow your
    progress.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![Line graph with “Lines of code written” on the x-axis and “Time per additional
    line” on the y-axis. The “quick and dirty code” rapidly increases in time per
    line and the “Thoughtful and clean code” line maintains a steady rate.](image_fi/502185c04/f04001.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: Clean code improves the scalability and maintainability of your
    codebase.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-1](#figure4-1) also shows the difference between writing dirty and
    clean code. Dirty code is less time-consuming in the short term and for small
    code projects—if there were no benefits to writing dirty code, nobody would do
    it! If you cram all your functionality into a 100-line code script, you don’t
    need to invest a lot of time thinking about and restructuring your project. Problems
    begin to arise only as you add more code: as your monolithic code file grows from
    100 to 1,000 lines, it’ll be less efficient than code developed using a more thoughtful
    approach in which you structure the code logically in different modules, classes,
    or files.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule of thumb: always write thoughtful and clean code. The additional
    costs for rethinking, refactoring, and restructuring will pay back many times
    over for any non-trivial project. The stakes can sometimes be quite high: in 1962
    the National Aeronautics and Space Administration (NASA) attempted to send a spacecraft
    to Venus, but a tiny bug—the omission of a hyphen in the source code—caused the
    engineers to issue a self-destruct command, which resulted in the loss of a rocket
    worth more than $18 million at the time. If the code had been cleaner, the engineers
    may have caught the error before the launch.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not you’re doing rocket science, the philosophy of carefully crafting
    your programming will carry you further in life. Simple code also facilitates
    scaling your project to more programmers and more features because fewer coders
    will be scared off by the project’s complexity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s learn how to write clean and simple code, shall we?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing Clean Code: The Principles'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I learned to write clean code the hard way when I was developing a distributed
    graph-processing system from scratch as part of my doctoral research. If you’ve
    ever written a distributed application—where two processes residing on different
    computers interact with each other via messages—you know that the complexity can
    quickly become overwhelming. My code grew to thousands of lines, and bugs popped
    up frequently. I didn’t make any progress for weeks at a time; it was very frustrating.
    The concepts were convincing in theory, but somehow they didn’t work in my implementation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我在从零开始开发一个分布式图处理系统作为博士研究的一部分时，以一种非常艰难的方式学会了编写干净的代码。如果你曾经编写过分布式应用程序——两个进程分别驻留在不同的计算机上，通过消息互相通信——你就知道这种复杂性可以迅速变得让人不堪重负。我的代码增长到几千行，错误频繁出现。好几个星期我都没有任何进展；这让我感到非常沮丧。理论上的概念很有说服力，但不知为何它们在我的实现中并没有奏效。
- en: Finally, after a month or so working full-time on the codebase without seeing
    any encouraging progress, I decided to simplify the codebase radically. Among
    other changes, I started to use libraries instead of coding functionality myself.
    I removed code blocks that I had commented out for a possible later use. I renamed
    variables and functions. I structured the code in logical units and created new
    classes instead of cramming everything into a “God” class. After a week or so,
    not only was my code more readable and understandable for other researchers, it
    was also more efficient and less buggy. My frustration morphed into enthusiasm—clean
    code had rescued my research project!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在大约一个月的时间里，我全职工作在代码库上，却没有看到任何令人鼓舞的进展，于是我决定彻底简化代码库。除了其他改动，我开始使用现成的库，而不是自己编写功能。我删除了那些曾经注释掉、可能以后会用到的代码块。我重命名了变量和函数。我将代码结构化成逻辑单元，并创建了新类，而不是将所有东西塞进一个“上帝”类中。大约一周后，我的代码不仅对于其他研究人员来说更加易读和易懂，而且也更加高效，出错率更低。我的沮丧转变为热情——干净的代码救了我的研究项目！
- en: 'Improving your codebase and reducing complexity is called *refactoring*, and
    it must be a scheduled and crucial element of your software development process
    if you want to write clean and simple code. Writing clean code is mainly about
    keeping two things in mind: knowing the best ways to build your code from the
    ground up and going back to make revisions periodically. I’ll cover some important
    techniques for keeping your code clean in the following 17 principles. While each
    principle covers a unique strategy to write cleaner code, some of the principles
    overlap, but I felt like combining the overlapping principles would reduce clarity
    and actionability. With this out of the way, let’s get started with the first
    one!'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 改进代码库并减少复杂性叫做*重构*，如果你想编写干净简洁的代码，它必须成为你的软件开发过程中一个有计划且至关重要的环节。编写干净代码主要是记住两件事：知道从头开始构建代码的最佳方法，并定期回去进行修订。我将在接下来的17条原则中介绍一些保持代码干净的重要技巧。虽然每条原则涵盖了编写更干净代码的独特策略，但其中一些原则是重叠的，我觉得将重叠的原则合并会降低清晰度和可操作性。既然这些已经讲完，我们就开始第一个原则吧！
- en: 'Principle 1: Think About the Big Picture'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 1：思考大局
- en: 'If you work on a non-trivial project, you’ll likely end up with multiple files,
    modules, and libraries working together within the overall application. Your *software
    architecture* defines how your software elements interact. Good architectural
    decisions can initiate huge leaps of improvement in performance, maintainability,
    and usability. To build a good architecture, you’ll need to take a step back and
    think about the big picture. Decide on features that are needed in the first place.
    In Chapter 3 about building an MVP, you learned how to focus your project on the
    necessary features. If you do this, you save yourself a lot of work and the code
    will be a lot more clean per design. At this point, we assume you’ve already created
    your first application with multiple modules, files, and classes. How can you
    apply big-picture thinking to impose some order on the mess? Considering the following
    questions can give you some ideas on how to best make your code cleaner:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在做一个非简单项目，你很可能会遇到多个文件、模块和库在整体应用中一起工作。你的*软件架构*定义了软件元素如何相互作用。良好的架构决策可以带来巨大的性能、可维护性和可用性的提升。要建立一个好的架构，你需要退后一步，思考整体局面。首先决定需要的功能。在第3章关于构建最小可行产品（MVP）中，你学会了如何将项目聚焦于必要的功能。如果你这样做了，你会节省很多工作，并且代码会更加简洁有序。到这个阶段，我们假设你已经创建了第一个包含多个模块、文件和类的应用程序。你如何运用整体思维来给这些混乱的代码带来一些秩序？考虑以下问题可以给你一些关于如何清理代码的思路：
- en: Do you need all the separate files and modules, or can you consolidate some
    of them and reduce the interdependency of your code?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要所有独立的文件和模块吗，还是可以合并其中一些，减少代码之间的相互依赖？
- en: 'Can you divide a large and complicated file into two simpler ones? Note that
    there’s usually a sweet spot between two extremes: a large, monolithic code block
    that is completely unreadable or a myriad of small code blocks that are impossible
    to mentally keep track of. Neither is desirable, and most stages in between are
    better options. Think of it as an inverted U curve where the maximum represents
    the sweet spot between a few large code blocks and many small code blocks.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能将一个大而复杂的文件拆分成两个更简单的文件吗？请注意，通常在两种极端之间会有一个“甜点”区域：一个庞大、单一的代码块完全无法阅读，或者是无数个小代码块，你很难一一追踪。两者都不可取，而大多数介于两者之间的阶段会是更好的选择。可以将其视为一个倒U形曲线，最大值代表了少数大代码块和大量小代码块之间的甜点区域。
- en: Can you generalize code and turn it into a library to simplify the main application?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能将代码通用化并将其转化为库，从而简化主应用程序吗？
- en: Can you use existing libraries to get rid of many lines of code?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能使用现有的库来消除许多代码行吗？
- en: Can you use caching to avoid recomputing the same result over and over again?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能使用缓存来避免一次又一次地重新计算相同的结果吗？
- en: Can you use more straightforward and suitable algorithms that accomplish the
    same things as your current algorithms?
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能使用更直接和更合适的算法来实现与你当前算法相同的功能吗？
- en: Can you remove premature optimizations that don’t improve the overall performance?
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能去除那些不会提升整体性能的过早优化吗？
- en: Can you use another programming language that would be more suitable for the
    problem at hand?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能使用其他更适合当前问题的编程语言吗？
- en: Big-picture thinking is a time-efficient way to drastically reduce the complexity
    of your application as a whole. Sometimes it’s hard to implement those changes
    at later various stages of the process or because of collaborations that might
    interfere. In particular, this kind of high-level thinking can be difficult for
    applications with millions of lines of code, like the Windows operating system.
    However, you simply cannot afford to ignore these questions entirely because all
    the small tweaks combined cannot mitigate the adverse effects of wrong or lazy
    design choices. If you’re working in a small startup or just for yourself, you
    can usually make bold architectural decisions, such as changing the algorithm,
    swiftly. If you’re working in a big organization, you might not have as much flexibility.
    The bigger the application, the more likely you are to find easy fixes and low-hanging
    fruit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从大局思考是一种高效的方式，可以大幅度降低整个应用程序的复杂性。有时候，在后续的不同阶段实施这些改变会很困难，或者可能因为合作影响而无法进行。特别是，对于像
    Windows 操作系统这样有数百万行代码的应用程序，这种高层次的思维方式可能会变得很困难。然而，你绝对不能完全忽视这些问题，因为所有的小调整加起来也无法弥补错误或懒惰设计选择带来的负面影响。如果你在一个小型创业公司工作，或者仅仅为自己工作，你通常可以迅速做出大胆的架构决策，比如改变算法。如果你在一个大组织中工作，你的灵活性可能会小一些。应用程序越大，你越容易找到简单的修复和容易解决的问题。
- en: 'Principle 2: Stand on the Shoulders of Giants'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 2：站在巨人的肩膀上
- en: 'Reinventing the wheel is rarely valuable. Programming is a decades-old industry.
    The best coders in the world have provided us with a great legacy: a database
    of millions of fine-tuned and well-tested algorithms and code functions. Accessing
    the collective wisdom of millions of programmers is as simple as using a one-line
    import statement. There’s no reason not to use this superpower in your own projects.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 发明轮子很少是有价值的。编程已经是一个有几十年历史的行业。世界上最优秀的程序员为我们提供了伟大的遗产：一个包含数百万个精细调优和经过充分测试的算法和代码函数的数据库。访问数百万程序员的集体智慧，就像使用一行导入语句那么简单。在你自己的项目中，完全没有理由不利用这个超级能力。
- en: Using library code is likely to improve the efficiency of your code. Functions
    that have been used by thousands of coders tend to be much more optimized than
    your own. Furthermore, library calls are easier to understand and take less space
    in your code project than code you’ve written in yourself. For example, suppose
    you need a clustering algorithm to visualize clusters of customers. You can *stand
    on the shoulders of giants* by importing a well-tested clustering algorithm from
    an external library and passing your data into it. This is far more time-efficient
    than using your own code—it will implement the same functionality with fewer bugs,
    less space, and more performant code. Libraries are among the primary tools that
    master coders use to increase their productivity thousandfold.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用库代码可能会提高你的代码效率。已经被成千上万的程序员使用过的函数往往比你自己写的更加优化。而且，库函数调用通常比你自己编写的代码更容易理解，占用的代码空间也更少。例如，假设你需要一个聚类算法来可视化客户的聚类。你可以通过从外部库导入一个经过良好测试的聚类算法并将数据传入其中，*站在巨人的肩膀上*。这比使用你自己的代码更为高效——它将以更少的错误、更少的空间和更高效的代码实现相同的功能。库是高级程序员用来千倍提高生产力的主要工具之一。
- en: 'As an example of some library code that can save you time, here’s the two-liner
    that imports the KMeans module from the scikit-learn Python library to find two
    cluster centers on a given dataset stored in variable `X`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个能够节省时间的库代码示例，下面是从 scikit-learn Python 库中导入 KMeans 模块以在存储在变量 `X` 中的给定数据集上找到两个聚类中心的两行代码：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Implementing the KMeans algorithm on your own instead would take you several
    hours and likely more than 50 lines of code, cluttering your codebase so that
    all future code would become harder to implement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己实现 KMeans 算法，可能需要几个小时，且很可能需要超过 50 行代码，甚至会让你的代码库变得杂乱无章，使得未来的代码实现更加困难。
- en: 'Principle 3: Code for People, Not Machines'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 3：为人编程，而不是为机器编程
- en: You may think that the primary purpose of a piece of source code is to define
    what machines should do and how they should do it. Not so. The single purpose
    of a programming language such as Python is to help humans write code. Compilers
    do the heavy lifting and translate your high-level code to low-level code that
    is understandable by your machine. Yes, your code will eventually be run by a
    machine. But code is still written mainly by humans, and in today’s software development
    process, the code likely must pass many levels of human judgment before it is
    deployed. First and foremost, you’re writing code for people, not machines.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Always assume that others will read your source code. Imagine you moved to a
    new project and someone else had to take your place at the codebase. There are
    many ways to make their job easier and minimize frustration. First of all, use
    meaningful variable names so that readers can easily follow what a given line
    of code is intended to accomplish. [Listing 4-1](#listing4-1) shows an example
    of poorly chosen variable names.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 4-1: Code that uses poorly chosen variable names'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: It’s difficult to guess what this code computes. [Listing 4-2](#listing4-2),
    on the other hand, is a semantically equivalent code that uses meaningful variable
    names.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 4-2: Code that uses meaningful variable names'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s much easier to understand what’s happening here: the variable names indicate
    how to calculate the value of an initial investment of 10,000 compounded over
    10 years, assuming an annual return of 10 percent.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: While we won’t go into every way to implement this principle here (though later
    principles will cover some approaches in more detail), it also manifests in other
    aspects that might clarify intent, such as indentation, whitespace, comments,
    and line lengths, among others. Clean code radically optimizes for human readability.
    As Martin Fowler, an international expert on software engineering and author of
    the popular book *Refactoring*, argues, “Any fool can write code that a computer
    can understand. Good programmers write code that humans can understand” (Addison-Wesley,
    1999).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 4: Use the Right Names'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relatedly, experienced coders have often agreed on a set of specific naming
    conventions for functions, function arguments, objects, methods, and variables,
    both implicit and explicit. Everybody benefits from adhering to these conventions:
    code becomes more readable, easier to understand, and less cluttered. If you violate
    these conventions, readers of your code are likely to assume that it was written
    by an inexperienced programmer and may not take your code seriously.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: These conventions may differ from language to language. For example, by convention
    Java uses `camelCaseNaming` for naming variables, while Python uses `underscore_naming`
    for variables and functions. If you start using camel case in Python, it may confuse
    the reader. You don’t want your untraditional naming conventions to distract those
    reading your code. You want them to focus on what your code does, not on your
    coding style. As outlined by the *principle of least surprise*, there’s no value
    in surprising other coders by choosing unconventional variable names.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s dive into a list of naming rules you can consider when writing source
    code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Choose descriptive names Say you create a function to convert currencies from
    United States dollars (USD) to euros (EUR) in Python. Call it `usd_to_eur(amount)`
    rather than `f(x)`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose unambiguous names You may think that `dollar_to_euro(amount)` would be
    a good name for a currency conversion function. While it is better than `f(x)`,
    it’s worse than `usd_to_eur(amount)` because it introduces an unnecessary degree
    of ambiguity. Do you mean United States, Canadian, or Australian dollars? If you’re
    in the United States, the answer may be obvious to you, but an Australian coder
    may not know that the code is written in the United States and may assume a different
    output. Minimize these confusions!
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use pronounceable names Most coders subconsciously read code by pronouncing
    it in their minds. If a variable name is unpronounceable, the problem of deciphering
    it takes attention and costs precious mental space. For example, the variable
    name `cstmr_lst` may be descriptive and unambiguous, but it’s not pronounceable.
    Choosing the variable name `customer_list` is well worth the additional space
    in your code.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use named constants, not magic numbers In your code, you may use the magic number
    0.9 multiple times as a factor to convert a sum in USD to a sum in EUR. However,
    the reader of your code—including your future self—has to think about the purpose
    of this number. It’s not self-explanatory. A far better way of handling the magic
    number 0.9 is to store it in an all-uppercase variable—used to indicate that it
    is a constant that doesn’t change—such as `CONVERSION_RATE = 0.9` and use it as
    a factor in your conversion computations. For example, you may then calculate
    your income in EUR as `income_euro = CONVERSION_RATE * income_usd`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are only a few naming rules. Beyond these quick tips, the best way to
    learn naming conventions is to study the well-crafted code of experts. Googling
    the relevant conventions (for example, “Python naming conventions”) is a good
    place to start. You might also read programming tutorials, join StackOverflow
    to query fellow coders, check out the GitHub code of open source projects, and
    join the Finxter blog community of ambitious coders who help each other grow their
    programming skills.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 5: Adhere to Standards and Be Consistent'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every programming language comes with an implicit or explicit set of rules on
    how to write clean code. If you are an active coder, these standards will always
    catch up with you eventually. However, you can speed the process by taking the
    time to study the code standard of the programming language you’re learning.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都会有一套隐式或显式的规则来指导如何编写整洁的代码。如果你是一个活跃的程序员，这些标准最终会成为你必须遵守的要求。然而，你可以通过花时间研究你正在学习的编程语言的代码标准来加速这一过程。
- en: 'For example, you can access the official Python style guide, PEP 8, at this
    link: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/).
    As with any style guide, PEP 8 defines the correct code layout and indentation;
    the method to set line breaks; the maximum number of characters in a line; the
    correct use of commenting; the formulation of your own function documentation;
    and the conventions for naming classes, variables, and functions. For instance,
    [Listing 4-3](#listing4-3) shows a positive example from PEP 8’s guidelines on
    the correct way to use different stylings and conventions. You use four spaces
    per indentation level, align function arguments consistently, use single whitespaces
    when listing comma-separated values in argument lists, and correctly name functions
    and variables by combining multiple words with the underscore:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以通过这个链接访问官方的 Python 风格指南 PEP 8：[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)。和任何风格指南一样，PEP
    8 定义了正确的代码布局和缩进方法；如何设置换行符；每行最大字符数；正确使用注释；编写函数文档的方法；以及命名类、变量和函数的约定。例如，[列表 4-3](#listing4-3)
    展示了 PEP 8 指南中的正面示例，展示了如何正确使用不同的样式和约定。你需要为每个缩进级别使用四个空格，始终对齐函数参数，在列出逗号分隔的参数列表时使用单个空格，并通过使用下划线将多个单词结合起来来正确命名函数和变量：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 4-3: Use of indentation, spacing, and naming in Python according to
    the PEP 8 standard'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-3：根据 PEP 8 标准在 Python 中使用缩进、空格和命名
- en: '[Listing 4-4](#listing4-4) shows the wrong way to do it. The arguments are
    not aligned, multiple words are not properly combined in variable and function
    names, argument lists are not properly separated by a single empty space, and
    indentation levels have only two or three empty spaces instead of four:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-4](#listing4-4) 展示了错误的做法。参数没有对齐，多个单词在变量和函数名称中没有正确结合，参数列表没有用单个空格正确分隔，缩进级别只有两个或三个空格，而不是四个：'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-4: Incorrect use of indentation, spacing, and naming in Python'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：在 Python 中错误使用缩进、空格和命名
- en: All readers of your code will expect you to adhere to the accepted standards.
    Anything else will result in confusion and frustration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有阅读你代码的人都会期望你遵循已接受的标准。否则会导致混淆和挫败感。
- en: Reading through style guides can be a tedious task, though. As a less boring
    way to learn conventions and standards, use linters and integrated development
    environments (IDEs) that tell you where and how you’ve made mistakes. In a weekend
    hackathon with my Finxter team, we created a tool called Pythonchecker.com that
    playfully helps you refactor your Python code from messy to super clean. For Python,
    one of the best projects in this regard is the *black* module for PyCharm. Similar
    tools exist for all major programming languages. Just search the net for *<Your
    Language> Linter* to find the best tools for your programming environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，阅读风格指南可能是一个乏味的任务。作为一种不那么枯燥的学习约定和标准的方法，使用能够告诉你在哪里以及如何犯错的代码检查工具（如 linters）和集成开发环境（IDEs）。在与我的
    Finxter 团队参加一个周末黑客马拉松时，我们创建了一个工具，叫做 Pythonchecker.com，它以有趣的方式帮助你将 Python 代码从凌乱的状态重构为超级整洁。对于
    Python，最好的相关项目之一是 PyCharm 的 *black* 模块。类似的工具适用于所有主要的编程语言。只需在网上搜索 *<Your Language>
    Linter*，就可以找到适合你编程环境的最佳工具。
- en: 'Principle 6: Use Comments'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原则 6：使用注释
- en: As mentioned earlier, when writing code for humans, not machines, you’ll need
    to use comments to help readers understand it. Consider the code without comments
    in [Listing 4-5](#listing4-5).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在为人类而不是机器编写代码时，你需要使用注释来帮助读者理解代码。考虑一下 [列表 4-5](#listing4-5) 中没有注释的代码。
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-5: Code without comments'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-5：没有注释的代码
- en: '[Listing 4-5](#listing4-5) analyzes a short text snippet from Shakespeare’s
    *Romeo and Juliet* using regular expressions. If you’re not familiar with regular
    expressions, you’ll probably struggle to understand what the code does. Even the
    meaningful variable names don’t help much.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-5](#listing4-5) 分析了莎士比亚的 *罗密欧与朱丽叶* 中的一段短文本，通过正则表达式进行处理。如果你不熟悉正则表达式，你可能会很难理解这段代码的作用。即使是有意义的变量名称也没多大帮助。'
- en: Let’s see if a few comments can resolve your confusion (see [Listing 4-6](#listing4-6)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-6: Code with comments'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The two short comments (❶ ❷) illuminate the purpose of the regular expression
    patterns `'\\bf\w+\\b'` and `'\\bl\w+\\b'`. I won’t dive deeply into regular expressions
    here, but the example shows how comments can help you get a rough understanding
    of other people’s code without understanding the syntactic sugar.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: You can also use comments to abstract over blocks of code. For example, if you
    have five code lines that deal with updating customer information in a database,
    add a short comment before the block to explain this, as in [Listing 4-7](#listing4-7).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-7: Commented blocks give an overview of the code.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows how an online shop completes a customer order in two high-level
    steps: processing the next order ❶ and shipping the order ❷. The comments help
    you understand the purpose of the code quickly without needing to decipher each
    method call.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: You can also use comments to warn programmers of potentially undesirable consequences.
    For example, [Listing 4-8](#listing4-8) alerts us that calling the function `ship_yacht()`
    will actually ship an expensive yacht to a customer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 4-8: Comments as warnings'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: You can employ comments in many more useful ways; they are not only about applying
    the standards correctly. Keep the principle *code for humans* at the top of your
    mind when writing comments, and you will be fine. As you read code from experienced
    programmers, you’ll absorb the unspoken rules effectively and almost automatically
    over time. Since you’re the expert on code you’ve written, helpful comments give
    outsiders a glimpse into your thinking. Don’t miss out on sharing your insights
    with other people!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 7: Avoid Unnecessary Comments'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That said, not all comments help readers understand code better. In some cases,
    comments actually reduce clarity and confuse the readers of a codebase. To write
    clean code, you should not only use valuable comments but also avoid unnecessary
    comments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: During my time as a computer science researcher, a skilled student of mine successfully
    applied for a job at Google. He told me that the Google headhunters had criticized
    his code style because he added too many unnecessary comments. Evaluating your
    comments is another way expert coders can ascertain whether you’re a beginner,
    intermediate, or expert coder yourself. Issues in the code, such as breaking style
    guides, being lazy or sloppy with comments, or writing non-idiomatic code for
    a given programming language, are called *code smells* that point to potential
    problems in the code, and expert coders can spot them a mile away.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: How do you know which comments to leave out? In most cases, a comment is unnecessary
    if it is redundant. For example, if you’ve used meaningful variable names, the
    code often becomes self-explanatory and doesn’t require line-level comments. Let’s
    look at the code snippet with meaningful variable names in [Listing 4-9](#listing4-9).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 4-9: Code snippet with meaningful variable names'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: It’s already clear that the code calculates your cumulative investment return
    for 10 years, assuming a 10 percent yield. For the sake of argument, let’s add
    some unnecessary comments in [Listing 4-10](#listing4-10).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 4-10: Unnecessary comments'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: All comments in [Listing 4-10](#listing4-10) are redundant. Some would have
    been useful if you’d chosen less meaningful variable names, but explaining a variable
    named `yearly_return` with a comment about it representing the yearly return only
    adds unnecessary clutter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should use common sense to decide whether a comment is necessary,
    but here are some of the main guidelines.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Don’t use inline comments These can be avoided entirely by choosing meaningful
    variable names.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t add obvious comments In [Listing 4-10](#listing4-10), the comment explaining
    the `for` loop statement is unnecessary. Every coder knows the `for` loop, so
    there is no additional value in adding the comment `# Go over each year` given
    the expression `for year in range(years)`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t comment out old code; remove it We programmers often hang on to our beloved
    code snippets, even after we’ve (grudgingly) decided to remove them, by simply
    commenting them out. This kills your code’s readability! Always remove unnecessary
    code—for peace of mind, you can use a version history tool such as Git that saves
    earlier drafts of your project.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use documentation functionality Many programming languages such as Python come
    with built-in documentation functionality that allows you to describe the purpose
    of each function, method, and class in your code. If each of these has only a
    single responsibility (as per Principle 10), it’s often enough to use the documentation
    instead of comments to describe what your code does.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Principle 8: The Principle of Least Surprise'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The principle of least surprise states that a component of a system should
    behave in the way most users expect it to behave. This principle is one of the
    golden rules when designing effective applications and user experience. For example,
    if you open the Google search engine, the cursor will place itself in the search
    input field so that you can start typing your search keyword right away, just
    as you would expect: no surprises.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Clean code also leverages this design principle. Say you write a currency converter
    that converts the user’s input from USD to Chinese renminbi. You store the user
    input in a variable. Which variable name is better suited, `user_input` or `var_x`?
    The principle of least surprise answers this question for you!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 9: Don’t Repeat Yourself'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Don’t repeat yourself (DRY)* is a widely recognized principle that recommends,
    intuitively enough, avoiding repetitive code. For example, take the Python code
    in [Listing 4-11](#listing4-11), which prints the same string five times to the
    shell.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 4-11: Printing `hello world` five times'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Code that is much less repetitive is shown in [Listing 4-12](#listing4-12).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 4-12: Reducing the repetition found in [Listing 4-11](#listing4-11)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 4-12](#listing4-12) will print `hello world` five times,
    just as [Listing 4-11](#listing4-11) does, but without redundancy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Functions can also be a useful tool to reduce repetition. Say you need to convert
    miles into kilometers in multiple instances in your code, as in [Listing 4-13](#listing4-13).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: First, you create a variable `miles` and convert it to kilometers by multiplying
    it by 1.60934\. Second, you convert 20 miles to kilometers by multiplying 20 by
    1.60934, and store the result in the variable `distance`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 4-13: Converting miles to kilometers twice'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: You’ve used the same multiplication procedure twice by multiplying the miles
    value by the factor 1.60934 to convert miles to kilometers. DRY suggests that
    it would be better to write a function `miles_to_km(miles)` once, as in [Listing
    4-14](#listing4-14), rather than performing the same conversion explicitly in
    the code multiple times.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 4-14: Using a function to convert miles to kilometers'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: This way, the code is easier to maintain. You could, for example, tweak the
    function to increase the conversion accuracy, and you would have to make the change
    in only one place. In [Listing 4-13](#listing4-13), you’d have to search the code
    for all instances to make that improvement. Applying the DRY principle also makes
    the code easier to understand for human readers. There’s little doubt about the
    purpose of the function `miles_to_km(20)`, but you may have to think harder about
    the purpose of the computation `20 * 1.60934`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Violations of DRY are often abbreviated as WET: *we enjoy typing*, *write everything
    twice*, and *waste everyone’s time*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 10: Single Responsibility Principle'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The single responsibility principle means that every function should have one
    main task. It’s better to use many small functions than one big function accomplishing
    everything at the same time. The encapsulation of functionality reduces the overall
    code complexity.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule of thumb, every class and every function should have only one responsibility.
    Robert C. Martin, the inventor of this principle, defines a *responsibility* as
    a *reason to change*. His gold standard when defining a class and a function,
    thus, is to focus them on a single responsibility so that only the programmer
    who needs this single responsibility changed would request a change in the definition—and
    no other programmer with other responsibilities would even consider to issue a
    change request for the class when assuming, of course, that the code is correct.
    For example, a function that’s responsible for reading data from a database wouldn’t
    also be responsible for processing the data. Otherwise, the function would have
    two reasons to change: a change in the database model and a change in the processing
    requirements. If there are multiple reasons to change, multiple programmers may
    change the same class simultaneously. Your class has too many responsibilities
    and has become messy and cluttered.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a small Python example that may run on an ebook reader to model
    and manage a user’s reading experience ([Listing 4-15](#listing4-15)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 4-15: Modeling the `B``ook` class while violating the single responsibility
    principle'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in [Listing 4-15](#listing4-15) defines the class `Book` ❶ with four
    attributes: title, author, publisher, and the current page number. You define
    getter methods for the attributes ❷, along with some minimal functionality to
    move to the next page ❸, which may be called each time the user presses a button
    on the reading device. The function, `print_page()`, is responsible for printing
    the current page to the reading device ❹. This is only given as a stub and would
    be more complicated in the real world. Finally, you create a `Book` instance named
    `python_one_liners` ❺, and you access its attributes via a series of method calls
    and print statements in the last couple of lines. A real ebook reader implementation,
    for example, would call the methods `next_page()` and `print_page()` each time
    the user requests a new page when reading the book.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'While the code looks clean and simple, it violates the single responsibility
    principle: the class `Book` is responsible both for modeling data, such as the
    book content, and for printing the book to the device. Modeling and printing are
    two different functions but are encapsulated in a single class. You have multiple
    reasons to change. You may want to change the modeling of the book’s data: for
    example, you could use a database instead of a file-based input/output method.
    But you may also want to change the representation of the modeled data by, for
    example, using another book-formatting scheme on other types of screens.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Let’s fix this issue in [Listing 4-16](#listing4-16).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 4-16: Adhering to the single responsibility principle'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 4-16](#listing4-16) accomplishes the same task, but it
    satisfies the single responsibility principle. You create both a `Book` ❶ and
    a `Printer` ❸ class. The `Book` class represents book metadata and the current
    page number ❷, while the `Printer` class is responsible for printing the book
    to the device. You pass the book for which you want to print the current page
    into the method `Printer.print_page()` ❹. This way, data modeling (*what is the
    data?*) and data presentation (*how is the data presented to the user?*) are decoupled,
    and the code becomes easier to maintain. For example, if you wanted to change
    the book data model by adding a new attribute `publishing_year`, you’d do it in
    the class `Book`. And if you wanted to reflect this change in the data presentation
    by providing readers this information as well, you’d do so in the class `Printer`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 11: Test'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Test-driven development is an integral part of modern software development.
    No matter how skilled you are, you will make mistakes in your code. In order to
    catch them, you’ll need to run periodic tests or build test-driven code in the
    first place. Every great software company employs multiple levels of testing before
    it ships the final product to the public, since it’s far better to discover errors
    internally than to learn about them from unhappy users.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are no limitations to what types of tests you can perform to improve
    your software applications, these are the most common types:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests With unit tests, you write a separate application to check the correct
    input/output relationship for different inputs of each function in the application.
    The unit tests are usually applied at regular intervals—for example, each time
    a new software version is released. This reduces the likelihood that a software
    change will cause previously stable features to suddenly fail.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User acceptance tests These allow people in your target market to use your application
    in a controlled environment while you observe their behavior. You then ask them
    how they liked the application and how to improve it. These tests are usually
    deployed in the final phase of project development after extensive testing within
    the organization.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Smoke tests Smoke tests are rough tests designed to try to fail the application
    under development before the teams building the software give the application
    to the testing team. In other words, smoke tests are often deployed by the application-building
    team for quality assurance before handing the code to the testing teams. When
    the app passes the smoke test, it’s ready for the next round of testing.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performance tests Performance tests aim to show whether the application meets
    or even exceeds its users’ performance requirements rather than testing the actual
    functionality. For instance, before Netflix releases a new feature, it must test
    its website for page-loading time. If the new feature slows down the frontend
    too much, Netflix doesn’t release it, proactively avoiding a negative user experience.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scalability tests If your application becomes successful, you may have to handle
    1,000 requests per minute instead of the original 2 requests. A scalability test
    will show whether your application is scalable enough to handle that. Note that
    a performant application isn’t necessarily scalable and vice versa. For instance,
    a speed boat is very performant but doesn’t scale to thousands of people at a
    time!
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing and refactoring will often reduce complexity and the number of errors
    in your code. However, be careful not to over-engineer (see Principle 14)—you
    need to test scenarios that can occur only in the real world. For example, testing
    whether the Netflix application can handle 100 billion streaming devices is unnecessary
    considering there are only 7 billion potential viewers on the planet.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 12: Small Is Beautiful'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Small code* is code that requires only a relatively small number of lines
    to accomplish a single specified task. Here’s an example of a small code function
    that reads an integer value from a user and ensures the input is indeed an integer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The code runs until the user types in an integer. Here’s an example run:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By separating the logic of reading an integer value from a user, you can reuse
    the same function multiple times. But, more importantly, you’ve broken up the
    code into smaller units of functionality that are relatively easy to read and
    understand.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Instead, many beginner coders (or lazy intermediate coders) write large, monolithic
    code functions, or so-called *God objects*, that do everything in a centralized
    manner. These monolithic code blocks are a nightmare to maintain. For one thing,
    it’s easier for humans to understand one small code function at a time than to
    try to integrate a specific feature into a 10,000-line code block. You can potentially
    make far more mistakes in a large code block than in a few small functions and
    code blocks that you can then integrate with your existing codebase.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this chapter, [Figure 4-1](#figure4-1) showed that writing
    code becomes more time-consuming with each additional line, though writing clean
    code is much faster in the long run than writing dirty code. [Figure 4-2](#figure4-2)
    compares the time it takes to work with small code blocks versus monolithic code
    blocks. For large code blocks, the time it takes to add each additional line will
    increase superlinearly. If you stack multiple small code functions on top of each
    other, however, the time spent per additional line increases quasi-linearly. To
    best achieve this effect, you’ll need to be sure each code function is more or
    less independent of other code functions. You’ll learn more about this idea in
    the next principle, the Law of Demeter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Line graph with “Lines of code written” on the x-axis and “Time per additional
    line” on the y-axis. The “Big monolithic code block” line rapidly increases in
    time per line, and the “many small code blocks” line maintains a steady rate.](image_fi/502185c04/f04002.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: With the Big Monolithic Code Block, time increases exponentially.
    With the Many Small Code Blocks, time increases quasi-linearly.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 13: The Law of Demeter'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dependencies are everywhere. When you import a library in your code, your code
    depends partially on the library’s functionality, but it will also have interdependencies
    within itself. In object-oriented programming, one function may depend on another
    function, one object on another object, and one class definition on another class
    definition.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'To write clean code, minimize the interdependency of your code elements by
    following the *Law of Demeter*, which was proposed in the late 1980s by Ian Holland,
    a software developer working on a software project named after Demeter, the Greek
    goddess of agriculture, growth, and fertility. The project group promoted the
    idea of “growing software” as opposed to simply building it. However, what became
    known as the Law of Demeter has little to do with these arguably more metaphysic
    ideas—it’s a practical approach of writing loosely coupled code in object-oriented
    programming. Here’s a concise quote explaining the Law of Demeter from the project
    group’s website, [http://ccs.neu.edu/home/lieber/what-is-demeter.html](http://ccs.neu.edu/home/lieber/what-is-demeter.html):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'An important concept of Demeter is to split software into at least two parts:
    The first part defines the objects. The second part defines the operations. The
    goal of Demeter is to maintain a loose coupling between the objects and the operations,
    so that one can make modifications to either without serious impact on the other.
    This cuts down significantly on maintenance time.'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In other words, you should minimize the dependencies of your code objects.
    By reducing dependencies between code objects, you reduce the complexity of your
    code and, in turn, improve maintainability. One specific implication is that every
    object should call only its own methods or methods from adjacent objects rather
    than call methods of objects it obtains from calling a method of an adjacent object.
    For the sake of explanation, let’s define two objects A and B as *friends* if
    A calls a method provided by B. Simple. But what if B’s method returns a reference
    to object C? Now, object A may perform something like this: `B.method_of_B().method_of_C()`.
    This is called *chaining* of method calls—in our metaphor, you talk to a friend
    of your friend. The Law of Demeter says to *talk only to your immediate friends*,
    so it discourages this type of method chaining. This may sound confusing at first,
    so let’s dive into the practical example shown in [Figure 4-3](#figure4-3).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![Right side is a visual representation of a bad implementation of calculating
    price per coffee in the upcoming Listing 4-17, and the left side depicts a good
    implementation explored in Listing 4-18.](image_fi/502185c04/f04003.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: Law of Demeter: talking only to your friends to minimize dependencies'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-3](#figure4-3) shows two object-oriented code projects that calculate
    the price per cup of coffee for a given person. One of the implementations violates
    the Law of Demeter, and the other one adheres to it. Let’s start with the negative
    example first in which you use method chaining in the `Person` class to talk to
    a stranger ❶ (see [Listing 4-17](#listing4-17)).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 4-17: Code that violates the Law of Demeter'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: You create the method `price_per_cup()` that calculates the cost per cup of
    coffee based on the price of the coffee machine and the number of cups produced
    by this machine. The `Coffee_Cup` object collects information about the price
    of the coffee machine, which influences the price per cup, and passes it to the
    caller of the method `price_per_cup()` on the `Person` object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The diagram on the left of [Figure 4-3](#figure4-3) shows a bad strategy for
    doing so. Let’s look at the step-by-step explanation of the corresponding code
    from [Listing 4-17](#listing4-17).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The method `price_per_cup()` calls the method `Coffee_Cup.get_creator_machine()`
    to get a reference to the `Coffee_Machine` object that created the coffee.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `get_creator_machine()` returns an object reference to the `Coffee_Machine`
    object that has produced the cup’s contents.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `price_per_cup()` calls the method `Coffee_Machine.get_price()` on
    the `Coffee_Machine` object it just obtained from the previous `Coffee_Cup` method
    call.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `get_price()` returns the price of the machine.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `price_per_cup()` calculates the depreciation per cup and uses this
    to estimate the price of a single cup. This is returned to the caller of the method.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a bad strategy because the class `Person` depends on two objects: `Coffee_Cup`
    and `Coffee_Machine` ❶. A programmer responsible for maintaining this class must
    know about both parent class definitions—any change in either of those may impact
    the `Person` class as well.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The Law of Demeter minimizes such dependencies. You can see a better way to
    model the same problem on the right in [Figure 4-3](#figure4-3) and in [Listing
    4-18](#listing4-18). In this code snippet, the `Person` class doesn’t talk to
    the `Machine` class directly—it doesn’t even need to be aware of its existence!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 4-18: Code that adheres to the Law of Demeter by not talking to strangers'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine this code in a step-by-step manner:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The method `price_per_cup()` calls the method `Coffee_Cup.get_cost_per_cup()`
    to get the estimated price per cup.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `get_cost_per_cup()`—before replying to the calling method—calls
    the method `Coffee_Machine.get_price()` to access the price of the machine.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `get_price()` returns the price information.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `get_cost_per_cup()` calculates the price per cup and returns it
    to the calling method `price_per_cup()`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `price_per_cup()` simply forwards this calculated value to its caller
    ❶.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a better approach, because the class `Person` is now independent of
    the class `Coffee_Machine`. The total number of dependencies is reduced. For a
    project with hundreds of classes, reducing dependencies dramatically reduces the
    overall complexity of your application. Here’s the danger in terms of growing
    complexity for large applications: the number of potential dependencies grows
    superlinearly with the number of objects. Roughly speaking, a superlinear curve
    grows faster than a straight line. For example, doubling the number of objects
    can easily quadruple the number of dependencies (which equates to complexity).
    However, following the Law of Demeter can offset this trend by significantly reducing
    the number of dependencies. If every object talks to only *k* other objects and
    you have *n* objects, the total number of dependencies is bounded by *k*n*, which
    is a linear relationship if *k* is a constant. Thus, the Law of Demeter can mathematically
    help you gracefully scale your applications!'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 14: You Ain’t Gonna Need It'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle suggests that you should never implement code if you only *suspect*
    that you’ll need to use it someday in the future—because you ain’t gonna need
    it! Write code only if you’re 100 percent sure it’s necessary. Code for today’s
    needs and not tomorrow’s. If in the future you actually need the code you previously
    only suspected you needed, you can still implement the feature then. But in the
    meantime, you’ve saved many unnecessary lines of code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'It helps to think from first principles: the simplest and cleanest code is
    the empty file. Now, go from there—what do you *need* to add to that? In Chapter
    3, you learned about the MVP: code that is stripped of features to focus on the
    core functionality. If you minimize the number of features you pursue, you’ll
    obtain cleaner and simpler code than you could ever attain through refactoring
    methods or all other principles combined. Consider leaving out features that provide
    relatively little value compared to others. Opportunity costs are seldom measured
    but are often significant. You should really *need* a feature before you even
    consider implementing it.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'An implication of this is to avoid *overengineering*: creating a product that
    is more performant and robust or contains more features than needed. It adds unnecessary
    complexity, which should immediately ring your alarm bells.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: For example, I’ve often encountered problems that could be solved within a few
    minutes using a naive algorithmic approach but, like many programmers, I refused
    to accept the minor limitations of these algorithms. Instead, I studied state-of-the-art
    clustering algorithms to eke out a few percentage points of clustering performance
    compared to the simple KMeans algorithm. These long-tail optimizations were incredibly
    costly—I had to spend 80 percent of the time to obtain 20 percent of the improvement.
    This would have been unavoidable if I’d *needed* that 20 percent and had no other
    way to get it, but in reality, I didn’t need to implement fancy clustering algorithms.
    A typical case of overengineering!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Always go for the low-hanging fruit first. Use naive algorithms and straightforward
    methods to establish a benchmark, then analyze which new feature or performance
    optimization would yield superior results for the overall application. Think global,
    not local: focus on the big picture (as per Principle 1) rather than on small,
    time-consuming fixes.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 15: Don’t Use Too Many Levels of Indentation'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most programming languages use text indentation to visualize the hierarchical
    structure of potentially nested conditional blocks, function definitions, or code
    loops. Overusing indentation, however, can decrease the readability of your code.
    [Listing 4-19](#listing4-19) shows an example of a code snippet with too many
    levels of indentation, which makes it hard to quickly understand.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 4-19: Too many levels of nested code blocks'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: If you now try to guess the output of this code snippet, you’ll find it’s actually
    difficult to trace. The code function `if_confusion(x, y)` performs relatively
    simple checks on variables `x` and `y`. However, it’s easy to get lost in the
    different levels of indentation. The code is not clean at all.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-20](#listing4-20) shows how to write the same code more cleanly
    and simply.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 4-20: Fewer levels of nested code blocks'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 4-20](#listing4-20), we reduced indentation and nesting. You can
    now go over all checks and see what applies first to your two arguments `x` and
    `y`. Most coders will enjoy reading flat code much more than reading highly nested
    code—even if it comes at the expense of redundant checks; here, for example, `x>y`
    is checked multiple times.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 16: Use Metrics'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use code quality metrics to track the complexity of your code over time. The
    ultimate, if informal, metric is known as the number of WTFs per minute, intended
    to measure your code readers’ frustration. The results will be low for clean and
    simple code and high for dirty, confusing code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: As a proxy for this hard-to-quantify standard, you can use established metrics
    such as the NPath complexity or cyclomatic complexity discussed in Chapter 1.
    For most IDEs, many online tools and plug-ins will automatically calculate the
    complexity as you write your source code. These include CyclomaticComplexity,
    which you can find by searching in the plug-ins section of JetBrains at [https://plugins.jetbrains.com/](https://plugins.jetbrains.com/).
    In my experience, the actual measure of complexity used is less important than
    being aware of the fact that you need to weed out complexity wherever you can.
    I highly recommend using these tools to help you write cleaner and simpler code.
    The return on your invested time will be phenomenal.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Principle 17: Boy Scout Rule and Refactoring'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The boy scout rule is simple: *leave the campground cleaner than you found
    it*. It’s a great rule to live and code by. Get into the habit of cleaning up
    every piece of code you encounter. This will not only improve the codebases you’re
    involved in and make your own life easier but also help you develop the sharp
    eye of a master coder who can evaluate source code quickly. As a bonus, it’ll
    help your team be more productive, and your colleagues will be grateful for your
    value-oriented attitude. Note that this shouldn’t violate the rule we stated earlier
    about avoiding premature optimization (overengineering). Spending time to clean
    up your code to reduce complexity is almost always efficient. Doing so will yield
    big dividends in reduced maintenance overhead, bugs, and cognitive demands. Put
    succinctly, overengineering is likely to *increase* complexity whereas cleaning
    up the code will *reduce* complexity.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The process of improving your code is called *refactoring*. You could argue
    that refactoring is the overall method comprising every principle we’ve discussed
    here. As a great coder, you’ll incorporate many of the clean code principles from
    the beginning. Even then, however, you’ll still need to occasionally refactor
    your code to clean up any messes you’ve made. In particular, you should refactor
    your code before releasing any new features to keep the code clean.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: There are many techniques for refactoring code. One is to explain your code
    to a colleague or have them look it over in order to discover any poor decisions
    you’ve made and had not noticed on your own. For example, you may have created
    two classes, `Cars` and `Trucks`, because you expected your application would
    need to model both. As you explain your code to your teammate, you realize that
    you don’t use the class `Trucks` very often—and when you do, you use methods that
    already exist in the `Car` class. Your colleague suggests creating a `Vehicle`
    class that handles all cars and trucks. This allows you to get rid of many lines
    of code immediately. This type of thinking can result in enormous improvements,
    since it will force you to account for your decisions and explain your project
    from a bird’s-eye view.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: If you’re an introverted coder, you can explain your code to a rubber duck instead—a
    technique known as *rubber duck debugging*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Beyond speaking to your colleagues (or your rubber duck), you can use the other
    clean code principles listed here to quickly evaluate your code from time to time.
    When you do, you’ll likely discover some tweaks you can apply quickly to greatly
    reduce complexity by cleaning up your codebase. This integral part of your software
    development process will improve your results significantly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned 17 principles for how to write clean and simple
    code. You’ve learned that clean code reduces complexity and increases your productivity
    as well as the scalability and maintainability of your project. You’ve learned
    that you should use libraries wherever possible to reduce clutter and increase
    your code quality. You’ve learned that choosing meaningful names of variables
    and functions while adhering to standards is important to reduce friction for
    future readers of your code. You’ve learned to design functions to do one thing
    only. Reducing complexity and increasing scalability by minimizing dependencies
    (according to the Law of Demeter) can be done by avoiding direct and indirect
    method chaining. You’ve learned to comment code in a way that provides a valuable
    glimpse into your mind, but you’ve also learned to avoid unnecessary or trivial
    comments. And, most importantly, you’ve learned that the key to unlocking your
    clean code superpower is to code for humans, not machines.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: You can gradually improve your clean code–writing skills by collaborating with
    great coders, reading their code on GitHub, and studying the best practices in
    your programming language. Integrate a linter that dynamically checks your code
    against those best practices into your programming environment. From time to time,
    revisit these clean code principles and check your current project against them.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you’ll learn another principle of effective coding that
    goes beyond just writing clean code: premature optimization. You’ll be surprised
    by how much time and effort is wasted by programmers who haven’t yet figured out
    that *premature optimization is the root of all evil*!'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
