["```py\n>>> **print(\"Hello Python interpreter!\")**\nHello Python interpreter!\n```", "```py\nC:\\> **python**\nPython 3.`x`.`x` (main, Jun . . . , 13:29:14) [MSC v.1932 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n```", "```py\n>>> **print(\"Hello Python interpreter!\")**\nHello Python interpreter!\n>>>\n```", "```py\n$ **python3**\nPython 3.`x`.`x` (v3.11.0:eb0004c271, Jun . . . , 10:03:01)\n[Clang 13.0.0 (clang-1300.0.29.30)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n```", "```py\n>>> **print(\"Hello Python interpreter!\")**\nHello Python interpreter!\n>>>\n```", "```py\n$ **python3**\nPython 3.10.4 (main, Apr  . . . , 09:04:19) [GCC 11.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\n```", "```py\n>>> **print(\"Hello Python interpreter!\")**\nHello Python interpreter!\n>>>\n```", "```py\nprint(\"Hello Python world!\")\n```", "```py\nHello Python world!\n```", "```py\nC:\\> **cd Desktop\\python_work**\nC:\\Desktop\\python_work> **dir**\nhello_world.py\nC:\\Desktop\\python_work> **python hello_world.py**\nHello Python world!\n```", "```py\n~$ **cd Desktop/python_work/**\n~/Desktop/python_work$ **ls**\nhello_world.py\n~/Desktop/python_work$ **python3 hello_world.py**\nHello Python world!\n```", "```py\nprint(\"Hello Python world!\")\n```", "```py\nHello Python world!\n```", "```py\nmessage = \"Hello Python world!\"\nprint(message)\n```", "```py\nHello Python world!\n```", "```py\nmessage = \"Hello Python world!\"\nprint(message)\n\nmessage = \"Hello Python Crash Course world!\"\nprint(message)\n```", "```py\nHello Python world!\nHello Python Crash Course world!\n```", "```py\nmessage = \"Hello Python Crash Course reader!\"\nprint(**mesage**)\n```", "```py\nTraceback (most recent call last):\n❶   File \"hello_world.py\", line 2, in <module>\n❷     print(mesage)\n          ^^^^^^\n❸ NameError: name 'mesage' is not defined. Did you mean: 'message'?\n```", "```py\nmesage = \"Hello Python Crash Course reader!\"\nprint(mesage)\n```", "```py\nHello Python Crash Course reader!\n```", "```py\n\"This is a string.\"\n'This is also a string.'\n```", "```py\n'I told my friend, \"Python is my favorite language!\"'\n\"The language 'Python' is named after Monty Python, not the snake.\"\n\"One of Python's strengths is its diverse and supportive community.\"\n```", "```py\nname = \"ada lovelace\"\nprint(name.title())\n```", "```py\nAda Lovelace\n```", "```py\nname = \"Ada Lovelace\"\nprint(name.upper())\nprint(name.lower())\n```", "```py\nADA LOVELACE\nada lovelace\n```", "```py\nfirst_name = \"ada\"\nlast_name = \"lovelace\"\n❶ full_name = f\"{first_name} {last_name}\"\nprint(full_name)\n```", "```py\nada lovelace\n```", "```py\nfirst_name = \"ada\"\nlast_name = \"lovelace\"\nfull_name = f\"{first_name} {last_name}\"\n❶ print(f\"Hello, {full_name.title()}!\")\n```", "```py\nHello, Ada Lovelace!\n```", "```py\nfirst_name = \"ada\"\nlast_name = \"lovelace\"\nfull_name = f\"{first_name} {last_name}\"\n❶ message = f\"Hello, {full_name.title()}!\"\n❷ print(message)\n```", "```py\n>>> **print(\"Python\")**\nPython\n>>> **print(\"\\tPython\")**\n    Python\n```", "```py\n>>> **print(\"Languages:\\nPython\\nC\\nJavaScript\")**\nLanguages:\nPython\nC\nJavaScript\n```", "```py\n>>> **print(\"Languages:\\n\\tPython\\n\\tC\\n\\tJavaScript\")**\nLanguages:\n    Python\n    C\n    JavaScript\n```", "```py\n❶ >>> **favorite_language = 'python '**\n❷ >>> **favorite_language**\n'python '\n❸ >>> **favorite_language.rstrip()**\n'python'\n❹ >>> **favorite_language**\n'python '\n```", "```py\n>>> **favorite_language = 'python '**\n❶ >>> **favorite_language = favorite_language.rstrip()**\n>>> **favorite_language**\n'python'\n```", "```py\n❶ >>> **favorite_language = ' python '**\n❷ >>> **favorite_language.rstrip()**\n' python'\n❸ >>> **favorite_language.lstrip()**\n'python '\n❹ >>> **favorite_language.strip()**\n'python'\n```", "```py\n>>> nostarch_url = 'https://nostarch.com'\n>>> nostarch_url.removeprefix('https://')\n'nostarch.com'\n```", "```py\n>>> simple_url = nostarch_url.removeprefix('https://')\n```", "```py\nmessage = \"One of Python's strengths is its diverse community.\"\nprint(message)\n```", "```py\nOne of Python's strengths is its diverse community.\n```", "```py\nmessage = 'One of Python's strengths is its diverse community.'\nprint(message)\n```", "```py\n File \"apostrophe.py\", line 1\n    message = 'One of Python's strengths is its diverse community.'\n                                                                ❶ ^\nSyntaxError: unterminated string literal (detected at line 1)\n```", "```py\n>>> **2 + 3**\n5\n>>> **3 - 2**\n1\n>>> **2 * 3**\n6\n>>> **3 / 2**\n1.5\n```", "```py\n>>> **3 ** 2**\n9\n>>> **3 ** 3**\n27\n>>> **10 ** 6**\n1000000\n```", "```py\n>>> **2 + 3*4**\n14\n>>> **(2 + 3) * 4**\n20\n```", "```py\n>>> **0.1 + 0.1**\n0.2\n>>> **0.2 + 0.2**\n0.4\n>>> **2 * 0.1**\n0.2\n>>> **2 * 0.2**\n0.4\n```", "```py\n>>> **0.2 + 0.1**\n0.30000000000000004\n>>> **3 * 0.1**\n0.30000000000000004\n```", "```py\n>>> **4/2**\n2.0\n```", "```py\n>>> **1 + 2.0**\n3.0\n>>> **2 * 3.0**\n6.0\n>>> **3.0 ** 2**\n9.0\n```", "```py\n>>> **universe_age = 14_000_000_000**\n```", "```py\n>>> **print(universe_age)**\n14000000000\n```", "```py\n>>> **x, y, z = 0, 0, 0**\n```", "```py\nMAX_CONNECTIONS = 5000\n```", "```py\n# Say hello to everyone.\nprint(\"Hello Python people!\")\n```", "```py\nHello Python people!\n```", "```py\n>>> **import this**\nThe Zen of Python, by Tim Peters\nBeautiful is better than ugly.\n```", "```py\nSimple is better than complex.\n```", "```py\nComplex is better than complicated.\n```", "```py\nReadability counts.\n```", "```py\nThere should be one-- and preferably only one --obvious way to do it.\n```", "```py\nNow is better than never.\n```", "```py\nbicycles = ['trek', 'cannondale', 'redline', 'specialized']\nprint(bicycles)\n```", "```py\n['trek', 'cannondale', 'redline', 'specialized']\n```", "```py\nbicycles = ['trek', 'cannondale', 'redline', 'specialized']\nprint(bicycles[0])\n```", "```py\ntrek\n```", "```py\nbicycles = ['trek', 'cannondale', 'redline', 'specialized']\nprint(bicycles[0].title())\n```", "```py\nbicycles = ['trek', 'cannondale', 'redline', 'specialized']\nprint(bicycles[1])\nprint(bicycles[3])\n```", "```py\ncannondale\nspecialized\n```", "```py\nbicycles = ['trek', 'cannondale', 'redline', 'specialized']\nprint(bicycles[-1])\n```", "```py\nbicycles = ['trek', 'cannondale', 'redline', 'specialized']\nmessage = f\"My first bicycle was a {bicycles[0].title()}.\"\n\nprint(message)\n```", "```py\nMy first bicycle was a Trek.\n```", "```py\nmotorcycles = ['honda', 'yamaha', 'suzuki']\nprint(motorcycles)\n\nmotorcycles[0] = 'ducati'\nprint(motorcycles)\n```", "```py\n['honda', 'yamaha', 'suzuki']\n['ducati', 'yamaha', 'suzuki']\n```", "```py\nmotorcycles = ['honda', 'yamaha', 'suzuki']\nprint(motorcycles)\n\nmotorcycles.append('ducati')\nprint(motorcycles)\n```", "```py\n['honda', 'yamaha', 'suzuki']\n['honda', 'yamaha', 'suzuki', 'ducati']\n```", "```py\nmotorcycles = []\n\nmotorcycles.append('honda')\nmotorcycles.append('yamaha')\nmotorcycles.append('suzuki')\n\nprint(motorcycles)\n```", "```py\n['honda', 'yamaha', 'suzuki']\n```", "```py\nmotorcycles = ['honda', 'yamaha', 'suzuki']\n\nmotorcycles.insert(0, 'ducati')\nprint(motorcycles)\n```", "```py\n['ducati', 'honda', 'yamaha', 'suzuki']\n```", "```py\nmotorcycles = ['honda', 'yamaha', 'suzuki']\nprint(motorcycles)\n\ndel motorcycles[0]\nprint(motorcycles)\n```", "```py\n['honda', 'yamaha', 'suzuki']\n['yamaha', 'suzuki']\n```", "```py\nmotorcycles = ['honda', 'yamaha', 'suzuki']\nprint(motorcycles)\n\ndel motorcycles[1]\nprint(motorcycles)\n```", "```py\n['honda', 'yamaha', 'suzuki']\n['honda', 'suzuki']\n```", "```py\n❶ motorcycles = ['honda', 'yamaha', 'suzuki']\nprint(motorcycles)\n\n❷ popped_motorcycle = motorcycles.pop()\n❸ print(motorcycles)\n❹ print(popped_motorcycle)\n```", "```py\n['honda', 'yamaha', 'suzuki']\n['honda', 'yamaha']\nsuzuki\n```", "```py\nmotorcycles = ['honda', 'yamaha', 'suzuki']\n\nlast_owned = motorcycles.pop()\nprint(f\"The last motorcycle I owned was a {last_owned.title()}.\")\n```", "```py\nThe last motorcycle I owned was a Suzuki.\n```", "```py\nmotorcycles = ['honda', 'yamaha', 'suzuki']\n\nfirst_owned = motorcycles.pop(0)\nprint(f\"The first motorcycle I owned was a {first_owned.title()}.\")\n```", "```py\nThe first motorcycle I owned was a Honda.\n```", "```py\nmotorcycles = ['honda', 'yamaha', 'suzuki', 'ducati']\nprint(motorcycles)\n\nmotorcycles.remove('ducati')\nprint(motorcycles)\n```", "```py\n['honda', 'yamaha', 'suzuki', 'ducati']\n['honda', 'yamaha', 'suzuki']\n```", "```py\n❶ motorcycles = ['honda', 'yamaha', 'suzuki', 'ducati']\nprint(motorcycles)\n\n❷ too_expensive = 'ducati'\n❸ motorcycles.remove(too_expensive)\nprint(motorcycles)\n❹ print(f\"\\nA {too_expensive.title()} is too expensive for me.\")\n```", "```py\n['honda', 'yamaha', 'suzuki', 'ducati']\n['honda', 'yamaha', 'suzuki']\n\nA Ducati is too expensive for me.\n```", "```py\ncars = ['bmw', 'audi', 'toyota', 'subaru']\ncars.sort()\nprint(cars)\n```", "```py\n['audi', 'bmw', 'subaru', 'toyota']\n```", "```py\ncars = ['bmw', 'audi', 'toyota', 'subaru']\ncars.sort(reverse=True)\nprint(cars)\n```", "```py\n['toyota', 'subaru', 'bmw', 'audi']\n```", "```py\ncars = ['bmw', 'audi', 'toyota', 'subaru']\n\n❶ print(\"Here is the original list:\")\nprint(cars)\n\n❷ print(\"\\nHere is the sorted list:\")\nprint(sorted(cars))\n\n❸ print(\"\\nHere is the original list again:\")\nprint(cars)\n```", "```py\nHere is the original list:\n['bmw', 'audi', 'toyota', 'subaru']\n\nHere is the sorted list:\n['audi', 'bmw', 'subaru', 'toyota']\n\n❶ Here is the original list again:\n['bmw', 'audi', 'toyota', 'subaru']\n```", "```py\ncars = ['bmw', 'audi', 'toyota', 'subaru']\nprint(cars)\n\ncars.reverse()\nprint(cars)\n```", "```py\n['bmw', 'audi', 'toyota', 'subaru']\n['subaru', 'toyota', 'audi', 'bmw']\n```", "```py\n>>> **cars = ['bmw', 'audi', 'toyota', 'subaru']**\n>>> **len(cars)**\n4\n```", "```py\nmotorcycles = ['honda', 'yamaha', 'suzuki']\nprint(motorcycles[3])\n```", "```py\nTraceback (most recent call last):\n  File \"motorcycles.py\", line 2, in <module>\n    print(motorcycles[3])\n          ~~~~~~~~~~~^^^\nIndexError: list index out of range\n```", "```py\nmotorcycles = ['honda', 'yamaha', 'suzuki']\nprint(motorcycles[-1])\n```", "```py\nsuzuki\n```", "```py\nmotorcycles = []\nprint(motorcycles[-1])\n```", "```py\nTraceback (most recent call last):\n  File \"motorcyles.py\", line 3, in <module>\n    print(motorcycles[-1])\n          ~~~~~~~~~~~^^^^\nIndexError: list index out of range\n```", "```py\nmagicians = ['alice', 'david', 'carolina']\nfor magician in magicians:\n    print(magician)\n```", "```py\nalice\ndavid\ncarolina\n```", "```py\nfor magician in magicians:\n```", "```py\n print(magician)\n```", "```py\nfor magician in magicians:\n```", "```py\n print(magician)\n```", "```py\nfor cat in cats:\nfor dog in dogs:\nfor item in list_of_items:\n```", "```py\nmagicians = ['alice', 'david', 'carolina']\nfor magician in magicians:\n    print(f\"{magician.title()}, that was a great trick!\")\n```", "```py\nAlice, that was a great trick!\nDavid, that was a great trick!\nCarolina, that was a great trick!\n```", "```py\nmagicians = ['alice', 'david', 'carolina']\nfor magician in magicians:\n print(f\"{magician.title()}, that was a great trick!\")\n    print(f\"I can't wait to see your next trick, {magician.title()}.\\n\")\n```", "```py\nAlice, that was a great trick!\nI can't wait to see your next trick, Alice.\n\nDavid, that was a great trick!\nI can't wait to see your next trick, David.\n\nCarolina, that was a great trick!\nI can't wait to see your next trick, Carolina.\n```", "```py\nmagicians = ['alice', 'david', 'carolina']\nfor magician in magicians:\n print(f\"{magician.title()}, that was a great trick!\")\n print(f\"I can't wait to see your next trick, {magician.title()}.\\n\")\n\nprint(\"Thank you, everyone. That was a great magic show!\")\n```", "```py\nAlice, that was a great trick!\nI can't wait to see your next trick, Alice.\n\nDavid, that was a great trick!\nI can't wait to see your next trick, David.\n\nCarolina, that was a great trick!\nI can't wait to see your next trick, Carolina.\n\nThank you, everyone. That was a great magic show!\n```", "```py\nmagicians = ['alice', 'david', 'carolina']\nfor magician in magicians:\n❶ print(magician)\n```", "```py\n File \"magicians.py\", line 3\n    print(magician)\n    ^\nIndentationError: expected an indented block after 'for' statement on line 2\n```", "```py\nmagicians = ['alice', 'david', 'carolina']\nfor magician in magicians:\n    print(f\"{magician.title()}, that was a great trick!\")\n❶ print(f\"I can't wait to see your next trick, {magician.title()}.\\n\")\n```", "```py\nAlice, that was a great trick!\nDavid, that was a great trick!\nCarolina, that was a great trick!\nI can't wait to see your next trick, Carolina.\n```", "```py\nmessage = \"Hello Python world!\"\n    print(message)\n```", "```py\n File \"hello_world.py\", line 2\n    print(message)\n    ^\nIndentationError: unexpected indent\n```", "```py\nmagicians = ['alice', 'david', 'carolina']\nfor magician in magicians:\n    print(f\"{magician.title()}, that was a great trick!\")\n    print(f\"I can't wait to see your next trick, {magician.title()}.\\n\")\n\n❶     print(\"Thank you everyone, that was a great magic show!\")\n```", "```py\nAlice, that was a great trick!\nI can't wait to see your next trick, Alice.\n\nThank you everyone, that was a great magic show!\nDavid, that was a great trick!\nI can't wait to see your next trick, David.\n\nThank you everyone, that was a great magic show!\nCarolina, that was a great trick!\nI can't wait to see your next trick, Carolina.\n\nThank you everyone, that was a great magic show!\n```", "```py\nmagicians = ['alice', 'david', 'carolina']\n❶ for magician in magicians\n    print(magician)\n```", "```py\n File \"magicians.py\", line 2\n    for magician in magicians\n                             ^\nSyntaxError: expected ':'\n```", "```py\nfor value in range(1, 5):\n    print(value)\n```", "```py\n1\n2\n3\n4\n```", "```py\nfor value in range(1, 6):\n    print(value)\n```", "```py\n1\n2\n3\n4\n5\n```", "```py\nnumbers = list(range(1, 6))\nprint(numbers)\n```", "```py\n[1, 2, 3, 4, 5]\n```", "```py\neven_numbers = list(range(2, 11, 2))\nprint(even_numbers)\n```", "```py\n[2, 4, 6, 8, 10]\n```", "```py\nsquares = []\nfor value in range(1, 11):\n❶     square = value ** 2\n❷     squares.append(square)\n\nprint(squares)\n```", "```py\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n```", "```py\nsquares = []\nfor value in range(1,11):\n    squares.append(value**2)\n\nprint(squares)\n```", "```py\n>>> **digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]**\n>>> **min(digits)**\n0\n>>> **max(digits)**\n9\n>>> **sum(digits)**\n45\n```", "```py\nsquares = [value**2 for value in range(1, 11)]\nprint(squares)\n```", "```py\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n```", "```py\nplayers = ['charles', 'martina', 'michael', 'florence', 'eli']\nprint(players[0:3])\n```", "```py\n['charles', 'martina', 'michael']\n```", "```py\nplayers = ['charles', 'martina', 'michael', 'florence', 'eli']\nprint(players[1:4])\n```", "```py\n['martina', 'michael', 'florence']\n```", "```py\nplayers = ['charles', 'martina', 'michael', 'florence', 'eli']\nprint(players[:4])\n```", "```py\n['charles', 'martina', 'michael', 'florence']\n```", "```py\nplayers = ['charles', 'martina', 'michael', 'florence', 'eli']\nprint(players[2:])\n```", "```py\n['michael', 'florence', 'eli']\n```", "```py\nplayers = ['charles', 'martina', 'michael', 'florence', 'eli']\nprint(players[-3:])\n```", "```py\nplayers = ['charles', 'martina', 'michael', 'florence', 'eli']\n\nprint(\"Here are the first three players on my team:\")\n❶ for player in players[:3]:\n    print(player.title())\n```", "```py\nHere are the first three players on my team:\nCharles\nMartina\nMichael\n```", "```py\nmy_foods = ['pizza', 'falafel', 'carrot cake']\n❶ friend_foods = my_foods[:]\n\nprint(\"My favorite foods are:\")\nprint(my_foods)\n\nprint(\"\\nMy friend's favorite foods are:\")\nprint(friend_foods)\n```", "```py\nMy favorite foods are:\n['pizza', 'falafel', 'carrot cake']\n\nMy friend's favorite foods are:\n['pizza', 'falafel', 'carrot cake']\n```", "```py\nmy_foods = ['pizza', 'falafel', 'carrot cake']\n❶ friend_foods = my_foods[:]\n\n❷ my_foods.append('cannoli')\n❸ friend_foods.append('ice cream')\n\nprint(\"My favorite foods are:\")\nprint(my_foods)\n\nprint(\"\\nMy friend's favorite foods are:\")\nprint(friend_foods)\n```", "```py\nMy favorite foods are:\n['pizza', 'falafel', 'carrot cake', 'cannoli']\n\nMy friend's favorite foods are:\n['pizza', 'falafel', 'carrot cake', 'ice cream']\n```", "```py\nmy_foods = ['pizza', 'falafel', 'carrot cake']\n\n# This doesn't work:\nfriend_foods = my_foods\n\nmy_foods.append('cannoli')\nfriend_foods.append('ice cream')\n\nprint(\"My favorite foods are:\")\nprint(my_foods)\n\nprint(\"\\nMy friend's favorite foods are:\")\nprint(friend_foods)\n```", "```py\nMy favorite foods are:\n['pizza', 'falafel', 'carrot cake', 'cannoli', 'ice cream']\n\nMy friend's favorite foods are:\n['pizza', 'falafel', 'carrot cake', 'cannoli', 'ice cream']\n```", "```py\ndimensions = (200, 50)\nprint(dimensions[0])\nprint(dimensions[1])\n```", "```py\n200\n50\n```", "```py\ndimensions = (200, 50)\ndimensions[0] = 250\n```", "```py\nTraceback (most recent call last):\n  File \"dimensions.py\", line 2, in <module>\n    dimensions[0] = 250\nTypeError: 'tuple' object does not support item assignment\n```", "```py\ndimensions = (200, 50)\nfor dimension in dimensions:\n    print(dimension)\n```", "```py\n200\n50\n```", "```py\ndimensions = (200, 50)\nprint(\"Original dimensions:\")\nfor dimension in dimensions:\n    print(dimension)\n\ndimensions = (400, 100)\nprint(\"\\nModified dimensions:\")\nfor dimension in dimensions:\n    print(dimension)\n```", "```py\nOriginal dimensions:\n200\n50\n\nModified dimensions:\n400\n100\n```", "```py\ncars = ['audi', 'bmw', 'subaru', 'toyota']\n\nfor car in cars:\n❶     if car == 'bmw':\n        print(car.upper())\n    else:\n        print(car.title())\n```", "```py\nAudi\nBMW\nSubaru\nToyota\n```", "```py\n>>> **car = 'bmw'**\n>>> **car == 'bmw'**\nTrue\n```", "```py\n>>> **car = 'audi'**\n>>> **car == 'bmw'**\nFalse\n```", "```py\n>>> **car = 'Audi'**\n>>> **car == 'audi'**\nFalse\n```", "```py\n>>> **car = 'Audi'**\n>>> **car.lower() == 'audi'**\nTrue\n```", "```py\n>>> **car = 'Audi'**\n>>> **car.lower() == 'audi'**\nTrue\n>>> **car**\n'Audi'\n```", "```py\nrequested_topping = 'mushrooms'\n\nif requested_topping != 'anchovies':\n    print(\"Hold the anchovies!\")\n```", "```py\nHold the anchovies!\n```", "```py\n>>> **age = 18**\n>>> **age == 18**\nTrue\n```", "```py\nanswer = 17\nif answer != 42:\n    print(\"That is not the correct answer. Please try again!\")\n```", "```py\nThat is not the correct answer. Please try again!\n```", "```py\n>>> **age = 19**\n>>> **age < 21**\nTrue\n>>> **age <= 21**\nTrue\n>>> **age > 21**\nFalse\n>>> **age >= 21**\nFalse\n```", "```py\n>>> **age_0 = 22**\n>>> **age_1 = 18**\n❶ >>> **age_0 >= 21 and age_1 >= 21**\nFalse\n❷ >>> **age_1 = 22**\n>>> **age_0 >= 21 and age_1 >= 21**\nTrue\n```", "```py\n(age_0 >= 21) and (age_1 >= 21)\n```", "```py\n>>> **age_0 = 22**\n>>> **age_1 = 18**\n❶ >>> **age_0 >= 21 or age_1 >= 21**\nTrue\n❷ >>> **age_0 = 18**\n>>> **age_0 >= 21 or age_1 >= 21**\nFalse\n```", "```py\n>>> **requested_toppings = ['mushrooms', 'onions', 'pineapple']**\n>>> **'mushrooms' in requested_toppings**\nTrue\n>>> **'pepperoni' in requested_toppings**\nFalse\n```", "```py\nbanned_users = ['andrew', 'carolina', 'david']\nuser = 'marie'\n\nif user not in banned_users:\n    print(f\"{user.title()}, you can post a response if you wish.\")\n```", "```py\nMarie, you can post a response if you wish.\n```", "```py\ngame_active = True\ncan_edit = False\n```", "```py\nif `conditional_test`:\n    `do something`\n```", "```py\nage = 19\nif age >= 18:\n    print(\"You are old enough to vote!\")\n```", "```py\nYou are old enough to vote!\n```", "```py\nage = 19\nif age >= 18:\n print(\"You are old enough to vote!\")\n    print(\"Have you registered to vote yet?\")\n```", "```py\nYou are old enough to vote!\nHave you registered to vote yet?\n```", "```py\nage = 17\n❶ if age >= 18:\n print(\"You are old enough to vote!\")\n print(\"Have you registered to vote yet?\")\n❷ else:\n    print(\"Sorry, you are too young to vote.\")\n    print(\"Please register to vote as soon as you turn 18!\")\n```", "```py\nSorry, you are too young to vote.\nPlease register to vote as soon as you turn 18!\n```", "```py\nage = 12\n❶ if age < 4:\n    print(\"Your admission cost is $0.\")\n❷ elif age < 18:\n    print(\"Your admission cost is $25.\")\n❸ else:\n    print(\"Your admission cost is $40.\")\n```", "```py\nYour admission cost is $25.\n```", "```py\nage = 12\n\nif age < 4:\n    price = 0\nelif age < 18:\n    price = 25\nelse:\n    price = 40\n\nprint(f\"Your admission cost is ${price}.\")\n```", "```py\nage = 12\n\nif age < 4:\n price = 0\nelif age < 18:\n price = 25\nelif age < 65:\n    price = 40\nelse:\n    price = 20\n\nprint(f\"Your admission cost is ${price}.\")\n```", "```py\nage = 12\n\nif age < 4:\n price = 0\nelif age < 18:\n price = 25\nelif age < 65:\n price = 40\nelif age >= 65:\n    price = 20\n\nprint(f\"Your admission cost is ${price}.\")\n```", "```py\nrequested_toppings = ['mushrooms', 'extra cheese']\n\nif 'mushrooms' in requested_toppings:\n    print(\"Adding mushrooms.\")\n❶ if 'pepperoni' in requested_toppings:\n    print(\"Adding pepperoni.\")\nif 'extra cheese' in requested_toppings:\n    print(\"Adding extra cheese.\")\n\nprint(\"\\nFinished making your pizza!\")\n```", "```py\nAdding mushrooms.\nAdding extra cheese.\n\nFinished making your pizza!\n```", "```py\nrequested_toppings = ['mushrooms', 'extra cheese']\n\nif 'mushrooms' in requested_toppings:\n print(\"Adding mushrooms.\")\nelif 'pepperoni' in requested_toppings:\n    print(\"Adding pepperoni.\")\nelif 'extra cheese' in requested_toppings:\n    print(\"Adding extra cheese.\")\n\nprint(\"\\nFinished making your pizza!\")\n```", "```py\nAdding mushrooms.\n\nFinished making your pizza!\n```", "```py\nrequested_toppings = ['mushrooms', 'green peppers', 'extra cheese']\n\nfor requested_topping in requested_toppings:\n    print(f\"Adding {requested_topping}.\")\n\nprint(\"\\nFinished making your pizza!\")\n```", "```py\nAdding mushrooms.\nAdding green peppers.\nAdding extra cheese.\n\nFinished making your pizza!\n```", "```py\nrequested_toppings = ['mushrooms', 'green peppers', 'extra cheese']\n\nfor requested_topping in requested_toppings:\n    if requested_topping == 'green peppers':\n        print(\"Sorry, we are out of green peppers right now.\")\n    else:\n        print(f\"Adding {requested_topping}.\")\n\nprint(\"\\nFinished making your pizza!\")\n```", "```py\nAdding mushrooms.\nSorry, we are out of green peppers right now.\nAdding extra cheese.\n\nFinished making your pizza!\n```", "```py\nrequested_toppings = []\n\nif requested_toppings:\n    for requested_topping in requested_toppings:\n print(f\"Adding {requested_topping}.\")\n print(\"\\nFinished making your pizza!\")\nelse:\n    print(\"Are you sure you want a plain pizza?\")\n```", "```py\nAre you sure you want a plain pizza?\n```", "```py\navailable_toppings = ['mushrooms', 'olives', 'green peppers',\n                      'pepperoni', 'pineapple', 'extra cheese']\n\n❶ requested_toppings = ['mushrooms', 'french fries', 'extra cheese']\n\nfor requested_topping in requested_toppings:\n❷     if requested_topping in available_toppings:\n        print(f\"Adding {requested_topping}.\")\n❸     else:\n        print(f\"Sorry, we don't have {requested_topping}.\")\n\nprint(\"\\nFinished making your pizza!\")\n```", "```py\nAdding mushrooms.\nSorry, we don't have french fries.\nAdding extra cheese.\n\nFinished making your pizza!\n```", "```py\nif age < 4:\n```", "```py\nif age<4:\n```", "```py\nalien_0 = {'color': 'green', 'points': 5}\n\nprint(alien_0['color'])\nprint(alien_0['points'])\n```", "```py\ngreen\n5\n```", "```py\nalien_0 = {'color': 'green', 'points': 5}\n```", "```py\nalien_0 = {'color': 'green'}\n```", "```py\nalien_0 = {'color': 'green'}\nprint(alien_0['color'])\n```", "```py\ngreen\n```", "```py\nalien_0 = {'color': 'green', 'points': 5}\n```", "```py\nalien_0 = {'color': 'green', 'points': 5}\n\nnew_points = alien_0['points']\nprint(f\"You just earned {new_points} points!\")\n```", "```py\nYou just earned 5 points!\n```", "```py\nalien_0 = {'color': 'green', 'points': 5}\nprint(alien_0)\n\nalien_0['x_position'] = 0\nalien_0['y_position'] = 25\nprint(alien_0)\n```", "```py\n{'color': 'green', 'points': 5}\n{'color': 'green', 'points': 5, 'x_position': 0, 'y_position': 25}\n```", "```py\nalien_0 = {}\n\nalien_0['color'] = 'green'\nalien_0['points'] = 5\n\nprint(alien_0)\n```", "```py\n{'color': 'green', 'points': 5}\n```", "```py\nalien_0 = {'color': 'green'}\nprint(f\"The alien is {alien_0['color']}.\")\n\nalien_0['color'] = 'yellow'\nprint(f\"The alien is now {alien_0['color']}.\")\n```", "```py\nThe alien is green.\nThe alien is now yellow.\n```", "```py\nalien_0 = {'x_position': 0, 'y_position': 25, 'speed': 'medium'}\nprint(f\"Original position: {alien_0['x_position']}\")\n\n# Move the alien to the right.\n# Determine how far to move the alien based on its current speed.\n❶ if alien_0['speed'] == 'slow':\n    x_increment = 1\nelif alien_0['speed'] == 'medium':\n    x_increment = 2\nelse:\n    # This must be a fast alien.\n    x_increment = 3\n\n# The new position is the old position plus the increment.\n❷ alien_0['x_position'] = alien_0['x_position'] + x_increment\n\nprint(f\"New position: {alien_0['x_position']}\")\n```", "```py\nOriginal x-position: 0\nNew x-position: 2\n```", "```py\nalien_0['speed'] = 'fast'\n```", "```py\nalien_0 = {'color': 'green', 'points': 5}\nprint(alien_0)\n\n❶ del alien_0['points']\nprint(alien_0)\n```", "```py\n{'color': 'green', 'points': 5}\n{'color': 'green'}\n```", "```py\nfavorite_languages = {\n    'jen': 'python',\n    'sarah': 'c',\n    'edward': 'rust',\n    'phil': 'python',\n    }\n```", "```py\nfavorite_languages = {\n 'jen': 'python',\n 'sarah': 'c',\n 'edward': 'rust',\n 'phil': 'python',\n }\n\n❶ language = favorite_languages['sarah'].title()\nprint(f\"Sarah's favorite language is {language}.\")\n```", "```py\nfavorite_languages['sarah']\n```", "```py\nSarah's favorite language is C.\n```", "```py\nalien_0 = {'color': 'green', 'speed': 'slow'}\nprint(alien_0['points'])\n```", "```py\nTraceback (most recent call last):\n  File \"alien_no_points.py\", line 2, in <module>\n    print(alien_0['points'])\n          ~~~~~~~^^^^^^^^^^\nKeyError: 'points'\n```", "```py\nalien_0 = {'color': 'green', 'speed': 'slow'}\n\npoint_value = alien_0.get('points', 'No point value assigned.')\nprint(point_value)\n```", "```py\nNo point value assigned.\n```", "```py\nuser_0 = {\n    'username': 'efermi',\n    'first': 'enrico',\n    'last': 'fermi',\n    }\n```", "```py\nuser_0 = {\n 'username': 'efermi',\n 'first': 'enrico',\n 'last': 'fermi',\n }\n\nfor key, value in user_0.items():\n    print(f\"\\nKey: {key}\")\n    print(f\"Value: {value}\")\n```", "```py\nfor k, v in user_0.items()\n```", "```py\nKey: username\nValue: efermi\n\nKey: first\nValue: enrico\n\nKey: last\nValue: fermi\n```", "```py\nfavorite_languages = {\n 'jen': 'python',\n 'sarah': 'c',\n 'edward': 'rust',\n 'phil': 'python',\n }\n\nfor name, language in favorite_languages.items():\n    print(f\"{name.title()}'s favorite language is {language.title()}.\")\n```", "```py\nJen's favorite language is Python.\nSarah's favorite language is C.\nEdward's favorite language is Rust.\nPhil's favorite language is Python.\n```", "```py\nfavorite_languages = {\n 'jen': 'python',\n 'sarah': 'c',\n 'edward': 'rust',\n 'phil': 'python',\n }\n\nfor name in favorite_languages.keys():\n    print(name.title())\n```", "```py\nJen\nSarah\nEdward\nPhil\n```", "```py\nfor name in favorite_languages:\n```", "```py\nfor name in favorite_languages.keys():\n```", "```py\nfavorite_languages = {\n    *--snip--*\n }\n\nfriends = ['phil', 'sarah']\nfor name in favorite_languages.keys():\n    print(f\"Hi {name.title()}.\")\n\n❶     if name in friends:\n❷         language = favorite_languages[name].title()\n        print(f\"\\t{name.title()}, I see you love {language}!\")\n```", "```py\nHi Jen.\nHi Sarah.\n    Sarah, I see you love C!\nHi Edward.\nHi Phil.\n    Phil, I see you love Python!\n```", "```py\nfavorite_languages = {\n *--snip--*\n }\n\nif 'erin' not in favorite_languages.keys():\n    print(\"Erin, please take our poll!\")\n```", "```py\nErin, please take our poll!\n```", "```py\nfavorite_languages = {\n 'jen': 'python',\n 'sarah': 'c',\n 'edward': 'rust',\n 'phil': 'python',\n }\n\nfor name in sorted(favorite_languages.keys()):\n    print(f\"{name.title()}, thank you for taking the poll.\")\n```", "```py\nEdward, thank you for taking the poll.\nJen, thank you for taking the poll.\nPhil, thank you for taking the poll.\nSarah, thank you for taking the poll.\n```", "```py\nfavorite_languages = {\n 'jen': 'python',\n 'sarah': 'c',\n 'edward': 'rust',\n 'phil': 'python',\n }\n\nprint(\"The following languages have been mentioned:\")\nfor language in favorite_languages.values():\n    print(language.title())\n```", "```py\nThe following languages have been mentioned:\nPython\nC\nRust\nPython\n```", "```py\nfavorite_languages = {\n *--snip--*\n }\n\nprint(\"The following languages have been mentioned:\")\nfor language in set(favorite_languages.values()):\n print(language.title())\n```", "```py\nThe following languages have been mentioned:\nPython\nC\nRust\n```", "```py\nalien_0 = {'color': 'green', 'points': 5}\nalien_1 = {'color': 'yellow', 'points': 10}\nalien_2 = {'color': 'red', 'points': 15}\n\n❶ aliens = [alien_0, alien_1, alien_2]\n\nfor alien in aliens:\n    print(alien)\n```", "```py\n{'color': 'green', 'points': 5}\n{'color': 'yellow', 'points': 10}\n{'color': 'red', 'points': 15}\n```", "```py\n# Make an empty list for storing aliens.\naliens = []\n\n# Make 30 green aliens.\n❶ for alien_number in range(30):\n❷     new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}\n❸     aliens.append(new_alien)\n\n# Show the first 5 aliens.\n❹ for alien in aliens[:5]:\n    print(alien)\nprint(\"...\")\n\n# Show how many aliens have been created.\nprint(f\"Total number of aliens: {len(aliens)}\")\n```", "```py\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n...\n\nTotal number of aliens: 30\n```", "```py\n# Make an empty list for storing aliens.\naliens = []\n\n# Make 30 green aliens.\nfor alien_number in range (30):\n new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}\n aliens.append(new_alien)\n\nfor alien in aliens[:3]:\n    if alien['color'] == 'green':\n        alien['color'] = 'yellow'\n        alien['speed'] = 'medium'\n        alien['points'] = 10\n\n# Show the first 5 aliens.\nfor alien in aliens[:5]:\n print(alien)\nprint(\"...\")\n```", "```py\n{'color': 'yellow', 'points': 10, 'speed': 'medium'}\n{'color': 'yellow', 'points': 10, 'speed': 'medium'}\n{'color': 'yellow', 'points': 10, 'speed': 'medium'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n{'color': 'green', 'points': 5, 'speed': 'slow'}\n...\n```", "```py\nfor alien in aliens[0:3]:\n if alien['color'] == 'green':\n alien['color'] = 'yellow'\n alien['speed'] = 'medium'\n alien['points'] = 10\n    elif alien['color'] == 'yellow':\n        alien['color'] = 'red'\n        alien['speed'] = 'fast'\n        alien['points'] = 15\n```", "```py\n# Store information about a pizza being ordered.\npizza = {\n    'crust': 'thick',\n    'toppings': ['mushrooms', 'extra cheese'],\n    }\n\n# Summarize the order.\n❶ print(f\"You ordered a {pizza['crust']}-crust pizza \"\n    \"with the following toppings:\")\n\n❷ for topping in pizza['toppings']:\n    print(f\"\\t{topping}\")\n```", "```py\nYou ordered a thick-crust pizza with the following toppings:\n    mushrooms\n    extra cheese\n```", "```py\nfavorite_languages = {\n 'jen': ['python', 'rust'],\n 'sarah': ['c'],\n    'edward': ['rust', 'go'],\n    'phil': ['python', 'haskell'],\n    }\n\n❶ for name, languages in favorite_languages.items():\n    print(f\"\\n{name.title()}'s favorite languages are:\")\n❷     for language in languages:\n        print(f\"\\t{language.title()}\")\n```", "```py\nJen's favorite languages are:\n    Python\n    Rust\n\nSarah's favorite languages are:\n    C\n\nEdward's favorite languages are:\n    Rust\n    Go\n\nPhil's favorite languages are:\n    Python\n    Haskell\n```", "```py\nusers = {\n    'aeinstein': {\n        'first': 'albert',\n        'last': 'einstein',\n        'location': 'princeton',\n        },\n\n    'mcurie': {\n        'first': 'marie',\n        'last': 'curie',\n        'location': 'paris',\n        },\n\n    }\n\n❶ for username, user_info in users.items():\n❷     print(f\"\\nUsername: {username}\")\n❸     full_name = f\"{user_info['first']} {user_info['last']}\"\n    location = user_info['location']\n\n❹     print(f\"\\tFull name: {full_name.title()}\")\n    print(f\"\\tLocation: {location.title()}\")\n```", "```py\nUsername: aeinstein\n    Full name: Albert Einstein\n    Location: Princeton\n\nUsername: mcurie\n    Full name: Marie Curie\n    Location: Paris\n```", "```py\nmessage = input(\"Tell me something, and I will repeat it back to you: \")\nprint(message)\n```", "```py\nTell me something, and I will repeat it back to you: **Hello everyone!**\nHello everyone!\n```", "```py\nname = input(\"Please enter your name: \")\nprint(f\"\\nHello, {name}!\")\n```", "```py\nPlease enter your name: **Eric**\nHello, Eric!\n```", "```py\nprompt = \"If you share your name, we can personalize the messages you see.\"\nprompt += \"\\nWhat is your first name? \"\n\nname = input(prompt)\nprint(f\"\\nHello, {name}!\")\n```", "```py\nIf you share your name, we can personalize the messages you see.\nWhat is your first name? **Eric**\n\nHello, Eric!\n```", "```py\n>>> **age = input(\"How old are you? \")**\nHow old are you? **21**\n>>> **age**\n'21'\n```", "```py\n>>> **age = input(\"How old are you? \")**\nHow old are you? **21**\n❶ >>> **age >= 18**\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n❷ TypeError: '>=' not supported between instances of 'str' and 'int'\n```", "```py\n>>> **age = input(\"How old are you? \")**\nHow old are you? **21**\n❶ >>> **age = int(age)**\n>>> **age >= 18**\nTrue\n```", "```py\nheight = input(\"How tall are you, in inches? \")\nheight = int(height)\n\nif height >= 48:\n    print(\"\\nYou're tall enough to ride!\")\nelse:\n    print(\"\\nYou'll be able to ride when you're a little older.\")\n```", "```py\nHow tall are you, in inches? **71**\n\nYou're tall enough to ride!\n```", "```py\n>>> **4 % 3**\n1\n>>> **5 % 3**\n2\n>>> **6 % 3**\n0\n>>> **7 % 3**\n1\n```", "```py\nnumber = input(\"Enter a number, and I'll tell you if it's even or odd: \")\nnumber = int(number)\n\nif number % 2 == 0:\n    print(f\"\\nThe number {number} is even.\")\nelse:\n    print(f\"\\nThe number {number} is odd.\")\n```", "```py\nEnter a number, and I'll tell you if it's even or odd: **42**\n\nThe number 42 is even.\n```", "```py\ncurrent_number = 1\nwhile current_number <= 5:\n print(current_number)\n    current_number += 1\n```", "```py\n1\n2\n3\n4\n5\n```", "```py\nprompt = \"\\nTell me something, and I will repeat it back to you:\"\nprompt += \"\\nEnter 'quit' to end the program. \"\n\nmessage = \"\"\nwhile message != 'quit':\n    message = input(prompt)\n    print(message)\n```", "```py\nTell me something, and I will repeat it back to you:\nEnter 'quit' to end the program. **Hello everyone!**\nHello everyone!\n\nTell me something, and I will repeat it back to you:\nEnter 'quit' to end the program. **Hello again.**\nHello again.\n\nTell me something, and I will repeat it back to you:\nEnter 'quit' to end the program. **quit**\nquit\n```", "```py\nprompt = \"\\nTell me something, and I will repeat it back to you:\"\nprompt += \"\\nEnter 'quit' to end the program. \"\n\nmessage = \"\"\nwhile message != 'quit':\n message = input(prompt)\n\n    if message != 'quit':\n        print(message)\n```", "```py\nTell me something, and I will repeat it back to you:\nEnter 'quit' to end the program. **Hello everyone!**\nHello everyone!\n\nTell me something, and I will repeat it back to you:\nEnter 'quit' to end the program. **Hello again.**\nHello again.\n\nTell me something, and I will repeat it back to you:\nEnter 'quit' to end the program. **quit**\n```", "```py\nprompt = \"\\nTell me something, and I will repeat it back to you:\"\nprompt += \"\\nEnter 'quit' to end the program. \"\n\nactive = True\n❶ while active:\n    message = input(prompt)\n\n    if message == 'quit':\n        active = False\n    else:\n        print(message)\n```", "```py\nprompt = \"\\nPlease enter the name of a city you have visited:\"\nprompt += \"\\n(Enter 'quit' when you are finished.) \"\n\n❶ while True:\n    city = input(prompt)\n\n    if city == 'quit':\n        break\n    else:\n        print(f\"I'd love to go to {city.title()}!\")\n```", "```py\nPlease enter the name of a city you have visited:\n(Enter 'quit' when you are finished.) **New York**\nI'd love to go to New York!\n\nPlease enter the name of a city you have visited:\n(Enter 'quit' when you are finished.) **San Francisco**\nI'd love to go to San Francisco!\n\nPlease enter the name of a city you have visited:\n(Enter 'quit' when you are finished.) **quit**\n```", "```py\ncurrent_number = 0\nwhile current_number < 10:\n❶     current_number += 1\n    if current_number % 2 == 0:\n        continue\n\n    print(current_number)\n```", "```py\n1\n3\n5\n7\n9\n```", "```py\nx = 1\nwhile x <= 5:\n    print(x)\n    x += 1\n```", "```py\n# This loop runs forever!\nx = 1\nwhile x <= 5:\n    print(x)\n```", "```py\n1\n1\n1\n1\n`--snip--`\n```", "```py\n# Start with users that need to be verified,\n#  and an empty list to hold confirmed users.\n❶ unconfirmed_users = ['alice', 'brian', 'candace']\nconfirmed_users = []\n\n# Verify each user until there are no more unconfirmed users.\n#  Move each verified user into the list of confirmed users.\n❷ while unconfirmed_users:\n❸     current_user = unconfirmed_users.pop()\n\n    print(f\"Verifying user: {current_user.title()}\")\n❹     confirmed_users.append(current_user)\n\n# Display all confirmed users.\nprint(\"\\nThe following users have been confirmed:\")\nfor confirmed_user in confirmed_users:\n    print(confirmed_user.title())\n```", "```py\nVerifying user: Candace\nVerifying user: Brian\nVerifying user: Alice\n\nThe following users have been confirmed:\nCandace\nBrian\nAlice\n```", "```py\npets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']\nprint(pets)\n\nwhile 'cat' in pets:\n    pets.remove('cat')\n\nprint(pets)\n```", "```py\n['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']\n['dog', 'dog', 'goldfish', 'rabbit']\n```", "```py\nresponses = {}\n# Set a flag to indicate that polling is active.\npolling_active = True\n\nwhile polling_active:\n    # Prompt for the person's name and response.\n❶     name = input(\"\\nWhat is your name? \")\n    response = input(\"Which mountain would you like to climb someday? \")\n\n    # Store the response in the dictionary.\n❷     responses[name] = response\n\n    # Find out if anyone else is going to take the poll.\n❸     repeat = input(\"Would you like to let another person respond? (yes/ no) \")\n    if repeat == 'no':\n        polling_active = False\n\n# Polling is complete. Show the results.\nprint(\"\\n--- Poll Results ---\")\n❹ for name, response in responses.items():\n    print(f\"{name} would like to climb {response}.\")\n```", "```py\nWhat is your name? **Eric**\nWhich mountain would you like to climb someday? **Denali**\nWould you like to let another person respond? (yes/ no) **yes**\n\nWhat is your name? **Lynn**\nWhich mountain would you like to climb someday? **Devil's Thumb**\nWould you like to let another person respond? (yes/ no) **no**\n\n--- Poll Results ---\nEric would like to climb Denali.\nLynn would like to climb Devil's Thumb.\n```", "```py\ndef greet_user():\n    \"\"\"Display a simple greeting.\"\"\"\n    print(\"Hello!\")\n\ngreet_user()\n```", "```py\nHello!\n```", "```py\ndef greet_user(username):\n    \"\"\"Display a simple greeting.\"\"\"\n    print(f\"Hello, {username.title()}!\")\n\ngreet_user('jesse')\n```", "```py\nHello, Jesse!\n```", "```py\n❶ def describe_pet(animal_type, pet_name):\n    \"\"\"Display information about a pet.\"\"\"\n    print(f\"\\nI have a {animal_type}.\")\n    print(f\"My {animal_type}'s name is {pet_name.title()}.\")\n\n❷ describe_pet('hamster', 'harry')\n```", "```py\nI have a hamster.\nMy hamster's name is Harry.\n```", "```py\ndef describe_pet(animal_type, pet_name):\n \"\"\"Display information about a pet.\"\"\"\n print(f\"\\nI have a {animal_type}.\")\n print(f\"My {animal_type}'s name is {pet_name.title()}.\")\n\ndescribe_pet('hamster', 'harry')\ndescribe_pet('dog', 'willie')\n```", "```py\nI have a hamster.\nMy hamster's name is Harry.\n\nI have a dog.\nMy dog's name is Willie.\n```", "```py\ndef describe_pet(animal_type, pet_name):\n \"\"\"Display information about a pet.\"\"\"\n print(f\"\\nI have a {animal_type}.\")\n print(f\"My {animal_type}'s name is {pet_name.title()}.\")\n\ndescribe_pet('harry', 'hamster')\n```", "```py\nI have a harry.\nMy harry's name is Hamster.\n```", "```py\ndef describe_pet(animal_type, pet_name):\n \"\"\"Display information about a pet.\"\"\"\n print(f\"\\nI have a {animal_type}.\")\n print(f\"My {animal_type}'s name is {pet_name.title()}.\")\n\ndescribe_pet(animal_type='hamster', pet_name='harry')\n```", "```py\ndescribe_pet(animal_type='hamster', pet_name='harry')\ndescribe_pet(pet_name='harry', animal_type='hamster')\n```", "```py\ndef describe_pet(pet_name, animal_type='dog'):\n    \"\"\"Display information about a pet.\"\"\"\n print(f\"\\nI have a {animal_type}.\")\n print(f\"My {animal_type}'s name is {pet_name.title()}.\")\n\ndescribe_pet(pet_name='willie')\n```", "```py\nI have a dog.\nMy dog's name is Willie.\n```", "```py\ndescribe_pet('willie')\n```", "```py\ndescribe_pet(pet_name='harry', animal_type='hamster')\n```", "```py\ndef describe_pet(pet_name, animal_type='dog'):\n```", "```py\n# A dog named Willie.\ndescribe_pet('willie')\ndescribe_pet(pet_name='willie')\n\n# A hamster named Harry.\ndescribe_pet('harry', 'hamster')\ndescribe_pet(pet_name='harry', animal_type='hamster')\ndescribe_pet(animal_type='hamster', pet_name='harry')\n```", "```py\ndef describe_pet(animal_type, pet_name):\n \"\"\"Display information about a pet.\"\"\"\n print(f\"\\nI have a {animal_type}.\")\n print(f\"My {animal_type}'s name is {pet_name.title()}.\")\n\ndescribe_pet()\n```", "```py\nTraceback (most recent call last):\n❶   File \"pets.py\", line 6, in <module>\n❷     describe_pet()\n    ^^^^^^^^^^^^^^\n❸ TypeError: describe_pet() missing 2 required positional arguments: \n    'animal_type' and 'pet_name'\n```", "```py\ndef get_formatted_name(first_name, last_name):\n    \"\"\"Return a full name, neatly formatted.\"\"\"\n❶     full_name = f\"{first_name} {last_name}\"\n❷     return full_name.title()\n\n❸ musician = get_formatted_name('jimi', 'hendrix')\nprint(musician)\n```", "```py\nJimi Hendrix\n```", "```py\nprint(\"Jimi Hendrix\")\n```", "```py\ndef get_formatted_name(first_name, middle_name, last_name):\n    \"\"\"Return a full name, neatly formatted.\"\"\"\n    full_name = f\"{first_name} {middle_name} {last_name}\"\n    return full_name.title()\n\nmusician = get_formatted_name('john', 'lee', 'hooker')\nprint(musician)\n```", "```py\nJohn Lee Hooker\n```", "```py\ndef get_formatted_name(first_name, last_name, middle_name=''):\n    \"\"\"Return a full name, neatly formatted.\"\"\"\n❶     if middle_name:\n        full_name = f\"{first_name} {middle_name} {last_name}\"\n❷     else:\n        full_name = f\"{first_name} {last_name}\"\n    return full_name.title()\n\nmusician = get_formatted_name('jimi', 'hendrix')\nprint(musician)\n\n❸ musician = get_formatted_name('john', 'hooker', 'lee')\nprint(musician)\n```", "```py\nJimi Hendrix\nJohn Lee Hooker\n```", "```py\ndef build_person(first_name, last_name):\n    \"\"\"Return a dictionary of information about a person.\"\"\"\n❶     person = {'first': first_name, 'last': last_name}\n❷     return person\n\nmusician = build_person('jimi', 'hendrix')\n❸ print(musician)\n```", "```py\n{'first': 'jimi', 'last': 'hendrix'}\n```", "```py\ndef build_person(first_name, last_name, age=None):\n \"\"\"Return a dictionary of information about a person.\"\"\"\n person = {'first': first_name, 'last': last_name}\n    if age:\n        person['age'] = age\n return person\n\nmusician = build_person('jimi', 'hendrix', age=27)\nprint(musician)\n```", "```py\ndef get_formatted_name(first_name, last_name):\n \"\"\"Return a full name, neatly formatted.\"\"\"\n full_name = f\"{first_name} {last_name}\"\n return full_name.title()\n\n# This is an infinite loop!\nwhile True:\n❶     print(\"\\nPlease tell me your name:\")\n    f_name = input(\"First name: \")\n    l_name = input(\"Last name: \")\n\n    formatted_name = get_formatted_name(f_name, l_name)\n    print(f\"\\nHello, {formatted_name}!\")\n```", "```py\ndef get_formatted_name(first_name, last_name):\n \"\"\"Return a full name, neatly formatted.\"\"\"\n full_name = f\"{first_name} {last_name}\"\n return full_name.title()\n\nwhile True:\n print(\"\\nPlease tell me your name:\")\n  print(\"(enter 'q' at any time to quit)\")\n\n f_name = input(\"First name: \")\n  if f_name == 'q':\n        break\n\n l_name = input(\"Last name: \")\n  if l_name == 'q':\n        break\n\n formatted_name = get_formatted_name(f_name, l_name)\n print(f\"\\nHello, {formatted_name}!\")\n```", "```py\nPlease tell me your name:\n(enter 'q' at any time to quit)\nFirst name: **eric**\nLast name: **matthes**\n\nHello, Eric Matthes!\n\nPlease tell me your name:\n(enter 'q' at any time to quit)\nFirst name: **q**\n```", "```py\ndef greet_users(names):\n    \"\"\"Print a simple greeting to each user in the list.\"\"\"\n    for name in names:\n        msg = f\"Hello, {name.title()}!\"\n        print(msg)\n\nusernames = ['hannah', 'ty', 'margot']\ngreet_users(usernames)\n```", "```py\nHello, Hannah!\nHello, Ty!\nHello, Margot!\n```", "```py\n# Start with some designs that need to be printed.\nunprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']\ncompleted_models = []\n\n# Simulate printing each design, until none are left.\n#  Move each design to completed_models after printing.\nwhile unprinted_designs:\n    current_design = unprinted_designs.pop()\n    print(f\"Printing model: {current_design}\")\n    completed_models.append(current_design)\n\n# Display all completed models.\nprint(\"\\nThe following models have been printed:\")\nfor completed_model in completed_models:\n    print(completed_model)\n```", "```py\nPrinting model: dodecahedron\nPrinting model: robot pendant\nPrinting model: phone case\n\nThe following models have been printed:\ndodecahedron\nrobot pendant\nphone case\n```", "```py\n❶ def print_models(unprinted_designs, completed_models):\n    \"\"\"\n    Simulate printing each design, until none are left.\n Move each design to completed_models after printing.\n    \"\"\"\n    while unprinted_designs:\n        current_design = unprinted_designs.pop()\n        print(f\"Printing model: {current_design}\")\n        completed_models.append(current_design)\n\n❷ def show_completed_models(completed_models):\n    \"\"\"Show all the models that were printed.\"\"\"\n    print(\"\\nThe following models have been printed:\")\n    for completed_model in completed_models:\n        print(completed_model)\n\nunprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']\ncompleted_models = []\n\nprint_models(unprinted_designs, completed_models)\nshow_completed_models(completed_models)\n```", "```py\nunprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']\ncompleted_models = []\n\nprint_models(unprinted_designs, completed_models)\nshow_completed_models(completed_models)\n```", "```py`This example also demonstrates the idea that every function should have one specific job. The first function prints each design, and the second displays the completed models. This is more beneficial than using one function to do both jobs. If you’re writing a function and notice the function is doing too many different tasks, try to split the code into two functions. Remember that you can always call a function from another function, which can be helpful when splitting a complex task into a series of steps.    ### Preventing a Function from Modifying a List    Sometimes you’ll want to prevent a function from modifying a list. For example, say that you start with a list of unprinted designs and write a function to move them to a list of completed models, as in the previous example. You may decide that even though you’ve printed all the designs, you want to keep the original list of unprinted designs for your records. But because you moved all the design names out of `unprinted_designs`, the list is now empty, and the empty list is the only version you have; the original is gone. In this case, you can address this issue by passing the function a copy of the list, not the original. Any changes the function makes to the list will affect only the copy, leaving the original list intact.    You can send a copy of a list to a function like this:    ```", "```py    The slice notation `[:]` makes a copy of the list to send to the function. If we didn’t want to empty the list of unprinted designs in *printing_models.py*, we could call `print_models()` like this:    ```", "```py    The function `print_models()` can do its work because it still receives the names of all unprinted designs. But this time it uses a copy of the original unprinted designs list, not the actual `unprinted_designs` list. The list `completed_models` will fill up with the names of printed models like it did before, but the original list of unprinted designs will be unaffected by the function.    Even though you can preserve the contents of a list by passing a copy of it to your functions, you should pass the original list to functions unless you have a specific reason to pass a copy. It’s more efficient for a function to work with an existing list, because this avoids using the time and memory needed to make a separate copy. This is especially true when working with large lists.    ## Passing an Arbitrary Number of Arguments    Sometimes you won’t know ahead of time how many arguments a function needs to accept. Fortunately, Python allows a function to collect an arbitrary number of arguments from the calling statement.    For example, consider a function that builds a pizza. It needs to accept a number of toppings, but you can’t know ahead of time how many toppings a person will want. The function in the following example has one parameter, `*toppings`, but this parameter collects as many arguments as the calling line provides:    **pizza.py**    ```", "```py    The asterisk in the parameter name `*toppings` tells Python to make a tuple called `toppings`, containing all the values this function receives. The `print()` call in the function body produces output showing that Python can handle a function call with one value and a call with three values. It treats the different calls similarly. Note that Python packs the arguments into a tuple, even if the function receives only one value:    ```", "```py    Now we can replace the `print()` call with a loop that runs through the list of toppings and describes the pizza being ordered:    ```", "```py    The function responds appropriately, whether it receives one value or three values:    ```", "```py    This syntax works no matter how many arguments the function receives.    ### Mixing Positional and Arbitrary Arguments    If you want a function to accept several different kinds of arguments, the parameter that accepts an arbitrary number of arguments must be placed last in the function definition. Python matches positional and keyword arguments first and then collects any remaining arguments in the final parameter.    For example, if the function needs to take in a size for the pizza, that parameter must come before the parameter `*toppings`:    ```", "```py    In the function definition, Python assigns the first value it receives to the parameter `size`. All other values that come after are stored in the tuple `toppings`. The function calls include an argument for the size first, followed by as many toppings as needed.    Now each pizza has a size and a number of toppings, and each piece of information is printed in the proper place, showing size first and toppings after:    ```", "```py    ### Using Arbitrary Keyword Arguments    Sometimes you’ll want to accept an arbitrary number of arguments, but you won’t know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you’ll get information about a user, but you’re not sure what kind of information you’ll receive. The function `build_profile()` in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well:    **user_profile.py**    ```", "```py    The definition of `build_profile()` expects a first and last name, and then it allows the user to pass in as many name-value pairs as they want. The double asterisks before the parameter `**user_info` cause Python to create a dictionary called `user_info` containing all the extra name-value pairs the function receives. Within the function, you can access the key-value pairs in `user_info` just as you would for any dictionary.    In the body of `build_profile()`, we add the first and last names to the `user_info` dictionary because we’ll always receive these two pieces of information from the user ❶, and they haven’t been placed into the dictionary yet. Then we return the `user_info` dictionary to the function call line.    We call `build_profile()`, passing it the first name `'albert'`, the last name `'einstein'`, and the two key-value pairs `location='princeton'` and `field='physics'`. We assign the returned `profile` to `user_profile` and print `user_profile`:    ```", "```py    The returned dictionary contains the user’s first and last names and, in this case, the location and field of study as well. The function will work no matter how many additional key-value pairs are provided in the function call.    You can mix positional, keyword, and arbitrary values in many different ways when writing your own functions. It’s useful to know that all these argument types exist because you’ll see them often when you start reading other people’s code. It takes practice to use the different types correctly and to know when to use each type. For now, remember to use the simplest approach that gets the job done. As you progress, you’ll learn to use the most efficient approach each time.    ## Storing Your Functions in Modules    One advantage of functions is the way they separate blocks of code from your main program. When you use descriptive names for your functions, your programs become much easier to follow. You can go a step further by storing your functions in a separate file called a *module* and then *importing* that module into your main program. An `import` statement tells Python to make the code in a module available in the currently running program file.    Storing your functions in a separate file allows you to hide the details of your program’s code and focus on its higher-level logic. It also allows you to reuse functions in many different programs. When you store your functions in separate files, you can share those files with other programmers without having to share your entire program. Knowing how to import functions also allows you to use libraries of functions that other programmers have written.    There are several ways to import a module, and I’ll show you each of these briefly.    ### Importing an Entire Module    To start importing functions, we first need to create a module. A *module* is a file ending in *.py* that contains the code you want to import into your program. Let’s make a module that contains the function `make_pizza()`. To make this module, we’ll remove everything from the file *pizza.py* except the function `make_pizza()`:    **pizza.py**    ```", "```py    Now we’ll make a separate file called *making_pizzas.py* in the same directory as *pizza.py*. This file imports the module we just created and then makes two calls to `make_pizza()`:    **making_pizzas.py**    ```", "```py    When Python reads this file, the line `import pizza` tells Python to open the file *pizza.py* and copy all the functions from it into this program. You don’t actually see code being copied between files because Python copies the code behind the scenes, just before the program runs. All you need to know is that any function defined in *pizza.py* will now be available in *making_pizzas.py*.    To call a function from an imported module, enter the name of the module you imported, `pizza`, followed by the name of the function, `make_pizza()`, separated by a dot ❶. This code produces the same output as the original program that didn’t import a module:    ```", "```py    This first approach to importing, in which you simply write `import` followed by the name of the module, makes every function from the module available in your program. If you use this kind of `import` statement to import an entire module named *module_name.py*, each function in the module is available through the following syntax:    ```", "```py    ### Importing Specific Functions    You can also import a specific function from a module. Here’s the general syntax for this approach:    ```", "```py    You can import as many functions as you want from a module by separating each function’s name with a comma:    ```", "```py    The *making_pizzas.py* example would look like this if we want to import just the function we’re going to use:    ```", "```py    With this syntax, you don’t need to use the dot notation when you call a function. Because we’ve explicitly imported the function `make_pizza()` in the `import` statement, we can call it by name when we use the function.    ### Using as to Give a Function an Alias    If the name of a function you’re importing might conflict with an existing name in your program, or if the function name is long, you can use a short, unique *alias*—an alternate name similar to a nickname for the function. You’ll give the function this special nickname when you import the function.    Here we give the function `make_pizza()` an alias, `mp()`, by importing `make_pizza as mp`. The `as` keyword renames a function using the alias you provide:    ```", "```py    The `import` statement shown here renames the function `make_pizza()` to `mp()` in this program. Anytime we want to call `make_pizza()` we can simply write `mp()` instead, and Python will run the code in `make_pizza()` while avoiding any confusion with another `make_pizza()` function you might have written in this program file.    The general syntax for providing an alias is:    ```", "```py    ### Using as to Give a Module an Alias    You can also provide an alias for a module name. Giving a module a short alias, like `p` for `pizza`, allows you to call the module’s functions more quickly. Calling `p.make_pizza()` is more concise than calling `pizza.make_pizza()`:    ```", "```py    The module `pizza` is given the alias `p` in the `import` statement, but all of the module’s functions retain their original names. Calling the functions by writing `p.make_pizza()` is not only more concise than `pizza.make_pizza()`, but it also redirects your attention from the module name and allows you to focus on the descriptive names of its functions. These function names, which clearly tell you what each function does, are more important to the readability of your code than using the full module name.    The general syntax for this approach is:    ```", "```py    ### Importing All Functions in a Module    You can tell Python to import every function in a module by using the asterisk (`*`) operator:    ```", "```py    The asterisk in the `import` statement tells Python to copy every function from the module `pizza` into this program file. Because every function is imported, you can call each function by name without using the dot notation. However, it’s best not to use this approach when you’re working with larger modules that you didn’t write: if the module has a function name that matches an existing name in your project, you can get unexpected results. Python may see several functions or variables with the same name, and instead of importing all the functions separately, it will overwrite the functions.    The best approach is to import the function or functions you want, or import the entire module and use the dot notation. This leads to clear code that’s easy to read and understand. I include this section so you’ll recognize `import` statements like the following when you see them in other people’s code:    ```", "```py    ## Styling Functions    You need to keep a few details in mind when you’re styling functions. Functions should have descriptive names, and these names should use lowercase letters and underscores. Descriptive names help you and others understand what your code is trying to do. Module names should use these conventions as well.    Every function should have a comment that explains concisely what the function does. This comment should appear immediately after the function definition and use the docstring format. In a well-documented function, other programmers can use the function by reading only the description in the docstring. They should be able to trust that the code works as described, and as long as they know the name of the function, the arguments it needs, and the kind of value it returns, they should be able to use it in their programs.    If you specify a default value for a parameter, no spaces should be used on either side of the equal sign:    ```", "```py    The same convention should be used for keyword arguments in function calls:    ```", "```py    PEP 8 ([https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008)) recommends that you limit lines of code to 79 characters so every line is visible in a reasonably sized editor window. If a set of parameters causes a function’s definition to be longer than 79 characters, press ENTER after the opening parenthesis on the definition line. On the next line, press the TAB key twice to separate the list of arguments from the body of the function, which will only be indented one level.    Most editors automatically line up any additional lines of arguments to match the indentation you have established on the first line:    ```", "```py    If your program or module has more than one function, you can separate each by two blank lines to make it easier to see where one function ends and the next one begins.    All `import` statements should be written at the beginning of a file. The only exception is if you use comments at the beginning of your file to describe the overall program.    ## Summary    In this chapter, you learned how to write functions and to pass arguments so that your functions have access to the information they need to do their work. You learned how to use positional and keyword arguments, and also how to accept an arbitrary number of arguments. You saw functions that display output and functions that return values. You learned how to use functions with lists, dictionaries, `if` statements, and `while` loops. You also saw how to store your functions in separate files called *modules*, so your program files will be simpler and easier to understand. Finally, you learned to style your functions so your programs will continue to be well-structured and as easy as possible for you and others to read.    One of your goals as a programmer should be to write simple code that does what you want it to, and functions help you do this. They allow you to write blocks of code and leave them alone once you know they work. When you know a function does its job correctly, you can trust that it will continue to work and move on to your next coding task.    Functions allow you to write code once and then reuse that code as many times as you want. When you need to run the code in a function, all you need to do is write a one-line call and the function does its job. When you need to modify a function’s behavior, you only have to modify one block of code, and your change takes effect everywhere you’ve made a call to that function.    Using functions makes your programs easier to read, and good function names summarize what each part of a program does. Reading a series of function calls gives you a much quicker sense of what a program does than reading a long series of code blocks.    Functions also make your code easier to test and debug. When the bulk of your program’s work is done by a set of functions, each of which has a specific job, it’s much easier to test and maintain the code you’ve written. You can write a separate program that calls each function and tests whether each function works in all the situations it may encounter. When you do this, you can be confident that your functions will work properly each time you call them.    In Chapter 9, you’ll learn to write classes. *Classes* combine functions and data into one neat package that can be used in flexible and efficient ways.```", "```py`# 9 Classes  ![](Images/chapterart.png)  *Object-oriented programming (OOP**)* is one of the most effective approaches to writing software. In object-oriented programming, you write *classes* that represent real-world things and situations, and you create *objects* based on these classes. When you write a class, you define the general behavior that a whole category of objects can have.    When you create individual objects from the class, each object is automatically equipped with the general behavior; you can then give each object whatever unique traits you desire. You’ll be amazed how well real-world situations can be modeled with object-oriented programming.    Making an object from a class is called *instantiation*, and you work with *instances* of a class. In this chapter you’ll write classes and create instances of those classes. You’ll specify the kind of information that can be stored in instances, and you’ll define actions that can be taken with these instances. You’ll also write classes that extend the functionality of existing classes, so similar classes can share common functionality, and you can do more with less code. You’ll store your classes in modules and import classes written by other programmers into your own program files.    Learning about object-oriented programming will help you see the world as a programmer does. It’ll help you understand your code—not just what’s happening line by line, but also the bigger concepts behind it. Knowing the logic behind classes will train you to think logically, so you can write programs that effectively address almost any problem you encounter.    Classes also make life easier for you and the other programmers you’ll work with as you take on increasingly complex challenges. When you and other programmers write code based on the same kind of logic, you’ll be able to understand each other’s work. Your programs will make sense to the people you work with, allowing everyone to accomplish more.    ## Creating and Using a Class    You can model almost anything using classes. Let’s start by writing a simple class, `Dog`, that represents a dog—not one dog in particular, but any dog. What do we know about most pet dogs? Well, they all have a name and an age. We also know that most dogs sit and roll over. Those two pieces of information (name and age) and those two behaviors (sit and roll over) will go in our `Dog` class because they’re common to most dogs. This class will tell Python how to make an object representing a dog. After our class is written, we’ll use it to make individual instances, each of which represents one specific dog.    ### Creating the Dog Class    Each instance created from the `Dog` class will store a `name` and an `age`, and we’ll give each dog the ability to `sit()` and `roll_over()`:    **dog.py**    ```", "```py    There’s a lot to notice here, but don’t worry. You’ll see this structure throughout this chapter and have lots of time to get used to it. We first define a class called `Dog` ❶. By convention, capitalized names refer to classes in Python. There are no parentheses in the class definition because we’re creating this class from scratch. We then write a docstring describing what this class does.    ### The __init__() Method    A function that’s part of a class is a *method*. Everything you learned about functions applies to methods as well; the only practical difference for now is the way we’ll call methods. The `__init__()` method ❷ is a special method that Python runs automatically whenever we create a new instance based on the `Dog` class. This method has two leading underscores and two trailing underscores, a convention that helps prevent Python’s default method names from conflicting with your method names. Make sure to use two underscores on each side of `__init__()`. If you use just one on each side, the method won’t be called automatically when you use your class, which can result in errors that are difficult to identify.    We define the `__init__()` method to have three parameters: `self`, `name`, and `age`. The `self` parameter is required in the method definition, and it must come first, before the other parameters. It must be included in the definition because when Python calls this method later (to create an instance of `Dog`), the method call will automatically pass the `self` argument. Every method call associated with an instance automatically passes `self`, which is a reference to the instance itself; it gives the individual instance access to the attributes and methods in the class. When we make an instance of `Dog`, Python will call the `__init__()` method from the `Dog` class. We’ll pass `Dog()` a name and an age as arguments; `self` is passed automatically, so we don’t need to pass it. Whenever we want to make an instance from the `Dog` class, we’ll provide values for only the last two parameters, `name` and `age`.    The two variables defined in the body of the `__init__()` method each have the prefix `self` ❸. Any variable prefixed with `self` is available to every method in the class, and we’ll also be able to access these variables through any instance created from the class. The line `self.name = name` takes the value associated with the parameter `name` and assigns it to the variable `name`, which is then attached to the instance being created. The same process happens with `self.age = age`. Variables that are accessible through instances like this are called *attributes*.    The `Dog` class has two other methods defined: `sit()` and `roll_over()` ❹. Because these methods don’t need additional information to run, we just define them to have one parameter, `self`. The instances we create later will have access to these methods. In other words, they’ll be able to sit and roll over. For now, `sit()` and `roll_over()` don’t do much. They simply print a message saying the dog is sitting or rolling over. But the concept can be extended to realistic situations: if this class were part of a computer game, these methods would contain code to make an animated dog sit and roll over. If this class was written to control a robot, these methods would direct movements that cause a robotic dog to sit and roll over.    ### Making an Instance from a Class    Think of a class as a set of instructions for how to make an instance. The `Dog` class is a set of instructions that tells Python how to make individual instances representing specific dogs.    Let’s make an instance representing a specific dog:    ```", "```py    The `Dog` class we’re using here is the one we just wrote in the previous example. Here, we tell Python to create a dog whose name is `'Willie'` and whose age is `6` ❶. When Python reads this line, it calls the `__init__()` method in `Dog` with the arguments `'Willie'` and `6`. The `__init__()` method creates an instance representing this particular dog and sets the `name` and `age` attributes using the values we provided. Python then returns an instance representing this dog. We assign that instance to the variable `my_dog`. The naming convention is helpful here; we can usually assume that a capitalized name like `Dog` refers to a class, and a lowercase name like `my_dog` refers to a single instance created from a class.    #### Accessing Attributes    To access the attributes of an instance, you use dot notation. We access the value of `my_dog`’s attribute `name` ❷ by writing:    ```", "```py    Dot notation is used often in Python. This syntax demonstrates how Python finds an attribute’s value. Here, Python looks at the instance `my_dog` and then finds the attribute `name` associated with `my_dog`. This is the same attribute referred to as `self.name` in the class `Dog`. We use the same approach to work with the attribute `age` ❸.    The output is a summary of what we know about `my_dog`:    ```", "```py    #### Calling Methods    After we create an instance from the class `Dog`, we can use dot notation to call any method defined in `Dog`. Let’s make our dog sit and roll over:    ```", "```py    To call a method, give the name of the instance (in this case, `my_dog`) and the method you want to call, separated by a dot. When Python reads `my_dog.sit()`, it looks for the method `sit()` in the class `Dog` and runs that code. Python interprets the line `my_dog.roll_over()` in the same way.    Now Willie does what we tell him to:    ```", "```py    This syntax is quite useful. When attributes and methods have been given appropriately descriptive names like `name`, `age`, `sit()`, and `roll_over()`, we can easily infer what a block of code, even one we’ve never seen before, is supposed to do.    #### Creating Multiple Instances    You can create as many instances from a class as you need. Let’s create a second dog called `your_dog`:    ```", "```py    In this example we create a dog named Willie and a dog named Lucy. Each dog is a separate instance with its own set of attributes, capable of the same set of actions:    ```", "```py    Even if we used the same name and age for the second dog, Python would still create a separate instance from the `Dog` class. You can make as many instances from one class as you need, as long as you give each instance a unique variable name or it occupies a unique spot in a list or dictionary.    ## Working with Classes and Instances    You can use classes to represent many real-world situations. Once you write a class, you’ll spend most of your time working with instances created from that class. One of the first tasks you’ll want to do is modify the attributes associated with a particular instance. You can modify the attributes of an instance directly or write methods that update attributes in specific ways.    ### The Car Class    Let’s write a new class representing a car. Our class will store information about the kind of car we’re working with, and it will have a method that summarizes this information:    **car.py**    ```", "```py    In the `Car` class, we define the `__init__()` method with the `self` parameter first ❶, just like we did with the `Dog` class. We also give it three other parameters: `make`, `model`, and `year`. The `__init__()` method takes in these parameters and assigns them to the attributes that will be associated with instances made from this class. When we make a new `Car` instance, we’ll need to specify a make, model, and year for our instance.    We define a method called `get_descriptive_name()` ❷ that puts a car’s `year`, `make`, and `model` into one string neatly describing the car. This will spare us from having to print each attribute’s value individually. To work with the attribute values in this method, we use `self.make`, `self.model`, and `self.year`. Outside of the class, we make an instance from the `Car` class and assign it to the variable `my_new_car` ❸. Then we call `get_descriptive_name()` to show what kind of car we have:    ```", "```py    To make the class more interesting, let’s add an attribute that changes over time. We’ll add an attribute that stores the car’s overall mileage.    ### Setting a Default Value for an Attribute    When an instance is created, attributes can be defined without being passed in as parameters. These attributes can be defined in the `__init__()` method, where they are assigned a default value.    Let’s add an attribute called `odometer_reading` that always starts with a value of 0\\. We’ll also add a method `read_odometer()` that helps us read each car’s odometer:    ```", "```py    This time, when Python calls the `__init__()` method to create a new instance, it stores the make, model, and year values as attributes, like it did in the previous example. Then Python creates a new attribute called `odometer_reading` and sets its initial value to 0 ❶. We also have a new method called `read_odometer()` ❷ that makes it easy to read a car’s mileage.    Our car starts with a mileage of 0:    ```", "```py    Not many cars are sold with exactly 0 miles on the odometer, so we need a way to change the value of this attribute.    ### Modifying Attribute Values    You can change an attribute’s value in three ways: you can change the value directly through an instance, set the value through a method, or increment the value (add a certain amount to it) through a method. Let’s look at each of these approaches.    #### Modifying an Attribute’s Value Directly    The simplest way to modify the value of an attribute is to access the attribute directly through an instance. Here we set the odometer reading to 23 directly:    ```", "```py    We use dot notation to access the car’s `odometer_reading` attribute, and set its value directly. This line tells Python to take the instance `my_new_car`, find the attribute `odometer_reading` associated with it, and set the value of that attribute to 23:    ```", "```py    Sometimes you’ll want to access attributes directly like this, but other times you’ll want to write a method that updates the value for you.    #### Modifying an Attribute’s Value Through a Method    It can be helpful to have methods that update certain attributes for you. Instead of accessing the attribute directly, you pass the new value to a method that handles the updating internally.    Here’s an example showing a method called `update_odometer()`:    ```", "```py    The only modification to `Car` is the addition of `update_odometer()`. This method takes in a mileage value and assigns it to `self.odometer_reading`. Using the `my_new_car` instance, we call `update_odometer()` with `23` as an argument ❶. This sets the odometer reading to 23, and `read_odometer()` prints the reading:    ```", "```py    We can extend the method `update_odometer()` to do additional work every time the odometer reading is modified. Let’s add a little logic to make sure no one tries to roll back the odometer reading:    ```", "```py    Now `update_odometer()` checks that the new reading makes sense before modifying the attribute. If the value provided for `mileage` is greater than or equal to the existing mileage, `self.odometer_reading`, you can update the odometer reading to the new mileage ❶. If the new mileage is less than the existing mileage, you’ll get a warning that you can’t roll back an odometer ❷.    #### Incrementing an Attribute’s Value Through a Method    Sometimes you’ll want to increment an attribute’s value by a certain amount, rather than set an entirely new value. Say we buy a used car and put 100 miles on it between the time we buy it and the time we register it. Here’s a method that allows us to pass this incremental amount and add that value to the odometer reading:    ```", "```py    The new method `increment_odometer()` takes in a number of miles, and adds this value to `self.odometer_reading`. First, we create a used car, `my_used_car` ❶. We set its odometer to 23,500 by calling `update_odometer()` and passing it `23_500` ❷. Finally, we call `increment_odometer()` and pass it `100` to add the 100 miles that we drove between buying the car and registering it:    ```", "```py    You can modify this method to reject negative increments so no one uses this function to roll back an odometer as well.    ## Inheritance    You don’t always have to start from scratch when writing a class. If the class you’re writing is a specialized version of another class you wrote, you can use *inheritance*. When one class *inherits* from another, it takes on the attributes and methods of the first class. The original class is called the *parent class*, and the new class is the *child class*. The child class can inherit any or all of the attributes and methods of its parent class, but it’s also free to define new attributes and methods of its own.    ### The __init__() Method for a Child Class    When you’re writing a new class based on an existing class, you’ll often want to call the `__init__()` method from the parent class. This will initialize any attributes that were defined in the parent `__init__()` method and make them available in the child class.    As an example, let’s model an electric car. An electric car is just a specific kind of car, so we can base our new `ElectricCar` class on the `Car` class we wrote earlier. Then we’ll only have to write code for the attributes and behaviors specific to electric cars.    Let’s start by making a simple version of the `ElectricCar` class, which does everything the `Car` class does:    **electric_car.py**    ```", "```py    We start with `Car` ❶. When you create a child class, the parent class must be part of the current file and must appear before the child class in the file. We then define the child class, `ElectricCar` ❷. The name of the parent class must be included in parentheses in the definition of a child class. The `__init__()` method takes in the information required to make a `Car` instance ❸.    The `super()` function ❹ is a special function that allows you to call a method from the parent class. This line tells Python to call the `__init__()` method from `Car`, which gives an `ElectricCar` instance all the attributes defined in that method. The name *super* comes from a convention of calling the parent class a *superclass* and the child class a *subclass*.    We test whether inheritance is working properly by trying to create an electric car with the same kind of information we’d provide when making a regular car. We make an instance of the `ElectricCar` class and assign it to `my_leaf` ❺. This line calls the `__init__()` method defined in `ElectricCar`, which in turn tells Python to call the `__init__()` method defined in the parent class `Car`. We provide the arguments `'nissan'`, `'leaf'`, and `2024`.    Aside from `__init__()`, there are no attributes or methods yet that are particular to an electric car. At this point we’re just making sure the electric car has the appropriate `Car` behaviors:    ```", "```py    The `ElectricCar` instance works just like an instance of `Car`, so now we can begin defining attributes and methods specific to electric cars.    ### Defining Attributes and Methods for the Child Class    Once you have a child class that inherits from a parent class, you can add any new attributes and methods necessary to differentiate the child class from the parent class.    Let’s add an attribute that’s specific to electric cars (a battery, for example) and a method to report on this attribute. We’ll store the battery size and write a method that prints a description of the battery:    ```", "```py    We add a new attribute `self.battery_size` and set its initial value to `40` ❶. This attribute will be associated with all instances created from the `ElectricCar` class but won’t be associated with any instances of `Car`. We also add a method called `describe_battery()` that prints information about the battery ❷. When we call this method, we get a description that is clearly specific to an electric car:    ```", "```py    There’s no limit to how much you can specialize the `ElectricCar` class. You can add as many attributes and methods as you need to model an electric car to whatever degree of accuracy you need. An attribute or method that could belong to any car, rather than one that’s specific to an electric car, should be added to the `Car` class instead of the `ElectricCar` class. Then anyone who uses the `Car` class will have that functionality available as well, and the `ElectricCar` class will only contain code for the information and behavior specific to electric vehicles.    ### Overriding Methods from the Parent Class    You can override any method from the parent class that doesn’t fit what you’re trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Python will disregard the parent class method and only pay attention to the method you define in the child class.    Say the class `Car` had a method called `fill_gas_tank()`. This method is meaningless for an all-electric vehicle, so you might want to override this method. Here’s one way to do that:    ```", "```py    Now if someone tries to call `fill_gas_tank()` with an electric car, Python will ignore the method `fill_gas_tank()` in `Car` and run this code instead. When you use inheritance, you can make your child classes retain what you need and override anything you don’t need from the parent class.    ### Instances as Attributes    When modeling something from the real world in code, you may find that you’re adding more and more detail to a class. You’ll find that you have a growing list of attributes and methods and that your files are becoming lengthy. In these situations, you might recognize that part of one class can be written as a separate class. You can break your large class into smaller classes that work together; this approach is called *composition*.    For example, if we continue adding detail to the `ElectricCar` class, we might notice that we’re adding many attributes and methods specific to the car’s battery. When we see this happening, we can stop and move those attributes and methods to a separate class called `Battery`. Then we can use a `Battery` instance as an attribute in the `ElectricCar` class:    ```", "```py    We define a new class called `Battery` that doesn’t inherit from any other class. The `__init__()` method ❶ has one parameter, `battery_size`, in addition to `self`. This is an optional parameter that sets the battery’s size to 40 if no value is provided. The method `describe_battery()` has been moved to this class as well ❷.    In the `ElectricCar` class, we now add an attribute called `self.battery` ❸. This line tells Python to create a new instance of `Battery` (with a default size of 40, because we’re not specifying a value) and assign that instance to the attribute `self.battery`. This will happen every time the `__init__()` method is called; any `ElectricCar` instance will now have a `Battery` instance created automatically.    We create an electric car and assign it to the variable `my_leaf`. When we want to describe the battery, we need to work through the car’s `battery` attribute:    ```", "```py    This line tells Python to look at the instance `my_leaf`, find its `battery` attribute, and call the method `describe_battery()` that’s associated with the `Battery` instance assigned to the attribute.    The output is identical to what we saw previously:    ```", "```py    This looks like a lot of extra work, but now we can describe the battery in as much detail as we want without cluttering the `ElectricCar` class. Let’s add another method to `Battery` that reports the range of the car based on the battery size:    ```", "```py    The new method `get_range()` performs some simple analysis. If the battery’s capacity is 40 kWh, `get_range()` sets the range to 150 miles, and if the capacity is 65 kWh, it sets the range to 225 miles. It then reports this value. When we want to use this method, we again have to call it through the car’s `battery` attribute ❶.    The output tells us the range of the car based on its battery size:    ```", "```py    ### Modeling Real-World Objects    As you begin to model more complicated things like electric cars, you’ll wrestle with interesting questions. Is the range of an electric car a property of the battery or of the car? If we’re only describing one car, it’s probably fine to maintain the association of the method `get_range()` with the `Battery` class. But if we’re describing a manufacturer’s entire line of cars, we probably want to move `get_range()` to the `ElectricCar` class. The `get_range()` method would still check the battery size before determining the range, but it would report a range specific to the kind of car it’s associated with. Alternatively, we could maintain the association of the `get_range()` method with the battery but pass it a parameter such as `car_model`. The `get_range()` method would then report a range based on the battery size and car model.    This brings you to an interesting point in your growth as a programmer. When you wrestle with questions like these, you’re thinking at a higher logical level rather than a syntax-focused level. You’re thinking not about Python, but about how to represent the real world in code. When you reach this point, you’ll realize there are often no right or wrong approaches to modeling real-world situations. Some approaches are more efficient than others, but it takes practice to find the most efficient representations. If your code is working as you want it to, you’re doing well! Don’t be discouraged if you find you’re ripping apart your classes and rewriting them several times using different approaches. In the quest to write accurate, efficient code, everyone goes through this process.    ## Importing Classes    As you add more functionality to your classes, your files can get long, even when you use inheritance and composition properly. In keeping with the overall philosophy of Python, you’ll want to keep your files as uncluttered as possible. To help, Python lets you store classes in modules and then import the classes you need into your main program.    ### Importing a Single Class    Let’s create a module containing just the `Car` class. This brings up a subtle naming issue: we already have a file named *car.py* in this chapter, but this module should be named *car.py* because it contains code representing a car. We’ll resolve this naming issue by storing the `Car` class in a module named *car.py*, replacing the *car.py* file we were previously using. From now on, any program that uses this module will need a more specific filename, such as *my_car.py*. Here’s *car.py* with just the code from the class `Car`:    **car.py**    ```", "```py    We include a module-level docstring that briefly describes the contents of this module ❶. You should write a docstring for each module you create.    Now we make a separate file called *my_car.py*. This file will import the `Car` class and then create an instance from that class:    **my_car.py**    ```", "```py    The `import` statement ❶ tells Python to open the `car` module and import the class `Car`. Now we can use the `Car` class as if it were defined in this file. The output is the same as we saw earlier:    ```", "```py    Importing classes is an effective way to program. Picture how long this program file would be if the entire `Car` class were included. When you instead move the class to a module and import the module, you still get all the same functionality, but you keep your main program file clean and easy to read. You also store most of the logic in separate files; once your classes work as you want them to, you can leave those files alone and focus on the higher-level logic of your main program.    ### Storing Multiple Classes in a Module    You can store as many classes as you need in a single module, although each class in a module should be related somehow. The classes `Battery` and `ElectricCar` both help represent cars, so let’s add them to the module *car.py*.    **car.py**    ```", "```py    Now we can make a new file called *my_electric_car.py*, import the `ElectricCar` class, and make an electric car:    **my_electric_car.py**    ```", "```py    This has the same output we saw earlier, even though most of the logic is hidden away in a module:    ```", "```py    ### Importing Multiple Classes from a Module    You can import as many classes as you need into a program file. If we want to make a regular car and an electric car in the same file, we need to import both classes, `Car` and `ElectricCar`:    **my_cars.py**    ```", "```py    You import multiple classes from a module by separating each class with a comma ❶. Once you’ve imported the necessary classes, you’re free to make as many instances of each class as you need.    In this example we make a gas-powered Ford Mustang ❷ and then an electric Nissan Leaf ❸:    ```", "```py    ### Importing an Entire Module    You can also import an entire module and then access the classes you need using dot notation. This approach is simple and results in code that is easy to read. Because every call that creates an instance of a class includes the module name, you won’t have naming conflicts with any names used in the current file.    Here’s what it looks like to import the entire `car` module and then create a regular car and an electric car:    **my_cars.py**    ```", "```py    First we import the entire `car` module ❶. We then access the classes we need through the `module_name`.`ClassName` syntax. We again create a Ford Mustang ❷, and a Nissan Leaf ❸.    ### Importing All Classes from a Module    You can import every class from a module using the following syntax:    ```", "```py    This method is not recommended for two reasons. First, it’s helpful to be able to read the `import` statements at the top of a file and get a clear sense of which classes a program uses. With this approach it’s unclear which classes you’re using from the module. This approach can also lead to confusion with names in the file. If you accidentally import a class with the same name as something else in your program file, you can create errors that are hard to diagnose. I show this here because even though it’s not a recommended approach, you’re likely to see it in other people’s code at some point.    If you need to import many classes from a module, you’re better off importing the entire module and using the `module_name.ClassName` syntax. You won’t see all the classes used at the top of the file, but you’ll see clearly where the module is used in the program. You’ll also avoid the potential naming conflicts that can arise when you import every class in a module.    ### Importing a Module into a Module    Sometimes you’ll want to spread out your classes over several modules to keep any one file from growing too large and avoid storing unrelated classes in the same module. When you store your classes in several modules, you may find that a class in one module depends on a class in another module. When this happens, you can import the required class into the first module.    For example, let’s store the `Car` class in one module and the `ElectricCar` and `Battery` classes in a separate module. We’ll make a new module called *electric_car.py*—replacing the *electric_car.py* file we created earlier—and copy just the `Battery` and `ElectricCar` classes into this file:    **electric_car.py**    ```", "```py    The class `ElectricCar` needs access to its parent class `Car`, so we import `Car` directly into the module. If we forget this line, Python will raise an error when we try to import the `electric_car` module. We also need to update the `Car` module so it contains only the `Car` class:    **car.py**    ```", "```py    Now we can import from each module separately and create whatever kind of car we need:    **my_cars.py**    ```", "```py    We import `Car` from its module, and `ElectricCar` from its module. We then create one regular car and one electric car. Both cars are created correctly:    ```", "```py    ### Using Aliases    As you saw in Chapter 8, aliases can be quite helpful when using modules to organize your projects’ code. You can use aliases when importing classes as well.    As an example, consider a program where you want to make a bunch of electric cars. It might get tedious to type (and read) `ElectricCar` over and over again. You can give `ElectricCar` an alias in the import statement:    ```", "```py    Now you can use this alias whenever you want to make an electric car:    ```", "```py    You can also give a module an alias. Here’s how to import the entire `electric_car` module using an alias:    ```", "```py    Now you can use this module alias with the full class name:    ```", "```py    ### Finding Your Own Workflow    As you can see, Python gives you many options for how to structure code in a large project. It’s important to know all these possibilities so you can determine the best ways to organize your projects as well as understand other people’s projects.    When you’re starting out, keep your code structure simple. Try doing everything in one file and moving your classes to separate modules once everything is working. If you like how modules and files interact, try storing your classes in modules when you start a project. Find an approach that lets you write code that works, and go from there.    ## The Python Standard Library    The *Python standard library* is a set of modules included with every Python installation. Now that you have a basic understanding of how functions and classes work, you can start to use modules like these that other programmers have written. You can use any function or class in the standard library by including a simple `import` statement at the top of your file. Let’s look at one module, `random`, which can be useful in modeling many real-world situations.    One interesting function from the random module is `randint()`. This function takes two integer arguments and returns a randomly selected integer between (and including) those numbers.    Here’s how to generate a random number between 1 and 6:    ```", "```py    Another useful function is `choice()`. This function takes in a list or tuple and returns a randomly chosen element:    ```", "```py    The `random` module shouldn’t be used when building security-related applications, but it works well for many fun and interesting projects.    ## Styling Classes    A few styling issues related to classes are worth clarifying, especially as your programs become more complicated.    Class names should be written in *CamelCase*. To do this, capitalize the first letter of each word in the name, and don’t use underscores. Instance and module names should be written in lowercase, with underscores between words.    Every class should have a docstring immediately following the class definition. The docstring should be a brief description of what the class does, and you should follow the same formatting conventions you used for writing docstrings in functions. Each module should also have a docstring describing what the classes in a module can be used for.    You can use blank lines to organize code, but don’t use them excessively. Within a class you can use one blank line between methods, and within a module you can use two blank lines to separate classes.    If you need to import a module from the standard library and a module that you wrote, place the import statement for the standard library module first. Then add a blank line and the import statement for the module you wrote. In programs with multiple import statements, this convention makes it easier to see where the different modules used in the program come from.    ## Summary    In this chapter, you learned how to write your own classes. You learned how to store information in a class using attributes and how to write methods that give your classes the behavior they need. You learned to write `__init__()` methods that create instances from your classes with exactly the attributes you want. You saw how to modify the attributes of an instance directly and through methods. You learned that inheritance can simplify the creation of classes that are related to each other, and you learned to use instances of one class as attributes in another class to keep each class simple.    You saw how storing classes in modules and importing classes you need into the files where they’ll be used can keep your projects organized. You started learning about the Python standard library, and you saw an example based on the `random` module. Finally, you learned to style your classes using Python conventions.    In Chapter 10, you’ll learn to work with files so you can save the work you’ve done in a program and the work you’ve allowed users to do. You’ll also learn about *exceptions*, a special Python class designed to help you respond to errors when they arise.    # 10 Files and Exceptions  ![](Images/chapterart.png)  Now that you’ve mastered the basic skills you need to write organized programs that are easy to use, it’s time to think about making your programs even more relevant and usable. In this chapter, you’ll learn to work with files so your programs can quickly analyze lots of data.    You’ll learn to handle errors so your programs don’t crash when they encounter unexpected situations. You’ll learn about *exceptions*, which are special objects Python creates to manage errors that arise while a program is running. You’ll also learn about the `json` module, which allows you to save user data so it isn’t lost when your program stops running.    Learning to work with files and save data will make your programs easier for people to use. Users will be able to choose what data to enter and when to enter it. People will be able to run your program, do some work, and then close the program and pick up where they left off. Learning to handle exceptions will help you deal with situations in which files don’t exist and deal with other problems that can cause your programs to crash. This will make your programs more robust when they encounter bad data, whether it comes from innocent mistakes or from malicious attempts to break your programs. With the skills you’ll learn in this chapter, you’ll make your programs more applicable, usable, and stable.    ## Reading from a File    An incredible amount of data is available in text files. Text files can contain weather data, traffic data, socioeconomic data, literary works, and more. Reading from a file is particularly useful in data analysis applications, but it’s also applicable to any situation in which you want to analyze or modify information stored in a file. For example, you can write a program that reads in the contents of a text file and rewrites the file with formatting that allows a browser to display it.    When you want to work with the information in a text file, the first step is to read the file into memory. You can then work through all of the file’s contents at once or work through the contents line by line.    ### Reading the Contents of a File    To begin, we need a file with a few lines of text in it. Let’s start with a file that contains *pi* to 30 decimal places, with 10 decimal places per line:    **pi_digits.txt**    ```", "```py    To try the following examples yourself, you can enter these lines in an editor and save the file as *pi_digits.txt*, or you can download the file from the book’s resources through [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e). Save the file in the same directory where you’ll store this chapter’s programs.    Here’s a program that opens this file, reads it, and prints the contents of the file to the screen:    **file_reader.py**    ```", "```py    To work with the contents of a file, we need to tell Python the path to the file. A *path* is the exact location of a file or folder on a system. Python provides a module called `pathlib` that makes it easier to work with files and directories, no matter which operating system you or your program’s users are working with. A module that provides specific functionality like this is often called a *library*, hence the name `pathlib`.    We start by importing the `Path` class from `pathlib`. There’s a lot you can do with a `Path` object that points to a file. For example, you can check that the file exists before working with it, read the file’s contents, or write new data to the file. Here, we build a `Path` object representing the file *pi_digits.txt*, which we assign to the variable `path` ❶. Since this file is saved in the same directory as the *.py* file we’re writing, the filename is all that `Path` needs to access the file.    Once we have a `Path` object representing *pi_digits.txt*, we use the `read_text()` method to read the entire contents of the file ❷. The contents of the file are returned as a single string, which we assign to the variable `contents`. When we print the value of `contents`, we see the entire contents of the text file:    ```", "```py    The only difference between this output and the original file is the extra blank line at the end of the output. The blank line appears because `read_text()` returns an empty string when it reaches the end of the file; this empty string shows up as a blank line.    We can remove the extra blank line by using `rstrip()` on the `contents` string:    ```", "```py    Recall from Chapter 2 that Python’s `rstrip()` method removes, or strips, any whitespace characters from the right side of a string. Now the output matches the contents of the original file exactly:    ```", "```py    We can strip the trailing newline character when we read the contents of the file, by applying the `rstrip()` method immediately after calling `read_text()`:    ```", "```py    This line tells Python to call the `read_text()` method on the file we’re working with. Then it applies the `rstrip()` method to the string that `read_text()` returns. The cleaned-up string is then assigned to the variable `contents`. This approach is called *method chaining*, and you’ll see it used often in programming.    ### Relative and Absolute File Paths    When you pass a simple filename like *pi_digits.txt* to `Path`, Python looks in the directory where the file that’s currently being executed (that is, your *.py* program file) is stored.    Sometimes, depending on how you organize your work, the file you want to open won’t be in the same directory as your program file. For example, you might store your program files in a folder called *python_work*; inside *python_work*, you might have another folder called *text_files* to distinguish your program files from the text files they’re manipulating. Even though *text_files* is in *python_work*, just passing `Path` the name of a file in *text_files* won’t work, because Python will only look in *python_work* and stop there; it won’t go on and look in *text_files.* To get Python to open files from a directory other than the one where your program file is stored, you need to provide the correct path.    There are two main ways to specify paths in programming. A *relative file path* tells Python to look for a given location relative to the directory where the currently running program file is stored. Since *text_files* is inside *python_work*, we need to build a path that starts with the directory *text_files*, and ends with the filename. Here’s how to build this path:    ```", "```py    You can also tell Python exactly where the file is on your computer, regardless of where the program that’s being executed is stored. This is called an *absolute file path*. You can use an absolute path if a relative path doesn’t work. For instance, if you’ve put *text_files* in some folder other than *python_work*, then just passing `Path` the path `'text_files/``filename``.txt'` won’t work because Python will only look for that location inside *python_work*. You’ll need to write out an absolute path to clarify where you want Python to look.    Absolute paths are usually longer than relative paths, because they start at your system’s root folder:    ```", "```py    Using absolute paths, you can read files from any location on your system. For now it’s easiest to store files in the same directory as your program files, or in a folder such as *text_files* within the directory that stores your program files.    ### Accessing a File’s Lines    When you’re working with a file, you’ll often want to examine each line of the file. You might be looking for certain information in the file, or you might want to modify the text in the file in some way. For example, you might want to read through a file of weather data and work with any line that includes the word *sunny* in the description of that day’s weather. In a news report, you might look for any line with the tag `<headline>` and rewrite that line with a specific kind of formatting.    You can use the `splitlines()` method to turn a long string into a set of lines, and then use a `for` loop to examine each line from a file, one at a time:    **file_reader.py**    ```", "```py    We start out by reading the entire contents of the file, as we did earlier ❶. If you’re planning to work with the individual lines in a file, you don’t need to strip any whitespace when reading the file. The `splitlines()` method returns a list of all lines in the file, and we assign this list to the variable `lines` ❷. We then loop over these lines and print each one:    ```", "```py    Since we haven’t modified any of the lines, the output matches the original text file exactly.    ### Working with a File’s Contents    After you’ve read the contents of a file into memory, you can do whatever you want with that data, so let’s briefly explore the digits of *pi*. First, we’ll attempt to build a single string containing all the digits in the file with no whitespace in it:    **pi_string.py**    ```", "```py    We start by reading the file and storing each line of digits in a list, just as we did in the previous example. We then create a variable, `pi_string`, to hold the digits of *pi*. We write a loop that adds each line of digits to `pi_string` ❶. We print this string, and also show how long the string is:    ```", "```py    The variable `pi_string` contains the whitespace that was on the left side of the digits in each line, but we can get rid of that by using `lstrip()` on each line:    ```", "```py    Now we have a string containing *pi* to 30 decimal places. The string is 32 characters long because it also includes the leading `3` and a decimal point:    ```", "```py    ### Large Files: One Million Digits    So far, we’ve focused on analyzing a text file that contains only three lines, but the code in these examples would work just as well on much larger files. If we start with a text file that contains *pi* to 1,000,000 decimal places, instead of just 30, we can create a single string containing all these digits. We don’t need to change our program at all, except to pass it a different file. We’ll also print just the first 50 decimal places, so we don’t have to watch a million digits scroll by in the terminal:    **pi_string.py**    ```", "```py    The output shows that we do indeed have a string containing *pi* to 1,000,000 decimal places:    ```", "```py    Python has no inherent limit to how much data you can work with; you can work with as much data as your system’s memory can handle.    ### Is Your Birthday Contained in Pi?    I’ve always been curious to know if my birthday appears anywhere in the digits of *pi*. Let’s use the program we just wrote to find out if someone’s birthday appears anywhere in the first million digits of *pi*. We can do this by expressing each birthday as a string of digits and seeing if that string appears anywhere in `pi_string`:    **pi_birthday.py**    ```", "```py    We first prompt for the user’s birthday, and then check if that string is in `pi_string`. Let’s try it:    ```", "```py    My birthday does appear in the digits of *pi*! Once you’ve read from a file, you can analyze its contents in just about any way you can imagine.    ## Writing to a File    One of the simplest ways to save data is to write it to a file. When you write text to a file, the output will still be available after you close the terminal containing your program’s output. You can examine output after a program finishes running, and you can share the output files with others as well. You can also write programs that read the text back into memory and work with it again later.    ### Writing a Single Line    Once you have a path defined, you can write to a file using the `write_text()` method. To see how this works, let’s write a simple message and store it in a file instead of printing it to the screen:    **write_message.py**    ```", "```py    The `write_text()` method takes a single argument: the string that you want to write to the file. This program has no terminal output, but if you open the file *programming.txt*, you’ll see one line:    **programming.txt**    ```", "```py    This file behaves like any other file on your computer. You can open it, write new text in it, copy from it, paste to it, and so forth.    ### Writing Multiple Lines    The `write_text()` method does a few things behind the scenes. If the file that `path` points to doesn’t exist, it creates that file. Also, after writing the string to the file, it makes sure the file is closed properly. Files that aren’t closed properly can lead to missing or corrupted data.    To write more than one line to a file, you need to build a string containing the entire contents of the file, and then call `write_text()` with that string. Let’s write several lines to the *programming.txt* file:    ```", "```py    We define a variable called `contents` that will hold the entire contents of the file. On the next line, we use the `+=` operator to add to this string. You can do this as many times as you need, to build strings of any length. In this case we include newline characters at the end of each line, to make sure each statement appears on its own line.    If you run this and then open *programming.txt*, you’ll see each of these lines in the text file:    ```", "```py    You can also use spaces, tab characters, and blank lines to format your output, just as you’ve been doing with terminal-based output. There’s no limit to the length of your strings, and this is how many computer-generated documents are created.    ## Exceptions    Python uses special objects called *exceptions* to manage errors that arise during a program’s execution. Whenever an error occurs that makes Python unsure of what to do next, it creates an exception object. If you write code that handles the exception, the program will continue running. If you don’t handle the exception, the program will halt and show a *traceback*, which includes a report of the exception that was raised.    Exceptions are handled with `try`-`except` blocks. A *try*-*except* block asks Python to do something, but it also tells Python what to do if an exception is raised. When you use `try`-`except` blocks, your programs will continue running even if things start to go wrong. Instead of tracebacks, which can be confusing for users to read, users will see friendly error messages that you’ve written.    ### Handling the ZeroDivisionError Exception    Let’s look at a simple error that causes Python to raise an exception. You probably know that it’s impossible to divide a number by zero, but let’s ask Python to do it anyway:    **division_calculator.py**    ```", "```py    Python can’t do this, so we get a traceback:    ```", "```py    The error reported in the traceback, `ZeroDivisionError`, is an exception object ❶. Python creates this kind of object in response to a situation where it can’t do what we ask it to. When this happens, Python stops the program and tells us the kind of exception that was raised. We can use this information to modify our program. We’ll tell Python what to do when this kind of exception occurs; that way, if it happens again, we’ll be prepared.    ### Using try-except Blocks    When you think an error may occur, you can write a `try`-`except` block to handle the exception that might be raised. You tell Python to try running some code, and you tell it what to do if the code results in a particular kind of exception.    Here’s what a `try`-`except` block for handling the `ZeroDivisionError` exception looks like:    ```", "```py    We put `print(5/0)`, the line that caused the error, inside a `try` block. If the code in a `try` block works, Python skips over the `except` block. If the code in the `try` block causes an error, Python looks for an `except` block whose error matches the one that was raised, and runs the code in that block.    In this example, the code in the `try` block produces a `ZeroDivisionError`, so Python looks for an `except` block telling it how to respond. Python then runs the code in that block, and the user sees a friendly error message instead of a traceback:    ```", "```py    If more code followed the `try`-`except` block, the program would continue running because we told Python how to handle the error. Let’s look at an example where catching an error can allow a program to continue running.    ### Using Exceptions to Prevent Crashes    Handling errors correctly is especially important when the program has more work to do after the error occurs. This happens often in programs that prompt users for input. If the program responds to invalid input appropriately, it can prompt for more valid input instead of crashing.    Let’s create a simple calculator that does only division:    **division_calculator.py**    ```", "```py    This program prompts the user to input a `first_number` ❶ and, if the user does not enter `q` to quit, a `second_number` ❷. We then divide these two numbers to get an `answer` ❸. This program does nothing to handle errors, so asking it to divide by zero causes it to crash:    ```", "```py    It’s bad that the program crashed, but it’s also not a good idea to let users see tracebacks. Nontechnical users will be confused by them, and in a malicious setting, attackers will learn more than you want them to. For example, they’ll know the name of your program file, and they’ll see a part of your code that isn’t working properly. A skilled attacker can sometimes use this information to determine which kind of attacks to use against your code.    ### The else Block    We can make this program more error resistant by wrapping the line that might produce errors in a `try`-`except` block. The error occurs on the line that performs the division, so that’s where we’ll put the `try`-`except` block. This example also includes an `else` block. Any code that depends on the `try` block executing successfully goes in the `else` block:    ```", "```py    We ask Python to try to complete the division operation in a `try` block ❶, which includes only the code that might cause an error. Any code that depends on the `try` block succeeding is added to the `else` block. In this case, if the division operation is successful, we use the `else` block to print the result ❸.    The `except` block tells Python how to respond when a `ZeroDivisionError` arises ❷. If the `try` block doesn’t succeed because of a division-by-zero error, we print a friendly message telling the user how to avoid this kind of error. The program continues to run, and the user never sees a traceback:    ```", "```py    The only code that should go in a `try` block is code that might cause an exception to be raised. Sometimes you’ll have additional code that should run only if the `try` block was successful; this code goes in the `else` block. The `except` block tells Python what to do in case a certain exception arises when it tries to run the code in the `try` block.    By anticipating likely sources of errors, you can write robust programs that continue to run even when they encounter invalid data and missing resources. Your code will be resistant to innocent user mistakes and malicious attacks.    ### Handling the FileNotFoundError Exception    One common issue when working with files is handling missing files. The file you’re looking for might be in a different location, the filename might be misspelled, or the file might not exist at all. You can handle all of these situations with a `try`-`except` block.    Let’s try to read a file that doesn’t exist. The following program tries to read in the contents of *Alice in Wonderland*, but I haven’t saved the file *alice.txt* in the same directory as *alice.py*:    **alice.py**    ```", "```py    Note that we’re using `read_text()` in a slightly different way here than what you saw earlier. The `encoding` argument is needed when your system’s default encoding doesn’t match the encoding of the file that’s being read. This is most likely to happen when reading from a file that wasn’t created on your system.    Python can’t read from a missing file, so it raises an exception:    ```", "```py    This is a longer traceback than the ones we’ve seen previously, so let’s look at how you can make sense of more complex tracebacks. It’s often best to start at the very end of the traceback. On the last line, we can see that a `FileNotFoundError` exception was raised ❸. This is important because it tells us what kind of exception to use in the `except` block that we’ll write.    Looking back near the beginning of the traceback ❶, we can see that the error occurred at line 4 in the file *alice.py*. The next line shows the line of code that caused the error ❷. The rest of the traceback shows some code from the libraries that are involved in opening and reading from files. You don’t usually need to read through or understand all of these lines in a traceback.    To handle the error that’s being raised, the `try` block will begin with the line that was identified as problematic in the traceback. In our example, this is the line that contains `read_text()`:    ```", "```py    In this example, the code in the `try` block produces a `FileNotFoundError`, so we write an `except` block that matches that error ❶. Python then runs the code in that block when the file can’t be found, and the result is a friendly error message instead of a traceback:    ```", "```py    The program has nothing more to do if the file doesn’t exist, so this is all the output we see. Let’s build on this example and see how exception handling can help when you’re working with more than one file.    ### Analyzing Text    You can analyze text files containing entire books. Many classic works of literature are available as simple text files because they are in the public domain. The texts used in this section come from Project Gutenberg ([https://gutenberg.org](https://gutenberg.org)). Project Gutenberg maintains a collection of literary works that are available in the public domain, and it’s a great resource if you’re interested in working with literary texts in your programming projects.    Let’s pull in the text of *Alice in Wonderland* and try to count the number of words in the text. To do this, we’ll use the string method `split()`, which by default splits a string wherever it finds any whitespace:    ```", "```py    I moved the file *alice.txt* to the correct directory, so the `try` block will work this time. We take the string `contents`, which now contains the entire text of *Alice in Wonderland* as one long string, and use `split()` to produce a list of all the words in the book ❶. Using `len()` on this list ❷ gives us a good approximation of the number of words in the original text. Lastly, we print a statement that reports how many words were found in the file. This code is placed in the `else` block because it only works if the code in the `try` block was executed successfully.    The output tells us how many words are in *alice.txt*:    ```", "```py    The count is a little high because extra information is provided by the publisher in the text file used here, but it’s a good approximation of the length of *Alice in Wonderland*.    ### Working with Multiple Files    Let’s add more books to analyze, but before we do, let’s move the bulk of this program to a function called `count_words()`. This will make it easier to run the analysis for multiple books:    **word_count.py**    ```", "```py    Most of this code is unchanged. It’s only been indented, and moved into the body of `count_words()`. It’s a good habit to keep comments up to date when you’re modifying a program, so the comment has also been changed to a docstring and reworded slightly ❶.    Now we can write a short loop to count the words in any text we want to analyze. We do this by storing the names of the files we want to analyze in a list, and then we call `count_words()` for each file in the list. We’ll try to count the words for *Alice in Wonderland*, *Siddhartha*, *Moby Dick*, and *Little Women*, which are all available in the public domain. I’ve intentionally left *siddhartha.txt* out of the directory containing *word_count.py*, so we can see how well our program handles a missing file:    ```", "```py    The names of the files are stored as simple strings. Each string is then converted to a `Path` object ❶, before the call to `count_words()`. The missing *siddhartha.txt* file has no effect on the rest of the program’s execution:    ```", "```py    Using the `try`-`except` block in this example provides two significant advantages. We prevent our users from seeing a traceback, and we let the program continue analyzing the texts it’s able to find. If we don’t catch the `FileNotFoundError` that *siddhartha.txt* raises, the user would see a full traceback, and the program would stop running after trying to analyze *Siddhartha*. It would never analyze *Moby Dick* or *Little Women*.    ### Failing Silently    In the previous example, we informed our users that one of the files was unavailable. But you don’t need to report every exception you catch. Sometimes, you’ll want the program to fail silently when an exception occurs and continue on as if nothing happened. To make a program fail silently, you write a `try` block as usual, but you explicitly tell Python to do nothing in the `except` block. Python has a `pass` statement that tells it to do nothing in a block:    ```", "```py    The only difference between this listing and the previous one is the `pass` statement in the `except` block. Now when a `FileNotFoundError` is raised, the code in the `except` block runs, but nothing happens. No traceback is produced, and there’s no output in response to the error that was raised. Users see the word counts for each file that exists, but they don’t see any indication that a file wasn’t found:    ```", "```py    The `pass` statement also acts as a placeholder. It’s a reminder that you’re choosing to do nothing at a specific point in your program’s execution and that you might want to do something there later. For example, in this program we might decide to write any missing filenames to a file called *missing_files.txt*. Our users wouldn’t see this file, but we’d be able to read the file and deal with any missing texts.    ### Deciding Which Errors to Report    How do you know when to report an error to your users and when to let your program fail silently? If users know which texts are supposed to be analyzed, they might appreciate a message informing them why some texts were not analyzed. If users expect to see some results but don’t know which books are supposed to be analyzed, they might not need to know that some texts were unavailable. Giving users information they aren’t looking for can decrease the usability of your program. Python’s error-handling structures give you fine-grained control over how much to share with users when things go wrong; it’s up to you to decide how much information to share.    Well-written, properly tested code is not very prone to internal errors, such as syntax or logical errors. But every time your program depends on something external such as user input, the existence of a file, or the availability of a network connection, there is a possibility of an exception being raised. A little experience will help you know where to include exception-handling blocks in your program and how much to report to users about errors that arise.    ## Storing Data    Many of your programs will ask users to input certain kinds of information. You might allow users to store preferences in a game or provide data for a visualization. Whatever the focus of your program is, you’ll store the information users provide in data structures such as lists and dictionaries. When users close a program, you’ll almost always want to save the information they entered. A simple way to do this involves storing your data using the `json` module.    The `json` module allows you to convert simple Python data structures into JSON-formatted strings, and then load the data from that file the next time the program runs. You can also use `json` to share data between different Python programs. Even better, the JSON data format is not specific to Python, so you can share data you store in the JSON format with people who work in many other programming languages. It’s a useful and portable format, and it’s easy to learn.    ### Using json.dumps() and json.loads()    Let’s write a short program that stores a set of numbers and another program that reads these numbers back into memory. The first program will use `json.dumps()` to store the set of numbers, and the second program will use `json.loads()`.    The `json.dumps()` function takes one argument: a piece of data that should be converted to the JSON format. The function returns a string, which we can then write to a data file:    **number_writer.py**    ```", "```py    We first import the `json` module, and then create a list of numbers to work with. Then we choose a filename in which to store the list of numbers ❶. It’s customary to use the file extension *.json* to indicate that the data in the file is stored in the JSON format. Next, we use the `json.dumps()` ❷ function to generate a string containing the JSON representation of the data we’re working with. Once we have this string, we write it to the file using the same `write_text()` method we used earlier.    This program has no output, but let’s open the file *numbers.json* and look at it. The data is stored in a format that looks just like Python:    ```", "```py    Now we’ll write a separate program that uses `json.loads()` to read the list back into memory:    **number_reader.py**    ```", "```py    We make sure to read from the same file we wrote to ❶. Since the data file is just a text file with specific formatting, we can read it with the `read_text()` method ❷. We then pass the contents of the file to `json.loads()` ❸. This function takes in a JSON-formatted string and returns a Python object (in this case, a list), which we assign to `numbers`. Finally, we print the recovered list of numbers and see that it’s the same list created in *number_writer.py*:    ```", "```py    This is a simple way to share data between two programs.    ### Saving and Reading User-Generated Data    Saving data with `json` is useful when you’re working with user-generated data, because if you don’t store your user’s information somehow, you’ll lose it when the program stops running. Let’s look at an example where we prompt the user for their name the first time they run a program and then remember their name when they run the program again.    Let’s start by storing the user’s name:    **remember_me.py**    ```", "```py    We first prompt for a username to store ❶. Next, we write the data we just collected to a file called *username.json* ❷. Then we print a message informing the user that we’ve stored their information ❸:    ```", "```py    Now let’s write a new program that greets a user whose name has already been stored:    **greet_user.py**    ```", "```py    We read the contents of the data file ❶ and then use `json.loads()` to assign the recovered data to the variable `username` ❷. Since we’ve recovered the username, we can welcome the user back with a personalized greeting:    ```", "```py    We need to combine these two programs into one file. When someone runs *remember_me.py*, we want to retrieve their username from memory if possible; if not, we’ll prompt for a username and store it in *username.json* for next time. We could write a `try`-`except` block here to respond appropriately if *username.json* doesn’t exist, but instead we’ll use a handy method from the `pathlib` module:    **remember_me.py**    ```", "```py    There are many helpful methods you can use with `Path` objects. The `exists()` method returns `True` if a file or folder exists and `False` if it doesn’t. Here we use `path.exists()` to find out if a username has already been stored ❶. If *username.json* exists, we load the username and print a personalized greeting to the user.    If the file *username.json* doesn’t exist ❷, we prompt for a username and store the value that the user enters. We also print the familiar message that we’ll remember them when they come back.    Whichever block executes, the result is a username and an appropriate greeting. If this is the first time the program runs, this is the output:    ```", "```py    Otherwise:    ```", "```py    This is the output you see if the program was already run at least once. Even though the data in this section is just a single string, the program would work just as well with any data that can be converted to a JSON-formatted string.    ### Refactoring    Often, you’ll come to a point where your code will work, but you’ll recognize that you could improve the code by breaking it up into a series of functions that have specific jobs. This process is called *refactoring*. Refactoring makes your code cleaner, easier to understand, and easier to extend.    We can refactor *remember_me.py* by moving the bulk of its logic into one or more functions. The focus of *remember_me.py* is on greeting the user, so let’s move all of our existing code into a function called `greet_user()`:    **remember_me.py**    ```", "```py    Because we’re using a function now, we rewrite the comments as a docstring that reflects how the program currently works ❶. This file is a little cleaner, but the function `greet_user()` is doing more than just greeting the user—it’s also retrieving a stored username if one exists and prompting for a new username if one doesn’t.    Let’s refactor `greet_user()` so it’s not doing so many different tasks. We’ll start by moving the code for retrieving a stored username to a separate function:    ```", "```py    The new function `get_stored_username()` ❶ has a clear purpose, as stated in the docstring. This function retrieves a stored username and returns the username if it finds one. If the path that’s passed to `get_stored_username()` doesn’t exist, the function returns `None` ❷. This is good practice: a function should either return the value you’re expecting, or it should return `None`. This allows us to perform a simple test with the return value of the function. We print a welcome back message to the user if the attempt to retrieve a username is successful ❸, and if it isn’t, we prompt for a new username.    We should factor one more block of code out of `greet_user()`. If the username doesn’t exist, we should move the code that prompts for a new username to a function dedicated to that purpose:    ```", "```py    Each function in this final version of *remember_me.py* has a single, clear purpose. We call `greet_user()`, and that function prints an appropriate message: it either welcomes back an existing user or greets a new user. It does this by calling `get_stored_username()` ❶, which is responsible only for retrieving a stored username if one exists. Finally, if necessary, `greet_user()` calls `get_new_username()`❷, which is responsible only for getting a new username and storing it. This compartmentalization of work is an essential part of writing clear code that will be easy to maintain and extend.    ## Summary    In this chapter, you learned how to work with files. You learned to read the entire contents of a file, and then work through the contents one line at a time if you need to. You learned to write as much text as you want to a file. You also read about exceptions and how to handle the exceptions you’re likely to see in your programs. Finally, you learned how to store Python data structures so you can save information your users provide, preventing them from having to start over each time they run a program.    In Chapter 11, you’ll learn efficient ways to test your code. This will help you trust that the code you develop is correct, and it will help you identify bugs that are introduced as you continue to build on the programs you’ve written.    # 11 Testing Your Code  ![](Images/chapterart.png)  When you write a function or a class, you can also write tests for that code. Testing proves that your code works as it’s supposed to in response to all the kinds of input it’s designed to receive. When you write tests, you can be confident that your code will work correctly as more people begin to use your programs. You’ll also be able to test new code as you add it, to make sure your changes don’t break your program’s existing behavior. Every programmer makes mistakes, so every programmer must test their code often, to catch problems before users encounter them.    In this chapter, you’ll learn to test your code using `pytest`. The `pytest` library is a collection of tools that will help you write your first tests quickly and simply, while supporting your tests as they grow in complexity along with your projects. Python doesn’t include `pytest` by default, so you’ll learn to install external libraries. Knowing how to install external libraries will make a wide variety of well-designed code available to you. These libraries will expand the kinds of projects you can work on immensely.    You’ll learn to build a series of tests and check that each set of inputs results in the output you want. You’ll see what a passing test looks like and what a failing test looks like, and you’ll learn how a failing test can help you improve your code. You’ll learn to test functions and classes, and you’ll start to understand how many tests to write for a project.    ## Installing pytest with pip    While Python includes a lot of functionality in the standard library, Python developers also depend heavily on third-party packages. A *third-party package* is a library that’s developed outside the core Python language. Some popular third-party libraries are eventually adopted into the standard library, and end up being included in most Python installations from that point forward. This happens most often with libraries that are unlikely to change much once they’ve had their initial bugs worked out. These kinds of libraries can evolve at the same pace as the overall language.    Many packages, however, are kept out of the standard library so they can be developed on a timeline independent of the language itself. These packages tend to be updated more frequently than they would be if they were tied to Python’s development schedule. This is true of `pytest` and most of the libraries we’ll use in the second half of this book. You shouldn’t blindly trust every third-party package, but you also shouldn’t be put off by the fact that a lot of important functionality is implemented through such packages.    ### Updating pip    Python includes a tool called pip that’s used to install third-party packages. Because pip helps install packages from external resources, it’s updated often to address potential security issues. So, we’ll start by updating pip.    Open a new terminal window and issue the following command:    ```", "```py    The first part of this command, `python -m pip`, tells Python to run the module `pip`. The second part, `install --upgrade`, tells pip to update a package that’s already been installed. The last part, `pip`, specifies which third-party package should be updated. The output shows that my current version of pip, version 22.0.4 ❶, was replaced by the latest version at the time of this writing, 22.1.2 ❷.    You can use this command to update any third-party package installed on your system:    ```", "```py    ### Installing pytest    Now that pip is up to date, we can install `pytest`:    ```", "```py    We’re still using the core command `pip install`, without the `--upgrade` flag this time. Instead, we’re using the `--user` flag, which tells Python to install this package for the current user only. The output shows that the latest version of `pytest` was successfully installed, along with a number of other packages that `pytest` depends on.    You can use this command to install many third-party packages:    ```", "```py    ## Testing a Function    To learn about testing, we need code to test. Here’s a simple function that takes in a first and last name, and returns a neatly formatted full name:    **name_function.py**    ```", "```py    The function `get_formatted_name()` combines the first and last name with a space in between to complete a full name, and then capitalizes and returns the full name. To check that `get_formatted_name()` works, let’s make a program that uses this function. The program *names.py* lets users enter a first and last name, and see a neatly formatted full name:    **names.py**    ```", "```py    This program imports `get_formatted_name()` from *name_function.py*. The user can enter a series of first and last names and see the formatted full names that are generated:    ```", "```py    We can see that the names generated here are correct. But say we want to modify `get_formatted_name()` so it can also handle middle names. As we do so, we want to make sure we don’t break the way the function handles names that have only a first and last name. We could test our code by running *names.py* and entering a name like `Janis Joplin` every time we modify `get_formatted_name()`, but that would become tedious. Fortunately, `pytest` provides an efficient way to automate the testing of a function’s output. If we automate the testing of `get_formatted_name()`, we can always be confident that the function will work when given the kinds of names we’ve written tests for.    ### Unit Tests and Test Cases    There is a wide variety of approaches to testing software. One of the simplest kinds of test is a unit test. A *unit test* verifies that one specific aspect of a function’s behavior is correct. A *test case* is a collection of unit tests that together prove that a function behaves as it’s supposed to, within the full range of situations you expect it to handle.    A good test case considers all the possible kinds of input a function could receive and includes tests to represent each of these situations. A test case with *full coverage* includes a full range of unit tests covering all the possible ways you can use a function. Achieving full coverage on a large project can be daunting. It’s often good enough to write tests for your code’s critical behaviors and then aim for full coverage only if the project starts to see widespread use.    ### A Passing Test    With `pytest`, writing your first unit test is pretty straightforward. We’ll write a single test function. The test function will call the function we’re testing, and we’ll make an assertion about the value that’s returned. If our assertion is correct, the test will pass; if the assertion is incorrect, the test will fail.    Here’s the first test of the function `get_formatted_name()`:    **test_name_function.py**    ```", "```py    Before we run the test, let’s take a closer look at this function. The name of a test file is important; it must start with *test_*. When we ask `pytest` to run the tests we’ve written, it will look for any file that begins with *test_*, and run all of the tests it finds in that file.    In the test file, we first import the function that we want to test: `get_formatted_name()`. Then we define a test function: in this case, `test_first_last_name()` ❶. This is a longer function name than we’ve been using, for a good reason. First, test functions need to start with the word *test*, followed by an underscore. Any function that starts with `test_` will be *discovered* by `pytest`, and will be run as part of the testing process.    Also, test names should be longer and more descriptive than a typical function name. You’ll never call the function yourself; `pytest` will find the function and run it for you. Test function names should be long enough that if you see the function name in a test report, you’ll have a good sense of what behavior was being tested.    Next, we call the function we’re testing ❷. Here we call `get_formatted_name()` with the arguments `'janis'` and `'joplin'`, just like we used when we ran *names.py*. We assign the return value of this function to `formatted_name`.    Finally, we make an assertion ❸. An *assertion* is a claim about a condition. Here we’re claiming that the value of `formatted_name` should be `'Janis Joplin'`.    ### Running a Test    If you run the file *test_name_function.py* directly, you won’t get any output because we never called the test function. Instead, we’ll have `pytest` run the test file for us.    To do this, open a terminal window and navigate to the folder that contains the test file. If you’re using VS Code, you can open the folder containing the test file and use the terminal that’s embedded in the editor window. In the terminal window, enter the command `pytest`. Here’s what you should see:    ```", "```py    Let’s try to make sense of this output. First of all, we see some information about the system the test is running on ❶. I’m testing this on a macOS system, so you may see some different output here. Most importantly, we can see which versions of Python, `pytest`, and other packages are being used to run the test.    Next, we see the directory where the test is being run from ❷: in my case, *python_work/chapter_11*. We can see that `pytest` found one test to run ❸, and we can see the test file that’s being run ❹. The single dot after the name of the file tells us that a single test passed, and the `100%` makes it clear that all of the tests have been run. A large project can have hundreds or thousands of tests, and the dots and percentage-complete indicator can be helpful in monitoring the overall progress of the test run.    The last line tells us that one test passed, and it took less than 0.01 seconds to run the test.    This output indicates that the function `get_formatted_name()` will always work for names that have a first and last name, unless we modify the function. When we modify `get_formatted_name()`, we can run this test again. If the test passes, we know the function will still work for names like Janis Joplin.    ### A Failing Test    What does a failing test look like? Let’s modify `get_formatted_name()` so it can handle middle names, but let’s do so in a way that breaks the function for names with just a first and last name, like Janis Joplin.    Here’s a new version of `get_formatted_name()` that requires a middle name argument:    **name_function.py**    ```", "```py    This version should work for people with middle names, but when we test it, we see that we’ve broken the function for people with just a first and last name.    This time, running `pytest` gives the following output:    ```", "```py    There’s a lot of information here because there’s a lot you might need to know when a test fails. The first item of note in the output is a single `F` ❶, which tells us that one test failed. We then see a section that focuses on `FAILURES` ❷, because failed tests are usually the most important thing to focus on in a test run. Next, we see that `test_first_last_name()` was the test function that failed ❸. An angle bracket ❹ indicates the line of code that caused the test to fail. The `E` on the next line ❺ shows the actual error that caused the failure: a `TypeError` due to a missing required positional argument, `last`. The most important information is repeated in a shorter summary at the end, so when you’re running many tests, you can get a quick sense of which tests failed and why.    ### Responding to a Failed Test    What do you do when a test fails? Assuming you’re checking the right conditions, a passing test means the function is behaving correctly and a failing test means there’s an error in the new code you wrote. So when a test fails, don’t change the test. If you do, your tests might pass, but any code that calls your function like the test does will suddenly stop working. Instead, fix the code that’s causing the test to fail. Examine the changes you just made to the function, and figure out how those changes broke the desired behavior.    In this case, `get_formatted_name()` used to require only two parameters: a first name and a last name. Now it requires a first name, middle name, and last name. The addition of that mandatory middle name parameter broke the original behavior of `get_formatted_name()`. The best option here is to make the middle name optional. Once we do, our test for names like `Janis Joplin` should pass again, and we should be able to accept middle names as well. Let’s modify `get_formatted_name()` so middle names are optional and then run the test case again. If it passes, we’ll move on to making sure the function handles middle names properly.    To make middle names optional, we move the parameter `middle` to the end of the parameter list in the function definition and give it an empty default value. We also add an `if` test that builds the full name properly, depending on whether a middle name is provided:    **name_function.py**    ```", "```py    In this new version of `get_formatted_name()`, the middle name is optional. If a middle name is passed to the function, the full name will contain a first, middle, and last name. Otherwise, the full name will consist of just a first and last name. Now the function should work for both kinds of names. To find out if the function still works for names like `Janis Joplin`, let’s run the test again:    ```", "```py    The test passes now. This is ideal; it means the function works for names like `Janis Joplin` again, without us having to test the function manually. Fixing our function was easier because the failed test helped us identify how the new code broke existing behavior.    ### Adding New Tests    Now that we know `get_formatted_name()` works for simple names again, let’s write a second test for people who include a middle name. We do this by adding another test function to the file *test_name_function.py*:    **test_name_function.py**    ```", "```py    We name this new function `test_first_last_middle_name()`. The function name must start with `test_` so the function runs automatically when we run `pytest`. We name the function to make it clear which behavior of `get_formatted_name()` we’re testing. As a result, if the test fails, we’ll know right away what kinds of names are affected.    To test the function, we call `get_formatted_name()` with a first, last, and middle name ❶, and then we make an assertion ❷ that the returned full name matches the full name (first, middle, and last) that we expect. When we run `pytest` again, both tests pass:    ```", "```py    The two dots ❶ indicate that two tests passed, which is also clear from the last line of output. This is great! We now know that the function still works for names like `Janis Joplin`, and we can be confident that it will work for names like `Wolfgang Amadeus Mozart` as well.    ## Testing a Class    In the first part of this chapter, you wrote tests for a single function. Now you’ll write tests for a class. You’ll use classes in many of your own programs, so it’s helpful to be able to prove that your classes work correctly. If you have passing tests for a class you’re working on, you can be confident that improvements you make to the class won’t accidentally break its current behavior.    ### A Variety of Assertions    So far, you’ve seen just one kind of assertion: a claim that a string has a specific value. When writing a test, you can make any claim that can be expressed as a conditional statement. If the condition is `True` as expected, your assumption about how that part of your program behaves will be confirmed; you can be confident that no errors exist. If the condition you assume is `True` is actually `False`, the test will fail and you’ll know there’s an issue to resolve. [Table 11-1](#table11-1) shows some of the most useful kinds of assertions you can include in your initial tests.      Table 11-1: Commonly Used Assertion Statements in Tests       | **Assertion** | **Claim** | | --- | --- | | `assert a == b` | Assert that two values are equal. | | `assert a != b` | Assert that two values are not equal. | | `assert a` | Assert that `a` evaluates to `True`. | | `assert not a` | Assert that `a` evaluates to `False`. | | `assert` `element` `in` `list` | Assert that an element is in a list. | | `assert` `element` `not in` `list` | Assert that an element is not in a list. |    These are just a few examples; anything that can be expressed as a conditional statement can be included in a test.    ### A Class to Test    Testing a class is similar to testing a function, because much of the work involves testing the behavior of the methods in the class. However, there are a few differences, so let’s write a class to test. Consider a class that helps administer anonymous surveys:    **survey.py**    ```", "```py    This class starts with a survey question that you provide ❶ and includes an empty list to store responses. The class has methods to print the survey question ❷, add a new response to the response list ❸, and print all the responses stored in the list ❹. To create an instance from this class, all you have to provide is a question. Once you have an instance representing a particular survey, you display the survey question with `show_question()`, store a response using `store_response()`, and show results with `show_results()`.    To show that the `AnonymousSurvey` class works, let’s write a program that uses the class:    **language_survey.py**    ```", "```py    This program defines a question (`\"What language did you first learn to speak?\"`) and creates an `AnonymousSurvey` object with that question. The program calls `show_question()` to display the question and then prompts for responses. Each response is stored as it is received. When all responses have been entered (the user inputs `q` to quit), `show_results()` prints the survey results:    ```", "```py    This class works for a simple anonymous survey, but say we want to improve `AnonymousSurvey` and the module it’s in, `survey`. We could allow each user to enter more than one response, we could write a method to list only unique responses and to report how many times each response was given, or we could even write another class to manage non-anonymous surveys.    Implementing such changes would risk affecting the current behavior of the class `AnonymousSurvey`. For example, it’s possible that while trying to allow each user to enter multiple responses, we could accidentally change how single responses are handled. To ensure we don’t break existing behavior as we develop this module, we can write tests for the class.    ### Testing the AnonymousSurvey Class    Let’s write a test that verifies one aspect of the way `AnonymousSurvey` behaves. We’ll write a test to verify that a single response to the survey question is stored properly:    **test_survey.py**    ```", "```py    We start by importing the class we want to test, `AnonymousSurvey`. The first test function will verify that when we store a response to the survey question, the response will end up in the survey’s list of responses. A good descriptive name for this function is `test_store_single_response()` ❶. If this test fails, we’ll know from the function name in the test summary that there was a problem storing a single response to the survey.    To test the behavior of a class, we need to make an instance of the class. We create an instance called `language_survey` ❷ with the question `\"What language did you first learn to speak?\"` We store a single response, `English`, using the `store_response()` method. Then we verify that the response was stored correctly by asserting that `English` is in the list `language_survey.responses` ❸.    By default, running the command `pytest` with no arguments will run all the tests that `pytest` discovers in the current directory. To focus on the tests in one file, pass the name of the test file you want to run. Here we’ll run just the one test we wrote for `AnonymousSurvey`:    ```", "```py    This is a good start, but a survey is useful only if it generates more than one response. Let’s verify that three responses can be stored correctly. To do this, we add another method to `TestAnonymousSurvey`:    ```", "```py    We call the new function `test_store_three_responses()`. We create a survey object just like we did in `test_store_single_response()`. We define a list containing three different responses ❶, and then we call `store_response()` for each of these responses. Once the responses have been stored, we write another loop and assert that each response is now in `language_survey.responses` ❷.    When we run the test file again, both tests (for a single response and for three responses) pass:    ```", "```py    This works perfectly. However, these tests are a bit repetitive, so we’ll use another feature of `pytest` to make them more efficient.    ### Using Fixtures    In *test_survey.py*, we created a new instance of `AnonymousSurvey` in each test function. This is fine in the short example we’re working with, but in a real-world project with tens or hundreds of tests, this would be problematic.    In testing, a *fixture* helps set up a test environment. Often, this means creating a resource that’s used by more than one test. We create a fixture in `pytest` by writing a function with the decorator `@pytest.fixture`. A *decorator* is a directive placed just before a function definition; Python applies this directive to the function before it runs, to alter how the function code behaves. Don’t worry if this sounds complicated; you can start to use decorators from third-party packages before learning to write them yourself.    Let’s use a fixture to create a single survey instance that can be used in both test functions in *test_survey.py*:    ```", "```py    We need to import `pytest` now, because we’re using a decorator that’s defined in `pytest`. We apply the `@pytest.fixture` decorator ❶ to the new function `language_survey()` ❷. This function builds an `AnonymousSurvey` object and returns the new survey.    Notice that the definitions of both test functions have changed ❸ ❺; each test function now has a parameter called `language_survey`. When a parameter in a test function matches the name of a function with the `@pytest.fixture` decorator, the fixture will be run automatically and the return value will be passed to the test function. In this example, the function `language_survey()` supplies both `test_store_single_response()` and `test_store_three_responses()` with a `language_survey` instance.    There’s no new code in either of the test functions, but notice that two lines have been removed from each function ❹ ❻: the line that defined a question and the line that created an `AnonymousSurvey` object.    When we run the test file again, both tests still pass. These tests would be particularly useful when trying to expand `AnonymousSurvey` to handle multiple responses for each person. After modifying the code to accept multiple responses, you could run these tests and make sure you haven’t affected the ability to store a single response or a series of individual responses.    The structure above will almost certainly look complicated; it contains some of the most abstract code you’ve seen so far. You don’t need to use fixtures right away; it’s better to write tests that have a lot of repetitive code than to write no tests at all. Just know that when you’ve written enough tests that the repetition is getting in the way, there’s a well-established way to deal with the repetition. Also, fixtures in simple examples like this one don’t really make the code any shorter or simpler to follow. But in projects with many tests, or in situations where it takes many lines to build a resource that’s used in multiple tests, fixtures can drastically improve your test code.    When you want to write a fixture, write a function that generates the resource that’s used by multiple test functions. Add the `@pytest.fixture` decorator to the new function, and add the name of this function as a parameter for each test function that uses this resource. Your tests will be shorter and easier to write and maintain from that point forward.    ## Summary    In this chapter, you learned to write tests for functions and classes using tools in the `pytest` module. You learned to write test functions that verify specific behaviors your functions and classes should exhibit. You saw how fixtures can be used to efficiently create resources that can be used in multiple test functions in a test file.    Testing is an important topic that many newer programmers aren’t exposed to. You don’t have to write tests for all the simple projects you try as a new programmer. But as soon as you start to work on projects that involve significant development effort, you should test the critical behaviors of your functions and classes. You’ll be more confident that new work on your project won’t break the parts that work, and this will give you the freedom to make improvements to your code. If you accidentally break existing functionality, you’ll know right away, so you can still fix the problem easily. Responding to a failed test that you ran is much easier than responding to a bug report from an unhappy user.    Other programmers will respect your projects more if you include some initial tests. They’ll feel more comfortable experimenting with your code and be more willing to work with you on projects. If you want to contribute to a project that other programmers are working on, you’ll be expected to show that your code passes existing tests and you’ll usually be expected to write tests for any new behavior you introduce to the project.    Play around with tests to become familiar with the process of testing your code. Write tests for the most critical behaviors of your functions and classes, but don’t aim for full coverage in early projects unless you have a specific reason to do so.```"]