- en: '1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GETTING STARTED
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Programming involves writing code to solve a problem. As such, I want to solve
    problems with you from the outset. That is, rather than learning Python concept
    by concept and then solving a problem, we’re going to use a problem to dictate
    the concepts we need to learn.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll solve two problems: determining the number of words
    in a line (like the word-count feature in a word processor) and calculating the
    volume of a cone. Solving these problems requires a tour of quite a few Python
    concepts. You may feel that you need more details to fully understand some of
    what I introduce here and how it all fits together in the design of a Python program.
    Don’t worry: we’ll revisit and elaborate on the most important concepts in later
    chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: What We’ll Be Doing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As described in the introduction, we’ll be solving competitive programming problems
    using the Python programming language. The competitive programming problems can
    each be found on an online judge website. I assume that you’ve followed the instructions
    in the introduction to install Python and make your judge accounts.
  prefs: []
  type: TYPE_NORMAL
- en: For each problem, we’ll write a program to solve it. Each problem specifies
    the kind of *input* that our program will be provided, and the kind of *output*
    (or result) that is expected. Our program correctly solves the problem if it can
    take any valid input and produce the correct output.
  prefs: []
  type: TYPE_NORMAL
- en: In general, there will be millions or billions of possible inputs. Each such
    input is referred to as a *problem instance*. For example, in the first problem
    that we’ll solve, the input is a line of text, like `hello there` or `bbaabbb
    aa abab`. Our task will be to output the number of words in the line. One of the
    most powerful ideas in programming is that often a small amount of general-purpose
    code can solve a seemingly endless number of problem instances. Whether the line
    has 2 words or 3 or 50, it won’t matter. Our program will get it right every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our programs will perform three tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read input** We need to determine the specific instance of the problem that
    we’re solving, so we first read the provided input.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process** We process the input to determine the correct output.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write output** Having solved the problem, we produce the desired output.'
  prefs: []
  type: TYPE_NORMAL
- en: The boundaries between these steps may not always be crisp—we might have to
    interleave some processing with producing some output, for example—but it will
    be helpful to keep these three broad steps in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'You likely use programs on a daily basis that follow this input-process-output
    model. Consider a calculator program: you type in a formula (the input), the program
    crunches your numbers (process), and the program displays the answer (output).
    Or consider a web search engine: you type in a search query (input), the search
    engine determines the most relevant results (process), and it displays them (output).'
  prefs: []
  type: TYPE_NORMAL
- en: Contrast these kinds of programs with *interactive* programs, which fuse input,
    processing, and output. For example, I’m typing this book using a text editor.
    When I type a character, the editor responds by adding that character to my document.
    It doesn’t wait for me to type the entire document before displaying it to me;
    it interactively displays it as I build it. We won’t be writing interactive programs
    in this book. If you’re interested in writing such programs after studying this
    book, you’ll be happy to hear that Python is certainly up for the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text for each problem is found both here and on the online judge. However,
    the text won’t match, because I’ve rewritten it for purposes of consistency throughout
    the book. Don’t worry: what I’ve written conveys the same information as the official
    problem statement.'
  prefs: []
  type: TYPE_NORMAL
- en: The Python Shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For each problem in the book, we want to write a program and save it in a file.
    But that assumes we know what program to write! For many of the problems in the
    book, we’ll need to learn some new Python features before we can solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to experiment with Python features is by using the Python shell.
    It’s an interactive environment where you type some Python code and press ENTER,
    and Python shows you the result. Once we learn enough to solve the current problem,
    we’ll stop using the shell and start typing our solution in a text file instead.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, create a new folder on your desktop called *programming*. We’ll use
    that folder to store all of the work that we do for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’ll navigate to this *programming* folder and launch the Python shell.
    Follow these steps for your operating system whenever you’d like to start the
    Python shell.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Windows, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Hold down SHIFT and right-click your **programming** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the resulting menu, click **Open PowerShell window here**. If that choice
    isn’t there, click **Open command window here**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the resulting window, you’ll see a line that ends with a greater-than
    sign (`>`). This is your operating system *prompt*, and it’s waiting for you to
    type a command. You type operating system commands here, *not* Python code. Be
    sure to press ENTER after each command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’re now in your *programming* folder. You can type dir (for *directory*)
    if you’d like to see what’s there. You shouldn’t see any files yet, because we
    haven’t created any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, enter python to start the Python shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you start the Python shell, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of this window, you’ll see a `>>>` Python prompt. This is where
    you type Python code. Never type the `>>>` symbols yourself. Once you’re done
    programming, you can press CTRL-Z and then press ENTER to quit.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On macOS, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Terminal. You can do that by pressing COMMAND-spacebar, typing **terminal**,
    and then double-clicking the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the resulting window, you’ll see a line that ends with a dollar symbol (`$`).
    This is your operating system *prompt*, and it’s waiting for you to type a command.
    You type operating system commands here, *not* Python code. Be sure to press ENTER
    after each command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can enter the ls command to obtain a list of what’s in the current folder.
    Your *Desktop* should be listed there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter cd Desktop to navigate to your *Desktop* folder. The cd command stands
    for *change directory*; *directory* is another name for folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter cd programming to navigate to your *programming* folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, enter python3 to start the Python shell. (You could also try entering `python`,
    without the `3`, but that might start up an older version of Python 2\. Python
    2 is not suitable for working through this book.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you start the Python shell, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of this window, you’ll see a `>>>` Python prompt. This is where
    you type Python code. Never type the `>>>` symbols yourself. Once you’re done
    programming, you can press CTRL-D to quit.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Linux, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click your *programming* folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the resulting menu, click *Open in Terminal*. (You can also open the terminal
    and navigate to your *programming* folder if you’re more comfortable with that.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the resulting window, you’ll see a line that ends with a dollar
    sign (`$`). This is your operating system *prompt*, and it’s waiting for you to
    type a command. You type operating system commands here, *not* Python code. Be
    sure to press ENTER after each command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’re now in your *programming* folder. You can type `ls` if you’d like to
    see what’s there. You shouldn’t see any files yet, because we haven’t created
    any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, enter python3 to start the Python shell. (You could also try entering `python`,
    without the `3`, but that might start up an older version of Python 2\. Python
    2 is not suitable for working through this book.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you start the Python shell, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of this window, you’ll see a `>>>` Python prompt. This is where
    you type Python code. Never type the `>>>` symbols yourself. Once you’re done
    programming, you can press CTRL-D to quit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #1: Word Count'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it’s time for our first problem! We’re going to use Python to write a little
    word-count program. We’ll learn how to read input from the user, process the input
    to solve the problem, and output the result. We’ll also learn how to manipulate
    text and numbers in our programs, make use of built-in Python operations, and
    store intermediate results on our way to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `dmopc15c7p2`.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Count the number of words provided. For this problem, a *word* is any sequence
    of lowercase letters. For example, `hello` is a word, but so are non-English “words”
    like `bbaabbb`.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input is one line of text, consisting of lowercase letters and spaces. There
    is exactly one space between each pair of words, and there are no spaces before
    the first word or after the last word.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum length of the line is 80 characters.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the number of words in the input line.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Values* are a fundamental building block of Python programs. Each value has
    a *type*, and the type determines the operations that can be performed on the
    value. In the Word Count problem, we’re working with a line of text. Text is stored
    as a string value in Python, so we’ll need to learn about strings. To solve the
    problem, we output the number of words in the text, so we also need to learn about
    numeric values. Let’s begin with strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Representing Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *string* is the Python type that’s used to store and manipulate text. To
    write a string value, we place its characters between single quotes. Follow along
    in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Python shell echoes each string that I’ve typed.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when our string contains a single quote as one of its characters?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The single quote in the word `don't` terminates the string. The rest of the
    line, `t say that'`, therefore doesn’t make sense, and that’s what generates the
    syntax error. A *syntax error* means that we have violated the rules of Python
    and have not written valid Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we can take advantage of the fact that double quotes can also
    be used to delimit strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Unless the string in question has a single quote, I won’t use double quotes
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: String Operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use a string to hold the text whose words we want to count. To count
    the words—or to do anything else with strings—we need to learn how to work with
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings come with a rich variety of operations that we can perform. Some of
    them use special symbols between their operands. For example, the `+` operator
    is used for string concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops—we need a space between those two words. Let’s add one to the end of the
    first string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s also the `*` operator, which replicates a string a specified number
    of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That `30` there is an integer value. I’ll have more to say about integers shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A. `''''''`
  prefs: []
  type: TYPE_NORMAL
- en: B. `''`
  prefs: []
  type: TYPE_NORMAL
- en: C. This code produces a syntax error (invalid Python code)
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. `''''` is the empty string—a string of zero characters. Repeating
    an empty string three times is still an empty string!'
  prefs: []
  type: TYPE_NORMAL
- en: String Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *method* is an operation specific to a type of value. Strings have a large
    number of methods. For example, there’s a method called `upper`, which produces
    the uppercase version of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The information we get back from a method is known as the method’s *return value*.
    For example, we could say for the previous example that `upper` returned the string
    `'HELLO'`.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a method on a value is known as *calling* the method. Calling a method
    involves placing the *dot operator* (`.`) between the value and the method name.
    It also requires parentheses after the method name. For some methods, we leave
    those parentheses empty, as when calling `upper`.
  prefs: []
  type: TYPE_NORMAL
- en: For other methods, we can optionally include information there. Still other
    methods require information and won’t work at all without it. Information we include
    when calling a method is referred to as the method’s *arguments*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, strings have a `strip` method. If called with no arguments, `strip`
    removes all leading and trailing spaces from a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can also call it with a string as the argument. If we do, that argument
    determines which characters are stripped from the beginning and the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s talk about one more string method: `count`. We pass it a string argument,
    and it tells us how many occurrences of that argument are found in our string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If occurrences of the argument overlap, only the first counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the other methods I’ve described, `count` is directly useful to our Word
    Count problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of a string like `''this is a string with a few words''`. Notice that
    a space comes after each word. In fact, if you had to count the number of words
    by hand, you might use the spaces to tell you where each word ends. What if we
    count the number of spaces in a string? To do that, we can pass a string consisting
    of a single space character to `count`. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We get a value of `7`. That’s not quite the number of words—the string has eight
    words—but we’re close. Why are we getting `7` instead of `8`?
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that each word has a space after it except the last word. Counting
    the spaces therefore fails to account for the final word. To remedy that, we need
    to learn how to handle numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Integer and Floating-Point Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *expression* is made up of values and operators. We’ll now see how to write
    numeric values and combine them with operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different Python types that represent numbers: integers (with
    no decimal part) and floating-point numbers (with a decimal part).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We write integer values as numbers with no decimal point. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A value on its own is the simplest kind of expression.
  prefs: []
  type: TYPE_NORMAL
- en: The familiar mathematical operators work on integers. We have `+` for addition,
    `-` for subtraction, and `*` for multiplication. We can use these operators to
    write more complicated expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice the spaces around the operators. While `8+10` and `8 + 10` are the same
    as far as Python is concerned, the latter makes the expression easier for us humans
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has two division operators, not one! The `//` operator performs integer
    division, which throws away any remainder and rounds the result down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the remainder of the division, use the mod operator, written as
    `%`. For example, dividing 8 by 2 leaves no remainder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Dividing 8 by 3 leaves a remainder of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/` operator, in contrast to `//`, doesn’t do any rounding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These result values are not integers! They have a decimal point and belong
    to a different Python type called *float* (for “floating-point numbers”). You
    can write float values by including a decimal point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We’ll focus on integers for now and return to floating-point numbers when we
    solve Cone Volume later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use multiple operators in an expression, Python uses precedence rules
    to determine the order that operators are applied. Each operator has a precedence.
    Just like when we evaluate a mathematical expression on paper, Python performs
    multiplications and divisions (higher precedence) before additions and subtractions
    (lower precedence):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, like on paper, operations inside parentheses have the highest precedence.
    We can use this to force Python to perform operations in our desired order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Programmers often add parentheses even when not technically required. That’s
    because Python has many operators, as we’ll see, and keeping track of their precedence
    is error-prone and not something that programmers typically do.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re wondering whether integer values and float values have methods, just
    like strings, they do! But they aren’t all that useful. For example, there’s a
    method that tells us how much of the computer’s memory is taken up by an integer.
    The bigger the integer, the more memory it requires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We need the parentheses around the integers; otherwise, the dot operator gets
    confused with a decimal point, and we get a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now know how to write string and numeric values. We’ll also find it valuable
    to be able to store them so we can access them later. In Word Count, it would
    be convenient to be able to store the line of words somewhere and then count the
    number of words.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment Statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *variable* is a name that refers to a value. Whenever we later use a variable’s
    name, it gets substituted by what that variable refers to. To make a variable
    refer to a value, we use the *assignment statement*. An assignment statement consists
    of a variable, an equal sign (`=`), and an expression. Python evaluates the expression
    and makes the variable refer to the result. Here’s an example assignment statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `dollars` is substituted by `250` whenever we use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A variable refers to only one value at a time. Once we use an assignment statement
    to make a variable refer to another value, it no longer refers to the old value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have as many variables as we like. Large programs typically use hundreds
    of variables. Here’s an example of using two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I’ve chosen variable names that give some sense of what they’re
    storing. These two variables, for example, have to do with the prices of two purchases.
    Using variable names `p1` and `p2` would be easier to type, but in a few days
    we’d probably forget what the names mean!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make variables refer to strings, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As with variables that refer to numbers, we can use these in larger expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Python variable names should start with a lowercase letter and then can contain
    additional letters, underscores to separate words, and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Variable Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose we have a variable `dollars` that refers to value `250`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to increase the value so that `dollars` refers to 251\. This won’t
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is 251, but that value is gone, not stored anywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What we need is an assignment statement that captures the result of `dollars
    + 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It’s common for learners to think of the assignment symbol `=` as equality.
    But don’t do that! The assignment statement is a command to make a variable refer
    to the value of an expression, not a claim that two entities are equal.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the value of `y` after the execution of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: A. `39`
  prefs: []
  type: TYPE_NORMAL
- en: B. `22`
  prefs: []
  type: TYPE_NORMAL
- en: C. `35`
  prefs: []
  type: TYPE_NORMAL
- en: D. `20`
  prefs: []
  type: TYPE_NORMAL
- en: E. `18`
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. There’s only one assignment to `y`, and it makes `y` refer to the
    value `39`. The `x = 20` assignment statement changes what `x` refers to, from
    `37` to `20`, but this has no impact on the value referred to by `y`.'
  prefs: []
  type: TYPE_NORMAL
- en: Counting the Words Using a Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take stock of our progress toward solving the Word Count problem:'
  prefs: []
  type: TYPE_NORMAL
- en: We know about strings, and we can use a string to store the line of words.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know about the string `count` method, which we can use to count the number
    of spaces in the line of words. That gives us one less than the output value that
    we need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know about integers, whose `+` operator we can use to add `1` to a number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know about variables and the assignment statement, which help us hold on
    to values so that we don’t lose them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Putting all of this together, we can make a variable refer to a string and
    then count the number of words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `line` and `total_words` variables aren’t required here; here’s how we
    could do it without them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: But using variables to capture intermediate results is a good practice for keeping
    code readable. Once our programs get longer than a few lines, variables will be
    indispensable.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One problem with the code that we’ve written is that it works only on the particular
    string that we’ve typed in. It tells us that there are eight words in `'this is
    a string with a few words'`, but that’s all it can do. If we want to know how
    many words are in a different string, we’ll have to replace the current string
    with a new one. To solve Word Count, though, we need our program to work on *any*
    string provided as input to our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read a line of input, we use the `input` function. A *function* is similar
    to a method: we call it, perhaps with some arguments, and it returns a value to
    us. One difference between a method and a function is that a function does not
    use the dot operator. All information passed to functions is through arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of calling the `input` function and then typing some input—in
    this case, the word `testing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When you type `input()` and press ENTER, you don’t get a `>>>` prompt back.
    Instead, Python waits for you to type something on the keyboard and press ENTER.
    The `input` function then returns the string you typed. As usual, if we don’t
    store that string anywhere, then it’s lost. Let’s use an assignment statement
    to store what we type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the last line that I’ve used the `upper` method on the value returned
    by `input`. This is allowed because `input` returns a string, and `upper` is a
    string method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ve seen that typing expressions at the Python shell causes their values
    to be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s just a convenience provided by the Python shell. It assumes that if
    you type an expression, then you probably want to see its value. But when running
    a Python program outside of the Python shell, this convenience is gone. Instead,
    we must explicitly use the `print` function whenever we want to output something.
    The `print` function works from the shell, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice that strings output by `print` don’t have quotes around them. That’s
    good—we probably don’t want to include quotes when communicating with users of
    our programs anyway!
  prefs: []
  type: TYPE_NORMAL
- en: 'One nice feature of `print` is that you can supply as many arguments as you
    like, and they all get output with separating spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Solving the Problem: A Complete Python Program'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re now ready to solve Word Count by writing a complete Python program. Exit
    the Python shell and you’ll be back at your operating system command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a Text Editor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll use a text editor to write our code. Follow the steps for your operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: On Windows, we’ll use Notepad, a bare-bones text editor. At the operating system
    command prompt, navigate to your *programming* folder if you’re not already there.
    Then type notepad word_count.py and press ENTER. Since the *word_count.py* file
    doesn’t exist, Notepad will ask you whether you’d like to create a new *word_count.py*
    file. Click **Yes** and you’ll be ready to type your Python program.
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'On macOS, you can use whichever text editor you like. One editor that you likely
    already have installed is TextEdit. At the operating system command prompt, navigate
    to your *programming* folder if you’re not already there. Then type the following
    two commands, pressing ENTER after each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `touch` command creates an empty file so that your text editor can open
    it. Now you’re ready to type your Python program.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: On Linux, you can use whichever text editor you like. One editor that you likely
    already have installed is gedit. At the operating system command prompt, navigate
    to your *programming* folder if you’re not already there. Then type gedit word_count.py
    and press ENTER. Now you’re ready to type your Python program.
  prefs: []
  type: TYPE_NORMAL
- en: The Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With your text editor loaded, you can type the code of our Python program. The
    code is in [Listing 1-1](ch01.xhtml#ch01ex01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-1: Solving Word Count*'
  prefs: []
  type: TYPE_NORMAL
- en: When entering that code, don’t enter the ❶, ❷, or ❸. Those are there to help
    us walk through the code and are not part of the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by acquiring the line of text from the input and assigning it to a
    variable ❶. That gives us a string, on which we can use the `count` method. We
    add 1 to the count of spaces to account for the final word in the string, and
    we use the variable `total_words` to refer to that result ❷. The last thing to
    do is output the value referred to by `total_words` ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to save the file once you’ve finished typing the code.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run the program, we’ll use the `python` command from our operating system
    command prompt. As we’ve seen, entering `python` by itself runs the Python shell,
    but we don’t want that this time. Instead, we want to tell Python to run the program
    in *word_count.py*. To do that, navigate to your *programming* folder, and enter
    python word_count.py. Here and throughout the book, please use the `python3` command
    instead of the `python` command if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your program is now waiting at the `input` prompt for you to type something.
    Type a few words, press ENTER, and you should see our program working correctly.
    For example, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You should see the program produce `6` as the output.
  prefs: []
  type: TYPE_NORMAL
- en: If instead you see a Python error, go back over the code and make sure you’ve
    typed it in exactly. Python requires precision. Even a missing parenthesis or
    single quote will lead to an error.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be frustrated if it takes you some time to get this program to run. Getting
    a first program to run can require a lot of work. We have to be able to type a
    program into a file, invoke Python to run that program, and fix any errors resulting
    from an incorrect program. But the procedure for running programs doesn’t change,
    no matter how complex the program, so time you spend here will be well worth it
    as you work through the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting to the Judge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Congratulations! I hope it was satisfying to run your first Python program on
    your computer. But how do we know this program is correct? Does it work for all
    possible strings? We can test it on a few more strings, but the way we’ll gain
    even more confidence in the correctness of our code is by submitting it to the
    online judge. The judge automatically runs a bunch of tests on our code and tells
    us whether we passed the tests or if something is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Go to *[https://dmoj.ca/](https://dmoj.ca/)* and log in. (If you don’t have
    a DMOJ account, please create one following the instructions in the introduction.)
    Click **Problems**, and search for the Word Count problem code `dmopc15c7p2`.
    Click the search result to load the problem—it’s called Not a Wall of Text rather
    than Word Count.
  prefs: []
  type: TYPE_NORMAL
- en: You should then see the text of the problem, as written by the problem author.
    Click **Submit Solution**, and paste our code into the text area. Be sure to select
    Python 3 as the programming language. Finally, click the **Submit** button.
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ runs tests on our code and shows us the results. For each test case, you’ll
    see a status code. *AC* stands for *accepted* and is what you want to see for
    each test case. Other codes include *WA* (*wrong answer*) and *TLE* (*time limit
    exceeded*). If you see one of these, double-check the code that you pasted, making
    sure it exactly matches the code from your text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming all test cases are accepted, we should see that our score is 100/100
    and that we’ve earned 3 points for our work.
  prefs: []
  type: TYPE_NORMAL
- en: For each problem, we’ll follow the approach that we used to solve Word Count.
    First, we’ll explore using the Python shell, learning new Python features as needed.
    Then, we’ll write a program that solves the problem. We’ll test that program on
    our computer by supplying our own test cases. Finally, we’ll submit the code to
    the judge. If any test cases fail, we’ll look over our code again and fix the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #2: Cone Volume'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Word Count, we needed to read a string from the input. In this problem, we’ll
    need to read integers from the input. Doing so requires an extra step to produce
    an integer from a string. We’ll also learn a little more about doing math in Python.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `dmopc14c5p1`.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Calculate the volume of a right circular cone.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input consists of two lines of text. The first line contains integer *r*,
    the radius of the cone. The second line contains integer *h*, the height of the
    cone. Both *r* and *h* are between 1 and 100\. (That is, the minimum value for
    *r* and *h* is 1, and the maximum value is 100.)
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the volume of the right circular cone with radius *r* and height *h*.
    The formula to calculate the volume is (*πr*²*h*)/3.
  prefs: []
  type: TYPE_NORMAL
- en: More Math in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Say we have `r` and `h` variables referring to a radius and height, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now we want to evaluate (*πr*²*h*)/3\. Substituting a radius of `4` and height
    of `6`, we have (*π* * 4² * 6)/3\. Using a value of `3.14159` for *π*, a calculator
    gives a result of `100.531`. How can we do this in Python?
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Pi
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To access the value of *π*, we’ll use a suitable variable. Here’s an assignment
    statement to `PI` with a lot of accuracy in its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is more a *constant* than a variable, since we’ll never want to change
    the value of `PI` in our code. It’s Python convention to use uppercase letters
    for such variables, as I’ve done here.
  prefs: []
  type: TYPE_NORMAL
- en: Exponents
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Looking back at our formula, (*πr*²*h*)/3, the only thing we haven’t talked
    about yet is how to perform the *r*² part. Since *r*² is the same as *r* * *r*,
    we can use multiplication rather than exponentiation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'But it’s more transparent to use exponentiation directly. We always want to
    write code that’s as clear as possible. Besides, one day you might have to calculate
    larger exponents, where repeated multiplication becomes increasingly unwieldy.
    Python’s exponentiation operator is `**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the complete formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Great—that’s close to the `100.531` result we expected!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re producing a floating-point number here. As we discussed in
    “Integer and Floating-Point Numbers” in this chapter, the `/` division operator
    produces a floating-point result.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Between Strings and Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re ultimately going to have to read the radius and height as input. We’ll
    then use those values to calculate the volume. Let’s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `input` function always returns a string, even if the user types an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The single quotes confirm that these values are strings. Strings cannot be
    used to perform mathematical calculations. If we try, we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: A `TypeError` is generated when we use values of the wrong type. Python is objecting
    to us using the `**` operator on the string referred to by `r` and the integer
    `2`. The `**` operator is purely mathematical and has no meaning when used with
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert our strings to integers, we can use Python’s `int` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can once again use these values in our formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever you have a string whose characters represent an integer, you can use
    the `int` function to convert it to a value whose type is integer. It can cope
    with leading and trailing spaces, but not non-numeric characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When converting a string returned by `input` to an integer, we can take it
    in two steps, first assigning the return value of `input` to a variable and then
    converting that value to an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can combine the `input` and `int` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, the argument passed to `int` is the string returned by `input`. The `int`
    function takes this string and returns it as an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we ever need to convert the other way, from an integer to a string, we can
    do that with the `str` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We can’t concatenate a string and an integer. The `str` function returns `'82'`
    from `82` so that it can be used in a string concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re ready to solve Cone Volume. Create a text file called *cone_volume.py*
    and type the code in [Listing 1-2](ch01.xhtml#ch01ex02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-2: Solving Cone Volume*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included blank lines to separate the code into its logical pieces. Python
    ignores these blank lines, but such blank lines can make it easier for us to read
    and chunk the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that I’ve used descriptive variable names: `radius` instead of `r`,
    `height` instead of `h`, and `volume`. Single-letter variable names are the norm
    in math formulas, but when writing code, we can use variable names that convey
    more information.'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by making a variable called `PI` refer to an approximation of pi ❶.
    We then read the radius ❷ and height ❸ from the input, converting both from strings
    to integers. We use the formula for the volume of a right circular cone to compute
    the volume ❹. Lastly, we output the volume ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Save your *cone_volume.py* file.
  prefs: []
  type: TYPE_NORMAL
- en: Run your program by typing python cone_volume.py and then type a value for the
    radius and a value for the height. Use a calculator to verify that your program
    produces the correct output!
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if you type garbage for the radius or height? For example, run
    your program and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: It is not user-friendly at all, that’s for sure. But for purposes of learning
    to program, we won’t worry about this. All of the test cases on the judge will
    be valid according to the problem’s input specification, so we’ll never have to
    worry about what to do with invalid input.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of the judge, DMOJ owes us three points, because we’ve finished writing
    correct code for this problem. Go ahead and submit your work!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And we’re off! We’ve just solved our first two problems by writing Python code.
    We learned about the fundamentals of programming, including values, types, strings,
    integers, methods, variables, the assignment statement, and input and output.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re comfortable with this material—perhaps by working on some of the
    following exercises—it’s on to [Chapter 2](ch02.xhtml#ch02). There, we’ll learn
    how our programs can make decisions. We’ll no longer be writing programs that
    invariably run from top to bottom. They’ll be more flexible, doing what’s needed
    for the specific problem instance being solved.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each chapter ends with some exercises for you to try. I encourage you to complete
    as many exercises as you can.
  prefs: []
  type: TYPE_NORMAL
- en: Some exercises may take you a long time. You might get frustrated with repeated
    Python errors. Like with any skill worth learning, focused practice is needed.
    When you’re starting to work on an exercise, I recommend solving a few examples
    by hand. That way you know what the problem is asking and what your program is
    supposed to do. Otherwise, you might be writing code without a plan, contending
    both with organizing your thoughts and with writing the program at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your code isn’t working, ask: what, precisely, is the behavior that you
    want? What are the lines of code that are likely culprits for the error that you’re
    getting? Is there another, perhaps simpler, approach you could try?'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included solutions to the exercises on the book website (*[https://nostarch.com/learn-code-solving-problems/](https://nostarch.com/learn-code-solving-problems/)*).
    But don’t peek at those until you’ve given your chosen exercise an honest try.
    Or two. Or three. If you do look at a solution and learn how one might solve the
    problem, take a break and then try solving it yourself from scratch. There’s often
    more than one way to solve a problem. If your solution does the right thing but
    is different from mine, it doesn’t mean that one of us is wrong. Rather, it serves
    as an opportunity for you to compare your code to mine, perhaps learning alternate
    techniques in the process.
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem `wc16c1j1`, A Spooky Season
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `wc15c2j1`, A New Hope
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ccc13j1`, Next in Line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `wc17c1j2`, How’s the Weather? (Be careful with the direction of
    conversion!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem `wc18c3j1`, An Honest Day’s Work (Hint: how can you determine
    the number of bottle caps and the total paint required by those bottle caps?)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Word Count is originally from the DMOPC ’15 April Contest. Cone Volume is originally
    from the DMOPC ’14 March Contest.
  prefs: []
  type: TYPE_NORMAL
