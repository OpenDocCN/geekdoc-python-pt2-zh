- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: GETTING STARTED
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 入门指南
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: Programming involves writing code to solve a problem. As such, I want to solve
    problems with you from the outset. That is, rather than learning Python concept
    by concept and then solving a problem, we’re going to use a problem to dictate
    the concepts we need to learn.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编程涉及编写代码来解决问题。因此，我希望从一开始就和你一起解决问题。也就是说，我们不会一项一项地学习 Python 的概念再去解决问题，而是通过问题来指导我们需要学习的概念。
- en: 'In this chapter, we’ll solve two problems: determining the number of words
    in a line (like the word-count feature in a word processor) and calculating the
    volume of a cone. Solving these problems requires a tour of quite a few Python
    concepts. You may feel that you need more details to fully understand some of
    what I introduce here and how it all fits together in the design of a Python program.
    Don’t worry: we’ll revisit and elaborate on the most important concepts in later
    chapters.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将解决两个问题：确定一行中的单词数量（类似于文字处理软件中的字数统计功能）和计算圆锥的体积。解决这些问题需要我们遍历许多 Python
    概念。你可能觉得需要更多的细节才能完全理解我在这里介绍的一些内容，以及这些内容如何在 Python 程序设计中协同工作。别担心：我们将在后面的章节中回顾并详细讲解最重要的概念。
- en: What We’ll Be Doing
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们将做的事情
- en: As described in the introduction, we’ll be solving competitive programming problems
    using the Python programming language. The competitive programming problems can
    each be found on an online judge website. I assume that you’ve followed the instructions
    in the introduction to install Python and make your judge accounts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如引言中所述，我们将使用 Python 编程语言解决竞争性编程问题。这些竞争性编程问题可以在在线评测网站上找到。我假设你已经按照引言中的指示安装了 Python，并创建了评测账户。
- en: For each problem, we’ll write a program to solve it. Each problem specifies
    the kind of *input* that our program will be provided, and the kind of *output*
    (or result) that is expected. Our program correctly solves the problem if it can
    take any valid input and produce the correct output.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个问题，我们将编写一个程序来解决它。每个问题都指定了我们的程序将接受的*输入*类型，以及期望的*输出*（或结果）类型。如果我们的程序能够接受任何有效的输入并产生正确的输出，那么它就成功地解决了问题。
- en: In general, there will be millions or billions of possible inputs. Each such
    input is referred to as a *problem instance*. For example, in the first problem
    that we’ll solve, the input is a line of text, like `hello there` or `bbaabbb
    aa abab`. Our task will be to output the number of words in the line. One of the
    most powerful ideas in programming is that often a small amount of general-purpose
    code can solve a seemingly endless number of problem instances. Whether the line
    has 2 words or 3 or 50, it won’t matter. Our program will get it right every time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，会有数百万或数十亿种可能的输入。每种输入被称为一个*问题实例*。例如，在我们将要解决的第一个问题中，输入是一行文本，比如 `hello there`
    或 `bbaabbb aa abab`。我们的任务是输出这行文本中的单词数。在编程中，最强大的理念之一是，通常一小段通用代码可以解决看似无穷无尽的多种问题实例。无论这一行有
    2 个单词、3 个单词还是 50 个单词，程序都会每次都正确输出。
- en: 'Our programs will perform three tasks:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将执行三个任务：
- en: '**Read input** We need to determine the specific instance of the problem that
    we’re solving, so we first read the provided input.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**读取输入** 我们需要确定我们正在解决的问题的具体实例，因此我们首先读取提供的输入。'
- en: '**Process** We process the input to determine the correct output.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程** 我们处理输入以确定正确的输出。'
- en: '**Write output** Having solved the problem, we produce the desired output.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**写出输出** 解决问题后，我们产生所需的输出。'
- en: The boundaries between these steps may not always be crisp—we might have to
    interleave some processing with producing some output, for example—but it will
    be helpful to keep these three broad steps in mind.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤之间的界限可能并不总是那么明确——例如，我们可能需要将一些处理和输出结合起来——但记住这三个大致的步骤将非常有帮助。
- en: 'You likely use programs on a daily basis that follow this input-process-output
    model. Consider a calculator program: you type in a formula (the input), the program
    crunches your numbers (process), and the program displays the answer (output).
    Or consider a web search engine: you type in a search query (input), the search
    engine determines the most relevant results (process), and it displays them (output).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能每天都在使用遵循这种输入—处理—输出模型的程序。举个例子，一个计算器程序：你输入一个公式（输入），程序计算你的数字（处理），然后程序显示答案（输出）。或者考虑一个网页搜索引擎：你输入搜索查询（输入），搜索引擎确定最相关的结果（处理），然后显示它们（输出）。
- en: Contrast these kinds of programs with *interactive* programs, which fuse input,
    processing, and output. For example, I’m typing this book using a text editor.
    When I type a character, the editor responds by adding that character to my document.
    It doesn’t wait for me to type the entire document before displaying it to me;
    it interactively displays it as I build it. We won’t be writing interactive programs
    in this book. If you’re interested in writing such programs after studying this
    book, you’ll be happy to hear that Python is certainly up for the task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将这类程序与*交互式*程序进行对比，后者将输入、处理和输出融合在一起。例如，我正在使用文本编辑器编写本书。当我输入一个字符时，编辑器会响应并将该字符添加到我的文档中。它不会等我输入完整个文档后才显示给我，而是会随着我的输入实时显示内容。在本书中，我们不会编写交互式程序。如果你在学习完本书后有兴趣编写此类程序，你会很高兴地知道，Python完全能够胜任这项任务。
- en: 'The text for each problem is found both here and on the online judge. However,
    the text won’t match, because I’ve rewritten it for purposes of consistency throughout
    the book. Don’t worry: what I’ve written conveys the same information as the official
    problem statement.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个问题的文本都可以在这里和在线评测平台上找到。然而，文本内容可能有所不同，因为我已经为确保整本书的一致性对其进行了改写。别担心：我所写的内容传达的信息和官方问题陈述是一样的。
- en: The Python Shell
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python Shell
- en: For each problem in the book, we want to write a program and save it in a file.
    But that assumes we know what program to write! For many of the problems in the
    book, we’ll need to learn some new Python features before we can solve the problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于书中的每个问题，我们都需要编写一个程序并将其保存在文件中。但这前提是我们知道要写什么程序！对于书中的许多问题，我们需要先学习一些新的Python特性，才能解决这些问题。
- en: The best way to experiment with Python features is by using the Python shell.
    It’s an interactive environment where you type some Python code and press ENTER,
    and Python shows you the result. Once we learn enough to solve the current problem,
    we’ll stop using the shell and start typing our solution in a text file instead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试Python功能的最佳方式是使用Python shell。这是一个交互式环境，你输入一些Python代码并按下ENTER键，Python会显示结果。一旦我们学到足够的知识来解决当前问题，我们就会停止使用shell，而开始在文本文件中输入解决方案。
- en: To begin, create a new folder on your desktop called *programming*. We’ll use
    that folder to store all of the work that we do for this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在桌面上创建一个名为*programming*的文件夹。我们将使用这个文件夹来存储本书中所有的工作文件。
- en: Now, we’ll navigate to this *programming* folder and launch the Python shell.
    Follow these steps for your operating system whenever you’d like to start the
    Python shell.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将导航到*programming*文件夹并启动Python shell。每当你想要启动Python shell时，请根据你的操作系统遵循这些步骤。
- en: Windows
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows
- en: 'On Windows, do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，执行以下操作：
- en: Hold down SHIFT and right-click your **programming** folder.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住SHIFT键，然后右键点击你的**programming**文件夹。
- en: From the resulting menu, click **Open PowerShell window here**. If that choice
    isn’t there, click **Open command window here**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出的菜单中，点击**在此处打开PowerShell窗口**。如果没有这个选项，点击**在此处打开命令窗口**。
- en: At the bottom of the resulting window, you’ll see a line that ends with a greater-than
    sign (`>`). This is your operating system *prompt*, and it’s waiting for you to
    type a command. You type operating system commands here, *not* Python code. Be
    sure to press ENTER after each command.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的窗口底部，你会看到一行以大于号（`>`）结尾。这是你的操作系统*提示符*，它在等待你输入命令。在这里，你输入的是操作系统命令，而*不是*Python代码。每输入一个命令后，记得按下ENTER键。
- en: You’re now in your *programming* folder. You can type dir (for *directory*)
    if you’d like to see what’s there. You shouldn’t see any files yet, because we
    haven’t created any.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在已经进入了*programming*文件夹。你可以输入dir（表示*目录*）来查看当前文件夹中的内容。如果你还看不到任何文件，那是因为我们还没有创建任何文件。
- en: Now, enter python to start the Python shell.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入python来启动Python shell。
- en: 'When you start the Python shell, you should see something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Python shell时，你应该看到类似这样的界面：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，在第一行你应该看到至少为3.6版本的Python。如果你的版本较旧，特别是2.*x*版本，或者Python根本没有加载，请按照引言中的说明安装一个更新的Python版本。
- en: At the bottom of this window, you’ll see a `>>>` Python prompt. This is where
    you type Python code. Never type the `>>>` symbols yourself. Once you’re done
    programming, you can press CTRL-Z and then press ENTER to quit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口底部，你会看到一个 `>>>` 的 Python 提示符。这是你输入 Python 代码的地方。切勿自己输入 `>>>` 符号。一旦编程完成，你可以按
    CTRL-Z，然后按 ENTER 退出。
- en: macOS
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: macOS
- en: 'On macOS, do the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，执行以下操作：
- en: Open Terminal. You can do that by pressing COMMAND-spacebar, typing **terminal**,
    and then double-clicking the result.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。你可以通过按下 COMMAND + 空格键，输入 **terminal**，然后双击结果来打开。
- en: In the resulting window, you’ll see a line that ends with a dollar symbol (`$`).
    This is your operating system *prompt*, and it’s waiting for you to type a command.
    You type operating system commands here, *not* Python code. Be sure to press ENTER
    after each command.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的窗口中，你会看到一行以美元符号（`$`）结尾。这是你的操作系统 *提示符*，它在等待你输入命令。你在这里输入的是操作系统命令，而不是 Python
    代码。每输入完一条命令后，一定要按下 ENTER 键。
- en: You can enter the ls command to obtain a list of what’s in the current folder.
    Your *Desktop* should be listed there.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以输入 ls 命令来获取当前文件夹中的文件列表。你的 *桌面* 应该会出现在列表中。
- en: Enter cd Desktop to navigate to your *Desktop* folder. The cd command stands
    for *change directory*; *directory* is another name for folder.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 cd Desktop 进入你的 *桌面* 文件夹。cd 命令表示 *更改目录*；*目录* 是文件夹的另一种说法。
- en: Enter cd programming to navigate to your *programming* folder.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 cd programming 来进入你的 *编程* 文件夹。
- en: Now, enter python3 to start the Python shell. (You could also try entering `python`,
    without the `3`, but that might start up an older version of Python 2\. Python
    2 is not suitable for working through this book.)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入 python3 来启动 Python Shell。（你也可以尝试输入 `python`，不带 `3`，但那可能会启动旧版本的 Python
    2。Python 2 不适合本书的学习。）
- en: 'When you start the Python shell, you should see something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动 Python Shell 时，你应该看到类似这样的内容：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是你看到第一行显示的 Python 版本至少为 3.6。如果你的版本较旧，尤其是 2.*x*，或者 Python 根本没有加载，请根据引言中的说明安装最新版本的
    Python。
- en: At the bottom of this window, you’ll see a `>>>` Python prompt. This is where
    you type Python code. Never type the `>>>` symbols yourself. Once you’re done
    programming, you can press CTRL-D to quit.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口底部，你会看到一个 `>>>` 的 Python 提示符。这是你输入 Python 代码的地方。切勿自己输入 `>>>` 符号。一旦编程完成，你可以按
    CTRL-D 来退出。
- en: Linux
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux
- en: 'On Linux, do the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，执行以下操作：
- en: Right-click your *programming* folder.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击你的 *编程* 文件夹。
- en: In the resulting menu, click *Open in Terminal*. (You can also open the terminal
    and navigate to your *programming* folder if you’re more comfortable with that.)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的菜单中，点击 *在终端中打开*。（如果你更习惯那样，也可以直接打开终端并进入你的 *编程* 文件夹。）
- en: At the bottom of the resulting window, you’ll see a line that ends with a dollar
    sign (`$`). This is your operating system *prompt*, and it’s waiting for you to
    type a command. You type operating system commands here, *not* Python code. Be
    sure to press ENTER after each command.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的窗口底部，你会看到以美元符号（`$`）结尾的一行。这是你的操作系统 *提示符*，它在等待你输入命令。你在这里输入的是操作系统命令，而不是 Python
    代码。每输入完一条命令后，一定要按下 ENTER 键。
- en: You’re now in your *programming* folder. You can type `ls` if you’d like to
    see what’s there. You shouldn’t see any files yet, because we haven’t created
    any.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在位于你的 *编程* 文件夹内。你可以输入 `ls` 来查看文件夹中的内容。如果你什么都没看到，那是因为我们还没有创建任何文件。
- en: Now, enter python3 to start the Python shell. (You could also try entering `python`,
    without the `3`, but that might start up an older version of Python 2\. Python
    2 is not suitable for working through this book.)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入 python3 来启动 Python Shell。（你也可以尝试输入 `python`，不带 `3`，但那可能会启动旧版本的 Python
    2。Python 2 不适合本书的学习。）
- en: 'When you start the Python shell, you should see something like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动 Python Shell 时，你应该看到类似这样的内容：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是你看到第一行显示的 Python 版本至少为 3.6。如果你的版本较旧，尤其是 2.*x*，或者 Python 根本没有加载，请根据引言中的说明安装最新版本的
    Python。
- en: At the bottom of this window, you’ll see a `>>>` Python prompt. This is where
    you type Python code. Never type the `>>>` symbols yourself. Once you’re done
    programming, you can press CTRL-D to quit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口的底部，你会看到一个`>>>`的Python提示符。这是你输入Python代码的地方。请不要自己输入`>>>`符号。编程完成后，你可以按CTRL-D退出。
- en: 'Problem #1: Word Count'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #1：单词计数'
- en: Now it’s time for our first problem! We’re going to use Python to write a little
    word-count program. We’ll learn how to read input from the user, process the input
    to solve the problem, and output the result. We’ll also learn how to manipulate
    text and numbers in our programs, make use of built-in Python operations, and
    store intermediate results on our way to the solution.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决我们的第一个问题了！我们将使用Python编写一个小型的单词计数程序。我们将学习如何从用户获取输入，处理输入以解决问题，并输出结果。我们还将学习如何在程序中操作文本和数字，利用Python内置操作，并在解决问题的过程中存储中间结果。
- en: This is DMOJ problem `dmopc15c7p2`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`dmopc15c7p2`。
- en: The Challenge
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Count the number of words provided. For this problem, a *word* is any sequence
    of lowercase letters. For example, `hello` is a word, but so are non-English “words”
    like `bbaabbb`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 计算提供的单词数。对于这个问题，*单词*是任何由小写字母组成的序列。例如，`hello`是一个单词，但像`bbaabbb`这样的非英语“单词”也是有效的。
- en: Input
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input is one line of text, consisting of lowercase letters and spaces. There
    is exactly one space between each pair of words, and there are no spaces before
    the first word or after the last word.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是一行文本，由小写字母和空格组成。每对单词之间有且只有一个空格，且第一个单词之前和最后一个单词之后没有空格。
- en: The maximum length of the line is 80 characters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每行的最大长度为80个字符。
- en: Output
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the number of words in the input line.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出输入行中的单词数量。
- en: Strings
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: '*Values* are a fundamental building block of Python programs. Each value has
    a *type*, and the type determines the operations that can be performed on the
    value. In the Word Count problem, we’re working with a line of text. Text is stored
    as a string value in Python, so we’ll need to learn about strings. To solve the
    problem, we output the number of words in the text, so we also need to learn about
    numeric values. Let’s begin with strings.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*值*是Python程序的基本构建块。每个值都有一个*类型*，类型决定了可以对该值执行的操作。在词频统计问题中，我们处理的是一行文本。文本在Python中作为字符串值存储，因此我们需要了解字符串。为了解决这个问题，我们输出文本中的单词数量，因此我们还需要了解数值类型。让我们从字符串开始。'
- en: Representing Strings
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串表示
- en: 'A *string* is the Python type that’s used to store and manipulate text. To
    write a string value, we place its characters between single quotes. Follow along
    in the Python shell:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是Python类型，用于存储和操作文本。要写一个字符串值，我们将其字符放在单引号之间。在Python shell中跟随操作：'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Python shell echoes each string that I’ve typed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python shell会回显我输入的每个字符串。
- en: What happens when our string contains a single quote as one of its characters?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的字符串包含一个单引号作为字符时会发生什么？
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The single quote in the word `don't` terminates the string. The rest of the
    line, `t say that'`, therefore doesn’t make sense, and that’s what generates the
    syntax error. A *syntax error* means that we have violated the rules of Python
    and have not written valid Python code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号在单词`don't`中结束了字符串。因此，剩下的部分`t say that'`是无意义的，这就导致了语法错误。*语法错误*意味着我们违反了Python的规则，写出了无效的Python代码。
- en: 'To fix this, we can take advantage of the fact that double quotes can also
    be used to delimit strings:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修正这个问题，我们可以利用双引号也可以用来定界字符串这一事实：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unless the string in question has a single quote, I won’t use double quotes
    in this book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除非字符串中包含单引号，否则我在本书中不会使用双引号。
- en: String Operators
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串操作符
- en: We can use a string to hold the text whose words we want to count. To count
    the words—or to do anything else with strings—we need to learn how to work with
    strings.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字符串来保存我们想要统计单词的文本。要计算单词数——或者对字符串做其他操作——我们需要学习如何使用字符串。
- en: 'Strings come with a rich variety of operations that we can perform. Some of
    them use special symbols between their operands. For example, the `+` operator
    is used for string concatenation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有丰富的操作可供我们执行。其中一些操作符在其操作数之间使用特殊符号。例如，`+`操作符用于字符串连接：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Oops—we need a space between those two words. Let’s add one to the end of the
    first string:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀——我们需要在这两个单词之间加个空格。让我们在第一个字符串的末尾加一个空格：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There’s also the `*` operator, which replicates a string a specified number
    of times:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`*`操作符，用于将字符串复制指定次数：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That `30` there is an integer value. I’ll have more to say about integers shortly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`30`是一个整数值。稍后我会详细讲解整数。
- en: '**CONCEPT CHECK**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A. `''''''`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: A. `''''''`
- en: B. `''`
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: B. `''`
- en: C. This code produces a syntax error (invalid Python code)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: C. 这段代码会产生语法错误（无效的 Python 代码）
- en: 'Answer: B. `''''` is the empty string—a string of zero characters. Repeating
    an empty string three times is still an empty string!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B. `''`是空字符串——一个零字符的字符串。重复三次空字符串仍然是空字符串！
- en: String Methods
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串方法
- en: 'A *method* is an operation specific to a type of value. Strings have a large
    number of methods. For example, there’s a method called `upper`, which produces
    the uppercase version of a string:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*方法*是特定类型值的操作。字符串有许多方法。例如，有一个叫做`upper`的方法，它可以生成一个字符串的大写版本：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The information we get back from a method is known as the method’s *return value*.
    For example, we could say for the previous example that `upper` returned the string
    `'HELLO'`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个方法得到的信息被称为该方法的*返回值*。例如，在之前的示例中，我们可以说`upper`返回了字符串`'HELLO'`。
- en: Performing a method on a value is known as *calling* the method. Calling a method
    involves placing the *dot operator* (`.`) between the value and the method name.
    It also requires parentheses after the method name. For some methods, we leave
    those parentheses empty, as when calling `upper`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个值执行方法称为*调用*该方法。调用方法时需要在值和方法名之间放置*点操作符*（`.`）。方法名后还需要加上圆括号。对于一些方法，我们可以不传递任何参数，就像调用`upper`一样。
- en: For other methods, we can optionally include information there. Still other
    methods require information and won’t work at all without it. Information we include
    when calling a method is referred to as the method’s *arguments*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他方法，我们可以选择性地在其中包含信息。还有一些方法需要信息，且没有信息将无法正常工作。当我们调用一个方法时所包含的信息被称为该方法的*参数*。
- en: 'For example, strings have a `strip` method. If called with no arguments, `strip`
    removes all leading and trailing spaces from a string:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，字符串有一个`strip`方法。如果不带参数调用，`strip`会去掉字符串的所有前导和尾随空格：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But we can also call it with a string as the argument. If we do, that argument
    determines which characters are stripped from the beginning and the end:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以用一个字符串作为参数来调用它。如果这样做，那个参数决定了从字符串的开始和结尾去除哪些字符：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s talk about one more string method: `count`. We pass it a string argument,
    and it tells us how many occurrences of that argument are found in our string:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再讨论一个字符串方法：`count`。我们传递给它一个字符串参数，它会告诉我们该参数在字符串中出现了多少次：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If occurrences of the argument overlap, only the first counts:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数的出现是重叠的，只有第一个算数：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Unlike the other methods I’ve described, `count` is directly useful to our Word
    Count problem.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与我之前描述的其他方法不同，`count`对我们的单词计数问题直接有用。
- en: 'Think of a string like `''this is a string with a few words''`. Notice that
    a space comes after each word. In fact, if you had to count the number of words
    by hand, you might use the spaces to tell you where each word ends. What if we
    count the number of spaces in a string? To do that, we can pass a string consisting
    of a single space character to `count`. It looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个字符串，比如`'this is a string with a few words'`。注意到每个单词后面都有一个空格。事实上，如果你需要手动计算单词的数量，你可能会利用空格来判断每个单词的结束位置。如果我们计算字符串中的空格数量会怎样呢？为此，我们可以将一个仅包含一个空格字符的字符串传递给`count`。它看起来是这样的：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We get a value of `7`. That’s not quite the number of words—the string has eight
    words—but we’re close. Why are we getting `7` instead of `8`?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个值`7`。这不是准确的单词数量——字符串有八个单词——但我们接近了。为什么我们得到的是`7`而不是`8`呢？
- en: The reason is that each word has a space after it except the last word. Counting
    the spaces therefore fails to account for the final word. To remedy that, we need
    to learn how to handle numbers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为每个单词后面都有一个空格，除了最后一个单词。因此，计算空格的数量无法考虑最后一个单词。为了解决这个问题，我们需要学习如何处理数字。
- en: Integer and Floating-Point Numbers
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数和浮动点数
- en: An *expression* is made up of values and operators. We’ll now see how to write
    numeric values and combine them with operators.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*表达式*由值和操作符组成。接下来我们将看到如何写出数字值并将它们与操作符结合。
- en: 'There are two different Python types that represent numbers: integers (with
    no decimal part) and floating-point numbers (with a decimal part).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的 Python 类型代表数字：整数（没有小数部分）和浮动点数（有小数部分）。
- en: 'We write integer values as numbers with no decimal point. Here are some examples:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整数值写成没有小数点的数字。这里有一些例子：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A value on its own is the simplest kind of expression.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的一个值是最简单的表达式类型。
- en: The familiar mathematical operators work on integers. We have `+` for addition,
    `-` for subtraction, and `*` for multiplication. We can use these operators to
    write more complicated expressions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉的数学运算符可以作用于整数。我们有 `+` 用于加法，`-` 用于减法，`*` 用于乘法。我们可以使用这些运算符来编写更复杂的表达式。
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice the spaces around the operators. While `8+10` and `8 + 10` are the same
    as far as Python is concerned, the latter makes the expression easier for us humans
    to read.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意运算符周围的空格。虽然 `8+10` 和 `8 + 10` 对 Python 来说是一样的，但后者使得表达式对我们人类更易读。
- en: 'Python has two division operators, not one! The `//` operator performs integer
    division, which throws away any remainder and rounds the result down:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两个除法运算符，而不是一个！`//` 运算符执行整数除法，会丢弃任何余数并将结果向下舍入：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you want the remainder of the division, use the mod operator, written as
    `%`. For example, dividing 8 by 2 leaves no remainder:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想得到除法的余数，使用模运算符 `%`。例如，将 8 除以 2 没有余数：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Dividing 8 by 3 leaves a remainder of 2:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将 8 除以 3 会剩余 2：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `/` operator, in contrast to `//`, doesn’t do any rounding:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`/` 运算符与 `//` 不同，它不会进行任何四舍五入：'
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These result values are not integers! They have a decimal point and belong
    to a different Python type called *float* (for “floating-point numbers”). You
    can write float values by including a decimal point:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果值不是整数！它们有一个小数点，并属于另一种 Python 类型，称为 *浮点数*（用于“浮动小数点数”）。你可以通过包含小数点来编写浮点值：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’ll focus on integers for now and return to floating-point numbers when we
    solve Cone Volume later in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在先集中讨论整数，稍后在本章解决圆锥体体积时再回到浮点数的内容。
- en: 'When we use multiple operators in an expression, Python uses precedence rules
    to determine the order that operators are applied. Each operator has a precedence.
    Just like when we evaluate a mathematical expression on paper, Python performs
    multiplications and divisions (higher precedence) before additions and subtractions
    (lower precedence):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一个表达式中使用多个运算符时，Python 使用优先级规则来确定运算符应用的顺序。每个运算符都有一个优先级。就像在纸面上计算数学表达式一样，Python
    会先执行乘法和除法（优先级更高），然后才执行加法和减法（优先级较低）：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Again, like on paper, operations inside parentheses have the highest precedence.
    We can use this to force Python to perform operations in our desired order:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次和纸面上一样，括号内的操作具有最高的优先级。我们可以利用这一点来强制 Python 按照我们期望的顺序执行操作：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Programmers often add parentheses even when not technically required. That’s
    because Python has many operators, as we’ll see, and keeping track of their precedence
    is error-prone and not something that programmers typically do.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常在不需要的情况下也添加括号。这是因为 Python 有很多运算符，正如我们将看到的那样，追踪它们的优先级容易出错，而且这通常不是程序员做的事。
- en: 'If you’re wondering whether integer values and float values have methods, just
    like strings, they do! But they aren’t all that useful. For example, there’s a
    method that tells us how much of the computer’s memory is taken up by an integer.
    The bigger the integer, the more memory it requires:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想整数值和浮点值是否像字符串一样有方法，那答案是有的！但是它们并不太有用。例如，有一个方法可以告诉我们一个整数占用了多少计算机内存。整数越大，占用的内存就越多：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We need the parentheses around the integers; otherwise, the dot operator gets
    confused with a decimal point, and we get a syntax error.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在整数周围加上括号；否则，点运算符会与小数点混淆，从而导致语法错误。
- en: Variables
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量
- en: We now know how to write string and numeric values. We’ll also find it valuable
    to be able to store them so we can access them later. In Word Count, it would
    be convenient to be able to store the line of words somewhere and then count the
    number of words.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何编写字符串和数值类型的值。我们也会发现能够存储它们以便稍后访问是非常有用的。在词频统计中，将一行单词存储在某个地方，然后统计单词数是非常方便的。
- en: Assignment Statement
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 赋值语句
- en: 'A *variable* is a name that refers to a value. Whenever we later use a variable’s
    name, it gets substituted by what that variable refers to. To make a variable
    refer to a value, we use the *assignment statement*. An assignment statement consists
    of a variable, an equal sign (`=`), and an expression. Python evaluates the expression
    and makes the variable refer to the result. Here’s an example assignment statement:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量* 是一个引用值的名称。每当我们稍后使用变量的名称时，它会被替换成该变量所引用的值。为了让一个变量引用一个值，我们使用 *赋值语句*。赋值语句由一个变量、一个等号（`=`）和一个表达式组成。Python
    会计算表达式并使变量引用结果。以下是一个赋值语句的例子：'
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, `dollars` is substituted by `250` whenever we use it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们使用`dollars`时，它就被替换为`250`：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A variable refers to only one value at a time. Once we use an assignment statement
    to make a variable refer to another value, it no longer refers to the old value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量一次只能指向一个值。一旦我们用赋值语句让一个变量指向另一个值，它就不再指向旧的值：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can have as many variables as we like. Large programs typically use hundreds
    of variables. Here’s an example of using two variables:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有任意多个变量。大型程序通常使用成百上千个变量。这是一个使用两个变量的例子：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that I’ve chosen variable names that give some sense of what they’re
    storing. These two variables, for example, have to do with the prices of two purchases.
    Using variable names `p1` and `p2` would be easier to type, but in a few days
    we’d probably forget what the names mean!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我选择的变量名有助于表达它们所存储的内容。例如，这两个变量与两笔购买的价格有关。如果使用变量名`p1`和`p2`会更容易输入，但过几天我们可能就会忘记这些名字的含义了！
- en: 'We can make variables refer to strings, too:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以让变量指向字符串：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As with variables that refer to numbers, we can use these in larger expressions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像指代数字的变量一样，我们可以在更大的表达式中使用这些变量：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Python variable names should start with a lowercase letter and then can contain
    additional letters, underscores to separate words, and numbers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Python的变量名应该以小写字母开头，之后可以包含其他字母、下划线分隔单词，以及数字。
- en: Changing Variable Values
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 改变变量值
- en: 'Suppose we have a variable `dollars` that refers to value `250`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个变量`dollars`，它表示值`250`：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we want to increase the value so that `dollars` refers to 251\. This won’t
    work:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想增加值，使得`dollars`表示251。这样做是行不通的：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result is 251, but that value is gone, not stored anywhere:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是251，但该值已经消失，没有存储在任何地方：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What we need is an assignment statement that captures the result of `dollars
    + 1`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个赋值语句，它捕获`dollars + 1`的结果：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s common for learners to think of the assignment symbol `=` as equality.
    But don’t do that! The assignment statement is a command to make a variable refer
    to the value of an expression, not a claim that two entities are equal.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 学习者常常把赋值符号`=`误认为是等号。但不要这样做！赋值语句是一个命令，用来让变量指向一个表达式的值，而不是声称两个实体相等。
- en: '**CONCEPT CHECK**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the value of `y` after the execution of the following code?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行后，`y`的值是多少？
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A. `39`
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: A. `39`
- en: B. `22`
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: B. `22`
- en: C. `35`
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: C. `35`
- en: D. `20`
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: D. `20`
- en: E. `18`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: E. `18`
- en: 'Answer: A. There’s only one assignment to `y`, and it makes `y` refer to the
    value `39`. The `x = 20` assignment statement changes what `x` refers to, from
    `37` to `20`, but this has no impact on the value referred to by `y`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. 只有一个对`y`的赋值操作，它让`y`指向值`39`。`x = 20`赋值语句改变了`x`指向的值，从`37`变为`20`，但这对`y`指向的值没有影响。
- en: Counting the Words Using a Variable
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用变量计数单词
- en: 'Let’s take stock of our progress toward solving the Word Count problem:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在解决单词计数问题上取得的进展：
- en: We know about strings, and we can use a string to store the line of words.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经了解了字符串，并且可以使用字符串来存储一行文字。
- en: We know about the string `count` method, which we can use to count the number
    of spaces in the line of words. That gives us one less than the output value that
    we need.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经了解了字符串`count`方法，可以用它来计算文字行中空格的数量。这给我们一个比所需输出值少1的结果。
- en: We know about integers, whose `+` operator we can use to add `1` to a number.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经了解了整数，我们可以使用其`+`运算符将`1`加到一个数字上。
- en: We know about variables and the assignment statement, which help us hold on
    to values so that we don’t lose them.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解了变量和赋值语句，它们帮助我们保存值，以便我们不会丢失它们。
- en: 'Putting all of this together, we can make a variable refer to a string and
    then count the number of words:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些内容结合起来，我们可以让一个变量指向一个字符串，然后计算单词的数量：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `line` and `total_words` variables aren’t required here; here’s how we
    could do it without them:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`line`和`total_words`这两个变量在这里不是必须的；我们可以不用它们来实现：'
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: But using variables to capture intermediate results is a good practice for keeping
    code readable. Once our programs get longer than a few lines, variables will be
    indispensable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但是使用变量来捕捉中间结果是保持代码可读性的好习惯。一旦我们的程序超过几行，变量将变得不可或缺。
- en: Reading Input
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取输入
- en: One problem with the code that we’ve written is that it works only on the particular
    string that we’ve typed in. It tells us that there are eight words in `'this is
    a string with a few words'`, but that’s all it can do. If we want to know how
    many words are in a different string, we’ll have to replace the current string
    with a new one. To solve Word Count, though, we need our program to work on *any*
    string provided as input to our program.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码存在一个问题，那就是它只能在我们输入的特定字符串上工作。它告诉我们字符串 `'this is a string with a few words'`
    中有八个单词，但它只能做这些。如果我们想知道另一个字符串中有多少个单词，我们就得把当前字符串替换成新的字符串。然而，要解决单词计数问题，我们需要让程序能够处理任何作为输入提供的*字符串*。
- en: 'To read a line of input, we use the `input` function. A *function* is similar
    to a method: we call it, perhaps with some arguments, and it returns a value to
    us. One difference between a method and a function is that a function does not
    use the dot operator. All information passed to functions is through arguments.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取一行输入，我们使用 `input` 函数。*函数*类似于方法：我们调用它，可能会传递一些参数，它会返回一个值给我们。方法和函数之间的一个区别是，函数不使用点操作符。所有传递给函数的信息都是通过参数传递的。
- en: 'Here’s an example of calling the `input` function and then typing some input—in
    this case, the word `testing`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个调用 `input` 函数并输入内容的示例——在这种情况下，输入的内容是 `testing`：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When you type `input()` and press ENTER, you don’t get a `>>>` prompt back.
    Instead, Python waits for you to type something on the keyboard and press ENTER.
    The `input` function then returns the string you typed. As usual, if we don’t
    store that string anywhere, then it’s lost. Let’s use an assignment statement
    to store what we type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入 `input()` 并按下 ENTER 键时，你不会看到 `>>>` 提示符。相反，Python 会等待你在键盘上输入内容并按下 ENTER
    键。然后，`input` 函数返回你输入的字符串。像往常一样，如果我们没有将这个字符串保存到任何地方，那么它就会丢失。我们可以使用赋值语句来保存我们输入的内容：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice in the last line that I’ve used the `upper` method on the value returned
    by `input`. This is allowed because `input` returns a string, and `upper` is a
    string method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在最后一行，我对 `input` 返回的值使用了 `upper` 方法。这是允许的，因为 `input` 返回的是一个字符串，而 `upper`
    是字符串方法。
- en: Writing Output
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出内容
- en: 'You’ve seen that typing expressions at the Python shell causes their values
    to be displayed:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，在 Python shell 中输入表达式会导致其值被显示：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That’s just a convenience provided by the Python shell. It assumes that if
    you type an expression, then you probably want to see its value. But when running
    a Python program outside of the Python shell, this convenience is gone. Instead,
    we must explicitly use the `print` function whenever we want to output something.
    The `print` function works from the shell, too:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 Python shell 提供的一种便利。它假设如果你输入一个表达式，那么你可能想看到它的值。但在 Python 程序外运行时，这种便利就不复存在了。相反，当我们想输出内容时，我们必须显式地使用
    `print` 函数。`print` 函数在 shell 中也能工作：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that strings output by `print` don’t have quotes around them. That’s
    good—we probably don’t want to include quotes when communicating with users of
    our programs anyway!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`print` 输出的字符串没有引号。这是好的——我们可能并不希望在与程序用户的交互中包含引号！
- en: 'One nice feature of `print` is that you can supply as many arguments as you
    like, and they all get output with separating spaces:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 的一个优点是你可以提供任意多个参数，它们会用空格分开一起输出：'
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Solving the Problem: A Complete Python Program'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题：一个完整的 Python 程序
- en: We’re now ready to solve Word Count by writing a complete Python program. Exit
    the Python shell and you’ll be back at your operating system command prompt.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备通过编写一个完整的 Python 程序来解决单词计数问题。退出 Python shell，你将回到操作系统的命令提示符。
- en: Launching a Text Editor
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动文本编辑器
- en: We’ll use a text editor to write our code. Follow the steps for your operating
    system.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用文本编辑器来编写代码。根据你的操作系统，按照步骤操作。
- en: Windows
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Windows
- en: On Windows, we’ll use Notepad, a bare-bones text editor. At the operating system
    command prompt, navigate to your *programming* folder if you’re not already there.
    Then type notepad word_count.py and press ENTER. Since the *word_count.py* file
    doesn’t exist, Notepad will ask you whether you’d like to create a new *word_count.py*
    file. Click **Yes** and you’ll be ready to type your Python program.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，我们将使用 Notepad，一个简单的文本编辑器。在操作系统的命令提示符下，如果你还没有在 *编程* 文件夹中，请导航到该文件夹。然后输入
    `notepad word_count.py` 并按 ENTER 键。由于 *word_count.py* 文件不存在，Notepad 会问你是否希望创建一个新的
    *word_count.py* 文件。点击 **是**，然后你就可以开始输入你的 Python 程序了。
- en: macOS
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: macOS
- en: 'On macOS, you can use whichever text editor you like. One editor that you likely
    already have installed is TextEdit. At the operating system command prompt, navigate
    to your *programming* folder if you’re not already there. Then type the following
    two commands, pressing ENTER after each one:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，你可以使用任何你喜欢的文本编辑器。你可能已经安装的一个编辑器是TextEdit。在操作系统命令提示符下，如果你还不在*编程*文件夹中，请导航到该文件夹。然后依次输入以下两个命令，并在每个命令后按下ENTER键：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `touch` command creates an empty file so that your text editor can open
    it. Now you’re ready to type your Python program.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch`命令会创建一个空文件，以便你的文本编辑器可以打开它。现在，你可以开始编写Python程序了。'
- en: Linux
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Linux
- en: On Linux, you can use whichever text editor you like. One editor that you likely
    already have installed is gedit. At the operating system command prompt, navigate
    to your *programming* folder if you’re not already there. Then type gedit word_count.py
    and press ENTER. Now you’re ready to type your Python program.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，你可以使用任何你喜欢的文本编辑器。你可能已经安装的一个编辑器是gedit。在操作系统命令提示符下，如果你还不在*编程*文件夹中，请导航到该文件夹。然后输入`gedit
    word_count.py`并按ENTER键。现在你可以开始编写Python程序了。
- en: The Program
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 程序
- en: With your text editor loaded, you can type the code of our Python program. The
    code is in [Listing 1-1](ch01.xhtml#ch01ex01).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文本编辑器后，你可以开始编写我们的Python程序代码。代码位于[列表1-1](ch01.xhtml#ch01ex01)。
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 1-1: Solving Word Count*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表1-1：解决单词计数问题*'
- en: When entering that code, don’t enter the ❶, ❷, or ❸. Those are there to help
    us walk through the code and are not part of the code itself.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入代码时，不要输入❶、❷或❸。这些符号是为了帮助我们逐步讲解代码，它们不是代码的一部分。
- en: We begin by acquiring the line of text from the input and assigning it to a
    variable ❶. That gives us a string, on which we can use the `count` method. We
    add 1 to the count of spaces to account for the final word in the string, and
    we use the variable `total_words` to refer to that result ❷. The last thing to
    do is output the value referred to by `total_words` ❸.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从输入中获取一行文本并将其赋值给变量❶。这将给我们一个字符串，接着我们可以使用`count`方法。在计算空格数量时，我们加1以考虑字符串中的最后一个单词，并使用变量`total_words`来引用这个结果❷。最后一步是输出`total_words`所引用的值❸。
- en: Be sure to save the file once you’ve finished typing the code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成代码输入后，记得保存文件。
- en: Running the Program
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行程序
- en: To run the program, we’ll use the `python` command from our operating system
    command prompt. As we’ve seen, entering `python` by itself runs the Python shell,
    but we don’t want that this time. Instead, we want to tell Python to run the program
    in *word_count.py*. To do that, navigate to your *programming* folder, and enter
    python word_count.py. Here and throughout the book, please use the `python3` command
    instead of the `python` command if needed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，我们将在操作系统命令提示符下使用`python`命令。如前所述，输入`python`本身会启动Python交互式环境，但这次我们不想这样做。相反，我们希望告诉Python去运行*word_count.py*中的程序。为此，导航到你的*编程*文件夹，输入`python
    word_count.py`。在本书中，如果需要，请使用`python3`命令代替`python`命令。
- en: 'Your program is now waiting at the `input` prompt for you to type something.
    Type a few words, press ENTER, and you should see our program working correctly.
    For example, type the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序现在在`input`提示符下等待你输入内容。输入几个单词，按下ENTER，你应该看到程序正确运行。例如，输入以下内容：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You should see the program produce `6` as the output.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到程序输出`6`。
- en: If instead you see a Python error, go back over the code and make sure you’ve
    typed it in exactly. Python requires precision. Even a missing parenthesis or
    single quote will lead to an error.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到Python错误，请仔细检查代码，确保输入的完全正确。Python要求精确输入，哪怕是缺少一个括号或单引号也会导致错误。
- en: Don’t be frustrated if it takes you some time to get this program to run. Getting
    a first program to run can require a lot of work. We have to be able to type a
    program into a file, invoke Python to run that program, and fix any errors resulting
    from an incorrect program. But the procedure for running programs doesn’t change,
    no matter how complex the program, so time you spend here will be well worth it
    as you work through the rest of the book.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序运行需要一些时间，不要感到沮丧。第一次让程序运行可能需要很多工作。我们必须能够将程序输入到文件中，调用Python来运行该程序，并修复因程序错误而产生的任何错误。但不管程序有多复杂，运行程序的过程都不会改变，因此你在这里花费的时间会非常值得，特别是在你完成本书后续章节时。
- en: Submitting to the Judge
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提交给评测系统
- en: Congratulations! I hope it was satisfying to run your first Python program on
    your computer. But how do we know this program is correct? Does it work for all
    possible strings? We can test it on a few more strings, but the way we’ll gain
    even more confidence in the correctness of our code is by submitting it to the
    online judge. The judge automatically runs a bunch of tests on our code and tells
    us whether we passed the tests or if something is wrong.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！希望在你的电脑上运行第一个 Python 程序让你感到满意。但我们如何知道这个程序是正确的呢？它能处理所有可能的字符串吗？我们可以在更多的字符串上测试它，但我们获得更多信心的方式是将它提交给在线评测系统。评测系统会自动运行多个测试，告诉我们是否通过了测试，或者是否有问题。
- en: Go to *[https://dmoj.ca/](https://dmoj.ca/)* and log in. (If you don’t have
    a DMOJ account, please create one following the instructions in the introduction.)
    Click **Problems**, and search for the Word Count problem code `dmopc15c7p2`.
    Click the search result to load the problem—it’s called Not a Wall of Text rather
    than Word Count.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 *[https://dmoj.ca/](https://dmoj.ca/)* 并登录。（如果你没有 DMOJ 账户，请根据介绍中的说明创建一个。）点击**问题**，搜索单词计数问题代码
    `dmopc15c7p2`。点击搜索结果加载问题—它叫做 "Not a Wall of Text" 而不是 "Word Count"。
- en: You should then see the text of the problem, as written by the problem author.
    Click **Submit Solution**, and paste our code into the text area. Be sure to select
    Python 3 as the programming language. Finally, click the **Submit** button.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你应该看到问题的文本，按照问题作者的写法。点击**提交解答**，并将我们的代码粘贴到文本区域。确保选择 Python 3 作为编程语言。最后，点击**提交**按钮。
- en: DMOJ runs tests on our code and shows us the results. For each test case, you’ll
    see a status code. *AC* stands for *accepted* and is what you want to see for
    each test case. Other codes include *WA* (*wrong answer*) and *TLE* (*time limit
    exceeded*). If you see one of these, double-check the code that you pasted, making
    sure it exactly matches the code from your text editor.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: DMOJ 会对我们的代码进行测试，并展示结果。对于每个测试用例，你将看到一个状态码。*AC* 代表 *通过*，是你希望在每个测试用例上看到的状态。其他状态码包括
    *WA*（*错误答案*）和 *TLE*（*超时*）。如果你看到其中之一，检查一下你粘贴的代码，确保它与文本编辑器中的代码完全一致。
- en: Assuming all test cases are accepted, we should see that our score is 100/100
    and that we’ve earned 3 points for our work.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有测试用例都被接受，我们应该看到我们的分数是 100/100，并且我们已经为我们的工作赚取了 3 分。
- en: For each problem, we’ll follow the approach that we used to solve Word Count.
    First, we’ll explore using the Python shell, learning new Python features as needed.
    Then, we’ll write a program that solves the problem. We’ll test that program on
    our computer by supplying our own test cases. Finally, we’ll submit the code to
    the judge. If any test cases fail, we’ll look over our code again and fix the
    problem.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个问题，我们将遵循解决单词计数问题时使用的方法。首先，我们将探索使用 Python shell，根据需要学习新的 Python 特性。然后，我们将编写一个解决问题的程序。在电脑上通过输入我们自己的测试用例来测试这个程序。最后，我们将代码提交给评测系统。如果有任何测试用例失败，我们会再次检查代码并修复问题。
- en: 'Problem #2: Cone Volume'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #2：圆锥体积'
- en: In Word Count, we needed to read a string from the input. In this problem, we’ll
    need to read integers from the input. Doing so requires an extra step to produce
    an integer from a string. We’ll also learn a little more about doing math in Python.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在单词计数问题中，我们需要从输入中读取一个字符串。在这个问题中，我们需要从输入中读取整数。这样做需要额外的步骤，将字符串转换为整数。我们还将学习更多关于如何在
    Python 中进行数学计算的内容。
- en: This is DMOJ problem `dmopc14c5p1`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `dmopc14c5p1`。
- en: The Challenge
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Calculate the volume of a right circular cone.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 计算直圆锥的体积。
- en: Input
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input consists of two lines of text. The first line contains integer *r*,
    the radius of the cone. The second line contains integer *h*, the height of the
    cone. Both *r* and *h* are between 1 and 100\. (That is, the minimum value for
    *r* and *h* is 1, and the maximum value is 100.)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包括两行文本。第一行包含整数 *r*，表示圆锥的半径。第二行包含整数 *h*，表示圆锥的高度。*r* 和 *h* 都在 1 到 100 之间。（也就是说，*r*
    和 *h* 的最小值是 1，最大值是 100。）
- en: Output
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the volume of the right circular cone with radius *r* and height *h*.
    The formula to calculate the volume is (*πr*²*h*)/3.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 输出直圆锥的体积，已知半径 *r* 和高度 *h*。计算体积的公式是 (*πr*²*h*)/3。
- en: More Math in Python
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多 Python 数学运算
- en: 'Say we have `r` and `h` variables referring to a radius and height, respectively:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有 `r` 和 `h` 两个变量，分别代表半径和高度：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now we want to evaluate (*πr*²*h*)/3\. Substituting a radius of `4` and height
    of `6`, we have (*π* * 4² * 6)/3\. Using a value of `3.14159` for *π*, a calculator
    gives a result of `100.531`. How can we do this in Python?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要计算(*πr*²*h*)/3。将半径`4`和高度`6`代入，公式变为(*π* * 4² * 6)/3。使用`3.14159`作为*π*的值，计算器给出的结果是`100.531`。我们该如何在Python中实现这个呢？
- en: Accessing Pi
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问Pi
- en: 'To access the value of *π*, we’ll use a suitable variable. Here’s an assignment
    statement to `PI` with a lot of accuracy in its value:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问*π*的值，我们将使用一个合适的变量。这里是一个赋值语句，将`PI`的值设定为具有高精度的值：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is more a *constant* than a variable, since we’ll never want to change
    the value of `PI` in our code. It’s Python convention to use uppercase letters
    for such variables, as I’ve done here.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是一个*常量*而不是变量，因为我们在代码中永远不希望更改`PI`的值。按照Python的惯例，像这种变量使用大写字母，就像我在这里做的那样。
- en: Exponents
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指数运算
- en: Looking back at our formula, (*πr*²*h*)/3, the only thing we haven’t talked
    about yet is how to perform the *r*² part. Since *r*² is the same as *r* * *r*,
    we can use multiplication rather than exponentiation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的公式，(*πr*²*h*)/3，我们还没有讨论的是如何进行*r*²的运算。由于*r*²等同于*r* * *r*，我们可以使用乘法而不是指数运算。
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'But it’s more transparent to use exponentiation directly. We always want to
    write code that’s as clear as possible. Besides, one day you might have to calculate
    larger exponents, where repeated multiplication becomes increasingly unwieldy.
    Python’s exponentiation operator is `**`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但直接使用指数运算更为直观。我们总是希望编写尽可能清晰的代码。此外，总有一天你可能需要计算更大的指数，在那时，重复的乘法会变得越来越难以处理。Python的指数运算符是`**`：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here’s the complete formula:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的公式：
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Great—that’s close to the `100.531` result we expected!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——这接近我们预期的`100.531`结果！
- en: Notice that we’re producing a floating-point number here. As we discussed in
    “Integer and Floating-Point Numbers” in this chapter, the `/` division operator
    produces a floating-point result.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里得到的是一个浮点数。正如我们在本章的“整数与浮点数”部分讨论过的，`/`除法运算符会产生浮点结果。
- en: Converting Between Strings and Integers
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串与整数的转换
- en: 'We’re ultimately going to have to read the radius and height as input. We’ll
    then use those values to calculate the volume. Let’s give it a try:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们需要将半径和高度作为输入来读取。然后，我们将使用这些值来计算体积。我们来试试看：
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `input` function always returns a string, even if the user types an integer:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`input`函数始终返回一个字符串，即使用户输入的是整数：'
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The single quotes confirm that these values are strings. Strings cannot be
    used to perform mathematical calculations. If we try, we get an error:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号确认了这些值是字符串。字符串不能用于进行数学计算。如果我们尝试，程序会报错：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: A `TypeError` is generated when we use values of the wrong type. Python is objecting
    to us using the `**` operator on the string referred to by `r` and the integer
    `2`. The `**` operator is purely mathematical and has no meaning when used with
    strings.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用错误类型的值时，会生成`TypeError`。Python拒绝我们在字符串`r`和整数`2`之间使用`**`运算符。`**`运算符是纯数学运算，不能用于字符串。
- en: 'To convert our strings to integers, we can use Python’s `int` function:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将字符串转换为整数，我们可以使用Python的`int`函数：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now we can once again use these values in our formula:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以再次将这些值代入公式：
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Whenever you have a string whose characters represent an integer, you can use
    the `int` function to convert it to a value whose type is integer. It can cope
    with leading and trailing spaces, but not non-numeric characters:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有一个字符串，其中的字符表示一个整数时，你可以使用`int`函数将其转换为整数类型的值。它可以处理前导和尾随空格，但无法处理非数字字符：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When converting a string returned by `input` to an integer, we can take it
    in two steps, first assigning the return value of `input` to a variable and then
    converting that value to an integer:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`input`返回的字符串转换为整数时，我们可以分两步进行，首先将`input`的返回值赋给一个变量，然后将该值转换为整数：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Or we can combine the `input` and `int` calls:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以将`input`和`int`函数结合使用：
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, the argument passed to `int` is the string returned by `input`. The `int`
    function takes this string and returns it as an integer.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，传递给`int`的参数是`input`返回的字符串。`int`函数将该字符串转换并返回一个整数。
- en: 'If we ever need to convert the other way, from an integer to a string, we can
    do that with the `str` function:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要进行反向转换，即从整数转换为字符串，我们可以使用`str`函数：
- en: '[PRE60]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We can’t concatenate a string and an integer. The `str` function returns `'82'`
    from `82` so that it can be used in a string concatenation.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将字符串和整数连接在一起。`str`函数将`82`转换为字符串`'82'`，使其可以用于字符串拼接。
- en: Solving the Problem
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: We’re ready to solve Cone Volume. Create a text file called *cone_volume.py*
    and type the code in [Listing 1-2](ch01.xhtml#ch01ex02).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备解决圆锥体积问题。创建一个名为 *cone_volume.py* 的文本文件，并输入[列表 1-2](ch01.xhtml#ch01ex02)中的代码。
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '*Listing 1-2: Solving Cone Volume*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-2：解决圆锥体积问题*'
- en: I’ve included blank lines to separate the code into its logical pieces. Python
    ignores these blank lines, but such blank lines can make it easier for us to read
    and chunk the code.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我在代码中加入了空行，以将其分成逻辑块。Python 会忽略这些空行，但这些空行可以让我们更容易阅读和组织代码。
- en: 'Notice that I’ve used descriptive variable names: `radius` instead of `r`,
    `height` instead of `h`, and `volume`. Single-letter variable names are the norm
    in math formulas, but when writing code, we can use variable names that convey
    more information.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我使用了描述性的变量名：`radius` 代替 `r`，`height` 代替 `h`，以及 `volume`。单字母变量名在数学公式中是常见的，但在编写代码时，我们可以使用更具信息性的变量名。
- en: We begin by making a variable called `PI` refer to an approximation of pi ❶.
    We then read the radius ❷ and height ❸ from the input, converting both from strings
    to integers. We use the formula for the volume of a right circular cone to compute
    the volume ❹. Lastly, we output the volume ❺.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 `PI` 的变量，表示 pi 的近似值 ❶。然后我们从输入中读取半径 ❷ 和高度 ❸，将两者从字符串转换为整数。我们使用圆锥体积的公式计算体积
    ❹。最后，我们输出体积 ❺。
- en: Save your *cone_volume.py* file.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的 *cone_volume.py* 文件。
- en: Run your program by typing python cone_volume.py and then type a value for the
    radius and a value for the height. Use a calculator to verify that your program
    produces the correct output!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的程序，输入 `python cone_volume.py`，然后输入半径和高度的值。使用计算器验证你的程序是否输出正确结果！
- en: 'What happens if you type garbage for the radius or height? For example, run
    your program and type the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入无效的半径或高度会发生什么？例如，运行你的程序并输入以下内容：
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You should see an error:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个错误：
- en: '[PRE63]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: It is not user-friendly at all, that’s for sure. But for purposes of learning
    to program, we won’t worry about this. All of the test cases on the judge will
    be valid according to the problem’s input specification, so we’ll never have to
    worry about what to do with invalid input.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定一点也不友好。但为了学习编程，我们不需要担心这个问题。裁判的所有测试用例都符合问题的输入规范，因此我们不需要担心如何处理无效输入。
- en: Speaking of the judge, DMOJ owes us three points, because we’ve finished writing
    correct code for this problem. Go ahead and submit your work!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 说到裁判，DMOJ 应该给我们三分，因为我们已经完成了这个问题的正确代码。赶紧提交你的作业吧！
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: And we’re off! We’ve just solved our first two problems by writing Python code.
    We learned about the fundamentals of programming, including values, types, strings,
    integers, methods, variables, the assignment statement, and input and output.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始了！我们通过编写 Python 代码解决了前两个问题。我们学习了编程的基础，包括值、类型、字符串、整数、方法、变量、赋值语句以及输入和输出。
- en: Once you’re comfortable with this material—perhaps by working on some of the
    following exercises—it’s on to [Chapter 2](ch02.xhtml#ch02). There, we’ll learn
    how our programs can make decisions. We’ll no longer be writing programs that
    invariably run from top to bottom. They’ll be more flexible, doing what’s needed
    for the specific problem instance being solved.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了这些内容——也许通过做一些以下的练习——我们就可以继续学习[第二章](ch02.xhtml#ch02)。在那里，我们将学习如何让程序做出决策。我们将不再编写从上到下始终执行的程序。它们将更加灵活，根据特定问题的实例进行调整。
- en: Chapter Exercises
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: Each chapter ends with some exercises for you to try. I encourage you to complete
    as many exercises as you can.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章的结尾都会有一些练习题供你尝试。我鼓励你尽可能多地完成这些练习。
- en: Some exercises may take you a long time. You might get frustrated with repeated
    Python errors. Like with any skill worth learning, focused practice is needed.
    When you’re starting to work on an exercise, I recommend solving a few examples
    by hand. That way you know what the problem is asking and what your program is
    supposed to do. Otherwise, you might be writing code without a plan, contending
    both with organizing your thoughts and with writing the program at the same time.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有些练习可能需要很长时间。你可能会因为反复出现 Python 错误而感到沮丧。就像任何值得学习的技能一样，需要有针对性的练习。当你开始做一个练习时，我建议先手动解决几个例子。这样你就能知道问题在问什么，以及你的程序应该做什么。否则，你可能会在没有计划的情况下编写代码，一边组织思路一边编写程序。
- en: 'If your code isn’t working, ask: what, precisely, is the behavior that you
    want? What are the lines of code that are likely culprits for the error that you’re
    getting? Is there another, perhaps simpler, approach you could try?'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码不工作，问问自己：你到底想要的行为是什么？哪些代码行可能是你遇到的错误的罪魁祸首？你是否可以尝试另一种，也许更简单的方法？
- en: I’ve included solutions to the exercises on the book website (*[https://nostarch.com/learn-code-solving-problems/](https://nostarch.com/learn-code-solving-problems/)*).
    But don’t peek at those until you’ve given your chosen exercise an honest try.
    Or two. Or three. If you do look at a solution and learn how one might solve the
    problem, take a break and then try solving it yourself from scratch. There’s often
    more than one way to solve a problem. If your solution does the right thing but
    is different from mine, it doesn’t mean that one of us is wrong. Rather, it serves
    as an opportunity for you to compare your code to mine, perhaps learning alternate
    techniques in the process.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在书籍网站上提供了练习的解答 (*[https://nostarch.com/learn-code-solving-problems/](https://nostarch.com/learn-code-solving-problems/)*)。但在你诚实尝试完所选的练习之前，不要偷看那些解答。尝试一次，两次，或者三次。如果你查看了解答，并了解了一个可能的解决方案，休息一下，然后从头开始自己尝试解决。解决问题的方式通常不止一种。如果你的解法做对了事情，但与我的解法不同，这并不意味着我们其中有一个是错的。相反，这为你提供了一个机会，可以将你的代码与我的代码进行对比，也许你能在过程中学习到不同的技巧。
- en: DMOJ problem `wc16c1j1`, A Spooky Season
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目`wc16c1j1`，一个恐怖的季节
- en: DMOJ problem `wc15c2j1`, A New Hope
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目`wc15c2j1`，新的希望
- en: DMOJ problem `ccc13j1`, Next in Line
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目`ccc13j1`，排队等待
- en: DMOJ problem `wc17c1j2`, How’s the Weather? (Be careful with the direction of
    conversion!)
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目`wc17c1j2`，天气怎么样？（注意转换方向！）
- en: 'DMOJ problem `wc18c3j1`, An Honest Day’s Work (Hint: how can you determine
    the number of bottle caps and the total paint required by those bottle caps?)'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目`wc18c3j1`，诚实的一天工作（提示：你如何确定瓶盖的数量以及这些瓶盖所需的总油漆量？）
- en: Notes
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Word Count is originally from the DMOPC ’15 April Contest. Cone Volume is originally
    from the DMOPC ’14 March Contest.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 字数统计最初来自DMOPC ’15年4月比赛。圆锥体体积最初来自DMOPC ’14年3月比赛。
