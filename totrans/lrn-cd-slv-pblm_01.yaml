- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: GETTING STARTED
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开始
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: Programming involves writing code to solve a problem. As such, I want to solve
    problems with you from the outset. That is, rather than learning Python concept
    by concept and then solving a problem, we’re going to use a problem to dictate
    the concepts we need to learn.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编程就是编写代码来解决问题。因此，我希望从一开始就和你一起解决问题。也就是说，我们不是一个个地学习 Python 的概念，然后再解决问题，而是通过问题来决定我们需要学习的概念。
- en: 'In this chapter, we’ll solve two problems: determining the number of words
    in a line (like the word-count feature in a word processor) and calculating the
    volume of a cone. Solving these problems requires a tour of quite a few Python
    concepts. You may feel that you need more details to fully understand some of
    what I introduce here and how it all fits together in the design of a Python program.
    Don’t worry: we’ll revisit and elaborate on the most important concepts in later
    chapters.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将解决两个问题：确定一行中的单词数（类似于文字处理软件中的字数统计功能）和计算圆锥体的体积。解决这些问题需要我们了解一些 Python
    的概念。你可能会觉得要完全理解我在这里介绍的某些内容以及它们如何在 Python 程序设计中结合起来，你需要更多的细节。别担心：我们将在后续章节中重新访问并详细阐述最重要的概念。
- en: What We’ll Be Doing
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们将做什么
- en: As described in the introduction, we’ll be solving competitive programming problems
    using the Python programming language. The competitive programming problems can
    each be found on an online judge website. I assume that you’ve followed the instructions
    in the introduction to install Python and make your judge accounts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，我们将使用 Python 编程语言来解决竞赛编程问题。每个竞赛编程问题都可以在一个在线评测网站上找到。我假设你已经按照介绍中的说明安装了
    Python，并且创建了评测平台账号。
- en: For each problem, we’ll write a program to solve it. Each problem specifies
    the kind of *input* that our program will be provided, and the kind of *output*
    (or result) that is expected. Our program correctly solves the problem if it can
    take any valid input and produce the correct output.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个问题，我们将编写一个程序来解决它。每个问题都会指定程序将接收到的*输入*类型和期望的*输出*（或结果）类型。如果我们的程序能接受任何有效输入并产生正确的输出，那么它就能正确解决该问题。
- en: In general, there will be millions or billions of possible inputs. Each such
    input is referred to as a *problem instance*. For example, in the first problem
    that we’ll solve, the input is a line of text, like hello there or bbaabbb aa
    abab. Our task will be to output the number of words in the line. One of the most
    powerful ideas in programming is that often a small amount of general-purpose
    code can solve a seemingly endless number of problem instances. Whether the line
    has 2 words or 3 or 50, it won’t matter. Our program will get it right every time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，可能有数百万或数十亿个可能的输入。每个这样的输入被称为*问题实例*。例如，在我们要解决的第一个问题中，输入是一个文本行，如 hello there
    或 bbaabbb aa abab。我们的任务是输出该行中的单词数。编程中最强大的一个概念就是，通常少量通用代码可以解决看似无尽的多个问题实例。无论这行文字有
    2 个单词、3 个单词，还是 50 个单词，都无关紧要。我们的程序每次都能正确处理。
- en: 'Our programs will perform three tasks:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将执行三个任务：
- en: '**Read input** We need to determine the specific instance of the problem that
    we’re solving, so we first read the provided input.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**读取输入** 我们需要确定我们要解决的问题的具体实例，因此我们首先读取提供的输入。'
- en: '**Process** We process the input to determine the correct output.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理** 我们处理输入，确定正确的输出。'
- en: '**Write output** Having solved the problem, we produce the desired output.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出结果** 解决问题后，我们生成所需的输出。'
- en: The boundaries between these steps may not always be crisp—we might have to
    interleave some processing with producing some output, for example—but it will
    be helpful to keep these three broad steps in mind.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤之间的界限可能并不总是很清晰——例如，我们可能需要在生成输出的同时进行一些处理——但牢记这三个大致的步骤会很有帮助。
- en: 'You likely use programs on a daily basis that follow this input-process-output
    model. Consider a calculator program: you type in a formula (the input), the program
    crunches your numbers (process), and the program displays the answer (output).
    Or consider a web search engine: you type in a search query (input), the search
    engine determines the most relevant results (process), and it displays them (output).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能每天都在使用遵循这种输入-处理-输出模型的程序。考虑一下计算器程序：你输入一个公式（输入），程序进行计算（处理），然后显示答案（输出）。或者考虑一下网页搜索引擎：你输入一个搜索查询（输入），搜索引擎确定最相关的结果（处理），然后显示它们（输出）。
- en: Contrast these kinds of programs with *interactive* programs, which fuse input,
    processing, and output. For example, I’m typing this book using a text editor.
    When I type a character, the editor responds by adding that character to my document.
    It doesn’t wait for me to type the entire document before displaying it to me;
    it interactively displays it as I build it. We won’t be writing interactive programs
    in this book. If you’re interested in writing such programs after studying this
    book, you’ll be happy to hear that Python is certainly up for the task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The text for each problem is found both here and on the online judge. However,
    the text won’t match, because I’ve rewritten it for purposes of consistency throughout
    the book. Don’t worry: what I’ve written conveys the same information as the official
    problem statement.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The Python Shell
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For each problem in the book, we want to write a program and save it in a file.
    But that assumes we know what program to write! For many of the problems in the
    book, we’ll need to learn some new Python features before we can solve the problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The best way to experiment with Python features is by using the Python shell.
    It’s an interactive environment where you type some Python code and press ENTER,
    and Python shows you the result. Once we learn enough to solve the current problem,
    we’ll stop using the shell and start typing our solution in a text file instead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: To begin, create a new folder on your desktop called *programming*. We’ll use
    that folder to store all of the work that we do for this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’ll navigate to this *programming* folder and launch the Python shell.
    Follow these steps for your operating system whenever you’d like to start the
    Python shell.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Windows, do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Hold down SHIFT and right-click your **programming** folder.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the resulting menu, click **Open PowerShell window here**. If that choice
    isn’t there, click **Open command window here**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the resulting window, you’ll see a line that ends with a greater-than
    sign (>). This is your operating system *prompt*, and it’s waiting for you to
    type a command. You type operating system commands here, *not* Python code. Be
    sure to press ENTER after each command.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’re now in your *programming* folder. You can type dir (for *directory*)
    if you’d like to see what’s there. You shouldn’t see any files yet, because we
    haven’t created any.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, enter python to start the Python shell.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you start the Python shell, you should see something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.9.2 (tags/v3.9.2:1a79785, Feb 19 2021, 13:30:23)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[MSC v.1928 32 bit (Intel)] on win32'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Type "help", "copyright", "credits" or "license" for more information.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '>>>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of this window, you’ll see a >>> Python prompt. This is where
    you type Python code. Never type the >>> symbols yourself. Once you’re done programming,
    you can press CTRL-Z and then press ENTER to quit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口的底部，你会看到一个>>> Python提示符。在这里你输入Python代码。不要自己输入>>>符号。编程完成后，你可以按CTRL-Z，然后按ENTER退出。
- en: macOS
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: macOS
- en: 'On macOS, do the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，请执行以下操作：
- en: Open Terminal. You can do that by pressing COMMAND-spacebar, typing **terminal**,
    and then double-clicking the result.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。你可以通过按COMMAND-空格键，输入**terminal**，然后双击结果来打开。
- en: In the resulting window, you’ll see a line that ends with a dollar symbol ($).
    This is your operating system *prompt*, and it’s waiting for you to type a command.
    You type operating system commands here, *not* Python code. Be sure to press ENTER
    after each command.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果窗口中，你会看到一行以美元符号（$）结尾。这是你的操作系统*提示符*，它在等待你输入命令。你在这里输入操作系统命令，*不是*Python代码。确保每输入一条命令后按ENTER键。
- en: You can enter the ls command to obtain a list of what’s in the current folder.
    Your *Desktop* should be listed there.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以输入ls命令来查看当前文件夹中的内容。你的*桌面*应该会列在其中。
- en: Enter cd Desktop to navigate to your *Desktop* folder. The cd command stands
    for *change directory*; *directory* is another name for folder.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入cd桌面以导航到你的*桌面*文件夹。cd命令代表*更改目录*；*目录*是文件夹的另一种说法。
- en: Enter cd programming to navigate to your *programming* folder.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入cd编程以导航到你的*编程*文件夹。
- en: Now, enter python3 to start the Python shell. (You could also try entering python,
    without the 3, but that might start up an older version of Python 2\. Python 2
    is not suitable for working through this book.)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入python3启动Python shell。（你也可以尝试输入python，没有3，但那可能会启动Python 2的旧版本。Python 2不适合用来学习本书内容。）
- en: 'When you start the Python shell, you should see something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动Python shell时，你应该看到类似这样的内容：
- en: Python 3.9.2 (default, Mar 15 2021, 17:23:44)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9.2（默认，2021年3月15日，17:23:44）
- en: '[Clang 11.0.0 (clang-1100.0.33.17)] on darwin'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[Clang 11.0.0 (clang-1100.0.33.17)] 在Darwin上'
- en: Type "help", "copyright", "credits" or "license" for more information.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输入"help"、"copyright"、"credits"或"license"获取更多信息。
- en: '>>>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，你应该在第一行看到至少3.6版本的Python。如果你使用的是旧版本，尤其是2.*x*，或者如果Python根本没有加载，请按照介绍中的说明安装一个较新的Python版本。
- en: At the bottom of this window, you’ll see a >>> Python prompt. This is where
    you type Python code. Never type the >>> symbols yourself. Once you’re done programming,
    you can press CTRL-D to quit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口的底部，你会看到一个>>> Python提示符。在这里你输入Python代码。不要自己输入>>>符号。编程完成后，你可以按CTRL-D退出。
- en: Linux
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux
- en: 'On Linux, do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，请执行以下操作：
- en: Right-click your *programming* folder.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右击你的*编程*文件夹。
- en: In the resulting menu, click *Open in Terminal*. (You can also open the terminal
    and navigate to your *programming* folder if you’re more comfortable with that.)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的菜单中，点击*在终端中打开*。（如果你更习惯的话，也可以先打开终端并导航到你的*编程*文件夹。）
- en: At the bottom of the resulting window, you’ll see a line that ends with a dollar
    sign ($). This is your operating system *prompt*, and it’s waiting for you to
    type a command. You type operating system commands here, *not* Python code. Be
    sure to press ENTER after each command.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果窗口的底部，你会看到一行以美元符号（$）结尾。这是你的操作系统*提示符*，它在等待你输入命令。你在这里输入操作系统命令，*不是*Python代码。确保每输入一条命令后按ENTER键。
- en: You’re now in your *programming* folder. You can type ls if you’d like to see
    what’s there. You shouldn’t see any files yet, because we haven’t created any.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在在你的*编程*文件夹中。如果你想查看文件夹里的内容，可以输入ls命令。你应该还看不见任何文件，因为我们还没有创建文件。
- en: Now, enter python3 to start the Python shell. (You could also try entering python,
    without the 3, but that might start up an older version of Python 2\. Python 2
    is not suitable for working through this book.)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入python3启动Python shell。（你也可以尝试输入python，没有3，但那可能会启动Python 2的旧版本。Python 2不适合用来学习本书内容。）
- en: 'When you start the Python shell, you should see something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动Python shell时，你应该看到类似这样的内容：
- en: Python 3.9.2 (default, Feb 20 2021, 20:57:50)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9.2（默认，2021年2月20日，20:57:50）
- en: '[GCC 7.5.0] on linux'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[GCC 7.5.0] 在Linux上'
- en: Type "help", "copyright", "credits" or "license" for more information.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输入"help"、"copyright"、"credits"或"license"获取更多信息。
- en: '>>>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: What’s important here is that you see a Python version of at least 3.6 in the
    first line. If you have an older version, especially 2.*x*, or if Python doesn’t
    load at all, please install a recent version of Python following the instructions
    in the introduction.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的是你看到的 Python 版本至少是 3.6。如果你使用的是旧版本，尤其是 2.*x*，或者 Python 根本没有加载，请按照介绍中的说明安装一个最新版本的
    Python。
- en: At the bottom of this window, you’ll see a >>> Python prompt. This is where
    you type Python code. Never type the >>> symbols yourself. Once you’re done programming,
    you can press CTRL-D to quit.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口的底部，你会看到一个 >>> Python 提示符。这是你输入 Python 代码的地方。切记不要自己输入 >>> 符号。一旦编程完成，你可以按
    CTRL-D 退出。
- en: 'Problem #1: Word Count'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #1：单词计数'
- en: Now it’s time for our first problem! We’re going to use Python to write a little
    word-count program. We’ll learn how to read input from the user, process the input
    to solve the problem, and output the result. We’ll also learn how to manipulate
    text and numbers in our programs, make use of built-in Python operations, and
    store intermediate results on our way to the solution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决第一个问题了！我们将使用 Python 编写一个简单的单词计数程序。我们将学习如何从用户那里读取输入，处理输入以解决问题，并输出结果。我们还将学习如何在程序中操作文本和数字，利用
    Python 的内置操作，并在解决问题的过程中存储中间结果。
- en: This is DMOJ problem dmopc15c7p2.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 dmopc15c7p2。
- en: The Challenge
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Count the number of words provided. For this problem, a *word* is any sequence
    of lowercase letters. For example, hello is a word, but so are non-English “words”
    like bbaabbb.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 计算提供的单词数。对于这个问题，*单词*是任何一串小写字母。例如，hello 是一个单词，但像 bbaabbb 这样的非英语“单词”也算。
- en: Input
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input is one line of text, consisting of lowercase letters and spaces. There
    is exactly one space between each pair of words, and there are no spaces before
    the first word or after the last word.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是一行文本，由小写字母和空格组成。每对单词之间正好有一个空格，且第一个单词前和最后一个单词后没有空格。
- en: The maximum length of the line is 80 characters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该行的最大长度为 80 个字符。
- en: Output
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the number of words in the input line.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出输入行中的单词数量。
- en: Strings
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: '*Values* are a fundamental building block of Python programs. Each value has
    a *type*, and the type determines the operations that can be performed on the
    value. In the Word Count problem, we’re working with a line of text. Text is stored
    as a string value in Python, so we’ll need to learn about strings. To solve the
    problem, we output the number of words in the text, so we also need to learn about
    numeric values. Let’s begin with strings.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*值*是 Python 程序的基本构建块。每个值都有一个 *类型*，而类型决定了可以对该值执行哪些操作。在单词计数问题中，我们正在处理一行文本。文本在
    Python 中作为字符串值存储，所以我们需要了解字符串。为了解决问题，我们需要输出文本中的单词数量，因此我们还需要了解数值。让我们从字符串开始。'
- en: Representing Strings
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串的表示
- en: 'A *string* is the Python type that’s used to store and manipulate text. To
    write a string value, we place its characters between single quotes. Follow along
    in the Python shell:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是 Python 中用于存储和处理文本的类型。要写一个字符串值，我们将它的字符放在单引号之间。可以在 Python shell 中跟着操作：'
- en: '>>> ''hello'''
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''hello'''
- en: '''hello'''
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '''hello'''
- en: '>>> ''a bunch of words'''
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''一堆词'''
- en: '''a bunch of words'''
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '''一堆词'''
- en: The Python shell echoes each string that I’ve typed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Python shell 会回显我输入的每个字符串。
- en: What happens when our string contains a single quote as one of its characters?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的字符串包含单引号作为其中一个字符时，会发生什么？
- en: '>>> ''don''t say that'''
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''别这么说'''
- en: File "<stdin>", line 1
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行
- en: '''don''t say that'''
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '''别这么说'''
- en: ^
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ^
- en: 'SyntaxError: invalid syntax'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'SyntaxError: 无效的语法'
- en: The single quote in the word don't terminates the string. The rest of the line,
    t say that', therefore doesn’t make sense, and that’s what generates the syntax
    error. A *syntax error* means that we have violated the rules of Python and have
    not written valid Python code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号在单词 don’t 中终止了字符串。剩下的部分，t say that'，因此没有意义，这就导致了语法错误。*语法错误*意味着我们违反了 Python
    的规则，写出了无效的 Python 代码。
- en: 'To fix this, we can take advantage of the fact that double quotes can also
    be used to delimit strings:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以利用双引号也可以用来界定字符串的事实：
- en: '>>> "don''t say that"'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> "别这么说"'
- en: '"don''t say that"'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '"别这么说"'
- en: Unless the string in question has a single quote, I won’t use double quotes
    in this book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除非字符串中包含单引号，否则我在这本书中不会使用双引号。
- en: String Operators
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串操作符
- en: We can use a string to hold the text whose words we want to count. To count
    the words—or to do anything else with strings—we need to learn how to work with
    strings.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings come with a rich variety of operations that we can perform. Some of
    them use special symbols between their operands. For example, the + operator is
    used for string concatenation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''hello'' + ''there'''
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '''hellothere'''
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Oops—we need a space between those two words. Let’s add one to the end of the
    first string:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''hello '' + ''there'''
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '''hello there'''
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also the * operator, which replicates a string a specified number of
    times:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''-'' * 30'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '''------------------------------'''
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: That 30 there is an integer value. I’ll have more to say about integers shortly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '>>> '''' * 3'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: A. ''''''
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: B. ''
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: C. This code produces a syntax error (invalid Python code)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. '''' is the empty string—a string of zero characters. Repeating
    an empty string three times is still an empty string!'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: String Methods
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *method* is an operation specific to a type of value. Strings have a large
    number of methods. For example, there’s a method called upper, which produces
    the uppercase version of a string:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''hello''.upper()'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '''HELLO'''
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The information we get back from a method is known as the method’s *return value*.
    For example, we could say for the previous example that upper returned the string
    'HELLO'.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Performing a method on a value is known as *calling* the method. Calling a method
    involves placing the *dot operator* (.) between the value and the method name.
    It also requires parentheses after the method name. For some methods, we leave
    those parentheses empty, as when calling upper.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: For other methods, we can optionally include information there. Still other
    methods require information and won’t work at all without it. Information we include
    when calling a method is referred to as the method’s *arguments*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, strings have a strip method. If called with no arguments, strip
    removes all leading and trailing spaces from a string:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''   abc''.strip()'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '''abc'''
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''   abc       ''.strip()'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '''abc'''
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''abc''.strip()'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '''abc'''
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can also call it with a string as the argument. If we do, that argument
    determines which characters are stripped from the beginning and the end:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''abc''.strip(''a'')'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '''bc'''
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''abca''.strip(''a'')'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '''bc'''
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''abca''.strip(''ac'')'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '''b'''
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s talk about one more string method: count. We pass it a string argument,
    and it tells us how many occurrences of that argument are found in our string:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''abc''.count(''a'')'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''abc''.count(''q'')'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''aaabcaa''.count(''a'')'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''aaabcaa''.count(''ab'')'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'If occurrences of the argument overlap, only the first counts:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''ababa''.count(''aba'')'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the other methods I’ve described, count is directly useful to our Word
    Count problem.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of a string like ''this is a string with a few words''. Notice that a
    space comes after each word. In fact, if you had to count the number of words
    by hand, you might use the spaces to tell you where each word ends. What if we
    count the number of spaces in a string? To do that, we can pass a string consisting
    of a single space character to count. It looks like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个字符串，比如'this is a string with a few words'。注意每个单词后面都有一个空格。事实上，如果你需要手动计算单词的数量，可能会使用空格来告诉你每个单词的结束位置。如果我们数一下字符串中的空格数量呢？为此，我们可以传入一个由单个空格字符组成的字符串来计数。它看起来是这样的：
- en: '>>> ''this is a string with a few words''.count('' '')'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''this is a string with a few words''.count('' '')'
- en: '7'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: We get a value of 7. That’s not quite the number of words—the string has eight
    words—but we’re close. Why are we getting 7 instead of 8?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了7这个值。虽然这不是准确的单词数——字符串有八个单词——但我们已经接近了。为什么我们得到的是7而不是8呢？
- en: The reason is that each word has a space after it except the last word. Counting
    the spaces therefore fails to account for the final word. To remedy that, we need
    to learn how to handle numbers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于每个单词后面都有一个空格，除了最后一个单词。因此，计数空格无法计算最后一个单词。为了解决这个问题，我们需要学习如何处理数字。
- en: Integer and Floating-Point Numbers
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数和浮点数
- en: An *expression* is made up of values and operators. We’ll now see how to write
    numeric values and combine them with operators.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*表达式*由值和运算符组成。现在我们将看到如何编写数值并将它们与运算符结合。
- en: 'There are two different Python types that represent numbers: integers (with
    no decimal part) and floating-point numbers (with a decimal part).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两种不同的数字类型：整数（没有小数部分）和浮点数（有小数部分）。
- en: 'We write integer values as numbers with no decimal point. Here are some examples:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整数值写成没有小数点的数字。以下是一些例子：
- en: '>>> 30'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 30'
- en: '30'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '>>> 7'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 7'
- en: '7'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '>>> 1000000'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 1000000'
- en: '1000000'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '1000000'
- en: '>>> -9'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -9'
- en: '-9'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '-9'
- en: A value on its own is the simplest kind of expression.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的值是最简单的表达式形式。
- en: The familiar mathematical operators work on integers. We have + for addition,
    - for subtraction, and * for multiplication. We can use these operators to write
    more complicated expressions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的数学运算符作用于整数。我们有+表示加法，-表示减法，*表示乘法。我们可以使用这些运算符编写更复杂的表达式。
- en: '>>> 8 + 10'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 + 10'
- en: '18'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '>>> 8 - 10'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 - 10'
- en: '-2'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '-2'
- en: '>>> 8 * 10'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 * 10'
- en: '80'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '80'
- en: Notice the spaces around the operators. While 8+10 and 8 + 10 are the same as
    far as Python is concerned, the latter makes the expression easier for us humans
    to read.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意运算符两边的空格。虽然8+10和8 + 10在Python看来是一样的，但后者让我们人类更容易阅读这个表达式。
- en: 'Python has two division operators, not one! The // operator performs integer
    division, which throws away any remainder and rounds the result down:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两个除法运算符，而不是一个！//运算符执行整数除法，它会舍弃余数并向下舍入结果：
- en: '>>> 8 // 2'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 // 2'
- en: '4'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> 9 // 5'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 9 // 5'
- en: '1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '>>> -9 // 5'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -9 // 5'
- en: '-2'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '-2'
- en: 'If you want the remainder of the division, use the mod operator, written as
    %. For example, dividing 8 by 2 leaves no remainder:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要除法的余数，可以使用取模运算符，写作%。例如，8除以2没有余数：
- en: '>>> 8 % 2'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 % 2'
- en: '0'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: 'Dividing 8 by 3 leaves a remainder of 2:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 8除以3留下余数2：
- en: '>>> 8 % 3'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 % 3'
- en: '2'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 'The / operator, in contrast to //, doesn’t do any rounding:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与//运算符不同，/运算符不会做任何四舍五入：
- en: '>>> 8 / 2'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 / 2'
- en: '4.0'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '4.0'
- en: '>>> 9 / 5'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 9 / 5'
- en: '1.8'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '1.8'
- en: '>>> -9 / 5'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -9 / 5'
- en: '-1.8'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '-1.8'
- en: 'These result values are not integers! They have a decimal point and belong
    to a different Python type called *float* (for “floating-point numbers”). You
    can write float values by including a decimal point:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果值不是整数！它们有小数点，并且属于另一种Python类型，叫做*float*（浮点数）。你可以通过包含小数点来写浮点值：
- en: '>>> 12.5 * 2'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 12.5 * 2'
- en: '25.0'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '25.0'
- en: We’ll focus on integers for now and return to floating-point numbers when we
    solve Cone Volume later in this chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将专注于整数，并在本章稍后的圆锥体体积问题中再回到浮点数。
- en: 'When we use multiple operators in an expression, Python uses precedence rules
    to determine the order that operators are applied. Each operator has a precedence.
    Just like when we evaluate a mathematical expression on paper, Python performs
    multiplications and divisions (higher precedence) before additions and subtractions
    (lower precedence):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一个表达式中使用多个运算符时，Python会根据优先级规则来确定运算符应用的顺序。每个运算符都有一个优先级。就像我们在纸上计算数学表达式时一样，Python会先进行乘法和除法（优先级高），再进行加法和减法（优先级低）：
- en: '>>> 50 + 10 * 2'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 50 + 10 * 2'
- en: '70'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '70'
- en: 'Again, like on paper, operations inside parentheses have the highest precedence.
    We can use this to force Python to perform operations in our desired order:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的，和在纸上计算一样，括号内的操作有最高的优先级。我们可以利用这一点强制Python按照我们期望的顺序执行操作：
- en: '>>> (50 + 10) * 2'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (50 + 10) * 2'
- en: '120'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '120'
- en: Programmers often add parentheses even when not technically required. That’s
    because Python has many operators, as we’ll see, and keeping track of their precedence
    is error-prone and not something that programmers typically do.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常即使在技术上不需要时也加上括号。这是因为 Python 有许多操作符，正如我们将看到的那样，跟踪它们的优先级容易出错，而程序员通常不会这么做。
- en: 'If you’re wondering whether integer values and float values have methods, just
    like strings, they do! But they aren’t all that useful. For example, there’s a
    method that tells us how much of the computer’s memory is taken up by an integer.
    The bigger the integer, the more memory it requires:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想整数值和浮点值是否也有方法，就像字符串一样，它们是有的！但它们并不总是非常有用。例如，有一个方法告诉我们一个整数占用了多少计算机内存。整数越大，它所需的内存就越多：
- en: '>>> (5).bit_length()'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (5).bit_length()'
- en: '3'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '>>> (100).bit_length()'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (100).bit_length()'
- en: '7'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '>>> (99999).bit_length()'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (99999).bit_length()'
- en: '17'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: We need the parentheses around the integers; otherwise, the dot operator gets
    confused with a decimal point, and we get a syntax error.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在整数周围加上括号，否则点操作符会被误认为是小数点，导致语法错误。
- en: Variables
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量
- en: We now know how to write string and numeric values. We’ll also find it valuable
    to be able to store them so we can access them later. In Word Count, it would
    be convenient to be able to store the line of words somewhere and then count the
    number of words.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何编写字符串和数字值。我们还会发现能够存储它们，以便以后访问会很有用。在“字数统计”中，能够把一行文字存储起来，然后统计单词数将非常方便。
- en: Assignment Statement
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 赋值语句
- en: 'A *variable* is a name that refers to a value. Whenever we later use a variable’s
    name, it gets substituted by what that variable refers to. To make a variable
    refer to a value, we use the *assignment statement*. An assignment statement consists
    of a variable, an equal sign (=), and an expression. Python evaluates the expression
    and makes the variable refer to the result. Here’s an example assignment statement:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*变量*是一个表示值的名称。每当我们使用变量名称时，它会被替换为该变量所表示的值。为了使变量指向一个值，我们使用*赋值语句*。赋值语句由一个变量、一个等号（=）和一个表达式组成。Python
    会评估表达式并使变量指向结果。以下是一个赋值语句的示例：
- en: '>>> dollars = 250'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = 250'
- en: 'Now, dollars is substituted by 250 whenever we use it:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们使用 dollars 时，它都会被替换为 250：
- en: '>>> dollars'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '250'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '250'
- en: '>>> dollars + 10'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars + 10'
- en: '260'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '260'
- en: '>>> dollars'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '250'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '250'
- en: 'A variable refers to only one value at a time. Once we use an assignment statement
    to make a variable refer to another value, it no longer refers to the old value:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量一次只指向一个值。一旦我们使用赋值语句使变量指向另一个值，它就不再指向旧值：
- en: '>>> dollars = 250'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = 250'
- en: '>>> dollars'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '250'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '250'
- en: '>>> dollars = 300'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = 300'
- en: '>>> dollars'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '300'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '300'
- en: 'We can have as many variables as we like. Large programs typically use hundreds
    of variables. Here’s an example of using two variables:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有任意数量的变量。大型程序通常使用数百个变量。以下是使用两个变量的示例：
- en: '>>> purchase_price1 = 58'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> purchase_price1 = 58'
- en: '>>> purchase_price2 = 9'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> purchase_price2 = 9'
- en: '>>> purchase_price1 + purchase_price2'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> purchase_price1 + purchase_price2'
- en: '67'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '67'
- en: Notice that I’ve chosen variable names that give some sense of what they’re
    storing. These two variables, for example, have to do with the prices of two purchases.
    Using variable names p1 and p2 would be easier to type, but in a few days we’d
    probably forget what the names mean!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我选择的变量名称能够大致说明它们存储的内容。例如，这两个变量与两项购买的价格有关。使用 p1 和 p2 这样的变量名可能更容易输入，但几天后我们可能就会忘记这些名称代表什么！
- en: 'We can make variables refer to strings, too:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以让变量指向字符串：
- en: '>>> start = ''Monday'''
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> start = ''Monday'''
- en: '>>> end = ''Friday'''
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> end = ''Friday'''
- en: '>>> start'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 开始'
- en: '''Monday'''
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '''Monday'''
- en: '>>> end'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 结束'
- en: '''Friday'''
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '''Friday'''
- en: 'As with variables that refer to numbers, we can use these in larger expressions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与指向数字的变量一样，我们也可以在更大的表达式中使用它们：
- en: '>>> start + ''-'' + end'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> start + ''-'' + end'
- en: '''Monday-Friday'''
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '''Monday-Friday'''
- en: Python variable names should start with a lowercase letter and then can contain
    additional letters, underscores to separate words, and numbers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Python 变量名应该以小写字母开头，然后可以包含额外的字母、下划线分隔单词以及数字。
- en: Changing Variable Values
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量值的改变
- en: 'Suppose we have a variable dollars that refers to value 250:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 dollars 的变量，它表示值 250：
- en: '>>> dollars = 250'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = 250'
- en: 'Now we want to increase the value so that dollars refers to 251\. This won’t
    work:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想增加值，使 dollars 指向 251。这样做是行不通的：
- en: '>>> dollars + 1'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars + 1'
- en: '251'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '251'
- en: 'The result is 251, but that value is gone, not stored anywhere:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 251，但该值已消失，并未存储在任何地方：
- en: '>>> dollars'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '250'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '250'
- en: 'What we need is an assignment statement that captures the result of dollars
    + 1:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个赋值语句，它捕捉到dollars + 1的结果：
- en: '>>> dollars = dollars + 1'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = dollars + 1'
- en: '>>> dollars'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 美元'
- en: '251'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '251'
- en: '>>> dollars = dollars + 1'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars = dollars + 1'
- en: '>>> dollars'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> dollars'
- en: '252'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '252'
- en: It’s common for learners to think of the assignment symbol = as equality. But
    don’t do that! The assignment statement is a command to make a variable refer
    to the value of an expression, not a claim that two entities are equal.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 学习者常常把赋值符号 = 当作等式来理解。但千万不要那样想！赋值语句是一个命令，它使得一个变量指向一个表达式的值，而不是声明两个实体相等。
- en: '**CONCEPT CHECK**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the value of y after the execution of the following code?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码后，y 的值是多少？
- en: '>>> x = 37'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = 37'
- en: '>>> y = x + 2'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = x + 2'
- en: '>>> x = 20'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = 20'
- en: A. 39
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: A. 39
- en: B. 22
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: B. 22
- en: C. 35
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: C. 35
- en: D. 20
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: D. 20
- en: E. 18
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: E. 18
- en: 'Answer: A. There’s only one assignment to y, and it makes y refer to the value
    39. The x = 20 assignment statement changes what x refers to, from 37 to 20, but
    this has no impact on the value referred to by y.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. y 只被赋值一次，并且它指向值 39。x = 20 的赋值语句改变了 x 的值，从 37 变为 20，但这对 y 的值没有影响。
- en: Counting the Words Using a Variable
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用变量计数单词
- en: 'Let’s take stock of our progress toward solving the Word Count problem:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在解决单词计数问题中的进展：
- en: We know about strings, and we can use a string to store the line of words.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解字符串，可以使用字符串存储一行单词。
- en: We know about the string count method, which we can use to count the number
    of spaces in the line of words. That gives us one less than the output value that
    we need.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解字符串的 count 方法，可以用它来计算一行单词中的空格数量。这样会给我们比需要的输出值少 1 的结果。
- en: We know about integers, whose + operator we can use to add 1 to a number.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解整数，可以使用其 + 操作符给一个数字加 1。
- en: We know about variables and the assignment statement, which help us hold on
    to values so that we don’t lose them.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解变量和赋值语句，它们帮助我们保留值，防止丢失。
- en: 'Putting all of this together, we can make a variable refer to a string and
    then count the number of words:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 把这些都放在一起，我们可以让一个变量指向一个字符串，然后计算单词的数量：
- en: '>>> line = ''this is a string with a few words'''
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> line = ''this is a string with a few words'''
- en: '>>> total_words = line.count('' '') + 1'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> total_words = line.count('' '') + 1'
- en: '>>> total_words'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> total_words'
- en: '8'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: 'The line and total_words variables aren’t required here; here’s how we could
    do it without them:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不需要line 和 total_words 变量；我们可以不使用它们，直接这样做：
- en: '>>> ''this is a string with a few words''.count('' '') + 1'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''this is a string with a few words''.count('' '') + 1'
- en: '8'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: But using variables to capture intermediate results is a good practice for keeping
    code readable. Once our programs get longer than a few lines, variables will be
    indispensable.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 但是使用变量来捕捉中间结果是保持代码可读性的好习惯。一旦我们的程序超过几行，变量将变得不可或缺。
- en: Reading Input
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取输入
- en: One problem with the code that we’ve written is that it works only on the particular
    string that we’ve typed in. It tells us that there are eight words in 'this is
    a string with a few words', but that’s all it can do. If we want to know how many
    words are in a different string, we’ll have to replace the current string with
    a new one. To solve Word Count, though, we need our program to work on *any* string
    provided as input to our program.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写的代码的一个问题是，它只对我们输入的特定字符串有效。它告诉我们'this is a string with a few words'中有八个单词，但它只能做到这一点。如果我们想知道另一个字符串中有多少个单词，我们就必须替换当前字符串为一个新的字符串。然而，为了完成单词计数，我们需要我们的程序能够处理*任何*作为输入提供给程序的字符串。
- en: 'To read a line of input, we use the input function. A *function* is similar
    to a method: we call it, perhaps with some arguments, and it returns a value to
    us. One difference between a method and a function is that a function does not
    use the dot operator. All information passed to functions is through arguments.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取一行输入，我们使用输入函数。*函数*类似于方法：我们调用它，可能带有一些参数，然后它会返回一个值。方法和函数的区别在于，函数不使用点操作符。所有传递给函数的信息都是通过参数传递的。
- en: 'Here’s an example of calling the input function and then typing some input—in
    this case, the word testing:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个调用输入函数并输入内容的示例——在这个例子中，输入的是单词 testing：
- en: '>>> input()'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> input()'
- en: testing
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: testing
- en: '''testing'''
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '''testing'''
- en: 'When you type input() and press ENTER, you don’t get a >>> prompt back. Instead,
    Python waits for you to type something on the keyboard and press ENTER. The input
    function then returns the string you typed. As usual, if we don’t store that string
    anywhere, then it’s lost. Let’s use an assignment statement to store what we type:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '>>> result = input()'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: testing
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '>>> result'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '''testing'''
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '>>> result.upper()'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '''TESTING'''
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the last line that I’ve used the upper method on the value returned
    by input. This is allowed because input returns a string, and upper is a string
    method.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Writing Output
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ve seen that typing expressions at the Python shell causes their values
    to be displayed:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''abc'''
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '''abc'''
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''abc''.upper()'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '''ABC'''
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '>>> 45 + 9'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s just a convenience provided by the Python shell. It assumes that if
    you type an expression, then you probably want to see its value. But when running
    a Python program outside of the Python shell, this convenience is gone. Instead,
    we must explicitly use the print function whenever we want to output something.
    The print function works from the shell, too:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(''abc'')'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: abc
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(''abc''.upper())'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: ABC
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(45 + 9)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '54'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Notice that strings output by print don’t have quotes around them. That’s good—we
    probably don’t want to include quotes when communicating with users of our programs
    anyway!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'One nice feature of print is that you can supply as many arguments as you like,
    and they all get output with separating spaces:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(''abc'', 45 + 9)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: abc 54
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving the Problem: A Complete Python Program'
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re now ready to solve Word Count by writing a complete Python program. Exit
    the Python shell and you’ll be back at your operating system command prompt.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Launching a Text Editor
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll use a text editor to write our code. Follow the steps for your operating
    system.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: On Windows, we’ll use Notepad, a bare-bones text editor. At the operating system
    command prompt, navigate to your *programming* folder if you’re not already there.
    Then type notepad word_count.py and press ENTER. Since the *word_count.py* file
    doesn’t exist, Notepad will ask you whether you’d like to create a new *word_count.py*
    file. Click **Yes** and you’ll be ready to type your Python program.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'On macOS, you can use whichever text editor you like. One editor that you likely
    already have installed is TextEdit. At the operating system command prompt, navigate
    to your *programming* folder if you’re not already there. Then type the following
    two commands, pressing ENTER after each one:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: $ touch word_count.py
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: $ open -a TextEdit word_count.py
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The touch command creates an empty file so that your text editor can open it.
    Now you’re ready to type your Python program.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: On Linux, you can use whichever text editor you like. One editor that you likely
    already have installed is gedit. At the operating system command prompt, navigate
    to your *programming* folder if you’re not already there. Then type gedit word_count.py
    and press ENTER. Now you’re ready to type your Python program.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，你可以使用任何你喜欢的文本编辑器。你可能已经安装的一个编辑器是 gedit。在操作系统的命令提示符下，如果你还没有在那里，请导航到你的*编程*文件夹。然后输入
    gedit word_count.py 并按回车键。现在你可以输入你的 Python 程序了。
- en: The Program
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 程序
- en: With your text editor loaded, you can type the code of our Python program. The
    code is in [Listing 1-1](ch01.xhtml#ch01ex01).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载好文本编辑器后，你可以输入我们的 Python 程序代码。代码位于[清单 1-1](ch01.xhtml#ch01ex01)。
- en: ❶ line = input()
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ line = input()
- en: ❷ total_words = line.count(' ') + 1
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ total_words = line.count(' ') + 1
- en: ❸ print(total_words)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ print(total_words)
- en: '*Listing 1-1: Solving Word Count*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-1：解决单词计数*'
- en: When entering that code, don’t enter the ❶, ❷, or ❸. Those are there to help
    us walk through the code and are not part of the code itself.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 输入代码时，请不要输入 ❶、❷ 或 ❸。它们是用来帮助我们逐步讲解代码的，不是代码的一部分。
- en: We begin by acquiring the line of text from the input and assigning it to a
    variable ❶. That gives us a string, on which we can use the count method. We add
    1 to the count of spaces to account for the final word in the string, and we use
    the variable total_words to refer to that result ❷. The last thing to do is output
    the value referred to by total_words ❸.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从输入中获取一行文本，并将其赋值给变量 ❶。这将得到一个字符串，我们可以在其上使用 count 方法。我们将空格的计数加 1，以考虑字符串中的最后一个单词，并使用变量
    total_words 来引用这个结果 ❷。最后一步是输出 total_words 所引用的值 ❸。
- en: Be sure to save the file once you’ve finished typing the code.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 完成代码输入后，请务必保存文件。
- en: Running the Program
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行程序
- en: To run the program, we’ll use the python command from our operating system command
    prompt. As we’ve seen, entering python by itself runs the Python shell, but we
    don’t want that this time. Instead, we want to tell Python to run the program
    in *word_count.py*. To do that, navigate to your *programming* folder, and enter
    python word_count.py. Here and throughout the book, please use the python3 command
    instead of the python command if needed.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，我们将在操作系统命令提示符下使用 python 命令。正如我们之前看到的，单独输入 python 会运行 Python shell，但这次我们不想这样做。相反，我们要告诉
    Python 运行 *word_count.py* 程序。为此，导航到你的 *编程* 文件夹，输入 python word_count.py。这里以及在全书中，如果需要，请使用
    python3 命令，而不是 python 命令。
- en: 'Your program is now waiting at the input prompt for you to type something.
    Type a few words, press ENTER, and you should see our program working correctly.
    For example, type the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的程序在输入提示符下等待你输入内容。输入几个单词，按回车键，你应该能看到程序正确运行。例如，输入以下内容：
- en: this is my first python program
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的第一个 Python 程序
- en: You should see the program produce 6 as the output.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到程序输出 6 作为结果。
- en: If instead you see a Python error, go back over the code and make sure you’ve
    typed it in exactly. Python requires precision. Even a missing parenthesis or
    single quote will lead to an error.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到 Python 错误，请仔细检查代码，确保你完全输入正确。Python 要求精确。即使缺少一个括号或单引号，也会导致错误。
- en: Don’t be frustrated if it takes you some time to get this program to run. Getting
    a first program to run can require a lot of work. We have to be able to type a
    program into a file, invoke Python to run that program, and fix any errors resulting
    from an incorrect program. But the procedure for running programs doesn’t change,
    no matter how complex the program, so time you spend here will be well worth it
    as you work through the rest of the book.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花一些时间才让程序运行，不要感到沮丧。让第一个程序运行可能需要做很多工作。我们必须能够将程序输入到文件中，调用 Python 运行该程序，并修复由于程序错误导致的问题。但运行程序的过程是固定的，无论程序多复杂，所以在这里花的时间会为你完成书中的其余内容打下坚实的基础。
- en: Submitting to the Judge
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提交给评测系统
- en: Congratulations! I hope it was satisfying to run your first Python program on
    your computer. But how do we know this program is correct? Does it work for all
    possible strings? We can test it on a few more strings, but the way we’ll gain
    even more confidence in the correctness of our code is by submitting it to the
    online judge. The judge automatically runs a bunch of tests on our code and tells
    us whether we passed the tests or if something is wrong.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！希望你运行第一个 Python 程序时感到满足。但我们怎么知道这个程序是正确的呢？它对所有可能的字符串都有效吗？我们可以再对几个字符串进行测试，但我们将通过将代码提交给在线评测来更有信心地判断它的正确性。评测系统会自动对我们的代码进行一系列测试，并告诉我们是否通过了测试，或者是否有错误。
- en: Go to *[https://dmoj.ca/](https://dmoj.ca/)* and log in. (If you don’t have
    a DMOJ account, please create one following the instructions in the introduction.)
    Click **Problems**, and search for the Word Count problem code dmopc15c7p2. Click
    the search result to load the problem—it’s called Not a Wall of Text rather than
    Word Count.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: You should then see the text of the problem, as written by the problem author.
    Click **Submit Solution**, and paste our code into the text area. Be sure to select
    Python 3 as the programming language. Finally, click the **Submit** button.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ runs tests on our code and shows us the results. For each test case, you’ll
    see a status code. *AC* stands for *accepted* and is what you want to see for
    each test case. Other codes include *WA* (*wrong answer*) and *TLE* (*time limit
    exceeded*). If you see one of these, double-check the code that you pasted, making
    sure it exactly matches the code from your text editor.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Assuming all test cases are accepted, we should see that our score is 100/100
    and that we’ve earned 3 points for our work.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: For each problem, we’ll follow the approach that we used to solve Word Count.
    First, we’ll explore using the Python shell, learning new Python features as needed.
    Then, we’ll write a program that solves the problem. We’ll test that program on
    our computer by supplying our own test cases. Finally, we’ll submit the code to
    the judge. If any test cases fail, we’ll look over our code again and fix the
    problem.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #2: Cone Volume'
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Word Count, we needed to read a string from the input. In this problem, we’ll
    need to read integers from the input. Doing so requires an extra step to produce
    an integer from a string. We’ll also learn a little more about doing math in Python.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem dmopc14c5p1.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Calculate the volume of a right circular cone.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input consists of two lines of text. The first line contains integer *r*,
    the radius of the cone. The second line contains integer *h*, the height of the
    cone. Both *r* and *h* are between 1 and 100\. (That is, the minimum value for
    *r* and *h* is 1, and the maximum value is 100.)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Output
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the volume of the right circular cone with radius *r* and height *h*.
    The formula to calculate the volume is (*πr*²*h*)/3.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: More Math in Python
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Say we have r and h variables referring to a radius and height, respectively:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r = 4'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '>>> h = 6'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to evaluate (*πr*²*h*)/3\. Substituting a radius of 4 and height
    of 6, we have (*π* * 4² * 6)/3\. Using a value of 3.14159 for *π*, a calculator
    gives a result of 100.531. How can we do this in Python?
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Pi
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To access the value of *π*, we’ll use a suitable variable. Here’s an assignment
    statement to PI with a lot of accuracy in its value:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: PI = 3.141592653589793
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: This is more a *constant* than a variable, since we’ll never want to change
    the value of PI in our code. It’s Python convention to use uppercase letters for
    such variables, as I’ve done here.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Exponents
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Looking back at our formula, (*πr*²*h*)/3, the only thing we haven’t talked
    about yet is how to perform the *r*² part. Since *r*² is the same as *r* * *r*,
    we can use multiplication rather than exponentiation.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r * r'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'But it’s more transparent to use exponentiation directly. We always want to
    write code that’s as clear as possible. Besides, one day you might have to calculate
    larger exponents, where repeated multiplication becomes increasingly unwieldy.
    Python’s exponentiation operator is **:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r ** 2'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the complete formula:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '>>> (PI * r ** 2 * h) / 3'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '100.53096491487338'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Great—that’s close to the 100.531 result we expected!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re producing a floating-point number here. As we discussed in
    “Integer and Floating-Point Numbers” in this chapter, the / division operator
    produces a floating-point result.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Converting Between Strings and Integers
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re ultimately going to have to read the radius and height as input. We’ll
    then use those values to calculate the volume. Let’s give it a try:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r = input()'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '>>> h = input()'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'The input function always returns a string, even if the user types an integer:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '''4'''
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '>>> h'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '''6'''
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'The single quotes confirm that these values are strings. Strings cannot be
    used to perform mathematical calculations. If we try, we get an error:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '>>> (PI * r ** 2 * h) / 3'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: unsupported operand type(s) for ** or pow(): ''str'' and ''int'''
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: A TypeError is generated when we use values of the wrong type. Python is objecting
    to us using the ** operator on the string referred to by r and the integer 2.
    The ** operator is purely mathematical and has no meaning when used with strings.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert our strings to integers, we can use Python’s int function:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '''4'''
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '>>> h'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '''6'''
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r = int(r)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '>>> h = int(h)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '>>> r'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '>>> h'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can once again use these values in our formula:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '>>> (PI * r ** 2 * h) / 3'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '100.53096491487338'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you have a string whose characters represent an integer, you can use
    the int function to convert it to a value whose type is integer. It can cope with
    leading and trailing spaces, but not non-numeric characters:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '>>> int(''  12  '')'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '>>> int(''12x'')'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'ValueError: invalid literal for int() with base 10: ''12x'''
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'When converting a string returned by input to an integer, we can take it in
    two steps, first assigning the return value of input to a variable and then converting
    that value to an integer:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num = input()'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num = int(num)'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can combine the input and int calls:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num = int(input())'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '82'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Here, the argument passed to int is the string returned by input. The int function
    takes this string and returns it as an integer.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'If we ever need to convert the other way, from an integer to a string, we can
    do that with the str function:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num = 82'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''my number is '' + num'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeError: can only concatenate str (not "int") to str'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '>>> str(num)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '''82'''
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''my number is '' + str(num)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '''my number is 82'''
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: We can’t concatenate a string and an integer. The str function returns '82'
    from 82 so that it can be used in a string concatenation.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re ready to solve Cone Volume. Create a text file called *cone_volume.py*
    and type the code in [Listing 1-2](ch01.xhtml#ch01ex02).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: ❶ PI = 3.141592653589793
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: ❷ radius = int(input())
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: ❸ height = int(input())
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: ❹ volume = (PI * radius ** 2 * height) / 3
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: ❺ print(volume)
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 1-2: Solving Cone Volume*'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included blank lines to separate the code into its logical pieces. Python
    ignores these blank lines, but such blank lines can make it easier for us to read
    and chunk the code.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that I’ve used descriptive variable names: radius instead of r, height
    instead of h, and volume. Single-letter variable names are the norm in math formulas,
    but when writing code, we can use variable names that convey more information.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: We begin by making a variable called PI refer to an approximation of pi ❶. We
    then read the radius ❷ and height ❸ from the input, converting both from strings
    to integers. We use the formula for the volume of a right circular cone to compute
    the volume ❹. Lastly, we output the volume ❺.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Save your *cone_volume.py* file.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Run your program by typing python cone_volume.py and then type a value for the
    radius and a value for the height. Use a calculator to verify that your program
    produces the correct output!
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if you type garbage for the radius or height? For example, run
    your program and type the following:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: xyz
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see an error:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: File "cone_volume.py", line 3, in <module>
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: radius = int(input())
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'ValueError: invalid literal for int() with base 10: ''xyz'''
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: It is not user-friendly at all, that’s for sure. But for purposes of learning
    to program, we won’t worry about this. All of the test cases on the judge will
    be valid according to the problem’s input specification, so we’ll never have to
    worry about what to do with invalid input.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of the judge, DMOJ owes us three points, because we’ve finished writing
    correct code for this problem. Go ahead and submit your work!
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And we’re off! We’ve just solved our first two problems by writing Python code.
    We learned about the fundamentals of programming, including values, types, strings,
    integers, methods, variables, the assignment statement, and input and output.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re comfortable with this material—perhaps by working on some of the
    following exercises—it’s on to [Chapter 2](ch02.xhtml#ch02). There, we’ll learn
    how our programs can make decisions. We’ll no longer be writing programs that
    invariably run from top to bottom. They’ll be more flexible, doing what’s needed
    for the specific problem instance being solved.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each chapter ends with some exercises for you to try. I encourage you to complete
    as many exercises as you can.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Some exercises may take you a long time. You might get frustrated with repeated
    Python errors. Like with any skill worth learning, focused practice is needed.
    When you’re starting to work on an exercise, I recommend solving a few examples
    by hand. That way you know what the problem is asking and what your program is
    supposed to do. Otherwise, you might be writing code without a plan, contending
    both with organizing your thoughts and with writing the program at the same time.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'If your code isn’t working, ask: what, precisely, is the behavior that you
    want? What are the lines of code that are likely culprits for the error that you’re
    getting? Is there another, perhaps simpler, approach you could try?'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included solutions to the exercises on the book website (*[https://nostarch.com/learn-code-solving-problems/](https://nostarch.com/learn-code-solving-problems/)*).
    But don’t peek at those until you’ve given your chosen exercise an honest try.
    Or two. Or three. If you do look at a solution and learn how one might solve the
    problem, take a break and then try solving it yourself from scratch. There’s often
    more than one way to solve a problem. If your solution does the right thing but
    is different from mine, it doesn’t mean that one of us is wrong. Rather, it serves
    as an opportunity for you to compare your code to mine, perhaps learning alternate
    techniques in the process.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem wc16c1j1, A Spooky Season
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem wc15c2j1, A New Hope
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ccc13j1, Next in Line
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem wc17c1j2, How’s the Weather? (Be careful with the direction of
    conversion!)
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DMOJ problem wc18c3j1, An Honest Day’s Work (Hint: how can you determine the
    number of bottle caps and the total paint required by those bottle caps?)'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Word Count is originally from the DMOPC ’15 April Contest. Cone Volume is originally
    from the DMOPC ’14 March Contest.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
