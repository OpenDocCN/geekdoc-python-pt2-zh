<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_203"/><span class="big">8</span><br/>DRAWING VECTOR IMAGES</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">We’re about to start drawing images described by mathematical equations, a topic as fascinating as it is entertaining. We call images consisting of geometric primitives <em>vector images</em>, as opposed to <em>bitmap images</em>, which are sometimes also called <em>raster images</em>. Vector images are perfect for plotting the results of engineering problems that often come in the form of diagrams and simplified problem geometries.</p>&#13;
<p class="indent">In this chapter, we’ll create our own Python package capable of creating SVG images out of the geometric primitives we created in <a href="part02.xhtml#part02">Part II</a> of the book: points, segments, circles, polygons, and so on. In later chapters, when we use code to solve actual mechanics problems, this package will help us produce graphical results.</p>&#13;
<p class="indent">There are good SVG packages out there (such as <em>svgwrite</em>, for instance), and we could just import them, but this book is about learning by doing, so we won’t be using anything besides the Python Standard Library and our own code.</p>&#13;
<p class="indent">For the sake of brevity, we won’t be writing unit tests in this chapter, but if you download the code, you’ll see I wrote them to make sure everything <span epub:type="pagebreak" id="page_204"/>works as it should. I encourage you to try to write your own unit tests for functions in this chapter and then compare them to the code I provided.</p>&#13;
<p class="indent">This chapter will introduce a powerful concept: <em>templating</em>. When templating, we have a piece of text, the <em>template</em>, that can be customized by filling in different placeholders. This technique is widely used in web development to produce the HTML document that gets rendered in your browser. Here again, there are many good templating libraries (such as <em>jinja2</em> or <em>mako</em>), but we want to learn how they work behind the scenes, so instead of using any of them, we’ll write our own templating logic.</p>&#13;
<h3 class="h3" id="ch00lev1sec48"><strong>Bitmaps and Vector Images</strong></h3>&#13;
<p class="noindent">There are two types of images: <em>bitmaps</em> and <em>vectors</em>. You’ve likely seen bitmap images before: <em>.jpeg</em>, <em>.gif</em>, and <em>.png</em> are all examples of bitmap image formats. A bitmap is an image defined over a grid of pixels where each individual pixel is assigned a particular color. These images look nice in their original size, but if you zoom in, you may start to distinguish those squares, the pixels.</p>&#13;
<p class="indent">Vector images, on the other hand, define their content by means of mathematical equations. This has the advantage of scaling smoothly without losing any quality. Let’s explore <em>.svg</em>, the most widely used vector image format and the one we’ll be using in this book.</p>&#13;
<h3 class="h3" id="ch00lev1sec49"><strong>The SVG Format</strong></h3>&#13;
<p class="noindent">SVG stands for Scalable Vector Graphics. Its specification was developed by the <em>World Wide Web Consortium (W3C)</em> and is an open standard. I recommend that you open <a href="https://developer.mozilla.org/en-US/docs/Web/SVG"><em>https://developer.mozilla.org/en-US/docs/Web/SVG</em></a> and have it with you as a reference to look at; it’ll provide more complete descriptions and examples that can complement the ones in this book. If you ever need to add something new to your SVG package, this page will be your ally.</p>&#13;
<p class="indent">Let’s look at the following definition from the Mozilla website mentioned above for a quick reference on how these kinds of images are defined, as it beautifully describes the process:</p>&#13;
<div class="quote">&#13;
<p class="noindent">SVG images and their related behaviors are defined in XML text files, which means they can be searched, indexed, scripted, and compressed. Additionally, this means they can be created and edited with any text editor and with drawing software.</p>&#13;
</div>&#13;
<p class="noindent">Note that SVG images are defined as plaintext, whereas most other image formats are binary encoded. This means we can readily automate the creation of SVG images and even inspect the contents of an existing image.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_205"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This chapter assumes you have a basic understanding of XML format, but if you don’t, don’t worry; it’s quite simple to learn. Check the following resources to get started with it:</em> <a href="https://www.w3schools.com/xml">https://www.w3schools.com/xml</a> <em>and</em> <a href="https://www.xmlfiles.com/xml">https://www.xmlfiles.com/xml</a>.</p>&#13;
</div>&#13;
<p class="indent">Let’s try to create our first SVG image. Open your favorite plaintext editor such as Sublime Text, Visual Studio Code, Atom, or even PyCharm if you want, and write <a href="ch08.xhtml#ch8lis1">Listing 8-1</a>.</p>&#13;
<pre>&lt;svg  width="500" height="500"&gt;&#13;
    &lt;circle cx="200" cy="200" r="100" fill="#ff000077" /&gt;&#13;
    &lt;circle cx="300" cy="200" r="100" fill="#00ff0077" /&gt;&#13;
    &lt;circle cx="250" cy="300" r="100" fill="#0000ff77" /&gt;&#13;
&lt;/svg&gt;</pre>&#13;
<p class="caption"><a id="ch8lis1"/><em>Listing 8-1: SVG description of several circles</em></p>&#13;
<p class="indent">Note that you shouldn’t create SVG files using a rich-text editor such as Word. These rich-text editors add their own markings into the raw file and break the SVG format.</p>&#13;
<p class="indent">Once you’ve copied what’s in <a href="ch08.xhtml#ch8lis1">Listing 8-1</a>, save the file as <em>circles.svg</em>, and open it using either Chrome or Firefox. Believe it or not, browsers are some of the best SVG image viewers. Using their <em>developer tools</em>, we can inspect the different parts that make up an image, something that will prove useful later when we build more complex images. You should see something like <a href="ch08.xhtml#ch8fig1">Figure 8-1</a> (there’ll be colors on your screen, but the print version of the book is in grayscale). Zoom in on the image, and you’ll see how it retains its crispness.</p>&#13;
<div class="image"><img src="../images/08fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig1"><em>Figure 8-1: Examples of SVG circles</em></p>&#13;
<p class="indent">Let’s break down the code in <a href="ch08.xhtml#ch8lis1">Listing 8-1</a>. The first and most cryptic line contains the <em>XML namespace</em> (<span class="literal">xmln</span>) attribute.</p>&#13;
<pre> width="500" height="500"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_206"/>We have to include this namespace definition in every <span class="literal">svg</span> opening tag. The <span class="literal">width</span> and <span class="literal">height</span> attributes determine the size of the image in pixels. SVG <em>attributes</em> are modifiers that affect how a particular element is rendered. The <span class="literal">width</span> and <span class="literal">height</span> attributes, for example, determine the size of the drawing.</p>&#13;
<p class="indent">Then, between the <span class="literal">svg</span> open and close tags is the actual definition of what is drawn, in this case three circles:</p>&#13;
<pre>&lt;circle cx="200" cy="200" r="100" fill="#ff000077" /&gt;&#13;
&lt;circle cx="300" cy="200" r="100" fill="#00ff0077" /&gt;&#13;
&lt;circle cx="250" cy="300" r="100" fill="#0000ff77" /&gt;</pre>&#13;
<p class="indent">As you may have guessed, <span class="literal">cx</span> and <span class="literal">cy</span> correspond to the coordinates of the center point; <span class="literal">r</span> is the radius of the circle. The attribute <span class="literal">fill</span> determines the fill color for the circles in hexadecimal format: <span class="literal">#rrggbbaa</span>, where <span class="literal">rr</span> is the red value, <span class="literal">gg</span> is the green value, <span class="literal">bb</span> is the blue value, and <span class="literal">aa</span> is the alpha or opacity value (see <a href="ch08.xhtml#ch8fig2">Figure 8-2</a>).</p>&#13;
<div class="image"><img src="../images/08fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig2"><em>Figure 8-2: Hexadecimal color components</em></p>&#13;
<p class="indent">For example, the color <span class="literal">#ff000077</span> has the following components:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><strong>red</strong>    <span class="literal">ff</span>, the maximum value (255 in base 10)</p>&#13;
<p class="noindentin"><strong>green</strong>    <span class="literal">00</span>, the minimum value (0 in base 10)</p>&#13;
<p class="noindentin"><strong>blue</strong>    <span class="literal">00</span>, the minimum value (0 in base 10)</p>&#13;
<p class="noindentin"><strong>alpha</strong>    <span class="literal">77</span>, a value of 119 out of 255, which equals an alpha percentage of around 47%</p>&#13;
</div>&#13;
<p class="indent">This color is a perfect red with some transparency added to it.</p>&#13;
<p class="indent">You may not have realized, but the origin of coordinates for SVG images is located in the upper-left corner, with its y-axis pointing down. You may not be used to this orientation of the vertical axis, but don’t worry: by using one of our affine transformations, we can easily transform space so that the y-axis points upward, as you’ll see later in the chapter. <a href="ch08.xhtml#ch8fig3">Figure 8-3</a> shows the geometry and arrangement of coordinates for the image we created.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_207"/><img src="../images/08fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig3"><em>Figure 8-3: The geometry of our first SVG image</em></p>&#13;
<h4 class="h4" id="ch00lev2sec92"><strong><em>The viewBox</em></strong></h4>&#13;
<p class="noindent">A useful attribute that we can define for the <span class="literal">svg</span> tag is the <span class="literal">viewBox</span>. The <span class="literal">viewBox</span> is the rectangular portion of the image the user sees. It’s defined using four numbers,</p>&#13;
<pre>viewBox="x y w h"</pre>&#13;
<p class="noindent">where <span class="literal">x</span> and <span class="literal">y</span> are the coordinates of the rectangle’s origin, and <span class="literal">w</span> and <span class="literal">h</span> are the width and height of the rectangle.</p>&#13;
<p class="indent">Let’s add a <span class="literal">viewBox</span> to our circles image to see its effect (see <a href="ch08.xhtml#ch8lis2">Listing 8-2</a>).</p>&#13;
<pre>&lt;svg &#13;
    width="500"&#13;
    height="500"&#13;
    <span class="codestrong1">viewBox="100 100 300 300"</span>&gt;&#13;
    &lt;circle cx="200" cy="200" r="100" fill="#ff000077" /&gt;&#13;
    &lt;circle cx="300" cy="200" r="100" fill="#00ff0077" /&gt;&#13;
    &lt;circle cx="250" cy="300" r="100" fill="#0000ff77" /&gt;&#13;
&lt;/svg&gt;</pre>&#13;
<p class="caption"><a id="ch8lis2"/><em>Listing 8-2: SVG <span class="codeitalic1">viewBox</span></em></p>&#13;
<p class="indent">Save the changes we made in <a href="ch08.xhtml#ch8lis2">Listing 8-2</a> and reload the image in the browser to see the change. To understand what’s happened, take a look at <a href="ch08.xhtml#ch8fig4">Figure 8-4</a>.</p>&#13;
<p class="indent">We’ve defined a rectangle whose origin is at (100, 100), with a width of 300 and a height of 300: a rectangle that contains all three circles without any margin. Notice the image retains its size of 500 by 500 pixels, as defined by the <span class="literal">width</span> and <span class="literal">height</span> attributes. If the size of the <span class="literal">viewBox</span> is not the same as the size of the SVG itself, the content is scaled.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_208"/><img src="../images/08fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig4"><em>Figure 8-4: The <em>viewBox</em> of an SVG image</em></p>&#13;
<p class="indent">The <span class="literal">viewBox</span> is therefore the rectangular portion from the infinite canvas that’s displayed to the user. It’s optional, and it defaults to the rectangle with the size defined by <span class="literal">width</span> and <span class="literal">height</span>, with its origin at (0, 0).</p>&#13;
<h4 class="h4" id="ch00lev2sec93"><strong><em>Space Transformation</em></strong></h4>&#13;
<p class="noindent">Remember the concept of affine transformations from <a href="ch07.xhtml#ch07">Chapter 7</a>? SVG images use them to transform their content. The attribute <span class="literal">transform</span> can be used to define the affine transformation matrix as follows:</p>&#13;
<pre>transform="matrix(sx shy shx sy tx ty)"</pre>&#13;
<p class="indent">The confusing order of the matrix terms may seem surprising at first, but it actually makes sense, at least for the people behind the SVG standard. The SVG documentation defines the affine transformation matrix as follows:</p>&#13;
<div class="equationc"><img src="../images/f0208-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">So these are the terms of the <span class="literal">transform</span> attribute:</p>&#13;
<pre>transform="matrix(a b c d e f)"</pre>&#13;
<p class="noindent">Translated to our less cryptic language, the terms are <em>a</em> = <em>s</em><sub><em>x</em></sub>, <em>b</em> = <em>sh</em><sub><em>y</em></sub>, <em>c</em> = <em>sh</em><sub><em>x</em></sub>, <em>d</em> = <em>s</em><sub><em>y</em></sub>, <em>e</em> = <em>t</em><sub><em>x</em></sub>, and <em>f</em> = <em>t</em><sub><em>y</em></sub>:</p>&#13;
<div class="equationc"><img src="../images/f0208-02.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_209"/>Let’s see it in action. We’ll apply a shear in the x direction by setting <em>sh</em><sub><em>x</em></sub> to be 1. Remember that both <em>s</em><sub><em>x</em></sub> and <em>s</em><sub><em>y</em></sub> have to be 1; otherwise, if set as zero, the image would collapse in a line or point, and we wouldn’t see anything. <a href="ch08.xhtml#ch8lis3">Listing 8-3</a> has the added <span class="literal">transform</span> attribute.</p>&#13;
<pre>&lt;svg &#13;
    width="500"&#13;
    height="500"&#13;
    <span class="codestrong1">transform="matrix(1 0 1 1 0 0)"</span>&#13;
    &lt;circle cx="200" cy="200" r="100" fill="#ff000077" /&gt;&#13;
    &lt;circle cx="300" cy="200" r="100" fill="#00ff0077" /&gt;&#13;
    &lt;circle cx="250" cy="300" r="100" fill="#0000ff77" /&gt;&#13;
&lt;/svg&gt;</pre>&#13;
<p class="caption"><a id="ch8lis3"/><em>Listing 8-3: Shear transformation in circles image</em></p>&#13;
<p class="indent">Remember to remove the <span class="literal">viewBox</span> attribute so the resulting geometry doesn’t get cropped. You should see something like <a href="ch08.xhtml#ch8fig5">Figure 8-5</a>.</p>&#13;
<div class="image"><img src="../images/08fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig5"><em>Figure 8-5: Our circles once transformed</em></p>&#13;
<p class="indent">What about inverting the y-axis so that it points upward, like we’re used to? Easy! Edit the transform matrix to the following:</p>&#13;
<pre>transform="matrix(1 0 0 -1 0 0)"</pre>&#13;
<p class="indent">The resulting geometry you should see is outlined in <a href="ch08.xhtml#ch8fig6">Figure 8-6</a>. Compare it with <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>. See what happened? The picture flipped vertically.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_210"/><img src="../images/08fig06.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig6"><em>Figure 8-6: Transformed circles, with the y-axis inverted</em></p>&#13;
<p class="indent">Now that you have a basic understanding of how to create SVG images, let’s do some Python coding. We’ll create a package in our project to draw SVG images.</p>&#13;
<h3 class="h3" id="ch00lev1sec50"><strong>The svg Package</strong></h3>&#13;
<p class="noindent">Let’s create a new package for graphics in our project, which will contain a subpackage to produce SVG images. Later in the book we’ll add other subpackages for other kinds of graphical operations. Right-click the project name in the <strong>Project Tool</strong> window and choose <strong>New</strong> ▸ <strong>Python Package</strong>. Name it <em>graphic</em>. You can also create a new folder yourself, but don’t forget to add the <em>__init__.py</em> file to instruct Python this is a package.</p>&#13;
<p class="indent">You should have the package at the same level as <em>geom2d</em>, and it should contain only an <em>__init__.py</em> file. Your project’s directory structure should look like this:</p>&#13;
<p class="pre2">    Mechanics<br/>      |- geom2d<br/>      |    |- tests<br/>      |- graphic<br/>      |- utils</p>&#13;
<p class="indent">Now let’s add the <em>svg</em> subpackage: right-click the package you just created and choose <strong>New</strong> ▸ <strong>Python Package</strong> again, but this time name it <em>svg</em>. Now we’re ready to start adding our code.</p>&#13;
<h4 class="h4" id="ch00lev2sec94"><strong><em>Templates</em></strong></h4>&#13;
<p class="noindent">A template is a document with some placeholders in it. By assigning values to these placeholders we can produce a complete version of the document. Think, for instance, about those email campaigns that greet you by your name. The company sending them probably has a template like<span epub:type="pagebreak" id="page_211"/></p>&#13;
<p class="pre2">    Hello, {{name}}!<br/>    Here are some book recommendations we think you may like.<br/>    ...</p>&#13;
<p class="noindent">and an automatic process that substitutes the <span class="literal">{{name}}</span> placeholder with each of their clients’ names and then sends the final composed email.</p>&#13;
<p class="indent">The placeholders in a template may also be called <em>variables</em>. Variables are given values in the process of rendering the template, which produces the final document with everything defined in it. <a href="ch08.xhtml#ch8fig7">Figure 8-7</a> illustrates the process of rendering the same template with two different sets of values. The template has the variables <span class="literal">place-from</span>, <span class="literal">place-to</span>, <span class="literal">distance</span>, and <span class="literal">units</span>, which we assign different values to produce different versions of the same template.</p>&#13;
<div class="image"><img src="../images/08fig07.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig7"><em>Figure 8-7: Template rendering process</em></p>&#13;
<p class="indent">Using templates is a powerful technique that solves a variety of problems where text of any shape and format needs to be generated. Most web frameworks, for instance, use some kind of templating to produce the rendered HTML document. We’ll employ a template to generate our SVG images.</p>&#13;
<h5 class="h5" id="ch00lev3sec51"><strong>An Example Using Python’s String Replacement</strong></h5>&#13;
<p class="noindent">Let’s work on a template example in code. Open Python’s shell and enter the following template string:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">template = 'Hello, my name is {{name}}'</span></pre>&#13;
<p class="noindent">Now, let’s create a greeting by substituting the <span class="literal">{{name}}</span> variable with a real name:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">template.replace('{{name}}', 'Angel')</span>&#13;
'Hello, my name is Angel'</pre>&#13;
<p class="indent">As you can see, we can use Python’s <span class="literal">replace</span> string method to create a new string where <span class="literal">{{name}}</span> has been replaced by ’<span class="literal">Angel</span>’. Since <span class="literal">replace</span> returns a new instance, we can chain the calls like so:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">template.replace('{{name}}', 'Angel').replace('Hello', 'Hi there')</span>&#13;
'Hi there, my name is Angel'</pre>&#13;
<p class="indent">In this example, we first replaced the <span class="literal">{{name}}</span> variable with the string ’<span class="literal">Angel</span>’. Then, we called the <span class="literal">replace</span> method on the resulting string to substitute the word ’<span class="literal">Hello</span>’ with ’<span class="literal">Hi there</span>’.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_212"/>Note that we can substitute whatever sequence of characters we want using the <span class="literal">replace</span> method; there’s no need for our replacement targets to appear between braces, like for instance we did with <span class="literal">{{name}}</span>. Using the double braces is a convention for us to quickly identify a variable inside a template. This convention also serves the purpose of preventing unwanted replacements: it’s unlikely that our templates include anything inside two levels of braces, except for our variables.</p>&#13;
<p class="indent">Now that we know how to work with template strings in Python, let’s see how we can define templates in separate files and load them into strings in our code.</p>&#13;
<h4 class="h4" id="ch00lev2sec95"><strong><em>Loading Templates</em></strong></h4>&#13;
<p class="noindent">To avoid mixing XML and Python code, we want to separate the definitions of SVG tags into their own files. The files containing the XML need to have placeholders where the actual data will be inserted. For example, our circle definition file could look something like this:</p>&#13;
<pre>&lt;circle cx="{{cx}}" cy="{{cy}}" r="{{r}}" /&gt;</pre>&#13;
<p class="indent">Here we’ve put placeholders using double braces. We’ll use code to load this definition into a string and replace the placeholders with the actual coordinates of the center and the radius of the circle.</p>&#13;
<p class="indent">We’ll be creating a few templates, so let’s create a folder named <em>templates</em> inside the <em>svg</em> package by right-clicking the package name and choosing <strong>New</strong> ▸ <strong>Directory</strong>. We need a function that reads the templates inside this folder by their name and returns their content as a string. In the <em>svg</em> package, but not in the <em>templates</em> folder, create a new file named <em>read.py</em> and add the code in <a href="ch08.xhtml#ch8lis4">Listing 8-4</a>.</p>&#13;
<pre>from os import path&#13;
&#13;
import pkg_resources as res&#13;
&#13;
&#13;
def read_template(file_name: str):&#13;
    file_path = path.join('templates', file_name)&#13;
    bytes_str = res.resource_string(__name__, file_path)&#13;
    return bytes_str.decode('UTF-8')</pre>&#13;
<p class="caption"><a id="ch8lis4"/><em>Listing 8-4: Reading the content of a template file</em></p>&#13;
<p class="indent">Let’s break <a href="ch08.xhtml#ch8lis4">Listing 8-4</a> down. The first thing we do in the function is obtain the path inside <em>templates</em> where the file lives. We do this using the <span class="literal">os.path</span> module’s <span class="literal">join</span> function. This function computes the path by joining the parts passed as arguments and using the correct separator for your operating system. For instance, Unix-based operating systems use the / character.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_213"/>Then, using <span class="literal">resource_string</span> from the <em>pkg_resources</em> module, we read the file as a <em>byte string</em>. A file is stored to disk as a sequence of bytes, so when we read it using the <span class="literal">resource_string</span> function, we get this byte string. To convert it to a Unicode character string, we need to <em>decode</em> it. For this, byte strings have the method <span class="literal">decode</span>, which accepts the encoding as an argument.</p>&#13;
<p class="indent">We return the result of decoding the string of bytes using UTF-8 encoding. This will give us a string version of the template we can easily work with.</p>&#13;
<h4 class="h4" id="ch00lev2sec96"><strong><em>Image Templates</em></strong></h4>&#13;
<p class="noindent">The most important template we want to define is the template for the SVG image. Create a new text file named <em>img</em> (without an extension; we don’t need one) in the <em>templates</em> folder and include the definition in <a href="ch08.xhtml#ch8lis5">Listing 8-5</a>.</p>&#13;
<pre>&lt;svg  version="1.1"&#13;
     width="{{width}}"&#13;
     height="{{height}}"&#13;
     viewBox="{{viewBox}}"&#13;
     transform="matrix({{transf}})"&gt;&#13;
    {{content}}&#13;
&lt;/svg&gt;</pre>&#13;
<p class="caption"><a id="ch8lis5"/><em>Listing 8-5: SVG image template</em></p>&#13;
<p class="indent">This template includes five placeholders that need to be replaced with the actual values from the resulting image. We can try to load the template in Python’s shell using the <span class="literal">read_template</span> function we defined earlier:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from graphic.svg.read import read_template</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">read_template('img')</span>&#13;
'&lt;svg  version="1.1"\n  width="{{width}}"...'</pre>&#13;
<p class="indent">Let’s create a new file <em>image.py</em> in the <em>svg</em> directory (but outside the <em>templates</em> folder!) and define a function that reads in the file and does the replacement. In your <em>image.py</em> file, enter the code in <a href="ch08.xhtml#ch8lis6">Listing 8-6</a>.</p>&#13;
<pre>from geom2d import AffineTransform, Rect, Point, Size&#13;
from graphic.svg.read import read_template&#13;
&#13;
&#13;
def svg_content(&#13;
        size: Size,&#13;
        primitives: [str],&#13;
        viewbox_rect=None,&#13;
        transform=None&#13;
):&#13;
 <span class="ent">➊</span> viewbox_rect = viewbox_rect or __default_viewbox_rect(size)&#13;
 <span class="ent">➋</span> transform = transform or AffineTransform()&#13;
 <span class="ent">➌</span> template = read_template('img')<span epub:type="pagebreak" id="page_214"/>&#13;
    return template \&#13;
        .replace('{{width}}', str(size.width)) \&#13;
        .replace('{{height}}', str(size.height)) \&#13;
     <span class="ent">➍</span> .replace('{{content}}', '\n\t'.join(primitives)) \&#13;
     <span class="ent">➎</span> .replace('{{viewBox}}', __viewbox_from_rect(viewbox_rect)) \&#13;
     <span class="ent">➏</span> .replace('{{transf}}', __transf_matrix_vals(transform))</pre>&#13;
<p class="caption"><a id="ch8lis6"/><em>Listing 8-6: SVG image</em></p>&#13;
<p class="indent">The <span class="literal">svg_content</span> function takes four parameters; the last two, <span class="literal">viewbox_rect</span> and <span class="literal">transform</span>, are given a default value of <span class="literal">None</span>. We can use <span class="literal">or</span> so that <span class="literal">viewbox</span> <span class="literal">_rect</span> keeps its value if it’s not <span class="literal">None</span> and otherwise gets a default instance created by <span class="literal">__default_viewbox_rect</span> <span class="ent">➊</span> (we’ll write this function next). We do the same with <span class="literal">transform</span> <span class="ent">➋</span>, using an affine transformation constructed with the default values.</p>&#13;
<p class="indent">Then, using the function we prepared in the previous section, we load the template stored in <em>templates/img</em> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The last and most important step is to replace all placeholders in the loaded template string with the values we’ve been passed.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>One nice property of strings in Python, as in most programming languages, is that they’re immutable; you can’t take a string and change a character in it. What you do instead is create a new string with the desired change. This is how the</em> <span class="codeitalic">replace</span> <em>string method works: it replaces a given sequence of characters with another and returns a new string with the result. Thanks to this nice property, we can beautifully chain several</em> <span class="codeitalic">replace</span> <em>calls to the result of the call to</em> <span class="codeitalic">read_template</span>.</p>&#13;
</div>&#13;
<p class="indent">The replacements for the <span class="literal">{{width}}</span> and <span class="literal">{{height}}</span> placeholders are straightforward; just keep in mind that the passed-in <span class="literal">size.width</span> and <span class="literal">size.height</span> properties are numbers, so we need to convert them to their string representation using <span class="literal">str</span>.</p>&#13;
<p class="indent">The <span class="literal">primitives</span> parameter contains a sequence of strings representing the content of the image. We need to collect these strings in a single string. The <span class="literal">join</span> string method joins all the elements in a list together into a single string using the string it was called on as a separator. To obtain a string including all the primitives, we’ll use <span class="literal">join</span> <span class="ent">➍</span> on the list, with a new line and a tab character (<span class="literal">\n\t</span>) as the separator.</p>&#13;
<p class="indent">For <span class="literal">viewBox</span> we need to convert the <span class="literal">Rect</span> instance into the four numbers that define it <span class="ent">➎</span>; this is done with <span class="literal">__viewbox_from_rect</span>, which we’ll define in a minute. The same goes for <span class="literal">transf</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Let’s write the missing helping functions after <span class="literal">svg_content</span>. The code is in <a href="ch08.xhtml#ch8lis7">Listing 8-7</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def __default_viewbox_rect(size: Size):&#13;
    <span epub:type="pagebreak" id="page_215"/>return Rect(Point(0, 0), size)&#13;
&#13;
&#13;
def __viewbox_from_rect(rect: Rect):&#13;
    x = rect.origin.x&#13;
    y = rect.origin.y&#13;
    width = rect.size.width&#13;
    height = rect.size.height&#13;
&#13;
    return f'{x} {y} {width} {height}'&#13;
&#13;
&#13;
def __transf_matrix_vals(t: AffineTransform):&#13;
    return f'{t.sx} {t.shy} {t.shx} {t.sy} {t.tx} {t.ty}'</pre>&#13;
<p class="caption"><a id="ch8lis7"/><em>Listing 8-7: SVG image helper functions</em></p>&#13;
<p class="indent">The first function (<span class="literal">__default_viewbox_rect</span>) creates a rectangle for the <span class="literal">viewBox</span> using the point (0, 0) as the origin and the provided size. This function, as its name indicates, is used to provide a default value for the <span class="literal">viewbox</span> <span class="literal">_rect</span> parameter in case it wasn’t given by the user.</p>&#13;
<p class="indent">The <span class="literal">__viewbox_from_rect</span> function returns a string formatted to be used as <span class="literal">viewBox</span> inside the SVG definition. The last function, <span class="literal">__transf_matrix_vals</span>, does something similar: it converts an affine transformation into a string with the format expected by SVG.</p>&#13;
<p class="indent">Great! We now have a function that renders the SVG template into a string. Let’s take a look at some attributes we’ll add to almost all primitives.</p>&#13;
<h4 class="h4" id="ch00lev2sec97"><strong><em>Attributes</em></strong></h4>&#13;
<p class="noindent">The appearance of SVG elements can be modified using <em>attributes</em>. SVG attributes are defined following the XML attribute syntax (don’t forget that SVG images are defined following the XML format):</p>&#13;
<pre><span class="codeitalic1">name="value"</span></pre>&#13;
<p class="noindent">For example, we can use the <span class="literal">stroke</span> attribute to set a primitive’s stroke color:</p>&#13;
<pre>&lt;circle cx="10" cy="15" r="40" stroke="green" /&gt;</pre>&#13;
<p class="indent">Note that, in the previous example, the circle’s center coordinates (<span class="literal">cx</span> and <span class="literal">cy</span>) and radius (<span class="literal">r</span>) are also defined as attributes in the <span class="literal">circle</span> SVG element.</p>&#13;
<p class="indent">As we’re about to see, many SVG geometry primitives have shared attributes to define things such as the color of their stroke, the stroke’s width, the fill color, etc. To reuse this logic, we’ll place it in a file that all primitive generation functions will use. As these attribute definitions are short, we won’t include them in templates that need to be loaded; instead, we’ll define them inside the function that replaces the placeholders.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_216"/>Create a new file named <em>attributes.py</em> inside the <em>svg</em> directory. Your <em>graphic/svg</em> folder should look like the following:</p>&#13;
<p class="pre2">    svg<br/>      |- templates<br/>      |    |- img<br/>      |- __init__.py<br/>      |- attributes.py<br/>      |- image.py<br/>      |- read.py</p>&#13;
<p class="indent">Enter the functions in <a href="ch08.xhtml#ch8lis8">Listing 8-8</a>.</p>&#13;
<pre>from geom2d.affine_transf import AffineTransform&#13;
&#13;
&#13;
def stroke_color(color: str):&#13;
    return f'stroke="{color}"'&#13;
&#13;
&#13;
def stroke_width(width: float):&#13;
    return f'stroke-width="{str(width)}"'&#13;
&#13;
&#13;
def fill_color(color: str):&#13;
    return f'fill="{color}"'&#13;
&#13;
&#13;
def fill_opacity(opacity: float):&#13;
    return f'fill-opacity="{str(opacity)}"'&#13;
&#13;
&#13;
def affine_transform(t: AffineTransform):&#13;
    values = f'{t.sx} {t.shy} {t.shx} {t.sy} {t.tx} {t.ty}'&#13;
    return f'transform="matrix({values})"'&#13;
&#13;
&#13;
def font_size(size: float):&#13;
    return f'font-size="{size}px"'&#13;
&#13;
&#13;
def font_family(font: str):&#13;
    return f'font-family="{font}"'&#13;
&#13;
&#13;
def attrs_to_str(attrs_list: [str]):&#13;
    return ' '.join(attrs_list)</pre>&#13;
<p class="caption"><a id="ch8lis8"/><em>Listing 8-8: SVG attributes</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_217"/>All the functions are quite straightforward; they receive a value and return a string with the definition of an SVG attribute. We use single quotes around the returned strings, and this allows us to use double quotes inside without the need of escaping them. The SVG attributes are defined using double quotes, like, for example, <span class="literal">stroke="blue"</span>.</p>&#13;
<p class="indent">The last function takes some attributes and joins them into a string separating them with spaces. We achieve this using a single space (’ ’) as a separator for the <span class="literal">join</span> function. To fully understand how this works, give this a try in the shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">words = ['svg', 'is', 'a', 'nice', 'format']</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">' '.join(words)&#13;
'svg is a nice format'</span></pre>&#13;
<h3 class="h3" id="ch00lev1sec51"><strong>The SVG Primitives</strong></h3>&#13;
<p class="noindent">We’ve written the foundations of our <em>svg</em> package; we can now produce empty images, a process that involves reading the <em>img</em> template and replacing its variables. If we called our <span class="literal">svg_content</span> function from Python’s shell,</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from graphic.svg.image import svg_content</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from geom2d import Size</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">svg_content(Size(200, 150), [])</span></pre>&#13;
<p class="noindent">we’d get the following SVG content:</p>&#13;
<pre>&lt;svg  version="1.1"&#13;
     width="200"&#13;
     height="150"&#13;
     viewBox="0 0 200 150"&#13;
     transform="matrix(1 0 0 1 0 0)"&gt;&#13;
&lt;/svg&gt;</pre>&#13;
<p class="noindent">It’s a great beginning, but who wants blank images?</p>&#13;
<p class="indent">In the next sections, we’ll create a couple basic SVG primitives to add between the <span class="literal">&lt;svg&gt;&lt;/svg&gt;</span> tags: lines, rectangles, circles, polygons, and text labels, to name a few. As we’ll see throughout the book, we don’t need a lot of primitives to draw our engineering drawings; we can get pretty far with only straight lines, circles, and rectangles.</p>&#13;
<p class="indent">The strategy we’ll follow to produce these SVG primitives is the same we used for the SVG content: we’ll use a template to define the SVG code with variables that we’ll replace inside a function.</p>&#13;
<h4 class="h4" id="ch00lev2sec98"><strong><em>Lines</em></strong></h4>&#13;
<p class="noindent">The first primitive we’ll implement in our <em>svg</em> package is the line segment, or <span class="literal">line</span> in SVG parlance. This may be a little unfortunate, as segments and lines are different concepts. (Recall that lines are infinite, but segments are not; <span epub:type="pagebreak" id="page_218"/>they have a finite length.) At any rate, we’ll use the SVG terminology here, so let’s create a new template file named <em>line</em> inside the <em>templates</em> folder and add the code in <a href="ch08.xhtml#ch8lis9">Listing 8-9</a>:</p>&#13;
<pre>&lt;line x1="{{x1}}" y1="{{y1}}" x2="{{x2}}" y2="{{y2}}" {{attrs}}/&gt;</pre>&#13;
<p class="caption"><a id="ch8lis9"/><em>Listing 8-9: Line template</em></p>&#13;
<p class="noindent">The template for a line is simple. The placeholders define the following:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">x1</span> and <span class="literal">y1</span>, the coordinates of the start point</li>&#13;
<li class="noindent"><span class="literal">x2</span> and <span class="literal">y2</span>, the coordinates of the end point</li>&#13;
<li class="noindent"><span class="literal">attrs</span>, where the attributes will be inserted</li>&#13;
</ul>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8fig8">Figure 8-8</a> depicts the line with its attributes using the default coordinate system for SVG images.</p>&#13;
<div class="image"><img src="../images/08fig08.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig8"><em>Figure 8-8: An example of an SVG line</em></p>&#13;
<p class="indent">Let’s now create a function that reads the template and inserts the values of a segment. We need a new file; let’s create it inside <em>svg</em> with the name <em>primitives.py</em>. Enter the function in <a href="ch08.xhtml#ch8lis10">Listing 8-10</a>.</p>&#13;
<pre>from geom2d import Segment&#13;
from graphic.svg.attributes import attrs_to_str&#13;
from graphic.svg.read import read_template&#13;
&#13;
&#13;
__segment_template = read_template('line')&#13;
&#13;
&#13;
def segment(seg: Segment, attributes=()):&#13;
    return __segment_template \&#13;
        .replace('{{x1}}', str(seg.start.x)) \&#13;
        .replace('{{y1}}', str(seg.start.y)) \&#13;
        .replace('{{x2}}', str(seg.end.x)) \&#13;
        .replace('{{y2}}', str(seg.end.y)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))</pre>&#13;
<p class="caption"><a id="ch8lis10"/><em>Listing 8-10: SVG line</em></p>&#13;
<p class="indent">One thing to note is that the parameter <span class="literal">attributes</span> has a default value of <span class="literal">()</span>, that is, an empty tuple. We could have also used an empty list <span class="literal">[]</span> as the default for the parameter, but there’s an important difference between <span epub:type="pagebreak" id="page_219"/>those two options: tuples are immutable, and lists are mutable. Function default arguments are evaluated only once when the file is loaded into the interpreter, so if a mutable default parameter is mutated, all subsequent calls to the same function would get the mutated value as the default, and that’s something we want to avoid.</p>&#13;
<p class="indent">In the shell, try the code below to create an SVG line in order to see the result and make sure that all placeholders are properly replaced.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d import Segment, make_point</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from graphic import svg</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">seg = Segment(make_point(1, 4), make_point(2, 5))</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">attrs = [svg.attributes.stroke_color('#cacaca')]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">svg.primitives.segment(seg, attrs)</span>&#13;
'&lt;line x1="1" y1="4" x2="2" y2="5" stroke="#cacaca"/&gt;'</pre>&#13;
<p class="noindent">This line inside an SVG file would be drawn as in <a href="ch08.xhtml#ch8fig9">Figure 8-9</a>.</p>&#13;
<div class="image"><img src="../images/08fig09.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig9"><em>Figure 8-9: SVG line</em></p>&#13;
<p class="indent">Bear in mind the arrows and position captions are added in this figure for clarity but won’t appear in the image itself.</p>&#13;
<h4 class="h4" id="ch00lev2sec99"><strong><em>Rectangles</em></strong></h4>&#13;
<p class="noindent">Our next primitive is the rectangle, so inside <em>templates</em> create a new file named <em>rect</em> (remember, we’re not using any extension in our template files) with the definition shown in <a href="ch08.xhtml#ch8lis11">Listing 8-11</a>:</p>&#13;
<pre>&lt;rect x="{{x}}" y="{{y}}"&#13;
      width="{{width}}" height="{{height}}"&#13;
      {{attrs}}/&gt;</pre>&#13;
<p class="caption"><a id="ch8lis11"/><em>Listing 8-11: The rectangle template</em></p>&#13;
<p class="indent">You can write the template in a single line; here we used several lines because in the print version, the code didn’t fit in just one. The attributes that define a rectangle are, as expected, the coordinates of the origin <span class="literal">x</span> and <span class="literal">y</span> and its size given by <span class="literal">width</span> and <span class="literal">height</span>. In <em>primitives.py</em>, add the function in <a href="ch08.xhtml#ch8lis12">Listing 8-12</a>.</p>&#13;
<pre>from geom2d import <span class="codestrong1">Rect</span>, Segment&#13;
from graphic.svg.attributes import attrs_to_str&#13;
from graphic.svg.read import read_template&#13;
&#13;
<span epub:type="pagebreak" id="page_220"/>__segment_template = read_template('line')&#13;
<span class="codestrong1">__rect_template = read_template(</span>'<span class="codestrong1">rect</span>'<span class="codestrong1">)</span>&#13;
&#13;
<span class="codeitalic1">--snip--</span>&#13;
&#13;
def rectangle(rect: Rect, attributes=()):&#13;
    return __rect_template \&#13;
        .replace('{{x}}', str(rect.origin.x)) \&#13;
        .replace('{{y}}', str(rect.origin.y)) \&#13;
        .replace('{{width}}', str(rect.size.width)) \&#13;
        .replace('{{height}}', str(rect.size.height)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))</pre>&#13;
<p class="caption"><a id="ch8lis12"/><em>Listing 8-12: SVG rectangle</em></p>&#13;
<p class="indent">To gain a better understanding of the attributes that define a rectangle in the SVG format, take a look at <a href="ch08.xhtml#ch8fig10">Figure 8-10</a>. The figure uses the default coordinate system from SVG: the y-axis pointing downward. This is why the origin of the rectangle is the upper-left corner. If we were using a coordinate system whose y-axis pointed upward, the origin would be the lower-left corner.</p>&#13;
<div class="image"><img src="../images/08fig10.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig10"><em>Figure 8-10: An example of an SVG rectangle</em></p>&#13;
<p class="indent">Give it a try in the shell, as we did with the segment, to check that all placeholders are properly replaced:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d import Rect, Point, Size</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from graphic.svg.primitives import rectangle</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">r = Rect(Point(3, 4), Size(10, 20))</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">rectangle(r)</span>&#13;
'&lt;rect x="3" y="4" width="10" height="20" /&gt;'</pre>&#13;
<p class="indent">It’s a good idea to check that everything works as expected, since later in the book we’ll be creating lots of diagrams using these simple primitives. Unit testing is the best option, much better than testing manually in the shell. If you downloaded the code for the book, you’ll see all these primitive rendering functions are covered by tests. Try to write them yourself so you get used to writing unit tests and then compare them to the ones that I’ve provided you.</p>&#13;
<h4 class="h4" id="ch00lev2sec100"><strong><em>Circles</em></strong></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_221"/>We’ll take a similar approach to rectangles to create circles. Create the template in a file named <em>circle</em> (see <a href="ch08.xhtml#ch8lis13">Listing 8-13</a>).</p>&#13;
<pre>&lt;circle cx="{{cx}}" cy="{{cy}}" r="{{r}}" {{attrs}}/&gt;</pre>&#13;
<p class="caption"><a id="ch8lis13"/><em>Listing 8-13: The circle template</em></p>&#13;
<p class="indent">Then add the function to render the circle inside <em>primitives.py</em> (see <a href="ch08.xhtml#ch8lis14">Listing 8-14</a>).</p>&#13;
<pre>from geom2d import <span class="codestrong1">Circle</span>, Rect, Segment&#13;
from graphic.svg.attributes import attrs_to_str&#13;
from graphic.svg.read import read_template&#13;
&#13;
&#13;
__segment_template = read_template('line')&#13;
__rect_template = read_template('rect')&#13;
<span class="codestrong1">__circle_template = read_template('circle')</span>&#13;
&#13;
<span class="codeitalic1">--snip--</span>&#13;
&#13;
def circle(circ: Circle, attributes=()):&#13;
    return __circle_template \&#13;
        .replace('{{cx}}', str(circ.center.x)) \&#13;
        .replace('{{cy}}', str(circ.center.y)) \&#13;
        .replace('{{r}}', str(circ.radius)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))</pre>&#13;
<p class="caption"><a id="ch8lis14"/><em>Listing 8-14: SVG circle</em></p>&#13;
<p class="indent">Nothing unexpected here! You can take a look at <a href="ch08.xhtml#ch8fig11">Figure 8-11</a> to see the attributes we used to define the circle in the SVG format.</p>&#13;
<div class="image"><img src="../images/08fig11.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig11"><em>Figure 8-11: An example of an SVG circle</em></p>&#13;
<p class="indent">Let’s give it a try in the shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d import Circle, Point</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from graphic.svg.primitives import circle</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">c = Circle(Point(3, 4), 10)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">circle(c)</span>&#13;
'&lt;circle cx="3" cy="4" r="10" /&gt;'</pre>&#13;
<h4 class="h4" id="ch00lev2sec101"><span epub:type="pagebreak" id="page_222"/><strong><em>Polygons</em></strong></h4>&#13;
<p class="noindent">Polygons are simple to define; we simply need to provide the list of vertex coordinates formatted in a specific way. Create the template file <em>polygon</em> in <em>templates</em> (see <a href="ch08.xhtml#ch8lis15">Listing 8-15</a>).</p>&#13;
<pre>&lt;polygon points="{{points}}" {{attrs}}/&gt;</pre>&#13;
<p class="caption"><a id="ch8lis15"/><em>Listing 8-15: The polygon template</em></p>&#13;
<p class="indent">Then inside <em>primitives.py</em> include the function in <a href="ch08.xhtml#ch8lis16">Listing 8-16</a>.</p>&#13;
<pre>from geom2d import Circle, Rect, Segment, <span class="codestrong1">Polygon</span>&#13;
from graphic.svg.attributes import attrs_to_str&#13;
from graphic.svg.read import read_template&#13;
&#13;
&#13;
__segment_template = read_template('line')&#13;
__rect_template = read_template('rect')&#13;
__circle_template = read_template('circle')&#13;
<span class="codestrong1">__polygon_template = read_template(</span>'<span class="codestrong1">polygon</span>'<span class="codestrong1">)</span>&#13;
&#13;
<span class="codeitalic1">--snip--</span>&#13;
&#13;
def polygon(pol: Polygon, attributes=()):&#13;
    return __polygon_template \&#13;
        .replace('{{points}}', __format_points(pol.vertices)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))</pre>&#13;
<p class="caption"><a id="ch8lis16"/><em>Listing 8-16: SVG polygon</em></p>&#13;
<p class="indent">The placeholder <span class="literal">{{points}}</span> is replaced with the result of applying <span class="literal">__format_points</span> to the list of vertices. Let’s write that function here, inside the <em>primitives.py</em> file (see <a href="ch08.xhtml#ch8lis16">Listing 8-16</a>):</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def __format_points(points: [Point]):&#13;
    return ' '.join([f'{p.x},{p.y}' for p in points])</pre>&#13;
<p class="caption"><a id="ch8lis17"/><em>Listing 8-17: Format points</em></p>&#13;
<p class="indent">As you can see, the list of vertices is converted into a string where each vertex is separated by a space,</p>&#13;
<pre>' '.join(...)</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_223"/>and the two coordinates, <span class="literal">x</span> and <span class="literal">y</span>, are separated with a comma:</p>&#13;
<pre>[f'\{p.x\},\{p.y\}' for p in points]</pre>&#13;
<p class="indent">For example, a polygon with vertices (1, 2), (5, 6), and (8, 9) would result in the following:</p>&#13;
<pre>&lt;polygon points="1, 2 5, 6 8, 9" /&gt;</pre>&#13;
<h4 class="h4" id="ch00lev2sec102"><strong><em>Polylines</em></strong></h4>&#13;
<p class="noindent"><em>Polylines</em> are defined the same way as polygons—the only difference is that the last vertex isn’t connected with the first one. Create the template in a file named <em>polyline</em> in <em>templates</em> (see <a href="ch08.xhtml#ch8lis18">Listing 8-18</a>).</p>&#13;
<pre>&lt;polyline points="{{points}}" {{attrs}}/&gt;</pre>&#13;
<p class="caption"><a id="ch8lis18"/><em>Listing 8-18: The polyline template</em></p>&#13;
<p class="indent">Include the rendering function inside file <em>primitives.py</em> (see <a href="ch08.xhtml#ch8lis19">Listing 8-19</a>).</p>&#13;
<pre>from geom2d import Circle, Rect, Segment, Polygon&#13;
from graphic.svg.attributes import attrs_to_str&#13;
from graphic.svg.read import read_template&#13;
&#13;
&#13;
__segment_template = read_template('line')&#13;
__rect_template = read_template('rect')&#13;
__circle_template = read_template('circle')&#13;
__polygon_template = read_template('polygon')&#13;
<span class="codestrong1">__polyline_template = read_template(</span>'<span class="codestrong1">polyline</span>'<span class="codestrong1">)</span>&#13;
&#13;
<span class="codeitalic1">--snip--</span>&#13;
&#13;
def polyline(points: [Point], attributes=()):&#13;
    return __polyline_template \&#13;
        .replace('{{points}}', __format_points(points)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))</pre>&#13;
<p class="caption"><a id="ch8lis19"/><em>Listing 8-19: SVG polyline</em></p>&#13;
<p class="indent">Again, no surprises here. <a href="ch08.xhtml#ch8fig12">Figure 8-12</a> shows the difference between a polygon and a polyline. The definition for both is the same; the only difference is that last segment connecting vertex (<em>x</em><sub>4</sub>, <em>y</em><sub>4</sub>) back to (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>) appears only in the case of a polygon.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_224"/><img src="../images/08fig12.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig12"><em>Figure 8-12: An SVG polygon and polyline</em></p>&#13;
<p class="indent">Let’s try a polygon and a polyline in the shell to see the results:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d import Polygon, Point</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from graphic.svg.primitives import polygon, polyline</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">points = [Point(1, 2), Point(3, 4), Point(5, 6)]</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">polygon(Polygon(points))</span>&#13;
'&lt;polygon points="1, 2 3, 4 5, 6" /&gt;'&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">polyline(points)</span>&#13;
'&lt;polyline points="1,2 3,4 5,6" /&gt;'</pre>&#13;
<p class="indent">Both the polygon and the polyline have the same sequence of points, but in an SVG image, the polygon will have a segment connecting the first and last vertices, whereas the polyline will remain open.</p>&#13;
<h4 class="h4" id="ch00lev2sec103"><strong><em>Text</em></strong></h4>&#13;
<p class="noindent">Our diagrams will contain captions (like the structural analysis result diagrams in <a href="ch18.xhtml#ch18">Chapter 18</a>), so we need to be able to include text in our images. Create a new template file named <em>text</em> in folder <em>templates</em> with the code in <a href="ch08.xhtml#ch8lis20">Listing 8-20</a>.</p>&#13;
<pre>&lt;text x="{{x}}" y="{{y}}" dx="{{dx}}" dy="{{dy}}" {{attrs}}&gt;&#13;
    {{text}}&#13;
&lt;/text&gt;</pre>&#13;
<p class="caption"><a id="ch8lis20"/><em>Listing 8-20: The text template</em></p>&#13;
<p class="indent">The placeholder <span class="literal">{{text}}</span> has to be between the open and close tags <span class="literal">&lt;text&gt;</span> and <span class="literal">&lt;/text&gt;</span>; this is where the actual text will be inserted. The attributes <span class="literal">x</span> and <span class="literal">y</span> define the position where the text will be located; then <span class="literal">dx</span> and <span class="literal">dy</span> displace that original position. We’ll find this displacement handy when, for instance, we want to add the coordinates of a point next to it. We can choose the position of the point itself as the base, which we then displace a given amount so that the text and the drawing of the point don’t overlap.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_225"/>In <em>primitives.py</em> add the function shown in <a href="ch08.xhtml#ch8lis21">Listing 8-21</a> to render text:</p>&#13;
<pre>from geom2d import Circle, Rect, Segment, Polygon, <span class="codestrong1">Vector</span>&#13;
from graphic.svg.attributes import attrs_to_str&#13;
from graphic.svg.read import read_template&#13;
&#13;
&#13;
__segment_template = read_template('line')&#13;
__rect_template = read_template('rect')&#13;
__circle_template = read_template('circle')&#13;
__polygon_template = read_template('polygon')&#13;
__polyline_template = read_template('polyline')&#13;
<span class="codestrong1">__text_template = read_template(</span>'<span class="codestrong1">text</span>'<span class="codestrong1">)</span>&#13;
&#13;
<span class="codeitalic1">--snip--</span>&#13;
&#13;
def text(txt: str, pos: Point, disp: Vector, attrs_list=()):&#13;
    return __text_template \&#13;
        .replace('{{x}}', str(pos.x)) \&#13;
        .replace('{{y}}', str(pos.y)) \&#13;
        .replace('{{dx}}', str(disp.u)) \&#13;
        .replace('{{dy}}', str(disp.v)) \&#13;
        .replace('{{text}}', txt) \&#13;
        .replace('{{attrs}}', attrs_to_str(attrs_list))</pre>&#13;
<p class="caption"><a id="ch8lis21"/><em>Listing 8-21: SVG text</em></p>&#13;
<p class="indent">Let’s give it a try in the shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d import Point, Vector</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from graphic.svg.primitives import text</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">text('Hello, SVG', Point(10, 15), Vector(5, 6))</span>&#13;
'&lt;text x="10" y="15" dx="5" dy="6" &gt;\n    Hello, SVG\n&lt;/text&gt;'</pre>&#13;
<p class="indent">If we format the result string, the result is as follows:</p>&#13;
<pre>&lt;text x="10" y="15" dx="5" dy="6" &gt;&#13;
    Hello, SVG&#13;
&lt;/text&gt;</pre>&#13;
<h4 class="h4" id="ch00lev2sec104"><strong><em>Groups</em></strong></h4>&#13;
<p class="noindent">Oftentimes we want to group a bunch of elements so we can add a common attribute to all of them, such as an affine transformation or fill color. This is what groups are for. They’re nothing to be rendered by themselves, but they group a bunch of primitives in a neat way. Create the file <em>group</em> inside the <em>templates</em> folder (see <a href="ch08.xhtml#ch8lis22">Listing 8-22</a>).<span epub:type="pagebreak" id="page_226"/></p>&#13;
<pre>&lt;g {{attrs}}&gt;&#13;
    {{content}}&#13;
&lt;/g&gt;</pre>&#13;
<p class="caption"><a id="ch8lis22"/><em>Listing 8-22: The group template</em></p>&#13;
<p class="indent">To render the group, we’ll add the function shown in <a href="ch08.xhtml#ch8lis23">Listing 8-23</a> to file <em>primitives.py</em>.</p>&#13;
<pre>from geom2d import Circle, Rect, Segment, Polygon, Vector&#13;
from graphic.svg.attributes import attrs_to_str&#13;
from graphic.svg.read import read_template&#13;
&#13;
&#13;
__segment_template = read_template('line')&#13;
__rect_template = read_template('rect')&#13;
__circle_template = read_template('circle')&#13;
__polygon_template = read_template('polygon')&#13;
__polyline_template = read_template('polyline')&#13;
__text_template = read_template('text')&#13;
<span class="codestrong1">__group_template = read_template(</span>'<span class="codestrong1">group</span>'<span class="codestrong1">)</span>&#13;
&#13;
<span class="codeitalic1">--snip--</span>&#13;
&#13;
def group(primitives: [str], attributes=()):&#13;
    return __group_template \&#13;
        .replace('{{content}}', '\n'.join(primitives)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))</pre>&#13;
<p class="caption"><a id="ch8lis23"/><em>Listing 8-23: SVG group</em></p>&#13;
<p class="indent">This time, all primitives passed as a sequence are joined into a string separated by line breaks (<span class="literal">\n</span>). This is so that each primitive is inserted in a new line, which will make the file easier to read.</p>&#13;
<h4 class="h4" id="ch00lev2sec105"><strong><em>Arrows</em></strong></h4>&#13;
<p class="noindent">In this section, we’re going to add a different primitive, one that’s built not by loading and rendering a template but by using other primitives: an arrow. In <a href="ch18.xhtml#ch18">Chapter 18</a>, when we draw structure diagrams, we’ll use arrows to represent forces, so this is a good moment to implement them.</p>&#13;
<p class="indent">The arrow consists of a line segment with a small triangle at one of its ends, the arrow’s head (see <a href="ch08.xhtml#ch8fig13">Figure 8-13</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_227"/><img src="../images/08fig13.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig13"><em>Figure 8-13: An SVG arrow</em></p>&#13;
<p class="indent">Drawing the arrow’s segment is simple: we just need a line segment. Drawing the head is a bit more involved, because it needs to always be aligned with the segment. Using a bit of elementary geometry we can figure out the points that define the arrow’s head. Take a look at <a href="ch08.xhtml#ch8fig14">Figure 8-14</a>.</p>&#13;
<div class="image"><img src="../images/08fig14.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch8fig14"><em>Figure 8-14: Key points in an arrow</em></p>&#13;
<p class="indent">Our arrow’s head is a triangle defined between points <em>C</em><sub>1</sub>, <em>E</em> (the segment’s end point), and <em>C</em><sub>2</sub>. The size of the arrow is given by a length and a height, sizes that we’ll use to locate the <em>C</em><sub>1</sub> and <em>C</em><sub>2</sub> points.</p>&#13;
<p class="indent">The figure uses three vectors to position these two points.</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><img class="inline" src="../images/vlvictorit.jpg" alt="Image"/>    This is a vector in the direction opposite to the segment’s direction vector and is the same length as the arrow.</p>&#13;
<p class="noindentin"><img class="inline" src="../images/vh1victorit.jpg" alt="Image"/>    This is a vector perpendicular to the segment, and the length is half the arrow’s head height.</p>&#13;
<p class="noindentin"><img class="inline" src="../images/vh2victorit.jpg" alt="Image"/>    This is similar to <img class="inline" src="../images/vh1victorit.jpg" alt="Image"/>, but in the opposite direction.</p>&#13;
</div>&#13;
<p class="indent">Using these vectors, we can now compute the points as follows:</p>&#13;
<div class="equationc"><img src="../images/f00227-p1.jpg" alt="Image"/></div>&#13;
<p class="indent">and</p>&#13;
<div class="equationc"><img src="../images/f00227-p2.jpg" alt="Image"/></div>&#13;
<p class="indent">Without further ado, let’s write the code to draw arrows. Inside <em>primitives.py</em>, enter the code in <a href="ch08.xhtml#ch8lis24">Listing 8-24</a>.<span epub:type="pagebreak" id="page_228"/></p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def arrow(&#13;
        _segment: Segment,&#13;
        length: float,&#13;
        height: float,&#13;
        attributes=()&#13;
):&#13;
    director = _segment.direction_vector&#13;
 <span class="ent">➊</span> v_l = director.opposite().with_length(length)&#13;
 <span class="ent">➋</span> v_h1 = director.perpendicular().with_length(height / 2.0)&#13;
 <span class="ent">➌</span> v_h2 = v_h1.opposite()&#13;
&#13;
    return group(&#13;
        [&#13;
&#13;
         <span class="ent">➍</span> segment(_segment),&#13;
         <span class="ent">➎</span> polyline([&#13;
                _segment.end.displaced(v_l + v_h1),&#13;
                _segment.end,&#13;
                _segment.end.displaced(v_l + v_h2)&#13;
            ])&#13;
        ],&#13;
        attributes&#13;
    )</pre>&#13;
<p class="caption"><a id="ch8lis24"/><em>Listing 8-24: SVG arrow</em></p>&#13;
<p class="indent">We’ve defined the <span class="literal">arrow</span> function that accepts as parameters a segment, the length and height of the arrow, and the SVG attributes. Note that the <span class="literal">_segment</span> parameter starts with an underscore. This is to avoid a clash with the file’s <span class="literal">segment</span> function.</p>&#13;
<p class="indent">In this function we first store the segment’s director vector in the variable <span class="literal">director</span>. We then compute the <img class="inline" src="../images/vlvictorit.jpg" alt="Image"/> vector taking <span class="literal">director</span>’s opposite vector scaled to the passed-in length <span class="ent">➊</span>. The <img class="inline" src="../images/vh1victorit.jpg" alt="Image"/> vector is obtained by taking <span class="literal">director</span>’s perpendicular vector scaled to the arrow’s half-height <span class="ent">➋</span>. Then, <img class="inline" src="../images/vh2victorit.jpg" alt="Image"/> is simply the opposite of it <span class="ent">➌</span>.</p>&#13;
<p class="indent">The function returns an SVG group including the arrow’s segment <span class="ent">➍</span> and a polyline <span class="ent">➎</span>. This polyline defines the arrow’s head using the three points we discussed earlier.</p>&#13;
<p class="indent">The first point, <em>C</em><sub>1</sub>, is computed by displacing the segment’s end point by the result of adding vectors <img class="inline" src="../images/vlvictorit.jpg" alt="Image"/> and <img class="inline" src="../images/vh1victorit.jpg" alt="Image"/>. Then comes the segment’s end point. Lastly comes <em>C</em><sub>2</sub>, resulting from the displacement of the segment’s end point by a vector that’s the result of adding <img class="inline" src="../images/vlvictorit.jpg" alt="Image"/> and <img class="inline" src="../images/vh2victorit.jpg" alt="Image"/>.</p>&#13;
<h3 class="h3" id="ch00lev1sec52"><span epub:type="pagebreak" id="page_229"/><strong>Primitives Result</strong></h3>&#13;
<p class="noindent">We’ve added a few functions to our <em>primitives.py</em> file. If you followed along, your file should look similar to <a href="ch08.xhtml#ch8lis25">Listing 8-25</a>.</p>&#13;
<pre>from geom2d import Circle, Rect, Segment, Point, Polygon, Vector&#13;
from graphic.svg.attributes import attrs_to_str&#13;
from graphic.svg.read import read_template&#13;
&#13;
__segment_template = read_template('line')&#13;
__rect_template = read_template('rect')&#13;
__circle_template = read_template('circle')&#13;
__polygon_template = read_template('polygon')&#13;
__polyline_template = read_template('polyline')&#13;
__text_template = read_template('text')&#13;
__group_template = read_template('group')&#13;
&#13;
&#13;
def segment(seg: Segment, attributes=()):&#13;
    return __segment_template \&#13;
        .replace('{{x1}}', str(seg.start.x)) \&#13;
        .replace('{{y1}}', str(seg.start.y)) \&#13;
        .replace('{{x2}}', str(seg.end.x)) \&#13;
        .replace('{{y2}}', str(seg.end.y)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))&#13;
&#13;
&#13;
def rectangle(rect: Rect, attributes=()):&#13;
    return __rect_template \&#13;
        .replace('{{x}}', str(rect.origin.x)) \&#13;
        .replace('{{y}}', str(rect.origin.y)) \&#13;
        .replace('{{width}}', str(rect.size.width)) \&#13;
        .replace('{{height}}', str(rect.size.height)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))&#13;
&#13;
&#13;
def circle(circ: Circle, attributes=()):&#13;
    return __circle_template \&#13;
        .replace('{{cx}}', str(circ.center.x)) \&#13;
        .replace('{{cy}}', str(circ.center.y)) \&#13;
        .replace('{{r}}', str(circ.radius)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))&#13;
&#13;
&#13;
def polygon(pol: Polygon, attributes=()):&#13;
    return __polygon_template \&#13;
        .replace('{{points}}', __format_points(pol.vertices)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_230"/>def polyline(points: [Point], attributes=()):&#13;
    return __polyline_template \&#13;
        .replace('{{points}}', __format_points(points)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))&#13;
&#13;
&#13;
def text(txt: str, pos: Point, disp: Vector, attrs_list=()):&#13;
    return __text_template \&#13;
        .replace('{{x}}', str(pos.x)) \&#13;
        .replace('{{y}}', str(pos.y)) \&#13;
        .replace('{{dx}}', str(disp.u)) \&#13;
        .replace('{{dy}}', str(disp.v)) \&#13;
        .replace('{{text}}', txt) \&#13;
        .replace('{{attrs}}', attrs_to_str(attrs_list))&#13;
&#13;
&#13;
def group(primitives: [str], attributes=()):&#13;
    return __group_template \&#13;
        .replace('{{content}}', '\n\t'.join(primitives)) \&#13;
        .replace('{{attrs}}', attrs_to_str(attributes))&#13;
&#13;
&#13;
def arrow(&#13;
        _segment: Segment,&#13;
        length: float,&#13;
        height: float,&#13;
        attributes=()&#13;
):&#13;
    director = _segment.direction_vector&#13;
    v_l = director.opposite().with_length(length)&#13;
    v_h1 = director.perpendicular().with_length(height / 2.0)&#13;
    v_h2 = v_h1.opposite()&#13;
&#13;
    return group(&#13;
        [&#13;
            segment(_segment),&#13;
            polyline([&#13;
                _segment.end.displaced(v_l + v_h1),&#13;
                _segment.end,&#13;
                _segment.end.displaced(v_l + v_h2)&#13;
            ])&#13;
        ],&#13;
        attributes&#13;
    )&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_231"/>def __format_points(points: [Point]):&#13;
    return ' '.join([f'{p.x},{p.y}' for p in points])</pre>&#13;
<p class="caption"><a id="ch8lis25"/><em>Listing 8-25: SVG primitives result</em></p>&#13;
<p class="indent">We have everything we need to start drawing images. In the next chapter, we’ll use our <em>svg</em> package to plot the result of a geometrical problem. But first, let’s provide a convenient way of importing the contents of this package.</p>&#13;
<h3 class="h3" id="ch00lev1sec53"><strong>Package Imports</strong></h3>&#13;
<p class="noindent">Similar to what we did with the <em>geom2d</em> package, we want to give the option of importing everything from <em>svg</em> with a single import line:</p>&#13;
<pre>from graphic import svg</pre>&#13;
<p class="indent">The only thing we have to do is import all relevant modules inside the <em>svg</em> package’s <em>__init__.py</em> file file:</p>&#13;
<pre>from .attributes import *&#13;
from .image import svg_content&#13;
from .primitives import *</pre>&#13;
<h3 class="h3" id="ch00lev1sec54"><strong>Summary</strong></h3>&#13;
<p class="noindent">Graphics are key to engineering applications. Many involve creating diagrams made of simple geometric primitives such as segments and rectangles. We created a geometry package in <a href="part02.xhtml#part02">Part II</a> of this book; in this chapter, we learned how to turn those primitives into vector images.</p>&#13;
<p class="indent">We started with a quick introduction to the SVG format and saw how easy it is to create SVG images using just a few lines of XML data. We then learned about templates, extensionless plaintext files that define the SVG structure using placeholders. The placeholders, which have the form of <span class="literal">{{name}}</span>, are replaced by concrete data using code. Templates are widely used, and there are some complex packages for rendering templates. Our use case was pretty simple, so we did the replacement using the <span class="literal">replace</span> method from Python strings.</p>&#13;
<p class="indent">Lastly, we created functions to obtain the SVG representation for our geometric primitives: line segments, circles, rectangles, and polygons. From now on, creating vector diagrams should be straightforward, something that we’ll prove in the next chapter.<span epub:type="pagebreak" id="page_232"/></p>&#13;
</body></html>