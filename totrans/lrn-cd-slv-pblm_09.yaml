- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: DESIGNING ALGORITHMS WITH COMPLETE SEARCH
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全搜索设计算法
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: An *algorithm* is a sequence of steps that solves a problem. For each problem
    in this book, we solved it by writing an algorithm in the form of Python code.
    We’ll focus in this chapter on designing algorithms. When faced with a new problem,
    sometimes it’s hard to know what to do to solve it. What algorithm should we write?
    Fortunately, we don’t need to start from scratch each time. Computer scientists
    and programmers have identified several general types of algorithms, and it’s
    likely that at least one of them can be used to solve our problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法*是解决问题的一系列步骤。本书中的每个问题我们都是通过编写Python代码形式的算法来解决的。在本章中，我们将专注于算法设计。当面对一个新问题时，有时很难知道该做什么来解决它。我们应该编写什么样的算法呢？幸运的是，我们不必每次都从头开始。计算机科学家和程序员已经确定了几种通用的算法类型，至少有一种可能能够解决我们的问题。'
- en: One type of algorithm is called a *complete search* algorithm; it involves trying
    all candidate solutions and choosing the best one. For example, if the problem
    asks us to find a maximum, we try all solutions and choose the largest; if the
    problem asks us to find a minimum, we try all solutions and choose the smallest.
    Complete-search algorithms are also known as *brute-force* algorithms, but I’ll
    avoid that term. It’s true that the computer is powering its way through, checking
    solution after solution, but there’s nothing brute force about what we’re doing
    as algorithm designers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一种算法被称为*完全搜索*算法；它涉及尝试所有候选解并选择最优解。例如，如果问题要求我们找到最大值，我们就尝试所有解并选择最大的；如果问题要求我们找到最小值，我们就尝试所有解并选择最小的。完全搜索算法也被称为*暴力算法*，但我将避免使用这个术语。确实，计算机正在全力处理，逐一检查每个解，但作为算法设计师，我们所做的并没有暴力的成分。
- en: We used a complete-search algorithm to solve Village Neighborhood in [Chapter
    5](ch05.xhtml#ch05). We were asked to find the smallest size of the neighborhoods,
    and we did that by looking at each neighborhood and remembering the size of the
    smallest one. In this chapter, we’ll use complete-search algorithms to solve other
    problems. We’ll see that it can take considerable ingenuity to determine what
    exactly to search.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了完全搜索算法来解决[第5章](ch05.xhtml#ch05)中的“村庄邻里”问题。我们的任务是找到最小的邻里大小，我们通过查看每个邻里并记住最小的那个来实现这一目标。在本章中，我们将使用完全搜索算法来解决其他问题。我们将看到，确定具体要搜索什么，可能需要相当的巧妙构思。
- en: 'We’ll solve two problems using complete search: determining which lifeguard
    to fire and identifying the minimum cost to meet ski training camp requirements.
    Then we’ll see a third problem, counting triples of cows that meet given observations,
    that requires we go a little further.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过完全搜索来解决两个问题：确定解雇哪个救生员和识别满足滑雪训练营要求的最低成本。接着我们将看到一个第三个问题，计算满足给定观察条件的奶牛三元组，这个问题要求我们更进一步。
- en: 'Problem #21: Lifeguards'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题#21：救生员
- en: In this problem, we’ll need to determine which lifeguard to fire that leaves
    us with the maximum schedule coverage of a pool. We’ll try separately firing each
    one and observing the results—that’s a complete-search algorithm!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们需要确定解雇哪个救生员，以使我们能获得最大覆盖时间的游泳池。我们将分别尝试解雇每个救生员并观察结果——这就是一个完全搜索算法！
- en: This is USACO 2018 January Bronze Contest problem Lifeguards.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是USACO 2018年1月铜奖比赛中的问题：救生员。
- en: The Challenge
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Farmer John has purchased a swimming pool for his cows. The pool is open from
    time 0 to time 1000.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 农夫约翰为他的奶牛购买了一个游泳池。该游泳池的开放时间为从时间0到时间1000。
- en: Farmer John hires *n* lifeguards to monitor the pool. Each lifeguard monitors
    the pool for a given interval of time. For example, a lifeguard might start at
    time 2 and end at time 7\. I’ll denote such an interval as 2–7\. The number of
    units of time covered by an interval is the ending time minus the starting time.
    For example, the lifeguard whose time interval is 2–7 covers 7 – 2 = 5 units of
    time. Those time units are from time 2 to 3, 3 to 4, 4 to 5, 5 to 6, and 6 to
    7.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 农夫约翰雇佣了*n*个救生员来监控游泳池。每个救生员在一个给定的时间段内监控池塘。例如，一个救生员可能从时间2开始，到时间7结束。我将把这个时间段表示为2-7。一个时间段所覆盖的时间单位数是结束时间减去开始时间。例如，时间段为2-7的救生员覆盖了7-2=5个时间单位。那些时间单位分别是从时间2到3，3到4，4到5，5到6，以及6到7。
- en: Unfortunately, Farmer John only has enough money to pay for *n* – 1 lifeguards,
    not *n* lifeguards, so he must fire one lifeguard.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，农夫约翰只有足够的钱支付*n* – 1个救生员的薪水，而不是*n*个救生员，因此他必须解雇一个救生员。
- en: Determine the maximum number of units of time that can still be covered after
    firing one lifeguard.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 确定在解雇一名救生员后，仍然可以覆盖的最大时间单位数。
- en: Input
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *lifeguards.in*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为 *lifeguards.in* 的文件中读取输入。
- en: 'The input consists of the following lines:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由以下几行组成：
- en: A line containing *n*, the number of lifeguards who were hired. *n* is between
    1 and 100.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n*，表示被雇佣的救生员数量。*n* 的范围在 1 到 100 之间。
- en: '*n* lines, one per lifeguard. Each line gives the time when the lifeguard starts,
    a space, and the time when the lifeguard ends. The start and end times are all
    integers between 0 and 1,000 and are all distinct.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行一个救生员。每行给出救生员的开始时间、一个空格和结束时间。开始和结束时间都是介于 0 到 1000 之间的整数，且各不相同。'
- en: Output
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *lifeguards.out*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入名为 *lifeguards.out* 的文件中。
- en: Output the maximum number of units of time that can be covered by *n* – 1 of
    the lifeguards.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输出 *n* – 1 名救生员能够覆盖的最大时间单位数。
- en: The time limit for solving each test case is four seconds.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例的解答时间限制为四秒。
- en: Exploring a Test Case
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: 'Let’s explore a test case to help justify why a complete-search algorithm makes
    sense for this problem. Here’s the test case:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个测试用例，帮助说明为什么完整搜索算法对于这个问题是合理的。以下是测试用例：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: One simple rule you might try to use to solve this problem is to fire the lifeguard
    with the shortest time interval. That makes some intuitive sense, because it seems
    as though that lifeguard contributes the least to covering the pool.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试使用的一个简单规则是解雇时间间隔最短的救生员。这在直觉上有些道理，因为似乎那个救生员对覆盖泳池的贡献最小。
- en: Does this rule give us a correct algorithm? Let’s see. It tells us to fire the
    5–8 lifeguard, since that lifeguard has the shortest time interval. That leaves
    us with the three lifeguards whose time intervals are 10–15, 17–25, and 9–20\.
    These three remaining lifeguards cover exactly the interval 9–25, which consists
    of 25 – 9 = 16 units of time. Is 16 the correct answer?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则给出的算法正确吗？让我们来看看。它告诉我们解雇第 5–8 名救生员，因为那名救生员的时间间隔最短。这样剩下的三个救生员的时间间隔是 10–15、17–25
    和 9–20。这三个剩余的救生员恰好覆盖了 9–25 的区间，包含 25 – 9 = 16 个时间单位。那么 16 是正确答案吗？
- en: 'Unfortunately, no. It turns out that what we should have done is fire the 10–15
    lifeguard. If we do that, then we’re left with the three lifeguards whose time
    intervals are 5–8, 17–25, and 9–20\. These three remaining lifeguards cover the
    intervals 5–8 and 9–25\. (Careful: they don’t cover the unit of time from 8 to
    9.) The first of these intervals covers 8 – 5 = 3 units of time, and the second
    covers 25 – 9 = 16 units of time, for a total of 19 units of time.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，不是的。事实上，我们应该解雇的是 10–15 名救生员。如果我们这么做，那么剩下的三个救生员的时间区间将是 5–8、17–25 和 9–20。这三个剩余的救生员覆盖了
    5–8 和 9–25 的区间。（小心：它们不覆盖从 8 到 9 这一单位时间。）这两个区间分别覆盖 8 – 5 = 3 个时间单位，和 25 – 9 = 16
    个时间单位，总共是 19 个时间单位。
- en: The correct answer is 19, not 16\. Firing the lifeguard with the shortest time
    interval didn’t work.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案是 19，而不是 16。解雇时间间隔最短的救生员并没有奏效。
- en: 'It’s not easy to come up with a simple rule that always works to solve this
    problem. We don’t need to worry, though: with a complete-search algorithm, we
    dodge this requirement entirely.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个始终有效的简单规则来解决这个问题并不容易。不过我们不需要担心：通过完整搜索算法，我们可以完全绕过这一要求。
- en: 'Here’s what our complete-search algorithm will do to solve our test case:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的完整搜索算法如何解决测试用例的过程：
- en: First, it will ignore the first lifeguard and determine the number of units
    of time that the three remaining lifeguards cover. It will obtain an answer of
    16\. It will remember 16 as the score to beat.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它将忽略第一个救生员，确定其余三个救生员所覆盖的时间单位数。它将得到一个 16 的答案，并将其记住为需要超越的分数。
- en: Next, it will ignore the second lifeguard and determine the number of units
    of time that the three remaining lifeguards cover. It will obtain an answer of
    19\. Since 19 is greater than 16, it will remember 19 as the score to beat.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它将忽略第二个救生员，确定其余三个救生员所覆盖的时间单位数。它将得到一个 19 的答案。由于 19 大于 16，它会将 19 记住为超越的分数。
- en: Next, it will ignore the third lifeguard and determine the number of units of
    time that the three remaining lifeguards cover. It will obtain an answer of 14\.
    The score to beat is still 19.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它将忽略第三个救生员，确定其余三个救生员所覆盖的时间单位数。它将得到一个 14 的答案，超越的分数依然是 19。
- en: Finally, it will ignore the fourth lifeguard and determine the number of units
    of time that the three remaining lifeguards cover. It will obtain an answer of
    16\. The score to beat is still 19.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它将忽略第四个救生员，并确定其余三个救生员所覆盖的时间单位数量。它将得到16的答案。要打破的分数仍然是19。
- en: Having considered the ramifications of firing each lifeguard, the algorithm
    concludes that 19 is the correct answer. There can be no better answer than this,
    because we tried every option! We performed a complete search of the possible
    solutions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了解雇每个救生员的后果之后，算法得出结论，19是正确答案。因为我们尝试了所有的选项，所以没有比这更好的答案了！我们进行了完整的解决方案搜索。
- en: Solving the Problem
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: To use complete search, it’s often helpful to begin by writing a function that
    solves the problem for a particular candidate solution. We can then call that
    function many times, once for each candidate solution.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用完整搜索，通常有助于首先编写一个函数，解决某个特定候选解决方案的问题。然后，我们可以多次调用该函数，每次使用一个候选解决方案。
- en: Firing One Lifeguard
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解雇一个救生员
- en: Let’s write a function to determine the number of time units that are covered
    when one particular lifeguard is fired. [Listing 9-1](ch09.xhtml#ch09ex01) shows
    the code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数来确定解雇某个特定救生员时所覆盖的时间单位数。[列表 9-1](ch09.xhtml#ch09ex01)展示了代码。
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-1: Solving when one particular lifeguard is fired*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-1：解雇某个特定救生员时的解决方案*'
- en: 'The first parameter is a list of lifeguard time intervals; the second is the
    index of the lifeguard to fire. Enter the code into the Python shell. Here are
    two sample calls of the function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是救生员时间间隔的列表；第二个参数是被解雇的救生员的索引。将代码输入Python shell。以下是两个函数调用的示例：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These calls confirm that we can cover 16 units of time if we fire lifeguard
    0 and can cover 19 units of time if we fire lifeguard 1.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调用确认，如果我们解雇救生员0，我们可以覆盖16个时间单位；如果我们解雇救生员1，我们可以覆盖19个时间单位。
- en: Now let’s understand how the function operates. We begin by creating a set that
    will hold the units of time that are covered ❶. Whenever a unit of time is covered,
    the code will add the start of that unit of time to the set. For example, if the
    unit of time from 0 to 1 is covered, then the code will add `0` to the set; if
    the unit of time from 4 to 5 is covered, it will add `4` to the set.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解这个函数是如何操作的。我们首先创建一个集合，用来存储覆盖的时间单位❶。每当有时间单位被覆盖时，代码会将该时间单位的起始时间添加到集合中。例如，如果从0到1的时间单位被覆盖，代码会将`0`添加到集合中；如果从4到5的时间单位被覆盖，它将添加`4`到集合中。
- en: We loop through the lifeguard time intervals. If a lifeguard isn’t fired, then
    we loop through this lifeguard’s time interval ❷ to consider each unit of covered
    time. We add each of these time units to the set ❸, as promised. Recall that sets
    don’t retain duplicate values; we don’t have to worry if we try to add the same
    unit of time multiple times. We’ve gone through all of the nonfired lifeguards
    and added to the set all units of time that are covered. We therefore simply return
    the number of values in the set.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历救生员时间间隔。如果某个救生员没有被解雇，那么我们会遍历该救生员的时间间隔❷，考虑每一个被覆盖的时间单位。我们将这些时间单位添加到集合中❸，如承诺的那样。回想一下，集合不会保留重复的值；如果我们尝试多次添加相同的时间单位，也不用担心。我们已经遍历了所有没有被解雇的救生员，并将所有覆盖的时间单位添加到了集合中。因此，我们只需返回集合中的值的数量。
- en: The Main Program
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主程序
- en: The main part of our program is in [Listing 9-2](ch09.xhtml#ch09ex02). It uses
    the `num_covered` function to determine the number of units of time that are covered
    when separately firing each lifeguard. Be sure to enter our `num_covered` function
    ([Listing 9-1](ch09.xhtml#ch09ex01)) before this code for a complete solution
    to the problem.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的主要部分在[列表 9-2](ch09.xhtml#ch09ex02)中。它使用`num_covered`函数来确定分别解雇每个救生员时所覆盖的时间单位数。请确保在这段代码之前输入我们的`num_covered`函数([列表
    9-1](ch09.xhtml#ch09ex01))，以便完整解决这个问题。
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-2: Main program*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-2：主程序*'
- en: We’re working with files here, not standard input and standard output.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里处理的是文件，而不是标准输入和标准输出。
- en: The program begins by reading the number of lifeguards and then uses a range
    `for` loop to read each lifeguard’s time interval. We read each time interval
    from the input ❶, convert each of its components to an integer, and append it
    as a two-value list to our list of intervals.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 程序开始时读取救生员的数量，然后使用`for`循环读取每个救生员的时间间隔。我们从输入❶中读取每个时间间隔，将其各个组成部分转换为整数，并将其作为一个包含两个值的列表附加到我们的时间间隔列表中。
- en: We use the `max_covered` variable to track the maximum number of time units
    that can be covered.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`max_covered`变量来跟踪可以覆盖的最大时间单位数。
- en: Now we separately fire each lifeguard using a range `for` loop ❷. We call `num_covered`
    ❸ to determine the number of time units that are covered given the firing of one
    lifeguard. We update `max_covered` whenever we’re able to cover a greater number
    of time units.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过一个 `for` 循环 ❷ 分别开火每个救生员。我们调用 `num_covered` ❸ 来确定一个救生员开火后能覆盖的时间单位数。每当我们能够覆盖更多的时间单位时，就会更新
    `max_covered`。
- en: When that loop completes, we’ll have checked the number of units of time that
    can be covered by firing each lifeguard, and we’ll have remembered the maximum.
    We output this maximum to solve the problem.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当那个循环完成时，我们将检查每个救生员的开火所能覆盖的时间单位，并记住其中的最大值。我们输出这个最大值来解决问题。
- en: Feel free to submit our code to the USACO judge. For Python code, this judge
    uses a time limit per test case of four seconds, but our solution shouldn’t come
    close to that limit. For example, I just ran the code here, and each test case
    finished in no more than 130 milliseconds.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以将我们的代码提交给 USACO 判定器。对于 Python 代码，判定器每个测试用例的时间限制是四秒，但我们的解决方案应该不会接近这个限制。例如，我刚刚运行了这段代码，每个测试用例的执行时间都不超过
    130 毫秒。
- en: Efficiency of Our Program
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们程序的效率
- en: The reason our code is so fast is because there are so few lifeguards—only at
    most 100 of them. If there were a large number of lifeguards, then our code would
    no longer solve the problem within the time limit. We’d be fine if there were
    a few hundred lifeguards. We might squeak through if we had as many as 3,000 or
    4,000 lifeguards. Any more than that, though, and our code would be too slow.
    We probably couldn’t make it in time with 5,000 lifeguards, for example. We’d
    need to design a new algorithm, likely one that uses something faster than complete
    search.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码之所以如此快速，是因为救生员的数量非常少——最多只有 100 名。如果救生员的数量很多，那么我们的代码就无法在时间限制内解决问题。如果只有几百名救生员，应该没问题。如果有
    3,000 或 4,000 名救生员，我们也许还能勉强完成。再多的话，代码就太慢了。例如，如果有 5,000 名救生员，我们可能无法按时完成。我们需要设计一种新算法，可能是采用比完全搜索更快的方法。
- en: You might think that 5,000 is a huge number of lifeguards and that it’s okay
    that our algorithm can’t go that high. But it’s not! Think back to the Email Addresses
    problem in [Chapter 8](ch08.xhtml#ch08). There, we had to contend with up to 100,000
    email addresses. And think back to the Cities and States problem in the same chapter.
    There, we had to contend with up to 200,000 cities. By comparison, 5,000 is not
    a lot of lifeguards.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为 5,000 名救生员是一个非常庞大的数字，既然我们的算法无法处理这么多，也没关系。但其实不然！回想一下[第 8 章](ch08.xhtml#ch08)中的电子邮件地址问题。那时，我们要处理最多
    100,000 个电子邮件地址。再想想同一章中的城市和州问题。那时，我们需要处理最多 200,000 个城市。相比之下，5,000 名救生员其实并不算多。
- en: A complete-search solution often works fine for a small amount of input. Large
    test cases are often where complete-search solutions break down.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 完全搜索的解决方案通常在输入量较小的情况下效果良好。然而，大规模的测试用例往往是完全搜索解决方案失效的地方。
- en: The reason that our complete-search solution for Lifeguards doesn’t work well
    with large test cases is because it does a lot of repeated work. Imagine that
    we’re solving a test case with 5,000 lifeguards. We’ll fire lifeguard `0` and
    call `num_covered` to determine the number of units of time covered by the remaining
    lifeguards. Then, we’ll fire lifeguard `1` and call `num_covered` again. Now,
    what `num_covered` does this time is similar to what it did on the previous call.
    After all, things haven’t changed much. The only change is that lifeguard 0 is
    back and lifeguard 1 is fired. The other 4,998 lifeguards are the same as they
    were! But `num_covered` doesn’t know that. It grinds through all of the lifeguards
    again. That same thing happens when we fire lifeguard 2, then lifeguard 3, and
    so on. Each time, `num_covered` does all of its work from scratch, without learning
    anything about what it did previously.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的完全搜索解决方案之所以在大规模测试用例下对救生员问题不太适用，是因为它做了大量重复的工作。假设我们正在解决一个包含 5,000 名救生员的测试用例。我们会开火救生员
    `0` 并调用 `num_covered` 来确定其余救生员所能覆盖的时间单位数。然后，我们开火救生员 `1` 并再次调用 `num_covered`。这次
    `num_covered` 所做的事情和之前调用时差不多。毕竟，情况没有发生太大变化。唯一的不同是救生员 0 回来了，救生员 1 被开火了。其余的 4,998
    名救生员和之前一样！但是 `num_covered` 并不知道这一点。它会重新计算所有救生员。每次我们开火救生员 2、3 等等时，`num_covered`
    都会从头开始做所有工作，完全没有记住它之前做了什么。
- en: Remember that, while useful, complete-search algorithms do have limitations.
    Given a new problem that we want to solve, a complete-search algorithm is a useful
    starting point, even if it ultimately turns out to be too inefficient. That’s
    because the act of designing that algorithm may deepen our appreciation of the
    problem and lead to new ideas for solving it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管完全搜索算法有其用处，但它们也有局限性。对于我们想要解决的新问题，完全搜索算法是一个有用的起点，即使它最终证明效率太低。这是因为设计该算法的过程可能会加深我们对问题的理解，并激发出新的解决思路。
- en: In the next section, we’ll see another problem where we’ll be able to use complete
    search.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看到另一个可以使用完全搜索的方法来解决的问题。
- en: '**CONCEPT CHECK**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Is the following version of `num_covered` correct?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本的 `num_covered` 是否正确？
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A. Yes
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是
- en: B. No
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: B. 否
- en: 'Answer: B. This function removes the fired lifeguard from the list of lifeguards.
    That’s not allowed, because the docstring doesn’t say anything about the function
    modifying the list. With this version of the function, our program will fail many
    test cases because lifeguard information is lost over time. For example, when
    we test firing lifeguard 0, lifeguard 0 is removed from the list. When we later
    test firing lifeguard 1, lifeguard 0 is unfortunately still gone! If you want
    to use a version of the function where the fired lifeguard is removed from the
    list, you need to work with a copy of the list rather than the original.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B. 这个函数将被解雇的救生员从救生员列表中移除。这样是不允许的，因为文档字符串中没有说明该函数会修改列表。使用这个版本的函数时，我们的程序会在多个测试用例中失败，因为救生员信息会随着时间丢失。例如，当我们测试解雇救生员0时，救生员0会从列表中被移除。之后，当我们测试解雇救生员1时，遗憾的是救生员0已经消失了！如果你想使用一个版本的函数，其中被解雇的救生员会从列表中移除，你需要操作列表的副本，而不是原始列表。
- en: 'Problem #22: Ski Hills'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题#22：滑雪山丘
- en: Sometimes, the problem description makes it clear what we should search through
    in a complete-search solution. For example, in Lifeguards, we were asked to fire
    one lifeguard, so it made sense to try firing each one. Other times, we’ll have
    to be more creative to determine what to search through. As you read this next
    problem, think about what you would search in a complete-search solution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，问题描述会明确指出我们应该在完全搜索的解决方案中搜索什么。例如，在救生员问题中，我们被要求解雇一名救生员，所以尝试解雇每一名救生员是有意义的。而其他时候，我们需要更有创意地确定应该搜索什么内容。当你阅读下一个问题时，想一想在完全搜索的解决方案中，你会搜索什么。
- en: This is USACO 2014 January Bronze Contest problem Ski Course Design.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是USACO 2014年1月的铜奖比赛题目：滑雪道设计。
- en: The Challenge
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Farmer John has *n* hills on his farm, each with a height between 0 and 100\.
    He would like to register his farm as a ski training camp.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 农民约翰的农场上有 *n* 座山丘，每座山丘的高度在0到100之间。他希望将他的农场注册为滑雪训练营。
- en: A farm can be registered as a ski training camp only if the difference in height
    between the highest and lowest hills is 17 or less. Farmer John may therefore
    need to increase the heights of some of his hills and decrease the heights of
    others. He is able to change the heights only by integer amounts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当最高山丘和最低山丘之间的高度差不超过17时，一块农场才能注册为滑雪训练营。因此，农民约翰可能需要增加一些山丘的高度并减少其他山丘的高度。他只能以整数值改变山丘的高度。
- en: The cost of changing a hill’s height by *x* units is *x*². For example, changing
    a hill from height 1 to height 4 costs (4 – 1)² = 9.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 改变一座山丘的高度* x *单位的成本是 *x*²。例如，将一座山丘从高度1改为高度4的成本是(4 – 1)² = 9。
- en: Determine the minimum amount that Farmer John will need to pay to change the
    heights of hills so that he can register his farm as a ski training camp.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 确定农民约翰需要支付的最小金额，以改变山丘的高度，从而能够将他的农场注册为滑雪训练营。
- en: Input
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *skidesign.in*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为*skidesign.in*的文件中读取输入。
- en: 'The input consists of the following lines:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包括以下几行：
- en: A line containing integer *n*, the number of hills on the farm. *n* is between
    1 and 1,000.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含整数 *n* 的一行，表示农场上的山丘数量。*n* 的值介于1和1000之间。
- en: '*n* lines, each of which gives the height of a hill. Each height is an integer
    between 0 and 100.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行给出一座山丘的高度。每个高度是介于0和100之间的整数。'
- en: Output
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *skidesign.out*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入名为*skidesign.out*的文件。
- en: Output the minimum amount that Farmer John will need to pay to change the heights
    of hills.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出农民约翰需要支付的最小金额，以改变山丘的高度。
- en: The time limit for solving each test case is four seconds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例的时间限制为四秒。
- en: Exploring a Test Case
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索一个测试用例
- en: Let’s see if we can apply what we learned from Lifeguards to this problem. To
    solve Lifeguards, we separately fired each lifeguard to figure out the lifeguard
    that we should fire. To solve Ski Hills, perhaps there’s something analogous that
    we can do with each hill? For example, perhaps we can use each hill’s height as
    the low end in an allowed height range?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看能否将从 Lifeguards 中学到的内容应用到这个问题中。为了解决 Lifeguards 问题，我们分别试图解雇每个救生员，找出应该解雇的救生员。要解决滑雪山丘问题，也许我们能对每个山丘做类似的处理？例如，也许我们可以将每个山丘的高度作为允许高度范围的低端？
- en: 'We’ll give this a try using the following test case:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下测试用例进行尝试：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The smallest height of these four hills is 2, and the biggest height is 40\.
    The difference between 40 and 2 is 38, greater than 17\. Farmer John is going
    to have to pay to fix these hills!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个山丘中的最小高度是 2，最大高度是 40。40 和 2 之间的差是 38，大于 17。Farmer John 需要支付费用来修正这些山丘！
- en: The first hill is height 23\. If we use 23 as the low end of the range, then
    the high end is 23 + 17 = 40\. We need to calculate the cost to bring all hills
    into the range 23–40\. There are two hills that are out of this range, the ones
    of heights 16 and 2\. Bringing them up to height 23 costs (23 – 16)² + (23 – 2)²
    = 490\. A cost of 490 is the cost to beat.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个山丘的高度是 23。如果我们将 23 作为范围的低端，那么高端就是 23 + 17 = 40。我们需要计算将所有山丘都带入范围 23–40 的成本。有两个山丘不在这个范围内，分别是高度为
    16 和 2 的山丘。将它们提升到高度 23 的成本是 (23 – 16)² + (23 – 2)² = 490。490 的成本仍然是需要打破的成本。
- en: The second hill is height 40\. The high end of this range is 40 + 17 = 57, so
    we’re looking to get all hills into the range 40–57\. The other three hills are
    out of this range, so each of them contributes to the total cost. That total is
    (40 – 23)² + (40 – 16)² + (40 – 2)² = 2,309\. This is greater than 490, our current
    minimum cost, so 490 is still the cost to beat. (Remember that in this problem
    we’re trying to *minimize* Farmer John’s cost, whereas in Lifeguards we were trying
    to *maximize* coverage.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个山丘的高度是 40。这个范围的高端是 40 + 17 = 57，因此我们需要将所有山丘都包含在 40–57 的范围内。其他三个山丘不在这个范围内，因此每个山丘都会增加总成本。这个总成本是
    (40 – 23)² + (40 – 16)² + (40 – 2)² = 2,309。这个值大于 490，我们当前的最小成本，所以 490 仍然是要打破的成本。（记住，在这个问题中，我们的目标是*最小化*
    Farmer John 的成本，而在 Lifeguards 中，我们的目标是*最大化*覆盖率。）
- en: The third hill is height 16, which gives us the range 16–33\. There are two
    hills that are out of this range, the ones of heights 40 and 2\. The total cost
    for this range is therefore (40 – 33)² + (16 – 2)² = 245\. The new cost to beat
    is 245!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个山丘的高度是 16，这给我们提供了范围 16–33。有两个山丘不在这个范围内，分别是高度为 40 和 2 的山丘。因此，这个范围的总成本是 (40
    – 33)² + (16 – 2)² = 245。新的最小成本是 245！
- en: The fourth hill is height 2, which gives us the range 2–19\. If you calculate
    the cost for this range, you should obtain a cost of 457.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个山丘的高度是 2，这给我们提供了范围 2–19。如果你计算这个范围的成本，你应该得到 457 的成本。
- en: The minimum cost we obtained using that algorithm is 245\. Is 245 the answer?
    Are we done?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个算法得到的最小成本是 245。245 是答案吗？我们完成了吗？
- en: 'No and no! It turns out that the minimum cost is 221\. There are two ranges
    that give us this minimum cost: 12–29 and 13–30\. There is no hill whose height
    is 12\. Similarly, there is no hill whose height is 13\. We therefore can’t use
    hill heights as the possible low ends of ranges.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不对，完全不对！结果显示，最小成本是 221。我们有两个范围可以得到这个最小成本：12–29 和 13–30。没有一个山丘的高度是 12。同样，也没有一个山丘的高度是
    13。因此，我们不能将山丘的高度作为范围的可能低端。
- en: Think about what a correct complete-search algorithm could look like, one that’s
    guaranteed not to miss any ranges.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看，一个正确的完整搜索算法应该是什么样子，能够保证不会漏掉任何范围。
- en: Here’s a plan that’s guaranteed to get us the correct answer. We start by calculating
    the cost for range 0–17\. Then we calculate the cost for range 1–18\. Then 2–19\.
    Then 3–20\. Then 4–21, and so on. We test every possible range, one by one, and
    remember the minimum cost that we obtain. The ranges we test have nothing to do
    with the heights of the hills. Since we’re testing every possible range, there’s
    no way we’ll miss finding the best one.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个计划，保证能帮我们得到正确的答案。我们从计算范围 0–17 的成本开始。然后我们计算范围 1–18 的成本。接着是 2–19。然后是 3–20，再是
    4–21，依此类推。我们逐个测试每个可能的范围，并记住我们得到的最小成本。我们测试的范围与山丘的高度无关。由于我们测试了所有可能的范围，因此不可能错过找到最优解。
- en: Which ranges should we test? How high should we go? Should we test the range
    50–67? Yes. How about the range 71–88? Yes again. How about 115–132? No! Not that
    one.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该测试哪些范围？要测试多高的范围？我们应该测试范围 50–67 吗？是的。那范围 71–88 呢？再次是的。那 115–132 呢？不！不是那个。
- en: The final range that we’ll check is 100–117\. The reason has to do with the
    guarantee from the problem description that the height of any hill is at most
    100.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要检查的最后一个区间是 100–117。原因在于问题描述中有一个保证，即任何山丘的高度最多为 100。
- en: Suppose we figure out the cost for range 101–118\. Without even knowing the
    heights of the hills, we know for sure that none of the hills is in this range.
    The maximum height of a hill, after all, is 100, and our range starts at 101\.
    Now slide our range from 101–118 down to 100–117\. This 100–117 range costs less
    than the 101–118 range! That’s because 100 is closer to the hills than 101 is.
    For example, consider a hill of height 80\. This hill would cost us 21² = 441
    to raise it to height 101, but only 20² = 400 to raise it to height 100\. This
    shows that 101–118 cannot be the best range to use. There’s no point trying it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们算出了区间 101–118 的成本。即使不知道山丘的高度，我们也能确定这个区间内没有任何山丘。毕竟山丘的最大高度是 100，而我们的区间从 101
    开始。现在将我们的区间从 101–118 滑动到 100–117。这个 100–117 区间的成本比 101–118 低！这是因为 100 比 101 离山丘更近。例如，考虑一座高度为
    80 的山丘。将这座山丘的高度提高到 101，需要花费 21² = 441，但将其提高到 100 只需要 20² = 400。由此可见，101–118 不能是最优的区间，尝试它是没有意义的。
- en: Similar logic explains why it’s pointless to try any higher range such as 102–119,
    103–120, and so on. We can always slide these ranges down to make them cost less.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的逻辑也解释了为什么尝试更高的区间，比如 102–119、103–120 等，毫无意义。我们总是可以将这些区间滑动下来，从而减少其成本。
- en: 'In summary, we are going to test exactly 101 ranges: 0–17, 1–18, 2–19, and
    so on, all the way up to 100–117\. We’ll remember the cost of the best one. Let’s
    do this!'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将测试正好 101 个区间：0–17、1–18、2–19，以此类推，一直到 100–117。我们会记住最优区间的成本。让我们开始吧！
- en: Solving the Problem
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: We’ll take the solution in two steps, just as we did when solving Lifeguards.
    We’ll start with a function to determine the cost of a single range. Then we’ll
    write a main program to call this function once for each range.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步来解决问题，就像解决 Lifeguards 问题时那样。我们首先写一个函数来计算单个区间的成本。然后编写一个主程序，为每个区间调用该函数一次。
- en: Determining the Cost of One Range
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算一个区间的成本
- en: '[Listing 9-3](ch09.xhtml#ch09ex03) gives the code for the function that determines
    the cost of a given range.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-3](ch09.xhtml#ch09ex03) 给出了计算给定区间成本的函数代码。'
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 9-3: Solving for one particular range*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-3：求解某一特定区间*'
- en: I’ve included two constants that we’ll use later. The `MAX_DIFFERENCE` constant
    records the maximum difference allowed between the heights of the highest and
    lowest hills. The `MAX_HEIGHT` constant records the maximum height of a hill.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经包含了我们稍后会用到的两个常量。`MAX_DIFFERENCE` 常量记录了最高山丘和最低山丘之间允许的最大高度差。`MAX_HEIGHT` 常量记录了山丘的最大高度。
- en: Now let’s turn to the `cost_for_range` function. It takes a list of hill heights
    and a desired range specified by its low end and high end. It returns the cost
    of changing hill heights so that all hills are in the desired range. I encourage
    you to enter the code for the function into the Python shell so that you can try
    it before continuing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看 `cost_for_range` 函数。它接受一个山丘高度的列表和一个由低端和高端指定的目标区间。它返回将山丘高度调整到目标区间所需的成本。我建议你在
    Python 解释器中输入这个函数的代码，以便在继续之前进行测试。
- en: The function loops through the height of each hill ❶, adding up the cost to
    bring that hill into the desired range. There are two cases we need to account
    for. First, the height of the current hill might be out of range by being less
    than `low` ❷. The expression `low - height` gives us the amount of height that
    we need to add to this hill, and we square that result to get the cost ❸. Second,
    the height of the current hill might be out of range by being greater than `high`
    ❹. The expression `height - high` gives us the amount of height that we need to
    subtract from this hill, and we square that result to get the cost ❺. Notice that
    we don’t do anything if the height is already in the low-high range. Once we’ve
    gone through all of the heights, we return the total cost.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数遍历每个山丘的高度 ❶，计算将该山丘调整到目标区间所需的成本。我们需要考虑两种情况。首先，当前山丘的高度可能低于 `low`，即超出了下限 ❷。表达式
    `low - height` 给出我们需要为这座山丘增加的高度，我们将这个结果平方来得到成本 ❸。其次，当前山丘的高度可能高于 `high`，即超出了上限
    ❹。表达式 `height - high` 给出我们需要为这座山丘减少的高度，我们将这个结果平方来得到成本 ❺。请注意，如果山丘的高度已经在低高区间内，我们不会做任何操作。遍历完所有山丘后，我们返回总成本。
- en: The Main Program
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主程序
- en: The main part of our program is in [Listing 9-4](ch09.xhtml#ch09ex04). It uses
    the `cost_for_range` function to determine the cost for each range. Be sure to
    enter our `cost_for_range` function ([Listing 9-3](ch09.xhtml#ch09ex03)) before
    this code for a complete solution to the problem.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的主要部分在 [清单 9-4](ch09.xhtml#ch09ex04) 中。它使用 `cost_for_range` 函数来确定每个范围的成本。确保在这段代码之前输入我们的
    `cost_for_range` 函数（[清单 9-3](ch09.xhtml#ch09ex03)），以便完整解决问题。
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 9-4: Main program*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-4：主程序*'
- en: We start by reading the number of hills and then read each height into the `heights`
    list.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先读取山丘的数量，然后将每个高度读入 `heights` 列表中。
- en: We use the `min_cost` variable to remember the minimum cost that we’ve discovered
    so far. We set `min_cost` to the cost for range 0–17 ❶. Then, in a range `for`
    loop ❷, we try every other range cost, updating `min_cost` every time we find
    a smaller cost. When we’re done with this loop, we output the minimum cost that
    we found.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `min_cost` 变量来记录迄今为止发现的最小成本。我们将 `min_cost` 设置为范围 0–17 的成本 ❶。然后，在一个范围 `for`
    循环 ❷ 中，我们尝试其他范围的成本，每当找到更小的成本时，就更新 `min_cost`。当这个循环结束时，我们输出我们找到的最小成本。
- en: It’s time to submit our code to the judge. Our complete-search solution should
    solve the problem well under the time limit.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的代码提交给评审了。我们的完全搜索解决方案应当能够在时间限制内良好地解决问题。
- en: In the next problem, we’ll see an example where a straight complete-search solution
    is not efficient enough.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个问题中，我们将看到一个示例，其中直接的完全搜索解决方案效率不足。
- en: '**CONCEPT CHECK**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: 'Here’s a proposed change to the code in [Listing 9-4](ch09.xhtml#ch09ex04).
    Take this line:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 [清单 9-4](ch09.xhtml#ch09ex04) 中代码的提议更改。请看这一行：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And change it to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其更改为以下内容：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Is the code still correct?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码仍然正确吗？
- en: A. Yes
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是
- en: B. No
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: B. 否
- en: 'Answer: A. The last range that the code now checks is 83–100, so we have to
    argue that the ranges we no longer check—84–101, 85–102, and so on—don’t matter.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A。代码现在检查的最后一个范围是 83–100，所以我们必须证明我们不再检查的范围——84–101、85–102 等——并不重要。
- en: Consider the range 84–101\. If we can argue that the range 83–100 is at least
    as good as 84–101, then we would have no reason to check range 84–101.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑范围 84–101。如果我们可以证明范围 83–100 至少与 84–101 一样好，那么我们就没有理由检查范围 84–101。
- en: 'The range 84–101 includes height 101\. But that’s pointless: the highest hill
    has height 100, so height 101 may as well not even be there. We can remove 101
    without making the range worse. If we remove it, we’re left with the range 84–100\.
    Aha—but 100–84 is only 16, and we’re allowed to have a difference of 17\. So we
    can extend the range by one on the left, giving us a range of 83–100\. Surely,
    making the range bigger like this can’t make the range any worse. It might even
    make the range better, since it’s now one unit closer to any hill whose height
    is 83 or less.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 范围 84–101 包括高度 101。但是，这毫无意义：最高的山丘高度是 100，所以 101 的高度就不需要存在了。我们可以去掉 101，而不会使范围变差。如果去掉它，剩下的范围是
    84–100。哈——但 100–84 只有 16，而我们允许的差值是 17。所以我们可以将范围从左边扩展一个单位，得到 83–100 的范围。显然，这样扩大范围不会让范围变差，甚至可能使范围更好，因为它现在距离任何高度为
    83 或更低的山丘更近了。
- en: We started with range 84–101 and showed that range 83–100 is at least as good.
    We can make this same argument for range 85–102, 86–103, and so on. There’s no
    point going any higher than 83–100!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从范围 84–101 开始，并证明范围 83–100 至少与之同样有效。我们可以对范围 85–102、86–103 等做相同的推理。没有必要去考虑比
    83–100 更大的范围！
- en: Before continuing, you might like to try solving exercises 1 and 2 from “Chapter
    Exercises” on [page 263](ch09.xhtml#ch09lev1sec14).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可以尝试解决“章节练习”中的第 1 和第 2 题，见 [第 263 页](ch09.xhtml#ch09lev1sec14)。
- en: 'Problem #23: Cow Baseball'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #23：牛球赛'
- en: To end this chapter, I’ve chosen a problem where we’ll need to bump up our algorithm
    design skills beyond complete search. As you read the problem, notice that there’s
    not all that much input. That generally signals the effectiveness of a complete-search
    algorithm. But not this time, because of the amount of searching that such an
    algorithm has to do through this input. The difficulty boils down to having too
    many nested loops. Why do the nested loops bite us here? What can we do about
    it? Read on!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，我选择了一个我们需要提升算法设计技能的题目，超越完全搜索的范畴。当你阅读这个问题时，请注意输入并不多。这通常意味着完全搜索算法的有效性。但这一次并非如此，因为这种算法需要在输入中进行大量搜索。困难的关键在于有太多嵌套循环。为什么嵌套循环在这里会给我们带来麻烦？我们能做些什么呢？继续阅读！
- en: This is USACO 2013 December Bronze Contest problem Cow Baseball.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 USACO 2013 年 12 月铜级竞赛题目“牛球赛”。
- en: The Challenge
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Farmer John has *n* cows. They are standing in a row, each at a distinct integer
    position. They are having fun throwing a baseball around.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 农场主约翰有 *n* 只牛。它们排成一排，每只牛处在一个独特的位置。它们正在玩传球棒球的游戏。
- en: Farmer John is watching the antics. He observes that cow *x* throws the ball
    to some cow *y* to its right, and then that cow *y* throws the ball to some cow
    *z* to its right. He also knows that the distance of the second throw is at least
    the distance of the first throw and at most twice the distance of the first throw.
    (For example, if the first throw is distance 5, then the second throw is at least
    distance 5 and at most distance 10.)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 农场主约翰正在观察这些牛的举动。他观察到牛 *x* 将球投给其右侧的牛 *y*，然后牛 *y* 又将球投给其右侧的牛 *z*。他还知道，第二次投球的距离至少是第一次投球的距离，并且最多是第一次投球距离的两倍。（例如，如果第一次投球的距离是
    5，那么第二次投球的距离至少是 5，最多是 10。）
- en: Determine the number of (*x*, *y*, *z*) triples of cows that satisfy Farmer
    John’s observations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 确定满足农场主约翰观察条件的 (*x*, *y*, *z*) 牛三元组的数量。
- en: Input
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: Read input from the file named *baseball.in*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为 *baseball.in* 的文件中读取输入。
- en: 'The input consists of the following lines:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含以下几行：
- en: A line containing *n*, the number of cows. *n* is between 3 and 1,000.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n*，即牛的数量。*n* 的值在 3 到 1,000 之间。
- en: '*n* lines, each of which gives the position of a cow. All positions are unique,
    and each is between 1 and 100,000,000.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行给出一只牛的位置。所有位置都是唯一的，且每个位置都在 1 到 100,000,000 之间。'
- en: Output
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Write output to the file named *baseball.out*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入名为 *baseball.out* 的文件。
- en: Output the number of triples of cows that satisfy Farmer John’s observations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出满足农场主约翰观察条件的牛三元组的数量。
- en: The time limit for solving each test case is four seconds.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例的时间限制为四秒。
- en: Using Three Nested Loops
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用三重嵌套循环
- en: We can use three nested loops to consider all possible triples. We’ll start
    by looking at the code and then discuss its efficiency.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三重嵌套循环来考虑所有可能的三元组。我们先来看一下代码，然后再讨论其效率。
- en: The Code
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'In “Nesting” in [Chapter 3](ch03.xhtml#ch03), we learned that we can loop through
    all pairs of values using two nested loops. Doing so looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.xhtml#ch03)中的“嵌套”一节里，我们学到了如何使用两重嵌套循环遍历所有的值对。这样做的代码如下所示：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can similarly loop through all triples of values using three nested loops,
    like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用三重嵌套循环，类似于这样遍历所有的三元组：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using three nested loops like this gives us a starting point for solving the
    Cow Baseball problem. For each triple, we can check whether it matches Farmer
    John’s observations. See [Listing 9-5](ch09.xhtml#ch09ex05) for the code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三重嵌套循环的方式为我们解决牛棒球问题提供了一个起点。对于每个三元组，我们可以检查它是否符合农场主约翰的观察条件。具体代码见 [列表 9-5](ch09.xhtml#ch09ex05)。
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-5: Using three nested* for *loops*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-5：使用三重*for*循环*'
- en: We read all of the cow positions into the `positions` list ❶. We then loop over
    all positions in the list using a `for` loop ❷. For each of these positions, we
    loop through all positions in the list using a nested `for` loop ❸. At this point,
    `position1` and `position2` refer to two positions from the list. We need a third
    nested loop, yes, but not yet. We first need to calculate the difference between
    `position1` and `position2` because that tells us the range of `position3`s that
    we’ll be looking for.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有牛的位置读取到 `positions` 列表❶中。然后，我们用一个 `for` 循环❷遍历列表中的所有位置。对于这些位置中的每一个，我们用一个嵌套的
    `for` 循环❸遍历列表中的所有位置。此时，`position1` 和 `position2` 分别代表列表中的两个位置。我们需要一个第三个嵌套循环，没错，但还不急。我们首先需要计算
    `position1` 和 `position2` 之间的差值，因为这决定了我们要查找的 `position3` 的范围。
- en: We require from the problem description that `position2` be on the right of
    `position1`. If it is ❹, then we calculate the low end and high end of the range
    for `position3` and store them using `low` and `high`, respectively. For example,
    if `position1` is 1 and `position2` is 6, then we’ll calculate 6 + 5 = 11 for
    `low` and 6 + 5 * 2 = 16 for `high`. Then we loop through the list with a third
    nested `for` loop ❺, looking for positions that are between `low` and `high`.
    For each such `position3`, we increase our total by `1`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 根据题目描述，我们要求 `position2` 在 `position1` 的右侧。如果满足这一条件❹，我们就计算 `position3` 的范围，分别用
    `low` 和 `high` 来存储。例如，如果 `position1` 是 1，`position2` 是 6，那么我们会计算 6 + 5 = 11 作为
    `low`，并计算 6 + 5 * 2 = 16 作为 `high`。接着，我们用第三个嵌套的 `for` 循环❺遍历列表，寻找位于 `low` 和 `high`
    之间的位置。对于每一个符合条件的 `position3`，我们就将总数加 1。
- en: Following the three nested loops, we have calculated the total number of triples.
    We finish up by outputting that number to the output file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随三个嵌套的循环，我们计算出了三元组的总数。最后，我们将这个数字输出到输出文件。
- en: 'Let’s try our program on a small test case to make sure nothing weird is happening.
    Here it is:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个小的测试用例上运行程序，确保没有出现奇怪的情况。测试用例如下：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The correct answer for this test case is 11\. The 11 satisfying triples are
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例的正确答案是11。满足条件的11个三元组如下：
- en: 14, 16, 18
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 14, 16, 18
- en: 14, 18, 23
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 14, 18, 23
- en: 1, 6, 16
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1, 6, 16
- en: 1, 6, 14
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1, 6, 14
- en: 1, 6, 11
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1, 6, 11
- en: 1, 11, 23
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1, 11, 23
- en: 6, 14, 23
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6, 14, 23
- en: 6, 11, 16
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6, 11, 16
- en: 6, 11, 18
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6, 11, 18
- en: 11, 16, 23
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 11, 16, 23
- en: 11, 14, 18
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 11, 14, 18
- en: 'Good news: our program outputs `11` for this test case! It does so because
    it eventually finds each satisfying triple. For example, at some point, `position1`
    will be `14`, `position2` will be `16`, and `position3` will be `18`. That triple
    satisfies the distance requirements, so our program will count it in our total.
    Don’t be worried about what will happen, later, when `position1` is `18`, `position2`
    is `16`, and `position3` is `14`. We definitely don’t want to count that one,
    because these throws are not going to the right. We’re fine, though: the `if`
    statement ❹ prevents these triples from being processed.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息：我们的程序对于这个测试用例输出了`11`！它之所以能够输出这个结果，是因为程序最终找到了每个满足条件的三元组。例如，在某个时刻，`position1`会是`14`，`position2`会是`16`，`position3`会是`18`。这个三元组满足距离要求，因此程序会将其计入总数。不要担心，当`position1`是`18`，`position2`是`16`，`position3`是`14`时会发生什么。我们肯定不希望将那个三元组计入，因为这些投掷并没有朝着正确的方向进行。不过没关系：`if`语句❹会防止这些三元组被处理。
- en: Our program is correct. But as you’ll see if you submit it to the judge, it
    is not efficient enough. For this problem, and many competitive programming problems,
    the first few test cases are small—just a few cows, a few lifeguards, or a few
    ski hills. Our program should be able to solve those in time. The remaining test
    cases test our program closer and closer to the limit of acceptable input. Our
    program does not solve those in time. It’s too slow.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序是正确的。但正如你在提交给判题系统后看到的，它的效率不够高。对于这个问题以及许多竞争编程问题，前几个测试用例都比较小——只有几只牛、几位救生员或几座滑雪山。我们的程序应该能够在规定时间内解决这些问题。剩下的测试用例则测试我们的程序是否能处理接近最大输入量的情况。我们的程序无法在规定时间内解决这些问题，速度太慢了。
- en: Efficiency of Our Program
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们程序的效率
- en: 'To understand why our program is so slow, it helps to think about the number
    of triples that it must go through. Think back to the test case we just studied,
    which had seven cows. How many triples will our program check? Well, for the first
    cow, there are seven choices: 16, 14, 23, and so on. There are also seven choices
    for the second cow, and seven choices for the third cow. Multiplying these together,
    we see that our program checks 7 * 7 * 7 = 343 triples.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么我们的程序如此缓慢，我们可以考虑一下它必须检查的三元组数量。回想一下我们刚才研究过的测试用例，那里有7只牛。我们的程序将检查多少个三元组呢？对于第一只牛，有七个选择：16、14、23等等。第二只牛也有七个选择，第三只牛也有七个选择。将这些数相乘，我们可以得出程序检查了7
    * 7 * 7 = 343个三元组。
- en: What if we had eight cows instead of seven? Then our program would check 8 *
    8 * 8 = 512 triples.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有8只牛，而不是7只呢？那么程序将检查8 * 8 * 8 = 512个三元组。
- en: We can give an expression for the number of triples that works for any number
    of cows. Let’s use *n* for the number of cows; it could be 7, 8, 50, 1,000, and
    so on, depending on the test case. Then we can say that the number of triples
    our program checks is *n* * *n* * *n*, or *n*³.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以给出一个表达式，来表示适用于任意数量牛的三元组数。假设牛的数量是*n*；它可以是7、8、50、1000等等，具体取决于测试用例。然后我们可以说，程序检查的三元组数量是*n*
    * *n* * *n*，即*n*³。
- en: We can substitute any number of cows for *n* to determine the number of triples
    that we check. For example, we can verify that the number of triples for seven
    cows is 7³ = 343 and that the number of triples for eight cows is 8³ = 512\. These
    numbers—343 and 512—are tiny. It would take any computer no more than a few milliseconds
    to check those many triples. As a conservative guide, you can think of a Python
    program as being able to check or do about 5,000,000 things per second. The time
    limit for this problem is four seconds per test case, so we’ll be able to check
    about 20,000,000 triples.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以替换任意数量的牛为*n*来确定我们检查的三元组数量。例如，我们可以验证7只牛的三元组数量是7³ = 343，而8只牛的三元组数量是8³ = 512。这些数字——343和512——是微不足道的。任何计算机检查这些三元组都不会超过几毫秒。作为保守估计，你可以认为一个Python程序每秒钟大约能够检查或处理500万项任务。这个问题的时间限制是每个测试用例4秒，因此我们大约能检查2000万个三元组。
- en: 'Let’s substitute larger numbers for *n* and see what happens. For 50 cows,
    we have 50³ = 125,000 triples. No big deal: checking 125,000 things is easy for
    today’s computers. For 100 cows, we have 100³ = 1,000,000 triples. Again, no problem.
    We can check a million things in less than a second. For 200 cows, we have 200³
    = 8,000,000 triples. We’re still OK for four seconds, but I hope you’re starting
    to get a little worried. The number of triples is shooting up pretty quickly here,
    and we’re only at 200 cows. Remember that we need to be able to support up to
    1,000 cows.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用更大的数字代替*n*，看看会发生什么。对于50头牛，我们有50³ = 125,000个三元组。没问题：检查125,000个东西对今天的计算机来说不算什么。对于100头牛，我们有100³
    = 1,000,000个三元组。同样，没问题。我们可以在不到一秒钟的时间内检查一百万个东西。对于200头牛，我们有200³ = 8,000,000个三元组。我们在四秒钟内还行，但我希望你已经开始有些担心了。三元组的数量增长得相当快，而我们只考虑了200头牛。记住，我们需要支持最多1,000头牛。
- en: For 400 cows, we have 400³ = 64,000,000 triples. That’s too many for us to process
    in four seconds. To add insult to injury, let’s try 1,000 cows, the maximum we’ll
    ever get. For 1,000 cows, we have 1,000³ = 1,000,000,000 triples. That’s one billion.
    Nope. There’s no way we’re ever going to be able to check that many triples in
    four seconds. We’ll need to make our program more efficient.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于400头牛，我们有400³ = 64,000,000个三元组。这个数量太多，四秒钟内处理不过来。更糟的是，让我们试试1,000头牛，这是我们可能遇到的最大值。对于1,000头牛，我们有1,000³
    = 1,000,000,000个三元组。那就是十亿。不行。我们永远不可能在四秒钟内检查这么多三元组。我们需要让程序更加高效。
- en: Sorting First
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 先排序
- en: Sorting is helpful here. Let’s look at how to use sorting and then discuss the
    efficiency of our resulting solution.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 排序在这里很有帮助。让我们看看如何使用排序，并讨论我们最终解法的效率。
- en: The Code
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: Our cow positions can come in any order—there’s certainly no guarantee from
    the problem description that they’re sorted. Unfortunately, this leads our program
    to check many triples that have no chance of satisfying the requirements. For
    example, checking the triple 18, 16, 14 is pointless, because the numbers aren’t
    in increasing order. If we sorted the cow positions at the outset, then we could
    avoid ever checking these out-of-order triples.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的牛的位置可以按任何顺序排列——从问题描述中并没有保证它们是排序的。不幸的是，这导致我们的程序会检查许多根本不可能满足要求的三元组。例如，检查三元组18、16、14是没有意义的，因为这些数字不是按递增顺序排列的。如果我们一开始就对牛的位置进行排序，那么就可以避免检查这些不按顺序的三元组。
- en: There’s another benefit to sorting. Suppose that `position1` refers to some
    cow position and `position2` refers to another. For this pair of positions, we
    know the smallest value of `position3` and largest value of `position3` that we
    care about. We can use the fact that the positions are sorted to cut down on the
    number of values that we need to check for this range. Before continuing, think
    about why this is the case. How can we use the fact that the positions are sorted
    to look at fewer values?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 排序还有另一个好处。假设`position1`表示某个牛的位置，`position2`表示另一个牛的位置。对于这对位置，我们知道我们关心的`position3`的最小值和最大值。我们可以利用位置已排序的事实来减少我们需要检查的值的数量。在继续之前，想一想为什么会这样。我们如何利用位置已经排序这一事实，来查看更少的值呢？
- en: When you’re ready, see [Listing 9-6](ch09.xhtml#ch09ex06) for our code that
    uses sorting.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好后，查看[Listing 9-6](ch09.xhtml#ch09ex06)，其中有使用排序的代码。
- en: '[PRE14]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 9-6: Using sorting*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-6: 使用排序*'
- en: Before we start looking for triples, we sort the positions ❶.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查找三元组之前，先对位置进行排序❶。
- en: Our first loop goes through all positions using the loop variable `i` ❷. It’s
    a range `for` loop this time, not a `for` loop, so that we can keep track of which
    index we’re at. That’s useful because we can use the value of `i + 1` as the starting
    index for our second loop ❸. The second loop will now never waste time looking
    at positions that are to the left of the first position.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个循环使用循环变量`i` ❷遍历所有位置。这次是一个范围`for`循环，而不是一个普通的`for`循环，这样我们就能跟踪当前的索引。这样做很有用，因为我们可以使用`i
    + 1`的值作为第二个循环的起始索引❸。这样，第二个循环就不会浪费时间查看第一个位置左边的那些位置。
- en: We next calculate the low and high ends of the range of values for our third
    position.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算第三个位置的值范围的低端和高端。
- en: Rather than increase `total` by 1 each time we find a suitable third position,
    we can instead find the left and right borders of suitable positions and then
    increase `total` in one shot. We can only do it this way because the list of positions
    is sorted. We find each of the borders using a `while` loop. The first `while`
    loop finds the left border ❹. It keeps going as long as the positions are less
    than `low`. When it’s done, `left` will be the leftmost index whose position is
    greater than or equal to `low`. The second `while` loop finds the right border
    ❺. It keeps going as long as the positions are less than or equal to `high`. When
    it’s done, `right` is the rightmost index whose position is greater than `high`.
    Each of the positions from `left` up to but not including `right` can serve as
    the third position in a triple involving the positions at indices `i` and `j`.
    We add `right - left` to `total` to account for these positions ❻.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过找到适合的第三个位置的左右边界来增加`total`，而不是每次找到合适的第三个位置时就将`total`加1。我们之所以能够这样做，是因为位置列表已经排序。我们通过`while`循环找到每个边界。第一个`while`循环找到左边界❹。它会一直执行，直到位置大于等于`low`。当它完成时，`left`将是第一个大于或等于`low`的索引。第二个`while`循环找到右边界❺。它会一直执行，直到位置小于等于`high`。当它完成时，`right`将是第一个大于`high`的索引。从`left`到`right`之间的每个位置（不包括`right`）都可以作为包含索引`i`和`j`的三元组中的第三个位置。我们通过`right
    - left`将这些位置加到`total`中❻。
- en: 'The two `while` loops in this program are quite tricky. Let’s make sure we
    know exactly what they’re doing by working through an example. We’ll use the following
    list of positions; they’re the same as those we used in the previous section,
    but sorted:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序中的两个`while`循环相当复杂。让我们通过一个例子来确保我们完全理解它们的作用。我们将使用以下位置列表；这些位置与我们在前一节中使用的相同，只是经过了排序：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Suppose that `i` is `1` and `j` is `2` so that the two positions in prospective
    triples are `6` and `11`. For the third position, we’re therefore looking for
    positions greater than or equal to `16` and less than or equal to `21`. The first
    `while` loop will set `left` to `4`, the leftmost index whose position is greater
    than or equal to `16`. The second `while` loop will set `right` to `6`, the leftmost
    index whose position is greater than `21`. Subtracting `left` from `right`, we
    obtain 6 – 4 = 2, which means that there are two triples involving positions `6`
    and `11`. Before continuing, I encourage you to convince yourself that these `while`
    loops work just fine in “special” cases, such as when there are no suitable third
    positions or when there is one suitable third position.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`i`为`1`，`j`为`2`，那么预期三元组中的两个位置分别是`6`和`11`。因此，第三个位置应该是大于或等于`16`且小于或等于`21`的索引。第一个`while`循环将`left`设置为`4`，即第一个大于或等于`16`的位置的索引。第二个`while`循环将`right`设置为`6`，即第一个大于`21`的位置的索引。从`right`中减去`left`，得到6
    – 4 = 2，这意味着有两个三元组涉及到位置`6`和`11`。在继续之前，我建议你验证一下这些`while`循环在“特殊”情况下是否能够正常工作，比如没有合适的第三个位置，或者只有一个合适的第三个位置时。
- en: We’ve made strong progress in this section. Our code here is certainly more
    efficient than the code we gave in [Listing 9-5](ch09.xhtml#ch09ex05). However,
    it still isn’t efficient enough. If you submit to the judge, you’ll see that it
    doesn’t get much further than we got last time. It still times out on most of
    the test cases.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中我们取得了显著进展。我们的代码无疑比我们在[清单9-5](ch09.xhtml#ch09ex05)中的代码更高效。然而，它仍然不够高效。如果你将其提交给评测系统，你会发现它并没有比上次更进一步。它仍然会在大多数测试用例上超时。
- en: Efficiency of Our Program
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们程序的效率
- en: The problem with our program is that finding the third position can still take
    a long time. Those `while` loops still have some inefficiency. I can demonstrate
    this with a new list of positions, namely, the positions from 1 to 32.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序中的问题是找到第三个位置仍然需要很长时间。这些`while`循环仍然存在一些低效之处。我可以通过一个新的位置列表来演示这一点，即位置从1到32的列表。
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let’s focus on when `i` is `0` and `j` is `7`; these are the positions `1` and
    `8`. For the third position, we’re looking for positions that are greater than
    or equal to 15 and less than or equal to 22\. To find the `15`, the first `while`
    loop scans to the right, one position at a time. It scans the `9`, then the `10`,
    then the `11`, then the `12`, then the `13`, then the `14`, and finally the `15`.
    Then the second `while` loop takes over, doing a similarly large amount of scanning,
    one position at a time, all the way until it finds the `23`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注当`i`为`0`，`j`为`7`时；这分别是位置`1`和位置`8`。对于第三个位置，我们需要寻找大于或等于15且小于或等于22的位置。为了找到`15`，第一个`while`循环从右向左扫描，一次一个位置。它依次扫描`9`，然后是`10`，然后是`11`，然后是`12`，然后是`13`，然后是`14`，最后找到`15`。然后第二个`while`循环接管，进行类似的大量扫描，一次一个位置，一直扫描到找到`23`。
- en: Each `while` loop implements what’s known as a *linear search*. A linear search
    is a technique that searches through a collection one value at a time. It’s a
    lot of work, scanning through all those values! And there are many other values
    of `i` and `j` that lead to a similar amount of work. For example, try tracing
    what happens when `i` is `0` and `j` is `8`, or when `i` is `1` and `j` is `11`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`while`循环实现了我们所说的*线性搜索*。线性搜索是一种逐个查找集合中每个值的技术。这是一项繁重的工作，得逐一扫描所有这些值！而且对于不同的`i`和`j`值，工作量也差不多。例如，试着追踪一下当`i`为`0`，`j`为`8`，或者当`i`为`1`，`j`为`11`时会发生什么。
- en: How can we improve on this? How can we avoid scanning through a huge chunk of
    the list, looking for the appropriate `left` and `right` indices?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改进这个方法呢？如何避免扫描一大段列表，寻找合适的`left`和`right`索引？
- en: Suppose I give you a book with a thousand sorted integers, one integer per line.
    I ask you to find me the first integer that’s greater or equal to 300\. Are you
    going to look through the numbers one by one? Are you going to look at the 1,
    then the 3, then the 4, then the 7? Still a long way to go—will you look at the
    8, then the 12, then the 17? Probably not! It’d be much faster if you just flipped
    to the middle of the book. Maybe you find number 450 there. Since 450 is greater
    than 300, now you know that the number is in the first half of the book. It can’t
    be in the second half, because those numbers are even bigger than 450\. You’ve
    reduced your work by half by checking only one number! You can now repeat this
    process on the first half of the book, flipping halfway between the beginning
    and middle of the book. You might find the number 200 there. Now you know that
    the 300 is on a later page, somewhere in the second quarter of the book. You can
    repeat this process until you find 300—and it won’t take long at all. This technique—repeatedly
    dividing the problem in half—is known as *binary search*. It’s shockingly fast.
    It blows away the linear search technique of searching one by one. Python has
    a binary search function that will put the finishing touches on Cow Baseball.
    That function, though, is inside of something called a *module*; we’ll need to
    discuss them first.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我给你一本有一千个排序整数的书，每行一个整数。我让你找出第一个大于或等于300的整数。你会逐个查看这些数字吗？会先看`1`，然后是`3`，然后是`4`，然后是`7`吗？路还很长——接下来你会看`8`，然后是`12`，然后是`17`？大概不会吧！如果你直接翻到书的中间会快得多。也许你在中间找到了数字`450`。既然`450`大于`300`，你就知道数字在书的前半部分。它不可能在后半部分，因为那里的数字比`450`还要大。你通过检查一个数字就减少了一半的工作量！你现在可以在书的前半部分重复这个过程，从书的开头和中间翻找。你可能在那找到数字`200`。现在你知道`300`在后面的某一页，可能是在书的第二四分之一部分。你可以继续重复这个过程，直到找到`300`——而且这不会花太多时间。这个技巧——反复将问题一分为二——就叫做*二分查找*。它惊人地快速，比逐个查找的线性搜索方法要快得多。Python
    有一个二分查找函数，它将为牛仔棒球项目画上圆满的句号。不过，这个函数在一个叫做*模块*的东西里；我们需要先讨论模块。
- en: Python Modules
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 模块
- en: A *module* is a self-contained collection of Python code. A module generally
    contains several functions that we can call.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*模块*是一个自包含的 Python 代码集合。一个模块通常包含几个我们可以调用的函数。
- en: Python comes with a variety of modules that we can use to add functionality
    to our programs. There are modules for working with random numbers, dates and
    times, statistics, emails, web pages, audio files, and much more. It would take
    a separate book to cover them all! There are even modules that you can download
    should Python not come with the module that you need.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了各种各样的模块，可以用来为我们的程序添加功能。有处理随机数、日期和时间、统计、电子邮件、网页、音频文件等的模块，种类繁多，甚至可以专门写一本书来讲解它们！如果
    Python 中没有你需要的模块，你还可以下载额外的模块。
- en: I’ll focus in this section on one module—the `random` module. We’ll use it to
    learn what we need to know about modules. Then we’ll be all set for the binary
    search module in the next section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我将专注于一个模块——`random`模块。我们将使用它来了解模块的使用方法。然后，我们就能为下一节中的二分查找模块做好准备。
- en: Have you ever wondered how people make computer games where things happen at
    random? Maybe it’s a game where you draw cards, where you roll dice, or where
    enemies spawn unpredictably. The key is the use of random numbers. Python gives
    us access to random-number generation through its `random` module.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过，人们是如何制作那些包含随机事件的计算机游戏的？也许这是一个抽卡的游戏，或者是一个掷骰子的游戏，或者是敌人随机生成的游戏。关键在于使用随机数。Python通过其`random`模块为我们提供了随机数生成的功能。
- en: 'Before we can use what’s in a module, we must *import* it. One way to do this
    is to import the entire module using the `import` keyword, like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用模块中的内容之前，我们必须*导入*它。导入整个模块的一种方法是使用`import`关键字，像这样：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'What’s in there? To find out, you can use `dir(random)`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 里面有什么？要查找，可以使用`dir(random)`：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: One function that’s offered by the `random` module is `randint`. We pass it
    the low and high ends of a range, and Python gives us a random integer in the
    range (including both endpoints).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`random`模块提供的一个函数是`randint`。我们传递给它一个范围的低端和高端，Python会返回该范围内的一个随机整数（包括两个端点）。'
- en: 'We can’t just call it like a regular function, though. If we try, we get an
    error:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能像普通函数那样直接调用它。如果尝试这样做，会出现错误：
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We need to tell Python that the `randint` function is housed in the `random`
    module. To do that, we prefix `randint` with the name of the module and a dot,
    like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉Python，`randint`函数位于`random`模块中。为此，我们需要在`randint`前加上模块名和一个点，像这样：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To get help on the `randint` function, you can type `help(random.randint)`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关`randint`函数的帮助，可以输入`help(random.randint)`：
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another useful function in the `random` module is `choice`. We pass it a sequence,
    and it returns one of its values at random:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`random`模块中另一个有用的函数是`choice`。我们传递给它一个序列，它会随机返回其中的一个值：'
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we frequently use a small number of functions from a module, it can be tedious
    to type the module name and a dot each time. There’s another way to import these
    functions that lets us call them like any other nonmodule function. Here’s how
    we can import only the `randint` function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们经常使用模块中的少量函数，输入模块名和点每次都显得很麻烦。还有另一种导入这些函数的方法，可以让我们像调用任何其他非模块函数一样调用它们。以下是我们只导入`randint`函数的方式：
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can call `randint` without the `random.` in front:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以直接调用`randint`，而不需要加上`random.`：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we need `randint` and `choice`, we can import them both:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要`randint`和`choice`，我们可以同时导入它们：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We won’t do so in this book, but we can create our own modules containing whatever
    functions we like. For example, if we designed a few Python functions related
    to playing a game, we could place them all in a file named *game_functions.py*.
    We could then import that module using `import game_functions` and then access
    the functions within.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们不会这么做，但我们可以创建自己的模块，包含我们喜欢的任何函数。例如，如果我们设计了一些与玩游戏相关的Python函数，我们可以将它们都放在一个名为*game_functions.py*的文件中。然后，我们可以使用`import
    game_functions`导入该模块，并访问其中的函数。
- en: 'The Python programs we’ve written in this book are not designed to be imported
    as modules. The reason is that they all read input as soon as they start running.
    A module shouldn’t do that. Rather, a module should wait for its functions to
    be called before it does anything. The `random` module is an example of a well-behaved
    module: it only starts giving us random things when we ask for them.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们编写的Python程序并不是为了作为模块被导入的。原因是它们在开始运行时就会读取输入，而模块不应该这样做。一个模块应该等待函数被调用之后再执行任何操作。`random`模块是一个表现良好的模块：它只有在我们请求时才开始给我们提供随机内容。
- en: The bisect Module
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bisect模块
- en: 'Now we’re ready to play around with binary search. In [Listing 9-6](ch09.xhtml#ch09ex06),
    we had two `while` loops. They’re slow, so we want to get rid of them. To do that,
    we’re going to replace each one with a call to a binary search function: `bisect_left`
    for the first `while` loop and `bisect_right` for the second.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好进行二分查找的练习了。在[示例 9-6](ch09.xhtml#ch09ex06)中，我们有两个`while`循环。它们比较慢，所以我们想要去掉它们。为此，我们将用一个二分查找函数来替换每个循环：第一个`while`循环用`bisect_left`，第二个用`bisect_right`。
- en: 'Both of these functions are in the `bisect` module. Let’s import them:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都在`bisect`模块中。让我们导入它们：
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let’s first discuss `bisect_left`. We call it by providing a list sorted from
    smallest to largest and a value `x`. It returns to us the index of the leftmost
    value in the list that’s greater than or equal to `x`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论`bisect_left`。我们通过提供一个从小到大排序的列表和一个值`x`来调用它。它返回列表中第一个大于或等于`x`的左侧值的索引。
- en: 'If the value is in the list, we get the index of its leftmost occurrence:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值在列表中，我们会得到它最左侧出现位置的索引：
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the value isn’t in the list, then we get the index of the first value that’s
    greater:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值不在列表中，我们会得到第一个大于该值的索引：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we search for something that’s greater than every value in the list, we
    get the list’s length:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查找的值大于列表中的所有值，我们将得到列表的长度：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s use `bisect_left` on our list of seven positions from “Sorting First”
    earlier in this chapter. We’ll find the index of the leftmost position that’s
    greater than or equal to 16:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本章前面“首先排序”的七个位置的列表上使用`bisect_left`。我们将找到第一个大于或等于16的左侧位置的索引：
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Perfect: that’s exactly what we need to replace the first `while` loop in [Listing
    9-6](ch09.xhtml#ch09ex06).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 完美：这正是我们需要的，用来替换[清单 9-6](ch09.xhtml#ch09ex06)中第一个`while`循环的内容。
- en: 'To replace the second `while` loop, we’ll use `bisect_right` rather than `bisect_left`.
    We call `bisect_right` just as we called `bisect_left` : with a sorted list and
    a value `x`. Rather than returning the index of the leftmost value in the list
    that’s *greater than or equal to* `x`, it returns the index of the leftmost value
    that’s *greater than* `x`.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了替换第二个`while`循环，我们将使用`bisect_right`而不是`bisect_left`。我们像调用`bisect_left`一样调用`bisect_right`：传入一个排序好的列表和一个值`x`。它不会返回列表中左侧第一个大于或等于`x`的值的索引，而是返回第一个大于`x`的值的索引。
- en: 'Let’s compare `bisect_left` and `bisect_right`. For a value that’s in the list,
    `bisect_right` returns an index greater than that returned by `bisect_left`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下`bisect_left`和`bisect_right`。对于在列表中的值，`bisect_right`返回的索引大于`bisect_left`返回的索引：
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For a value that isn’t in the list, `bisect_left` and `bisect_right` return
    the same index:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不在列表中的值，`bisect_left`和`bisect_right`返回相同的索引：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s use `bisect_right` on our list of seven positions from “Sorting First”
    earlier in this chapter. We’ll find the index of the leftmost position that’s
    greater than 21:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本章前面“首先排序”的七个位置的列表上使用`bisect_right`。我们将找到第一个大于21的左侧位置的索引：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There we go: that’s what we can use to replace the second `while` loop in [Listing
    9-6](ch09.xhtml#ch09ex06).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：这正是我们可以用来替换[清单 9-6](ch09.xhtml#ch09ex06)中第二个`while`循环的内容。
- en: The stunning speed of binary search is hard to appreciate using these tiny examples.
    Time to get real. We’ll search one million times for the rightmost value in a
    list of length `1000000`. Don’t look away when you run this code. You might miss
    it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找的惊人速度，通过这些小示例是难以体会的。是时候展示真正的速度了。我们将在长度为`1000000`的列表中，进行一百万次查找，寻找最右侧的值。运行这段代码时不要移开眼睛，你可能错过它。
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On my computer, that takes about a second. You might be wondering what would
    happen if you replaced the binary search with a call to the list `index` method.
    If you try it, you’ll literally wait hours for the code to run. That’s because
    `index`, like the `in` operator, does a linear search through the list. (See “Efficiency
    of Searching a List” in [Chapter 8](ch08.xhtml#ch08) for more on this.) It has
    no guarantee that the list is sorted, so it can’t perform a blazing-fast binary
    search. It has to go through the values one by one, comparing each of them to
    the value we’re searching for. If you have a sorted list and you want to find
    values in it, binary search is unstoppable.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的电脑上，这大约需要一秒钟。你可能会想，如果用列表的`index`方法代替二分查找会发生什么。如果你尝试这样做，你将真的等上好几个小时才等到代码运行完成。这是因为`index`像`in`操作符一样，进行的是线性搜索（有关此更多内容，请参见[第
    8 章](ch08.xhtml#ch08)中的“搜索列表的效率”）。它没有保证列表是排序的，因此无法执行快速的二分查找。它必须逐个比对每个值，找到与我们要查找的值相等的项。如果你有一个排序好的列表，并且想要在其中查找值，二分查找是无法阻挡的。
- en: Solving the Problem
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: We’re ready to solve Cow Baseball using binary search. See [Listing 9-7](ch09.xhtml#ch09ex07)
    for the code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好使用二分查找解决牛棒球问题了。查看[清单 9-7](ch09.xhtml#ch09ex07)以获取代码。
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 9-7: Using binary search*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7：使用二分查找*'
- en: To begin, we import the `bisect_left` and `bisect_right` functions from the
    `bisect` module so that we can call them ❶. The only other difference compared
    to [Listing 9-6](ch09.xhtml#ch09ex06) is that we now use `bisect_left` ❷ and `bisect_right`
    ❸ instead of the `while` loops.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`bisect`模块中导入`bisect_left`和`bisect_right`函数，以便可以调用它们❶。与[清单 9-6](ch09.xhtml#ch09ex06)相比，唯一的不同之处是我们现在使用`bisect_left`❷和`bisect_right`❸，而不再使用`while`循环。
- en: If you submit our code to the judge now, you should pass all test cases within
    the time limit.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在将我们的代码提交给评测系统，你应该能够在时间限制内通过所有测试用例。
- en: The arc that we followed in this section is typical of that required to solve
    hard problems. We might start with a complete-search solution that is correct
    but, alas, is also too slow, not meeting the judge’s time limits. We then make
    improvements, leading us away from complete search and toward a more refined approach.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的思路弧线是解决难题时常见的思路。我们可能从一个正确但效率较低的完全搜索解决方案开始，然而，这个方案也过于慢，无法满足评测系统的时间限制。然后我们进行改进，最终抛弃完全搜索，转向更精细的方法。
- en: '**CONCEPT CHECK**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: 'Suppose we start with [Listing 9-7](ch09.xhtml#ch09ex07) and use `bisect_left`
    in place of `bisect_right`. That is, we take this line:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从[清单 9-7](ch09.xhtml#ch09ex07)开始，并用`bisect_left`替代`bisect_right`。也就是说，我们修改这一行：
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And we change it to the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将其改为以下内容：
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Does the program still produce the correct answers?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 程序仍然能产生正确的答案吗？
- en: A. It always produces the correct answer, just as before.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: A. 它始终产生正确的答案，就像之前一样。
- en: B. It sometimes produces the correct answer; it depends on the test case.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: B. 它有时产生正确答案，具体取决于测试用例。
- en: C. It never produces the correct answer.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: C. 它从不产生正确的答案。
- en: 'Answer: B. There are test cases for which the modified code does produce the
    correct answer. Here’s one:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。有些测试用例中，修改后的代码确实会产生正确的答案。以下是一个例子：
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The correct answer is 0, and that’s what our program produces.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的答案是0，这也是我们程序产生的结果。
- en: 'Be careful, though, because there are other test cases for which the modified
    code produces the wrong answer. Here’s one:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心，因为还有其他一些测试用例，修改后的代码会产生错误的答案。以下是一个反例：
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The correct answer is 1, but our program produces `0`. When `i` is `0` and `j`
    is `1`, the program is supposed to set `left` to `2` and set `right` to `3`. Unfortunately,
    using `bisect_left` causes `right` to be set to `2`, because the position at index
    2 is the leftmost position that’s greater than or equal to `8`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案是1，但我们程序产生了`0`。当`i`是`0`并且`j`是`1`时，程序应该将`left`设置为`2`，并将`right`设置为`3`。不幸的是，使用`bisect_left`会导致`right`被设置为`2`，因为索引2的位置是大于或等于`8`的最左侧位置。
- en: Given this counterexample, you might be surprised to know that there *is* a
    way to use `bisect_left` rather than `bisect_right`. To do it, we need to alter
    what we search for in the call to `bisect_left`. If you’re curious, give it a
    try!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这个反例，你可能会惊讶地发现，其实*是有*一种方法可以使用`bisect_left`而不是`bisect_right`。为了做到这一点，我们需要改变在调用`bisect_left`时要搜索的内容。如果你感兴趣，不妨试试看！
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about complete-search algorithms, algorithms that
    search through all options to find the best one. To determine the lifeguard that
    we should fire, we try firing each lifeguard and choose the best one. To determine
    the minimum cost to fix ski hills, we try all valid ranges and choose the best
    one. To determine the number of relevant triples of cows, we check each triple
    and add the ones that meet the requirements.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了完全搜索算法，这些算法通过遍历所有选项来找到最佳解。为了确定我们应该解雇的救生员，我们尝试解雇每一个救生员并选择最合适的一个。为了确定修复滑雪坡的最低成本，我们尝试所有有效的区间并选择最佳的一个。为了确定相关的牛的三元组数量，我们检查每一个三元组并添加符合要求的三元组。
- en: Sometimes, complete-search algorithms are efficient enough as they are. We solved
    the Lifeguards and Ski Hills problems with unadorned complete-search code. Other
    times, however, we’ll need to make our complete-search algorithm more efficient.
    We did that when solving Cow Baseball by replacing complete-search `while` loops
    by much faster binary searches.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，完全搜索算法本身就足够高效。我们用简单的完全搜索代码解决了救生员和滑雪坡的问题。然而，有时我们需要让完全搜索算法更加高效。我们在解决牛棒球问题时就做到了这一点，通过将完全搜索的`while`循环替换为更快速的二分查找。
- en: How do programmers and computer scientists discuss efficiency? How do you know
    whether an algorithm is going to be efficient enough? And can you avoid implementing
    algorithms that are simply too slow? [Chapter 10](ch10.xhtml#ch10) awaits.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员和计算机科学家如何讨论效率？你怎么知道一个算法是否足够高效？如何避免实现那些太慢的算法？[第 10 章](ch10.xhtml#ch10) 等待着你。
- en: Chapter Exercises
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节练习
- en: Here are some exercises for you to try. For each, use complete search. If your
    solution is not efficient enough, think about how you can make it more efficient
    while still producing the right answer.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些练习供你尝试。对于每个练习，使用完全搜索。如果你的解决方案效率不够高，思考如何在保证正确答案的前提下提高效率。
- en: 'For each exercise, double-check the judge that the problem comes from: some
    are on the DMOJ judge, while others are on the USACO judge.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个练习，务必核实问题来源的判题系统：有些是在 DMOJ 判题系统上，其他则是在 USACO 判题系统上。
- en: USACO 2019 January Bronze Contest problem Shell Game
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2019 年 1 月青铜奖竞赛问题 Shell Game
- en: USACO 2016 US Open Bronze Contest problem Diamond Collector
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2016 年美国公开赛青铜奖竞赛问题 Diamond Collector
- en: DMOJ problem `coci20c1p1`, Patkice
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci20c1p1`，Patkice
- en: DMOJ problem `ccc09j2`, Old Fishin’ Hole
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ccc09j2`，Old Fishin’ Hole
- en: DMOJ problem `ecoo16r1p2`, Spindie
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ecoo16r1p2`，Spindie
- en: DMOJ problem `cco96p2`, SafeBreaker
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `cco96p2`，SafeBreaker
- en: USACO 2019 December Bronze Contest problem Where Am I
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2019 年 12 月青铜奖竞赛问题 Where Am I
- en: USACO 2016 January Bronze Contest problem Angry Cows
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2016 年 1 月青铜奖竞赛问题 Angry Cows
- en: USACO 2016 December Silver Contest problem Counting Haybales
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: USACO 2016 年 12 月银奖竞赛问题 Counting Haybales
- en: DMOJ problem `crci06p3`, Firefly
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `crci06p3`，Firefly
- en: Notes
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Lifeguards is originally from the USACO 2018 January Bronze Contest. Ski Hills
    is originally from the USACO 2014 January Bronze Contest. Cow Baseball is originally
    from the USACO 2013 December Bronze Contest.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Lifeguards 最初来自 USACO 2018 年 1 月的青铜奖竞赛。Ski Hills 最初来自 USACO 2014 年 1 月的青铜奖竞赛。Cow
    Baseball 最初来自 USACO 2013 年 12 月的青铜奖竞赛。
- en: There are other types of algorithms beyond complete search, such as *greedy
    algorithms* and *dynamic-programming algorithms*. If a problem cannot be solved
    by complete search, then it’s worth thinking through whether it can be solved
    using one of these other types.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 除了完全搜索外，还有其他类型的算法，如 *贪心算法* 和 *动态规划算法*。如果一个问题不能通过完全搜索解决，那么值得思考是否可以使用这些其他类型的算法来解决。
- en: If you’re interested in learning more about these and other algorithms topics
    using Python, I recommend *Python Algorithms*, 2nd edition by Magnus Lie Hetland
    (Apress, 2014).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣了解更多使用 Python 进行的算法相关内容，我推荐 Magnus Lie Hetland 编写的《*Python Algorithms*》第二版（Apress，2014）。
- en: 'I’ve also written a book about algorithm design: *Algorithmic Thinking: A Problem-Based
    Introduction* (No Starch Press, 2021). It follows the same problem-based format
    as this book; as a result, its style and pacing will be familiar to you. However,
    it uses the C programming language, not the Python programming language, so to
    make the most of it, you’ll want to learn some C beforehand.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '我还写了一本关于算法设计的书：《*Algorithmic Thinking: A Problem-Based Introduction*》（No Starch
    Press，2021）。它采用与本书相同的问题导向格式，因此它的风格和节奏你应该会很熟悉。然而，它使用的是 C 编程语言，而不是 Python 编程语言，因此为了更好地理解这本书，你可能需要先学习一些
    C 语言。'
- en: In this chapter, we called preexisting Python functions to perform binary searches.
    If we like, we can write our own binary-search code instead of relying on those
    functions. The idea of dividing a list in half until we find the value that we
    want is intuitive, but the code to implement this is surprisingly tricky. Equally
    surprising is the vast range of problems that can be solved using variations of
    binary search. My book mentioned earlier, *Algorithmic Thinking*, contains an
    entire chapter on binary search and what it can do.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们调用了预先存在的 Python 函数来执行二分查找。如果愿意，我们可以编写自己的二分查找代码，而不是依赖这些函数。将列表一分为二，直到找到我们想要的值，这个思路是直观的，但实现这一功能的代码出乎意料地复杂。同样令人惊讶的是，使用二分查找的变种可以解决的广泛问题。我之前提到的书籍《*Algorithmic
    Thinking*》中有一整章专门讲解二分查找及其应用。
