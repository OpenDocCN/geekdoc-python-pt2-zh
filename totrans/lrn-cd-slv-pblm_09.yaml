- en: '9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DESIGNING ALGORITHMS WITH COMPLETE SEARCH
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An *algorithm* is a sequence of steps that solves a problem. For each problem
    in this book, we solved it by writing an algorithm in the form of Python code.
    We’ll focus in this chapter on designing algorithms. When faced with a new problem,
    sometimes it’s hard to know what to do to solve it. What algorithm should we write?
    Fortunately, we don’t need to start from scratch each time. Computer scientists
    and programmers have identified several general types of algorithms, and it’s
    likely that at least one of them can be used to solve our problem.
  prefs: []
  type: TYPE_NORMAL
- en: One type of algorithm is called a *complete search* algorithm; it involves trying
    all candidate solutions and choosing the best one. For example, if the problem
    asks us to find a maximum, we try all solutions and choose the largest; if the
    problem asks us to find a minimum, we try all solutions and choose the smallest.
    Complete-search algorithms are also known as *brute-force* algorithms, but I’ll
    avoid that term. It’s true that the computer is powering its way through, checking
    solution after solution, but there’s nothing brute force about what we’re doing
    as algorithm designers.
  prefs: []
  type: TYPE_NORMAL
- en: We used a complete-search algorithm to solve Village Neighborhood in [Chapter
    5](ch05.xhtml#ch05). We were asked to find the smallest size of the neighborhoods,
    and we did that by looking at each neighborhood and remembering the size of the
    smallest one. In this chapter, we’ll use complete-search algorithms to solve other
    problems. We’ll see that it can take considerable ingenuity to determine what
    exactly to search.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll solve two problems using complete search: determining which lifeguard
    to fire and identifying the minimum cost to meet ski training camp requirements.
    Then we’ll see a third problem, counting triples of cows that meet given observations,
    that requires we go a little further.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #21: Lifeguards'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this problem, we’ll need to determine which lifeguard to fire that leaves
    us with the maximum schedule coverage of a pool. We’ll try separately firing each
    one and observing the results—that’s a complete-search algorithm!
  prefs: []
  type: TYPE_NORMAL
- en: This is USACO 2018 January Bronze Contest problem Lifeguards.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Farmer John has purchased a swimming pool for his cows. The pool is open from
    time 0 to time 1000.
  prefs: []
  type: TYPE_NORMAL
- en: Farmer John hires *n* lifeguards to monitor the pool. Each lifeguard monitors
    the pool for a given interval of time. For example, a lifeguard might start at
    time 2 and end at time 7\. I’ll denote such an interval as 2–7\. The number of
    units of time covered by an interval is the ending time minus the starting time.
    For example, the lifeguard whose time interval is 2–7 covers 7 – 2 = 5 units of
    time. Those time units are from time 2 to 3, 3 to 4, 4 to 5, 5 to 6, and 6 to
    7.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Farmer John only has enough money to pay for *n* – 1 lifeguards,
    not *n* lifeguards, so he must fire one lifeguard.
  prefs: []
  type: TYPE_NORMAL
- en: Determine the maximum number of units of time that can still be covered after
    firing one lifeguard.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Read input from the file named *lifeguards.in*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of lifeguards who were hired. *n* is between
    1 and 100.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, one per lifeguard. Each line gives the time when the lifeguard starts,
    a space, and the time when the lifeguard ends. The start and end times are all
    integers between 0 and 1,000 and are all distinct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write output to the file named *lifeguards.out*.
  prefs: []
  type: TYPE_NORMAL
- en: Output the maximum number of units of time that can be covered by *n* – 1 of
    the lifeguards.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving each test case is four seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s explore a test case to help justify why a complete-search algorithm makes
    sense for this problem. Here’s the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: 5 8
  prefs: []
  type: TYPE_NORMAL
- en: 10 15
  prefs: []
  type: TYPE_NORMAL
- en: 17 25
  prefs: []
  type: TYPE_NORMAL
- en: 9 20
  prefs: []
  type: TYPE_NORMAL
- en: One simple rule you might try to use to solve this problem is to fire the lifeguard
    with the shortest time interval. That makes some intuitive sense, because it seems
    as though that lifeguard contributes the least to covering the pool.
  prefs: []
  type: TYPE_NORMAL
- en: Does this rule give us a correct algorithm? Let’s see. It tells us to fire the
    5–8 lifeguard, since that lifeguard has the shortest time interval. That leaves
    us with the three lifeguards whose time intervals are 10–15, 17–25, and 9–20\.
    These three remaining lifeguards cover exactly the interval 9–25, which consists
    of 25 – 9 = 16 units of time. Is 16 the correct answer?
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, no. It turns out that what we should have done is fire the 10–15
    lifeguard. If we do that, then we’re left with the three lifeguards whose time
    intervals are 5–8, 17–25, and 9–20\. These three remaining lifeguards cover the
    intervals 5–8 and 9–25\. (Careful: they don’t cover the unit of time from 8 to
    9.) The first of these intervals covers 8 – 5 = 3 units of time, and the second
    covers 25 – 9 = 16 units of time, for a total of 19 units of time.'
  prefs: []
  type: TYPE_NORMAL
- en: The correct answer is 19, not 16\. Firing the lifeguard with the shortest time
    interval didn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not easy to come up with a simple rule that always works to solve this
    problem. We don’t need to worry, though: with a complete-search algorithm, we
    dodge this requirement entirely.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what our complete-search algorithm will do to solve our test case:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it will ignore the first lifeguard and determine the number of units
    of time that the three remaining lifeguards cover. It will obtain an answer of
    16\. It will remember 16 as the score to beat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it will ignore the second lifeguard and determine the number of units
    of time that the three remaining lifeguards cover. It will obtain an answer of
    19\. Since 19 is greater than 16, it will remember 19 as the score to beat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it will ignore the third lifeguard and determine the number of units of
    time that the three remaining lifeguards cover. It will obtain an answer of 14\.
    The score to beat is still 19.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it will ignore the fourth lifeguard and determine the number of units
    of time that the three remaining lifeguards cover. It will obtain an answer of
    16\. The score to beat is still 19.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having considered the ramifications of firing each lifeguard, the algorithm
    concludes that 19 is the correct answer. There can be no better answer than this,
    because we tried every option! We performed a complete search of the possible
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use complete search, it’s often helpful to begin by writing a function that
    solves the problem for a particular candidate solution. We can then call that
    function many times, once for each candidate solution.
  prefs: []
  type: TYPE_NORMAL
- en: Firing One Lifeguard
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s write a function to determine the number of time units that are covered
    when one particular lifeguard is fired. [Listing 9-1](ch09.xhtml#ch09ex01) shows
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'def num_covered(intervals, fired):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: intervals is a list of lifeguard intervals;
  prefs: []
  type: TYPE_NORMAL
- en: each interval is a [start, end] list.
  prefs: []
  type: TYPE_NORMAL
- en: fired is the index of the lifeguard to fire.
  prefs: []
  type: TYPE_NORMAL
- en: Return the number of time units covered by all lifeguards
  prefs: []
  type: TYPE_NORMAL
- en: except the one fired.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ covered = set()
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(len(intervals)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if i != fired:'
  prefs: []
  type: TYPE_NORMAL
- en: interval = intervals[i]
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for j in range(interval[0], interval[1]):'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ covered.add(j)
  prefs: []
  type: TYPE_NORMAL
- en: return len(covered)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-1: Solving when one particular lifeguard is fired*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter is a list of lifeguard time intervals; the second is the
    index of the lifeguard to fire. Enter the code into the Python shell. Here are
    two sample calls of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 0)'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> num_covered([[5, 8], [10, 15], [9, 20], [17, 25]], 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '19'
  prefs: []
  type: TYPE_NORMAL
- en: These calls confirm that we can cover 16 units of time if we fire lifeguard
    0 and can cover 19 units of time if we fire lifeguard 1.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s understand how the function operates. We begin by creating a set that
    will hold the units of time that are covered ❶. Whenever a unit of time is covered,
    the code will add the start of that unit of time to the set. For example, if the
    unit of time from 0 to 1 is covered, then the code will add 0 to the set; if the
    unit of time from 4 to 5 is covered, it will add 4 to the set.
  prefs: []
  type: TYPE_NORMAL
- en: We loop through the lifeguard time intervals. If a lifeguard isn’t fired, then
    we loop through this lifeguard’s time interval ❷ to consider each unit of covered
    time. We add each of these time units to the set ❸, as promised. Recall that sets
    don’t retain duplicate values; we don’t have to worry if we try to add the same
    unit of time multiple times. We’ve gone through all of the nonfired lifeguards
    and added to the set all units of time that are covered. We therefore simply return
    the number of values in the set.
  prefs: []
  type: TYPE_NORMAL
- en: The Main Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The main part of our program is in [Listing 9-2](ch09.xhtml#ch09ex02). It uses
    the num_covered function to determine the number of units of time that are covered
    when separately firing each lifeguard. Be sure to enter our num_covered function
    ([Listing 9-1](ch09.xhtml#ch09ex01)) before this code for a complete solution
    to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: input_file = open('lifeguards.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('lifeguards.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input_file.readline())
  prefs: []
  type: TYPE_NORMAL
- en: intervals = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ interval = input_file.readline().split()
  prefs: []
  type: TYPE_NORMAL
- en: interval[0] = int(interval[0])
  prefs: []
  type: TYPE_NORMAL
- en: interval[1] = int(interval[1])
  prefs: []
  type: TYPE_NORMAL
- en: intervals.append(interval)
  prefs: []
  type: TYPE_NORMAL
- en: max_covered = 0
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for fired in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ result = num_covered(intervals, fired)
  prefs: []
  type: TYPE_NORMAL
- en: 'if result > max_covered:'
  prefs: []
  type: TYPE_NORMAL
- en: max_covered = result
  prefs: []
  type: TYPE_NORMAL
- en: output_file.write(str(max_covered) + '\n')
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-2: Main program*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re working with files here, not standard input and standard output.
  prefs: []
  type: TYPE_NORMAL
- en: The program begins by reading the number of lifeguards and then uses a range
    for loop to read each lifeguard’s time interval. We read each time interval from
    the input ❶, convert each of its components to an integer, and append it as a
    two-value list to our list of intervals.
  prefs: []
  type: TYPE_NORMAL
- en: We use the max_covered variable to track the maximum number of time units that
    can be covered.
  prefs: []
  type: TYPE_NORMAL
- en: Now we separately fire each lifeguard using a range for loop ❷. We call num_covered
    ❸ to determine the number of time units that are covered given the firing of one
    lifeguard. We update max_covered whenever we’re able to cover a greater number
    of time units.
  prefs: []
  type: TYPE_NORMAL
- en: When that loop completes, we’ll have checked the number of units of time that
    can be covered by firing each lifeguard, and we’ll have remembered the maximum.
    We output this maximum to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to submit our code to the USACO judge. For Python code, this judge
    uses a time limit per test case of four seconds, but our solution shouldn’t come
    close to that limit. For example, I just ran the code here, and each test case
    finished in no more than 130 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency of Our Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The reason our code is so fast is because there are so few lifeguards—only at
    most 100 of them. If there were a large number of lifeguards, then our code would
    no longer solve the problem within the time limit. We’d be fine if there were
    a few hundred lifeguards. We might squeak through if we had as many as 3,000 or
    4,000 lifeguards. Any more than that, though, and our code would be too slow.
    We probably couldn’t make it in time with 5,000 lifeguards, for example. We’d
    need to design a new algorithm, likely one that uses something faster than complete
    search.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that 5,000 is a huge number of lifeguards and that it’s okay
    that our algorithm can’t go that high. But it’s not! Think back to the Email Addresses
    problem in [Chapter 8](ch08.xhtml#ch08). There, we had to contend with up to 100,000
    email addresses. And think back to the Cities and States problem in the same chapter.
    There, we had to contend with up to 200,000 cities. By comparison, 5,000 is not
    a lot of lifeguards.
  prefs: []
  type: TYPE_NORMAL
- en: A complete-search solution often works fine for a small amount of input. Large
    test cases are often where complete-search solutions break down.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that our complete-search solution for Lifeguards doesn’t work well
    with large test cases is because it does a lot of repeated work. Imagine that
    we’re solving a test case with 5,000 lifeguards. We’ll fire lifeguard 0 and call
    num_covered to determine the number of units of time covered by the remaining
    lifeguards. Then, we’ll fire lifeguard 1 and call num_covered again. Now, what
    num_covered does this time is similar to what it did on the previous call. After
    all, things haven’t changed much. The only change is that lifeguard 0 is back
    and lifeguard 1 is fired. The other 4,998 lifeguards are the same as they were!
    But num_covered doesn’t know that. It grinds through all of the lifeguards again.
    That same thing happens when we fire lifeguard 2, then lifeguard 3, and so on.
    Each time, num_covered does all of its work from scratch, without learning anything
    about what it did previously.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, while useful, complete-search algorithms do have limitations.
    Given a new problem that we want to solve, a complete-search algorithm is a useful
    starting point, even if it ultimately turns out to be too inefficient. That’s
    because the act of designing that algorithm may deepen our appreciation of the
    problem and lead to new ideas for solving it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll see another problem where we’ll be able to use complete
    search.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: Is the following version of num_covered correct?
  prefs: []
  type: TYPE_NORMAL
- en: 'def num_covered(intervals, fired):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: intervals is a list of lifeguard intervals;
  prefs: []
  type: TYPE_NORMAL
- en: each interval is a [start, end] list.
  prefs: []
  type: TYPE_NORMAL
- en: fired is the index of the lifeguard to fire.
  prefs: []
  type: TYPE_NORMAL
- en: Return the number of time units covered by all lifeguards
  prefs: []
  type: TYPE_NORMAL
- en: except the one fired.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: covered = set()
  prefs: []
  type: TYPE_NORMAL
- en: intervals.pop(fired)
  prefs: []
  type: TYPE_NORMAL
- en: 'for interval in intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(interval[0], interval[1]):'
  prefs: []
  type: TYPE_NORMAL
- en: covered.add(j)
  prefs: []
  type: TYPE_NORMAL
- en: return len(covered)
  prefs: []
  type: TYPE_NORMAL
- en: A. Yes
  prefs: []
  type: TYPE_NORMAL
- en: B. No
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. This function removes the fired lifeguard from the list of lifeguards.
    That’s not allowed, because the docstring doesn’t say anything about the function
    modifying the list. With this version of the function, our program will fail many
    test cases because lifeguard information is lost over time. For example, when
    we test firing lifeguard 0, lifeguard 0 is removed from the list. When we later
    test firing lifeguard 1, lifeguard 0 is unfortunately still gone! If you want
    to use a version of the function where the fired lifeguard is removed from the
    list, you need to work with a copy of the list rather than the original.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #22: Ski Hills'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, the problem description makes it clear what we should search through
    in a complete-search solution. For example, in Lifeguards, we were asked to fire
    one lifeguard, so it made sense to try firing each one. Other times, we’ll have
    to be more creative to determine what to search through. As you read this next
    problem, think about what you would search in a complete-search solution.
  prefs: []
  type: TYPE_NORMAL
- en: This is USACO 2014 January Bronze Contest problem Ski Course Design.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Farmer John has *n* hills on his farm, each with a height between 0 and 100\.
    He would like to register his farm as a ski training camp.
  prefs: []
  type: TYPE_NORMAL
- en: A farm can be registered as a ski training camp only if the difference in height
    between the highest and lowest hills is 17 or less. Farmer John may therefore
    need to increase the heights of some of his hills and decrease the heights of
    others. He is able to change the heights only by integer amounts.
  prefs: []
  type: TYPE_NORMAL
- en: The cost of changing a hill’s height by *x* units is *x*². For example, changing
    a hill from height 1 to height 4 costs (4 – 1)² = 9.
  prefs: []
  type: TYPE_NORMAL
- en: Determine the minimum amount that Farmer John will need to pay to change the
    heights of hills so that he can register his farm as a ski training camp.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Read input from the file named *skidesign.in*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing integer *n*, the number of hills on the farm. *n* is between
    1 and 1,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, each of which gives the height of a hill. Each height is an integer
    between 0 and 100.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write output to the file named *skidesign.out*.
  prefs: []
  type: TYPE_NORMAL
- en: Output the minimum amount that Farmer John will need to pay to change the heights
    of hills.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving each test case is four seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Test Case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s see if we can apply what we learned from Lifeguards to this problem. To
    solve Lifeguards, we separately fired each lifeguard to figure out the lifeguard
    that we should fire. To solve Ski Hills, perhaps there’s something analogous that
    we can do with each hill? For example, perhaps we can use each hill’s height as
    the low end in an allowed height range?
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll give this a try using the following test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: The smallest height of these four hills is 2, and the biggest height is 40\.
    The difference between 40 and 2 is 38, greater than 17\. Farmer John is going
    to have to pay to fix these hills!
  prefs: []
  type: TYPE_NORMAL
- en: The first hill is height 23\. If we use 23 as the low end of the range, then
    the high end is 23 + 17 = 40\. We need to calculate the cost to bring all hills
    into the range 23–40\. There are two hills that are out of this range, the ones
    of heights 16 and 2\. Bringing them up to height 23 costs (23 – 16)² + (23 – 2)²
    = 490\. A cost of 490 is the cost to beat.
  prefs: []
  type: TYPE_NORMAL
- en: The second hill is height 40\. The high end of this range is 40 + 17 = 57, so
    we’re looking to get all hills into the range 40–57\. The other three hills are
    out of this range, so each of them contributes to the total cost. That total is
    (40 – 23)² + (40 – 16)² + (40 – 2)² = 2,309\. This is greater than 490, our current
    minimum cost, so 490 is still the cost to beat. (Remember that in this problem
    we’re trying to *minimize* Farmer John’s cost, whereas in Lifeguards we were trying
    to *maximize* coverage.)
  prefs: []
  type: TYPE_NORMAL
- en: The third hill is height 16, which gives us the range 16–33\. There are two
    hills that are out of this range, the ones of heights 40 and 2\. The total cost
    for this range is therefore (40 – 33)² + (16 – 2)² = 245\. The new cost to beat
    is 245!
  prefs: []
  type: TYPE_NORMAL
- en: The fourth hill is height 2, which gives us the range 2–19\. If you calculate
    the cost for this range, you should obtain a cost of 457.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum cost we obtained using that algorithm is 245\. Is 245 the answer?
    Are we done?
  prefs: []
  type: TYPE_NORMAL
- en: 'No and no! It turns out that the minimum cost is 221\. There are two ranges
    that give us this minimum cost: 12–29 and 13–30\. There is no hill whose height
    is 12\. Similarly, there is no hill whose height is 13\. We therefore can’t use
    hill heights as the possible low ends of ranges.'
  prefs: []
  type: TYPE_NORMAL
- en: Think about what a correct complete-search algorithm could look like, one that’s
    guaranteed not to miss any ranges.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a plan that’s guaranteed to get us the correct answer. We start by calculating
    the cost for range 0–17\. Then we calculate the cost for range 1–18\. Then 2–19\.
    Then 3–20\. Then 4–21, and so on. We test every possible range, one by one, and
    remember the minimum cost that we obtain. The ranges we test have nothing to do
    with the heights of the hills. Since we’re testing every possible range, there’s
    no way we’ll miss finding the best one.
  prefs: []
  type: TYPE_NORMAL
- en: Which ranges should we test? How high should we go? Should we test the range
    50–67? Yes. How about the range 71–88? Yes again. How about 115–132? No! Not that
    one.
  prefs: []
  type: TYPE_NORMAL
- en: The final range that we’ll check is 100–117\. The reason has to do with the
    guarantee from the problem description that the height of any hill is at most
    100.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we figure out the cost for range 101–118\. Without even knowing the
    heights of the hills, we know for sure that none of the hills is in this range.
    The maximum height of a hill, after all, is 100, and our range starts at 101\.
    Now slide our range from 101–118 down to 100–117\. This 100–117 range costs less
    than the 101–118 range! That’s because 100 is closer to the hills than 101 is.
    For example, consider a hill of height 80\. This hill would cost us 21² = 441
    to raise it to height 101, but only 20² = 400 to raise it to height 100\. This
    shows that 101–118 cannot be the best range to use. There’s no point trying it.
  prefs: []
  type: TYPE_NORMAL
- en: Similar logic explains why it’s pointless to try any higher range such as 102–119,
    103–120, and so on. We can always slide these ranges down to make them cost less.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, we are going to test exactly 101 ranges: 0–17, 1–18, 2–19, and
    so on, all the way up to 100–117\. We’ll remember the cost of the best one. Let’s
    do this!'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll take the solution in two steps, just as we did when solving Lifeguards.
    We’ll start with a function to determine the cost of a single range. Then we’ll
    write a main program to call this function once for each range.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the Cost of One Range
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 9-3](ch09.xhtml#ch09ex03) gives the code for the function that determines
    the cost of a given range.'
  prefs: []
  type: TYPE_NORMAL
- en: MAX_DIFFERENCE = 17
  prefs: []
  type: TYPE_NORMAL
- en: MAX_HEIGHT = 100
  prefs: []
  type: TYPE_NORMAL
- en: 'def cost_for_range(heights, low, high):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: heights is a list of hill heights.
  prefs: []
  type: TYPE_NORMAL
- en: low is an integer giving the low end of the range.
  prefs: []
  type: TYPE_NORMAL
- en: high is an integer giving the high end of a range.
  prefs: []
  type: TYPE_NORMAL
- en: Return the cost of changing all heights of hills to be
  prefs: []
  type: TYPE_NORMAL
- en: between low and high.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: cost = 0
  prefs: []
  type: TYPE_NORMAL
- en: '❶ for height in heights:'
  prefs: []
  type: TYPE_NORMAL
- en: '❷ if height < low:'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ cost = cost + (low - height) ** 2
  prefs: []
  type: TYPE_NORMAL
- en: '❹ elif height > high:'
  prefs: []
  type: TYPE_NORMAL
- en: ❺ cost = cost + (height - high) ** 2
  prefs: []
  type: TYPE_NORMAL
- en: return cost
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-3: Solving for one particular range*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included two constants that we’ll use later. The MAX_DIFFERENCE constant
    records the maximum difference allowed between the heights of the highest and
    lowest hills. The MAX_HEIGHT constant records the maximum height of a hill.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s turn to the cost_for_range function. It takes a list of hill heights
    and a desired range specified by its low end and high end. It returns the cost
    of changing hill heights so that all hills are in the desired range. I encourage
    you to enter the code for the function into the Python shell so that you can try
    it before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: The function loops through the height of each hill ❶, adding up the cost to
    bring that hill into the desired range. There are two cases we need to account
    for. First, the height of the current hill might be out of range by being less
    than low ❷. The expression low - height gives us the amount of height that we
    need to add to this hill, and we square that result to get the cost ❸. Second,
    the height of the current hill might be out of range by being greater than high
    ❹. The expression height - high gives us the amount of height that we need to
    subtract from this hill, and we square that result to get the cost ❺. Notice that
    we don’t do anything if the height is already in the low-high range. Once we’ve
    gone through all of the heights, we return the total cost.
  prefs: []
  type: TYPE_NORMAL
- en: The Main Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The main part of our program is in [Listing 9-4](ch09.xhtml#ch09ex04). It uses
    the cost_for_range function to determine the cost for each range. Be sure to enter
    our cost_for_range function ([Listing 9-3](ch09.xhtml#ch09ex03)) before this code
    for a complete solution to the problem.
  prefs: []
  type: TYPE_NORMAL
- en: input_file = open('skidesign.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('skidesign.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input_file.readline())
  prefs: []
  type: TYPE_NORMAL
- en: heights = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: heights.append(int(input_file.readline()))
  prefs: []
  type: TYPE_NORMAL
- en: ❶ min_cost = cost_for_range(heights, 0, MAX_DIFFERENCE)
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for low in range(1, MAX_HEIGHT + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: result = cost_for_range(heights, low, low + MAX_DIFFERENCE)
  prefs: []
  type: TYPE_NORMAL
- en: 'if result < min_cost:'
  prefs: []
  type: TYPE_NORMAL
- en: min_cost = result
  prefs: []
  type: TYPE_NORMAL
- en: output_file.write(str(min_cost) + '\n')
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-4: Main program*'
  prefs: []
  type: TYPE_NORMAL
- en: We start by reading the number of hills and then read each height into the heights
    list.
  prefs: []
  type: TYPE_NORMAL
- en: We use the min_cost variable to remember the minimum cost that we’ve discovered
    so far. We set min_cost to the cost for range 0–17 ❶. Then, in a range for loop
    ❷, we try every other range cost, updating min_cost every time we find a smaller
    cost. When we’re done with this loop, we output the minimum cost that we found.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to submit our code to the judge. Our complete-search solution should
    solve the problem well under the time limit.
  prefs: []
  type: TYPE_NORMAL
- en: In the next problem, we’ll see an example where a straight complete-search solution
    is not efficient enough.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a proposed change to the code in [Listing 9-4](ch09.xhtml#ch09ex04).
    Take this line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for low in range(1, MAX_HEIGHT + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'And change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for low in range(1, MAX_HEIGHT - MAX_DIFFERENCE + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: Is the code still correct?
  prefs: []
  type: TYPE_NORMAL
- en: A. Yes
  prefs: []
  type: TYPE_NORMAL
- en: B. No
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. The last range that the code now checks is 83–100, so we have to
    argue that the ranges we no longer check—84–101, 85–102, and so on—don’t matter.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the range 84–101\. If we can argue that the range 83–100 is at least
    as good as 84–101, then we would have no reason to check range 84–101.
  prefs: []
  type: TYPE_NORMAL
- en: 'The range 84–101 includes height 101\. But that’s pointless: the highest hill
    has height 100, so height 101 may as well not even be there. We can remove 101
    without making the range worse. If we remove it, we’re left with the range 84–100\.
    Aha—but 100–84 is only 16, and we’re allowed to have a difference of 17\. So we
    can extend the range by one on the left, giving us a range of 83–100\. Surely,
    making the range bigger like this can’t make the range any worse. It might even
    make the range better, since it’s now one unit closer to any hill whose height
    is 83 or less.'
  prefs: []
  type: TYPE_NORMAL
- en: We started with range 84–101 and showed that range 83–100 is at least as good.
    We can make this same argument for range 85–102, 86–103, and so on. There’s no
    point going any higher than 83–100!
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you might like to try solving exercises 1 and 2 from “Chapter
    Exercises” on [page 263](ch09.xhtml#ch09lev1sec14).
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #23: Cow Baseball'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To end this chapter, I’ve chosen a problem where we’ll need to bump up our algorithm
    design skills beyond complete search. As you read the problem, notice that there’s
    not all that much input. That generally signals the effectiveness of a complete-search
    algorithm. But not this time, because of the amount of searching that such an
    algorithm has to do through this input. The difficulty boils down to having too
    many nested loops. Why do the nested loops bite us here? What can we do about
    it? Read on!
  prefs: []
  type: TYPE_NORMAL
- en: This is USACO 2013 December Bronze Contest problem Cow Baseball.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Farmer John has *n* cows. They are standing in a row, each at a distinct integer
    position. They are having fun throwing a baseball around.
  prefs: []
  type: TYPE_NORMAL
- en: Farmer John is watching the antics. He observes that cow *x* throws the ball
    to some cow *y* to its right, and then that cow *y* throws the ball to some cow
    *z* to its right. He also knows that the distance of the second throw is at least
    the distance of the first throw and at most twice the distance of the first throw.
    (For example, if the first throw is distance 5, then the second throw is at least
    distance 5 and at most distance 10.)
  prefs: []
  type: TYPE_NORMAL
- en: Determine the number of (*x*, *y*, *z*) triples of cows that satisfy Farmer
    John’s observations.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Read input from the file named *baseball.in*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing *n*, the number of cows. *n* is between 3 and 1,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, each of which gives the position of a cow. All positions are unique,
    and each is between 1 and 100,000,000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write output to the file named *baseball.out*.
  prefs: []
  type: TYPE_NORMAL
- en: Output the number of triples of cows that satisfy Farmer John’s observations.
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving each test case is four seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Using Three Nested Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use three nested loops to consider all possible triples. We’ll start
    by looking at the code and then discuss its efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In “Nesting” in [Chapter 3](ch03.xhtml#ch03), we learned that we can loop through
    all pairs of values using two nested loops. Doing so looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst = [1, 9]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for num1 in lst:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     for num2 in lst:'
  prefs: []
  type: TYPE_NORMAL
- en: '...         print(num1, num2)'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 1 1
  prefs: []
  type: TYPE_NORMAL
- en: 1 9
  prefs: []
  type: TYPE_NORMAL
- en: 9 1
  prefs: []
  type: TYPE_NORMAL
- en: 9 9
  prefs: []
  type: TYPE_NORMAL
- en: 'We can similarly loop through all triples of values using three nested loops,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for num1 in lst:'
  prefs: []
  type: TYPE_NORMAL
- en: '...     for num2 in lst:'
  prefs: []
  type: TYPE_NORMAL
- en: '...         for num3 in lst:'
  prefs: []
  type: TYPE_NORMAL
- en: '...             print(num1, num2, num3)'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 1 1 1
  prefs: []
  type: TYPE_NORMAL
- en: 1 1 9
  prefs: []
  type: TYPE_NORMAL
- en: 1 9 1
  prefs: []
  type: TYPE_NORMAL
- en: 1 9 9
  prefs: []
  type: TYPE_NORMAL
- en: 9 1 1
  prefs: []
  type: TYPE_NORMAL
- en: 9 1 9
  prefs: []
  type: TYPE_NORMAL
- en: 9 9 1
  prefs: []
  type: TYPE_NORMAL
- en: 9 9 9
  prefs: []
  type: TYPE_NORMAL
- en: Using three nested loops like this gives us a starting point for solving the
    Cow Baseball problem. For each triple, we can check whether it matches Farmer
    John’s observations. See [Listing 9-5](ch09.xhtml#ch09ex05) for the code.
  prefs: []
  type: TYPE_NORMAL
- en: input_file = open('baseball.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('baseball.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input_file.readline())
  prefs: []
  type: TYPE_NORMAL
- en: positions = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ positions.append(int(input_file.readline()))
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for position1 in positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '❸ for position2 in positions:'
  prefs: []
  type: TYPE_NORMAL
- en: first_two_diff = position2 - position1
  prefs: []
  type: TYPE_NORMAL
- en: '❹ if first_two_diff > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: low = position2 + first_two_diff
  prefs: []
  type: TYPE_NORMAL
- en: high = position2 + first_two_diff * 2
  prefs: []
  type: TYPE_NORMAL
- en: '❺ for position3 in positions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if position3 >= low and position3 <= high:'
  prefs: []
  type: TYPE_NORMAL
- en: total = total + 1
  prefs: []
  type: TYPE_NORMAL
- en: output_file.write(str(total) + '\n')
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-5: Using three nested* for *loops*'
  prefs: []
  type: TYPE_NORMAL
- en: We read all of the cow positions into the positions list ❶. We then loop over
    all positions in the list using a for loop ❷. For each of these positions, we
    loop through all positions in the list using a nested for loop ❸. At this point,
    position1 and position2 refer to two positions from the list. We need a third
    nested loop, yes, but not yet. We first need to calculate the difference between
    position1 and position2 because that tells us the range of position3s that we’ll
    be looking for.
  prefs: []
  type: TYPE_NORMAL
- en: We require from the problem description that position2 be on the right of position1.
    If it is ❹, then we calculate the low end and high end of the range for position3
    and store them using low and high, respectively. For example, if position1 is
    1 and position2 is 6, then we’ll calculate 6 + 5 = 11 for low and 6 + 5 * 2 =
    16 for high. Then we loop through the list with a third nested for loop ❺, looking
    for positions that are between low and high. For each such position3, we increase
    our total by 1.
  prefs: []
  type: TYPE_NORMAL
- en: Following the three nested loops, we have calculated the total number of triples.
    We finish up by outputting that number to the output file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try our program on a small test case to make sure nothing weird is happening.
    Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs: []
  type: TYPE_NORMAL
- en: '23'
  prefs: []
  type: TYPE_NORMAL
- en: '18'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct answer for this test case is 11\. The 11 satisfying triples are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 14, 16, 18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14, 18, 23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1, 6, 16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1, 6, 14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1, 6, 11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1, 11, 23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6, 14, 23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6, 11, 16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6, 11, 18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11, 16, 23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11, 14, 18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Good news: our program outputs 11 for this test case! It does so because it
    eventually finds each satisfying triple. For example, at some point, position1
    will be 14, position2 will be 16, and position3 will be 18. That triple satisfies
    the distance requirements, so our program will count it in our total. Don’t be
    worried about what will happen, later, when position1 is 18, position2 is 16,
    and position3 is 14. We definitely don’t want to count that one, because these
    throws are not going to the right. We’re fine, though: the if statement ❹ prevents
    these triples from being processed.'
  prefs: []
  type: TYPE_NORMAL
- en: Our program is correct. But as you’ll see if you submit it to the judge, it
    is not efficient enough. For this problem, and many competitive programming problems,
    the first few test cases are small—just a few cows, a few lifeguards, or a few
    ski hills. Our program should be able to solve those in time. The remaining test
    cases test our program closer and closer to the limit of acceptable input. Our
    program does not solve those in time. It’s too slow.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency of Our Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To understand why our program is so slow, it helps to think about the number
    of triples that it must go through. Think back to the test case we just studied,
    which had seven cows. How many triples will our program check? Well, for the first
    cow, there are seven choices: 16, 14, 23, and so on. There are also seven choices
    for the second cow, and seven choices for the third cow. Multiplying these together,
    we see that our program checks 7 * 7 * 7 = 343 triples.'
  prefs: []
  type: TYPE_NORMAL
- en: What if we had eight cows instead of seven? Then our program would check 8 *
    8 * 8 = 512 triples.
  prefs: []
  type: TYPE_NORMAL
- en: We can give an expression for the number of triples that works for any number
    of cows. Let’s use *n* for the number of cows; it could be 7, 8, 50, 1,000, and
    so on, depending on the test case. Then we can say that the number of triples
    our program checks is *n* * *n* * *n*, or *n*³.
  prefs: []
  type: TYPE_NORMAL
- en: We can substitute any number of cows for *n* to determine the number of triples
    that we check. For example, we can verify that the number of triples for seven
    cows is 7³ = 343 and that the number of triples for eight cows is 8³ = 512\. These
    numbers—343 and 512—are tiny. It would take any computer no more than a few milliseconds
    to check those many triples. As a conservative guide, you can think of a Python
    program as being able to check or do about 5,000,000 things per second. The time
    limit for this problem is four seconds per test case, so we’ll be able to check
    about 20,000,000 triples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s substitute larger numbers for *n* and see what happens. For 50 cows,
    we have 50³ = 125,000 triples. No big deal: checking 125,000 things is easy for
    today’s computers. For 100 cows, we have 100³ = 1,000,000 triples. Again, no problem.
    We can check a million things in less than a second. For 200 cows, we have 200³
    = 8,000,000 triples. We’re still OK for four seconds, but I hope you’re starting
    to get a little worried. The number of triples is shooting up pretty quickly here,
    and we’re only at 200 cows. Remember that we need to be able to support up to
    1,000 cows.'
  prefs: []
  type: TYPE_NORMAL
- en: For 400 cows, we have 400³ = 64,000,000 triples. That’s too many for us to process
    in four seconds. To add insult to injury, let’s try 1,000 cows, the maximum we’ll
    ever get. For 1,000 cows, we have 1,000³ = 1,000,000,000 triples. That’s one billion.
    Nope. There’s no way we’re ever going to be able to check that many triples in
    four seconds. We’ll need to make our program more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting First
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sorting is helpful here. Let’s look at how to use sorting and then discuss the
    efficiency of our resulting solution.
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our cow positions can come in any order—there’s certainly no guarantee from
    the problem description that they’re sorted. Unfortunately, this leads our program
    to check many triples that have no chance of satisfying the requirements. For
    example, checking the triple 18, 16, 14 is pointless, because the numbers aren’t
    in increasing order. If we sorted the cow positions at the outset, then we could
    avoid ever checking these out-of-order triples.
  prefs: []
  type: TYPE_NORMAL
- en: There’s another benefit to sorting. Suppose that position1 refers to some cow
    position and position2 refers to another. For this pair of positions, we know
    the smallest value of position3 and largest value of position3 that we care about.
    We can use the fact that the positions are sorted to cut down on the number of
    values that we need to check for this range. Before continuing, think about why
    this is the case. How can we use the fact that the positions are sorted to look
    at fewer values?
  prefs: []
  type: TYPE_NORMAL
- en: When you’re ready, see [Listing 9-6](ch09.xhtml#ch09ex06) for our code that
    uses sorting.
  prefs: []
  type: TYPE_NORMAL
- en: input_file = open('baseball.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('baseball.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input_file.readline())
  prefs: []
  type: TYPE_NORMAL
- en: positions = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: positions.append(int(input_file.readline()))
  prefs: []
  type: TYPE_NORMAL
- en: ❶ positions.sort()
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: '❸ for j in range(i + 1, n):'
  prefs: []
  type: TYPE_NORMAL
- en: first_two_diff = positions[j] - positions[i]
  prefs: []
  type: TYPE_NORMAL
- en: low = positions[j] + first_two_diff
  prefs: []
  type: TYPE_NORMAL
- en: high = positions[j] + first_two_diff * 2
  prefs: []
  type: TYPE_NORMAL
- en: left = j + 1
  prefs: []
  type: TYPE_NORMAL
- en: '❹ while left < n and positions[left] < low:'
  prefs: []
  type: TYPE_NORMAL
- en: left = left + 1
  prefs: []
  type: TYPE_NORMAL
- en: right = left
  prefs: []
  type: TYPE_NORMAL
- en: '❺ while right < n and positions[right] <= high:'
  prefs: []
  type: TYPE_NORMAL
- en: right = right + 1
  prefs: []
  type: TYPE_NORMAL
- en: ❻ total = total + right - left
  prefs: []
  type: TYPE_NORMAL
- en: output_file.write(str(total) + '\n')
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-6: Using sorting*'
  prefs: []
  type: TYPE_NORMAL
- en: Before we start looking for triples, we sort the positions ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Our first loop goes through all positions using the loop variable i ❷. It’s
    a range for loop this time, not a for loop, so that we can keep track of which
    index we’re at. That’s useful because we can use the value of i + 1 as the starting
    index for our second loop ❸. The second loop will now never waste time looking
    at positions that are to the left of the first position.
  prefs: []
  type: TYPE_NORMAL
- en: We next calculate the low and high ends of the range of values for our third
    position.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than increase total by 1 each time we find a suitable third position,
    we can instead find the left and right borders of suitable positions and then
    increase total in one shot. We can only do it this way because the list of positions
    is sorted. We find each of the borders using a while loop. The first while loop
    finds the left border ❹. It keeps going as long as the positions are less than
    low. When it’s done, left will be the leftmost index whose position is greater
    than or equal to low. The second while loop finds the right border ❺. It keeps
    going as long as the positions are less than or equal to high. When it’s done,
    right is the rightmost index whose position is greater than high. Each of the
    positions from left up to but not including right can serve as the third position
    in a triple involving the positions at indices i and j. We add right - left to
    total to account for these positions ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two while loops in this program are quite tricky. Let’s make sure we know
    exactly what they’re doing by working through an example. We’ll use the following
    list of positions; they’re the same as those we used in the previous section,
    but sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 6, 11, 14, 16, 18, 23]'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that i is 1 and j is 2 so that the two positions in prospective triples
    are 6 and 11. For the third position, we’re therefore looking for positions greater
    than or equal to 16 and less than or equal to 21. The first while loop will set
    left to 4, the leftmost index whose position is greater than or equal to 16. The
    second while loop will set right to 6, the leftmost index whose position is greater
    than 21. Subtracting left from right, we obtain 6 – 4 = 2, which means that there
    are two triples involving positions 6 and 11. Before continuing, I encourage you
    to convince yourself that these while loops work just fine in “special” cases,
    such as when there are no suitable third positions or when there is one suitable
    third position.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve made strong progress in this section. Our code here is certainly more
    efficient than the code we gave in [Listing 9-5](ch09.xhtml#ch09ex05). However,
    it still isn’t efficient enough. If you submit to the judge, you’ll see that it
    doesn’t get much further than we got last time. It still times out on most of
    the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency of Our Program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The problem with our program is that finding the third position can still take
    a long time. Those while loops still have some inefficiency. I can demonstrate
    this with a new list of positions, namely, the positions from 1 to 32.
  prefs: []
  type: TYPE_NORMAL
- en: '[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,'
  prefs: []
  type: TYPE_NORMAL
- en: 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus on when i is 0 and j is 7; these are the positions 1 and 8. For
    the third position, we’re looking for positions that are greater than or equal
    to 15 and less than or equal to 22\. To find the 15, the first while loop scans
    to the right, one position at a time. It scans the 9, then the 10, then the 11,
    then the 12, then the 13, then the 14, and finally the 15. Then the second while
    loop takes over, doing a similarly large amount of scanning, one position at a
    time, all the way until it finds the 23.
  prefs: []
  type: TYPE_NORMAL
- en: Each while loop implements what’s known as a *linear search*. A linear search
    is a technique that searches through a collection one value at a time. It’s a
    lot of work, scanning through all those values! And there are many other values
    of i and j that lead to a similar amount of work. For example, try tracing what
    happens when i is 0 and j is 8, or when i is 1 and j is 11.
  prefs: []
  type: TYPE_NORMAL
- en: How can we improve on this? How can we avoid scanning through a huge chunk of
    the list, looking for the appropriate left and right indices?
  prefs: []
  type: TYPE_NORMAL
- en: Suppose I give you a book with a thousand sorted integers, one integer per line.
    I ask you to find me the first integer that’s greater or equal to 300\. Are you
    going to look through the numbers one by one? Are you going to look at the 1,
    then the 3, then the 4, then the 7? Still a long way to go—will you look at the
    8, then the 12, then the 17? Probably not! It’d be much faster if you just flipped
    to the middle of the book. Maybe you find number 450 there. Since 450 is greater
    than 300, now you know that the number is in the first half of the book. It can’t
    be in the second half, because those numbers are even bigger than 450\. You’ve
    reduced your work by half by checking only one number! You can now repeat this
    process on the first half of the book, flipping halfway between the beginning
    and middle of the book. You might find the number 200 there. Now you know that
    the 300 is on a later page, somewhere in the second quarter of the book. You can
    repeat this process until you find 300—and it won’t take long at all. This technique—repeatedly
    dividing the problem in half—is known as *binary search*. It’s shockingly fast.
    It blows away the linear search technique of searching one by one. Python has
    a binary search function that will put the finishing touches on Cow Baseball.
    That function, though, is inside of something called a *module*; we’ll need to
    discuss them first.
  prefs: []
  type: TYPE_NORMAL
- en: Python Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *module* is a self-contained collection of Python code. A module generally
    contains several functions that we can call.
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with a variety of modules that we can use to add functionality
    to our programs. There are modules for working with random numbers, dates and
    times, statistics, emails, web pages, audio files, and much more. It would take
    a separate book to cover them all! There are even modules that you can download
    should Python not come with the module that you need.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll focus in this section on one module—the random module. We’ll use it to
    learn what we need to know about modules. Then we’ll be all set for the binary
    search module in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever wondered how people make computer games where things happen at
    random? Maybe it’s a game where you draw cards, where you roll dice, or where
    enemies spawn unpredictably. The key is the use of random numbers. Python gives
    us access to random-number generation through its random module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use what’s in a module, we must *import* it. One way to do this
    is to import the entire module using the import keyword, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import random'
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s in there? To find out, you can use dir(random):'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> dir(random)'
  prefs: []
  type: TYPE_NORMAL
- en: '[stuff to ignore'
  prefs: []
  type: TYPE_NORMAL
- en: '''betavariate'', ''choice'', ''choices'', ''expovariate'','
  prefs: []
  type: TYPE_NORMAL
- en: '''gammavariate'', ''gauss'', ''getrandbits'', ''getstate'','
  prefs: []
  type: TYPE_NORMAL
- en: '''lognormvariate'', ''normalvariate'', ''paretovariate'','
  prefs: []
  type: TYPE_NORMAL
- en: '''randint'', ''random'', ''randrange'', ''sample'', ''seed'','
  prefs: []
  type: TYPE_NORMAL
- en: '''setstate'', ''shuffle'', ''triangular'', ''uniform'','
  prefs: []
  type: TYPE_NORMAL
- en: '''vonmisesvariate'', ''weibullvariate'']'
  prefs: []
  type: TYPE_NORMAL
- en: One function that’s offered by the random module is randint. We pass it the
    low and high ends of a range, and Python gives us a random integer in the range
    (including both endpoints).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can’t just call it like a regular function, though. If we try, we get an
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> randint(2, 10)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  prefs: []
  type: TYPE_NORMAL
- en: 'NameError: name ''randint'' is not defined'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to tell Python that the randint function is housed in the random module.
    To do that, we prefix randint with the name of the module and a dot, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> random.randint(2, 10)'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> random.randint(2, 10)'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> random.randint(2, 10)'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get help on the randint function, you can type help(random.randint):'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> help(random.randint)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Help on method randint in module random:'
  prefs: []
  type: TYPE_NORMAL
- en: randint(a, b) method of random.Random instance
  prefs: []
  type: TYPE_NORMAL
- en: Return random integer in range [a, b], including both end points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful function in the random module is choice. We pass it a sequence,
    and it returns one of its values at random:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> random.choice([''win'', ''lose''])'
  prefs: []
  type: TYPE_NORMAL
- en: '''lose'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> random.choice([''win'', ''lose''])'
  prefs: []
  type: TYPE_NORMAL
- en: '''lose'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> random.choice([''win'', ''lose''])'
  prefs: []
  type: TYPE_NORMAL
- en: '''win'''
  prefs: []
  type: TYPE_NORMAL
- en: 'If we frequently use a small number of functions from a module, it can be tedious
    to type the module name and a dot each time. There’s another way to import these
    functions that lets us call them like any other nonmodule function. Here’s how
    we can import only the randint function:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from random import randint'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can call randint without the random. in front:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> randint(2, 10)'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need randint and choice, we can import them both:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from random import randint, choice'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t do so in this book, but we can create our own modules containing whatever
    functions we like. For example, if we designed a few Python functions related
    to playing a game, we could place them all in a file named *game_functions.py*.
    We could then import that module using import game_functions and then access the
    functions within.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python programs we’ve written in this book are not designed to be imported
    as modules. The reason is that they all read input as soon as they start running.
    A module shouldn’t do that. Rather, a module should wait for its functions to
    be called before it does anything. The random module is an example of a well-behaved
    module: it only starts giving us random things when we ask for them.'
  prefs: []
  type: TYPE_NORMAL
- en: The bisect Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’re ready to play around with binary search. In [Listing 9-6](ch09.xhtml#ch09ex06),
    we had two while loops. They’re slow, so we want to get rid of them. To do that,
    we’re going to replace each one with a call to a binary search function: bisect_left
    for the first while loop and bisect_right for the second.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these functions are in the bisect module. Let’s import them:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from bisect import bisect_left, bisect_right'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first discuss bisect_left. We call it by providing a list sorted from
    smallest to largest and a value x. It returns to us the index of the leftmost
    value in the list that’s greater than or equal to x.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the value is in the list, we get the index of its leftmost occurrence:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_left([10, 50, 80, 80, 100], 10)'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_left([10, 50, 80, 80, 100], 80)'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the value isn’t in the list, then we get the index of the first value that’s
    greater:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_left([10, 50, 80, 80, 100], 15)'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_left([10, 50, 80, 80, 100], 81)'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we search for something that’s greater than every value in the list, we
    get the list’s length:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_left([10, 50, 80, 80, 100], 986)'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use bisect_left on our list of seven positions from “Sorting First” earlier
    in this chapter. We’ll find the index of the leftmost position that’s greater
    than or equal to 16:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> positions = [1, 6, 11, 14, 16, 18, 23]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_left(positions, 16)'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perfect: that’s exactly what we need to replace the first while loop in [Listing
    9-6](ch09.xhtml#ch09ex06).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the second while loop, we’ll use bisect_right rather than bisect_left.
    We call bisect_right just as we called bisect_left : with a sorted list and a
    value x. Rather than returning the index of the leftmost value in the list that’s
    *greater than or equal to* x, it returns the index of the leftmost value that’s
    *greater than* x.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare bisect_left and bisect_right. For a value that’s in the list,
    bisect_right returns an index greater than that returned by bisect_left:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_left([10, 50, 80, 80, 100], 10)'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_right([10, 50, 80, 80, 100], 10)'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_left([10, 50, 80, 80, 100], 80)'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_right([10, 50, 80, 80, 100], 80)'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a value that isn’t in the list, bisect_left and bisect_right return the
    same index:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_left([10, 50, 80, 80, 100], 15)'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_right([10, 50, 80, 80, 100], 15)'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_left([10, 50, 80, 80, 100], 81)'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_right([10, 50, 80, 80, 100], 81)'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_left([10, 50, 80, 80, 100], 986)'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_right([10, 50, 80, 80, 100], 986)'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use bisect_right on our list of seven positions from “Sorting First”
    earlier in this chapter. We’ll find the index of the leftmost position that’s
    greater than 21:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> positions = [1, 6, 11, 14, 16, 18, 23]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> bisect_right(positions, 21)'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: 'There we go: that’s what we can use to replace the second while loop in [Listing
    9-6](ch09.xhtml#ch09ex06).'
  prefs: []
  type: TYPE_NORMAL
- en: The stunning speed of binary search is hard to appreciate using these tiny examples.
    Time to get real. We’ll search one million times for the rightmost value in a
    list of length 1000000. Don’t look away when you run this code. You might miss
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '>>> lst = list(range(1, 1000001))'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for i in range(1000000):'
  prefs: []
  type: TYPE_NORMAL
- en: '...     where = bisect_left(lst, 1000000)'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: On my computer, that takes about a second. You might be wondering what would
    happen if you replaced the binary search with a call to the list index method.
    If you try it, you’ll literally wait hours for the code to run. That’s because
    index, like the in operator, does a linear search through the list. (See “Efficiency
    of Searching a List” in [Chapter 8](ch08.xhtml#ch08) for more on this.) It has
    no guarantee that the list is sorted, so it can’t perform a blazing-fast binary
    search. It has to go through the values one by one, comparing each of them to
    the value we’re searching for. If you have a sorted list and you want to find
    values in it, binary search is unstoppable.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re ready to solve Cow Baseball using binary search. See [Listing 9-7](ch09.xhtml#ch09ex07)
    for the code.
  prefs: []
  type: TYPE_NORMAL
- en: ❶ from bisect import bisect_left, bisect_right
  prefs: []
  type: TYPE_NORMAL
- en: input_file = open('baseball.in', 'r')
  prefs: []
  type: TYPE_NORMAL
- en: output_file = open('baseball.out', 'w')
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input_file.readline())
  prefs: []
  type: TYPE_NORMAL
- en: positions = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: positions.append(int(input_file.readline()))
  prefs: []
  type: TYPE_NORMAL
- en: positions.sort()
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(i + 1, n):'
  prefs: []
  type: TYPE_NORMAL
- en: first_two_diff = positions[j] - positions[i]
  prefs: []
  type: TYPE_NORMAL
- en: low = positions[j] + first_two_diff
  prefs: []
  type: TYPE_NORMAL
- en: high = positions[j] + first_two_diff * 2
  prefs: []
  type: TYPE_NORMAL
- en: ❷ left = bisect_left(positions, low)
  prefs: []
  type: TYPE_NORMAL
- en: ❸ right = bisect_right(positions, high)
  prefs: []
  type: TYPE_NORMAL
- en: total = total + right - left
  prefs: []
  type: TYPE_NORMAL
- en: output_file.write(str(total) + '\n')
  prefs: []
  type: TYPE_NORMAL
- en: input_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: output_file.close()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-7: Using binary search*'
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we import the bisect_left and bisect_right functions from the bisect
    module so that we can call them ❶. The only other difference compared to [Listing
    9-6](ch09.xhtml#ch09ex06) is that we now use bisect_left ❷ and bisect_right ❸
    instead of the while loops.
  prefs: []
  type: TYPE_NORMAL
- en: If you submit our code to the judge now, you should pass all test cases within
    the time limit.
  prefs: []
  type: TYPE_NORMAL
- en: The arc that we followed in this section is typical of that required to solve
    hard problems. We might start with a complete-search solution that is correct
    but, alas, is also too slow, not meeting the judge’s time limits. We then make
    improvements, leading us away from complete search and toward a more refined approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we start with [Listing 9-7](ch09.xhtml#ch09ex07) and use bisect_left
    in place of bisect_right. That is, we take this line:'
  prefs: []
  type: TYPE_NORMAL
- en: right = bisect_right(positions, high)
  prefs: []
  type: TYPE_NORMAL
- en: 'And we change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: right = bisect_left(positions, high)
  prefs: []
  type: TYPE_NORMAL
- en: Does the program still produce the correct answers?
  prefs: []
  type: TYPE_NORMAL
- en: A. It always produces the correct answer, just as before.
  prefs: []
  type: TYPE_NORMAL
- en: B. It sometimes produces the correct answer; it depends on the test case.
  prefs: []
  type: TYPE_NORMAL
- en: C. It never produces the correct answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. There are test cases for which the modified code does produce the
    correct answer. Here’s one:'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: The correct answer is 0, and that’s what our program produces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful, though, because there are other test cases for which the modified
    code produces the wrong answer. Here’s one:'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: The correct answer is 1, but our program produces 0. When i is 0 and j is 1,
    the program is supposed to set left to 2 and set right to 3. Unfortunately, using
    bisect_left causes right to be set to 2, because the position at index 2 is the
    leftmost position that’s greater than or equal to 8.
  prefs: []
  type: TYPE_NORMAL
- en: Given this counterexample, you might be surprised to know that there *is* a
    way to use bisect_left rather than bisect_right. To do it, we need to alter what
    we search for in the call to bisect_left. If you’re curious, give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned about complete-search algorithms, algorithms that
    search through all options to find the best one. To determine the lifeguard that
    we should fire, we try firing each lifeguard and choose the best one. To determine
    the minimum cost to fix ski hills, we try all valid ranges and choose the best
    one. To determine the number of relevant triples of cows, we check each triple
    and add the ones that meet the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, complete-search algorithms are efficient enough as they are. We solved
    the Lifeguards and Ski Hills problems with unadorned complete-search code. Other
    times, however, we’ll need to make our complete-search algorithm more efficient.
    We did that when solving Cow Baseball by replacing complete-search while loops
    by much faster binary searches.
  prefs: []
  type: TYPE_NORMAL
- en: How do programmers and computer scientists discuss efficiency? How do you know
    whether an algorithm is going to be efficient enough? And can you avoid implementing
    algorithms that are simply too slow? [Chapter 10](ch10.xhtml#ch10) awaits.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try. For each, use complete search. If your
    solution is not efficient enough, think about how you can make it more efficient
    while still producing the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each exercise, double-check the judge that the problem comes from: some
    are on the DMOJ judge, while others are on the USACO judge.'
  prefs: []
  type: TYPE_NORMAL
- en: USACO 2019 January Bronze Contest problem Shell Game
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2016 US Open Bronze Contest problem Diamond Collector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci20c1p1, Patkice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ccc09j2, Old Fishin’ Hole
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ecoo16r1p2, Spindie
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem cco96p2, SafeBreaker
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2019 December Bronze Contest problem Where Am I
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2016 January Bronze Contest problem Angry Cows
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: USACO 2016 December Silver Contest problem Counting Haybales
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem crci06p3, Firefly
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lifeguards is originally from the USACO 2018 January Bronze Contest. Ski Hills
    is originally from the USACO 2014 January Bronze Contest. Cow Baseball is originally
    from the USACO 2013 December Bronze Contest.
  prefs: []
  type: TYPE_NORMAL
- en: There are other types of algorithms beyond complete search, such as *greedy
    algorithms* and *dynamic-programming algorithms*. If a problem cannot be solved
    by complete search, then it’s worth thinking through whether it can be solved
    using one of these other types.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in learning more about these and other algorithms topics
    using Python, I recommend *Python Algorithms*, 2nd edition by Magnus Lie Hetland
    (Apress, 2014).
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve also written a book about algorithm design: *Algorithmic Thinking: A Problem-Based
    Introduction* (No Starch Press, 2021). It follows the same problem-based format
    as this book; as a result, its style and pacing will be familiar to you. However,
    it uses the C programming language, not the Python programming language, so to
    make the most of it, you’ll want to learn some C beforehand.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we called preexisting Python functions to perform binary searches.
    If we like, we can write our own binary-search code instead of relying on those
    functions. The idea of dividing a list in half until we find the value that we
    want is intuitive, but the code to implement this is surprisingly tricky. Equally
    surprising is the vast range of problems that can be solved using variations of
    binary search. My book mentioned earlier, *Algorithmic Thinking*, contains an
    entire chapter on binary search and what it can do.
  prefs: []
  type: TYPE_NORMAL
