# 2

二分查找

![](img/chapterart.png)

*二分查找*是一种高效的已排序列表搜索算法。它通过不断地将已排序的列表分成两半，判断哪一半可能包含目标值，并丢弃另一半，来检查目标值是否存在。这种算法的逻辑和实现简洁，使其成为计算机科学的完美入门话题，因此二分查找算法几乎普遍出现在计算机科学课程和教科书中。

怀疑的读者可能会想：“我到底有多频繁需要搜索一个已排序的列表？”或者，更准确地说，“我到底有多频繁需要实现一个函数来搜索我的已排序列表？难道不是已经有几百万个人做过这个了吗？难道它不是某个库的一部分吗？”虽然你不应该排除未来需要实现你自己的二分查找的可能性，但它的真正重要性远远超出了其实现本身。

二分查找展示了聪明的算法如何利用数据存储结构来实现显著的计算节省，即使这种结构像排序数据那样简单。二分查找易于分析其正确性和效率，提供了速度和正确性的保证，并展示了数据与算法之间的基本互动。它是一个很好的视角，用来研究不同数据存储技术之间的差异，比如链表和数组之间的差异，或者许多基于树的算法背后的动机。它甚至可以用来做一杯更好的咖啡。

## 问题

在定义任何新算法之前，我们必须定义该算法将要解决的问题。在本章中，我们的目标是在列表中找到与给定目标值匹配的单个项目；我们需要一个能够高效执行这种搜索的算法。我们可以正式地将这个搜索定义为：

> 给定一组*N*个数据点 *X* = {*x*[*1*]*, x*[*2*]*, ... , x*[*N*]} 和一个目标值 *x*'，找出一个点 *x*[*i*]∈ *X* 使得 *x*' = *x*[*i*]，或者指示没有这样的点存在。

在我们的日常生活中，我们可能会把任务描述为“找到这个特定的东西”。这个搜索问题是我们每天都会遇到的。我们可能在查字典找一个单词，在通讯录里找一个名字，在历史事件列表里找一个特定的日期，或者在挤满货物的超市货架上找我们偏爱的咖啡品牌。我们所需要的只是一个候选列表和一个检查是否找到匹配项的方法。

## 线性扫描

为了更好地理解二分查找的优势，我们从一个更简单的算法——*线性扫描*开始，以此作为对比的基准。线性扫描通过逐个测试列表中的每个值与目标值进行比对，直到找到目标值或遍历到列表的末尾。这就是作者通常搜索超市货架的方式——逐个用手指划过五彩缤纷的咖啡包装袋，同时低声抱怨索引系统需要改进。

假设我们要在一个包含数字的数组`A`中查找目标值。在这种情况下，假设`target = 21`。我们遍历数组中的每个箱子，并检查该值是否等于 21，如图 2-1 所示。

清单 2-1 展示了线性扫描的代码。如果找到匹配的元素，代码返回该元素的索引；如果搜索失败且数组中没有该项，则返回索引`-1`。

```py
LinearScan(Array: A, Integer: target):
    Integer: i = 0
    WHILE i < length(A):
        IF A[i] == target:
            return i
        i = i + 1
    return -1
```

清单 2-1：线性扫描的代码

![一个图表，展示了如何对包含数字的 11 个无序箱子执行线性扫描。我们检查第一个箱子的值是否为 21；如果不是，则检查下一个箱子，以此类推，直到找到匹配项。](img/f02001.png)

图 2-1：对整数数组进行线性扫描

一个简单的`WHILE`循环遍历数组中的每个元素，内部的`IF`语句将该元素与目标进行比较。一旦遇到匹配的元素，我们返回对应的索引。如果遍历到数组的末尾，则返回`-1`。

线性扫描并不复杂或巧妙。它是一个*暴力破解*测试，保证能找到感兴趣的项目（如果项目在数据中存在），因为它会检查每一个可能的项，直到找到匹配项或确认该项不存在。这种方法全面，但效率较低，特别是在大型列表中。如果我们对`A`中数据的结构一无所知，就没有办法优化这个过程。目标值可能在任何一个箱子中，所以我们可能需要检查所有箱子。

为了说明线性扫描的局限性，想象一下在一排物品上执行这样的扫描，比如一排站在教室外的计算机科学入门学生。老师为了找出某个学生的作业，逐个走下去问每个学生：“你的名字是 Jeremy 吗？”然后可能继续问下一个。搜索在老师找到正确的学生或走到队列末尾时停止。学生们（正确地）翻了翻眼睛，低声抱怨老师效率低下。

有时可以通过*每次比较*优化线性查找的速度。例如，我们可以通过在比较字符串时遇到第一个不匹配的字母就停止，从而优化复杂数据的比较时间，正如第一章中所描述的那样。同样，在超市的例子中，我们可以提前喝大量的咖啡，这样我们的颤抖的手指就能更快地沿着货架滑动。然而，这只能帮助到一定程度。我们仍然需要逐一检查每个项目。

在下一节中，我们将看到数据中的少量结构如何改变一切。

## 二分查找算法

二分查找是一种在*排序*列表中查找目标值*v*的算法，仅适用于排序数据。该算法可以编写成适用于按递增或递减顺序排序的数据，但目前我们考虑的是按递增顺序排序的数据——从最小到最大。该算法通过将列表分成两半，确定*v*应该位于哪一半来进行操作。然后，它会丢弃*v*不在的那一半，并在可能仍包含*v*的那一半上重复该过程，直到只剩一个值。例如，如果我们在图 2-2 中查找值 7，我们会在中点找到 5，并可以排除列表的前半部分。中点之前的任何元素都不可能大于 5，而由于 5 小于 7，因此 5 之前的所有元素也都小于 7。

![从 1 到 9 的整数排序列表。一箭头指向值为 5 的中点。](img/f02002.png)

图 2-2：一个从 1 到 9 的整数排序列表，其中 5 是中点。

高效算法的关键是利用数据中的信息或结构。在二分查找的情况下，我们利用了数组按递增顺序排序这一事实。更正式地说，考虑一个排序数组`A`：

对于任意一对索引*i*和*j*，若*i* < *j*，则有 *A*[*i*] ≤ *A*[*j*]

尽管这看起来信息量不大，但它足以让我们排除数组中的整个区域。这类似于我们在找咖啡时避免走冰淇淋过道的逻辑。一旦我们知道某个物品不会出现在某个区域，我们就可以排除该区域内的所有物品，而不必一个个检查它们。

二分查找通过两个边界来跟踪当前的搜索空间：上界`IndexHigh`标记数组中属于活动搜索空间的最高索引，下界`IndexLow`标记最低索引。在整个算法中，如果目标值在数组中，我们可以保证以下几点：

```py
A[IndexLow] ≤ v ≤ A[IndexHigh]
```

二分查找从每次迭代选择当前搜索空间的中点开始：

```py
IndexMid = Floor((IndexHigh + IndexLow) / 2)
```

其中，`Floor`是一个数学函数，用于将一个数向下取整为整数。然后，我们将中间位置的值`A[IndexMid]`与目标值`v`进行比较。如果中点小于目标值，即`A[IndexMid] < v`，我们知道目标值必须位于中点索引之后。这使我们能够通过将`IndexLow = IndexMid + 1`来将搜索空间减半。或者，如果中点大于目标值，即`A[IndexMid] > v`，我们知道目标值必须位于中点索引之前，这样我们就可以通过将`IndexHigh = IndexMid – 1`来将搜索空间减半。当然，如果我们发现`A[IndexMid] == v`，我们会立即结束搜索：目标已经找到。热烈庆祝是可选的。

图 2-3 中的每一行表示排序数组中二分查找过程的一步。我们在第(a)行中搜索数组中的值`15`。开始时，我们的搜索边界包括整个数组：`IndexLow = 0` 和 `IndexHigh = 11`。

在第(b)行中，我们计算中点（向下取整）为`IndexMid = 5`。将中点的值与目标值进行比较，我们看到`A[5] = 11`，小于目标值`15`。因此，在第(c)行中，我们排除了数组中从索引`5`及之前的所有元素——即所有阴影部分——通过调整下界：`IndexLow = 6`。通过一次比较，我们就消除了几乎一半的搜索空间！算法继续在剩余范围内重复这个过程，计算新的中点为`IndexMid = 8`，并与目标值进行比较（`A[8] = 30`，大于`v = 15`），然后将边界调整为`IndexHigh = 7`。在第(d)行中，我们再次以相同的方式排除剩余搜索空间的一半。在第(e)行中，我们再次计算中点为`IndexMid = 6`并将其与目标值进行比较（`A[6] == v`）。目标已经找到了！

请注意，尽管下界索引已经指向目标值（`v = 15`）好几次，我们仍然继续搜索，直到*中点*指向目标值。这是因为我们的搜索只检查中点位置的值是否与目标匹配，而不是下界或上界索引的值。

回到我们的计算机科学入门课程的学生，我们可以想象，到学期末，老师要求学生按字母顺序排队。然后，老师开始进行二分查找，问中间的学生“你叫什么名字？”，并根据学生的回答将一半的学生从队伍中去除。教授随后在脑海中调整边界，移动到新的中点，并重复这个过程。这样，教授就能将交作业的练习变成演示二分查找——同时也掩盖了他们从未记住学生名字的事实。

![一张图示，表示对排序数组中的值 15 进行二分查找，其中最小值是-5，最大值是 54。五行（a）到（e）分别展示了搜索过程中不同阶段的数组。被排除的数组部分以灰色阴影标出，其他部分以白色阴影标出。](img/f02003.png)

图 2-3：对排序数组中的值 15 进行的二分查找

### 缺失的值

接下来，我们需要考虑目标值不在列表中时会发生什么，以及二分查找是如何确认值的缺失的。在线性扫描的情况下，一旦我们到达列表末尾，就知道元素不在列表中。对于二分查找，我们可以通过测试边界来得出结论，目标项不存在。随着搜索的进行，上下边界会越来越接近，直到它们之间没有未探索的值。由于我们总是将一个边界*移动*到中点索引的另一侧，当`IndexHigh < IndexLow`时，我们可以停止搜索。此时，我们可以确保目标值不在列表中。Figure 2-4 展示了一个在排序数组中搜索`v = 10`的例子，其中`10`不出现在数组中。

![一张图示，表示对排序数组中缺失的值 10 进行二分查找，数组的最小值是-5，最大值是 54。六行（a）到（f）分别展示了搜索过程中不同阶段的数组。](img/f02004.png)

图 2-4：对一个不在数组中的值（10）进行的二分查找

理论上，我们可以在行（f）之前就停止搜索：一旦我们在高边界处的值小于目标值（`IndexHigh = 4`），我们就知道目标值不可能在数组中。然而，像 Figure 2-3 中的搜索一样，算法只会检查中点处的值与目标值进行比较。它会跟踪高低边界的索引，但不会显式地检查这些位置的值。虽然我们可以添加逻辑来捕捉这种情况，以及下边界大于目标值的相应情况，但为了简化逻辑，我们暂时保持现有的简单实现。

### 实现二分查找

我们可以通过一个单一的`WHILE`循环在代码中实现二分查找，如 Listing 2-2 所示。与 Listing 2-1 中的线性查找代码类似，二分查找算法会返回目标元素在数组中的索引。如果数组中没有匹配的元素，算法将返回`−1`。

```py
BinarySearch(Array: A, Integer: target):
    Integer: IndexHigh = length(A) - 1
    Integer: IndexLow = 0
  ❶ WHILE IndexLow <= IndexHigh:
      ❷ Integer: IndexMid = Floor((IndexHigh+IndexLow) / 2)

        IF A[IndexMid] == target:
            return IndexMid
        IF A[IndexMid] < target:
          ❸ IndexLow = IndexMid + 1
        ELSE:
          ❹ IndexHigh = IndexMid - 1
    return -1
```

Listing 2-2：用单个循环实现二分查找

当高低索引没有交叉时，我们继续搜索 ❶。在每次迭代中，我们计算一个新的中点 ❷，并将中点值与目标值进行比较。如果它完全匹配，我们就找到了目标，可以直接返回相应的索引。如果中点的值太小，我们调整下界 ❸。如果值太大，我们调整上界 ❹。如果`IndexHigh < IndexLow`，元素不在数组中，我们返回`-1`。

根据编程语言的不同，我们可以使用除返回`-1`外的其他方法来表示失败，比如抛出异常。无论具体的机制如何，您的代码和文档应该始终明确说明如果元素不在数组中会发生什么，以便函数的调用者能够正确使用它。

## 改编二分查找

到目前为止，我们已经考虑了在列表和数组中的二分查找——一组固定的离散项。很容易看出，我们可以通过将该算法应用于一排排的排序书籍、电话簿中的名字，或者按尺码排序的衣架，将其引入现实世界。但我们同样可以将这种方法适应于连续数据，在这种情况下，我们不从一组单独的项或索引开始，而是直接使用值本身的上下界。

假设您想要制作一杯完美的咖啡。在几个月的辛勤研究后，您已经确认了最佳的水温和水量。然而，还有一个谜团待解：应使用多少咖啡粉？此时，意见不一。浓咖啡派推荐使用 5 汤匙咖啡粉，而淡咖啡派则推荐仅使用 0.5 汤匙。

确定自己最佳咖啡粉量的问题非常适合使用二分查找，如图 2-5 所示。我们从合理的上下界开始，如图 2-5(a)所示。

1.  LowerBound = 0 汤匙 “咖啡”是一杯温水。

1.  UpperBound = 5 汤匙 咖啡太浓了。

真正的值必须在两者之间。请注意，我们的边界现在是这些值本身，而不是项的索引。

![一张展示在 0 到 5 汤匙咖啡之间进行二分查找的图表。在每一步（a）到（d）中，我们定义新的中点，直到找到最佳中点值 2。](img/f02005.png)

图 2-5：可以使用改编的二分查找来搜索一个实数范围。

与对一个值数组的二分查找一样，我们可以将中点定义为 2.5 汤匙并进行测试（见图 2-5(b)）。同样，2.5 汤匙只是一个值，它并不对应数组中的某个元素或书架上的某个项。我们没有一组预定的值数组，而是 0.0 到 5.0 之间所有实数的无限范围，任何单独的测量值实际上都对应于该范围中的一个索引。

我们发现 2.5 汤匙酿出的咖啡对于我们的口味来说有些太浓，这使得我们能够精细调整范围。我们现在的最佳咖啡量被限制在 0 汤匙和 2.5 汤匙之间（c）。我们的搜索继续进行，新的中间点是 1.25 汤匙，这个量酿出的咖啡较为淡薄。我们需要细化下限（d）。

寻找晨间愉悦的过程就是这样继续进行，直到我们足够缩小范围。与离散的数值数组不同，我们可能永远无法找到完全满足搜索条件的确切点。毕竟，实数的值是无限的。如果我们的最佳咖啡量是 2.0 汤匙，我们可能会尝试 2.50、1.25、1.875、2.1875 和 2.03125 等值，然后得出结论，认为我们已经足够接近了。因此，当我们的范围足够小时，我们会终止搜索：

```py
UpperBound – LowerBound < threshold
```

将这种搜索与线性扫描选项进行对比。在科学的名义下，我们可能决定尝试每一个 0.05 汤匙的增量，直到找到最佳的酿制比例。毕竟，这可是咖啡，我们必须彻底。从我们最低的起始点（0.0 汤匙——也就是一杯温水）开始，我们不断增加 0.05 的量并重新测试。我们从 0.05、0.10、0.15，……，一直到 1.00，才开始接近合理的浓度。我们需要进行许多试验才能找到正确的比例，至少有 20 次试验会太弱，甚至不能算作咖啡。这是大量的浪费努力和咖啡豆。

使用二分搜索还可以提高精度。在我们进行线性扫描时，每次仅增加 0.05 的增量，这限制了我们能接近目标值的程度。二分搜索不断缩小范围，直到我们停止。我们选择一个足够小的`UpperBound – LowerBound`差值来停止搜索，从而将范围缩小到 0.0001 汤匙或更精确。

这种二分搜索方法的改进形式构成了重要数学技术的基础，例如二分法搜索。*二分法搜索*用于寻找函数的零点，或者找到* x *值，使得 * f *（* x *）= 0。与评估咖啡是否太浓或太淡不同，二分法搜索跟踪函数在零点以上和以下的区间。通过不断在中点处分割区间，算法逐步缩小到 * x * 的值，使得函数的值恰好为零。

## 运行时间

直观上，我们可以看到二分搜索通常比线性扫描数据更快。让我们看看二分搜索到底能快多少，以确定它是否值得额外的代码复杂性。

当然，两个算法的相对速度依赖于数据本身。如果我们正在寻找的值总是出现在列表的开头，线性扫描会更快。同样，二分搜索对于小型列表可能是不必要的。如果列表只有两个元素，我们不需要将其分割成两半，只需直接查看这两个元素。

我们常常根据数据大小 *N* 的变化，分析算法的平均运行时间和最坏情况表现。计算机科学家通常使用像 Big-O 这样的度量来更正式地表达这些概念。虽然本书不会正式分析算法或使用 Big-O 符号，但我们会在每个算法中考虑相同的两个方面：

+   算法的平均情况运行时间随着数据量的增长

+   算法的最坏情况运行时间随着数据量的增长

现在，让我们比较线性扫描和二分查找的最坏情况表现。对于线性扫描，最坏情况发生在目标值位于列表的末尾或根本不在列表中。这时，算法必须检查每一个值。如果数组有 *N* 个值，它将需要 *N* 次比较。它的最坏情况运行时间是 *线性* 的，随着数据量的增大而增长。

相比之下，即使是最坏情况下的二分查找，也会在每一步中丢弃一半的数据，因此比较次数是与数据集大小的 *对数* 成正比。它的增长比例是 log[2]*N*，即 *N* 的以 2 为底的对数。诚然，每一步的工作量更多：我们不再检查单一的值，而是需要移动边界并计算新的中点。然而，对于足够大的列表，仅需进行对数次比较的优势，将远大于每步增加的额外开销。

## 为什么这很重要

在计算机科学入门课程中，过分关注二分查找并不是因为有二分查找的宣传活动、粉丝俱乐部或秘密社团（尽管这些都能理解）。实际上，正是二分查找的简洁性，使其成为一个完美的入门主题。它是计算思维中最基本概念之一的一个干净且有效的示例：通过利用问题本身的结构来设计算法，帮助我们构建高效的解决方案。通过利用数据的有序特性，我们能够将最坏情况的运行时间从与数据量成线性关系，降低到与数据量的对数成关系——这种差异随着数据量的增大变得更加显著。

在本书的其余部分，我们将继续探讨问题结构（包括数据本身）与如何创造高效解决方案之间的紧密关系。
