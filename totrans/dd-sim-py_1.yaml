- en: Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: THE PYTHON ENVIRONMENT
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python环境
- en: '1'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Python Philosophy
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python哲学
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: I believe the best place to start learning Python is not with the language itself,
    but with the guiding philosophy driving it. To write good Python code, you must
    first understand what Python is. That’s what this chapter will focus on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为学习Python的最佳起点不是从语言本身开始，而是从驱动它的指导哲学开始。要编写好的Python代码，你必须首先理解Python是什么。这也是本章的重点。
- en: What Is Python, Exactly?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Python，究竟是什么？
- en: Python is a programming language developed in 1991 by Dutch programmer Guido
    van Rossum. The name refers not to the snake often used as a mascot, but to *Monty
    Python’s Flying Circus* (that fact alone should tell you a lot about the mindset
    behind the language). What began as a hobby project over Christmas break turned
    into one of the most perennially popular computer languages today.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种由荷兰程序员Guido van Rossum于1991年开发的编程语言。这个名字并不是指常作为吉祥物的蛇，而是指*蒙提·派森的飞行马戏团*（这一点本身就能告诉你关于这门语言背后的思维方式）。从最初的圣诞假期业余项目开始，Python如今已成为全球最受欢迎的计算机语言之一。
- en: From a technical perspective, Python is considered a high-level, general-purpose
    language, with full support for the procedural, object-oriented, and functional
    programming paradigms, among others.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，Python被认为是一种高级的通用编程语言，完全支持过程式、面向对象和函数式编程等范式。
- en: 'Fans of Python are quick to point out its famous readability and simplicity,
    which lend to an initial feeling that the language is “magic.” This has also given
    rise to a less-than-useful bit of advice for newcomers: “Python is easy; it’s
    just pseudocode!”'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python的粉丝们常常指出它著名的可读性和简洁性，这让人最初觉得这门语言充满“魔力”。这也催生了一个对新手来说不太有用的建议：“Python很简单；它只是伪代码！”
- en: 'That isn’t strictly true. Don’t let the natural readability fool you: Python
    is beautifully unique and influenced by many other languages, but it often bears
    little resemblance to any of them. To truly master it, one must take it by itself,
    not in strong comparison to other languages. That is exactly what this book will
    do.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全正确。不要让Python自然的可读性迷惑了你：Python独具魅力，受到了许多其他语言的影响，但它常常与这些语言差异甚远。要真正掌握它，必须单独看待它，而不是与其他语言进行强烈对比。这正是本书的目标。
- en: Most importantly, however, Python is an idea. It’s the collective creation of
    a diverse group of nerds, united by nothing more than an audacious desire to build
    an awesome programming language. When you truly understand Python, it alters your
    entire perspective. You’re a part of something larger; something that has taken
    on a life of its own.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是，Python是一种理念。它是一个由各种极客共同创造的集体成果，他们仅凭着一种大胆的愿望：构建一个出色的编程语言。当你真正理解Python时，它会改变你对整个编程的看法。你是一个更大事物的一部分；一个已经具备了自己生命的事物。
- en: 'As Guido van Rossum explained in his famous King’s Day speech:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Guido van Rossum在他著名的国王日演讲中所解释的：
- en: I believe the most important idea is that Python is developed on the Internet,
    entirely in the open, by a community of volunteers (but not amateurs!) who feel
    passion and ownership.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认为最重要的理念是，Python是由一个志愿者社区（而非业余爱好者！）在互联网上完全开放地开发的，这些人怀着热情和归属感共同努力。
- en: 'Myths: What Python Isn’t'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 误解：Python不是……
- en: There are a lot of myths about Python, many of which lead to people shunning
    the language for certain applications, if not altogether.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Python有很多误解，很多人因此而避免在某些应用中使用Python，甚至完全放弃它。
- en: 'Myth #1: Python Is Merely a Scripting Language'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 误解#1：Python只是脚本语言
- en: 'I consider “scripting language” to be one of the most insidious terms used
    in discussing programming languages. It implies that the language is somehow unsuited
    for writing “real” software (see Myth #5).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为“脚本语言”是讨论编程语言时最具误导性的术语之一。它暗示着这种语言不适合编写“真正”的软件（参见误解#5）。
- en: Python is *turing-complete*, which means that you could implement any programming
    language in Python and then be able to execute any program written in that language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python是*图灵完备*的，这意味着你可以用Python实现任何编程语言，然后执行任何用该语言编写的程序。
- en: To put that another way, anything another programming language can do, Python
    can do. Whether it’s easy, or even advisable, depends on what you’re attempting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，任何其他编程语言能做的事，Python也能做。是否容易，甚至是否推荐，则取决于你正在尝试的事情。
- en: 'Myth #2: Python Is Slow'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 误解#2：Python很慢
- en: It’s easy to assume that high-level or interpreted languages like Python are
    naturally slower than compiled or low-level languages like C. In truth, it depends
    on the implementation of the language and how it’s used. In this book, we’ll cover
    several concepts related to improving the performance of Python code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易假设像Python这样的高级语言或解释型语言天然比像C这样的编译型或低级语言要慢。事实上，这取决于语言的实现方式以及它是如何使用的。在本书中，我们将介绍一些与提高Python代码性能相关的概念。
- en: The default implementation of the Python language interpreter, CPython, is written
    in C, and it is indeed slower than native machine code. However, there are various
    libraries and techniques—as well as other implementations of the language, including
    PyPy—which have much better performance overall (see Chapter 21) and even approach
    the speed of native machine code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言解释器的默认实现CPython是用C编写的，确实比原生机器码慢。然而，有各种各样的库和技术——以及其他实现版本的语言，包括PyPy——它们在整体性能上要好得多（参见第21章），甚至接近原生机器码的速度。
- en: With all that said, you should understand how performance actually factors into
    your project. In most situations, Python is plenty fast enough to be a good choice
    for application development, data analysis, scientific computing, game development,
    web development, and the list goes on. The performance drawbacks inherent in CPython
    usually only become problematic when you are dealing with very specific scenarios
    demanding extraordinarily high performance. Even then, there are ways around the
    bottlenecks. For the majority of projects, Python’s baseline performance is more
    than sufficient.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你应该理解性能实际上如何影响你的项目。在大多数情况下，Python的性能足够快，足以成为应用程序开发、数据分析、科学计算、游戏开发、Web开发等领域的好选择。CPython固有的性能缺陷通常只有在你处理需要非常高性能的特定场景时才会成为问题。即便如此，依然有方法绕过瓶颈。对于大多数项目而言，Python的基本性能已经足够。
- en: 'Myth #3: Python Cannot Be Compiled'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谬论#3：Python无法被编译
- en: Python is an *interpreted language*, meaning the code is read, interpreted,
    and executed at runtime by the language’s *interpreter*. An end user running a
    project written in Python will typically have to have the Python interpreter installed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种*解释型语言*，意味着代码在运行时由语言的*解释器*读取、解释并执行。运行用Python编写的项目的最终用户通常需要安装Python解释器。
- en: This contrasts with what I like to call *assembled languages*, like C, C++,
    or FORTRAN. In these languages, the final result of compilation is machine code,
    which can be executed directly on any compatible computer without needing an additional
    program on that machine (or somehow bundled with the code).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我喜欢称之为*汇编语言*的语言，如C、C++或FORTRAN形成对比。在这些语言中，编译的最终结果是机器代码，可以在任何兼容的计算机上直接执行，而不需要在该机器上额外的程序（或某种与代码捆绑在一起的程序）。
- en: Many developers take this to mean that Python cannot be compiled (assembled)
    to machine code, which seems like the obvious corollary. In fact, it is possible
    to compile Python to machine code, although this is rarely necessary and seldom
    done.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很多开发者以为这意味着Python无法被编译（汇编）成机器代码，这似乎是显而易见的推论。事实上，Python是可以编译成机器代码的，尽管这通常不必要，也很少这样做。
- en: If you want to go this route, there are a few options. On UNIX, the built-in
    *Freeze* tool transpiles to C arrays of Python bytecode, and then it assembles
    this C code to machine code. This doesn’t result in truly assembled Python code,
    however, because the Python interpreter must still be invoked behind the scenes.
    Freeze only works on UNIX systems. The *cx_Freeze* tool, as well as *py2exe* on
    Windows, does much the same thing as Freeze.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想走这条路，有几个选择。在UNIX系统上，内置的*Freeze*工具将Python字节码转译成C数组，然后将这些C代码汇编成机器代码。然而，这并不会产生真正的汇编Python代码，因为Python解释器仍然需要在幕后被调用。Freeze只适用于UNIX系统。*cx_Freeze*工具以及Windows上的*py2exe*做的事情与Freeze差不多。
- en: To truly compile Python to machine code, you must use an intermediary language.
    *Nuitka* can be used to transpile Python code C and C++, which can then be assembled
    to machine code. You can also transpile Python to Java with *VOC*. *Cython* also
    allows transpiling a specialized form of Python to C, although it’s primarily
    geared toward writing Python extensions in C.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正将Python编译成机器代码，你必须使用中介语言。*Nuitka*可以用来将Python代码转译成C和C++，然后将其汇编成机器代码。你还可以使用*VOC*将Python转译为Java。*Cython*也允许将一种特定形式的Python转译成C，尽管它主要是用于编写Python扩展模块。
- en: 'Myth #4: Python Gets Compiled Behind the Scenes'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谬论#4：Python在幕后被编译
- en: 'The Python interpreter converts code to *bytecode*, which is then executed.
    The interpreter includes a *virtual machine*, which executes the Python bytecode
    similarly to how a CPU executes machine code. Sometimes, the interpreter will
    do the conversion to bytecode in advance, for performance reasons, generating
    *.pyc* files containing bytecode. While this is “compiling” in one sense of the
    term, there is a key difference between compiling to bytecode and compiling to
    machine code: bytecode is still run through the interpreter, whereas machine code
    executes directly, without needing an additional program. (Technically, “compiling”
    to machine code is called *assembling*, although this distinction is often neglected
    or overlooked.)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器将代码转换为*字节码*，然后执行这些字节码。解释器包括一个*虚拟机*，它以类似CPU执行机器码的方式执行Python字节码。有时，为了性能原因，解释器会提前将代码转换为字节码，生成*.pyc*文件，这些文件包含字节码。虽然从某种意义上来说这是“编译”，但编译成字节码与编译成机器码之间有一个关键区别：字节码仍然需要通过解释器运行，而机器码可以直接执行，无需额外的程序。（从技术上讲，编译成机器码被称为*汇编*，尽管这个区别常常被忽略或忽视。）
- en: In practice, the majority of Python projects ship as source code, or at least
    Python bytecode, which is run in the Python interpreter installed on the user’s
    machine. There are occasions when a standard executable is preferable, such as
    for ease of installation on end-user computers or in closed-source projects. For
    those situations, tools such as *PyInstaller* and *cx_Freeze* exist. These don’t
    compile the code, but rather bundle the Python source code or bytecode with the
    interpreter so it can be executed by itself (see Chapter 18).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，大多数Python项目以源代码的形式发布，或者至少是Python字节码，并在用户机器上安装的Python解释器中运行。某些情况下，标准可执行文件更为合适，例如为了便于在最终用户计算机上安装，或者在闭源项目中。针对这些情况，存在像*PyInstaller*和*cx_Freeze*这样的工具。这些工具并不编译代码，而是将Python源代码或字节码与解释器捆绑在一起，使其能够独立执行（见第18章）。
- en: 'Myth #5: Python Is Unsuitable for Large Projects'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 神话#5：Python不适合用于大型项目
- en: I’ve heard some developers say, “Python is only useful if the whole project
    fits in one file.” This adage is partially based on the misconception that Python
    projects with multiple files are confusingly structured. This indeed tends to
    be the trend, but only because so few developers know how to correctly structure
    a Python project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我听过一些开发者说：“只有整个项目都在一个文件中，Python才有用。”这个说法部分来源于一种误解，认为包含多个文件的Python项目结构混乱。的确，这种情况有时会出现，但只是因为很少有开发者知道如何正确地组织一个Python项目。
- en: In reality, project structure in Python is far simpler than in C++ and Java.
    Once the developer understands the concepts of packages, modules, and the import
    system (see Chapter 4), working with multiple code files becomes trivial.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Python中的项目结构比C++和Java简单得多。一旦开发者理解了包、模块和导入系统的概念（见第4章），使用多个代码文件就变得轻松简单。
- en: Another reason for this myth has to do with the fact that Python is dynamically
    typed, rather than statically typed like Java or C++, which some believe makes
    refactoring harder. This doesn’t have to be the case, once the developer knows
    how to work with Python’s type system, instead of against it (see Chapter 5).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个误解的另一个原因与Python是动态类型语言有关，而不是像Java或C++那样的静态类型语言，有些人认为这使得重构变得更加困难。但事实上，只要开发者学会如何使用Python的类型系统，而不是与之对抗，这就不再是问题（见第5章）。
- en: Python 2 vs. Python 3
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 2 与 Python 3
- en: For many years, there existed two major versions of Python. Starting in 2001,
    *Python 2* was the standard, meaning most books and articles about Python were
    written for this version. The last release was Python 2.7.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Python存在两个主要版本。从2001年开始，*Python 2*是标准版本，这意味着大多数关于Python的书籍和文章都是为这个版本编写的。最后的发布版本是Python
    2.7。
- en: The current version is *Python 3*, known during its development as *Python 3000*
    or *Py3k*. From its release in 2008 until 2019, we were in a sort of limbo between
    the two versions; a lot of existing code and packages were written in Python 2,
    while Python 3 was increasingly recommended for new projects that didn’t require
    legacy support. Many techniques and tools existed for writing code that could
    run in either version, which eased the transition for many existing projects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本是*Python 3*，在开发过程中被称为*Python 3000*或*Py3k*。从2008年发布到2019年，我们处于两种版本之间的过渡期；大量现有的代码和包是用Python
    2编写的，而Python 3则越来越被推荐用于不需要遗留支持的新项目。很多技术和工具可以让代码在两种版本中都能运行，这也帮助了许多现有项目的过渡。
- en: In more recent years, especially since the release of Python 3.5, we’ve begun
    moving away from Python 2 altogether. Most major libraries officially supported
    Python 3, and legacy support became less of a priority.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在近些年，尤其是自 Python 3.5 发布以来，我们已经开始完全告别 Python 2。大多数主流库已经正式支持 Python 3，而对旧版的支持已不再是优先考虑事项。
- en: As of January 1, 2020, Python 2 has been officially retired, and Python 3 is
    the definitive standard. Since Python 4 is still nothing more than a vague wisp
    of a rumor at this point, it’s safe to say that Python 3 will be with us for years
    to come.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自2020年1月1日起，Python 2 已经正式退役，Python 3 是明确的标准。由于 Python 4 目前仍然只是一个模糊的传闻，因此可以肯定地说，Python
    3 将会陪伴我们多年。
- en: Unfortunately, many software development teams have been slow (sometimes unavoidably)
    about porting their code bases from Python 2 to Python 3\. This has left a lot
    of projects in limbo. If you use Python in a professional capacity, there is a
    good chance you’ll have to help transition some code to Python 3\. Python’s standard
    library includes a tool called *2to3*, which helps automate this process. Running
    the code through this tool is a good first step, but you will still need to manually
    update the code to use some of the newer patterns and tools Python 3 has to offer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多软件开发团队在将代码库从 Python 2 移植到 Python 3 时进展缓慢（有时是不可避免的）。这导致了许多项目处于停滞状态。如果你在专业领域使用
    Python，那么你很可能需要帮助过渡一些代码到 Python 3。Python 的标准库中有一个工具叫做 *2to3*，可以帮助自动化这个过程。通过这个工具处理代码是一个很好的第一步，但你仍然需要手动更新代码，使用一些
    Python 3 提供的新模式和新工具。
- en: Defining “Pythonic” Code
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义“Pythonic”代码
- en: Among Python developers, you’ll hear a lot of talk about *Pythonic* code and
    what it constitutes, precisely. In a general sense, idiomatic code that makes
    good use of the language’s features is considered Pythonic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 开发者中，你会听到很多关于 *Pythonic* 代码及其具体构成的讨论。一般来说，能够充分利用语言特性、符合习惯的代码被视为 Pythonic。
- en: Unfortunately, this is very much open to interpretation. As a result, the topic
    of best practices in Python is a regular source of heated debate in the community.
    Don’t be alarmed by this. By regularly grappling with our own conventions and
    standards, we continually improve them and our own understanding along the way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这一点非常容易引起不同的理解。因此，关于 Python 最佳实践的话题，常常成为社区中激烈争论的源泉。不要对此感到惊讶。通过不断地与我们自己的惯例和标准进行斗争，我们不断地改进这些惯例，并在此过程中加深对它们的理解。
- en: Our tendency to debate best practices in Python is rooted in our philosophy
    of *There’s Only One Way To Do It (TOOWTDI)*, a phrase coined by PythonLabs in
    2000 as a tongue-in-cheek response to the Perl community’s own adage of *There’s
    More Than One Way To Do It (TMTOWTDI)*. Despite the historic rivalry between these
    communities, these philosophies aren’t strictly opposing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们倾向于讨论 Python 中最佳实践的问题，这源于我们的哲学思想 *只有一种方式可以做（TOOWTDI）*，这一短语是由 PythonLabs 在2000年提出的，作为对
    Perl 社区同样格言 *有多种方式可以做（TMTOWTDI）* 的一种带有调侃性质的回应。尽管这两个社区之间有历史性的竞争，但这些哲学思想并非严格对立的。
- en: Python developers rightly assume there is some single, quantifiably “best” solution
    to any specific problem. Our task is to figure out what that solution is, but
    we also know we will often fall far short of the goal. Through continual discussion,
    debate, and experimentation, we refine our approaches in pursuit of the theoretical
    Best Solution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python 开发者通常认为，对任何特定问题，都有一个量化的“最佳”解决方案。我们的任务是找出这个解决方案，但我们也知道，我们往往会远远达不到这个目标。通过不断的讨论、辩论和实验，我们在追求理论上的最佳解决方案的过程中，逐步完善我们的方案。
- en: In the same way, the Perl community understands that it is often impossible
    to definitively arrive at that Best Solution, so they emphasize experimentation
    instead of compliance with strict standards, in an effort to discover better and
    better solutions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Perl 社区理解到，通常不可能最终得出那个“最佳解决方案”，因此他们强调实验而非遵循严格的标准，以努力发现越来越好的解决方案。
- en: 'In the end, the goal is the same: to ultimately define the best possible solution
    to a problem. Only the emphasis differs.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，目标是相同的：最终定义问题的最佳解决方案。唯一不同的是强调的重点。
- en: In this book, I’ll focus a lot on the generally accepted Pythonic ways of writing
    code. However, I don’t claim to be the final authority. My colleagues in the Python
    community will always have plenty to add to these discussions. I never fail to
    learn something new from them!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将重点讲解一般接受的 Pythonic 编程方式。然而，我并不自认为是最终的权威。我的 Python 社区同事们总会有很多值得补充的内容，我从他们那里总是能够学到新东西！
- en: The Zen of Python
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 之禅
- en: In 1999, a discussion started on the official Python mailing list about the
    need to write down some sort of formal guiding principles for the language. Tim
    Peters, a prominent member of the community, jokingly laid out a poetic summary
    of 19 principles to serve as an outline, leaving the 20th spot open for Guido
    van Rossum to complete (which he never did).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 1999年，关于需要为语言写下某种正式指导原则的讨论在Python官方邮件列表上开始了。社区中一位著名成员Tim Peters幽默地列出了19个原则的诗意总结，作为大纲，并为第20个位置留空，等待Guido
    van Rossum来补充（但他最终没有补充）。
- en: Other community members quickly seized on this summary as a fantastic overview
    of Python’s philosophy, ultimately adopting it wholesale as *The Zen of Python*.
    The entire text is published by Python as PEP 20.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其他社区成员很快就将这个总结视为Python哲学的极好概述，最终将其作为*Python之禅*完全采纳。整篇文本已作为PEP 20由Python发布。
- en: Beautiful is better than ugly.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 美丽比丑陋更好。
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显式比隐式更好。
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Simple is better than complex.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 简单比复杂更好。
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Complex is better than complicated.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 复杂比繁琐更好。
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Flat is better than nested.
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扁平比嵌套更好。
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sparse is better than dense.
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 稀疏比密集更好。
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Readability counts.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可读性很重要。
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Special cases aren’t special enough to break the rules.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 特殊情况不足以打破规则。
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although practicality beats purity.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管实用性胜过纯粹性。
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Errors should never pass silently.
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误不应悄无声息地通过。
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非明确地被静默处理。
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面对模糊性时，拒绝猜测的诱惑。
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该有一种——而且最好只有一种——显而易见的做法。
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you’re Dutch.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管如果你不是荷兰人，可能一开始并不明显。
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now is better than never.
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在比永不更好。
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although never is often better than *right* now.
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管“永不”通常比*现在就做*更好。
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the implementation is hard to explain, it’s a bad idea.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果实现难以解释，那就是一个坏主意。
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the implementation is easy to explain, it may be a good idea.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果实现容易解释，那可能是个好主意。
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea—let’s do more of those!
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名空间是一个极好的主意——让我们多做一些吧！
- en: This, too, is open to interpretation, and some argue that Tim Peters was kidding
    when he wrote The Zen of Python. However, if there’s one thing I’ve learned about
    Python developers, it’s that the line between “kidding” and “serious” is fine
    as spider silk.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点也可以有不同的解释，有人认为Tim Peters在写《Python之禅》时是在开玩笑。然而，如果有一件事我对Python开发者的了解是准确的，那就是“开玩笑”和“严肃”之间的界限就像蜘蛛丝一样细。
- en: In any case, The Zen of Python is a great place to start when talking about
    best practices in Python. Many developers, including myself, often refer back
    to it. I’ll refer to it frequently throughout this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，《Python之禅》是谈论Python最佳实践时一个很好的起点。包括我自己在内，许多开发者经常会回顾它。在本书中，我会频繁引用它。
- en: Documentation, PEPs, and You
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档、PEP与您
- en: '*Dead Simple Python* is intended as a beginning, not an ending, to your learning
    journey. Once you are well acquainted with the Python language, you can turn to
    the language’s extensive official documentation to learn more about any particular
    features or tools. These docs are found online at [https://docs.python.org/](https://docs.python.org/).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单的Python*旨在成为您学习旅程的开始，而非终点。熟悉Python语言后，您可以查阅语言的官方文档，深入了解任何特定的特性或工具。这些文档可以在线访问，网址是[https://docs.python.org/](https://docs.python.org/)。'
- en: Any new feature in Python begins its life as a *Python Enhancement Proposal*
    (PEP). Each is assigned a unique number and published to the official PEP index
    at [https://python.org/dev/peps/](https://python.org/dev/peps/). Once proposed,
    a PEP will be considered, discussed, and ultimately accepted or rejected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的任何新特性都始于*Python增强提案*（PEP）。每个PEP都会分配一个唯一的编号，并发布到官方PEP索引中，网址是[https://python.org/dev/peps/](https://python.org/dev/peps/)。一旦提出，PEP将被审议、讨论，最终决定接受还是拒绝。
- en: Accepted PEPs are effectively extensions of the documentation, as they are the
    most cohesive and authoritative descriptions of the feature(s) they define. Additionally,
    there are several Meta-PEPs and Informational PEPs that provide the backbone for
    the Python community and language.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 被接受的PEP实际上是文档的扩展，因为它们是最具凝聚力和权威性的特性定义描述。此外，还有一些元PEP和信息性PEP，它们为Python社区和语言提供了骨架。
- en: As such, the official documentation and PEP index should be the first place
    you go if you have any questions about Python. I’ll refer to these frequently
    throughout this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，官方文档和PEP索引应该是你如果对Python有任何疑问时，首先查阅的地方。在本书中，我会频繁引用这些内容。
- en: Who Calls the Shots?
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁来做决定？
- en: To understand how and why the language evolves, it is important to know who’s
    in charge. When a PEP is proposed, who gets to decide if it’s accepted or rejected?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解语言是如何以及为什么发展的，了解谁在掌控是非常重要的。当提出PEP时，谁来决定是否接受或拒绝它？
- en: Python is an open source project officially owned by the nonprofit Python Software
    Foundation. Unlike many other popular languages, no formal associations exist
    between Python and any for-profit organization.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一个由非营利的Python软件基金会正式拥有的开源项目。与许多其他流行语言不同，Python与任何盈利性组织之间没有正式的关联。
- en: As an open source project, Python is supported by an active and vibrant community.
    At its heart is the core team, the trusted volunteers who maintain the language
    and keep the community running smoothly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个开源项目，Python得到了一个活跃且充满活力的社区的支持。其核心是核心团队，这些受信任的志愿者维护语言并确保社区顺利运行。
- en: Language creator Guido van Rossum served as the Benevolent Dictator for Life
    (BDFL), making the final decisions on all PEPs and overseeing ongoing development
    of the language. In 2018, he made the decision to step down from the role.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的创始人Guido van Rossum曾担任终身仁慈独裁者（BDFL），对所有PEP做出最终决策，并监督语言的持续发展。2018年，他决定辞去这一职务。
- en: A few months after his resignation, PEP 13 was created to establish a new system
    of governance. Now the language is governed by a five-person steering committee,
    elected by the core team. Every time a new release of the language comes out,
    a new steering committee is elected.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在他辞职几个月后，PEP 13被创建，目的是建立一种新的治理系统。现在，语言由一个五人组成的指导委员会管理，委员会成员由核心团队选举产生。每当有新的语言版本发布时，都会选举新的指导委员会。
- en: The Python Community
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python社区
- en: The Python community is a vast and diverse group of individuals from all over
    the world, united by their passion for this unique language. Ever since I stumbled
    upon the community many years ago as an utter novice, I have gained immeasurable
    help, guidance, and inspiration from it and its people. I’ve been privileged to
    offer the same to others in return. This book would not have ever happened without
    the continual feedback of my Python friends!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python社区是一个庞大且多元化的群体，来自世界各地，因对这种独特语言的热情而团结在一起。多年前，当我作为一个完全的新手偶然发现这个社区时，我从其中及其成员那里得到了无尽的帮助、指导和启发。我有幸以同样的方式回馈给他人。如果没有我的Python朋友们不断的反馈，这本书根本不可能出现！
- en: 'The Python community is moderated by the core team and governed by the Python
    Code of Conduct. In short, it emphasizes open, considerate, and respectful behavior,
    summarizing itself as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python社区由核心团队进行管理，并遵循Python行为规范。简而言之，它强调开放、体贴和尊重的行为，并总结为以下内容：
- en: Overall, we’re good to each other. We contribute to this community, not because
    we have to, but because we want to. If we remember that, these guidelines will
    come naturally.
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总的来说，我们对彼此很好。我们为这个社区做贡献，不是因为我们必须，而是因为我们愿意。如果我们记住这一点，这些准则就会自然而然地遵循。
- en: I strongly encourage any developer who uses Python to plug into this vibrant
    community. One of the best ways to participate is through the Libera.Chat IRC
    `#python` chatroom. You can find guides to getting onto IRC at [https://python.org/community/](https://python.org/community/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈鼓励任何使用Python的开发者融入这个充满活力的社区。参与的最佳方式之一是通过Libera.Chat IRC `#python`聊天室。你可以在[https://python.org/community/](https://python.org/community/)找到加入IRC的指南。
- en: If you have any questions about Python, including while you read through this
    book, I recommend asking for help in the IRC channel. Chances are, you’ll find
    me and most of my technical editors there.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有任何关于Python的问题，包括在阅读本书时，我建议你在IRC频道寻求帮助。你很可能会在那找到我和我的大多数技术编辑。
- en: In Chapter 21, I’ll discuss the many facets of the Python community.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第21章，我将讨论Python社区的多个方面。
- en: The Pursuit of the One Obvious Way
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一种明显方法的追求
- en: The Python mantra “There’s Only One Way to Do It” can be quite confusing at
    first. There are many possible ways to solve any one problem. Are Pythonistas
    just too enamored with their own ideas?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python的口号“做事只有一种方式”起初可能让人感到困惑。解决同一个问题有许多可能的方式。难道Python开发者只是过于迷恋自己的想法吗？
- en: Thankfully, no. This mantra means something much more encouraging, and it’s
    something every Python developer should understand.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，不是的。这个口号意味着更具鼓励性的含义，这是每个Python开发者都应该理解的。
- en: 'Some insight comes from The Zen of Python, which includes this rather cryptic
    quip:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一些见解来自于《Python禅》，其中包括这一句相当晦涩的箴言：
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该有一种——并且最好只有一种——显而易见的方式来做这件事。
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you’re Dutch.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管这种方式一开始可能不显而易见，除非你是荷兰人。
- en: Tim Peters was, of course, referring to language creator Guido van Rossum, a
    Dutch national. As the creator of the language, Guido could usually cut right
    to the “most obvious way” of solving problems in Python, especially in the early
    days of the language.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Tim Peters 指的是编程语言的创造者 Guido van Rossum，一位荷兰国籍的程序员。作为该语言的创造者，Guido 通常能够直接找到在
    Python 中解决问题的“最明显方式”，尤其是在语言的早期阶段。
- en: This *obvious way* is Python’s term for “the best solution”—a marriage of good
    practice, clean style, and reasonable efficiency, resulting in elegant code that
    is comprehensible to even the greenest novice.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*显而易见的方式*是 Python 对“最佳解决方案”的定义——它结合了良好的实践、简洁的风格和合理的效率，最终生成优雅的代码，即使是最初学的新人也能理解。
- en: 'The details of the problem being solved will usually inform this “obvious way”:
    one situation may call for a loop, another for recursion, and yet another for
    a list comprehension. Contrary to the usual implications of the word *obvious*,
    the solution is often anything but simple to work out. The best solution is only
    obvious *once you know it*; arriving at it is where things get tricky. Most of
    us aren’t Guido.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 被解决问题的细节通常会指导这一“显而易见的方式”：一种情况可能需要循环，另一种情况可能需要递归，还有另一种情况可能需要列表推导。与*显而易见*一词的常见含义相反，解决方案通常并非易于推导。最佳解决方案只有在*知道它之后*才显而易见；到达它的过程才是最棘手的。我们大多数人都不是
    Guido。
- en: However, the *pursuit* of the “one obvious way” is a defining facet of the Python
    community, and it has had a profound impact on *Dead Simple Python*. A lot of
    the insights in this book were born out of sometimes intense debate between myself
    and my fellow Pythonistas. For this reason, I hand-selected my panel of technical
    editors from those colleagues who are commonly in opposition to me, and often
    each other, on pedantic technical points.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*追求*“唯一显而易见的方式”是 Python 社区的一个重要特征，这对*Dead Simple Python*产生了深远的影响。书中的许多洞见源自我与我的
    Python 朋友们之间有时激烈的辩论。正因如此，我从那些通常与我意见相左，并且在一些细节问题上常常彼此争论的同事中，精心挑选了我的技术编辑小组。
- en: Anything ultimately adopted as the “right way” to solve a problem is usually
    accepted as such because of its technical merit, rather than because of some like-minded
    bias among Python developers, who are among the most exacting folks I’ve had the
    privilege of working with. This approach to logic overflows into every other conversation
    we have (which leads to some rather amazing and enlightening academic debates).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最终被采纳为“正确方式”的任何解决方案，通常都是因为它的技术优点，而非因为 Python 开发者之间的相似偏见，毕竟他们是我曾有幸合作过的最严格的群体。这种注重逻辑的做法渗透到我们每一次的讨论中（这也引发了一些相当惊人和富有启发性的学术辩论）。
- en: New situations present themselves regularly. There will never come a point in
    any Python developer’s career when coding becomes truly “easy.” Situations will
    arise in every project that demand careful consideration, and often, debate. Developers
    must attempt to solve problems in the way that seems most obvious to them, then
    submit the solution to the critique of peers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 新的情况会不断出现。在任何 Python 开发者的职业生涯中，都不会有某一时刻编码变得真正“简单”。每个项目都会出现需要仔细考虑的问题，且往往会引发争论。开发者必须尝试以对他们来说最显而易见的方式解决问题，然后将解决方案提交给同行的批评。
- en: The approaches in this book are, in many cases, the most obvious according to
    my view. Most have been seconded by my colleagues, yet I dare not assert that
    I am altogether “Dutch” in the Python sense. If you find yourself debating techniques
    in the Python community, please do not wave this book in anyone’s face as evidence
    that your solution is best! Skill in finding an obvious solution is not something
    that can be taught; rather it is only learned through practice.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的方法在许多情况下，按照我的看法，是最明显的。大多数方法也得到了我的同事们的认同，但我敢不敢断言自己在 Python 的意义上完全是“荷兰人”。如果你发现自己在
    Python 社区内辩论技术，请不要拿这本书去向任何人证明你的解决方案是最好的！找到一个显而易见的解决方案的技巧不是可以教授的；它只有通过实践才能学会。
- en: Wrapping Up
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Despite the many myths that have been tossed around over the years, Python is
    a versatile and technically sound language, capable of handling just about any
    problem you can throw at it. It’s a solid choice, whether you are writing automation,
    crunching massive datasets, building native user applications, implementing machine
    learning, or crafting web applications and APIs. Most importantly, Python is backed
    by a vibrant, diverse, and helpful community.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多年来有许多关于 Python 的误解，Python 依然是一种多功能且技术上可靠的语言，能够处理你能想到的几乎任何问题。无论你是在编写自动化脚本、处理海量数据、构建本地用户应用、实现机器学习，还是开发
    web 应用和 API，Python 都是一个稳妥的选择。最重要的是，Python 拥有一个充满活力、多元化并且乐于助人的社区。
- en: The key to success, then, is writing Python code that makes the most of the
    strengths and features of the language. The goal is not simply to write code that
    works, but to write code that both looks and behaves elegantly. The rest of this
    book will teach you how to do exactly that.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的关键在于编写能够充分利用语言优点和特性的 Python 代码。目标不仅仅是编写能工作的代码，而是编写既优雅又高效的代码。本书接下来的内容将教你如何做到这一点。
- en: '2'
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Your Workbench
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工作台
- en: '![](Images/chapterart.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Your development environment is a major factor in how productive you’ll be in
    a language. Instead of contenting yourself with a bare-bones default shell, you’ll
    want to assemble a development environment worthy of any production-level project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的开发环境是你在某种语言中提高生产力的关键因素。你不仅仅满足于使用一个简单的默认 shell，而是要搭建一个足以应对任何生产级项目的开发环境。
- en: A good Python development environment usually consists of the language interpreter,
    the pip package manager, a *virtual environment*, a Python-oriented code editor,
    and one or more *static analyzers* to check your code for errors and problems.
    I’ll discuss each of these in this chapter. I’ll also introduce the style conventions
    common in Python and round out the chapter with a guided tour of the most common
    Python integrated development environments (IDEs).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的 Python 开发环境通常包括语言解释器、pip 包管理器、*虚拟环境*、面向 Python 的代码编辑器以及一个或多个*静态分析工具*，用于检查代码中的错误和问题。我将在本章中讨论这些内容。我还将介绍
    Python 中常见的编码风格，并带领你参观最常用的 Python 集成开发环境（IDEs）。
- en: Installing Python
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Python
- en: Before you can do anything, you have to install Python itself, along with a
    couple of essential tools. As you know from Chapter 1, Python is an interpreted
    language, so you’ll need to install its *interpreter*. You must also install pip,
    the Python package manager, so you can install additional Python tools and libraries.
    The exact steps for setup depend on your platform, but I will cover the major
    platforms here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何操作之前，你需要先安装 Python 及一些必要的工具。如同你在第一章所了解到的，Python 是一种解释型语言，因此你需要安装它的*解释器*。你还需要安装
    pip，这是 Python 的包管理器，它可以帮助你安装其他的 Python 工具和库。具体的安装步骤取决于你所使用的平台，但我将在这里介绍主要平台的安装方式。
- en: In this book, I’m using Python 3.9, the latest version at the time of writing.
    If you’re reading this at a later date, just use the latest stable release of
    Python 3\. All the instructions should work the same. You need only replace the
    version number in the obvious ways on any commands run in the command line.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我使用的是 Python 3.9，这是写作时的最新版本。如果你在稍后的时间阅读本书，请使用 Python 3 的最新稳定版本。所有的指令应该都能正常工作。你只需要在命令行运行时，根据需要替换版本号即可。
- en: This is merely a quick guide to installation. For the complete, official instructions,
    which cover many more situations and advanced options, see [https://docs.python.org/using/](https://docs.python.org/using/).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个快速安装指南。关于更多情况和高级选项的完整官方说明，请参阅[https://docs.python.org/using/](https://docs.python.org/using/)。
- en: Installing on Windows
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 上安装
- en: On Windows, Python is not generally installed by default, so you’ll need to
    download it yourself from [https://python.org/downloads/windows/](https://python.org/downloads/windows/)
    and run that installer. On the first screen of the installer, be sure you check
    the boxes for **Install the launcher for all users** and **Add Python to PATH**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，Python 通常不会默认安装，因此你需要从[https://python.org/downloads/windows/](https://python.org/downloads/windows/)
    下载并运行安装程序。在安装程序的第一个界面上，请确保勾选**为所有用户安装启动器**和**将 Python 添加到 PATH**。
- en: Python is also available through the Windows App Store. However, as of the date
    of my writing, this particular installation method is still officially considered
    unstable. I recommend downloading the official installer instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也可以通过 Windows 应用商店获取。然而，截止我写作时，这种安装方法仍然被官方认为是不稳定的。我建议你下载官方的安装程序。
- en: Installing on macOS
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 macOS 上安装
- en: On macOS, you can use either MacPorts or Homebrew to install Python and pip.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你可以使用 MacPorts 或 Homebrew 安装 Python 和 pip。
- en: 'Use the following commands to install Python and pip with MacPorts, replacing
    the `38` with whatever version you want to download (removing the decimal point):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令通过 MacPorts 安装 Python 和 pip，将 `38` 替换为你希望下载的版本号（去掉小数点）：
- en: '[PRE0]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, here’s the command to install both Python and pip in one step
    with Homebrew:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下命令通过 Homebrew 一次性安装 Python 和 pip：
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use only one of the two methods described above.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用上面描述的两种方法中的一种。
- en: Installing on Linux
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装
- en: If you’re running a Linux operating system, chances are that Python (`python3`)
    is installed by default, although the other tools you need may not be. (I’ll show
    you how to install Python anyway, just to be on the safe side.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行 Linux 操作系统，Python（`python3`）通常会默认安装，但你可能需要安装其他工具。（我会向你展示如何安装 Python，确保万无一失。）
- en: 'To install Python and pip on Ubuntu, Debian, or related, run this command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu、Debian 或相关发行版上安装 Python 和 pip，运行以下命令：
- en: '[PRE2]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On Fedora, RHEL, or CentOS, you can run this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora、RHEL 或 CentOS 上，你可以运行以下命令：
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On Arch Linux, run this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arch Linux 上，运行以下命令：
- en: '[PRE4]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For other distributions, you’ll need to search for the Python 3 and pip packages
    yourself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他发行版，你需要自行搜索 Python 3 和 pip 包。
- en: Installing from Source
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码安装
- en: If you’re running a UNIX-like system, and if your system either has an outdated
    version of Python 3 in the system packages or lacks a package manager altogether,
    you can build Python from source. This is how I usually install the latest Python.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行的是类 UNIX 系统，并且系统中要么包含了过时的 Python 3 版本，要么完全没有包管理器，你可以从源代码编译安装 Python。这通常是我安装最新版本
    Python 的方式。
- en: Installing Dependencies
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: On macOS, there are some relatively complex considerations when it comes to
    installing Python’s build dependencies. You should consult the documentation at
    [https://devguide.python.org/setup/#macos-and-os-x](https://devguide.python.org/setup/#macos-and-os-x).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，安装 Python 的构建依赖项时会有一些相对复杂的考虑事项。你应该参考 [https://devguide.python.org/setup/#macos-and-os-x](https://devguide.python.org/setup/#macos-and-os-x)
    上的文档。
- en: On most Linux systems, you will need to make sure you have the development files
    for several libraries that Python relies upon. The best way to install these depends
    on your system and, more specifically, which package manager you use.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Linux 系统上，你需要确保安装了 Python 依赖的几个库的开发文件。安装这些文件的最佳方法取决于你的系统，具体来说，取决于你使用的包管理器。
- en: If you’re on a Linux distribution that uses the APT package manager—such as
    Ubuntu, Pop!_OS, Debian, or Linux Mint—then you should either check the box to
    enable Source Code as a source in your Software Sources or Software & Updates
    settings or make sure you have it included in your *sources.list* file. (The exact
    method depends on your system, and that topic is beyond the scope of this book.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux 发行版并且采用 APT 包管理器——比如 Ubuntu、Pop!_OS、Debian 或 Linux Mint——那么你应该在软件源或软件与更新设置中勾选启用源代码作为源，或者确保它已经包含在你的*sources.list*
    文件中。（具体方法取决于你的系统，这部分内容超出了本书的讨论范围。）
- en: 'Then, run the following commands:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you get the message `Unable to find a source package for python3.9`, change
    the `9` to a lower (or higher) number until you find one that works. The dependencies
    for Python 3 don’t really change much between minor versions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到信息 `无法找到 python3.9 的源包`，将 `9` 改为较低（或较高）版本号，直到找到一个能正常工作版本。Python 3 的依赖项在次版本之间变化不大。
- en: 'If your Linux distribution uses the DNF package manager, such as if you’re
    on modern Fedora, RHEL, or CentOS, run the following commands:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Linux 发行版使用的是 DNF 包管理器，比如在现代 Fedora、RHEL 或 CentOS 上，运行以下命令：
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you’re on an older version of Fedora or RHEL that uses the yum package manager,
    run the following commands:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是较旧版本的 Fedora 或 RHEL，且使用的是 yum 包管理器，运行以下命令：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you’re on SUSE Linux, you’ll have to install the dependencies, including
    needed libraries, one by one. [Table 2-1](#table2-1) lists these dependencies.
    If you’re on another UNIX-based system, this list will be helpful, although you
    may need to change the package names or build the dependencies from source.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 SUSE Linux，你需要逐一安装依赖项，包括所需的库。[表 2-1](#table2-1)列出了这些依赖项。如果你使用的是其他基于
    UNIX 的系统，这个列表也会有帮助，尽管你可能需要更改软件包名称或从源代码构建依赖项。
- en: 'Table 2-1: Python 3 Build Dependencies According to SUSE Linux'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1：根据 SUSE Linux 构建 Python 3 的依赖项
- en: '| automake | intltool | netcfg |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| automake | intltool | netcfg |'
- en: '| fdupes | libbz2-devel | openssl-devel |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| fdupes | libbz2-devel | openssl-devel |'
- en: '| gcc | libexpat-devel | pkgconfig |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| gcc | libexpat-devel | pkgconfig |'
- en: '| gcc-c++ | libffi-devel | readline-devel |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| gcc-c++ | libffi-devel | readline-devel |'
- en: '| gcc-fortran | libnsl-devel | sqlite-devel |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| gcc-fortran | libnsl-devel | sqlite-devel |'
- en: '| gdbm-devel | lzma-devel | xz |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| gdbm-devel | lzma-devel | xz |'
- en: '| gettext-tools | make | zlib-devel |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| gettext-tools | make | zlib-devel |'
- en: '| gmp-devel | ncurses-devel |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| gmp-devel | ncurses-devel |  |'
- en: Downloading and Building Python
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下载和构建 Python
- en: You can download the Python source as a Gzipped source tarball, which is a compressed
    file (*.tgz*), from [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/).
    I usually like to move this tarball file into a dedicated directory for Python
    source tarballs, especially as I tend to have multiple versions of Python at any
    one time. Within that directory, extract (uncompress) this file with `tar -xzvf
    Python-3.x.x.tgz`, substituting the name of the tarball you downloaded.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[https://www.python.org/downloads/source/](https://www.python.org/downloads/source/)下载
    Python 源代码的 Gzipped 压缩源 tar 包（*.tgz* 文件）。我通常喜欢将这个 tar 包文件移到专门的 Python 源代码 tar
    包目录中，特别是当我同时拥有多个版本的 Python 时。在该目录中，用`tar -xzvf Python-3.x.x.tgz`解压（解压缩）此文件，替换你下载的
    tar 包名称。
- en: 'Next, from within the extracted directory, run the following, ensuring that
    each command succeeds before running the next one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从解压后的目录中运行以下命令，确保每个命令成功执行后再运行下一个命令：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should configure Python for normal use, ensure it won’t encounter any errors
    in the current environment, and then install it *alongside* any existing Python
    installations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将配置 Python 以便正常使用，确保在当前环境中不会遇到任何错误，然后将其安装到*与*现有的 Python 安装一起。
- en: Once the installation is complete, you can use Python right away.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以立即使用 Python。
- en: Meet the Interpreter
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认识解释器
- en: Now that you’ve installed that interpreter, you can run Python scripts and projects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了该解释器，可以运行 Python 脚本和项目了。
- en: Interactive Session
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式会话
- en: 'The interpreter’s *interactive session* allows you to enter and run code in
    real time and see the outcomes. You can start an interactive session on the command
    line with this command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器的*交互式会话*允许你实时输入和运行代码，并查看结果。你可以通过以下命令在命令行中启动交互式会话：
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Although the above should work on Windows, the same as on any other system,
    the Python documentation recommends the following alternative on Windows instead:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上述方法在 Windows 上也应该有效，就像在其他任何系统上一样，但 Python 文档推荐在 Windows 上使用以下替代方法：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just to keep everything system-agnostic, I’ll use `python3` throughout the rest
    of this book.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持系统无关性，我将在本书其余部分中使用`python3`。
- en: 'When you start the interactive session, you should see something that looks
    similar to this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动交互式会话时，你应该看到类似这样的内容：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enter any Python code you want at the prompt `>`, and the interpreter will
    run it immediately. You can even enter multiline statements, such as conditional
    statements, and the interpreter will know more lines are expected before it runs
    the code. You’ll see the three-dot (`...`) prompt when the interpreter is waiting
    for more lines. When you’re done, press Enter on a blank line, and the interpreter
    will run the whole block:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符`>`下输入任何你想运行的 Python 代码，解释器会立即执行。你甚至可以输入多行语句，如条件语句，解释器会知道在执行代码之前还需要更多的行。当解释器等待更多行时，你会看到三个点（`...`）的提示符。当你完成后，按空白行上的回车键，解释器将执行整个代码块：
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To quit the interactive session, run this command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出交互式会话，运行以下命令：
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The interactive session is useful for testing things out in Python, but not
    much else. You should know of its existence moving forward, but I won’t use it
    much in this book. Instead, you should be using a proper code editor.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式会话对于在 Python 中测试一些东西非常有用，但其他方面并不多。你应该了解它的存在，但在本书中我不会多用它。相反，你应该使用一个合适的代码编辑器。
- en: Running Python Files
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 Python 文件
- en: You write scripts and programs in a text or code editor. I’ll introduce several
    code editors and IDEs at the end of this chapter, but in the meantime, you can
    use your favorite text editor for writing your code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您在文本或代码编辑器中编写脚本和程序。我将在本章结尾介绍几种代码编辑器和 IDE，但在此之前，您可以使用您喜欢的文本编辑器来编写代码。
- en: 'Python code is written in *.py* files. To run a Python file (*myfile.py*, for
    example), you’d use this in the command line (*not* the interpreter):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Python 代码是写在*.py*文件中的。要运行 Python 文件（例如*myfile.py*），您可以在命令行中使用此命令（*而不是*解释器）：
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Packages and Virtual Environments
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包和虚拟环境
- en: A *package* is a collection of code, which is analogous to a library in most
    other programming languages. Python is rather famous for being “batteries included,”
    since most things “just work” with a simple `import` statement. But if you need
    to do something beyond the basics, such as creating a snazzy user interface, you
    often have to install a package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*包*是代码的集合，类似于大多数其他编程语言中的库。Python 因为“开箱即用”而广受欢迎，因为大多数东西通过简单的`import`语句“就能正常工作”。但是，如果您需要做一些基本操作之外的事情，比如创建一个华丽的用户界面，通常需要安装一个包。'
- en: Thankfully, installing most third-party libraries is easy. Library authors bundle
    their libraries into packages, which can be installed using the handy little pip
    package manager tool that we installed earlier. I’ll cover that tool later.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，安装大多数第三方库非常简单。库的作者将他们的库打包成包，可以使用我们之前安装的便捷工具 pip 包管理器来安装这些包。我稍后会介绍这个工具。
- en: Using multiple third-party packages requires a bit of finesse. Some packages
    require other packages to be installed first. Certain packages have conflicts
    with other packages. You can also install specific versions of a package, depending
    on what exactly you need. Did I mention that some of the applications and operating
    system components on your computer rely on certain Python packages? This is why
    virtual environments exist.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个第三方包需要一些技巧。有些包需要先安装其他包。某些包与其他包之间存在冲突。您还可以根据需要安装特定版本的包。我提到过，您计算机上的一些应用程序和操作系统组件依赖于某些
    Python 包吗？这就是虚拟环境存在的原因。
- en: A *virtual environment* is a sandbox where you can install only the Python packages
    you need for a particular project, without the risk of those packages clashing
    with those for another project (or your system). You create different little sandboxes
    for each project and install only the packages you want in it. Everything stays
    neatly organized. You never actually change what Python packages are installed
    on your system, so you avoid breaking important things that have nothing to do
    with your project.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟环境*是一个沙箱，您可以在其中仅安装某个特定项目所需的 Python 包，而不必担心这些包与其他项目（或您的系统）中的包发生冲突。您为每个项目创建不同的小沙箱，并仅在其中安装您需要的包。一切都保持井井有条。您实际上从未更改过系统上安装的
    Python 包，因此可以避免破坏与项目无关的重要内容。'
- en: You may even create virtual environments that have nothing to do with a particular
    project. For example, I have a dedicated virtual environment for running random
    code files in Python 3.10, with a particular set of tools I use for finding problems.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以创建与特定项目无关的虚拟环境。例如，我有一个专门的虚拟环境，用于在 Python 3.10 中运行随机代码文件，并配备了我用来查找问题的特定工具。
- en: Creating a Virtual Environment
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: Each virtual environment resides in a dedicated directory. Conventionally, we
    name this folder *env* or *venv*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟环境都驻留在一个专门的目录中。通常，我们将这个文件夹命名为*env*或*venv*。
- en: For each project, I typically like to create a dedicated virtual environment
    inside the project folder. Python provides a tool called *venv* for this.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个项目，我通常喜欢在项目文件夹中创建一个专门的虚拟环境。Python 提供了一个名为*venv*的工具来实现这一点。
- en: If you use Git or another *version control system* *(VCS)* for tracking changes
    to your code, there’s an additional setup step I’ll get to in a moment.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Git 或其他*版本控制系统*（*VCS*）来跟踪代码的变化，接下来我会介绍一个额外的设置步骤。
- en: 'To create the virtual environment with the name `venv` in the current working
    directory, run the following command in the command line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要在当前工作目录中创建名为`venv`的虚拟环境，请在命令行中运行以下命令：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first `venv` ❶ is a command that creates a virtual environment, and the
    second `venv` ❷ is the desired path to the virtual environment. In this case,
    `venv` is just a relative path, creating a *venv/* directory in the current working
    directory. However, you could also use an absolute path, and you could call it
    whatever you want. For example, you could create a virtual environment called
    *myvirtualenv* in the */opt* directory of a UNIX system, like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`venv` ❶是创建虚拟环境的命令，第二个`venv` ❷是虚拟环境的目标路径。在这种情况下，`venv`只是一个相对路径，会在当前工作目录中创建一个*venv/*目录。不过，你也可以使用绝对路径，并且可以随意命名。例如，你可以在
    UNIX 系统的*/opt*目录下创建一个名为*myvirtualenv*的虚拟环境，像这样：
- en: '[PRE16]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note, I’m specifying `python3` here, although I can run this with whatever Python
    version I want to use, such as `python3.9 -m venv venv`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在这里指定了`python3`，尽管我可以使用任何我想要的 Python 版本来运行，例如`python3.9 -m venv venv`。
- en: 'If you use something older than Python 3.3, make sure you install your system’s
    `virtualenv` package and then use this command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Python 3.3 以前的版本，请确保先安装系统的`virtualenv`包，然后使用以下命令：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now if you look at your working directory, you’ll notice that the directory
    *venv/* has been created.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看工作目录，你会注意到已经创建了*venv/*目录。
- en: Activating a Virtual Environment
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活虚拟环境
- en: To use your virtual environment, you need to activate it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用虚拟环境，你需要激活它。
- en: 'On UNIX-like systems, run this command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 UNIX 系统上，运行以下命令：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On Windows, run this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，运行以下命令：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, if you use PowerShell on Windows, run this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你在 Windows 上使用 PowerShell，请运行以下命令：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Some PowerShell users must first run `set-executionpolicy RemoteSigned` for
    virtual environments to work on Windows PowerShell. If you run into trouble, try
    this.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 PowerShell 用户必须首先运行`set-executionpolicy RemoteSigned`，以便在 Windows PowerShell
    上使虚拟环境生效。如果遇到问题，可以尝试这个方法。
- en: Like magic, you’re now using your virtual environment! You should see `(venv)`
    at the start of your command line prompt (not at the end), to indicate that you’re
    using a virtual environment named `venv`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 就像魔法一样，你现在正在使用你的虚拟环境！你应该能在命令行提示符的开始看到`(venv)`（而不是在末尾），这表示你正在使用名为`venv`的虚拟环境。
- en: While inside your virtual environment, you can still access all the same files
    on your system that you use outside the virtual environment, but your environment
    *paths* will be overridden by the virtual environment. Practically speaking, any
    packages you install in the virtual environment are only usable there, and from
    the `venv`, the system-wide packages cannot be accessed unless you explicitly
    specify otherwise.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境中，你仍然可以访问系统上所有与你在虚拟环境外使用的文件相同的文件，但你的环境*路径*会被虚拟环境所覆盖。实际上，任何你在虚拟环境中安装的包只能在虚拟环境中使用，而从`venv`中无法访问系统范围的包，除非你明确指定否则。
- en: If you want the virtual environment to also see the system-wide packages, you
    can do so with a special flag, which has to be set when you first create the virtual
    environment. You can’t change this after the virtual environment is created.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望虚拟环境也能看到系统范围的包，可以通过一个特殊标志来实现，这个标志必须在首次创建虚拟环境时设置。创建虚拟环境后无法更改此设置。
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Leaving a Virtual Environment
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退出虚拟环境
- en: To get out of the virtual environment and back to reality . . . er, *ahem*,
    the system, you need a simple command.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出虚拟环境并返回现实……呃，*咳咳*，系统，只需执行一个简单的命令。
- en: 'You ready for this, UNIX users? Just run this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗，UNIX 用户？只需运行以下命令：
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That really is it. The same works for Windows PowerShell users.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。Windows PowerShell 用户也可以按此操作。
- en: 'Things are only slightly more complicated on the Windows command line:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 命令行中，情况稍微复杂一些：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Still pretty painless. Remember, like with activation, if you named your virtual
    environment something else, you’d have to change the `venv` in that line accordingly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 还是挺简单的。记住，就像激活一样，如果你给虚拟环境取了别的名字，你需要相应地修改那行中的`venv`。
- en: Introducing pip
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 pip
- en: Most of us have great expectations for Python’s package system. Python’s package
    manager is *pip*, which usually makes package installation trivial, especially
    in virtual environments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人对 Python 的包管理系统有很高的期望。Python 的包管理工具是*pip*，通常使得包的安装变得简单，特别是在虚拟环境中。
- en: System-Wide Packages
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统范围的包
- en: 'Remember, for any Python development work, you should almost always work in
    virtual environments. This will ensure that you’re always using the right packages
    for your work, without potentially messing up which packages (and versions thereof)
    are available to other programs on your computer. If you absolutely, positively
    know you want to install packages in your system-wide Python environment, you
    may use pip for that as well. First, make sure you are *not* working in a virtual
    environment, and then use this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于任何 Python 开发工作，你几乎总是应该在虚拟环境中工作。这将确保你始终使用适合你工作所需的正确包，而不会无意中搞乱其他程序在你计算机上使用的包（及其版本）。如果你绝对确定要在系统范围的
    Python 环境中安装包，你也可以使用 pip。首先，确保你*没有*在虚拟环境中工作，然后使用以下命令：
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Replace the `command` with your pip commands, which I’ll cover next.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `command` 替换为你的 pip 命令，接下来我将介绍这些命令。
- en: Installing Packages
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装包
- en: 'To install a package, run `pip install` `package`. For example, to install
    PySide6 within an activated virtual environment, you’d use this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装一个包，运行 `pip install` `package`。例如，要在已激活的虚拟环境中安装 PySide6，你可以使用以下命令：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you want to install a specific version of something, append two equal signs
    (`==`), followed by the desired version number (no spaces):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想安装某个特定版本的包，可以在包名后加上两个等号（`==`），然后是所需的版本号（不加空格）：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Bonus: you can even use operators like `>=`, to mean “at least this version
    or greater.” These are called *requirement specifiers*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 额外提示：你甚至可以使用像 `>=` 这样的操作符，表示“至少这个版本或更高版本”。这些被称为 *需求规范符*。
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That line would install the latest version of PySide6 that is at least version
    `6.1.2`. This is really helpful if you want the most recent version of a package
    but also want to ensure you at least install a *minimum* version of a package
    (you might not). If it isn’t possible to install a version of the package that
    meets the requirement, pip will display an error message.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这行命令将安装至少是 `6.1.2` 版本的 PySide6 最新版本。如果你想要一个包的最新版本，但同时确保至少安装一个包的*最小*版本，这非常有用（即使你不一定需要它）。如果无法安装满足要求的包的版本，pip
    将显示错误信息。
- en: If you’re on a UNIX-like system, you may need to use `pip install "PySide6>=6.1.2"`
    instead, since `>` has another meaning in the shell.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是类 UNIX 系统，可能需要改用 `pip install "PySide6>=6.1.2"`，因为 `>` 在 shell 中有其他含义。
- en: requirements.txt
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: requirements.txt
- en: You can save even more time for yourself and others by writing a *requirements.txt*
    file for your project. This file lists the packages your project needs. When creating
    a virtual environment, you and other users can install all the required packages
    with a single command, using this file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过为你的项目编写一个 *requirements.txt* 文件来节省更多时间。这个文件列出了项目所需的包。在创建虚拟环境时，你和其他用户可以通过一个命令安装所有必需的包。
- en: 'To create this file, list the name of a pip package, as well as its version
    (if required), on each line. For example, one of my projects has a *requirements.txt*
    file like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个文件，在每一行列出一个 pip 包的名称，以及它的版本（如果需要）。例如，我的一个项目有一个这样的 *requirements.txt* 文件：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 2-1: *requirements.txt*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-1： *requirements.txt*
- en: 'Now anyone can install all those packages in one shot with this command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在任何人都可以通过以下命令一次性安装所有这些包：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I’ll revisit *requirements.txt* in Chapter 18, when I cover packaging and distribution.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第 18 章回顾 *requirements.txt*，在那一章我会讲解打包和分发。
- en: Upgrading Packages
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级包
- en: 'You can update an already-installed package with pip as well. For example,
    to update to the latest version of PySide6, run this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 pip 更新已安装的包。例如，要更新到 PySide6 的最新版本，运行以下命令：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you have a *requirements.txt* file, you can also upgrade all your required
    packages at once:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 *requirements.txt* 文件，也可以一次性升级所有必需的包：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Removing Packages
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除包
- en: 'You can remove packages with this command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令删除包：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Replace `package` with the package name.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `package` 替换为包名。
- en: There is one minor wrinkle. Installing one package will also install any other
    packages it relies upon, which we call its *dependencies*. Uninstalling a package
    does not remove its dependencies, so you may need to go through and remove them
    yourself. This can get tricky, since multiple packages may share dependencies
    and you therefore risk breaking a separate package.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个小小的复杂之处。安装一个包时，还会安装它所依赖的其他包，我们称之为 *依赖包*。卸载一个包并不会移除其依赖包，因此你可能需要手动去删除它们。这可能会变得复杂，因为多个包可能共享依赖包，因此你可能会破坏其他包。
- en: Herein lies one more advantage of virtual environments. Once I’m in that sort
    of a pickle, I can delete the virtual environment, create a new one, and install
    only those packages I need.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是虚拟环境的另一个优势。一旦我陷入这种困境，我可以删除虚拟环境，创建一个新的，并仅安装我需要的那些包。
- en: Finding Packages
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找包
- en: Great, so now you can install, upgrade, and remove things. But how do you even
    know what packages pip has to offer?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在你可以安装、升级和移除软件包了。但你怎么知道 pip 提供了哪些包呢？
- en: 'There are two ways to find out. The first is to use pip itself to run a search.
    Say you want a package for web scraping. Run this command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以找出你需要的包。第一种是使用 pip 本身运行搜索。假设你想要一个用于网页抓取的包。运行以下命令：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That will give you a whole ton of results to sift through, but it’s helpful
    at those times when you simply forget the name of a package.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给你一大堆结果需要筛选，但在你忘记某个包的名字时，它会很有帮助。
- en: If you want something a lot more browsable and informative, [https://pypi.org/](https://pypi.org/%20)
    is the official Python Package Index.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更易浏览且更有信息量的内容，[https://pypi.org/](https://pypi.org/%20) 是官方的 Python 包索引。
- en: One Warning About pip . . .
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于 pip 的一个警告……
- en: Unless you have expertise in the full technical implications, ***never*** use
    `sudo pip` on a UNIX-like system! It can do so many bad things to your system
    installation—things that your system package manager cannot correct—that if you
    decide to use it, you will regret it for the remainder of your system’s lifetime.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你对技术细节有充分的了解，否则***绝对不要***在类 UNIX 系统上使用 `sudo pip`！它可能会对你的系统安装造成很多不良影响——这些问题是你的系统包管理器无法修复的——如果你决定使用它，你会后悔一辈子。
- en: Usually, when someone thinks they need to use `sudo pip`, they should really
    use `python3 -m pip` or `pip install --user` to install to their local user directory.
    Most other problems can be solved with virtual environments. Unless you’re an
    expert who fully understands what you’re doing and how to reverse it, don’t *ever*
    use `sudo pip`!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当有人觉得他们需要使用 `sudo pip` 时，他们实际上应该使用 `python3 -m pip` 或 `pip install --user`
    来安装到本地用户目录。大多数其他问题可以通过虚拟环境来解决。除非你是一个完全了解自己在做什么以及如何恢复的专家，否则*永远不要*使用 `sudo pip`！
- en: Virtual Environments and Git
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟环境和 Git
- en: Working with virtual environments and a VCS, like Git, can be tricky. Within
    a virtual environment’s directory are the *actual packages* you installed with
    pip. Those would clutter up your VCS repository with big, unnecessary files, and
    you can’t necessarily copy a virtual environment folder from one computer to another
    and expect it to work anyway.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟环境和版本控制系统（如 Git）可能会有些棘手。在虚拟环境目录中包含了你通过 pip 安装的*实际包*。这些会让你的 VCS 仓库充满大而不必要的文件，而且你不一定能够将虚拟环境文件夹从一台计算机复制到另一台并期望它能正常工作。
- en: 'Thus, you *don’t* want to track these files in your VCS. There are two solutions:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你*不*想在版本控制系统中追踪这些文件。有两种解决方案：
- en: Only create virtual environments outside of your repository.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只在你的仓库之外创建虚拟环境。
- en: Untrack the virtual environment directory in the VCS.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在版本控制系统（VCS）中取消追踪虚拟环境目录。
- en: There are arguments in favor of both rules, but which one you should use really
    depends on your project, environment, and particular needs.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条规则各有支持的理由，但你应该使用哪一种，实际上取决于你的项目、环境和具体需求。
- en: 'If you’re using Git, create or edit a file called *.gitignore* in the root
    directory of your repository. Add this line somewhere in it:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Git，在仓库的根目录下创建或编辑一个名为 *.gitignore* 的文件。并在其中添加以下这一行：
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 2-2: *.gitignore*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 2-2: *.gitignore*'
- en: If you used a different name for your virtual environment, change that line
    to match. If you’re using a different VCS, like Subversion or Mercurial, check
    the documentation to see how to ignore a directory like *venv*.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为虚拟环境使用了不同的名称，请将这一行更改为匹配。如果你使用的是不同的版本控制系统，如 Subversion 或 Mercurial，请查阅文档以了解如何忽略像
    *venv* 这样的目录。
- en: Conventionally, every developer who clones your repository will build their
    own virtual environment, probably using that *requirements.txt* file you provided.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 按常规，每个克隆你仓库的开发者都会构建自己的虚拟环境，通常会使用你提供的 *requirements.txt* 文件。
- en: Even if you plan to place your virtual environments outside of the repository,
    it’s good to use your *.gitignore* file, just as a little extra insurance. Best
    VCS practice is to handpick which files to commit, but mistakes happen. Since
    *venv* is one of the most conventional names for a virtual environment directory,
    adding it to the *.gitignore* at least helps prevent some accidental commits.
    If your team has other standard names for virtual environments, you might consider
    adding those as well.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你计划将虚拟环境放置在仓库之外，使用 *.gitignore* 文件仍然是一个好的选择，这只是一个额外的保险措施。最佳的版本控制实践是精心挑选需要提交的文件，但错误总是难免发生。由于
    *venv* 是虚拟环境目录最常见的名字之一，将其添加到 *.gitignore* 至少可以防止一些意外的提交。如果你的团队有其他标准的虚拟环境名称，你可能也可以考虑将这些名称添加进去。
- en: The Whole Shebang
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整的 Shebang
- en: Many users and developers who might be running your code will also be using
    virtual environments. Yet all of this can come apart at the seams very easily
    if the very first line of your Python file is wrong.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用户和开发者可能会在使用你的代码时也会使用虚拟环境。然而，如果你的 Python 文件的第一行有问题，所有这些都可能很容易出错。
- en: 'I’m talking about the *shebang*, a special command at the top of a Python file,
    by which you can make that file directly executable:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我在讲的是 *shebang*，这是一个位于 Python 文件顶部的特殊命令，通过它你可以让文件直接变得可执行：
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 2-3: *hello_world.py*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-3: *hello_world.py*'
- en: 'The shebang (short for haSH-BANG, or `#!`) ❶ provides the path to the Python
    interpreter. While it’s optional, I strongly recommend including it in your code,
    as it means the file can be marked as executable and run directly, like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: shebang（即 haSH-BANG，或 `#!`）❶ 提供了 Python 解释器的路径。虽然它是可选的，但我强烈建议在代码中包括它，因为这意味着文件可以标记为可执行并直接运行，如下所示：
- en: '[PRE36]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is helpful, but as I’ve hinted before, one must be careful with shebangs.
    A shebang tells the computer where to find the exact Python interpreter to use,
    so the wrong shebang can break out of the confines of a virtual environment or
    even point to a version of the interpreter that isn’t installed.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有帮助，但正如我之前提到的，必须小心使用 shebang。shebang 告诉计算机在哪里找到准确的 Python 解释器，所以错误的 shebang
    可能会突破虚拟环境的限制，甚至指向一个未安装的解释器版本。
- en: 'You may have seen this kind of shebang in the wild:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在实际使用中看到过这种 shebang：
- en: '[PRE37]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 2-4: *shebang.py:1a*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-4: *shebang.py:1a*'
- en: That line is terribly wrong, because it forces the computer to use a particular
    system-wide copy of Python. Again, that dismisses the entire purpose of a virtual
    environment.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 那一行是非常错误的，因为它强制计算机使用特定的系统范围的 Python 副本。再次强调，这完全无视虚拟环境的整个目的。
- en: 'Instead, you should always use this shebang for any Python file that only runs
    with Python 3:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你应该始终为任何仅在 Python 3 中运行的 Python 文件使用这个 shebang：
- en: '[PRE38]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 2-5: *shebang.py:1b*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-5: *shebang.py:1b*'
- en: 'If you happen to have a script which runs in *both* Python 2 and Python 3,
    use this shebang instead:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个脚本同时在 *Python 2* 和 *Python 3* 中运行，使用这个 shebang 代替：
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 2-6: *shebang.py:1c*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-6: *shebang.py:1c*'
- en: The rules about shebangs and how they are handled are officially outlined in
    PEP 394 (for UNIX-like systems) and PEP 397 (for Windows systems). Regardless
    of which system you develop for, it’s good to understand the implications of shebangs
    in both UNIX and Windows.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 shebang 的规则及其如何处理，已在 PEP 394（针对类 UNIX 系统）和 PEP 397（针对 Windows 系统）中正式说明。无论你为哪个系统开发，理解
    shebang 在 UNIX 和 Windows 中的影响都是有益的。
- en: File Encoding
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件编码
- en: Since Python 3.1, all Python files have used the *UTF-8 encoding*, allowing
    the interpreter to use all of the characters in Unicode. (Prior to that version,
    the default was to use the old ASCII encoding.)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.1 开始，所有 Python 文件都使用 *UTF-8 编码*，允许解释器使用 Unicode 中的所有字符。（在此版本之前，默认使用旧的
    ASCII 编码。）
- en: If you need to use a different encoding system, instead of the default UTF-8,
    you need to tell the Python interpreter that outright.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用不同的编码系统，而不是默认的 UTF-8，你需要直接告诉 Python 解释器。
- en: 'For example, to use Latin-1 encoding in a Python file, include this line at
    the top of your file, right below the shebang. To work, it must be on the first
    or second line—that’s where the interpreter looks for this information:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在 Python 文件中使用 Latin-1 编码，可以在文件顶部、shebang 下面包含这一行。为了使其生效，它必须位于第一行或第二行——这是解释器查找该信息的地方：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you want another encoding system, replace `latin-1` with whatever you need.
    If you specify an encoding that Python doesn’t recognize, it will throw an error.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要其他编码系统，将 `latin-1` 替换为你所需的编码。如果指定了 Python 无法识别的编码，它会抛出错误。
- en: 'Although the preceding is the conventional way to specify encoding, there are
    two other valid ways to write the above comment. You can use this form, without
    the hard-to-remember `-*-`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的方法是指定编码的传统方式，但还有两种有效的方式来写上面的注释。你可以使用这种形式，省略难以记住的`-*-`：
- en: '[PRE41]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or you can use this longer but more English-like form:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用这种更长但更符合英文语法的形式：
- en: '[PRE42]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Whatever you use, it must be *exactly* as shown above, except for swapping `latin-1`
    for whatever encoding you want. For this reason, the first or second forms are
    preferred.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种方式，它必须*完全*与上面所示的相同，只是将`latin-1`替换为你需要的编码。因此，首选第一种或第二种形式。
- en: To learn more, read PEP 263, which defined this feature.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多信息，可以阅读PEP 263，它定义了这一特性。
- en: Most of the time, you’ll be fine using the default UTF-8 encoding anyway; if
    you need something else, now you know how to inform the interpreter.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你使用默认的UTF-8编码就足够了；如果你需要其他编码，现在你知道如何告知解释器了。
- en: A Few Extra Virtual Environment Tricks
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些额外的虚拟环境技巧
- en: 'As you get used to using virtual environments and pip, you’ll pick up additional
    tricks and tools to make the whole process easier. Here are a few of the more
    popular ones:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当你习惯使用虚拟环境和pip时，你会掌握更多技巧和工具，使整个过程更加简单。这里列出了一些较为流行的技巧：
- en: Using a Virtual Environment Without Activating
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不激活虚拟环境的情况下使用虚拟环境
- en: You can use the binaries that are a part of the virtual environment without
    activating it. For example, you can execute `venv/bin/python` to run the virtual
    environment’s own Python instance, or `venv/bin/pip` to run its instance of pip.
    It’ll work the same as if you had activated the virtual environment.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不激活虚拟环境的情况下，使用虚拟环境中的二进制文件。例如，你可以执行`venv/bin/python`来运行虚拟环境中的Python实例，或`venv/bin/pip`来运行它的pip实例。它的表现就像你已经激活了虚拟环境一样。
- en: 'For example, assuming my virtual environment is `venv`, I could do this in
    the terminal:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我的虚拟环境是`venv`，我可以在终端中执行以下命令：
- en: '[PRE43]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It works! Yet, `import pylint` still will not work on the system-wide Python
    interactive shell (unless, of course, you installed it on the system).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以工作！不过，`import pylint` 仍然无法在系统范围的Python交互式 shell 中运行（除非你已经在系统中安装了它）。
- en: The Alternatives
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代方案
- en: Throughout this book, I’ll be using pip and `venv`, as they’re the default tools
    for modern Python. However, there are a few other solutions out there worth looking
    into.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将使用pip和`venv`，因为它们是现代Python的默认工具。然而，市面上也有一些其他值得关注的解决方案。
- en: Pipenv
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pipenv
- en: A number of Python developers swear by *Pipenv*, which combines both pip and
    `venv` into one cohesive tool, with many additional features.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python开发者非常推崇*Pipenv*，它将pip和`venv`结合成一个统一的工具，拥有许多额外功能。
- en: Because the workflow is quite different, I won’t cover Pipenv here. If you’re
    interested in it, I recommend reading their superb documentation at [https://docs.pipenv.org/](https://docs.pipenv.org/).
    You’ll find comprehensive setup and usage instructions there, as well as a more
    detailed explanation of the advantages Pipenv offers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工作流程有所不同，我不会在这里介绍Pipenv。如果你对它感兴趣，建议阅读他们的优秀文档，网址是[https://docs.pipenv.org/](https://docs.pipenv.org/)。你可以在这里找到完整的设置和使用说明，并详细了解Pipenv所提供的优势。
- en: pip-tools
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pip-tools
- en: A number of tasks in pip can be simplified with pip-tools, including automatic
    updating, aids for writing *requirements.txt*, and more.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pip-tools可以简化pip中的许多任务，包括自动更新、生成*requirements.txt*等辅助工具。
- en: If you use pip-tools, you should only install it within a virtual environment.
    It is designed specifically for that use case.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用pip-tools，应该只在虚拟环境中安装它。它专门为这种用例设计。
- en: More information is available at [https://pypi.org/project/pip-tools/](https://pypi.org/project/pip-tools/).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请访问[https://pypi.org/project/pip-tools/](https://pypi.org/project/pip-tools/)。
- en: poetry
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: poetry
- en: Some Python developers absolutely hate the entire pip workflow. One such developer
    created *poetry* as an alternative package manager. I don’t use it in this book,
    as it behaves very differently, but I’d be remiss not to point it out.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python开发者非常讨厌整个pip工作流程。有一位开发者创建了*poetry*，作为一种替代的包管理器。虽然在本书中我并没有使用它，因为它的行为与pip非常不同，但我还是觉得有必要提到它。
- en: 'You can find more information, download directions (the creator does not recommend
    using pip to install it), and access documentation on their website: [https://python-poetry.org/](https://python-poetry.org/).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在他们的网站找到更多信息、下载说明（创建者不推荐使用pip安装），并访问文档：[https://python-poetry.org/](https://python-poetry.org/)。
- en: Introduction to PEP 8
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEP 8简介
- en: Unlike many languages, where style decisions are left entirely to the discretion
    of the community at large, Python does have an official style guide, which is
    published as *PEP 8*. Although the conventions in the guide are intended primarily
    for standard library code, many Python developers choose to stick to them as a
    rule.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多语言不同，样式决策完全由社区决定，Python有一个官方的样式指南，即*PEP 8*。虽然指南中的规范主要适用于标准库代码，但许多 Python
    开发者选择将其作为规则来遵循。
- en: 'That doesn’t make them mandatory: if you have an objective reason to follow
    a different style convention in your project, that’s fine, although you should
    apply that style consistently, as much as is reasonable.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着它们是强制性的：如果你有客观理由在项目中遵循不同的样式规范，那也没问题，尽管你应该尽可能一致地应用该样式，合理的范围内。
- en: 'PEP 8 itself makes this distinction clear, early on:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 本身很早就明确了这一点：
- en: A style guide is about consistency. Consistency with this style guide is important.
    Consistency within a project is more important. Consistency within one module
    or function is the most important.
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 样式指南的核心是保持一致性。遵循这个样式指南的一致性很重要。项目内部的一致性更重要。一个模块或函数内部的一致性是最重要的。
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, know when to be inconsistent—sometimes, style guide recommendations
    just aren’t applicable. When in doubt, use your best judgment. Look at other examples
    and decide what looks best. And don’t hesitate to ask!
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，知道何时不一致也很重要——有时，样式指南的建议并不适用。遇到疑问时，凭借你最好的判断力来决定。查看其他示例，决定什么看起来最好。并且不要犹豫，随时提问！
- en: In practice, you’ll likely find very little reason to deviate from PEP 8\. The
    style guide is far from all-encompassing. It leaves plenty of breathing room,
    while making it clear what constitutes a good or bad coding style.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你很可能几乎没有理由偏离 PEP 8。样式指南远非包罗万象，它留下了很多空间，同时明确了什么样的编码风格是好的，什么是不好的。
- en: The Line Limit Debate
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行限制辩论
- en: PEP 8 recommends a line limit of 79 characters, or an 80-character cutoff, though
    there’s a lot of debate on the topic. Some Python developers respect that rule,
    while others prefer cutoffs of 100 or 120 characters. What to do?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 推荐的行限制是 79 个字符，或者 80 字符的截断，尽管这个话题存在很多争议。一些 Python 开发者遵守这个规则，而另一些则更倾向于使用
    100 或 120 字符的限制。该怎么办呢？
- en: 'The most common argument for longer limits is that modern monitors are wider
    and higher resolution. Surely, the 80-character limit is a relic of a bygone era,
    right? ***Definitely not!*** There are several reasons to stick to a common line
    limit. For example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的关于较长字符限制的论点是，现代显示器更宽且分辨率更高。肯定是80字符限制是过去时代的遗物，对吧？***绝对不是！*** 仍然有多个理由坚持使用通用的行限制。例如：
- en: Vision-impaired individuals who must work with larger font sizes or zoomed-in
    interfaces
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要使用较大字体或放大界面的视力受限的用户
- en: Viewing differences in a file between commits in a side-by-side diff
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并排差异对比中查看文件在提交之间的差异
- en: Split-screen editors, displaying multiple files simultaneously
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分屏编辑器，同时显示多个文件
- en: Vertical monitors
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直显示器
- en: Side-by-side windows on a laptop monitor, wherein the editor only has half its
    usual space
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记本显示器上的并排窗口，其中编辑器只有通常的一半空间
- en: Individuals with older monitors, who cannot afford to upgrade to the latest
    1080p monster
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用老旧显示器的人，无法负担升级到最新的1080p大屏显示器
- en: Viewing code on mobile devices
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动设备上查看代码
- en: Writing coding books for No Starch Press
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 No Starch Press 写编码书籍
- en: 'In all of these scenarios, the reasoning behind the 80-character limit becomes
    apparent: there simply isn’t enough horizontal space for 120 characters or more
    per line. Soft text wrapping, wherein the remainder of a cut-off line appears
    on a separate line (without a line number), does solve some of these issues. However,
    it can be difficult to read, as many people forced to rely on it regularly will
    attest to.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些场景中，80字符限制的原因变得显而易见：每行如果超过120个字符或更多，横向空间根本不够。软换行，即被截断的行的其余部分出现在另一行（没有行号）中，确实解决了其中一些问题。然而，阅读起来可能会很困难，因为很多人不得不经常依赖这种方式。
- en: 'This doesn’t mean that you have to follow this 79-character maximum religiously.
    There are exceptions. Above all, *readability* and *consistency* are the goals.
    Many developers embrace the 80/100 rule: an 80-character “soft” cutoff, you try
    to respect in most cases; and a 100-character “hard” cutoff, you reserve for all
    those cases where the lower limit would negatively impact readability.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你必须严格遵循 79 个字符的最大限制。也有例外。最重要的是，*可读性* 和 *一致性* 是目标。许多开发者采用 80/100 规则：80
    字符的“软性”限制，你尽量在大多数情况下遵守；而 100 字符的“硬性”限制，适用于那些低于限制会影响可读性的情况。
- en: Tabs or Spaces?
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制表符还是空格？
- en: Ah yes, the civil war over which many friendships have been strained and many
    relationships have abruptly ended (okay, maybe just that one?). Most programmers
    have strong feelings on the topic.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，是的，这场内战让许多友谊变得紧张，也导致了不少关系的突然结束（好吧，也许只有那一场？）。大多数程序员对此话题有强烈的看法。
- en: PEP 8 recommends spaces over tabs, but technically, it allows either. The important
    thing is to *never mix the two*. Use either spaces or tabs, and stick to it throughout
    your entire project.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 推荐使用空格而不是制表符，但从技术上讲，它允许两者都可以。重要的是要 *绝不混用两者*。使用空格或制表符，且在整个项目中保持一致。
- en: 'If you do use spaces, then there’s the debate about how many spaces to use.
    PEP 8 answers this question, too: *four spaces per indentation level*. Any less
    can negatively impact code readability, especially for people with visual impairments
    or some forms of dyslexia.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用空格，那么就会有关于每次缩进使用多少个空格的争论。PEP 8 也回答了这个问题：*每个缩进级别使用四个空格*。少于这个数量可能会影响代码的可读性，尤其是对于有视力障碍或某些类型阅读障碍的人来说。
- en: By the way, most code editors are able to automatically enter four spaces when
    they press Tab, so there’s rarely an excuse to press space repeatedly.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，大多数代码编辑器在按下 Tab 键时会自动输入四个空格，所以几乎没有理由反复按空格键。
- en: 'Quality Control: Static Analyzers'
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 质量控制：静态分析器
- en: One of the most useful tools in any programmer’s toolkit is a reliable *static
    analyzer*, which reads your source code, looking for potential problems or deviations
    from the standards. If you’ve never used one before, now is the time to change
    that. One common type of static analyzer, called a *linter*, checks your source
    code for common mistakes, potential errors, and style inconsistencies. Two of
    the most popular linters are *Pylint* and *PyFlakes*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 对任何程序员而言，最有用的工具之一就是可靠的 *静态分析器*，它会读取你的源代码，寻找潜在的问题或偏离标准的地方。如果你以前从未使用过静态分析工具，那么现在是时候改变这种情况了。一种常见的静态分析工具叫做
    *linter*，它检查源代码中的常见错误、潜在问题和风格不一致之处。最流行的两个 linter 工具是 *Pylint* 和 *PyFlakes*。
- en: There are many more kinds of static analyzers available for Python, including
    static type checkers like *Mypy* and complexity analyzers like *mccabe*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同种类的静态分析工具可供 Python 使用，包括像 *Mypy* 这样的静态类型检查器和像 *mccabe* 这样的复杂度分析器。
- en: I’ll cover how to install all of these below, and I’ll discuss how to use many
    of them. I recommend you choose only one of these two linters and install the
    rest of the static analyzers.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下面介绍如何安装这些工具，并讨论如何使用其中的许多工具。我建议你只选择这两个 linter 中的一个并安装其余的静态分析工具。
- en: Pylint
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pylint
- en: Pylint is perhaps the most versatile static analyzer in Python. It works decently
    well by default, and it allows you to customize exactly what you want it to look
    for and ignore.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 可能是 Python 中最全能的静态分析工具。它默认表现得相当不错，并且允许你精确自定义要查找和忽略的内容。
- en: 'You can install the Pylint package with pip, which I recommend doing in a virtual
    environment. Once installed, you pass Pylint the name of a file you want analyzed,
    like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 pip 安装 Pylint 包，我建议在虚拟环境中进行安装。安装完成后，你只需向 Pylint 传递你想要分析的文件名，像这样：
- en: '[PRE44]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can also analyze an entire package or module at once. (I’ll define what
    modules and packages are in Chapter 4.) For example, if you want Pylint to analyze
    a package called `myawesomeproject` in the current working directory, you’d run
    this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以一次性分析整个包或模块。（我将在第 4 章中定义模块和包的概念。）例如，如果你想让 Pylint 分析当前工作目录中的一个叫做 `myawesomeproject`
    的包，你可以运行如下命令：
- en: '[PRE45]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Pylint will scan the files and display its warnings and recommendations on the
    command line. Then, you can edit your file and make the necessary changes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 会扫描文件并在命令行中显示警告和建议。然后，你可以编辑文件并进行必要的修改。
- en: 'For example, consider the following Python file:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下 Python 文件：
- en: '[PRE46]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 2-7: *cooking.py:1a*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-7：*cooking.py:1a*
- en: 'I’ll run the linter on that file with the following in the system command line:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在系统命令行中使用以下命令运行 linter 对文件进行检查：
- en: '[PRE47]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Pylint provides the following feedback:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 提供了以下反馈：
- en: '[PRE48]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The linter found five errors in my code: both the module and the function are
    missing their docstrings (see Chapter 3). I tried to use the variables `eggs`
    and `order`, neither of which exist. I also assigned a value to the variable `ham`,
    but I never used that value anywhere.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析工具发现了我代码中的五个错误：模块和函数都缺少文档字符串（见第3章）。我尝试使用了`eggs`和`order`这两个变量，但它们都不存在。我还为变量`ham`赋了值，但我从未在其他地方使用过这个值。
- en: 'If Pylint takes umbrage at a particular line of code you feel should be left
    as is, you can tell the static analyzer to ignore it and move on. You do this
    with a special comment, either inline on the line in question or at the top of
    the affected block. For example:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Pylint对某行代码提出异议，而你认为这行代码应该保持原样，你可以告诉静态分析工具忽略它并继续。你可以通过特殊注释来实现这一点，可以是该行代码的内联注释，也可以是影响代码块顶部的注释。例如：
- en: '[PRE49]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 2-8: *cooking.py:1b*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '列表2-8: *cooking.py:1b*'
- en: 'With the first command, I tell Pylint not to alert me about the missing docstring
    on the module; that affects the entire block of code. The inline comment on the
    next line will suppress the warning about the missing docstring on the function,
    and it will only affect that line. If I ran the linter again, I’d only see the
    other two linter errors:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一个命令，我告诉Pylint不要提醒我模块缺少文档字符串；这会影响整个代码块。下一行的内联注释会抑制关于函数缺少文档字符串的警告，这只会影响该行。如果我再次运行静态分析工具，我只会看到另外两个错误：
- en: '[PRE50]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At this point, I’d edit my code and actually fix the rest of those problems.
    (Except I won’t, for this example.)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，我会编辑我的代码并实际修复其余的问题。（不过为了这个例子，我不会这么做。）
- en: 'You can also control Pylint’s project-wide behavior by creating a *pylintrc*
    file in the root directory of your project. To do this, run the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在项目的根目录中创建*pylintrc*文件来控制Pylint的项目级行为。为此，运行以下命令：
- en: '[PRE51]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Find that file; open it; and edit it to turn on and off different warnings,
    ignore files, and define other settings. The documentation isn’t fantastic for
    this, but you can often work out what different options do from the comments in
    that *pylintrc* file.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 找到那个文件，打开它，并编辑以开启或关闭不同的警告、忽略文件，并定义其他设置。关于这一点的文档并不完美，但你通常可以从那个*pylintrc*文件中的注释推测出不同选项的作用。
- en: 'When you run Pylint, it will look for a *pylintrc* (or *.pylintrc*) file in
    the current working directory. Alternatively, you can specify a different filename
    for Pylint to read its settings from, such as *myrcfile*, by passing the filename
    to the `--rcfile` option when invoking Pylint:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行Pylint时，它会在当前工作目录中查找*pylintrc*（或*.pylintrc*）文件。或者，你也可以通过在调用Pylint时使用`--rcfile`选项指定一个不同的文件名，让Pylint读取该文件的设置，例如*myrcfile*：
- en: '[PRE52]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Some regular users of Pylint like to create `.pylintrc` or `.config/pylintrc`
    in their home directory (UNIX-like systems only). If Pylint cannot find another
    configuration file, it will use the one in the home directory.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Pylint的常规用户喜欢在他们的主目录中创建`.pylintrc`或`.config/pylintrc`文件（仅限类Unix系统）。如果Pylint找不到其他配置文件，它将使用主目录中的那个文件。
- en: Although the Pylint documentation is far from comprehensive, it can still be
    useful. You can find it at [https://pylint.readthedocs.io/](https://pylint.readthedocs.io/).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Pylint文档远非全面，但它仍然很有用。你可以在[https://pylint.readthedocs.io/](https://pylint.readthedocs.io/)找到它。
- en: Flake8
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flake8
- en: 'The *Flake8* tool is actually a combination of three static analyzers:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flake8*工具实际上是三个静态分析工具的组合：'
- en: '*PyFlakes* is a linter, similar in purpose to Pylint. It is designed to work
    faster and to avoid false positives (both being common complaints about Pylint).
    It also ignores style rules, which are handled by the next tool.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PyFlakes*是一个静态分析工具，其用途与Pylint类似。它的设计目标是更快地运行，并避免假阳性（这两者都是Pylint常见的抱怨）。它还忽略了样式规则，后者由下一个工具处理。'
- en: '*pycodestyle* is a style checker, to help ensure you write PEP 8-compliant
    code. (This tool used to be called `pep8`, but it was renamed to avoid confusion
    with the actual style guide.)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pycodestyle*是一个样式检查工具，帮助确保你编写符合PEP 8规范的代码。（这个工具以前叫做`pep8`，但为了避免与实际的样式指南混淆，它被重命名了。）'
- en: '*mccabe* checks the McCabe (or Cyclomatic) complexity of your code. If you
    don’t know what that is, don’t worry—its purpose is essentially just to warn you
    when your code’s structure is getting too complicated.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mccabe*检查你代码的McCabe（或圈复杂度）复杂度。如果你不知道这是什么意思，不用担心——它的目的是在代码结构过于复杂时发出警告。'
- en: You can install the Flake8 package with pip, which I typically do within a virtual
    environment.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用pip安装Flake8包，我通常是在虚拟环境中执行此操作。
- en: 'To scan a file, module, or package, pass it to `flake8` on the command line.
    For example, to scan my earlier *cooking.py* file ([Listing 2-8](#listing2-8)),
    I’d use this command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要扫描一个文件、模块或包，可以在命令行中将其传递给`flake8`。例如，要扫描我之前的 *cooking.py* 文件（[清单 2-8](#listing2-8)），我会使用以下命令：
- en: '[PRE53]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That outputs the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出以下内容：
- en: '[PRE54]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: (You’ll notice that Flake8 isn’t complaining about the lack of docstrings; that’s
    disabled by default in this linter.)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: （你会注意到 Flake8 并没有抱怨缺少文档字符串；这是默认在此 linter 中禁用的。）
- en: 'By default, only PyFlakes and pycodestyle are run. If you want to analyze the
    complexity of your code, you also need to pass the argument `--max-complexity`,
    followed by a number. Anything higher than `10` is considered too complex, but
    if you understand McCabe complexity, you can change this to suit your needs. So,
    for example, to check the complexity of the *cooking.py* file, you’d run this:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只会运行 PyFlakes 和 pycodestyle。如果你想分析代码的复杂性，还需要传递参数 `--max-complexity`，后面跟一个数字。任何高于
    `10` 的值都被认为太复杂，但如果你理解 McCabe 复杂度，可以根据需要调整它。所以，例如，要检查 *cooking.py* 文件的复杂度，你可以运行以下命令：
- en: '[PRE55]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However you run Flake8, you’ll get a comprehensive list of all the errors and
    warnings in your code.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何运行 Flake8，你都会得到代码中所有错误和警告的详细列表。
- en: If you need to tell Flake8 to ignore something it thinks is a problem, you use
    a `# noqa` comment, followed by the error code to ignore. This comment should
    be inline, on the line where the error occurs. If you omit the error code, then
    `# noqa` will cause Flake8 to ignore all errors on that line.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要告诉 Flake8 忽略它认为是问题的某些内容，可以使用 `# noqa` 注释，后面跟上要忽略的错误代码。这个注释应该是内联的，写在发生错误的那一行。如果省略错误代码，则
    `# noqa` 会导致 Flake8 忽略该行上的所有错误。
- en: 'In my code, if I wanted to ignore both of the errors I received, it might look
    like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的代码中，如果我想忽略收到的两个错误，它可能看起来像这样：
- en: '[PRE56]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 2-9: *cooking.py:1c*'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 2-9: *cooking.py:1c*'
- en: Here, you see three different scenarios. First, I’m ignoring only warning `F841`.
    Second, I’m ignoring two errors (even though one of them isn’t actually raised;
    this is just a silly example). Third, I’m ignoring all possible errors.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你看到三种不同的情况。首先，我只忽略了警告 `F841`。第二，我忽略了两个错误（即使其中一个实际上并没有被触发；这只是一个愚蠢的例子）。第三，我忽略了所有可能的错误。
- en: Flake8 also supports configuration files. In the project directory, you can
    create a *.flake8* file. Start a section in that file with the line `[flake8]`,
    followed by all the Flake8 settings you want to define. (See the documentation.)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Flake8 也支持配置文件。在项目目录中，你可以创建一个 *.flake8* 文件。在该文件中，以 `[flake8]` 开头的行开始一个部分，后面跟上你想要定义的所有
    Flake8 设置。（请参阅文档。）
- en: Flake8 will also accept project-wide configuration files called *tox.ini* or
    *setup.cfg*, so long as they have a `[flake8]` section within them.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Flake8 还支持名为 *tox.ini* 或 *setup.cfg* 的项目范围配置文件，只要它们包含 `[flake8]` 部分。
- en: 'For example, if you want to automatically run mccabe each time you invoke Flake8,
    rather than specify `--max-complexity` every time, you could define a *.flake8*
    file that looks like this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你希望每次调用 Flake8 时自动运行 mccabe，而不是每次都指定 `--max-complexity`，你可以定义一个 *.flake8*
    文件，内容如下：
- en: '[PRE57]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 2-10: *.flake8*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 2-10: *.flake8*'
- en: Some developers like to define a system-wide configuration file for Flake8,
    which you can do (only) on a UNIX-like system. In your home folder, create the
    configuration file as either *.flake8* or *.config/flake8*.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 有些开发者喜欢为 Flake8 定义一个系统范围的配置文件，这在 UNIX 类系统上是可以做到的。在你的主文件夹中，可以创建名为 *.flake8* 或
    *.config/flake8* 的配置文件。
- en: One of the chief advantages of Flake8 over Pylint is the documentation. Flake8
    has a complete list of their warnings, errors, options, and the like. You can
    find the documentation at [https://flake8.readthedocs.io/](https://flake8.readthedocs.io/).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Flake8 相较于 Pylint 的一个主要优势是它的文档。Flake8 提供了完整的警告、错误、选项等列表。你可以在 [https://flake8.readthedocs.io/](https://flake8.readthedocs.io/)
    找到文档。
- en: Mypy
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mypy
- en: '*Mypy* is an unusual static analyzer because it focuses entirely on *type annotations*
    (see Chapter 6). Because it involves so many concepts I haven’t covered yet, I
    won’t go into much depth here.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mypy* 是一个不寻常的静态分析工具，因为它完全专注于 *类型注解*（见第六章）。由于它涉及许多我还没有涉及的概念，这里我不会深入探讨。'
- en: Still, now is a good time to get it installed. Like everything else so far,
    you can install the `mypy` package from pip.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正是安装它的好时机。和之前的所有步骤一样，你可以通过 pip 安装 `mypy` 包。
- en: 'Once installed, Mypy can be used by passing it the file, package, or module
    you wish to check:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，可以通过传递文件、包或模块来使用 Mypy 进行检查：
- en: '[PRE58]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Mypy will only attempt to check files that have type annotations, and it will
    ignore the rest.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 只会尝试检查具有类型注解的文件，其它的将被忽略。
- en: 'Style Janitors: Autoformatting Tools'
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式清理工：自动格式化工具
- en: Another tool you may find useful is an *autoformatter,* which can automatically
    change your Python code—spacing, indentation, and preferred equivalent expressions
    (such as `!=` instead of `<>`)—to be PEP 8 compliant. Two options are *autopep8*
    and *Black*.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可能会觉得有用的工具是 *自动格式化器*，它可以自动更改你的 Python 代码——空格、缩进和首选的等效表达式（例如用 `!=` 替代 `<>`）——使其符合
    PEP 8。两个选项是 *autopep8* 和 *Black*。
- en: autopep8
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: autopep8
- en: The autopep8 tool leverages pycodestyle (part of Flake8), even using the same
    configuration file as that tool to determine what style rules it ultimately follows
    or ignores.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: autopep8 工具利用了 pycodestyle（Flake8 的一部分），甚至使用与该工具相同的配置文件来确定它最终遵循或忽略的样式规则。
- en: As always, you can install `autopep8` with pip.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，你可以通过 pip 安装 `autopep8`。
- en: By default, autopep8 only fixes whitespace, but if you pass the `--aggressive`
    argument to it, it will make additional changes. In fact, if you pass that argument
    twice, it will do even more. The complete list is beyond the scope of this explanation,
    so consult the documentation at [https://pypi.org/project/autopep8/](https://pypi.org/project/autopep8/)
    to learn more.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，autopep8 只会修复空格问题，但如果你传递 `--aggressive` 参数，它将进行额外的修改。实际上，如果你传递该参数两次，它将进行更多修改。完整的列表超出了本解释的范围，请参阅文档
    [https://pypi.org/project/autopep8/](https://pypi.org/project/autopep8/) 以了解更多。
- en: 'To fix most PEP 8 issues on a Python code file by changing it in place (as
    opposed to making a copy, which is the default behavior), run this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过原地修改（与创建副本不同，这是默认行为）来修复 Python 代码文件中的大多数 PEP 8 问题，请运行：
- en: '[PRE59]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Changing the file directly may sound a bit risky, but it really isn’t. Style
    changes are just that: style. They don’t affect the actual behavior of the code.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 直接修改文件可能听起来有点冒险，但实际上并非如此。样式变化仅仅是样式，它们不会影响代码的实际行为。
- en: Black
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Black
- en: 'The Black tool is a little more straightforward: it assumes you want to follow
    PEP 8 in its entirety, and it doesn’t overwhelm you with many options as a result.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Black 工具则更直接：它假设你希望完全遵循 PEP 8，因此它不会给你提供太多的选项。
- en: 'Like autopep8, you install `black` with pip, although it requires Python 3.6
    or later. To format a file with it, pass the filename:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 和 autopep8 一样，你可以通过 pip 安装 `black`，不过它需要 Python 3.6 或更高版本。要使用它格式化文件，只需传递文件名：
- en: '[PRE60]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A complete list of Black’s few options can be seen via `black --help`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `black --help` 查看 Black 的完整选项列表。
- en: Testing Frameworks
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试框架
- en: 'Testing frameworks form an essential part of any good development workflow,
    but I won’t go into detail about them in this chapter. Python has three major
    options for testing frameworks: *Pytest*, *nose2*, and *unittest*, in addition
    to a promising new project called *ward*. All of these can be installed with pip.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架是任何良好开发流程中的核心部分，但在本章中我不会详细讲解。Python 有三个主要的测试框架选项：*Pytest*、*nose2* 和 *unittest*，此外还有一个有前景的新项目叫做
    *ward*。所有这些都可以通过 pip 安装。
- en: More knowledge is essential to cover this topic effectively, so I’ll revisit
    it in Chapter 20.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 更深入的知识对于有效地讲解这个话题至关重要，因此我将在第20章再次讨论此内容。
- en: An Exhibition of Code Editors
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码编辑器展示
- en: You have your Python interpreter, your virtual environments, your static analyzers,
    and other such tools. Now you are prepared to write code.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经拥有了 Python 解释器、虚拟环境、静态分析工具和其他类似的工具。现在，你已经准备好编写代码了。
- en: You can write Python in any basic text editor, just as you could with practically
    any other programming language. Yet you’ll probably have an easier time writing
    production-quality code with a proper code editor.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何基础文本编辑器中编写 Python 代码，就像你可以用几乎任何其他编程语言一样。然而，使用一个合适的代码编辑器，你可能会更容易编写出生产质量的代码。
- en: Before I end this chapter, I want to take you on a tour of several of the most
    popular Python code editors and integrated development environments (*IDEs*) available.
    This is only a sampling, as there are many more options besides. **If you already
    know what code editor or IDE you want to use, skip forward to the last section
    of this chapter.**
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我想带你参观几款最流行的 Python 代码编辑器和集成开发环境（*IDEs*）。这只是一个示例，因为除了这些，还有很多其他选择。**如果你已经知道要使用哪个代码编辑器或
    IDE，可以跳到本章的最后部分。**
- en: IDLE
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IDLE
- en: 'Python has its own IDE, called *IDLE*, which ships with the standard distribution
    of Python. It’s a fairly bare-bones IDE with two components: an editor and an
    interface for the interactive shell. You could do worse than IDLE, so if you aren’t
    in the mood to install a different editor right now, start here. However, I recommend
    exploring your options, as most editors and IDEs have a host of useful features
    that IDLE lacks.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Python 自带一个 IDE，叫做 *IDLE*，它与 Python 标准发行版一起提供。这是一个相当简洁的 IDE，包含两个部分：一个编辑器和一个交互式
    shell 界面。如果你现在不想安装其他编辑器，IDLE 也不失为一个不错的选择。然而，我还是建议你探索一下其他选项，因为大多数编辑器和 IDE 都有 IDLE
    所没有的有用功能。
- en: Emacs and Vim
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Emacs 和 Vim
- en: The purists and old-school hackers among you will be glad to know that Emacs
    and Vim both have excellent Python support. Setting up either is not for the faint
    of heart, so I’m not going into any of that here.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些追求纯粹和怀旧的黑客们，你们会很高兴知道，Emacs 和 Vim 都有出色的 Python 支持。设置这两者中的任何一个都不是心脏不好的人的选择，所以我在这里不会深入讨论这些。
- en: If you’re already a lover of either (or both?) code editors, you can find excellent
    tutorials for both at Real Python.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经是某个（或两个？）代码编辑器的爱好者，你可以在 Real Python 网站上找到这两个编辑器的优秀教程。
- en: For Emacs, see [https://realpython.com/emacs-the-best-python-editor/](https://realpython.com/emacs-the-best-python-editor/).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Emacs，请参考 [https://realpython.com/emacs-the-best-python-editor/](https://realpython.com/emacs-the-best-python-editor/)。
- en: For Vim, see [https://realpython.com/vim-and-python-a-match-made-in-heaven/](https://realpython.com/vim-and-python-a-match-made-in-heaven/).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Vim，请参考 [https://realpython.com/vim-and-python-a-match-made-in-heaven/](https://realpython.com/vim-and-python-a-match-made-in-heaven/)。
- en: PyCharm
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyCharm
- en: 'According to “The State of Developer Ecosystem 2021” developer survey by JetBrains,
    the PyCharm IDE from JetBrains is far and away the most popular option for Python
    programming. It comes in two flavors: the free *PyCharm Community Edition* and
    the paid *PyCharm Professional Edition*. (Steps were taken by JetBrains to eliminate
    bias. See the survey here: [https://www.jetbrains.com/lp/devecosystem-2021/python/](https://www.jetbrains.com/lp/devecosystem-2021/python/).)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 JetBrains 发布的“开发者生态系统 2021”调查，JetBrains 的 PyCharm IDE 远远是最受欢迎的 Python 编程选项。它有两个版本：免费的*PyCharm
    Community Edition*和付费的*PyCharm Professional Edition*。（JetBrains 已采取措施消除偏见。调查详情请见：
    [https://www.jetbrains.com/lp/devecosystem-2021/python/](https://www.jetbrains.com/lp/devecosystem-2021/python/)）。
- en: Both versions offer a dedicated Python code editor with autocompletion, refactoring,
    debugging, and testing tools. It can manage and use virtual environments with
    ease, and it integrates with your version control software. It even performs static
    analysis (using its own tool). The professional edition adds tools for data, scientific
    development, and web development.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本都提供了一个专用的 Python 代码编辑器，支持自动补全、重构、调试和测试工具。它可以轻松管理和使用虚拟环境，并与版本控制软件集成。它甚至会执行静态分析（使用其自有工具）。专业版还增加了数据、科学开发和
    Web 开发工具。
- en: If you’re familiar with other JetBrains IDEs, like IntelliJ IDEA or CLion, PyCharm
    would be a great Python IDE to start with. It requires more computer resources
    than many code editors, but if you have a decently powerful machine, this won’t
    be a problem. If you haven’t used JetBrains IDEs before, try the Community Edition
    before investing in the paid version.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他 JetBrains IDE，例如 IntelliJ IDEA 或 CLion，那么 PyCharm 会是一个很好的 Python IDE
    入门选择。它比许多代码编辑器占用更多计算机资源，但如果你的机器足够强大，这不会成为问题。如果你之前没有使用过 JetBrains 的 IDE，可以先尝试社区版，看看是否值得投资付费版本。
- en: You can find more information and downloads at [https://jetbrains.com/pycharm/](https://jetbrains.com/pycharm/).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://jetbrains.com/pycharm/](https://jetbrains.com/pycharm/) 获取更多信息和下载链接。
- en: Visual Studio Code
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: '*Visual Studio Code* has excellent Python support. It’s the second-most popular
    Python code editor, according to that 2021 JetBrains survey. It’s free and open
    source, and it runs on virtually every platform. Install the official Python extension
    from Microsoft, and you’re ready to go!'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '*Visual Studio Code* 具有出色的 Python 支持。根据 2021 年 JetBrains 的调查，它是第二受欢迎的 Python
    代码编辑器。它是免费的、开源的，几乎可以在所有平台上运行。只需安装 Microsoft 官方的 Python 扩展，就可以开始使用了！'
- en: Visual Studio Code supports autocompletion, refactoring, debugging, and virtual
    environment switching, along with the usual version control integration. It integrates
    with Pylint, Flake8, and Mypy, among several other popular static analyzers. It
    even works with the most common Python unit testing tools.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 支持自动补全、重构、调试和虚拟环境切换，并且还集成了常见的版本控制功能。它与 Pylint、Flake8 和 Mypy
    等多种流行的静态分析工具兼容，甚至可以与最常用的 Python 单元测试工具配合使用。
- en: Download it at [https://code.visualstudio.com/](https://code.visualstudio.com/).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://code.visualstudio.com/](https://code.visualstudio.com/) 下载它。
- en: Sublime Text
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sublime Text
- en: '*Sublime* is another popular multilanguage code editor. It is appreciated for
    its speed and simplicity, and it is easily customized with extensions and configuration
    files. Sublime Text is free to try, but if you find you like it and wish to continue
    using it, you need to purchase it.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sublime* 是另一个受欢迎的多语言代码编辑器。它因速度快、简洁而受到赞赏，并且可以通过扩展和配置文件轻松定制。Sublime Text 可以免费试用，但如果你发现它好用并希望继续使用，你需要购买许可证。'
- en: 'The Anaconda plug-in transforms Sublime Text into a Python IDE, with everything:
    autocompletion, navigation, static analysis, autoformatting, test running, and
    even a documentation browser. It requires a little more hand-tuned configuration
    than some of the other options, especially if you want to use virtual environments.
    However, if Sublime Text is your jam, it’s worth it.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda 插件将 Sublime Text 转变为一个 Python IDE，具备所有功能：自动补全、导航、静态分析、自动格式化、测试运行，甚至文档浏览器。它比一些其他选项需要更多的手动配置，尤其是如果你想使用虚拟环境的话。不过，如果
    Sublime Text 是你的首选，这些额外的配置是值得的。
- en: Download Sublime Text at [https://sublimetext.com/](https://sublimetext.com/)
    and the Anaconda plug-in at [https://damnwidget.github.io/anaconda/](https://damnwidget.github.io/anaconda/).
    That second link also provides instructions for installing the plug-in in Sublime
    Text.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://sublimetext.com/](https://sublimetext.com/) 下载 Sublime Text，在 [https://damnwidget.github.io/anaconda/](https://damnwidget.github.io/anaconda/)
    下载 Anaconda 插件。第二个链接还提供了如何在 Sublime Text 中安装插件的说明。
- en: Spyder
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spyder
- en: If your focus is scientific programming or data analysis, or if you’re a fan
    of MATLAB’s interface, you’ll be right at home in *Spyder*, a free and open source
    Python IDE that is also written *in* Python.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的重点是科学编程或数据分析，或者如果你是 MATLAB 界面的粉丝，那么你会很喜欢 *Spyder*，它是一个免费的开源 Python IDE，且也是用
    *Python* 编写的。
- en: In addition to the usual features—a dedicated Python code editor, a debugger,
    integration with static analyzers, and documentation viewing—Spyder includes integration
    with many common Python libraries for data analysis and scientific computing.
    It integrates a full code profiler and variable explorer. Plug-ins exist for supporting
    unit tests, autoformatting, and editing Jupyter notebooks, among other features.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的功能——专用 Python 代码编辑器、调试器、与静态分析器的集成以及文档查看——Spyder 还集成了许多常用的 Python 数据分析和科学计算库。它还集成了完整的代码分析器和变量探查器。插件支持单元测试、自动格式化以及编辑
    Jupyter notebooks 等功能。
- en: Download Spyder at [https://spyder-ide.org/](https://spyder-ide.org/).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://spyder-ide.org/](https://spyder-ide.org/) 下载 Spyder。
- en: Eclipse + PyDev/LiClipse
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Eclipse + PyDev/LiClipse
- en: '*Eclipse* has lost a lot of ground to the newer editors, but it still has a
    loyal user base. Although it’s geared toward languages like Java, C++, PHP, and
    JavaScript, Eclipse can also become a Python IDE with the *PyDev* plug-in.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*Eclipse* 在新型编辑器的竞争中失去了许多市场份额，但它仍然有着忠实的用户群体。尽管 Eclipse 主要面向 Java、C++、PHP 和
    JavaScript 等语言，但它也可以通过 *PyDev* 插件变成一个 Python IDE。'
- en: If you already have installed Eclipse, which is completely free, then you only
    need to install the PyDev plug-in from the Eclipse Marketplace. Download Eclipse
    at [https://eclipse.org/ide/](https://eclipse.org/ide/) and look in the marketplace
    for the plug-in.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了完全免费的 Eclipse，那么只需从 Eclipse Marketplace 安装 PyDev 插件即可。在 [https://eclipse.org/ide/](https://eclipse.org/ide/)
    下载 Eclipse，并在 Marketplace 中查找插件。
- en: Alternatively, you can install *LiClipse,* which bundles Eclipse, PyDev, and
    other useful tools. The PyDev developers recommend this approach, as it directly
    supports their development work. You can use LiClipse without a license for 30
    days, after which point, you must purchase a license. Download LiClipse from [https://liclipse.com/](https://liclipse.com/).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以安装 *LiClipse*，它将 Eclipse、PyDev 和其他有用的工具捆绑在一起。PyDev 开发者推荐这种方式，因为它直接支持他们的开发工作。你可以在没有许可证的情况下使用
    LiClipse 30 天，之后必须购买许可证。你可以从 [https://liclipse.com/](https://liclipse.com/) 下载
    LiClipse。
- en: PyDev offers autocompletion, refactoring, support for type hinting and static
    analysis, debugging, unit test integration, and many more features. You can find
    more information about PyDev at [https://pydev.org/](https://pydev.org/).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: PyDev 提供自动补全、重构、类型提示和静态分析支持、调试、单元测试集成等众多功能。你可以在 [https://pydev.org/](https://pydev.org/)
    获取更多关于 PyDev 的信息。
- en: The Eric Python IDE
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Eric Python IDE
- en: '*Eric* might be the oldest IDE on the list, but it’s still as reliable as ever.
    Named after Eric Idle of *Monty Python’s Flying Circus*, Eric is a free and open
    source IDE written in Python.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '*Eric* 可能是列表中最古老的 IDE，但它依然像往常一样可靠。它以 *Monty Python’s Flying Circus* 的 Eric
    Idle 命名，是一个用 Python 编写的免费开源 IDE。'
- en: 'It offers everything you could possibly need to write Python: autocompletion,
    debugging, refactoring, static analysis, testing integration, documentation tools,
    virtual environment management, and the list goes on.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了写 Python 所需的一切：自动补全、调试、重构、静态分析、测试集成、文档工具、虚拟环境管理，等等。
- en: Find information about Eric and download it at [https://eric-ide.python-projects.org/](https://eric-ide.python-projects.org/).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 查找关于 Eric 的信息并下载：[https://eric-ide.python-projects.org/](https://eric-ide.python-projects.org/)。
- en: Wrapping Up
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Writing code involves so much more than just code. Having set up your development
    environment, project, and IDE, you are now prepared to focus exclusively on making
    your code the best it can be.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码远不止编写代码。设置好你的开发环境、项目和 IDE 后，你现在已经准备好专注于让你的代码达到最佳水平。
- en: By this point, you should have assembled a Python development workbench worthy
    of any production-level project. At minimum, you should have installed the Python
    interpreter, pip, `venv`, one or more static analyzers, and a Python code editor.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点为止，你应该已经搭建了一个足以应对任何生产级项目的 Python 开发工作台。至少，你应该已经安装了 Python 解释器、pip、`venv`、一个或多个静态分析工具以及一个
    Python 代码编辑器。
- en: 'Right now, in your code editor or IDE, create a *FiringRange* project for experimenting
    in while working through this book. For the moment, to be sure everything works,
    you can make a single Python file in that project with these contents:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的代码编辑器或 IDE 中，创建一个 *FiringRange* 项目，用于在阅读本书时进行实验。为了确保一切正常，你可以在该项目中创建一个包含以下内容的
    Python 文件：
- en: '[PRE61]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 2-11: *hello_world.py*'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 2-11: *hello_world.py*'
- en: 'Run that like this:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这样运行：
- en: '[PRE62]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You should see the following output:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下输出：
- en: '[PRE63]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: I’ll go into the correct structure for Python projects in Chapter 4, but writing
    and running individual Python files in your firing range project should be sufficient
    for Chapter 3.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第 4 章中详细讲解 Python 项目的正确结构，但在第 3 章中，你的射击场项目中编写和运行单个 Python 文件应该足够了。
- en: If you’re new to the IDE you have selected, take a few minutes now to familiarize
    yourself with it. You should particularly ensure you know how to navigate and
    run code, manage files, work with virtual environments, access the interactive
    console, and use the static analyzers.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是首次使用你选择的 IDE，花几分钟时间熟悉一下它吧。你应该特别确保你知道如何导航、运行代码、管理文件、使用虚拟环境、访问交互式控制台并使用静态分析工具。
- en: '3'
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Syntax Crash Course
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 语法速成班
- en: '![](Images/chapterart.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Python is an unusual mix of common and unique concepts. Before diving into the
    intricacies of the language, you must first grasp its essential syntax.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种常见概念与独特概念相结合的语言。在深入了解语言的复杂性之前，你必须先掌握其基本语法。
- en: In this chapter, you’ll learn most of the essential syntactic structures you’ll
    encounter in Python, and you’ll also become familiar with the basic mathematical
    and logical features of the language.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习到大部分你在 Python 中会遇到的基本语法结构，并且你还将熟悉语言中的基本数学和逻辑特性。
- en: 'Most Python developers will point newcomers to the official Python tutorial,
    which is an excellent introduction to the language’s structure. While I’ll cover
    all of these concepts in this book in depth, the tutorial is still a good resource
    worth reading: [https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/).'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Python 开发者会把新手引导到官方 Python 教程，那是对语言结构的极好介绍。尽管我将在本书中深入讲解所有这些概念，教程仍然是值得阅读的好资源：[https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/)。
- en: Hello, World!
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: 'It won’t feel like a proper introduction to the language without the classic
    Hello World program. In Python, it’s written like this:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有经典的 Hello World 程序，它就不算是对语言的真正介绍。在 Python 中，它是这样写的：
- en: '[PRE64]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 3-1: *hello_world.py*'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-1: *hello_world.py*'
- en: There’s nothing novel here. You call the `print()` function to write text to
    the console, and you pass data in a string, wrapped in quotes as an argument.
    You can pass whatever sort of data you like, and it will be output on the console.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新奇的内容。你调用`print()`函数将文本输出到控制台，并将数据作为字符串传入，数据用引号括起来作为参数。你可以传递任何类型的数据，它都会在控制台上输出。
- en: 'I can also get input from the console with the `input()` function:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以通过 `input()` 函数从控制台获取输入：
- en: '[PRE65]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Listing 3-2: *hello_input.py*'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-2: *hello_input.py*'
- en: I use the `input()` function and pass my prompt as a string ❶. When I run that
    code, Python greets me using the name I entered on the console.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `input()` 函数并传递我的提示字符串 ❶。当我运行这段代码时，Python 会使用我在控制台上输入的名字向我打招呼。
- en: Statements and Expression
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句与表达式
- en: Each line of code in Python that ends with a line break is a *statement*, sometimes
    more specifically known as a *simple statement*. Unlike in many C-inspired languages,
    you don’t need to end a line in Python with a special character.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中每一行代码，若以换行符结束，都被视为 *语句*，有时更具体地称为 *简单语句*。与许多 C 风格语言不同，Python 中的行末不需要特定的字符来结束。
- en: A section of code that evaluates to a single value is called an *expression*.
    In Python, you can put expressions nearly anywhere a value is expected. The expression
    is evaluated down to a value, and that value is used in that position in the statement.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 一段求值为单一值的代码称为 *表达式*。在 Python 中，你几乎可以把表达式放在任何需要值的地方。表达式会被求值为一个值，并且这个值会在语句中相应的位置被使用。
- en: 'For example, in one statement, I can create a variable, and in another statement,
    I can print its contents to the console:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一条语句中，我可以创建一个变量，而在另一条语句中，我可以将其内容打印到控制台：
- en: '[PRE66]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Listing 3-3: *hello_statements.py:1a*'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-3: *hello_statements.py:1a*'
- en: I assign the expression `"Hello, world!"` to `message`, and then I pass the
    expression `message` to `print()`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我将表达式 `"Hello, world!"` 赋值给 `message`，然后将表达式 `message` 传递给 `print()`。
- en: 'If you ever need to place multiple statements on the same line, you can separate
    them with a semicolon (`;`). To demonstrate this, here are the same two statements
    as earlier, but packed onto one line, with a semicolon to separate them:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将多个语句放在同一行，可以使用分号（`;`）分隔它们。为了演示这一点，以下是前面提到的两条语句，但它们被压缩到一行中，并使用分号分隔：
- en: '[PRE67]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 3-4: *hello_statements.py:1b*'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-4: *hello_statements.py:1b*'
- en: While this is valid code, using this technique is somewhat discouraged. The
    Python philosophy places a high value on readability, and the placement of multiple
    statements on the same line often detracts from that.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是有效的代码，但这种写法是有所不鼓励的。Python 的哲学非常重视代码的可读性，而将多个语句放在同一行通常会影响这一点。
- en: Stick to placing one statement per line, unless you have a specific reason to
    do otherwise.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有特定的原因，否则最好每行只放一条语句。
- en: The Importance of Whitespace
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空格的重要性
- en: When you’re looking at a sample of Python source code, the first thing that
    will probably jump out at you is the use of indentation for nesting. A *compound
    statement* is made up of one or more *clauses*, each of which consists of a line
    of code called a *header* and a block of code called a *suite*, which is associated
    with the header.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看 Python 源代码示例时，首先可能会引起你注意的是嵌套的缩进用法。一个 *复合语句* 由一个或多个 *子句* 组成，每个子句都包括一行代码，称为
    *头部*，以及一个与头部关联的代码块，称为 *语句块*。
- en: 'For example, this program prints different messages, depending on whether a
    `name` is specified:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个程序根据是否指定了 `name` 来打印不同的消息：
- en: '[PRE68]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 3-5: *hello_conditional.py*'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-5: *hello_conditional.py*'
- en: I set up a conditional statement with an `if` header ❶, after which I have a
    suite made up of two indented lines of code, which “belongs” to the header. These
    lines of code are executed only if the conditional expression in the header is
    evaluated to `True`.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了一个带有 `if` 头部 ❶ 的条件语句，之后我有一个由两行缩进代码组成的语句块，这些代码“属于”该头部。只有当头部中的条件表达式被求值为 `True`
    时，这些代码行才会执行。
- en: The unindented line ❷ is not part of the suite that belongs to the conditional
    statement, and it will be run every time.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 没有缩进的行 ❷ 不是条件语句所属的语句块的一部分，它每次都会执行。
- en: 'As I nest deeper, I need to add more indentation:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我嵌套得更深，我需要添加更多的缩进：
- en: '[PRE69]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Listing 3-6: *weather_nested_conditional.py*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-6: *weather_nested_conditional.py*'
- en: The first `print` statement is indented twice, which is how Python knows that
    it belongs to both preceding conditional statements.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条 `print` 语句缩进了两次，这就是 Python 知道它属于前面两个条件语句的方式。
- en: Given the importance of whitespace, the “tabs versus spaces” war is fairly common
    in Python world. You’ll remember from Chapter 2 that the PEP 8 style guide stresses
    using either four spaces or a single tab per indentation level. ***Consistency
    is key!*** Python really doesn’t care whether you use tabs, two spaces, four spaces,
    or even seven spaces (although that’s probably a step too far) for each level
    of indentation. The point is to be consistent within any and every given block
    of code.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空白符的重要性，"制表符与空格"的争论在 Python 世界中非常常见。你会记得在第二章中，PEP 8 风格指南强调每个缩进级别使用四个空格或一个制表符。***一致性是关键！***
    Python 实际上并不关心你使用的是制表符、两个空格、四个空格，还是七个空格（虽然那可能有点过头），关键是在每个代码块中保持一致。
- en: You should use only one indentation style throughout your project, even if your
    situation provides a technical loophole. Don’t mix tabs and spaces. Chances are
    your IDE has tools to help you with this.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在整个项目中使用一致的缩进风格，即使你的情况提供了技术上的漏洞。不要混用制表符和空格。你的 IDE 很可能有工具帮助你做到这一点。
- en: For simplicity’s sake, I’ll use the PEP 8 convention of four spaces throughout
    my code examples. While I’d recommend you follow this same convention—you can
    even configure your editor to insert four spaces each time you hit the Tab key—if
    you have a strong preference for tabs, you’re welcome to use those instead. It
    really doesn’t matter.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，我将在我的代码示例中使用 PEP 8 约定的四个空格。虽然我建议你也遵循这个约定——你甚至可以配置编辑器，每次按下 Tab 键时自动插入四个空格——如果你更喜欢使用制表符，当然也可以使用它们。实际上，这并不重要。
- en: Doing Nothing
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么也不做
- en: On occasion, you will need to insert a statement that has absolutely no effect.
    This is particularly useful when you need to put a syntactically valid placeholder
    where a suite of code will exist later. For this purpose, Python provides the
    `pass` keyword.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要插入一条完全没有效果的语句。当你需要在代码块将来填充内容的地方放一个语法上有效的占位符时，这特别有用。为此，Python 提供了 `pass`
    关键字。
- en: 'For example, I can employ the `pass` keyword as a placeholder in my `if raining`
    conditional, until I’m able to write the final code:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可以在 `if raining` 条件语句中使用 `pass` 关键字作为占位符，直到我能够编写最终的代码：
- en: '[PRE70]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Listing 3-7: *raining_pass.py*'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-7：*raining_pass.py*
- en: Just remember, `pass` does absolutely nothing. That’s the only reason it exists.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，`pass` 什么也不做。这就是它存在的唯一原因。
- en: Comments and Docstrings
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释与文档字符串
- en: To write comments in Python, precede the line with a hash (`#`). Everything
    between the hash and the end of the line is a comment and will be ignored by the
    interpreter.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中编写注释时，在行前加上井号（`#`）。井号和行尾之间的所有内容都是注释，会被解释器忽略。
- en: '[PRE71]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 3-8: *comments.py*'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-8：*comments.py*
- en: If you ran this program, the `print` statements would both execute. The rest
    of the second `print` statement, from the hash onward, is an inline comment ❶
    and would be ignored by the interpreter. All the other lines are only comments.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，`print` 语句都会执行。第二个 `print` 语句中从井号开始的部分是内联注释 ❶，会被解释器忽略。所有其他行都是注释。
- en: Docstrings
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档字符串
- en: 'Officially, there is no syntax for “multiline” comments; you just comment each
    line. There is one special exception: the *docstring*. It looks like this:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 官方来说，没有“多行”注释的语法；你只需注释每一行。有一个特殊的例外：*文档字符串*。它看起来是这样的：
- en: '[PRE72]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Listing 3-9: *docstrings.py:1*'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-9：*docstrings.py:1*
- en: I define a function that would (theoretically) make tea, and I place the description
    of the function inside a docstring.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个理论上能够泡茶的函数，并将该函数的描述放入文档字符串中。
- en: Docstrings exist to provide documentation for functions, classes, and modules,
    especially public ones. They conventionally begin and end with three quotation
    marks (`"""`), allowing the string to automatically span multiple lines. You would
    typically place docstrings at the top, inside of whatever they’re defining, such
    as in the function above.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串用于为函数、类和模块（尤其是公共模块）提供文档说明。它们通常以三个引号（`"""`）开始和结束，这样字符串就可以自动跨越多行。你通常会把文档字符串放在其定义的顶部，例如上面的函数。
- en: 'There are three important distinctions between comments and docstrings:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 注释和文档字符串之间有三个重要区别：
- en: Docstrings are string literals, and they are seen by the interpreter; comments
    are ignored.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串是字符串字面量，解释器会看到它们；而注释则会被忽略。
- en: Docstrings are used in automatic documentation generation.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串用于自动生成文档。
- en: Docstrings are generally only docstrings when they appear at the top of the
    module, function, class, or method they define. Comments can live anywhere.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串通常只有在出现在它们定义的模块、函数、类或方法的顶部时，才算是文档字符串。注释可以放在任何地方。
- en: It is perfectly possible to use a triple-quoted string literal to write a sort
    of “multiline comment,” but it’s not recommended, since a string literal can easily
    get left in a place where Python will try to use it as a value.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以使用三引号字符串字面量来写“多行注释”，但不推荐这么做，因为字符串字面量很容易被留在一个 Python 会尝试将其作为值使用的地方。
- en: In short, use docstrings as intended, and stick with comments for everything
    else. Many Python IDEs have hotkeys for toggling comments on a selection, which
    can save you a lot of time.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，按照预期使用文档字符串，其他地方则使用注释。许多 Python 集成开发环境（IDE）都有快捷键，可以快速切换选定代码的注释，这能为你节省很多时间。
- en: 'I can access these docstrings later in my code. For instance, given the previous
    example, I can do this:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在代码中稍后访问这些文档字符串。例如，参考之前的例子，我可以这样做：
- en: '[PRE73]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Listing 3-10: *docstrings.py:2*'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-10: *docstrings.py:2*'
- en: Docstrings have their own style conventions, which are outlined in depth in
    PEP 257.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串有其自身的格式规范，详细内容可以参考 PEP 257。
- en: Declaring Variables
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'You may have already noticed that Python doesn’t have a distinct keyword for
    declaring a new variable (technically called a *name* in this language; see Chapter
    5). Here, I define two variables—`name` and `points`:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Python 没有专门的关键字来声明新变量（在这种语言中，它被称为 *名称*；参见第 5 章）。在这里，我定义了两个变量——`name`
    和 `points`：
- en: '[PRE74]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Listing 3-11: *variables.py*'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-11: *variables.py*'
- en: Python is *dynamically typed*, meaning the data type of a value is determined
    when it is evaluated. This contrasts with statically typed languages, in which
    you declare the data type initially. (C++ and Java are both statically typed.)
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是 *动态类型* 的，这意味着值的数据类型是在计算时确定的。这与静态类型语言不同，后者在一开始就声明数据类型。（C++ 和 Java 都是静态类型语言。）
- en: With Python, you can assign a value to a name anytime, by using the assignment
    operator (`=`). It infers the data type. If the name is a new variable, Python
    will create it; if the name already exists, Python will change the value. It’s
    a pretty straightforward system.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以随时通过使用赋值运算符（`=`）将值赋给一个名称。Python 会推断数据类型。如果这个名称是一个新变量，Python 会创建它；如果这个名称已经存在，Python
    会改变它的值。这是一个非常直观的系统。
- en: 'In general, there are only two rules to follow with Python variables:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Python 变量只有两条规则：
- en: Define a variable before you access it; otherwise, you’ll get an error.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在访问变量之前先声明它；否则，你会遇到错误。
- en: Don’t change what kind of data you’re storing in the variable, even when replacing
    a value.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使在替换值时，也不要改变变量中存储的数据类型。
- en: Python is considered a *strongly typed language*, meaning you usually can’t
    magically combine data of different types. For example, it won’t allow you to
    add an integer and a string together. On the other hand, *weakly typed* languages
    let you do practically anything with different data types, and they try to figure
    out how to do what you asked for. (JavaScript is weakly typed.) There’s an entire
    spectrum between those last two terms and plenty of debate about what behaviors
    qualify under which name. While Python is decidedly in the “strongly typed” camp,
    it still has weaker typing than some languages.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: Python 被认为是 *强类型语言*，这意味着通常不能魔法般地将不同类型的数据合并。例如，它不会允许你将整数和字符串相加。另一方面，*弱类型* 语言允许你在不同的数据类型间做几乎任何事情，它们会尽量弄清楚如何完成你请求的操作。（JavaScript
    是弱类型的。）这两个术语之间有一个完整的谱系，关于哪些行为属于哪个名称的讨论也很多。虽然 Python 明确属于“强类型”阵营，但它的类型系统比某些语言要弱。
- en: Python is, however, *weakly bound*, so it is possible to assign a value of a
    different type to an existing variable. While this is technically permissible,
    it is strongly discouraged, as it can produce confusing code.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python 是 *弱绑定* 的，所以你可以将不同类型的值赋给现有变量。虽然从技术上讲，这是允许的，但强烈不建议这么做，因为这会产生混乱的代码。
- en: What About Constants?
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量怎么办？
- en: Python doesn’t have any formally defined constants. In keeping with PEP 8, you
    would indicate a variable is intended to be treated as a constant by using all-caps
    names with underscores. This naming convention is sometimes humorously referred
    to as *screaming snake case* for the all-caps (screaming) and the underscores
    (snakes). For example, the name `INTEREST_RATE` indicates that you don’t want
    the variable redefined or changed in any way. While the interpreter itself won’t
    prevent the variable from being modified, your linter will usually complain if
    you do.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有正式定义的常量。根据PEP 8规范，你可以通过使用全大写字母和下划线的命名方式来表明一个变量应该当作常量使用。这种命名约定有时幽默地被称为*尖叫蛇式命名法*，因为它包含了全大写字母（尖叫）和下划线（蛇）。例如，`INTEREST_RATE`这个名字表示你不希望这个变量被重新定义或改变。尽管解释器本身不会阻止修改这个变量，但如果你这么做，通常静态检查工具会给出警告。
- en: Mathematics
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学
- en: Python has all the math functionality you would expect from a good programming
    language; its excellent support for both simple and complicated mathematics is
    one of the reasons Python is popular for scientific programming, data processing,
    and statistical analysis.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了你期望从一个优秀编程语言中得到的所有数学功能；它对简单和复杂数学的出色支持是Python在科学编程、数据处理和统计分析中如此受欢迎的原因之一。
- en: Meet the Number Types
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认识数字类型
- en: Before I get into the operations, you should be aware of the three data types
    used for storing numbers.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在我介绍操作之前，你应该了解用于存储数字的三种数据类型。
- en: '*Integers* (`int`) store whole numbers. In Python, integers are always signed
    and effectively have no maximum value. Integers use decimal base (base-10) by
    default, but they can also be specified in binary (`0b101010`), octal (`0o52`),
    or hexadecimal (`0x2A`).'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数*（`int`）用于存储整数。在Python中，整数总是带符号的，并且实际上没有最大值。整数默认使用十进制（基数10），但也可以使用二进制（`0b101010`）、八进制（`0o52`）或十六进制（`0x2A`）表示。'
- en: '*Floating-point numbers* (`float`) store numbers with a decimal part (for example,
    `3.141592`). You can also use scientific notation (for example, `2.49e4`). Internally,
    values are stored as double-precision, IEEE 754 floating-point numbers, which
    are subject to the limits inherent in that format. (For more insight into the
    limits and gotchas of floating-point arithmetic, read the article “What Every
    Computer Scientist Should Know About Floating-Point Arithmetic” by David Goldberg:
    [https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)*.*)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮点数*（`float`）用于存储带有小数部分的数字（例如，`3.141592`）。你也可以使用科学计数法（例如，`2.49e4`）。在内部，值作为双精度IEEE
    754浮点数存储，这种格式存在固有的限制。（想了解更多浮点算术的限制和注意事项，请阅读David Goldberg的文章《每个计算机科学家都应该知道的浮点算术》：[https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)*。）'
- en: You can also specify an invalid number with `float("nan")`, a number larger
    than the largest possible value with `float("inf")`, or a number smaller than
    the smallest possible value with `float("-inf")`.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`float("nan")`来指定一个无效的数字，使用`float("inf")`来指定一个比最大可能值还大的数字，或者使用`float("-inf")`来指定一个比最小可能值还小的数字。
- en: Notice that I wrapped the special values in quotes. This is necessary if you
    want to use these values without *importing* the `math` module (see Chapter 4
    for more about importing). If you have imported the `math` module (see “The `math`
    Module” subsection below), you can use the constants `nan`, `inf`, and so forth,
    instead of the quoted versions.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我将特殊值放在了引号中。如果你不想使用*导入*`math`模块（有关导入的更多信息，请参见第4章），这一步是必须的。如果你已经导入了`math`模块（见下文“`math`模块”小节），你可以使用常量`nan`、`inf`等，而不需要引号版本。
- en: '*Complex numbers* (`complex`) can store imaginary numbers by appending `j`
    to the value, as in `42j`. You can combine a real part with the imaginary part,
    using addition: `24+42j`.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '*复数*（`complex`）通过在值后面添加`j`来存储虚数，例如`42j`。你可以通过加法将实数部分与虚数部分组合，例如：`24+42j`。'
- en: In case you missed it in math class, an imaginary number has the square root
    of negative one as one of its factors, even though this value is utterly impossible;
    there is no value that you can multiply by itself to get negative one! Yet imaginary
    numbers definitely show up in real-world math. Spooky, no?
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在数学课上没学到，虚数是其平方根为负一的数字，尽管这个值从数学上来说是不可能存在的；没有任何值可以自乘得到负一！然而，虚数在实际数学中确实会出现。很神奇吧？
- en: '*Decimal* and *Fraction* are two of the additional object types for storing
    numeric data. `Decimal` stores fixed-point decimal numbers, while `Fraction` does
    the same for fractions. To use either, you’ll need to import them first.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '*Decimal*和*Fraction*是用于存储数字数据的两种附加对象类型。`Decimal`用于存储定点小数，而`Fraction`则用于存储分数。要使用它们，你需要先导入。'
- en: 'Here’s a brief example that uses both types:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简短的示例，使用了两种类型的条件：
- en: '[PRE75]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 3-12: *fractions_and_decimals.py*'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-12: *fractions_and_decimals.py*'
- en: The `float()` function turns `Fraction` and `Decimal` objects into floats.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`float()`函数将`Fraction`和`Decimal`对象转换为浮动小数。'
- en: Operators
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符
- en: Python has the usual operators, with a couple of additions that may not be familiar
    to some developers.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有常见的运算符，并且添加了一些可能对某些开发者不太熟悉的运算符。
- en: 'Here’s a bit of code that will demonstrate the math operators. I’ll wrap each
    equation inside a `print()` statement, so you can run the code and see the results:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个展示数学运算符的代码示例。我将每个方程放入`print()`语句中，这样你可以运行代码并查看结果：
- en: '[PRE76]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Listing 3-13: *math_operators.py*'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-13: *math_operators.py*'
- en: The *unary* (one-operand) negative operator flips the sign of whatever follows
    it. The `abs()` function is technically considered a unary operator as well. The
    rest of the operators here are *binary*, meaning they accept two operands.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '*一元*（单操作数）负号运算符会翻转其后面的数值符号。`abs()`函数从技术上讲也被视为一元运算符。其余的运算符都是*二元*运算符，意味着它们接受两个操作数。'
- en: '[PRE77]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Listing 3-14: *augmented_assignment_operators.py*'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-14: *augmented_assignment_operators.py*'
- en: If you need both floor division (`//`) and modulo (`%`) on the same operands,
    Python provides the `divmod()` function to efficiently perform the calculation,
    returning the two results in a tuple. Thus, `c = divmod(a, b)` is the same as
    `c = (a // b, a % b)`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对同一操作数进行整除（`//`）和取余（`%`），Python提供了`divmod()`函数，可以高效地执行计算，并返回一个包含两个结果的元组。因此，`c
    = divmod(a, b)`与`c = (a // b, a % b)`是等价的。
- en: 'Python also has `bitwise` operators, which I’ll list below for those readers
    already familiar with bitwise arithmetic. I won’t introduce these concepts until
    Chapter 12:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有`bitwise`运算符，下面我会列出这些运算符，供已经熟悉位运算的读者参考。直到第12章我才会介绍这些概念：
- en: '[PRE78]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Listing 3-15: *bitwise_operators.py*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-15: *bitwise_operators.py*'
- en: The math Module
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学模块
- en: 'Python provides plenty of additional functions in the `math` module, along
    with the five most common math constants: `pi`, `tau`, `e`, `inf`, and `nan`.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: Python在`math`模块中提供了大量附加函数，以及五个最常用的数学常量：`pi`、`tau`、`e`、`inf`和`nan`。
- en: '[PRE79]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Listing 3-16: *math_constants.py*'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-16: *math_constants.py*'
- en: All five constants are floats and can be directly used as such ❶. The official
    documentation provides a complete list of everything available in the `math` module.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个常量都是浮动小数，并可以直接作为浮动小数使用❶。官方文档提供了`math`模块中所有可用项的完整列表。
- en: 'You might remember a little trick from high school trigonometry, where you
    could calculate the height of something using your distance to it and the angle
    from your vantage point to the top of the object. Here’s a way to calculate that
    with Python, using the `math` module:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得高中的三角学小技巧，利用你与物体之间的距离和从你的观察点到物体顶部的角度来计算物体的高度。这里有一种使用Python来计算的方法，利用了`math`模块：
- en: '[PRE80]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Listing 3-17: *surveying_height.py*'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-17: *surveying_height.py*'
- en: 'I use two functions from the `math` module: `math.radians()` ❶ and `math.tan()`
    ❷. The `round()` function ❸ is built into the language itself.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了来自`math`模块的两个函数：`math.radians()`❶和`math.tan()`❷。`round()`函数❸是Python内置的函数。
- en: Logic
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑
- en: Python’s clean, obvious syntax for logical expressions is one of the attractive
    elements of the language. Here, I’ll cover conditional statements and expressions,
    as well as the comparison and logic operators.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: Python简洁明了的逻辑表达式语法是该语言的吸引力之一。在这里，我将介绍条件语句和表达式，以及比较和逻辑运算符。
- en: Conditionals
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Conditionals are compound statements composed of `if`, `elif`, and `else` clauses,
    each made up of a header and a suite. As with most languages, you can have as
    many `elif` conditionals in Python as you want, sandwiched between `if` and (optionally)
    `else`. Here’s a really simple example:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句是由`if`、`elif`和`else`子句组成的复合语句，每个子句都包含一个头部和一个代码块。和大多数语言一样，你可以在Python中使用任意数量的`elif`条件，它们位于`if`和（可选的）`else`之间。这里有一个非常简单的例子：
- en: '[PRE81]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Listing 3-18: *conditional_greet.py*'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-18: *conditional_greet.py*'
- en: This conditional statement is made up of three clauses. The `if` clause evaluates
    first, and if the expression in its header evaluates to `True`, its suite runs,
    printing `"Hello!"` Otherwise, it evaluates the expression in the `elif` header
    next. If none of the expressions evaluate to `True`, then the `else` clause runs.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件语句由三个子句组成。`if`子句首先进行求值，如果其头部表达式的结果为`True`，则执行其语句块，输出`"Hello!"`。否则，它会继续评估`elif`头部的表达式。如果没有任何表达式结果为`True`，则执行`else`子句。
- en: You’ll notice you don’t need to wrap the conditional expressions, such as `command
    == "greet"`, in parentheses, although you may do so anyway if it helps clarify
    your code. You’ll see an example of this shortly.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，不需要将条件表达式（例如`command == "greet"`）用括号括起来，尽管如果这样做有助于代码更清晰，你仍然可以这么做。稍后你将看到这个的一个例子。
- en: If you’re looking for something similar to the `switch` statement from your
    favorite programming language, see the “Structural Pattern Matching” section toward
    the end of this chapter.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找类似于你喜欢的编程语言中的`switch`语句的东西，请参见本章末尾的“结构模式匹配”部分。
- en: Comparison Operators
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'Python has all the comparison operators you’d expect. Take a look at these
    in the context of comparing two integers:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: Python拥有你期望的所有比较运算符。看看在比较两个整数时的表现：
- en: '[PRE82]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 3-19: *comparison_operators.py*'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3-19：*comparison_operators.py*
- en: As you can see, Python has operators for `equals`, `not equals`, `less than`,
    `less than or equals`, `greater than`, and `greater than or equals`.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python有用于`等于`、`不等于`、`小于`、`小于或等于`、`大于`和`大于或等于`的运算符。
- en: No surprises there, but what about boolean comparisons? This is where Python
    takes a different line.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有什么意外，但布尔比较呢？这就是Python与众不同的地方。
- en: Boolean, None, and Identity Operators
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值、None 和身份运算符
- en: Python offers the values `True` and `False`, which are the two values for boolean
    (type `bool`) variables. It also has a dedicated `None` value (type `NoneType`),
    which serves in the capacity of a “null” value.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了`True`和`False`这两个布尔值（类型`bool`）。它还有一个专门的`None`值（类型`NoneType`），作为“空”值使用。
- en: You check for these values in a very different way than with other data types.
    Instead of the comparison operators, use the special *identity operator* `is`.
    (I’ll also use the logical operator `not` below, which I’ll discuss separately
    in a bit.)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 你检查这些值的方式与其他数据类型大不相同。与其使用比较运算符，不如使用特殊的*身份运算符*`is`。（我下面还会使用逻辑运算符`not`，我稍后会单独讨论它。）
- en: 'Here’s an example:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE83]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Listing 3-20: *boolean_identity_operators.py*'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3-20：*boolean_identity_operators.py*
- en: Aside from being a little high in sodium, that code shows the many ways of testing
    boolean values and checking for `None`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 除了含钠量稍高外，那段代码展示了多种测试布尔值和检查`None`的方法。
- en: You can test if a variable is set to `True`, `False`, or `None` by comparing
    with the `is` operator. You can also invert the logic with `is not`.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`is`运算符来测试变量是否设置为`True`、`False`或`None`。你还可以使用`is not`来反转逻辑。
- en: Most commonly, when testing against `True`, you can use the variable as the
    entire condition ❶. For `False`, invert that condition test with `not` ❷.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是，在测试`True`时，可以直接使用变量作为整个条件❶。对于`False`，用`not`反转该条件测试❷。
- en: Take particular note of the last condition, which illustrates an important gotcha
    with the `is` operator ❸. It actually compares the identity of the variables,
    rather than the value. This is particularly troublesome, as the logic looks sound
    but is a bug waiting for a place to happen. That probably doesn’t mean much to
    you yet, but rest assured, I’ll cover this concept in depth in Chapter 5.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意最后一个条件，它展示了`is`运算符的一个重要陷阱❸。它实际上比较的是变量的身份，而不是值。这尤其麻烦，因为逻辑看起来是合理的，但却是一个潜在的bug。虽然这可能现在对你来说意义不大，但请放心，我会在第5章深入讲解这个概念。
- en: 'For now, you can take this rule for granted: use `is` *only* for comparing
    directly to `None`, and use regular comparison operators for everything else.
    In practice, we usually say `if spam` or `if not spam`, instead of directly comparing
    to `True` or `False`.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你可以将这个规则视为理所当然：`is`*仅*用于直接与`None`比较，其他所有情况都使用常规比较运算符。实际上，我们通常会说`if spam`或`if
    not spam`，而不是直接与`True`或`False`比较。
- en: Truthiness
  id: totrans-648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真值性
- en: Most expressions and values in Python can be evaluated to a `True` or `False`
    value. This is typically done by using the value as an expression by itself, although
    you can also pass it to the `bool()` function to convert it explicitly.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的大多数表达式和值都可以求值为 `True` 或 `False`。这通常是通过将值本身作为表达式来完成的，尽管你也可以将其传递给 `bool()`
    函数显式地转换。
- en: '[PRE84]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Listing 3-21: *truthiness.py*'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-21: *truthiness.py*'
- en: When an expression will evaluate to `True`, it is considered “truthy.” When
    it will evaluate to `False`, it is “falsey.” The `None` constant, values representing
    zero, and empty collections are all considered “falsey,” while most other values
    are “truthy.”
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式的求值结果为 `True` 时，它被认为是“真值”（truthy）。当其结果为 `False` 时，它是“假值”（falsey）。`None`
    常量、表示零的值和空集合都被视为“假值”，而其他大多数值则被视为“真值”。
- en: Logical Operators
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'If you’re coming from a language where logical operators are a little more
    difficult to remember, you’ll find Python refreshing: it simply uses the keywords
    `and`, `or`, and `not`!'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自一个逻辑运算符稍微难记的语言，你会发现 Python 刷新了你的记忆：它简单地使用关键字 `and`、`or` 和 `not`！
- en: '[PRE85]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Listing 3-22: *logical_operators.py*'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-22: *logical_operators.py*'
- en: With the `and` condition, both expressions must evaluate to `True`. With the
    `or` condition, one or the other (or both) must evaluate to `True`. The third
    condition adds `not` to the picture, requiring that `eggs` be `False` and `spam`
    be `True`.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `and` 条件下，两个表达式都必须求值为 `True`。在 `or` 条件下，至少一个表达式（或两者）必须求值为 `True`。第三个条件通过加入
    `not`，要求 `eggs` 为 `False`，而 `spam` 为 `True`。
- en: I could have omitted the parentheses on the third condition, as `not` takes
    precedence and so is evaluated before `and`. However, the parentheses help to
    clarify my intended logic.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以省略第三个条件中的括号，因为 `not` 的优先级更高，因此会先于 `and` 进行求值。然而，括号有助于澄清我想表达的逻辑。
- en: 'In practice, you can use the `not` keyword to invert any conditional expression,
    such as in the following:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可以使用 `not` 关键字反转任何条件表达式，例如如下所示：
- en: '[PRE86]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Listing 3-23: *not_operators.py*'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-23: *not_operators.py*'
- en: 'Both comparisons do the same thing; the issue becomes readability. In this
    case, the expression using `not` is less readable because your eyes might skip
    over the `not` keyword, so you might not catch what’s happening in the code. The
    condition employing the `!=` operator is preferred for readability. While you
    might find situations where `not` is the best way to invert your conditional logic,
    remember The Zen of Python: ***Readability counts!***'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 两个比较做的是相同的事情；问题在于可读性。在这种情况下，使用 `not` 的表达式可读性较差，因为你的眼睛可能会跳过 `not` 关键字，因此你可能不会注意到代码中发生的事情。使用
    `!=` 运算符的条件更易于阅读。虽然你可能会遇到一些情况，其中 `not` 是反转条件逻辑的最佳方式，但请记住 Python 的 Zen：***可读性很重要！***
- en: The Walrus Operator
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 海象运算符
- en: Python 3.8 introduced *assignment expressions*, which allow you to assign a
    value to a variable and use that variable in another expression at the same time.
    This is possible with the so-called *walrus operator* (`:=`).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.8 引入了 *赋值表达式*，它允许你将一个值赋给变量，并在另一个表达式中同时使用该变量。这是通过所谓的 *海象运算符*（`:=`）实现的。
- en: '[PRE87]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Listing 3-24: *walrus.py*'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-24: *walrus.py*'
- en: With the walrus operator, Python first evaluates the expression on the left
    (`7+5`) and then assigns it to the variable `eggs`. The assignment expression
    is enclosed in parentheses for readability, although I technically could have
    omitted them.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 使用海象运算符时，Python 首先计算左边的表达式（`7+5`），然后将其赋值给变量 `eggs`。赋值表达式被括号包围以提高可读性，尽管从技术上讲，我本可以省略它们。
- en: The assignment expression is then evaluated to a single value, namely the value
    of `eggs`, which is used in the comparison. Since the value is `12`, the condition
    evaluates to `True`.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式然后被求值为一个单一的值，即 `eggs` 的值，该值用于比较中。由于该值是 `12`，所以条件的求值为 `True`。
- en: What’s interesting about the assignment expression is that `eggs` is now a valid
    variable in the outer scope, so I can print its value outside of the conditional.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，赋值表达式使得 `eggs` 成为外部作用域中的一个有效变量，因此我可以在条件外打印它的值。
- en: This feature is potentially useful in many scenarios, not only in conditional
    expressions, as above.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能在许多场景中都可能有用，不仅仅是在上面的条件表达式中。
- en: 'Assignment expressions and the walrus operator were defined in PEP 572, which
    also contains an in-depth discussion about when and where this feature should
    be used. Two particularly useful style rules are put forth by this PEP:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式和海象运算符是在 PEP 572 中定义的，该 PEP 还深入讨论了何时以及在何处使用此功能。该 PEP 提出了两个特别有用的风格规则：
- en: If either assignment statements or assignment expressions can be used, then
    prefer statements; they are clear declarations of intent.
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以使用赋值语句或赋值表达式，则应优先使用语句；它们是意图的明确声明。
- en: If using assignment expressions would lead to ambiguity about execution order,
    then restructure to use statements instead.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用赋值表达式会导致执行顺序的歧义，那么应该重构代码，改为使用语句。
- en: As of the writing of this book, Python assignment expressions are still in their
    infancy. A lot of debate and controversy still surrounds them. In any case, resist
    the temptation to abuse the walrus operator to cram as much logic onto one line
    as possible. You should always aim for readability and clarity in your code, above
    all else.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本书写作时，Python 的赋值表达式仍处于初期阶段。关于它们仍然存在许多争议和讨论。无论如何，抵制滥用海象运算符将尽可能多的逻辑压缩到一行的诱惑。你应该始终以代码的可读性和清晰性为首要目标。
- en: Ellipsis
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 省略号
- en: 'One seldom-used piece of syntax is the *Ellipsis*:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很少使用的语法是 *省略号*：
- en: '[PRE88]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is sometimes used by various libraries and modules, but seldom consistently.
    For example, it’s used with multidimensional arrays in the NumPy third-party library
    and when working with type hints from the built-in `typing` module. When you see
    it come up, consult the documentation for whatever module you’re using.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时会被各种库和模块使用，但很少一致地使用。例如，它在 NumPy 第三方库中的多维数组中使用，也在使用内置 `typing` 模块的类型提示时使用。当你看到它时，可以查阅你正在使用的模块的文档。
- en: Strings
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'There are a few things to know about strings as you move forward. Here, I’ll
    cover the three kinds of strings: string literals, raw strings, and formatted
    strings.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续学习时，有一些关于字符串的知识需要了解。这里，我将介绍三种类型的字符串：字符串字面量、原始字符串和格式化字符串。
- en: String Literals
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: 'There are multiple ways of defining a *string literal*:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *字符串字面量* 的方式有多种：
- en: '[PRE89]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Listing 3-25: *string_literals.py*'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-25：*string_literals.py*
- en: You can wrap a literal in double quotes (`"`), single quotes (`'`), or triple
    quotes (`"""`) of either type. You may remember from earlier that there’s something
    special about triple quotes, but I’ll come back to that in a moment.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用双引号（`"`）、单引号（`'`）或三重引号（`"""`）中的任意一种类型来包裹字面量。你可能记得之前提到过三重引号有些特别，不过我稍后会再讲到这一点。
- en: 'PEP 8 addresses the use of single and double quotes:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 规范讨论了单引号和双引号的使用：
- en: In Python, single-quoted strings and double-quoted strings are the same. This
    PEP does not make a recommendation for this. Pick a rule and stick to it. When
    a string contains single or double quote characters, however, use the other one
    to avoid backslashes in the string. It improves readability.
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Python 中，单引号字符串和双引号字符串是相同的。这个 PEP 没有对此做出推荐。选择一个规则并遵循它。然而，当字符串中包含单引号或双引号字符时，使用另一种引号来避免字符串中出现反斜杠，这样有助于提高可读性。
- en: 'The advice about placing quotes inside a string comes in handy when dealing
    with something like this:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在字符串内部放置引号的建议，在处理类似情况时非常有用：
- en: '[PRE90]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Listing 3-26: *escaping_quotes.py:1a*'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-26：*escaping_quotes.py:1a*
- en: This version escapes the double quotes I want to include in the string literal
    itself. The backslash (`\`) before the quotes means I want the string to contain
    that *literal character*, not to have Python treat the double quote as the boundary
    of a string. The string literal must always be wrapped in matching quotes.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本转义了我想在字符串字面量中包含的双引号。双引号前面的反斜杠（`\`）意味着我希望字符串包含该*字面字符*，而不是让 Python 将双引号视为字符串的边界。字符串字面量必须始终用匹配的引号包裹。
- en: 'It is possible to avoid backslashes in this scenario, however:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，是可以避免使用反斜杠的：
- en: '[PRE91]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Listing 3-27: *escaping_quotes.py:1b*'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-27：*escaping_quotes.py:1b*
- en: This second version wraps the literal in single quotes, so the double quotes
    will be automatically interpreted as part of the string literal. That approach
    is much more readable. By wrapping the string in single quotes, Python will assume
    the double quotes are characters in the string.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第二个版本将字面量用单引号包裹，这样双引号就会自动被解释为字符串字面量的一部分。这种方式更加可读。通过将字符串用单引号包裹，Python 会认为双引号是字符串中的字符。
- en: 'The only time you’d really need to escape either single or double quotes with
    backslashes would be if you had both types of quotes in the string at once:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要用反斜杠转义单引号或双引号的情况是当字符串中同时包含两种类型的引号时：
- en: '[PRE92]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Listing 3-28: *escaping_quotes.py:2a*'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-28：*escaping_quotes.py:2a*
- en: Personally, in cases like that, I’d prefer to use (and escape) the double quotes,
    because they don’t evade my attention like an apostrophe would tend to do.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，在这种情况下，我更倾向于使用（并转义）双引号，因为它们不会像撇号那样容易分散我的注意力。
- en: 'You also have the option to use triple quotes:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以选择使用三引号：
- en: '[PRE93]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Listing 3-29: *escaping_quotes.py:2b*'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-29：*escaping_quotes.py:2b*
- en: 'Remember that triple quotes define *multiline string literals*. In other words,
    I can use them to do this:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，三引号定义了*多行字符串字面量*。换句话说，我可以用它们来做这样的事情：
- en: '[PRE94]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Listing 3-30: *multiline_string.py*'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-30：*multiline_string.py*
- en: Everything, including newlines and leading whitespace, is literal in triple
    quotes. If I `print("parrot")`, it will display exactly like this in the terminal.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在三引号中的所有内容，包括换行符和前导空白，都是字面意义上的。如果我 `print("parrot")`，它将准确地显示在终端中。
- en: The only exception occurs when you use a backslash (`\`) to escape a particular
    character, like I did with that newline at the beginning ❶. It is conventional
    to escape the first newline after the opening triple quotes, just to make the
    code look cleaner.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是当你使用反斜杠（`\`）来转义某个特定字符时，像我在开头 ❶ 处理换行符那样。通常建议转义开头的第一个换行符，只是为了让代码看起来更整洁。
- en: The built-in `textwrap` module has some functions for working with multiline
    strings, including tools that allow you remove leading indentation (`textwrap.dedent`).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `textwrap` 模块有一些用于处理多行字符串的函数，包括可以去除前导缩进的工具（`textwrap.dedent`）。
- en: Alternatively, you can *concatenate* (combine) string literals, simply by writing
    them next to one another, without any operators between them. For example, `spam
    = "Hello " "world" "!"` is valid, resulting in the string `Hello world!.` If you
    wrap the assignment expression in parentheses, you can even span multiple lines.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以*连接*（组合）字符串字面量，只需将它们并排写在一起，而不在它们之间使用任何运算符。例如，`spam = "Hello " "world"
    "!"` 是有效的，结果是字符串 `Hello world!`。如果你将赋值表达式括在括号中，甚至可以跨多行书写。
- en: Raw Strings
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始字符串
- en: '*Raw strings* constitute another form of string literal, wherein the backslash
    (`\`) is always treated as a literal character. They’re preceded with an `r`,
    such as in this example:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始字符串*构成了另一种字符串字面量形式，其中反斜杠（`\`）始终被视为字面字符。它们以 `r` 为前缀，例如这个例子：'
- en: '[PRE95]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Listing 3-31: *raw_string.py*'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-31：*raw_string.py*
- en: 'The backslash is treated like a literal character, which means that nothing
    can be escaped inside of a raw string. The output of that line of code looks like
    this:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠被视为字面字符，这意味着在原始字符串内不能转义任何内容。那行代码的输出看起来是这样的：
- en: '[PRE96]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This has implications for what type of quotes you use, so beware.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 这会影响你使用什么类型的引号，所以要小心。
- en: 'Compare these two lines and their outputs:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两行及其输出：
- en: '[PRE97]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Listing 3-32: *raw_or_not.py*'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-32：*raw_or_not.py*
- en: 'The first string is ordinary, so `\n` is treated as a normal escape sequence:
    specifically, the newline character. That line break appears in the output, like
    this:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符串是普通字符串，所以 `\n` 被视为一个普通的转义序列：具体来说，是换行符。这个换行符会出现在输出中，像这样：
- en: '[PRE98]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The second string is a raw string, so the backslash (`\`) is treated as a literal
    character in its own right. The output would be as follows:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字符串是原始字符串，所以反斜杠（`\`）作为字面字符处理。输出将如下所示：
- en: '[PRE99]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This is particularly useful for regular expression patterns, where you’re likely
    to have plenty of backslashes that you want as part of the *pattern*, not interpreted
    by Python before it gets there. ***Always use raw strings for regular expression
    patterns.***
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于正则表达式模式特别有用，因为你可能会有很多反斜杠，这些反斜杠应该作为*模式*的一部分，而不是在到达那里之前被 Python 解释。***始终对正则表达式模式使用原始字符串。***
- en: Formatted Strings
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化字符串
- en: A third kind of string literal is a *formatted string* or *f-string*, which
    is new as of Python 3.6 (defined in PEP 498). It allows you to insert the values
    of variables into a string in a very elegant manner.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种字符串字面量是*格式化字符串*或*f-string*，这是 Python 3.6 引入的新特性（在 PEP 498 中定义）。它允许你以非常优雅的方式将变量的值插入到字符串中。
- en: 'If I wanted to include the value of a variable in a string without an f-string,
    the code might look like this:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想在字符串中插入一个变量的值而不使用 f-string，代码可能是这样的：
- en: '[PRE100]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Listing 3-33: *cheese_shop.py:1a*'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-33：*cheese_shop.py:1a*
- en: The `str()` function converts the value passed to it into a string, and then
    the three strings are *concatenated*, or combined, into one, using the `+` operator.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()` 函数将传递给它的值转换为字符串，然后这三个字符串通过 `+` 运算符*连接*（组合）成一个字符串。'
- en: Using f-strings, this code becomes more elegant.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 f-string 后，这段代码变得更加优雅。
- en: '[PRE101]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Listing 3-34: *cheese_shop.py:1b*'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: You precede the string literal with an `f`. Inside, you can substitute a variable
    by wrapping it in curly braces (`{ }`). The `f` tells Python to interpret and
    evaluate as an expression anything in the string that’s wrapped in curly braces.
    This means you’re not limited to variables in those curly braces. You can put
    just about any valid Python code in there, including math, function calls, conditional
    expressions, or whatever you need.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: As of Python 3.8, you can even display both the expression *and* its result
    by appending a trailing equal sign (`=`).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Listing 3-35: *expression_fstring.py*'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of gotchas when using f-strings:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if you want to wrap an expression in literal curly braces, you must
    use two curly braces (`{{ }}`) for every one you want displayed:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Listing 3-36: *literal_curly_braces.py*'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an odd number of braces, one pair will be ignored. So, if I used
    five pairs, the result would be the same as if I only had four: two literal pairs
    would be printed.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you cannot use backslashes within an expression in an f-string. This
    makes it difficult to escape quotes inside expressions. For example, this would
    not work:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: To get around this, I’d need to use triple quotes on the outside of the string,
    to ensure I can employ both single and double quotes inside of the expression.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Backslashes have other roles. The documentation points out the following problematic
    situation:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: There’s no direct way around this limitation. Instead, you’d have to evaluate
    that expression in advance, assign the result to a name, and use it in the f-string.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Third, and perhaps least surprising, you cannot put comments inside of f-string
    expressions; the hash (`#`) symbol isn’t allowed, except as a string literal.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Lastly, you can never use f-strings as docstrings.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: These small wrinkles aside, f-strings are incredibly straightforward to work
    with.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: Format Specifications
  id: totrans-755
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides arbitrary expressions, f-strings support *format specifications*, which
    allow you to control how values are displayed. This is a fairly in-depth topic
    that could easily become a main section on its own, so I will entrust you to the
    guidance of the documentation for the bulk of it. I’ll breeze over the essentials
    herein.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after the expression, you may choose to include one of three special
    flags: `!r`, `!a`, or `!s` (although that last one is the default behavior, so
    it can be omitted in most cases). These determine which function is used to fetch
    the string representation of some value: `repr()`, `ascii()`, or `str()`, respectively
    (see “String Conversion” below).'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the format specification itself, which always begins with a colon
    (`:`), followed by one or more flags. These have to be specified in a particular
    order to work, although any of them may be omitted if they’re not desired:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: Align An alignment flag, specifying left (`<`), right (`>`), center (`^`), or
    (if numeric) split with the sign aligned left but the digits aligned right (`=`).
    This is optionally preceded by a character that will be used to fill any blank
    space in the alignment.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: Sign A flag controlling when the sign is displayed on a number. The plus (`+`)
    flag displays the sign on both positive and negative numbers, while the minus
    (`–`) flag only displays it on negative numbers. A third option is to show a leading
    space on positive numbers and a sign on negative numbers (space).
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: Alternative form The hash (`#`) flag turns on the “alternative form,” which
    has different meanings for different types (see documentation).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: Leading zeros The zero (`0`) flag causes leading zeros to be displayed (unless
    a fill character is specified for alignment).
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: Width The width of the output string in characters. This is where the alignment
    comes into play.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: Grouping A flag controlling whether numbers should separate thousands with a
    comma (`,`) or an underscore (`_`). If omitted, no separator is used. If enabled,
    the underscore separator also appears every four digits in octal, hexadecimal,
    and binary numbers.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: Precision A dot (`.`), followed by an integer for decimal precision.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: Type A flag controlling how numbers are displayed; common options include binary
    (`b`), character (`c`), decimal (`d`), hexadecimal (`x`), exponent notation (`e`),
    fixed-point (`f`), and general (`g`). There are more (see documentation).
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is a bit abstract, so here are a few quick examples:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Listing 3-37: *formatting_strings.py*'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete details about the format specification can be found in the official
    Python documentation: [https://docs.python.org/3/library/string.html#format-string-syntax](https://docs.python.org/3/library/string.html#format-string-syntax).'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: Another useful reference is [https://pyformat.info](https://pyformat.info),
    although as of this writing, it only shows the format specification in the context
    of the old `format()` function. You will need to apply it to f-strings yourself.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: Previous String-Formatting Methods
  id: totrans-772
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re reading older Python code, you may encounter the two previous forms
    of string formatting: `%` notation and the newer `format()`. These have both been
    superseded by f-strings, which have superior performance. That’s because they’re
    parsed and converted to bytecode *before* the code is run.'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself needing to rewrite a `format()` call as an f-string, the
    process is thankfully quite simple.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example. I’ll start out with a couple of variables:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Listing 3-38: *format_to_fstring.py:1*'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the advent of f-strings, if I wanted to print out a message containing
    the values of those two variables, I’d have used `format()`:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Listing 3-39: *format_to_fstring.py:2a*'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: In the old format, a string literal ❶ would contain sets of curly braces, optionally
    containing the format specifications. The `format()` function would be called
    on that string literal (or on a name referencing it). Then, the expressions to
    be evaluated would be passed to the `format()` function in order ❷.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: 'That would have the following output:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Converting this to an f-string is as simple as moving the expressions into
    the string literal in order and then prepending an `f` to the literal to make
    it an f-string:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Listing 3-40: *format_to_fstring.py:2b*'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: The output is the same as before.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, with `format()`, you could refer to the index of the expression
    in the argument list:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Listing 3-41: *format_to_fstring.py:3a*'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: 'That produces this output:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'To convert this code to an f-string, you substitute the expressions in place
    of the indices in the string literal, which you (again) turn into an f-string
    by prepending an `f`:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Listing 3-42: *format_to_fstring.py:3b*'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: Converting from `%` notation is a little less trivial, but most Python 3 code
    uses `format()` anyway. If you find yourself needing to do this, [https://pyformat.info](https://pyformat.info)
    does an excellent job of comparing `%` notation and `format()`.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: Template Strings
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Template strings* constitute one more alternative to f-strings that is worth
    knowing about, especially as it still fulfills some use cases, including internationalizing
    user interfaces. Personally, I find template strings a bit more reusable. On the
    other hand, the drawback is that they’re considerably more limited in terms of
    formatting.'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: If you know how they work, you’ll be equipped to decide for yourself which tool
    is best for your particular situation.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a template string for greeting a user:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Listing 3-43: *template_string.py:1*'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: To use template strings, I first have to import `Template` from the `string`
    module.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: 'Then I can create a new `Template` and pass it a string literal:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Listing 3-44: *template_string.py:2*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: I can name my fields whatever I want, preceding each with a dollar sign (`$`).
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I call the `substitute()` function on the template I created (`s`)
    and pass expressions to each of the fields:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Listing 3-45: *template_string.py:3*'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished string is returned, and in this case, it is passed to `print()`
    and displayed:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'There are a couple of odd syntax rules with template strings. First, to show
    a literal dollar sign in the string literal, use two dollar signs (`$$`). Second,
    to substitute an expression as part of a word, wrap the name of the field in curly
    braces (`{ }`). Both of these rules are demonstrated below:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Listing 3-46: *template_string.py:4*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: There’s a handful of additional abilities contained within string templates,
    but I’ll entrust you to the official Python documentation for the rest of that.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: String Conversion
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I previously mentioned that there are three ways to get the string representation
    of a value: `str()`, `repr()`, and `ascii()`.'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: The first function, `str()`, is the one you’ll use most often, as it returns
    the *human-readable* representation of the value.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, `repr()` returns the *canonical string representation* of the
    value: that is, (usually) the value as Python sees it. In the case of many basic
    data types, this will return the same thing as `str()`, but when used on most
    objects, the output contains additional information useful in debugging.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: The `ascii()` function is the same as `repr()`, except that the string literal
    it returns is completely ASCII-compatible, having escaped any non-ASCII (for example,
    Unicode) characters.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: I’ll return to this concept in Chapter 7, when I start defining my own objects.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: A Note on String Concatenation
  id: totrans-825
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point, I’ve been using the addition (`+`) operator for concatenating
    strings together. This is acceptable in basic situations.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: However, this is seldom the most efficient solution, especially when combining
    multiple strings. Therefore, it is recommended to prefer the `join()` method,
    which is called on a string or string literal instead.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a comparison between the two. I start with a couple of string variables:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Listing 3-47: *concat_strings.py:1*'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, you’ve seen concatenation with the addition (`+`) operator, like this:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Listing 3-48: *concat_strings.py:2a*'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, I can use the `join()` method:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Listing 3-49: *concat_strings.py:2b*'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: I call the `join()` method on the string that will appear between each piece.
    In this case, I use an empty string. The `join()` method accepts a *tuple* of
    strings—an array-like structure wrapped in parentheses, and therefore, the double
    set of parentheses in the code. I’ll introduce tuples in an upcoming section.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: Typical concatenation with `+` or the `join()` function has the same result,
    but the latter function will be *as fast or faster*, especially when you’re using
    other implementations of Python besides CPython. Therefore, whenever you need
    to concatenate and f-strings aren’t right for the job, you should consider using
    `join()` instead of the `+` or `+=` operators. In practice, f-strings are the
    fastest, but `join()` is your next-best option.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-839
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python functions are *first-class citizens*, which means they can be treated
    like any other object. Even so, you call them as you would in any other programming
    language.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of a very basic function, which prints a selected type of
    joke to the terminal.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: 'I start with the function header:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Listing 3-50: *joke_function.py:1*'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: I declared the function with the `def` keyword, followed by the name of the
    function. Parameters are named in the parentheses after the function name. The
    entire header is concluded with a colon (`:`).
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the header, indented one level, is the *suite* (or body) of the function:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Listing 3-51: *joke_function.py:2*'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: 'You call functions in much the same way as in most languages:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Listing 3-52: *joke_function.py:3*'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: I’ll go into depth on functions and their many cousins in Chapter 6.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: Classes and Objects
  id: totrans-853
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python fully supports object-oriented programming. In fact, one of the language’s
    design principles is that “everything is an object,” at least behind the scenes.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot more to classes than meets the eye, but for now, you should just
    get an absolutely bare-bones familiarity with the syntax.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class contains a joke of a selected type and displays it on demand:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Listing 3-53: *joke_class.py:1*'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: I define the class using the `class` keyword, the name of the class, and a colon
    (`:`) at the end of the header.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: 'This is followed by the suite of the class, indented one level:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Listing 3-54: *joke_class.py:2*'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: The initializer, which is similar in purpose to the constructor in other OOP
    languages, is a member function, or *method*, with the name `__init__()` and at
    least one parameter, `self`.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Listing 3-55: *joke_class.py:3*'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions that belong to the class are called methods and are part of the class
    suite. Methods must accept at least one parameter: `self`.'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: 'You would use this class like so:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Listing 3-56: *joke_class.py:4*'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: You create a new instance of the `Joke` class by passing the string `"lethal"`
    to its *initializer*, the `__init__()` from earlier. The new object is stored
    in the variable `lethal_joke`.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: Then, you use the *dot operator* (`.`) to call the function `tell()` within
    the object. Take note that you didn’t have to pass any argument for `self`. That’s
    done automatically when you call the function in this manner.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: I’ll discuss classes and objects in detail in Chapter 7 and further in Chapter
    13.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling
  id: totrans-873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python offers error and exception handling functionality through the `try` compound
    statement.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: For example, if I wanted to get a number from the user, I couldn’t reliably
    predict what they would type in. Trying to convert a string, like `"spam"`, to
    an integer would cause an error. I can use error handling to take a different
    action if it isn’t possible to convert the user `input`.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Listing 3-57: *try_except.py*'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: I get a string from the user, and then in the `try` clause, I attempt to convert
    it to an integer with the `int()` function. That would raise a `ValueError` exception
    if the string it’s trying to convert is not a valid whole number (base 10).
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: If that exception is raised, I catch it in the `except` clause and handle the
    failure.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the last line would always be run.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: There are additional features and subtleties to the `try` statement, including
    `finally` and `else` clauses, which I’ll cover in Chapter 8. For now, it’s better
    to avoid these concepts rather than use them incorrectly.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and Lists
  id: totrans-882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two of Python’s most common built-in data structures, called *collections*,
    are tuples and lists.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '*Lists* constitute the most array-like collection in Python. In CPython, they
    are implemented as variable-length arrays, not as linked lists like the name might
    suggest.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a list of strings with names of cheeses:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Listing 3-58: *cheese_list.py:1*'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: You enclose a list literal in square brackets, separating each item in the list
    with commas.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access or reassign the values of individual items with the same bracket
    notation used by most programming languages:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Listing 3-59: *cheese_list.py:2*'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: A *tuple* is somewhat similar to a list, but with a few key differences. First,
    a tuple cannot have items added, reassigned, or removed after its creation. Attempting
    to modify the contents of a tuple with bracket notation will result in a `TypeError`.
    This is because tuples, unlike lists, are *immutable*, effectively meaning their
    contents cannot be modified (see Chapter 5 for the full explanation).
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a tuple:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Listing 3-60: *knight_tuple.py:1*'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: 'You enclose tuple literals in parentheses (`( )`), instead of brackets (`[
    ]`). Nevertheless, you still use bracket notation to access individual items:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Listing 3-61: *knight_tuple.py:2*'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said, you cannot change the items of a tuple after creation, such as if
    you tried to reassign the first item:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Listing 3-62: *knight_tuple.py:3*'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: The guideline is to use tuples for collections of items of different types (*heterogeneous*
    collections) and to use lists for collections of items of the same type (*homogeneous*
    collections).
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: I’ll discuss these collections, and many more, in Chapter 9.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  id: totrans-904
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has two basic loop types: *while* and *for*.'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: while Loop
  id: totrans-906
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` loop probably looks familiar from other languages:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Listing 3-63: *while_loop.py*'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: I start the loop with the `while` keyword, follow it with the condition to test,
    and finish the header with a colon (`:`). As long as that condition evaluates
    to `True`, the code in the suite of the loop is executed.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: When you need to keep running a loop until some condition is met, use `while`
    loops. These are particularly useful when you don’t know how many iterations of
    the loop will take place before the condition is met.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: Loop Control
  id: totrans-912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can manually control the loop, using two keywords. The `continue` keyword
    abandons the current iteration and jumps to the next one. The `break` keyword
    exits the loop altogether.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: 'One common scenario where you may use these keywords is in an infinite loop
    used for running a game or a user interface. For example, here’s a very simple
    command prompt:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Listing 3-64: *loop_control.py*'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: The loop `while True` is inherently infinite; `True` is always `True`. That’s
    the behavior I actually want here, since I want to keep iterating until the user
    enters the string `"exit"`, at which point, I manually end the loop with `break`.
    (By the way, if you’ve been waiting for a `do-while` loop, this is effectively
    the way to recreate that behavior.)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: The command `"sing"` has a different behavior, after which I’d want to immediately
    go to the top and prompt the user for another command, skipping the last print
    statement. The `continue` keyword does exactly that, immediately abandoning the
    current iteration and jumping back to the top of the loop.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: for Loop
  id: totrans-919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s `for` loop is a little different from loops in many languages. It’s
    generally used for iterating over a range, list, or other collection.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Listing 3-65: *for_loop.py*'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: I start the loop header with the `for` keyword. Technically, this kind of loop
    is a `for`-`in` (or “`for`-`each`”) loop, meaning the loop iterates once for each
    item in the given range, list, or other collection. This means the loop needs
    something to iterate over—in this case, a special object called `range()`—which
    iterates over a range of values, returning each one in turn. I’ve specified that
    I want the range to start with the value `1` and end before `11`. The local variable
    `i` will refer to the current item for each iteration. Finally, the `in` keyword
    precedes the thing I’m iterating over—that is, before `range()` in this example.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: As long as there are items to iterate over, the code belonging to the loop will
    be executed—in this case, printing out the value of the current item. The loop
    stops when the last item is iterated over.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: Running this code would print the numbers 1 through 10.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: This only scratches the surface of loops. See Chapter 9 for more.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: Structural Pattern Matching
  id: totrans-927
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many years, developers coming to Python from languages like C, C++, Java,
    or Javascript would ask if there was a Python equivalent to the `switch`/`case`
    statement (or `match`/`case` in Scala, `case`/`when` in Ruby, and so on). They’d
    always be disappointed to hear a resounding “No!” Python only had conditional
    statements.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: At long last, Python 3.10 gained *structural pattern matching* via PEP 634\.
    This provides conditional logic that is at least syntactically similar to `switch`
    statements of other languages. In short, you test a single *subject*, such as
    a variable, against one or more *patterns*. If the subject matches the pattern,
    the associated suite of code runs.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: Literal Patterns and Wildcards
  id: totrans-930
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the most basic use case, you can check a variable against different possible
    values. These are called *literal patterns*. For example, perhaps I want to display
    different messages, depending on a user’s `input` `lunch` `order`:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Listing 3-66: *pattern_match.py:1a*'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: The value of `lunch_order` is compared to each case until it matches one. Once
    a match is found, the case’s suite is run, and the match statement is finished;
    the value won’t be checked against additional patterns once it matches one. So,
    if the user inputs `"pizza"`, the `"Pizza` `time!"` message is displayed. Similarly,
    if they input `"taco"`, the message `"Taco,` `taco,` `TACO,` `tacotacotaco!"`
    is displayed instead.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: The underscore (`_`) in the last case is the *wildcard*, which will match any
    value. This serves as a fallback case, and it must come last, as it will match
    anything.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: Or Patterns
  id: totrans-936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A single case can cover multiple possible values. One way to do this is with
    an *or pattern*, where possible literal values are separated by the bar character:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Listing 3-67: *pattern_match.py:1b*'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: This pattern will match if the user enters either `"salad"` or `"soup"` at the
    prompt.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: Capture Patterns
  id: totrans-941
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One particularly helpful feature of structural pattern matching is the ability
    to capture part or all of the subject. For example, it isn’t very helpful in our
    example that the fallback case only says `"Yummy."`. Instead, I’d like to have
    a default message announcing the user’s selection. To do that, I write a *capture
    pattern* like this:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Listing 3-68: *pattern_match.py:1c*'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: This pattern acts like a wildcard, except the value of `lunch_order` is captured
    as `order`. Now, no matter what the user enters, if it doesn’t match any of the
    previous patterns, the value will be captured and displayed in the message here.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: 'Capture patterns don’t just have to capture the entire value. For example,
    I can write a pattern that matches a tuple or list (a *sequence*) and then captures
    only part of that sequence:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Listing 3-69: *pattern_match.py:1d*'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: In this version, if the lunch order has a space, I split the string into two
    parts, which are stored in a list. Then, if the second item in the sequence has
    the value `"ice cream"`, the first part is captured as `flavor`. Thus, the code
    can account for Bojan if he decides to break down and have strawberry ice cream
    for lunch. (And I’m not stopping him!)
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: 'The capture pattern feature has one surprising downside: all *unqualified*
    names in patterns—that is, any bare variable names with no dots—will be used to
    capture. This means that if you want to use the value assigned to some variable,
    it must be *qualified*, meaning you must access it within some class or module
    with the dot operator:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Listing 3-70: *pattern_match.py:1e*'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: Guard Statements
  id: totrans-953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One last trick I’ll demonstrate with pattern matching is the *guard statement*,
    an additional conditional statement that must be satisfied for a pattern to match.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the current version of my lunch order example, using the logic
    to split the order by spaces means the code doesn’t behave very nicely with other
    foods with spaces in them. Also, if I enter `"rocky road ice cream"`, it won’t
    match the current ice cream pattern.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: Instead of splitting my string by spaces, I can write a pattern with a guard
    statement that looks for the words *ice cream* in the lunch order.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Listing 3-71: *pattern_match_object.py:1f*'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: The pattern here captures the value as `ice_cream`, but only if the guard statement
    `if 'ice cream' in ice_cream` is satisfied. In that case, I use `.replace()` to
    remove the words *ice cream* from the captured value, leaving me with only the
    name of the flavor. I also use `.strip()` to remove any leading or trailing whitespace
    from the new string. Finally, I print out my message.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: More About Structural Pattern Matching
  id: totrans-960
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are quite a few other tricks and techniques that work with structural
    pattern matching. They work with objects (see Chapter 7), with dictionaries via
    mapping patterns (see Chapter 9), and even by support nesting patterns within
    other patterns.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: As with many Python techniques, pattern matching feels like “magic,” and there’s
    a strong temptation to use it everywhere possible. Resist this urge! Structural
    pattern matching is very useful for checking a single subject against multiple
    possible patterns, but as you can even see from the “ice cream” situation in the
    lunch order example, it quickly reaches its limits as the possible values of the
    subject get more elaborate. As a rule, if you’re unsure whether you need structural
    pattern matching in a particular situation, stick with conditional statements.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn even more, read PEP 636, which serves as the official tutorial for
    this topic and demonstrates all of the functionality available with this language
    feature: [https://peps.python.org/pep-0636/](https://peps.python.org/pep-0636/).'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-964
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should now have a feeling for Python’s syntax and a basic familiarity with
    its key structures. If you were to stop here, you could probably write Python
    code that at least works. In fact, many developers new to the language do indeed
    work with about this much information, implicitly bringing the habits and practices
    of whatever language they know best.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: There is a profound difference between valid code and idiomatic, Pythonic code.
    Writing the latter is the focus of this book.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-967
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Project Structure and Imports
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-969
  prefs: []
  type: TYPE_IMG
- en: I’ve found that structuring a Python project is one of the most often overlooked
    components of teaching the language. Many developers therefore get their project
    structure wrong, stumbling through a jumble of common mistakes until they arrive
    at something that at least works.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the good news: you don’t have to be one of them!'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll introduce import statements, modules, and packages, and
    I’ll show you how to fit everything together without tearing your hair out.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware, I’m skipping over one critical piece of project structure in this
    chapter: *setup.cfg*, as it relies on concepts we haven’t yet covered. Without
    a *setup.cfg* or *setup.py* file, your project will not be ready to ship to end
    users. In this chapter, you’ll put everything in the right place for development.
    From there, preparing your project for distribution will be a fairly simple process.
    I’ll cover *setup.cfg*, *setup.py*, and other project structure issues relating
    to distribution in Chapter 18.'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Repository
  id: totrans-974
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before delving into the actual project structure, I want to address how it will
    fit into your *version control system (VCS)*, which I recommend using. For the
    rest of this book, I’ll assume you’re using Git, as that’s the most common option.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve created your repository and cloned a local copy to your computer,
    you can begin to set up your project. At minimum, create the following files:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: '*README*, which is a description of your project and its goals'
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*LICENSE*, which is your project’s license'
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.gitignore*, which is a special file that tells Git what files and directories
    to ignore'
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A directory, which has the name of your project
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your Python code belongs in a separate subdirectory and not in the root of the
    repository. This is very important, as your repository’s root directory will get
    mighty cluttered with build files, packaging scripts, documentation, virtual environments,
    and all manner of other things that aren’t actually part of the source code.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, in this chapter, I’ll use one of my own Python projects: *omission*.'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: A Python project is composed of modules and packages. In the next section, I’ll
    cover what those are and how to create them.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: Modules and Packages
  id: totrans-984
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *module* is any Python (*.py*) file. (Anticlimactic, isn’t it?)
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: A *package*, occasionally called a *regular package*, is one or more modules
    within a directory. That directory must include a file called *__init__.py* (which
    can be empty). The *__init__.py* file is important! If it isn’t there, Python
    will not know the directory constitutes a package.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: You can leave the *__init__.py* file empty (it often is), or you can use it
    to run certain code when the package is first imported. For example, you might
    use `__init__.py` to select and rename certain functions, so the end user of the
    package doesn’t need to understand how the modules are laid out. (See the subsection
    “Controlling Package Imports” later in the chapter.)
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: If you do forget *__init__.py* in your package, it becomes an *implicit namespace
    package*, also just known as a *namespace package*. These behave differently from
    regular packages. ***The two are not interchangeable!*** A namespace package allows
    you to distribute a package in multiple pieces, called *portions*. There are some
    cool advanced things you can do with namespace packages, but you will seldom need
    them. As this is a doozy of a rabbit hole, if you need namespace packages, see
    the documentation at [https://packaging.python.org/guides/packaging-namespace-packages/](https://packaging.python.org/guides/packaging-namespace-packages/).
    You can also read PEP 420, which officially defined the concept.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: In my project structure, *omission* is a package that contains other packages.
    Thus, *omission* is my *top-level package*, and all the packages underneath it
    are its *subpackages*. This convention will be important once you start importing
    stuff.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: PEP 8 and Naming
  id: totrans-990
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your packages and modules need clear names to identify them. Consulting with
    PEP 8 about the naming conventions reveals this:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: Modules should have short, all-lowercase names. Underscores can be used in the
    module name if it improves readability. Python packages should also have short,
    all-lowercase names, although the use of underscores is discouraged.
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Understand that modules are named by filenames and packages are named by their
    directory name. Thus, these conventions define how you name your directories and
    code files.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, filenames should be all lowercase, with underscores (`_`) if that
    improves readability. Similarly, directory names should be all lowercase, without
    underscores if at all possible. To put that another way . . .
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: 'Do this: *omission/data/data_loader.py*'
  id: totrans-995
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'NOT this: *omission/Data/DataLoader.py*'
  id: totrans-996
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project Directory Structure
  id: totrans-997
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With that covered, take a look at my project’s repository directory structure:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Listing 4-1: Directory structure of *omission-git/*'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see that I have one top-level package called *omission*, with four subpackages:
    *common/*, *data/*, *game/*, and *tests/*. Each subpackage contains an *__init__.py*
    file, which is what designates them as packages. Every file that ends in *.py*
    is a module.'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: I also have the directory *resources/*, but that only contains game audio, images,
    and other sundry files (omitted here for brevity). The *resources/* directory
    is *not* a regular package, as it doesn’t contain an *__init__.py*.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: 'I have another special file in my top-level package: *__main__.py*. This is
    the file that runs when I execute my top-level package directly, via this command:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: I’ll come back to *__main__.py* in a bit (see the subsection “Package Entry
    Points” later in the chapter), as well as explain that lonely little *omission.py*
    file outside the top-level package.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: How import Works
  id: totrans-1006
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’ve written any meaningful Python code before, you’re almost certainly
    familiar with the `import` statement for importing modules. For example, to use
    it to import the module for regex, you’d enter this:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Once you’ve imported a module, you can access any variables, functions, or classes
    defined within it.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: When you import the module, you are actually running it, which in turn executes
    any other `import` statements in the module. If there are any errors or performance
    costs in those secondarily (and onward) imported modules, they might seem to originate
    from your otherwise innocent import statement. It also means that Python has to
    be able to find all those modules.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the module *re.py*, which is part of the Python standard library,
    has several import statements of its own, which are executed when you `import
    re`. The contents of those imported modules aren’t automatically available to
    the file you imported `re` from, but those module files have to exist for `import
    re` to succeed. If, for some unlikely reason, *enum.py* (another module that is
    part of the Python standard library) got deleted from your Python environment
    and you ran `import re`, it would fail with an error:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: This might seem like a confusing error message. I’ve seen people erroneously
    wonder why the outer module (in this example, `re`) couldn’t be found. Others
    have wondered why the inner module (`enum` here) is being imported at all, since
    they didn’t ask for it directly in their code.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the `re` module was imported, and that in turn imported
    the `enum` module. However, because the `enum` module is missing, importing `re`
    fails with a `ModuleNotFoundError`.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: 'Take note that this scenario is fictional: `import enum` and `import re` will
    never fail under normal circumstances, because both modules are part of Python’s
    standard library. However, this little example demonstrates the common problem
    of `import` statements failing due to missing modules.'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: Import Dos and Don’ts
  id: totrans-1016
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various ways of importing, but most of them should rarely, if ever,
    be used.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: 'For the upcoming examples, I’ll be using a module called *smart_door.py*, which
    reads as follows:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Listing 4-2: *smart_door.py*'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say I want to use this module in another Python file, which (in this
    example) is in the same directory. To run the functions defined in that module,
    I’d have to first import the module `smart_door`. The easiest way to do this is
    as follows:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Listing 4-3: *use_smart_door.py:1a*'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: The *namespace* of `open()` and `close()` is `smart_door`. A *namespace* is
    an explicitly defined path to something, such as a function. The function `open()`
    has the namespace `smart_door`, which tells me that `open()` belongs to that particular
    module. Remember this from The Zen of Python?
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea—let’s do more of those!
  id: totrans-1025
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python developers really like namespaces because they make it obvious where
    functions and whatnot are coming from. That comes in handy when you have multiple
    functions that have similar names or the same name, but that are defined in different
    modules. Without that bit of namespace, `smart_door`, you would not know that
    `open()` had anything to do with opening the smart door. Appropriately using namespaces
    can help you avoid massive errors in your code. However, as important as namespaces
    are, they can get out of hand very quickly if used improperly.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: Be advised, in referring to *namespaces*, I’m not necessarily talking about
    *implicit namespace packages*, which I don’t cover in this book.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a look at some good and bad examples of namespaces in action.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: Importing Functions from Modules
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In my previous `smart_door` function calls, I referenced the namespace on every
    function call. This is usually best when a function is called only a handful of
    times, but if you use a function often, it gets tedious to use a namespace for
    every single function call.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, Python provides a way around that. To be able to use the `open()`
    function without constantly having to precede it with its module name (`smart_door`),
    I need only know the *qualified name*—that is, the name of the function, class,
    or variable, preceded by its complete namespace within one of its modules or packages
    (if any). Within the *smart_door.py* module, the qualified name of the function
    I want is just `open`. Thus, I import that function like this, instead:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Listing 4-4: *use_smart_door.py:1b*'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: 'This introduces a new problem. Neither `close()` nor `smart_door.close()` will
    work in this example, because I didn’t import the function outright. The entire
    `smart_door` module was still run by the import command, but only the `open()`
    function was actually imported. To use `smart_door.close()`, I’d need to change
    the code to this:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Listing 4-5: *use_smart_door.py:1c*'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: This gives me access to both functions, no namespace required.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: The Problem of Shadowing
  id: totrans-1038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might have noticed another problem: `open()` is already a built-in Python
    function! Assume I also need to read a file called *data.txt*, which exists in
    my current directory. If I try this after importing `open()` from the `smart_door`
    function ([Listing 4-5](#listing4-5)), my program is going to behave very badly:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Listing 4-6: *use_smart_door.py:2*'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: When I used `open()` earlier ([Listing 4-5](#listing4-5)), I wanted to use `smart_door.open()`.
    Now, in the same file, I’m trying to call Python’s built-in `open()` function
    to open a text file for reading. Unfortunately, because of the earlier import,
    the built-in `open()` function has been *shadowed* by `smart_door.open()`, meaning
    the presence of the latter is making it impossible for Python to even find the
    former. This code will fail!
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: I got that error because I’m trying to use the built-in `open()` function, which
    accepts two arguments, but I unintentionally called `smart_door.open()`, which
    doesn’t accept any arguments.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: Getting an actual error message is one of the better failure scenarios for this
    sort of mistake. Imagine if `smart_door.open()` did accept similar arguments to
    the built-in `open()`. Depending on my code, I might wind up with an error elsewhere
    (perhaps from trying to use a file I hadn’t opened), or worse, some form of incorrect
    but technically valid behavior. This sort of mistake is infamously difficult to
    debug, so it is wise to avoid.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: 'So how should I fix this? If I were the one who wrote *smart_door.py*, I should
    just go and change the function name. It’s universally considered bad practice
    to use function names that shadow built-in Python functions anyhow, unless the
    entire point *is* to shadow. However, assume that I’m not the author of that module
    and I need another solution. Thankfully, Python offers one in the `as` keyword,
    which allows me to create an alias for that function:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Listing 4-7: *use_smart_door.py:1d*'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: In the import, I use the `as` keyword to rename `smart_door.open()` to `door_open()`,
    but only in the context of this file. Then, I can refer to `door_open()` where
    I wanted `smart_door.open()`.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: This leaves Python’s built-in `open()` function unshadowed, so the earlier code
    for working with the file ([Listing 4-6](#listing4-6)) can function properly.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The Trouble with Nested Packages
  id: totrans-1052
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you’ve seen, packages can contain other packages. In my *omission* project,
    if I wanted to import the module *data_loader.py*, I could use this line (refer
    back to the *omission* project structure):'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The Python interpreter looks for the *omission* package, the *data* package
    inside that, and the *data_loader* module inside that. The *data_loader* module
    (and only that module) is imported. This is a good structure, and all’s well.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: 'At a certain point, however, nesting packages can become a pain. A function
    call like `musicapp.player.data.library.song.play()` is just ugly, not to mention,
    difficult to read. As The Zen of Python muses:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: Flat is better than nested.
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some nesting of packages is certainly okay, but when your project starts looking
    like an elaborate set of Matryoshka dolls, you’ve done something wrong. Organize
    your modules into packages, but keep the structure reasonably simple. Nesting
    two or three packages deep is okay; deeper is generally not advisable, if it can
    be avoided.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we’d never have overly nested nightmares in an ideal world, real-life
    projects aren’t always that neat. Sometimes, it isn’t possible to avoid deep nesting
    structures. I need another way to keep my import statements sane. Graciously,
    the import system can handle this:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: I only have to deal with the deeply nested namespace once, in the actual import
    statement. After that, I just use the function name, `play()`.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if I want a little bit of namespace, I can have that, too:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: My import statement has resolved all but that last bit of namespace, `song`,
    so I still know where the `play()` function is coming from.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: The import system is deliciously flexible like that.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: Beware of Importing All
  id: totrans-1066
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before long, you’ll probably find yourself tempted to import all of the hundreds
    of functions in your module, to save time. This is the point at which many developers
    go off the rails:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: This statement imports nearly everything in the module directly, except for
    anything preceded by one or more underscores. This import-all pattern is a Very
    Bad Idea, as you won’t know what all is getting imported or what will be shadowed
    in the process.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem gets even worse when you start importing all from multiple modules:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Doing this, you may be blissfully unaware that `open()`, `smart_door.open()`,
    and `gzip.open()` all exist and are fighting over the same name in your file!
    The function `gzip.open()` will win out in this example, because it’s the last
    version of `open()` that was imported. The other two functions have been shadowed,
    which means you effectively can’t call them at all.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: Since no one is likely to remember every single function, class, and variable
    in every module that gets imported, one can easily wind up with a whole lot of
    messes.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: 'The Zen of Python applies to this situation:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1076
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (. . .)
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-1079
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You should never have to guess where a function or variable is coming from.
    There should be code somewhere in the file that explicitly tells you where everything
    comes from, as seen in the preceding examples.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: This `import *` doesn’t quite work the same way with packages. By default, a
    line like `from some_package import *` will be functionally the same as `import
    some_package`, unless the package has been configured to work with `import *`.
    I’ll come back to this later.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: Importing Within Your Project
  id: totrans-1082
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to structure your project and import from packages and
    modules, I’ll tie everything together.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall my *omission* project structure from [Listing 4-1](#listing4-1). Here’s
    a subsection of that project directory:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Listing 4-8: Directory structure of *omission-git/*'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: Any one module in my project may need to be able to import from another module,
    whether it’s within the same package or somewhere else in the project structure.
    I’ll explain how to handle both scenarios.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: Absolute Imports
  id: totrans-1088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have a class `GameMode` defined within the *game_enums.py* module, which lives
    in the *omission/common* package. I want to use that class within my *game_round_settings.py*
    module, defined in the *omission/data* package. How do I get to it?
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: 'Because I defined *omission* as a top-level package and organized my modules
    into subpackages, it’s pretty straightforward. In *game_round_settings.py*, I’d
    write the following:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Listing 4-9: *game_round_settings.py:1a*'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: This line is an *absolute import*. It starts at the top-level package, *omission*,
    and walks down into the *common* package, where it looks for *game_enums.py*.
    Inside that module, it finds whatever has the name `GameMode` and imports that.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: Relative Imports
  id: totrans-1094
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also import from a module in the same package or subpackage. This is
    known as a *relative import* or an *intrapackage reference*. In practice, intra-package
    references are easy to do wrong. If some developer wanted to import `GameMode`
    (which is provided by *omission/common/game_enums.py*) into *omission/data/game_round_settings.py*,
    they might incorrectly attempt to use something like the following:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Listing 4-10: *game_round_settings.py:1b*'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: This fails, leaving the developer wondering why it doesn’t work. The *data*
    package (where *game_round_settings.py* lives) has no knowledge of its sibling
    packages, such as *common*.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: A module knows what package it belongs to, and a package knows its parent package
    (if it has one). Because of this, relative imports can start the search from the
    current package and move up and down through the project structure.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: 'Within *omission/data/game_round_settings.py*, I can use the following import
    statement:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Listing 4-11: *game_round_settings.py:1c*'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: The two dots (`..`) mean “the current package’s direct parent package,” which,
    in this case, is *omission*. The import steps up one level, walks down into *common*,
    and finds *game_enums.py*.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: There’s some difference of opinion among Python developers about whether to
    use absolute or relative imports. Personally, I prefer to use absolute imports
    whenever possible, because I feel it makes the code a lot more readable. You can
    make up your own mind. The only important factor is that the result should be
    *obvious*—there should be no mystery about where anything comes from.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: Importing from the Same Package
  id: totrans-1105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one other lurking gotcha here. In *omission/data/settings.py*, I have
    this statement for importing a class from the module *omission/data/game_round_settings.py*:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Listing 4-12: *settings.py:1a*'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think that since both *settings.py* and *game_round_settings.py*
    are in the same package, *data*, I should be able to just use this:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Listing 4-13: *settings.py:1b*'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: However, that will not work. It will fail to locate the *game_round_settings.py*
    module because I am running the top-level package (`python3 -m omission`), and
    absolute imports for anything within the package being executed (*omission*) have
    to start from the top.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: 'I can instead use a relative import, which looks much simpler than the absolute
    import:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Listing 4-14: *settings.py:1c*'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the single dot (`.`) means “this package.”
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: 'This probably feels familiar if you’re used to the typical UNIX filesystem,
    although Python takes the concept a bit further:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: One dot (`.`) means the current package.
  id: totrans-1118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two dots (`..`) takes you back one level, to the parent package.
  id: totrans-1119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Three dots (`...`) takes you back two levels, to the parent of the parent package.
  id: totrans-1120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Four dots (`....`) takes you back three levels.
  id: totrans-1121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And so on, and so forth.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that those “levels” aren’t just plain directories; they’re packages.
    If you have two distinct packages in a plain directory that isn’t a package, you
    can’t use relative imports to jump from one to another. You’ll have to work with
    the Python search path for that. I’ll talk more about that later in this chapter.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: Entry Points
  id: totrans-1124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you’ve learned how to create modules, packages, and projects, and how
    to make full use of the import system. The last piece of this puzzle is gaining
    the ability to control what happens when a package is imported or executed. The
    parts of the project that are run first when importing or executing are called
    *entry points*.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: Module Entry Points
  id: totrans-1126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you import a Python module or package, it is given a special variable
    called `__name__`. This contains the *fully qualified name* of the module or package,
    which is the name as the import system sees it. For example, the fully qualified
    name of the module *omission/common/game_enums.py* would be `omission.common.game_enums`.
    There is one exception: when a module or package is run directly, its `__name__`
    is set to the value `"__main__"`.'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, assume I have a package called *testpkg*, which contains
    the module *awesome.py*. It defines a function, `greet()`:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Listing 4-15: *awesome.py:1*'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom of that same file also contains a `print` message:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Listing 4-16: *awesome.py:2a*'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: 'In another module in the same directory as *testpkg*, I have this module (*example.py*),
    which I run directly with `python3 example.py`:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Listing 4-17: *example.py*'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: If I look at the `_name_` local variable—which is the `__name__` presently assigned
    to the current module, *example.py*—I’ll see the value is `"__main__"` because
    I executed *example.py* directly.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: The package `awesome` I imported also has a `__name__` variable, which has the
    value `"testpkg.awesome"`, representing where the package came from in the import
    system.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ran that module, you’d get the following output:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: That first line is coming from *testpkg/awesome.py*, which is run by the import
    command. The rest is coming from the two print commands in *example.py*.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if I want that first message to appear only if *awesome.py* is executed
    directly, and *not* when the module is only imported? To accomplish that, I’d
    check the value of `__name__` variable in a conditional statement. I’ve rewritten
    my *awesome.py* file to do exactly that:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Listing 4-18: *awesome.py:2b*'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: If *awesome.py* is executed directly, `__name__` will have the value `"__main__"`,
    so the print statement will run. Otherwise, if *awesome.py* is being imported
    (or otherwise run indirectly), the conditional will fail.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: While you’ll frequently see this pattern in Python, some Python experts consider
    it an anti-pattern, because it can encourage you to both execute and import a
    module at the same time. While I don’t agree that using `if__name__ == "__main__"`
    is an anti-pattern, you often don’t need it. In any case, be certain you never
    import your main module from anywhere else in your package.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: Package Entry Points
  id: totrans-1147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that my *omission* project has a file called `__main__` in the top-level
    package. This file is automatically run when a package is executed directly, but
    never when importing the package.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: So, when executing *omission* via `python3 -m omission`, Python first runs the
    *__init__.py* module (as always), followed by its *__main__.py* module. Otherwise,
    if the package is imported instead, only *__init__.py* is executed.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: If you omit *__main__.py* from a package, it cannot be executed directly.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: 'A good *__main__.py* for a top-level package would look something like the
    following:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Listing 4-19: *__main__.py*'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: All the logic for starting the package belongs in the `main()` function. Then,
    the `if` statement checks the `__name__` assigned to the *__main__.py* module.
    Since this package is being executed directly, the value of `__name__` is `"__main__"`,
    and the code within the `if` statement, being the call to the `main()` function,
    is run. Otherwise, if *__main__.py* were only being imported, its fully qualified
    name would include its containing package (for example, `omission.__main__`),
    the condition would fail, and the code wouldn’t run.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Package Imports
  id: totrans-1155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A package’s *__init__.py* file can come in handy when you want to change what
    is available for import and how it can be used. The most common uses for this
    file are to simplify imports and to control the behavior of import-all (`import
    *`).
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying Imports
  id: totrans-1157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine I have a particularly complicated package, `rockets`, which is made
    up of dozens of subpackages and hundreds of modules. I can safely assume that
    many developers using the package won’t want to know about most of that functionality.
    They only want one thing: to define a rocket and then launch it! Instead of expecting
    all the users of my package to know where those few basic bits of functionality
    exist in the package structure, I can use *__init__.py* to expose said functionality
    directly, making the bits easier to import later:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Listing 4-20: *__init__.py:1*'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: 'This greatly simplifies the usage of the package. I no longer need to remember
    where things like the `SmallRocket` and `Launchpad` classes live in the `rockets`
    package structure. I can import them directly from the top-level package and use
    them:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Listing 4-21: *rocket_usage.py*'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: Beautifully simple, isn’t it? Still, nothing is actually *preventing* me from
    importing things the long-form way (such as `from rockets.smallrocket.rocket import
    SmallRocket`) if I need to. The shortcut is there, but it’s optional.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: Because simplicity is such an essential part of the Python philosophy, it is
    also an essential component of package design. If you can anticipate the most
    common ways a user might interact with your package, you can greatly simplify
    their code by adding a few lines to *__init__.py*.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Import-All
  id: totrans-1166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, import-all doesn’t work with a package. You use *__init__.py* to
    enable and control the behavior of `import *`, even though such an import statement
    is generally discouraged. This can be done by assigning a list of strings to `__all__`,
    with each string containing something (such as a package or module) to import
    from the current package.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: 'This works well with the previous trick ([Listing 4-20](#listing4-20)):'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Listing 4-22: *__init__.py:2a*'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: 'When Python encounters a line like `from rockets import *`, that list from
    `__all__` (seen as `rockets.__all__`) is unpacked in place of the asterisk (`*`).
    This is important in figuring out what you can include in `__all__`: each item
    in my list should make sense when substituted for the asterisk in `from rockets
    import *`.'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, I could change the last line of my *__init__.py* to this, and
    there would be no error in the code:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Listing 4-23: *__init__.py:2b*'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: This works because, as you already know, the line `from rockets import smallrocket`
    is a valid import statement.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, this example would *not* work:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Listing 4-24: *__init__.py:2c*'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: It fails because `from rockets import smallrocket.rocket` does not make sense.
    You’ll have to consider this principle when defining `__all__`.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: If `__all__` is not defined in *__init__.py*, then `from rockets import *` will
    behave the same as `import rockets`.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: Program Entry Points
  id: totrans-1181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve applied all the concepts in this chapter to your project’s structure,
    you can run `python3 -m yourproject` to start your program.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: However, you (or your eventual end user) may want to run the program merely
    by double-clicking or directly executing some single Python file. With everything
    else in place, this is trivial to implement.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: 'To make my *omission* project easy to run, I created a single script file *outside
    the top-level package*, named *omission.py*:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Listing 4-25: *omission.py*'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: I import the `main()` function from *omission/__main__.py* and then execute
    that function. This is effectively the same as executing that package directly
    with `python3 -m omission`.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: There are better ways to create a program entry point, but I’ll cover those
    in Chapter 18, once I’ve created the all-important *setup.cfg* file. Again, what
    you have so far will be enough for development.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: The Python Module Search Path
  id: totrans-1189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *module search path*, or *import path*, defines where Python looks for packages
    and modules and what order it searches in. When you first start the Python interpreter,
    the module search path is assembled in order, from the directory of the module
    being executed, the system variable `PYTHONPATH`, and the default path for the
    Python instance being used.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the resulting module search path with the following commands:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Running that code within the context of a virtual environment (in my case,
    */home/jason/.venvs/venv310*) on my system gives me the following output:'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The import system looks through each of the locations in the module search path
    *in order*. As soon as it finds a match for the module or package being imported,
    it stops. You can see here that it searches the directory containing the module
    or script I’m running ❶, the standard libraries ❷ ❸ ❹, and then everything installed
    with pip in the virtual environment ❺.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: If you need to add locations to the module search path, the best way is to use
    a virtual environment and add a file ending in *.pth* to the *lib/python3.x/site-packages*
    directory. The name of the file doesn’t matter, as long as the file extension
    is *.pth*.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Listing 4-26: *venv/lib/python3.10/site-packages/stuff.pth*'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: Each line must contain exactly one path to be appended. The absolute path */home/jason/bunch_of_code*
    will be appended to the module search path. The relative path *../../../awesomesauce*
    is relative to the .*pth* file, so it will point to *venv/awesomesauce*.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: Because these are appended to the module search path, this technique cannot
    be used to replace any packages or modules installed on the system or virtual
    environment. However, any new modules or packages in my *bunch_of_code/* or *awesomesauce/*
    directories will be available for import within the virtual environment.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: What Really Happens
  id: totrans-1202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at what really happens under the hood when you import a module. Most
    of the time, those details won’t matter, but every now and then (such as when
    the wrong module seems to be imported instead of the one you expect), the technical
    details leak to the surface. It never hurts to know what’s going on.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: The `import` statement calls the built-in`__import__()` function.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: 'To import a module, Python uses two special objects: a *finder* and a *loader*.
    In some cases, it uses an *importer* object, which serves as both a finder and
    a loader.'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: The *finder* is responsible for locating the module being imported. There are
    many places to look for modules—they aren’t even necessarily files—and a number
    of special situations exist that must be handled. Python has several types of
    finders to handle these different situations, and it gives each one an opportunity
    to locate a module with a given name.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: 'First, Python uses *meta path finders*, which are stored in the `sys.meta_path`
    list. By default, there are three meta path finders:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: The *built-in importer* finds and loads built-in modules.
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *frozen importer* finds and loads *frozen* modules, meaning modules that
    have been converted to compiled bytecode (see Chapter 1).
  id: totrans-1209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *path-based finder* looks in the filesystem for the module.
  id: totrans-1210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This search order is the reason why you cannot globally shadow a built-in module;
    the built-in importer runs before the path-based finder. If you need some additional
    meta path finder, such as if you were importing a module from a novel location
    not already supported, you can add it as a *meta hook* by appending it to the
    `sys.meta_path` list.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: There’s some additional complexity to the path-based finder that is worth breaking
    down. The path-based finder tries each of the *path entry finders* in turn. These
    path entry finders, also known as *path entry hooks*, are stored in `sys.path_hooks`.
    Each one searches every location (known as a *path* entry) listed on the import
    path, as specified by `sys.path` or the `__path__` attribute of the current package.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: If any of the finders locates the module, it returns a *module spec* object
    with all the information about how to load the module. However, if all the meta
    path finders return `None`, you’ll get a `ModuleNotFoundError`.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: Once the module is found, the module spec goes to the *loader*, which is responsible
    for actually loading the module.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot of technical detail regarding loading that’s beyond the scope
    of this book, but one thing worth noting is how the loader deals with *cached
    bytecode*. Ordinarily, once a Python module has been run, a *.pyc* file is generated.
    The file contains the bytecode, which from then on is *cached*. You’ll often see
    these *.pyc* files hanging out in your project directories. The loader always
    needs to be sure that the cached bytecode is not out of date before loading it,
    by using one of two strategies. The first strategy is for the bytecode to also
    store the timestamp from the last time the source code file was modified. When
    loading the module, the timestamp of the source code is checked against this cached
    timestamp. If it doesn’t match, the bytecode is out of date, and the source will
    be recompiled. The second strategy, introduced in Python 3.7, instead stores a
    *hash*, which is a short and (relatively) unique value algorithmically generated
    from the source code itself. If the source code changes, the hash will be different
    from the one stored in the cached bytecode. Python bytecode files that contain
    this hash are appropriately called *hash-based .pyc* files.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how the loader is loading the module, it will add the module object
    to `sys.modules`—adding it, in fact, just before actually loading, to prevent
    an import loop if the module being loaded imports itself. Finally, the loader
    will bind the imported module object to a name in the module importing it, so
    the imported module can be referenced. (I’ll cover name binding in Chapter 5.)
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: Once the module has been imported, it’s cached in `sys.path_importer_cache`,
    along with the importer object used to import it. This is actually the first place
    the import system will check for an imported module, even before running through
    the finders, so importing a module multiple times in a project will still only
    go through the finding-and-loading process once.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: This is a very broad overview of the import system, but most of the time, it’s
    all you’ll need to know. To learn all the intricate details, you can read the
    official documentation at [https://docs.python.org/3/reference/import.html](https://docs.python.org/3/reference/import.html).
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-1219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python import system is often overlooked when learning the language, leading
    to many headaches for new users. By understanding how to use and import modules
    and packages, you will greatly reduce the roadblocks between you and a viable
    project. A little effort now will save you countless hours of confusion and trouble
    later!
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
