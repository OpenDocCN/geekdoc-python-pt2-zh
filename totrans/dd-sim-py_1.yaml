- en: Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: THE PYTHON ENVIRONMENT
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python 环境
- en: '1'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Python Philosophy
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 哲学
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: I believe the best place to start learning Python is not with the language itself,
    but with the guiding philosophy driving it. To write good Python code, you must
    first understand what Python is. That’s what this chapter will focus on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为学习 Python 的最佳起点不是从语言本身开始，而是从支撑它的指导哲学开始。要编写出好的 Python 代码，首先你必须理解 Python 是什么。这一章将专注于这一点。
- en: What Is Python, Exactly?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，Python 到底是什么呢？
- en: Python is a programming language developed in 1991 by Dutch programmer Guido
    van Rossum. The name refers not to the snake often used as a mascot, but to *Monty
    Python’s Flying Circus* (that fact alone should tell you a lot about the mindset
    behind the language). What began as a hobby project over Christmas break turned
    into one of the most perennially popular computer languages today.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是由荷兰程序员 Guido van Rossum 于 1991 年开发的编程语言。这个名字并不是指常作为吉祥物的蛇，而是指 *Monty
    Python’s Flying Circus*（这一点足以告诉你关于语言背后的思维方式）。最初作为一个圣诞假期的爱好项目，后来发展成了如今世界上最持久受欢迎的编程语言之一。
- en: From a technical perspective, Python is considered a high-level, general-purpose
    language, with full support for the procedural, object-oriented, and functional
    programming paradigms, among others.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度看，Python 被认为是一种高级通用语言，全面支持过程式、面向对象和函数式编程范式等。
- en: 'Fans of Python are quick to point out its famous readability and simplicity,
    which lend to an initial feeling that the language is “magic.” This has also given
    rise to a less-than-useful bit of advice for newcomers: “Python is easy; it’s
    just pseudocode!”'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的爱好者常常强调它著名的可读性和简洁性，这给人一种初步的感觉，认为这门语言“有魔力”。这也催生了一个对初学者不太有用的建议：“Python
    很简单；它只是伪代码！”
- en: 'That isn’t strictly true. Don’t let the natural readability fool you: Python
    is beautifully unique and influenced by many other languages, but it often bears
    little resemblance to any of them. To truly master it, one must take it by itself,
    not in strong comparison to other languages. That is exactly what this book will
    do.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全正确。不要被它天然的可读性所迷惑：Python 独具魅力，受到许多其他编程语言的影响，但它通常与这些语言几乎没有相似之处。要真正掌握它，必须将其独立看待，而不是与其他语言做强烈比较。这正是本书的目标。
- en: Most importantly, however, Python is an idea. It’s the collective creation of
    a diverse group of nerds, united by nothing more than an audacious desire to build
    an awesome programming language. When you truly understand Python, it alters your
    entire perspective. You’re a part of something larger; something that has taken
    on a life of its own.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是，Python 是一个理念。它是由一群各具特色的极客共同创造的，他们的唯一目标就是打造一个令人赞叹的编程语言。当你真正理解 Python
    时，它将改变你整个的视角。你成为了某个更大事物的一部分；某个已经拥有自己生命的事物。
- en: 'As Guido van Rossum explained in his famous King’s Day speech:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Guido van Rossum 在他著名的国王日演讲中所解释的：
- en: I believe the most important idea is that Python is developed on the Internet,
    entirely in the open, by a community of volunteers (but not amateurs!) who feel
    passion and ownership.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认为最重要的思想是，Python 是在互联网上完全公开开发的，由一群充满热情并且拥有责任感的志愿者（而非业余爱好者）共同完成的。
- en: 'Myths: What Python Isn’t'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '神话：Python 不是……  '
- en: There are a lot of myths about Python, many of which lead to people shunning
    the language for certain applications, if not altogether.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 有许多神话，其中许多导致人们在某些应用中放弃使用这门语言，甚至完全不使用它。
- en: 'Myth #1: Python Is Merely a Scripting Language'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #1：Python 仅仅是脚本语言'
- en: 'I consider “scripting language” to be one of the most insidious terms used
    in discussing programming languages. It implies that the language is somehow unsuited
    for writing “real” software (see Myth #5).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '我认为“脚本语言”是讨论编程语言时最具误导性的术语之一。它暗示该语言不适合编写“真正的”软件（见神话 #5）。'
- en: Python is *turing-complete*, which means that you could implement any programming
    language in Python and then be able to execute any program written in that language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是 *图灵完备* 的，这意味着你可以用 Python 实现任何编程语言，并且能够执行任何用该语言编写的程序。
- en: To put that another way, anything another programming language can do, Python
    can do. Whether it’s easy, or even advisable, depends on what you’re attempting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，任何其他编程语言能做的，Python 都能做。不管它是否简单，甚至是否明智，这取决于你所尝试的内容。
- en: 'Myth #2: Python Is Slow'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #2：Python 很慢'
- en: It’s easy to assume that high-level or interpreted languages like Python are
    naturally slower than compiled or low-level languages like C. In truth, it depends
    on the implementation of the language and how it’s used. In this book, we’ll cover
    several concepts related to improving the performance of Python code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易假设，像 Python 这样的高级语言或解释型语言天生比 C 这样的编译型或低级语言要慢。事实上，这取决于语言的实现方式以及如何使用。在本书中，我们将介绍几个与提高
    Python 代码性能相关的概念。
- en: The default implementation of the Python language interpreter, CPython, is written
    in C, and it is indeed slower than native machine code. However, there are various
    libraries and techniques—as well as other implementations of the language, including
    PyPy—which have much better performance overall (see Chapter 21) and even approach
    the speed of native machine code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言解释器的默认实现 CPython 是用 C 编写的，确实比原生机器代码慢。然而，还有许多库和技术——以及包括 PyPy 在内的其他语言实现——整体性能更好（见第
    21 章），甚至接近原生机器代码的速度。
- en: With all that said, you should understand how performance actually factors into
    your project. In most situations, Python is plenty fast enough to be a good choice
    for application development, data analysis, scientific computing, game development,
    web development, and the list goes on. The performance drawbacks inherent in CPython
    usually only become problematic when you are dealing with very specific scenarios
    demanding extraordinarily high performance. Even then, there are ways around the
    bottlenecks. For the majority of projects, Python’s baseline performance is more
    than sufficient.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，你应该理解性能实际上如何影响你的项目。在大多数情况下，Python 足够快，足以成为应用开发、数据分析、科学计算、游戏开发、网页开发等领域的好选择，列表还在继续。CPython
    中固有的性能缺陷通常只有在面对要求极高性能的特定场景时才会成为问题。即便如此，仍然有办法绕过这些瓶颈。对于大多数项目而言，Python 的基础性能已经足够。
- en: 'Myth #3: Python Cannot Be Compiled'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #3：Python 不能被编译'
- en: Python is an *interpreted language*, meaning the code is read, interpreted,
    and executed at runtime by the language’s *interpreter*. An end user running a
    project written in Python will typically have to have the Python interpreter installed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种*解释型语言*，意味着代码会被语言的*解释器*在运行时读取、解释并执行。运行 Python 编写的项目的最终用户通常需要安装 Python
    解释器。
- en: This contrasts with what I like to call *assembled languages*, like C, C++,
    or FORTRAN. In these languages, the final result of compilation is machine code,
    which can be executed directly on any compatible computer without needing an additional
    program on that machine (or somehow bundled with the code).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我喜欢称之为*汇编语言*的语言形成对比，比如 C、C++ 或 FORTRAN。在这些语言中，编译的最终结果是机器代码，它可以直接在任何兼容的计算机上执行，无需额外的程序（或与代码捆绑在一起）。
- en: Many developers take this to mean that Python cannot be compiled (assembled)
    to machine code, which seems like the obvious corollary. In fact, it is possible
    to compile Python to machine code, although this is rarely necessary and seldom
    done.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者认为这意味着 Python 不能被编译（汇编）成机器代码，这似乎是显而易见的推论。实际上，Python 是可以编译成机器代码的，尽管这通常不必要，也很少有人这样做。
- en: If you want to go this route, there are a few options. On UNIX, the built-in
    *Freeze* tool transpiles to C arrays of Python bytecode, and then it assembles
    this C code to machine code. This doesn’t result in truly assembled Python code,
    however, because the Python interpreter must still be invoked behind the scenes.
    Freeze only works on UNIX systems. The *cx_Freeze* tool, as well as *py2exe* on
    Windows, does much the same thing as Freeze.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想走这条路，还是有一些选择的。在 UNIX 系统中，内置的 *Freeze* 工具可以将 Python 字节码转译成 C 数组，然后将这些 C 代码汇编成机器代码。然而，这并不会产生真正的汇编
    Python 代码，因为 Python 解释器仍然需要在幕后调用。Freeze 只在 UNIX 系统上有效。*cx_Freeze* 工具以及 Windows
    上的 *py2exe* 做的工作与 Freeze 类似。
- en: To truly compile Python to machine code, you must use an intermediary language.
    *Nuitka* can be used to transpile Python code C and C++, which can then be assembled
    to machine code. You can also transpile Python to Java with *VOC*. *Cython* also
    allows transpiling a specialized form of Python to C, although it’s primarily
    geared toward writing Python extensions in C.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Python 代码真正编译成机器代码，你必须使用一种中介语言。*Nuitka* 可以将 Python 代码转译为 C 和 C++，然后再将其汇编成机器代码。你也可以通过
    *VOC* 将 Python 转译为 Java。*Cython* 还允许将一种特定形式的 Python 转译为 C，尽管它主要用于用 C 编写 Python
    扩展。
- en: 'Myth #4: Python Gets Compiled Behind the Scenes'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #4：Python 在幕后被编译'
- en: 'The Python interpreter converts code to *bytecode*, which is then executed.
    The interpreter includes a *virtual machine*, which executes the Python bytecode
    similarly to how a CPU executes machine code. Sometimes, the interpreter will
    do the conversion to bytecode in advance, for performance reasons, generating
    *.pyc* files containing bytecode. While this is “compiling” in one sense of the
    term, there is a key difference between compiling to bytecode and compiling to
    machine code: bytecode is still run through the interpreter, whereas machine code
    executes directly, without needing an additional program. (Technically, “compiling”
    to machine code is called *assembling*, although this distinction is often neglected
    or overlooked.)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python 解释器将代码转换为*字节码*，然后执行这些字节码。解释器包括一个*虚拟机*，它以类似于 CPU 执行机器码的方式执行 Python 字节码。有时，为了提高性能，解释器会提前将代码转换为字节码，生成包含字节码的*.pyc*
    文件。虽然从某种意义上来说这被称为“编译”，但编译字节码与编译机器码之间有一个关键的区别：字节码仍然需要通过解释器执行，而机器码则可以直接执行，无需额外的程序。（从技术上讲，“编译”成机器码被称为*汇编*，尽管这一区别通常会被忽略或忽视。）
- en: In practice, the majority of Python projects ship as source code, or at least
    Python bytecode, which is run in the Python interpreter installed on the user’s
    machine. There are occasions when a standard executable is preferable, such as
    for ease of installation on end-user computers or in closed-source projects. For
    those situations, tools such as *PyInstaller* and *cx_Freeze* exist. These don’t
    compile the code, but rather bundle the Python source code or bytecode with the
    interpreter so it can be executed by itself (see Chapter 18).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，大多数 Python 项目以源代码形式发布，或者至少是 Python 字节码，这些字节码在用户计算机上安装的 Python 解释器中运行。在某些情况下，标准的可执行文件更为合适，比如在最终用户计算机上安装方便或在闭源项目中使用。在这些情况下，*PyInstaller*
    和 *cx_Freeze* 等工具应运而生。这些工具不会编译代码，而是将 Python 源代码或字节码与解释器捆绑在一起，使其能够独立执行（见第 18 章）。
- en: 'Myth #5: Python Is Unsuitable for Large Projects'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #5：Python 不适合大型项目'
- en: I’ve heard some developers say, “Python is only useful if the whole project
    fits in one file.” This adage is partially based on the misconception that Python
    projects with multiple files are confusingly structured. This indeed tends to
    be the trend, but only because so few developers know how to correctly structure
    a Python project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾听到一些开发者说：“Python 只有在整个项目都能放在一个文件里时才有用。”这个说法部分基于一种误解，认为包含多个文件的 Python 项目结构混乱。确实，这种情况往往会发生，但仅仅是因为很少有开发者知道如何正确地结构化一个
    Python 项目。
- en: In reality, project structure in Python is far simpler than in C++ and Java.
    Once the developer understands the concepts of packages, modules, and the import
    system (see Chapter 4), working with multiple code files becomes trivial.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Python 的项目结构比 C++ 和 Java 要简单得多。一旦开发者理解了包、模块和导入系统的概念（见第 4 章），使用多个代码文件就变得非常简单。
- en: Another reason for this myth has to do with the fact that Python is dynamically
    typed, rather than statically typed like Java or C++, which some believe makes
    refactoring harder. This doesn’t have to be the case, once the developer knows
    how to work with Python’s type system, instead of against it (see Chapter 5).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个神话的另一个原因与 Python 是动态类型的有关，而不是像 Java 或 C++ 那样的静态类型，许多人认为这使得重构变得更加困难。但只要开发者学会如何利用
    Python 的类型系统，而不是与之对抗（见第 5 章），这种情况就不必如此。
- en: Python 2 vs. Python 3
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 2 与 Python 3
- en: For many years, there existed two major versions of Python. Starting in 2001,
    *Python 2* was the standard, meaning most books and articles about Python were
    written for this version. The last release was Python 2.7.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Python 存在两个主要版本。从 2001 年开始，*Python 2* 是标准版本，这意味着大多数关于 Python 的书籍和文章都是为这个版本编写的。最后一个版本是
    Python 2.7。
- en: The current version is *Python 3*, known during its development as *Python 3000*
    or *Py3k*. From its release in 2008 until 2019, we were in a sort of limbo between
    the two versions; a lot of existing code and packages were written in Python 2,
    while Python 3 was increasingly recommended for new projects that didn’t require
    legacy support. Many techniques and tools existed for writing code that could
    run in either version, which eased the transition for many existing projects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本是*Python 3*，在开发过程中被称为*Python 3000* 或 *Py3k*。从 2008 年发布到 2019 年，我们一直处于两个版本之间的某种过渡期；大量现有的代码和包是用
    Python 2 编写的，而 Python 3 被越来越多地推荐用于不需要遗留支持的新项目。许多技术和工具使得编写能够同时在两个版本上运行的代码成为可能，从而帮助了许多现有项目的过渡。
- en: In more recent years, especially since the release of Python 3.5, we’ve begun
    moving away from Python 2 altogether. Most major libraries officially supported
    Python 3, and legacy support became less of a priority.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，尤其是自Python 3.5发布以来，我们已经开始完全摆脱Python 2。大多数主要的库已经正式支持Python 3，而对遗留版本的支持不再是优先事项。
- en: As of January 1, 2020, Python 2 has been officially retired, and Python 3 is
    the definitive standard. Since Python 4 is still nothing more than a vague wisp
    of a rumor at this point, it’s safe to say that Python 3 will be with us for years
    to come.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2020年1月1日，Python 2已经正式退役，Python 3成为了公认的标准。由于Python 4目前仍然只是一个模糊的传闻，可以安全地说，Python
    3将会陪伴我们多年。
- en: Unfortunately, many software development teams have been slow (sometimes unavoidably)
    about porting their code bases from Python 2 to Python 3\. This has left a lot
    of projects in limbo. If you use Python in a professional capacity, there is a
    good chance you’ll have to help transition some code to Python 3\. Python’s standard
    library includes a tool called *2to3*, which helps automate this process. Running
    the code through this tool is a good first step, but you will still need to manually
    update the code to use some of the newer patterns and tools Python 3 has to offer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多软件开发团队在将代码库从Python 2迁移到Python 3的过程中进展缓慢（有时是不可避免的）。这导致了很多项目陷入了停滞。如果你在专业环境中使用Python，很有可能需要帮助将一些代码迁移到Python
    3。Python的标准库包含一个名为*2to3*的工具，能够帮助自动化这一过程。通过这个工具运行代码是一个很好的第一步，但你仍然需要手动更新代码，以使用Python
    3所提供的一些更新的模式和工具。
- en: Defining “Pythonic” Code
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义“Pythonic”代码
- en: Among Python developers, you’ll hear a lot of talk about *Pythonic* code and
    what it constitutes, precisely. In a general sense, idiomatic code that makes
    good use of the language’s features is considered Pythonic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python开发者中，你会经常听到关于*Pythonic*代码的讨论，以及它究竟代表什么。从广义上讲，能够充分利用语言特性的习惯用法代码被认为是Pythonic的。
- en: Unfortunately, this is very much open to interpretation. As a result, the topic
    of best practices in Python is a regular source of heated debate in the community.
    Don’t be alarmed by this. By regularly grappling with our own conventions and
    standards, we continually improve them and our own understanding along the way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这一点非常依赖于解释。因此，Python中最佳实践的话题常常成为社区热议的焦点。不要因此感到惊讶。通过不断与我们自己的约定和标准斗争，我们不断改进这些标准，同时也提升我们自己的理解。
- en: Our tendency to debate best practices in Python is rooted in our philosophy
    of *There’s Only One Way To Do It (TOOWTDI)*, a phrase coined by PythonLabs in
    2000 as a tongue-in-cheek response to the Perl community’s own adage of *There’s
    More Than One Way To Do It (TMTOWTDI)*. Despite the historic rivalry between these
    communities, these philosophies aren’t strictly opposing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Python中讨论最佳实践的倾向源于我们的哲学理念*只有一种方法可以做到（TOOWTDI）*，这个短语由PythonLabs在2000年创造，作为对Perl社区自己格言*有不止一种方法可以做到（TMTOWTDI）*的幽默回应。尽管这两个社区之间有历史性的竞争，但这些哲学理念并不是严格对立的。
- en: Python developers rightly assume there is some single, quantifiably “best” solution
    to any specific problem. Our task is to figure out what that solution is, but
    we also know we will often fall far short of the goal. Through continual discussion,
    debate, and experimentation, we refine our approaches in pursuit of the theoretical
    Best Solution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python开发者正确地认为，对于任何特定问题，都有一个量化的“最佳”解决方案。我们的任务是弄清楚这个解决方案是什么，但我们也知道我们往往会远远低于这个目标。通过不断的讨论、辩论和实验，我们在追求理论上最佳解决方案的过程中不断完善我们的做法。
- en: In the same way, the Perl community understands that it is often impossible
    to definitively arrive at that Best Solution, so they emphasize experimentation
    instead of compliance with strict standards, in an effort to discover better and
    better solutions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Perl社区也明白，要想最终找到那个最佳解决方案常常是不可能的，所以他们强调实验而非遵循严格的标准，努力发现越来越好的解决方案。
- en: 'In the end, the goal is the same: to ultimately define the best possible solution
    to a problem. Only the emphasis differs.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，目标是相同的：定义出解决问题的最佳方法。只是重点有所不同。
- en: In this book, I’ll focus a lot on the generally accepted Pythonic ways of writing
    code. However, I don’t claim to be the final authority. My colleagues in the Python
    community will always have plenty to add to these discussions. I never fail to
    learn something new from them!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将重点讲解一般公认的Pythonic编程方式。然而，我并不声称自己是最终权威。我的Python社区同仁总是有很多可以补充的内容，我从他们那里总能学到新东西！
- en: The Zen of Python
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python之禅
- en: In 1999, a discussion started on the official Python mailing list about the
    need to write down some sort of formal guiding principles for the language. Tim
    Peters, a prominent member of the community, jokingly laid out a poetic summary
    of 19 principles to serve as an outline, leaving the 20th spot open for Guido
    van Rossum to complete (which he never did).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 1999年，关于是否需要为Python语言写下一些正式的指导原则，官方Python邮件列表上展开了讨论。社区的杰出成员Tim Peters开玩笑地列出了19条原则的诗意总结，作为大纲，并留出了第20个位置让Guido
    van Rossum来完成（但他从未完成）。
- en: Other community members quickly seized on this summary as a fantastic overview
    of Python’s philosophy, ultimately adopting it wholesale as *The Zen of Python*.
    The entire text is published by Python as PEP 20.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其他社区成员迅速将这个总结视为Python哲学的精彩概述，最终将其作为*Python之禅*全面采纳。整篇文章由Python以PEP 20的形式发布。
- en: Beautiful is better than ugly.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 美丽胜于丑陋。
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显式胜于隐式。
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Simple is better than complex.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 简单胜于复杂。
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Complex is better than complicated.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 复杂胜于复杂化。
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Flat is better than nested.
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扁平胜于嵌套。
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sparse is better than dense.
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 稀疏胜于密集。
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Readability counts.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可读性很重要。
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Special cases aren’t special enough to break the rules.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 特殊情况不足以打破规则。
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although practicality beats purity.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管实用性胜于纯粹性。
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Errors should never pass silently.
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误永远不应悄悄通过。
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非明确地沉默。
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面对模糊时，要拒绝猜测的诱惑。
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该有一种——最好只有一种——显而易见的方式来做。
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you’re Dutch.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管如果你不是荷兰人，那条路一开始可能不那么显而易见。
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now is better than never.
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在胜于永不。
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although never is often better than *right* now.
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管往往“永不”比*立刻*更好。
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the implementation is hard to explain, it’s a bad idea.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果实现难以解释，那就是个坏主意。
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the implementation is easy to explain, it may be a good idea.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果实现容易解释，那可能是个好主意。
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea—let’s do more of those!
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名空间是一个非常棒的主意——让我们多做一些吧！
- en: This, too, is open to interpretation, and some argue that Tim Peters was kidding
    when he wrote The Zen of Python. However, if there’s one thing I’ve learned about
    Python developers, it’s that the line between “kidding” and “serious” is fine
    as spider silk.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这点也可以有不同的解释，有人认为Tim Peters在写《Python之禅》时是在开玩笑。然而，如果我从Python开发者身上学到了什么，那就是“开玩笑”和“认真”之间的界限像蜘蛛丝一样细微。
- en: In any case, The Zen of Python is a great place to start when talking about
    best practices in Python. Many developers, including myself, often refer back
    to it. I’ll refer to it frequently throughout this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，《Python之禅》是谈论Python最佳实践的好起点。包括我在内的许多开发者常常回头参考它。我将在本书中频繁提到它。
- en: Documentation, PEPs, and You
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档、PEP和你
- en: '*Dead Simple Python* is intended as a beginning, not an ending, to your learning
    journey. Once you are well acquainted with the Python language, you can turn to
    the language’s extensive official documentation to learn more about any particular
    features or tools. These docs are found online at [https://docs.python.org/](https://docs.python.org/).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单至极的Python*旨在作为你学习之旅的开始，而非终点。一旦你熟悉了Python语言，就可以转向语言的官方文档，进一步了解任何特定的功能或工具。这些文档可以在线访问，网址是[https://docs.python.org/](https://docs.python.org/)。'
- en: Any new feature in Python begins its life as a *Python Enhancement Proposal*
    (PEP). Each is assigned a unique number and published to the official PEP index
    at [https://python.org/dev/peps/](https://python.org/dev/peps/). Once proposed,
    a PEP will be considered, discussed, and ultimately accepted or rejected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的任何新特性都会以*Python增强提案*（PEP）的形式开始。每个PEP都被分配一个独特的编号，并发布到官方PEP索引，网址是[https://python.org/dev/peps/](https://python.org/dev/peps/)。一旦提案提交，PEP将被考虑、讨论，并最终接受或拒绝。
- en: Accepted PEPs are effectively extensions of the documentation, as they are the
    most cohesive and authoritative descriptions of the feature(s) they define. Additionally,
    there are several Meta-PEPs and Informational PEPs that provide the backbone for
    the Python community and language.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 被接受的PEP实际上是文档的扩展，因为它们是最具凝聚力和权威性的功能描述。此外，还有一些Meta-PEP和Informational PEP，提供了Python社区和语言的支柱。
- en: As such, the official documentation and PEP index should be the first place
    you go if you have any questions about Python. I’ll refer to these frequently
    throughout this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，官方文档和PEP索引应该是你遇到Python问题时首先查阅的地方。我将在本书中频繁提到这些。
- en: Who Calls the Shots?
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁来决定？
- en: To understand how and why the language evolves, it is important to know who’s
    in charge. When a PEP is proposed, who gets to decide if it’s accepted or rejected?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解语言是如何以及为什么发展的，了解谁在主导非常重要。当一个 PEP 被提议时，谁来决定是否接受或拒绝它？
- en: Python is an open source project officially owned by the nonprofit Python Software
    Foundation. Unlike many other popular languages, no formal associations exist
    between Python and any for-profit organization.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一个由非营利组织 Python 软件基金会官方拥有的开源项目。与许多其他流行的编程语言不同，Python 与任何营利性组织之间没有正式的关联。
- en: As an open source project, Python is supported by an active and vibrant community.
    At its heart is the core team, the trusted volunteers who maintain the language
    and keep the community running smoothly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个开源项目，Python 得到了一个活跃而充满活力的社区的支持。其核心是核心团队，这些受信任的志愿者负责维护语言并保持社区的顺利运作。
- en: Language creator Guido van Rossum served as the Benevolent Dictator for Life
    (BDFL), making the final decisions on all PEPs and overseeing ongoing development
    of the language. In 2018, he made the decision to step down from the role.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的创造者 Guido van Rossum 曾担任“终身仁慈独裁者”（BDFL），对所有 PEP 做出最终决定，并监督语言的持续开发。2018年，他决定辞去这一职务。
- en: A few months after his resignation, PEP 13 was created to establish a new system
    of governance. Now the language is governed by a five-person steering committee,
    elected by the core team. Every time a new release of the language comes out,
    a new steering committee is elected.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在他辞职几个月后，PEP 13 被创建，建立了一个新的治理体系。现在，语言由一个五人组成的领导委员会来管理，该委员会由核心团队选举产生。每当语言发布新版本时，都会选举新的领导委员会。
- en: The Python Community
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 社区
- en: The Python community is a vast and diverse group of individuals from all over
    the world, united by their passion for this unique language. Ever since I stumbled
    upon the community many years ago as an utter novice, I have gained immeasurable
    help, guidance, and inspiration from it and its people. I’ve been privileged to
    offer the same to others in return. This book would not have ever happened without
    the continual feedback of my Python friends!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python 社区是一个庞大且多元化的群体，来自世界各地，因对这一独特语言的热情而团结在一起。自从我多年前作为一个初学者偶然发现这个社区以来，我从其中及其成员那里获得了无尽的帮助、指导和启发。我也很荣幸能将这些回馈给他人。如果没有我
    Python 朋友们的不断反馈，这本书根本不会成型！
- en: 'The Python community is moderated by the core team and governed by the Python
    Code of Conduct. In short, it emphasizes open, considerate, and respectful behavior,
    summarizing itself as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python 社区由核心团队进行管理，并由 Python 行为准则治理。简而言之，它强调开放、体贴和尊重的行为，并将自己总结如下：
- en: Overall, we’re good to each other. We contribute to this community, not because
    we have to, but because we want to. If we remember that, these guidelines will
    come naturally.
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总的来说，我们彼此之间相处融洽。我们为这个社区做出贡献，不是因为我们必须这样做，而是因为我们愿意。如果我们记住这一点，这些指导方针就会自然而然地融入我们的行动中。
- en: I strongly encourage any developer who uses Python to plug into this vibrant
    community. One of the best ways to participate is through the Libera.Chat IRC
    `#python` chatroom. You can find guides to getting onto IRC at [https://python.org/community/](https://python.org/community/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈鼓励任何使用 Python 的开发者加入这个充满活力的社区。参与的最佳方式之一是通过 Libera.Chat IRC `#python` 聊天室。你可以在
    [https://python.org/community/](https://python.org/community/) 找到关于如何加入 IRC 的指南。
- en: If you have any questions about Python, including while you read through this
    book, I recommend asking for help in the IRC channel. Chances are, you’ll find
    me and most of my technical editors there.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 Python 有任何疑问，包括在阅读本书时，我建议你在 IRC 频道寻求帮助。很有可能，你会在那找到我和我的大多数技术编辑。
- en: In Chapter 21, I’ll discuss the many facets of the Python community.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 21 章中，我将讨论 Python 社区的许多方面。
- en: The Pursuit of the One Obvious Way
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追求唯一的显而易见的方式
- en: The Python mantra “There’s Only One Way to Do It” can be quite confusing at
    first. There are many possible ways to solve any one problem. Are Pythonistas
    just too enamored with their own ideas?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的口号“只有一种方式可以做到”一开始可能会让人感到困惑。解决任何一个问题都有许多可能的方式。难道 Python 爱好者只是过于迷恋自己的想法吗？
- en: Thankfully, no. This mantra means something much more encouraging, and it’s
    something every Python developer should understand.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，不是这样的。这句口号意味着一些更加令人振奋的内容，而且这是每一个 Python 开发者都应该理解的。
- en: 'Some insight comes from The Zen of Python, which includes this rather cryptic
    quip:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一些见解来自《Python 的禅》，其中包括这句相当隐晦的俏皮话：
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该有一种——最好只有一种——明显的方式来做这件事。
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you’re Dutch.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管这种方法一开始可能并不显而易见，除非你是荷兰人。
- en: Tim Peters was, of course, referring to language creator Guido van Rossum, a
    Dutch national. As the creator of the language, Guido could usually cut right
    to the “most obvious way” of solving problems in Python, especially in the early
    days of the language.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，蒂姆·彼得斯指的是语言的创造者，荷兰国籍的吉多·范罗苏姆。作为语言的创造者，吉多通常能够直接找到“最明显的解决方法”，尤其是在 Python 语言初期。
- en: This *obvious way* is Python’s term for “the best solution”—a marriage of good
    practice, clean style, and reasonable efficiency, resulting in elegant code that
    is comprehensible to even the greenest novice.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*明显的方式*是 Python 对“最佳解决方案”的称谓——它是良好实践、简洁风格和合理效率的结合，产生的代码优雅且即使是最初学的新人也能理解。
- en: 'The details of the problem being solved will usually inform this “obvious way”:
    one situation may call for a loop, another for recursion, and yet another for
    a list comprehension. Contrary to the usual implications of the word *obvious*,
    the solution is often anything but simple to work out. The best solution is only
    obvious *once you know it*; arriving at it is where things get tricky. Most of
    us aren’t Guido.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 被解决问题的具体细节通常会指引出这个“明显的方式”：一种情况可能需要循环，另一种可能需要递归，还有一种可能需要列表推导式。与*明显*一词通常的含义相反，解决方案往往并不简单，找到它才是最棘手的部分。大多数人并不像吉多那样直觉明确。
- en: However, the *pursuit* of the “one obvious way” is a defining facet of the Python
    community, and it has had a profound impact on *Dead Simple Python*. A lot of
    the insights in this book were born out of sometimes intense debate between myself
    and my fellow Pythonistas. For this reason, I hand-selected my panel of technical
    editors from those colleagues who are commonly in opposition to me, and often
    each other, on pedantic technical points.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*追求*“唯一明显的方式”是 Python 社区的一个定义性特征，这对*极简 Python*产生了深远的影响。本书中的许多见解来源于我与我的 Python
    同好们之间有时激烈的辩论。正因如此，我从那些经常与我意见相左的同事中精心挑选了我的技术编辑小组，他们之间也常常就细枝末节的技术问题产生分歧。
- en: Anything ultimately adopted as the “right way” to solve a problem is usually
    accepted as such because of its technical merit, rather than because of some like-minded
    bias among Python developers, who are among the most exacting folks I’ve had the
    privilege of working with. This approach to logic overflows into every other conversation
    we have (which leads to some rather amazing and enlightening academic debates).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最终被接受为“正确方法”的解决方案，通常是因为其技术上的优越性，而不是因为 Python 开发者之间有某种志同道合的偏见。Python 开发者是我有幸合作过的最严格的人群之一。这种以逻辑为导向的方式渗透到我们每次的对话中（也导致了一些相当惊人且具有启发性的学术辩论）。
- en: New situations present themselves regularly. There will never come a point in
    any Python developer’s career when coding becomes truly “easy.” Situations will
    arise in every project that demand careful consideration, and often, debate. Developers
    must attempt to solve problems in the way that seems most obvious to them, then
    submit the solution to the critique of peers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 新的情况不断出现。在任何 Python 开发者的职业生涯中，永远不会有一个时刻，编程变得真正“容易”。每个项目中都会出现需要仔细考虑的情况，并且往往需要辩论。开发者必须尝试以他们认为最明显的方式来解决问题，然后将解决方案提交给同行进行批评。
- en: The approaches in this book are, in many cases, the most obvious according to
    my view. Most have been seconded by my colleagues, yet I dare not assert that
    I am altogether “Dutch” in the Python sense. If you find yourself debating techniques
    in the Python community, please do not wave this book in anyone’s face as evidence
    that your solution is best! Skill in finding an obvious solution is not something
    that can be taught; rather it is only learned through practice.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的方法在许多情况下是我个人认为最明显的。大多数方法得到了我的同事们的支持，但我不敢断言自己完全是“荷兰人”（在 Python 术语中）。如果你在
    Python 社区中争论某些技巧，请不要把这本书当作证据，强行证明你的解决方案是最好的！寻找明显解决方案的技巧是无法通过教学获得的，而是只能通过实践学习。
- en: Wrapping Up
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Despite the many myths that have been tossed around over the years, Python is
    a versatile and technically sound language, capable of handling just about any
    problem you can throw at it. It’s a solid choice, whether you are writing automation,
    crunching massive datasets, building native user applications, implementing machine
    learning, or crafting web applications and APIs. Most importantly, Python is backed
    by a vibrant, diverse, and helpful community.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多年来有许多关于 Python 的误解，Python 仍然是一种多功能且技术上可靠的语言，能够处理几乎任何你抛给它的问题。无论你是在编写自动化脚本、处理海量数据集、构建本地用户应用、实现机器学习，还是开发
    web 应用和 API，Python 都是一个坚实的选择。最重要的是，Python 得到了一个充满活力、多样化且乐于助人的社区的支持。
- en: The key to success, then, is writing Python code that makes the most of the
    strengths and features of the language. The goal is not simply to write code that
    works, but to write code that both looks and behaves elegantly. The rest of this
    book will teach you how to do exactly that.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的关键在于编写充分利用语言优点和特性的 Python 代码。目标不仅仅是编写可用的代码，而是编写既美观又优雅的代码。本书的其余部分将教你如何做到这一点。
- en: '2'
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Your Workbench
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工作台
- en: '![](Images/chapterart.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Your development environment is a major factor in how productive you’ll be in
    a language. Instead of contenting yourself with a bare-bones default shell, you’ll
    want to assemble a development environment worthy of any production-level project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的开发环境是你在一种语言中能达到的生产力的重要因素。与其满足于一个简陋的默认 shell，你会希望组建一个适合任何生产级项目的开发环境。
- en: A good Python development environment usually consists of the language interpreter,
    the pip package manager, a *virtual environment*, a Python-oriented code editor,
    and one or more *static analyzers* to check your code for errors and problems.
    I’ll discuss each of these in this chapter. I’ll also introduce the style conventions
    common in Python and round out the chapter with a guided tour of the most common
    Python integrated development environments (IDEs).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的 Python 开发环境通常包括语言解释器、pip 包管理器、*虚拟环境*、面向 Python 的代码编辑器以及一个或多个 *静态分析工具*，用于检查你的代码中的错误和问题。我将在本章中讨论这些工具。我还会介绍
    Python 中常见的编码风格规范，并通过一个常见的 Python 集成开发环境（IDE）导览来结束本章内容。
- en: Installing Python
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Python
- en: Before you can do anything, you have to install Python itself, along with a
    couple of essential tools. As you know from Chapter 1, Python is an interpreted
    language, so you’ll need to install its *interpreter*. You must also install pip,
    the Python package manager, so you can install additional Python tools and libraries.
    The exact steps for setup depend on your platform, but I will cover the major
    platforms here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始任何操作之前，你需要安装 Python 及一些必需的工具。正如你在第一章中所了解到的，Python 是一种解释型语言，因此你需要安装它的*解释器*。你还必须安装
    pip，这是 Python 的包管理工具，以便安装额外的 Python 工具和库。具体的安装步骤取决于你的平台，但我将在这里介绍主要平台的安装方式。
- en: In this book, I’m using Python 3.9, the latest version at the time of writing.
    If you’re reading this at a later date, just use the latest stable release of
    Python 3\. All the instructions should work the same. You need only replace the
    version number in the obvious ways on any commands run in the command line.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我使用的是 Python 3.9，这是写作时的最新版本。如果你在之后的时间阅读此书，只需使用最新稳定版本的 Python 3\。所有的指令应该是一样的。你只需要在命令行中替换命令中的版本号即可。
- en: This is merely a quick guide to installation. For the complete, official instructions,
    which cover many more situations and advanced options, see [https://docs.python.org/using/](https://docs.python.org/using/).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个快速的安装指南。有关完整的官方说明，涵盖了更多情况和高级选项，请参见 [https://docs.python.org/using/](https://docs.python.org/using/)。
- en: Installing on Windows
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 上安装
- en: On Windows, Python is not generally installed by default, so you’ll need to
    download it yourself from [https://python.org/downloads/windows/](https://python.org/downloads/windows/)
    and run that installer. On the first screen of the installer, be sure you check
    the boxes for **Install the launcher for all users** and **Add Python to PATH**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，Python 通常不会默认安装，因此你需要从 [https://python.org/downloads/windows/](https://python.org/downloads/windows/)
    下载并运行安装程序。在安装程序的第一个屏幕上，确保勾选 **为所有用户安装启动器** 和 **将 Python 添加到 PATH**。
- en: Python is also available through the Windows App Store. However, as of the date
    of my writing, this particular installation method is still officially considered
    unstable. I recommend downloading the official installer instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也可以通过 Windows 应用商店获取。然而，截止我写这篇文章时，这种安装方法仍然被官方认为是不稳定的。我建议你下载官方安装程序。
- en: Installing on macOS
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 macOS 上安装
- en: On macOS, you can use either MacPorts or Homebrew to install Python and pip.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你可以使用 MacPorts 或 Homebrew 安装 Python 和 pip。
- en: 'Use the following commands to install Python and pip with MacPorts, replacing
    the `38` with whatever version you want to download (removing the decimal point):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令通过 MacPorts 安装 Python 和 pip，将 `38` 替换为你要下载的版本（去掉小数点）：
- en: '[PRE0]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, here’s the command to install both Python and pip in one step
    with Homebrew:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这里有一个使用 Homebrew 一步安装 Python 和 pip 的命令：
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use only one of the two methods described above.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用上述两种方法中的一种。
- en: Installing on Linux
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装
- en: If you’re running a Linux operating system, chances are that Python (`python3`)
    is installed by default, although the other tools you need may not be. (I’ll show
    you how to install Python anyway, just to be on the safe side.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行的是 Linux 操作系统，那么 Python（`python3`）很可能默认已经安装，尽管你可能还需要安装其他工具。（我会展示如何安装 Python，以防万一。）
- en: 'To install Python and pip on Ubuntu, Debian, or related, run this command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu、Debian 或相关系统上安装 Python 和 pip，运行此命令：
- en: '[PRE2]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On Fedora, RHEL, or CentOS, you can run this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora、RHEL 或 CentOS 上，你可以运行以下命令：
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On Arch Linux, run this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arch Linux 上，运行以下命令：
- en: '[PRE4]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For other distributions, you’ll need to search for the Python 3 and pip packages
    yourself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他发行版，你需要自行查找 Python 3 和 pip 软件包。
- en: Installing from Source
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码安装
- en: If you’re running a UNIX-like system, and if your system either has an outdated
    version of Python 3 in the system packages or lacks a package manager altogether,
    you can build Python from source. This is how I usually install the latest Python.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行的是类 UNIX 系统，并且系统中有一个过时的 Python 3 版本，或者根本没有包管理器，你可以从源代码构建 Python。这是我通常安装最新
    Python 的方法。
- en: Installing Dependencies
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: On macOS, there are some relatively complex considerations when it comes to
    installing Python’s build dependencies. You should consult the documentation at
    [https://devguide.python.org/setup/#macos-and-os-x](https://devguide.python.org/setup/#macos-and-os-x).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，安装 Python 构建依赖时有一些相对复杂的考虑因素。你应该参考[https://devguide.python.org/setup/#macos-and-os-x](https://devguide.python.org/setup/#macos-and-os-x)中的文档。
- en: On most Linux systems, you will need to make sure you have the development files
    for several libraries that Python relies upon. The best way to install these depends
    on your system and, more specifically, which package manager you use.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Linux 系统上，你需要确保安装了 Python 依赖的几个库的开发文件。安装这些文件的最佳方式取决于你的系统，具体来说，取决于你使用的包管理器。
- en: If you’re on a Linux distribution that uses the APT package manager—such as
    Ubuntu, Pop!_OS, Debian, or Linux Mint—then you should either check the box to
    enable Source Code as a source in your Software Sources or Software & Updates
    settings or make sure you have it included in your *sources.list* file. (The exact
    method depends on your system, and that topic is beyond the scope of this book.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux 发行版并且使用 APT 包管理器——例如 Ubuntu、Pop!_OS、Debian 或 Linux Mint——那么你应该勾选启用源代码作为软件源，或者确保它包含在你的
    *sources.list* 文件中。（具体方法取决于你的系统，详细内容超出了本书的范围。）
- en: 'Then, run the following commands:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you get the message `Unable to find a source package for python3.9`, change
    the `9` to a lower (or higher) number until you find one that works. The dependencies
    for Python 3 don’t really change much between minor versions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到消息`Unable to find a source package for python3.9`，将 `9` 改为更低（或更高）的数字，直到找到一个可用的版本。Python
    3 的依赖项在次要版本之间变化不大。
- en: 'If your Linux distribution uses the DNF package manager, such as if you’re
    on modern Fedora, RHEL, or CentOS, run the following commands:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Linux 发行版使用 DNF 包管理器，例如在现代的 Fedora、RHEL 或 CentOS 上，运行以下命令：
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you’re on an older version of Fedora or RHEL that uses the yum package manager,
    run the following commands:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是旧版本的 Fedora 或 RHEL，并且使用 yum 包管理器，可以运行以下命令：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you’re on SUSE Linux, you’ll have to install the dependencies, including
    needed libraries, one by one. [Table 2-1](#table2-1) lists these dependencies.
    If you’re on another UNIX-based system, this list will be helpful, although you
    may need to change the package names or build the dependencies from source.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 SUSE Linux，你需要逐一安装依赖项，包括所需的库。[表 2-1](#table2-1) 列出了这些依赖项。如果你使用的是其他 UNIX
    系统，这个列表会有所帮助，尽管你可能需要更改包名或从源代码构建依赖项。
- en: 'Table 2-1: Python 3 Build Dependencies According to SUSE Linux'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1：根据 SUSE Linux 的 Python 3 构建依赖项
- en: '| automake | intltool | netcfg |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| automake | intltool | netcfg |'
- en: '| fdupes | libbz2-devel | openssl-devel |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| fdupes | libbz2-devel | openssl-devel |'
- en: '| gcc | libexpat-devel | pkgconfig |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| gcc | libexpat-devel | pkgconfig |'
- en: '| gcc-c++ | libffi-devel | readline-devel |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| gcc-c++ | libffi-devel | readline-devel |'
- en: '| gcc-fortran | libnsl-devel | sqlite-devel |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| gcc-fortran | libnsl-devel | sqlite-devel |'
- en: '| gdbm-devel | lzma-devel | xz |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| gdbm-devel | lzma-devel | xz |'
- en: '| gettext-tools | make | zlib-devel |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| gettext-tools | make | zlib-devel |'
- en: '| gmp-devel | ncurses-devel |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| gmp-devel | ncurses-devel |  |'
- en: Downloading and Building Python
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下载和构建 Python
- en: You can download the Python source as a Gzipped source tarball, which is a compressed
    file (*.tgz*), from [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/).
    I usually like to move this tarball file into a dedicated directory for Python
    source tarballs, especially as I tend to have multiple versions of Python at any
    one time. Within that directory, extract (uncompress) this file with `tar -xzvf
    Python-3.x.x.tgz`, substituting the name of the tarball you downloaded.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/)
    下载 Python 源代码作为 Gzipped 源代码 tarball，这是一种压缩文件 (*.tgz*)。我通常喜欢将这个 tarball 文件移到一个专门用于
    Python 源代码 tarball 的目录中，特别是当我通常同时拥有多个版本的 Python 时。在该目录中，使用 `tar -xzvf Python-3.x.x.tgz`
    解压（解压缩）此文件，替换你下载的 tarball 文件名。
- en: 'Next, from within the extracted directory, run the following, ensuring that
    each command succeeds before running the next one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在解压的目录中运行以下命令，确保每个命令成功执行后再执行下一个：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should configure Python for normal use, ensure it won’t encounter any errors
    in the current environment, and then install it *alongside* any existing Python
    installations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会配置 Python 以便正常使用，确保它在当前环境中不会遇到任何错误，然后将其 *与* 现有的 Python 安装一起安装。
- en: Once the installation is complete, you can use Python right away.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以立即使用 Python。
- en: Meet the Interpreter
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认识解释器
- en: Now that you’ve installed that interpreter, you can run Python scripts and projects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了这个解释器，你可以运行 Python 脚本和项目。
- en: Interactive Session
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式会话
- en: 'The interpreter’s *interactive session* allows you to enter and run code in
    real time and see the outcomes. You can start an interactive session on the command
    line with this command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器的 *交互式会话* 允许你实时输入并运行代码并查看结果。你可以使用以下命令在命令行启动交互式会话：
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Although the above should work on Windows, the same as on any other system,
    the Python documentation recommends the following alternative on Windows instead:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上述方法在 Windows 上也应当有效，就像在任何其他系统上一样，但 Python 文档推荐在 Windows 上使用以下替代方法：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just to keep everything system-agnostic, I’ll use `python3` throughout the rest
    of this book.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持系统无关性，我将在本书的剩余部分使用 `python3`。
- en: 'When you start the interactive session, you should see something that looks
    similar to this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动交互式会话时，你应该看到类似于以下内容的提示：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enter any Python code you want at the prompt `>`, and the interpreter will
    run it immediately. You can even enter multiline statements, such as conditional
    statements, and the interpreter will know more lines are expected before it runs
    the code. You’ll see the three-dot (`...`) prompt when the interpreter is waiting
    for more lines. When you’re done, press Enter on a blank line, and the interpreter
    will run the whole block:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符 `>` 下输入你想要的任何 Python 代码，解释器会立即执行它。你甚至可以输入多行语句，比如条件语句，解释器会知道在执行代码之前还需要更多的行。当解释器等待更多的行时，你会看到三点
    (`...`) 的提示。当你完成时，按空白行并回车，解释器会运行整个代码块：
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To quit the interactive session, run this command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出交互式会话，运行此命令：
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The interactive session is useful for testing things out in Python, but not
    much else. You should know of its existence moving forward, but I won’t use it
    much in this book. Instead, you should be using a proper code editor.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式会话在 Python 中进行测试时很有用，但除此之外没有太多用处。你应该知道它的存在，但在本书中我不会多加使用。相反，你应该使用合适的代码编辑器。
- en: Running Python Files
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 Python 文件
- en: You write scripts and programs in a text or code editor. I’ll introduce several
    code editors and IDEs at the end of this chapter, but in the meantime, you can
    use your favorite text editor for writing your code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你在文本或代码编辑器中编写脚本和程序。我将在本章末尾介绍几款代码编辑器和 IDE，但在此期间，你可以使用你最喜欢的文本编辑器来编写代码。
- en: 'Python code is written in *.py* files. To run a Python file (*myfile.py*, for
    example), you’d use this in the command line (*not* the interpreter):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Python 代码是写在*.py*文件中的。要运行一个 Python 文件（例如 *myfile.py*），你需要在命令行中使用这个命令（*不是*解释器）：
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Packages and Virtual Environments
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包和虚拟环境
- en: A *package* is a collection of code, which is analogous to a library in most
    other programming languages. Python is rather famous for being “batteries included,”
    since most things “just work” with a simple `import` statement. But if you need
    to do something beyond the basics, such as creating a snazzy user interface, you
    often have to install a package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*包*是代码的集合，在大多数其他编程语言中，它类似于一个库。Python 因为“自带电池”而颇为出名，因为大多数功能只需简单的`import`语句就能“直接使用”。但如果你需要做一些基本之外的事情，比如创建一个炫酷的用户界面，你通常需要安装一个包。'
- en: Thankfully, installing most third-party libraries is easy. Library authors bundle
    their libraries into packages, which can be installed using the handy little pip
    package manager tool that we installed earlier. I’ll cover that tool later.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，安装大多数第三方库非常简单。库的作者将他们的库打包成包，可以使用我们之前安装的便捷的 pip 包管理工具进行安装。我稍后会介绍这个工具。
- en: Using multiple third-party packages requires a bit of finesse. Some packages
    require other packages to be installed first. Certain packages have conflicts
    with other packages. You can also install specific versions of a package, depending
    on what exactly you need. Did I mention that some of the applications and operating
    system components on your computer rely on certain Python packages? This is why
    virtual environments exist.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个第三方包需要一些技巧。有些包需要先安装其他包。有些包与其他包存在冲突。你还可以根据需要安装特定版本的包。我提过吗？你计算机上的一些应用程序和操作系统组件依赖于特定的
    Python 包？这就是虚拟环境存在的原因。
- en: A *virtual environment* is a sandbox where you can install only the Python packages
    you need for a particular project, without the risk of those packages clashing
    with those for another project (or your system). You create different little sandboxes
    for each project and install only the packages you want in it. Everything stays
    neatly organized. You never actually change what Python packages are installed
    on your system, so you avoid breaking important things that have nothing to do
    with your project.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟环境*是一个沙箱，你可以在其中只安装某个特定项目所需的 Python 包，而不会有这些包与其他项目（或你的系统）中的包冲突的风险。你为每个项目创建不同的小沙箱，并只在其中安装你需要的包。一切都保持整洁有序。你从不真正改变系统上安装的
    Python 包，因此避免了破坏那些与项目无关的重要内容。'
- en: You may even create virtual environments that have nothing to do with a particular
    project. For example, I have a dedicated virtual environment for running random
    code files in Python 3.10, with a particular set of tools I use for finding problems.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以创建与特定项目无关的虚拟环境。例如，我有一个专门的虚拟环境，用于在 Python 3.10 中运行随机代码文件，并且有一组特定的工具我用来查找问题。
- en: Creating a Virtual Environment
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: Each virtual environment resides in a dedicated directory. Conventionally, we
    name this folder *env* or *venv*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟环境都位于一个专门的目录中。通常，我们将这个文件夹命名为*env*或*venv*。
- en: For each project, I typically like to create a dedicated virtual environment
    inside the project folder. Python provides a tool called *venv* for this.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个项目，我通常喜欢在项目文件夹中创建一个专门的虚拟环境。Python 提供了一个名为 *venv* 的工具来实现这一点。
- en: If you use Git or another *version control system* *(VCS)* for tracking changes
    to your code, there’s an additional setup step I’ll get to in a moment.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Git 或其他*版本控制系统*（*VCS*）来跟踪代码的更改，那么接下来有一步额外的设置我会介绍。
- en: 'To create the virtual environment with the name `venv` in the current working
    directory, run the following command in the command line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要在当前工作目录中创建一个名为 `venv` 的虚拟环境，可以在命令行中运行以下命令：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first `venv` ❶ is a command that creates a virtual environment, and the
    second `venv` ❷ is the desired path to the virtual environment. In this case,
    `venv` is just a relative path, creating a *venv/* directory in the current working
    directory. However, you could also use an absolute path, and you could call it
    whatever you want. For example, you could create a virtual environment called
    *myvirtualenv* in the */opt* directory of a UNIX system, like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`venv` ❶是一个用于创建虚拟环境的命令，而第二个`venv` ❷是虚拟环境的目标路径。在这个例子中，`venv` 只是一个相对路径，它会在当前工作目录下创建一个*venv/*目录。不过，你也可以使用绝对路径，并且可以根据需要命名它。例如，你可以在UNIX系统的*/opt*目录下创建一个名为*myvirtualenv*的虚拟环境，像这样：
- en: '[PRE16]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note, I’m specifying `python3` here, although I can run this with whatever Python
    version I want to use, such as `python3.9 -m venv venv`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在这里指定了`python3`，尽管我可以使用任何想要的Python版本运行这个命令，例如`python3.9 -m venv venv`。
- en: 'If you use something older than Python 3.3, make sure you install your system’s
    `virtualenv` package and then use this command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是早于Python 3.3的版本，确保先安装系统的`virtualenv`包，然后使用这个命令：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now if you look at your working directory, you’ll notice that the directory
    *venv/* has been created.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看你的工作目录，你会注意到*venv/*目录已经创建。
- en: Activating a Virtual Environment
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活虚拟环境
- en: To use your virtual environment, you need to activate it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用你的虚拟环境，你需要激活它。
- en: 'On UNIX-like systems, run this command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在类UNIX系统中，运行这个命令：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On Windows, run this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，运行这个：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, if you use PowerShell on Windows, run this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你在Windows上使用PowerShell，可以运行这个：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Some PowerShell users must first run `set-executionpolicy RemoteSigned` for
    virtual environments to work on Windows PowerShell. If you run into trouble, try
    this.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一些PowerShell用户必须首先运行`set-executionpolicy RemoteSigned`，才能让虚拟环境在Windows PowerShell中正常工作。如果遇到问题，请尝试这个。
- en: Like magic, you’re now using your virtual environment! You should see `(venv)`
    at the start of your command line prompt (not at the end), to indicate that you’re
    using a virtual environment named `venv`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 就像魔法一样，你现在正在使用你的虚拟环境！你应该能在命令行提示符的开始处看到`(venv)`（而不是结尾处），以表示你正在使用名为`venv`的虚拟环境。
- en: While inside your virtual environment, you can still access all the same files
    on your system that you use outside the virtual environment, but your environment
    *paths* will be overridden by the virtual environment. Practically speaking, any
    packages you install in the virtual environment are only usable there, and from
    the `venv`, the system-wide packages cannot be accessed unless you explicitly
    specify otherwise.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境中，你仍然可以访问系统上所有与虚拟环境外部使用的文件相同的文件，但你的环境*路径*会被虚拟环境覆盖。实际上，任何你在虚拟环境中安装的包只能在其中使用，而且从`venv`中无法访问系统范围的包，除非你明确指定。
- en: If you want the virtual environment to also see the system-wide packages, you
    can do so with a special flag, which has to be set when you first create the virtual
    environment. You can’t change this after the virtual environment is created.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望虚拟环境也能访问系统范围的包，可以通过一个特殊的标志来实现，必须在第一次创建虚拟环境时设置。虚拟环境创建后无法更改这一设置。
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Leaving a Virtual Environment
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 离开虚拟环境
- en: To get out of the virtual environment and back to reality . . . er, *ahem*,
    the system, you need a simple command.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要离开虚拟环境并回到现实……呃，*咳咳*，回到系统中，你只需要一个简单的命令。
- en: 'You ready for this, UNIX users? Just run this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗，UNIX用户？只需运行这个：
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That really is it. The same works for Windows PowerShell users.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。Windows PowerShell用户也可以使用相同的方法。
- en: 'Things are only slightly more complicated on the Windows command line:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows命令行中，事情稍微复杂一些：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Still pretty painless. Remember, like with activation, if you named your virtual
    environment something else, you’d have to change the `venv` in that line accordingly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 还是非常简单。记住，就像激活一样，如果你给虚拟环境起了别的名字，你需要在那一行中相应地修改`venv`。
- en: Introducing pip
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍pip
- en: Most of us have great expectations for Python’s package system. Python’s package
    manager is *pip*, which usually makes package installation trivial, especially
    in virtual environments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人对Python的包系统有很高的期望。Python的包管理器是*pip*，它通常使得包的安装变得非常简单，尤其是在虚拟环境中。
- en: System-Wide Packages
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统范围的包
- en: 'Remember, for any Python development work, you should almost always work in
    virtual environments. This will ensure that you’re always using the right packages
    for your work, without potentially messing up which packages (and versions thereof)
    are available to other programs on your computer. If you absolutely, positively
    know you want to install packages in your system-wide Python environment, you
    may use pip for that as well. First, make sure you are *not* working in a virtual
    environment, and then use this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于任何Python开发工作，你几乎总是应该在虚拟环境中工作。这样可以确保你始终使用适合你工作的正确包，而不会弄乱其他程序在你电脑上可用的包（及其版本）。如果你非常确定自己要在系统级别的Python环境中安装包，你也可以使用pip。首先，确保你*没有*在虚拟环境中工作，然后使用以下命令：
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Replace the `command` with your pip commands, which I’ll cover next.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将`command`替换为你的pip命令，我会在接下来的部分中介绍。
- en: Installing Packages
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装包
- en: 'To install a package, run `pip install` `package`. For example, to install
    PySide6 within an activated virtual environment, you’d use this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装包，运行`pip install` `package`。例如，要在已激活的虚拟环境中安装PySide6，你需要使用以下命令：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you want to install a specific version of something, append two equal signs
    (`==`), followed by the desired version number (no spaces):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想安装某个特定版本，可以在版本号后面加上两个等号（`==`），并跟上所需的版本号（不加空格）：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Bonus: you can even use operators like `>=`, to mean “at least this version
    or greater.” These are called *requirement specifiers*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 额外提示：你甚至可以使用像`>=`这样的操作符，表示“至少这个版本或更高”。这些被称为*需求说明符*。
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That line would install the latest version of PySide6 that is at least version
    `6.1.2`. This is really helpful if you want the most recent version of a package
    but also want to ensure you at least install a *minimum* version of a package
    (you might not). If it isn’t possible to install a version of the package that
    meets the requirement, pip will display an error message.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将安装至少为`6.1.2`的PySide6最新版本。如果你想要最新版本的包，但也希望确保至少安装包的*最低*版本（可能不需要），这非常有用。如果无法安装符合要求的包版本，pip会显示错误信息。
- en: If you’re on a UNIX-like system, you may need to use `pip install "PySide6>=6.1.2"`
    instead, since `>` has another meaning in the shell.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是类UNIX系统，你可能需要改用`pip install "PySide6>=6.1.2"`，因为`>`在shell中有另一层含义。
- en: requirements.txt
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: requirements.txt
- en: You can save even more time for yourself and others by writing a *requirements.txt*
    file for your project. This file lists the packages your project needs. When creating
    a virtual environment, you and other users can install all the required packages
    with a single command, using this file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为你的项目编写*requirements.txt*文件，你可以为自己和其他人节省更多的时间。该文件列出了项目所需的所有包。在创建虚拟环境时，你和其他用户可以使用这个文件，通过一个命令安装所有必需的包。
- en: 'To create this file, list the name of a pip package, as well as its version
    (if required), on each line. For example, one of my projects has a *requirements.txt*
    file like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个文件，在每一行列出一个pip包的名称，以及其版本（如果需要）。例如，我的一个项目有这样一个*requirements.txt*文件：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 2-1: *requirements.txt*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-1：*requirements.txt*
- en: 'Now anyone can install all those packages in one shot with this command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何人都可以通过以下命令一次性安装所有这些包：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I’ll revisit *requirements.txt* in Chapter 18, when I cover packaging and distribution.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第18章中重新提到*requirements.txt*，当时我会讲解打包和分发。
- en: Upgrading Packages
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级包
- en: 'You can update an already-installed package with pip as well. For example,
    to update to the latest version of PySide6, run this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用pip更新已安装的包。例如，要更新到最新版本的PySide6，请运行以下命令：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you have a *requirements.txt* file, you can also upgrade all your required
    packages at once:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有*requirements.txt*文件，你也可以一次性升级所有所需的包：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Removing Packages
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除包
- en: 'You can remove packages with this command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令删除包：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Replace `package` with the package name.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将`package`替换为包的名称。
- en: There is one minor wrinkle. Installing one package will also install any other
    packages it relies upon, which we call its *dependencies*. Uninstalling a package
    does not remove its dependencies, so you may need to go through and remove them
    yourself. This can get tricky, since multiple packages may share dependencies
    and you therefore risk breaking a separate package.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个小小的问题。安装一个包时，它也会安装所有它依赖的其他包，这些我们称之为*依赖项*。卸载一个包并不会移除它的依赖项，因此你可能需要自己去手动删除它们。这可能会变得棘手，因为多个包可能共享依赖项，从而有可能破坏其他包。
- en: Herein lies one more advantage of virtual environments. Once I’m in that sort
    of a pickle, I can delete the virtual environment, create a new one, and install
    only those packages I need.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是虚拟环境的另一个优势所在。一旦遇到这种困境，我可以删除虚拟环境，创建一个新的，并且仅安装我需要的那些软件包。
- en: Finding Packages
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找软件包
- en: Great, so now you can install, upgrade, and remove things. But how do you even
    know what packages pip has to offer?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在你可以安装、升级和删除软件包了。但是你怎么知道 pip 提供了哪些软件包呢？
- en: 'There are two ways to find out. The first is to use pip itself to run a search.
    Say you want a package for web scraping. Run this command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以找出这些软件包。第一种是使用 pip 自身进行搜索。假设你想找一个用于网页抓取的包，可以运行这个命令：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That will give you a whole ton of results to sift through, but it’s helpful
    at those times when you simply forget the name of a package.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给你带来大量的结果需要筛选，但在你忘记一个软件包的名字时，这非常有帮助。
- en: If you want something a lot more browsable and informative, [https://pypi.org/](https://pypi.org/%20)
    is the official Python Package Index.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个更易浏览和更具信息性的资源，[https://pypi.org/](https://pypi.org/%20) 是官方的 Python 包索引。
- en: One Warning About pip . . .
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于 pip 的一个警告...
- en: Unless you have expertise in the full technical implications, ***never*** use
    `sudo pip` on a UNIX-like system! It can do so many bad things to your system
    installation—things that your system package manager cannot correct—that if you
    decide to use it, you will regret it for the remainder of your system’s lifetime.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你精通所有技术细节，***绝对不要*** 在类 UNIX 系统上使用 `sudo pip`！它可能会对你的系统安装造成很多坏影响——这些是系统包管理器无法修复的问题——如果你决定使用它，你会为你的系统的一生感到后悔。
- en: Usually, when someone thinks they need to use `sudo pip`, they should really
    use `python3 -m pip` or `pip install --user` to install to their local user directory.
    Most other problems can be solved with virtual environments. Unless you’re an
    expert who fully understands what you’re doing and how to reverse it, don’t *ever*
    use `sudo pip`!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当有人认为他们需要使用 `sudo pip` 时，他们实际上应该使用 `python3 -m pip` 或 `pip install --user`
    来安装到本地用户目录。其他大多数问题可以通过虚拟环境来解决。除非你是一个完全理解自己在做什么并且知道如何恢复的专家，否则*绝对不要*使用 `sudo pip`！
- en: Virtual Environments and Git
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟环境和 Git
- en: Working with virtual environments and a VCS, like Git, can be tricky. Within
    a virtual environment’s directory are the *actual packages* you installed with
    pip. Those would clutter up your VCS repository with big, unnecessary files, and
    you can’t necessarily copy a virtual environment folder from one computer to another
    and expect it to work anyway.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟环境和版本控制系统（VCS），比如 Git，可能会有点棘手。在虚拟环境的目录中是你通过 pip 安装的*实际软件包*。这些会把你的 VCS 仓库弄得杂乱无章，充满不必要的大文件，而且你也不能指望将一个虚拟环境文件夹从一台电脑复制到另一台电脑上并且它依然能够正常工作。
- en: 'Thus, you *don’t* want to track these files in your VCS. There are two solutions:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你*不*希望在 VCS 中跟踪这些文件。有两种解决方案：
- en: Only create virtual environments outside of your repository.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只在仓库外部创建虚拟环境。
- en: Untrack the virtual environment directory in the VCS.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在版本控制系统中取消跟踪虚拟环境目录。
- en: There are arguments in favor of both rules, but which one you should use really
    depends on your project, environment, and particular needs.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对这两条规则都有支持的论据，但你应该使用哪一条实际上取决于你的项目、环境和具体需求。
- en: 'If you’re using Git, create or edit a file called *.gitignore* in the root
    directory of your repository. Add this line somewhere in it:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Git，在你的仓库根目录下创建或编辑一个名为 *.gitignore* 的文件。并在文件中添加以下内容：
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 2-2: *.gitignore*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-2: *.gitignore*'
- en: If you used a different name for your virtual environment, change that line
    to match. If you’re using a different VCS, like Subversion or Mercurial, check
    the documentation to see how to ignore a directory like *venv*.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为虚拟环境使用了不同的名称，请修改该行以匹配。如果你使用的是其他版本控制系统，如 Subversion 或 Mercurial，请查阅文档了解如何忽略像
    *venv* 这样的目录。
- en: Conventionally, every developer who clones your repository will build their
    own virtual environment, probably using that *requirements.txt* file you provided.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，每个克隆你仓库的开发者都会建立他们自己的虚拟环境，可能是使用你提供的 *requirements.txt* 文件。
- en: Even if you plan to place your virtual environments outside of the repository,
    it’s good to use your *.gitignore* file, just as a little extra insurance. Best
    VCS practice is to handpick which files to commit, but mistakes happen. Since
    *venv* is one of the most conventional names for a virtual environment directory,
    adding it to the *.gitignore* at least helps prevent some accidental commits.
    If your team has other standard names for virtual environments, you might consider
    adding those as well.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你计划将虚拟环境放在代码库外部，使用 *.gitignore* 文件也是个好主意，就像额外的保险一样。最佳的版本控制系统（VCS）实践是精确选择需要提交的文件，但错误总是会发生。由于
    *venv* 是虚拟环境目录的最常见名称，将其添加到 *.gitignore* 至少有助于避免一些意外提交。如果你的团队有其他标准的虚拟环境名称，也可以考虑将它们添加进去。
- en: The Whole Shebang
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整的 Shebang
- en: Many users and developers who might be running your code will also be using
    virtual environments. Yet all of this can come apart at the seams very easily
    if the very first line of your Python file is wrong.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 许多可能运行你代码的用户和开发者也会使用虚拟环境。然而，如果你的 Python 文件的第一行是错误的，所有这些都很容易出错。
- en: 'I’m talking about the *shebang*, a special command at the top of a Python file,
    by which you can make that file directly executable:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我在说的是 *shebang*，它是 Python 文件顶部的一个特殊命令，允许你直接使该文件可执行：
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 2-3: *hello_world.py*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-3: *hello_world.py*'
- en: 'The shebang (short for haSH-BANG, or `#!`) ❶ provides the path to the Python
    interpreter. While it’s optional, I strongly recommend including it in your code,
    as it means the file can be marked as executable and run directly, like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Shebang（简称 haSH-BANG 或 `#!`）❶ 提供了 Python 解释器的路径。虽然它是可选的，但我强烈建议在代码中包含它，因为这意味着文件可以被标记为可执行文件，并且可以直接运行，如下所示：
- en: '[PRE36]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is helpful, but as I’ve hinted before, one must be careful with shebangs.
    A shebang tells the computer where to find the exact Python interpreter to use,
    so the wrong shebang can break out of the confines of a virtual environment or
    even point to a version of the interpreter that isn’t installed.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有帮助，但正如我之前所暗示的，使用 shebang 时必须小心。Shebang 告诉计算机在哪里找到正确的 Python 解释器，所以错误的 shebang
    可能会突破虚拟环境的限制，甚至指向一个未安装的解释器版本。
- en: 'You may have seen this kind of shebang in the wild:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在实际使用中见过这种 shebang：
- en: '[PRE37]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 2-4: *shebang.py:1a*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-4: *shebang.py:1a*'
- en: That line is terribly wrong, because it forces the computer to use a particular
    system-wide copy of Python. Again, that dismisses the entire purpose of a virtual
    environment.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 那行是完全错误的，因为它强迫计算机使用系统中的某个特定的 Python 版本。再次强调，这完全忽视了虚拟环境的作用。
- en: 'Instead, you should always use this shebang for any Python file that only runs
    with Python 3:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你应该始终为任何仅在 Python 3 中运行的 Python 文件使用这个 shebang：
- en: '[PRE38]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 2-5: *shebang.py:1b*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-5: *shebang.py:1b*'
- en: 'If you happen to have a script which runs in *both* Python 2 and Python 3,
    use this shebang instead:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你恰好有一个既在 *Python 2* 又在 *Python 3* 中运行的脚本，应该使用这个 shebang：
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 2-6: *shebang.py:1c*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-6: *shebang.py:1c*'
- en: The rules about shebangs and how they are handled are officially outlined in
    PEP 394 (for UNIX-like systems) and PEP 397 (for Windows systems). Regardless
    of which system you develop for, it’s good to understand the implications of shebangs
    in both UNIX and Windows.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 shebang 及其处理方式的规则在 PEP 394（针对类 UNIX 系统）和 PEP 397（针对 Windows 系统）中有正式的说明。无论你开发的是哪个系统，了解
    shebang 在 UNIX 和 Windows 中的影响都是很有必要的。
- en: File Encoding
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件编码
- en: Since Python 3.1, all Python files have used the *UTF-8 encoding*, allowing
    the interpreter to use all of the characters in Unicode. (Prior to that version,
    the default was to use the old ASCII encoding.)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.1 开始，所有 Python 文件都使用 *UTF-8 编码*，这使得解释器可以使用 Unicode 中的所有字符。（在该版本之前，默认的是使用旧的
    ASCII 编码。）
- en: If you need to use a different encoding system, instead of the default UTF-8,
    you need to tell the Python interpreter that outright.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用不同的编码系统，而不是默认的 UTF-8，你需要明确告诉 Python 解释器。
- en: 'For example, to use Latin-1 encoding in a Python file, include this line at
    the top of your file, right below the shebang. To work, it must be on the first
    or second line—that’s where the interpreter looks for this information:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在 Python 文件中使用 Latin-1 编码，可以在文件顶部的 shebang 下方包含这一行。为了生效，它必须位于第一行或第二行——因为解释器会在这里查找这些信息：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you want another encoding system, replace `latin-1` with whatever you need.
    If you specify an encoding that Python doesn’t recognize, it will throw an error.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用其他编码系统，可以将 `latin-1` 替换为你需要的编码。如果你指定了一个 Python 不认识的编码，它会抛出错误。
- en: 'Although the preceding is the conventional way to specify encoding, there are
    two other valid ways to write the above comment. You can use this form, without
    the hard-to-remember `-*-`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上述是指定编码的传统方式，但还有两种有效的方式可以编写上述注释。你可以使用这种形式，无需记住复杂的 `-*-`：
- en: '[PRE41]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or you can use this longer but more English-like form:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用这种更长但更像英语的形式：
- en: '[PRE42]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Whatever you use, it must be *exactly* as shown above, except for swapping `latin-1`
    for whatever encoding you want. For this reason, the first or second forms are
    preferred.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么，它必须*完全*与上述显示一致，除了将 `latin-1` 替换为你想要的编码。因此，首选第一种或第二种形式。
- en: To learn more, read PEP 263, which defined this feature.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息，请阅读 PEP 263，它定义了这个功能。
- en: Most of the time, you’ll be fine using the default UTF-8 encoding anyway; if
    you need something else, now you know how to inform the interpreter.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，使用默认的 UTF-8 编码就足够了；如果需要其他编码，现在你知道如何告知解释器了。
- en: A Few Extra Virtual Environment Tricks
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些额外的虚拟环境技巧
- en: 'As you get used to using virtual environments and pip, you’ll pick up additional
    tricks and tools to make the whole process easier. Here are a few of the more
    popular ones:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你逐渐习惯使用虚拟环境和 pip，你将掌握一些额外的技巧和工具，使整个过程更加轻松。以下是一些比较流行的工具：
- en: Using a Virtual Environment Without Activating
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不激活虚拟环境的情况下使用
- en: You can use the binaries that are a part of the virtual environment without
    activating it. For example, you can execute `venv/bin/python` to run the virtual
    environment’s own Python instance, or `venv/bin/pip` to run its instance of pip.
    It’ll work the same as if you had activated the virtual environment.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不激活虚拟环境的情况下使用虚拟环境中的二进制文件。例如，你可以执行 `venv/bin/python` 来运行虚拟环境中的 Python 实例，或者执行
    `venv/bin/pip` 来运行其 pip 实例。它的工作方式与激活虚拟环境相同。
- en: 'For example, assuming my virtual environment is `venv`, I could do this in
    the terminal:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我的虚拟环境是 `venv`，我可以在终端中执行以下操作：
- en: '[PRE43]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It works! Yet, `import pylint` still will not work on the system-wide Python
    interactive shell (unless, of course, you installed it on the system).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效！不过，`import pylint` 在系统级 Python 交互式 shell 上仍然无法使用（除非你已经在系统上安装了它）。
- en: The Alternatives
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代方案
- en: Throughout this book, I’ll be using pip and `venv`, as they’re the default tools
    for modern Python. However, there are a few other solutions out there worth looking
    into.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将使用 pip 和 `venv`，因为它们是现代 Python 的默认工具。然而，市面上还有一些其他值得关注的解决方案。
- en: Pipenv
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pipenv
- en: A number of Python developers swear by *Pipenv*, which combines both pip and
    `venv` into one cohesive tool, with many additional features.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Python 开发者非常推崇 *Pipenv*，它将 pip 和 `venv` 结合成一个统一的工具，并提供了许多附加功能。
- en: Because the workflow is quite different, I won’t cover Pipenv here. If you’re
    interested in it, I recommend reading their superb documentation at [https://docs.pipenv.org/](https://docs.pipenv.org/).
    You’ll find comprehensive setup and usage instructions there, as well as a more
    detailed explanation of the advantages Pipenv offers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工作流程有很大不同，我在这里不会讲解 Pipenv。如果你对它感兴趣，建议阅读他们出色的文档 [https://docs.pipenv.org/](https://docs.pipenv.org/)。你会在那里找到完整的安装和使用说明，以及
    Pipenv 提供的优势的更详细解释。
- en: pip-tools
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pip-tools
- en: A number of tasks in pip can be simplified with pip-tools, including automatic
    updating, aids for writing *requirements.txt*, and more.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: pip 中的许多任务可以通过 pip-tools 简化，包括自动更新、编写 *requirements.txt* 的辅助工具等。
- en: If you use pip-tools, you should only install it within a virtual environment.
    It is designed specifically for that use case.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 pip-tools，应该仅在虚拟环境中安装它。它专门为这种用例设计。
- en: More information is available at [https://pypi.org/project/pip-tools/](https://pypi.org/project/pip-tools/).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请访问 [https://pypi.org/project/pip-tools/](https://pypi.org/project/pip-tools/)。
- en: poetry
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: poetry
- en: Some Python developers absolutely hate the entire pip workflow. One such developer
    created *poetry* as an alternative package manager. I don’t use it in this book,
    as it behaves very differently, but I’d be remiss not to point it out.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Python 开发者非常讨厌整个 pip 工作流。一位开发者创建了 *poetry* 作为替代的包管理器。我在本书中没有使用它，因为它的行为方式与
    pip 大不相同，但如果不提到它，我会感到失职。
- en: 'You can find more information, download directions (the creator does not recommend
    using pip to install it), and access documentation on their website: [https://python-poetry.org/](https://python-poetry.org/).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在他们的网站上找到更多信息、下载指南（创作者不建议使用 pip 安装）以及文档：[https://python-poetry.org/](https://python-poetry.org/)。
- en: Introduction to PEP 8
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEP 8 简介
- en: Unlike many languages, where style decisions are left entirely to the discretion
    of the community at large, Python does have an official style guide, which is
    published as *PEP 8*. Although the conventions in the guide are intended primarily
    for standard library code, many Python developers choose to stick to them as a
    rule.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '与许多语言不同，在这些语言中，风格决策完全由社区自由决定，Python有官方的风格指南，即*PEP 8*。尽管该指南中的规范主要是针对标准库代码，但许多Python开发者选择将其作为规则来遵循。  '
- en: 'That doesn’t make them mandatory: if you have an objective reason to follow
    a different style convention in your project, that’s fine, although you should
    apply that style consistently, as much as is reasonable.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '这并不意味着它们是强制性的：如果你有客观的理由在你的项目中遵循不同的风格规范，那是可以的，尽管你应该尽可能一致地应用该风格，合理范围内。  '
- en: 'PEP 8 itself makes this distinction clear, early on:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'PEP 8本身在早期就明确做出了这一区分：  '
- en: A style guide is about consistency. Consistency with this style guide is important.
    Consistency within a project is more important. Consistency within one module
    or function is the most important.
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '风格指南关乎一致性。遵守此风格指南的一致性很重要。在一个项目内保持一致性更为重要。在一个模块或函数内保持一致性是最重要的。  '
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, know when to be inconsistent—sometimes, style guide recommendations
    just aren’t applicable. When in doubt, use your best judgment. Look at other examples
    and decide what looks best. And don’t hesitate to ask!
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '然而，要知道何时打破一致性——有时候，风格指南的建议并不适用。当有疑问时，使用你最好的判断力。查看其他示例，决定什么看起来最合适。并且不要犹豫，向他人请教！  '
- en: In practice, you’ll likely find very little reason to deviate from PEP 8\. The
    style guide is far from all-encompassing. It leaves plenty of breathing room,
    while making it clear what constitutes a good or bad coding style.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，你可能很少需要偏离PEP 8。风格指南远非包罗万象。它留下了很多余地，同时明确了什么样的编码风格是好的，什么样的是不好的。  '
- en: The Line Limit Debate
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '行限制辩论  '
- en: PEP 8 recommends a line limit of 79 characters, or an 80-character cutoff, though
    there’s a lot of debate on the topic. Some Python developers respect that rule,
    while others prefer cutoffs of 100 or 120 characters. What to do?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'PEP 8推荐的行限制是79个字符，或者80个字符的上限，尽管这个话题有很多争议。一些Python开发者遵守这个规则，而另一些人则更喜欢100或120个字符的上限。该怎么办呢？  '
- en: 'The most common argument for longer limits is that modern monitors are wider
    and higher resolution. Surely, the 80-character limit is a relic of a bygone era,
    right? ***Definitely not!*** There are several reasons to stick to a common line
    limit. For example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '最常见的关于更长限制的论点是，现代显示器更宽且分辨率更高。当然，80个字符的限制是过去时代的遗物，对吧？***绝对不是！*** 坚持使用常见的行限制有几个原因。例如：  '
- en: Vision-impaired individuals who must work with larger font sizes or zoomed-in
    interfaces
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '视力受损的人必须使用更大的字体或放大界面  '
- en: Viewing differences in a file between commits in a side-by-side diff
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在提交之间查看文件差异时的并排比较  '
- en: Split-screen editors, displaying multiple files simultaneously
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '分屏编辑器，同时显示多个文件  '
- en: Vertical monitors
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '垂直显示器  '
- en: Side-by-side windows on a laptop monitor, wherein the editor only has half its
    usual space
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '笔记本显示器上的并排窗口，其中编辑器只有通常空间的一半  '
- en: Individuals with older monitors, who cannot afford to upgrade to the latest
    1080p monster
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用较旧显示器的个人，他们无法负担升级到最新的1080p大显示器  '
- en: Viewing code on mobile devices
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在移动设备上查看代码  '
- en: Writing coding books for No Starch Press
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '为No Starch Press编写编程书籍  '
- en: 'In all of these scenarios, the reasoning behind the 80-character limit becomes
    apparent: there simply isn’t enough horizontal space for 120 characters or more
    per line. Soft text wrapping, wherein the remainder of a cut-off line appears
    on a separate line (without a line number), does solve some of these issues. However,
    it can be difficult to read, as many people forced to rely on it regularly will
    attest to.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些场景中，80字符限制背后的理由变得显而易见：每行120个字符或更多，横向空间实在不够。软文本换行，即将被截断的行的其余部分显示在另一行（没有行号），确实解决了一些问题。然而，它可能难以阅读，许多人被迫经常依赖它的人可以证明这一点。
- en: 'This doesn’t mean that you have to follow this 79-character maximum religiously.
    There are exceptions. Above all, *readability* and *consistency* are the goals.
    Many developers embrace the 80/100 rule: an 80-character “soft” cutoff, you try
    to respect in most cases; and a 100-character “hard” cutoff, you reserve for all
    those cases where the lower limit would negatively impact readability.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着您必须严格遵守 79 字符的最大限制。也有例外情况。最重要的是，*可读性* 和 *一致性* 是目标。许多开发人员采用 80/100 规则：80
    字符“软”限制，尽量遵守；100 字符“硬”限制，适用于所有低于此限制会影响可读性的情况。
- en: Tabs or Spaces?
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tab 还是空格？
- en: Ah yes, the civil war over which many friendships have been strained and many
    relationships have abruptly ended (okay, maybe just that one?). Most programmers
    have strong feelings on the topic.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，是的，关于这个话题的内战已经让许多友谊变得紧张，甚至一些关系突然破裂（好吧，也许只有那一次？）。大多数程序员对此有强烈的看法。
- en: PEP 8 recommends spaces over tabs, but technically, it allows either. The important
    thing is to *never mix the two*. Use either spaces or tabs, and stick to it throughout
    your entire project.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 推荐使用空格而非 Tab，但从技术上讲，它允许两者。重要的是 *永远不要混用两者*。在整个项目中，要么使用空格，要么使用 Tab，并始终坚持一致。
- en: 'If you do use spaces, then there’s the debate about how many spaces to use.
    PEP 8 answers this question, too: *four spaces per indentation level*. Any less
    can negatively impact code readability, especially for people with visual impairments
    or some forms of dyslexia.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实使用空格，那么就会有关于使用多少空格的争论。PEP 8 也回答了这个问题：*每个缩进级别使用四个空格*。使用更少的空格可能会影响代码的可读性，特别是对于视力障碍者或一些阅读障碍者。
- en: By the way, most code editors are able to automatically enter four spaces when
    they press Tab, so there’s rarely an excuse to press space repeatedly.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，大多数代码编辑器都能够在按下 Tab 键时自动输入四个空格，因此很少需要反复按空格键。
- en: 'Quality Control: Static Analyzers'
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 质量控制：静态分析器
- en: One of the most useful tools in any programmer’s toolkit is a reliable *static
    analyzer*, which reads your source code, looking for potential problems or deviations
    from the standards. If you’ve never used one before, now is the time to change
    that. One common type of static analyzer, called a *linter*, checks your source
    code for common mistakes, potential errors, and style inconsistencies. Two of
    the most popular linters are *Pylint* and *PyFlakes*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何程序员的工具包中，最有用的工具之一就是可靠的 *静态分析器*，它可以读取源代码，寻找潜在问题或偏离标准的地方。如果您从未使用过它们，现在是时候开始了。静态分析器中的一种常见类型叫做
    *linter*，它检查源代码中常见的错误、潜在问题和风格不一致。最流行的两个 linter 是 *Pylint* 和 *PyFlakes*。
- en: There are many more kinds of static analyzers available for Python, including
    static type checkers like *Mypy* and complexity analyzers like *mccabe*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有许多其他类型的静态分析工具，包括静态类型检查工具，如 *Mypy* 和复杂度分析工具，如 *mccabe*。
- en: I’ll cover how to install all of these below, and I’ll discuss how to use many
    of them. I recommend you choose only one of these two linters and install the
    rest of the static analyzers.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下面介绍如何安装所有这些工具，并讨论如何使用其中的许多工具。我建议您只选择其中一种 linter，并安装其余的静态分析工具。
- en: Pylint
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pylint
- en: Pylint is perhaps the most versatile static analyzer in Python. It works decently
    well by default, and it allows you to customize exactly what you want it to look
    for and ignore.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 可能是 Python 中最通用的静态分析工具。它默认工作得相当好，而且允许您自定义要检测和忽略的内容。
- en: 'You can install the Pylint package with pip, which I recommend doing in a virtual
    environment. Once installed, you pass Pylint the name of a file you want analyzed,
    like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 pip 安装 Pylint 包，我推荐在虚拟环境中安装。安装完成后，您可以将 Pylint 与要分析的文件名一起传递，例如：
- en: '[PRE44]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can also analyze an entire package or module at once. (I’ll define what
    modules and packages are in Chapter 4.) For example, if you want Pylint to analyze
    a package called `myawesomeproject` in the current working directory, you’d run
    this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以一次分析整个包或模块。（我将在第 4 章定义模块和包的概念。）例如，如果您想让 Pylint 分析当前工作目录下名为 `myawesomeproject`
    的包，可以运行以下命令：
- en: '[PRE45]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Pylint will scan the files and display its warnings and recommendations on the
    command line. Then, you can edit your file and make the necessary changes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 会扫描文件并在命令行显示其警告和建议。然后，您可以编辑文件并进行必要的更改。
- en: 'For example, consider the following Python file:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下 Python 文件：
- en: '[PRE46]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 2-7: *cooking.py:1a*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 2-7: *cooking.py:1a*'
- en: 'I’ll run the linter on that file with the following in the system command line:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用以下命令在系统命令行中运行 linter 来分析该文件：
- en: '[PRE47]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Pylint provides the following feedback:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 提供了以下反馈：
- en: '[PRE48]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The linter found five errors in my code: both the module and the function are
    missing their docstrings (see Chapter 3). I tried to use the variables `eggs`
    and `order`, neither of which exist. I also assigned a value to the variable `ham`,
    but I never used that value anywhere.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'If Pylint takes umbrage at a particular line of code you feel should be left
    as is, you can tell the static analyzer to ignore it and move on. You do this
    with a special comment, either inline on the line in question or at the top of
    the affected block. For example:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 2-8: *cooking.py:1b*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'With the first command, I tell Pylint not to alert me about the missing docstring
    on the module; that affects the entire block of code. The inline comment on the
    next line will suppress the warning about the missing docstring on the function,
    and it will only affect that line. If I ran the linter again, I’d only see the
    other two linter errors:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At this point, I’d edit my code and actually fix the rest of those problems.
    (Except I won’t, for this example.)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also control Pylint’s project-wide behavior by creating a *pylintrc*
    file in the root directory of your project. To do this, run the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Find that file; open it; and edit it to turn on and off different warnings,
    ignore files, and define other settings. The documentation isn’t fantastic for
    this, but you can often work out what different options do from the comments in
    that *pylintrc* file.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run Pylint, it will look for a *pylintrc* (or *.pylintrc*) file in
    the current working directory. Alternatively, you can specify a different filename
    for Pylint to read its settings from, such as *myrcfile*, by passing the filename
    to the `--rcfile` option when invoking Pylint:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Some regular users of Pylint like to create `.pylintrc` or `.config/pylintrc`
    in their home directory (UNIX-like systems only). If Pylint cannot find another
    configuration file, it will use the one in the home directory.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Although the Pylint documentation is far from comprehensive, it can still be
    useful. You can find it at [https://pylint.readthedocs.io/](https://pylint.readthedocs.io/).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Flake8
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Flake8* tool is actually a combination of three static analyzers:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '*PyFlakes* is a linter, similar in purpose to Pylint. It is designed to work
    faster and to avoid false positives (both being common complaints about Pylint).
    It also ignores style rules, which are handled by the next tool.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pycodestyle* is a style checker, to help ensure you write PEP 8-compliant
    code. (This tool used to be called `pep8`, but it was renamed to avoid confusion
    with the actual style guide.)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*mccabe* checks the McCabe (or Cyclomatic) complexity of your code. If you
    don’t know what that is, don’t worry—its purpose is essentially just to warn you
    when your code’s structure is getting too complicated.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can install the Flake8 package with pip, which I typically do within a virtual
    environment.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'To scan a file, module, or package, pass it to `flake8` on the command line.
    For example, to scan my earlier *cooking.py* file ([Listing 2-8](#listing2-8)),
    I’d use this command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That outputs the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: (You’ll notice that Flake8 isn’t complaining about the lack of docstrings; that’s
    disabled by default in this linter.)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, only PyFlakes and pycodestyle are run. If you want to analyze the
    complexity of your code, you also need to pass the argument `--max-complexity`,
    followed by a number. Anything higher than `10` is considered too complex, but
    if you understand McCabe complexity, you can change this to suit your needs. So,
    for example, to check the complexity of the *cooking.py* file, you’d run this:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However you run Flake8, you’ll get a comprehensive list of all the errors and
    warnings in your code.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: If you need to tell Flake8 to ignore something it thinks is a problem, you use
    a `# noqa` comment, followed by the error code to ignore. This comment should
    be inline, on the line where the error occurs. If you omit the error code, then
    `# noqa` will cause Flake8 to ignore all errors on that line.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'In my code, if I wanted to ignore both of the errors I received, it might look
    like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 2-9: *cooking.py:1c*'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Here, you see three different scenarios. First, I’m ignoring only warning `F841`.
    Second, I’m ignoring two errors (even though one of them isn’t actually raised;
    this is just a silly example). Third, I’m ignoring all possible errors.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Flake8 also supports configuration files. In the project directory, you can
    create a *.flake8* file. Start a section in that file with the line `[flake8]`,
    followed by all the Flake8 settings you want to define. (See the documentation.)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Flake8 will also accept project-wide configuration files called *tox.ini* or
    *setup.cfg*, so long as they have a `[flake8]` section within them.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to automatically run mccabe each time you invoke Flake8,
    rather than specify `--max-complexity` every time, you could define a *.flake8*
    file that looks like this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 2-10: *.flake8*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Some developers like to define a system-wide configuration file for Flake8,
    which you can do (only) on a UNIX-like system. In your home folder, create the
    configuration file as either *.flake8* or *.config/flake8*.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: One of the chief advantages of Flake8 over Pylint is the documentation. Flake8
    has a complete list of their warnings, errors, options, and the like. You can
    find the documentation at [https://flake8.readthedocs.io/](https://flake8.readthedocs.io/).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Mypy
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Mypy* is an unusual static analyzer because it focuses entirely on *type annotations*
    (see Chapter 6). Because it involves so many concepts I haven’t covered yet, I
    won’t go into much depth here.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Still, now is a good time to get it installed. Like everything else so far,
    you can install the `mypy` package from pip.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, Mypy can be used by passing it the file, package, or module
    you wish to check:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Mypy will only attempt to check files that have type annotations, and it will
    ignore the rest.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 只会尝试检查具有类型注解的文件，忽略其他文件。
- en: 'Style Janitors: Autoformatting Tools'
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 风格清洁工：自动格式化工具
- en: Another tool you may find useful is an *autoformatter,* which can automatically
    change your Python code—spacing, indentation, and preferred equivalent expressions
    (such as `!=` instead of `<>`)—to be PEP 8 compliant. Two options are *autopep8*
    and *Black*.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能对你有用的工具是 *自动格式化工具*，它可以自动更改你的 Python 代码——空格、缩进以及首选的等价表达式（如使用 `!=` 代替 `<>`）——以符合
    PEP 8。两个选项是 *autopep8* 和 *Black*。
- en: autopep8
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: autopep8
- en: The autopep8 tool leverages pycodestyle (part of Flake8), even using the same
    configuration file as that tool to determine what style rules it ultimately follows
    or ignores.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: autopep8 工具利用了 pycodestyle（Flake8 的一部分），甚至使用与该工具相同的配置文件来决定它最终遵循或忽略哪些风格规则。
- en: As always, you can install `autopep8` with pip.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，你可以通过 pip 安装 `autopep8`。
- en: By default, autopep8 only fixes whitespace, but if you pass the `--aggressive`
    argument to it, it will make additional changes. In fact, if you pass that argument
    twice, it will do even more. The complete list is beyond the scope of this explanation,
    so consult the documentation at [https://pypi.org/project/autopep8/](https://pypi.org/project/autopep8/)
    to learn more.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，autopep8 只会修复空格问题，但如果你传递 `--aggressive` 参数，它会进行额外的修改。事实上，如果你传递该参数两次，它会做更多修改。完整的列表超出了本说明的范围，因此请参考文档
    [https://pypi.org/project/autopep8/](https://pypi.org/project/autopep8/) 以了解更多。
- en: 'To fix most PEP 8 issues on a Python code file by changing it in place (as
    opposed to making a copy, which is the default behavior), run this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过就地修改（而不是复制文件，这是默认行为）来修复 Python 代码文件中的大部分 PEP 8 问题，可以运行以下命令：
- en: '[PRE59]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Changing the file directly may sound a bit risky, but it really isn’t. Style
    changes are just that: style. They don’t affect the actual behavior of the code.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 直接修改文件听起来有点冒险，但实际上并不危险。风格的改变就是风格改变：它们不会影响代码的实际行为。
- en: Black
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Black
- en: 'The Black tool is a little more straightforward: it assumes you want to follow
    PEP 8 in its entirety, and it doesn’t overwhelm you with many options as a result.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Black 工具稍微直接一些：它假设你想完全遵循 PEP 8，因此不会让你被许多选项所困扰。
- en: 'Like autopep8, you install `black` with pip, although it requires Python 3.6
    or later. To format a file with it, pass the filename:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 与 autopep8 类似，你可以通过 pip 安装 `black`，但它需要 Python 3.6 或更高版本。要使用它格式化文件，只需传递文件名：
- en: '[PRE60]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A complete list of Black’s few options can be seen via `black --help`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Black 的完整选项列表可以通过 `black --help` 查看。
- en: Testing Frameworks
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试框架
- en: 'Testing frameworks form an essential part of any good development workflow,
    but I won’t go into detail about them in this chapter. Python has three major
    options for testing frameworks: *Pytest*, *nose2*, and *unittest*, in addition
    to a promising new project called *ward*. All of these can be installed with pip.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架是任何良好的开发工作流中不可或缺的一部分，但在本章中我不会详细讨论它们。Python 有三种主要的测试框架：*Pytest*、*nose2* 和
    *unittest*，此外还有一个有前景的新项目叫做 *ward*。这些都可以通过 pip 安装。
- en: More knowledge is essential to cover this topic effectively, so I’ll revisit
    it in Chapter 20.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更多的知识来有效覆盖这个话题，因此我将在第 20 章再次讨论它。
- en: An Exhibition of Code Editors
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码编辑器展览
- en: You have your Python interpreter, your virtual environments, your static analyzers,
    and other such tools. Now you are prepared to write code.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你有了 Python 解释器、虚拟环境、静态分析工具以及其他相关工具。现在你已经准备好编写代码了。
- en: You can write Python in any basic text editor, just as you could with practically
    any other programming language. Yet you’ll probably have an easier time writing
    production-quality code with a proper code editor.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何基本的文本编辑器中编写 Python 代码，就像你可以使用几乎任何其他编程语言一样。然而，你可能会更容易用一个合适的代码编辑器编写生产质量的代码。
- en: Before I end this chapter, I want to take you on a tour of several of the most
    popular Python code editors and integrated development environments (*IDEs*) available.
    This is only a sampling, as there are many more options besides. **If you already
    know what code editor or IDE you want to use, skip forward to the last section
    of this chapter.**
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我想带你参观几款最流行的 Python 代码编辑器和集成开发环境（*IDEs*）。这只是一个样本，因为还有很多其他选项可供选择。**如果你已经知道要使用哪个代码编辑器或
    IDE，可以跳到本章的最后一节。**
- en: IDLE
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IDLE
- en: 'Python has its own IDE, called *IDLE*, which ships with the standard distribution
    of Python. It’s a fairly bare-bones IDE with two components: an editor and an
    interface for the interactive shell. You could do worse than IDLE, so if you aren’t
    in the mood to install a different editor right now, start here. However, I recommend
    exploring your options, as most editors and IDEs have a host of useful features
    that IDLE lacks.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Emacs and Vim
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purists and old-school hackers among you will be glad to know that Emacs
    and Vim both have excellent Python support. Setting up either is not for the faint
    of heart, so I’m not going into any of that here.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: If you’re already a lover of either (or both?) code editors, you can find excellent
    tutorials for both at Real Python.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: For Emacs, see [https://realpython.com/emacs-the-best-python-editor/](https://realpython.com/emacs-the-best-python-editor/).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: For Vim, see [https://realpython.com/vim-and-python-a-match-made-in-heaven/](https://realpython.com/vim-and-python-a-match-made-in-heaven/).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'According to “The State of Developer Ecosystem 2021” developer survey by JetBrains,
    the PyCharm IDE from JetBrains is far and away the most popular option for Python
    programming. It comes in two flavors: the free *PyCharm Community Edition* and
    the paid *PyCharm Professional Edition*. (Steps were taken by JetBrains to eliminate
    bias. See the survey here: [https://www.jetbrains.com/lp/devecosystem-2021/python/](https://www.jetbrains.com/lp/devecosystem-2021/python/).)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Both versions offer a dedicated Python code editor with autocompletion, refactoring,
    debugging, and testing tools. It can manage and use virtual environments with
    ease, and it integrates with your version control software. It even performs static
    analysis (using its own tool). The professional edition adds tools for data, scientific
    development, and web development.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with other JetBrains IDEs, like IntelliJ IDEA or CLion, PyCharm
    would be a great Python IDE to start with. It requires more computer resources
    than many code editors, but if you have a decently powerful machine, this won’t
    be a problem. If you haven’t used JetBrains IDEs before, try the Community Edition
    before investing in the paid version.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information and downloads at [https://jetbrains.com/pycharm/](https://jetbrains.com/pycharm/).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Visual Studio Code* has excellent Python support. It’s the second-most popular
    Python code editor, according to that 2021 JetBrains survey. It’s free and open
    source, and it runs on virtually every platform. Install the official Python extension
    from Microsoft, and you’re ready to go!'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code supports autocompletion, refactoring, debugging, and virtual
    environment switching, along with the usual version control integration. It integrates
    with Pylint, Flake8, and Mypy, among several other popular static analyzers. It
    even works with the most common Python unit testing tools.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Download it at [https://code.visualstudio.com/](https://code.visualstudio.com/).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Sublime Text
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Sublime* is another popular multilanguage code editor. It is appreciated for
    its speed and simplicity, and it is easily customized with extensions and configuration
    files. Sublime Text is free to try, but if you find you like it and wish to continue
    using it, you need to purchase it.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'The Anaconda plug-in transforms Sublime Text into a Python IDE, with everything:
    autocompletion, navigation, static analysis, autoformatting, test running, and
    even a documentation browser. It requires a little more hand-tuned configuration
    than some of the other options, especially if you want to use virtual environments.
    However, if Sublime Text is your jam, it’s worth it.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Download Sublime Text at [https://sublimetext.com/](https://sublimetext.com/)
    and the Anaconda plug-in at [https://damnwidget.github.io/anaconda/](https://damnwidget.github.io/anaconda/).
    That second link also provides instructions for installing the plug-in in Sublime
    Text.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Spyder
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your focus is scientific programming or data analysis, or if you’re a fan
    of MATLAB’s interface, you’ll be right at home in *Spyder*, a free and open source
    Python IDE that is also written *in* Python.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the usual features—a dedicated Python code editor, a debugger,
    integration with static analyzers, and documentation viewing—Spyder includes integration
    with many common Python libraries for data analysis and scientific computing.
    It integrates a full code profiler and variable explorer. Plug-ins exist for supporting
    unit tests, autoformatting, and editing Jupyter notebooks, among other features.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: Download Spyder at [https://spyder-ide.org/](https://spyder-ide.org/).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse + PyDev/LiClipse
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Eclipse* has lost a lot of ground to the newer editors, but it still has a
    loyal user base. Although it’s geared toward languages like Java, C++, PHP, and
    JavaScript, Eclipse can also become a Python IDE with the *PyDev* plug-in.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: If you already have installed Eclipse, which is completely free, then you only
    need to install the PyDev plug-in from the Eclipse Marketplace. Download Eclipse
    at [https://eclipse.org/ide/](https://eclipse.org/ide/) and look in the marketplace
    for the plug-in.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can install *LiClipse,* which bundles Eclipse, PyDev, and
    other useful tools. The PyDev developers recommend this approach, as it directly
    supports their development work. You can use LiClipse without a license for 30
    days, after which point, you must purchase a license. Download LiClipse from [https://liclipse.com/](https://liclipse.com/).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: PyDev offers autocompletion, refactoring, support for type hinting and static
    analysis, debugging, unit test integration, and many more features. You can find
    more information about PyDev at [https://pydev.org/](https://pydev.org/).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: The Eric Python IDE
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Eric* might be the oldest IDE on the list, but it’s still as reliable as ever.
    Named after Eric Idle of *Monty Python’s Flying Circus*, Eric is a free and open
    source IDE written in Python.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'It offers everything you could possibly need to write Python: autocompletion,
    debugging, refactoring, static analysis, testing integration, documentation tools,
    virtual environment management, and the list goes on.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Find information about Eric and download it at [https://eric-ide.python-projects.org/](https://eric-ide.python-projects.org/).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing code involves so much more than just code. Having set up your development
    environment, project, and IDE, you are now prepared to focus exclusively on making
    your code the best it can be.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: By this point, you should have assembled a Python development workbench worthy
    of any production-level project. At minimum, you should have installed the Python
    interpreter, pip, `venv`, one or more static analyzers, and a Python code editor.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, in your code editor or IDE, create a *FiringRange* project for experimenting
    in while working through this book. For the moment, to be sure everything works,
    you can make a single Python file in that project with these contents:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 2-11: *hello_world.py*'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 'Run that like this:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You should see the following output:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: I’ll go into the correct structure for Python projects in Chapter 4, but writing
    and running individual Python files in your firing range project should be sufficient
    for Chapter 3.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: If you’re new to the IDE you have selected, take a few minutes now to familiarize
    yourself with it. You should particularly ensure you know how to navigate and
    run code, manage files, work with virtual environments, access the interactive
    console, and use the static analyzers.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Syntax Crash Course
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
- en: Python is an unusual mix of common and unique concepts. Before diving into the
    intricacies of the language, you must first grasp its essential syntax.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn most of the essential syntactic structures you’ll
    encounter in Python, and you’ll also become familiar with the basic mathematical
    and logical features of the language.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Python developers will point newcomers to the official Python tutorial,
    which is an excellent introduction to the language’s structure. While I’ll cover
    all of these concepts in this book in depth, the tutorial is still a good resource
    worth reading: [https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/).'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Hello, World!
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It won’t feel like a proper introduction to the language without the classic
    Hello World program. In Python, it’s written like this:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 3-1: *hello_world.py*'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: There’s nothing novel here. You call the `print()` function to write text to
    the console, and you pass data in a string, wrapped in quotes as an argument.
    You can pass whatever sort of data you like, and it will be output on the console.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'I can also get input from the console with the `input()` function:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Listing 3-2: *hello_input.py*'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: I use the `input()` function and pass my prompt as a string ❶. When I run that
    code, Python greets me using the name I entered on the console.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Statements and Expression
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each line of code in Python that ends with a line break is a *statement*, sometimes
    more specifically known as a *simple statement*. Unlike in many C-inspired languages,
    you don’t need to end a line in Python with a special character.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: A section of code that evaluates to a single value is called an *expression*.
    In Python, you can put expressions nearly anywhere a value is expected. The expression
    is evaluated down to a value, and that value is used in that position in the statement.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in one statement, I can create a variable, and in another statement,
    I can print its contents to the console:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Listing 3-3: *hello_statements.py:1a*'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: I assign the expression `"Hello, world!"` to `message`, and then I pass the
    expression `message` to `print()`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever need to place multiple statements on the same line, you can separate
    them with a semicolon (`;`). To demonstrate this, here are the same two statements
    as earlier, but packed onto one line, with a semicolon to separate them:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 3-4: *hello_statements.py:1b*'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: While this is valid code, using this technique is somewhat discouraged. The
    Python philosophy places a high value on readability, and the placement of multiple
    statements on the same line often detracts from that.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Stick to placing one statement per line, unless you have a specific reason to
    do otherwise.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: The Importance of Whitespace
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re looking at a sample of Python source code, the first thing that
    will probably jump out at you is the use of indentation for nesting. A *compound
    statement* is made up of one or more *clauses*, each of which consists of a line
    of code called a *header* and a block of code called a *suite*, which is associated
    with the header.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this program prints different messages, depending on whether a
    `name` is specified:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 3-5: *hello_conditional.py*'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: I set up a conditional statement with an `if` header ❶, after which I have a
    suite made up of two indented lines of code, which “belongs” to the header. These
    lines of code are executed only if the conditional expression in the header is
    evaluated to `True`.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: The unindented line ❷ is not part of the suite that belongs to the conditional
    statement, and it will be run every time.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'As I nest deeper, I need to add more indentation:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Listing 3-6: *weather_nested_conditional.py*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: The first `print` statement is indented twice, which is how Python knows that
    it belongs to both preceding conditional statements.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Given the importance of whitespace, the “tabs versus spaces” war is fairly common
    in Python world. You’ll remember from Chapter 2 that the PEP 8 style guide stresses
    using either four spaces or a single tab per indentation level. ***Consistency
    is key!*** Python really doesn’t care whether you use tabs, two spaces, four spaces,
    or even seven spaces (although that’s probably a step too far) for each level
    of indentation. The point is to be consistent within any and every given block
    of code.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: You should use only one indentation style throughout your project, even if your
    situation provides a technical loophole. Don’t mix tabs and spaces. Chances are
    your IDE has tools to help you with this.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity’s sake, I’ll use the PEP 8 convention of four spaces throughout
    my code examples. While I’d recommend you follow this same convention—you can
    even configure your editor to insert four spaces each time you hit the Tab key—if
    you have a strong preference for tabs, you’re welcome to use those instead. It
    really doesn’t matter.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Doing Nothing
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On occasion, you will need to insert a statement that has absolutely no effect.
    This is particularly useful when you need to put a syntactically valid placeholder
    where a suite of code will exist later. For this purpose, Python provides the
    `pass` keyword.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I can employ the `pass` keyword as a placeholder in my `if raining`
    conditional, until I’m able to write the final code:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Listing 3-7: *raining_pass.py*'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Just remember, `pass` does absolutely nothing. That’s the only reason it exists.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Comments and Docstrings
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write comments in Python, precede the line with a hash (`#`). Everything
    between the hash and the end of the line is a comment and will be ignored by the
    interpreter.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 3-8: *comments.py*'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: If you ran this program, the `print` statements would both execute. The rest
    of the second `print` statement, from the hash onward, is an inline comment ❶
    and would be ignored by the interpreter. All the other lines are only comments.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Officially, there is no syntax for “multiline” comments; you just comment each
    line. There is one special exception: the *docstring*. It looks like this:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Listing 3-9: *docstrings.py:1*'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: I define a function that would (theoretically) make tea, and I place the description
    of the function inside a docstring.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings exist to provide documentation for functions, classes, and modules,
    especially public ones. They conventionally begin and end with three quotation
    marks (`"""`), allowing the string to automatically span multiple lines. You would
    typically place docstrings at the top, inside of whatever they’re defining, such
    as in the function above.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important distinctions between comments and docstrings:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings are string literals, and they are seen by the interpreter; comments
    are ignored.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docstrings are used in automatic documentation generation.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docstrings are generally only docstrings when they appear at the top of the
    module, function, class, or method they define. Comments can live anywhere.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is perfectly possible to use a triple-quoted string literal to write a sort
    of “multiline comment,” but it’s not recommended, since a string literal can easily
    get left in a place where Python will try to use it as a value.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: In short, use docstrings as intended, and stick with comments for everything
    else. Many Python IDEs have hotkeys for toggling comments on a selection, which
    can save you a lot of time.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'I can access these docstrings later in my code. For instance, given the previous
    example, I can do this:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Listing 3-10: *docstrings.py:2*'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings have their own style conventions, which are outlined in depth in
    PEP 257.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Variables
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have already noticed that Python doesn’t have a distinct keyword for
    declaring a new variable (technically called a *name* in this language; see Chapter
    5). Here, I define two variables—`name` and `points`:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Listing 3-11: *variables.py*'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Python is *dynamically typed*, meaning the data type of a value is determined
    when it is evaluated. This contrasts with statically typed languages, in which
    you declare the data type initially. (C++ and Java are both statically typed.)
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: With Python, you can assign a value to a name anytime, by using the assignment
    operator (`=`). It infers the data type. If the name is a new variable, Python
    will create it; if the name already exists, Python will change the value. It’s
    a pretty straightforward system.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, there are only two rules to follow with Python variables:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Define a variable before you access it; otherwise, you’ll get an error.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t change what kind of data you’re storing in the variable, even when replacing
    a value.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python is considered a *strongly typed language*, meaning you usually can’t
    magically combine data of different types. For example, it won’t allow you to
    add an integer and a string together. On the other hand, *weakly typed* languages
    let you do practically anything with different data types, and they try to figure
    out how to do what you asked for. (JavaScript is weakly typed.) There’s an entire
    spectrum between those last two terms and plenty of debate about what behaviors
    qualify under which name. While Python is decidedly in the “strongly typed” camp,
    it still has weaker typing than some languages.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: Python is, however, *weakly bound*, so it is possible to assign a value of a
    different type to an existing variable. While this is technically permissible,
    it is strongly discouraged, as it can produce confusing code.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: What About Constants?
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python doesn’t have any formally defined constants. In keeping with PEP 8, you
    would indicate a variable is intended to be treated as a constant by using all-caps
    names with underscores. This naming convention is sometimes humorously referred
    to as *screaming snake case* for the all-caps (screaming) and the underscores
    (snakes). For example, the name `INTEREST_RATE` indicates that you don’t want
    the variable redefined or changed in any way. While the interpreter itself won’t
    prevent the variable from being modified, your linter will usually complain if
    you do.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: Mathematics
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has all the math functionality you would expect from a good programming
    language; its excellent support for both simple and complicated mathematics is
    one of the reasons Python is popular for scientific programming, data processing,
    and statistical analysis.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Meet the Number Types
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before I get into the operations, you should be aware of the three data types
    used for storing numbers.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '*Integers* (`int`) store whole numbers. In Python, integers are always signed
    and effectively have no maximum value. Integers use decimal base (base-10) by
    default, but they can also be specified in binary (`0b101010`), octal (`0o52`),
    or hexadecimal (`0x2A`).'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '*Floating-point numbers* (`float`) store numbers with a decimal part (for example,
    `3.141592`). You can also use scientific notation (for example, `2.49e4`). Internally,
    values are stored as double-precision, IEEE 754 floating-point numbers, which
    are subject to the limits inherent in that format. (For more insight into the
    limits and gotchas of floating-point arithmetic, read the article “What Every
    Computer Scientist Should Know About Floating-Point Arithmetic” by David Goldberg:
    [https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)*.*)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify an invalid number with `float("nan")`, a number larger
    than the largest possible value with `float("inf")`, or a number smaller than
    the smallest possible value with `float("-inf")`.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I wrapped the special values in quotes. This is necessary if you
    want to use these values without *importing* the `math` module (see Chapter 4
    for more about importing). If you have imported the `math` module (see “The `math`
    Module” subsection below), you can use the constants `nan`, `inf`, and so forth,
    instead of the quoted versions.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '*Complex numbers* (`complex`) can store imaginary numbers by appending `j`
    to the value, as in `42j`. You can combine a real part with the imaginary part,
    using addition: `24+42j`.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: In case you missed it in math class, an imaginary number has the square root
    of negative one as one of its factors, even though this value is utterly impossible;
    there is no value that you can multiply by itself to get negative one! Yet imaginary
    numbers definitely show up in real-world math. Spooky, no?
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '*Decimal* and *Fraction* are two of the additional object types for storing
    numeric data. `Decimal` stores fixed-point decimal numbers, while `Fraction` does
    the same for fractions. To use either, you’ll need to import them first.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief example that uses both types:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 3-12: *fractions_and_decimals.py*'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: The `float()` function turns `Fraction` and `Decimal` objects into floats.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python has the usual operators, with a couple of additions that may not be familiar
    to some developers.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a bit of code that will demonstrate the math operators. I’ll wrap each
    equation inside a `print()` statement, so you can run the code and see the results:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Listing 3-13: *math_operators.py*'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: The *unary* (one-operand) negative operator flips the sign of whatever follows
    it. The `abs()` function is technically considered a unary operator as well. The
    rest of the operators here are *binary*, meaning they accept two operands.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Listing 3-14: *augmented_assignment_operators.py*'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: If you need both floor division (`//`) and modulo (`%`) on the same operands,
    Python provides the `divmod()` function to efficiently perform the calculation,
    returning the two results in a tuple. Thus, `c = divmod(a, b)` is the same as
    `c = (a // b, a % b)`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'Python also has `bitwise` operators, which I’ll list below for those readers
    already familiar with bitwise arithmetic. I won’t introduce these concepts until
    Chapter 12:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Listing 3-15: *bitwise_operators.py*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: The math Module
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python provides plenty of additional functions in the `math` module, along
    with the five most common math constants: `pi`, `tau`, `e`, `inf`, and `nan`.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Listing 3-16: *math_constants.py*'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: All five constants are floats and can be directly used as such ❶. The official
    documentation provides a complete list of everything available in the `math` module.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'You might remember a little trick from high school trigonometry, where you
    could calculate the height of something using your distance to it and the angle
    from your vantage point to the top of the object. Here’s a way to calculate that
    with Python, using the `math` module:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Listing 3-17: *surveying_height.py*'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: 'I use two functions from the `math` module: `math.radians()` ❶ and `math.tan()`
    ❷. The `round()` function ❸ is built into the language itself.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Logic
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python’s clean, obvious syntax for logical expressions is one of the attractive
    elements of the language. Here, I’ll cover conditional statements and expressions,
    as well as the comparison and logic operators.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditionals are compound statements composed of `if`, `elif`, and `else` clauses,
    each made up of a header and a suite. As with most languages, you can have as
    many `elif` conditionals in Python as you want, sandwiched between `if` and (optionally)
    `else`. Here’s a really simple example:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Listing 3-18: *conditional_greet.py*'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: This conditional statement is made up of three clauses. The `if` clause evaluates
    first, and if the expression in its header evaluates to `True`, its suite runs,
    printing `"Hello!"` Otherwise, it evaluates the expression in the `elif` header
    next. If none of the expressions evaluate to `True`, then the `else` clause runs.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice you don’t need to wrap the conditional expressions, such as `command
    == "greet"`, in parentheses, although you may do so anyway if it helps clarify
    your code. You’ll see an example of this shortly.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: If you’re looking for something similar to the `switch` statement from your
    favorite programming language, see the “Structural Pattern Matching” section toward
    the end of this chapter.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Operators
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python has all the comparison operators you’d expect. Take a look at these
    in the context of comparing two integers:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 3-19: *comparison_operators.py*'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Python has operators for `equals`, `not equals`, `less than`,
    `less than or equals`, `greater than`, and `greater than or equals`.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: No surprises there, but what about boolean comparisons? This is where Python
    takes a different line.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: Boolean, None, and Identity Operators
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python offers the values `True` and `False`, which are the two values for boolean
    (type `bool`) variables. It also has a dedicated `None` value (type `NoneType`),
    which serves in the capacity of a “null” value.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: You check for these values in a very different way than with other data types.
    Instead of the comparison operators, use the special *identity operator* `is`.
    (I’ll also use the logical operator `not` below, which I’ll discuss separately
    in a bit.)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Listing 3-20: *boolean_identity_operators.py*'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Aside from being a little high in sodium, that code shows the many ways of testing
    boolean values and checking for `None`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: You can test if a variable is set to `True`, `False`, or `None` by comparing
    with the `is` operator. You can also invert the logic with `is not`.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: Most commonly, when testing against `True`, you can use the variable as the
    entire condition ❶. For `False`, invert that condition test with `not` ❷.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: Take particular note of the last condition, which illustrates an important gotcha
    with the `is` operator ❸. It actually compares the identity of the variables,
    rather than the value. This is particularly troublesome, as the logic looks sound
    but is a bug waiting for a place to happen. That probably doesn’t mean much to
    you yet, but rest assured, I’ll cover this concept in depth in Chapter 5.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, you can take this rule for granted: use `is` *only* for comparing
    directly to `None`, and use regular comparison operators for everything else.
    In practice, we usually say `if spam` or `if not spam`, instead of directly comparing
    to `True` or `False`.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: Truthiness
  id: totrans-648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most expressions and values in Python can be evaluated to a `True` or `False`
    value. This is typically done by using the value as an expression by itself, although
    you can also pass it to the `bool()` function to convert it explicitly.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Listing 3-21: *truthiness.py*'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: When an expression will evaluate to `True`, it is considered “truthy.” When
    it will evaluate to `False`, it is “falsey.” The `None` constant, values representing
    zero, and empty collections are all considered “falsey,” while most other values
    are “truthy.”
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’re coming from a language where logical operators are a little more
    difficult to remember, you’ll find Python refreshing: it simply uses the keywords
    `and`, `or`, and `not`!'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Listing 3-22: *logical_operators.py*'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: With the `and` condition, both expressions must evaluate to `True`. With the
    `or` condition, one or the other (or both) must evaluate to `True`. The third
    condition adds `not` to the picture, requiring that `eggs` be `False` and `spam`
    be `True`.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: I could have omitted the parentheses on the third condition, as `not` takes
    precedence and so is evaluated before `and`. However, the parentheses help to
    clarify my intended logic.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, you can use the `not` keyword to invert any conditional expression,
    such as in the following:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Listing 3-23: *not_operators.py*'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 'Both comparisons do the same thing; the issue becomes readability. In this
    case, the expression using `not` is less readable because your eyes might skip
    over the `not` keyword, so you might not catch what’s happening in the code. The
    condition employing the `!=` operator is preferred for readability. While you
    might find situations where `not` is the best way to invert your conditional logic,
    remember The Zen of Python: ***Readability counts!***'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: The Walrus Operator
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python 3.8 introduced *assignment expressions*, which allow you to assign a
    value to a variable and use that variable in another expression at the same time.
    This is possible with the so-called *walrus operator* (`:=`).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Listing 3-24: *walrus.py*'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: With the walrus operator, Python first evaluates the expression on the left
    (`7+5`) and then assigns it to the variable `eggs`. The assignment expression
    is enclosed in parentheses for readability, although I technically could have
    omitted them.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: The assignment expression is then evaluated to a single value, namely the value
    of `eggs`, which is used in the comparison. Since the value is `12`, the condition
    evaluates to `True`.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: What’s interesting about the assignment expression is that `eggs` is now a valid
    variable in the outer scope, so I can print its value outside of the conditional.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: This feature is potentially useful in many scenarios, not only in conditional
    expressions, as above.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment expressions and the walrus operator were defined in PEP 572, which
    also contains an in-depth discussion about when and where this feature should
    be used. Two particularly useful style rules are put forth by this PEP:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: If either assignment statements or assignment expressions can be used, then
    prefer statements; they are clear declarations of intent.
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If using assignment expressions would lead to ambiguity about execution order,
    then restructure to use statements instead.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of the writing of this book, Python assignment expressions are still in their
    infancy. A lot of debate and controversy still surrounds them. In any case, resist
    the temptation to abuse the walrus operator to cram as much logic onto one line
    as possible. You should always aim for readability and clarity in your code, above
    all else.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: Ellipsis
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One seldom-used piece of syntax is the *Ellipsis*:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is sometimes used by various libraries and modules, but seldom consistently.
    For example, it’s used with multidimensional arrays in the NumPy third-party library
    and when working with type hints from the built-in `typing` module. When you see
    it come up, consult the documentation for whatever module you’re using.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few things to know about strings as you move forward. Here, I’ll
    cover the three kinds of strings: string literals, raw strings, and formatted
    strings.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: String Literals
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are multiple ways of defining a *string literal*:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Listing 3-25: *string_literals.py*'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: You can wrap a literal in double quotes (`"`), single quotes (`'`), or triple
    quotes (`"""`) of either type. You may remember from earlier that there’s something
    special about triple quotes, but I’ll come back to that in a moment.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 8 addresses the use of single and double quotes:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: In Python, single-quoted strings and double-quoted strings are the same. This
    PEP does not make a recommendation for this. Pick a rule and stick to it. When
    a string contains single or double quote characters, however, use the other one
    to avoid backslashes in the string. It improves readability.
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The advice about placing quotes inside a string comes in handy when dealing
    with something like this:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Listing 3-26: *escaping_quotes.py:1a*'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: This version escapes the double quotes I want to include in the string literal
    itself. The backslash (`\`) before the quotes means I want the string to contain
    that *literal character*, not to have Python treat the double quote as the boundary
    of a string. The string literal must always be wrapped in matching quotes.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to avoid backslashes in this scenario, however:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Listing 3-27: *escaping_quotes.py:1b*'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: This second version wraps the literal in single quotes, so the double quotes
    will be automatically interpreted as part of the string literal. That approach
    is much more readable. By wrapping the string in single quotes, Python will assume
    the double quotes are characters in the string.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: 'The only time you’d really need to escape either single or double quotes with
    backslashes would be if you had both types of quotes in the string at once:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Listing 3-28: *escaping_quotes.py:2a*'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Personally, in cases like that, I’d prefer to use (and escape) the double quotes,
    because they don’t evade my attention like an apostrophe would tend to do.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have the option to use triple quotes:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Listing 3-29: *escaping_quotes.py:2b*'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that triple quotes define *multiline string literals*. In other words,
    I can use them to do this:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Listing 3-30: *multiline_string.py*'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: Everything, including newlines and leading whitespace, is literal in triple
    quotes. If I `print("parrot")`, it will display exactly like this in the terminal.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: The only exception occurs when you use a backslash (`\`) to escape a particular
    character, like I did with that newline at the beginning ❶. It is conventional
    to escape the first newline after the opening triple quotes, just to make the
    code look cleaner.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `textwrap` module has some functions for working with multiline
    strings, including tools that allow you remove leading indentation (`textwrap.dedent`).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can *concatenate* (combine) string literals, simply by writing
    them next to one another, without any operators between them. For example, `spam
    = "Hello " "world" "!"` is valid, resulting in the string `Hello world!.` If you
    wrap the assignment expression in parentheses, you can even span multiple lines.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: Raw Strings
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Raw strings* constitute another form of string literal, wherein the backslash
    (`\`) is always treated as a literal character. They’re preceded with an `r`,
    such as in this example:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Listing 3-31: *raw_string.py*'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: 'The backslash is treated like a literal character, which means that nothing
    can be escaped inside of a raw string. The output of that line of code looks like
    this:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This has implications for what type of quotes you use, so beware.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare these two lines and their outputs:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Listing 3-32: *raw_or_not.py*'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'The first string is ordinary, so `\n` is treated as a normal escape sequence:
    specifically, the newline character. That line break appears in the output, like
    this:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The second string is a raw string, so the backslash (`\`) is treated as a literal
    character in its own right. The output would be as follows:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This is particularly useful for regular expression patterns, where you’re likely
    to have plenty of backslashes that you want as part of the *pattern*, not interpreted
    by Python before it gets there. ***Always use raw strings for regular expression
    patterns.***
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: Formatted Strings
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A third kind of string literal is a *formatted string* or *f-string*, which
    is new as of Python 3.6 (defined in PEP 498). It allows you to insert the values
    of variables into a string in a very elegant manner.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: 'If I wanted to include the value of a variable in a string without an f-string,
    the code might look like this:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Listing 3-33: *cheese_shop.py:1a*'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: The `str()` function converts the value passed to it into a string, and then
    the three strings are *concatenated*, or combined, into one, using the `+` operator.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: Using f-strings, this code becomes more elegant.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Listing 3-34: *cheese_shop.py:1b*'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: You precede the string literal with an `f`. Inside, you can substitute a variable
    by wrapping it in curly braces (`{ }`). The `f` tells Python to interpret and
    evaluate as an expression anything in the string that’s wrapped in curly braces.
    This means you’re not limited to variables in those curly braces. You can put
    just about any valid Python code in there, including math, function calls, conditional
    expressions, or whatever you need.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: As of Python 3.8, you can even display both the expression *and* its result
    by appending a trailing equal sign (`=`).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Listing 3-35: *expression_fstring.py*'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of gotchas when using f-strings:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if you want to wrap an expression in literal curly braces, you must
    use two curly braces (`{{ }}`) for every one you want displayed:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Listing 3-36: *literal_curly_braces.py*'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an odd number of braces, one pair will be ignored. So, if I used
    five pairs, the result would be the same as if I only had four: two literal pairs
    would be printed.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you cannot use backslashes within an expression in an f-string. This
    makes it difficult to escape quotes inside expressions. For example, this would
    not work:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: To get around this, I’d need to use triple quotes on the outside of the string,
    to ensure I can employ both single and double quotes inside of the expression.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Backslashes have other roles. The documentation points out the following problematic
    situation:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: There’s no direct way around this limitation. Instead, you’d have to evaluate
    that expression in advance, assign the result to a name, and use it in the f-string.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Third, and perhaps least surprising, you cannot put comments inside of f-string
    expressions; the hash (`#`) symbol isn’t allowed, except as a string literal.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Lastly, you can never use f-strings as docstrings.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: These small wrinkles aside, f-strings are incredibly straightforward to work
    with.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: Format Specifications
  id: totrans-755
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides arbitrary expressions, f-strings support *format specifications*, which
    allow you to control how values are displayed. This is a fairly in-depth topic
    that could easily become a main section on its own, so I will entrust you to the
    guidance of the documentation for the bulk of it. I’ll breeze over the essentials
    herein.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after the expression, you may choose to include one of three special
    flags: `!r`, `!a`, or `!s` (although that last one is the default behavior, so
    it can be omitted in most cases). These determine which function is used to fetch
    the string representation of some value: `repr()`, `ascii()`, or `str()`, respectively
    (see “String Conversion” below).'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the format specification itself, which always begins with a colon
    (`:`), followed by one or more flags. These have to be specified in a particular
    order to work, although any of them may be omitted if they’re not desired:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: Align An alignment flag, specifying left (`<`), right (`>`), center (`^`), or
    (if numeric) split with the sign aligned left but the digits aligned right (`=`).
    This is optionally preceded by a character that will be used to fill any blank
    space in the alignment.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: Sign A flag controlling when the sign is displayed on a number. The plus (`+`)
    flag displays the sign on both positive and negative numbers, while the minus
    (`–`) flag only displays it on negative numbers. A third option is to show a leading
    space on positive numbers and a sign on negative numbers (space).
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: Alternative form The hash (`#`) flag turns on the “alternative form,” which
    has different meanings for different types (see documentation).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: Leading zeros The zero (`0`) flag causes leading zeros to be displayed (unless
    a fill character is specified for alignment).
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: Width The width of the output string in characters. This is where the alignment
    comes into play.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: Grouping A flag controlling whether numbers should separate thousands with a
    comma (`,`) or an underscore (`_`). If omitted, no separator is used. If enabled,
    the underscore separator also appears every four digits in octal, hexadecimal,
    and binary numbers.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: Precision A dot (`.`), followed by an integer for decimal precision.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: Type A flag controlling how numbers are displayed; common options include binary
    (`b`), character (`c`), decimal (`d`), hexadecimal (`x`), exponent notation (`e`),
    fixed-point (`f`), and general (`g`). There are more (see documentation).
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is a bit abstract, so here are a few quick examples:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Listing 3-37: *formatting_strings.py*'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete details about the format specification can be found in the official
    Python documentation: [https://docs.python.org/3/library/string.html#format-string-syntax](https://docs.python.org/3/library/string.html#format-string-syntax).'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: Another useful reference is [https://pyformat.info](https://pyformat.info),
    although as of this writing, it only shows the format specification in the context
    of the old `format()` function. You will need to apply it to f-strings yourself.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: Previous String-Formatting Methods
  id: totrans-772
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re reading older Python code, you may encounter the two previous forms
    of string formatting: `%` notation and the newer `format()`. These have both been
    superseded by f-strings, which have superior performance. That’s because they’re
    parsed and converted to bytecode *before* the code is run.'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself needing to rewrite a `format()` call as an f-string, the
    process is thankfully quite simple.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example. I’ll start out with a couple of variables:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Listing 3-38: *format_to_fstring.py:1*'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the advent of f-strings, if I wanted to print out a message containing
    the values of those two variables, I’d have used `format()`:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Listing 3-39: *format_to_fstring.py:2a*'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: In the old format, a string literal ❶ would contain sets of curly braces, optionally
    containing the format specifications. The `format()` function would be called
    on that string literal (or on a name referencing it). Then, the expressions to
    be evaluated would be passed to the `format()` function in order ❷.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: 'That would have the following output:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Converting this to an f-string is as simple as moving the expressions into
    the string literal in order and then prepending an `f` to the literal to make
    it an f-string:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Listing 3-40: *format_to_fstring.py:2b*'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: The output is the same as before.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, with `format()`, you could refer to the index of the expression
    in the argument list:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Listing 3-41: *format_to_fstring.py:3a*'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: 'That produces this output:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'To convert this code to an f-string, you substitute the expressions in place
    of the indices in the string literal, which you (again) turn into an f-string
    by prepending an `f`:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Listing 3-42: *format_to_fstring.py:3b*'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: Converting from `%` notation is a little less trivial, but most Python 3 code
    uses `format()` anyway. If you find yourself needing to do this, [https://pyformat.info](https://pyformat.info)
    does an excellent job of comparing `%` notation and `format()`.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: Template Strings
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Template strings* constitute one more alternative to f-strings that is worth
    knowing about, especially as it still fulfills some use cases, including internationalizing
    user interfaces. Personally, I find template strings a bit more reusable. On the
    other hand, the drawback is that they’re considerably more limited in terms of
    formatting.'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: If you know how they work, you’ll be equipped to decide for yourself which tool
    is best for your particular situation.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a template string for greeting a user:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Listing 3-43: *template_string.py:1*'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: To use template strings, I first have to import `Template` from the `string`
    module.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: 'Then I can create a new `Template` and pass it a string literal:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Listing 3-44: *template_string.py:2*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: I can name my fields whatever I want, preceding each with a dollar sign (`$`).
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I call the `substitute()` function on the template I created (`s`)
    and pass expressions to each of the fields:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Listing 3-45: *template_string.py:3*'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished string is returned, and in this case, it is passed to `print()`
    and displayed:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'There are a couple of odd syntax rules with template strings. First, to show
    a literal dollar sign in the string literal, use two dollar signs (`$$`). Second,
    to substitute an expression as part of a word, wrap the name of the field in curly
    braces (`{ }`). Both of these rules are demonstrated below:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Listing 3-46: *template_string.py:4*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: There’s a handful of additional abilities contained within string templates,
    but I’ll entrust you to the official Python documentation for the rest of that.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: String Conversion
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I previously mentioned that there are three ways to get the string representation
    of a value: `str()`, `repr()`, and `ascii()`.'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: The first function, `str()`, is the one you’ll use most often, as it returns
    the *human-readable* representation of the value.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, `repr()` returns the *canonical string representation* of the
    value: that is, (usually) the value as Python sees it. In the case of many basic
    data types, this will return the same thing as `str()`, but when used on most
    objects, the output contains additional information useful in debugging.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: The `ascii()` function is the same as `repr()`, except that the string literal
    it returns is completely ASCII-compatible, having escaped any non-ASCII (for example,
    Unicode) characters.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: I’ll return to this concept in Chapter 7, when I start defining my own objects.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: A Note on String Concatenation
  id: totrans-825
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point, I’ve been using the addition (`+`) operator for concatenating
    strings together. This is acceptable in basic situations.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: However, this is seldom the most efficient solution, especially when combining
    multiple strings. Therefore, it is recommended to prefer the `join()` method,
    which is called on a string or string literal instead.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a comparison between the two. I start with a couple of string variables:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Listing 3-47: *concat_strings.py:1*'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, you’ve seen concatenation with the addition (`+`) operator, like this:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Listing 3-48: *concat_strings.py:2a*'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, I can use the `join()` method:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Listing 3-49: *concat_strings.py:2b*'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: I call the `join()` method on the string that will appear between each piece.
    In this case, I use an empty string. The `join()` method accepts a *tuple* of
    strings—an array-like structure wrapped in parentheses, and therefore, the double
    set of parentheses in the code. I’ll introduce tuples in an upcoming section.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: Typical concatenation with `+` or the `join()` function has the same result,
    but the latter function will be *as fast or faster*, especially when you’re using
    other implementations of Python besides CPython. Therefore, whenever you need
    to concatenate and f-strings aren’t right for the job, you should consider using
    `join()` instead of the `+` or `+=` operators. In practice, f-strings are the
    fastest, but `join()` is your next-best option.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-839
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python functions are *first-class citizens*, which means they can be treated
    like any other object. Even so, you call them as you would in any other programming
    language.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of a very basic function, which prints a selected type of
    joke to the terminal.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: 'I start with the function header:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Listing 3-50: *joke_function.py:1*'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: I declared the function with the `def` keyword, followed by the name of the
    function. Parameters are named in the parentheses after the function name. The
    entire header is concluded with a colon (`:`).
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the header, indented one level, is the *suite* (or body) of the function:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Listing 3-51: *joke_function.py:2*'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: 'You call functions in much the same way as in most languages:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Listing 3-52: *joke_function.py:3*'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: I’ll go into depth on functions and their many cousins in Chapter 6.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: Classes and Objects
  id: totrans-853
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python fully supports object-oriented programming. In fact, one of the language’s
    design principles is that “everything is an object,” at least behind the scenes.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot more to classes than meets the eye, but for now, you should just
    get an absolutely bare-bones familiarity with the syntax.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class contains a joke of a selected type and displays it on demand:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Listing 3-53: *joke_class.py:1*'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: I define the class using the `class` keyword, the name of the class, and a colon
    (`:`) at the end of the header.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: 'This is followed by the suite of the class, indented one level:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Listing 3-54: *joke_class.py:2*'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: The initializer, which is similar in purpose to the constructor in other OOP
    languages, is a member function, or *method*, with the name `__init__()` and at
    least one parameter, `self`.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Listing 3-55: *joke_class.py:3*'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions that belong to the class are called methods and are part of the class
    suite. Methods must accept at least one parameter: `self`.'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: 'You would use this class like so:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Listing 3-56: *joke_class.py:4*'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: You create a new instance of the `Joke` class by passing the string `"lethal"`
    to its *initializer*, the `__init__()` from earlier. The new object is stored
    in the variable `lethal_joke`.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: Then, you use the *dot operator* (`.`) to call the function `tell()` within
    the object. Take note that you didn’t have to pass any argument for `self`. That’s
    done automatically when you call the function in this manner.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: I’ll discuss classes and objects in detail in Chapter 7 and further in Chapter
    13.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling
  id: totrans-873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python offers error and exception handling functionality through the `try` compound
    statement.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: For example, if I wanted to get a number from the user, I couldn’t reliably
    predict what they would type in. Trying to convert a string, like `"spam"`, to
    an integer would cause an error. I can use error handling to take a different
    action if it isn’t possible to convert the user `input`.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Listing 3-57: *try_except.py*'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: I get a string from the user, and then in the `try` clause, I attempt to convert
    it to an integer with the `int()` function. That would raise a `ValueError` exception
    if the string it’s trying to convert is not a valid whole number (base 10).
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: If that exception is raised, I catch it in the `except` clause and handle the
    failure.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the last line would always be run.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: There are additional features and subtleties to the `try` statement, including
    `finally` and `else` clauses, which I’ll cover in Chapter 8. For now, it’s better
    to avoid these concepts rather than use them incorrectly.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and Lists
  id: totrans-882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two of Python’s most common built-in data structures, called *collections*,
    are tuples and lists.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '*Lists* constitute the most array-like collection in Python. In CPython, they
    are implemented as variable-length arrays, not as linked lists like the name might
    suggest.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a list of strings with names of cheeses:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Listing 3-58: *cheese_list.py:1*'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: You enclose a list literal in square brackets, separating each item in the list
    with commas.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access or reassign the values of individual items with the same bracket
    notation used by most programming languages:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Listing 3-59: *cheese_list.py:2*'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: A *tuple* is somewhat similar to a list, but with a few key differences. First,
    a tuple cannot have items added, reassigned, or removed after its creation. Attempting
    to modify the contents of a tuple with bracket notation will result in a `TypeError`.
    This is because tuples, unlike lists, are *immutable*, effectively meaning their
    contents cannot be modified (see Chapter 5 for the full explanation).
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a tuple:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Listing 3-60: *knight_tuple.py:1*'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: 'You enclose tuple literals in parentheses (`( )`), instead of brackets (`[
    ]`). Nevertheless, you still use bracket notation to access individual items:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Listing 3-61: *knight_tuple.py:2*'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said, you cannot change the items of a tuple after creation, such as if
    you tried to reassign the first item:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Listing 3-62: *knight_tuple.py:3*'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: The guideline is to use tuples for collections of items of different types (*heterogeneous*
    collections) and to use lists for collections of items of the same type (*homogeneous*
    collections).
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: I’ll discuss these collections, and many more, in Chapter 9.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  id: totrans-904
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has two basic loop types: *while* and *for*.'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: while Loop
  id: totrans-906
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` loop probably looks familiar from other languages:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Listing 3-63: *while_loop.py*'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: I start the loop with the `while` keyword, follow it with the condition to test,
    and finish the header with a colon (`:`). As long as that condition evaluates
    to `True`, the code in the suite of the loop is executed.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: When you need to keep running a loop until some condition is met, use `while`
    loops. These are particularly useful when you don’t know how many iterations of
    the loop will take place before the condition is met.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: Loop Control
  id: totrans-912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can manually control the loop, using two keywords. The `continue` keyword
    abandons the current iteration and jumps to the next one. The `break` keyword
    exits the loop altogether.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: 'One common scenario where you may use these keywords is in an infinite loop
    used for running a game or a user interface. For example, here’s a very simple
    command prompt:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Listing 3-64: *loop_control.py*'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: The loop `while True` is inherently infinite; `True` is always `True`. That’s
    the behavior I actually want here, since I want to keep iterating until the user
    enters the string `"exit"`, at which point, I manually end the loop with `break`.
    (By the way, if you’ve been waiting for a `do-while` loop, this is effectively
    the way to recreate that behavior.)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: The command `"sing"` has a different behavior, after which I’d want to immediately
    go to the top and prompt the user for another command, skipping the last print
    statement. The `continue` keyword does exactly that, immediately abandoning the
    current iteration and jumping back to the top of the loop.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: for Loop
  id: totrans-919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s `for` loop is a little different from loops in many languages. It’s
    generally used for iterating over a range, list, or other collection.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Listing 3-65: *for_loop.py*'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: I start the loop header with the `for` keyword. Technically, this kind of loop
    is a `for`-`in` (or “`for`-`each`”) loop, meaning the loop iterates once for each
    item in the given range, list, or other collection. This means the loop needs
    something to iterate over—in this case, a special object called `range()`—which
    iterates over a range of values, returning each one in turn. I’ve specified that
    I want the range to start with the value `1` and end before `11`. The local variable
    `i` will refer to the current item for each iteration. Finally, the `in` keyword
    precedes the thing I’m iterating over—that is, before `range()` in this example.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: As long as there are items to iterate over, the code belonging to the loop will
    be executed—in this case, printing out the value of the current item. The loop
    stops when the last item is iterated over.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: Running this code would print the numbers 1 through 10.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: This only scratches the surface of loops. See Chapter 9 for more.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: Structural Pattern Matching
  id: totrans-927
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many years, developers coming to Python from languages like C, C++, Java,
    or Javascript would ask if there was a Python equivalent to the `switch`/`case`
    statement (or `match`/`case` in Scala, `case`/`when` in Ruby, and so on). They’d
    always be disappointed to hear a resounding “No!” Python only had conditional
    statements.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: At long last, Python 3.10 gained *structural pattern matching* via PEP 634\.
    This provides conditional logic that is at least syntactically similar to `switch`
    statements of other languages. In short, you test a single *subject*, such as
    a variable, against one or more *patterns*. If the subject matches the pattern,
    the associated suite of code runs.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: Literal Patterns and Wildcards
  id: totrans-930
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the most basic use case, you can check a variable against different possible
    values. These are called *literal patterns*. For example, perhaps I want to display
    different messages, depending on a user’s `input` `lunch` `order`:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Listing 3-66: *pattern_match.py:1a*'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: The value of `lunch_order` is compared to each case until it matches one. Once
    a match is found, the case’s suite is run, and the match statement is finished;
    the value won’t be checked against additional patterns once it matches one. So,
    if the user inputs `"pizza"`, the `"Pizza` `time!"` message is displayed. Similarly,
    if they input `"taco"`, the message `"Taco,` `taco,` `TACO,` `tacotacotaco!"`
    is displayed instead.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: The underscore (`_`) in the last case is the *wildcard*, which will match any
    value. This serves as a fallback case, and it must come last, as it will match
    anything.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: Or Patterns
  id: totrans-936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A single case can cover multiple possible values. One way to do this is with
    an *or pattern*, where possible literal values are separated by the bar character:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Listing 3-67: *pattern_match.py:1b*'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: This pattern will match if the user enters either `"salad"` or `"soup"` at the
    prompt.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: Capture Patterns
  id: totrans-941
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One particularly helpful feature of structural pattern matching is the ability
    to capture part or all of the subject. For example, it isn’t very helpful in our
    example that the fallback case only says `"Yummy."`. Instead, I’d like to have
    a default message announcing the user’s selection. To do that, I write a *capture
    pattern* like this:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Listing 3-68: *pattern_match.py:1c*'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: This pattern acts like a wildcard, except the value of `lunch_order` is captured
    as `order`. Now, no matter what the user enters, if it doesn’t match any of the
    previous patterns, the value will be captured and displayed in the message here.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: 'Capture patterns don’t just have to capture the entire value. For example,
    I can write a pattern that matches a tuple or list (a *sequence*) and then captures
    only part of that sequence:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Listing 3-69: *pattern_match.py:1d*'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: In this version, if the lunch order has a space, I split the string into two
    parts, which are stored in a list. Then, if the second item in the sequence has
    the value `"ice cream"`, the first part is captured as `flavor`. Thus, the code
    can account for Bojan if he decides to break down and have strawberry ice cream
    for lunch. (And I’m not stopping him!)
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: 'The capture pattern feature has one surprising downside: all *unqualified*
    names in patterns—that is, any bare variable names with no dots—will be used to
    capture. This means that if you want to use the value assigned to some variable,
    it must be *qualified*, meaning you must access it within some class or module
    with the dot operator:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Listing 3-70: *pattern_match.py:1e*'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: Guard Statements
  id: totrans-953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One last trick I’ll demonstrate with pattern matching is the *guard statement*,
    an additional conditional statement that must be satisfied for a pattern to match.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the current version of my lunch order example, using the logic
    to split the order by spaces means the code doesn’t behave very nicely with other
    foods with spaces in them. Also, if I enter `"rocky road ice cream"`, it won’t
    match the current ice cream pattern.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: Instead of splitting my string by spaces, I can write a pattern with a guard
    statement that looks for the words *ice cream* in the lunch order.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Listing 3-71: *pattern_match_object.py:1f*'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: The pattern here captures the value as `ice_cream`, but only if the guard statement
    `if 'ice cream' in ice_cream` is satisfied. In that case, I use `.replace()` to
    remove the words *ice cream* from the captured value, leaving me with only the
    name of the flavor. I also use `.strip()` to remove any leading or trailing whitespace
    from the new string. Finally, I print out my message.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: More About Structural Pattern Matching
  id: totrans-960
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are quite a few other tricks and techniques that work with structural
    pattern matching. They work with objects (see Chapter 7), with dictionaries via
    mapping patterns (see Chapter 9), and even by support nesting patterns within
    other patterns.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: As with many Python techniques, pattern matching feels like “magic,” and there’s
    a strong temptation to use it everywhere possible. Resist this urge! Structural
    pattern matching is very useful for checking a single subject against multiple
    possible patterns, but as you can even see from the “ice cream” situation in the
    lunch order example, it quickly reaches its limits as the possible values of the
    subject get more elaborate. As a rule, if you’re unsure whether you need structural
    pattern matching in a particular situation, stick with conditional statements.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn even more, read PEP 636, which serves as the official tutorial for
    this topic and demonstrates all of the functionality available with this language
    feature: [https://peps.python.org/pep-0636/](https://peps.python.org/pep-0636/).'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-964
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should now have a feeling for Python’s syntax and a basic familiarity with
    its key structures. If you were to stop here, you could probably write Python
    code that at least works. In fact, many developers new to the language do indeed
    work with about this much information, implicitly bringing the habits and practices
    of whatever language they know best.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: There is a profound difference between valid code and idiomatic, Pythonic code.
    Writing the latter is the focus of this book.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-967
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Project Structure and Imports
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-969
  prefs: []
  type: TYPE_IMG
- en: I’ve found that structuring a Python project is one of the most often overlooked
    components of teaching the language. Many developers therefore get their project
    structure wrong, stumbling through a jumble of common mistakes until they arrive
    at something that at least works.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the good news: you don’t have to be one of them!'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll introduce import statements, modules, and packages, and
    I’ll show you how to fit everything together without tearing your hair out.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware, I’m skipping over one critical piece of project structure in this
    chapter: *setup.cfg*, as it relies on concepts we haven’t yet covered. Without
    a *setup.cfg* or *setup.py* file, your project will not be ready to ship to end
    users. In this chapter, you’ll put everything in the right place for development.
    From there, preparing your project for distribution will be a fairly simple process.
    I’ll cover *setup.cfg*, *setup.py*, and other project structure issues relating
    to distribution in Chapter 18.'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Repository
  id: totrans-974
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before delving into the actual project structure, I want to address how it will
    fit into your *version control system (VCS)*, which I recommend using. For the
    rest of this book, I’ll assume you’re using Git, as that’s the most common option.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve created your repository and cloned a local copy to your computer,
    you can begin to set up your project. At minimum, create the following files:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: '*README*, which is a description of your project and its goals'
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*LICENSE*, which is your project’s license'
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.gitignore*, which is a special file that tells Git what files and directories
    to ignore'
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A directory, which has the name of your project
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your Python code belongs in a separate subdirectory and not in the root of the
    repository. This is very important, as your repository’s root directory will get
    mighty cluttered with build files, packaging scripts, documentation, virtual environments,
    and all manner of other things that aren’t actually part of the source code.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, in this chapter, I’ll use one of my own Python projects: *omission*.'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: A Python project is composed of modules and packages. In the next section, I’ll
    cover what those are and how to create them.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: Modules and Packages
  id: totrans-984
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *module* is any Python (*.py*) file. (Anticlimactic, isn’t it?)
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: A *package*, occasionally called a *regular package*, is one or more modules
    within a directory. That directory must include a file called *__init__.py* (which
    can be empty). The *__init__.py* file is important! If it isn’t there, Python
    will not know the directory constitutes a package.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: You can leave the *__init__.py* file empty (it often is), or you can use it
    to run certain code when the package is first imported. For example, you might
    use `__init__.py` to select and rename certain functions, so the end user of the
    package doesn’t need to understand how the modules are laid out. (See the subsection
    “Controlling Package Imports” later in the chapter.)
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: If you do forget *__init__.py* in your package, it becomes an *implicit namespace
    package*, also just known as a *namespace package*. These behave differently from
    regular packages. ***The two are not interchangeable!*** A namespace package allows
    you to distribute a package in multiple pieces, called *portions*. There are some
    cool advanced things you can do with namespace packages, but you will seldom need
    them. As this is a doozy of a rabbit hole, if you need namespace packages, see
    the documentation at [https://packaging.python.org/guides/packaging-namespace-packages/](https://packaging.python.org/guides/packaging-namespace-packages/).
    You can also read PEP 420, which officially defined the concept.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: In my project structure, *omission* is a package that contains other packages.
    Thus, *omission* is my *top-level package*, and all the packages underneath it
    are its *subpackages*. This convention will be important once you start importing
    stuff.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: PEP 8 and Naming
  id: totrans-990
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your packages and modules need clear names to identify them. Consulting with
    PEP 8 about the naming conventions reveals this:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: Modules should have short, all-lowercase names. Underscores can be used in the
    module name if it improves readability. Python packages should also have short,
    all-lowercase names, although the use of underscores is discouraged.
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Understand that modules are named by filenames and packages are named by their
    directory name. Thus, these conventions define how you name your directories and
    code files.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, filenames should be all lowercase, with underscores (`_`) if that
    improves readability. Similarly, directory names should be all lowercase, without
    underscores if at all possible. To put that another way . . .
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: 'Do this: *omission/data/data_loader.py*'
  id: totrans-995
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'NOT this: *omission/Data/DataLoader.py*'
  id: totrans-996
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project Directory Structure
  id: totrans-997
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With that covered, take a look at my project’s repository directory structure:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Listing 4-1: Directory structure of *omission-git/*'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see that I have one top-level package called *omission*, with four subpackages:
    *common/*, *data/*, *game/*, and *tests/*. Each subpackage contains an *__init__.py*
    file, which is what designates them as packages. Every file that ends in *.py*
    is a module.'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: I also have the directory *resources/*, but that only contains game audio, images,
    and other sundry files (omitted here for brevity). The *resources/* directory
    is *not* a regular package, as it doesn’t contain an *__init__.py*.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: 'I have another special file in my top-level package: *__main__.py*. This is
    the file that runs when I execute my top-level package directly, via this command:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: I’ll come back to *__main__.py* in a bit (see the subsection “Package Entry
    Points” later in the chapter), as well as explain that lonely little *omission.py*
    file outside the top-level package.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: How import Works
  id: totrans-1006
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’ve written any meaningful Python code before, you’re almost certainly
    familiar with the `import` statement for importing modules. For example, to use
    it to import the module for regex, you’d enter this:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Once you’ve imported a module, you can access any variables, functions, or classes
    defined within it.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: When you import the module, you are actually running it, which in turn executes
    any other `import` statements in the module. If there are any errors or performance
    costs in those secondarily (and onward) imported modules, they might seem to originate
    from your otherwise innocent import statement. It also means that Python has to
    be able to find all those modules.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the module *re.py*, which is part of the Python standard library,
    has several import statements of its own, which are executed when you `import
    re`. The contents of those imported modules aren’t automatically available to
    the file you imported `re` from, but those module files have to exist for `import
    re` to succeed. If, for some unlikely reason, *enum.py* (another module that is
    part of the Python standard library) got deleted from your Python environment
    and you ran `import re`, it would fail with an error:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: This might seem like a confusing error message. I’ve seen people erroneously
    wonder why the outer module (in this example, `re`) couldn’t be found. Others
    have wondered why the inner module (`enum` here) is being imported at all, since
    they didn’t ask for it directly in their code.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the `re` module was imported, and that in turn imported
    the `enum` module. However, because the `enum` module is missing, importing `re`
    fails with a `ModuleNotFoundError`.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: 'Take note that this scenario is fictional: `import enum` and `import re` will
    never fail under normal circumstances, because both modules are part of Python’s
    standard library. However, this little example demonstrates the common problem
    of `import` statements failing due to missing modules.'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: Import Dos and Don’ts
  id: totrans-1016
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various ways of importing, but most of them should rarely, if ever,
    be used.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: 'For the upcoming examples, I’ll be using a module called *smart_door.py*, which
    reads as follows:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Listing 4-2: *smart_door.py*'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say I want to use this module in another Python file, which (in this
    example) is in the same directory. To run the functions defined in that module,
    I’d have to first import the module `smart_door`. The easiest way to do this is
    as follows:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Listing 4-3: *use_smart_door.py:1a*'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: The *namespace* of `open()` and `close()` is `smart_door`. A *namespace* is
    an explicitly defined path to something, such as a function. The function `open()`
    has the namespace `smart_door`, which tells me that `open()` belongs to that particular
    module. Remember this from The Zen of Python?
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea—let’s do more of those!
  id: totrans-1025
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python developers really like namespaces because they make it obvious where
    functions and whatnot are coming from. That comes in handy when you have multiple
    functions that have similar names or the same name, but that are defined in different
    modules. Without that bit of namespace, `smart_door`, you would not know that
    `open()` had anything to do with opening the smart door. Appropriately using namespaces
    can help you avoid massive errors in your code. However, as important as namespaces
    are, they can get out of hand very quickly if used improperly.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: Be advised, in referring to *namespaces*, I’m not necessarily talking about
    *implicit namespace packages*, which I don’t cover in this book.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a look at some good and bad examples of namespaces in action.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: Importing Functions from Modules
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In my previous `smart_door` function calls, I referenced the namespace on every
    function call. This is usually best when a function is called only a handful of
    times, but if you use a function often, it gets tedious to use a namespace for
    every single function call.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, Python provides a way around that. To be able to use the `open()`
    function without constantly having to precede it with its module name (`smart_door`),
    I need only know the *qualified name*—that is, the name of the function, class,
    or variable, preceded by its complete namespace within one of its modules or packages
    (if any). Within the *smart_door.py* module, the qualified name of the function
    I want is just `open`. Thus, I import that function like this, instead:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Listing 4-4: *use_smart_door.py:1b*'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: 'This introduces a new problem. Neither `close()` nor `smart_door.close()` will
    work in this example, because I didn’t import the function outright. The entire
    `smart_door` module was still run by the import command, but only the `open()`
    function was actually imported. To use `smart_door.close()`, I’d need to change
    the code to this:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Listing 4-5: *use_smart_door.py:1c*'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: This gives me access to both functions, no namespace required.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: The Problem of Shadowing
  id: totrans-1038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might have noticed another problem: `open()` is already a built-in Python
    function! Assume I also need to read a file called *data.txt*, which exists in
    my current directory. If I try this after importing `open()` from the `smart_door`
    function ([Listing 4-5](#listing4-5)), my program is going to behave very badly:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Listing 4-6: *use_smart_door.py:2*'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: When I used `open()` earlier ([Listing 4-5](#listing4-5)), I wanted to use `smart_door.open()`.
    Now, in the same file, I’m trying to call Python’s built-in `open()` function
    to open a text file for reading. Unfortunately, because of the earlier import,
    the built-in `open()` function has been *shadowed* by `smart_door.open()`, meaning
    the presence of the latter is making it impossible for Python to even find the
    former. This code will fail!
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: I got that error because I’m trying to use the built-in `open()` function, which
    accepts two arguments, but I unintentionally called `smart_door.open()`, which
    doesn’t accept any arguments.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: Getting an actual error message is one of the better failure scenarios for this
    sort of mistake. Imagine if `smart_door.open()` did accept similar arguments to
    the built-in `open()`. Depending on my code, I might wind up with an error elsewhere
    (perhaps from trying to use a file I hadn’t opened), or worse, some form of incorrect
    but technically valid behavior. This sort of mistake is infamously difficult to
    debug, so it is wise to avoid.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: 'So how should I fix this? If I were the one who wrote *smart_door.py*, I should
    just go and change the function name. It’s universally considered bad practice
    to use function names that shadow built-in Python functions anyhow, unless the
    entire point *is* to shadow. However, assume that I’m not the author of that module
    and I need another solution. Thankfully, Python offers one in the `as` keyword,
    which allows me to create an alias for that function:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Listing 4-7: *use_smart_door.py:1d*'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: In the import, I use the `as` keyword to rename `smart_door.open()` to `door_open()`,
    but only in the context of this file. Then, I can refer to `door_open()` where
    I wanted `smart_door.open()`.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: This leaves Python’s built-in `open()` function unshadowed, so the earlier code
    for working with the file ([Listing 4-6](#listing4-6)) can function properly.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The Trouble with Nested Packages
  id: totrans-1052
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you’ve seen, packages can contain other packages. In my *omission* project,
    if I wanted to import the module *data_loader.py*, I could use this line (refer
    back to the *omission* project structure):'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The Python interpreter looks for the *omission* package, the *data* package
    inside that, and the *data_loader* module inside that. The *data_loader* module
    (and only that module) is imported. This is a good structure, and all’s well.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: 'At a certain point, however, nesting packages can become a pain. A function
    call like `musicapp.player.data.library.song.play()` is just ugly, not to mention,
    difficult to read. As The Zen of Python muses:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: Flat is better than nested.
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some nesting of packages is certainly okay, but when your project starts looking
    like an elaborate set of Matryoshka dolls, you’ve done something wrong. Organize
    your modules into packages, but keep the structure reasonably simple. Nesting
    two or three packages deep is okay; deeper is generally not advisable, if it can
    be avoided.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we’d never have overly nested nightmares in an ideal world, real-life
    projects aren’t always that neat. Sometimes, it isn’t possible to avoid deep nesting
    structures. I need another way to keep my import statements sane. Graciously,
    the import system can handle this:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: I only have to deal with the deeply nested namespace once, in the actual import
    statement. After that, I just use the function name, `play()`.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if I want a little bit of namespace, I can have that, too:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: My import statement has resolved all but that last bit of namespace, `song`,
    so I still know where the `play()` function is coming from.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: The import system is deliciously flexible like that.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: Beware of Importing All
  id: totrans-1066
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before long, you’ll probably find yourself tempted to import all of the hundreds
    of functions in your module, to save time. This is the point at which many developers
    go off the rails:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: This statement imports nearly everything in the module directly, except for
    anything preceded by one or more underscores. This import-all pattern is a Very
    Bad Idea, as you won’t know what all is getting imported or what will be shadowed
    in the process.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem gets even worse when you start importing all from multiple modules:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Doing this, you may be blissfully unaware that `open()`, `smart_door.open()`,
    and `gzip.open()` all exist and are fighting over the same name in your file!
    The function `gzip.open()` will win out in this example, because it’s the last
    version of `open()` that was imported. The other two functions have been shadowed,
    which means you effectively can’t call them at all.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: Since no one is likely to remember every single function, class, and variable
    in every module that gets imported, one can easily wind up with a whole lot of
    messes.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: 'The Zen of Python applies to this situation:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1076
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (. . .)
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-1079
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You should never have to guess where a function or variable is coming from.
    There should be code somewhere in the file that explicitly tells you where everything
    comes from, as seen in the preceding examples.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: This `import *` doesn’t quite work the same way with packages. By default, a
    line like `from some_package import *` will be functionally the same as `import
    some_package`, unless the package has been configured to work with `import *`.
    I’ll come back to this later.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: Importing Within Your Project
  id: totrans-1082
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to structure your project and import from packages and
    modules, I’ll tie everything together.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall my *omission* project structure from [Listing 4-1](#listing4-1). Here’s
    a subsection of that project directory:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Listing 4-8: Directory structure of *omission-git/*'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: Any one module in my project may need to be able to import from another module,
    whether it’s within the same package or somewhere else in the project structure.
    I’ll explain how to handle both scenarios.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: Absolute Imports
  id: totrans-1088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have a class `GameMode` defined within the *game_enums.py* module, which lives
    in the *omission/common* package. I want to use that class within my *game_round_settings.py*
    module, defined in the *omission/data* package. How do I get to it?
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: 'Because I defined *omission* as a top-level package and organized my modules
    into subpackages, it’s pretty straightforward. In *game_round_settings.py*, I’d
    write the following:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Listing 4-9: *game_round_settings.py:1a*'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: This line is an *absolute import*. It starts at the top-level package, *omission*,
    and walks down into the *common* package, where it looks for *game_enums.py*.
    Inside that module, it finds whatever has the name `GameMode` and imports that.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: Relative Imports
  id: totrans-1094
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also import from a module in the same package or subpackage. This is
    known as a *relative import* or an *intrapackage reference*. In practice, intra-package
    references are easy to do wrong. If some developer wanted to import `GameMode`
    (which is provided by *omission/common/game_enums.py*) into *omission/data/game_round_settings.py*,
    they might incorrectly attempt to use something like the following:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Listing 4-10: *game_round_settings.py:1b*'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: This fails, leaving the developer wondering why it doesn’t work. The *data*
    package (where *game_round_settings.py* lives) has no knowledge of its sibling
    packages, such as *common*.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: A module knows what package it belongs to, and a package knows its parent package
    (if it has one). Because of this, relative imports can start the search from the
    current package and move up and down through the project structure.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: 'Within *omission/data/game_round_settings.py*, I can use the following import
    statement:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Listing 4-11: *game_round_settings.py:1c*'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: The two dots (`..`) mean “the current package’s direct parent package,” which,
    in this case, is *omission*. The import steps up one level, walks down into *common*,
    and finds *game_enums.py*.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: There’s some difference of opinion among Python developers about whether to
    use absolute or relative imports. Personally, I prefer to use absolute imports
    whenever possible, because I feel it makes the code a lot more readable. You can
    make up your own mind. The only important factor is that the result should be
    *obvious*—there should be no mystery about where anything comes from.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: Importing from the Same Package
  id: totrans-1105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one other lurking gotcha here. In *omission/data/settings.py*, I have
    this statement for importing a class from the module *omission/data/game_round_settings.py*:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Listing 4-12: *settings.py:1a*'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think that since both *settings.py* and *game_round_settings.py*
    are in the same package, *data*, I should be able to just use this:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Listing 4-13: *settings.py:1b*'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: However, that will not work. It will fail to locate the *game_round_settings.py*
    module because I am running the top-level package (`python3 -m omission`), and
    absolute imports for anything within the package being executed (*omission*) have
    to start from the top.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: 'I can instead use a relative import, which looks much simpler than the absolute
    import:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Listing 4-14: *settings.py:1c*'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the single dot (`.`) means “this package.”
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: 'This probably feels familiar if you’re used to the typical UNIX filesystem,
    although Python takes the concept a bit further:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: One dot (`.`) means the current package.
  id: totrans-1118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two dots (`..`) takes you back one level, to the parent package.
  id: totrans-1119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Three dots (`...`) takes you back two levels, to the parent of the parent package.
  id: totrans-1120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Four dots (`....`) takes you back three levels.
  id: totrans-1121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And so on, and so forth.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that those “levels” aren’t just plain directories; they’re packages.
    If you have two distinct packages in a plain directory that isn’t a package, you
    can’t use relative imports to jump from one to another. You’ll have to work with
    the Python search path for that. I’ll talk more about that later in this chapter.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: Entry Points
  id: totrans-1124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you’ve learned how to create modules, packages, and projects, and how
    to make full use of the import system. The last piece of this puzzle is gaining
    the ability to control what happens when a package is imported or executed. The
    parts of the project that are run first when importing or executing are called
    *entry points*.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: Module Entry Points
  id: totrans-1126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you import a Python module or package, it is given a special variable
    called `__name__`. This contains the *fully qualified name* of the module or package,
    which is the name as the import system sees it. For example, the fully qualified
    name of the module *omission/common/game_enums.py* would be `omission.common.game_enums`.
    There is one exception: when a module or package is run directly, its `__name__`
    is set to the value `"__main__"`.'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, assume I have a package called *testpkg*, which contains
    the module *awesome.py*. It defines a function, `greet()`:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Listing 4-15: *awesome.py:1*'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom of that same file also contains a `print` message:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Listing 4-16: *awesome.py:2a*'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: 'In another module in the same directory as *testpkg*, I have this module (*example.py*),
    which I run directly with `python3 example.py`:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Listing 4-17: *example.py*'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: If I look at the `_name_` local variable—which is the `__name__` presently assigned
    to the current module, *example.py*—I’ll see the value is `"__main__"` because
    I executed *example.py* directly.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: The package `awesome` I imported also has a `__name__` variable, which has the
    value `"testpkg.awesome"`, representing where the package came from in the import
    system.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ran that module, you’d get the following output:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: That first line is coming from *testpkg/awesome.py*, which is run by the import
    command. The rest is coming from the two print commands in *example.py*.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if I want that first message to appear only if *awesome.py* is executed
    directly, and *not* when the module is only imported? To accomplish that, I’d
    check the value of `__name__` variable in a conditional statement. I’ve rewritten
    my *awesome.py* file to do exactly that:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Listing 4-18: *awesome.py:2b*'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: If *awesome.py* is executed directly, `__name__` will have the value `"__main__"`,
    so the print statement will run. Otherwise, if *awesome.py* is being imported
    (or otherwise run indirectly), the conditional will fail.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: While you’ll frequently see this pattern in Python, some Python experts consider
    it an anti-pattern, because it can encourage you to both execute and import a
    module at the same time. While I don’t agree that using `if__name__ == "__main__"`
    is an anti-pattern, you often don’t need it. In any case, be certain you never
    import your main module from anywhere else in your package.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: Package Entry Points
  id: totrans-1147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that my *omission* project has a file called `__main__` in the top-level
    package. This file is automatically run when a package is executed directly, but
    never when importing the package.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: So, when executing *omission* via `python3 -m omission`, Python first runs the
    *__init__.py* module (as always), followed by its *__main__.py* module. Otherwise,
    if the package is imported instead, only *__init__.py* is executed.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: If you omit *__main__.py* from a package, it cannot be executed directly.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: 'A good *__main__.py* for a top-level package would look something like the
    following:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Listing 4-19: *__main__.py*'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: All the logic for starting the package belongs in the `main()` function. Then,
    the `if` statement checks the `__name__` assigned to the *__main__.py* module.
    Since this package is being executed directly, the value of `__name__` is `"__main__"`,
    and the code within the `if` statement, being the call to the `main()` function,
    is run. Otherwise, if *__main__.py* were only being imported, its fully qualified
    name would include its containing package (for example, `omission.__main__`),
    the condition would fail, and the code wouldn’t run.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Package Imports
  id: totrans-1155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A package’s *__init__.py* file can come in handy when you want to change what
    is available for import and how it can be used. The most common uses for this
    file are to simplify imports and to control the behavior of import-all (`import
    *`).
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying Imports
  id: totrans-1157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine I have a particularly complicated package, `rockets`, which is made
    up of dozens of subpackages and hundreds of modules. I can safely assume that
    many developers using the package won’t want to know about most of that functionality.
    They only want one thing: to define a rocket and then launch it! Instead of expecting
    all the users of my package to know where those few basic bits of functionality
    exist in the package structure, I can use *__init__.py* to expose said functionality
    directly, making the bits easier to import later:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Listing 4-20: *__init__.py:1*'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: 'This greatly simplifies the usage of the package. I no longer need to remember
    where things like the `SmallRocket` and `Launchpad` classes live in the `rockets`
    package structure. I can import them directly from the top-level package and use
    them:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Listing 4-21: *rocket_usage.py*'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: Beautifully simple, isn’t it? Still, nothing is actually *preventing* me from
    importing things the long-form way (such as `from rockets.smallrocket.rocket import
    SmallRocket`) if I need to. The shortcut is there, but it’s optional.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: Because simplicity is such an essential part of the Python philosophy, it is
    also an essential component of package design. If you can anticipate the most
    common ways a user might interact with your package, you can greatly simplify
    their code by adding a few lines to *__init__.py*.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Import-All
  id: totrans-1166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, import-all doesn’t work with a package. You use *__init__.py* to
    enable and control the behavior of `import *`, even though such an import statement
    is generally discouraged. This can be done by assigning a list of strings to `__all__`,
    with each string containing something (such as a package or module) to import
    from the current package.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: 'This works well with the previous trick ([Listing 4-20](#listing4-20)):'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Listing 4-22: *__init__.py:2a*'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: 'When Python encounters a line like `from rockets import *`, that list from
    `__all__` (seen as `rockets.__all__`) is unpacked in place of the asterisk (`*`).
    This is important in figuring out what you can include in `__all__`: each item
    in my list should make sense when substituted for the asterisk in `from rockets
    import *`.'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, I could change the last line of my *__init__.py* to this, and
    there would be no error in the code:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Listing 4-23: *__init__.py:2b*'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: This works because, as you already know, the line `from rockets import smallrocket`
    is a valid import statement.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, this example would *not* work:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Listing 4-24: *__init__.py:2c*'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: It fails because `from rockets import smallrocket.rocket` does not make sense.
    You’ll have to consider this principle when defining `__all__`.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: If `__all__` is not defined in *__init__.py*, then `from rockets import *` will
    behave the same as `import rockets`.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: Program Entry Points
  id: totrans-1181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve applied all the concepts in this chapter to your project’s structure,
    you can run `python3 -m yourproject` to start your program.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: However, you (or your eventual end user) may want to run the program merely
    by double-clicking or directly executing some single Python file. With everything
    else in place, this is trivial to implement.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: 'To make my *omission* project easy to run, I created a single script file *outside
    the top-level package*, named *omission.py*:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Listing 4-25: *omission.py*'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: I import the `main()` function from *omission/__main__.py* and then execute
    that function. This is effectively the same as executing that package directly
    with `python3 -m omission`.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: There are better ways to create a program entry point, but I’ll cover those
    in Chapter 18, once I’ve created the all-important *setup.cfg* file. Again, what
    you have so far will be enough for development.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: The Python Module Search Path
  id: totrans-1189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *module search path*, or *import path*, defines where Python looks for packages
    and modules and what order it searches in. When you first start the Python interpreter,
    the module search path is assembled in order, from the directory of the module
    being executed, the system variable `PYTHONPATH`, and the default path for the
    Python instance being used.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the resulting module search path with the following commands:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Running that code within the context of a virtual environment (in my case,
    */home/jason/.venvs/venv310*) on my system gives me the following output:'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The import system looks through each of the locations in the module search path
    *in order*. As soon as it finds a match for the module or package being imported,
    it stops. You can see here that it searches the directory containing the module
    or script I’m running ❶, the standard libraries ❷ ❸ ❹, and then everything installed
    with pip in the virtual environment ❺.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: If you need to add locations to the module search path, the best way is to use
    a virtual environment and add a file ending in *.pth* to the *lib/python3.x/site-packages*
    directory. The name of the file doesn’t matter, as long as the file extension
    is *.pth*.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Listing 4-26: *venv/lib/python3.10/site-packages/stuff.pth*'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: Each line must contain exactly one path to be appended. The absolute path */home/jason/bunch_of_code*
    will be appended to the module search path. The relative path *../../../awesomesauce*
    is relative to the .*pth* file, so it will point to *venv/awesomesauce*.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: Because these are appended to the module search path, this technique cannot
    be used to replace any packages or modules installed on the system or virtual
    environment. However, any new modules or packages in my *bunch_of_code/* or *awesomesauce/*
    directories will be available for import within the virtual environment.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: What Really Happens
  id: totrans-1202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at what really happens under the hood when you import a module. Most
    of the time, those details won’t matter, but every now and then (such as when
    the wrong module seems to be imported instead of the one you expect), the technical
    details leak to the surface. It never hurts to know what’s going on.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: The `import` statement calls the built-in`__import__()` function.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: 'To import a module, Python uses two special objects: a *finder* and a *loader*.
    In some cases, it uses an *importer* object, which serves as both a finder and
    a loader.'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: The *finder* is responsible for locating the module being imported. There are
    many places to look for modules—they aren’t even necessarily files—and a number
    of special situations exist that must be handled. Python has several types of
    finders to handle these different situations, and it gives each one an opportunity
    to locate a module with a given name.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: 'First, Python uses *meta path finders*, which are stored in the `sys.meta_path`
    list. By default, there are three meta path finders:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: The *built-in importer* finds and loads built-in modules.
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *frozen importer* finds and loads *frozen* modules, meaning modules that
    have been converted to compiled bytecode (see Chapter 1).
  id: totrans-1209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *path-based finder* looks in the filesystem for the module.
  id: totrans-1210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This search order is the reason why you cannot globally shadow a built-in module;
    the built-in importer runs before the path-based finder. If you need some additional
    meta path finder, such as if you were importing a module from a novel location
    not already supported, you can add it as a *meta hook* by appending it to the
    `sys.meta_path` list.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: There’s some additional complexity to the path-based finder that is worth breaking
    down. The path-based finder tries each of the *path entry finders* in turn. These
    path entry finders, also known as *path entry hooks*, are stored in `sys.path_hooks`.
    Each one searches every location (known as a *path* entry) listed on the import
    path, as specified by `sys.path` or the `__path__` attribute of the current package.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: If any of the finders locates the module, it returns a *module spec* object
    with all the information about how to load the module. However, if all the meta
    path finders return `None`, you’ll get a `ModuleNotFoundError`.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: Once the module is found, the module spec goes to the *loader*, which is responsible
    for actually loading the module.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot of technical detail regarding loading that’s beyond the scope
    of this book, but one thing worth noting is how the loader deals with *cached
    bytecode*. Ordinarily, once a Python module has been run, a *.pyc* file is generated.
    The file contains the bytecode, which from then on is *cached*. You’ll often see
    these *.pyc* files hanging out in your project directories. The loader always
    needs to be sure that the cached bytecode is not out of date before loading it,
    by using one of two strategies. The first strategy is for the bytecode to also
    store the timestamp from the last time the source code file was modified. When
    loading the module, the timestamp of the source code is checked against this cached
    timestamp. If it doesn’t match, the bytecode is out of date, and the source will
    be recompiled. The second strategy, introduced in Python 3.7, instead stores a
    *hash*, which is a short and (relatively) unique value algorithmically generated
    from the source code itself. If the source code changes, the hash will be different
    from the one stored in the cached bytecode. Python bytecode files that contain
    this hash are appropriately called *hash-based .pyc* files.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how the loader is loading the module, it will add the module object
    to `sys.modules`—adding it, in fact, just before actually loading, to prevent
    an import loop if the module being loaded imports itself. Finally, the loader
    will bind the imported module object to a name in the module importing it, so
    the imported module can be referenced. (I’ll cover name binding in Chapter 5.)
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: Once the module has been imported, it’s cached in `sys.path_importer_cache`,
    along with the importer object used to import it. This is actually the first place
    the import system will check for an imported module, even before running through
    the finders, so importing a module multiple times in a project will still only
    go through the finding-and-loading process once.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: This is a very broad overview of the import system, but most of the time, it’s
    all you’ll need to know. To learn all the intricate details, you can read the
    official documentation at [https://docs.python.org/3/reference/import.html](https://docs.python.org/3/reference/import.html).
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-1219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python import system is often overlooked when learning the language, leading
    to many headaches for new users. By understanding how to use and import modules
    and packages, you will greatly reduce the roadblocks between you and a viable
    project. A little effort now will save you countless hours of confusion and trouble
    later!
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
