- en: Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: THE PYTHON ENVIRONMENT
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python 环境
- en: '1'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Python Philosophy
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 哲学
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: I believe the best place to start learning Python is not with the language itself,
    but with the guiding philosophy driving it. To write good Python code, you must
    first understand what Python is. That’s what this chapter will focus on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为学习 Python 的最佳起点不是从语言本身开始，而是从支撑它的指导哲学开始。要编写出好的 Python 代码，首先你必须理解 Python 是什么。这一章将专注于这一点。
- en: What Is Python, Exactly?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，Python 到底是什么呢？
- en: Python is a programming language developed in 1991 by Dutch programmer Guido
    van Rossum. The name refers not to the snake often used as a mascot, but to *Monty
    Python’s Flying Circus* (that fact alone should tell you a lot about the mindset
    behind the language). What began as a hobby project over Christmas break turned
    into one of the most perennially popular computer languages today.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是由荷兰程序员 Guido van Rossum 于 1991 年开发的编程语言。这个名字并不是指常作为吉祥物的蛇，而是指 *Monty
    Python’s Flying Circus*（这一点足以告诉你关于语言背后的思维方式）。最初作为一个圣诞假期的爱好项目，后来发展成了如今世界上最持久受欢迎的编程语言之一。
- en: From a technical perspective, Python is considered a high-level, general-purpose
    language, with full support for the procedural, object-oriented, and functional
    programming paradigms, among others.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度看，Python 被认为是一种高级通用语言，全面支持过程式、面向对象和函数式编程范式等。
- en: 'Fans of Python are quick to point out its famous readability and simplicity,
    which lend to an initial feeling that the language is “magic.” This has also given
    rise to a less-than-useful bit of advice for newcomers: “Python is easy; it’s
    just pseudocode!”'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的爱好者常常强调它著名的可读性和简洁性，这给人一种初步的感觉，认为这门语言“有魔力”。这也催生了一个对初学者不太有用的建议：“Python
    很简单；它只是伪代码！”
- en: 'That isn’t strictly true. Don’t let the natural readability fool you: Python
    is beautifully unique and influenced by many other languages, but it often bears
    little resemblance to any of them. To truly master it, one must take it by itself,
    not in strong comparison to other languages. That is exactly what this book will
    do.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全正确。不要被它天然的可读性所迷惑：Python 独具魅力，受到许多其他编程语言的影响，但它通常与这些语言几乎没有相似之处。要真正掌握它，必须将其独立看待，而不是与其他语言做强烈比较。这正是本书的目标。
- en: Most importantly, however, Python is an idea. It’s the collective creation of
    a diverse group of nerds, united by nothing more than an audacious desire to build
    an awesome programming language. When you truly understand Python, it alters your
    entire perspective. You’re a part of something larger; something that has taken
    on a life of its own.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是，Python 是一个理念。它是由一群各具特色的极客共同创造的，他们的唯一目标就是打造一个令人赞叹的编程语言。当你真正理解 Python
    时，它将改变你整个的视角。你成为了某个更大事物的一部分；某个已经拥有自己生命的事物。
- en: 'As Guido van Rossum explained in his famous King’s Day speech:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Guido van Rossum 在他著名的国王日演讲中所解释的：
- en: I believe the most important idea is that Python is developed on the Internet,
    entirely in the open, by a community of volunteers (but not amateurs!) who feel
    passion and ownership.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认为最重要的思想是，Python 是在互联网上完全公开开发的，由一群充满热情并且拥有责任感的志愿者（而非业余爱好者）共同完成的。
- en: 'Myths: What Python Isn’t'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '神话：Python 不是……  '
- en: There are a lot of myths about Python, many of which lead to people shunning
    the language for certain applications, if not altogether.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 有许多神话，其中许多导致人们在某些应用中放弃使用这门语言，甚至完全不使用它。
- en: 'Myth #1: Python Is Merely a Scripting Language'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #1：Python 仅仅是脚本语言'
- en: 'I consider “scripting language” to be one of the most insidious terms used
    in discussing programming languages. It implies that the language is somehow unsuited
    for writing “real” software (see Myth #5).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '我认为“脚本语言”是讨论编程语言时最具误导性的术语之一。它暗示该语言不适合编写“真正的”软件（见神话 #5）。'
- en: Python is *turing-complete*, which means that you could implement any programming
    language in Python and then be able to execute any program written in that language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是 *图灵完备* 的，这意味着你可以用 Python 实现任何编程语言，并且能够执行任何用该语言编写的程序。
- en: To put that another way, anything another programming language can do, Python
    can do. Whether it’s easy, or even advisable, depends on what you’re attempting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，任何其他编程语言能做的，Python 都能做。不管它是否简单，甚至是否明智，这取决于你所尝试的内容。
- en: 'Myth #2: Python Is Slow'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #2：Python 很慢'
- en: It’s easy to assume that high-level or interpreted languages like Python are
    naturally slower than compiled or low-level languages like C. In truth, it depends
    on the implementation of the language and how it’s used. In this book, we’ll cover
    several concepts related to improving the performance of Python code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易假设，像 Python 这样的高级语言或解释型语言天生比 C 这样的编译型或低级语言要慢。事实上，这取决于语言的实现方式以及如何使用。在本书中，我们将介绍几个与提高
    Python 代码性能相关的概念。
- en: The default implementation of the Python language interpreter, CPython, is written
    in C, and it is indeed slower than native machine code. However, there are various
    libraries and techniques—as well as other implementations of the language, including
    PyPy—which have much better performance overall (see Chapter 21) and even approach
    the speed of native machine code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言解释器的默认实现 CPython 是用 C 编写的，确实比原生机器代码慢。然而，还有许多库和技术——以及包括 PyPy 在内的其他语言实现——整体性能更好（见第
    21 章），甚至接近原生机器代码的速度。
- en: With all that said, you should understand how performance actually factors into
    your project. In most situations, Python is plenty fast enough to be a good choice
    for application development, data analysis, scientific computing, game development,
    web development, and the list goes on. The performance drawbacks inherent in CPython
    usually only become problematic when you are dealing with very specific scenarios
    demanding extraordinarily high performance. Even then, there are ways around the
    bottlenecks. For the majority of projects, Python’s baseline performance is more
    than sufficient.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，你应该理解性能实际上如何影响你的项目。在大多数情况下，Python 足够快，足以成为应用开发、数据分析、科学计算、游戏开发、网页开发等领域的好选择，列表还在继续。CPython
    中固有的性能缺陷通常只有在面对要求极高性能的特定场景时才会成为问题。即便如此，仍然有办法绕过这些瓶颈。对于大多数项目而言，Python 的基础性能已经足够。
- en: 'Myth #3: Python Cannot Be Compiled'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #3：Python 不能被编译'
- en: Python is an *interpreted language*, meaning the code is read, interpreted,
    and executed at runtime by the language’s *interpreter*. An end user running a
    project written in Python will typically have to have the Python interpreter installed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种*解释型语言*，意味着代码会被语言的*解释器*在运行时读取、解释并执行。运行 Python 编写的项目的最终用户通常需要安装 Python
    解释器。
- en: This contrasts with what I like to call *assembled languages*, like C, C++,
    or FORTRAN. In these languages, the final result of compilation is machine code,
    which can be executed directly on any compatible computer without needing an additional
    program on that machine (or somehow bundled with the code).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我喜欢称之为*汇编语言*的语言形成对比，比如 C、C++ 或 FORTRAN。在这些语言中，编译的最终结果是机器代码，它可以直接在任何兼容的计算机上执行，无需额外的程序（或与代码捆绑在一起）。
- en: Many developers take this to mean that Python cannot be compiled (assembled)
    to machine code, which seems like the obvious corollary. In fact, it is possible
    to compile Python to machine code, although this is rarely necessary and seldom
    done.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者认为这意味着 Python 不能被编译（汇编）成机器代码，这似乎是显而易见的推论。实际上，Python 是可以编译成机器代码的，尽管这通常不必要，也很少有人这样做。
- en: If you want to go this route, there are a few options. On UNIX, the built-in
    *Freeze* tool transpiles to C arrays of Python bytecode, and then it assembles
    this C code to machine code. This doesn’t result in truly assembled Python code,
    however, because the Python interpreter must still be invoked behind the scenes.
    Freeze only works on UNIX systems. The *cx_Freeze* tool, as well as *py2exe* on
    Windows, does much the same thing as Freeze.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想走这条路，还是有一些选择的。在 UNIX 系统中，内置的 *Freeze* 工具可以将 Python 字节码转译成 C 数组，然后将这些 C 代码汇编成机器代码。然而，这并不会产生真正的汇编
    Python 代码，因为 Python 解释器仍然需要在幕后调用。Freeze 只在 UNIX 系统上有效。*cx_Freeze* 工具以及 Windows
    上的 *py2exe* 做的工作与 Freeze 类似。
- en: To truly compile Python to machine code, you must use an intermediary language.
    *Nuitka* can be used to transpile Python code C and C++, which can then be assembled
    to machine code. You can also transpile Python to Java with *VOC*. *Cython* also
    allows transpiling a specialized form of Python to C, although it’s primarily
    geared toward writing Python extensions in C.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Python 代码真正编译成机器代码，你必须使用一种中介语言。*Nuitka* 可以将 Python 代码转译为 C 和 C++，然后再将其汇编成机器代码。你也可以通过
    *VOC* 将 Python 转译为 Java。*Cython* 还允许将一种特定形式的 Python 转译为 C，尽管它主要用于用 C 编写 Python
    扩展。
- en: 'Myth #4: Python Gets Compiled Behind the Scenes'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #4：Python 在幕后被编译'
- en: 'The Python interpreter converts code to *bytecode*, which is then executed.
    The interpreter includes a *virtual machine*, which executes the Python bytecode
    similarly to how a CPU executes machine code. Sometimes, the interpreter will
    do the conversion to bytecode in advance, for performance reasons, generating
    *.pyc* files containing bytecode. While this is “compiling” in one sense of the
    term, there is a key difference between compiling to bytecode and compiling to
    machine code: bytecode is still run through the interpreter, whereas machine code
    executes directly, without needing an additional program. (Technically, “compiling”
    to machine code is called *assembling*, although this distinction is often neglected
    or overlooked.)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python 解释器将代码转换为*字节码*，然后执行这些字节码。解释器包括一个*虚拟机*，它以类似于 CPU 执行机器码的方式执行 Python 字节码。有时，为了提高性能，解释器会提前将代码转换为字节码，生成包含字节码的*.pyc*
    文件。虽然从某种意义上来说这被称为“编译”，但编译字节码与编译机器码之间有一个关键的区别：字节码仍然需要通过解释器执行，而机器码则可以直接执行，无需额外的程序。（从技术上讲，“编译”成机器码被称为*汇编*，尽管这一区别通常会被忽略或忽视。）
- en: In practice, the majority of Python projects ship as source code, or at least
    Python bytecode, which is run in the Python interpreter installed on the user’s
    machine. There are occasions when a standard executable is preferable, such as
    for ease of installation on end-user computers or in closed-source projects. For
    those situations, tools such as *PyInstaller* and *cx_Freeze* exist. These don’t
    compile the code, but rather bundle the Python source code or bytecode with the
    interpreter so it can be executed by itself (see Chapter 18).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，大多数 Python 项目以源代码形式发布，或者至少是 Python 字节码，这些字节码在用户计算机上安装的 Python 解释器中运行。在某些情况下，标准的可执行文件更为合适，比如在最终用户计算机上安装方便或在闭源项目中使用。在这些情况下，*PyInstaller*
    和 *cx_Freeze* 等工具应运而生。这些工具不会编译代码，而是将 Python 源代码或字节码与解释器捆绑在一起，使其能够独立执行（见第 18 章）。
- en: 'Myth #5: Python Is Unsuitable for Large Projects'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '神话 #5：Python 不适合大型项目'
- en: I’ve heard some developers say, “Python is only useful if the whole project
    fits in one file.” This adage is partially based on the misconception that Python
    projects with multiple files are confusingly structured. This indeed tends to
    be the trend, but only because so few developers know how to correctly structure
    a Python project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾听到一些开发者说：“Python 只有在整个项目都能放在一个文件里时才有用。”这个说法部分基于一种误解，认为包含多个文件的 Python 项目结构混乱。确实，这种情况往往会发生，但仅仅是因为很少有开发者知道如何正确地结构化一个
    Python 项目。
- en: In reality, project structure in Python is far simpler than in C++ and Java.
    Once the developer understands the concepts of packages, modules, and the import
    system (see Chapter 4), working with multiple code files becomes trivial.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Python 的项目结构比 C++ 和 Java 要简单得多。一旦开发者理解了包、模块和导入系统的概念（见第 4 章），使用多个代码文件就变得非常简单。
- en: Another reason for this myth has to do with the fact that Python is dynamically
    typed, rather than statically typed like Java or C++, which some believe makes
    refactoring harder. This doesn’t have to be the case, once the developer knows
    how to work with Python’s type system, instead of against it (see Chapter 5).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个神话的另一个原因与 Python 是动态类型的有关，而不是像 Java 或 C++ 那样的静态类型，许多人认为这使得重构变得更加困难。但只要开发者学会如何利用
    Python 的类型系统，而不是与之对抗（见第 5 章），这种情况就不必如此。
- en: Python 2 vs. Python 3
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 2 与 Python 3
- en: For many years, there existed two major versions of Python. Starting in 2001,
    *Python 2* was the standard, meaning most books and articles about Python were
    written for this version. The last release was Python 2.7.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Python 存在两个主要版本。从 2001 年开始，*Python 2* 是标准版本，这意味着大多数关于 Python 的书籍和文章都是为这个版本编写的。最后一个版本是
    Python 2.7。
- en: The current version is *Python 3*, known during its development as *Python 3000*
    or *Py3k*. From its release in 2008 until 2019, we were in a sort of limbo between
    the two versions; a lot of existing code and packages were written in Python 2,
    while Python 3 was increasingly recommended for new projects that didn’t require
    legacy support. Many techniques and tools existed for writing code that could
    run in either version, which eased the transition for many existing projects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本是*Python 3*，在开发过程中被称为*Python 3000* 或 *Py3k*。从 2008 年发布到 2019 年，我们一直处于两个版本之间的某种过渡期；大量现有的代码和包是用
    Python 2 编写的，而 Python 3 被越来越多地推荐用于不需要遗留支持的新项目。许多技术和工具使得编写能够同时在两个版本上运行的代码成为可能，从而帮助了许多现有项目的过渡。
- en: In more recent years, especially since the release of Python 3.5, we’ve begun
    moving away from Python 2 altogether. Most major libraries officially supported
    Python 3, and legacy support became less of a priority.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，尤其是自Python 3.5发布以来，我们已经开始完全摆脱Python 2。大多数主要的库已经正式支持Python 3，而对遗留版本的支持不再是优先事项。
- en: As of January 1, 2020, Python 2 has been officially retired, and Python 3 is
    the definitive standard. Since Python 4 is still nothing more than a vague wisp
    of a rumor at this point, it’s safe to say that Python 3 will be with us for years
    to come.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2020年1月1日，Python 2已经正式退役，Python 3成为了公认的标准。由于Python 4目前仍然只是一个模糊的传闻，可以安全地说，Python
    3将会陪伴我们多年。
- en: Unfortunately, many software development teams have been slow (sometimes unavoidably)
    about porting their code bases from Python 2 to Python 3\. This has left a lot
    of projects in limbo. If you use Python in a professional capacity, there is a
    good chance you’ll have to help transition some code to Python 3\. Python’s standard
    library includes a tool called *2to3*, which helps automate this process. Running
    the code through this tool is a good first step, but you will still need to manually
    update the code to use some of the newer patterns and tools Python 3 has to offer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多软件开发团队在将代码库从Python 2迁移到Python 3的过程中进展缓慢（有时是不可避免的）。这导致了很多项目陷入了停滞。如果你在专业环境中使用Python，很有可能需要帮助将一些代码迁移到Python
    3。Python的标准库包含一个名为*2to3*的工具，能够帮助自动化这一过程。通过这个工具运行代码是一个很好的第一步，但你仍然需要手动更新代码，以使用Python
    3所提供的一些更新的模式和工具。
- en: Defining “Pythonic” Code
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义“Pythonic”代码
- en: Among Python developers, you’ll hear a lot of talk about *Pythonic* code and
    what it constitutes, precisely. In a general sense, idiomatic code that makes
    good use of the language’s features is considered Pythonic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python开发者中，你会经常听到关于*Pythonic*代码的讨论，以及它究竟代表什么。从广义上讲，能够充分利用语言特性的习惯用法代码被认为是Pythonic的。
- en: Unfortunately, this is very much open to interpretation. As a result, the topic
    of best practices in Python is a regular source of heated debate in the community.
    Don’t be alarmed by this. By regularly grappling with our own conventions and
    standards, we continually improve them and our own understanding along the way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这一点非常依赖于解释。因此，Python中最佳实践的话题常常成为社区热议的焦点。不要因此感到惊讶。通过不断与我们自己的约定和标准斗争，我们不断改进这些标准，同时也提升我们自己的理解。
- en: Our tendency to debate best practices in Python is rooted in our philosophy
    of *There’s Only One Way To Do It (TOOWTDI)*, a phrase coined by PythonLabs in
    2000 as a tongue-in-cheek response to the Perl community’s own adage of *There’s
    More Than One Way To Do It (TMTOWTDI)*. Despite the historic rivalry between these
    communities, these philosophies aren’t strictly opposing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Python中讨论最佳实践的倾向源于我们的哲学理念*只有一种方法可以做到（TOOWTDI）*，这个短语由PythonLabs在2000年创造，作为对Perl社区自己格言*有不止一种方法可以做到（TMTOWTDI）*的幽默回应。尽管这两个社区之间有历史性的竞争，但这些哲学理念并不是严格对立的。
- en: Python developers rightly assume there is some single, quantifiably “best” solution
    to any specific problem. Our task is to figure out what that solution is, but
    we also know we will often fall far short of the goal. Through continual discussion,
    debate, and experimentation, we refine our approaches in pursuit of the theoretical
    Best Solution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python开发者正确地认为，对于任何特定问题，都有一个量化的“最佳”解决方案。我们的任务是弄清楚这个解决方案是什么，但我们也知道我们往往会远远低于这个目标。通过不断的讨论、辩论和实验，我们在追求理论上最佳解决方案的过程中不断完善我们的做法。
- en: In the same way, the Perl community understands that it is often impossible
    to definitively arrive at that Best Solution, so they emphasize experimentation
    instead of compliance with strict standards, in an effort to discover better and
    better solutions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Perl社区也明白，要想最终找到那个最佳解决方案常常是不可能的，所以他们强调实验而非遵循严格的标准，努力发现越来越好的解决方案。
- en: 'In the end, the goal is the same: to ultimately define the best possible solution
    to a problem. Only the emphasis differs.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，目标是相同的：定义出解决问题的最佳方法。只是重点有所不同。
- en: In this book, I’ll focus a lot on the generally accepted Pythonic ways of writing
    code. However, I don’t claim to be the final authority. My colleagues in the Python
    community will always have plenty to add to these discussions. I never fail to
    learn something new from them!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将重点讲解一般公认的Pythonic编程方式。然而，我并不声称自己是最终权威。我的Python社区同仁总是有很多可以补充的内容，我从他们那里总能学到新东西！
- en: The Zen of Python
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python之禅
- en: In 1999, a discussion started on the official Python mailing list about the
    need to write down some sort of formal guiding principles for the language. Tim
    Peters, a prominent member of the community, jokingly laid out a poetic summary
    of 19 principles to serve as an outline, leaving the 20th spot open for Guido
    van Rossum to complete (which he never did).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 1999年，关于是否需要为Python语言写下一些正式的指导原则，官方Python邮件列表上展开了讨论。社区的杰出成员Tim Peters开玩笑地列出了19条原则的诗意总结，作为大纲，并留出了第20个位置让Guido
    van Rossum来完成（但他从未完成）。
- en: Other community members quickly seized on this summary as a fantastic overview
    of Python’s philosophy, ultimately adopting it wholesale as *The Zen of Python*.
    The entire text is published by Python as PEP 20.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其他社区成员迅速将这个总结视为Python哲学的精彩概述，最终将其作为*Python之禅*全面采纳。整篇文章由Python以PEP 20的形式发布。
- en: Beautiful is better than ugly.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 美丽胜于丑陋。
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显式胜于隐式。
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Simple is better than complex.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 简单胜于复杂。
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Complex is better than complicated.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 复杂胜于复杂化。
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Flat is better than nested.
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扁平胜于嵌套。
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sparse is better than dense.
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 稀疏胜于密集。
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Readability counts.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可读性很重要。
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Special cases aren’t special enough to break the rules.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 特殊情况不足以打破规则。
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although practicality beats purity.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管实用性胜于纯粹性。
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Errors should never pass silently.
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误永远不应悄悄通过。
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非明确地沉默。
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面对模糊时，要拒绝猜测的诱惑。
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该有一种——最好只有一种——显而易见的方式来做。
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you’re Dutch.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管如果你不是荷兰人，那条路一开始可能不那么显而易见。
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now is better than never.
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在胜于永不。
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although never is often better than *right* now.
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管往往“永不”比*立刻*更好。
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the implementation is hard to explain, it’s a bad idea.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果实现难以解释，那就是个坏主意。
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the implementation is easy to explain, it may be a good idea.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果实现容易解释，那可能是个好主意。
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Namespaces are one honking great idea—let’s do more of those!
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名空间是一个非常棒的主意——让我们多做一些吧！
- en: This, too, is open to interpretation, and some argue that Tim Peters was kidding
    when he wrote The Zen of Python. However, if there’s one thing I’ve learned about
    Python developers, it’s that the line between “kidding” and “serious” is fine
    as spider silk.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这点也可以有不同的解释，有人认为Tim Peters在写《Python之禅》时是在开玩笑。然而，如果我从Python开发者身上学到了什么，那就是“开玩笑”和“认真”之间的界限像蜘蛛丝一样细微。
- en: In any case, The Zen of Python is a great place to start when talking about
    best practices in Python. Many developers, including myself, often refer back
    to it. I’ll refer to it frequently throughout this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，《Python之禅》是谈论Python最佳实践的好起点。包括我在内的许多开发者常常回头参考它。我将在本书中频繁提到它。
- en: Documentation, PEPs, and You
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档、PEP和你
- en: '*Dead Simple Python* is intended as a beginning, not an ending, to your learning
    journey. Once you are well acquainted with the Python language, you can turn to
    the language’s extensive official documentation to learn more about any particular
    features or tools. These docs are found online at [https://docs.python.org/](https://docs.python.org/).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单至极的Python*旨在作为你学习之旅的开始，而非终点。一旦你熟悉了Python语言，就可以转向语言的官方文档，进一步了解任何特定的功能或工具。这些文档可以在线访问，网址是[https://docs.python.org/](https://docs.python.org/)。'
- en: Any new feature in Python begins its life as a *Python Enhancement Proposal*
    (PEP). Each is assigned a unique number and published to the official PEP index
    at [https://python.org/dev/peps/](https://python.org/dev/peps/). Once proposed,
    a PEP will be considered, discussed, and ultimately accepted or rejected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的任何新特性都会以*Python增强提案*（PEP）的形式开始。每个PEP都被分配一个独特的编号，并发布到官方PEP索引，网址是[https://python.org/dev/peps/](https://python.org/dev/peps/)。一旦提案提交，PEP将被考虑、讨论，并最终接受或拒绝。
- en: Accepted PEPs are effectively extensions of the documentation, as they are the
    most cohesive and authoritative descriptions of the feature(s) they define. Additionally,
    there are several Meta-PEPs and Informational PEPs that provide the backbone for
    the Python community and language.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 被接受的PEP实际上是文档的扩展，因为它们是最具凝聚力和权威性的功能描述。此外，还有一些Meta-PEP和Informational PEP，提供了Python社区和语言的支柱。
- en: As such, the official documentation and PEP index should be the first place
    you go if you have any questions about Python. I’ll refer to these frequently
    throughout this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，官方文档和PEP索引应该是你遇到Python问题时首先查阅的地方。我将在本书中频繁提到这些。
- en: Who Calls the Shots?
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁来决定？
- en: To understand how and why the language evolves, it is important to know who’s
    in charge. When a PEP is proposed, who gets to decide if it’s accepted or rejected?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解语言是如何以及为什么发展的，了解谁在主导非常重要。当一个 PEP 被提议时，谁来决定是否接受或拒绝它？
- en: Python is an open source project officially owned by the nonprofit Python Software
    Foundation. Unlike many other popular languages, no formal associations exist
    between Python and any for-profit organization.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一个由非营利组织 Python 软件基金会官方拥有的开源项目。与许多其他流行的编程语言不同，Python 与任何营利性组织之间没有正式的关联。
- en: As an open source project, Python is supported by an active and vibrant community.
    At its heart is the core team, the trusted volunteers who maintain the language
    and keep the community running smoothly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个开源项目，Python 得到了一个活跃而充满活力的社区的支持。其核心是核心团队，这些受信任的志愿者负责维护语言并保持社区的顺利运作。
- en: Language creator Guido van Rossum served as the Benevolent Dictator for Life
    (BDFL), making the final decisions on all PEPs and overseeing ongoing development
    of the language. In 2018, he made the decision to step down from the role.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的创造者 Guido van Rossum 曾担任“终身仁慈独裁者”（BDFL），对所有 PEP 做出最终决定，并监督语言的持续开发。2018年，他决定辞去这一职务。
- en: A few months after his resignation, PEP 13 was created to establish a new system
    of governance. Now the language is governed by a five-person steering committee,
    elected by the core team. Every time a new release of the language comes out,
    a new steering committee is elected.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在他辞职几个月后，PEP 13 被创建，建立了一个新的治理体系。现在，语言由一个五人组成的领导委员会来管理，该委员会由核心团队选举产生。每当语言发布新版本时，都会选举新的领导委员会。
- en: The Python Community
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 社区
- en: The Python community is a vast and diverse group of individuals from all over
    the world, united by their passion for this unique language. Ever since I stumbled
    upon the community many years ago as an utter novice, I have gained immeasurable
    help, guidance, and inspiration from it and its people. I’ve been privileged to
    offer the same to others in return. This book would not have ever happened without
    the continual feedback of my Python friends!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python 社区是一个庞大且多元化的群体，来自世界各地，因对这一独特语言的热情而团结在一起。自从我多年前作为一个初学者偶然发现这个社区以来，我从其中及其成员那里获得了无尽的帮助、指导和启发。我也很荣幸能将这些回馈给他人。如果没有我
    Python 朋友们的不断反馈，这本书根本不会成型！
- en: 'The Python community is moderated by the core team and governed by the Python
    Code of Conduct. In short, it emphasizes open, considerate, and respectful behavior,
    summarizing itself as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python 社区由核心团队进行管理，并由 Python 行为准则治理。简而言之，它强调开放、体贴和尊重的行为，并将自己总结如下：
- en: Overall, we’re good to each other. We contribute to this community, not because
    we have to, but because we want to. If we remember that, these guidelines will
    come naturally.
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总的来说，我们彼此之间相处融洽。我们为这个社区做出贡献，不是因为我们必须这样做，而是因为我们愿意。如果我们记住这一点，这些指导方针就会自然而然地融入我们的行动中。
- en: I strongly encourage any developer who uses Python to plug into this vibrant
    community. One of the best ways to participate is through the Libera.Chat IRC
    `#python` chatroom. You can find guides to getting onto IRC at [https://python.org/community/](https://python.org/community/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈鼓励任何使用 Python 的开发者加入这个充满活力的社区。参与的最佳方式之一是通过 Libera.Chat IRC `#python` 聊天室。你可以在
    [https://python.org/community/](https://python.org/community/) 找到关于如何加入 IRC 的指南。
- en: If you have any questions about Python, including while you read through this
    book, I recommend asking for help in the IRC channel. Chances are, you’ll find
    me and most of my technical editors there.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 Python 有任何疑问，包括在阅读本书时，我建议你在 IRC 频道寻求帮助。很有可能，你会在那找到我和我的大多数技术编辑。
- en: In Chapter 21, I’ll discuss the many facets of the Python community.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 21 章中，我将讨论 Python 社区的许多方面。
- en: The Pursuit of the One Obvious Way
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追求唯一的显而易见的方式
- en: The Python mantra “There’s Only One Way to Do It” can be quite confusing at
    first. There are many possible ways to solve any one problem. Are Pythonistas
    just too enamored with their own ideas?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的口号“只有一种方式可以做到”一开始可能会让人感到困惑。解决任何一个问题都有许多可能的方式。难道 Python 爱好者只是过于迷恋自己的想法吗？
- en: Thankfully, no. This mantra means something much more encouraging, and it’s
    something every Python developer should understand.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，不是这样的。这句口号意味着一些更加令人振奋的内容，而且这是每一个 Python 开发者都应该理解的。
- en: 'Some insight comes from The Zen of Python, which includes this rather cryptic
    quip:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一些见解来自《Python 的禅》，其中包括这句相当隐晦的俏皮话：
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该有一种——最好只有一种——明显的方式来做这件事。
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although that way may not be obvious at first unless you’re Dutch.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管这种方法一开始可能并不显而易见，除非你是荷兰人。
- en: Tim Peters was, of course, referring to language creator Guido van Rossum, a
    Dutch national. As the creator of the language, Guido could usually cut right
    to the “most obvious way” of solving problems in Python, especially in the early
    days of the language.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，蒂姆·彼得斯指的是语言的创造者，荷兰国籍的吉多·范罗苏姆。作为语言的创造者，吉多通常能够直接找到“最明显的解决方法”，尤其是在 Python 语言初期。
- en: This *obvious way* is Python’s term for “the best solution”—a marriage of good
    practice, clean style, and reasonable efficiency, resulting in elegant code that
    is comprehensible to even the greenest novice.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*明显的方式*是 Python 对“最佳解决方案”的称谓——它是良好实践、简洁风格和合理效率的结合，产生的代码优雅且即使是最初学的新人也能理解。
- en: 'The details of the problem being solved will usually inform this “obvious way”:
    one situation may call for a loop, another for recursion, and yet another for
    a list comprehension. Contrary to the usual implications of the word *obvious*,
    the solution is often anything but simple to work out. The best solution is only
    obvious *once you know it*; arriving at it is where things get tricky. Most of
    us aren’t Guido.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 被解决问题的具体细节通常会指引出这个“明显的方式”：一种情况可能需要循环，另一种可能需要递归，还有一种可能需要列表推导式。与*明显*一词通常的含义相反，解决方案往往并不简单，找到它才是最棘手的部分。大多数人并不像吉多那样直觉明确。
- en: However, the *pursuit* of the “one obvious way” is a defining facet of the Python
    community, and it has had a profound impact on *Dead Simple Python*. A lot of
    the insights in this book were born out of sometimes intense debate between myself
    and my fellow Pythonistas. For this reason, I hand-selected my panel of technical
    editors from those colleagues who are commonly in opposition to me, and often
    each other, on pedantic technical points.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*追求*“唯一明显的方式”是 Python 社区的一个定义性特征，这对*极简 Python*产生了深远的影响。本书中的许多见解来源于我与我的 Python
    同好们之间有时激烈的辩论。正因如此，我从那些经常与我意见相左的同事中精心挑选了我的技术编辑小组，他们之间也常常就细枝末节的技术问题产生分歧。
- en: Anything ultimately adopted as the “right way” to solve a problem is usually
    accepted as such because of its technical merit, rather than because of some like-minded
    bias among Python developers, who are among the most exacting folks I’ve had the
    privilege of working with. This approach to logic overflows into every other conversation
    we have (which leads to some rather amazing and enlightening academic debates).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最终被接受为“正确方法”的解决方案，通常是因为其技术上的优越性，而不是因为 Python 开发者之间有某种志同道合的偏见。Python 开发者是我有幸合作过的最严格的人群之一。这种以逻辑为导向的方式渗透到我们每次的对话中（也导致了一些相当惊人且具有启发性的学术辩论）。
- en: New situations present themselves regularly. There will never come a point in
    any Python developer’s career when coding becomes truly “easy.” Situations will
    arise in every project that demand careful consideration, and often, debate. Developers
    must attempt to solve problems in the way that seems most obvious to them, then
    submit the solution to the critique of peers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 新的情况不断出现。在任何 Python 开发者的职业生涯中，永远不会有一个时刻，编程变得真正“容易”。每个项目中都会出现需要仔细考虑的情况，并且往往需要辩论。开发者必须尝试以他们认为最明显的方式来解决问题，然后将解决方案提交给同行进行批评。
- en: The approaches in this book are, in many cases, the most obvious according to
    my view. Most have been seconded by my colleagues, yet I dare not assert that
    I am altogether “Dutch” in the Python sense. If you find yourself debating techniques
    in the Python community, please do not wave this book in anyone’s face as evidence
    that your solution is best! Skill in finding an obvious solution is not something
    that can be taught; rather it is only learned through practice.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的方法在许多情况下是我个人认为最明显的。大多数方法得到了我的同事们的支持，但我不敢断言自己完全是“荷兰人”（在 Python 术语中）。如果你在
    Python 社区中争论某些技巧，请不要把这本书当作证据，强行证明你的解决方案是最好的！寻找明显解决方案的技巧是无法通过教学获得的，而是只能通过实践学习。
- en: Wrapping Up
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Despite the many myths that have been tossed around over the years, Python is
    a versatile and technically sound language, capable of handling just about any
    problem you can throw at it. It’s a solid choice, whether you are writing automation,
    crunching massive datasets, building native user applications, implementing machine
    learning, or crafting web applications and APIs. Most importantly, Python is backed
    by a vibrant, diverse, and helpful community.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多年来有许多关于 Python 的误解，Python 仍然是一种多功能且技术上可靠的语言，能够处理几乎任何你抛给它的问题。无论你是在编写自动化脚本、处理海量数据集、构建本地用户应用、实现机器学习，还是开发
    web 应用和 API，Python 都是一个坚实的选择。最重要的是，Python 得到了一个充满活力、多样化且乐于助人的社区的支持。
- en: The key to success, then, is writing Python code that makes the most of the
    strengths and features of the language. The goal is not simply to write code that
    works, but to write code that both looks and behaves elegantly. The rest of this
    book will teach you how to do exactly that.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的关键在于编写充分利用语言优点和特性的 Python 代码。目标不仅仅是编写可用的代码，而是编写既美观又优雅的代码。本书的其余部分将教你如何做到这一点。
- en: '2'
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Your Workbench
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工作台
- en: '![](Images/chapterart.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Your development environment is a major factor in how productive you’ll be in
    a language. Instead of contenting yourself with a bare-bones default shell, you’ll
    want to assemble a development environment worthy of any production-level project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的开发环境是你在一种语言中能达到的生产力的重要因素。与其满足于一个简陋的默认 shell，你会希望组建一个适合任何生产级项目的开发环境。
- en: A good Python development environment usually consists of the language interpreter,
    the pip package manager, a *virtual environment*, a Python-oriented code editor,
    and one or more *static analyzers* to check your code for errors and problems.
    I’ll discuss each of these in this chapter. I’ll also introduce the style conventions
    common in Python and round out the chapter with a guided tour of the most common
    Python integrated development environments (IDEs).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的 Python 开发环境通常包括语言解释器、pip 包管理器、*虚拟环境*、面向 Python 的代码编辑器以及一个或多个 *静态分析工具*，用于检查你的代码中的错误和问题。我将在本章中讨论这些工具。我还会介绍
    Python 中常见的编码风格规范，并通过一个常见的 Python 集成开发环境（IDE）导览来结束本章内容。
- en: Installing Python
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Python
- en: Before you can do anything, you have to install Python itself, along with a
    couple of essential tools. As you know from Chapter 1, Python is an interpreted
    language, so you’ll need to install its *interpreter*. You must also install pip,
    the Python package manager, so you can install additional Python tools and libraries.
    The exact steps for setup depend on your platform, but I will cover the major
    platforms here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始任何操作之前，你需要安装 Python 及一些必需的工具。正如你在第一章中所了解到的，Python 是一种解释型语言，因此你需要安装它的*解释器*。你还必须安装
    pip，这是 Python 的包管理工具，以便安装额外的 Python 工具和库。具体的安装步骤取决于你的平台，但我将在这里介绍主要平台的安装方式。
- en: In this book, I’m using Python 3.9, the latest version at the time of writing.
    If you’re reading this at a later date, just use the latest stable release of
    Python 3\. All the instructions should work the same. You need only replace the
    version number in the obvious ways on any commands run in the command line.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我使用的是 Python 3.9，这是写作时的最新版本。如果你在之后的时间阅读此书，只需使用最新稳定版本的 Python 3\。所有的指令应该是一样的。你只需要在命令行中替换命令中的版本号即可。
- en: This is merely a quick guide to installation. For the complete, official instructions,
    which cover many more situations and advanced options, see [https://docs.python.org/using/](https://docs.python.org/using/).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个快速的安装指南。有关完整的官方说明，涵盖了更多情况和高级选项，请参见 [https://docs.python.org/using/](https://docs.python.org/using/)。
- en: Installing on Windows
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 上安装
- en: On Windows, Python is not generally installed by default, so you’ll need to
    download it yourself from [https://python.org/downloads/windows/](https://python.org/downloads/windows/)
    and run that installer. On the first screen of the installer, be sure you check
    the boxes for **Install the launcher for all users** and **Add Python to PATH**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，Python 通常不会默认安装，因此你需要从 [https://python.org/downloads/windows/](https://python.org/downloads/windows/)
    下载并运行安装程序。在安装程序的第一个屏幕上，确保勾选 **为所有用户安装启动器** 和 **将 Python 添加到 PATH**。
- en: Python is also available through the Windows App Store. However, as of the date
    of my writing, this particular installation method is still officially considered
    unstable. I recommend downloading the official installer instead.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也可以通过 Windows 应用商店获取。然而，截止我写这篇文章时，这种安装方法仍然被官方认为是不稳定的。我建议你下载官方安装程序。
- en: Installing on macOS
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 macOS 上安装
- en: On macOS, you can use either MacPorts or Homebrew to install Python and pip.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，你可以使用 MacPorts 或 Homebrew 安装 Python 和 pip。
- en: 'Use the following commands to install Python and pip with MacPorts, replacing
    the `38` with whatever version you want to download (removing the decimal point):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令通过 MacPorts 安装 Python 和 pip，将 `38` 替换为你要下载的版本（去掉小数点）：
- en: '[PRE0]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, here’s the command to install both Python and pip in one step
    with Homebrew:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这里有一个使用 Homebrew 一步安装 Python 和 pip 的命令：
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use only one of the two methods described above.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用上述两种方法中的一种。
- en: Installing on Linux
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装
- en: If you’re running a Linux operating system, chances are that Python (`python3`)
    is installed by default, although the other tools you need may not be. (I’ll show
    you how to install Python anyway, just to be on the safe side.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行的是 Linux 操作系统，那么 Python（`python3`）很可能默认已经安装，尽管你可能还需要安装其他工具。（我会展示如何安装 Python，以防万一。）
- en: 'To install Python and pip on Ubuntu, Debian, or related, run this command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu、Debian 或相关系统上安装 Python 和 pip，运行此命令：
- en: '[PRE2]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On Fedora, RHEL, or CentOS, you can run this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora、RHEL 或 CentOS 上，你可以运行以下命令：
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On Arch Linux, run this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arch Linux 上，运行以下命令：
- en: '[PRE4]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For other distributions, you’ll need to search for the Python 3 and pip packages
    yourself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他发行版，你需要自行查找 Python 3 和 pip 软件包。
- en: Installing from Source
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码安装
- en: If you’re running a UNIX-like system, and if your system either has an outdated
    version of Python 3 in the system packages or lacks a package manager altogether,
    you can build Python from source. This is how I usually install the latest Python.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行的是类 UNIX 系统，并且系统中有一个过时的 Python 3 版本，或者根本没有包管理器，你可以从源代码构建 Python。这是我通常安装最新
    Python 的方法。
- en: Installing Dependencies
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: On macOS, there are some relatively complex considerations when it comes to
    installing Python’s build dependencies. You should consult the documentation at
    [https://devguide.python.org/setup/#macos-and-os-x](https://devguide.python.org/setup/#macos-and-os-x).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，安装 Python 构建依赖时有一些相对复杂的考虑因素。你应该参考[https://devguide.python.org/setup/#macos-and-os-x](https://devguide.python.org/setup/#macos-and-os-x)中的文档。
- en: On most Linux systems, you will need to make sure you have the development files
    for several libraries that Python relies upon. The best way to install these depends
    on your system and, more specifically, which package manager you use.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Linux 系统上，你需要确保安装了 Python 依赖的几个库的开发文件。安装这些文件的最佳方式取决于你的系统，具体来说，取决于你使用的包管理器。
- en: If you’re on a Linux distribution that uses the APT package manager—such as
    Ubuntu, Pop!_OS, Debian, or Linux Mint—then you should either check the box to
    enable Source Code as a source in your Software Sources or Software & Updates
    settings or make sure you have it included in your *sources.list* file. (The exact
    method depends on your system, and that topic is beyond the scope of this book.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Linux 发行版并且使用 APT 包管理器——例如 Ubuntu、Pop!_OS、Debian 或 Linux Mint——那么你应该勾选启用源代码作为软件源，或者确保它包含在你的
    *sources.list* 文件中。（具体方法取决于你的系统，详细内容超出了本书的范围。）
- en: 'Then, run the following commands:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you get the message `Unable to find a source package for python3.9`, change
    the `9` to a lower (or higher) number until you find one that works. The dependencies
    for Python 3 don’t really change much between minor versions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到消息`Unable to find a source package for python3.9`，将 `9` 改为更低（或更高）的数字，直到找到一个可用的版本。Python
    3 的依赖项在次要版本之间变化不大。
- en: 'If your Linux distribution uses the DNF package manager, such as if you’re
    on modern Fedora, RHEL, or CentOS, run the following commands:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Linux 发行版使用 DNF 包管理器，例如在现代的 Fedora、RHEL 或 CentOS 上，运行以下命令：
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you’re on an older version of Fedora or RHEL that uses the yum package manager,
    run the following commands:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是旧版本的 Fedora 或 RHEL，并且使用 yum 包管理器，可以运行以下命令：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you’re on SUSE Linux, you’ll have to install the dependencies, including
    needed libraries, one by one. [Table 2-1](#table2-1) lists these dependencies.
    If you’re on another UNIX-based system, this list will be helpful, although you
    may need to change the package names or build the dependencies from source.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 SUSE Linux，你需要逐一安装依赖项，包括所需的库。[表 2-1](#table2-1) 列出了这些依赖项。如果你使用的是其他 UNIX
    系统，这个列表会有所帮助，尽管你可能需要更改包名或从源代码构建依赖项。
- en: 'Table 2-1: Python 3 Build Dependencies According to SUSE Linux'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1：根据 SUSE Linux 的 Python 3 构建依赖项
- en: '| automake | intltool | netcfg |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| automake | intltool | netcfg |'
- en: '| fdupes | libbz2-devel | openssl-devel |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| fdupes | libbz2-devel | openssl-devel |'
- en: '| gcc | libexpat-devel | pkgconfig |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| gcc | libexpat-devel | pkgconfig |'
- en: '| gcc-c++ | libffi-devel | readline-devel |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| gcc-c++ | libffi-devel | readline-devel |'
- en: '| gcc-fortran | libnsl-devel | sqlite-devel |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| gcc-fortran | libnsl-devel | sqlite-devel |'
- en: '| gdbm-devel | lzma-devel | xz |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| gdbm-devel | lzma-devel | xz |'
- en: '| gettext-tools | make | zlib-devel |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| gettext-tools | make | zlib-devel |'
- en: '| gmp-devel | ncurses-devel |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| gmp-devel | ncurses-devel |  |'
- en: Downloading and Building Python
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下载和构建 Python
- en: You can download the Python source as a Gzipped source tarball, which is a compressed
    file (*.tgz*), from [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/).
    I usually like to move this tarball file into a dedicated directory for Python
    source tarballs, especially as I tend to have multiple versions of Python at any
    one time. Within that directory, extract (uncompress) this file with `tar -xzvf
    Python-3.x.x.tgz`, substituting the name of the tarball you downloaded.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [https://www.python.org/downloads/source/](https://www.python.org/downloads/source/)
    下载 Python 源代码作为 Gzipped 源代码 tarball，这是一种压缩文件 (*.tgz*)。我通常喜欢将这个 tarball 文件移到一个专门用于
    Python 源代码 tarball 的目录中，特别是当我通常同时拥有多个版本的 Python 时。在该目录中，使用 `tar -xzvf Python-3.x.x.tgz`
    解压（解压缩）此文件，替换你下载的 tarball 文件名。
- en: 'Next, from within the extracted directory, run the following, ensuring that
    each command succeeds before running the next one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在解压的目录中运行以下命令，确保每个命令成功执行后再执行下一个：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should configure Python for normal use, ensure it won’t encounter any errors
    in the current environment, and then install it *alongside* any existing Python
    installations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会配置 Python 以便正常使用，确保它在当前环境中不会遇到任何错误，然后将其 *与* 现有的 Python 安装一起安装。
- en: Once the installation is complete, you can use Python right away.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以立即使用 Python。
- en: Meet the Interpreter
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认识解释器
- en: Now that you’ve installed that interpreter, you can run Python scripts and projects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了这个解释器，你可以运行 Python 脚本和项目。
- en: Interactive Session
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式会话
- en: 'The interpreter’s *interactive session* allows you to enter and run code in
    real time and see the outcomes. You can start an interactive session on the command
    line with this command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器的 *交互式会话* 允许你实时输入并运行代码并查看结果。你可以使用以下命令在命令行启动交互式会话：
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Although the above should work on Windows, the same as on any other system,
    the Python documentation recommends the following alternative on Windows instead:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上述方法在 Windows 上也应当有效，就像在任何其他系统上一样，但 Python 文档推荐在 Windows 上使用以下替代方法：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just to keep everything system-agnostic, I’ll use `python3` throughout the rest
    of this book.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持系统无关性，我将在本书的剩余部分使用 `python3`。
- en: 'When you start the interactive session, you should see something that looks
    similar to this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动交互式会话时，你应该看到类似于以下内容的提示：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enter any Python code you want at the prompt `>`, and the interpreter will
    run it immediately. You can even enter multiline statements, such as conditional
    statements, and the interpreter will know more lines are expected before it runs
    the code. You’ll see the three-dot (`...`) prompt when the interpreter is waiting
    for more lines. When you’re done, press Enter on a blank line, and the interpreter
    will run the whole block:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符 `>` 下输入你想要的任何 Python 代码，解释器会立即执行它。你甚至可以输入多行语句，比如条件语句，解释器会知道在执行代码之前还需要更多的行。当解释器等待更多的行时，你会看到三点
    (`...`) 的提示。当你完成时，按空白行并回车，解释器会运行整个代码块：
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To quit the interactive session, run this command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出交互式会话，运行此命令：
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The interactive session is useful for testing things out in Python, but not
    much else. You should know of its existence moving forward, but I won’t use it
    much in this book. Instead, you should be using a proper code editor.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式会话在 Python 中进行测试时很有用，但除此之外没有太多用处。你应该知道它的存在，但在本书中我不会多加使用。相反，你应该使用合适的代码编辑器。
- en: Running Python Files
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 Python 文件
- en: You write scripts and programs in a text or code editor. I’ll introduce several
    code editors and IDEs at the end of this chapter, but in the meantime, you can
    use your favorite text editor for writing your code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你在文本或代码编辑器中编写脚本和程序。我将在本章末尾介绍几款代码编辑器和 IDE，但在此期间，你可以使用你最喜欢的文本编辑器来编写代码。
- en: 'Python code is written in *.py* files. To run a Python file (*myfile.py*, for
    example), you’d use this in the command line (*not* the interpreter):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Python 代码是写在*.py*文件中的。要运行一个 Python 文件（例如 *myfile.py*），你需要在命令行中使用这个命令（*不是*解释器）：
- en: '[PRE14]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Packages and Virtual Environments
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包和虚拟环境
- en: A *package* is a collection of code, which is analogous to a library in most
    other programming languages. Python is rather famous for being “batteries included,”
    since most things “just work” with a simple `import` statement. But if you need
    to do something beyond the basics, such as creating a snazzy user interface, you
    often have to install a package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*包*是代码的集合，在大多数其他编程语言中，它类似于一个库。Python 因为“自带电池”而颇为出名，因为大多数功能只需简单的`import`语句就能“直接使用”。但如果你需要做一些基本之外的事情，比如创建一个炫酷的用户界面，你通常需要安装一个包。'
- en: Thankfully, installing most third-party libraries is easy. Library authors bundle
    their libraries into packages, which can be installed using the handy little pip
    package manager tool that we installed earlier. I’ll cover that tool later.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，安装大多数第三方库非常简单。库的作者将他们的库打包成包，可以使用我们之前安装的便捷的 pip 包管理工具进行安装。我稍后会介绍这个工具。
- en: Using multiple third-party packages requires a bit of finesse. Some packages
    require other packages to be installed first. Certain packages have conflicts
    with other packages. You can also install specific versions of a package, depending
    on what exactly you need. Did I mention that some of the applications and operating
    system components on your computer rely on certain Python packages? This is why
    virtual environments exist.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个第三方包需要一些技巧。有些包需要先安装其他包。有些包与其他包存在冲突。你还可以根据需要安装特定版本的包。我提过吗？你计算机上的一些应用程序和操作系统组件依赖于特定的
    Python 包？这就是虚拟环境存在的原因。
- en: A *virtual environment* is a sandbox where you can install only the Python packages
    you need for a particular project, without the risk of those packages clashing
    with those for another project (or your system). You create different little sandboxes
    for each project and install only the packages you want in it. Everything stays
    neatly organized. You never actually change what Python packages are installed
    on your system, so you avoid breaking important things that have nothing to do
    with your project.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟环境*是一个沙箱，你可以在其中只安装某个特定项目所需的 Python 包，而不会有这些包与其他项目（或你的系统）中的包冲突的风险。你为每个项目创建不同的小沙箱，并只在其中安装你需要的包。一切都保持整洁有序。你从不真正改变系统上安装的
    Python 包，因此避免了破坏那些与项目无关的重要内容。'
- en: You may even create virtual environments that have nothing to do with a particular
    project. For example, I have a dedicated virtual environment for running random
    code files in Python 3.10, with a particular set of tools I use for finding problems.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以创建与特定项目无关的虚拟环境。例如，我有一个专门的虚拟环境，用于在 Python 3.10 中运行随机代码文件，并且有一组特定的工具我用来查找问题。
- en: Creating a Virtual Environment
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: Each virtual environment resides in a dedicated directory. Conventionally, we
    name this folder *env* or *venv*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟环境都位于一个专门的目录中。通常，我们将这个文件夹命名为*env*或*venv*。
- en: For each project, I typically like to create a dedicated virtual environment
    inside the project folder. Python provides a tool called *venv* for this.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个项目，我通常喜欢在项目文件夹中创建一个专门的虚拟环境。Python 提供了一个名为 *venv* 的工具来实现这一点。
- en: If you use Git or another *version control system* *(VCS)* for tracking changes
    to your code, there’s an additional setup step I’ll get to in a moment.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Git 或其他*版本控制系统*（*VCS*）来跟踪代码的更改，那么接下来有一步额外的设置我会介绍。
- en: 'To create the virtual environment with the name `venv` in the current working
    directory, run the following command in the command line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要在当前工作目录中创建一个名为 `venv` 的虚拟环境，可以在命令行中运行以下命令：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first `venv` ❶ is a command that creates a virtual environment, and the
    second `venv` ❷ is the desired path to the virtual environment. In this case,
    `venv` is just a relative path, creating a *venv/* directory in the current working
    directory. However, you could also use an absolute path, and you could call it
    whatever you want. For example, you could create a virtual environment called
    *myvirtualenv* in the */opt* directory of a UNIX system, like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`venv` ❶是一个用于创建虚拟环境的命令，而第二个`venv` ❷是虚拟环境的目标路径。在这个例子中，`venv` 只是一个相对路径，它会在当前工作目录下创建一个*venv/*目录。不过，你也可以使用绝对路径，并且可以根据需要命名它。例如，你可以在UNIX系统的*/opt*目录下创建一个名为*myvirtualenv*的虚拟环境，像这样：
- en: '[PRE16]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note, I’m specifying `python3` here, although I can run this with whatever Python
    version I want to use, such as `python3.9 -m venv venv`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在这里指定了`python3`，尽管我可以使用任何想要的Python版本运行这个命令，例如`python3.9 -m venv venv`。
- en: 'If you use something older than Python 3.3, make sure you install your system’s
    `virtualenv` package and then use this command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是早于Python 3.3的版本，确保先安装系统的`virtualenv`包，然后使用这个命令：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now if you look at your working directory, you’ll notice that the directory
    *venv/* has been created.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看你的工作目录，你会注意到*venv/*目录已经创建。
- en: Activating a Virtual Environment
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活虚拟环境
- en: To use your virtual environment, you need to activate it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用你的虚拟环境，你需要激活它。
- en: 'On UNIX-like systems, run this command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在类UNIX系统中，运行这个命令：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On Windows, run this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，运行这个：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, if you use PowerShell on Windows, run this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你在Windows上使用PowerShell，可以运行这个：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Some PowerShell users must first run `set-executionpolicy RemoteSigned` for
    virtual environments to work on Windows PowerShell. If you run into trouble, try
    this.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一些PowerShell用户必须首先运行`set-executionpolicy RemoteSigned`，才能让虚拟环境在Windows PowerShell中正常工作。如果遇到问题，请尝试这个。
- en: Like magic, you’re now using your virtual environment! You should see `(venv)`
    at the start of your command line prompt (not at the end), to indicate that you’re
    using a virtual environment named `venv`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 就像魔法一样，你现在正在使用你的虚拟环境！你应该能在命令行提示符的开始处看到`(venv)`（而不是结尾处），以表示你正在使用名为`venv`的虚拟环境。
- en: While inside your virtual environment, you can still access all the same files
    on your system that you use outside the virtual environment, but your environment
    *paths* will be overridden by the virtual environment. Practically speaking, any
    packages you install in the virtual environment are only usable there, and from
    the `venv`, the system-wide packages cannot be accessed unless you explicitly
    specify otherwise.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境中，你仍然可以访问系统上所有与虚拟环境外部使用的文件相同的文件，但你的环境*路径*会被虚拟环境覆盖。实际上，任何你在虚拟环境中安装的包只能在其中使用，而且从`venv`中无法访问系统范围的包，除非你明确指定。
- en: If you want the virtual environment to also see the system-wide packages, you
    can do so with a special flag, which has to be set when you first create the virtual
    environment. You can’t change this after the virtual environment is created.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望虚拟环境也能访问系统范围的包，可以通过一个特殊的标志来实现，必须在第一次创建虚拟环境时设置。虚拟环境创建后无法更改这一设置。
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Leaving a Virtual Environment
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 离开虚拟环境
- en: To get out of the virtual environment and back to reality . . . er, *ahem*,
    the system, you need a simple command.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要离开虚拟环境并回到现实……呃，*咳咳*，回到系统中，你只需要一个简单的命令。
- en: 'You ready for this, UNIX users? Just run this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗，UNIX用户？只需运行这个：
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That really is it. The same works for Windows PowerShell users.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。Windows PowerShell用户也可以使用相同的方法。
- en: 'Things are only slightly more complicated on the Windows command line:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows命令行中，事情稍微复杂一些：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Still pretty painless. Remember, like with activation, if you named your virtual
    environment something else, you’d have to change the `venv` in that line accordingly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 还是非常简单。记住，就像激活一样，如果你给虚拟环境起了别的名字，你需要在那一行中相应地修改`venv`。
- en: Introducing pip
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍pip
- en: Most of us have great expectations for Python’s package system. Python’s package
    manager is *pip*, which usually makes package installation trivial, especially
    in virtual environments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人对Python的包系统有很高的期望。Python的包管理器是*pip*，它通常使得包的安装变得非常简单，尤其是在虚拟环境中。
- en: System-Wide Packages
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统范围的包
- en: 'Remember, for any Python development work, you should almost always work in
    virtual environments. This will ensure that you’re always using the right packages
    for your work, without potentially messing up which packages (and versions thereof)
    are available to other programs on your computer. If you absolutely, positively
    know you want to install packages in your system-wide Python environment, you
    may use pip for that as well. First, make sure you are *not* working in a virtual
    environment, and then use this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于任何Python开发工作，你几乎总是应该在虚拟环境中工作。这样可以确保你始终使用适合你工作的正确包，而不会弄乱其他程序在你电脑上可用的包（及其版本）。如果你非常确定自己要在系统级别的Python环境中安装包，你也可以使用pip。首先，确保你*没有*在虚拟环境中工作，然后使用以下命令：
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Replace the `command` with your pip commands, which I’ll cover next.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将`command`替换为你的pip命令，我会在接下来的部分中介绍。
- en: Installing Packages
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装包
- en: 'To install a package, run `pip install` `package`. For example, to install
    PySide6 within an activated virtual environment, you’d use this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装包，运行`pip install` `package`。例如，要在已激活的虚拟环境中安装PySide6，你需要使用以下命令：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you want to install a specific version of something, append two equal signs
    (`==`), followed by the desired version number (no spaces):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想安装某个特定版本，可以在版本号后面加上两个等号（`==`），并跟上所需的版本号（不加空格）：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Bonus: you can even use operators like `>=`, to mean “at least this version
    or greater.” These are called *requirement specifiers*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 额外提示：你甚至可以使用像`>=`这样的操作符，表示“至少这个版本或更高”。这些被称为*需求说明符*。
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That line would install the latest version of PySide6 that is at least version
    `6.1.2`. This is really helpful if you want the most recent version of a package
    but also want to ensure you at least install a *minimum* version of a package
    (you might not). If it isn’t possible to install a version of the package that
    meets the requirement, pip will display an error message.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将安装至少为`6.1.2`的PySide6最新版本。如果你想要最新版本的包，但也希望确保至少安装包的*最低*版本（可能不需要），这非常有用。如果无法安装符合要求的包版本，pip会显示错误信息。
- en: If you’re on a UNIX-like system, you may need to use `pip install "PySide6>=6.1.2"`
    instead, since `>` has another meaning in the shell.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是类UNIX系统，你可能需要改用`pip install "PySide6>=6.1.2"`，因为`>`在shell中有另一层含义。
- en: requirements.txt
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: requirements.txt
- en: You can save even more time for yourself and others by writing a *requirements.txt*
    file for your project. This file lists the packages your project needs. When creating
    a virtual environment, you and other users can install all the required packages
    with a single command, using this file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为你的项目编写*requirements.txt*文件，你可以为自己和其他人节省更多的时间。该文件列出了项目所需的所有包。在创建虚拟环境时，你和其他用户可以使用这个文件，通过一个命令安装所有必需的包。
- en: 'To create this file, list the name of a pip package, as well as its version
    (if required), on each line. For example, one of my projects has a *requirements.txt*
    file like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个文件，在每一行列出一个pip包的名称，以及其版本（如果需要）。例如，我的一个项目有这样一个*requirements.txt*文件：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 2-1: *requirements.txt*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-1：*requirements.txt*
- en: 'Now anyone can install all those packages in one shot with this command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何人都可以通过以下命令一次性安装所有这些包：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I’ll revisit *requirements.txt* in Chapter 18, when I cover packaging and distribution.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第18章中重新提到*requirements.txt*，当时我会讲解打包和分发。
- en: Upgrading Packages
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级包
- en: 'You can update an already-installed package with pip as well. For example,
    to update to the latest version of PySide6, run this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用pip更新已安装的包。例如，要更新到最新版本的PySide6，请运行以下命令：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you have a *requirements.txt* file, you can also upgrade all your required
    packages at once:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有*requirements.txt*文件，你也可以一次性升级所有所需的包：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Removing Packages
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除包
- en: 'You can remove packages with this command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令删除包：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Replace `package` with the package name.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将`package`替换为包的名称。
- en: There is one minor wrinkle. Installing one package will also install any other
    packages it relies upon, which we call its *dependencies*. Uninstalling a package
    does not remove its dependencies, so you may need to go through and remove them
    yourself. This can get tricky, since multiple packages may share dependencies
    and you therefore risk breaking a separate package.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个小小的问题。安装一个包时，它也会安装所有它依赖的其他包，这些我们称之为*依赖项*。卸载一个包并不会移除它的依赖项，因此你可能需要自己去手动删除它们。这可能会变得棘手，因为多个包可能共享依赖项，从而有可能破坏其他包。
- en: Herein lies one more advantage of virtual environments. Once I’m in that sort
    of a pickle, I can delete the virtual environment, create a new one, and install
    only those packages I need.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是虚拟环境的另一个优势所在。一旦遇到这种困境，我可以删除虚拟环境，创建一个新的，并且仅安装我需要的那些软件包。
- en: Finding Packages
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找软件包
- en: Great, so now you can install, upgrade, and remove things. But how do you even
    know what packages pip has to offer?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在你可以安装、升级和删除软件包了。但是你怎么知道 pip 提供了哪些软件包呢？
- en: 'There are two ways to find out. The first is to use pip itself to run a search.
    Say you want a package for web scraping. Run this command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以找出这些软件包。第一种是使用 pip 自身进行搜索。假设你想找一个用于网页抓取的包，可以运行这个命令：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That will give you a whole ton of results to sift through, but it’s helpful
    at those times when you simply forget the name of a package.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给你带来大量的结果需要筛选，但在你忘记一个软件包的名字时，这非常有帮助。
- en: If you want something a lot more browsable and informative, [https://pypi.org/](https://pypi.org/%20)
    is the official Python Package Index.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个更易浏览和更具信息性的资源，[https://pypi.org/](https://pypi.org/%20) 是官方的 Python 包索引。
- en: One Warning About pip . . .
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于 pip 的一个警告...
- en: Unless you have expertise in the full technical implications, ***never*** use
    `sudo pip` on a UNIX-like system! It can do so many bad things to your system
    installation—things that your system package manager cannot correct—that if you
    decide to use it, you will regret it for the remainder of your system’s lifetime.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你精通所有技术细节，***绝对不要*** 在类 UNIX 系统上使用 `sudo pip`！它可能会对你的系统安装造成很多坏影响——这些是系统包管理器无法修复的问题——如果你决定使用它，你会为你的系统的一生感到后悔。
- en: Usually, when someone thinks they need to use `sudo pip`, they should really
    use `python3 -m pip` or `pip install --user` to install to their local user directory.
    Most other problems can be solved with virtual environments. Unless you’re an
    expert who fully understands what you’re doing and how to reverse it, don’t *ever*
    use `sudo pip`!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当有人认为他们需要使用 `sudo pip` 时，他们实际上应该使用 `python3 -m pip` 或 `pip install --user`
    来安装到本地用户目录。其他大多数问题可以通过虚拟环境来解决。除非你是一个完全理解自己在做什么并且知道如何恢复的专家，否则*绝对不要*使用 `sudo pip`！
- en: Virtual Environments and Git
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟环境和 Git
- en: Working with virtual environments and a VCS, like Git, can be tricky. Within
    a virtual environment’s directory are the *actual packages* you installed with
    pip. Those would clutter up your VCS repository with big, unnecessary files, and
    you can’t necessarily copy a virtual environment folder from one computer to another
    and expect it to work anyway.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟环境和版本控制系统（VCS），比如 Git，可能会有点棘手。在虚拟环境的目录中是你通过 pip 安装的*实际软件包*。这些会把你的 VCS 仓库弄得杂乱无章，充满不必要的大文件，而且你也不能指望将一个虚拟环境文件夹从一台电脑复制到另一台电脑上并且它依然能够正常工作。
- en: 'Thus, you *don’t* want to track these files in your VCS. There are two solutions:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你*不*希望在 VCS 中跟踪这些文件。有两种解决方案：
- en: Only create virtual environments outside of your repository.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只在仓库外部创建虚拟环境。
- en: Untrack the virtual environment directory in the VCS.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在版本控制系统中取消跟踪虚拟环境目录。
- en: There are arguments in favor of both rules, but which one you should use really
    depends on your project, environment, and particular needs.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对这两条规则都有支持的论据，但你应该使用哪一条实际上取决于你的项目、环境和具体需求。
- en: 'If you’re using Git, create or edit a file called *.gitignore* in the root
    directory of your repository. Add this line somewhere in it:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Git，在你的仓库根目录下创建或编辑一个名为 *.gitignore* 的文件。并在文件中添加以下内容：
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 2-2: *.gitignore*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-2: *.gitignore*'
- en: If you used a different name for your virtual environment, change that line
    to match. If you’re using a different VCS, like Subversion or Mercurial, check
    the documentation to see how to ignore a directory like *venv*.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为虚拟环境使用了不同的名称，请修改该行以匹配。如果你使用的是其他版本控制系统，如 Subversion 或 Mercurial，请查阅文档了解如何忽略像
    *venv* 这样的目录。
- en: Conventionally, every developer who clones your repository will build their
    own virtual environment, probably using that *requirements.txt* file you provided.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，每个克隆你仓库的开发者都会建立他们自己的虚拟环境，可能是使用你提供的 *requirements.txt* 文件。
- en: Even if you plan to place your virtual environments outside of the repository,
    it’s good to use your *.gitignore* file, just as a little extra insurance. Best
    VCS practice is to handpick which files to commit, but mistakes happen. Since
    *venv* is one of the most conventional names for a virtual environment directory,
    adding it to the *.gitignore* at least helps prevent some accidental commits.
    If your team has other standard names for virtual environments, you might consider
    adding those as well.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你计划将虚拟环境放在代码库外部，使用 *.gitignore* 文件也是个好主意，就像额外的保险一样。最佳的版本控制系统（VCS）实践是精确选择需要提交的文件，但错误总是会发生。由于
    *venv* 是虚拟环境目录的最常见名称，将其添加到 *.gitignore* 至少有助于避免一些意外提交。如果你的团队有其他标准的虚拟环境名称，也可以考虑将它们添加进去。
- en: The Whole Shebang
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整的 Shebang
- en: Many users and developers who might be running your code will also be using
    virtual environments. Yet all of this can come apart at the seams very easily
    if the very first line of your Python file is wrong.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 许多可能运行你代码的用户和开发者也会使用虚拟环境。然而，如果你的 Python 文件的第一行是错误的，所有这些都很容易出错。
- en: 'I’m talking about the *shebang*, a special command at the top of a Python file,
    by which you can make that file directly executable:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我在说的是 *shebang*，它是 Python 文件顶部的一个特殊命令，允许你直接使该文件可执行：
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 2-3: *hello_world.py*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-3: *hello_world.py*'
- en: 'The shebang (short for haSH-BANG, or `#!`) ❶ provides the path to the Python
    interpreter. While it’s optional, I strongly recommend including it in your code,
    as it means the file can be marked as executable and run directly, like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Shebang（简称 haSH-BANG 或 `#!`）❶ 提供了 Python 解释器的路径。虽然它是可选的，但我强烈建议在代码中包含它，因为这意味着文件可以被标记为可执行文件，并且可以直接运行，如下所示：
- en: '[PRE36]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is helpful, but as I’ve hinted before, one must be careful with shebangs.
    A shebang tells the computer where to find the exact Python interpreter to use,
    so the wrong shebang can break out of the confines of a virtual environment or
    even point to a version of the interpreter that isn’t installed.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有帮助，但正如我之前所暗示的，使用 shebang 时必须小心。Shebang 告诉计算机在哪里找到正确的 Python 解释器，所以错误的 shebang
    可能会突破虚拟环境的限制，甚至指向一个未安装的解释器版本。
- en: 'You may have seen this kind of shebang in the wild:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在实际使用中见过这种 shebang：
- en: '[PRE37]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 2-4: *shebang.py:1a*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-4: *shebang.py:1a*'
- en: That line is terribly wrong, because it forces the computer to use a particular
    system-wide copy of Python. Again, that dismisses the entire purpose of a virtual
    environment.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 那行是完全错误的，因为它强迫计算机使用系统中的某个特定的 Python 版本。再次强调，这完全忽视了虚拟环境的作用。
- en: 'Instead, you should always use this shebang for any Python file that only runs
    with Python 3:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你应该始终为任何仅在 Python 3 中运行的 Python 文件使用这个 shebang：
- en: '[PRE38]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 2-5: *shebang.py:1b*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-5: *shebang.py:1b*'
- en: 'If you happen to have a script which runs in *both* Python 2 and Python 3,
    use this shebang instead:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你恰好有一个既在 *Python 2* 又在 *Python 3* 中运行的脚本，应该使用这个 shebang：
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 2-6: *shebang.py:1c*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-6: *shebang.py:1c*'
- en: The rules about shebangs and how they are handled are officially outlined in
    PEP 394 (for UNIX-like systems) and PEP 397 (for Windows systems). Regardless
    of which system you develop for, it’s good to understand the implications of shebangs
    in both UNIX and Windows.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 shebang 及其处理方式的规则在 PEP 394（针对类 UNIX 系统）和 PEP 397（针对 Windows 系统）中有正式的说明。无论你开发的是哪个系统，了解
    shebang 在 UNIX 和 Windows 中的影响都是很有必要的。
- en: File Encoding
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件编码
- en: Since Python 3.1, all Python files have used the *UTF-8 encoding*, allowing
    the interpreter to use all of the characters in Unicode. (Prior to that version,
    the default was to use the old ASCII encoding.)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.1 开始，所有 Python 文件都使用 *UTF-8 编码*，这使得解释器可以使用 Unicode 中的所有字符。（在该版本之前，默认的是使用旧的
    ASCII 编码。）
- en: If you need to use a different encoding system, instead of the default UTF-8,
    you need to tell the Python interpreter that outright.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用不同的编码系统，而不是默认的 UTF-8，你需要明确告诉 Python 解释器。
- en: 'For example, to use Latin-1 encoding in a Python file, include this line at
    the top of your file, right below the shebang. To work, it must be on the first
    or second line—that’s where the interpreter looks for this information:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在 Python 文件中使用 Latin-1 编码，可以在文件顶部的 shebang 下方包含这一行。为了生效，它必须位于第一行或第二行——因为解释器会在这里查找这些信息：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you want another encoding system, replace `latin-1` with whatever you need.
    If you specify an encoding that Python doesn’t recognize, it will throw an error.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用其他编码系统，可以将 `latin-1` 替换为你需要的编码。如果你指定了一个 Python 不认识的编码，它会抛出错误。
- en: 'Although the preceding is the conventional way to specify encoding, there are
    two other valid ways to write the above comment. You can use this form, without
    the hard-to-remember `-*-`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上述是指定编码的传统方式，但还有两种有效的方式可以编写上述注释。你可以使用这种形式，无需记住复杂的 `-*-`：
- en: '[PRE41]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or you can use this longer but more English-like form:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用这种更长但更像英语的形式：
- en: '[PRE42]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Whatever you use, it must be *exactly* as shown above, except for swapping `latin-1`
    for whatever encoding you want. For this reason, the first or second forms are
    preferred.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么，它必须*完全*与上述显示一致，除了将 `latin-1` 替换为你想要的编码。因此，首选第一种或第二种形式。
- en: To learn more, read PEP 263, which defined this feature.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息，请阅读 PEP 263，它定义了这个功能。
- en: Most of the time, you’ll be fine using the default UTF-8 encoding anyway; if
    you need something else, now you know how to inform the interpreter.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，使用默认的 UTF-8 编码就足够了；如果需要其他编码，现在你知道如何告知解释器了。
- en: A Few Extra Virtual Environment Tricks
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些额外的虚拟环境技巧
- en: 'As you get used to using virtual environments and pip, you’ll pick up additional
    tricks and tools to make the whole process easier. Here are a few of the more
    popular ones:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你逐渐习惯使用虚拟环境和 pip，你将掌握一些额外的技巧和工具，使整个过程更加轻松。以下是一些比较流行的工具：
- en: Using a Virtual Environment Without Activating
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不激活虚拟环境的情况下使用
- en: You can use the binaries that are a part of the virtual environment without
    activating it. For example, you can execute `venv/bin/python` to run the virtual
    environment’s own Python instance, or `venv/bin/pip` to run its instance of pip.
    It’ll work the same as if you had activated the virtual environment.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不激活虚拟环境的情况下使用虚拟环境中的二进制文件。例如，你可以执行 `venv/bin/python` 来运行虚拟环境中的 Python 实例，或者执行
    `venv/bin/pip` 来运行其 pip 实例。它的工作方式与激活虚拟环境相同。
- en: 'For example, assuming my virtual environment is `venv`, I could do this in
    the terminal:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我的虚拟环境是 `venv`，我可以在终端中执行以下操作：
- en: '[PRE43]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It works! Yet, `import pylint` still will not work on the system-wide Python
    interactive shell (unless, of course, you installed it on the system).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效！不过，`import pylint` 在系统级 Python 交互式 shell 上仍然无法使用（除非你已经在系统上安装了它）。
- en: The Alternatives
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代方案
- en: Throughout this book, I’ll be using pip and `venv`, as they’re the default tools
    for modern Python. However, there are a few other solutions out there worth looking
    into.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将使用 pip 和 `venv`，因为它们是现代 Python 的默认工具。然而，市面上还有一些其他值得关注的解决方案。
- en: Pipenv
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pipenv
- en: A number of Python developers swear by *Pipenv*, which combines both pip and
    `venv` into one cohesive tool, with many additional features.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Python 开发者非常推崇 *Pipenv*，它将 pip 和 `venv` 结合成一个统一的工具，并提供了许多附加功能。
- en: Because the workflow is quite different, I won’t cover Pipenv here. If you’re
    interested in it, I recommend reading their superb documentation at [https://docs.pipenv.org/](https://docs.pipenv.org/).
    You’ll find comprehensive setup and usage instructions there, as well as a more
    detailed explanation of the advantages Pipenv offers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工作流程有很大不同，我在这里不会讲解 Pipenv。如果你对它感兴趣，建议阅读他们出色的文档 [https://docs.pipenv.org/](https://docs.pipenv.org/)。你会在那里找到完整的安装和使用说明，以及
    Pipenv 提供的优势的更详细解释。
- en: pip-tools
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pip-tools
- en: A number of tasks in pip can be simplified with pip-tools, including automatic
    updating, aids for writing *requirements.txt*, and more.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: pip 中的许多任务可以通过 pip-tools 简化，包括自动更新、编写 *requirements.txt* 的辅助工具等。
- en: If you use pip-tools, you should only install it within a virtual environment.
    It is designed specifically for that use case.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 pip-tools，应该仅在虚拟环境中安装它。它专门为这种用例设计。
- en: More information is available at [https://pypi.org/project/pip-tools/](https://pypi.org/project/pip-tools/).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请访问 [https://pypi.org/project/pip-tools/](https://pypi.org/project/pip-tools/)。
- en: poetry
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: poetry
- en: Some Python developers absolutely hate the entire pip workflow. One such developer
    created *poetry* as an alternative package manager. I don’t use it in this book,
    as it behaves very differently, but I’d be remiss not to point it out.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Python 开发者非常讨厌整个 pip 工作流。一位开发者创建了 *poetry* 作为替代的包管理器。我在本书中没有使用它，因为它的行为方式与
    pip 大不相同，但如果不提到它，我会感到失职。
- en: 'You can find more information, download directions (the creator does not recommend
    using pip to install it), and access documentation on their website: [https://python-poetry.org/](https://python-poetry.org/).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在他们的网站上找到更多信息、下载指南（创作者不建议使用 pip 安装）以及文档：[https://python-poetry.org/](https://python-poetry.org/)。
- en: Introduction to PEP 8
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEP 8 简介
- en: Unlike many languages, where style decisions are left entirely to the discretion
    of the community at large, Python does have an official style guide, which is
    published as *PEP 8*. Although the conventions in the guide are intended primarily
    for standard library code, many Python developers choose to stick to them as a
    rule.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '与许多语言不同，在这些语言中，风格决策完全由社区自由决定，Python有官方的风格指南，即*PEP 8*。尽管该指南中的规范主要是针对标准库代码，但许多Python开发者选择将其作为规则来遵循。  '
- en: 'That doesn’t make them mandatory: if you have an objective reason to follow
    a different style convention in your project, that’s fine, although you should
    apply that style consistently, as much as is reasonable.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '这并不意味着它们是强制性的：如果你有客观的理由在你的项目中遵循不同的风格规范，那是可以的，尽管你应该尽可能一致地应用该风格，合理范围内。  '
- en: 'PEP 8 itself makes this distinction clear, early on:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'PEP 8本身在早期就明确做出了这一区分：  '
- en: A style guide is about consistency. Consistency with this style guide is important.
    Consistency within a project is more important. Consistency within one module
    or function is the most important.
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '风格指南关乎一致性。遵守此风格指南的一致性很重要。在一个项目内保持一致性更为重要。在一个模块或函数内保持一致性是最重要的。  '
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, know when to be inconsistent—sometimes, style guide recommendations
    just aren’t applicable. When in doubt, use your best judgment. Look at other examples
    and decide what looks best. And don’t hesitate to ask!
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '然而，要知道何时打破一致性——有时候，风格指南的建议并不适用。当有疑问时，使用你最好的判断力。查看其他示例，决定什么看起来最合适。并且不要犹豫，向他人请教！  '
- en: In practice, you’ll likely find very little reason to deviate from PEP 8\. The
    style guide is far from all-encompassing. It leaves plenty of breathing room,
    while making it clear what constitutes a good or bad coding style.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，你可能很少需要偏离PEP 8。风格指南远非包罗万象。它留下了很多余地，同时明确了什么样的编码风格是好的，什么样的是不好的。  '
- en: The Line Limit Debate
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '行限制辩论  '
- en: PEP 8 recommends a line limit of 79 characters, or an 80-character cutoff, though
    there’s a lot of debate on the topic. Some Python developers respect that rule,
    while others prefer cutoffs of 100 or 120 characters. What to do?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'PEP 8推荐的行限制是79个字符，或者80个字符的上限，尽管这个话题有很多争议。一些Python开发者遵守这个规则，而另一些人则更喜欢100或120个字符的上限。该怎么办呢？  '
- en: 'The most common argument for longer limits is that modern monitors are wider
    and higher resolution. Surely, the 80-character limit is a relic of a bygone era,
    right? ***Definitely not!*** There are several reasons to stick to a common line
    limit. For example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '最常见的关于更长限制的论点是，现代显示器更宽且分辨率更高。当然，80个字符的限制是过去时代的遗物，对吧？***绝对不是！*** 坚持使用常见的行限制有几个原因。例如：  '
- en: Vision-impaired individuals who must work with larger font sizes or zoomed-in
    interfaces
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '视力受损的人必须使用更大的字体或放大界面  '
- en: Viewing differences in a file between commits in a side-by-side diff
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在提交之间查看文件差异时的并排比较  '
- en: Split-screen editors, displaying multiple files simultaneously
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '分屏编辑器，同时显示多个文件  '
- en: Vertical monitors
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '垂直显示器  '
- en: Side-by-side windows on a laptop monitor, wherein the editor only has half its
    usual space
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '笔记本显示器上的并排窗口，其中编辑器只有通常空间的一半  '
- en: Individuals with older monitors, who cannot afford to upgrade to the latest
    1080p monster
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用较旧显示器的个人，他们无法负担升级到最新的1080p大显示器  '
- en: Viewing code on mobile devices
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在移动设备上查看代码  '
- en: Writing coding books for No Starch Press
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '为No Starch Press编写编程书籍  '
- en: 'In all of these scenarios, the reasoning behind the 80-character limit becomes
    apparent: there simply isn’t enough horizontal space for 120 characters or more
    per line. Soft text wrapping, wherein the remainder of a cut-off line appears
    on a separate line (without a line number), does solve some of these issues. However,
    it can be difficult to read, as many people forced to rely on it regularly will
    attest to.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些场景中，80字符限制背后的理由变得显而易见：每行120个字符或更多，横向空间实在不够。软文本换行，即将被截断的行的其余部分显示在另一行（没有行号），确实解决了一些问题。然而，它可能难以阅读，许多人被迫经常依赖它的人可以证明这一点。
- en: 'This doesn’t mean that you have to follow this 79-character maximum religiously.
    There are exceptions. Above all, *readability* and *consistency* are the goals.
    Many developers embrace the 80/100 rule: an 80-character “soft” cutoff, you try
    to respect in most cases; and a 100-character “hard” cutoff, you reserve for all
    those cases where the lower limit would negatively impact readability.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着您必须严格遵守 79 字符的最大限制。也有例外情况。最重要的是，*可读性* 和 *一致性* 是目标。许多开发人员采用 80/100 规则：80
    字符“软”限制，尽量遵守；100 字符“硬”限制，适用于所有低于此限制会影响可读性的情况。
- en: Tabs or Spaces?
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tab 还是空格？
- en: Ah yes, the civil war over which many friendships have been strained and many
    relationships have abruptly ended (okay, maybe just that one?). Most programmers
    have strong feelings on the topic.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，是的，关于这个话题的内战已经让许多友谊变得紧张，甚至一些关系突然破裂（好吧，也许只有那一次？）。大多数程序员对此有强烈的看法。
- en: PEP 8 recommends spaces over tabs, but technically, it allows either. The important
    thing is to *never mix the two*. Use either spaces or tabs, and stick to it throughout
    your entire project.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 推荐使用空格而非 Tab，但从技术上讲，它允许两者。重要的是 *永远不要混用两者*。在整个项目中，要么使用空格，要么使用 Tab，并始终坚持一致。
- en: 'If you do use spaces, then there’s the debate about how many spaces to use.
    PEP 8 answers this question, too: *four spaces per indentation level*. Any less
    can negatively impact code readability, especially for people with visual impairments
    or some forms of dyslexia.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实使用空格，那么就会有关于使用多少空格的争论。PEP 8 也回答了这个问题：*每个缩进级别使用四个空格*。使用更少的空格可能会影响代码的可读性，特别是对于视力障碍者或一些阅读障碍者。
- en: By the way, most code editors are able to automatically enter four spaces when
    they press Tab, so there’s rarely an excuse to press space repeatedly.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，大多数代码编辑器都能够在按下 Tab 键时自动输入四个空格，因此很少需要反复按空格键。
- en: 'Quality Control: Static Analyzers'
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 质量控制：静态分析器
- en: One of the most useful tools in any programmer’s toolkit is a reliable *static
    analyzer*, which reads your source code, looking for potential problems or deviations
    from the standards. If you’ve never used one before, now is the time to change
    that. One common type of static analyzer, called a *linter*, checks your source
    code for common mistakes, potential errors, and style inconsistencies. Two of
    the most popular linters are *Pylint* and *PyFlakes*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何程序员的工具包中，最有用的工具之一就是可靠的 *静态分析器*，它可以读取源代码，寻找潜在问题或偏离标准的地方。如果您从未使用过它们，现在是时候开始了。静态分析器中的一种常见类型叫做
    *linter*，它检查源代码中常见的错误、潜在问题和风格不一致。最流行的两个 linter 是 *Pylint* 和 *PyFlakes*。
- en: There are many more kinds of static analyzers available for Python, including
    static type checkers like *Mypy* and complexity analyzers like *mccabe*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有许多其他类型的静态分析工具，包括静态类型检查工具，如 *Mypy* 和复杂度分析工具，如 *mccabe*。
- en: I’ll cover how to install all of these below, and I’ll discuss how to use many
    of them. I recommend you choose only one of these two linters and install the
    rest of the static analyzers.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下面介绍如何安装所有这些工具，并讨论如何使用其中的许多工具。我建议您只选择其中一种 linter，并安装其余的静态分析工具。
- en: Pylint
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pylint
- en: Pylint is perhaps the most versatile static analyzer in Python. It works decently
    well by default, and it allows you to customize exactly what you want it to look
    for and ignore.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 可能是 Python 中最通用的静态分析工具。它默认工作得相当好，而且允许您自定义要检测和忽略的内容。
- en: 'You can install the Pylint package with pip, which I recommend doing in a virtual
    environment. Once installed, you pass Pylint the name of a file you want analyzed,
    like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 pip 安装 Pylint 包，我推荐在虚拟环境中安装。安装完成后，您可以将 Pylint 与要分析的文件名一起传递，例如：
- en: '[PRE44]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can also analyze an entire package or module at once. (I’ll define what
    modules and packages are in Chapter 4.) For example, if you want Pylint to analyze
    a package called `myawesomeproject` in the current working directory, you’d run
    this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以一次分析整个包或模块。（我将在第 4 章定义模块和包的概念。）例如，如果您想让 Pylint 分析当前工作目录下名为 `myawesomeproject`
    的包，可以运行以下命令：
- en: '[PRE45]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Pylint will scan the files and display its warnings and recommendations on the
    command line. Then, you can edit your file and make the necessary changes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 会扫描文件并在命令行显示其警告和建议。然后，您可以编辑文件并进行必要的更改。
- en: 'For example, consider the following Python file:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下 Python 文件：
- en: '[PRE46]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 2-7: *cooking.py:1a*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 2-7: *cooking.py:1a*'
- en: 'I’ll run the linter on that file with the following in the system command line:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用以下命令在系统命令行中运行 linter 来分析该文件：
- en: '[PRE47]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Pylint provides the following feedback:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint 提供了以下反馈：
- en: '[PRE48]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The linter found five errors in my code: both the module and the function are
    missing their docstrings (see Chapter 3). I tried to use the variables `eggs`
    and `order`, neither of which exist. I also assigned a value to the variable `ham`,
    but I never used that value anywhere.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: linter 在我的代码中发现了五个错误：模块和函数都缺少 docstring（见第 3 章）。我尝试使用 `eggs` 和 `order` 这两个变量，但它们并不存在。我还给变量
    `ham` 赋了一个值，但我从未在任何地方使用过这个值。
- en: 'If Pylint takes umbrage at a particular line of code you feel should be left
    as is, you can tell the static analyzer to ignore it and move on. You do this
    with a special comment, either inline on the line in question or at the top of
    the affected block. For example:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Pylint 对你觉得应该保留的某行代码提出异议，你可以告诉静态分析工具忽略它并继续。你可以使用一个特殊的注释来实现这一点，既可以在相关行内使用，也可以在受影响的代码块顶部使用。例如：
- en: '[PRE49]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 2-8: *cooking.py:1b*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-8: *cooking.py:1b*'
- en: 'With the first command, I tell Pylint not to alert me about the missing docstring
    on the module; that affects the entire block of code. The inline comment on the
    next line will suppress the warning about the missing docstring on the function,
    and it will only affect that line. If I ran the linter again, I’d only see the
    other two linter errors:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一个命令，我告诉 Pylint 不要提醒我模块缺少 docstring；这会影响整个代码块。下一行的内联注释会抑制函数缺少 docstring 的警告，只会影响该行。如果我再次运行
    linter，我只会看到其他两个 linter 错误：
- en: '[PRE50]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At this point, I’d edit my code and actually fix the rest of those problems.
    (Except I won’t, for this example.)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我会编辑我的代码并实际修复其余的问题。（不过为了这个例子，我不会这么做。）
- en: 'You can also control Pylint’s project-wide behavior by creating a *pylintrc*
    file in the root directory of your project. To do this, run the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在项目的根目录中创建一个 *pylintrc* 文件来控制 Pylint 的全局行为。要做到这一点，请运行以下命令：
- en: '[PRE51]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Find that file; open it; and edit it to turn on and off different warnings,
    ignore files, and define other settings. The documentation isn’t fantastic for
    this, but you can often work out what different options do from the comments in
    that *pylintrc* file.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 找到那个文件，打开它，并编辑它以开启或关闭不同的警告，忽略文件，并定义其他设置。关于这一点的文档并不是特别详细，但你通常可以通过该 *pylintrc*
    文件中的注释推测不同选项的作用。
- en: 'When you run Pylint, it will look for a *pylintrc* (or *.pylintrc*) file in
    the current working directory. Alternatively, you can specify a different filename
    for Pylint to read its settings from, such as *myrcfile*, by passing the filename
    to the `--rcfile` option when invoking Pylint:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 Pylint 时，它会在当前工作目录中查找 *pylintrc*（或 *.pylintrc*）文件。或者，你可以指定一个不同的文件名供 Pylint
    读取其设置，比如 *myrcfile*，通过在调用 Pylint 时传递 `--rcfile` 选项来实现：
- en: '[PRE52]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Some regular users of Pylint like to create `.pylintrc` or `.config/pylintrc`
    in their home directory (UNIX-like systems only). If Pylint cannot find another
    configuration file, it will use the one in the home directory.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Pylint 的常规用户喜欢在他们的主目录中创建 `.pylintrc` 或 `.config/pylintrc` 文件（仅限类 UNIX 系统）。如果
    Pylint 找不到其他配置文件，它将使用主目录中的那个文件。
- en: Although the Pylint documentation is far from comprehensive, it can still be
    useful. You can find it at [https://pylint.readthedocs.io/](https://pylint.readthedocs.io/).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Pylint 的文档远不是详尽无遗，但它仍然是有用的。你可以在 [https://pylint.readthedocs.io/](https://pylint.readthedocs.io/)
    找到它。
- en: Flake8
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flake8
- en: 'The *Flake8* tool is actually a combination of three static analyzers:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flake8* 工具实际上是三个静态分析工具的组合：'
- en: '*PyFlakes* is a linter, similar in purpose to Pylint. It is designed to work
    faster and to avoid false positives (both being common complaints about Pylint).
    It also ignores style rules, which are handled by the next tool.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PyFlakes* 是一个 linter，功能类似于 Pylint。它的设计目的是提高速度并避免假阳性（这两者都是 Pylint 常见的抱怨）。它还忽略了样式规则，后续工具会处理这些。'
- en: '*pycodestyle* is a style checker, to help ensure you write PEP 8-compliant
    code. (This tool used to be called `pep8`, but it was renamed to avoid confusion
    with the actual style guide.)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pycodestyle* 是一个样式检查工具，帮助确保你编写符合 PEP 8 的代码。（这个工具以前叫做 `pep8`，但为了避免与实际的样式指南混淆，它已被重命名。）'
- en: '*mccabe* checks the McCabe (or Cyclomatic) complexity of your code. If you
    don’t know what that is, don’t worry—its purpose is essentially just to warn you
    when your code’s structure is getting too complicated.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mccabe* 检查你的代码的 McCabe（或圈复杂度）复杂度。如果你不知道那是什么，不用担心——它的主要目的是在你的代码结构变得过于复杂时提醒你。'
- en: You can install the Flake8 package with pip, which I typically do within a virtual
    environment.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 pip 安装 Flake8 包，我通常是在虚拟环境中进行安装。
- en: 'To scan a file, module, or package, pass it to `flake8` on the command line.
    For example, to scan my earlier *cooking.py* file ([Listing 2-8](#listing2-8)),
    I’d use this command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要扫描一个文件、模块或包，只需在命令行中将其传递给 `flake8`。例如，要扫描我之前的 *cooking.py* 文件（[列表 2-8](#listing2-8)），我会使用以下命令：
- en: '[PRE53]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That outputs the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE54]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: (You’ll notice that Flake8 isn’t complaining about the lack of docstrings; that’s
    disabled by default in this linter.)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: （你会注意到，Flake8 并没有抱怨缺少 docstrings；这是默认在这个 linter 中被禁用的。）
- en: 'By default, only PyFlakes and pycodestyle are run. If you want to analyze the
    complexity of your code, you also need to pass the argument `--max-complexity`,
    followed by a number. Anything higher than `10` is considered too complex, but
    if you understand McCabe complexity, you can change this to suit your needs. So,
    for example, to check the complexity of the *cooking.py* file, you’d run this:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只会运行 PyFlakes 和 pycodestyle。如果你想分析代码的复杂性，还需要传递 `--max-complexity` 参数，后跟一个数字。任何大于
    `10` 的值都被认为过于复杂，但如果你理解 McCabe 复杂度，可以根据需要调整此值。所以，例如，要检查 *cooking.py* 文件的复杂度，你可以运行以下命令：
- en: '[PRE55]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However you run Flake8, you’ll get a comprehensive list of all the errors and
    warnings in your code.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何运行 Flake8，你都会得到一份代码中的所有错误和警告的完整列表。
- en: If you need to tell Flake8 to ignore something it thinks is a problem, you use
    a `# noqa` comment, followed by the error code to ignore. This comment should
    be inline, on the line where the error occurs. If you omit the error code, then
    `# noqa` will cause Flake8 to ignore all errors on that line.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要告诉 Flake8 忽略它认为是问题的部分，可以使用 `# noqa` 注释，后跟要忽略的错误代码。这个注释应该在发生错误的行内。如果你省略了错误代码，`#
    noqa` 将导致 Flake8 忽略该行的所有错误。
- en: 'In my code, if I wanted to ignore both of the errors I received, it might look
    like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的代码中，如果我想忽略收到的两个错误，它可能看起来像这样：
- en: '[PRE56]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 2-9: *cooking.py:1c*'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-9：*cooking.py:1c*
- en: Here, you see three different scenarios. First, I’m ignoring only warning `F841`.
    Second, I’m ignoring two errors (even though one of them isn’t actually raised;
    this is just a silly example). Third, I’m ignoring all possible errors.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你看到了三种不同的情况。首先，我只忽略了警告 `F841`。第二，我忽略了两个错误（即使其中一个错误实际上并未被触发；这只是一个愚蠢的示例）。第三，我忽略了所有可能的错误。
- en: Flake8 also supports configuration files. In the project directory, you can
    create a *.flake8* file. Start a section in that file with the line `[flake8]`,
    followed by all the Flake8 settings you want to define. (See the documentation.)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Flake8 也支持配置文件。在项目目录中，你可以创建一个 *.flake8* 文件。在该文件中以 `[flake8]` 开头，然后跟随你希望定义的所有
    Flake8 设置。（请参见文档。）
- en: Flake8 will also accept project-wide configuration files called *tox.ini* or
    *setup.cfg*, so long as they have a `[flake8]` section within them.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Flake8 还会接受名为 *tox.ini* 或 *setup.cfg* 的项目范围配置文件，只要它们其中有一个 `[flake8]` 部分。
- en: 'For example, if you want to automatically run mccabe each time you invoke Flake8,
    rather than specify `--max-complexity` every time, you could define a *.flake8*
    file that looks like this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你希望每次调用 Flake8 时自动运行 mccabe，而不是每次都指定 `--max-complexity`，你可以定义一个如下的 *.flake8*
    文件：
- en: '[PRE57]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 2-10: *.flake8*'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-10：*.flake8*
- en: Some developers like to define a system-wide configuration file for Flake8,
    which you can do (only) on a UNIX-like system. In your home folder, create the
    configuration file as either *.flake8* or *.config/flake8*.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者喜欢为 Flake8 定义一个系统范围的配置文件，这只有在类 UNIX 系统中可以实现。在你的主目录中，创建一个配置文件，命名为 *.flake8*
    或 *.config/flake8*。
- en: One of the chief advantages of Flake8 over Pylint is the documentation. Flake8
    has a complete list of their warnings, errors, options, and the like. You can
    find the documentation at [https://flake8.readthedocs.io/](https://flake8.readthedocs.io/).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Flake8 相对于 Pylint 的主要优点之一是它的文档。Flake8 有一份完整的警告、错误、选项等的列表。你可以在 [https://flake8.readthedocs.io/](https://flake8.readthedocs.io/)
    找到文档。
- en: Mypy
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mypy
- en: '*Mypy* is an unusual static analyzer because it focuses entirely on *type annotations*
    (see Chapter 6). Because it involves so many concepts I haven’t covered yet, I
    won’t go into much depth here.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mypy* 是一种不寻常的静态分析器，因为它完全专注于 *类型注解*（见第六章）。由于它涉及很多我还没有涵盖的概念，所以在这里我不会深入讨论。'
- en: Still, now is a good time to get it installed. Like everything else so far,
    you can install the `mypy` package from pip.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，现在是一个安装它的好时机。像之前的所有步骤一样，你可以通过 pip 安装 `mypy` 包。
- en: 'Once installed, Mypy can be used by passing it the file, package, or module
    you wish to check:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，可以通过传递文件、包或模块来使用 Mypy 进行检查：
- en: '[PRE58]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Mypy will only attempt to check files that have type annotations, and it will
    ignore the rest.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 只会尝试检查具有类型注解的文件，忽略其他文件。
- en: 'Style Janitors: Autoformatting Tools'
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 风格清洁工：自动格式化工具
- en: Another tool you may find useful is an *autoformatter,* which can automatically
    change your Python code—spacing, indentation, and preferred equivalent expressions
    (such as `!=` instead of `<>`)—to be PEP 8 compliant. Two options are *autopep8*
    and *Black*.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能对你有用的工具是 *自动格式化工具*，它可以自动更改你的 Python 代码——空格、缩进以及首选的等价表达式（如使用 `!=` 代替 `<>`）——以符合
    PEP 8。两个选项是 *autopep8* 和 *Black*。
- en: autopep8
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: autopep8
- en: The autopep8 tool leverages pycodestyle (part of Flake8), even using the same
    configuration file as that tool to determine what style rules it ultimately follows
    or ignores.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: autopep8 工具利用了 pycodestyle（Flake8 的一部分），甚至使用与该工具相同的配置文件来决定它最终遵循或忽略哪些风格规则。
- en: As always, you can install `autopep8` with pip.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，你可以通过 pip 安装 `autopep8`。
- en: By default, autopep8 only fixes whitespace, but if you pass the `--aggressive`
    argument to it, it will make additional changes. In fact, if you pass that argument
    twice, it will do even more. The complete list is beyond the scope of this explanation,
    so consult the documentation at [https://pypi.org/project/autopep8/](https://pypi.org/project/autopep8/)
    to learn more.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，autopep8 只会修复空格问题，但如果你传递 `--aggressive` 参数，它会进行额外的修改。事实上，如果你传递该参数两次，它会做更多修改。完整的列表超出了本说明的范围，因此请参考文档
    [https://pypi.org/project/autopep8/](https://pypi.org/project/autopep8/) 以了解更多。
- en: 'To fix most PEP 8 issues on a Python code file by changing it in place (as
    opposed to making a copy, which is the default behavior), run this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过就地修改（而不是复制文件，这是默认行为）来修复 Python 代码文件中的大部分 PEP 8 问题，可以运行以下命令：
- en: '[PRE59]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Changing the file directly may sound a bit risky, but it really isn’t. Style
    changes are just that: style. They don’t affect the actual behavior of the code.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 直接修改文件听起来有点冒险，但实际上并不危险。风格的改变就是风格改变：它们不会影响代码的实际行为。
- en: Black
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Black
- en: 'The Black tool is a little more straightforward: it assumes you want to follow
    PEP 8 in its entirety, and it doesn’t overwhelm you with many options as a result.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Black 工具稍微直接一些：它假设你想完全遵循 PEP 8，因此不会让你被许多选项所困扰。
- en: 'Like autopep8, you install `black` with pip, although it requires Python 3.6
    or later. To format a file with it, pass the filename:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 与 autopep8 类似，你可以通过 pip 安装 `black`，但它需要 Python 3.6 或更高版本。要使用它格式化文件，只需传递文件名：
- en: '[PRE60]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A complete list of Black’s few options can be seen via `black --help`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Black 的完整选项列表可以通过 `black --help` 查看。
- en: Testing Frameworks
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试框架
- en: 'Testing frameworks form an essential part of any good development workflow,
    but I won’t go into detail about them in this chapter. Python has three major
    options for testing frameworks: *Pytest*, *nose2*, and *unittest*, in addition
    to a promising new project called *ward*. All of these can be installed with pip.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架是任何良好的开发工作流中不可或缺的一部分，但在本章中我不会详细讨论它们。Python 有三种主要的测试框架：*Pytest*、*nose2* 和
    *unittest*，此外还有一个有前景的新项目叫做 *ward*。这些都可以通过 pip 安装。
- en: More knowledge is essential to cover this topic effectively, so I’ll revisit
    it in Chapter 20.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更多的知识来有效覆盖这个话题，因此我将在第 20 章再次讨论它。
- en: An Exhibition of Code Editors
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码编辑器展览
- en: You have your Python interpreter, your virtual environments, your static analyzers,
    and other such tools. Now you are prepared to write code.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你有了 Python 解释器、虚拟环境、静态分析工具以及其他相关工具。现在你已经准备好编写代码了。
- en: You can write Python in any basic text editor, just as you could with practically
    any other programming language. Yet you’ll probably have an easier time writing
    production-quality code with a proper code editor.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何基本的文本编辑器中编写 Python 代码，就像你可以使用几乎任何其他编程语言一样。然而，你可能会更容易用一个合适的代码编辑器编写生产质量的代码。
- en: Before I end this chapter, I want to take you on a tour of several of the most
    popular Python code editors and integrated development environments (*IDEs*) available.
    This is only a sampling, as there are many more options besides. **If you already
    know what code editor or IDE you want to use, skip forward to the last section
    of this chapter.**
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我想带你参观几款最流行的 Python 代码编辑器和集成开发环境（*IDEs*）。这只是一个样本，因为还有很多其他选项可供选择。**如果你已经知道要使用哪个代码编辑器或
    IDE，可以跳到本章的最后一节。**
- en: IDLE
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IDLE
- en: 'Python has its own IDE, called *IDLE*, which ships with the standard distribution
    of Python. It’s a fairly bare-bones IDE with two components: an editor and an
    interface for the interactive shell. You could do worse than IDLE, so if you aren’t
    in the mood to install a different editor right now, start here. However, I recommend
    exploring your options, as most editors and IDEs have a host of useful features
    that IDLE lacks.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有自己的 IDE，叫做 *IDLE*，它随 Python 的标准分发包一起提供。它是一个相当基础的 IDE，包含两个组件：一个编辑器和一个交互式
    Shell 界面。如果你不想现在安装其他编辑器，IDLE 也能应急。不过，我建议你探索一下其他选项，因为大多数编辑器和 IDE 都有 IDLE 所缺少的许多有用功能。
- en: Emacs and Vim
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Emacs 和 Vim
- en: The purists and old-school hackers among you will be glad to know that Emacs
    and Vim both have excellent Python support. Setting up either is not for the faint
    of heart, so I’m not going into any of that here.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 那些追求纯粹和老派黑客的朋友们会很高兴知道，Emacs 和 Vim 都有很好的 Python 支持。配置这两者都不适合心脏脆弱的人，所以我这里就不展开讲解了。
- en: If you’re already a lover of either (or both?) code editors, you can find excellent
    tutorials for both at Real Python.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经是其中（或者两者？）代码编辑器的爱好者，你可以在 Real Python 上找到这两者的优秀教程。
- en: For Emacs, see [https://realpython.com/emacs-the-best-python-editor/](https://realpython.com/emacs-the-best-python-editor/).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Emacs，见 [https://realpython.com/emacs-the-best-python-editor/](https://realpython.com/emacs-the-best-python-editor/)。
- en: For Vim, see [https://realpython.com/vim-and-python-a-match-made-in-heaven/](https://realpython.com/vim-and-python-a-match-made-in-heaven/).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Vim，见 [https://realpython.com/vim-and-python-a-match-made-in-heaven/](https://realpython.com/vim-and-python-a-match-made-in-heaven/)。
- en: PyCharm
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyCharm
- en: 'According to “The State of Developer Ecosystem 2021” developer survey by JetBrains,
    the PyCharm IDE from JetBrains is far and away the most popular option for Python
    programming. It comes in two flavors: the free *PyCharm Community Edition* and
    the paid *PyCharm Professional Edition*. (Steps were taken by JetBrains to eliminate
    bias. See the survey here: [https://www.jetbrains.com/lp/devecosystem-2021/python/](https://www.jetbrains.com/lp/devecosystem-2021/python/).)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 JetBrains 的《2021 年开发者生态系统现状》调查，JetBrains 的 PyCharm IDE 是 Python 编程中最受欢迎的选择。它有两个版本：免费的*PyCharm
    Community Edition* 和付费的*PyCharm Professional Edition*。（JetBrains 已采取措施消除偏见。查看调查内容：[https://www.jetbrains.com/lp/devecosystem-2021/python/](https://www.jetbrains.com/lp/devecosystem-2021/python/)）。
- en: Both versions offer a dedicated Python code editor with autocompletion, refactoring,
    debugging, and testing tools. It can manage and use virtual environments with
    ease, and it integrates with your version control software. It even performs static
    analysis (using its own tool). The professional edition adds tools for data, scientific
    development, and web development.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本都提供专用的 Python 代码编辑器，具有自动补全、重构、调试和测试工具。它可以轻松管理和使用虚拟环境，并与版本控制软件进行集成。它还执行静态分析（使用其自己的工具）。专业版增加了数据、科学开发和
    Web 开发的工具。
- en: If you’re familiar with other JetBrains IDEs, like IntelliJ IDEA or CLion, PyCharm
    would be a great Python IDE to start with. It requires more computer resources
    than many code editors, but if you have a decently powerful machine, this won’t
    be a problem. If you haven’t used JetBrains IDEs before, try the Community Edition
    before investing in the paid version.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他 JetBrains 的 IDE，如 IntelliJ IDEA 或 CLion，PyCharm 将是一个很好的 Python IDE 入门选择。它比许多代码编辑器消耗更多的计算资源，但如果你的机器性能足够强大，这不会成为问题。如果你之前没有使用过
    JetBrains 的 IDE，可以先尝试 Community Edition，再决定是否购买付费版。
- en: You can find more information and downloads at [https://jetbrains.com/pycharm/](https://jetbrains.com/pycharm/).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://jetbrains.com/pycharm/](https://jetbrains.com/pycharm/) 找到更多信息和下载链接。
- en: Visual Studio Code
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: '*Visual Studio Code* has excellent Python support. It’s the second-most popular
    Python code editor, according to that 2021 JetBrains survey. It’s free and open
    source, and it runs on virtually every platform. Install the official Python extension
    from Microsoft, and you’re ready to go!'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '*Visual Studio Code* 对 Python 的支持非常出色。根据 2021 年 JetBrains 的调查，它是第二受欢迎的 Python
    代码编辑器。它是免费的开源软件，几乎可以在所有平台上运行。安装 Microsoft 提供的官方 Python 扩展，你就可以开始使用了！'
- en: Visual Studio Code supports autocompletion, refactoring, debugging, and virtual
    environment switching, along with the usual version control integration. It integrates
    with Pylint, Flake8, and Mypy, among several other popular static analyzers. It
    even works with the most common Python unit testing tools.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 支持自动补全、重构、调试和虚拟环境切换，同时还集成了常见的版本控制工具。它与 Pylint、Flake8 和 Mypy
    等多个流行的静态分析工具兼容，甚至可以与最常用的 Python 单元测试工具一起使用。
- en: Download it at [https://code.visualstudio.com/](https://code.visualstudio.com/).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://code.visualstudio.com/](https://code.visualstudio.com/)下载它。
- en: Sublime Text
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sublime Text
- en: '*Sublime* is another popular multilanguage code editor. It is appreciated for
    its speed and simplicity, and it is easily customized with extensions and configuration
    files. Sublime Text is free to try, but if you find you like it and wish to continue
    using it, you need to purchase it.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sublime*是另一个受欢迎的多语言代码编辑器。它因其速度和简洁性而受到赞赏，并且可以通过扩展和配置文件轻松自定义。Sublime Text可以免费试用，但如果你喜欢它并希望继续使用，则需要购买。'
- en: 'The Anaconda plug-in transforms Sublime Text into a Python IDE, with everything:
    autocompletion, navigation, static analysis, autoformatting, test running, and
    even a documentation browser. It requires a little more hand-tuned configuration
    than some of the other options, especially if you want to use virtual environments.
    However, if Sublime Text is your jam, it’s worth it.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda插件将Sublime Text转变为一个完整的Python IDE，包含所有功能：自动补全、导航、静态分析、自动格式化、测试运行，甚至文档浏览器。它比其他选项需要更多的手动配置，特别是如果你想使用虚拟环境的话。然而，如果Sublime
    Text是你喜欢的编辑器，那么这确实值得尝试。
- en: Download Sublime Text at [https://sublimetext.com/](https://sublimetext.com/)
    and the Anaconda plug-in at [https://damnwidget.github.io/anaconda/](https://damnwidget.github.io/anaconda/).
    That second link also provides instructions for installing the plug-in in Sublime
    Text.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://sublimetext.com/](https://sublimetext.com/)下载Sublime Text，并在[https://damnwidget.github.io/anaconda/](https://damnwidget.github.io/anaconda/)下载Anaconda插件。第二个链接还提供了在Sublime
    Text中安装插件的说明。
- en: Spyder
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spyder
- en: If your focus is scientific programming or data analysis, or if you’re a fan
    of MATLAB’s interface, you’ll be right at home in *Spyder*, a free and open source
    Python IDE that is also written *in* Python.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的重点是科学编程或数据分析，或者你是MATLAB界面的粉丝，那么*Spyder*会是一个理想的选择，它是一个免费的开源Python IDE，也是在*Python*中编写的。
- en: In addition to the usual features—a dedicated Python code editor, a debugger,
    integration with static analyzers, and documentation viewing—Spyder includes integration
    with many common Python libraries for data analysis and scientific computing.
    It integrates a full code profiler and variable explorer. Plug-ins exist for supporting
    unit tests, autoformatting, and editing Jupyter notebooks, among other features.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的功能——专用的Python代码编辑器、调试器、与静态分析工具的集成以及文档查看——Spyder还包括与许多常用Python库（用于数据分析和科学计算）的集成。它集成了完整的代码分析器和变量浏览器。还可以安装插件支持单元测试、自动格式化和编辑Jupyter笔记本等功能。
- en: Download Spyder at [https://spyder-ide.org/](https://spyder-ide.org/).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://spyder-ide.org/](https://spyder-ide.org/)下载Spyder。
- en: Eclipse + PyDev/LiClipse
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Eclipse + PyDev/LiClipse
- en: '*Eclipse* has lost a lot of ground to the newer editors, but it still has a
    loyal user base. Although it’s geared toward languages like Java, C++, PHP, and
    JavaScript, Eclipse can also become a Python IDE with the *PyDev* plug-in.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*Eclipse*已经在新一代编辑器的竞争中失去了很多市场份额，但它仍然拥有一批忠实的用户。虽然它主要针对Java、C++、PHP和JavaScript等语言，但通过*PyDev*插件，Eclipse也可以成为Python
    IDE。'
- en: If you already have installed Eclipse, which is completely free, then you only
    need to install the PyDev plug-in from the Eclipse Marketplace. Download Eclipse
    at [https://eclipse.org/ide/](https://eclipse.org/ide/) and look in the marketplace
    for the plug-in.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了完全免费的Eclipse，那么你只需要从Eclipse Marketplace安装PyDev插件。可以在[https://eclipse.org/ide/](https://eclipse.org/ide/)下载Eclipse，并在Marketplace中寻找插件。
- en: Alternatively, you can install *LiClipse,* which bundles Eclipse, PyDev, and
    other useful tools. The PyDev developers recommend this approach, as it directly
    supports their development work. You can use LiClipse without a license for 30
    days, after which point, you must purchase a license. Download LiClipse from [https://liclipse.com/](https://liclipse.com/).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以安装*LiClipse*，它将Eclipse、PyDev和其他有用的工具打包在一起。PyDev的开发者推荐这种方式，因为它直接支持他们的开发工作。你可以在没有许可证的情况下使用LiClipse
    30天，之后需要购买许可证。可以从[https://liclipse.com/](https://liclipse.com/)下载LiClipse。
- en: PyDev offers autocompletion, refactoring, support for type hinting and static
    analysis, debugging, unit test integration, and many more features. You can find
    more information about PyDev at [https://pydev.org/](https://pydev.org/).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: PyDev提供自动补全、重构、类型提示和静态分析支持、调试、单元测试集成等多个功能。你可以在[https://pydev.org/](https://pydev.org/)找到关于PyDev的更多信息。
- en: The Eric Python IDE
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Eric Python IDE
- en: '*Eric* might be the oldest IDE on the list, but it’s still as reliable as ever.
    Named after Eric Idle of *Monty Python’s Flying Circus*, Eric is a free and open
    source IDE written in Python.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '*Eric* 可能是列表中最古老的 IDE，但它仍然一如既往地可靠。Eric 以 *Monty Python’s Flying Circus* 的 Eric
    Idle 命名，是一个用 Python 编写的免费开源 IDE。'
- en: 'It offers everything you could possibly need to write Python: autocompletion,
    debugging, refactoring, static analysis, testing integration, documentation tools,
    virtual environment management, and the list goes on.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了编写 Python 所需的一切功能：自动补全、调试、重构、静态分析、测试集成、文档工具、虚拟环境管理，等等。
- en: Find information about Eric and download it at [https://eric-ide.python-projects.org/](https://eric-ide.python-projects.org/).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 获取关于 Eric 的信息并下载，网址为 [https://eric-ide.python-projects.org/](https://eric-ide.python-projects.org/)。
- en: Wrapping Up
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Writing code involves so much more than just code. Having set up your development
    environment, project, and IDE, you are now prepared to focus exclusively on making
    your code the best it can be.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码远不止编写代码本身。完成开发环境、项目和 IDE 的设置后，你现在可以专注于将你的代码做到最好。
- en: By this point, you should have assembled a Python development workbench worthy
    of any production-level project. At minimum, you should have installed the Python
    interpreter, pip, `venv`, one or more static analyzers, and a Python code editor.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经搭建了一个适合任何生产级项目的 Python 开发工作台。至少，你应该已经安装了 Python 解释器、pip、`venv`、一个或多个静态分析器，以及一个
    Python 代码编辑器。
- en: 'Right now, in your code editor or IDE, create a *FiringRange* project for experimenting
    in while working through this book. For the moment, to be sure everything works,
    you can make a single Python file in that project with these contents:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的代码编辑器或 IDE 中，为本书的实验创建一个*FiringRange*项目。在目前阶段，为确保一切正常，你可以在该项目中创建一个包含以下内容的单个
    Python 文件：
- en: '[PRE61]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 2-11: *hello_world.py*'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-11: *hello_world.py*'
- en: 'Run that like this:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样运行：
- en: '[PRE62]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You should see the following output:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下输出：
- en: '[PRE63]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: I’ll go into the correct structure for Python projects in Chapter 4, but writing
    and running individual Python files in your firing range project should be sufficient
    for Chapter 3.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第 4 章中深入讲解 Python 项目的正确结构，但在第 3 章中，只需在你的射击靶场项目中编写并运行单个 Python 文件就足够了。
- en: If you’re new to the IDE you have selected, take a few minutes now to familiarize
    yourself with it. You should particularly ensure you know how to navigate and
    run code, manage files, work with virtual environments, access the interactive
    console, and use the static analyzers.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对所选的 IDE 不熟悉，花几分钟时间熟悉它。你应该特别确保你知道如何导航和运行代码、管理文件、使用虚拟环境、访问交互式控制台以及使用静态分析器。
- en: '3'
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Syntax Crash Course
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 语法速成课程
- en: '![](Images/chapterart.png)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Python is an unusual mix of common and unique concepts. Before diving into the
    intricacies of the language, you must first grasp its essential syntax.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是常见概念和独特概念的奇特混合。在深入了解语言的细节之前，你首先需要掌握它的基本语法。
- en: In this chapter, you’ll learn most of the essential syntactic structures you’ll
    encounter in Python, and you’ll also become familiar with the basic mathematical
    and logical features of the language.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习到在 Python 中遇到的大部分基本语法结构，并且会熟悉该语言的基本数学和逻辑特性。
- en: 'Most Python developers will point newcomers to the official Python tutorial,
    which is an excellent introduction to the language’s structure. While I’ll cover
    all of these concepts in this book in depth, the tutorial is still a good resource
    worth reading: [https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/).'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Python 开发者会将新手引导到官方的 Python 教程，这是对语言结构的一个很好的介绍。虽然我会在本书中深入讨论所有这些概念，但这个教程仍然是一个值得阅读的好资源：[https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/)。
- en: Hello, World!
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: 'It won’t feel like a proper introduction to the language without the classic
    Hello World program. In Python, it’s written like this:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有经典的 Hello World 程序，它就不像是对该语言的正确介绍。在 Python 中，它是这样写的：
- en: '[PRE64]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 3-1: *hello_world.py*'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-1: *hello_world.py*'
- en: There’s nothing novel here. You call the `print()` function to write text to
    the console, and you pass data in a string, wrapped in quotes as an argument.
    You can pass whatever sort of data you like, and it will be output on the console.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新奇的内容。你调用`print()`函数将文本输出到控制台，并将数据作为字符串传入，字符串用引号括起来作为参数。你可以传入任何你喜欢的数据，它将被输出到控制台。
- en: 'I can also get input from the console with the `input()` function:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我还可以通过`input()`函数从控制台获取输入：
- en: '[PRE65]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Listing 3-2: *hello_input.py*'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-2: *hello_input.py*'
- en: I use the `input()` function and pass my prompt as a string ❶. When I run that
    code, Python greets me using the name I entered on the console.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`input()`函数并将我的提示作为字符串 ❶ 传入。当我运行这段代码时，Python会使用我在控制台输入的名字向我问候。
- en: Statements and Expression
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句与表达式
- en: Each line of code in Python that ends with a line break is a *statement*, sometimes
    more specifically known as a *simple statement*. Unlike in many C-inspired languages,
    you don’t need to end a line in Python with a special character.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，每一行以换行符结尾的代码都是一个*语句*，有时也更具体地称为*简单语句*。与许多受C语言影响的语言不同，在Python中，行末不需要特别的字符来表示语句结束。
- en: A section of code that evaluates to a single value is called an *expression*.
    In Python, you can put expressions nearly anywhere a value is expected. The expression
    is evaluated down to a value, and that value is used in that position in the statement.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 一段计算结果为单一值的代码叫做*表达式*。在Python中，你几乎可以在任何期望值的地方使用表达式。表达式会被评估为一个值，并在语句中该位置使用这个值。
- en: 'For example, in one statement, I can create a variable, and in another statement,
    I can print its contents to the console:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个语句中，我可以创建一个变量，在另一个语句中，我可以将其内容打印到控制台：
- en: '[PRE66]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Listing 3-3: *hello_statements.py:1a*'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-3: *hello_statements.py:1a*'
- en: I assign the expression `"Hello, world!"` to `message`, and then I pass the
    expression `message` to `print()`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我将表达式 `"Hello, world!"` 赋值给 `message`，然后将 `message` 传递给 `print()` 函数。
- en: 'If you ever need to place multiple statements on the same line, you can separate
    them with a semicolon (`;`). To demonstrate this, here are the same two statements
    as earlier, but packed onto one line, with a semicolon to separate them:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将多个语句放在同一行，可以用分号（`;`）将它们分开。为了演示这一点，这里是之前的两个语句，但它们被放到了一行，并用分号分隔开：
- en: '[PRE67]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 3-4: *hello_statements.py:1b*'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-4: *hello_statements.py:1b*'
- en: While this is valid code, using this technique is somewhat discouraged. The
    Python philosophy places a high value on readability, and the placement of multiple
    statements on the same line often detracts from that.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码是有效的，但使用这种技巧在一定程度上是不推荐的。Python哲学高度重视可读性，多个语句放在同一行通常会降低代码的可读性。
- en: Stick to placing one statement per line, unless you have a specific reason to
    do otherwise.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有特定的理由，否则最好每行放一个语句。
- en: The Importance of Whitespace
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空格的重要性
- en: When you’re looking at a sample of Python source code, the first thing that
    will probably jump out at you is the use of indentation for nesting. A *compound
    statement* is made up of one or more *clauses*, each of which consists of a line
    of code called a *header* and a block of code called a *suite*, which is associated
    with the header.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看Python源代码示例时，最先引起你注意的可能是缩进用于嵌套的方式。一个*复合语句*由一个或多个*子句*组成，每个子句包含一个称为*头部*的代码行和一个称为*语句块*的代码块，语句块与头部相关联。
- en: 'For example, this program prints different messages, depending on whether a
    `name` is specified:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，程序根据是否指定了 `name` 来打印不同的消息：
- en: '[PRE68]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 3-5: *hello_conditional.py*'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-5: *hello_conditional.py*'
- en: I set up a conditional statement with an `if` header ❶, after which I have a
    suite made up of two indented lines of code, which “belongs” to the header. These
    lines of code are executed only if the conditional expression in the header is
    evaluated to `True`.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了一个带有 `if` 头部的条件语句 ❶，然后在后面有一个由两行缩进代码组成的语句块，这些代码“属于”该头部。这些代码只有在头部的条件表达式被评估为
    `True` 时才会执行。
- en: The unindented line ❷ is not part of the suite that belongs to the conditional
    statement, and it will be run every time.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 未缩进的第❷行不是属于条件语句的语句块的一部分，它每次都会执行。
- en: 'As I nest deeper, I need to add more indentation:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 当我嵌套得更深时，我需要增加更多的缩进：
- en: '[PRE69]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Listing 3-6: *weather_nested_conditional.py*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-6: *weather_nested_conditional.py*'
- en: The first `print` statement is indented twice, which is how Python knows that
    it belongs to both preceding conditional statements.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `print` 语句缩进了两次，这就是Python判断它属于前面两个条件语句的方式。
- en: Given the importance of whitespace, the “tabs versus spaces” war is fairly common
    in Python world. You’ll remember from Chapter 2 that the PEP 8 style guide stresses
    using either four spaces or a single tab per indentation level. ***Consistency
    is key!*** Python really doesn’t care whether you use tabs, two spaces, four spaces,
    or even seven spaces (although that’s probably a step too far) for each level
    of indentation. The point is to be consistent within any and every given block
    of code.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到空白字符的重要性，Python 社区中“制表符与空格”的争论相当常见。你会记得在第二章中提到的 PEP 8 风格指南强调每一级缩进使用四个空格或一个制表符。***一致性是关键！***
    Python 并不关心你使用制表符、两个空格、四个空格，甚至是七个空格（尽管这可能有些过分）来进行每一级缩进。关键是，在任何给定的代码块内保持一致。
- en: You should use only one indentation style throughout your project, even if your
    situation provides a technical loophole. Don’t mix tabs and spaces. Chances are
    your IDE has tools to help you with this.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在整个项目中使用一致的缩进风格，即使你的情况提供了技术上的漏洞。不要混合使用制表符和空格。你的IDE很可能有相关工具来帮助你做到这一点。
- en: For simplicity’s sake, I’ll use the PEP 8 convention of four spaces throughout
    my code examples. While I’d recommend you follow this same convention—you can
    even configure your editor to insert four spaces each time you hit the Tab key—if
    you have a strong preference for tabs, you’re welcome to use those instead. It
    really doesn’t matter.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我会在我的代码示例中使用 PEP 8 约定的四个空格缩进。虽然我建议你遵循这个约定——你甚至可以配置编辑器，每次按下 Tab 键时自动插入四个空格——如果你更喜欢制表符，也可以使用它们。实际上，这并不重要。
- en: Doing Nothing
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么都不做
- en: On occasion, you will need to insert a statement that has absolutely no effect.
    This is particularly useful when you need to put a syntactically valid placeholder
    where a suite of code will exist later. For this purpose, Python provides the
    `pass` keyword.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要插入一个完全没有效果的语句。当你需要在后续某个地方写入代码时，放置一个语法上有效的占位符就特别有用。为了这个目的，Python 提供了 `pass`
    关键字。
- en: 'For example, I can employ the `pass` keyword as a placeholder in my `if raining`
    conditional, until I’m able to write the final code:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可以在我的 `if raining` 条件语句中使用 `pass` 关键字作为占位符，直到我能够编写最终的代码：
- en: '[PRE70]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Listing 3-7: *raining_pass.py*'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-7: *raining_pass.py*'
- en: Just remember, `pass` does absolutely nothing. That’s the only reason it exists.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，`pass` 完全什么也不做。它存在的唯一原因就是这个。
- en: Comments and Docstrings
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释和文档字符串
- en: To write comments in Python, precede the line with a hash (`#`). Everything
    between the hash and the end of the line is a comment and will be ignored by the
    interpreter.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中编写注释时，在行前加上井号（`#`）。井号与行尾之间的所有内容都是注释，解释器会忽略它们。
- en: '[PRE71]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 3-8: *comments.py*'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-8: *comments.py*'
- en: If you ran this program, the `print` statements would both execute. The rest
    of the second `print` statement, from the hash onward, is an inline comment ❶
    and would be ignored by the interpreter. All the other lines are only comments.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了这个程序，`print` 语句都会执行。第二个 `print` 语句中的其余部分，从井号（#）开始，是内联注释❶，会被解释器忽略。其余的所有行只是注释。
- en: Docstrings
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档字符串
- en: 'Officially, there is no syntax for “multiline” comments; you just comment each
    line. There is one special exception: the *docstring*. It looks like this:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，Python 没有“多行”注释的语法；你只能注释每一行。有一个特别的例外：*文档字符串*。它长得像这样：
- en: '[PRE72]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Listing 3-9: *docstrings.py:1*'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-9: *docstrings.py:1*'
- en: I define a function that would (theoretically) make tea, and I place the description
    of the function inside a docstring.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个函数，它（理论上）可以泡茶，并将该函数的描述放在文档字符串中。
- en: Docstrings exist to provide documentation for functions, classes, and modules,
    especially public ones. They conventionally begin and end with three quotation
    marks (`"""`), allowing the string to automatically span multiple lines. You would
    typically place docstrings at the top, inside of whatever they’re defining, such
    as in the function above.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串用于为函数、类和模块提供文档，尤其是公共的。它们通常以三个引号（`"""`）开始并结束，允许字符串自动跨越多行。你通常会把文档字符串放在它们所定义的内容上方，比如上面函数的例子中。
- en: 'There are three important distinctions between comments and docstrings:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 注释和文档字符串之间有三点重要的区别：
- en: Docstrings are string literals, and they are seen by the interpreter; comments
    are ignored.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串是字符串字面量，解释器会读取它们；注释则会被忽略。
- en: Docstrings are used in automatic documentation generation.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串用于自动生成文档。
- en: Docstrings are generally only docstrings when they appear at the top of the
    module, function, class, or method they define. Comments can live anywhere.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串通常只有在出现在模块、函数、类或方法的顶部时，才算真正的文档字符串。注释可以出现在任何地方。
- en: It is perfectly possible to use a triple-quoted string literal to write a sort
    of “multiline comment,” but it’s not recommended, since a string literal can easily
    get left in a place where Python will try to use it as a value.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以使用三重引号字符串字面量来写一种“多行注释”，但不推荐这样做，因为字符串字面量很容易被遗留在Python会尝试作为值使用的地方。
- en: In short, use docstrings as intended, and stick with comments for everything
    else. Many Python IDEs have hotkeys for toggling comments on a selection, which
    can save you a lot of time.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，按照预期使用文档字符串，其它情况则使用注释。许多Python集成开发环境（IDE）都有快捷键来切换选中部分的注释，这能为你节省大量时间。
- en: 'I can access these docstrings later in my code. For instance, given the previous
    example, I can do this:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在代码中稍后访问这些文档字符串。例如，基于之前的示例，我可以这样做：
- en: '[PRE73]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Listing 3-10: *docstrings.py:2*'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-10: *docstrings.py:2*'
- en: Docstrings have their own style conventions, which are outlined in depth in
    PEP 257.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串（Docstrings）有自己的一套风格约定，详细内容可以参考PEP 257。
- en: Declaring Variables
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'You may have already noticed that Python doesn’t have a distinct keyword for
    declaring a new variable (technically called a *name* in this language; see Chapter
    5). Here, I define two variables—`name` and `points`:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Python没有用于声明新变量的独立关键字（在这个语言中，通常称之为*名称*；见第5章）。在这里，我定义了两个变量——`name`和`points`：
- en: '[PRE74]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Listing 3-11: *variables.py*'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-11: *variables.py*'
- en: Python is *dynamically typed*, meaning the data type of a value is determined
    when it is evaluated. This contrasts with statically typed languages, in which
    you declare the data type initially. (C++ and Java are both statically typed.)
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: Python是*动态类型*语言，这意味着值的数据类型在计算时确定。这与静态类型语言不同，静态类型语言需要你在开始时就声明数据类型。（C++和Java都是静态类型语言。）
- en: With Python, you can assign a value to a name anytime, by using the assignment
    operator (`=`). It infers the data type. If the name is a new variable, Python
    will create it; if the name already exists, Python will change the value. It’s
    a pretty straightforward system.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你可以随时通过赋值运算符（`=`）为一个名称赋值。Python会推断数据类型。如果这个名称是一个新变量，Python会创建它；如果该名称已经存在，Python会修改其值。这个系统非常直接。
- en: 'In general, there are only two rules to follow with Python variables:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Python变量有两个规则需要遵守：
- en: Define a variable before you access it; otherwise, you’ll get an error.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在访问变量之前定义它；否则，你会遇到错误。
- en: Don’t change what kind of data you’re storing in the variable, even when replacing
    a value.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在替换值时，不要更改你存储在变量中的数据类型。
- en: Python is considered a *strongly typed language*, meaning you usually can’t
    magically combine data of different types. For example, it won’t allow you to
    add an integer and a string together. On the other hand, *weakly typed* languages
    let you do practically anything with different data types, and they try to figure
    out how to do what you asked for. (JavaScript is weakly typed.) There’s an entire
    spectrum between those last two terms and plenty of debate about what behaviors
    qualify under which name. While Python is decidedly in the “strongly typed” camp,
    it still has weaker typing than some languages.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: Python被认为是*强类型语言*，这意味着你通常不能将不同类型的数据随意结合。例如，它不会允许你将整数和字符串相加。另一方面，*弱类型*语言允许你用不同的数据类型做几乎任何事，它们会尝试弄清楚如何执行你要求的操作。（JavaScript是弱类型语言。）这两个术语之间有一个完整的谱系，并且关于哪些行为属于哪个名称的讨论也很多。虽然Python明显属于“强类型”这一阵营，但它的类型系统比一些语言要弱一些。
- en: Python is, however, *weakly bound*, so it is possible to assign a value of a
    different type to an existing variable. While this is technically permissible,
    it is strongly discouraged, as it can produce confusing code.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python是*弱绑定*的，因此可以将不同类型的值赋给已存在的变量。虽然技术上是允许的，但强烈不建议这样做，因为它可能会导致混乱的代码。
- en: What About Constants?
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 那么常量呢？
- en: Python doesn’t have any formally defined constants. In keeping with PEP 8, you
    would indicate a variable is intended to be treated as a constant by using all-caps
    names with underscores. This naming convention is sometimes humorously referred
    to as *screaming snake case* for the all-caps (screaming) and the underscores
    (snakes). For example, the name `INTEREST_RATE` indicates that you don’t want
    the variable redefined or changed in any way. While the interpreter itself won’t
    prevent the variable from being modified, your linter will usually complain if
    you do.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有正式定义的常量。根据 PEP 8 的规范，你可以通过使用全大写的变量名并加上下划线来表示某个变量应被视为常量。这种命名规范有时被幽默地称为
    *尖叫蛇式命名法*，因为它包含了全大写（尖叫）和下划线（蛇）。例如，`INTEREST_RATE` 这个变量名表示你不希望这个变量被重新定义或以任何方式改变。虽然解释器本身不会阻止修改变量，但如果你修改了它，通常你的代码检查工具会发出警告。
- en: Mathematics
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学
- en: Python has all the math functionality you would expect from a good programming
    language; its excellent support for both simple and complicated mathematics is
    one of the reasons Python is popular for scientific programming, data processing,
    and statistical analysis.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了你期望的所有数学功能；它在简单和复杂数学方面的出色支持是 Python 在科学编程、数据处理和统计分析中受欢迎的原因之一。
- en: Meet the Number Types
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认识数字类型
- en: Before I get into the operations, you should be aware of the three data types
    used for storing numbers.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍操作之前，你应该了解用于存储数字的三种数据类型。
- en: '*Integers* (`int`) store whole numbers. In Python, integers are always signed
    and effectively have no maximum value. Integers use decimal base (base-10) by
    default, but they can also be specified in binary (`0b101010`), octal (`0o52`),
    or hexadecimal (`0x2A`).'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数* (`int`) 存储整数。在 Python 中，整数总是带符号的，并且实际上没有最大值。整数默认使用十进制（base-10），但也可以用二进制（`0b101010`）、八进制（`0o52`）或十六进制（`0x2A`）表示。'
- en: '*Floating-point numbers* (`float`) store numbers with a decimal part (for example,
    `3.141592`). You can also use scientific notation (for example, `2.49e4`). Internally,
    values are stored as double-precision, IEEE 754 floating-point numbers, which
    are subject to the limits inherent in that format. (For more insight into the
    limits and gotchas of floating-point arithmetic, read the article “What Every
    Computer Scientist Should Know About Floating-Point Arithmetic” by David Goldberg:
    [https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)*.*)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮点数* (`float`) 存储带有小数部分的数字（例如 `3.141592`）。你也可以使用科学计数法（例如 `2.49e4`）。在内部，值以双精度
    IEEE 754 浮点数的形式存储，这种格式有其固有的限制。（关于浮点算术的限制和陷阱，更多内容请阅读 David Goldberg 的文章《每个计算机科学家都应该知道的浮点算术》：[https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)*.*)'
- en: You can also specify an invalid number with `float("nan")`, a number larger
    than the largest possible value with `float("inf")`, or a number smaller than
    the smallest possible value with `float("-inf")`.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `float("nan")` 来指定一个无效数字，使用 `float("inf")` 来指定一个比最大可能值更大的数字，或者使用 `float("-inf")`
    来指定一个比最小可能值更小的数字。
- en: Notice that I wrapped the special values in quotes. This is necessary if you
    want to use these values without *importing* the `math` module (see Chapter 4
    for more about importing). If you have imported the `math` module (see “The `math`
    Module” subsection below), you can use the constants `nan`, `inf`, and so forth,
    instead of the quoted versions.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我将特殊值用引号括起来。如果你不想 *导入* `math` 模块（关于导入更多内容，请见第 4 章），这是必要的。如果你已经导入了 `math`
    模块（请参见下文的 “`math` 模块” 小节），你可以使用常量 `nan`、`inf` 等，而不必使用引号包裹。
- en: '*Complex numbers* (`complex`) can store imaginary numbers by appending `j`
    to the value, as in `42j`. You can combine a real part with the imaginary part,
    using addition: `24+42j`.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '*复数* (`complex`) 可以通过在值后添加 `j` 来存储虚数，例如 `42j`。你还可以通过加法将实数部分和虚数部分结合在一起，例如 `24+42j`。'
- en: In case you missed it in math class, an imaginary number has the square root
    of negative one as one of its factors, even though this value is utterly impossible;
    there is no value that you can multiply by itself to get negative one! Yet imaginary
    numbers definitely show up in real-world math. Spooky, no?
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在数学课上没学过，虚数的平方根是负一，虽然这个值在数学上是不可能的；没有任何一个数能和自己相乘得到负一！然而，虚数在现实世界的数学中确实出现。神奇吧？
- en: '*Decimal* and *Fraction* are two of the additional object types for storing
    numeric data. `Decimal` stores fixed-point decimal numbers, while `Fraction` does
    the same for fractions. To use either, you’ll need to import them first.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '*Decimal* 和 *Fraction* 是两种额外的对象类型，用于存储数字数据。`Decimal` 存储定点小数，而 `Fraction` 则用于存储分数。要使用这两者，你需要先导入它们。'
- en: 'Here’s a brief example that uses both types:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用这两种类型的简短示例：
- en: '[PRE75]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 3-12: *fractions_and_decimals.py*'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-12: *fractions_and_decimals.py*'
- en: The `float()` function turns `Fraction` and `Decimal` objects into floats.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`float()` 函数将 `Fraction` 和 `Decimal` 对象转换为浮点数。'
- en: Operators
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符
- en: Python has the usual operators, with a couple of additions that may not be familiar
    to some developers.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: Python 具有常见的运算符，并增加了一些可能对部分开发者来说不太熟悉的运算符。
- en: 'Here’s a bit of code that will demonstrate the math operators. I’ll wrap each
    equation inside a `print()` statement, so you can run the code and see the results:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一段代码，将演示数学运算符。我会将每个方程包裹在一个`print()`语句内，这样你可以运行代码并查看结果：
- en: '[PRE76]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Listing 3-13: *math_operators.py*'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-13: *math_operators.py*'
- en: The *unary* (one-operand) negative operator flips the sign of whatever follows
    it. The `abs()` function is technically considered a unary operator as well. The
    rest of the operators here are *binary*, meaning they accept two operands.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '*一元*（单操作数）负号运算符会翻转其后跟随的内容的符号。`abs()` 函数在技术上也被认为是一个一元运算符。这里的其余运算符是 *二元* 运算符，意味着它们接受两个操作数。'
- en: '[PRE77]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Listing 3-14: *augmented_assignment_operators.py*'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-14: *augmented_assignment_operators.py*'
- en: If you need both floor division (`//`) and modulo (`%`) on the same operands,
    Python provides the `divmod()` function to efficiently perform the calculation,
    returning the two results in a tuple. Thus, `c = divmod(a, b)` is the same as
    `c = (a // b, a % b)`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对同一操作数同时执行整除（`//`）和取模（`%`），Python 提供了 `divmod()` 函数来高效地执行该计算，并返回一个元组中的两个结果。因此，`c
    = divmod(a, b)` 等价于 `c = (a // b, a % b)`。
- en: 'Python also has `bitwise` operators, which I’ll list below for those readers
    already familiar with bitwise arithmetic. I won’t introduce these concepts until
    Chapter 12:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还具有 `bitwise` 运算符，下面列出了这些运算符，供那些已经熟悉位运算的读者参考。直到第12章，我才会介绍这些概念：
- en: '[PRE78]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Listing 3-15: *bitwise_operators.py*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-15: *bitwise_operators.py*'
- en: The math Module
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`math` 模块'
- en: 'Python provides plenty of additional functions in the `math` module, along
    with the five most common math constants: `pi`, `tau`, `e`, `inf`, and `nan`.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了丰富的 `math` 模块函数，以及五个最常见的数学常量：`pi`、`tau`、`e`、`inf` 和 `nan`。
- en: '[PRE79]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Listing 3-16: *math_constants.py*'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-16: *math_constants.py*'
- en: All five constants are floats and can be directly used as such ❶. The official
    documentation provides a complete list of everything available in the `math` module.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个常量都是浮点数，可以直接作为浮点数使用 ❶。官方文档提供了 `math` 模块中所有可用内容的完整列表。
- en: 'You might remember a little trick from high school trigonometry, where you
    could calculate the height of something using your distance to it and the angle
    from your vantage point to the top of the object. Here’s a way to calculate that
    with Python, using the `math` module:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得高中三角学的一些技巧，你可以利用与物体的距离和从你的视角到物体顶部的角度来计算物体的高度。以下是使用 Python 计算这一点的方法，借助
    `math` 模块：
- en: '[PRE80]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Listing 3-17: *surveying_height.py*'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-17: *surveying_height.py*'
- en: 'I use two functions from the `math` module: `math.radians()` ❶ and `math.tan()`
    ❷. The `round()` function ❸ is built into the language itself.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了 `math` 模块中的两个函数：`math.radians()` ❶ 和 `math.tan()` ❷。`round()` 函数 ❸ 是语言本身内置的。
- en: Logic
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑
- en: Python’s clean, obvious syntax for logical expressions is one of the attractive
    elements of the language. Here, I’ll cover conditional statements and expressions,
    as well as the comparison and logic operators.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的简洁、直观的逻辑表达式语法是该语言的一个吸引人的特点。在这里，我将介绍条件语句和表达式，以及比较和逻辑运算符。
- en: Conditionals
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Conditionals are compound statements composed of `if`, `elif`, and `else` clauses,
    each made up of a header and a suite. As with most languages, you can have as
    many `elif` conditionals in Python as you want, sandwiched between `if` and (optionally)
    `else`. Here’s a really simple example:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句是由 `if`、`elif` 和 `else` 子句组成的复合语句，每个子句由头部和语句块构成。和大多数语言一样，你可以在 Python 中有任意数量的
    `elif` 条件，夹在 `if` 和（可选的）`else` 之间。这里有一个非常简单的示例：
- en: '[PRE81]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Listing 3-18: *conditional_greet.py*'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-18: *conditional_greet.py*'
- en: This conditional statement is made up of three clauses. The `if` clause evaluates
    first, and if the expression in its header evaluates to `True`, its suite runs,
    printing `"Hello!"` Otherwise, it evaluates the expression in the `elif` header
    next. If none of the expressions evaluate to `True`, then the `else` clause runs.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件语句由三个子句组成。`if`子句首先进行评估，如果其头部的表达式评估为`True`，则执行其语句块，打印`"Hello!"`。否则，接着评估`elif`头部的表达式。如果没有任何表达式评估为`True`，则执行`else`子句。
- en: You’ll notice you don’t need to wrap the conditional expressions, such as `command
    == "greet"`, in parentheses, although you may do so anyway if it helps clarify
    your code. You’ll see an example of this shortly.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，不需要将条件表达式（例如`command == "greet"`）用括号括起来，尽管如果有助于清晰代码，你仍然可以这么做。稍后你会看到一个例子。
- en: If you’re looking for something similar to the `switch` statement from your
    favorite programming language, see the “Structural Pattern Matching” section toward
    the end of this chapter.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找类似于你喜欢的编程语言中的`switch`语句的功能，请查看本章末尾的“结构模式匹配”部分。
- en: Comparison Operators
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'Python has all the comparison operators you’d expect. Take a look at these
    in the context of comparing two integers:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: Python有你所期待的所有比较运算符。看看在比较两个整数时这些运算符是如何使用的：
- en: '[PRE82]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 3-19: *comparison_operators.py*'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-19: *comparison_operators.py*'
- en: As you can see, Python has operators for `equals`, `not equals`, `less than`,
    `less than or equals`, `greater than`, and `greater than or equals`.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python有`equals`、`not equals`、`less than`、`less than or equals`、`greater
    than`和`greater than or equals`运算符。
- en: No surprises there, but what about boolean comparisons? This is where Python
    takes a different line.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这没什么意外的，但布尔值比较怎么样？这是Python与众不同的地方。
- en: Boolean, None, and Identity Operators
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值、None 和标识运算符
- en: Python offers the values `True` and `False`, which are the two values for boolean
    (type `bool`) variables. It also has a dedicated `None` value (type `NoneType`),
    which serves in the capacity of a “null” value.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了`True`和`False`这两个布尔（类型`bool`）值。它还具有专用的`None`值（类型`NoneType`），作为“空”值使用。
- en: You check for these values in a very different way than with other data types.
    Instead of the comparison operators, use the special *identity operator* `is`.
    (I’ll also use the logical operator `not` below, which I’ll discuss separately
    in a bit.)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 你检查这些值的方式与其他数据类型非常不同。不是使用比较运算符，而是使用特殊的*标识运算符*`is`。（我下面也会使用逻辑运算符`not`，稍后我会单独讨论这个。）
- en: 'Here’s an example:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE83]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Listing 3-20: *boolean_identity_operators.py*'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-20: *boolean_identity_operators.py*'
- en: Aside from being a little high in sodium, that code shows the many ways of testing
    boolean values and checking for `None`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有点高钠，这段代码展示了测试布尔值和检查`None`的多种方法。
- en: You can test if a variable is set to `True`, `False`, or `None` by comparing
    with the `is` operator. You can also invert the logic with `is not`.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过与`is`运算符进行比较来测试一个变量是否设置为`True`、`False`或`None`。你也可以使用`is not`来反转逻辑。
- en: Most commonly, when testing against `True`, you can use the variable as the
    entire condition ❶. For `False`, invert that condition test with `not` ❷.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况是，在测试`True`时，你可以将变量作为整个条件❶。对于`False`，则用`not`反转这个条件测试❷。
- en: Take particular note of the last condition, which illustrates an important gotcha
    with the `is` operator ❸. It actually compares the identity of the variables,
    rather than the value. This is particularly troublesome, as the logic looks sound
    but is a bug waiting for a place to happen. That probably doesn’t mean much to
    you yet, but rest assured, I’ll cover this concept in depth in Chapter 5.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意最后一个条件，它展示了`is`运算符❸的一个重要陷阱。它实际上比较的是变量的标识，而不是值。这是特别麻烦的，因为逻辑看起来是合理的，但实际上是一个等待发生的bug。虽然你可能现在还不完全理解，但放心，我将在第五章深入讲解这个概念。
- en: 'For now, you can take this rule for granted: use `is` *only* for comparing
    directly to `None`, and use regular comparison operators for everything else.
    In practice, we usually say `if spam` or `if not spam`, instead of directly comparing
    to `True` or `False`.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以放心遵循这个规则：仅在与`None`直接比较时使用`is`，其他情况使用常规比较运算符。在实际中，我们通常会说`if spam`或`if not
    spam`，而不是直接与`True`或`False`比较。
- en: Truthiness
  id: totrans-648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值判断
- en: Most expressions and values in Python can be evaluated to a `True` or `False`
    value. This is typically done by using the value as an expression by itself, although
    you can also pass it to the `bool()` function to convert it explicitly.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的大多数表达式和值都可以被评估为`True`或`False`。通常是通过将该值作为单独的表达式来完成的，尽管你也可以将它传递给`bool()`函数进行显式转换。
- en: '[PRE84]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Listing 3-21: *truthiness.py*'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-21: *truthiness.py*'
- en: When an expression will evaluate to `True`, it is considered “truthy.” When
    it will evaluate to `False`, it is “falsey.” The `None` constant, values representing
    zero, and empty collections are all considered “falsey,” while most other values
    are “truthy.”
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式的结果为`True`时，它被认为是“真值”。当结果为`False`时，它被认为是“假值”。`None`常量、表示零的值以及空集合都被认为是“假值”，而其他大多数值则是“真值”。
- en: Logical Operators
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'If you’re coming from a language where logical operators are a little more
    difficult to remember, you’ll find Python refreshing: it simply uses the keywords
    `and`, `or`, and `not`!'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自一个逻辑运算符稍显复杂的语言，你会发现Python的方式很清新：它简单地使用关键字`and`、`or`和`not`！
- en: '[PRE85]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Listing 3-22: *logical_operators.py*'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-22: *logical_operators.py*'
- en: With the `and` condition, both expressions must evaluate to `True`. With the
    `or` condition, one or the other (or both) must evaluate to `True`. The third
    condition adds `not` to the picture, requiring that `eggs` be `False` and `spam`
    be `True`.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`and`条件时，两个表达式都必须评估为`True`。使用`or`条件时，至少一个（或者两个）必须评估为`True`。第三种条件加入了`not`，要求`eggs`为`False`，而`spam`为`True`。
- en: I could have omitted the parentheses on the third condition, as `not` takes
    precedence and so is evaluated before `and`. However, the parentheses help to
    clarify my intended logic.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以省略第三个条件中的括号，因为`not`的优先级更高，所以会在`and`之前被评估。然而，括号有助于澄清我意图的逻辑。
- en: 'In practice, you can use the `not` keyword to invert any conditional expression,
    such as in the following:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以使用`not`关键字来反转任何条件表达式，如下所示：
- en: '[PRE86]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Listing 3-23: *not_operators.py*'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-23: *not_operators.py*'
- en: 'Both comparisons do the same thing; the issue becomes readability. In this
    case, the expression using `not` is less readable because your eyes might skip
    over the `not` keyword, so you might not catch what’s happening in the code. The
    condition employing the `!=` operator is preferred for readability. While you
    might find situations where `not` is the best way to invert your conditional logic,
    remember The Zen of Python: ***Readability counts!***'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 两种比较做的是一样的；问题在于可读性。在这种情况下，使用`not`的表达式可读性较差，因为你的眼睛可能会跳过`not`关键字，因此你可能不会注意到代码中发生了什么。使用`!=`运算符的条件更有可读性。虽然你可能会发现`not`在某些情况下是反转条件逻辑的最佳方式，但请记住Python的禅意：***可读性最重要！***
- en: The Walrus Operator
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 海象运算符
- en: Python 3.8 introduced *assignment expressions*, which allow you to assign a
    value to a variable and use that variable in another expression at the same time.
    This is possible with the so-called *walrus operator* (`:=`).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.8引入了*赋值表达式*，允许你将一个值赋给变量并在同一时间将该变量用于另一个表达式。这通过所谓的*海象运算符*（`:=`）实现。
- en: '[PRE87]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Listing 3-24: *walrus.py*'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-24: *walrus.py*'
- en: With the walrus operator, Python first evaluates the expression on the left
    (`7+5`) and then assigns it to the variable `eggs`. The assignment expression
    is enclosed in parentheses for readability, although I technically could have
    omitted them.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 使用海象运算符时，Python首先计算左侧的表达式（`7+5`），然后将其赋值给变量`eggs`。赋值表达式被括号包围以增强可读性，尽管从技术上讲，我本可以省略这些括号。
- en: The assignment expression is then evaluated to a single value, namely the value
    of `eggs`, which is used in the comparison. Since the value is `12`, the condition
    evaluates to `True`.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，赋值表达式会被评估为一个单一的值，即`eggs`的值，这个值用于比较。由于值是`12`，所以条件评估为`True`。
- en: What’s interesting about the assignment expression is that `eggs` is now a valid
    variable in the outer scope, so I can print its value outside of the conditional.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式有趣之处在于`eggs`现在是外部作用域中的有效变量，因此我可以在条件外部打印它的值。
- en: This feature is potentially useful in many scenarios, not only in conditional
    expressions, as above.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在许多场景中都可能非常有用，不仅仅是在像上面那样的条件表达式中。
- en: 'Assignment expressions and the walrus operator were defined in PEP 572, which
    also contains an in-depth discussion about when and where this feature should
    be used. Two particularly useful style rules are put forth by this PEP:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式和海象运算符是在PEP 572中定义的，该PEP还深入讨论了何时以及在何处使用此功能。此PEP提出了两条特别有用的风格规则：
- en: If either assignment statements or assignment expressions can be used, then
    prefer statements; they are clear declarations of intent.
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果既可以使用赋值语句也可以使用赋值表达式，优先选择语句；它们是意图的明确声明。
- en: If using assignment expressions would lead to ambiguity about execution order,
    then restructure to use statements instead.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用赋值表达式会导致执行顺序上的歧义，则应重构代码改用语句。
- en: As of the writing of this book, Python assignment expressions are still in their
    infancy. A lot of debate and controversy still surrounds them. In any case, resist
    the temptation to abuse the walrus operator to cram as much logic onto one line
    as possible. You should always aim for readability and clarity in your code, above
    all else.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本书撰写时，Python 赋值表达式仍处于初期阶段，围绕它们的争论和争议仍然存在。无论如何，避免滥用海象运算符，把尽可能多的逻辑挤到一行中。你应该始终以代码的可读性和清晰性为首要目标。
- en: Ellipsis
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 省略号
- en: 'One seldom-used piece of syntax is the *Ellipsis*:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很少使用的语法是 *省略号*：
- en: '[PRE88]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is sometimes used by various libraries and modules, but seldom consistently.
    For example, it’s used with multidimensional arrays in the NumPy third-party library
    and when working with type hints from the built-in `typing` module. When you see
    it come up, consult the documentation for whatever module you’re using.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时被各种库和模块使用，但不常一致。例如，它在 NumPy 第三方库中的多维数组中使用，也用于处理来自内置 `typing` 模块的类型提示。当你看到它时，查阅你正在使用的模块的文档。
- en: Strings
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'There are a few things to know about strings as you move forward. Here, I’ll
    cover the three kinds of strings: string literals, raw strings, and formatted
    strings.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进时，有几件关于字符串的事情需要了解。在这里，我将介绍三种字符串类型：字符串字面量、原始字符串和格式化字符串。
- en: String Literals
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: 'There are multiple ways of defining a *string literal*:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *字符串字面量* 的方法有多种：
- en: '[PRE89]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Listing 3-25: *string_literals.py*'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-25: *string_literals.py*'
- en: You can wrap a literal in double quotes (`"`), single quotes (`'`), or triple
    quotes (`"""`) of either type. You may remember from earlier that there’s something
    special about triple quotes, but I’ll come back to that in a moment.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用双引号（`"`）、单引号（`'`）或三引号（`"""`）括起来字面量。你可能还记得之前提到过三引号有特别之处，但稍后我会再谈到这个。
- en: 'PEP 8 addresses the use of single and double quotes:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8 讨论了单引号和双引号的使用：
- en: In Python, single-quoted strings and double-quoted strings are the same. This
    PEP does not make a recommendation for this. Pick a rule and stick to it. When
    a string contains single or double quote characters, however, use the other one
    to avoid backslashes in the string. It improves readability.
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Python 中，单引号字符串和双引号字符串是一样的。本 PEP 并未对此做出推荐。选择一个规则并坚持使用。然而，当字符串中包含单引号或双引号字符时，应使用另一种引号，以避免在字符串中使用反斜杠。这能提高可读性。
- en: 'The advice about placing quotes inside a string comes in handy when dealing
    with something like this:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在字符串中放置引号的建议，在处理类似这样的情况时非常有用：
- en: '[PRE90]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Listing 3-26: *escaping_quotes.py:1a*'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-26: *escaping_quotes.py:1a*'
- en: This version escapes the double quotes I want to include in the string literal
    itself. The backslash (`\`) before the quotes means I want the string to contain
    that *literal character*, not to have Python treat the double quote as the boundary
    of a string. The string literal must always be wrapped in matching quotes.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本转义了我希望包含在字符串字面量中的双引号。引号前的反斜杠 (`\`) 表示我希望字符串包含该*字面字符*，而不是让 Python 将双引号视为字符串的边界。字符串字面量必须始终用匹配的引号括起来。
- en: 'It is possible to avoid backslashes in this scenario, however:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，虽然可以避免使用反斜杠，但：
- en: '[PRE91]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Listing 3-27: *escaping_quotes.py:1b*'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-27: *escaping_quotes.py:1b*'
- en: This second version wraps the literal in single quotes, so the double quotes
    will be automatically interpreted as part of the string literal. That approach
    is much more readable. By wrapping the string in single quotes, Python will assume
    the double quotes are characters in the string.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种版本将字面量包裹在单引号中，这样双引号将被自动解释为字符串字面量的一部分。这个方法更加可读。通过使用单引号包裹字符串，Python 会认为双引号是字符串中的字符。
- en: 'The only time you’d really need to escape either single or double quotes with
    backslashes would be if you had both types of quotes in the string at once:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 你真的需要用反斜杠转义单引号或双引号的唯一情况是当字符串中同时包含这两种类型的引号时：
- en: '[PRE92]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Listing 3-28: *escaping_quotes.py:2a*'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-28: *escaping_quotes.py:2a*'
- en: Personally, in cases like that, I’d prefer to use (and escape) the double quotes,
    because they don’t evade my attention like an apostrophe would tend to do.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，在这种情况下，我更倾向于使用（并转义）双引号，因为它们不像撇号那样容易引起我的注意。
- en: 'You also have the option to use triple quotes:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以选择使用三引号：
- en: '[PRE93]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Listing 3-29: *escaping_quotes.py:2b*'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-29: *escaping_quotes.py:2b*'
- en: 'Remember that triple quotes define *multiline string literals*. In other words,
    I can use them to do this:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，三引号定义了*多行字符串字面量*。换句话说，我可以用它们做这样的事情：
- en: '[PRE94]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Listing 3-30: *multiline_string.py*'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-30: *multiline_string.py*'
- en: Everything, including newlines and leading whitespace, is literal in triple
    quotes. If I `print("parrot")`, it will display exactly like this in the terminal.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 三引号中的所有内容，包括换行符和前导空格，都是字面上的。如果我执行 `print("parrot")`，终端将会精确地显示这样内容。
- en: The only exception occurs when you use a backslash (`\`) to escape a particular
    character, like I did with that newline at the beginning ❶. It is conventional
    to escape the first newline after the opening triple quotes, just to make the
    code look cleaner.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是当你使用反斜杠（`\`）来转义特定字符时，就像我在开始时用来转义换行符❶那样。通常做法是转义开头的第一个换行符，只是为了让代码看起来更清晰。
- en: The built-in `textwrap` module has some functions for working with multiline
    strings, including tools that allow you remove leading indentation (`textwrap.dedent`).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `textwrap` 模块提供了一些处理多行字符串的函数，包括允许你去除前导缩进的工具（`textwrap.dedent`）。
- en: Alternatively, you can *concatenate* (combine) string literals, simply by writing
    them next to one another, without any operators between them. For example, `spam
    = "Hello " "world" "!"` is valid, resulting in the string `Hello world!.` If you
    wrap the assignment expression in parentheses, you can even span multiple lines.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以*连接*（合并）字符串字面量，只需将它们并排写在一起，不需要任何运算符。例如，`spam = "Hello " "world" "!"` 是有效的，结果将是字符串
    `Hello world!`。如果你将赋值表达式括在括号中，甚至可以跨越多行。
- en: Raw Strings
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始字符串
- en: '*Raw strings* constitute another form of string literal, wherein the backslash
    (`\`) is always treated as a literal character. They’re preceded with an `r`,
    such as in this example:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始字符串*是另一种形式的字符串字面量，其中反斜杠（`\`）总是被视为字面字符。它们以 `r` 为前缀，像这个例子：'
- en: '[PRE95]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Listing 3-31: *raw_string.py*'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-31: *raw_string.py*'
- en: 'The backslash is treated like a literal character, which means that nothing
    can be escaped inside of a raw string. The output of that line of code looks like
    this:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠被当作字面字符对待，这意味着在原始字符串中无法转义任何内容。那行代码的输出如下所示：
- en: '[PRE96]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This has implications for what type of quotes you use, so beware.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你使用哪种引号有影响，因此要注意。
- en: 'Compare these two lines and their outputs:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两行及其输出：
- en: '[PRE97]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Listing 3-32: *raw_or_not.py*'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-32: *raw_or_not.py*'
- en: 'The first string is ordinary, so `\n` is treated as a normal escape sequence:
    specifically, the newline character. That line break appears in the output, like
    this:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符串是普通字符串，因此 `\n` 被当作普通转义序列：具体来说是换行符。该换行符会出现在输出中，如下所示：
- en: '[PRE98]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The second string is a raw string, so the backslash (`\`) is treated as a literal
    character in its own right. The output would be as follows:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字符串是原始字符串，因此反斜杠（`\`）被当作字面字符对待。输出将如下所示：
- en: '[PRE99]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This is particularly useful for regular expression patterns, where you’re likely
    to have plenty of backslashes that you want as part of the *pattern*, not interpreted
    by Python before it gets there. ***Always use raw strings for regular expression
    patterns.***
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于正则表达式模式尤其有用，因为在模式中你可能会有许多反斜杠，这些反斜杠应该作为*模式*的一部分，而不是在到达那里之前被 Python 解析。***正则表达式模式中永远使用原始字符串。***
- en: Formatted Strings
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化字符串
- en: A third kind of string literal is a *formatted string* or *f-string*, which
    is new as of Python 3.6 (defined in PEP 498). It allows you to insert the values
    of variables into a string in a very elegant manner.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种字符串字面量是*格式化字符串*或*f-字符串*，这是 Python 3.6 新增的（在 PEP 498 中定义）。它允许你以非常优雅的方式将变量的值插入到字符串中。
- en: 'If I wanted to include the value of a variable in a string without an f-string,
    the code might look like this:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想在字符串中包含一个变量的值，而不使用 f-字符串，代码可能如下所示：
- en: '[PRE100]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Listing 3-33: *cheese_shop.py:1a*'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-33: *cheese_shop.py:1a*'
- en: The `str()` function converts the value passed to it into a string, and then
    the three strings are *concatenated*, or combined, into one, using the `+` operator.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()` 函数将传入的值转换为字符串，然后这三段字符串*连接*（合并）成一个字符串，使用 `+` 运算符。'
- en: Using f-strings, this code becomes more elegant.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 f-字符串后，这段代码变得更加优雅。
- en: '[PRE101]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Listing 3-34: *cheese_shop.py:1b*'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-34: *cheese_shop.py:1b*'
- en: You precede the string literal with an `f`. Inside, you can substitute a variable
    by wrapping it in curly braces (`{ }`). The `f` tells Python to interpret and
    evaluate as an expression anything in the string that’s wrapped in curly braces.
    This means you’re not limited to variables in those curly braces. You can put
    just about any valid Python code in there, including math, function calls, conditional
    expressions, or whatever you need.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 你在字符串字面量前加上一个`f`。在其中，你可以通过将变量包裹在大括号（`{ }`）中来替换它。`f`告诉Python解释并评估字符串中被大括号包裹的任何表达式。这意味着在这些大括号中，你不仅限于使用变量。你可以在其中放入几乎任何有效的Python代码，包括数学运算、函数调用、条件表达式或任何你需要的内容。
- en: As of Python 3.8, you can even display both the expression *and* its result
    by appending a trailing equal sign (`=`).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.8开始，你甚至可以通过在表达式后追加等号（`=`）来显示表达式*和*其结果。
- en: '[PRE102]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Listing 3-35: *expression_fstring.py*'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-35: *expression_fstring.py*'
- en: 'There are a couple of gotchas when using f-strings:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 使用f-string时有几个小陷阱：
- en: 'First, if you want to wrap an expression in literal curly braces, you must
    use two curly braces (`{{ }}`) for every one you want displayed:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你想在字面上使用大括号包裹表达式，你必须使用两个大括号（`{{ }}`）来表示每个你想显示的大括号：
- en: '[PRE103]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Listing 3-36: *literal_curly_braces.py*'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-36: *literal_curly_braces.py*'
- en: 'If you have an odd number of braces, one pair will be ignored. So, if I used
    five pairs, the result would be the same as if I only had four: two literal pairs
    would be printed.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有奇数对大括号，其中一对会被忽略。因此，如果我用了五对大括号，结果就和只有四对大括号一样：会打印两个字面量的大括号对。
- en: 'Second, you cannot use backslashes within an expression in an f-string. This
    makes it difficult to escape quotes inside expressions. For example, this would
    not work:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你不能在f-string的表达式中使用反斜杠。这使得在表达式中转义引号变得困难。例如，下面的代码无法正常工作：
- en: '[PRE104]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: To get around this, I’d need to use triple quotes on the outside of the string,
    to ensure I can employ both single and double quotes inside of the expression.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我需要在字符串外部使用三引号，以确保我可以在表达式中同时使用单引号和双引号。
- en: '[PRE105]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Backslashes have other roles. The documentation points out the following problematic
    situation:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠有其他的作用。文档指出了以下问题情况：
- en: '[PRE106]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: There’s no direct way around this limitation. Instead, you’d have to evaluate
    that expression in advance, assign the result to a name, and use it in the f-string.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制没有直接的解决方法。相反，你必须先计算这个表达式，将结果赋值给一个变量，并在f-string中使用它。
- en: '[PRE107]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Third, and perhaps least surprising, you cannot put comments inside of f-string
    expressions; the hash (`#`) symbol isn’t allowed, except as a string literal.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，或许是最不令人惊讶的一点，你不能在f-string表达式中放置注释；井号（`#`）符号是不允许的，除非它是字符串字面量。
- en: '[PRE108]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Lastly, you can never use f-strings as docstrings.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你永远不能将f-string用作文档字符串。
- en: These small wrinkles aside, f-strings are incredibly straightforward to work
    with.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些小瑕疵外，f-string的使用非常简单明了。
- en: Format Specifications
  id: totrans-755
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 格式说明
- en: Besides arbitrary expressions, f-strings support *format specifications*, which
    allow you to control how values are displayed. This is a fairly in-depth topic
    that could easily become a main section on its own, so I will entrust you to the
    guidance of the documentation for the bulk of it. I’ll breeze over the essentials
    herein.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 除了任意表达式外，f-string还支持*格式说明符*，它们允许你控制值的显示方式。这是一个相当深入的话题，完全可以单独成为一个章节，因此我将把大部分内容留给文档来指导。这里我会简要介绍一些要点。
- en: 'Immediately after the expression, you may choose to include one of three special
    flags: `!r`, `!a`, or `!s` (although that last one is the default behavior, so
    it can be omitted in most cases). These determine which function is used to fetch
    the string representation of some value: `repr()`, `ascii()`, or `str()`, respectively
    (see “String Conversion” below).'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟在表达式之后，你可以选择包括三个特殊标志之一：`!r`、`!a`或`!s`（虽然最后一个是默认行为，因此在大多数情况下可以省略）。这些标志决定了用于获取某个值的字符串表示的函数：`repr()`、`ascii()`或`str()`，分别对应（请参见“字符串转换”部分）。
- en: 'Next comes the format specification itself, which always begins with a colon
    (`:`), followed by one or more flags. These have to be specified in a particular
    order to work, although any of them may be omitted if they’re not desired:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是格式说明符本身，它总是以冒号（`:`）开始，后跟一个或多个标志。为了使其工作，这些标志必须按特定的顺序指定，虽然如果不需要，它们中的任何一个都可以省略：
- en: Align An alignment flag, specifying left (`<`), right (`>`), center (`^`), or
    (if numeric) split with the sign aligned left but the digits aligned right (`=`).
    This is optionally preceded by a character that will be used to fill any blank
    space in the alignment.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐 一个对齐标志，指定左对齐（`<`）、右对齐（`>`）、居中（`^`），或者（如果是数字）用符号左对齐，但数字右对齐（`=`）。这个标志可以前置一个字符，用来填充对齐时的空白空间。
- en: Sign A flag controlling when the sign is displayed on a number. The plus (`+`)
    flag displays the sign on both positive and negative numbers, while the minus
    (`–`) flag only displays it on negative numbers. A third option is to show a leading
    space on positive numbers and a sign on negative numbers (space).
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 一个标志，控制数字何时显示符号。加号（`+`）标志会在正数和负数上都显示符号，而减号（`–`）标志只在负数上显示符号。第三种选项是在正数前显示空格，在负数前显示符号（空格）。
- en: Alternative form The hash (`#`) flag turns on the “alternative form,” which
    has different meanings for different types (see documentation).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 替代形式 井号（`#`）标志启用“替代形式”，对于不同类型有不同的含义（参见文档）。
- en: Leading zeros The zero (`0`) flag causes leading zeros to be displayed (unless
    a fill character is specified for alignment).
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 前导零 零（`0`）标志会显示前导零（除非为对齐指定了填充字符）。
- en: Width The width of the output string in characters. This is where the alignment
    comes into play.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度 输出字符串的宽度，以字符为单位。这就是对齐起作用的地方。
- en: Grouping A flag controlling whether numbers should separate thousands with a
    comma (`,`) or an underscore (`_`). If omitted, no separator is used. If enabled,
    the underscore separator also appears every four digits in octal, hexadecimal,
    and binary numbers.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 分组 一个标志，控制数字是否应该用逗号（`,`) 或下划线（`_`）分隔千位。如果省略，则不使用分隔符。如果启用，下划线分隔符在八进制、十六进制和二进制数字中，每四位也会出现。
- en: Precision A dot (`.`), followed by an integer for decimal precision.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 精度 一个点（`.`），后跟一个整数，表示小数精度。
- en: Type A flag controlling how numbers are displayed; common options include binary
    (`b`), character (`c`), decimal (`d`), hexadecimal (`x`), exponent notation (`e`),
    fixed-point (`f`), and general (`g`). There are more (see documentation).
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 一个标志，控制数字的显示方式；常见的选项包括二进制（`b`）、字符（`c`）、十进制（`d`）、十六进制（`x`）、指数表示法（`e`）、定点数（`f`）和通用（`g`）。还有更多选项（见文档）。
- en: 'All that is a bit abstract, so here are a few quick examples:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容有些抽象，所以这里有几个简短的示例：
- en: '[PRE109]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Listing 3-37: *formatting_strings.py*'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-37: *formatting_strings.py*'
- en: 'Complete details about the format specification can be found in the official
    Python documentation: [https://docs.python.org/3/library/string.html#format-string-syntax](https://docs.python.org/3/library/string.html#format-string-syntax).'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明的完整细节可以在官方 Python 文档中找到：[https://docs.python.org/3/library/string.html#format-string-syntax](https://docs.python.org/3/library/string.html#format-string-syntax)。
- en: Another useful reference is [https://pyformat.info](https://pyformat.info),
    although as of this writing, it only shows the format specification in the context
    of the old `format()` function. You will need to apply it to f-strings yourself.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的参考是 [https://pyformat.info](https://pyformat.info)，尽管截至本文写作时，它仅在旧版 `format()`
    函数的上下文中显示格式说明。你需要将其应用到 f-strings 上。
- en: Previous String-Formatting Methods
  id: totrans-772
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 之前的字符串格式化方法
- en: 'If you’re reading older Python code, you may encounter the two previous forms
    of string formatting: `%` notation and the newer `format()`. These have both been
    superseded by f-strings, which have superior performance. That’s because they’re
    parsed and converted to bytecode *before* the code is run.'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在阅读旧的 Python 代码时，可能会遇到两种以前的字符串格式化方式：`%` 符号和较新的 `format()`。这两者都已被 f-strings
    取代，因为 f-strings 在性能上更优。那是因为它们在代码运行之前就已经被解析并转换为字节码。
- en: If you find yourself needing to rewrite a `format()` call as an f-string, the
    process is thankfully quite simple.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要将 `format()` 调用重写为 f-string，幸运的是，这个过程非常简单。
- en: 'Here’s an example. I’ll start out with a couple of variables:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例。我将从几个变量开始：
- en: '[PRE110]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Listing 3-38: *format_to_fstring.py:1*'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-38: *format_to_fstring.py:1*'
- en: 'Before the advent of f-strings, if I wanted to print out a message containing
    the values of those two variables, I’d have used `format()`:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在 f-strings 出现之前，如果我想打印出包含这两个变量值的消息，我会使用 `format()`：
- en: '[PRE111]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Listing 3-39: *format_to_fstring.py:2a*'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-39: *format_to_fstring.py:2a*'
- en: In the old format, a string literal ❶ would contain sets of curly braces, optionally
    containing the format specifications. The `format()` function would be called
    on that string literal (or on a name referencing it). Then, the expressions to
    be evaluated would be passed to the `format()` function in order ❷.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧格式中，字符串文字 ❶ 会包含一对花括号，里面可以选择性地包含格式规范。然后会在该字符串文字（或引用它的名称）上调用 `format()` 函数。接着，待评估的表达式会按照顺序
    ❷ 传递给 `format()` 函数。
- en: 'That would have the following output:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下输出：
- en: '[PRE112]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Converting this to an f-string is as simple as moving the expressions into
    the string literal in order and then prepending an `f` to the literal to make
    it an f-string:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为 f-string 的方法非常简单：将表达式按顺序移入字符串文字中，然后在文字前加上 `f` 使其成为 f-string：
- en: '[PRE113]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Listing 3-40: *format_to_fstring.py:2b*'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-40: *format_to_fstring.py:2b*'
- en: The output is the same as before.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与之前相同。
- en: 'Optionally, with `format()`, you could refer to the index of the expression
    in the argument list:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，使用 `format()`，你可以引用表达式在参数列表中的索引：
- en: '[PRE114]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Listing 3-41: *format_to_fstring.py:3a*'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-41: *format_to_fstring.py:3a*'
- en: 'That produces this output:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下输出：
- en: '[PRE115]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'To convert this code to an f-string, you substitute the expressions in place
    of the indices in the string literal, which you (again) turn into an f-string
    by prepending an `f`:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这段代码转换为 f-string，你需要将表达式替换为字符串文字中的索引，然后通过在文字前加上 `f` 将其变为 f-string：
- en: '[PRE116]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Listing 3-42: *format_to_fstring.py:3b*'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-42: *format_to_fstring.py:3b*'
- en: Converting from `%` notation is a little less trivial, but most Python 3 code
    uses `format()` anyway. If you find yourself needing to do this, [https://pyformat.info](https://pyformat.info)
    does an excellent job of comparing `%` notation and `format()`.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `%` 语法转换过来稍微有点复杂，但大多数 Python 3 代码还是使用 `format()`。如果你发现自己需要这样做，[https://pyformat.info](https://pyformat.info)
    对 `%` 语法和 `format()` 进行了很好的比较。
- en: Template Strings
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板字符串
- en: '*Template strings* constitute one more alternative to f-strings that is worth
    knowing about, especially as it still fulfills some use cases, including internationalizing
    user interfaces. Personally, I find template strings a bit more reusable. On the
    other hand, the drawback is that they’re considerably more limited in terms of
    formatting.'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板字符串* 是另一种值得了解的 f-string 替代方案，特别是它仍然满足一些使用场景，包括国际化用户界面。就个人而言，我发现模板字符串更具可重用性。另一方面，缺点是它们在格式化方面的功能相对有限。'
- en: If you know how they work, you’ll be equipped to decide for yourself which tool
    is best for your particular situation.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道它们是如何工作的，你将能够为自己决定哪种工具最适合你的特定情况。
- en: 'Here’s a template string for greeting a user:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于问候用户的模板字符串：
- en: '[PRE117]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Listing 3-43: *template_string.py:1*'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-43: *template_string.py:1*'
- en: To use template strings, I first have to import `Template` from the `string`
    module.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板字符串时，我首先需要从 `string` 模块导入 `Template`。
- en: 'Then I can create a new `Template` and pass it a string literal:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以创建一个新的 `Template` 并将字符串文字传递给它：
- en: '[PRE118]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Listing 3-44: *template_string.py:2*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-44: *template_string.py:2*'
- en: I can name my fields whatever I want, preceding each with a dollar sign (`$`).
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以根据需要给字段命名，在每个字段前加上美元符号（`$`）。
- en: 'Finally, I call the `substitute()` function on the template I created (`s`)
    and pass expressions to each of the fields:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我在我创建的模板（`s`）上调用 `substitute()` 函数，并将表达式传递给每个字段：
- en: '[PRE119]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Listing 3-45: *template_string.py:3*'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-45: *template_string.py:3*'
- en: 'The finished string is returned, and in this case, it is passed to `print()`
    and displayed:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的字符串会被返回，在这种情况下，它会被传递给 `print()` 并显示出来：
- en: '[PRE120]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'There are a couple of odd syntax rules with template strings. First, to show
    a literal dollar sign in the string literal, use two dollar signs (`$$`). Second,
    to substitute an expression as part of a word, wrap the name of the field in curly
    braces (`{ }`). Both of these rules are demonstrated below:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串有几个奇怪的语法规则。首先，要在字符串文字中显示字面上的美元符号，请使用两个美元符号（`$$`）。其次，要将表达式作为单词的一部分进行替换，请将字段的名称用花括号（`{
    }`）括起来。以下示范了这两条规则：
- en: '[PRE121]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Listing 3-46: *template_string.py:4*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-46: *template_string.py:4*'
- en: 'That outputs the following:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE122]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: There’s a handful of additional abilities contained within string templates,
    but I’ll entrust you to the official Python documentation for the rest of that.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模板中包含一些额外的功能，但剩下的部分请参考官方的 Python 文档。
- en: String Conversion
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串转换
- en: 'I previously mentioned that there are three ways to get the string representation
    of a value: `str()`, `repr()`, and `ascii()`.'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，有三种方式可以获取值的字符串表示：`str()`、`repr()` 和 `ascii()`。
- en: The first function, `str()`, is the one you’ll use most often, as it returns
    the *human-readable* representation of the value.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`str()`是你最常用的函数，因为它返回该值的*人类可读*表示。
- en: 'By contrast, `repr()` returns the *canonical string representation* of the
    value: that is, (usually) the value as Python sees it. In the case of many basic
    data types, this will return the same thing as `str()`, but when used on most
    objects, the output contains additional information useful in debugging.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`repr()`返回的是该值的*标准字符串表示*：也就是说，（通常）是Python如何看待该值的表示。对于许多基本数据类型，这将返回与`str()`相同的内容，但在大多数对象上使用时，输出包含额外的调试信息。
- en: The `ascii()` function is the same as `repr()`, except that the string literal
    it returns is completely ASCII-compatible, having escaped any non-ASCII (for example,
    Unicode) characters.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '`ascii()`函数与`repr()`函数相同，不同之处在于它返回的字符串字面值是完全ASCII兼容的，已对所有非ASCII（例如，Unicode）字符进行了转义。'
- en: I’ll return to this concept in Chapter 7, when I start defining my own objects.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第7章再次回到这个概念，当时我会开始定义我自己的对象。
- en: A Note on String Concatenation
  id: totrans-825
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串拼接说明
- en: Up to this point, I’ve been using the addition (`+`) operator for concatenating
    strings together. This is acceptable in basic situations.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直使用加法（`+`）运算符来拼接字符串。在基本情况下，这种方法是可以接受的。
- en: However, this is seldom the most efficient solution, especially when combining
    multiple strings. Therefore, it is recommended to prefer the `join()` method,
    which is called on a string or string literal instead.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这通常不是最有效的解决方案，特别是当要拼接多个字符串时。因此，建议使用`join()`方法，该方法调用字符串或字符串字面值来完成拼接。
- en: 'Here’s a comparison between the two. I start with a couple of string variables:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两者的对比。我从几个字符串变量开始：
- en: '[PRE123]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Listing 3-47: *concat_strings.py:1*'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-47：*concat_strings.py:1*
- en: 'So far, you’ve seen concatenation with the addition (`+`) operator, like this:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了使用加法（`+`）运算符进行拼接的例子，像这样：
- en: '[PRE124]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Listing 3-48: *concat_strings.py:2a*'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-48：*concat_strings.py:2a*
- en: 'Alternatively, I can use the `join()` method:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，我可以使用`join()`方法：
- en: '[PRE125]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Listing 3-49: *concat_strings.py:2b*'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-49：*concat_strings.py:2b*
- en: I call the `join()` method on the string that will appear between each piece.
    In this case, I use an empty string. The `join()` method accepts a *tuple* of
    strings—an array-like structure wrapped in parentheses, and therefore, the double
    set of parentheses in the code. I’ll introduce tuples in an upcoming section.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 我在每个元素之间调用`join()`方法，这里我使用的是空字符串。`join()`方法接受一个*元组*的字符串——一种像数组一样的结构，包含在括号中，因此代码中的双括号。我将在接下来的章节中介绍元组。
- en: Typical concatenation with `+` or the `join()` function has the same result,
    but the latter function will be *as fast or faster*, especially when you’re using
    other implementations of Python besides CPython. Therefore, whenever you need
    to concatenate and f-strings aren’t right for the job, you should consider using
    `join()` instead of the `+` or `+=` operators. In practice, f-strings are the
    fastest, but `join()` is your next-best option.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`+`或`join()`函数进行的典型拼接会产生相同的结果，但后者函数的性能会*同样快或更快*，特别是当你使用除CPython以外的其他Python实现时。因此，每当你需要拼接字符串且f-strings不适合时，你应该考虑使用`join()`，而不是`+`或`+=`运算符。实际上，f-strings是最快的，但`join()`是下一个最佳选择。
- en: Functions
  id: totrans-839
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: Python functions are *first-class citizens*, which means they can be treated
    like any other object. Even so, you call them as you would in any other programming
    language.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数是*第一类公民*，这意味着它们可以像任何其他对象一样被处理。尽管如此，你调用它们的方式与在其他编程语言中的方式相同。
- en: Here’s an example of a very basic function, which prints a selected type of
    joke to the terminal.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非常基础的函数示例，它会将选定类型的笑话打印到终端。
- en: 'I start with the function header:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 我从函数头开始：
- en: '[PRE126]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Listing 3-50: *joke_function.py:1*'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-50：*joke_function.py:1*
- en: I declared the function with the `def` keyword, followed by the name of the
    function. Parameters are named in the parentheses after the function name. The
    entire header is concluded with a colon (`:`).
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 我用`def`关键字声明了该函数，后面跟上函数的名称。参数在函数名称后的括号内命名。整个函数头以冒号（`:`）结尾。
- en: 'Below the header, indented one level, is the *suite* (or body) of the function:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数头部下面，缩进一级的是函数的*主体*：
- en: '[PRE127]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Listing 3-51: *joke_function.py:2*'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-51：*joke_function.py:2*
- en: 'You call functions in much the same way as in most languages:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用函数的方式与大多数编程语言中的方法非常相似：
- en: '[PRE128]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Listing 3-52: *joke_function.py:3*'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-52：*joke_function.py:3*
- en: I’ll go into depth on functions and their many cousins in Chapter 6.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第6章深入讨论函数及其众多“亲戚”。
- en: Classes and Objects
  id: totrans-853
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象
- en: Python fully supports object-oriented programming. In fact, one of the language’s
    design principles is that “everything is an object,” at least behind the scenes.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: Python 完全支持面向对象编程。事实上，语言设计原则之一就是“万物皆对象”，至少在幕后是这样的。
- en: There’s a lot more to classes than meets the eye, but for now, you should just
    get an absolutely bare-bones familiarity with the syntax.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 类远比眼睛所见的更复杂，但现在，你只需对语法有一个基本的了解。
- en: 'The following class contains a joke of a selected type and displays it on demand:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类包含一个选定类型的笑话，并可以按需显示：
- en: '[PRE129]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Listing 3-53: *joke_class.py:1*'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-53: *joke_class.py:1*'
- en: I define the class using the `class` keyword, the name of the class, and a colon
    (`:`) at the end of the header.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `class` 关键字、类名和一个冒号（`:`）来定义类，在类头的末尾加上冒号。
- en: 'This is followed by the suite of the class, indented one level:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后是类的代码块，缩进一级：
- en: '[PRE130]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Listing 3-54: *joke_class.py:2*'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-54: *joke_class.py:2*'
- en: The initializer, which is similar in purpose to the constructor in other OOP
    languages, is a member function, or *method*, with the name `__init__()` and at
    least one parameter, `self`.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器，类似于其他面向对象语言中的构造函数，是一个成员函数或 *方法*，其名称为 `__init__()`，并且至少接受一个参数 `self`。
- en: '[PRE131]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Listing 3-55: *joke_class.py:3*'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-55: *joke_class.py:3*'
- en: 'Functions that belong to the class are called methods and are part of the class
    suite. Methods must accept at least one parameter: `self`.'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 属于类的函数被称为方法，并且是类的一部分。方法必须至少接受一个参数：`self`。
- en: 'You would use this class like so:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样使用这个类：
- en: '[PRE132]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Listing 3-56: *joke_class.py:4*'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-56: *joke_class.py:4*'
- en: You create a new instance of the `Joke` class by passing the string `"lethal"`
    to its *initializer*, the `__init__()` from earlier. The new object is stored
    in the variable `lethal_joke`.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过将字符串 `"lethal"` 传递给类的 *初始化器* `__init__()` 来创建 `Joke` 类的新实例。新对象存储在变量 `lethal_joke`
    中。
- en: Then, you use the *dot operator* (`.`) to call the function `tell()` within
    the object. Take note that you didn’t have to pass any argument for `self`. That’s
    done automatically when you call the function in this manner.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你使用 *点运算符*（`.`）调用对象内的 `tell()` 函数。请注意，你无需为 `self` 传递任何参数。当你以这种方式调用函数时，`self`
    会自动传递。
- en: I’ll discuss classes and objects in detail in Chapter 7 and further in Chapter
    13.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第7章和第13章详细讨论类和对象。
- en: Error Handling
  id: totrans-873
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: Python offers error and exception handling functionality through the `try` compound
    statement.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了通过 `try` 复合语句进行错误和异常处理的功能。
- en: For example, if I wanted to get a number from the user, I couldn’t reliably
    predict what they would type in. Trying to convert a string, like `"spam"`, to
    an integer would cause an error. I can use error handling to take a different
    action if it isn’t possible to convert the user `input`.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想从用户那里获取一个数字，我无法可靠地预测他们会输入什么。试图将像 `"spam"` 这样的字符串转换为整数会导致错误。我可以使用错误处理来采取不同的行动，如果无法转换用户的
    `input`。
- en: '[PRE133]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Listing 3-57: *try_except.py*'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-57: *try_except.py*'
- en: I get a string from the user, and then in the `try` clause, I attempt to convert
    it to an integer with the `int()` function. That would raise a `ValueError` exception
    if the string it’s trying to convert is not a valid whole number (base 10).
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 我从用户那里获取一个字符串，然后在 `try` 子句中，我尝试使用 `int()` 函数将其转换为整数。如果该字符串无法转换为有效的整数（十进制），则会引发
    `ValueError` 异常。
- en: If that exception is raised, I catch it in the `except` clause and handle the
    failure.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出了异常，我会在 `except` 子句中捕获它并处理失败情况。
- en: In any case, the last line would always be run.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，最后一行总是会被执行。
- en: There are additional features and subtleties to the `try` statement, including
    `finally` and `else` clauses, which I’ll cover in Chapter 8. For now, it’s better
    to avoid these concepts rather than use them incorrectly.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句还有其他的特性和细微差别，包括 `finally` 和 `else` 子句，我将在第8章中讲解。现在，最好避免使用这些概念，以免错误使用。'
- en: Tuples and Lists
  id: totrans-882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组和列表
- en: Two of Python’s most common built-in data structures, called *collections*,
    are tuples and lists.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: Python 最常见的两种内建数据结构，称为 *集合*，分别是元组和列表。
- en: '*Lists* constitute the most array-like collection in Python. In CPython, they
    are implemented as variable-length arrays, not as linked lists like the name might
    suggest.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* 是 Python 中最接近数组的集合。在 CPython 中，它们是作为可变长度数组实现的，而不是像名称所暗示的那样是链表。'
- en: 'For example, here is a list of strings with names of cheeses:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个包含奶酪名称的字符串列表：
- en: '[PRE134]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Listing 3-58: *cheese_list.py:1*'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-58: *cheese_list.py:1*'
- en: You enclose a list literal in square brackets, separating each item in the list
    with commas.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 你将列表字面量放在方括号中，并用逗号分隔列表中的每个项。
- en: 'You can access or reassign the values of individual items with the same bracket
    notation used by most programming languages:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用与大多数编程语言相同的括号表示法来访问或重新赋值单个元素的值：
- en: '[PRE135]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Listing 3-59: *cheese_list.py:2*'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-59: *cheese_list.py:2*'
- en: A *tuple* is somewhat similar to a list, but with a few key differences. First,
    a tuple cannot have items added, reassigned, or removed after its creation. Attempting
    to modify the contents of a tuple with bracket notation will result in a `TypeError`.
    This is because tuples, unlike lists, are *immutable*, effectively meaning their
    contents cannot be modified (see Chapter 5 for the full explanation).
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组*与列表有些相似，但有一些关键的不同点。首先，元组在创建后不能添加、重新赋值或删除元素。尝试使用括号表示法修改元组的内容会导致`TypeError`错误。这是因为与列表不同，元组是*不可变的*，实际上意味着它们的内容无法修改（完整解释请参见第5章）。'
- en: 'Here is an example of a tuple:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个元组的例子：
- en: '[PRE136]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Listing 3-60: *knight_tuple.py:1*'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-60: *knight_tuple.py:1*'
- en: 'You enclose tuple literals in parentheses (`( )`), instead of brackets (`[
    ]`). Nevertheless, you still use bracket notation to access individual items:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 你将元组字面量放在圆括号（`( )`）中，而不是方括号（`[ ]`）。然而，你仍然可以使用方括号表示法来访问单个元素：
- en: '[PRE137]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Listing 3-61: *knight_tuple.py:2*'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-61: *knight_tuple.py:2*'
- en: 'As I said, you cannot change the items of a tuple after creation, such as if
    you tried to reassign the first item:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，你不能在元组创建后更改其元素，例如尝试重新赋值第一个元素：
- en: '[PRE138]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Listing 3-62: *knight_tuple.py:3*'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-62: *knight_tuple.py:3*'
- en: The guideline is to use tuples for collections of items of different types (*heterogeneous*
    collections) and to use lists for collections of items of the same type (*homogeneous*
    collections).
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 指导方针是，对于不同类型的项的集合（*异质*集合），使用元组；对于相同类型的项的集合（*同质*集合），使用列表。
- en: I’ll discuss these collections, and many more, in Chapter 9.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第9章讨论这些集合，以及更多内容。
- en: Loops
  id: totrans-904
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'Python has two basic loop types: *while* and *for*.'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两种基本的循环类型：*while* 循环和 *for* 循环。
- en: while Loop
  id: totrans-906
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while 循环
- en: 'The `while` loop probably looks familiar from other languages:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环可能在其他编程语言中也很常见：'
- en: '[PRE139]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Listing 3-63: *while_loop.py*'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-63: *while_loop.py*'
- en: I start the loop with the `while` keyword, follow it with the condition to test,
    and finish the header with a colon (`:`). As long as that condition evaluates
    to `True`, the code in the suite of the loop is executed.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 我用`while`关键字开始循环，后面跟上要测试的条件，并用冒号（`:`）结束循环头。只要条件评估为`True`，循环体中的代码就会被执行。
- en: When you need to keep running a loop until some condition is met, use `while`
    loops. These are particularly useful when you don’t know how many iterations of
    the loop will take place before the condition is met.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要持续执行循环直到满足某个条件时，使用`while`循环。这在你不知道循环会执行多少次直到条件被满足时特别有用。
- en: Loop Control
  id: totrans-912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环控制
- en: You can manually control the loop, using two keywords. The `continue` keyword
    abandons the current iteration and jumps to the next one. The `break` keyword
    exits the loop altogether.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用两个关键字手动控制循环。`continue`关键字放弃当前迭代并跳到下一次迭代，而`break`关键字则完全退出循环。
- en: 'One common scenario where you may use these keywords is in an infinite loop
    used for running a game or a user interface. For example, here’s a very simple
    command prompt:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在一些常见场景中使用这些关键字，例如用于运行游戏或用户界面的无限循环。例如，下面是一个非常简单的命令提示符：
- en: '[PRE140]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Listing 3-64: *loop_control.py*'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-64: *loop_control.py*'
- en: The loop `while True` is inherently infinite; `True` is always `True`. That’s
    the behavior I actually want here, since I want to keep iterating until the user
    enters the string `"exit"`, at which point, I manually end the loop with `break`.
    (By the way, if you’ve been waiting for a `do-while` loop, this is effectively
    the way to recreate that behavior.)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 循环`while True`本身是无限的；`True`永远为`True`。这正是我在这里想要的行为，因为我希望在用户输入字符串`"exit"`之前不断迭代，此时我用`break`手动结束循环。（顺便说一句，如果你在等待`do-while`循环，这实际上是重现该行为的方法。）
- en: The command `"sing"` has a different behavior, after which I’d want to immediately
    go to the top and prompt the user for another command, skipping the last print
    statement. The `continue` keyword does exactly that, immediately abandoning the
    current iteration and jumping back to the top of the loop.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '`"sing"`命令有不同的行为，在此之后，我希望立即回到顶部并提示用户输入另一个命令，跳过最后的打印语句。`continue`关键字正是这样做的，它立即放弃当前迭代并跳回到循环的顶部。'
- en: for Loop
  id: totrans-919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环
- en: Python’s `for` loop is a little different from loops in many languages. It’s
    generally used for iterating over a range, list, or other collection.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `for` 循环与许多语言中的循环有所不同。它通常用于遍历一个范围、列表或其他集合。
- en: '[PRE141]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Listing 3-65: *for_loop.py*'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-65: *for_loop.py*'
- en: I start the loop header with the `for` keyword. Technically, this kind of loop
    is a `for`-`in` (or “`for`-`each`”) loop, meaning the loop iterates once for each
    item in the given range, list, or other collection. This means the loop needs
    something to iterate over—in this case, a special object called `range()`—which
    iterates over a range of values, returning each one in turn. I’ve specified that
    I want the range to start with the value `1` and end before `11`. The local variable
    `i` will refer to the current item for each iteration. Finally, the `in` keyword
    precedes the thing I’m iterating over—that is, before `range()` in this example.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 `for` 关键字开始循环头部。严格来说，这种类型的循环是 `for`-`in`（或“`for`-`each`”）循环，意味着循环会为给定范围、列表或其他集合中的每个项迭代一次。这意味着循环需要一个可以迭代的对象——在这种情况下，是一个特殊的对象
    `range()`，它遍历一个值的范围，并逐一返回每个值。我已经指定了范围从值 `1` 开始，并在 `11` 之前结束。局部变量 `i` 将表示每次迭代的当前项。最后，`in`
    关键字出现在我正在迭代的对象之前——在这个例子中，就是 `range()`。
- en: As long as there are items to iterate over, the code belonging to the loop will
    be executed—in this case, printing out the value of the current item. The loop
    stops when the last item is iterated over.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有项可以迭代，循环中的代码就会执行——在这种情况下，打印当前项的值。当最后一项被迭代时，循环停止。
- en: Running this code would print the numbers 1 through 10.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码将打印出数字 1 到 10。
- en: This only scratches the surface of loops. See Chapter 9 for more.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是循环的皮毛。更多内容请参见第 9 章。
- en: Structural Pattern Matching
  id: totrans-927
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化模式匹配
- en: For many years, developers coming to Python from languages like C, C++, Java,
    or Javascript would ask if there was a Python equivalent to the `switch`/`case`
    statement (or `match`/`case` in Scala, `case`/`when` in Ruby, and so on). They’d
    always be disappointed to hear a resounding “No!” Python only had conditional
    statements.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，许多从 C、C++、Java 或 Javascript 等语言转到 Python 的开发者都问 Python 是否有类似 `switch`/`case`
    语句的东西（或者 Scala 中的 `match`/`case`、Ruby 中的 `case`/`when` 等等）。他们总是失望地听到一个响亮的“没有！”Python
    只有条件语句。
- en: At long last, Python 3.10 gained *structural pattern matching* via PEP 634\.
    This provides conditional logic that is at least syntactically similar to `switch`
    statements of other languages. In short, you test a single *subject*, such as
    a variable, against one or more *patterns*. If the subject matches the pattern,
    the associated suite of code runs.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Python 3.10 通过 PEP 634 获得了 *结构化模式匹配*。这提供了至少在语法上类似于其他语言的 `switch` 语句的条件逻辑。简而言之，您将一个单一的
    *主题*，比如一个变量，与一个或多个 *模式* 进行测试。如果主题与模式匹配，则执行相关的代码块。
- en: Literal Patterns and Wildcards
  id: totrans-930
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字面模式和通配符
- en: 'In the most basic use case, you can check a variable against different possible
    values. These are called *literal patterns*. For example, perhaps I want to display
    different messages, depending on a user’s `input` `lunch` `order`:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的用例中，您可以将一个变量与不同的可能值进行比较。这些被称为 *字面模式*。例如，也许我想根据用户的 `input` `lunch` `order`
    显示不同的消息：
- en: '[PRE142]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Listing 3-66: *pattern_match.py:1a*'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-66: *pattern_match.py:1a*'
- en: The value of `lunch_order` is compared to each case until it matches one. Once
    a match is found, the case’s suite is run, and the match statement is finished;
    the value won’t be checked against additional patterns once it matches one. So,
    if the user inputs `"pizza"`, the `"Pizza` `time!"` message is displayed. Similarly,
    if they input `"taco"`, the message `"Taco,` `taco,` `TACO,` `tacotacotaco!"`
    is displayed instead.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '`lunch_order` 的值与每个 case 进行比较，直到匹配为止。一旦找到匹配项，case 的代码块将会执行，匹配语句结束；一旦匹配成功，值就不会再与其他模式进行比较。因此，如果用户输入
    `"pizza"`，`"Pizza` `time!"` 消息将显示出来。类似地，如果他们输入 `"taco"`，则会显示 `"Taco,` `taco,`
    `TACO,` `tacotacotaco!"` 消息。'
- en: The underscore (`_`) in the last case is the *wildcard*, which will match any
    value. This serves as a fallback case, and it must come last, as it will match
    anything.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个 case 中的下划线（`_`）是 *通配符*，它将匹配任何值。这是一个回退 case，必须放在最后，因为它将匹配任何值。
- en: Or Patterns
  id: totrans-936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 或模式
- en: 'A single case can cover multiple possible values. One way to do this is with
    an *or pattern*, where possible literal values are separated by the bar character:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 case 可以涵盖多个可能的值。实现这一点的一种方法是使用 *或模式*，其中可能的字面值通过竖线字符分隔：
- en: '[PRE143]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Listing 3-67: *pattern_match.py:1b*'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-67: *pattern_match.py:1b*'
- en: This pattern will match if the user enters either `"salad"` or `"soup"` at the
    prompt.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在提示符中输入`"salad"`或`"soup"`，这个模式就会匹配。
- en: Capture Patterns
  id: totrans-941
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获模式
- en: 'One particularly helpful feature of structural pattern matching is the ability
    to capture part or all of the subject. For example, it isn’t very helpful in our
    example that the fallback case only says `"Yummy."`. Instead, I’d like to have
    a default message announcing the user’s selection. To do that, I write a *capture
    pattern* like this:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化模式匹配的一个特别有用的功能是能够捕获部分或全部主题。例如，在我们的例子中，如果回退情况仅仅说`"Yummy."`，那就没有太大帮助。相反，我希望有一个默认消息来宣布用户的选择。为了做到这一点，我写了一个像这样的*捕获模式*：
- en: '[PRE144]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Listing 3-68: *pattern_match.py:1c*'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-68: *pattern_match.py:1c*'
- en: This pattern acts like a wildcard, except the value of `lunch_order` is captured
    as `order`. Now, no matter what the user enters, if it doesn’t match any of the
    previous patterns, the value will be captured and displayed in the message here.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式像一个通配符，除了`lunch_order`的值会被捕获为`order`。现在，无论用户输入什么，如果它不匹配任何之前的模式，值就会被捕获并在此处的消息中显示出来。
- en: 'Capture patterns don’t just have to capture the entire value. For example,
    I can write a pattern that matches a tuple or list (a *sequence*) and then captures
    only part of that sequence:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获模式不仅仅是捕获整个值。例如，我可以写一个匹配元组或列表（一个*序列*）的模式，然后只捕获序列中的一部分：
- en: '[PRE145]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Listing 3-69: *pattern_match.py:1d*'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-69: *pattern_match.py:1d*'
- en: In this version, if the lunch order has a space, I split the string into two
    parts, which are stored in a list. Then, if the second item in the sequence has
    the value `"ice cream"`, the first part is captured as `flavor`. Thus, the code
    can account for Bojan if he decides to break down and have strawberry ice cream
    for lunch. (And I’m not stopping him!)
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，如果午餐订单包含空格，我会将字符串分割成两部分，并将其存储在列表中。然后，如果序列中的第二项是`"ice cream"`，那么第一部分就会被捕获为`flavor`。这样，代码就能够考虑到如果博扬决定午餐吃草莓冰淇淋的情况。（而我不会阻止他！）
- en: 'The capture pattern feature has one surprising downside: all *unqualified*
    names in patterns—that is, any bare variable names with no dots—will be used to
    capture. This means that if you want to use the value assigned to some variable,
    it must be *qualified*, meaning you must access it within some class or module
    with the dot operator:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获模式特性有一个意想不到的缺点：所有在模式中*未限定*的名称——即任何没有点号的裸变量名——都会被用来进行捕获。这意味着，如果你想使用某个变量赋值的值，它必须是*限定的*，也就是说，你必须通过点操作符在某个类或模块中访问它：
- en: '[PRE146]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Listing 3-70: *pattern_match.py:1e*'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-70: *pattern_match.py:1e*'
- en: Guard Statements
  id: totrans-953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护语句
- en: One last trick I’ll demonstrate with pattern matching is the *guard statement*,
    an additional conditional statement that must be satisfied for a pattern to match.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示与模式匹配相关的最后一个技巧——*保护语句*，它是一个附加的条件语句，必须满足才能使模式匹配。
- en: For example, in the current version of my lunch order example, using the logic
    to split the order by spaces means the code doesn’t behave very nicely with other
    foods with spaces in them. Also, if I enter `"rocky road ice cream"`, it won’t
    match the current ice cream pattern.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我当前的午餐订单示例中，使用按空格分割订单的逻辑意味着代码在处理其他包含空格的食物时表现不好。此外，如果我输入`"rocky road ice
    cream"`，它将无法匹配当前的冰淇淋模式。
- en: Instead of splitting my string by spaces, I can write a pattern with a guard
    statement that looks for the words *ice cream* in the lunch order.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以写一个带有保护语句的模式，而不是按空格分割字符串，该语句查找午餐订单中是否有*ice cream*。
- en: '[PRE147]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Listing 3-71: *pattern_match_object.py:1f*'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-71: *pattern_match_object.py:1f*'
- en: The pattern here captures the value as `ice_cream`, but only if the guard statement
    `if 'ice cream' in ice_cream` is satisfied. In that case, I use `.replace()` to
    remove the words *ice cream* from the captured value, leaving me with only the
    name of the flavor. I also use `.strip()` to remove any leading or trailing whitespace
    from the new string. Finally, I print out my message.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的模式捕获了值作为`ice_cream`，但只有在满足保护语句`if 'ice cream' in ice_cream`的情况下才会进行捕获。在这种情况下，我使用`.replace()`来移除捕获值中的*ice
    cream*词语，只保留口味名称。我还使用`.strip()`来去除新字符串中的任何前导或尾随空白。最后，我打印出我的消息。
- en: More About Structural Pattern Matching
  id: totrans-960
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于结构化模式匹配的内容
- en: There are quite a few other tricks and techniques that work with structural
    pattern matching. They work with objects (see Chapter 7), with dictionaries via
    mapping patterns (see Chapter 9), and even by support nesting patterns within
    other patterns.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他的技巧和技术可以与结构化模式匹配一起使用。它们适用于对象（参见第7章），通过映射模式使用字典（参见第9章），甚至支持在其他模式中嵌套模式。
- en: As with many Python techniques, pattern matching feels like “magic,” and there’s
    a strong temptation to use it everywhere possible. Resist this urge! Structural
    pattern matching is very useful for checking a single subject against multiple
    possible patterns, but as you can even see from the “ice cream” situation in the
    lunch order example, it quickly reaches its limits as the possible values of the
    subject get more elaborate. As a rule, if you’re unsure whether you need structural
    pattern matching in a particular situation, stick with conditional statements.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 和许多 Python 技巧一样，模式匹配给人一种“魔法”的感觉，并且强烈的诱惑让人想在可能的地方都使用它。抵制这种冲动！结构化模式匹配非常适合检查一个对象是否符合多个可能的模式，但正如你从午餐订单示例中的“冰淇淋”情况中看到的那样，随着被检查对象的可能值变得更复杂，它很快就会达到极限。一般来说，如果你不确定在特定情况下是否需要结构化模式匹配，就坚持使用条件语句。
- en: 'To learn even more, read PEP 636, which serves as the official tutorial for
    this topic and demonstrates all of the functionality available with this language
    feature: [https://peps.python.org/pep-0636/](https://peps.python.org/pep-0636/).'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多内容，请阅读 PEP 636，它是该主题的官方教程，并展示了该语言特性所提供的所有功能：[https://peps.python.org/pep-0636/](https://peps.python.org/pep-0636/)。
- en: Wrapping Up
  id: totrans-964
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You should now have a feeling for Python’s syntax and a basic familiarity with
    its key structures. If you were to stop here, you could probably write Python
    code that at least works. In fact, many developers new to the language do indeed
    work with about this much information, implicitly bringing the habits and practices
    of whatever language they know best.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对 Python 的语法有了一定的了解，并且对其关键结构有了基本的熟悉。如果你在这里停下来，你可能能够写出至少能工作的 Python 代码。事实上，许多刚接触这门语言的开发者的确是凭借这些信息工作，他们会隐式地带入自己最熟悉的其他语言的习惯和实践。
- en: There is a profound difference between valid code and idiomatic, Pythonic code.
    Writing the latter is the focus of this book.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 有效代码与符合 Python 风格的代码之间有着深刻的区别。编写后者是本书的重点。
- en: '4'
  id: totrans-967
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Project Structure and Imports
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构和导入
- en: '![](Images/chapterart.png)'
  id: totrans-969
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: I’ve found that structuring a Python project is one of the most often overlooked
    components of teaching the language. Many developers therefore get their project
    structure wrong, stumbling through a jumble of common mistakes until they arrive
    at something that at least works.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，Python 项目的结构化是教学过程中最常被忽视的部分之一。因此，许多开发者在结构上出错，直到他们走过一连串常见错误，最终才做出一个至少能工作的结构。
- en: 'Here’s the good news: you don’t have to be one of them!'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个好消息：你不必成为他们中的一员！
- en: In this chapter, I’ll introduce import statements, modules, and packages, and
    I’ll show you how to fit everything together without tearing your hair out.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍导入语句、模块和包，并向你展示如何将所有内容结合起来，而不至于抓狂。
- en: 'Be aware, I’m skipping over one critical piece of project structure in this
    chapter: *setup.cfg*, as it relies on concepts we haven’t yet covered. Without
    a *setup.cfg* or *setup.py* file, your project will not be ready to ship to end
    users. In this chapter, you’ll put everything in the right place for development.
    From there, preparing your project for distribution will be a fairly simple process.
    I’ll cover *setup.cfg*, *setup.py*, and other project structure issues relating
    to distribution in Chapter 18.'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在本章跳过了一个关键的项目结构部分：*setup.cfg*，因为它依赖于我们尚未讲解的概念。如果没有 *setup.cfg* 或 *setup.py*
    文件，你的项目将无法准备好交付给最终用户。在本章中，你将把所有内容放在开发的正确位置。从那里开始，为分发做准备将是一个相对简单的过程。我将在第 18 章介绍
    *setup.cfg*、*setup.py* 和与分发相关的其他项目结构问题。
- en: Setting Up the Repository
  id: totrans-974
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置仓库
- en: Before delving into the actual project structure, I want to address how it will
    fit into your *version control system (VCS)*, which I recommend using. For the
    rest of this book, I’ll assume you’re using Git, as that’s the most common option.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实际项目结构之前，我想先讨论它如何融入你的*版本控制系统（VCS）*，我推荐使用版本控制系统。在本书的其余部分，我将假设你使用 Git，因为它是最常见的选择。
- en: 'Once you’ve created your repository and cloned a local copy to your computer,
    you can begin to set up your project. At minimum, create the following files:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了仓库并将本地副本克隆到计算机上，你就可以开始设置你的项目。至少，创建以下文件：
- en: '*README*, which is a description of your project and its goals'
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*README*，这是你项目及其目标的描述。'
- en: '*LICENSE*, which is your project’s license'
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*LICENSE*，这是你项目的许可证。'
- en: '*.gitignore*, which is a special file that tells Git what files and directories
    to ignore'
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.gitignore*，这是一个特殊的文件，告诉 Git 哪些文件和目录需要忽略。'
- en: A directory, which has the name of your project
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个目录，通常是你项目的名称
- en: Your Python code belongs in a separate subdirectory and not in the root of the
    repository. This is very important, as your repository’s root directory will get
    mighty cluttered with build files, packaging scripts, documentation, virtual environments,
    and all manner of other things that aren’t actually part of the source code.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Python 代码应放在一个单独的子目录中，而不是放在仓库的根目录下。这一点非常重要，因为仓库的根目录会因为构建文件、打包脚本、文档、虚拟环境和其他各种不属于源代码的内容而变得非常凌乱。
- en: 'As an example, in this chapter, I’ll use one of my own Python projects: *omission*.'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，在本章中，我将使用我自己的一份 Python 项目：*omission*。
- en: A Python project is composed of modules and packages. In the next section, I’ll
    cover what those are and how to create them.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Python 项目由模块和包组成。在接下来的章节中，我将介绍它们是什么以及如何创建它们。
- en: Modules and Packages
  id: totrans-984
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块和包
- en: A *module* is any Python (*.py*) file. (Anticlimactic, isn’t it?)
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块* 是任何 Python (*.py*) 文件。（有点反高潮，不是吗？）'
- en: A *package*, occasionally called a *regular package*, is one or more modules
    within a directory. That directory must include a file called *__init__.py* (which
    can be empty). The *__init__.py* file is important! If it isn’t there, Python
    will not know the directory constitutes a package.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '*包*，有时称为 *常规包*，是一个或多个模块所在的目录。该目录必须包含一个名为 *__init__.py* 的文件（可以为空）。 *__init__.py*
    文件非常重要！如果它不存在，Python 将无法识别该目录是一个包。'
- en: You can leave the *__init__.py* file empty (it often is), or you can use it
    to run certain code when the package is first imported. For example, you might
    use `__init__.py` to select and rename certain functions, so the end user of the
    package doesn’t need to understand how the modules are laid out. (See the subsection
    “Controlling Package Imports” later in the chapter.)
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 *__init__.py* 文件留空（它通常是空的），或者你可以利用它在包首次导入时运行某些代码。例如，你可以使用 `__init__.py`
    来选择和重命名某些函数，这样包的最终用户就不需要理解模块的布局方式。（参见本章后面的“控制包导入”小节。）
- en: If you do forget *__init__.py* in your package, it becomes an *implicit namespace
    package*, also just known as a *namespace package*. These behave differently from
    regular packages. ***The two are not interchangeable!*** A namespace package allows
    you to distribute a package in multiple pieces, called *portions*. There are some
    cool advanced things you can do with namespace packages, but you will seldom need
    them. As this is a doozy of a rabbit hole, if you need namespace packages, see
    the documentation at [https://packaging.python.org/guides/packaging-namespace-packages/](https://packaging.python.org/guides/packaging-namespace-packages/).
    You can also read PEP 420, which officially defined the concept.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记在包中加入 *__init__.py* 文件，它会变成一个 *隐式命名空间包*，也就是通常所说的 *命名空间包*。这些包与常规包的行为不同。***两者不能互换使用！***
    命名空间包允许你将一个包分发为多个部分，称为 *部分*。命名空间包有一些很酷的高级用法，但你通常不需要它们。由于这是一个复杂的主题，如果你需要命名空间包，请参考
    [https://packaging.python.org/guides/packaging-namespace-packages/](https://packaging.python.org/guides/packaging-namespace-packages/)
    上的文档。你也可以阅读 PEP 420，它正式定义了这一概念。
- en: In my project structure, *omission* is a package that contains other packages.
    Thus, *omission* is my *top-level package*, and all the packages underneath it
    are its *subpackages*. This convention will be important once you start importing
    stuff.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的项目结构中，*omission* 是一个包含其他包的包。因此，*omission* 是我的 *顶层包*，其下所有包都是它的 *子包*。一旦开始导入内容，这一约定将变得非常重要。
- en: PEP 8 and Naming
  id: totrans-990
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PEP 8 和命名
- en: 'Your packages and modules need clear names to identify them. Consulting with
    PEP 8 about the naming conventions reveals this:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 你的包和模块需要清晰的名称以便识别。查阅 PEP 8 的命名约定可以揭示如下信息：
- en: Modules should have short, all-lowercase names. Underscores can be used in the
    module name if it improves readability. Python packages should also have short,
    all-lowercase names, although the use of underscores is discouraged.
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块应具有简短的全小写名称。如果使用下划线能提高可读性，可以在模块名中使用下划线。Python 包也应具有简短的全小写名称，尽管不建议使用下划线。
- en: Understand that modules are named by filenames and packages are named by their
    directory name. Thus, these conventions define how you name your directories and
    code files.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 理解模块是通过文件名命名的，而包是通过其目录名命名的。因此，这些约定定义了如何命名你的目录和代码文件。
- en: To reiterate, filenames should be all lowercase, with underscores (`_`) if that
    improves readability. Similarly, directory names should be all lowercase, without
    underscores if at all possible. To put that another way . . .
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，文件名应该全部小写，必要时使用下划线（`_`）以提高可读性。类似地，目录名应该全部小写，尽可能不使用下划线。换句话说…
- en: 'Do this: *omission/data/data_loader.py*'
  id: totrans-995
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做这个：*omission/data/data_loader.py*
- en: 'NOT this: *omission/Data/DataLoader.py*'
  id: totrans-996
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是这样：*omission/Data/DataLoader.py*
- en: Project Directory Structure
  id: totrans-997
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目目录结构
- en: 'With that covered, take a look at my project’s repository directory structure:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 既然已经讲解过了，来看一下我项目的仓库目录结构：
- en: '[PRE148]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Listing 4-1: Directory structure of *omission-git/*'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：*omission-git/*的目录结构
- en: 'You’ll see that I have one top-level package called *omission*, with four subpackages:
    *common/*, *data/*, *game/*, and *tests/*. Each subpackage contains an *__init__.py*
    file, which is what designates them as packages. Every file that ends in *.py*
    is a module.'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我有一个名为*omission*的顶级包，里面包含四个子包：*common/*、*data/*、*game/* 和 *tests/*。每个子包都包含一个*__init__.py*文件，这个文件标志着它们是包。每个以*.py*结尾的文件都是一个模块。
- en: I also have the directory *resources/*, but that only contains game audio, images,
    and other sundry files (omitted here for brevity). The *resources/* directory
    is *not* a regular package, as it doesn’t contain an *__init__.py*.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 我还拥有*resources/*目录，但它只包含游戏音频、图像和其他杂项文件（这里为了简洁省略）。*resources/*目录*不是*一个常规包，因为它没有包含*__init__.py*。
- en: 'I have another special file in my top-level package: *__main__.py*. This is
    the file that runs when I execute my top-level package directly, via this command:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 我的顶级包中还有另一个特殊文件：*__main__.py*。这是当我通过以下命令直接执行顶级包时运行的文件：
- en: '[PRE149]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: I’ll come back to *__main__.py* in a bit (see the subsection “Package Entry
    Points” later in the chapter), as well as explain that lonely little *omission.py*
    file outside the top-level package.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 我稍后会回到*__main__.py*文件（参见本章后面的“包入口点”小节），并解释一下位于顶级包外的那个孤独的*omission.py*文件。
- en: How import Works
  id: totrans-1006
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作导入
- en: 'If you’ve written any meaningful Python code before, you’re almost certainly
    familiar with the `import` statement for importing modules. For example, to use
    it to import the module for regex, you’d enter this:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前写过任何有意义的 Python 代码，你几乎肯定熟悉`import`语句，它用于导入模块。例如，要使用它导入正则表达式模块，你会输入：
- en: '[PRE150]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Once you’ve imported a module, you can access any variables, functions, or classes
    defined within it.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你导入了一个模块，你就可以访问其中定义的任何变量、函数或类。
- en: When you import the module, you are actually running it, which in turn executes
    any other `import` statements in the module. If there are any errors or performance
    costs in those secondarily (and onward) imported modules, they might seem to originate
    from your otherwise innocent import statement. It also means that Python has to
    be able to find all those modules.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入模块时，实际上是执行了它，这又会执行模块中的其他`import`语句。如果这些二次（及之后的）导入模块中有任何错误或性能问题，它们可能看起来像是源自你原本无害的导入语句。这也意味着
    Python 必须能够找到所有这些模块。
- en: 'For example, the module *re.py*, which is part of the Python standard library,
    has several import statements of its own, which are executed when you `import
    re`. The contents of those imported modules aren’t automatically available to
    the file you imported `re` from, but those module files have to exist for `import
    re` to succeed. If, for some unlikely reason, *enum.py* (another module that is
    part of the Python standard library) got deleted from your Python environment
    and you ran `import re`, it would fail with an error:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Python 标准库中的模块*re.py*，它有几个自己的导入语句，这些语句在你`import re`时执行。那些被导入模块的内容不会自动对你导入`re`的文件可用，但这些模块文件必须存在，`import
    re`才会成功。如果出于某些不太可能的原因，*enum.py*（另一个属于 Python 标准库的模块）被从你的 Python 环境中删除，然后你运行`import
    re`，它会因为找不到该模块而报错：
- en: '[PRE151]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: This might seem like a confusing error message. I’ve seen people erroneously
    wonder why the outer module (in this example, `re`) couldn’t be found. Others
    have wondered why the inner module (`enum` here) is being imported at all, since
    they didn’t ask for it directly in their code.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个令人困惑的错误信息。我见过一些人错误地猜测为什么找不到外部模块（在这个例子中是`re`）。还有些人困惑为什么内部模块（这里是`enum`）会被导入，因为他们并没有在代码中直接请求它。
- en: The problem is that the `re` module was imported, and that in turn imported
    the `enum` module. However, because the `enum` module is missing, importing `re`
    fails with a `ModuleNotFoundError`.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，`re` 模块已被导入，而它又导入了 `enum` 模块。但是，因为 `enum` 模块缺失，导入 `re` 时会失败，并抛出 `ModuleNotFoundError`。
- en: 'Take note that this scenario is fictional: `import enum` and `import re` will
    never fail under normal circumstances, because both modules are part of Python’s
    standard library. However, this little example demonstrates the common problem
    of `import` statements failing due to missing modules.'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个场景是虚构的：`import enum` 和 `import re` 在正常情况下不会失败，因为这两个模块是 Python 标准库的一部分。然而，这个小例子展示了由于缺少模块而导致
    `import` 语句失败的常见问题。
- en: Import Dos and Don’ts
  id: totrans-1016
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入的注意事项
- en: There are various ways of importing, but most of them should rarely, if ever,
    be used.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 导入有多种方式，但其中大部分方法应该很少使用，甚至从不使用。
- en: 'For the upcoming examples, I’ll be using a module called *smart_door.py*, which
    reads as follows:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的例子中，我将使用一个名为*smart_door.py*的模块，它的内容如下：
- en: '[PRE152]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Listing 4-2: *smart_door.py*'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-2: *smart_door.py*'
- en: 'Let’s say I want to use this module in another Python file, which (in this
    example) is in the same directory. To run the functions defined in that module,
    I’d have to first import the module `smart_door`. The easiest way to do this is
    as follows:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想在另一个 Python 文件中使用这个模块（在这个例子中，它位于同一目录下）。为了运行该模块中定义的函数，我首先需要导入模块`smart_door`。最简单的做法如下：
- en: '[PRE153]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Listing 4-3: *use_smart_door.py:1a*'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-3: *use_smart_door.py:1a*'
- en: The *namespace* of `open()` and `close()` is `smart_door`. A *namespace* is
    an explicitly defined path to something, such as a function. The function `open()`
    has the namespace `smart_door`, which tells me that `open()` belongs to that particular
    module. Remember this from The Zen of Python?
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()` 和 `close()` 的*命名空间*是 `smart_door`。命名空间是指向某个对象的明确路径，例如一个函数。函数 `open()`
    的命名空间是 `smart_door`，这告诉我 `open()` 属于这个特定的模块。你还记得《Python之禅》中的这一点吗？'
- en: Namespaces are one honking great idea—let’s do more of those!
  id: totrans-1025
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名空间是一个非常棒的想法——让我们多多使用它！
- en: Python developers really like namespaces because they make it obvious where
    functions and whatnot are coming from. That comes in handy when you have multiple
    functions that have similar names or the same name, but that are defined in different
    modules. Without that bit of namespace, `smart_door`, you would not know that
    `open()` had anything to do with opening the smart door. Appropriately using namespaces
    can help you avoid massive errors in your code. However, as important as namespaces
    are, they can get out of hand very quickly if used improperly.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: Python 开发者非常喜欢命名空间，因为它能清楚地显示函数等的来源。当你有多个函数，它们的名字相似或相同，但定义在不同的模块中时，这一点特别有用。如果没有命名空间
    `smart_door`，你就无法知道 `open()` 与开启智能门有关。恰当地使用命名空间可以帮助你避免代码中的巨大错误。然而，尽管命名空间非常重要，如果使用不当，它们会迅速失控。
- en: Be advised, in referring to *namespaces*, I’m not necessarily talking about
    *implicit namespace packages*, which I don’t cover in this book.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在提到*命名空间*时，我并不一定指的是*隐式命名空间包*，这些我在本书中没有涉及。
- en: Here’s a look at some good and bad examples of namespaces in action.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一些命名空间使用中的好例子和坏例子。
- en: Importing Functions from Modules
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从模块中导入函数
- en: In my previous `smart_door` function calls, I referenced the namespace on every
    function call. This is usually best when a function is called only a handful of
    times, but if you use a function often, it gets tedious to use a namespace for
    every single function call.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 在我之前的 `smart_door` 函数调用中，我在每次调用函数时都引用了命名空间。通常，当一个函数只被调用几次时，这种做法是最好的，但如果你经常使用一个函数，每次都加上命名空间会显得很繁琐。
- en: 'Thankfully, Python provides a way around that. To be able to use the `open()`
    function without constantly having to precede it with its module name (`smart_door`),
    I need only know the *qualified name*—that is, the name of the function, class,
    or variable, preceded by its complete namespace within one of its modules or packages
    (if any). Within the *smart_door.py* module, the qualified name of the function
    I want is just `open`. Thus, I import that function like this, instead:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 提供了一种解决方法。为了能够使用 `open()` 函数而不必每次都在前面加上模块名（`smart_door`），我只需要知道*限定名*——即函数、类或变量的名称，并且在它之前加上其在模块或包中的完整命名空间（如果有的话）。在
    *smart_door.py* 模块中，我想要的函数的限定名就是 `open`。因此，我可以这样导入该函数：
- en: '[PRE154]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Listing 4-4: *use_smart_door.py:1b*'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-4: *use_smart_door.py:1b*'
- en: 'This introduces a new problem. Neither `close()` nor `smart_door.close()` will
    work in this example, because I didn’t import the function outright. The entire
    `smart_door` module was still run by the import command, but only the `open()`
    function was actually imported. To use `smart_door.close()`, I’d need to change
    the code to this:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了一个新问题。在这个例子中，`close()`和`smart_door.close()`都无法使用，因为我没有直接导入该函数。整个`smart_door`模块仍然通过导入命令运行，但实际上只有`open()`函数被导入了。要使用`smart_door.close()`，我需要将代码更改为以下内容：
- en: '[PRE155]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Listing 4-5: *use_smart_door.py:1c*'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-5: *use_smart_door.py:1c*'
- en: This gives me access to both functions, no namespace required.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我就能访问这两个函数，无需命名空间。
- en: The Problem of Shadowing
  id: totrans-1038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遮蔽问题
- en: 'You might have noticed another problem: `open()` is already a built-in Python
    function! Assume I also need to read a file called *data.txt*, which exists in
    my current directory. If I try this after importing `open()` from the `smart_door`
    function ([Listing 4-5](#listing4-5)), my program is going to behave very badly:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到另一个问题：`open()`已经是一个内置的Python函数！假设我还需要读取一个名为*data.txt*的文件，它位于我当前的目录中。如果我在导入`smart_door`中的`open()`后尝试这样做（[列表
    4-5](#listing4-5)），我的程序将会表现得非常糟糕：
- en: '[PRE156]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Listing 4-6: *use_smart_door.py:2*'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-6: *use_smart_door.py:2*'
- en: When I used `open()` earlier ([Listing 4-5](#listing4-5)), I wanted to use `smart_door.open()`.
    Now, in the same file, I’m trying to call Python’s built-in `open()` function
    to open a text file for reading. Unfortunately, because of the earlier import,
    the built-in `open()` function has been *shadowed* by `smart_door.open()`, meaning
    the presence of the latter is making it impossible for Python to even find the
    former. This code will fail!
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 当我之前使用`open()`时（[列表 4-5](#listing4-5)），我想使用的是`smart_door.open()`。现在，在同一个文件中，我又尝试调用Python的内置`open()`函数来打开一个文本文件进行读取。不幸的是，由于之前的导入，内置的`open()`函数已经被`smart_door.open()`遮蔽，意味着后者的存在使得Python根本无法找到前者。这个代码会失败！
- en: '[PRE157]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: I got that error because I’m trying to use the built-in `open()` function, which
    accepts two arguments, but I unintentionally called `smart_door.open()`, which
    doesn’t accept any arguments.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到那个错误是因为我试图使用内置的`open()`函数，它接受两个参数，但我不小心调用了`smart_door.open()`，它不接受任何参数。
- en: Getting an actual error message is one of the better failure scenarios for this
    sort of mistake. Imagine if `smart_door.open()` did accept similar arguments to
    the built-in `open()`. Depending on my code, I might wind up with an error elsewhere
    (perhaps from trying to use a file I hadn’t opened), or worse, some form of incorrect
    but technically valid behavior. This sort of mistake is infamously difficult to
    debug, so it is wise to avoid.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 获取实际的错误信息是这种错误的较好失败场景之一。试想如果`smart_door.open()`确实接受类似于内置`open()`的参数，根据我的代码，可能会在别的地方出现错误（也许是尝试使用一个未打开的文件），或者更糟的是，某种形式的错误但技术上有效的行为。这种错误通常非常难以调试，因此最好避免发生。
- en: 'So how should I fix this? If I were the one who wrote *smart_door.py*, I should
    just go and change the function name. It’s universally considered bad practice
    to use function names that shadow built-in Python functions anyhow, unless the
    entire point *is* to shadow. However, assume that I’m not the author of that module
    and I need another solution. Thankfully, Python offers one in the `as` keyword,
    which allows me to create an alias for that function:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我该如何解决这个问题呢？如果是我写的*smart_door.py*，我应该直接更改函数名。通常情况下，使用与内置Python函数相同的函数名被认为是坏习惯，除非整个目的是为了遮蔽（shadow）。不过，假设我不是该模块的作者，需要寻找另一种解决方案。幸运的是，Python提供了`as`关键字，允许我为该函数创建一个别名：
- en: '[PRE158]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Listing 4-7: *use_smart_door.py:1d*'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-7: *use_smart_door.py:1d*'
- en: In the import, I use the `as` keyword to rename `smart_door.open()` to `door_open()`,
    but only in the context of this file. Then, I can refer to `door_open()` where
    I wanted `smart_door.open()`.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入时，我使用`as`关键字将`smart_door.open()`重命名为`door_open()`，但仅在此文件的上下文中。然后，我可以在需要`smart_door.open()`的地方引用`door_open()`。
- en: This leaves Python’s built-in `open()` function unshadowed, so the earlier code
    for working with the file ([Listing 4-6](#listing4-6)) can function properly.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Python的内置`open()`函数没有被覆盖，因此之前用于处理文件的代码（[列表 4-6](#listing4-6)）可以正常工作。
- en: '[PRE159]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The Trouble with Nested Packages
  id: totrans-1052
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套包的问题
- en: 'As you’ve seen, packages can contain other packages. In my *omission* project,
    if I wanted to import the module *data_loader.py*, I could use this line (refer
    back to the *omission* project structure):'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，包可以包含其他包。在我的*omission*项目中，如果我想导入模块*data_loader.py*，我可以使用这一行（参考回*omission*项目结构）：
- en: '[PRE160]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The Python interpreter looks for the *omission* package, the *data* package
    inside that, and the *data_loader* module inside that. The *data_loader* module
    (and only that module) is imported. This is a good structure, and all’s well.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: Python 解释器会查找*omission*包，里面的*data*包，接着是里面的*data_loader*模块。只有这个*data_loader*模块被导入。这是一个不错的结构，一切正常。
- en: 'At a certain point, however, nesting packages can become a pain. A function
    call like `musicapp.player.data.library.song.play()` is just ugly, not to mention,
    difficult to read. As The Zen of Python muses:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，嵌套包可能会变得令人头疼。像`musicapp.player.data.library.song.play()`这样的函数调用不仅丑陋，而且难以阅读。正如《Python禅》所说：
- en: Flat is better than nested.
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 扁平比嵌套更好。
- en: Some nesting of packages is certainly okay, but when your project starts looking
    like an elaborate set of Matryoshka dolls, you’ve done something wrong. Organize
    your modules into packages, but keep the structure reasonably simple. Nesting
    two or three packages deep is okay; deeper is generally not advisable, if it can
    be avoided.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 一定程度的包嵌套是可以接受的，但当你的项目开始看起来像一套精致的俄罗斯套娃时，你就做错了什么。将模块组织成包是好的，但结构应该保持合理简单。嵌套两到三层包是可以的；如果可以避免，通常不建议嵌套得更深。
- en: 'Although we’d never have overly nested nightmares in an ideal world, real-life
    projects aren’t always that neat. Sometimes, it isn’t possible to avoid deep nesting
    structures. I need another way to keep my import statements sane. Graciously,
    the import system can handle this:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在理想世界里我们永远不会遇到过度嵌套的噩梦，但现实中的项目往往并不那么整洁。有时，避免深度嵌套结构是不可能的。我需要一种方法来保持我的导入语句的清晰。幸运的是，导入系统可以处理这个问题：
- en: '[PRE161]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: I only have to deal with the deeply nested namespace once, in the actual import
    statement. After that, I just use the function name, `play()`.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 我只需要在实际的导入语句中处理一次深度嵌套的命名空间。之后，我只需使用函数名`play()`。
- en: 'Alternatively, if I want a little bit of namespace, I can have that, too:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果我想要一点命名空间，我也可以做到：
- en: '[PRE162]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: My import statement has resolved all but that last bit of namespace, `song`,
    so I still know where the `play()` function is coming from.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 我的导入语句解决了除了最后一个命名空间`song`以外的所有问题，所以我仍然知道`play()`函数的来源。
- en: The import system is deliciously flexible like that.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 导入系统就是如此灵活。
- en: Beware of Importing All
  id: totrans-1066
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小心导入所有内容
- en: 'Before long, you’ll probably find yourself tempted to import all of the hundreds
    of functions in your module, to save time. This is the point at which many developers
    go off the rails:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 不久后，你可能会发现自己有冲动去导入模块中的所有数百个函数，以节省时间。这是许多开发者偏离正轨的时刻：
- en: '[PRE163]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: This statement imports nearly everything in the module directly, except for
    anything preceded by one or more underscores. This import-all pattern is a Very
    Bad Idea, as you won’t know what all is getting imported or what will be shadowed
    in the process.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句直接导入了模块中的几乎所有内容，除了以一个或多个下划线开头的内容。这个“导入所有”模式是一个非常糟糕的主意，因为你根本不知道究竟导入了什么，或者在这个过程中会被覆盖什么。
- en: 'The problem gets even worse when you start importing all from multiple modules:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始从多个模块导入所有内容时，问题会变得更加严重：
- en: '[PRE164]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Doing this, you may be blissfully unaware that `open()`, `smart_door.open()`,
    and `gzip.open()` all exist and are fighting over the same name in your file!
    The function `gzip.open()` will win out in this example, because it’s the last
    version of `open()` that was imported. The other two functions have been shadowed,
    which means you effectively can’t call them at all.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做时，你可能完全没有意识到`open()`、`smart_door.open()`和`gzip.open()`都存在，并且在你的文件中争夺同一个名字！在这个例子中，`gzip.open()`会胜出，因为它是最后一个被导入的`open()`版本。其他两个函数已经被隐藏，这意味着你实际上根本不能调用它们。
- en: Since no one is likely to remember every single function, class, and variable
    in every module that gets imported, one can easily wind up with a whole lot of
    messes.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有人能记住每个导入模块中的所有函数、类和变量，所以很容易就会陷入一团乱麻。
- en: 'The Zen of Python applies to this situation:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 《Python禅》适用于这种情况：
- en: Explicit is better than implicit.
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 明确比隐式更好。
- en: ''
  id: totrans-1076
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (. . .)
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （……）
- en: ''
  id: totrans-1078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-1079
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面对模糊性时，拒绝猜测的诱惑。
- en: You should never have to guess where a function or variable is coming from.
    There should be code somewhere in the file that explicitly tells you where everything
    comes from, as seen in the preceding examples.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不应该猜测一个函数或变量的来源。文件中应该有某处代码明确告诉你所有内容的来源，正如前面的示例所示。
- en: This `import *` doesn’t quite work the same way with packages. By default, a
    line like `from some_package import *` will be functionally the same as `import
    some_package`, unless the package has been configured to work with `import *`.
    I’ll come back to this later.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`import *`在包中的工作方式不完全一样。默认情况下，像`from some_package import *`这样的语句与`import some_package`的功能相同，除非该包已被配置为与`import
    *`一起使用。我稍后会再讲到这个问题。
- en: Importing Within Your Project
  id: totrans-1082
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的项目中导入
- en: Now that you know how to structure your project and import from packages and
    modules, I’ll tie everything together.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何构建项目并从包和模块中进行导入，我将把一切串联起来。
- en: 'Recall my *omission* project structure from [Listing 4-1](#listing4-1). Here’s
    a subsection of that project directory:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我的*omission*项目结构，参见[列表 4-1](#listing4-1)。这是该项目目录的一个子部分：
- en: '[PRE165]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Listing 4-8: Directory structure of *omission-git/*'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-8：*omission-git/*的目录结构
- en: Any one module in my project may need to be able to import from another module,
    whether it’s within the same package or somewhere else in the project structure.
    I’ll explain how to handle both scenarios.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 我项目中的任何一个模块可能都需要能够从另一个模块导入，无论它是在同一个包内还是项目结构中的其他地方。我将解释如何处理这两种情况。
- en: Absolute Imports
  id: totrans-1088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绝对导入
- en: I have a class `GameMode` defined within the *game_enums.py* module, which lives
    in the *omission/common* package. I want to use that class within my *game_round_settings.py*
    module, defined in the *omission/data* package. How do I get to it?
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*game_enums.py*模块中定义了一个`GameMode`类，这个模块位于*omission/common*包中。我想在*omission/data*包中的*game_round_settings.py*模块中使用这个类。我该如何访问它？
- en: 'Because I defined *omission* as a top-level package and organized my modules
    into subpackages, it’s pretty straightforward. In *game_round_settings.py*, I’d
    write the following:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我将*omission*定义为顶级包，并将我的模块组织到子包中，所以这很简单。在*game_round_settings.py*中，我会写如下代码：
- en: '[PRE166]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Listing 4-9: *game_round_settings.py:1a*'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-9：*game_round_settings.py:1a*
- en: This line is an *absolute import*. It starts at the top-level package, *omission*,
    and walks down into the *common* package, where it looks for *game_enums.py*.
    Inside that module, it finds whatever has the name `GameMode` and imports that.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 这行是一个*绝对导入*。它从顶级包*omission*开始，向下进入*common*包，在那里寻找*game_enums.py*。在该模块中，它找到名为`GameMode`的内容并进行导入。
- en: Relative Imports
  id: totrans-1094
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对导入
- en: 'You can also import from a module in the same package or subpackage. This is
    known as a *relative import* or an *intrapackage reference*. In practice, intra-package
    references are easy to do wrong. If some developer wanted to import `GameMode`
    (which is provided by *omission/common/game_enums.py*) into *omission/data/game_round_settings.py*,
    they might incorrectly attempt to use something like the following:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从同一包或子包中的模块进行导入。这被称为*相对导入*或*包内引用*。实际上，包内引用很容易出错。如果某个开发者想要将`GameMode`（由*omission/common/game_enums.py*提供）导入到*omission/data/game_round_settings.py*，他们可能会错误地尝试使用如下代码：
- en: '[PRE167]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Listing 4-10: *game_round_settings.py:1b*'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-10：*game_round_settings.py:1b*
- en: This fails, leaving the developer wondering why it doesn’t work. The *data*
    package (where *game_round_settings.py* lives) has no knowledge of its sibling
    packages, such as *common*.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 这会失败，开发者会疑惑为什么不起作用。*data*包（即*game_round_settings.py*所在的包）不知道它的兄弟包，如*common*。
- en: A module knows what package it belongs to, and a package knows its parent package
    (if it has one). Because of this, relative imports can start the search from the
    current package and move up and down through the project structure.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块知道它属于哪个包，而一个包知道它的父包（如果有的话）。因此，相对导入可以从当前包开始，向项目结构中上下查找。
- en: 'Within *omission/data/game_round_settings.py*, I can use the following import
    statement:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*omission/data/game_round_settings.py*中，我可以使用以下导入语句：
- en: '[PRE168]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Listing 4-11: *game_round_settings.py:1c*'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-11：*game_round_settings.py:1c*
- en: The two dots (`..`) mean “the current package’s direct parent package,” which,
    in this case, is *omission*. The import steps up one level, walks down into *common*,
    and finds *game_enums.py*.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 两个点（`..`）表示“当前包的直接父包”，在这个例子中是*omission*。导入会向上一层，进入*common*包，并找到*game_enums.py*。
- en: There’s some difference of opinion among Python developers about whether to
    use absolute or relative imports. Personally, I prefer to use absolute imports
    whenever possible, because I feel it makes the code a lot more readable. You can
    make up your own mind. The only important factor is that the result should be
    *obvious*—there should be no mystery about where anything comes from.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 关于是否使用绝对导入还是相对导入，Python 开发者之间存在一些分歧。就我个人而言，我倾向于在可能的情况下使用绝对导入，因为我觉得这样能使代码更加易读。你可以自己做决定。唯一重要的因素是结果应该是*显而易见*的——任何东西的来源都不应该有任何谜团。
- en: Importing from the Same Package
  id: totrans-1105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从同一包中导入
- en: 'There is one other lurking gotcha here. In *omission/data/settings.py*, I have
    this statement for importing a class from the module *omission/data/game_round_settings.py*:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个潜在的陷阱。在*omission/data/settings.py*中，我有以下语句用于从模块*omission/data/game_round_settings.py*导入一个类：
- en: '[PRE169]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Listing 4-12: *settings.py:1a*'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-12: *settings.py:1a*'
- en: 'You might think that since both *settings.py* and *game_round_settings.py*
    are in the same package, *data*, I should be able to just use this:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，由于*settings.py*和*game_round_settings.py*都在同一个包*data*中，我应该能够直接使用这个：
- en: '[PRE170]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Listing 4-13: *settings.py:1b*'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-13: *settings.py:1b*'
- en: However, that will not work. It will fail to locate the *game_round_settings.py*
    module because I am running the top-level package (`python3 -m omission`), and
    absolute imports for anything within the package being executed (*omission*) have
    to start from the top.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做是行不通的。它无法定位到*game_round_settings.py*模块，因为我正在运行顶级包（`python3 -m omission`），对于被执行包中的任何内容（*omission*），绝对导入必须从顶部开始。
- en: 'I can instead use a relative import, which looks much simpler than the absolute
    import:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以改用相对导入，它看起来比绝对导入简单得多：
- en: '[PRE171]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Listing 4-14: *settings.py:1c*'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-14: *settings.py:1c*'
- en: In this case, the single dot (`.`) means “this package.”
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，单个点（`.`）表示“当前包”。
- en: 'This probably feels familiar if you’re used to the typical UNIX filesystem,
    although Python takes the concept a bit further:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了典型的 UNIX 文件系统，这个概念可能会感到熟悉，尽管 Python 将这个概念进一步拓展了：
- en: One dot (`.`) means the current package.
  id: totrans-1118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个点（`.`）表示当前包。
- en: Two dots (`..`) takes you back one level, to the parent package.
  id: totrans-1119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个点（`..`）会让你回到上一层，即父包。
- en: Three dots (`...`) takes you back two levels, to the parent of the parent package.
  id: totrans-1120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个点（`...`）会让你回到父包的父级。
- en: Four dots (`....`) takes you back three levels.
  id: totrans-1121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四个点（`....`）会让你回到上三层。
- en: And so on, and so forth.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推。
- en: Keep in mind that those “levels” aren’t just plain directories; they’re packages.
    If you have two distinct packages in a plain directory that isn’t a package, you
    can’t use relative imports to jump from one to another. You’ll have to work with
    the Python search path for that. I’ll talk more about that later in this chapter.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些“层级”不仅仅是普通的目录；它们是包。如果你有两个不同的包位于一个不是包的普通目录中，你就不能使用相对导入从一个包跳到另一个包。你需要使用
    Python 搜索路径来实现这一点。我将在本章稍后介绍更多关于这方面的内容。
- en: Entry Points
  id: totrans-1124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入口点
- en: So far, you’ve learned how to create modules, packages, and projects, and how
    to make full use of the import system. The last piece of this puzzle is gaining
    the ability to control what happens when a package is imported or executed. The
    parts of the project that are run first when importing or executing are called
    *entry points*.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何创建模块、包和项目，并如何充分利用导入系统。这个难题的最后一块拼图是获得控制包导入或执行时发生的事情的能力。项目中在导入或执行时首先运行的部分被称为*入口点*。
- en: Module Entry Points
  id: totrans-1126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块入口点
- en: 'When you import a Python module or package, it is given a special variable
    called `__name__`. This contains the *fully qualified name* of the module or package,
    which is the name as the import system sees it. For example, the fully qualified
    name of the module *omission/common/game_enums.py* would be `omission.common.game_enums`.
    There is one exception: when a module or package is run directly, its `__name__`
    is set to the value `"__main__"`.'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入一个 Python 模块或包时，它会被赋予一个名为`__name__`的特殊变量。这个变量包含模块或包的*完全限定名称*，即导入系统看到的名称。例如，模块*omission/common/game_enums.py*的完全限定名称将是`omission.common.game_enums`。有一个例外：当一个模块或包直接运行时，它的`__name__`会被设置为`"__main__"`。
- en: 'To demonstrate this, assume I have a package called *testpkg*, which contains
    the module *awesome.py*. It defines a function, `greet()`:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，假设我有一个名为*testpkg*的包，其中包含模块*awesome.py*。它定义了一个函数`greet()`：
- en: '[PRE172]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Listing 4-15: *awesome.py:1*'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-15: *awesome.py:1*'
- en: 'The bottom of that same file also contains a `print` message:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 同一文件的底部还包含一条`print`消息：
- en: '[PRE173]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Listing 4-16: *awesome.py:2a*'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-16: *awesome.py:2a*'
- en: 'In another module in the same directory as *testpkg*, I have this module (*example.py*),
    which I run directly with `python3 example.py`:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 在与*testpkg*同一目录中的另一个模块中，我有这个模块（*example.py*），我通过`python3 example.py`直接运行它：
- en: '[PRE174]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Listing 4-17: *example.py*'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-17: *example.py*'
- en: If I look at the `_name_` local variable—which is the `__name__` presently assigned
    to the current module, *example.py*—I’ll see the value is `"__main__"` because
    I executed *example.py* directly.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我查看`_name_`局部变量——即当前模块*example.py*中分配给`__name__`的值——我会看到它的值为`"__main__"`，因为我直接执行了*example.py*。
- en: The package `awesome` I imported also has a `__name__` variable, which has the
    value `"testpkg.awesome"`, representing where the package came from in the import
    system.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 我导入的包`awesome`也有一个`__name__`变量，它的值为`"testpkg.awesome"`，表示包在导入系统中的来源。
- en: 'If you ran that module, you’d get the following output:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行该模块，你会看到以下输出：
- en: '[PRE175]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: That first line is coming from *testpkg/awesome.py*, which is run by the import
    command. The rest is coming from the two print commands in *example.py*.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行来自*testpkg/awesome.py*，它是通过导入命令运行的。其余部分来自*example.py*中的两个打印命令。
- en: 'But what if I want that first message to appear only if *awesome.py* is executed
    directly, and *not* when the module is only imported? To accomplish that, I’d
    check the value of `__name__` variable in a conditional statement. I’ve rewritten
    my *awesome.py* file to do exactly that:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我希望只有在直接执行*awesome.py*时才显示第一条消息，而不是在模块仅被导入时显示该消息该怎么办呢？为了实现这一点，我会在条件语句中检查`__name__`变量的值。我已经重新编写了我的*awesome.py*文件来做到这一点：
- en: '[PRE176]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Listing 4-18: *awesome.py:2b*'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-18: *awesome.py:2b*'
- en: If *awesome.py* is executed directly, `__name__` will have the value `"__main__"`,
    so the print statement will run. Otherwise, if *awesome.py* is being imported
    (or otherwise run indirectly), the conditional will fail.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果直接执行*awesome.py*，`__name__`的值将为`"__main__"`，因此打印语句会执行。否则，如果*awesome.py*是被导入的（或以其他方式间接执行），条件将失败。
- en: While you’ll frequently see this pattern in Python, some Python experts consider
    it an anti-pattern, because it can encourage you to both execute and import a
    module at the same time. While I don’t agree that using `if__name__ == "__main__"`
    is an anti-pattern, you often don’t need it. In any case, be certain you never
    import your main module from anywhere else in your package.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在Python中经常会看到这种模式，但一些Python专家认为它是一种反模式，因为它可能会鼓励你同时执行和导入一个模块。虽然我不同意使用`if__name__
    == "__main__"`是反模式的看法，但你通常不需要它。无论如何，确保你永远不要从包的其他地方导入你的主模块。
- en: Package Entry Points
  id: totrans-1147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包的入口点
- en: Notice that my *omission* project has a file called `__main__` in the top-level
    package. This file is automatically run when a package is executed directly, but
    never when importing the package.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我的*omission*项目中在顶级包中有一个名为`__main__`的文件。该文件在包被直接执行时会自动运行，但在导入包时永远不会运行。
- en: So, when executing *omission* via `python3 -m omission`, Python first runs the
    *__init__.py* module (as always), followed by its *__main__.py* module. Otherwise,
    if the package is imported instead, only *__init__.py* is executed.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当通过`python3 -m omission`执行*omission*时，Python首先运行*__init__.py*模块（和往常一样），然后运行其*__main__.py*模块。否则，如果包是被导入的，则仅执行*__init__.py*。
- en: If you omit *__main__.py* from a package, it cannot be executed directly.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从包中省略了*__main__.py*，则无法直接执行该包。
- en: 'A good *__main__.py* for a top-level package would look something like the
    following:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的顶级包的*__main__.py*文件大致如下所示：
- en: '[PRE177]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Listing 4-19: *__main__.py*'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-19: *__main__.py*'
- en: All the logic for starting the package belongs in the `main()` function. Then,
    the `if` statement checks the `__name__` assigned to the *__main__.py* module.
    Since this package is being executed directly, the value of `__name__` is `"__main__"`,
    and the code within the `if` statement, being the call to the `main()` function,
    is run. Otherwise, if *__main__.py* were only being imported, its fully qualified
    name would include its containing package (for example, `omission.__main__`),
    the condition would fail, and the code wouldn’t run.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 启动包的所有逻辑都应放在`main()`函数中。然后，`if`语句检查分配给*__main__.py*模块的`__name__`。由于该包是直接执行的，`__name__`的值为`"__main__"`，因此`if`语句中的代码（即调用`main()`函数）会被执行。否则，如果*__main__.py*只是被导入，它的完全限定名称将包括它所在的包（例如，`omission.__main__`），条件将失败，代码不会执行。
- en: Controlling Package Imports
  id: totrans-1155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制包的导入
- en: A package’s *__init__.py* file can come in handy when you want to change what
    is available for import and how it can be used. The most common uses for this
    file are to simplify imports and to control the behavior of import-all (`import
    *`).
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 包的*__init__.py*文件在你想要更改可导入的内容及其使用方式时非常有用。这个文件最常见的用途是简化导入并控制导入全部（`import *`）的行为。
- en: Simplifying Imports
  id: totrans-1157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简化导入
- en: 'Imagine I have a particularly complicated package, `rockets`, which is made
    up of dozens of subpackages and hundreds of modules. I can safely assume that
    many developers using the package won’t want to know about most of that functionality.
    They only want one thing: to define a rocket and then launch it! Instead of expecting
    all the users of my package to know where those few basic bits of functionality
    exist in the package structure, I can use *__init__.py* to expose said functionality
    directly, making the bits easier to import later:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有一个特别复杂的包`rockets`，它由数十个子包和数百个模块组成。我可以合理假设，很多使用这个包的开发者并不需要了解其中的大部分功能。他们只想要一件事：定义一个火箭，然后发射它！与其期待包的所有用户都知道这些基本功能在包结构中的位置，不如利用*__init__.py*直接暴露这些功能，让它们更容易导入：
- en: '[PRE178]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Listing 4-20: *__init__.py:1*'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-20: *__init__.py:1*'
- en: 'This greatly simplifies the usage of the package. I no longer need to remember
    where things like the `SmallRocket` and `Launchpad` classes live in the `rockets`
    package structure. I can import them directly from the top-level package and use
    them:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 这大大简化了包的使用。我不再需要记住像`SmallRocket`和`Launchpad`类在`rockets`包结构中的位置。我可以直接从顶级包导入它们并使用：
- en: '[PRE179]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Listing 4-21: *rocket_usage.py*'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-21: *rocket_usage.py*'
- en: Beautifully simple, isn’t it? Still, nothing is actually *preventing* me from
    importing things the long-form way (such as `from rockets.smallrocket.rocket import
    SmallRocket`) if I need to. The shortcut is there, but it’s optional.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 漂亮而简洁，不是吗？不过，实际上并没有*阻止*我以长格式的方式导入东西（比如 `from rockets.smallrocket.rocket import
    SmallRocket`），如果我需要的话。这个快捷方式是可选的。
- en: Because simplicity is such an essential part of the Python philosophy, it is
    also an essential component of package design. If you can anticipate the most
    common ways a user might interact with your package, you can greatly simplify
    their code by adding a few lines to *__init__.py*.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为简洁是 Python 哲学的核心部分，它也是包设计的重要组成部分。如果你能预测用户与包交互的最常见方式，通过在*__init__.py*中添加几行代码，你可以大大简化他们的代码。
- en: Controlling Import-All
  id: totrans-1166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制导入全部
- en: By default, import-all doesn’t work with a package. You use *__init__.py* to
    enable and control the behavior of `import *`, even though such an import statement
    is generally discouraged. This can be done by assigning a list of strings to `__all__`,
    with each string containing something (such as a package or module) to import
    from the current package.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，导入全部在包中是不可用的。你可以使用*__init__.py*来启用并控制`import *`的行为，尽管这种导入语句通常是不推荐使用的。可以通过将字符串列表赋值给`__all__`来实现，每个字符串包含一个需要从当前包导入的内容（比如包或模块）。
- en: 'This works well with the previous trick ([Listing 4-20](#listing4-20)):'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法与前面的技巧（[列表 4-20](#listing4-20)）结合得很好：
- en: '[PRE180]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Listing 4-22: *__init__.py:2a*'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-22: *__init__.py:2a*'
- en: 'When Python encounters a line like `from rockets import *`, that list from
    `__all__` (seen as `rockets.__all__`) is unpacked in place of the asterisk (`*`).
    This is important in figuring out what you can include in `__all__`: each item
    in my list should make sense when substituted for the asterisk in `from rockets
    import *`.'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 遇到像 `from rockets import *` 这样的行时，来自`__all__`的列表（可视为`rockets.__all__`）会被展开，替代星号（`*`）。这在确定你可以包含什么到`__all__`中时非常重要：我的列表中的每一项都应该在用`from
    rockets import *`替换星号时是有意义的。
- en: 'In other words, I could change the last line of my *__init__.py* to this, and
    there would be no error in the code:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我可以将我的*__init__.py*的最后一行改成这样，代码就不会出错了：
- en: '[PRE181]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Listing 4-23: *__init__.py:2b*'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-23: *__init__.py:2b*'
- en: This works because, as you already know, the line `from rockets import smallrocket`
    is a valid import statement.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以可行，是因为，正如你已经知道的，`from rockets import smallrocket`这一行是有效的导入语句。
- en: 'On the other hand, this example would *not* work:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这个例子是*不*可行的：
- en: '[PRE182]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Listing 4-24: *__init__.py:2c*'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 4-24: *__init__.py:2c*'
- en: It fails because `from rockets import smallrocket.rocket` does not make sense.
    You’ll have to consider this principle when defining `__all__`.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 它失败了，因为`from rockets import smallrocket.rocket`没有意义。你需要在定义`__all__`时考虑这一原则。
- en: If `__all__` is not defined in *__init__.py*, then `from rockets import *` will
    behave the same as `import rockets`.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`__all__`在 *__init__.py* 中没有定义，那么`from rockets import *`的行为将与`import rockets`相同。
- en: Program Entry Points
  id: totrans-1181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序入口点
- en: If you’ve applied all the concepts in this chapter to your project’s structure,
    you can run `python3 -m yourproject` to start your program.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将本章中的所有概念应用到你的项目结构中，你可以运行`python3 -m yourproject`来启动你的程序。
- en: However, you (or your eventual end user) may want to run the program merely
    by double-clicking or directly executing some single Python file. With everything
    else in place, this is trivial to implement.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你（或最终的最终用户）可能希望通过双击或直接执行某个单一的Python文件来运行程序。其他条件都已就绪时，这个实现非常简单。
- en: 'To make my *omission* project easy to run, I created a single script file *outside
    the top-level package*, named *omission.py*:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我的*omission*项目更容易运行，我创建了一个位于*顶层包外部*的单独脚本文件，命名为*omission.py*：
- en: '[PRE183]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Listing 4-25: *omission.py*'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-25：*omission.py*
- en: I import the `main()` function from *omission/__main__.py* and then execute
    that function. This is effectively the same as executing that package directly
    with `python3 -m omission`.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 我从*omission/__main__.py*中导入`main()`函数，然后执行该函数。这实际上等同于使用`python3 -m omission`直接执行该包。
- en: There are better ways to create a program entry point, but I’ll cover those
    in Chapter 18, once I’ve created the all-important *setup.cfg* file. Again, what
    you have so far will be enough for development.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 有更好的方法来创建程序入口点，但我会在第18章中讲解这些方法，届时我将创建一个至关重要的*setup.cfg*文件。再次强调，到目前为止，你所拥有的已足够进行开发。
- en: The Python Module Search Path
  id: totrans-1189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python模块搜索路径
- en: The *module search path*, or *import path*, defines where Python looks for packages
    and modules and what order it searches in. When you first start the Python interpreter,
    the module search path is assembled in order, from the directory of the module
    being executed, the system variable `PYTHONPATH`, and the default path for the
    Python instance being used.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块搜索路径*，或称为*导入路径*，定义了Python查找包和模块的位置以及搜索顺序。当你第一次启动Python解释器时，模块搜索路径会按顺序构建，包括正在执行的模块所在的目录、系统变量`PYTHONPATH`和所使用的Python实例的默认路径。'
- en: 'You can view the resulting module search path with the following commands:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令查看结果模块搜索路径：
- en: '[PRE184]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Running that code within the context of a virtual environment (in my case,
    */home/jason/.venvs/venv310*) on my system gives me the following output:'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上，在虚拟环境（在我的例子中是*/home/jason/.venvs/venv310*）的上下文中运行这段代码，会给我以下输出：
- en: '[PRE185]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The import system looks through each of the locations in the module search path
    *in order*. As soon as it finds a match for the module or package being imported,
    it stops. You can see here that it searches the directory containing the module
    or script I’m running ❶, the standard libraries ❷ ❸ ❹, and then everything installed
    with pip in the virtual environment ❺.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 导入系统会按*顺序*检查模块搜索路径中的每个位置。一旦它找到与被导入的模块或包匹配的项，就会停止搜索。你可以看到，它会首先搜索包含我正在运行的模块或脚本的目录
    ❶、标准库 ❷ ❸ ❹，然后是虚拟环境中通过pip安装的所有内容 ❺。
- en: If you need to add locations to the module search path, the best way is to use
    a virtual environment and add a file ending in *.pth* to the *lib/python3.x/site-packages*
    directory. The name of the file doesn’t matter, as long as the file extension
    is *.pth*.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要向模块搜索路径添加位置，最佳的方法是使用虚拟环境，并将一个以*.pth*结尾的文件添加到*lib/python3.x/site-packages*目录中。文件名无关紧要，只要文件扩展名是*.pth*即可。
- en: 'For example, consider the following:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下情况：
- en: '[PRE186]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Listing 4-26: *venv/lib/python3.10/site-packages/stuff.pth*'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-26：*venv/lib/python3.10/site-packages/stuff.pth*
- en: Each line must contain exactly one path to be appended. The absolute path */home/jason/bunch_of_code*
    will be appended to the module search path. The relative path *../../../awesomesauce*
    is relative to the .*pth* file, so it will point to *venv/awesomesauce*.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 每行必须包含一个要追加的路径。绝对路径*/home/jason/bunch_of_code*将被追加到模块搜索路径中。相对路径*../../../awesomesauce*相对于.*pth*文件，因此它将指向*venv/awesomesauce*。
- en: Because these are appended to the module search path, this technique cannot
    be used to replace any packages or modules installed on the system or virtual
    environment. However, any new modules or packages in my *bunch_of_code/* or *awesomesauce/*
    directories will be available for import within the virtual environment.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些路径被添加到模块搜索路径中，所以这种方法不能用来替代系统或虚拟环境中已安装的任何包或模块。然而，在我的*bunch_of_code/* 或 *awesomesauce/*
    目录中的任何新模块或包将可以在虚拟环境中导入。
- en: What Really Happens
  id: totrans-1202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际发生了什么
- en: Let’s look at what really happens under the hood when you import a module. Most
    of the time, those details won’t matter, but every now and then (such as when
    the wrong module seems to be imported instead of the one you expect), the technical
    details leak to the surface. It never hurts to know what’s going on.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当你导入一个模块时，底层发生了什么。大多数时候，这些细节并不重要，但偶尔（例如当导入了错误的模块而不是你期望的那个模块时），这些技术细节会浮出水面。了解这些细节总是没有坏处的。
- en: The `import` statement calls the built-in`__import__()` function.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句调用内置的`__import__()`函数。'
- en: 'To import a module, Python uses two special objects: a *finder* and a *loader*.
    In some cases, it uses an *importer* object, which serves as both a finder and
    a loader.'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入模块，Python使用两个特殊对象：*查找器*和*加载器*。在某些情况下，它会使用一个*导入器*对象，既充当查找器又充当加载器。
- en: The *finder* is responsible for locating the module being imported. There are
    many places to look for modules—they aren’t even necessarily files—and a number
    of special situations exist that must be handled. Python has several types of
    finders to handle these different situations, and it gives each one an opportunity
    to locate a module with a given name.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: '*查找器*负责定位被导入的模块。查找模块的地方有很多——它们甚至不一定是文件——并且存在一些必须处理的特殊情况。Python有几种类型的查找器来处理这些不同的情况，它会给每个查找器一个机会，使用给定名称查找模块。'
- en: 'First, Python uses *meta path finders*, which are stored in the `sys.meta_path`
    list. By default, there are three meta path finders:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Python使用*元路径查找器*，这些查找器存储在`sys.meta_path`列表中。默认情况下，有三个元路径查找器：
- en: The *built-in importer* finds and loads built-in modules.
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内置导入器*用于查找并加载内置模块。'
- en: The *frozen importer* finds and loads *frozen* modules, meaning modules that
    have been converted to compiled bytecode (see Chapter 1).
  id: totrans-1209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*冻结导入器*查找并加载*冻结*模块，意味着已经被转换为编译字节码的模块（参见第1章）。'
- en: The *path-based finder* looks in the filesystem for the module.
  id: totrans-1210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于路径的查找器*在文件系统中查找模块。'
- en: This search order is the reason why you cannot globally shadow a built-in module;
    the built-in importer runs before the path-based finder. If you need some additional
    meta path finder, such as if you were importing a module from a novel location
    not already supported, you can add it as a *meta hook* by appending it to the
    `sys.meta_path` list.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种搜索顺序是你无法全局覆盖内置模块的原因；内置导入器会在基于路径的查找器之前运行。如果你需要额外的元路径查找器，例如当你从一个未被支持的新位置导入模块时，你可以通过将其附加到`sys.meta_path`列表中，将其添加为*元钩子*。
- en: There’s some additional complexity to the path-based finder that is worth breaking
    down. The path-based finder tries each of the *path entry finders* in turn. These
    path entry finders, also known as *path entry hooks*, are stored in `sys.path_hooks`.
    Each one searches every location (known as a *path* entry) listed on the import
    path, as specified by `sys.path` or the `__path__` attribute of the current package.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 基于路径的查找器有一些额外的复杂性，值得拆解。基于路径的查找器依次尝试每个*路径条目查找器*。这些路径条目查找器，也叫做*路径条目钩子*，存储在`sys.path_hooks`中。每个查找器会搜索导入路径上列出的每个位置（称为*路径条目*），这些路径条目由`sys.path`或当前包的`__path__`属性指定。
- en: If any of the finders locates the module, it returns a *module spec* object
    with all the information about how to load the module. However, if all the meta
    path finders return `None`, you’ll get a `ModuleNotFoundError`.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何查找器找到模块，它会返回一个*模块规格*对象，其中包含加载该模块的所有信息。然而，如果所有元路径查找器都返回`None`，则会抛出`ModuleNotFoundError`。
- en: Once the module is found, the module spec goes to the *loader*, which is responsible
    for actually loading the module.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到模块，模块规格会传递给*加载器*，它负责实际加载该模块。
- en: There’s a lot of technical detail regarding loading that’s beyond the scope
    of this book, but one thing worth noting is how the loader deals with *cached
    bytecode*. Ordinarily, once a Python module has been run, a *.pyc* file is generated.
    The file contains the bytecode, which from then on is *cached*. You’ll often see
    these *.pyc* files hanging out in your project directories. The loader always
    needs to be sure that the cached bytecode is not out of date before loading it,
    by using one of two strategies. The first strategy is for the bytecode to also
    store the timestamp from the last time the source code file was modified. When
    loading the module, the timestamp of the source code is checked against this cached
    timestamp. If it doesn’t match, the bytecode is out of date, and the source will
    be recompiled. The second strategy, introduced in Python 3.7, instead stores a
    *hash*, which is a short and (relatively) unique value algorithmically generated
    from the source code itself. If the source code changes, the hash will be different
    from the one stored in the cached bytecode. Python bytecode files that contain
    this hash are appropriately called *hash-based .pyc* files.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 关于加载的技术细节有很多，超出了本书的范围，但有一点值得注意，那就是加载器如何处理*缓存的字节码*。通常，一旦Python模块被运行，一个*.pyc*文件会被生成。该文件包含字节码，从那时起它会被*缓存*。你常常会看到这些*.pyc*文件出现在你的项目目录中。加载器始终需要确保缓存的字节码没有过时，才能加载它，方法有两种。第一种策略是让字节码也存储上次源代码文件修改时的时间戳。在加载模块时，源代码的时间戳会与缓存的时间戳进行比较。如果它们不匹配，说明字节码已经过时，源代码将重新编译。第二种策略是在Python
    3.7中引入的，它存储一个*哈希*值，这是一个从源代码本身算法生成的简短且（相对）独特的值。如果源代码发生变化，哈希值与缓存字节码中存储的哈希值将不同。包含此哈希值的Python字节码文件被称为*基于哈希的
    .pyc* 文件。
- en: Regardless of how the loader is loading the module, it will add the module object
    to `sys.modules`—adding it, in fact, just before actually loading, to prevent
    an import loop if the module being loaded imports itself. Finally, the loader
    will bind the imported module object to a name in the module importing it, so
    the imported module can be referenced. (I’ll cover name binding in Chapter 5.)
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 无论加载器如何加载模块，它都会将模块对象添加到`sys.modules`中——实际上，它会在加载之前就将其添加，以防止出现导入循环（如果正在加载的模块导入了自身）。最后，加载器会将导入的模块对象绑定到导入该模块的名称上，以便可以引用导入的模块。（名称绑定将在第5章中介绍。）
- en: Once the module has been imported, it’s cached in `sys.path_importer_cache`,
    along with the importer object used to import it. This is actually the first place
    the import system will check for an imported module, even before running through
    the finders, so importing a module multiple times in a project will still only
    go through the finding-and-loading process once.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模块被导入，它会被缓存到`sys.path_importer_cache`中，连同用于导入它的导入器对象。实际上，这是导入系统检查已导入模块的第一个地方，甚至在遍历查找器之前，所以在项目中多次导入同一个模块时，查找和加载过程只会进行一次。
- en: This is a very broad overview of the import system, but most of the time, it’s
    all you’ll need to know. To learn all the intricate details, you can read the
    official documentation at [https://docs.python.org/3/reference/import.html](https://docs.python.org/3/reference/import.html).
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是导入系统的一个非常广泛的概述，但大多数情况下，这就是你需要知道的全部内容。要了解所有复杂的细节，你可以阅读官方文档：[https://docs.python.org/3/reference/import.html](https://docs.python.org/3/reference/import.html)。
- en: Wrapping Up
  id: totrans-1219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The Python import system is often overlooked when learning the language, leading
    to many headaches for new users. By understanding how to use and import modules
    and packages, you will greatly reduce the roadblocks between you and a viable
    project. A little effort now will save you countless hours of confusion and trouble
    later!
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习Python时，导入系统常常被忽视，这让新手用户感到很多困惑。通过了解如何使用和导入模块和包，你将大大减少你与一个可行项目之间的障碍。现在稍微付出的努力，能够为你以后节省无数的困惑和麻烦！
