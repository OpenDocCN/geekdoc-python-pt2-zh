<html><head></head><body>
<div id="sbo-rt-content"><section>
<header><h1 class="FrontmatterTitle" id="fm-502604f06-0001"><span epub:type="pagebreak" id="Page_xix" title="xix"/>Introduction</h1></header>
<figure class="opener">
<img alt="" height="99" src="image_fi/book_art/chapterart.png" width="98"/>
</figure>
<p class="ChapterIntro">This is a book about computational thinking through the lens of <em>data structures</em>, constructs for organizing and storing data. It is more than a cookbook of handy data structures. Rather, it explores the thinking behind these structures and their fundamental impact on solving complex problems, using real-world analogies to make abstract computational concepts intuitive. The goal of this book is to provide new insights into how you can use preexisting structure within the data to your advantage or create new structures to efficiently solve problems. </p>
<p>Among other things, I discuss the differences between arrays and linked lists, the complexity and power of pointers, the effect of data structures on algorithmic behavior, the branching of tree-based data structures, mathematical mappings in hash tables, and the usefulness of randomization. In short, you’ll learn to think about algorithms by investigating different ways to organize the data they process. You’ll also apply these computational approaches to real-world problems, a surprising number of which focus on procuring a decent cup of coffee.</p>
<p><span epub:type="pagebreak" id="Page_xx" title="xx"/>Understanding how data structures function is critical to using them effectively. Just as an experienced carpenter wouldn’t pound screws into wood with a hammer or use sandpaper to cut a two-by-four in half, an experienced programmer needs to choose the right tools for every job. As we’ll see repeatedly throughout the following chapters, every data structure comes with tradeoffs. Saws cut through wood more effectively than sandpaper but create coarse edges. There is no single data structure that is perfect for every possible use case, but this is what makes computer science and the development of algorithms so interesting. A good computer scientist must understand how different data structures behave in order to determine where they can be best used.</p>
<p>This book focuses on a few canonical data structures and uses them to explore fundamental themes in computational thinking. Each of these data structures is a useful exemplar of a more general class of data structures and of a conceptual approach. For example, B-trees demonstrate one approach to the problems of keeping search trees balanced and optimizing for expensive memory accesses. I discuss the tradeoffs between memory usage and accuracy with Bloom filters; the use of randomization with skip lists; and how to capture multidimensional structure with grids, quadtrees, or k-d trees. As such, this book is neither an introduction to programming, a comprehensive anthology of data structures, nor a full analysis of brewing coffee (although we will touch repeatedly on this important topic). Our goals are different—to develop mental tools that apply across a range of specific problems and programming languages.	</p>
<h2 id="h1-502604f06-0001">Intended Audience</h2>
<p class="BodyFirst">This book is for anyone who wants to learn more about the thinking behind the data structures that lie at the heart of computer science. I assume such basic familiarity with programming as can be expected after taking an introductory course, participating in a boot camp, or working through a beginners’ programming book. Readers should be familiar with fundamental programming concepts such as variables, loops, and conditional statements. Some more adventurous readers might even have coded up some of the data structures or algorithms in this book already or might do so as they read through it. However, you won’t need to know the specific details of particular programming languages or algorithms.</p>
<p>I hope this book appeals to a wide range of audiences. Practitioners who have learned basic programming from an introductory course will find an introduction to computational thinking that can provide a foundation for future investigation. Students will find a new way to understand particularly difficult or tricky topics. Mathematicians will learn new names and jargon for ideas they’ve used since well before computer science existed. And experienced computer scientists will find amusing new analogies to explain concepts they use every day.</p>
<h2 id="h1-502604f06-0002"><span epub:type="pagebreak" id="Page_xxi" title="xxi"/>Language-Agnostic</h2>
<p class="BodyFirst">This book is designed to apply to a wide range of programming languages. While this might come as a disappointment to the more opinionated readers who want to either (a) see their favorite language featured throughout these pages or (b) argue about the author’s terrible language preferences and how they must reflect suboptimal life choices (since programming languages, like sports teams, are always a topic for heated debate), the concepts presented in the book are generally applicable across a range of languages. You can implement a binary search tree in almost any language, for instance. In fact, most programming languages already include many of these basic data structures as part of their core language or a standard library.</p>
<p>The book uses pseudocode examples that are largely based on Python’s general syntax, since Python is a widely used and easily readable programming language. I denote code blocks via indentation, use standard equality notation (<code>==</code> for equal and <code>!=</code> for not equal), use <code>True</code> and <code>False</code> to indicate Boolean values, denote comments with lines starting with the <code>#</code> symbol, and pass composite data structures as references. Arrays are zero indexed, and the value at index <code>i</code> is referenced as <code>arr[i]</code>.</p>
<p>However, I also deviate from the Python syntax wherever this aids readability. I specify all variables as <code>Type: Name</code> to make the types explicit, and I use the value <code>null</code> to indicate a null pointer. I often use <code>WHILE</code> loops over <code>FOR</code> loops or other compact forms to clearly show how the loop is iterating and its termination condition.</p>
<p>I’ve intentionally kept the examples in this book simple in order to focus on the computational ideas behind them. This means that individual implementations may not be fully optimized and will often be more verbose than strictly necessary. Throughout the text, I break out different conditions to illustrate the thought process behind the approach. At times the implementations vary from programming best practices in order to structure the code in a way that matches the explanation. In addition, to keep the examples simple, I often leave out the basic validity checks that are vital to include in production programs, such as checking that our array access is inbounds. Needless to say, treat these examples only as illustrations of the concepts at hand, rather than using them verbatim in your own projects. This is a good rule in general: never treat pseudocode as a full implementation. Always incorporate the relevant testing, validity checks, and other best practices when implementing algorithms yourself.</p>
<h2 id="h1-502604f06-0003">On Analogies and Brewing Coffee </h2>
<p class="BodyFirst">This book makes extensive use of metaphor and analogy, illustrating complex technical concepts by comparison to (sometimes absurd) real-world scenarios. Similes are scattered through this book like blueberries through a muffin. Each chapter explains the intricate working of data structures and algorithms with examples ranging from organizing your kitchen to determining whether you’ve ever tried a specific brew of coffee, inviting you to consider how these computational concepts work in a different way from computer code. </p>
<p><span epub:type="pagebreak" id="Page_xxii" title="xxii"/>The examples will often bend the rules of reality, be oversimplified, or border on the ridiculous. For example, we repeatedly consider the question of storing and sorting extensive coffee collections, ignoring the tragic fact that coffee does go stale. While that means this book is not a strictly realistic guide to making the ultimate cup of coffee, the absurd analogies keep things fun and should encourage you to think outside your normal approaches. Simplifying the analogies allows us to focus on just those aspects that are critical to the computational concept. For example, when discussing the use of nearest-neighbor search to find a close cup of coffee, I focus on distances (the core computational concept) and neglect such complicating factors as fences or rivers. My goal is to tailor the analogy to the core of the problem.</p>
<p>I use analogies to augment formal descriptions and precise code. Personally, I find it easier to break free from technicalities and minutiae when viewing a data structure’s operation in an active, narrative context with people (or even overcaffeinated squirrels) interacting with physical objects, rather than sticking to the vocabulary of <code>FOR</code> loops and variable counters. Visualizing a frantic chase through a maze of alleyways provides a different perspective of a graph algorithm from the formal context of iterating over abstract nodes and edges. I encourage readers to map these analogies to their own broad range of concepts, whether part of their daily life or fancies of the absurd. </p>
<h2 id="h1-502604f06-0004">How to Use This Book</h2>
<p class="BodyFirst">The book is structured progressively. That is, while each chapter focuses on a different computational concept—either a data structure or motivating problem—each also builds upon the previous chapters. Most of the later chapters, for example, rely on the discussion of memory-linked data structures and the use of pointers introduced in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. We return to the basic binary search tree structure introduced in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> again and again as we examine variations of branching data structures. Thus, I recommend that you approach the chapters in order.</p>
<p>As we explore different data structures and how they apply to various problems, we will see consistent themes appear, including:</p>
<ul>
<li>The impact of the data’s structure on algorithms accessing it</li>
<li>How to think about performance in the worst case</li>
<li>The importance of allowing for dynamic changes in your data set and how to efficiently enable these changes</li>
<li>Tradeoffs among memory, runtime, code complexity, and accuracy</li>
<li>How we may need to tune data structures for the problem and what tradeoffs to consider</li>
<li>How we can adapt data structures to tackle new problems</li>
</ul>
<p class="BodyContinued"><span epub:type="pagebreak" id="Page_xxiii" title="xxiii"/>These themes provide both a framework for thinking about the data structures and a set of questions to ask when facing a new problem. A critical aspect of choosing the data structure is understanding why it performs the way it does and how it will apply to new data.</p>
<p>Most of all, the two questions that you should keep in mind throughout the book are “How?” and “Why?” <em>How</em> does a given data structure enable a computation? <em>How</em> do we structure the data to maximize efficiency in a given context? <em>Why</em> does a given structure enable these computations? <em>How</em> does this data structure break down in a different context? <em>Why</em> is the author using that ridiculous analogy? <em>Why</em> is the author so obsessed with coffee? Understanding the answers to these questions (other than the last one) will provide the foundation you need to effectively use already-existing data structures and develop novel techniques in the future.</p>
</section>
</div></body></html>