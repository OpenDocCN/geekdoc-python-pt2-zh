- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introspection and Generics
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Introspection* is the ability of code to access information about itself at
    runtime and respond accordingly. As an interpreted language, Python excels at
    introspection. By understanding how Python inspects objects, you can uncover a
    number of patterns for improving and optimizing your code.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll cover special attributes, which make this introspection
    possible. By making use of these special attributes, I’ll cover generic functions,
    descriptors, and slots, and I’ll even build an (effectively) immutable class.
    Then, while on the topic of code running itself, I’ll touch on the dangers of
    arbitrary execution.
  prefs: []
  type: TYPE_NORMAL
- en: Special Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python achieves introspection primarily by storing important information in
    *special attributes* on the different objects in use. These special attributes
    give Python runtime knowledge about names, project structure, relationships between
    objects, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Like special methods, all special attributes start and end with a double underscore
    (`__`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already seen several of these special attributes in preceding chapters,
    like the special attribute `__name__`, which contains the name of the module being
    executed, except on the entry point module, where it has the value `"__main__"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also the special attribute `__file__`, which contains the absolute
    path to the current module and can be used to find files in a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, Python is able to access information about the structure of the
    project at runtime. That’s introspection at work.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll introduce the various special attributes as I need them in this chapter.
    As a handy reference, I’ve listed all the special attributes in Python in Appendix
    A.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside Object Attribute Access: The __dict__ Special Attribute'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write introspective code, you must understand how Python stores the names
    and values of attributes. Every class and every object has an instance of the
    special attribute `__dict__`, which is a dictionary that stores attributes and
    methods. Much of the behavior relating to object attribute access depends on which
    dictionary—the one on the class or the one on the instance—contains a particular
    attribute or method. This is actually more complicated than you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following simple class structure defining a `Llama` as a `Quadruped`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-1: *llama.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: The `Quadruped` and `Llama` classes here are designed specifically to demonstrate
    attribute access, so please overlook the violations of good object design here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s inspect the `__dict__` special attributes for the instance and two classes
    we created, to learn where Python stores everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-2: *llama.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m using the `pprint` module and function to *pretty-print* the dictionaries,
    meaning I see each key-value pair in the dictionary on its own line. Pretty printing
    is useful for displaying complex collections in a more readable way. The output
    for this code shows the contents of the `__dict__` special attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You might be surprised at where some things are located. The instance attributes
    of `species` and `swimming` are found on the instance itself ❶, but all the instance
    methods are stored on the class (rather than the instance) ❷, along with the class
    attributes and custom class methods. `Quadruped.__dict__` stores the `Quadruped`
    class attribute `leg_count` ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Another oddity is that the class `__dict__` attribute is actually of type `mappingproxy`,
    a special class defined in `types.MappingProxyType`. Technical details aside,
    it’s effectively a read-only view of a dictionary. The class’s `__dict__` attribute
    is this `MappingProxyType`, but the instance’s `__dict__` attribute is just an
    ordinary dictionary. Because of this, however, you cannot directly modify a class
    `__dict__` special attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, although it’s impractical to depict here, all the special attributes
    and methods of the class itself are defined in the *metaclass’s* `__dict__` attribute.
    In most cases, including here, you can see that with `pprint(type.__dict__)`.
  prefs: []
  type: TYPE_NORMAL
- en: You can see there are some complex rules regarding where any given attribute
    or method is stored. Although I can directly access any class or instance attribute
    or method through the right `__dict__` special attribute, actually performing
    that lookup correctly is non-trivial. Python provides a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two functions built for the purpose of inspecting the `__dict__`
    attribute of any class or instance: `vars()` and `dir()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vars()` function prints the `__dict__` attribute for the given object
    or class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-3: *llama.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: The output of this code should be identical to that for [Listing 15-2](#listing15-2).
  prefs: []
  type: TYPE_NORMAL
- en: Running `vars()` without any argument inside a class, object, or function prints
    out the `__dict__` for the current scope. Outside the scope of any objects, functions,
    and classes, it prints a dictionary representing the local symbol table. If you
    want the local or global symbol table as a dictionary, you can also run `locals()`
    or `globals()`, respectively. Be warned that you should never attempt to modify
    local or global values using the dictionaries returned from these functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `dir()` built-in function returns a list of all names (but not values) in
    the current scope or the scope of the given object or class. By default, `dir()`
    compiles that list using the `__dict__` attributes, and it will also include names
    from the base classes. You can override this behavior by writing your own `__dir__()`
    method, which you might do if you’ve modified your class in other ways, to handle
    names that aren’t actually attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, these four functions—`vars()`, `locals()`, `globals()`, and `dir()`—are
    usually only useful when you’re working in the interactive prompt, or else during
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an Attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To access an attribute, say `leg_count` or `swimming`, I’d ordinarily use the
    dot operator (`.`), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-4: *llama.py:3a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dot operator on a class or object is syntactic sugar for the built-in function
    `getattr()`. Here are the equivalent function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-5: *llama.py:3b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, I pass two arguments to `getattr()`: the object I’m searching
    on, followed by the name I’m searching for as a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, the `getattr()` function employs two special methods: `__getattribute__()`,
    which handles the complex lookup logic, and `__getattr__()`, which the user can
    optionally implement to further extend the behavior of the `getattr()` function
    on a class.'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, either `object.__getattribute__()` or `type.__getattribute__()`
    is involved in searching on an instance or class, respectively. Even if this special
    method is reimplemented by a derived class or metaclass, that reimplementation
    will have to explicitly call `object.__getattribute__()` or `type.__getattribute__()`
    to avoid infinite recursion. This is just as well, as it would be no small matter
    to correctly reimplement all the behavior of `__getattribute__()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `__getattribute__()` special method works by searching through the `__dict__`
    objects on the instances and classes, following the method resolution order. If
    it doesn’t find the attribute it’s searching for, it raises an `AttributeError`.
    From there, `getattr()` will check whether the special method `__getattr__()`
    has been defined—that’s the special user-defined method used as a fallback for
    attribute lookup when `__getattribute__()` fails. If `__getattr__()` has been
    defined, it is called by `getattr()` as a last step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I’ll use `__getattribute__()` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-6: *llama.py:3c*'
  prefs: []
  type: TYPE_NORMAL
- en: Objects and metaclasses both have a `__dict__` special attribute, which is used
    to store all other attributes by name. This is why you can add attributes to an
    object or class arbitrarily, even from outside the class definition. (There’s
    an alternative means of storing attributes, which I’ll return to later.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a rough reimplementation of the `getattr()` function, demonstrating
    how `__getattribute__()` and `__gettattr__()` are actually used in attribute lookups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-7: *llama.py:3d*'
  prefs: []
  type: TYPE_NORMAL
- en: While this is not identical to what’s really happening in `getattr()`, it’s
    close enough to understand what’s going on. In the first block, I’m accessing
    `llama.swimming`, and in the second, `Llama.leg_count`. In both cases, I start
    by calling the appropriate `__getattribute__()` special method in a `try` clause.
    If an `AttributeError` is raised, I next check if `__getattr__()` has been implemented;
    this, too, is done with `__getattribute__()`. If `__getattr__()` does exist, it’s
    called to perform a fallback attribute check, but if it doesn’t, the original
    `AttributeError` is raised again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whew! That’s a lot of work. Thankfully, Python hides all this complexity from
    us. To access an attribute or method, use the dot operator if you know the name
    of what you’re looking for in advance, or use `getattr()` to perform lookups at
    runtime, using a string for the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-8: *llama.py:3e*'
  prefs: []
  type: TYPE_NORMAL
- en: As for overriding the normal behavior, `__getattr__()` is usually the only one
    of the two special methods involved that you should ever implement. One common
    use of `__getattr__()` is to provide a default value for attributes that don’t
    exist. As a rule, you should leave `__getattribute__()` alone.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for an Attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To check for the existence of an attribute, use the `hasattr()` function, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-9: *llama.py:4a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, `hasattr()` calls `getattr()` in a try statement, similar
    to if I had done this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-10: *llama.py:4b*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting an Attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting an attribute isn’t quite as involved as accessing one. The `setattr()`
    function relies on the `__setattr__()` special method. By default, setting an
    attribute to a value should always work. Here, I set the instance attribute `larger_than_frogs`
    on `llama` to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-11: *llama.py:5a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I pass three arguments to `setattr()`: the object or class to change the attribute
    on, the attribute name as a string, and the new value. The `setattr()` method
    completely ignores inheritance and the method resolution order; it is only concerned
    with modifying the `__dict__` on the specified object or class. If the attribute
    exists on that `__dict__`, the method alters it; otherwise, the method creates
    a new attribute on the `__dict__`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, `setattr()` relies on the special method `__setattr__()`,
    and the code in [Listing 15-11](#listing15-11) is effectively doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-12: *llama.py:5b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That, in turn, modifies `llama.__dict__` and `Llama.__dict__`, respectively.
    There’s one funny detail here: while I could have modified `llama.__dict__` manually,
    `Llama.__dict__` is a `mappingproxy`, meaning it is read-only for everyone and
    everything *except* `type.__setattr__()`, which alone knows the secret to modifying
    the data represented in a `mappingproxy`. (Seriously, it’s not even documented.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When setting an attribute, either via `setattr()` or the dot operator, pay
    careful attention to whether you are modifying an existing class attribute or
    merely shadowing it with an instance attribute. Accidental shadowing creates all
    sorts of bad surprises, as we’ve seen before. Here’s what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-13: *llama.py:6a*'
  prefs: []
  type: TYPE_NORMAL
- en: In my call to `setattr()` here, I’m adding the key `'dangerous'` to the instance’s
    special attribute `llama.__dict__`, ignoring altogether the existence of the same
    key on the class’s special attribute, `Llama.__dict__`. The print statements demonstrate
    the resulting shadowing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unexpected shadowing is not a problem particular to `setattr()` but exists
    with any assignment to an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-14: *llama.py:6b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure I don’t shadow class attributes with instance attributes, I must
    be careful to only modify class attributes on the class, never on an instance
    thereof:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-15: *llama.py:6c*'
  prefs: []
  type: TYPE_NORMAL
- en: To control how an object handles assignment to its attributes, you can reimplement
    the `__setattr__()` special method yourself. Use caution here, too. Your implementation
    of `__setattr__()` can actually *prevent* attributes from working altogether if
    it never modifies the `__dict__` special attribute and never calls `object.__setattr__()`
    (or `type.__setattr__()`, when working with class attributes).
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an Attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `delattr()` method deletes attributes. It relies on the `__delattr__()`
    special method and works in the same manner as `setattr()`, except that it returns
    an `AttributeError` if the requested attribute doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, you would use the `del` operator for this purpose, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-16: *llama.py:7a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the same as calling `delattr()` directly, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-17: *llama.py:7b*'
  prefs: []
  type: TYPE_NORMAL
- en: The `delattr()` function invokes `__delattr__()` the same way that `setattr()`
    invokes `__setattr__()`. If you want to control the deletion of attributes, you
    can reimplement `__delattr__()`, although you should use the same caution when
    altering this special method as with `__setattr__()`.
  prefs: []
  type: TYPE_NORMAL
- en: Function Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all objects can have attributes, and if functions are objects, then surely,
    functions can have attributes. This is indeed the case, but they don’t work in
    the way you might think.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, you will rarely need to use function attributes directly. They’re
    mainly useful for enabling other patterns and techniques to work. These tasks
    border “deep magic” territory, whence we find metaclasses (Chapter 14).
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, function attributes were originally added to Python purely because
    they looked like they *should* exist. Libraries could already abuse `__docstring__`
    to hack in an approximation of function attribute behavior anyway. Meanwhile,
    other developers were trying to approximate function attributes by creating classes
    that consisted purely of class attributes and a `__call__()` method, a technique
    that has a fair bit of performance overhead compared to a normal function with
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the Python developers reasoned, “Well, if they’re going to do it anyway,
    we might as well provide a formal and obvious mechanism for it.”
  prefs: []
  type: TYPE_NORMAL
- en: The Wrong Way to Use Function Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To demonstrate function attributes and their pitfalls, consider the following
    example, in which I initially use function attributes incorrectly. This code defines
    a multiplier function that stores one of its operands in a function attribute.
    I’ll get to why this entire technique is a bad idea in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `multiplier()` multiplies the argument `n` by the value `factor`
    and prints the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-18: *function_attribute.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: In the usage, I incorrectly attempt to change the value of `factor` to `3` by
    assigning the value to a function attribute ❶. As you can see, the output of the
    function call is `0`, proving this did not work as expected ❷, as the local-scope
    variable is still `0`. Yet, if I inspect `multiplier.factor`, this function attribute’s
    value is indeed `3`. What happened?
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that function attributes are not the same thing as local-scope
    variables, but rather exist inside the `multiplier` object’s `__dict__` attribute.
    If I print this `__dict__` attribute, you can see that it includes the `multiplier.factor`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-19: *function_attribute.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s more, I cannot access function attributes within the function by name
    only, as I tried to do with the print call in the `multiplier()` function. The
    only way to access the function attributes is through `getattr()`, either directly
    or via the dot operator, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-20: *function_attribute.py:1c*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the multiplication operation now succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s still another technical problem with this code: if I fail to assign
    an initial value to `multiplier.factor`, the call to `multiplier()` in [Listing
    15-20](#listing15-20) will fail. I can correct this problem by having the `multiplier()`
    function define a default value for that function attribute, if it is undefined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the final working version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-21: *function_attribute.py:1d*'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `multiplier()`, I check whether the `factor` function attribute
    has been defined. If it hasn’t, I set it to a default value of `0`. Then, by changing
    the function attribute externally ❶, I can change the behavior of the function.
  prefs: []
  type: TYPE_NORMAL
- en: As I’ve said from the start, though, this is only a simple example to demonstrate
    how function attributes work. My usage is not even remotely Pythonic!
  prefs: []
  type: TYPE_NORMAL
- en: Mutability and Function Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll recall from Chapter 6 that functions should be *stateless*. Given what
    the function is designed to do, one may reasonably expect that ``multiplier(2)
    will return the same value every time. That premise has been violated because
    `multiplier()` stores state in its function attributes. Changing `multiplier.factor`
    will change the value returned by `multiplier(2)`.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24] def skit():     print(skit.actor)  skit.actor = "John Cleese" skit()    #
    prints "John Cleese"  sketch = skit sketch()  # prints "John Cleese" sketch.actor
    = "Eric Idle" sketch()  # prints "Eric Idle"  skit()    # prints "Eric Idle"...yikes!
    [PRE25] import re   class Book:     pattern = re.compile(r''(.+)\((\d+)\)\. (.+)\.
    (.+)\..*'')      def __set__(self, instance, value):         matches = self.pattern.match(value)         if
    not matches:             raise ValueError("Book data must be specified in APA
    7 format.")         self.author = matches.group(1)         self.year = matches.group(2)         self.title
    = matches.group(3)         self.publisher = matches.group(4) [PRE26]  def __get__(self,
    instance, owner=None):         try:             return f"''{self.title}'' by {self.author}"         except
    AttributeError:             return "nothing right now" [PRE27] class BookClub:     reading
    = Book()      def __init__(self, name):         self.name = name         self.members
    = []      def new_member(self, member):         self.members.append(member)         print(             "=====
    - - - - - - - - - =====",             f"Welcome to the {self.name} Book Club,
    {member}!",             f"We are reading {self.reading}",             "===== -
    - - - - - - - - =====",             sep=''\n''         ) [PRE28] mystery_lovers
    = BookClub("Mystery Lovers") lattes_and_lit = BookClub("Lattes and Lit")  mystery_lovers.reading
    = (     "McDonald, J. C. (2019). "     "Noah Clue, P.I. AJ Charleson Publishing."
    ) lattes_and_lit.reading = (     "Christie, A. (1926). "     "The Murder of Roger
    Ackroyd. William Collins & Sons." )  print(mystery_lovers.reading)  # prints "''The
    Murder of Roger Ackroyd..." print(lattes_and_lit.reading)  # prints "''The Murder
    of Roger Ackroyd..." [PRE29] class Book:     pattern = re.compile(r''(.+)\((\d+)\)\.
    (.+)\. (.+)\..*'')      def __set__(self, instance, value):         matches =
    self.pattern.match(value)         if not matches:             raise ValueError("Book
    data must be specified in APA 7 format.")         **instance**.author = matches.group(1)         **instance**.year
    = matches.group(2)         **instance**.title = matches.group(3)         **instance**.publisher
    = matches.group(4) [PRE30]  def __get__(self, instance, owner=None):         try:             return
    f"''{**instance**.title}'' by {**instance**.author}"         except AttributeError:  return
    "nothing right now"      **def __delete__(self, instance):**  **del instance.author**  **del
    instance.year**  **del instance.title**  **del instance.publisher** [PRE31] mystery_lovers
    = BookClub("Mystery Lovers") lattes_and_lit = BookClub("Lattes and Lit")  mystery_lovers.reading
    = (     "McDonald, J. C. (2019). "     "Noah Clue, P.I. AJ Charleson Publishing."
    ) lattes_and_lit.reading = (     "Christie, A. (1926). "     "The Murder of Roger
    Ackroyd. William Collins & Sons." )  print(mystery_lovers.reading)  # prints "''Noah
    Clue, P.I...." print(lattes_and_lit.reading)  # prints "''The Murder of Roger
    Ackroyd..." [PRE32] del lattes_and_lit.reading  lattes_and_lit.new_member("Jaime")  lattes_and_lit.reading
    = (     "Hillerman, T. (1973). "     "Dance Hall Of The Dead. Harper and Row."
    )  lattes_and_lit.new_member("Danny") [PRE33] ===== - - - - - - - - - ===== Welcome
    to the Lattes and Lit Book Club, Jaime! We are reading nothing right now. =====
    - - - - - - - - - ===== Welcome to the Lattes and Lit Book Club, Danny! We are
    reading ''Dance Hall Of The Dead'' by Hillerman, T. [PRE34] class BookClub:     reading
    = Book()     **reading_next = Book()**      # `--snip--` [PRE35] mystery_lovers.reading
    = (     "McDonald, J. C. (2019). "     "Noah Clue, P.I. AJ Charleson Publishing."
    )  mystery_lovers.reading_next = (     "Chesterton, G.K. (1911). The Innocence
    of Father Brown. "     "Cassell and Company, Ltd." ) print(f"Now: {mystery_lovers.reading}")
    print(f"Next: {mystery_lovers.reading_next}") [PRE36] Now: ''The Innocence of
    Father Brown'' by Chesterton, G.K.  Next: ''The Innocence of Father Brown'' by
    Chesterton, G.K. [PRE37] import re  class Book:     pattern = re.compile(r''(.+)\((\d+)\)\.
    (.+)\. (.+)\..*'')      **def __set_name__(self, owner, name):**  **self.name
    = name**      **def attr(self, attr):**  **return f"{self.name}.{attr}"**      def
    __set__(self, instance, value):         matches = self.pattern.match(value)         if
    not matches:             raise ValueError("Book data must be specified in APA
    7 format.")         **setattr(**instance**, self.attr(''**author**''),** matches.group(1)**)**         **setattr(**instance**,
    self.attr(''**year**''),** matches.group(2)**)**         **setattr(**instance**,
    self.attr(''**title**''),** matches.group(3)**)**         **setattr(**instance**,
    self.attr(''**publisher**''),** matches.group(4)**)** [PRE38]  def __get__(self,
    instance, owner=None):         try:             **title = getattr(instance, self.attr(''title''))**             **author
    = getattr(instance, self.attr(''author''))**         except AttributeError:             return
    "nothing right now"         **return f"{title} by {author}"**      def __delete__(self,
    instance):         **delattr(**instance**, self.attr(''**author**''))**         **delattr(**instance**,
    self.attr(''**year**''))**  **delattr(**instance**, self.attr(''**title**''))**         **delattr(**instance**,
    self.attr(''**publisher**''))** [PRE39] Now: ''Noah Clue, P.I.'' by McDonald,
    J.C.  Next: ''The Innocence of Father Brown'' by Chesterton, G.K. [PRE40] import
    pprint pprint.pprint(dir(mystery_lovers)) [PRE41] [''__class__'', # `--snip--`  ''reading'',  ''reading.author'',  ''reading.publisher'',  ''reading.title'',  ''reading.year'',  ''reading_next'',  ''reading_next.author'',  ''reading_next.publisher'',  ''reading_next.title'',  ''reading_next.year'']
    [PRE42] class Element:     __slots__ = (         ''name'',         ''number'',         ''symbol'',         ''family'',         ''iupac_num'',     )
    [PRE43]  def __init__(self, symbol, number, name, family, numeration):         self.symbol
    = symbol.title()         self.number = number         self.name = name.lower()         self.family
    = family.lower()         self.iupac_num = numeration      def __str__(self):         return
    f"{self.symbol} ({self.name}): {self.number}" [PRE44] oxygen = Element(''O'',
    8, ''oxygen'', ''non-metals'', 16) iron = Element(''Fe'', 26, ''iron'', ''transition
    metal'', 8)  print(oxygen)  # prints ''O (Oxygen): 8'' print(iron)    # prints
    ''Fe (Iron): 26'' [PRE45] iron.atomic_mass = 55.845  # raises AttributeError [PRE46]
    class Element:     __slots__ = (         ''name'',         ''number'',         ''symbol'',         ''family'',         ''iupac_num'',         **''__dict__'',**         **''__weakref__'',**     )
    [PRE47] class Element:     __slots__ = (         ''name'',         ''number'',         ''symbol'',         ''__weakref__'',     )      def
    __init__(self, symbol, number, name):         self.symbol = symbol.title()         self.number
    = number         self.name = name.lower() [PRE48]  def __repr__(self):         return
    f"{self.symbol} ({self.name}): {self.number}"   def __str__(self):         return
    self.symbol      def __hash__(self):         return hash(self.symbol)      def
    __eq__(self, other):         return self.symbol == other.symbol      def __lt__(self,
    other):         return self.symbol < other.symbol      def __le__(self, other):         return
    self.symbol <= other.symbol [PRE49]  def __setattr__(self, name, value):         if
    hasattr(self, name):             raise AttributeError(                 f"''{type(self)}''
    object attribute ''{name}'' is read-only"             )         object.__setattr__(self,
    name, value) [PRE50]  def __delattr__(self, name):         raise AttributeError(             f"''{type(self)}''
    object attribute ′{name}'' is read-only"         ) [PRE51] oxygen = Element(''O'',
    8, ''oxygen'') iron = Element(''Fe'', 26, ''iron'')  print(oxygen)              #
    prints O print(f"{iron!r}")         # prints Fe (Iron): 26  iron.atomic_mass =
    55.845  # raises AttributeError iron.symbol = "Ir"         # raises AttributeError
    del iron.symbol            # raises AttributeError [PRE52] `object.__setattr__(iron,
    ''symbol'', ''Ir'')` [PRE53] **from functools import singledispatchmethod** **from
    typing import overload**  class Element:   # `--snip--` [PRE54]  @singledispatchmethod     def
    __eq__(self, other):         return self.symbol == other.symbol [PRE55]  @__eq__.register     def
    _(self, other: str):         return self.symbol == other      @overload     def
    _(self, other: float):         ...     @__eq__.register     def _(self, other:
    int):         return self.number == other [PRE56]  @singledispatchmethod     def
    __lt__(self, other):         return self.symbol < other.symbol      @__lt__.register(str)     def
    _(self, other):  return self.symbol < other      @__lt__.register(int)     @__lt__.register(float)     def
    _(self, other):         return self.number < other [PRE57]  @singledispatchmethod     def
    __le__(self, other):         return self.symbol <= other.symbol      __le__.register(str,
    lambda self, other: self.symbol <= other)      __le__.register(int, lambda self,
    other: self.number <= other)     __le__.register(float, lambda self, other: self.number
    <= other) [PRE58] class Compound:      def __init__(self, name):  self.name =
    name.title()         self.components = {}      def add_element(self, element,
    count):         try:             self.components[element] += count         except
    KeyError:             self.components[element] = count      def __str__(self):         s
    = ""         formula = self.components.copy()         # Hill system         if
    ''C'' in formula.keys():             s += f"C{formula[''C'']}"             del
    formula[''C'']             if 1 in formula.keys():                 s += f"H{formula[''H'']}"                 del
    formula[''H'']         for element, count in sorted(formula.items()):             s
    += f"{element.symbol}{count if count > 1 else ''''}"         # substitute subscript
    digits for normal digits         s = s.translate(str.maketrans("0123456789", "[₀₁₂₃₄₅₆₇₈₉]"))         return
    s      def __repr__(self):         return f"{self.name}: {self}" [PRE59] hydrogen
    = Element(''H'', 1, ''hydrogen'') carbon = Element(''C'', 6, ''carbon'') oxygen
    = Element(''O'', 8, ''oxygen'') iron = Element(''Fe'', 26, ''iron'')  rust = Compound("iron
    oxide") rust.add_element(oxygen, count=3) rust.add_element(iron, count=2) print(f"{rust!r}")     #
    prints ''Iron Oxide: Fe₂O₃''  aspirin = Compound("acetylsalicylic acid") aspirin.add_element(hydrogen,
    8) aspirin.add_element(oxygen, 4) aspirin.add_element(carbon, 9) print(f"{aspirin!r}")  #
    prints ''Acetylsalicylic Acid: C₉H₈O₄''  water = Compound("water") water.add_element(hydrogen,
    2) water.add_element(oxygen, 1) print(f"{water!r}")    # prints ''Water: H₂O''
    [PRE60] with open(''input.dat'', ''r'') as file:     nums = [value.strip() for
    value in file if value]  for num in nums:     expression = f"{num} // 2 + 2"     try:         answer
    = eval(expression)     except (NameError, ValueError, TypeError, SyntaxError)
    as e:         print(e)     finally:         code = "print(''The answer is'', answer)"         obj
    = compile(code, ''<string>'', mode=''exec'')         exec(obj) [PRE61] 40 (30
    + 7) 9 * 3 0xAA & 0xBB 80 [PRE62] The answer is 22 The answer is 20 The answer
    is 15 The answer is 10 The answer is 42 [PRE63] 40 (30 + 7) 9 * 3 0xAA & 0xBB
    80 exec(''import os'') or os.system(''echo \"`whoami` is DOOMED\"'') == 0 or 1
    [PRE64] The answer is 22 The answer is 20 The answer is 15 The answer is 10 The
    answer is 42 jason is DOOMED The answer is True [PRE65]`'
  prefs: []
  type: TYPE_NORMAL
