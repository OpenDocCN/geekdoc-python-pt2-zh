["```py\n*matrices.py*\nA = [[2,3],[5,-8]]\nB = [[1,-4],[8,-6]]\n\ndef addMatrices(a,b):\n    '''adds two 2x2 matrices together'''\n    C = [[a[0][0]+b[0][0],a[0][1]+b[0][1]],\n         [a[1][0]+b[1][0],a[1][1]+b[1][1]]]\n    return C\n\nC = addMatrices(A,B)\nprint(C)\n```", "```py\n[[3, -1], [13, -14]]\n```", "```py\ndef multmatrix(a,b):\n    #Returns the product of matrix a and matrix b\n    m = len(a) #number of rows in first matrix\n    n = len(b[0]) #number of columns in second matrix\n    newmatrix = []\n    for i in range(m):\n        row = []\n        #for every column in b\n        for j in range(n):\n            sum1 = 0\n            #for every element in the column\n            for k in range(len(b)):\n                sum1 += a[i][k]*b[k][j]\n            row.append(sum1)\n        newmatrix.append(row)\n    return newmatrix\n```", "```py\na[i][0] * b[0][j]\n```", "```py\na[i][1] * b[1][j]\n```", "```py\nsum1 += a[i][k] * b[k][j]\n```", "```py\n>>> a = [[1,2,-3,-1]]\n>>> b = [[4,-1],\n         [-2,3],\n         [6,-3],\n         [1,0]]\n>>> print(multmatrix(a,b))\n[[-19, 14]]\n```", "```py\n>>> a = [[1,-2],[2,1]]\n>>> b = [[3,-4],[5,6]]\n>>> multmatrix(a,b)\n[[-7, -16], [11, -2]]\n```", "```py\n>>> a = [[1,-2],[2,1]]\n>>> b = [[3,-4],[5,6]]\n>>> multmatrix(b,a)\n[[-5, -10], [17, -4]]\n```", "```py\n*matrices.pyde*\n#set the range of x-values\nxmin = -10\nxmax = 10\n\n#range of y-values\nymin = -10\nymax = 10\n\n #calculate the range\nrangex = xmax - xmin\nrangey = ymax - ymin\n\ndef setup():\n    global xscl, yscl\n    size(600,600)\n    #the scale factors for drawing on the grid:\n    xscl= width/rangex\n    yscl= -height/rangey\n    noFill()\n\ndef draw():\n    global xscl, yscl\n    background(255) #white\n    translate(width/2,height/2)\n    grid(xscl, yscl)\n\ndef grid(xscl,yscl):\n    '''Draws a grid for graphing'''\n    #cyan lines\n    strokeWeight(1)\n    stroke(0,255,255)\n    for i in range(xmin,xmax+1):\n        line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)\n    for i in range(ymin,ymax+1):\n        line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)\n    stroke(0) #black axes\n    line(0,ymin*yscl,0,ymax*yscl)\n    line(xmin*xscl,0,xmax*xscl,0)\n```", "```py\nfmatrix = [[0,0],[1,0],[1,2],[2,2],[2,3],[1,3],[1,4],[3,4],[3,5],[0,5]]\n\ndef graphPoints(matrix):\n    #draw line segments between consecutive points\n    beginShape()\n    for pt in matrix:\n        vertex(pt[0]*xscl,pt[1]*yscl)\n    endShape(CLOSE)\n```", "```py\n    strokeWeight(2) #thicker line\n    stroke(0) #black\n    graphPoints(fmatrix)\n```", "```py\ntransformation_matrix = [[0,-1],[1,0]]\n```", "```py\n    newmatrix = multmatrix(fmatrix,transformation_matrix)\n    graphPoints(fmatrix)\n    stroke(255,0,0) #red resultant matrix\n    graphPoints(newmatrix)\n```", "```py\nfmatrix = [[[0],[0]],[[1],[0]],[[1],[2]],[[2],[2]],[[2],[3]],\n           [[1],[3]],[[1],[4]],[[3],[4]],[[3],[5]],[[0],[5]]]\n```", "```py\nfmatrix = [[0,1,1,2,2,1,1,3,3,0],[0,0,2,2,3,3,4,4,5,5]]\n```", "```py\ndef transpose(a):\n    '''Transposes matrix a'''\n    output = []\n    m = len(a)\n    n = len(a[0])\n    #create an n x m matrix\n    for i in range(n):\n        output.append([])\n        for j in range(m):\n            #replace a[i][j] with a[j][i]\n            output[i].append(a[j][i])\n    return output\n```", "```py\noutput[i].append(a[j][i])\n```", "```py\n>>> a = [[1,2,-3,-1]]\n>>> transpose(a)\n[[1], [2], [-3], [-1]]\n>>> b = [[4,-1],\n         [-2,3],\n         [6,-3],\n         [1,0]]\n>>> transpose(b)\n[[4, -2, 6, 1], [-1, 3, -3, 0]]\n```", "```py\n*matrices.pyde*\ndef draw():\n    global xscl, yscl\n    background(255) #white\n    translate(width/2,height/2)\n    grid(xscl, yscl)\n    strokeWeight(2) #thicker line\n    stroke(0) #black\n ➊ newmatrix = transpose(multmatrix(transformation_matrix,\n                          ➋ transpose(fmatrix)))\n    graphPoints(fmatrix)\n    stroke(255,0,0) #red resultant matrix\n    graphPoints(newmatrix)\n```", "```py\n*matrices.pyde*\n#set the range of x-values\nxmin = -10\nxmax = 10\n\n#range of y-values\nymin = -10\nymax = 10\n\n#calculate the range\nrangex = xmax - xmin\nrangey = ymax - ymin\n\ntransformation_matrix = [[0,-1],[1,0]]\n\ndef setup():\n    global xscl, yscl\n    size(600,600)\n    #the scale factors for drawing on the grid:\n    xscl= width/rangex\n    yscl= -height/rangey\n    noFill()\n\ndef draw():\n    global xscl, yscl\n    background(255) #white\n    translate(width/2,height/2)\n    grid(xscl,yscl)\n    strokeWeight(2) #thicker line\n    stroke(0) #black\n    newmatrix = transpose(multmatrix(transformation_matrix,\n                          transpose(fmatrix)))\n    graphPoints(fmatrix)\n    stroke(255,0,0) #red resultant matrix\n    graphPoints(newmatrix)\n\nfmatrix = [[0,0],[1,0],[1,2],[2,2],[2,3],[1,3],[1,4],[3,4],[3,5],[0,5]]\n\ndef multmatrix(a,b):\n    '''Returns the product of\n    matrix a and matrix b'''\n    m = len(a) #number of rows in first matrix\n    n = len(b[0]) #number of columns in second matrix\n    newmatrix = []\n    for i in range(m): #for every row in a\n        row = []\n        #for every column in b\n        for j in range(n):\n            sum1 = 0\n            #for every element in the column\n            for k in range(len(b)):\n                sum1 += a[i][k]*b[k][j]\n            row.append(sum1)\n        newmatrix.append(row)\n    return newmatrix\n\ndef transpose(a):\n    '''Transposes matrix a'''\n    output = []\n    m = len(a)\n    n = len(a[0])\n    #create an n x m matrix\n    for i in range(n):\n        output.append([])\n        for j in range(m):\n            #replace a[i][j] with a[j][i]\n            output[i].append(a[j][i])\n    return output\n\ndef graphPoints(matrix):\n    #draw line segments between consecutive points\n    beginShape()\n    for pt in matrix:\n        vertex(pt[0]*xscl,pt[1]*yscl)\n    endShape(CLOSE)\n\ndef grid(xscl, yscl):\n    '''Draws a grid for graphing'''\n    #cyan lines\n    strokeWeight(1)\n    stroke(0,255,255)\n    for i in range(xmin,xmax + 1):\n        line(i*xscl,ymin*yscl,i*xscl,ymax*yscl)\n    for i in range(ymin,ymax+1):\n        line(xmin*xscl,i*yscl,xmax*xscl,i*yscl)\n    stroke(0) #black axes\n    line(0,ymin*yscl,0,ymax*yscl)\n    line(xmin*xscl,0,xmax*xscl,0)\n```", "```py\ndef draw():\n    global xscl, yscl\n    background(255) #white\n    translate(width/2,height/2)\n    grid(xscl, yscl)\n    ang = map(mouseX,0,width,0,TWO_PI)\n    rot_matrix = [[cos(ang),-sin(ang)],\n                [sin(ang),cos(ang)]]\n    newmatrix = transpose(multmatrix(rot_matrix,transpose(fmatrix)))\n    graphPoints(fmatrix)\n    strokeWeight(2) #thicker line\n    stroke(255,0,0) #red resultant matrix\n    graphPoints(newmatrix)\n```", "```py\nfmatrix = [[0,0,0],[1,0,0],[1,2,0],[2,2,0],[2,3,0],[1,3,0],[1,4,0],\n          [3,4,0],[3,5,0],[0,5,0],\n          [0,0,1],[1,0,1],[1,2,1],[2,2,1],[2,3,1],[1,3,1],[1,4,1],\n          [3,4,1],[3,5,1],[0,5,1]]\n```", "```py\n#list of points to connect:\nedges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],\n        [7,8],[8,9],[9,0],\n        [10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],\n        [17,18],[18,19],[19,10],\n        [0,10],[1,11],[2,12],[3,13],[4,14],[5,15],[6,16],[7,17],\n        [8,18],[9,19]]\n```", "```py\ndef graphPoints(pointList,edges):\n    '''Graphs the points in a list using segments'''\n    for e in edges:\n        line(pointList[e[0]][0]*xscl,pointList[e[0]][1]*yscl,\n            pointList[e[1]][0]*xscl,pointList[e[1]][1]*yscl)\n```", "```py\npointList[e[0]][0]*xscl\n```", "```py\npointList[e[0]][1]*yscl\n```", "```py\n    rot = map(mouseX,0,width,0,TWO_PI)\n    tilt = map(mouseY,0,height,0,TWO_PI)\n```", "```py\ndef rottilt(rot,tilt):\n    #returns the matrix for rotating a number of degrees\n    rotmatrix_Y = [[cos(rot),0.0,sin(rot)],\n                   [0.0,1.0,0.0],\n                   [-sin(rot),0.0,cos(rot)]]\n    rotmatrix_X = [[1.0,0.0,0.0],\n                   [0.0,cos(tilt),sin(tilt)],\n                   [0.0,-sin(tilt),cos(tilt)]]\n    return multmatrix(rotmatrix_Y,rotmatrix_X)\n```", "```py\ndef draw():\n    global xscl, yscl\n    background(255) #white\n    translate(width/2,height/2)\n    grid(xscl, yscl)\n    rot = map(mouseX,0,width,0,TWO_PI)\n    tilt = map(mouseY,0,height,0,TWO_PI)\n    newmatrix = transpose(multmatrix(rottilt(rot,tilt),transpose(fmatrix)))\n    strokeWeight(2) #thicker line\n    stroke(255,0,0) #red resultant matrix\n    graphPoints(newmatrix,edges)\n```", "```py\n*matrices3D.pyde*\n#set the range of x-values\nxmin = -5\nxmax = 5\n\n#range of y-values\nymin = -5\nymax = 5\n\n#calculate the range\nrangex = xmax - xmin\nrangey = ymax - ymin\n\ndef setup():\n    global xscl, yscl\n    size(600,600)\n    #the scale factors for drawing on the grid:\n    xscl= width/rangex\n    yscl= -height/rangey\n    noFill()\n\ndef draw():\n    global xscl, yscl\n    background(0) #black\n    translate(width/2,height/2)\n    rot = map(mouseX,0,width,0,TWO_PI)\n    tilt = map(mouseY,0,height,0,TWO_PI)\n    strokeWeight(2) #thicker line\n    stroke(0) #black\n    newmatrix = transpose(multmatrix(rottilt(rot,tilt),transpose(fmatrix)))\n #graphPoints(fmatrix)\n    stroke(255,0,0) #red resultant matrix\n    graphPoints(newmatrix,edges)\n\nfmatrix = [[0,0,0],[1,0,0],[1,2,0],[2,2,0],[2,3,0],[1,3,0],[1,4,0],\n          [3,4,0],[3,5,0],[0,5,0],\n          [0,0,1],[1,0,1],[1,2,1],[2,2,1],[2,3,1],[1,3,1],[1,4,1],\n          [3,4,1],[3,5,1],[0,5,1]]\n\n#list of points to connect:\nedges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],\n        [7,8],[8,9],[9,0],\n        [10,11],[11,12],[12,13],[13,14],[14,15],[15,16],[16,17],\n        [17,18],[18,19],[19,10],\n        [0,10],[1,11],[2,12],[3,13],[4,14],[5,15],[6,16],[7,17],\n        [8,18],[9,19]]\n\ndef rottilt(rot,tilt):\n    #returns the matrix for rotating a number of degrees\n    rotmatrix_Y = [[cos(rot),0.0,sin(rot)],\n                   [0.0,1.0,0.0],\n                   [-sin(rot),0.0,cos(rot)]]\n    rotmatrix_X = [[1.0,0.0,0.0],\n                   [0.0,cos(tilt),sin(tilt)],\n                   [0.0,-sin(tilt),cos(tilt)]]\n    return multmatrix(rotmatrix_Y,rotmatrix_X)\n\ndef multmatrix(a,b):\n    '''Returns the product of\n    matrix a and matrix b'''\n    m = len(a) #number of rows in first matrix\n    n = len(b[0]) #number of columns in second matrix\n    newmatrix = []\n    for i in range(m): #for every row in a\n        row = []\n        #for every column in b\n        for j in range(n):\n            sum1 = 0\n            #for every element in the column\n            for k in range(len(b)):\n                sum1 += a[i][k]*b[k][j]\n            row.append(sum1)\n        newmatrix.append(row)\n    return newmatrix\n\ndef graphPoints(pointList,edges):\n    '''Graphs the points in a list using segments'''\n    for e in edges:\n        line(pointList[e[0]][0]*xscl,pointList[e[0]][1]*yscl,\n             pointList[e[1]][0]*xscl,pointList[e[1]][1]*yscl)\n\ndef transpose(a):\n    '''Transposes matrix a'''\n    output = []\n    m = len(a)\n    n = len(a[0])\n    #create an n x m matrix\n    for i in range(n):\n        output.append([])\n        for j in range(m):\n            #replace a[i][j] with a[j][i]\n            output[i].append(a[j][i])\n    return output\n```", "```py\ndivisor = 2\nrow = [1,2,3,4,5]\nfor i, term in enumerate(row):\n    row[i] = term / divisor\nprint(row)\n```", "```py\n[0.5, 1.0, 1.5, 2.0, 2.5]\n```", "```py\n>>> my_matrix = [[2,-4,6,-8],\n             [-3,6,-9,12]]\n>>> for i in range(len(my_matrix[1])):\n        my_matrix[1][i] += my_matrix[0][i]\n>>> print(my_matrix)\n[[2, -4, 6, -8], [-1, 2, -3, 4]]\n```", "```py\n    for j,row in enumerate(A):\n        #diagonal term to be 1\n        #by dividing row by diagonal term\n        if row[j] != 0: #diagonal term can't be 0\n            divisor = row[j] #diagonal term\n for i, term in enumerate(row):\n                row[i] = term / divisor\n```", "```py\n        for i in range(m):\n            if i != j: #don't do this to row j\n                #calculate the additive inverse\n                addinv = -1*A[i][j]\n           #for every term in the ith row\n           for ind in range(n):\n               #add the corresponding term in the jth row\n               #multiplied by the additive inverse\n               #to the term in the ith row\n               A[i][ind] += addinv*A[j][ind]\n```", "```py\ndef gauss(A):\n    '''Converts a matrix into the identity\n    matrix by Gaussian elimination, with\n the last column containing the solutions\n    for the variables'''\n    m = len(A)\n    n = len(A[0])\n    for j,row in enumerate(A):\n        #diagonal term to be 1\n        #by dividing row by diagonal term\n        if row[j] != 0: #diagonal entry can't be zero\n            divisor = row[j]\n            for i, term in enumerate(row):\n                row[i] = term / divisor\n        #add the other rows to the additive inverse\n        #for every row\n        for i in range(m):\n            if i != j: #don't do it to row j\n                #calculate the additive inverse\n                addinv = -1*A[i][j]\n                #for every term in the ith row\n                for ind in range(n):\n                    #add the corresponding term in the jth row\n                    #multiplied by the additive inverse\n                    #to the term in the ith row\n                    A[i][ind] += addinv*A[j][ind]\n    return A\n#example:\nB = [[2,1,-1,8],\n     [-3,-1,2,-1],\n     [-2,1,2,-3]]\nprint(gauss(B))\n```", "```py\n[[1.0, 0.0, 0.0, 32.0], [0.0, 1.0, 0.0, -17.0], [-0.0, -0.0, 1.0, 39.0]]\n```"]