- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algorithms in History
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/circleart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Most people associate algorithms with computers. This is not unreasonable; computer
    operating systems use many sophisticated algorithms, and programming is well suited
    to implementing all sorts of algorithms precisely. But algorithms are more fundamental
    than the computer architecture we implement them on. As mentioned in Chapter 1,
    the word *algorithm* dates back about a millennium, and algorithms have been described
    in ancient records going back much further than that. Even outside of written
    records, there is abundant evidence for the use of complex algorithms in the ancient
    world—in, for example, their construction methods.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presents several algorithms of antique provenance. They show great
    ingenuity and insight, especially considering that they had to be invented and
    verified without the aid of computers. We start by discussing Russian peasant
    multiplication, a method for arithmetic that, despite the name, might be Egyptian
    and might not actually be associated with peasants. We continue by covering Euclid’s
    algorithm, an important “classic” algorithm for finding greatest common divisors.
    Finally, we cover an algorithm from Japan that generates magic squares.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Russian Peasant Multiplication
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many people remember learning the multiplication table as a particularly painful
    part of their education. Young children ask their parents why learning the multiplication
    table is necessary, and parents usually respond that they can’t multiply without
    knowing it. How wrong they are. *Russian peasant multiplication**(RPM)* is a method
    that enables people to multiply large numbers without knowing most of the multiplication
    table.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: RPM’s origins are unclear. An ancient Egyptian scroll called the Rhind papyrus
    contains a version of this algorithm, and some historians have proposed (mostly
    unconvincing) conjectures about how the method could have spread from ancient
    Egyptian scholars to the peasants of the vast Russian hinterlands. Regardless
    of the details of its history, RPM is an interesting algorithm.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Doing RPM by Hand
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the task of multiplying 89 by 18\. Russian peasant multiplication proceeds
    as follows. First, create two columns next to each other. The first column is
    called the *halving* column and starts with 89\. The second column is the *doubling*
    column and starts with 18 ([Table 2-1](#table2-1)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**[Table 2-1:](#tableanchor2-1)** Halving/Doubling Table, Part 1'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '| **Halving** | **Doubling** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: '| 89 | 18 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: We’ll fill out the halving column first. Each row of the halving column takes
    the previous entry and divides it by 2, ignoring the remainder. For example, 89
    divided by 2 is 44 remainder 1, so we write 44 in the second row of the halving
    column ([Table 2-2](#table2-2)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**[Table 2-2:](#tableanchor2-2)** Halving/Doubling Table, Part 2'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '| **Halving** | **Doubling** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| 89 | 18 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| 44 |  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: We continue dividing by 2 until we reach 1, dropping the remainder every time
    and writing the result in the next row. As we continue, we find that 44 divided
    by 2 is 22, then half of that is 11, then half of that (dropping the remainder)
    is 5, then 2, then 1\. After writing these in the halving column, we have [Table
    2-3](#table2-3).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续除以2，直到达到1，每次都丢弃余数并将结果写入下一行。继续下去，我们发现44除以2是22，然后一半是11，再然后一半（丢掉余数）是5，再然后是2，最后是1。将这些写入减半列后，我们得到了[表2-3](#table2-3)。
- en: '**[Table 2-3:](#tableanchor2-3)** Halving/Doubling Table, Part 3'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-3:](#tableanchor2-3)** 减半/倍增表，第3部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **减半** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 |'
- en: '| 44 |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 44 |  |'
- en: '| 22 |  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 22 |  |'
- en: '| 11 |  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 11 |  |'
- en: '| 5 |  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 5 |  |'
- en: '| 2 |  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 2 |  |'
- en: '| 1 |  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 1 |  |'
- en: We’ve completed the halving column. As the name suggests, each entry in the
    doubling column will be double the previous entry. So since 18 × 2 is 36, 36 is
    the second entry in the doubling column ([Table 2-4](#table2-4)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了减半列。顾名思义，倍增列中的每个条目都将是前一个条目的两倍。所以，由于18 × 2是36，36就是倍增列中的第二个条目（见[表2-4](#table2-4)）。
- en: '**[Table 2-4:](#tableanchor2-4)** Halving/Doubling Table, Part 4'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-4:](#tableanchor2-4)** 减半/倍增表，第4部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **减半** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 |'
- en: '| 44 | 36 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 44 | 36 |'
- en: '| 22 |  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 22 |  |'
- en: '| 11 |  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 11 |  |'
- en: '| 5 |  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 5 |  |'
- en: '| 2 |  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 2 |  |'
- en: '| 1 |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 1 |  |'
- en: 'We continue to add entries to the doubling column by following the same rule:
    just double the previous entry. We do this until the doubling column has as many
    entries as the halving column ([Table 2-5](#table2-5)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续按照相同的规则向倍增列中添加条目：只需将前一个条目乘以2。我们一直这样做，直到倍增列的条目数量与减半列一样多（见[表2-5](#table2-5)）。
- en: '**[Table 2-5:](#tableanchor2-5)** Halving/Doubling Table, Part 5'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-5:](#tableanchor2-5)** 减半/倍增表，第5部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **减半** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 |'
- en: '| 44 | 36 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 44 | 36 |'
- en: '| 22 | 72 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 72 |'
- en: '| 11 | 144 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 144 |'
- en: '| 5 | 288 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 288 |'
- en: '| 2 | 576 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 576 |'
- en: '| 1 | 1,152 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1,152 |'
- en: The next step is to cross out or remove every row in which the halving column
    contains an even number. The result is shown in [Table 2-6](#table2-6).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是划掉或移除减半列中包含偶数的每一行。结果如[表2-6](#table2-6)所示。
- en: '**[Table 2-6:](#tableanchor2-6)** Halving/Doubling Table, Part 6'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-6:](#tableanchor2-6)** 减半/倍增表，第6部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **减半** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 |'
- en: '| 11 | 144 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 144 |'
- en: '| 5 | 288 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 288 |'
- en: '| 1 | 1,152 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1,152 |'
- en: 'The final step is to take the sum of the remaining entries in the doubling
    column. The result is 18 + 144 + 288 + 1,152 = 1,602\. You can check with a calculator
    that this is correct: 89 × 18 = 1,602\. We have accomplished multiplication through
    halving, doubling, and addition, all without needing to memorize most of the tedious
    multiplication table that young children so despise.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将倍增列中剩下的条目求和。结果是18 + 144 + 288 + 1,152 = 1,602。你可以用计算器验证这是正确的：89 × 18 =
    1,602。通过减半、倍增和加法，我们完成了乘法运算，而无需记忆大多数年轻孩子所讨厌的繁琐乘法表。
- en: To see why this method works, try rewriting the doubling column in terms of
    18, the number we are trying to multiply ([Table 2-7](#table2-7)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这种方法为什么有效，试着将倍增列用18来表示，即我们要乘的数字（见[表2-7](#table2-7)）。
- en: '**[Table 2-7:](#tableanchor2-7)** Halving/Doubling Table, Part 7'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-7:](#tableanchor2-7)** 减半/倍增表，第7部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **减半** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 × 1 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 × 1 |'
- en: '| 44 | 18 × 2 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 44 | 18 × 2 |'
- en: '| 22 | 18 × 4 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 18 × 4 |'
- en: '| 11 | 18 × 8 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 18 × 8 |'
- en: '| 5 | 18 × 16 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 18 × 16 |'
- en: '| 2 | 18 × 32 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 18 × 32 |'
- en: '| 1 | 18 × 64 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 18 × 64 |'
- en: 'The doubling column is now written in terms of 1, 2, 4, 8, and so on to 64\.
    These are powers of 2, and we can also write them as 2⁰, 2¹, 2², and so on. When
    we take our final sum (adding together the doubling rows with odd entries in the
    halving column), we’re really finding this sum:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在倍增列已经用1、2、4、8，依此类推，直到64来表示。这些是2的幂次，我们也可以将它们表示为2⁰、2¹、2²，依此类推。当我们求出最终的和（将倍增列中减半列为奇数的行相加），实际上我们是在求这个和：
- en: '![c02eq001](Images/c02eq001.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![c02eq001](Images/c02eq001.png)'
- en: The fact that RPM works hinges on the fact that
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: RPM工作的关键在于
- en: '![c02eq002](Images/c02eq002.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![c02eq002](Images/c02eq002.png)'
- en: If you look closely enough at the halving column, you can get a sense for why
    the preceding equation is true. We can also write this column in terms of powers
    of 2 ([Table 2-8](#table2-8)). When we do so, it’s easier to start at the lowest
    entry and work upward. Remember that 2⁰ is 1 and 2¹ is 2\. In every row, we multiply
    by 2¹, and in the rows where the halving number is odd, we also add 2⁰. You can
    see the expression start to resemble our equation more and more as you rise through
    the rows. By the time we reach the top of the table, we have an expression that
    simplifies to exactly 2⁶ + 2⁴ + 2³ + 2⁰.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '**[Table 2-8:](#tableanchor2-8)** Halving/Doubling Table, Part 8'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '| **Halving** | **Doubling** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| (2⁵ + 2³ + 2²) × 2¹ + 2⁰ = 2⁶ + 2⁴ + 2³ + 2⁰ | 18 × 2⁰ |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| (2⁴ + 2² + 2¹) × 2¹ = 2⁵ + 2³ + 2² | 18 × 2¹ |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| (2³ + 2¹ + 2⁰) × 2¹ = 2⁴ + 2² + 2¹ | 18 × 2² |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| (2² + 2⁰) × 2¹ + 2⁰ = 2³ + 2¹ + 2⁰ | 18 × 2³ |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| 2¹ × 2¹ + 2⁰ = 2² + 2⁰ | 18 × 2⁴ |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| 2⁰ × 2¹ = 2¹ | 18 × 2⁵ |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| 2⁰ | 18 × 2⁶ |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: 'If you number the rows of the halving column starting with the top row as row
    0, then 1, 2, and all the way to the bottom row as row 6, you can see that the
    rows with odd values in the halving column are rows 0, 3, 4, and 6\. Now notice
    the crucial pattern: those row numbers are exactly the exponents in the expression
    for 89 that we found: 2⁶ + 2⁴ + 2³ + 2⁰. This is not a coincidence; the way we
    constructed the halving column means that the odd entries will always have row
    numbers that are the exponents in a sum of powers of 2 equaling our original number.
    When we take a sum of the doubling entries with those indices, we’re summing up
    18 multiplied by powers of 2 that sum to exactly 89, so we’ll get 89 × 18 as our
    result.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The reason this works is that really, RPM is an algorithm within an algorithm.
    The halving column itself is an implementation of an algorithm that finds the
    sum of powers of 2 that equals the number at the top of the column. This sum of
    powers of 2 is also called the *binary expansion* of 89\. Binary is an alternative
    way to write numbers using only 0s and 1s, and it has become extremely important
    in recent decades because computers store information in binary. We can write
    89 in binary as 1011001, with 1s in the zeroth, third, fourth, and sixth places
    (counting from the right), the same as the odd rows of the halving column, and
    also the same as the exponents in our equation. We can interpret the 1s and 0s
    in a binary representation as coefficients in a sum of powers of 2\. For example,
    if we write 100, we interpret it in binary as
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 1 × 2² + 0 × 2¹ + 0 × 2⁰
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: or what we would usually write as 4\. If we write 1001, we interpret it in binary
    as
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 1 × 2³ + 0 ×2² + 0 × 2¹ + 1 × 2⁰
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: or what we would usually write as 9\. After running this mini-algorithm to get
    the binary expansion of 89, we are poised to easily run the full algorithm and
    complete the multiplication process.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Implementing RPM in Python
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s relatively simple to implement RPM in Python. Let’s say that we want to
    multiply two numbers that we will call *n*[1] and *n*[2]. First, let’s open a
    Python script and define these variables:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中实现RPM相对简单。假设我们要乘以两个数字，我们称之为*n*[1]和*n*[2]。首先，让我们打开一个Python脚本并定义这些变量：
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we’ll start our halving column. Just as described, the halving column
    begins with one of the numbers we want to multiply:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始创建除法列。正如之前所描述的，除法列以我们想要相乘的一个数字开始：
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next entry will be `halving[0]/2`, ignoring the remainder. In Python, we
    can use the `math.floor()` function to accomplish this. This function just takes
    the closest integer less than a given number. For example, the second row of the
    halving column can be calculated as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个条目将是`halving[0]/2`，忽略余数。在Python中，我们可以使用`math.floor()`函数来实现这一点。这个函数返回一个小于给定数字的最接近整数。例如，除法列的第二行可以按如下方式计算：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you run this in Python, you’ll see that the answer is 44.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Python中运行这个，你将看到答案是44。
- en: 'We can loop through each row of the halving column, and in each iteration of
    our loop, we will find the next entry in the halving column in the same way, stopping
    when we reach 1:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历每一行除法列，在每次循环迭代中，我们将以相同的方式找到除法列中的下一个条目，直到达到1为止：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This loop uses the `append()` method for concatenation. At each iteration of
    the `while` loop, it concatenates the `halving` vector with half of its last value,
    using the `math.floor()` function to ignore the remainder.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环使用`append()`方法进行连接。在每次`while`循环的迭代中，它将`halving`向量与其最后一个值的一半连接，使用`math.floor()`函数忽略余数。
- en: 'For the doubling column, we can do the same: start with 18, and then continue
    through a loop. In each iteration of the loop, we’ll add double the previous entry
    to the doubling column, and we’ll stop after this column is the same length as
    the halving column:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于倍增列，我们可以做同样的操作：从18开始，然后通过一个循环继续。在每次循环中，我们将把前一个条目的两倍加到倍增列中，直到该列与除法列的长度相同为止：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, let’s put these two columns together in a dataframe called `half_double`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们把这两列合并到一个名为`half_double`的数据框中：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We imported the Python module called `pandas` here. This module enables us to
    work with tables easily. In this case, we used the `zip` command, which, as suggested
    by its name, joins `halving` and `doubling` together like a zipper joins two sides
    of a garment together. The two sets of numbers, `halving` and `doubling`, start
    as independent lists, and after being zipped together and converted into a `pandas`
    dataframe, are stored in a table as two aligned columns, as shown in [Table 2-5](#table2-5).
    Since they’re aligned and zipped together, we can refer to any row of [Table 2-5](#table2-5),
    such as the third row, and get the full row, including the elements from both
    `halving` and `doubling` (22 and 72). Being able to refer to and work with these
    rows will make it easy to remove the rows we don’t want, like we did to [Table
    2-5](#table2-5) to convert it to [Table 2-6](#table2-6).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里导入了一个名为`pandas`的Python模块。这个模块使我们能够轻松地处理表格。在这种情况下，我们使用了`zip`命令，顾名思义，它像拉链一样将`halving`和`doubling`连接在一起。两个数字集合，`halving`和`doubling`，开始时是独立的列表，在被“拉链”连接并转换成一个`pandas`数据框后，作为两列对齐的数据存储在表格中，如[表2-5](#table2-5)所示。由于它们已经对齐并被拉链连接，我们可以引用[表2-5](#table2-5)的任何一行，例如第三行，并获取该行的完整数据，包括`halving`和`doubling`中的元素（22和72）。能够引用和处理这些行将使我们能够轻松删除不需要的行，正如我们对[表2-5](#table2-5)所做的那样，将其转换为[表2-6](#table2-6)。
- en: 'Now we need to remove the rows whose entries in the halving column are even.
    We can test for evenness using the `%` (modulo) operator in Python, which returns
    a remainder after division. If a number *`x`* is odd, then `x%2` will be 1\. The
    following line will keep only the rows of the table whose entry in the halving
    column is odd:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要删除除法列中条目为偶数的行。我们可以使用Python中的`%`（取模）运算符来测试偶性，它会在除法后返回余数。如果一个数字*`x`*是奇数，那么`x%2`将是1。以下代码行将只保留除法列中条目为奇数的行：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, we use the `loc` functionality in the `pandas` module to select
    only the rows we want. When we use `loc`, we specify which rows and columns we
    want to select in the square brackets (`[]`) that follow it. Inside the square
    brackets, we specify which rows and columns we want in order, separated by a comma:
    the format is `[``row``,` `column``]`. For example, if we wanted the row with
    index 4 and the column with index 1, we could write `half_double.loc[4,1]`. In
    this case, we will do more than just specify indices. We will express a logical
    pattern for which rows we want: we want all rows where `halving` is odd. We specify
    the `halving` column in our logic with `half_double[0]`, since it’s the column
    with index 0\. We specify oddness with `%2 == 1`. Finally, we specify that we
    want all columns after the comma by writing a colon, which is a shortcut indicating
    that we want every column.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`pandas`模块中的`loc`功能来选择我们想要的行。当我们使用`loc`时，我们需要在其后面的方括号（`[]`）中指定我们要选择的行和列。在方括号内，我们按顺序指定我们想要的行和列，并用逗号隔开：格式是[`行`,`列`]。例如，如果我们想要索引为4的行和索引为1的列，我们可以写`half_double.loc[4,1]`。在这种情况下，我们不仅仅指定索引。我们将表达一个逻辑模式来选择我们想要的行：我们希望所有`halving`列为奇数的行。我们通过`half_double[0]`指定`halving`列，因为它是索引为0的列。我们通过`%2
    == 1`指定奇数性。最后，我们通过写冒号来指定我们想要所有列，冒号是一个快捷方式，表示我们想要每一列。
- en: 'Finally, we simply take the sum of the remaining doubling entries:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简单地计算剩余的倍增项之和：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are using `loc` again. We specify inside the square brackets that we
    want every row by using the colon shortcut. We specify that we want `doubling`,
    the column with index 1, after the comma. Note that the 89 × 18 example we worked
    through could be done more quickly and easily if we instead calculated 18 × 89—that
    is, if we put 18 in the halving column and 89 in the doubling column. I encourage
    you to try this to see the improvement. In general, RPM is faster if the smaller
    multiplicand is placed in the halving column and the larger one in the doubling
    column.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们再次使用`loc`。我们在方括号中指定使用冒号快捷方式选择每一行。我们在逗号后指定我们想要的`doubling`列，即索引为1的列。请注意，我们之前做的89
    × 18的例子如果改为计算18 × 89会更快更容易——也就是说，如果我们把18放在halving列，把89放在doubling列。我鼓励你试试看，感受一下改进。一般来说，如果较小的乘数放在halving列，较大的放在doubling列，RPM会更快。
- en: To someone who has already memorized the multiplication table, RPM may seem
    pointless. But besides its historical charm, RPM is worth learning for a few reasons.
    First, it shows that even something as dry as multiplying numbers can be done
    in multiple ways and is amenable to creative approaches. Just because you’ve learned
    one algorithm for something doesn’t mean that it’s the only, or the best, algorithm
    for the purpose—keep your mind open to new and potentially better ways of doing
    things.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些已经记住乘法表的人来说，RPM可能显得毫无意义。但除了它的历史魅力外，RPM还是值得学习的，原因有几个。首先，它表明即使像乘法这种枯燥的事情也可以有多种做法，并且可以采取创造性的方法。仅仅因为你学会了一种算法，并不意味着它是唯一的，或者是最好的算法——保持思维开放，去接受新的、可能更好的方法。
- en: RPM may be slow, but it requires less memorization up front because it doesn’t
    require knowledge of most of the multiplication table. Sometimes it can be very
    useful to sacrifice a little speed for the sake of low memory requirements, and
    this speed/memory tradeoff is an important consideration in many situations where
    we’re designing and implementing algorithms.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: RPM可能较慢，但它在前期要求较少的记忆，因为它不需要知道大多数乘法表。为了低内存需求，有时牺牲一点速度是非常有用的，而这种速度/内存的权衡是我们在设计和实现算法时要考虑的一个重要因素。
- en: 'Like many of the best algorithms, RPM also brings into focus relationships
    between apparently disparate ideas. Binary expansions may seem like just a curiosity,
    of interest to transistor engineers but not useful to a layperson or even a professional
    programmer. But RPM shows a deep connection between the binary expansion of a
    number and a convenient way to multiply with only minimal knowledge of the multiplication
    table. This is another reason to always keep learning: you never know when some
    apparently useless factoid may form the basis for a powerful algorithm.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多优秀的算法一样，RPM也将看似不相关的思想之间的关系呈现出来。二进制展开可能看起来只是一个好奇心的产物，对于晶体管工程师来说有兴趣，但对普通人甚至是专业程序员来说没什么用。但RPM展示了数字的二进制展开和一种仅需最少的乘法表知识就能进行乘法的便捷方法之间的深刻联系。这也是为什么要不断学习的另一个原因：你永远不知道什么时候一些看似无用的细节可能成为一个强大算法的基础。
- en: Euclid’s Algorithm
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欧几里得算法
- en: The ancient Greeks gave many gifts to humanity. One of their greatest was theoretical
    geometry, which was rigorously compiled by the great Euclid in his 13 books called
    the *Elements*. Most of Euclid’s mathematical writing is in a theorem/proof style,
    in which a proposition is deduced logically from simpler assumptions. Some of
    his work is also *constructive*, meaning that it provides a method for using simple
    tools to draw or create a useful figure, like a square with a particular area
    or a tangent to a curve. Though the word had not been coined yet, Euclid’s constructive
    methods were algorithms, and some of the ideas behind his algorithms can still
    be useful today.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 古希腊人给人类带来了许多礼物，其中最伟大的之一就是理论几何学，它由伟大的欧几里得在他的13本书《几何原本》中严谨地整理而成。欧几里得的大部分数学著作采用定理/证明的形式，其中一个命题是从更简单的假设中逻辑推导出来的。他的一些工作也是
    *构造性的*，意味着它提供了一种使用简单工具绘制或创建有用图形的方法，比如具有特定面积的正方形或曲线的切线。尽管那个时候这个词还没有被创造出来，欧几里得的构造性方法实际上是算法，他的算法背后的某些思想今天仍然是有用的。
- en: Doing Euclid’s Algorithm by Hand
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动进行欧几里得算法
- en: Euclid’s most famous algorithm is commonly known as *Euclid’s algorithm*, though
    it is only one of many that he wrote about. Euclid’s algorithm is a method for
    finding the greatest common divisor of two numbers. It is simple and elegant and
    takes only a few lines to implement in Python.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得最著名的算法通常被称为 *欧几里得算法*，尽管这只是他所写的众多算法中的一种。欧几里得算法是一种用于求解两个数的最大公约数的方法。它简单而优雅，只需几行代码即可在
    Python 中实现。
- en: 'We begin with two natural (whole) numbers: let’s call them *a* and *b*. Let’s
    say that *a* is larger than *b* (if it’s not, just rename *a* to *b* and rename
    *b* to *a*, and then *a* will be larger). If we divide *a*/*b*, we’ll get an integer
    quotient and an integer remainder. Let’s call the quotient *q*[1], and the remainder
    *c*. We can write this as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从两个自然数（整数）开始：我们将它们叫做 *a* 和 *b*。假设 *a* 大于 *b*（如果不是，直接将 *a* 和 *b* 交换名称，那么 *a*
    就会大于 *b*）。如果我们进行 *a*/*b* 的除法，我们将得到一个整数商和一个整数余数。我们将商记作 *q*[1]，余数记作 *c*。我们可以将其写成如下形式：
- en: '![c02eq003](Images/c02eq003.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![c02eq003](Images/c02eq003.png)'
- en: 'For example, if we say that *a* = 105 and *b* = 33, we find that 105/33 is
    3, remainder 6\. Notice that the remainder *c* will always be smaller than both
    *a* and *b*—that’s how remainders work. The next step of the process is to forget
    about *a*, and focus on *b* and *c*. Just like before, we say that *b* is larger
    than *c*. We then find the quotient and remainder when dividing *b*/*c*. If we
    say that *b*/*c* is *q*[2], with remainder *d*, we can write our result as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们说 *a* = 105 且 *b* = 33，我们会发现 105/33 的商为 3，余数为 6。注意，余数 *c* 总是小于 *a* 和
    *b*——这就是余数的特性。接下来的步骤是忘记 *a*，只关注 *b* 和 *c*。像之前一样，我们假设 *b* 大于 *c*。然后我们找出 *b*/*c*
    的商和余数。如果我们说 *b*/*c* 的商是 *q*[2]，余数是 *d*，我们可以将结果写成如下形式：
- en: '![c02eq004](Images/c02eq004.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![c02eq004](Images/c02eq004.png)'
- en: 'Again, *d* will be smaller than both *b* and *c*, since it’s a remainder. If
    you look at our two equations here, you can start to see a pattern: we’re working
    our way through the alphabet, shifting terms to the left every time. We started
    with *a*, *b*, and *c*, and then we had *b*, *c*, and *d*. You can see this pattern
    continue in our next step, in which we divide *c*/*d*, and call the quotient *q*[3]
    and the remainder *e*.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，*d* 将比 *b* 和 *c* 都小，因为它是余数。如果你看我们这里的两个方程，你可以开始看到一个模式：我们正在按字母表的顺序进行，每次将项移到左边。我们从
    *a*、*b* 和 *c* 开始，然后我们得到了 *b*、*c* 和 *d*。你可以看到这个模式在我们下一步中继续进行，在这一步中我们将 *c*/*d* 相除，并将商记作
    *q*[3]，余数记作 *e*。
- en: '![c02eq005](Images/c02eq005.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![c02eq005](Images/c02eq005.png)'
- en: We can continue this process, proceeding as far as we need through the alphabet,
    until the remainder is equal to zero. Remember that remainders are always smaller
    than the numbers that were divided to get them, so *c* is smaller than *a* and
    *b*, *d* is smaller than *b* and *c*, *e* is smaller than *c* and *d*, and so
    on. This means that at every step, we’re working with smaller and smaller integers,
    so we must eventually get to zero. When we get a zero remainder, we stop the process,
    and we know that the last nonzero remainder is the greatest common divisor. For
    example, if we find that *e* is zero, then *d* is the greatest common divisor
    of our original two numbers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续这个过程，一直执行直到余数为零。记住，余数总是比被除数小，所以 *c* 小于 *a* 和 *b*，*d* 小于 *b* 和 *c*，*e*
    小于 *c* 和 *d*，以此类推。这意味着每一步，我们都在处理越来越小的整数，所以最终我们一定会得到零。当余数为零时，我们停止这个过程，并知道最后一个非零余数就是最大公约数。例如，如果我们发现
    *e* 为零，那么 *d* 就是原始两个数的最大公约数。
- en: Implementing Euclid’s Algorithm in Python
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Python 中实现欧几里得算法
- en: We can implement this algorithm in Python quite easily, as shown in [Listing
    2-1](#listing2-1).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常容易地在 Python 中实现这个算法，如 [Listing 2-1](#listing2-1) 所示。
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Listing 2-1:](#listinganchor2-1) Implementing Euclid’s algorithm using recursion'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 2-1:](#listinganchor2-1) 使用递归实现欧几里得算法'
- en: 'The first thing to notice is that we don’t need any of the *q*[1], *q*[2],
    *q*[3] . . . quotients. We need only the remainders, the successive letters of
    the alphabet. Remainders are easy to get in Python: we can use the `%` operator
    from the previous section. We can write a function that takes the remainder after
    division for any two numbers. If the remainder is zero, then the greatest common
    divisor is the smaller of the two inputs. If the remainder is not zero, we use
    the smaller of the two inputs and the remainder as inputs into the same function.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意的是，我们不需要任何 *q*[1]、*q*[2]、*q*[3] 等商。我们只需要余数，即字母表中的连续字母。在 Python 中，获取余数很容易：我们可以使用上一节的
    `%` 运算符。我们可以编写一个函数，接受两个数字的除法余数。如果余数为零，那么最大公约数就是较小的那个输入。如果余数不为零，我们就使用较小的输入和余数作为输入，递归调用同一个函数。
- en: Notice that this function calls itself if the remainder is nonzero 1. The act
    of a function calling itself is known as *recursion*. Recursion can seem intimidating
    or confusing at first; a function that calls itself may seem paradoxical, like
    a snake that can eat itself or a person trying to fly by pulling on their own
    bootstraps. But don’t be scared. If you’re unfamiliar with recursion, one of the
    best things to do is start with a concrete example, like finding the greatest
    common divisor of 105 and 33, and follow each step of the code as if you are the
    computer. You will see that in this example, recursion is just a concise way to
    express the steps we listed in “Doing Euclid’s Algorithm by Hand” on page 20\.
    There is always a danger with recursion that you create an infinite recursion—that
    a function calls itself, and while calling itself, calls itself again, and nothing
    ever causes the function to end, so it attempts to call itself endlessly, which
    is a problem because we need the program to terminate in order to get the final
    answer. In this case, we can feel safe because at each step we are getting smaller
    and smaller remainders that will eventually go down to zero and enable us to exit
    the function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果余数不为零，函数会调用自身1。函数调用自身的行为称为*递归*。递归刚开始可能会让人感到害怕或困惑；一个调用自身的函数可能看起来像是自相矛盾的，比如一条能够吃掉自己的蛇，或者一个人通过拉自己的靴带来飞行。但不要害怕。如果你不熟悉递归，最好的方法之一是从一个具体的例子入手，比如计算
    105 和 33 的最大公约数，并像计算机一样一步步跟随代码。你会发现，在这个例子中，递归只是以简洁的方式表达我们在《手工做欧几里得算法》一节中列出的步骤。递归有一个危险，就是可能会造成无限递归——函数不断调用自己，在调用自身时又调用自己，永远没有结束的条件，导致函数永无休止地调用自己，这是一个问题，因为我们需要程序终止才能得到最终的答案。在这种情况下，我们可以放心，因为每一步我们得到的余数会越来越小，最终会变为零，从而让我们退出函数。
- en: Euclid’s algorithm is short and sweet and useful. I encourage you to create
    an even more concise implementation of it in Python.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得算法简洁、有效且实用。我鼓励你在 Python 中创建一个更简洁的实现。
- en: Japanese Magic Squares
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日本魔方阵
- en: The history of Japanese mathematics is particularly fascinating. In *A History
    of Japanese Mathematics*, originally published in 1914, the historians David Eugene
    Smith and Yoshio Mikami wrote that Japanese math had historically possessed a
    “genius for taking infinite pains” and “ingenuity in untangling minute knots and
    thousands of them.” On the one hand, mathematics uncovers absolute truths that
    should not vary between times and cultures. On the other hand, the types of problems
    that distinct groups tend to focus on and their idiosyncratic approaches to them,
    not to mention differences in notation and communication, provide great scope
    for noteworthy cultural differences, even in a field as austere as math.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 日本数学史特别引人入胜。在1914年首次出版的《日本数学史》中，历史学家David Eugene Smith和Yoshio Mikami写道，日本数学历来拥有“耐心极致的天赋”和“解开千头万绪的巧妙智慧”。一方面，数学揭示了不受时间和文化影响的绝对真理。另一方面，不同群体倾向于关注的问题类型以及他们独特的解决方式，更不用说符号和沟通方式的差异，都为数学这一严谨的领域提供了广阔的文化差异空间。
- en: Creating the Luo Shu Square in Python
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Python中创建洛书方阵
- en: Japanese mathematicians had a fondness for geometry, and many of their ancient
    manuscripts pose and solve problems related to finding the areas of exotic shapes
    like circles inscribed within ellipses and Japanese hand fans. Another steady
    area of focus for Japanese mathematicians throughout several centuries was the
    study of magic squares.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 日本数学家喜欢几何学，他们的许多古代手稿中提出并解决了与计算一些特殊形状的面积相关的问题，例如椭圆内的圆和日本手扇。另一个长期关注的领域是日本数学家们对魔方阵的研究。
- en: A *magic square* is an array of unique, consecutive natural numbers such that
    all rows, all columns, and both of the main diagonals have the same sum. Magic
    squares can be any size. [Table 2-9](#table2-9) shows an example of a 3×3 magic
    square.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*魔方阵*是一个由独特且连续的自然数组成的矩阵，使得所有的行、所有的列和两个主对角线的和都相等。魔方阵可以是任何大小的。[表2-9](#table2-9)展示了一个3×3魔方阵的例子。'
- en: '**[Table 2-9:](#tableanchor2-9)** The Luo Shu Square'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-9：](#tableanchor2-9)** 洛书方阵'
- en: '| 4 | 9 | 2 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 9 | 2 |'
- en: '| 3 | 5 | 7 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 5 | 7 |'
- en: '| 8 | 1 | 6 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1 | 6 |'
- en: In this square, each row, each column, and both main diagonals sum to 15\. This
    is more than just a random example—it’s the famous *Luo Shu square*. According
    to an ancient Chinese legend, this magic square was first seen inscribed on the
    back of a magical turtle who came out of a river in response to the prayers and
    sacrifices of a suffering people. In addition to the definitional pattern that
    each row, column, and diagonal sums to 15, there are a few other patterns. For
    example, the outer ring of numbers alternates between even and odd numbers, and
    the consecutive numbers 4, 5, and 6 appear in the main diagonal.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方阵中，每一行、每一列和两个主对角线的和都为15。这不仅仅是一个随机的例子——它是著名的*洛书方阵*。根据中国的一个古老传说，这个魔方阵最早出现在一只神奇乌龟的背上，这只乌龟从河里浮现出来，回应一个受苦人民的祈祷和祭祀。除了每行、每列和对角线之和为15的定义模式外，还有一些其他模式。例如，数字的外环交替出现奇数和偶数，且4、5、6这三个连续的数字出现在主对角线上。
- en: The legend of the sudden appearance of this simple but fascinating square as
    a gift from the gods is fitting for the study of algorithms. Algorithms are often
    easy to verify and use, but they can be difficult to design from scratch. Especially
    elegant algorithms, when we have the good luck to invent one, seem revelatory,
    as if they have come out of nowhere as a gift from the gods inscribed on the back
    of a magical turtle. If you doubt this, try to create an 11×11 magic square from
    scratch, or try to discover a general-purpose algorithm for generating new magic
    squares.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个简单却迷人的方阵突然作为神赐的礼物出现的传说，恰如其分地反映了算法的研究。算法通常容易验证和使用，但从零开始设计却非常困难。尤其是那些优雅的算法，当我们有幸发明一个时，常常显得如同启示般，好像它们从无到有，犹如神赐的礼物，刻在神奇乌龟的背上。如果你对此有疑问，可以试着从零开始创建一个11×11的魔方阵，或者尝试发现一个生成新魔方阵的通用算法。
- en: 'Knowledge of this and other magic squares apparently passed from China to Japan
    at least as early as 1673, when a mathematician named Sanenobu published a 20×20
    magic square in Japan. We can create the Luo Shu square in Python with the following
    command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些魔方阵的知识显然至少在1673年通过中国传入日本，当时一位名叫三信信的数学家在日本发表了一个20×20的魔方阵。我们可以用以下命令在Python中创建洛书方阵：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It will come in handy to have a function that verifies whether a given matrix
    is a magic square. The following function does this by verifying the sums across
    all rows, columns, and diagonals and then checking whether they are all the same:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个功能能够验证给定的矩阵是否是一个魔方阵，那将非常方便。以下的函数通过验证所有行、列和对角线的和，然后检查它们是否都相同，来实现这一功能：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implementing Kurushima's Algorithm in Python
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Python中实现Kurushima算法
- en: In the previous sections, we discussed how to perform our algorithms of interest
    “by hand” before providing details of the implementation of the code. In the case
    of Kurushima’s algorithm, we’ll outline the steps and introduce the code simultaneously.
    The reason for this change is the relative complexity of the algorithm, and especially
    the length of the code required to implement it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了如何在“手工”执行算法之前，提供代码实现的详细信息。在Kurushima算法的情况下，我们将同时概述步骤并介绍代码。之所以做出这种改变，是因为该算法的相对复杂性，特别是实现所需的代码长度。
- en: One of the most elegant algorithms for generating magic squares, *Kurushima’s
    algorithm* is named for Kurushima Yoshita, who lived during the Edo period. Kurushima’s
    algorithm works only for magic squares of *odd dimension*, meaning that it works
    for any *n*×*n* square if *n* is an odd number. It begins by filling out the center
    of the square in a way that matches the Luo Shu square. In particular, the central
    five squares are given by the following expressions, with *n* here referring to
    the dimension of the square ([Table 2-10](#table2-10)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 生成魔方阵最优雅的算法之一是*Kurushima算法*，它以江户时代的Kurushima Yoshita命名。Kurushima算法只适用于*奇数维度*的魔方阵，即当*n*是奇数时，适用于任何*n*×*n*的正方形。它首先按照与洛书正方形相匹配的方式填充正方形的中心。特别是，中心的五个方格由以下公式给出，其中*n*是正方形的维度（[表
    2-10](#table2-10)）。
- en: '**[Table 2-10:](#tableanchor2-10)** The Center of Kurushima’s Square'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表 2-10:](#tableanchor2-10)** Kurushima 正方形的中心'
- en: '|  | *n*² |  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  | *n*² |  |'
- en: '| *n* | (*n*² + 1)/2 | *n*² + 1 – *n* |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| *n* | (*n*² + 1)/2 | *n*² + 1 – *n* |'
- en: '|  | 1 |  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  | 1 |  |'
- en: 'Kurushima’s algorithm for generating an *n*×*n* magic square for odd *n* can
    be described simply as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Kurushima算法生成*n*×*n*的魔方阵（当*n*为奇数时）可以简要描述如下：
- en: Fill in the five central squares according to [Table 2-10](#table2-10).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据[表 2-10](#table2-10)填充中心的五个方格。
- en: Beginning with any entry whose value is known, determine the value of an unknown
    neighboring entry by following one of the three rules (described next).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从任何已知值的条目开始，通过遵循接下来介绍的三条规则之一，确定未知相邻条目的值。
- en: Repeat step 2 until every entry in the full magic square is filled in.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 2，直到填满整个魔方阵。
- en: Filling in the Central Squares
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 填充中心方格
- en: 'We can begin the process of creating a magic square by creating an empty square
    matrix that we’ll fill up. For example, if we want to create a 7×7 matrix, we
    can define `n=7` and then create a matrix with `n` rows and `n` columns:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个空的方形矩阵来开始创建魔方阵的过程，之后再填充它。例如，如果我们想创建一个7×7的矩阵，我们可以定义`n=7`，然后创建一个具有`n`行和`n`列的矩阵：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this case, we don’t know what numbers to put in the square, so we fill it
    entirely with entries equal to `float(''nan'')`. Here, `nan` stands for *not a
    number*, which we can use as a placeholder in Python when we want to fill up a
    list before we know what numbers to use. If we run `print(square)`, we find that
    this matrix by default is filled with `nan` entries:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不知道应该在正方形中放入什么数字，因此我们将其完全填充为`float('nan')`。这里，`nan`代表*不是一个数字*，我们可以在Python中使用它作为占位符，当我们想先填充一个列表，但还不知道要使用哪些数字时。如果我们运行`print(square)`，会发现该矩阵默认填充为`nan`条目：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This square is not too pretty as it is output in the Python console, so we
    can write a function that will print it in a more readable way:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该正方形在Python控制台中输出时并不太美观，我们可以编写一个函数，以更易读的方式打印它：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Don’t worry about the details of the `printsquare()` function, since it’s only
    for pretty printing and not part of our algorithm. We can fill in the central
    five squares with simple commands. First, we can get the indices of the central
    entry as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心`printsquare()`函数的细节，因为它只是为了美观地打印输出，并不是我们算法的一部分。我们可以用简单的命令填充中心的五个方格。首先，我们可以按如下方式获取中心条目的索引：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The central five squares can be populated according to the expressions in [Table
    2-10](#table2-10) as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 中心的五个方格可以根据[表 2-10](#table2-10)中的公式填充，如下所示：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Specifying the Three Rules
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指定三条规则
- en: The purpose of Kurushima’s algorithm is to fill in the rest of the `nan` entries
    according to simple rules. We can specify three simple rules that enable us to
    fill out every other entry, no matter how big the magic square is. The first rule
    is expressed in [Figure 2-1](#figure2-1).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure_2-1](Images/figure_2-1.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: '[Figure 2-1:](#figureanchor2-1) Rule 1 of Kurushima’s algorithm'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'So for any *x* in the magic square, we can determine the entry that is situated
    in this diagonal relationship to *x* by simply adding *n* and taking the result
    mod *n*² (mod refers to the modulo operation). Of course, we can also go in the
    opposite direction by reversing the operation: subtracting *n* and taking the
    result mod *n*².'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The second rule is even simpler, and is expressed in [Figure 2-2](#figure2-2).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure_2-2](Images/figure_2-2.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: '[Figure 2-2:](#figureanchor2-2) Rule 2 of Kurushima’s algorithm'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'For any *x* in the magic square, the entry below and to the right of *x* is
    1 greater than *x*, mod *n*². This is a simple rule, but it has one important
    exception: this rule is not followed when we cross from the upper-left half of
    the magic square to the lower-right half of the square. Another way to say this
    is that we do not follow the second rule if we are crossing the magic square’s
    *antidiagonal*, the bottom-left-to-top-right line shown in [Figure 2-3](#figure2-3).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure_2-3](Images/figure_2-3.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: '[Figure 2-3:](#figureanchor2-3) The antidiagonal of a square matrix'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: You can see the cells that are on the antidiagonal. The antidiagonal line passes
    fully through them. We can follow our normal two rules when we are dealing with
    these cells. We need the exceptional third rule only when starting in a cell that
    is fully above the antidiagonal and crossing to a cell that is fully below it,
    or vice versa. That final rule is expressed in [Figure 2-4](#figure2-4), which
    shows an antidiagonal and two cells that would need to follow this rule when crossing
    it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure_2-4](Images/figure_2-4.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: '[Figure 2-4:](#figureanchor2-4) Rule 3 of Kurushima’s algorithm'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: This rule is followed when we are crossing the antidiagonal. If we cross from
    the bottom right to the top left, we can follow the inverse of this rule, in which
    *x* is transformed to *x* + *n* – 1, mod *n*².
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a simple implementation of Rule 1 in Python by defining a function
    that takes `x` and `n` as its arguments and returns `(x+n)%n**2`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can try this out with the central entry in the Luo Shu square. Remember,
    the Luo Shu square is a 3×3 square matrix, so *n* = 3\. The central entry of the
    Luo Shu square is 5\. The entry below and to the left of this entry is 8, and
    if we have implemented our `rule1()` function correctly we’ll get an 8 when we
    run the following line:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see an `8` in the Python console. Our `rule1()` function seems to
    work as intended. However, we could improve it by enabling it to go “in reverse,”
    determining not only the entry on the bottom left of a given entry, but also the
    entry to the top right (that is, being able to go from 8 to 5 in addition to going
    from 5 to 8). We can make this improvement by adding one more argument to the
    function. We’ll call our new argument `upright`, and it will be a `True`/`False`
    indicator of whether we’re looking for the entry up and to the right of `x`. If
    not, we will by default look for the entry to the bottom left of `x`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In a mathematical expression, Python will interpret `True` as 1 and `False`
    as 0\. If `upright` is `False`, our function will return the same value as before,
    since (–1)⁰ = 1\. If `upright` is `True`, then it will subtract `n` instead of
    adding `n`, which will enable us to go in the other direction. Let’s check whether
    it can determine the entry above and to the right of 1 in the Luo Shu square:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It should print `7`, the correct value in the Luo Shu square.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'For Rule 2, we can create an analogous function. Our Rule 2 function will take
    `x` and `n` as arguments, just like Rule 1\. But Rule 2 is by default finding
    the entry below and to the right of `x`. So we will add an `upleft` argument that
    will be `True` if we want to reverse the rule. The final rule is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can test this on the Luo Shu square, though there are only two pairs of
    entries for which this doesn’t run into the exception to Rule 2\. For this exception,
    we can write the following function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This rule needs to be followed only when we’re crossing the magic square’s antidiagonal.
    We’ll see later how to determine whether or not we are crossing the antidiagonal.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to fill the five central squares, and we have a rule to
    fill out the remaining squares based on knowledge of those central squares, we
    can fill out the rest of the square.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Filling in the Rest of the Square
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One way to fill in the rest of the square is to “walk” randomly through it,
    using known entries to fill in unknown entries. First, we’ll determine the indices
    of our central entry as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we can randomly select a direction to “walk,” as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we’ve used Python’s `random.choice()` function, which does random selection
    from lists. It takes an element from the set we specified (`where_we_can_go`),
    but it chooses at random (or as close to random as it can get).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'After we’ve decided a direction to travel, we can follow whichever rule corresponds
    to our direction of travel. If we have chosen to go `down_left` or `up_right`,
    we’ll follow Rule 1, choosing the right arguments and indices as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly, we’ll follow Rule 2 if we have chosen to travel `up_left` or `down_right`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code is for going up-left and down-right, but we should follow it only
    if we’re not crossing the antidiagonal. We’ll have to make sure that we follow
    Rule 3 in the case where we are crossing the antidiagonal. There is a simple way
    to know if we are in an entry that is near the antidiagonal: the entries just
    above the antidiagonal will have indices that sum to `n-2`, and the entries just
    below the antidiagonal will have indices that sum to `n`. We’ll want to implement
    Rule 3 in these exceptional cases:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Keep in mind that our magic square is finite, so we cannot, for example, travel
    up/left from the top row or leftmost column. By creating our list of where it’s
    possible to travel based on our current location, we can add some simple logic
    to ensure that we travel only in allowed directions:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have all the elements we need to write Python code that implements Kurushima’s
    algorithm.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can put everything together in a function that takes a starting square with
    some `nan` entries and travels through it using our three rules to fill them in.
    [Listing 2-2](#listing2-2) contains the whole function.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Listing 2-2:](#listinganchor2-2) A function that enables an implementation
    of Kurushima’s algorithm'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'This function will take four arguments: first, a starting square that has some
    `nan` entries; second and third, the indices of the entry that we want to start
    with; and fourth, how much we want to fill up the square (measured by the number
    of `nan` entries we are willing to tolerate). The function consists of a `while`
    loop that writes a number to an entry in the square at every iteration by following
    one of our three rules. It continues until it has as many `nan` entries as we
    have specified in the function’s fourth argument. After it writes to a particular
    entry, it “travels” to that entry by changing its indices 1, and then it repeats
    again.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this function, all that remains is to call it in the right
    way.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Using the Right Arguments
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start with the central entry and fill up the magic square from there.
    For our `howfull` argument, we’ll specify `(n**2)/2-4`. The reason for using this
    value for `howfull` will become clear after we see our results:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this case, we call the `fillsquare()` function using the existing `square`
    variable that we defined previously. Remember we defined it to be full of `nan`
    entries except for five central elements that we specified. After we run the `fillsquare()`
    function with that `square` as its input, the `fillsquare()` function fills in
    many of the remaining entries. Let’s print out the resulting square and see what
    it looks like afterward:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You’ll notice that the `nan`s occupy alternating entries, like a checkerboard.
    The reason for this is that the rules we have for moving diagonally give us access
    to only about half of the total entries, depending on which entry we started with.
    The valid moves are the same as in checkers: a piece that starts on a dark square
    can move diagonally to other dark squares, but its diagonal moving pattern will
    never allow it to move to any of the light squares. The `nan` entries we see are
    inaccessible if we start on the central entry. We specified `(n**2)/2``-``4` for
    our `howfull` argument instead of zero because we know that we wouldn’t be able
    to fill the matrix completely by calling our function only once. But if we start
    again on one of the central entry’s neighbors, we will be able to access the rest
    of the `nan` entries in our “checkerboard.” Let’s call the `fillsquare()` function
    again, this time starting on a different entry and specifying our fourth argument
    as zero, indicating that we want to completely fill our square:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we print our square now, we can see that it is completely full:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There is just one final change we need to make. Because of the rules of the
    `%` operator, our square contains consecutive integers between 0 and 48, but Kurushima’s
    algorithm is meant to fill our square with the integers from 1 to 49\. We can
    add one line that replaces 0 with 49 in our square:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now our square is complete. We can verify that it is indeed a magic square
    by using the `verifysquare()` function we created earlier:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This should return `True`, indicating that we’ve succeeded.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'We just created a 7×7 magic square by following Kurushima’s algorithm. Let’s
    test our code and see if it can create a larger magic square. If we change `n`
    to 11 or any other odd number, we can run exactly the same code and get a magic
    square of any size:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our 11×11 square looks as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can verify, either manually or with our `verifysquare()` function, that this
    is indeed a magic square. You can do the same with any odd `n` and marvel at the
    results.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Magic squares don’t have much practical significance, but it’s fun to observe
    their patterns anyway. If you’re interested, you might spend some time thinking
    about the following questions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Do the larger magic squares we created follow the odd/even alternating pattern
    seen in the outer edge of the Luo Shu square? Do you think every possible magic
    square follows this pattern? What reason, if any, would there be for this pattern?
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you see any other patterns in the magic squares we’ve created that haven’t
    been mentioned yet?
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you find another set of rules that create Kurushima’s squares? For example,
    are there rules that enable one to travel up and down through Kurushima’s square
    instead of diagonally?
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there other types of magic squares that satisfy the definition of a magic
    square but don’t follow Kurushima’s rules at all?
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a more efficient way to write code to implement Kurushima’s algorithm?
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Magic squares occupied the attention of great Japanese mathematicians for several
    centuries, and they’ve found a significant place in cultures around the world.
    We can count ourselves lucky that the great mathematicians of the past gave us
    algorithms for generating and analyzing magic squares that we can easily implement
    on today’s powerful computers. At the same time, we can admire the patience and
    insight that was required for them to investigate magic squares with only pen,
    paper, and their wits (and the occasional magical turtle) to guide them.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 魔方占据了几百年来日本伟大数学家的注意力，并且在世界各地的文化中找到了重要的位置。我们可以认为自己非常幸运，因为过去的伟大数学家为我们提供了生成和分析魔方的算法，我们可以轻松地在今天强大的计算机上实现这些算法。与此同时，我们也可以钦佩他们仅凭纸笔和智慧（偶尔还有神奇的海龟）进行魔方研究所需的耐心和洞察力。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed some historical algorithms that range from a few
    centuries to a few millenia old. Readers who are interested in historical algorithms
    can find many more to study. These algorithms may not be of great practical utility
    today, but it can be worthwhile to study them—first because they give us a sense
    of history, and second because they help broaden our horizons and may provide
    the inspiration for writing our own innovative algorithms.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些历史性的算法，时间跨度从几个世纪到几千年不等。对历史算法感兴趣的读者可以找到更多的算法进行学习。这些算法今天可能没有很大的实际用途，但研究它们是值得的——首先因为它们让我们感受到了历史的气息，其次因为它们帮助我们拓宽视野，并且可能为编写我们自己创新算法提供灵感。
- en: 'The algorithms in the next chapter enable us to do some commonly needed and
    useful tasks with mathematical functions: maximize and minimize them. Now that
    we have discussed algorithms in general and algorithms in history, you should
    be comfortable with what an algorithm is and how one works, and you should be
    ready to dive into serious algorithms used in the most cutting-edge software being
    developed today.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章中的算法使我们能够完成一些常见且有用的数学功能任务：最大化和最小化它们。现在我们已经讨论了算法的概念以及历史中的算法，你应该对什么是算法以及它是如何工作的有了充分的了解，并且准备好深入研究当今最前沿软件中使用的严肃算法。
