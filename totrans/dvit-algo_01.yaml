- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Algorithms in History
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 历史中的算法
- en: '![](Images/circleart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/circleart.png)'
- en: Most people associate algorithms with computers. This is not unreasonable; computer
    operating systems use many sophisticated algorithms, and programming is well suited
    to implementing all sorts of algorithms precisely. But algorithms are more fundamental
    than the computer architecture we implement them on. As mentioned in Chapter 1,
    the word *algorithm* dates back about a millennium, and algorithms have been described
    in ancient records going back much further than that. Even outside of written
    records, there is abundant evidence for the use of complex algorithms in the ancient
    world—in, for example, their construction methods.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人将算法与计算机联系在一起。这并不无道理；计算机操作系统使用许多复杂的算法，编程非常适合精确实现各种算法。但算法比我们实现它们的计算机架构更为基础。如第一章所提到的，*算法*这个词可以追溯到大约千年前，而且早期的记录中就已有描述算法的内容。即使在没有文字记录的情况下，也有大量证据表明古代世界使用了复杂的算法——例如在他们的建筑方法中。
- en: This chapter presents several algorithms of antique provenance. They show great
    ingenuity and insight, especially considering that they had to be invented and
    verified without the aid of computers. We start by discussing Russian peasant
    multiplication, a method for arithmetic that, despite the name, might be Egyptian
    and might not actually be associated with peasants. We continue by covering Euclid’s
    algorithm, an important “classic” algorithm for finding greatest common divisors.
    Finally, we cover an algorithm from Japan that generates magic squares.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几种古老的算法。考虑到这些算法必须在没有计算机帮助的情况下被发明和验证，它们展现了极大的巧妙与洞察力。我们首先讨论俄罗斯农民乘法，这是一种算术方法，尽管名字如此，它可能起源于埃及，并且实际上与农民并无直接关联。接着我们介绍欧几里得算法，这是一种经典的“经典”算法，用于求最大公约数。最后，我们介绍一种来自日本的算法，用于生成魔方阵。
- en: Russian Peasant Multiplication
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 俄罗斯农民乘法
- en: Many people remember learning the multiplication table as a particularly painful
    part of their education. Young children ask their parents why learning the multiplication
    table is necessary, and parents usually respond that they can’t multiply without
    knowing it. How wrong they are. *Russian peasant multiplication**(RPM)* is a method
    that enables people to multiply large numbers without knowing most of the multiplication
    table.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人记得学习乘法表是他们教育过程中最痛苦的部分。小孩子会问父母为什么学习乘法表是必要的，父母通常会回答说，如果不懂它就不能进行乘法计算。他们错得很离谱。*俄罗斯农民乘法*（RPM）是一种方法，可以让人们在不熟悉大部分乘法表的情况下进行大数乘法运算。
- en: RPM’s origins are unclear. An ancient Egyptian scroll called the Rhind papyrus
    contains a version of this algorithm, and some historians have proposed (mostly
    unconvincing) conjectures about how the method could have spread from ancient
    Egyptian scholars to the peasants of the vast Russian hinterlands. Regardless
    of the details of its history, RPM is an interesting algorithm.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: RPM的起源尚不明确。一份古埃及卷轴《林德纸草书》包含了这个算法的一种版本，一些历史学家提出了（大多不太令人信服的）猜测，认为该方法可能从古埃及学者传入俄罗斯辽阔的农民中。不管它的历史细节如何，RPM依然是一个有趣的算法。
- en: Doing RPM by Hand
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手工进行RPM
- en: Consider the task of multiplying 89 by 18\. Russian peasant multiplication proceeds
    as follows. First, create two columns next to each other. The first column is
    called the *halving* column and starts with 89\. The second column is the *doubling*
    column and starts with 18 ([Table 2-1](#table2-1)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以89乘以18为例。俄罗斯农民乘法的步骤如下。首先，创建两列并排。第一列称为*除法*列，起始值为89。第二列称为*倍增*列，起始值为18（见[表 2-1](#table2-1)）。
- en: '**[Table 2-1:](#tableanchor2-1)** Halving/Doubling Table, Part 1'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表 2-1:](#tableanchor2-1)** 除法/倍增表，第一部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **除法** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 |'
- en: We’ll fill out the halving column first. Each row of the halving column takes
    the previous entry and divides it by 2, ignoring the remainder. For example, 89
    divided by 2 is 44 remainder 1, so we write 44 in the second row of the halving
    column ([Table 2-2](#table2-2)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先填写除法列。除法列的每一行都将上一行的数值除以2，忽略余数。例如，89除以2为44余1，因此在除法列的第二行填写44（见[表 2-2](#table2-2)）。
- en: '**[Table 2-2:](#tableanchor2-2)** Halving/Doubling Table, Part 2'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表 2-2:](#tableanchor2-2)** 除法/倍增表，第二部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **除法** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 |'
- en: '| 44 |  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 44 |  |'
- en: We continue dividing by 2 until we reach 1, dropping the remainder every time
    and writing the result in the next row. As we continue, we find that 44 divided
    by 2 is 22, then half of that is 11, then half of that (dropping the remainder)
    is 5, then 2, then 1\. After writing these in the halving column, we have [Table
    2-3](#table2-3).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续除以2，直到达到1，每次都丢弃余数并将结果写入下一行。继续下去，我们发现44除以2是22，然后一半是11，再然后一半（丢掉余数）是5，再然后是2，最后是1。将这些写入减半列后，我们得到了[表2-3](#table2-3)。
- en: '**[Table 2-3:](#tableanchor2-3)** Halving/Doubling Table, Part 3'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-3:](#tableanchor2-3)** 减半/倍增表，第3部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **减半** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 |'
- en: '| 44 |  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 44 |  |'
- en: '| 22 |  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 22 |  |'
- en: '| 11 |  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 11 |  |'
- en: '| 5 |  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 5 |  |'
- en: '| 2 |  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 2 |  |'
- en: '| 1 |  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 1 |  |'
- en: We’ve completed the halving column. As the name suggests, each entry in the
    doubling column will be double the previous entry. So since 18 × 2 is 36, 36 is
    the second entry in the doubling column ([Table 2-4](#table2-4)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了减半列。顾名思义，倍增列中的每个条目都将是前一个条目的两倍。所以，由于18 × 2是36，36就是倍增列中的第二个条目（见[表2-4](#table2-4)）。
- en: '**[Table 2-4:](#tableanchor2-4)** Halving/Doubling Table, Part 4'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-4:](#tableanchor2-4)** 减半/倍增表，第4部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **减半** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 |'
- en: '| 44 | 36 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 44 | 36 |'
- en: '| 22 |  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 22 |  |'
- en: '| 11 |  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 11 |  |'
- en: '| 5 |  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 5 |  |'
- en: '| 2 |  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 2 |  |'
- en: '| 1 |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 1 |  |'
- en: 'We continue to add entries to the doubling column by following the same rule:
    just double the previous entry. We do this until the doubling column has as many
    entries as the halving column ([Table 2-5](#table2-5)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续按照相同的规则向倍增列中添加条目：只需将前一个条目乘以2。我们一直这样做，直到倍增列的条目数量与减半列一样多（见[表2-5](#table2-5)）。
- en: '**[Table 2-5:](#tableanchor2-5)** Halving/Doubling Table, Part 5'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-5:](#tableanchor2-5)** 减半/倍增表，第5部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **减半** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 |'
- en: '| 44 | 36 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 44 | 36 |'
- en: '| 22 | 72 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 72 |'
- en: '| 11 | 144 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 144 |'
- en: '| 5 | 288 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 288 |'
- en: '| 2 | 576 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 576 |'
- en: '| 1 | 1,152 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1,152 |'
- en: The next step is to cross out or remove every row in which the halving column
    contains an even number. The result is shown in [Table 2-6](#table2-6).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是划掉或移除减半列中包含偶数的每一行。结果如[表2-6](#table2-6)所示。
- en: '**[Table 2-6:](#tableanchor2-6)** Halving/Doubling Table, Part 6'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-6:](#tableanchor2-6)** 减半/倍增表，第6部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **减半** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 |'
- en: '| 11 | 144 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 144 |'
- en: '| 5 | 288 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 288 |'
- en: '| 1 | 1,152 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1,152 |'
- en: 'The final step is to take the sum of the remaining entries in the doubling
    column. The result is 18 + 144 + 288 + 1,152 = 1,602\. You can check with a calculator
    that this is correct: 89 × 18 = 1,602\. We have accomplished multiplication through
    halving, doubling, and addition, all without needing to memorize most of the tedious
    multiplication table that young children so despise.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将倍增列中剩下的条目求和。结果是18 + 144 + 288 + 1,152 = 1,602。你可以用计算器验证这是正确的：89 × 18 =
    1,602。通过减半、倍增和加法，我们完成了乘法运算，而无需记忆大多数年轻孩子所讨厌的繁琐乘法表。
- en: To see why this method works, try rewriting the doubling column in terms of
    18, the number we are trying to multiply ([Table 2-7](#table2-7)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这种方法为什么有效，试着将倍增列用18来表示，即我们要乘的数字（见[表2-7](#table2-7)）。
- en: '**[Table 2-7:](#tableanchor2-7)** Halving/Doubling Table, Part 7'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-7:](#tableanchor2-7)** 减半/倍增表，第7部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **减半** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 89 | 18 × 1 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 89 | 18 × 1 |'
- en: '| 44 | 18 × 2 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 44 | 18 × 2 |'
- en: '| 22 | 18 × 4 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 18 × 4 |'
- en: '| 11 | 18 × 8 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 18 × 8 |'
- en: '| 5 | 18 × 16 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 18 × 16 |'
- en: '| 2 | 18 × 32 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 18 × 32 |'
- en: '| 1 | 18 × 64 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 18 × 64 |'
- en: 'The doubling column is now written in terms of 1, 2, 4, 8, and so on to 64\.
    These are powers of 2, and we can also write them as 2⁰, 2¹, 2², and so on. When
    we take our final sum (adding together the doubling rows with odd entries in the
    halving column), we’re really finding this sum:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在倍增列已经用1、2、4、8，依此类推，直到64来表示。这些是2的幂次，我们也可以将它们表示为2⁰、2¹、2²，依此类推。当我们求出最终的和（将倍增列中减半列为奇数的行相加），实际上我们是在求这个和：
- en: '![c02eq001](Images/c02eq001.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![c02eq001](Images/c02eq001.png)'
- en: The fact that RPM works hinges on the fact that
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: RPM工作的关键在于
- en: '![c02eq002](Images/c02eq002.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![c02eq002](Images/c02eq002.png)'
- en: If you look closely enough at the halving column, you can get a sense for why
    the preceding equation is true. We can also write this column in terms of powers
    of 2 ([Table 2-8](#table2-8)). When we do so, it’s easier to start at the lowest
    entry and work upward. Remember that 2⁰ is 1 and 2¹ is 2\. In every row, we multiply
    by 2¹, and in the rows where the halving number is odd, we also add 2⁰. You can
    see the expression start to resemble our equation more and more as you rise through
    the rows. By the time we reach the top of the table, we have an expression that
    simplifies to exactly 2⁶ + 2⁴ + 2³ + 2⁰.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察分半列，你就能明白为什么前面的方程成立。我们还可以将此列以2的幂的形式表示（[表2-8](#table2-8)）。这样做时，从最底部的项开始并向上进行计算会更容易。记住2⁰是1，2¹是2。在每一行中，我们都乘以2¹，而在分半数字为奇数的行中，我们还会加上2⁰。随着你向上走，你会看到这个表达式越来越像我们的方程。等到我们到达表格的顶部时，我们得到了一个简化为2⁶
    + 2⁴ + 2³ + 2⁰的表达式。
- en: '**[Table 2-8:](#tableanchor2-8)** Halving/Doubling Table, Part 8'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-8：](#tableanchor2-8)** 分半/倍增表，第8部分'
- en: '| **Halving** | **Doubling** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **分半** | **倍增** |'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| (2⁵ + 2³ + 2²) × 2¹ + 2⁰ = 2⁶ + 2⁴ + 2³ + 2⁰ | 18 × 2⁰ |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| (2⁵ + 2³ + 2²) × 2¹ + 2⁰ = 2⁶ + 2⁴ + 2³ + 2⁰ | 18 × 2⁰ |'
- en: '| (2⁴ + 2² + 2¹) × 2¹ = 2⁵ + 2³ + 2² | 18 × 2¹ |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| (2⁴ + 2² + 2¹) × 2¹ = 2⁵ + 2³ + 2² | 18 × 2¹ |'
- en: '| (2³ + 2¹ + 2⁰) × 2¹ = 2⁴ + 2² + 2¹ | 18 × 2² |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| (2³ + 2¹ + 2⁰) × 2¹ = 2⁴ + 2² + 2¹ | 18 × 2² |'
- en: '| (2² + 2⁰) × 2¹ + 2⁰ = 2³ + 2¹ + 2⁰ | 18 × 2³ |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| (2² + 2⁰) × 2¹ + 2⁰ = 2³ + 2¹ + 2⁰ | 18 × 2³ |'
- en: '| 2¹ × 2¹ + 2⁰ = 2² + 2⁰ | 18 × 2⁴ |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 2¹ × 2¹ + 2⁰ = 2² + 2⁰ | 18 × 2⁴ |'
- en: '| 2⁰ × 2¹ = 2¹ | 18 × 2⁵ |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 2⁰ × 2¹ = 2¹ | 18 × 2⁵ |'
- en: '| 2⁰ | 18 × 2⁶ |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 2⁰ | 18 × 2⁶ |'
- en: 'If you number the rows of the halving column starting with the top row as row
    0, then 1, 2, and all the way to the bottom row as row 6, you can see that the
    rows with odd values in the halving column are rows 0, 3, 4, and 6\. Now notice
    the crucial pattern: those row numbers are exactly the exponents in the expression
    for 89 that we found: 2⁶ + 2⁴ + 2³ + 2⁰. This is not a coincidence; the way we
    constructed the halving column means that the odd entries will always have row
    numbers that are the exponents in a sum of powers of 2 equaling our original number.
    When we take a sum of the doubling entries with those indices, we’re summing up
    18 multiplied by powers of 2 that sum to exactly 89, so we’ll get 89 × 18 as our
    result.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从顶行开始编号分半列的行，从0行开始，然后是1、2，一直到最底行为6行，你可以看到分半列中包含奇数值的行是0、3、4和6行。现在注意到一个关键的模式：这些行号恰好是我们在表达式中找到的89的指数：2⁶
    + 2⁴ + 2³ + 2⁰。这不是巧合；我们构造分半列的方式意味着奇数项的行号总是2的幂和中等于我们原始数字的指数。当我们将这些指数的倍增项加起来时，我们是在求18与2的幂之和，结果正好是89，所以我们的结果将是89
    × 18。
- en: The reason this works is that really, RPM is an algorithm within an algorithm.
    The halving column itself is an implementation of an algorithm that finds the
    sum of powers of 2 that equals the number at the top of the column. This sum of
    powers of 2 is also called the *binary expansion* of 89\. Binary is an alternative
    way to write numbers using only 0s and 1s, and it has become extremely important
    in recent decades because computers store information in binary. We can write
    89 in binary as 1011001, with 1s in the zeroth, third, fourth, and sixth places
    (counting from the right), the same as the odd rows of the halving column, and
    also the same as the exponents in our equation. We can interpret the 1s and 0s
    in a binary representation as coefficients in a sum of powers of 2\. For example,
    if we write 100, we interpret it in binary as
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以有效，是因为实际上，RPM是一个嵌套在另一个算法中的算法。分半列本身是一个算法的实现，用于找到与列顶端数字相等的2的幂的和。这个2的幂的和也叫做*二进制展开*。二进制是一种只使用0和1来表示数字的方式，近年来变得极其重要，因为计算机以二进制方式存储信息。我们可以将89表示为二进制的1011001，其中1出现在第0、3、4和6位（从右向左数），与分半列的奇数行相同，也与我们方程中的指数相同。我们可以将二进制表示中的1和0解释为2的幂和中的系数。例如，如果我们写100，我们将其在二进制中解释为
- en: 1 × 2² + 0 × 2¹ + 0 × 2⁰
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 1 × 2² + 0 × 2¹ + 0 × 2⁰
- en: or what we would usually write as 4\. If we write 1001, we interpret it in binary
    as
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或我们通常写作4。如果我们写1001，我们将其在二进制中解释为
- en: 1 × 2³ + 0 ×2² + 0 × 2¹ + 1 × 2⁰
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 1 × 2³ + 0 × 2² + 0 × 2¹ + 1 × 2⁰
- en: or what we would usually write as 9\. After running this mini-algorithm to get
    the binary expansion of 89, we are poised to easily run the full algorithm and
    complete the multiplication process.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或我们通常写作9。在运行这个小算法得到89的二进制展开后，我们已经准备好轻松地运行完整算法并完成乘法过程。
- en: Implementing RPM in Python
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Python中实现RPM
- en: 'It’s relatively simple to implement RPM in Python. Let’s say that we want to
    multiply two numbers that we will call *n*[1] and *n*[2]. First, let’s open a
    Python script and define these variables:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中实现RPM相对简单。假设我们要乘以两个数字，我们称之为*n*[1]和*n*[2]。首先，让我们打开一个Python脚本并定义这些变量：
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we’ll start our halving column. Just as described, the halving column
    begins with one of the numbers we want to multiply:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始创建除法列。正如之前所描述的，除法列以我们想要相乘的一个数字开始：
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next entry will be `halving[0]/2`, ignoring the remainder. In Python, we
    can use the `math.floor()` function to accomplish this. This function just takes
    the closest integer less than a given number. For example, the second row of the
    halving column can be calculated as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个条目将是`halving[0]/2`，忽略余数。在Python中，我们可以使用`math.floor()`函数来实现这一点。这个函数返回一个小于给定数字的最接近整数。例如，除法列的第二行可以按如下方式计算：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you run this in Python, you’ll see that the answer is 44.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Python中运行这个，你将看到答案是44。
- en: 'We can loop through each row of the halving column, and in each iteration of
    our loop, we will find the next entry in the halving column in the same way, stopping
    when we reach 1:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历每一行除法列，在每次循环迭代中，我们将以相同的方式找到除法列中的下一个条目，直到达到1为止：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This loop uses the `append()` method for concatenation. At each iteration of
    the `while` loop, it concatenates the `halving` vector with half of its last value,
    using the `math.floor()` function to ignore the remainder.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环使用`append()`方法进行连接。在每次`while`循环的迭代中，它将`halving`向量与其最后一个值的一半连接，使用`math.floor()`函数忽略余数。
- en: 'For the doubling column, we can do the same: start with 18, and then continue
    through a loop. In each iteration of the loop, we’ll add double the previous entry
    to the doubling column, and we’ll stop after this column is the same length as
    the halving column:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于倍增列，我们可以做同样的操作：从18开始，然后通过一个循环继续。在每次循环中，我们将把前一个条目的两倍加到倍增列中，直到该列与除法列的长度相同为止：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, let’s put these two columns together in a dataframe called `half_double`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们把这两列合并到一个名为`half_double`的数据框中：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We imported the Python module called `pandas` here. This module enables us to
    work with tables easily. In this case, we used the `zip` command, which, as suggested
    by its name, joins `halving` and `doubling` together like a zipper joins two sides
    of a garment together. The two sets of numbers, `halving` and `doubling`, start
    as independent lists, and after being zipped together and converted into a `pandas`
    dataframe, are stored in a table as two aligned columns, as shown in [Table 2-5](#table2-5).
    Since they’re aligned and zipped together, we can refer to any row of [Table 2-5](#table2-5),
    such as the third row, and get the full row, including the elements from both
    `halving` and `doubling` (22 and 72). Being able to refer to and work with these
    rows will make it easy to remove the rows we don’t want, like we did to [Table
    2-5](#table2-5) to convert it to [Table 2-6](#table2-6).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里导入了一个名为`pandas`的Python模块。这个模块使我们能够轻松地处理表格。在这种情况下，我们使用了`zip`命令，顾名思义，它像拉链一样将`halving`和`doubling`连接在一起。两个数字集合，`halving`和`doubling`，开始时是独立的列表，在被“拉链”连接并转换成一个`pandas`数据框后，作为两列对齐的数据存储在表格中，如[表2-5](#table2-5)所示。由于它们已经对齐并被拉链连接，我们可以引用[表2-5](#table2-5)的任何一行，例如第三行，并获取该行的完整数据，包括`halving`和`doubling`中的元素（22和72）。能够引用和处理这些行将使我们能够轻松删除不需要的行，正如我们对[表2-5](#table2-5)所做的那样，将其转换为[表2-6](#table2-6)。
- en: 'Now we need to remove the rows whose entries in the halving column are even.
    We can test for evenness using the `%` (modulo) operator in Python, which returns
    a remainder after division. If a number *`x`* is odd, then `x%2` will be 1\. The
    following line will keep only the rows of the table whose entry in the halving
    column is odd:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要删除除法列中条目为偶数的行。我们可以使用Python中的`%`（取模）运算符来测试偶性，它会在除法后返回余数。如果一个数字*`x`*是奇数，那么`x%2`将是1。以下代码行将只保留除法列中条目为奇数的行：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, we use the `loc` functionality in the `pandas` module to select
    only the rows we want. When we use `loc`, we specify which rows and columns we
    want to select in the square brackets (`[]`) that follow it. Inside the square
    brackets, we specify which rows and columns we want in order, separated by a comma:
    the format is `[``row``,` `column``]`. For example, if we wanted the row with
    index 4 and the column with index 1, we could write `half_double.loc[4,1]`. In
    this case, we will do more than just specify indices. We will express a logical
    pattern for which rows we want: we want all rows where `halving` is odd. We specify
    the `halving` column in our logic with `half_double[0]`, since it’s the column
    with index 0\. We specify oddness with `%2 == 1`. Finally, we specify that we
    want all columns after the comma by writing a colon, which is a shortcut indicating
    that we want every column.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`pandas`模块中的`loc`功能来选择我们想要的行。当我们使用`loc`时，我们需要在其后面的方括号（`[]`）中指定我们要选择的行和列。在方括号内，我们按顺序指定我们想要的行和列，并用逗号隔开：格式是[`行`,`列`]。例如，如果我们想要索引为4的行和索引为1的列，我们可以写`half_double.loc[4,1]`。在这种情况下，我们不仅仅指定索引。我们将表达一个逻辑模式来选择我们想要的行：我们希望所有`halving`列为奇数的行。我们通过`half_double[0]`指定`halving`列，因为它是索引为0的列。我们通过`%2
    == 1`指定奇数性。最后，我们通过写冒号来指定我们想要所有列，冒号是一个快捷方式，表示我们想要每一列。
- en: 'Finally, we simply take the sum of the remaining doubling entries:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简单地计算剩余的倍增项之和：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are using `loc` again. We specify inside the square brackets that we
    want every row by using the colon shortcut. We specify that we want `doubling`,
    the column with index 1, after the comma. Note that the 89 × 18 example we worked
    through could be done more quickly and easily if we instead calculated 18 × 89—that
    is, if we put 18 in the halving column and 89 in the doubling column. I encourage
    you to try this to see the improvement. In general, RPM is faster if the smaller
    multiplicand is placed in the halving column and the larger one in the doubling
    column.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们再次使用`loc`。我们在方括号中指定使用冒号快捷方式选择每一行。我们在逗号后指定我们想要的`doubling`列，即索引为1的列。请注意，我们之前做的89
    × 18的例子如果改为计算18 × 89会更快更容易——也就是说，如果我们把18放在halving列，把89放在doubling列。我鼓励你试试看，感受一下改进。一般来说，如果较小的乘数放在halving列，较大的放在doubling列，RPM会更快。
- en: To someone who has already memorized the multiplication table, RPM may seem
    pointless. But besides its historical charm, RPM is worth learning for a few reasons.
    First, it shows that even something as dry as multiplying numbers can be done
    in multiple ways and is amenable to creative approaches. Just because you’ve learned
    one algorithm for something doesn’t mean that it’s the only, or the best, algorithm
    for the purpose—keep your mind open to new and potentially better ways of doing
    things.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些已经记住乘法表的人来说，RPM可能显得毫无意义。但除了它的历史魅力外，RPM还是值得学习的，原因有几个。首先，它表明即使像乘法这种枯燥的事情也可以有多种做法，并且可以采取创造性的方法。仅仅因为你学会了一种算法，并不意味着它是唯一的，或者是最好的算法——保持思维开放，去接受新的、可能更好的方法。
- en: RPM may be slow, but it requires less memorization up front because it doesn’t
    require knowledge of most of the multiplication table. Sometimes it can be very
    useful to sacrifice a little speed for the sake of low memory requirements, and
    this speed/memory tradeoff is an important consideration in many situations where
    we’re designing and implementing algorithms.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: RPM可能较慢，但它在前期要求较少的记忆，因为它不需要知道大多数乘法表。为了低内存需求，有时牺牲一点速度是非常有用的，而这种速度/内存的权衡是我们在设计和实现算法时要考虑的一个重要因素。
- en: 'Like many of the best algorithms, RPM also brings into focus relationships
    between apparently disparate ideas. Binary expansions may seem like just a curiosity,
    of interest to transistor engineers but not useful to a layperson or even a professional
    programmer. But RPM shows a deep connection between the binary expansion of a
    number and a convenient way to multiply with only minimal knowledge of the multiplication
    table. This is another reason to always keep learning: you never know when some
    apparently useless factoid may form the basis for a powerful algorithm.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多优秀的算法一样，RPM也将看似不相关的思想之间的关系呈现出来。二进制展开可能看起来只是一个好奇心的产物，对于晶体管工程师来说有兴趣，但对普通人甚至是专业程序员来说没什么用。但RPM展示了数字的二进制展开和一种仅需最少的乘法表知识就能进行乘法的便捷方法之间的深刻联系。这也是为什么要不断学习的另一个原因：你永远不知道什么时候一些看似无用的细节可能成为一个强大算法的基础。
- en: Euclid’s Algorithm
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欧几里得算法
- en: The ancient Greeks gave many gifts to humanity. One of their greatest was theoretical
    geometry, which was rigorously compiled by the great Euclid in his 13 books called
    the *Elements*. Most of Euclid’s mathematical writing is in a theorem/proof style,
    in which a proposition is deduced logically from simpler assumptions. Some of
    his work is also *constructive*, meaning that it provides a method for using simple
    tools to draw or create a useful figure, like a square with a particular area
    or a tangent to a curve. Though the word had not been coined yet, Euclid’s constructive
    methods were algorithms, and some of the ideas behind his algorithms can still
    be useful today.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 古希腊人给人类带来了许多礼物，其中最伟大的之一就是理论几何学，它由伟大的欧几里得在他的13本书《几何原本》中严谨地整理而成。欧几里得的大部分数学著作采用定理/证明的形式，其中一个命题是从更简单的假设中逻辑推导出来的。他的一些工作也是
    *构造性的*，意味着它提供了一种使用简单工具绘制或创建有用图形的方法，比如具有特定面积的正方形或曲线的切线。尽管那个时候这个词还没有被创造出来，欧几里得的构造性方法实际上是算法，他的算法背后的某些思想今天仍然是有用的。
- en: Doing Euclid’s Algorithm by Hand
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动进行欧几里得算法
- en: Euclid’s most famous algorithm is commonly known as *Euclid’s algorithm*, though
    it is only one of many that he wrote about. Euclid’s algorithm is a method for
    finding the greatest common divisor of two numbers. It is simple and elegant and
    takes only a few lines to implement in Python.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得最著名的算法通常被称为 *欧几里得算法*，尽管这只是他所写的众多算法中的一种。欧几里得算法是一种用于求解两个数的最大公约数的方法。它简单而优雅，只需几行代码即可在
    Python 中实现。
- en: 'We begin with two natural (whole) numbers: let’s call them *a* and *b*. Let’s
    say that *a* is larger than *b* (if it’s not, just rename *a* to *b* and rename
    *b* to *a*, and then *a* will be larger). If we divide *a*/*b*, we’ll get an integer
    quotient and an integer remainder. Let’s call the quotient *q*[1], and the remainder
    *c*. We can write this as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从两个自然数（整数）开始：我们将它们叫做 *a* 和 *b*。假设 *a* 大于 *b*（如果不是，直接将 *a* 和 *b* 交换名称，那么 *a*
    就会大于 *b*）。如果我们进行 *a*/*b* 的除法，我们将得到一个整数商和一个整数余数。我们将商记作 *q*[1]，余数记作 *c*。我们可以将其写成如下形式：
- en: '![c02eq003](Images/c02eq003.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![c02eq003](Images/c02eq003.png)'
- en: 'For example, if we say that *a* = 105 and *b* = 33, we find that 105/33 is
    3, remainder 6\. Notice that the remainder *c* will always be smaller than both
    *a* and *b*—that’s how remainders work. The next step of the process is to forget
    about *a*, and focus on *b* and *c*. Just like before, we say that *b* is larger
    than *c*. We then find the quotient and remainder when dividing *b*/*c*. If we
    say that *b*/*c* is *q*[2], with remainder *d*, we can write our result as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们说 *a* = 105 且 *b* = 33，我们会发现 105/33 的商为 3，余数为 6。注意，余数 *c* 总是小于 *a* 和
    *b*——这就是余数的特性。接下来的步骤是忘记 *a*，只关注 *b* 和 *c*。像之前一样，我们假设 *b* 大于 *c*。然后我们找出 *b*/*c*
    的商和余数。如果我们说 *b*/*c* 的商是 *q*[2]，余数是 *d*，我们可以将结果写成如下形式：
- en: '![c02eq004](Images/c02eq004.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![c02eq004](Images/c02eq004.png)'
- en: 'Again, *d* will be smaller than both *b* and *c*, since it’s a remainder. If
    you look at our two equations here, you can start to see a pattern: we’re working
    our way through the alphabet, shifting terms to the left every time. We started
    with *a*, *b*, and *c*, and then we had *b*, *c*, and *d*. You can see this pattern
    continue in our next step, in which we divide *c*/*d*, and call the quotient *q*[3]
    and the remainder *e*.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，*d* 将比 *b* 和 *c* 都小，因为它是余数。如果你看我们这里的两个方程，你可以开始看到一个模式：我们正在按字母表的顺序进行，每次将项移到左边。我们从
    *a*、*b* 和 *c* 开始，然后我们得到了 *b*、*c* 和 *d*。你可以看到这个模式在我们下一步中继续进行，在这一步中我们将 *c*/*d* 相除，并将商记作
    *q*[3]，余数记作 *e*。
- en: '![c02eq005](Images/c02eq005.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![c02eq005](Images/c02eq005.png)'
- en: We can continue this process, proceeding as far as we need through the alphabet,
    until the remainder is equal to zero. Remember that remainders are always smaller
    than the numbers that were divided to get them, so *c* is smaller than *a* and
    *b*, *d* is smaller than *b* and *c*, *e* is smaller than *c* and *d*, and so
    on. This means that at every step, we’re working with smaller and smaller integers,
    so we must eventually get to zero. When we get a zero remainder, we stop the process,
    and we know that the last nonzero remainder is the greatest common divisor. For
    example, if we find that *e* is zero, then *d* is the greatest common divisor
    of our original two numbers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续这个过程，一直执行直到余数为零。记住，余数总是比被除数小，所以 *c* 小于 *a* 和 *b*，*d* 小于 *b* 和 *c*，*e*
    小于 *c* 和 *d*，以此类推。这意味着每一步，我们都在处理越来越小的整数，所以最终我们一定会得到零。当余数为零时，我们停止这个过程，并知道最后一个非零余数就是最大公约数。例如，如果我们发现
    *e* 为零，那么 *d* 就是原始两个数的最大公约数。
- en: Implementing Euclid’s Algorithm in Python
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Python 中实现欧几里得算法
- en: We can implement this algorithm in Python quite easily, as shown in [Listing
    2-1](#listing2-1).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常容易地在 Python 中实现这个算法，如 [Listing 2-1](#listing2-1) 所示。
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Listing 2-1:](#listinganchor2-1) Implementing Euclid’s algorithm using recursion'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 2-1:](#listinganchor2-1) 使用递归实现欧几里得算法'
- en: 'The first thing to notice is that we don’t need any of the *q*[1], *q*[2],
    *q*[3] . . . quotients. We need only the remainders, the successive letters of
    the alphabet. Remainders are easy to get in Python: we can use the `%` operator
    from the previous section. We can write a function that takes the remainder after
    division for any two numbers. If the remainder is zero, then the greatest common
    divisor is the smaller of the two inputs. If the remainder is not zero, we use
    the smaller of the two inputs and the remainder as inputs into the same function.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意的是，我们不需要任何 *q*[1]、*q*[2]、*q*[3] 等商。我们只需要余数，即字母表中的连续字母。在 Python 中，获取余数很容易：我们可以使用上一节的
    `%` 运算符。我们可以编写一个函数，接受两个数字的除法余数。如果余数为零，那么最大公约数就是较小的那个输入。如果余数不为零，我们就使用较小的输入和余数作为输入，递归调用同一个函数。
- en: Notice that this function calls itself if the remainder is nonzero 1. The act
    of a function calling itself is known as *recursion*. Recursion can seem intimidating
    or confusing at first; a function that calls itself may seem paradoxical, like
    a snake that can eat itself or a person trying to fly by pulling on their own
    bootstraps. But don’t be scared. If you’re unfamiliar with recursion, one of the
    best things to do is start with a concrete example, like finding the greatest
    common divisor of 105 and 33, and follow each step of the code as if you are the
    computer. You will see that in this example, recursion is just a concise way to
    express the steps we listed in “Doing Euclid’s Algorithm by Hand” on page 20\.
    There is always a danger with recursion that you create an infinite recursion—that
    a function calls itself, and while calling itself, calls itself again, and nothing
    ever causes the function to end, so it attempts to call itself endlessly, which
    is a problem because we need the program to terminate in order to get the final
    answer. In this case, we can feel safe because at each step we are getting smaller
    and smaller remainders that will eventually go down to zero and enable us to exit
    the function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果余数不为零，函数会调用自身1。函数调用自身的行为称为*递归*。递归刚开始可能会让人感到害怕或困惑；一个调用自身的函数可能看起来像是自相矛盾的，比如一条能够吃掉自己的蛇，或者一个人通过拉自己的靴带来飞行。但不要害怕。如果你不熟悉递归，最好的方法之一是从一个具体的例子入手，比如计算
    105 和 33 的最大公约数，并像计算机一样一步步跟随代码。你会发现，在这个例子中，递归只是以简洁的方式表达我们在《手工做欧几里得算法》一节中列出的步骤。递归有一个危险，就是可能会造成无限递归——函数不断调用自己，在调用自身时又调用自己，永远没有结束的条件，导致函数永无休止地调用自己，这是一个问题，因为我们需要程序终止才能得到最终的答案。在这种情况下，我们可以放心，因为每一步我们得到的余数会越来越小，最终会变为零，从而让我们退出函数。
- en: Euclid’s algorithm is short and sweet and useful. I encourage you to create
    an even more concise implementation of it in Python.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得算法简洁、有效且实用。我鼓励你在 Python 中创建一个更简洁的实现。
- en: Japanese Magic Squares
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日本魔方阵
- en: The history of Japanese mathematics is particularly fascinating. In *A History
    of Japanese Mathematics*, originally published in 1914, the historians David Eugene
    Smith and Yoshio Mikami wrote that Japanese math had historically possessed a
    “genius for taking infinite pains” and “ingenuity in untangling minute knots and
    thousands of them.” On the one hand, mathematics uncovers absolute truths that
    should not vary between times and cultures. On the other hand, the types of problems
    that distinct groups tend to focus on and their idiosyncratic approaches to them,
    not to mention differences in notation and communication, provide great scope
    for noteworthy cultural differences, even in a field as austere as math.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 日本数学史特别引人入胜。在1914年首次出版的《日本数学史》中，历史学家David Eugene Smith和Yoshio Mikami写道，日本数学历来拥有“耐心极致的天赋”和“解开千头万绪的巧妙智慧”。一方面，数学揭示了不受时间和文化影响的绝对真理。另一方面，不同群体倾向于关注的问题类型以及他们独特的解决方式，更不用说符号和沟通方式的差异，都为数学这一严谨的领域提供了广阔的文化差异空间。
- en: Creating the Luo Shu Square in Python
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Python中创建洛书方阵
- en: Japanese mathematicians had a fondness for geometry, and many of their ancient
    manuscripts pose and solve problems related to finding the areas of exotic shapes
    like circles inscribed within ellipses and Japanese hand fans. Another steady
    area of focus for Japanese mathematicians throughout several centuries was the
    study of magic squares.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 日本数学家喜欢几何学，他们的许多古代手稿中提出并解决了与计算一些特殊形状的面积相关的问题，例如椭圆内的圆和日本手扇。另一个长期关注的领域是日本数学家们对魔方阵的研究。
- en: A *magic square* is an array of unique, consecutive natural numbers such that
    all rows, all columns, and both of the main diagonals have the same sum. Magic
    squares can be any size. [Table 2-9](#table2-9) shows an example of a 3×3 magic
    square.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*魔方阵*是一个由独特且连续的自然数组成的矩阵，使得所有的行、所有的列和两个主对角线的和都相等。魔方阵可以是任何大小的。[表2-9](#table2-9)展示了一个3×3魔方阵的例子。'
- en: '**[Table 2-9:](#tableanchor2-9)** The Luo Shu Square'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表2-9：](#tableanchor2-9)** 洛书方阵'
- en: '| 4 | 9 | 2 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 9 | 2 |'
- en: '| 3 | 5 | 7 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 5 | 7 |'
- en: '| 8 | 1 | 6 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1 | 6 |'
- en: In this square, each row, each column, and both main diagonals sum to 15\. This
    is more than just a random example—it’s the famous *Luo Shu square*. According
    to an ancient Chinese legend, this magic square was first seen inscribed on the
    back of a magical turtle who came out of a river in response to the prayers and
    sacrifices of a suffering people. In addition to the definitional pattern that
    each row, column, and diagonal sums to 15, there are a few other patterns. For
    example, the outer ring of numbers alternates between even and odd numbers, and
    the consecutive numbers 4, 5, and 6 appear in the main diagonal.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方阵中，每一行、每一列和两个主对角线的和都为15。这不仅仅是一个随机的例子——它是著名的*洛书方阵*。根据中国的一个古老传说，这个魔方阵最早出现在一只神奇乌龟的背上，这只乌龟从河里浮现出来，回应一个受苦人民的祈祷和祭祀。除了每行、每列和对角线之和为15的定义模式外，还有一些其他模式。例如，数字的外环交替出现奇数和偶数，且4、5、6这三个连续的数字出现在主对角线上。
- en: The legend of the sudden appearance of this simple but fascinating square as
    a gift from the gods is fitting for the study of algorithms. Algorithms are often
    easy to verify and use, but they can be difficult to design from scratch. Especially
    elegant algorithms, when we have the good luck to invent one, seem revelatory,
    as if they have come out of nowhere as a gift from the gods inscribed on the back
    of a magical turtle. If you doubt this, try to create an 11×11 magic square from
    scratch, or try to discover a general-purpose algorithm for generating new magic
    squares.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个简单却迷人的方阵突然作为神赐的礼物出现的传说，恰如其分地反映了算法的研究。算法通常容易验证和使用，但从零开始设计却非常困难。尤其是那些优雅的算法，当我们有幸发明一个时，常常显得如同启示般，好像它们从无到有，犹如神赐的礼物，刻在神奇乌龟的背上。如果你对此有疑问，可以试着从零开始创建一个11×11的魔方阵，或者尝试发现一个生成新魔方阵的通用算法。
- en: 'Knowledge of this and other magic squares apparently passed from China to Japan
    at least as early as 1673, when a mathematician named Sanenobu published a 20×20
    magic square in Japan. We can create the Luo Shu square in Python with the following
    command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些魔方阵的知识显然至少在1673年通过中国传入日本，当时一位名叫三信信的数学家在日本发表了一个20×20的魔方阵。我们可以用以下命令在Python中创建洛书方阵：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It will come in handy to have a function that verifies whether a given matrix
    is a magic square. The following function does this by verifying the sums across
    all rows, columns, and diagonals and then checking whether they are all the same:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个功能能够验证给定的矩阵是否是一个魔方阵，那将非常方便。以下的函数通过验证所有行、列和对角线的和，然后检查它们是否都相同，来实现这一功能：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implementing Kurushima's Algorithm in Python
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Python中实现Kurushima算法
- en: In the previous sections, we discussed how to perform our algorithms of interest
    “by hand” before providing details of the implementation of the code. In the case
    of Kurushima’s algorithm, we’ll outline the steps and introduce the code simultaneously.
    The reason for this change is the relative complexity of the algorithm, and especially
    the length of the code required to implement it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了如何在“手工”执行算法之前，提供代码实现的详细信息。在Kurushima算法的情况下，我们将同时概述步骤并介绍代码。之所以做出这种改变，是因为该算法的相对复杂性，特别是实现所需的代码长度。
- en: One of the most elegant algorithms for generating magic squares, *Kurushima’s
    algorithm* is named for Kurushima Yoshita, who lived during the Edo period. Kurushima’s
    algorithm works only for magic squares of *odd dimension*, meaning that it works
    for any *n*×*n* square if *n* is an odd number. It begins by filling out the center
    of the square in a way that matches the Luo Shu square. In particular, the central
    five squares are given by the following expressions, with *n* here referring to
    the dimension of the square ([Table 2-10](#table2-10)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 生成魔方阵最优雅的算法之一是*Kurushima算法*，它以江户时代的Kurushima Yoshita命名。Kurushima算法只适用于*奇数维度*的魔方阵，即当*n*是奇数时，适用于任何*n*×*n*的正方形。它首先按照与洛书正方形相匹配的方式填充正方形的中心。特别是，中心的五个方格由以下公式给出，其中*n*是正方形的维度（[表
    2-10](#table2-10)）。
- en: '**[Table 2-10:](#tableanchor2-10)** The Center of Kurushima’s Square'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**[表 2-10:](#tableanchor2-10)** Kurushima 正方形的中心'
- en: '|  | *n*² |  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  | *n*² |  |'
- en: '| *n* | (*n*² + 1)/2 | *n*² + 1 – *n* |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| *n* | (*n*² + 1)/2 | *n*² + 1 – *n* |'
- en: '|  | 1 |  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  | 1 |  |'
- en: 'Kurushima’s algorithm for generating an *n*×*n* magic square for odd *n* can
    be described simply as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Kurushima算法生成*n*×*n*的魔方阵（当*n*为奇数时）可以简要描述如下：
- en: Fill in the five central squares according to [Table 2-10](#table2-10).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据[表 2-10](#table2-10)填充中心的五个方格。
- en: Beginning with any entry whose value is known, determine the value of an unknown
    neighboring entry by following one of the three rules (described next).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从任何已知值的条目开始，通过遵循接下来介绍的三条规则之一，确定未知相邻条目的值。
- en: Repeat step 2 until every entry in the full magic square is filled in.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 2，直到填满整个魔方阵。
- en: Filling in the Central Squares
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 填充中心方格
- en: 'We can begin the process of creating a magic square by creating an empty square
    matrix that we’ll fill up. For example, if we want to create a 7×7 matrix, we
    can define `n=7` and then create a matrix with `n` rows and `n` columns:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个空的方形矩阵来开始创建魔方阵的过程，之后再填充它。例如，如果我们想创建一个7×7的矩阵，我们可以定义`n=7`，然后创建一个具有`n`行和`n`列的矩阵：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this case, we don’t know what numbers to put in the square, so we fill it
    entirely with entries equal to `float(''nan'')`. Here, `nan` stands for *not a
    number*, which we can use as a placeholder in Python when we want to fill up a
    list before we know what numbers to use. If we run `print(square)`, we find that
    this matrix by default is filled with `nan` entries:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不知道应该在正方形中放入什么数字，因此我们将其完全填充为`float('nan')`。这里，`nan`代表*不是一个数字*，我们可以在Python中使用它作为占位符，当我们想先填充一个列表，但还不知道要使用哪些数字时。如果我们运行`print(square)`，会发现该矩阵默认填充为`nan`条目：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This square is not too pretty as it is output in the Python console, so we
    can write a function that will print it in a more readable way:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该正方形在Python控制台中输出时并不太美观，我们可以编写一个函数，以更易读的方式打印它：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Don’t worry about the details of the `printsquare()` function, since it’s only
    for pretty printing and not part of our algorithm. We can fill in the central
    five squares with simple commands. First, we can get the indices of the central
    entry as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心`printsquare()`函数的细节，因为它只是为了美观地打印输出，并不是我们算法的一部分。我们可以用简单的命令填充中心的五个方格。首先，我们可以按如下方式获取中心条目的索引：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The central five squares can be populated according to the expressions in [Table
    2-10](#table2-10) as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 中心的五个方格可以根据[表 2-10](#table2-10)中的公式填充，如下所示：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Specifying the Three Rules
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指定三条规则
- en: The purpose of Kurushima’s algorithm is to fill in the rest of the `nan` entries
    according to simple rules. We can specify three simple rules that enable us to
    fill out every other entry, no matter how big the magic square is. The first rule
    is expressed in [Figure 2-1](#figure2-1).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Kurushima 算法的目的是根据简单的规则填充其余的 `nan` 项。我们可以指定三个简单的规则，帮助我们填充每一项，无论魔方阵有多大。第一个规则见[图
    2-1](#figure2-1)。
- en: '![Figure_2-1](Images/figure_2-1.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![Figure_2-1](Images/figure_2-1.png)'
- en: '[Figure 2-1:](#figureanchor2-1) Rule 1 of Kurushima’s algorithm'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 2-1:](#figureanchor2-1) Kurushima 算法的规则 1'
- en: 'So for any *x* in the magic square, we can determine the entry that is situated
    in this diagonal relationship to *x* by simply adding *n* and taking the result
    mod *n*² (mod refers to the modulo operation). Of course, we can also go in the
    opposite direction by reversing the operation: subtracting *n* and taking the
    result mod *n*².'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以对于魔方阵中的任何 *x*，我们可以通过简单地加上 *n* 并对 *n*² 取模（mod 代表取模运算），来确定与 *x* 具有这种对角关系的项。当然，我们也可以通过逆向操作进行计算：减去
    *n* 并对 *n*² 取模。
- en: The second rule is even simpler, and is expressed in [Figure 2-2](#figure2-2).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则更简单，表达式见[图 2-2](#figure2-2)。
- en: '![Figure_2-2](Images/figure_2-2.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Figure_2-2](Images/figure_2-2.png)'
- en: '[Figure 2-2:](#figureanchor2-2) Rule 2 of Kurushima’s algorithm'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 2-2:](#figureanchor2-2) Kurushima 算法的规则 2'
- en: 'For any *x* in the magic square, the entry below and to the right of *x* is
    1 greater than *x*, mod *n*². This is a simple rule, but it has one important
    exception: this rule is not followed when we cross from the upper-left half of
    the magic square to the lower-right half of the square. Another way to say this
    is that we do not follow the second rule if we are crossing the magic square’s
    *antidiagonal*, the bottom-left-to-top-right line shown in [Figure 2-3](#figure2-3).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于魔方阵中的任何 *x*，位于 *x* 右下方的项比 *x* 大 1，mod *n*²。这是一个简单的规则，但有一个重要的例外：当我们从魔方阵的左上半部分穿越到右下半部分时，这个规则不适用。换句话说，如果我们穿越魔方阵的
    *反对角线*（即从左下到右上的对角线，见[图 2-3](#figure2-3)），我们就不遵循第二条规则。
- en: '![Figure_2-3](Images/figure_2-3.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Figure_2-3](Images/figure_2-3.png)'
- en: '[Figure 2-3:](#figureanchor2-3) The antidiagonal of a square matrix'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 2-3:](#figureanchor2-3) 方阵的反对角线'
- en: You can see the cells that are on the antidiagonal. The antidiagonal line passes
    fully through them. We can follow our normal two rules when we are dealing with
    these cells. We need the exceptional third rule only when starting in a cell that
    is fully above the antidiagonal and crossing to a cell that is fully below it,
    or vice versa. That final rule is expressed in [Figure 2-4](#figure2-4), which
    shows an antidiagonal and two cells that would need to follow this rule when crossing
    it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到反对角线上的单元格。反对角线完全通过这些单元格。当我们处理这些单元格时，可以遵循我们正常的两条规则。只有当我们从完全在反对角线上方的单元格出发，并穿越到完全位于反对角线下方的单元格，或反之时，才需要第三条例外规则。最后这条规则见[图
    2-4](#figure2-4)，其中显示了反对角线和两个在穿越时需要遵循此规则的单元格。
- en: '![Figure_2-4](Images/figure_2-4.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Figure_2-4](Images/figure_2-4.png)'
- en: '[Figure 2-4:](#figureanchor2-4) Rule 3 of Kurushima’s algorithm'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 2-4:](#figureanchor2-4) Kurushima 算法的规则 3'
- en: This rule is followed when we are crossing the antidiagonal. If we cross from
    the bottom right to the top left, we can follow the inverse of this rule, in which
    *x* is transformed to *x* + *n* – 1, mod *n*².
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们穿越反对角线时，遵循此规则。如果我们从右下角穿越到左上角，则可以遵循此规则的逆操作，其中 *x* 被转换为 *x* + *n* – 1，mod *n*²。
- en: 'We can write a simple implementation of Rule 1 in Python by defining a function
    that takes `x` and `n` as its arguments and returns `(x+n)%n**2`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义一个接收 `x` 和 `n` 作为参数并返回 `(x+n)%n**2` 的函数，用 Python 简单实现规则 1：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can try this out with the central entry in the Luo Shu square. Remember,
    the Luo Shu square is a 3×3 square matrix, so *n* = 3\. The central entry of the
    Luo Shu square is 5\. The entry below and to the left of this entry is 8, and
    if we have implemented our `rule1()` function correctly we’ll get an 8 when we
    run the following line:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试从洛书方阵的中心项开始。记住，洛书方阵是一个 3×3 的方阵，所以 *n* = 3。洛书方阵的中心项是 5。该项下方且左侧的项是 8，如果我们正确实现了
    `rule1()` 函数，当我们运行以下代码时，会得到一个 8：
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see an `8` in the Python console. Our `rule1()` function seems to
    work as intended. However, we could improve it by enabling it to go “in reverse,”
    determining not only the entry on the bottom left of a given entry, but also the
    entry to the top right (that is, being able to go from 8 to 5 in addition to going
    from 5 to 8). We can make this improvement by adding one more argument to the
    function. We’ll call our new argument `upright`, and it will be a `True`/`False`
    indicator of whether we’re looking for the entry up and to the right of `x`. If
    not, we will by default look for the entry to the bottom left of `x`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 Python 控制台中看到一个 `8`。我们的 `rule1()` 函数似乎按预期工作。然而，我们可以通过使它能够“倒退”来进行改进，确定不仅是给定条目左下方的条目，还包括右上方的条目（也就是说，不仅可以从
    5 走到 8，也可以从 8 走到 5）。我们可以通过向函数添加一个额外的参数来进行改进。我们将把这个新参数命名为 `upright`，它将是一个 `True`/`False`
    指示器，表示我们是否要查找 `x` 上方和右侧的条目。如果不是，默认情况下我们将查找 `x` 左下方的条目：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In a mathematical expression, Python will interpret `True` as 1 and `False`
    as 0\. If `upright` is `False`, our function will return the same value as before,
    since (–1)⁰ = 1\. If `upright` is `True`, then it will subtract `n` instead of
    adding `n`, which will enable us to go in the other direction. Let’s check whether
    it can determine the entry above and to the right of 1 in the Luo Shu square:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学表达式中，Python 会将 `True` 解释为 1，将 `False` 解释为 0。如果 `upright` 为 `False`，我们的函数将返回与之前相同的值，因为
    (–1)⁰ = 1。如果 `upright` 为 `True`，则它会减去 `n` 而不是加上 `n`，这将使我们能够朝相反的方向前进。让我们检查一下它是否可以确定
    Luo Shu 方阵中 1 上方和右侧的入口：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It should print `7`, the correct value in the Luo Shu square.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该打印出 `7`，这是 Luo Shu 方阵中的正确值。
- en: 'For Rule 2, we can create an analogous function. Our Rule 2 function will take
    `x` and `n` as arguments, just like Rule 1\. But Rule 2 is by default finding
    the entry below and to the right of `x`. So we will add an `upleft` argument that
    will be `True` if we want to reverse the rule. The final rule is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于规则 2，我们可以创建一个类似的函数。我们的规则 2 函数将像规则 1 一样接受 `x` 和 `n` 作为参数。但规则 2 默认查找 `x` 右下方的条目。因此，我们将添加一个
    `upleft` 参数，如果我们想要反向规则，它将为 `True`。最终规则如下：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can test this on the Luo Shu square, though there are only two pairs of
    entries for which this doesn’t run into the exception to Rule 2\. For this exception,
    we can write the following function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Luo Shu 方阵上测试这一点，尽管只有两对条目不会遇到规则 2 的例外情况。对于这个例外情况，我们可以编写以下函数：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This rule needs to be followed only when we’re crossing the magic square’s antidiagonal.
    We’ll see later how to determine whether or not we are crossing the antidiagonal.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则只有在我们穿越魔方的反对角线时才需要遵循。稍后我们会看到如何判断是否在穿越反对角线。
- en: Now that we know how to fill the five central squares, and we have a rule to
    fill out the remaining squares based on knowledge of those central squares, we
    can fill out the rest of the square.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何填充五个中央方块，并且有了基于这些中央方块的知识来填充其余方块的规则，我们可以填充其余部分的方阵。
- en: Filling in the Rest of the Square
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 填充其余部分的方阵
- en: 'One way to fill in the rest of the square is to “walk” randomly through it,
    using known entries to fill in unknown entries. First, we’ll determine the indices
    of our central entry as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 填充方阵其余部分的一种方法是通过随机“行走”，使用已知的条目填充未知的条目。首先，我们将按如下方式确定中央条目的索引：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we can randomly select a direction to “walk,” as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以随机选择一个方向进行“行走”，如下所示：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we’ve used Python’s `random.choice()` function, which does random selection
    from lists. It takes an element from the set we specified (`where_we_can_go`),
    but it chooses at random (or as close to random as it can get).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了 Python 的 `random.choice()` 函数，该函数从列表中随机选择元素。它从我们指定的集合（`where_we_can_go`）中选择一个元素，但它是随机选择的（或者说尽可能接近随机）。
- en: 'After we’ve decided a direction to travel, we can follow whichever rule corresponds
    to our direction of travel. If we have chosen to go `down_left` or `up_right`,
    we’ll follow Rule 1, choosing the right arguments and indices as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们决定了前进方向之后，可以根据我们选择的方向遵循相应的规则。如果我们选择了 `down_left` 或 `up_right`，我们将遵循规则 1，并按如下方式选择正确的参数和索引：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly, we’ll follow Rule 2 if we have chosen to travel `up_left` or `down_right`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果我们选择了 `up_left` 或 `down_right`，我们将遵循规则 2：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code is for going up-left and down-right, but we should follow it only
    if we’re not crossing the antidiagonal. We’ll have to make sure that we follow
    Rule 3 in the case where we are crossing the antidiagonal. There is a simple way
    to know if we are in an entry that is near the antidiagonal: the entries just
    above the antidiagonal will have indices that sum to `n-2`, and the entries just
    below the antidiagonal will have indices that sum to `n`. We’ll want to implement
    Rule 3 in these exceptional cases:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码用于向上左移动和向下右移动，但只有在不跨越反对角线时，我们才应遵循它。如果我们跨越了反对角线，就必须确保在这种情况下遵循规则 3。我们有一种简单的方法可以判断我们是否处在接近反对角线的条目：反对角线正上方的条目，其索引和为`n-2`，而反对角线正下方的条目，其索引和为`n`。在这些特殊情况下，我们需要实现规则
    3：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Keep in mind that our magic square is finite, so we cannot, for example, travel
    up/left from the top row or leftmost column. By creating our list of where it’s
    possible to travel based on our current location, we can add some simple logic
    to ensure that we travel only in allowed directions:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的魔方阵是有限的，因此我们不能像从顶部行或最左列那样向上或向左移动。通过根据当前位置创建可移动的列表，我们可以添加一些简单的逻辑，确保只朝着允许的方向移动：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have all the elements we need to write Python code that implements Kurushima’s
    algorithm.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了编写实现Kurushima算法的Python代码所需的所有元素。
- en: Putting It All Together
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将一切整合在一起
- en: We can put everything together in a function that takes a starting square with
    some `nan` entries and travels through it using our three rules to fill them in.
    [Listing 2-2](#listing2-2) contains the whole function.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有内容整合到一个函数中，该函数接受一个包含一些`nan`条目的起始方格，并使用我们的三条规则穿越它来填充这些条目。[列表 2-2](#listing2-2)包含了完整的函数。
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Listing 2-2:](#listinganchor2-2) A function that enables an implementation
    of Kurushima’s algorithm'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-2:](#listinganchor2-2) 一个实现Kurushima算法的函数'
- en: 'This function will take four arguments: first, a starting square that has some
    `nan` entries; second and third, the indices of the entry that we want to start
    with; and fourth, how much we want to fill up the square (measured by the number
    of `nan` entries we are willing to tolerate). The function consists of a `while`
    loop that writes a number to an entry in the square at every iteration by following
    one of our three rules. It continues until it has as many `nan` entries as we
    have specified in the function’s fourth argument. After it writes to a particular
    entry, it “travels” to that entry by changing its indices 1, and then it repeats
    again.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将接受四个参数：首先，一个包含一些`nan`条目的起始方格；第二和第三，表示我们想要开始的条目的索引；第四，我们希望填充方格的程度（由我们愿意容忍的`nan`条目数量来衡量）。这个函数由一个`while`循环组成，每次迭代时通过遵循我们三条规则之一来向方格中的条目写入一个数字。它会一直执行，直到写入的`nan`条目数达到我们在函数第四个参数中指定的数量。每次写入后，它会通过改变索引
    1 来“移动”到该条目，然后继续执行。
- en: Now that we have this function, all that remains is to call it in the right
    way.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了这个函数，剩下的就是以正确的方式调用它。
- en: Using the Right Arguments
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用正确的参数
- en: 'Let’s start with the central entry and fill up the magic square from there.
    For our `howfull` argument, we’ll specify `(n**2)/2-4`. The reason for using this
    value for `howfull` will become clear after we see our results:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从中央条目开始，从这里填充魔方阵。对于我们的`howfull`参数，我们将指定`(n**2)/2-4`。使用这个值作为`howfull`的原因将在我们看到结果后变得清晰：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this case, we call the `fillsquare()` function using the existing `square`
    variable that we defined previously. Remember we defined it to be full of `nan`
    entries except for five central elements that we specified. After we run the `fillsquare()`
    function with that `square` as its input, the `fillsquare()` function fills in
    many of the remaining entries. Let’s print out the resulting square and see what
    it looks like afterward:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用之前定义的`square`变量调用`fillsquare()`函数。记得我们定义它时，除了我们指定的五个中央元素外，其他位置都填充了`nan`。当我们用这个`square`作为输入运行`fillsquare()`函数后，`fillsquare()`函数会填充许多剩余的条目。接下来让我们打印出结果方阵，看看它看起来如何：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You’ll notice that the `nan`s occupy alternating entries, like a checkerboard.
    The reason for this is that the rules we have for moving diagonally give us access
    to only about half of the total entries, depending on which entry we started with.
    The valid moves are the same as in checkers: a piece that starts on a dark square
    can move diagonally to other dark squares, but its diagonal moving pattern will
    never allow it to move to any of the light squares. The `nan` entries we see are
    inaccessible if we start on the central entry. We specified `(n**2)/2``-``4` for
    our `howfull` argument instead of zero because we know that we wouldn’t be able
    to fill the matrix completely by calling our function only once. But if we start
    again on one of the central entry’s neighbors, we will be able to access the rest
    of the `nan` entries in our “checkerboard.” Let’s call the `fillsquare()` function
    again, this time starting on a different entry and specifying our fourth argument
    as zero, indicating that we want to completely fill our square:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`nan`值占据了交替的条目，就像棋盘一样。原因在于我们用于斜向移动的规则使得我们只能访问总条目的大约一半，具体取决于我们从哪个条目开始。有效的移动规则与跳棋相同：从黑色格子上开始的棋子可以斜着移动到其他黑色格子，但它的斜向移动模式永远无法移动到任何白色格子。如果我们从中心条目开始，看到的`nan`条目是不可访问的。我们在`howfull`参数中指定了`(n**2)/2``-``4`而不是零，因为我们知道仅仅调用一次我们的函数无法完全填充矩阵。但如果我们从中心条目的邻居开始，就能访问我们“棋盘”中的其余`nan`条目。让我们再次调用`fillsquare()`函数，这次从不同的条目开始，并将第四个参数指定为零，表示我们希望完全填满方阵：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we print our square now, we can see that it is completely full:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打印出我们的方阵，可以看到它已经完全填满：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There is just one final change we need to make. Because of the rules of the
    `%` operator, our square contains consecutive integers between 0 and 48, but Kurushima’s
    algorithm is meant to fill our square with the integers from 1 to 49\. We can
    add one line that replaces 0 with 49 in our square:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要做一个最后的更改。由于`%`运算符的规则，我们的方阵包含了从0到48的连续整数，但久留岛算法是用来填充从1到49的整数。我们可以加上一行代码，将方阵中的0替换为49：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now our square is complete. We can verify that it is indeed a magic square
    by using the `verifysquare()` function we created earlier:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的方阵已经完成。我们可以使用之前创建的`verifysquare()`函数验证它是否确实是一个魔方阵：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This should return `True`, indicating that we’ve succeeded.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回`True`，表示我们已经成功。
- en: 'We just created a 7×7 magic square by following Kurushima’s algorithm. Let’s
    test our code and see if it can create a larger magic square. If we change `n`
    to 11 or any other odd number, we can run exactly the same code and get a magic
    square of any size:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用久留岛算法创建了一个7×7的魔方阵。让我们测试一下我们的代码，看看它是否能创建一个更大的魔方阵。如果我们将`n`更改为11或任何其他奇数，我们可以运行完全相同的代码，得到任何大小的魔方阵：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Our 11×11 square looks as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的11×11方阵如下所示：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can verify, either manually or with our `verifysquare()` function, that this
    is indeed a magic square. You can do the same with any odd `n` and marvel at the
    results.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动验证，或者使用我们的`verifysquare()`函数，来确认这确实是一个魔方阵。你可以用任何奇数`n`做同样的操作，惊叹于结果。
- en: 'Magic squares don’t have much practical significance, but it’s fun to observe
    their patterns anyway. If you’re interested, you might spend some time thinking
    about the following questions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 魔方阵虽然没有太多实际意义，但观察它们的模式仍然很有趣。如果你感兴趣，可以花些时间思考以下问题：
- en: Do the larger magic squares we created follow the odd/even alternating pattern
    seen in the outer edge of the Luo Shu square? Do you think every possible magic
    square follows this pattern? What reason, if any, would there be for this pattern?
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建的更大魔方阵是否遵循了罗书方阵外缘所见的奇偶交替模式？你认为每个可能的魔方阵都遵循这个模式吗？如果有的话，为什么会有这个模式？
- en: Do you see any other patterns in the magic squares we’ve created that haven’t
    been mentioned yet?
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否发现我们创建的魔方阵中还有其他未提及的模式？
- en: Can you find another set of rules that create Kurushima’s squares? For example,
    are there rules that enable one to travel up and down through Kurushima’s square
    instead of diagonally?
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能找到另一组规则来创建久留岛的方阵吗？例如，是否有规则能够让人们通过久留岛的方阵上下移动，而不是斜着移动？
- en: Are there other types of magic squares that satisfy the definition of a magic
    square but don’t follow Kurushima’s rules at all?
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否存在其他类型的魔方阵，它们符合魔方阵的定义，但完全不遵循久留岛规则？
- en: Is there a more efficient way to write code to implement Kurushima’s algorithm?
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有更高效的方式编写代码来实现久留岛算法？
- en: Magic squares occupied the attention of great Japanese mathematicians for several
    centuries, and they’ve found a significant place in cultures around the world.
    We can count ourselves lucky that the great mathematicians of the past gave us
    algorithms for generating and analyzing magic squares that we can easily implement
    on today’s powerful computers. At the same time, we can admire the patience and
    insight that was required for them to investigate magic squares with only pen,
    paper, and their wits (and the occasional magical turtle) to guide them.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 魔方占据了几百年来日本伟大数学家的注意力，并且在世界各地的文化中找到了重要的位置。我们可以认为自己非常幸运，因为过去的伟大数学家为我们提供了生成和分析魔方的算法，我们可以轻松地在今天强大的计算机上实现这些算法。与此同时，我们也可以钦佩他们仅凭纸笔和智慧（偶尔还有神奇的海龟）进行魔方研究所需的耐心和洞察力。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed some historical algorithms that range from a few
    centuries to a few millenia old. Readers who are interested in historical algorithms
    can find many more to study. These algorithms may not be of great practical utility
    today, but it can be worthwhile to study them—first because they give us a sense
    of history, and second because they help broaden our horizons and may provide
    the inspiration for writing our own innovative algorithms.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些历史性的算法，时间跨度从几个世纪到几千年不等。对历史算法感兴趣的读者可以找到更多的算法进行学习。这些算法今天可能没有很大的实际用途，但研究它们是值得的——首先因为它们让我们感受到了历史的气息，其次因为它们帮助我们拓宽视野，并且可能为编写我们自己创新算法提供灵感。
- en: 'The algorithms in the next chapter enable us to do some commonly needed and
    useful tasks with mathematical functions: maximize and minimize them. Now that
    we have discussed algorithms in general and algorithms in history, you should
    be comfortable with what an algorithm is and how one works, and you should be
    ready to dive into serious algorithms used in the most cutting-edge software being
    developed today.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章中的算法使我们能够完成一些常见且有用的数学功能任务：最大化和最小化它们。现在我们已经讨论了算法的概念以及历史中的算法，你应该对什么是算法以及它是如何工作的有了充分的了解，并且准备好深入研究当今最前沿软件中使用的严肃算法。
