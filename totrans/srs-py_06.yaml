- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**UNIT TESTING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Many find unit testing to be arduous and time-consuming, and some people and
    projects have no testing policy. This chapter assumes that you see the wisdom
    of unit testing! Writing code that is not tested is fundamentally useless, as
    there’s no way to conclusively prove that it works. If you need convincing, I
    suggest you start by reading about the benefits of test-driven development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人觉得单元测试既繁琐又耗时，也有一些人和项目没有测试政策。本章假设你已经认识到单元测试的智慧！编写没有经过测试的代码本质上是没有意义的，因为无法确凿证明它能正常工作。如果你需要说服自己，我建议你从阅读测试驱动开发的好处开始。
- en: In this chapter you’ll learn about the Python tools you can use to construct
    a comprehensive suite of tests that will make testing simpler and more automated.
    We’ll talk about how you can use tools to make your software rock solid and regression-free.
    We’ll cover creating reusable test objects, running tests in parallel, revealing
    untested code, and using virtual environments to make sure your tests are clean,
    as well as some other good-practice methods and ideas.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用Python工具构建一个全面的测试套件，使测试更加简便和自动化。我们将讨论如何利用工具使你的软件更加稳定、无回归。我们将涉及创建可重用的测试对象、并行运行测试、揭示未测试的代码，以及使用虚拟环境确保你的测试是干净的，还有一些其他的最佳实践和想法。
- en: '**The Basics of Testing**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**测试基础**'
- en: Writing and running unit tests is uncomplicated in Python. The process is not
    intrusive or disruptive, and unit testing will greatly help you and other developers
    in maintaining your software. Here I’ll discuss some of the absolute basics of
    testing that will make things easier for you.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中编写和运行单元测试并不复杂。这个过程既不具侵入性，也不会造成干扰，单元测试会极大地帮助你和其他开发者维护软件。在这里，我将讨论一些测试的基础知识，帮助你更轻松地进行测试。
- en: '***Some Simple Tests***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一些简单的测试***'
- en: First, you should store tests inside a tests submodule of the application or
    library they apply to. Doing so will allow you to ship the tests as part of your
    module so that they can be run or reused by anyone—even after your software is
    installed—without necessarily using the source package. Making the tests a submodule
    of your main module also prevents them from being installed by mistake in a top-level
    tests module.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该将测试存储在适用于其所在应用或库的tests子模块中。这样做将使你能够将测试作为模块的一部分进行发布，以便任何人都可以运行或重用这些测试——即使软件已经安装——而不必使用源代码包。将测试作为主模块的子模块也能防止它们在顶层的tests模块中被误安装。
- en: Using a hierarchy in your test tree that mimics the hierarchy of your module
    tree will make the tests more manageable. This means that the tests covering the
    code of *mylib/foobar.py* should be stored inside *mylib/tests/test_foobar.py*.
    Consistent nomenclature makes things simpler when you’re looking for the tests
    related to a particular file. [Listing 6-1](ch06.xhtml#ch6list1) shows the simplest
    unit test you can write.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个模拟你模块树层次结构的测试树层次结构会让测试更加易于管理。这意味着，覆盖*mylib/foobar.py*代码的测试应存储在*mylib/tests/test_foobar.py*中。统一的命名法会让你在查找与特定文件相关的测试时更加简便。[列表
    6-1](ch06.xhtml#ch6list1)展示了你可以编写的最简单的单元测试。
- en: 'def test_true():'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_true():'
- en: assert True
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: assert True
- en: '*Listing 6-1: A really simple test in test_true.py*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-1: 在test_true.py中的一个非常简单的测试*'
- en: This will simply assert that the behavior of the program is what you expect.
    To run this test, you need to load the *test_true.py* file and run the test_true()
    function defined within.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地断言程序的行为符合你的预期。要运行这个测试，你需要加载*test_true.py*文件并运行其中定义的test_true()函数。
- en: However, writing and running an individual test for each of your test files
    and functions would be a pain. For small projects with simple usage, the pytest
    package comes to the rescue—once installed via pip, pytest provides the pytest
    command, which loads every file whose name starts with *test_* and then executes
    all functions within that start with test_.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为每个测试文件和函数编写和运行单独的测试会是一件麻烦事。对于简单用法的小型项目，pytest包能够提供帮助——通过pip安装后，pytest提供pytest命令，加载所有文件名以*test_*开头的文件，并执行所有以test_开头的函数。
- en: 'With just the *test_true.py* file in our source tree, running pytest gives
    us the following output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭我们源代码树中的*test_true.py*文件，运行pytest会给出以下输出：
- en: $ pytest -v test_true.py
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: $ pytest -v test_true.py
- en: ========================== test session starts ===========================
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ========================== 测试会话开始 ===========================
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 --
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 --
- en: /usr/local/opt/python/bin/python3.6
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'cachedir: .cache'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'rootdir: examples, inifile:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: collected 1 item
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: test_true.py::test_true PASSED                                     [100%]
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: ======================== 1 passed in 0.01 seconds ========================
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The -v option tells pytest to be verbose and print the name of each test run
    on a separate line. If a test fails, the output changes to indicate the failure,
    accompanied by the whole traceback.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a failing test this time, as shown in [Listing 6-2](ch06.xhtml#ch6list2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_false():'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: assert False
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-2: A failing test in test_true.py*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the test file again, here’s what happens:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: $ pytest -v test_true.py
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: ========================== test session starts ===========================
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: local/opt/python/bin/python3.6
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'cachedir: .cache'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'rootdir: examples, inifile:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: collected 2 items
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: test_true.py::test_true PASSED                                     [ 50%]
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: test_true.py::test_false FAILED                                    [100%]
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: ================================ FAILURES ================================
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: _______________________________ test_false _______________________________
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_false():'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '>       assert False'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: E       assert False
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'test_true.py:5: AssertionError'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: =================== 1 failed, 1 passed in 0.07 seconds ===================
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: A test fails as soon as an AssertionError exception is raised; our assert test
    will raise an AssertionError when its argument is evaluated to something false
    (False, None, 0, etc.). If any other exception is raised, the test also errors
    out.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Simple, isn’t it? While simplistic, a lot of small projects use this approach
    and it works very well. Those projects require no tools or libraries other than
    pytest and thus can rely on simple assert tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'As you start to write more sophisticated tests, pytest will help you understand
    what’s wrong in your failing tests. Imagine the following test:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_key():'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: a = ['a', 'b']
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: b = ['b']
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: assert a == b
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'When pytest is run, it gives the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: $ pytest test_true.py
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: ========================== test session starts =========================== platform
    darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'rootdir: /Users/jd/Source/python-book/examples, inifile:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'plugins: celery-4.1.0'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: collected 1 item
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: test_true.py F                                                     [100%]
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: ================================ FAILURES ================================
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: ________________________________ test_key ________________________________
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_key():'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: a = ['a', 'b']
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: b = ['b']
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '>       assert a == b'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'E       AssertionError: assert [''a'', ''b''] == [''b'']'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'E         At index 0 diff: ''a'' != ''b'''
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'E         Left contains more items, first extra item: ''b'''
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: E         Use -v to get the full diff
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'test_true.py:10: AssertionError'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: ======================== 1 failed in 0.07 seconds ========================
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that a and b are different and that this test does not pass. It
    also tells us exactly how they are different, making it easy to fix the test or
    code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '***Skipping Tests***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If a test cannot be run, you will probably want to skip that test—for example,
    you may wish to run a test conditionally based on the presence or absence of a
    particular library. To that end, you can use the pytest.skip() function, which
    will mark the test as skipped and move on to the next one. The pytest.mark.skip
    decorator skips the decorated test function unconditionally, so you’ll use it
    when a test always needs to be skipped. [Listing 6-3](ch06.xhtml#ch6list3) shows
    how to skip a test using these methods.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: import pytest
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: import mylib
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'except ImportError:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: mylib = None
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '@pytest.mark.skip("Do not run this")'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_fail():'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: assert False
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '@pytest.mark.skipif(mylib is None, reason="mylib is not available")'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_mylib():'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'assert mylib.foobar() == 42 def test_skip_at_runtime():'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'if True:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: pytest.skip("Finally I don't want to run it")
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-3: Skipping tests*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'When executed, this test file will output the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: $ pytest -v examples/test_skip.py
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: ========================== test session starts ===========================
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: local/opt/python/bin/python3.6
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'cachedir: .cache'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'rootdir: examples, inifile:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: collected 3 items
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: examples/test_skip.py::test_fail SKIPPED
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[ 33%]'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: examples/test_skip.py::test_mylib SKIPPED
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[ 66%]'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: examples/test_skip.py::test_skip_at_runtime SKIPPED
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[100%]'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: ================= 3 skipped in 0.01 seconds =================
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The output of the test run in [Listing 6-3](ch06.xhtml#ch6list3) indicates that,
    in this case, all the tests have been skipped. This information allows you to
    ensure you didn’t accidentally skip a test you expected to run.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '***Running Particular Tests***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When using pytest, you often want to run only a particular subset of your tests.
    You can select which tests you want to run by passing their directory or files
    as an argument to the pytest command line. For example, calling pytest test_one.py
    will only run the *test_one.py* test. Pytest also accepts a directory as argument,
    and in that case, it will recursively scan the directory and run any file that
    matches the *test_*.py* pattern.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: You can also add a filter with the -k argument on the command line in order
    to execute only the test matching a name, as shown in [Listing 6-4](ch06.xhtml#ch6list4).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: $ pytest -v examples/test_skip.py -k test_fail
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: ========================== test session starts ===========================
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: local/opt/python/bin/python3.6
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'cachedir: .cache'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'rootdir: examples, inifile:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: collected 3 items
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: examples/test_skip.py::test_fail SKIPPED
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[100%] === 2 tests deselected ==='
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: === 1 skipped, 2 deselected in 0.04 seconds ===
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-4: Filtering tests run by name*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Names are not always the best way to filter which tests will run. Commonly,
    a developer would group tests by functionalities or types instead. Pytest provides
    a dynamic marking system that allows you to mark tests with a keyword that can
    be used as a filter. To mark tests in this way, use the -m option. If we set up
    a couple of tests like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 名称并不总是过滤哪些测试会运行的最佳方式。通常，开发人员会根据功能或类型将测试分组。Pytest 提供了一种动态标记系统，允许您使用关键字标记测试，作为筛选器。要以这种方式标记测试，请使用
    -m 选项。如果我们设置了几个这样的测试：
- en: import pytest
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: '@pytest.mark.dicttest'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.mark.dicttest'
- en: 'def test_something():'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_something():'
- en: a = ['a', 'b']
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: a = ['a', 'b']
- en: assert a == a
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: assert a == a
- en: 'def test_something_else():'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_something_else():'
- en: assert False
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: assert False
- en: 'we can use the -m argument with pytest to run only one of those tests:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 -m 参数与 pytest 一起运行其中一个测试：
- en: $ pytest -v test_mark.py -m dicttest
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: $ pytest -v test_mark.py -m dicttest
- en: === test session starts ===
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: === 测试会话开始 ===
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
- en: local/opt/python/bin/python3.6
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: local/opt/python/bin/python3.6
- en: 'cachedir: .cache'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'cachedir: .cache'
- en: 'rootdir: examples, inifile:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'rootdir: examples, inifile:'
- en: collected 2 items
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 收集了 2 个项目
- en: test_mark.py::test_something PASSED
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: test_mark.py::test_something 通过
- en: '[100%]'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[100%]'
- en: === 1 tests deselected ===
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: === 1 个测试被取消选择 ===
- en: === 1 passed, 1 deselected in 0.01 seconds ===
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: === 1 通过，1 被取消选择，耗时 0.01 秒 ===
- en: 'The -m marker accepts more complex queries, so we can also run all tests that
    are *not* marked:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: -m 标记接受更复杂的查询，因此我们也可以运行所有*未*标记的测试：
- en: $ pytest test_mark.py -m 'not dicttest'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: $ pytest test_mark.py -m 'not dicttest'
- en: === test session starts ===
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: === 测试会话开始 ===
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0
- en: 'rootdir: examples, inifile:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'rootdir: examples, inifile:'
- en: collected 2 items
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 收集了 2 个项目
- en: test_mark.py F
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: test_mark.py F
- en: '[100%]'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[100%]'
- en: === FAILURES ===
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: === 失败的测试 ===
- en: 'test_something_else def test_something_else():'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'test_something_else def test_something_else():'
- en: '>       assert False'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '>       assert False'
- en: E       assert False
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: E       assert False
- en: 'test_mark.py:10: AssertionError'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'test_mark.py:10: AssertionError'
- en: === 1 tests deselected ===
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: === 1 个测试被取消选择 ===
- en: === 1 failed, 1 deselected in 0.07 seconds ===
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: === 1 个失败，1 被取消选择，耗时 0.07 秒 ===
- en: Here pytest executed every test that was not marked as dicttest—in this case,
    the test_something_else test, which failed. The remaining marked test, test_something,
    was not executed and so is listed as deselected.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 pytest 执行了所有未标记为 dicttest 的测试——在此案例中是 test_something_else 测试，它失败了。剩余的标记测试
    test_something 没有执行，因此列为取消选择。
- en: Pytest accepts complex expressions composed of the or, and, and not keywords,
    allowing you to do more advanced filtering.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest 接受由 or、and 和 not 关键字组成的复杂表达式，使您能够进行更高级的筛选。
- en: '***Running Tests in Parallel***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***并行运行测试***'
- en: Test suites can take a long time to run. It’s not uncommon for a full suite
    of unit tests to take tens of minutes to run in large software projects. By default,
    pytest runs all tests serially, in an undefined order. Since most computers have
    several CPUs, you can usually speed things up if you split the list of tests and
    run them on multiple CPUs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件可能需要很长时间才能完成。对于大型软件项目来说，完整的单元测试套件可能需要花费数十分钟来运行。默认情况下，pytest 会按顺序运行所有测试，但顺序是未定义的。由于大多数计算机都配备了多个
    CPU，通常可以通过将测试列表分割并在多个 CPU 上运行来加快速度。
- en: To handle this approach, pytest provides the plugin pytest-xdist, which you
    can install with pip. This plugin extends the pytest command line with the --numprocesses
    argument (shortened as -n), which accepts as its argument the number of CPUs to
    use. Running pytest -n 4 would run your test suite using four parallel processes,
    balancing the load across the available CPUs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种方法，pytest 提供了插件 pytest-xdist，您可以通过 pip 安装。该插件通过 --numprocesses 参数（缩写为
    -n）扩展了 pytest 命令行，该参数接受的值是要使用的 CPU 数量。运行 pytest -n 4 将使用四个并行进程运行您的测试套件，均衡地分配负载到可用的
    CPU 上。
- en: Because the number of CPUs can change from one computer to another, the plugin
    also accepts the auto keyword as a value. In this case, it will probe the machine
    to retrieve the number of CPUs available and start this number of processes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 CPU 的数量会因计算机而异，所以插件也接受 auto 关键字作为值。在这种情况下，它将探测机器以获取可用的 CPU 数量，并启动这个数量的进程。
- en: '***Creating Objects Used in Tests with Fixtures***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Fixtures 创建测试中使用的对象***'
- en: In unit testing, you’ll often need to execute a set of common instructions before
    and after running a test, and those instructions will use certain components.
    For example, you might need an object that represents the configuration state
    of your application, and you’ll likely want that object to be initialized before
    each test, then reset to its default values when the test is achieved. Similarly,
    if your test relies on the temporary creation of a file, the file must be created
    before the test starts and deleted once the test is done. These components, known
    as *fixtures*, are set up before a test and cleaned up after the test has finished.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，你通常需要在运行测试前后执行一组常见的指令，这些指令将使用某些组件。例如，你可能需要一个代表应用程序配置状态的对象，并且希望在每个测试前初始化该对象，测试完成后将其重置为默认值。同样，如果测试依赖于临时创建文件，文件必须在测试开始前创建，并在测试完成后删除。这些组件被称为*fixtures*，它们在测试前设置，并在测试完成后清理。
- en: With pytest, fixtures are defined as simple functions. The fixture function
    should return the desired object(s) so that a test using that fixture can use
    that object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在pytest中，fixtures被定义为简单的函数。fixture函数应该返回所需的对象，以便使用该fixture的测试可以使用该对象。
- en: 'Here’s a simple fixture:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的fixture：
- en: import pytest
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: '@pytest.fixture'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def database():'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'def database():'
- en: return <some database connection>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: return <某个数据库连接>
- en: 'def test_insert(database):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_insert(database):'
- en: database.insert(123)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: database.insert(123)
- en: The database fixture is automatically used by any test that has database in
    its argument list. The test_insert() function will receive the result of the database()
    function as its first argument and use that result as it wants. When we use a
    fixture this way, we don’t need to repeat the database initialization code several
    times.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库fixture会自动被任何包含数据库作为参数的测试使用。test_insert()函数将接收database()函数的返回值作为其第一个参数，并根据需要使用该结果。当我们以这种方式使用fixture时，无需重复数据库初始化代码。
- en: Another common feature of code testing is tearing down after a test has used
    a fixture. For example, you may need to close a database connection. Implementing
    the fixture as a generator allows us to add teardown functionality, as shown in
    [Listing 6-5](ch06.xhtml#ch6list5).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码测试中的另一个常见特性是在测试使用fixture后进行清理。例如，你可能需要关闭数据库连接。将fixture实现为生成器可以让我们添加清理功能，如[示例
    6-5](ch06.xhtml#ch6list5)所示。
- en: import pytest
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: '@pytest.fixture'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def database():'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'def database():'
- en: db = <some database connection>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: db = <某个数据库连接>
- en: yield db
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: yield db
- en: db.close()
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: db.close()
- en: 'def test_insert(database):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_insert(database):'
- en: database.insert(123)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: database.insert(123)
- en: '*Listing 6-5: Teardown functionality*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*清理功能示例 6-5*'
- en: Because we used the yield keyword and made database a generator, the code after
    the yield statement runs when the test is done. That code will close the database
    connection at the end of the test.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了yield关键字并将database实现为生成器，所以yield语句后的代码将在测试完成时运行。那段代码会在测试结束时关闭数据库连接。
- en: 'However, closing a database connection for each test might impose an unnecessary
    runtime cost, as tests may be able to reuse that same connection. In that case,
    you can pass the scope argument to the fixture decorator, specifying the scope
    of the fixture:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于每个测试都关闭数据库连接可能会带来不必要的运行时成本，因为测试可能能够重用相同的连接。在这种情况下，你可以将scope参数传递给fixture装饰器，指定fixture的作用范围：
- en: import pytest
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: '@pytest.fixture(scope="module")'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture(scope="module")'
- en: 'def database():'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'def database():'
- en: db = <some database connection>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: db = <某个数据库连接>
- en: yield db
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: yield db
- en: db.close()
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: db.close()
- en: 'def test_insert(database):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_insert(database):'
- en: database.insert(123)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: database.insert(123)
- en: By specifying the scope="module" parameter, you initialize the fixture once
    for the whole module, and the same database connection will be passed to all test
    functions requesting a database connection.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定scope="module"参数，你为整个模块初始化一次fixture，并且相同的数据库连接将被传递给所有请求数据库连接的测试函数。
- en: 'Finally, you can run some common code before and after your tests by marking
    fixtures as *automatically used* with the autouse keyword, rather than specifying
    them as an argument for each of the test functions. Specifying the autouse=True
    keyword argument to the pytest.fixture() function will make sure the fixture is
    called before running any test in the module or class it is defined in, as in
    this example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过使用autouse关键字将fixtures标记为*自动使用*，从而在每个测试函数中不需要将它们作为参数。将autouse=True关键字参数传递给pytest.fixture()函数，将确保在运行模块或类中定义的任何测试之前先调用该fixture，如下所示的示例：
- en: import os
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: import pytest
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: '@pytest.fixture(autouse=True)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture(autouse=True)'
- en: 'def change_user_env():'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'def change_user_env():'
- en: curuser = os.environ.get("USER")
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: curuser = os.environ.get("USER")
- en: os.environ["USER"] = "foobar"
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: os.environ["USER"] = "foobar"
- en: yield
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: yield
- en: os.environ["USER"] = curuser
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: os.environ["USER"] = curuser
- en: 'def test_user():'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_user():'
- en: assert os.getenv("USER") == "foobar"
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: assert os.getenv("USER") == "foobar"
- en: 'Such automatically enabled features are handy, but make sure not to abuse fixtures:
    they are run before each and every test covered by their scope, so they can slow
    down a test run significantly.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动启用的功能非常方便，但要确保不要滥用 fixture：它们会在每个包含在其范围内的测试之前运行，因此可能会显著减慢测试的运行速度。
- en: '***Running Test Scenarios***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行测试场景***'
- en: When unit testing, you may want to run the same error-handling test with several
    different objects that trigger that error, or you may want to run an entire test
    suite against different drivers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试时，你可能希望使用触发同样错误的多个不同对象来运行相同的错误处理测试，或者你可能希望使用不同的驱动程序运行整个测试套件。
- en: We relied heavily on this latter approach when developing *Gnocchi*, a time
    series database. Gnocchi provides an abstract class that we call the *storage
    API*. Any Python class can implement this abstract base and register itself to
    become a driver. The software loads the configured storage driver when required
    and uses the implemented storage API to store or retrieve data. In this case,
    we need a class of unit tests that runs against each driver—thus running against
    each implementation of this storage API—to be sure all drivers conform to what
    the callers expect.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发*Gnocchi*（一个时间序列数据库）时，我们大量依赖了这种后者的方法。Gnocchi 提供了一个我们称之为*存储 API*的抽象类。任何 Python
    类都可以实现这个抽象基类并注册自己成为一个驱动程序。软件会在需要时加载配置的存储驱动程序，并使用实现的存储 API 来存储或检索数据。在这种情况下，我们需要一类单元测试，针对每个驱动程序运行——即针对这个存储
    API 的每个实现运行——以确保所有驱动程序都符合调用者的预期。
- en: 'An easy way to achieve this is by using *parameterized fixtures*, which will
    run all the tests that use them several times, once for each of the defined parameters.
    [Listing 6-6](ch06.xhtml#ch6list6) shows an example of using parameterized fixtures
    to run a single test twice with different parameters: once for mysql and once
    for postgresql.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的简单方法是使用*参数化 fixture*，它会多次运行所有使用该 fixture 的测试，每次使用一个不同的定义参数。[列表 6-6](ch06.xhtml#ch6list6)展示了使用参数化
    fixture 来用不同的参数运行同一个测试两次的示例：一次使用 mysql，另一次使用 postgresql。
- en: import pytest
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: import myapp @pytest.fixture(params=["mysql", "postgresql"])
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: import myapp @pytest.fixture(params=["mysql", "postgresql"])
- en: 'def database(request):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'def database(request):'
- en: d = myapp.driver(request.param)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: d = myapp.driver(request.param)
- en: d.start()
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: d.start()
- en: yield d
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: yield d
- en: d.stop()
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: d.stop()
- en: 'def test_insert(database):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_insert(database):'
- en: database.insert("somedata")
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: database.insert("somedata")
- en: '*Listing 6-6: Running a test using parameterized fixtures*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-6：使用参数化 fixture 运行测试*'
- en: 'In [Listing 6-6](ch06.xhtml#ch6list6), the driver fixture is parameterized
    with two different values, each the name of a database driver that is supported
    by the application. When test_insert is run, it is actually run twice: once with
    a MySQL database connection and once with a PostgreSQL database connection. This
    allows us to easily reuse the same test with different scenarios, without adding
    many lines of code.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 6-6](ch06.xhtml#ch6list6)中，驱动程序 fixture 被用两个不同的值进行了参数化，每个值都是应用程序支持的数据库驱动程序的名称。当
    test_insert 运行时，实际上会运行两次：一次使用 MySQL 数据库连接，另一次使用 PostgreSQL 数据库连接。这使我们能够轻松地在不同场景下重用相同的测试，而不需要增加大量的代码行。
- en: '***Controlled Tests Using Mocking***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Mock 对象的受控测试***'
- en: Mock objects are simulated objects that mimic the behavior of real application
    objects, but in particular and controlled ways. These are especially useful in
    creating environments that describe precisely the conditions for which you would
    like to test code. You can replace all objects but one with mock objects to isolate
    the behavior of your focus object and create an enviroment for testing your code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Mock 对象是模拟的对象，它们模仿真实应用对象的行为，但在特定和受控的方式下。这些对象在创建精确描述你想要测试代码的条件的环境时特别有用。你可以将所有对象替换为
    mock 对象，只保留一个，来隔离你关注的对象的行为，并为测试代码创建一个环境。
- en: One use case is in writing an HTTP client, since it is likely impossible (or
    at least extremely complicated) to spawn the HTTP server and test it through all
    scenarios to return every possible value. HTTP clients are especially difficult
    to test for all failure scenarios.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用场景是在编写 HTTP 客户端时，因为几乎不可能（或者至少极其复杂）启动 HTTP 服务器并通过所有场景进行测试，以返回每个可能的值。HTTP
    客户端尤其难以测试所有失败场景。
- en: 'The standard library for creating mock objects in Python is mock. Starting
    with Python 3.3, mock has been merged into the Python Standard Library as unittest.mock.
    You can, therefore, use a snippet like the following to maintain backward compatibility
    between Python 3.3 and earlier versions:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: from unittest import mock
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'except ImportError:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: import mock
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The mock library is pretty simple to use. Any attribute accessed on a mock.Mock
    object is dynamically created at runtime. Any value can be set to such an attribute.
    [Listing 6-7](ch06.xhtml#ch6list7) shows mock being used to create a fake object
    with a fake attribute.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from unittest import mock'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '>>> m = mock.Mock()'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '>>> m.some_attribute = "hello world" >>> m.some_attribute'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '"hello world"'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-7: Accessing the mock.Mock attribute*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: You can also dynamically create a method on a malleable object, as in [Listing
    6-8](ch06.xhtml#ch6list8) where we create a fake method that always returns 42
    and accepts anything as an argument.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from unittest import mock'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '>>> m = mock.Mock()'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '>>> m.some_method.return_value = 42'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '>>> m.some_method()'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '>>> m.some_method("with", "arguments")'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '42'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-8: Creating methods on a mock.Mock object*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: In just a few lines, your mock.Mock object now has a some_method() method that
    returns 42\. It accepts any kind of argument, and there is no check on what the
    values are—yet.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically created methods can also have (intentional) side effects. Rather
    than being boilerplate methods that just return a value, they can be defined to
    execute useful code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-9](ch06.xhtml#ch6list9) creates a fake method that has the side
    effect of printing the "hello world" string.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from unittest import mock'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '>>> m = mock.Mock()'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '>>> def print_hello():'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '...     print("hello world!")'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '...     return 43'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: ➊ >>> m.some_method.side_effect = print_hello
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '>>> m.some_method()'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: hello world!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '43'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: ➋ >>> m.some_method.call_count
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-9: Creating methods on a mock.Mock object with side effects*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: We assign an entire function to the some_method attribute ➊. This technique
    allows us to implement more complex scenarios in a test because we can plug any
    code needed for testing into a mock object. We then just need to pass this mock
    object to whichever function expects it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The call_count attribute ➋ is a simple way of checking the number of times a
    method has been called.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'The mock library uses the action/assertion pattern: this means that once your
    test has run, it’s up to you to check that the actions you are mocking were correctly
    executed. [Listing 6-10](ch06.xhtml#ch6list10) applies the assert() method to
    our mock objects to perform these checks.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from unittest import mock'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '>>> m = mock.Mock()'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: ➊ >>> m.some_method('foo', 'bar')
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: <Mock name='mock.some_method()' id='26144272'>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: ➋ >>> m.some_method.assert_called_once_with('foo', 'bar')
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '>>> m.some_method.assert_called_once_with(''foo'', ➌mock.ANY)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '>>> m.some_method.assert_called_once_with(''foo'', ''baz'')'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，位于 <module>
- en: File "/usr/lib/python2.7/dist-packages/mock.py", line 846, in assert_called_
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "/usr/lib/python2.7/dist-packages/mock.py"，第 846 行，位于 assert_called_
- en: once_with
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: once_with
- en: return self.assert_called_with(*args, **kwargs)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 self.assert_called_with(*args, **kwargs)
- en: File "/usr/lib/python2.7/dist-packages/mock.py", line 835, in assert_called_
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "/usr/lib/python2.7/dist-packages/mock.py"，第 835 行，位于 assert_called_
- en: with
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: raise AssertionError(msg)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 AssertionError(msg)
- en: 'AssertionError: Expected call: some_method(''foo'', ''baz'')'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'AssertionError: 预期的调用：some_method(''foo'', ''baz'')'
- en: 'Actual call: some_method(''foo'', ''bar'')'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 实际调用：some_method('foo', 'bar')
- en: '*Listing 6-10: Checking method calls*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-10：检查方法调用*'
- en: We create a method with the arguments foo and bar to stand in as our tests by
    calling the method ➊. The usual way to check calls to a mock object is to use
    the assert_called() methods, such as assert_called_once_with() ➋. To these methods,
    you need to pass the values that you expect callers to use when calling your mock
    method. If the values passed are not the ones being used, then mock raises an
    AssertionError. If you don’t know what arguments may be passed, you can use mock.ANY
    as a value ➌; that will match any argument passed to your mock method.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个方法，参数为 foo 和 bar，通过调用该方法 ➊ 来作为我们的测试。检查对 mock 对象的调用通常使用 assert_called()
    方法，比如 assert_called_once_with() ➋。对于这些方法，你需要传入期望调用者在调用你的 mock 方法时使用的值。如果传入的值不是预期的，mock
    会抛出 AssertionError。如果你不知道可能传入什么参数，可以使用 mock.ANY 作为值 ➌；它会匹配传递给你的 mock 方法的任何参数。
- en: Th mock library can also be used to patch some function, method, or object from
    an external module. In [Listing 6-11](ch06.xhtml#ch6list11), we replace the os.unlink()
    function with a fake function we provide.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: mock 库也可以用于替换外部模块中的某个函数、方法或对象。在 [清单 6-11](ch06.xhtml#ch6list11) 中，我们将 os.unlink()
    函数替换为我们提供的一个伪函数。
- en: '>>> from unittest import mock'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from unittest import mock'
- en: '>>> import os'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import os'
- en: '>>> def fake_os_unlink(path):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def fake_os_unlink(path):'
- en: '...     raise IOError("Testing!")'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '...     引发 IOError("测试！")'
- en: '...'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> with mock.patch(''os.unlink'', fake_os_unlink):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 使用 mock.patch(''os.unlink'', fake_os_unlink):'
- en: '...     os.unlink(''foobar'')'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '...     os.unlink(''foobar'')'
- en: '...'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'Traceback (most recent call last):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 2, in <module>
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 2 行，位于 <module>
- en: File "<stdin>", line 2, in fake_os_unlink
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 2 行，位于 fake_os_unlink
- en: 'IOError: Testing!'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 'IOError: 测试！'
- en: '*Listing 6-11: Using mock.patch*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-11：使用 mock.patch*'
- en: When used as a context manager, mock.patch() replaces the target function with
    the function we provide so the code executed inside the context uses that patched
    method. With the mock.patch() method, it’s possible to change any part of an external
    piece of code, making it behave in a way that lets you test all conditions in
    your application, as shown in [Listing 6-12](ch06.xhtml#ch6list12).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当 mock.patch() 作为上下文管理器使用时，它将目标函数替换为我们提供的函数，因此在上下文中执行的代码会使用该修补后的方法。通过 mock.patch()
    方法，您可以更改外部代码的任何部分，使其按您希望的方式行为，从而让您在应用程序中测试所有条件，如 [清单 6-12](ch06.xhtml#ch6list12)
    所示。
- en: from unittest import mock
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: from unittest import mock
- en: import pytest
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: import requests
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: import requests
- en: 'class WhereIsPythonError(Exception):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 'class WhereIsPythonError(Exception):'
- en: pass
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '➊ def is_python_still_a_programming_language():'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def is_python_still_a_programming_language():'
- en: 'try:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: r = requests.get("http://python.org")
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: r = requests.get("http://python.org")
- en: 'except IOError:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 'except IOError:'
- en: pass
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'else:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: 'if r.status_code == 200:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 r.status_code == 200:'
- en: return 'Python is a programming language' in r.content
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 'Python 是一种编程语言' 在 r.content 中
- en: raise WhereIsPythonError("Something bad happened")
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 WhereIsPythonError("发生了某些错误")
- en: 'def get_fake_get(status_code, content):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_fake_get(status_code, content):'
- en: m = mock.Mock()
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: m = mock.Mock()
- en: m.status_code = status_code
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: m.status_code = status_code
- en: m.content = content
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: m.content = content
- en: 'def fake_get(url):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fake_get(url):'
- en: return m
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 m
- en: return fake_get
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 fake_get
- en: 'def raise_get(url):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'def raise_get(url):'
- en: raise IOError("Unable to fetch url %s" % url)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 IOError("无法获取 url %s" % url)
- en: ➋ @mock.patch('requests.get', get_fake_get(
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ @mock.patch('requests.get', get_fake_get(
- en: 200, 'Python is a programming language for sure'))
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 200, 'Python 确实是一种编程语言'))
- en: 'def test_python_is():'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_python_is():'
- en: assert is_python_still_a_programming_language() is True
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: assert is_python_still_a_programming_language() 是 True
- en: '@mock.patch(''requests.get'', get_fake_get('
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '@mock.patch(''requests.get'', get_fake_get('
- en: 200, 'Python is no more a programming language'))
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 200, 'Python 不再是编程语言'))
- en: 'def test_python_is_not():'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_python_is_not():'
- en: assert is_python_still_a_programming_language() is False
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: assert is_python_still_a_programming_language() 是 False
- en: '@mock.patch(''requests.get'', get_fake_get(404, ''Whatever''))'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '@mock.patch(''requests.get'', get_fake_get(404, ''Whatever''))'
- en: 'def test_bad_status_code():'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_bad_status_code():'
- en: 'with pytest.raises(WhereIsPythonError):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 pytest.raises(WhereIsPythonError):'
- en: is_python_still_a_programming_language()
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '@mock.patch(''requests.get'', raise_get)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_ioerror():'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'with pytest.raises(WhereIsPythonError):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: is_python_still_a_programming_language()
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-12: Using mock.patch() to test a set of behaviors*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-12](ch06.xhtml#ch6list12) implements a test suite that searches
    for all instances of the string “Python is a programming language” on the *[http://python.org/](http://python.org/)*
    web page ➊. There is no way to test negative scenarios (where this sentence is
    not on the web page) without modifying the page itself—something we’re not able
    to do, obviously. In this case, we’re using mock to cheat and change the behavior
    of the request so it returns a mocked reply with a fake page that doesn’t contain
    that string. This allows us to test the negative scenario in which *[http://python.org/](http://python.org/)*
    does not contain this sentence, making sure the program handles that case correctly.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: This example uses the decorator version of mock.patch() ➋. Using the decorator
    does not change the mocking behavior, but it is simpler when you need to use mocking
    within the context of an entire test function.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Using mocking, we can simulate any problem, such as a web server returning a
    404 error, an I/O error, or a network latency issue. We can make sure code returns
    the correct values or raises the correct exception in every case, ensuring our
    code always behaves as expected.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '***Revealing Untested Code with coverage***'
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A great complement to unit testing, the coverage tool identifies whether any
    of your code has been missed during testing. It uses code analysis tools and tracing
    hooks to determine which lines of your code have been executed; when used during
    a unit test run, it can show you which parts of your codebase have been crossed
    over and which parts have not. Writing tests is useful, but having a way to know
    what part of your code you may have missed during the testing process is the cherry
    on the cake.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Install the coverage Python module on your system via pip to have access to
    the coverage program command from your shell.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '*The command may also be named python-coverage, if you install coverage through
    your operating system installation software. This is the case on Debian, for example.*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Using coverage in stand-alone mode is straightforward. It can show you parts
    of your programs that are never run and which code might be “dead code,” that
    is, code that could be removed without modifying the normal workflow of the program.
    All the test tools we’ve talked about so far in this chapter are integrated with
    coverage.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: When using pytest, just install the pytest-cov plugin via pip install pytest-pycov
    and add a few option switches to generate a detailed code coverage output, as
    shown in [Listing 6-13](ch06.xhtml#ch6list13).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: $ pytest --cov=gnocchiclient gnocchiclient/tests/unit
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '---------- coverage: platform darwin, python 3.6.4-final-0 -----------'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Name                                          Stmts   Miss Branch BrPart  Cover
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 名称                                          语句数   遗漏  分支  部分分支  覆盖率
- en: '---------------------------'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------------------'
- en: gnocchiclient/__init__.py                         0      0      0      0   100%
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: gnocchiclient/__init__.py                         0      0      0      0   100%
- en: gnocchiclient/auth.py                            51     23      6      0    49%
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: gnocchiclient/auth.py                            51     23      6      0    49%
- en: gnocchiclient/benchmark.py                      175    175     36      0     0%
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: gnocchiclient/benchmark.py                      175    175     36      0     0%
- en: --snip--
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: '---------------------------'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------------------'
- en: TOTAL                                          2040   1868    424      6     8%
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 总计                                          2040   1868    424      6     8%
- en: === passed in 5.00 seconds ===
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: === 在 5.00 秒内通过 ===
- en: '*Listing 6-13: Using coverage with pytest*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-13：在pytest中使用覆盖率*'
- en: The --cov option enables the coverage report at the end of the test run. You
    need to pass the package name as an argument for the plugin to filter the coverage
    report properly. The output includes the lines of code that were not run and therefore
    have no tests. All you need to do now is spawn your favorite text editor and start
    writing tests for that code.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: --cov选项会在测试运行结束时启用覆盖率报告。你需要传递包名作为参数，以便插件正确地过滤覆盖率报告。输出包括未被执行的代码行，因此没有测试。现在你只需启动你喜欢的文本编辑器，开始为这些代码编写测试。
- en: However, coverage goes one better, allowing you to generate clear HTML reports.
    Simply add the --cov-report=html flag, and the *htmlcov* directory from which
    you ran the command will be populated with HTML pages. Each page will show you
    which parts of your source code were or were not run.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，覆盖率更进一步，允许你生成清晰的HTML报告。只需添加--cov-report=html标志，执行该命令的*htmlcov*目录将会填充HTML页面。每个页面都会显示你的源代码的哪些部分已被执行，哪些未被执行。
- en: If you want to be *that* person, you can use the option --cover-fail-under=COVER_MIN_PERCENTAGE,
    which will make the test suite fail if a minimum percentage of the code is not
    executed when the test suite is run. While having a good coverage percentage is
    a decent goal, and while the tool is useful to gain insight into the state of
    your test coverage, defining an arbitrary percentage value does not provide much
    insight. [Figure 6-1](ch06.xhtml#ch6fig1) shows an example of a coverage report
    with the percentage at the top.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想成为*那样的*人，可以使用选项--cover-fail-under=COVER_MIN_PERCENTAGE，当测试套件运行时，如果代码的最低执行百分比未达到，测试套件将会失败。虽然拥有良好的覆盖率是一个不错的目标，且该工具在获得测试覆盖率状态的洞察上非常有用，但定义一个任意的百分比值并不会提供太多有价值的洞察。[图
    6-1](ch06.xhtml#ch6fig1)展示了一个带有顶部百分比的覆盖率报告示例。
- en: For example, a code coverage score of 100 percent is a respectable goal, but
    it does not necessarily mean the code is entirely tested and you can rest. It
    only proves that your whole code path has been run; there is no indication that
    every possible condition has been tested.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，100%的代码覆盖率是一个值得尊敬的目标，但它并不一定意味着代码已经完全测试过，你可以放心了。它只证明了你的所有代码路径都已经运行过；但并没有说明每种可能的条件都已经被测试。
- en: You should use coverage information to consolidate your test suite and add tests
    for any code that is currently not being run. This facilitates later project maintenance
    and increases your code’s overall quality.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用覆盖率信息来整合你的测试套件，并为任何当前未运行的代码添加测试。这有助于以后的项目维护，并提高你代码的整体质量。
- en: '![image](../images/f06-01.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-01.jpg)'
- en: '*Figure 6-1: Coverage of ceilometer.publisher*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：ceilometer.publisher 的覆盖率*'
- en: '**Virtual Environments**'
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**虚拟环境**'
- en: 'Earlier we mentioned the danger that your tests may not capture the absence
    of dependencies. Any application of significant size inevitably depends on external
    libraries to provide features the application needs, but there are many ways external
    libraries might cause issues on your operating system. Here are a few:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，你的测试可能无法捕捉到缺少依赖项的危险。任何具有相当规模的应用程序都会依赖外部库来提供应用程序所需的功能，但外部库可能会在你的操作系统上引发许多问题。以下是其中一些：
- en: Your system does not have the library you need packaged.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的系统没有打包你所需要的库。
- en: Your system does not have the right *version* of the library you need packaged.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的系统没有正确的*版本*的所需库。
- en: You need two different versions of the same library for two different applications.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要为两个不同的应用程序提供同一个库的两个不同版本。
- en: These problems can happen when you first deploy your application or later on,
    while it’s running. Upgrading a Python library installed via your system manager
    might break your application in a snap without warning, for reasons as simple
    as an API change in the library being used by the application.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: The solution is for each application to use a library directory that contains
    all the application’s dependencies. This directory is then used to load the needed
    Python modules rather than the system-installed ones.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Such a directory is known as a *virtual environment*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting Up a Virtual Environment***'
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The tool virtualenv handles virtual environments automatically for you. Until
    Python 3.2, you’ll find it in the virtualenv package that you can install using
    pip install virtualenv. If you use Python 3.3 or later, it’s available directly
    via Python under the venv name.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the module, load it as the main program with a destination directory
    as its argument, like so:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: $ python3 -m venv myvenv
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: $ ls foobar
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: bin        include    lib        pyvenv.cfg
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Once run, venv creates a *lib/pythonX.Y* directory and uses it to install pip
    into the virtual environment, which will be useful to install further Python packages.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then activate the virtual environment by “sourcing” the activate command.
    Use the following on Posix systems:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: $ source myvenv/bin/activate
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows systems, use this code:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: \myvenv\Scripts\activate
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once you do that, your shell prompt should appear prefixed by the name of your
    virtual environment. Executing python will call the version of Python that has
    been copied into the virtual environment. You can check that it’s working by reading
    the sys.path variable and checking that it has your virtual environment directory
    as its first component.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'You can stop and leave the virtual environment at any time by calling the deactivate
    command:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: $ deactivate
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it. Also note that you are not forced to run activate if you want to
    use the Python installed in your virtual environment just once. Calling the python
    binary will also work:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: $ myvenv/bin/python
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, while we’re in our activated virtual environment, we do not have access
    to any of the modules installed and available on the main system. That is the
    point of using a virtual environment, but it does mean we probably need to install
    the packages we need. To do that, use the standard pip command to install each
    package, and the packages will install in the right place, without changing anything
    about your system:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: $ source myvenv/bin/activate
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: (myvenv) $ pip install six
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Downloading/unpacking six
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Downloading six-1.4.1.tar.gz
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Running setup.py egg_info for package six
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing collected packages: six'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Running setup.py install for six
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Successfully installed six
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up...
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We can install all the libraries we need and then run our application
    from this virtual environment, without breaking our system. It’s easy to see how
    we can script this to automate the installation of a virtual environment based
    on a list of dependencies, as in [Listing 6-14](ch06.xhtml#ch6list14).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: virtualenv myappvenv
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: source myappvenv/bin/activate
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: pip install -r requirements.txt
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: deactivate
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-14: Automatic virtual environment creation*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: It can still be useful to have access to your system-installed packages, so
    virtualenv allows you to enable them when creating your virtual environment by
    passing the --system-site-packages flag to the virtualenv command.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Inside myvenv, you will find a *pyvenv.cfg*, the configuration file for this
    environment. It doesn’t have a lot of configuration options by default. You should
    recognize include-system-site-package, whose purpose is the same as the --system-site-packages
    of virtualenv that we described earlier.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: As you might guess, virtual environments are incredibly useful for automated
    runs of unit test suites. Their use is so widespread that a particular tool has
    been built to address it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '***Using virtualenv with tox***'
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the central uses of virtual environments is to provide a clean environment
    for running unit tests. It would be detrimental if you were under the impression
    that your tests were working, when they were not, for example, respecting the
    dependency list.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to ensure you’re accounting for all the dependencies would be to write
    a script to deploy a virtual environment, install setuptools, and then install
    all of the dependencies required for both your application/library runtime and
    unit tests. Luckily, this is such a popular use case that an application dedicated
    to this task has already been built: tox.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: The tox management tool aims to automate and standardize how tests are run in
    Python. To that end, it provides everything needed to run an entire test suite
    in a clean virtual environment, while also installing your application to check
    that the installation works.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using tox, you need to provide a configuration file named *tox.ini*
    that should be placed in the root directory of your project, beside your *setup.py*
    file:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: $ touch tox.ini
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then run tox successfully:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '% tox'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'GLOB sdist-make: /home/jd/project/setup.py'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'python create: /home/jd/project/.tox/python'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'python inst: /home/jd/project/.tox/dist/project-1.zip'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: ____________________ summary _____________________
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'python: commands succeeded'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: congratulations :)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: In this instance, tox creates a virtual environment in *.tox/python* using the
    default Python version. It uses *setup.py* to create a distribution of your package,
    which it then installs inside this virtual environment. No commands are run, because
    we did not specify any in the configuration file. This alone is not particularly
    useful.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change this default behavior by adding a command to run inside our test
    environment. Edit *tox.ini* to include the following:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[testenv]'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: commands=pytest
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'Now tox runs the command pytest. However, since we do not have pytest installed
    in the virtual environment, this command will likely fail. We need to list pytest
    as a dependency to be installed:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[testenv]'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: deps=pytest
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: commands=pytest
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: When run now, tox re-creates the environment, installs the new dependency, and
    runs the command pytest, which executes all of the unit tests. To add more dependencies,
    you can either list them in the deps configuration option, as is done here, or
    use the -rfile syntax to read from a file.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '***Re-creating an Environment***'
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you’ll need to re-create an environment to, for example, ensure things
    work as expected when a new developer clones the source code repository and runs
    tox for the first time. For this, tox accepts a --recreate option that will rebuild
    the virtual environment from scratch based on parameters you lay out.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'You define the parameters for all virtual environments managed by tox in the
    [testenv] section of *tox.ini*. And, as mentioned, tox can manage multiple Python
    virtual environments—indeed, it is possible to run our tests under a Python version
    other than the default one by passing the -e flag to tox, like so:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '% tox -e py26'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'GLOB sdist-make: /home/jd/project/setup.py'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'py26 create: /home/jd/project/.tox/py26'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'py26 installdeps: nose'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'py26 inst: /home/jd/project/.tox/dist/rebuildd-1.zip'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'py26 runtests: commands[0] | pytests'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: == test session starts ==
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: === 5 passed in 4.87 seconds ====
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, tox simulates any environment that matches an existing Python version:
    py24, py25, py26, py27, py30, py31, py32, py33, py34, py35, py36, py37, jython,
    and pypy! Furthermore, you can define your own environments. You just need to
    add another section named [testenv:_envname_]. If you want to run a particular
    command for just one of the environments, you can do so easily by listing the
    following in the *tox.ini* file:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[testenv]'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: deps=pytest
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: commands=pytest
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[testenv:py36-coverage]'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: deps={[testenv]deps}
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: pytest-cov
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: commands=pytest --cov=myproject
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'By using pytest --cov=myproject under the py36-coverage section as shown here,
    you override the commands for the py36-coverage environment, meaning when you
    run tox -e py36-coverage, pytest is installed as part of the dependencies, but
    the command pytest is actually run instead with the coverage option. For that
    to work, the pytest-cov extension must be installed: to this end, we replace the
    deps value with the deps from testenv and add the pytest-cov dependency. Variable
    interpolation is also supported by tox, so you can refer to any other field from
    the *tox.ini* file and use it as a variable, the syntax being {[env_name]variable_name}.
    This allows us to avoid repeating the same things over and over again.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Different Python Versions***'
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also create a new environment with an unsupported version of Python
    right away with the following in *tox.ini*:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[testenv]'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: deps=pytest
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: commands=pytest
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[testenv:py21]'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: basepython=python2.1
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: When we run this, it will now (attempt to) use Python 2.1 to run the test suite—although
    since it is very unlikely you have this ancient Python version installed on your
    system, I doubt this would work for you!
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s likely that you’ll want to support multiple Python versions, in which
    case it would be useful to have tox run all the tests for all the Python versions
    you want to support by default. You can do this by specifying the environment
    list you want to use when tox is run without arguments:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[tox]'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: envlist=py35,py36,pypy
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[testenv]'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: deps=pytest
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: commands=pytest
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: When tox is launched without any further arguments, all four environments listed
    are created, populated with the dependencies and the application, and then run
    with the command pytest.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '***Integrating Other Tests***'
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also use tox to integrate tests like flake8, as discussed in [Chapter
    1](ch01.xhtml#ch01). The following *tox.ini* file provides a PEP 8 environment
    that will install flake8 and run it:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[tox]'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: envlist=py35,py36,pypy,pep8
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[testenv]'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: deps=pytest
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: commands=pytest
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[testenv:pep8]'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: deps=flake8
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: commands=flake8
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the pep8 environment is run using the default version of Python,
    which is probably fine, though you can still specify the basepython option if
    you want to change that.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: When running tox, you’ll notice that all the environments are built and run
    sequentially. This can make the process very long, but since virtual environments
    are isolated, nothing prevents you from running tox commands in parallel. This
    is exactly what the detox package does, by providing a detox command that runs
    all of the default environments from *envlist* in parallel. You should pip install
    it!
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing Policy**'
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Embedding testing code in your project is an excellent idea, but how that code
    is run is also extremely important. Too many projects have test code lying around
    that fails to run for some reason or other. This topic is not strictly limited
    to Python, but I consider it important enough to emphasize here: you should have
    a zero-tolerance policy regarding untested code. No code should be merged without
    a proper set of unit tests to cover it.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: The minimum you should aim for is that each of the commits you push passes all
    the tests. Automating this process is even better. For example, OpenStack relies
    on a specific workflow based on *Gerrit* (a web-based code review service) and
    *Zuul* (a continuous integration and delivery service). Each commit pushed goes
    through the code review system provided by Gerrit, and Zuul is in charge of running
    a set of testing jobs. Zuul runs the unit tests and various higher-level functional
    tests for each project. This code review, which is executed by a couple of developers,
    makes sure all code committed has associated unit tests.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using the popular GitHub hosting service, *Travis CI* is a tool that
    allows you to run tests after each push or merge or against pull requests that
    are submitted. While it is unfortunate that this testing is done post-push, it’s
    still a fantastic way to track regressions. Travis supports all significant Python
    versions out of the box, and it can be customized significantly. Once you’ve activated
    Travis on your project via the web interface at *[https://www.travis-ci.org/](https://www.travis-ci.org/)*,
    just add a *.travis.yml* file that will determine how the tests are run. [Listing
    6-15](ch06.xhtml#ch6list15) shows an example of a .*travis.yml* file.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'language: python'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'python:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '- "2.7"'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '- "3.6"'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: command to install dependencies
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'install: "pip install -r requirements.txt --use-mirrors"'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: command to run tests
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'script: pytest'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-15: A .travis.yml example file*'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: With this file in place in your code repository and Travis enabled, the latter
    will spawn a set of jobs to test your code with the associated unit tests. It’s
    easy to see how you can customize this by simply adding dependencies and tests.
    Travis is a paid service, but the good news is that for open source projects,
    it’s entirely free!
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: The tox-travis package (*[https://pypi.python.org/pypi/tox-travis/](https://pypi.python.org/pypi/tox-travis/)*)
    is also worth looking into, as it will polish the integration between tox and
    Travis by running the correct tox target depending on the Travis environment being
    used. [Listing 6-16](ch06.xhtml#ch6list16) shows an example of a *.travis.yml*
    file that will install tox-travis before running tox.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'sudo: false'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'language: python'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'python:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '- "2.7"'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '- "3.4"'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 'install: pip install tox-travis'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'script: tox'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-16: A .travis.yml example file with tox-travis*'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Using tox-travis, you can simply call tox as the script on Travis, and it will
    call tox with the environment you specify here in the *.travis.yml* file, building
    the necessary virtual environment, installing the dependency, and running the
    commands you specified in *tox.ini*. This makes it easy to use the same workflow
    both on your local development machine and on the Travis continuous integration
    platform.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: These days, wherever your code is hosted, it is always possible to apply some
    automatic testing of your software and to make sure your project is moving forward,
    not being held back by the addition of bugs.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '**Robert Collins on Testing**'
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Robert Collins is, among other things, the original author of the *Bazaar* distributed
    version control system. Today, he is a Distinguished Technologist at HP Cloud
    Services, where he works on OpenStack. Robert is also the author of many of the
    Python tools described in this book, such as fixtures, testscenarios, testrepository,
    and even python-subunit—you may have used one of his programs without knowing
    it!
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '**What kind of testing policy would you advise using? Is it ever acceptable
    not to test code?**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'I think testing is an engineering trade-off: you must consider the likelihood
    of a failure slipping through to production undetected, the cost and size of an
    undetected failure, and cohesion of the team doing the work. Take OpenStack, which
    has 1,600 contributors: it’s difficult to work with a nuanced policy with so many
    people with their own opinions. Generally speaking, a project needs some automated
    testing to check that the code will do what it is intended to do, and that what
    it is intended to do is what is needed. Often that requires functional tests that
    might be in different codebases. Unit tests are excellent for speed and pinning
    down corner cases. I think it is okay to vary the balance between styles of testing,
    as long as there is testing.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'Where the cost of testing is very high and the returns are very low, I think
    it’s fine to make an informed decision not to test, but that situation is relatively
    rare: most things can be tested reasonably cheaply, and the benefit of catching
    errors early is usually quite high.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the best strategies when writing Python code to make testing manageable
    and improve the quality of the code?**'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Separate out concerns and don’t do multiple things in one place; this makes
    reuse natural, and that makes it easier to put test doubles in place. Take a purely
    functional approach when possible; for example, in a single method either calculate
    something or change some state, but avoid doing both. That way you can test all
    of the calculating behaviors without dealing with state changes, such as writing
    to a database or talking to an HTTP server. The benefit works the other way around
    too—you can replace the calculation logic for tests to provoke corner case behavior
    and use mocks and test doubles to check that the expected state propagation happens
    as desired. The most heinous things to test are deeply layered stacks with complex
    cross-layer behavioral dependencies. There you want to evolve the code so that
    the contract between layers is simple, predictable, and—most usefully for testing—replaceable.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '**What’s the best way to organize unit tests in source code?**'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Have a clear hierarchy, like *$ROOT/$PACKAGE/tests*. I tend to do just one hierarchy
    for a whole source tree, for example *$ROOT/$PACKAGE/$SUBPACKAGE/tests*.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'Within tests, I often mirror the structure of the rest of the source tree:
    *$ROOT/$PACKAGE/foo.py* would be tested in *$ROOT/$PACKAGE/tests/test_foo.py*.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the tree should not import from the tests tree, except perhaps in
    the case of a test_suite/load_tests function in the top level __init__. This permits
    you to easily detach the tests for small-footprint installations.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '**What do you see as the future of unit-testing libraries and frameworks in
    Python?**'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'The significant challenges I see are these:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: The continued expansion of parallel capabilities in new machines, like phones
    with four CPUs. Existing unit test internal APIs are not optimized for parallel
    workloads. My work on the StreamResult Java class is aimed directly at resolving
    this.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More complex scheduling support—a less ugly solution for the problems that class
    and module-scoped setup aim at.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finding some way to consolidate the vast variety of frameworks we have today:
    for integration testing, it would be great to be able to get a consolidated view
    across multiple projects that have different test runners in use.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
