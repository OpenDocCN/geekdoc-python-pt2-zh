- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**UNIT TESTING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Many find unit testing to be arduous and time-consuming, and some people and
    projects have no testing policy. This chapter assumes that you see the wisdom
    of unit testing! Writing code that is not tested is fundamentally useless, as
    there’s no way to conclusively prove that it works. If you need convincing, I
    suggest you start by reading about the benefits of test-driven development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人觉得单元测试既繁琐又耗时，也有一些人和项目没有测试政策。本章假设你已经认识到单元测试的智慧！编写没有经过测试的代码本质上是没有意义的，因为无法确凿证明它能正常工作。如果你需要说服自己，我建议你从阅读测试驱动开发的好处开始。
- en: In this chapter you’ll learn about the Python tools you can use to construct
    a comprehensive suite of tests that will make testing simpler and more automated.
    We’ll talk about how you can use tools to make your software rock solid and regression-free.
    We’ll cover creating reusable test objects, running tests in parallel, revealing
    untested code, and using virtual environments to make sure your tests are clean,
    as well as some other good-practice methods and ideas.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用Python工具构建一个全面的测试套件，使测试更加简便和自动化。我们将讨论如何利用工具使你的软件更加稳定、无回归。我们将涉及创建可重用的测试对象、并行运行测试、揭示未测试的代码，以及使用虚拟环境确保你的测试是干净的，还有一些其他的最佳实践和想法。
- en: '**The Basics of Testing**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**测试基础**'
- en: Writing and running unit tests is uncomplicated in Python. The process is not
    intrusive or disruptive, and unit testing will greatly help you and other developers
    in maintaining your software. Here I’ll discuss some of the absolute basics of
    testing that will make things easier for you.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中编写和运行单元测试并不复杂。这个过程既不具侵入性，也不会造成干扰，单元测试会极大地帮助你和其他开发者维护软件。在这里，我将讨论一些测试的基础知识，帮助你更轻松地进行测试。
- en: '***Some Simple Tests***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一些简单的测试***'
- en: First, you should store tests inside a tests submodule of the application or
    library they apply to. Doing so will allow you to ship the tests as part of your
    module so that they can be run or reused by anyone—even after your software is
    installed—without necessarily using the source package. Making the tests a submodule
    of your main module also prevents them from being installed by mistake in a top-level
    tests module.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该将测试存储在适用于其所在应用或库的tests子模块中。这样做将使你能够将测试作为模块的一部分进行发布，以便任何人都可以运行或重用这些测试——即使软件已经安装——而不必使用源代码包。将测试作为主模块的子模块也能防止它们在顶层的tests模块中被误安装。
- en: Using a hierarchy in your test tree that mimics the hierarchy of your module
    tree will make the tests more manageable. This means that the tests covering the
    code of *mylib/foobar.py* should be stored inside *mylib/tests/test_foobar.py*.
    Consistent nomenclature makes things simpler when you’re looking for the tests
    related to a particular file. [Listing 6-1](ch06.xhtml#ch6list1) shows the simplest
    unit test you can write.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个模拟你模块树层次结构的测试树层次结构会让测试更加易于管理。这意味着，覆盖*mylib/foobar.py*代码的测试应存储在*mylib/tests/test_foobar.py*中。统一的命名法会让你在查找与特定文件相关的测试时更加简便。[列表
    6-1](ch06.xhtml#ch6list1)展示了你可以编写的最简单的单元测试。
- en: 'def test_true():'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_true():'
- en: assert True
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: assert True
- en: '*Listing 6-1: A really simple test in test_true.py*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-1: 在test_true.py中的一个非常简单的测试*'
- en: This will simply assert that the behavior of the program is what you expect.
    To run this test, you need to load the *test_true.py* file and run the test_true()
    function defined within.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地断言程序的行为符合你的预期。要运行这个测试，你需要加载*test_true.py*文件并运行其中定义的test_true()函数。
- en: However, writing and running an individual test for each of your test files
    and functions would be a pain. For small projects with simple usage, the pytest
    package comes to the rescue—once installed via pip, pytest provides the pytest
    command, which loads every file whose name starts with *test_* and then executes
    all functions within that start with test_.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为每个测试文件和函数编写和运行单独的测试会是一件麻烦事。对于简单用法的小型项目，pytest包能够提供帮助——通过pip安装后，pytest提供pytest命令，加载所有文件名以*test_*开头的文件，并执行所有以test_开头的函数。
- en: 'With just the *test_true.py* file in our source tree, running pytest gives
    us the following output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭我们源代码树中的*test_true.py*文件，运行pytest会给出以下输出：
- en: $ pytest -v test_true.py
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: $ pytest -v test_true.py
- en: ========================== test session starts ===========================
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ========================== 测试会话开始 ===========================
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 --
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 --
- en: /usr/local/opt/python/bin/python3.6
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: /usr/local/opt/python/bin/python3.6
- en: 'cachedir: .cache'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存目录：.cache
- en: 'rootdir: examples, inifile:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根目录：examples, 配置文件：
- en: collected 1 item
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 收集到 1 项
- en: test_true.py::test_true PASSED                                     [100%]
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: test_true.py::test_true 测试通过                                     [100%]
- en: ======================== 1 passed in 0.01 seconds ========================
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ======================== 1 个通过，耗时 0.01 秒 ========================
- en: The -v option tells pytest to be verbose and print the name of each test run
    on a separate line. If a test fails, the output changes to indicate the failure,
    accompanied by the whole traceback.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: -v 选项告诉 pytest 显示详细信息，并在每个测试运行时单独打印测试名称。如果测试失败，输出会更改以指示失败，并附带完整的回溯信息。
- en: Let’s add a failing test this time, as shown in [Listing 6-2](ch06.xhtml#ch6list2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们添加一个失败的测试，如 [清单 6-2](ch06.xhtml#ch6list2) 所示。
- en: 'def test_false():'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_false():'
- en: assert False
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: assert False
- en: '*Listing 6-2: A failing test in test_true.py*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-2：test_true.py 中的失败测试*'
- en: 'If we run the test file again, here’s what happens:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行测试文件，结果会是这样：
- en: $ pytest -v test_true.py
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: $ pytest -v test_true.py
- en: ========================== test session starts ===========================
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ========================== 测试会话开始 ===========================
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 平台 darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
- en: local/opt/python/bin/python3.6
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: local/opt/python/bin/python3.6
- en: 'cachedir: .cache'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存目录：.cache
- en: 'rootdir: examples, inifile:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根目录：examples, 配置文件：
- en: collected 2 items
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 收集到 2 项
- en: test_true.py::test_true PASSED                                     [ 50%]
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: test_true.py::test_true 测试通过                                     [ 50%]
- en: test_true.py::test_false FAILED                                    [100%]
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: test_true.py::test_false 测试失败                                    [100%]
- en: ================================ FAILURES ================================
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ================================ 测试失败 ================================
- en: _______________________________ test_false _______________________________
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: _______________________________ test_false _______________________________
- en: 'def test_false():'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_false():'
- en: '>       assert False'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '>       assert False'
- en: E       assert False
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: E       assert False
- en: 'test_true.py:5: AssertionError'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 'test_true.py:5: 断言错误'
- en: =================== 1 failed, 1 passed in 0.07 seconds ===================
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: =================== 1 个失败，1 个通过，耗时 0.07 秒 ===================
- en: A test fails as soon as an AssertionError exception is raised; our assert test
    will raise an AssertionError when its argument is evaluated to something false
    (False, None, 0, etc.). If any other exception is raised, the test also errors
    out.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当断言错误异常被抛出时，测试会立即失败；我们的 assert 测试会在其参数评估为假（False、None、0 等）时抛出断言错误。如果抛出任何其他异常，测试也会失败。
- en: Simple, isn’t it? While simplistic, a lot of small projects use this approach
    and it works very well. Those projects require no tools or libraries other than
    pytest and thus can rely on simple assert tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吧？尽管这种方法很简化，但很多小项目都使用这种方式，并且效果很好。这些项目除了 pytest 外不需要其他工具或库，因此可以依赖简单的 assert
    测试。
- en: 'As you start to write more sophisticated tests, pytest will help you understand
    what’s wrong in your failing tests. Imagine the following test:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写更复杂的测试时，pytest 将帮助你理解失败测试的原因。假设以下是一个测试：
- en: 'def test_key():'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_key():'
- en: a = ['a', 'b']
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: a = ['a', 'b']
- en: b = ['b']
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: b = ['b']
- en: assert a == b
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: assert a == b
- en: 'When pytest is run, it gives the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 pytest 时，它会给出如下输出：
- en: $ pytest test_true.py
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: $ pytest test_true.py
- en: ========================== test session starts =========================== platform
    darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ========================== 测试会话开始 =========================== 平台 darwin -- Python
    3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0
- en: 'rootdir: /Users/jd/Source/python-book/examples, inifile:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根目录：/Users/jd/Source/python-book/examples, 配置文件：
- en: 'plugins: celery-4.1.0'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 插件：celery-4.1.0
- en: collected 1 item
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 收集到 1 项
- en: test_true.py F                                                     [100%]
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: test_true.py 测试失败                                                 [100%]
- en: ================================ FAILURES ================================
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ================================ 测试失败 ================================
- en: ________________________________ test_key ________________________________
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ________________________________ test_key ________________________________
- en: 'def test_key():'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_key():'
- en: a = ['a', 'b']
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: a = ['a', 'b']
- en: b = ['b']
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: b = ['b']
- en: '>       assert a == b'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '>       assert a == b'
- en: 'E       AssertionError: assert [''a'', ''b''] == [''b'']'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: E       断言错误：assert ['a', 'b'] == ['b']
- en: 'E         At index 0 diff: ''a'' != ''b'''
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: E         在索引 0 处有差异：'a' != 'b'
- en: 'E         Left contains more items, first extra item: ''b'''
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: E         左侧包含更多项，第一个额外项：'b'
- en: E         Use -v to get the full diff
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: E         使用 -v 获取完整的差异
- en: 'test_true.py:10: AssertionError'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'test_true.py:10: 断言错误'
- en: ======================== 1 failed in 0.07 seconds ========================
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ======================== 1 个失败，耗时 0.07 秒 ========================
- en: This tells us that a and b are different and that this test does not pass. It
    also tells us exactly how they are different, making it easy to fix the test or
    code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们 a 和 b 是不同的，并且此测试未通过。它还准确地告诉我们它们之间的不同之处，使得修复测试或代码变得容易。
- en: '***Skipping Tests***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跳过测试***'
- en: If a test cannot be run, you will probably want to skip that test—for example,
    you may wish to run a test conditionally based on the presence or absence of a
    particular library. To that end, you can use the pytest.skip() function, which
    will mark the test as skipped and move on to the next one. The pytest.mark.skip
    decorator skips the decorated test function unconditionally, so you’ll use it
    when a test always needs to be skipped. [Listing 6-3](ch06.xhtml#ch6list3) shows
    how to skip a test using these methods.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个测试无法运行，你可能想要跳过该测试。例如，你可能希望根据某个特定库是否存在来有条件地运行一个测试。为此，你可以使用 pytest.skip()
    函数，它会将测试标记为跳过，并继续执行下一个测试。pytest.mark.skip 装饰器会无条件跳过被装饰的测试函数，所以当一个测试总是需要被跳过时，你会使用它。[Listing
    6-3](ch06.xhtml#ch6list3) 显示了如何使用这些方法跳过一个测试。
- en: import pytest
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: 'try:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: import mylib
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: import mylib
- en: 'except ImportError:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'except ImportError:'
- en: mylib = None
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: mylib = None
- en: '@pytest.mark.skip("Do not run this")'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.mark.skip("不要运行这个")'
- en: 'def test_fail():'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_fail():'
- en: assert False
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: assert False
- en: '@pytest.mark.skipif(mylib is None, reason="mylib is not available")'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.mark.skipif(mylib is None, reason="mylib 不可用")'
- en: 'def test_mylib():'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_mylib():'
- en: 'assert mylib.foobar() == 42 def test_skip_at_runtime():'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'assert mylib.foobar() == 42 def test_skip_at_runtime():'
- en: 'if True:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'if True:'
- en: pytest.skip("Finally I don't want to run it")
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: pytest.skip("最终我不想运行它")
- en: '*Listing 6-3: Skipping tests*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-3: 跳过测试*'
- en: 'When executed, this test file will output the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，这个测试文件将输出以下内容：
- en: $ pytest -v examples/test_skip.py
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: $ pytest -v examples/test_skip.py
- en: ========================== test session starts ===========================
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ========================== 测试会话开始 ===========================
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 平台 darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
- en: local/opt/python/bin/python3.6
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: local/opt/python/bin/python3.6
- en: 'cachedir: .cache'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'cachedir: .cache'
- en: 'rootdir: examples, inifile:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'rootdir: examples, inifile:'
- en: collected 3 items
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 已收集 3 项
- en: examples/test_skip.py::test_fail SKIPPED
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: examples/test_skip.py::test_fail SKIPPED
- en: '[ 33%]'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 33%]'
- en: examples/test_skip.py::test_mylib SKIPPED
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: examples/test_skip.py::test_mylib SKIPPED
- en: '[ 66%]'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 66%]'
- en: examples/test_skip.py::test_skip_at_runtime SKIPPED
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: examples/test_skip.py::test_skip_at_runtime SKIPPED
- en: '[100%]'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[100%]'
- en: ================= 3 skipped in 0.01 seconds =================
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ================= 3 个测试在 0.01 秒内被跳过 =================
- en: The output of the test run in [Listing 6-3](ch06.xhtml#ch6list3) indicates that,
    in this case, all the tests have been skipped. This information allows you to
    ensure you didn’t accidentally skip a test you expected to run.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 6-3](ch06.xhtml#ch6list3) 中的测试运行输出显示，在这种情况下，所有测试都被跳过了。这些信息可以帮助你确保没有意外跳过你本希望运行的测试。
- en: '***Running Particular Tests***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行特定的测试***'
- en: When using pytest, you often want to run only a particular subset of your tests.
    You can select which tests you want to run by passing their directory or files
    as an argument to the pytest command line. For example, calling pytest test_one.py
    will only run the *test_one.py* test. Pytest also accepts a directory as argument,
    and in that case, it will recursively scan the directory and run any file that
    matches the *test_*.py* pattern.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 pytest 时，你经常只想运行某些特定的测试子集。你可以通过将它们的目录或文件作为参数传递给 pytest 命令行来选择要运行的测试。例如，调用
    pytest test_one.py 将只运行 *test_one.py* 测试。Pytest 也接受目录作为参数，在这种情况下，它会递归地扫描目录并运行任何匹配
    *test_*.py* 模式的文件。
- en: You can also add a filter with the -k argument on the command line in order
    to execute only the test matching a name, as shown in [Listing 6-4](ch06.xhtml#ch6list4).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在命令行中使用 -k 参数添加过滤器，以便只执行匹配某个名称的测试，如 [Listing 6-4](ch06.xhtml#ch6list4) 所示。
- en: $ pytest -v examples/test_skip.py -k test_fail
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: $ pytest -v examples/test_skip.py -k test_fail
- en: ========================== test session starts ===========================
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ========================== 测试会话开始 ===========================
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 平台 darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
- en: local/opt/python/bin/python3.6
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: local/opt/python/bin/python3.6
- en: 'cachedir: .cache'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'cachedir: .cache'
- en: 'rootdir: examples, inifile:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'rootdir: examples, inifile:'
- en: collected 3 items
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 已收集 3 项
- en: examples/test_skip.py::test_fail SKIPPED
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: examples/test_skip.py::test_fail SKIPPED
- en: '[100%] === 2 tests deselected ==='
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[100%] === 2 个测试被取消选择 ==='
- en: === 1 skipped, 2 deselected in 0.04 seconds ===
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: === 1 个测试被跳过，2 个被取消选择，在 0.04 秒内完成 ===
- en: '*Listing 6-4: Filtering tests run by name*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-4: 按名称过滤运行的测试*'
- en: 'Names are not always the best way to filter which tests will run. Commonly,
    a developer would group tests by functionalities or types instead. Pytest provides
    a dynamic marking system that allows you to mark tests with a keyword that can
    be used as a filter. To mark tests in this way, use the -m option. If we set up
    a couple of tests like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 名称并不总是过滤哪些测试会运行的最佳方式。通常，开发人员会根据功能或类型将测试分组。Pytest 提供了一种动态标记系统，允许您使用关键字标记测试，作为筛选器。要以这种方式标记测试，请使用
    -m 选项。如果我们设置了几个这样的测试：
- en: import pytest
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: '@pytest.mark.dicttest'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.mark.dicttest'
- en: 'def test_something():'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_something():'
- en: a = ['a', 'b']
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: a = ['a', 'b']
- en: assert a == a
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: assert a == a
- en: 'def test_something_else():'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_something_else():'
- en: assert False
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: assert False
- en: 'we can use the -m argument with pytest to run only one of those tests:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 -m 参数与 pytest 一起运行其中一个测试：
- en: $ pytest -v test_mark.py -m dicttest
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: $ pytest -v test_mark.py -m dicttest
- en: === test session starts ===
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: === 测试会话开始 ===
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0 -- /usr/
- en: local/opt/python/bin/python3.6
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: local/opt/python/bin/python3.6
- en: 'cachedir: .cache'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'cachedir: .cache'
- en: 'rootdir: examples, inifile:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'rootdir: examples, inifile:'
- en: collected 2 items
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 收集了 2 个项目
- en: test_mark.py::test_something PASSED
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: test_mark.py::test_something 通过
- en: '[100%]'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[100%]'
- en: === 1 tests deselected ===
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: === 1 个测试被取消选择 ===
- en: === 1 passed, 1 deselected in 0.01 seconds ===
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: === 1 通过，1 被取消选择，耗时 0.01 秒 ===
- en: 'The -m marker accepts more complex queries, so we can also run all tests that
    are *not* marked:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: -m 标记接受更复杂的查询，因此我们也可以运行所有*未*标记的测试：
- en: $ pytest test_mark.py -m 'not dicttest'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: $ pytest test_mark.py -m 'not dicttest'
- en: === test session starts ===
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: === 测试会话开始 ===
- en: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: platform darwin -- Python 3.6.4, pytest-3.3.2, py-1.5.2, pluggy-0.6.0
- en: 'rootdir: examples, inifile:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'rootdir: examples, inifile:'
- en: collected 2 items
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 收集了 2 个项目
- en: test_mark.py F
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: test_mark.py F
- en: '[100%]'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[100%]'
- en: === FAILURES ===
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: === 失败的测试 ===
- en: 'test_something_else def test_something_else():'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'test_something_else def test_something_else():'
- en: '>       assert False'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '>       assert False'
- en: E       assert False
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: E       assert False
- en: 'test_mark.py:10: AssertionError'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'test_mark.py:10: AssertionError'
- en: === 1 tests deselected ===
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: === 1 个测试被取消选择 ===
- en: === 1 failed, 1 deselected in 0.07 seconds ===
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: === 1 个失败，1 被取消选择，耗时 0.07 秒 ===
- en: Here pytest executed every test that was not marked as dicttest—in this case,
    the test_something_else test, which failed. The remaining marked test, test_something,
    was not executed and so is listed as deselected.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 pytest 执行了所有未标记为 dicttest 的测试——在此案例中是 test_something_else 测试，它失败了。剩余的标记测试
    test_something 没有执行，因此列为取消选择。
- en: Pytest accepts complex expressions composed of the or, and, and not keywords,
    allowing you to do more advanced filtering.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest 接受由 or、and 和 not 关键字组成的复杂表达式，使您能够进行更高级的筛选。
- en: '***Running Tests in Parallel***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***并行运行测试***'
- en: Test suites can take a long time to run. It’s not uncommon for a full suite
    of unit tests to take tens of minutes to run in large software projects. By default,
    pytest runs all tests serially, in an undefined order. Since most computers have
    several CPUs, you can usually speed things up if you split the list of tests and
    run them on multiple CPUs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件可能需要很长时间才能完成。对于大型软件项目来说，完整的单元测试套件可能需要花费数十分钟来运行。默认情况下，pytest 会按顺序运行所有测试，但顺序是未定义的。由于大多数计算机都配备了多个
    CPU，通常可以通过将测试列表分割并在多个 CPU 上运行来加快速度。
- en: To handle this approach, pytest provides the plugin pytest-xdist, which you
    can install with pip. This plugin extends the pytest command line with the --numprocesses
    argument (shortened as -n), which accepts as its argument the number of CPUs to
    use. Running pytest -n 4 would run your test suite using four parallel processes,
    balancing the load across the available CPUs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种方法，pytest 提供了插件 pytest-xdist，您可以通过 pip 安装。该插件通过 --numprocesses 参数（缩写为
    -n）扩展了 pytest 命令行，该参数接受的值是要使用的 CPU 数量。运行 pytest -n 4 将使用四个并行进程运行您的测试套件，均衡地分配负载到可用的
    CPU 上。
- en: Because the number of CPUs can change from one computer to another, the plugin
    also accepts the auto keyword as a value. In this case, it will probe the machine
    to retrieve the number of CPUs available and start this number of processes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 CPU 的数量会因计算机而异，所以插件也接受 auto 关键字作为值。在这种情况下，它将探测机器以获取可用的 CPU 数量，并启动这个数量的进程。
- en: '***Creating Objects Used in Tests with Fixtures***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Fixtures 创建测试中使用的对象***'
- en: In unit testing, you’ll often need to execute a set of common instructions before
    and after running a test, and those instructions will use certain components.
    For example, you might need an object that represents the configuration state
    of your application, and you’ll likely want that object to be initialized before
    each test, then reset to its default values when the test is achieved. Similarly,
    if your test relies on the temporary creation of a file, the file must be created
    before the test starts and deleted once the test is done. These components, known
    as *fixtures*, are set up before a test and cleaned up after the test has finished.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，你通常需要在运行测试前后执行一组常见的指令，这些指令将使用某些组件。例如，你可能需要一个代表应用程序配置状态的对象，并且希望在每个测试前初始化该对象，测试完成后将其重置为默认值。同样，如果测试依赖于临时创建文件，文件必须在测试开始前创建，并在测试完成后删除。这些组件被称为*fixtures*，它们在测试前设置，并在测试完成后清理。
- en: With pytest, fixtures are defined as simple functions. The fixture function
    should return the desired object(s) so that a test using that fixture can use
    that object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在pytest中，fixtures被定义为简单的函数。fixture函数应该返回所需的对象，以便使用该fixture的测试可以使用该对象。
- en: 'Here’s a simple fixture:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的fixture：
- en: import pytest
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: '@pytest.fixture'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def database():'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'def database():'
- en: return <some database connection>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: return <某个数据库连接>
- en: 'def test_insert(database):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_insert(database):'
- en: database.insert(123)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: database.insert(123)
- en: The database fixture is automatically used by any test that has database in
    its argument list. The test_insert() function will receive the result of the database()
    function as its first argument and use that result as it wants. When we use a
    fixture this way, we don’t need to repeat the database initialization code several
    times.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库fixture会自动被任何包含数据库作为参数的测试使用。test_insert()函数将接收database()函数的返回值作为其第一个参数，并根据需要使用该结果。当我们以这种方式使用fixture时，无需重复数据库初始化代码。
- en: Another common feature of code testing is tearing down after a test has used
    a fixture. For example, you may need to close a database connection. Implementing
    the fixture as a generator allows us to add teardown functionality, as shown in
    [Listing 6-5](ch06.xhtml#ch6list5).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码测试中的另一个常见特性是在测试使用fixture后进行清理。例如，你可能需要关闭数据库连接。将fixture实现为生成器可以让我们添加清理功能，如[示例
    6-5](ch06.xhtml#ch6list5)所示。
- en: import pytest
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: '@pytest.fixture'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def database():'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'def database():'
- en: db = <some database connection>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: db = <某个数据库连接>
- en: yield db
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: yield db
- en: db.close()
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: db.close()
- en: 'def test_insert(database):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_insert(database):'
- en: database.insert(123)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: database.insert(123)
- en: '*Listing 6-5: Teardown functionality*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*清理功能示例 6-5*'
- en: Because we used the yield keyword and made database a generator, the code after
    the yield statement runs when the test is done. That code will close the database
    connection at the end of the test.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了yield关键字并将database实现为生成器，所以yield语句后的代码将在测试完成时运行。那段代码会在测试结束时关闭数据库连接。
- en: 'However, closing a database connection for each test might impose an unnecessary
    runtime cost, as tests may be able to reuse that same connection. In that case,
    you can pass the scope argument to the fixture decorator, specifying the scope
    of the fixture:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于每个测试都关闭数据库连接可能会带来不必要的运行时成本，因为测试可能能够重用相同的连接。在这种情况下，你可以将scope参数传递给fixture装饰器，指定fixture的作用范围：
- en: import pytest
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: '@pytest.fixture(scope="module")'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture(scope="module")'
- en: 'def database():'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'def database():'
- en: db = <some database connection>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: db = <某个数据库连接>
- en: yield db
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: yield db
- en: db.close()
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: db.close()
- en: 'def test_insert(database):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_insert(database):'
- en: database.insert(123)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: database.insert(123)
- en: By specifying the scope="module" parameter, you initialize the fixture once
    for the whole module, and the same database connection will be passed to all test
    functions requesting a database connection.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定scope="module"参数，你为整个模块初始化一次fixture，并且相同的数据库连接将被传递给所有请求数据库连接的测试函数。
- en: 'Finally, you can run some common code before and after your tests by marking
    fixtures as *automatically used* with the autouse keyword, rather than specifying
    them as an argument for each of the test functions. Specifying the autouse=True
    keyword argument to the pytest.fixture() function will make sure the fixture is
    called before running any test in the module or class it is defined in, as in
    this example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过使用autouse关键字将fixtures标记为*自动使用*，从而在每个测试函数中不需要将它们作为参数。将autouse=True关键字参数传递给pytest.fixture()函数，将确保在运行模块或类中定义的任何测试之前先调用该fixture，如下所示的示例：
- en: import os
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: import pytest
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: '@pytest.fixture(autouse=True)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture(autouse=True)'
- en: 'def change_user_env():'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'def change_user_env():'
- en: curuser = os.environ.get("USER")
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: curuser = os.environ.get("USER")
- en: os.environ["USER"] = "foobar"
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: os.environ["USER"] = "foobar"
- en: yield
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: yield
- en: os.environ["USER"] = curuser
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: os.environ["USER"] = curuser
- en: 'def test_user():'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_user():'
- en: assert os.getenv("USER") == "foobar"
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: assert os.getenv("USER") == "foobar"
- en: 'Such automatically enabled features are handy, but make sure not to abuse fixtures:
    they are run before each and every test covered by their scope, so they can slow
    down a test run significantly.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动启用的功能非常方便，但要确保不要滥用 fixture：它们会在每个包含在其范围内的测试之前运行，因此可能会显著减慢测试的运行速度。
- en: '***Running Test Scenarios***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行测试场景***'
- en: When unit testing, you may want to run the same error-handling test with several
    different objects that trigger that error, or you may want to run an entire test
    suite against different drivers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试时，你可能希望使用触发同样错误的多个不同对象来运行相同的错误处理测试，或者你可能希望使用不同的驱动程序运行整个测试套件。
- en: We relied heavily on this latter approach when developing *Gnocchi*, a time
    series database. Gnocchi provides an abstract class that we call the *storage
    API*. Any Python class can implement this abstract base and register itself to
    become a driver. The software loads the configured storage driver when required
    and uses the implemented storage API to store or retrieve data. In this case,
    we need a class of unit tests that runs against each driver—thus running against
    each implementation of this storage API—to be sure all drivers conform to what
    the callers expect.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发*Gnocchi*（一个时间序列数据库）时，我们大量依赖了这种后者的方法。Gnocchi 提供了一个我们称之为*存储 API*的抽象类。任何 Python
    类都可以实现这个抽象基类并注册自己成为一个驱动程序。软件会在需要时加载配置的存储驱动程序，并使用实现的存储 API 来存储或检索数据。在这种情况下，我们需要一类单元测试，针对每个驱动程序运行——即针对这个存储
    API 的每个实现运行——以确保所有驱动程序都符合调用者的预期。
- en: 'An easy way to achieve this is by using *parameterized fixtures*, which will
    run all the tests that use them several times, once for each of the defined parameters.
    [Listing 6-6](ch06.xhtml#ch6list6) shows an example of using parameterized fixtures
    to run a single test twice with different parameters: once for mysql and once
    for postgresql.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的简单方法是使用*参数化 fixture*，它会多次运行所有使用该 fixture 的测试，每次使用一个不同的定义参数。[列表 6-6](ch06.xhtml#ch6list6)展示了使用参数化
    fixture 来用不同的参数运行同一个测试两次的示例：一次使用 mysql，另一次使用 postgresql。
- en: import pytest
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: import myapp @pytest.fixture(params=["mysql", "postgresql"])
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: import myapp @pytest.fixture(params=["mysql", "postgresql"])
- en: 'def database(request):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'def database(request):'
- en: d = myapp.driver(request.param)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: d = myapp.driver(request.param)
- en: d.start()
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: d.start()
- en: yield d
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: yield d
- en: d.stop()
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: d.stop()
- en: 'def test_insert(database):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_insert(database):'
- en: database.insert("somedata")
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: database.insert("somedata")
- en: '*Listing 6-6: Running a test using parameterized fixtures*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-6：使用参数化 fixture 运行测试*'
- en: 'In [Listing 6-6](ch06.xhtml#ch6list6), the driver fixture is parameterized
    with two different values, each the name of a database driver that is supported
    by the application. When test_insert is run, it is actually run twice: once with
    a MySQL database connection and once with a PostgreSQL database connection. This
    allows us to easily reuse the same test with different scenarios, without adding
    many lines of code.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 6-6](ch06.xhtml#ch6list6)中，驱动程序 fixture 被用两个不同的值进行了参数化，每个值都是应用程序支持的数据库驱动程序的名称。当
    test_insert 运行时，实际上会运行两次：一次使用 MySQL 数据库连接，另一次使用 PostgreSQL 数据库连接。这使我们能够轻松地在不同场景下重用相同的测试，而不需要增加大量的代码行。
- en: '***Controlled Tests Using Mocking***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Mock 对象的受控测试***'
- en: Mock objects are simulated objects that mimic the behavior of real application
    objects, but in particular and controlled ways. These are especially useful in
    creating environments that describe precisely the conditions for which you would
    like to test code. You can replace all objects but one with mock objects to isolate
    the behavior of your focus object and create an enviroment for testing your code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Mock 对象是模拟的对象，它们模仿真实应用对象的行为，但在特定和受控的方式下。这些对象在创建精确描述你想要测试代码的条件的环境时特别有用。你可以将所有对象替换为
    mock 对象，只保留一个，来隔离你关注的对象的行为，并为测试代码创建一个环境。
- en: One use case is in writing an HTTP client, since it is likely impossible (or
    at least extremely complicated) to spawn the HTTP server and test it through all
    scenarios to return every possible value. HTTP clients are especially difficult
    to test for all failure scenarios.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用场景是在编写 HTTP 客户端时，因为几乎不可能（或者至少极其复杂）启动 HTTP 服务器并通过所有场景进行测试，以返回每个可能的值。HTTP
    客户端尤其难以测试所有失败场景。
- en: 'The standard library for creating mock objects in Python is mock. Starting
    with Python 3.3, mock has been merged into the Python Standard Library as unittest.mock.
    You can, therefore, use a snippet like the following to maintain backward compatibility
    between Python 3.3 and earlier versions:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Python中用于创建mock对象的标准库是mock。从Python 3.3开始，mock被合并进Python标准库，成为unittest.mock。因此，你可以像以下代码片段一样使用它，以保持Python
    3.3及更早版本的向后兼容性：
- en: 'try:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: from unittest import mock
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从unittest导入mock
- en: 'except ImportError:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除非ImportError：
- en: import mock
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 导入mock
- en: The mock library is pretty simple to use. Any attribute accessed on a mock.Mock
    object is dynamically created at runtime. Any value can be set to such an attribute.
    [Listing 6-7](ch06.xhtml#ch6list7) shows mock being used to create a fake object
    with a fake attribute.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: mock库使用起来非常简单。对mock.Mock对象访问的任何属性都会在运行时动态创建。任何值都可以赋给这样的属性。[列表6-7](ch06.xhtml#ch6list7)展示了如何使用mock创建一个带有虚假属性的虚假对象。
- en: '>>> from unittest import mock'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 从unittest导入mock'
- en: '>>> m = mock.Mock()'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m = mock.Mock()'
- en: '>>> m.some_attribute = "hello world" >>> m.some_attribute'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m.some_attribute = "hello world" >>> m.some_attribute'
- en: '"hello world"'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '"hello world"'
- en: '*Listing 6-7: Accessing the mock.Mock attribute*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-7：访问mock.Mock属性*'
- en: You can also dynamically create a method on a malleable object, as in [Listing
    6-8](ch06.xhtml#ch6list8) where we create a fake method that always returns 42
    and accepts anything as an argument.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以像[列表6-8](ch06.xhtml#ch6list8)那样，在一个可变对象上动态创建一个方法，在这个例子中我们创建了一个始终返回42并接受任意参数的虚假方法。
- en: '>>> from unittest import mock'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 从unittest导入mock'
- en: '>>> m = mock.Mock()'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m = mock.Mock()'
- en: '>>> m.some_method.return_value = 42'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m.some_method.return_value = 42'
- en: '>>> m.some_method()'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m.some_method()'
- en: '42'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: '>>> m.some_method("with", "arguments")'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m.some_method("with", "arguments")'
- en: '42'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: '*Listing 6-8: Creating methods on a mock.Mock object*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-8：在mock.Mock对象上创建方法*'
- en: In just a few lines, your mock.Mock object now has a some_method() method that
    returns 42\. It accepts any kind of argument, and there is no check on what the
    values are—yet.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅几行代码，你的mock.Mock对象现在就有了一个返回42的some_method()方法。它接受任何类型的参数，且目前没有对这些参数的值进行任何检查。
- en: Dynamically created methods can also have (intentional) side effects. Rather
    than being boilerplate methods that just return a value, they can be defined to
    execute useful code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 动态创建的方法也可以有（故意的）副作用。它们不仅仅是返回一个值的模板方法，还可以被定义为执行有用的代码。
- en: '[Listing 6-9](ch06.xhtml#ch6list9) creates a fake method that has the side
    effect of printing the "hello world" string.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6-9](ch06.xhtml#ch6list9)创建了一个虚假方法，其副作用是打印"hello world"字符串。'
- en: '>>> from unittest import mock'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 从unittest导入mock'
- en: '>>> m = mock.Mock()'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m = mock.Mock()'
- en: '>>> def print_hello():'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def print_hello():'
- en: '...     print("hello world!")'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '...      print("hello world!")'
- en: '...     return 43'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '...      return 43'
- en: '...'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: ➊ >>> m.some_method.side_effect = print_hello
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> m.some_method.side_effect = print_hello
- en: '>>> m.some_method()'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m.some_method()'
- en: hello world!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: hello world!
- en: '43'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '43'
- en: ➋ >>> m.some_method.call_count
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> m.some_method.call_count
- en: '1'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '*Listing 6-9: Creating methods on a mock.Mock object with side effects*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-9：创建带有副作用的mock.Mock对象方法*'
- en: We assign an entire function to the some_method attribute ➊. This technique
    allows us to implement more complex scenarios in a test because we can plug any
    code needed for testing into a mock object. We then just need to pass this mock
    object to whichever function expects it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整个函数赋值给some_method属性 ➊。这种技术让我们能够在测试中实现更复杂的场景，因为我们可以将任何需要的代码插入到mock对象中。然后，我们只需要将这个mock对象传递给任何需要它的函数。
- en: The call_count attribute ➋ is a simple way of checking the number of times a
    method has been called.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: call_count属性 ➋是检查方法被调用次数的简单方式。
- en: 'The mock library uses the action/assertion pattern: this means that once your
    test has run, it’s up to you to check that the actions you are mocking were correctly
    executed. [Listing 6-10](ch06.xhtml#ch6list10) applies the assert() method to
    our mock objects to perform these checks.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: mock库使用动作/断言模式：这意味着一旦测试运行完成，你需要自行检查你正在模拟的动作是否已正确执行。[列表6-10](ch06.xhtml#ch6list10)对我们的mock对象应用assert()方法来执行这些检查。
- en: '>>> from unittest import mock'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 从unittest导入mock'
- en: '>>> m = mock.Mock()'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m = mock.Mock()'
- en: ➊ >>> m.some_method('foo', 'bar')
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> m.some_method('foo', 'bar')
- en: <Mock name='mock.some_method()' id='26144272'>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: <Mock name='mock.some_method()' id='26144272'>
- en: ➋ >>> m.some_method.assert_called_once_with('foo', 'bar')
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> m.some_method.assert_called_once_with('foo', 'bar')
- en: '>>> m.some_method.assert_called_once_with(''foo'', ➌mock.ANY)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m.some_method.assert_called_once_with(''foo'', ➌mock.ANY)'
- en: '>>> m.some_method.assert_called_once_with(''foo'', ''baz'')'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> m.some_method.assert_called_once_with(''foo'', ''baz'')'
- en: 'Traceback (most recent call last):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯（最近的调用最后）：
- en: File "<stdin>", line 1, in <module>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 1 行，位于 <module>
- en: File "/usr/lib/python2.7/dist-packages/mock.py", line 846, in assert_called_
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "/usr/lib/python2.7/dist-packages/mock.py"，第 846 行，位于 assert_called_
- en: once_with
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: once_with
- en: return self.assert_called_with(*args, **kwargs)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 self.assert_called_with(*args, **kwargs)
- en: File "/usr/lib/python2.7/dist-packages/mock.py", line 835, in assert_called_
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "/usr/lib/python2.7/dist-packages/mock.py"，第 835 行，位于 assert_called_
- en: with
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: raise AssertionError(msg)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 AssertionError(msg)
- en: 'AssertionError: Expected call: some_method(''foo'', ''baz'')'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'AssertionError: 预期的调用：some_method(''foo'', ''baz'')'
- en: 'Actual call: some_method(''foo'', ''bar'')'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 实际调用：some_method('foo', 'bar')
- en: '*Listing 6-10: Checking method calls*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-10：检查方法调用*'
- en: We create a method with the arguments foo and bar to stand in as our tests by
    calling the method ➊. The usual way to check calls to a mock object is to use
    the assert_called() methods, such as assert_called_once_with() ➋. To these methods,
    you need to pass the values that you expect callers to use when calling your mock
    method. If the values passed are not the ones being used, then mock raises an
    AssertionError. If you don’t know what arguments may be passed, you can use mock.ANY
    as a value ➌; that will match any argument passed to your mock method.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个方法，参数为 foo 和 bar，通过调用该方法 ➊ 来作为我们的测试。检查对 mock 对象的调用通常使用 assert_called()
    方法，比如 assert_called_once_with() ➋。对于这些方法，你需要传入期望调用者在调用你的 mock 方法时使用的值。如果传入的值不是预期的，mock
    会抛出 AssertionError。如果你不知道可能传入什么参数，可以使用 mock.ANY 作为值 ➌；它会匹配传递给你的 mock 方法的任何参数。
- en: Th mock library can also be used to patch some function, method, or object from
    an external module. In [Listing 6-11](ch06.xhtml#ch6list11), we replace the os.unlink()
    function with a fake function we provide.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: mock 库也可以用于替换外部模块中的某个函数、方法或对象。在 [清单 6-11](ch06.xhtml#ch6list11) 中，我们将 os.unlink()
    函数替换为我们提供的一个伪函数。
- en: '>>> from unittest import mock'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from unittest import mock'
- en: '>>> import os'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import os'
- en: '>>> def fake_os_unlink(path):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def fake_os_unlink(path):'
- en: '...     raise IOError("Testing!")'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '...     引发 IOError("测试！")'
- en: '...'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> with mock.patch(''os.unlink'', fake_os_unlink):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 使用 mock.patch(''os.unlink'', fake_os_unlink):'
- en: '...     os.unlink(''foobar'')'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '...     os.unlink(''foobar'')'
- en: '...'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'Traceback (most recent call last):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 2, in <module>
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 2 行，位于 <module>
- en: File "<stdin>", line 2, in fake_os_unlink
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 "<stdin>"，第 2 行，位于 fake_os_unlink
- en: 'IOError: Testing!'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 'IOError: 测试！'
- en: '*Listing 6-11: Using mock.patch*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-11：使用 mock.patch*'
- en: When used as a context manager, mock.patch() replaces the target function with
    the function we provide so the code executed inside the context uses that patched
    method. With the mock.patch() method, it’s possible to change any part of an external
    piece of code, making it behave in a way that lets you test all conditions in
    your application, as shown in [Listing 6-12](ch06.xhtml#ch6list12).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当 mock.patch() 作为上下文管理器使用时，它将目标函数替换为我们提供的函数，因此在上下文中执行的代码会使用该修补后的方法。通过 mock.patch()
    方法，您可以更改外部代码的任何部分，使其按您希望的方式行为，从而让您在应用程序中测试所有条件，如 [清单 6-12](ch06.xhtml#ch6list12)
    所示。
- en: from unittest import mock
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: from unittest import mock
- en: import pytest
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: import requests
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: import requests
- en: 'class WhereIsPythonError(Exception):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 'class WhereIsPythonError(Exception):'
- en: pass
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '➊ def is_python_still_a_programming_language():'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def is_python_still_a_programming_language():'
- en: 'try:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: r = requests.get("http://python.org")
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: r = requests.get("http://python.org")
- en: 'except IOError:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 'except IOError:'
- en: pass
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'else:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: 'if r.status_code == 200:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 r.status_code == 200:'
- en: return 'Python is a programming language' in r.content
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 'Python 是一种编程语言' 在 r.content 中
- en: raise WhereIsPythonError("Something bad happened")
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 WhereIsPythonError("发生了某些错误")
- en: 'def get_fake_get(status_code, content):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_fake_get(status_code, content):'
- en: m = mock.Mock()
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: m = mock.Mock()
- en: m.status_code = status_code
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: m.status_code = status_code
- en: m.content = content
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: m.content = content
- en: 'def fake_get(url):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fake_get(url):'
- en: return m
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 m
- en: return fake_get
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 fake_get
- en: 'def raise_get(url):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'def raise_get(url):'
- en: raise IOError("Unable to fetch url %s" % url)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 IOError("无法获取 url %s" % url)
- en: ➋ @mock.patch('requests.get', get_fake_get(
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ @mock.patch('requests.get', get_fake_get(
- en: 200, 'Python is a programming language for sure'))
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 200, 'Python 确实是一种编程语言'))
- en: 'def test_python_is():'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_python_is():'
- en: assert is_python_still_a_programming_language() is True
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: assert is_python_still_a_programming_language() 是 True
- en: '@mock.patch(''requests.get'', get_fake_get('
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '@mock.patch(''requests.get'', get_fake_get('
- en: 200, 'Python is no more a programming language'))
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 200, 'Python 不再是编程语言'))
- en: 'def test_python_is_not():'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_python_is_not():'
- en: assert is_python_still_a_programming_language() is False
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: assert is_python_still_a_programming_language() 是 False
- en: '@mock.patch(''requests.get'', get_fake_get(404, ''Whatever''))'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '@mock.patch(''requests.get'', get_fake_get(404, ''Whatever''))'
- en: 'def test_bad_status_code():'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_bad_status_code():'
- en: 'with pytest.raises(WhereIsPythonError):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 pytest.raises(WhereIsPythonError):'
- en: is_python_still_a_programming_language()
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: is_python_still_a_programming_language()
- en: '@mock.patch(''requests.get'', raise_get)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '@mock.patch(''requests.get'', raise_get)'
- en: 'def test_ioerror():'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_ioerror():'
- en: 'with pytest.raises(WhereIsPythonError):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 'with pytest.raises(WhereIsPythonError):'
- en: is_python_still_a_programming_language()
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: is_python_still_a_programming_language()
- en: '*Listing 6-12: Using mock.patch() to test a set of behaviors*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-12：使用 mock.patch() 测试一组行为*'
- en: '[Listing 6-12](ch06.xhtml#ch6list12) implements a test suite that searches
    for all instances of the string “Python is a programming language” on the *[http://python.org/](http://python.org/)*
    web page ➊. There is no way to test negative scenarios (where this sentence is
    not on the web page) without modifying the page itself—something we’re not able
    to do, obviously. In this case, we’re using mock to cheat and change the behavior
    of the request so it returns a mocked reply with a fake page that doesn’t contain
    that string. This allows us to test the negative scenario in which *[http://python.org/](http://python.org/)*
    does not contain this sentence, making sure the program handles that case correctly.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-12](ch06.xhtml#ch6list12) 实现了一个测试套件，该套件在 *[http://python.org/](http://python.org/)*
    网页上搜索所有包含“Python is a programming language”字符串的实例 ➊。如果不修改网页本身（显然我们无法做到这一点），就无法测试负面场景（即该句子不在网页上）。在这种情况下，我们使用
    mock 来模拟并更改请求的行为，使其返回一个虚假的页面，该页面不包含该字符串。这使我们能够测试负面场景，即 *[http://python.org/](http://python.org/)*
    页面不包含该句子，从而确保程序能正确处理这种情况。'
- en: This example uses the decorator version of mock.patch() ➋. Using the decorator
    does not change the mocking behavior, but it is simpler when you need to use mocking
    within the context of an entire test function.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 本例使用了 mock.patch() 的装饰器版本 ➋。使用装饰器不会改变模拟行为，但当你需要在整个测试函数的上下文中使用模拟时，它会更简洁。
- en: Using mocking, we can simulate any problem, such as a web server returning a
    404 error, an I/O error, or a network latency issue. We can make sure code returns
    the correct values or raises the correct exception in every case, ensuring our
    code always behaves as expected.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟，我们可以模拟任何问题，例如 web 服务器返回 404 错误、I/O 错误或网络延迟问题。我们可以确保代码在每种情况下都返回正确的值或抛出正确的异常，确保我们的代码始终按预期行为运行。
- en: '***Revealing Untested Code with coverage***'
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 coverage 显示未测试的代码***'
- en: A great complement to unit testing, the coverage tool identifies whether any
    of your code has been missed during testing. It uses code analysis tools and tracing
    hooks to determine which lines of your code have been executed; when used during
    a unit test run, it can show you which parts of your codebase have been crossed
    over and which parts have not. Writing tests is useful, but having a way to know
    what part of your code you may have missed during the testing process is the cherry
    on the cake.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 作为单元测试的一个重要补充，coverage 工具可以识别测试过程中是否有代码被遗漏。它使用代码分析工具和追踪钩子来确定哪些代码行已被执行；在单元测试运行时使用它，可以显示哪些代码部分已经被覆盖，哪些没有。编写测试是有用的，但拥有一种方法来了解在测试过程中可能遗漏了哪些代码部分，才是锦上添花的关键。
- en: Install the coverage Python module on your system via pip to have access to
    the coverage program command from your shell.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 pip 在系统上安装 coverage Python 模块，以便从你的 shell 中访问 coverage 程序命令。
- en: '**NOTE**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The command may also be named python-coverage, if you install coverage through
    your operating system installation software. This is the case on Debian, for example.*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你通过操作系统安装软件安装了 coverage，该命令也可能被命名为 python-coverage。例如，在 Debian 上就是这种情况。*'
- en: Using coverage in stand-alone mode is straightforward. It can show you parts
    of your programs that are never run and which code might be “dead code,” that
    is, code that could be removed without modifying the normal workflow of the program.
    All the test tools we’ve talked about so far in this chapter are integrated with
    coverage.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以独立模式使用 coverage 很简单。它可以显示程序中从未执行的部分，以及哪些代码可能是“死代码”，也就是说，可以删除而不修改程序的正常工作流程。到目前为止，在本章讨论的所有测试工具都与
    coverage 集成。
- en: When using pytest, just install the pytest-cov plugin via pip install pytest-pycov
    and add a few option switches to generate a detailed code coverage output, as
    shown in [Listing 6-13](ch06.xhtml#ch6list13).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pytest 时，只需通过 pip install pytest-pycov 安装 pytest-cov 插件，并添加一些选项开关来生成详细的代码覆盖率输出，如
    [列表 6-13](ch06.xhtml#ch6list13) 所示。
- en: $ pytest --cov=gnocchiclient gnocchiclient/tests/unit
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: $ pytest --cov=gnocchiclient gnocchiclient/tests/unit
- en: '---------- coverage: platform darwin, python 3.6.4-final-0 -----------'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '---------- coverage: platform darwin, python 3.6.4-final-0 -----------'
- en: Name                                          Stmts   Miss Branch BrPart  Cover
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 名称                                          语句数   遗漏  分支  部分分支  覆盖率
- en: '---------------------------'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------------------'
- en: gnocchiclient/__init__.py                         0      0      0      0   100%
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: gnocchiclient/__init__.py                         0      0      0      0   100%
- en: gnocchiclient/auth.py                            51     23      6      0    49%
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: gnocchiclient/auth.py                            51     23      6      0    49%
- en: gnocchiclient/benchmark.py                      175    175     36      0     0%
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: gnocchiclient/benchmark.py                      175    175     36      0     0%
- en: --snip--
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: '---------------------------'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------------------'
- en: TOTAL                                          2040   1868    424      6     8%
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 总计                                          2040   1868    424      6     8%
- en: === passed in 5.00 seconds ===
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: === 在 5.00 秒内通过 ===
- en: '*Listing 6-13: Using coverage with pytest*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-13：在pytest中使用覆盖率*'
- en: The --cov option enables the coverage report at the end of the test run. You
    need to pass the package name as an argument for the plugin to filter the coverage
    report properly. The output includes the lines of code that were not run and therefore
    have no tests. All you need to do now is spawn your favorite text editor and start
    writing tests for that code.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: --cov选项会在测试运行结束时启用覆盖率报告。你需要传递包名作为参数，以便插件正确地过滤覆盖率报告。输出包括未被执行的代码行，因此没有测试。现在你只需启动你喜欢的文本编辑器，开始为这些代码编写测试。
- en: However, coverage goes one better, allowing you to generate clear HTML reports.
    Simply add the --cov-report=html flag, and the *htmlcov* directory from which
    you ran the command will be populated with HTML pages. Each page will show you
    which parts of your source code were or were not run.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，覆盖率更进一步，允许你生成清晰的HTML报告。只需添加--cov-report=html标志，执行该命令的*htmlcov*目录将会填充HTML页面。每个页面都会显示你的源代码的哪些部分已被执行，哪些未被执行。
- en: If you want to be *that* person, you can use the option --cover-fail-under=COVER_MIN_PERCENTAGE,
    which will make the test suite fail if a minimum percentage of the code is not
    executed when the test suite is run. While having a good coverage percentage is
    a decent goal, and while the tool is useful to gain insight into the state of
    your test coverage, defining an arbitrary percentage value does not provide much
    insight. [Figure 6-1](ch06.xhtml#ch6fig1) shows an example of a coverage report
    with the percentage at the top.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想成为*那样的*人，可以使用选项--cover-fail-under=COVER_MIN_PERCENTAGE，当测试套件运行时，如果代码的最低执行百分比未达到，测试套件将会失败。虽然拥有良好的覆盖率是一个不错的目标，且该工具在获得测试覆盖率状态的洞察上非常有用，但定义一个任意的百分比值并不会提供太多有价值的洞察。[图
    6-1](ch06.xhtml#ch6fig1)展示了一个带有顶部百分比的覆盖率报告示例。
- en: For example, a code coverage score of 100 percent is a respectable goal, but
    it does not necessarily mean the code is entirely tested and you can rest. It
    only proves that your whole code path has been run; there is no indication that
    every possible condition has been tested.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，100%的代码覆盖率是一个值得尊敬的目标，但它并不一定意味着代码已经完全测试过，你可以放心了。它只证明了你的所有代码路径都已经运行过；但并没有说明每种可能的条件都已经被测试。
- en: You should use coverage information to consolidate your test suite and add tests
    for any code that is currently not being run. This facilitates later project maintenance
    and increases your code’s overall quality.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用覆盖率信息来整合你的测试套件，并为任何当前未运行的代码添加测试。这有助于以后的项目维护，并提高你代码的整体质量。
- en: '![image](../images/f06-01.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-01.jpg)'
- en: '*Figure 6-1: Coverage of ceilometer.publisher*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：ceilometer.publisher 的覆盖率*'
- en: '**Virtual Environments**'
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**虚拟环境**'
- en: 'Earlier we mentioned the danger that your tests may not capture the absence
    of dependencies. Any application of significant size inevitably depends on external
    libraries to provide features the application needs, but there are many ways external
    libraries might cause issues on your operating system. Here are a few:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，你的测试可能无法捕捉到缺少依赖项的危险。任何具有相当规模的应用程序都会依赖外部库来提供应用程序所需的功能，但外部库可能会在你的操作系统上引发许多问题。以下是其中一些：
- en: Your system does not have the library you need packaged.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的系统没有打包你所需要的库。
- en: Your system does not have the right *version* of the library you need packaged.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的系统没有正确的*版本*的所需库。
- en: You need two different versions of the same library for two different applications.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要为两个不同的应用程序提供同一个库的两个不同版本。
- en: These problems can happen when you first deploy your application or later on,
    while it’s running. Upgrading a Python library installed via your system manager
    might break your application in a snap without warning, for reasons as simple
    as an API change in the library being used by the application.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能发生在你首次部署应用程序时，或者在应用程序运行过程中发生。在通过系统管理器升级已安装的 Python 库时，可能会突然破坏应用程序，原因可能只是库中的
    API 发生了变化。
- en: The solution is for each application to use a library directory that contains
    all the application’s dependencies. This directory is then used to load the needed
    Python modules rather than the system-installed ones.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是让每个应用程序使用一个包含所有应用程序依赖项的库目录。然后，这个目录用于加载所需的 Python 模块，而不是使用系统安装的模块。
- en: Such a directory is known as a *virtual environment*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的目录被称为 *虚拟环境*。
- en: '***Setting Up a Virtual Environment***'
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置虚拟环境***'
- en: The tool virtualenv handles virtual environments automatically for you. Until
    Python 3.2, you’ll find it in the virtualenv package that you can install using
    pip install virtualenv. If you use Python 3.3 or later, it’s available directly
    via Python under the venv name.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 工具 virtualenv 会自动为你处理虚拟环境。在 Python 3.2 之前，你可以通过 pip install virtualenv 安装虚拟环境包来使用它。如果你使用的是
    Python 3.3 或更高版本，则可以直接通过 Python 使用 venv 名称。
- en: 'To use the module, load it as the main program with a destination directory
    as its argument, like so:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该模块，将其作为主程序加载，并将目标目录作为其参数，如下所示：
- en: $ python3 -m venv myvenv
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: $ python3 -m venv myvenv
- en: $ ls foobar
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: $ ls foobar
- en: bin        include    lib        pyvenv.cfg
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: bin        include     lib        pyvenv.cfg
- en: Once run, venv creates a *lib/pythonX.Y* directory and uses it to install pip
    into the virtual environment, which will be useful to install further Python packages.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行，venv 会创建一个 *lib/pythonX.Y* 目录，并使用它将 pip 安装到虚拟环境中，这对于安装进一步的 Python 包非常有用。
- en: 'You can then activate the virtual environment by “sourcing” the activate command.
    Use the following on Posix systems:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过“源”激活命令来激活虚拟环境。在 Posix 系统上，使用以下命令：
- en: $ source myvenv/bin/activate
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: $ source myvenv/bin/activate
- en: 'On Windows systems, use this code:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统上，使用以下代码：
- en: \myvenv\Scripts\activate
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \myvenv\Scripts\activate
- en: Once you do that, your shell prompt should appear prefixed by the name of your
    virtual environment. Executing python will call the version of Python that has
    been copied into the virtual environment. You can check that it’s working by reading
    the sys.path variable and checking that it has your virtual environment directory
    as its first component.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，命令行提示符前面应显示虚拟环境的名称。执行 python 将调用已复制到虚拟环境中的 Python 版本。你可以通过查看 sys.path 变量并检查它是否将虚拟环境目录作为第一个组件来检查它是否正常工作。
- en: 'You can stop and leave the virtual environment at any time by calling the deactivate
    command:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时通过调用 deactivate 命令停止并退出虚拟环境：
- en: $ deactivate
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: $ deactivate
- en: 'That’s it. Also note that you are not forced to run activate if you want to
    use the Python installed in your virtual environment just once. Calling the python
    binary will also work:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。还要注意，如果你只想使用一次虚拟环境中安装的 Python，是不强制要求运行 activate 的。直接调用 python 二进制文件也可以工作：
- en: $ myvenv/bin/python
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: $ myvenv/bin/python
- en: 'Now, while we’re in our activated virtual environment, we do not have access
    to any of the modules installed and available on the main system. That is the
    point of using a virtual environment, but it does mean we probably need to install
    the packages we need. To do that, use the standard pip command to install each
    package, and the packages will install in the right place, without changing anything
    about your system:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在激活的虚拟环境中，我们无法访问系统主机上安装和可用的任何模块。这就是使用虚拟环境的目的，但也意味着我们可能需要安装所需的包。为此，使用标准的 pip
    命令安装每个包，包将安装到正确的位置，而不会改变系统的任何内容：
- en: $ source myvenv/bin/activate
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: $ source myvenv/bin/activate
- en: (myvenv) $ pip install six
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: (myvenv) $ pip install six
- en: Downloading/unpacking six
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 正在下载/解压 six
- en: Downloading six-1.4.1.tar.gz
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 正在下载 six-1.4.1.tar.gz
- en: Running setup.py egg_info for package six
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 正在为包 six 执行 setup.py egg_info
- en: 'Installing collected packages: six'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 正在安装已收集的包：six
- en: Running setup.py install for six
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 正在为 six 执行 setup.py install
- en: Successfully installed six
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装 six
- en: Cleaning up...
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 清理中...
- en: Voilà! We can install all the libraries we need and then run our application
    from this virtual environment, without breaking our system. It’s easy to see how
    we can script this to automate the installation of a virtual environment based
    on a list of dependencies, as in [Listing 6-14](ch06.xhtml#ch6list14).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà！我们可以安装所有需要的库，然后从这个虚拟环境中运行我们的应用程序，而不会破坏系统。很容易看出，我们可以如何编写脚本来自动化基于依赖项列表的虚拟环境安装，正如
    [列表 6-14](ch06.xhtml#ch6list14) 所示。
- en: virtualenv myappvenv
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: virtualenv myappvenv
- en: source myappvenv/bin/activate
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: source myappvenv/bin/activate
- en: pip install -r requirements.txt
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: pip install -r requirements.txt
- en: deactivate
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: deactivate
- en: '*Listing 6-14: Automatic virtual environment creation*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-14：自动虚拟环境创建*'
- en: It can still be useful to have access to your system-installed packages, so
    virtualenv allows you to enable them when creating your virtual environment by
    passing the --system-site-packages flag to the virtualenv command.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要访问系统中安装的包，虚拟环境仍然可以提供帮助，因此 virtualenv 允许你在创建虚拟环境时通过传递 --system-site-packages
    标志来启用这些系统包。
- en: Inside myvenv, you will find a *pyvenv.cfg*, the configuration file for this
    environment. It doesn’t have a lot of configuration options by default. You should
    recognize include-system-site-package, whose purpose is the same as the --system-site-packages
    of virtualenv that we described earlier.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在 myvenv 中，你会找到一个 *pyvenv.cfg* 文件，这是该环境的配置文件。默认情况下，它没有很多配置选项。你应该能认出 include-system-site-package，它的作用与我们之前描述的
    virtualenv 的 --system-site-packages 相同。
- en: As you might guess, virtual environments are incredibly useful for automated
    runs of unit test suites. Their use is so widespread that a particular tool has
    been built to address it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，虚拟环境对于自动化运行单元测试套件非常有用。它们的使用非常广泛，因此专门为此任务开发了一个工具。
- en: '***Using virtualenv with tox***'
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 virtualenv 与 tox***'
- en: One of the central uses of virtual environments is to provide a clean environment
    for running unit tests. It would be detrimental if you were under the impression
    that your tests were working, when they were not, for example, respecting the
    dependency list.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境的一个主要用途是为运行单元测试提供一个干净的环境。如果你误以为测试正常运行，但实际上并没有，譬如没有遵守依赖列表，那将是非常有害的。
- en: 'One way to ensure you’re accounting for all the dependencies would be to write
    a script to deploy a virtual environment, install setuptools, and then install
    all of the dependencies required for both your application/library runtime and
    unit tests. Luckily, this is such a popular use case that an application dedicated
    to this task has already been built: tox.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 确保考虑到所有依赖项的一种方式是编写一个脚本来部署虚拟环境，安装 setuptools，然后安装应用程序/库运行时和单元测试所需的所有依赖项。幸运的是，这样的使用场景非常流行，已经有一个专门用于此任务的应用程序——tox。
- en: The tox management tool aims to automate and standardize how tests are run in
    Python. To that end, it provides everything needed to run an entire test suite
    in a clean virtual environment, while also installing your application to check
    that the installation works.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: tox 管理工具旨在自动化和标准化 Python 中测试的运行方式。为此，它提供了在干净的虚拟环境中运行整个测试套件所需的一切，同时还会安装你的应用程序，以检查安装是否成功。
- en: 'Before using tox, you need to provide a configuration file named *tox.ini*
    that should be placed in the root directory of your project, beside your *setup.py*
    file:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 tox 之前，你需要提供一个名为 *tox.ini* 的配置文件，应该将其放置在项目的根目录中，与 *setup.py* 文件一起：
- en: $ touch tox.ini
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: $ touch tox.ini
- en: 'You can then run tox successfully:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以成功运行 tox：
- en: '% tox'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '% tox'
- en: 'GLOB sdist-make: /home/jd/project/setup.py'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 'GLOB sdist-make: /home/jd/project/setup.py'
- en: 'python create: /home/jd/project/.tox/python'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 'python create: /home/jd/project/.tox/python'
- en: 'python inst: /home/jd/project/.tox/dist/project-1.zip'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 'python inst: /home/jd/project/.tox/dist/project-1.zip'
- en: ____________________ summary _____________________
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ____________________ 总结 _____________________
- en: 'python: commands succeeded'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 'python: commands succeeded'
- en: congratulations :)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你 :)
- en: In this instance, tox creates a virtual environment in *.tox/python* using the
    default Python version. It uses *setup.py* to create a distribution of your package,
    which it then installs inside this virtual environment. No commands are run, because
    we did not specify any in the configuration file. This alone is not particularly
    useful.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，tox 使用默认的 Python 版本在 *.tox/python* 中创建一个虚拟环境。它使用 *setup.py* 来创建你的包的分发版本，然后将其安装到该虚拟环境中。没有运行任何命令，因为我们在配置文件中没有指定任何命令。仅此而已，并没有特别的用途。
- en: 'We can change this default behavior by adding a command to run inside our test
    environment. Edit *tox.ini* to include the following:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在测试环境中添加要运行的命令来改变这种默认行为。编辑*tox.ini*并添加以下内容：
- en: '[testenv]'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[testenv]'
- en: commands=pytest
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: commands=pytest
- en: 'Now tox runs the command pytest. However, since we do not have pytest installed
    in the virtual environment, this command will likely fail. We need to list pytest
    as a dependency to be installed:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，tox运行pytest命令。然而，由于我们在虚拟环境中没有安装pytest，这个命令很可能会失败。我们需要将pytest列为一个依赖项以便安装：
- en: '[testenv]'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[testenv]'
- en: deps=pytest
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: deps=pytest
- en: commands=pytest
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: commands=pytest
- en: When run now, tox re-creates the environment, installs the new dependency, and
    runs the command pytest, which executes all of the unit tests. To add more dependencies,
    you can either list them in the deps configuration option, as is done here, or
    use the -rfile syntax to read from a file.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行时，tox会重新创建环境，安装新的依赖项，并运行pytest命令，这将执行所有单元测试。要添加更多依赖项，你可以将它们列在deps配置选项中，如此处所示，或者使用-rfile语法从文件中读取。
- en: '***Re-creating an Environment***'
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重新创建环境***'
- en: Sometimes you’ll need to re-create an environment to, for example, ensure things
    work as expected when a new developer clones the source code repository and runs
    tox for the first time. For this, tox accepts a --recreate option that will rebuild
    the virtual environment from scratch based on parameters you lay out.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要重新创建一个环境，例如，当新开发者克隆源代码仓库并首次运行tox时，确保一切按预期工作。为此，tox接受--recreate选项，它将根据你指定的参数从头开始重建虚拟环境。
- en: 'You define the parameters for all virtual environments managed by tox in the
    [testenv] section of *tox.ini*. And, as mentioned, tox can manage multiple Python
    virtual environments—indeed, it is possible to run our tests under a Python version
    other than the default one by passing the -e flag to tox, like so:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 你在*tox.ini*的[testenv]部分定义了所有虚拟环境的参数。如前所述，tox可以管理多个Python虚拟环境——实际上，通过向tox传递-e标志，你可以在除默认Python版本之外的其他Python版本下运行我们的测试，如下所示：
- en: '% tox -e py26'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '% tox -e py26'
- en: 'GLOB sdist-make: /home/jd/project/setup.py'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 'GLOB sdist-make: /home/jd/project/setup.py'
- en: 'py26 create: /home/jd/project/.tox/py26'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 'py26 创建: /home/jd/project/.tox/py26'
- en: 'py26 installdeps: nose'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 'py26 安装依赖项: nose'
- en: 'py26 inst: /home/jd/project/.tox/dist/rebuildd-1.zip'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'py26 安装: /home/jd/project/.tox/dist/rebuildd-1.zip'
- en: 'py26 runtests: commands[0] | pytests'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 'py26 运行测试: commands[0] | pytests'
- en: --snip--
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: == test session starts ==
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: == 测试会话开始 ==
- en: === 5 passed in 4.87 seconds ====
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: === 5个测试通过，耗时4.87秒 ====
- en: 'By default, tox simulates any environment that matches an existing Python version:
    py24, py25, py26, py27, py30, py31, py32, py33, py34, py35, py36, py37, jython,
    and pypy! Furthermore, you can define your own environments. You just need to
    add another section named [testenv:_envname_]. If you want to run a particular
    command for just one of the environments, you can do so easily by listing the
    following in the *tox.ini* file:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，tox会模拟任何匹配现有Python版本的环境：py24, py25, py26, py27, py30, py31, py32, py33,
    py34, py35, py36, py37, jython和pypy！此外，你可以定义自己的环境。只需添加一个名为[testenv:_envname_]的部分。如果你只想为某个特定环境运行某个命令，可以在*tox.ini*文件中列出以下内容：
- en: '[testenv]'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '[testenv]'
- en: deps=pytest
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: deps=pytest
- en: commands=pytest
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: commands=pytest
- en: '[testenv:py36-coverage]'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[testenv:py36-coverage]'
- en: deps={[testenv]deps}
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: deps={[testenv]deps}
- en: pytest-cov
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: pytest-cov
- en: commands=pytest --cov=myproject
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: commands=pytest --cov=myproject
- en: 'By using pytest --cov=myproject under the py36-coverage section as shown here,
    you override the commands for the py36-coverage environment, meaning when you
    run tox -e py36-coverage, pytest is installed as part of the dependencies, but
    the command pytest is actually run instead with the coverage option. For that
    to work, the pytest-cov extension must be installed: to this end, we replace the
    deps value with the deps from testenv and add the pytest-cov dependency. Variable
    interpolation is also supported by tox, so you can refer to any other field from
    the *tox.ini* file and use it as a variable, the syntax being {[env_name]variable_name}.
    This allows us to avoid repeating the same things over and over again.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在py36-coverage部分使用pytest --cov=myproject，如下所示，你可以覆盖py36-coverage环境中的命令，这意味着当你运行tox
    -e py36-coverage时，pytest会作为依赖项被安装，但实际运行的命令是带有coverage选项的pytest。为了使其工作，必须安装pytest-cov扩展：为此，我们将deps值替换为testenv中的deps，并添加pytest-cov依赖项。tox也支持变量插值，因此你可以引用*tox.ini*文件中的任何其他字段并将其作为变量使用，语法为{[env_name]variable_name}。这样可以避免重复写相同的内容。
- en: '***Using Different Python Versions***'
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用不同的Python版本***'
- en: 'We can also create a new environment with an unsupported version of Python
    right away with the following in *tox.ini*:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过以下配置，在 *tox.ini* 中立即创建一个使用不支持的 Python 版本的新环境：
- en: '[testenv]'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '[testenv]'
- en: deps=pytest
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: deps=pytest
- en: commands=pytest
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: commands=pytest
- en: '[testenv:py21]'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '[testenv:py21]'
- en: basepython=python2.1
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: basepython=python2.1
- en: When we run this, it will now (attempt to) use Python 2.1 to run the test suite—although
    since it is very unlikely you have this ancient Python version installed on your
    system, I doubt this would work for you!
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个命令时，它现在将（尝试）使用 Python 2.1 来运行测试套件——尽管由于你很可能没有在系统上安装这个古老的 Python 版本，我怀疑它对你有效！
- en: 'It’s likely that you’ll want to support multiple Python versions, in which
    case it would be useful to have tox run all the tests for all the Python versions
    you want to support by default. You can do this by specifying the environment
    list you want to use when tox is run without arguments:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望支持多个 Python 版本，在这种情况下，默认情况下让 tox 为你想要支持的所有 Python 版本运行所有测试将非常有用。你可以通过在没有任何参数的情况下运行
    tox 来指定环境列表：
- en: '[tox]'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[tox]'
- en: envlist=py35,py36,pypy
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: envlist=py35,py36,pypy
- en: '[testenv]'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '[testenv]'
- en: deps=pytest
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: deps=pytest
- en: commands=pytest
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: commands=pytest
- en: When tox is launched without any further arguments, all four environments listed
    are created, populated with the dependencies and the application, and then run
    with the command pytest.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有进一步的参数时运行 tox 时，所有列出的四个环境都会被创建，安装依赖项和应用程序，然后使用命令 pytest 运行。
- en: '***Integrating Other Tests***'
  id: totrans-467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***集成其他测试***'
- en: 'We can also use tox to integrate tests like flake8, as discussed in [Chapter
    1](ch01.xhtml#ch01). The following *tox.ini* file provides a PEP 8 environment
    that will install flake8 and run it:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 tox 集成像 flake8 这样的测试，正如 [第 1 章](ch01.xhtml#ch01) 中讨论的那样。以下 *tox.ini*
    文件提供了一个 PEP 8 环境，它将安装 flake8 并运行它：
- en: '[tox]'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[tox]'
- en: envlist=py35,py36,pypy,pep8
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: envlist=py35,py36,pypy,pep8
- en: '[testenv]'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[testenv]'
- en: deps=pytest
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: deps=pytest
- en: commands=pytest
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: commands=pytest
- en: '[testenv:pep8]'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[testenv:pep8]'
- en: deps=flake8
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: deps=flake8
- en: commands=flake8
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: commands=flake8
- en: In this case, the pep8 environment is run using the default version of Python,
    which is probably fine, though you can still specify the basepython option if
    you want to change that.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，pep8 环境使用默认版本的 Python 运行，这通常是可以的，但如果你想更改它，仍然可以指定 basepython 选项。
- en: When running tox, you’ll notice that all the environments are built and run
    sequentially. This can make the process very long, but since virtual environments
    are isolated, nothing prevents you from running tox commands in parallel. This
    is exactly what the detox package does, by providing a detox command that runs
    all of the default environments from *envlist* in parallel. You should pip install
    it!
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 tox 时，你会注意到所有的环境都按顺序构建并运行。这可能会使过程变得非常长，但由于虚拟环境是隔离的，因此没有什么阻止你并行运行 tox 命令。这正是
    detox 包所做的，通过提供一个 detox 命令，来并行运行 *envlist* 中的所有默认环境。你应该安装它！
- en: '**Testing Policy**'
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**测试政策**'
- en: 'Embedding testing code in your project is an excellent idea, but how that code
    is run is also extremely important. Too many projects have test code lying around
    that fails to run for some reason or other. This topic is not strictly limited
    to Python, but I consider it important enough to emphasize here: you should have
    a zero-tolerance policy regarding untested code. No code should be merged without
    a proper set of unit tests to cover it.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试代码嵌入项目是一个极好的主意，但如何运行这些代码同样至关重要。许多项目中有测试代码存在，但由于某些原因无法运行。这个话题不仅限于 Python，但我认为它足够重要，值得在这里强调：你应该对未测试的代码采取零容忍政策。没有经过适当单元测试的代码不应被合并。
- en: The minimum you should aim for is that each of the commits you push passes all
    the tests. Automating this process is even better. For example, OpenStack relies
    on a specific workflow based on *Gerrit* (a web-based code review service) and
    *Zuul* (a continuous integration and delivery service). Each commit pushed goes
    through the code review system provided by Gerrit, and Zuul is in charge of running
    a set of testing jobs. Zuul runs the unit tests and various higher-level functional
    tests for each project. This code review, which is executed by a couple of developers,
    makes sure all code committed has associated unit tests.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该至少确保每个你推送的提交都能通过所有测试。自动化这个过程更好。例如，OpenStack 依赖于基于 *Gerrit*（一个基于 web 的代码审查服务）和
    *Zuul*（一个持续集成和交付服务）的特定工作流。每个提交都会通过 Gerrit 提供的代码审查系统，Zuul 负责运行一系列测试任务。Zuul 会为每个项目运行单元测试和各种更高层次的功能测试。这个由几位开发者执行的代码审查，确保所有提交的代码都有相应的单元测试。
- en: If you’re using the popular GitHub hosting service, *Travis CI* is a tool that
    allows you to run tests after each push or merge or against pull requests that
    are submitted. While it is unfortunate that this testing is done post-push, it’s
    still a fantastic way to track regressions. Travis supports all significant Python
    versions out of the box, and it can be customized significantly. Once you’ve activated
    Travis on your project via the web interface at *[https://www.travis-ci.org/](https://www.travis-ci.org/)*,
    just add a *.travis.yml* file that will determine how the tests are run. [Listing
    6-15](ch06.xhtml#ch6list15) shows an example of a .*travis.yml* file.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是流行的GitHub托管服务，*Travis CI*是一个工具，可以在每次推送、合并后或提交的拉取请求中运行测试。虽然在推送后进行测试是遗憾的，但它仍然是跟踪回归的绝佳方式。Travis默认支持所有主要的Python版本，并且可以进行显著的自定义。一旦通过*https://www.travis-ci.org/*的Web界面在你的项目中激活Travis，只需添加一个*.travis.yml*文件来确定如何运行测试。[清单6-15](ch06.xhtml#ch6list15)展示了一个.*travis.yml*文件的示例。
- en: 'language: python'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 语言：python
- en: 'python:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: python：
- en: '- "2.7"'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '- "2.7"'
- en: '- "3.6"'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '- "3.6"'
- en: command to install dependencies
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装依赖项的命令
- en: 'install: "pip install -r requirements.txt --use-mirrors"'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 安装："pip install -r requirements.txt --use-mirrors"
- en: command to run tests
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试的命令
- en: 'script: pytest'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本：pytest
- en: '*Listing 6-15: A .travis.yml example file*'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-15：一个.travis.yml示例文件*'
- en: With this file in place in your code repository and Travis enabled, the latter
    will spawn a set of jobs to test your code with the associated unit tests. It’s
    easy to see how you can customize this by simply adding dependencies and tests.
    Travis is a paid service, but the good news is that for open source projects,
    it’s entirely free!
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件放入你的代码库并启用Travis后，Travis将启动一组作业，使用相关的单元测试对你的代码进行测试。很容易看到，你可以通过简单地添加依赖项和测试来定制这一过程。Travis是一个付费服务，但好消息是，对于开源项目，它完全免费！
- en: The tox-travis package (*[https://pypi.python.org/pypi/tox-travis/](https://pypi.python.org/pypi/tox-travis/)*)
    is also worth looking into, as it will polish the integration between tox and
    Travis by running the correct tox target depending on the Travis environment being
    used. [Listing 6-16](ch06.xhtml#ch6list16) shows an example of a *.travis.yml*
    file that will install tox-travis before running tox.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: tox-travis包（*[https://pypi.python.org/pypi/tox-travis/](https://pypi.python.org/pypi/tox-travis/)）也值得研究，它通过根据所使用的Travis环境运行正确的tox目标，优化了tox与Travis之间的集成。[清单6-16](ch06.xhtml#ch6list16)展示了一个示例*.travis.yml*文件，它将在运行tox之前安装tox-travis。
- en: 'sudo: false'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: sudo：false
- en: 'language: python'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 语言：python
- en: 'python:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: python：
- en: '- "2.7"'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '- "2.7"'
- en: '- "3.4"'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '- "3.4"'
- en: 'install: pip install tox-travis'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 安装：pip install tox-travis
- en: 'script: tox'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本：tox
- en: '*Listing 6-16: A .travis.yml example file with tox-travis*'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-16：带有tox-travis的.travis.yml示例文件*'
- en: Using tox-travis, you can simply call tox as the script on Travis, and it will
    call tox with the environment you specify here in the *.travis.yml* file, building
    the necessary virtual environment, installing the dependency, and running the
    commands you specified in *tox.ini*. This makes it easy to use the same workflow
    both on your local development machine and on the Travis continuous integration
    platform.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 使用tox-travis，你只需在Travis中调用tox作为脚本，它会使用你在*.travis.yml*文件中指定的环境来调用tox，构建必要的虚拟环境，安装依赖项，并运行你在*tox.ini*中指定的命令。这使得在本地开发机器和Travis持续集成平台上使用相同的工作流程变得容易。
- en: These days, wherever your code is hosted, it is always possible to apply some
    automatic testing of your software and to make sure your project is moving forward,
    not being held back by the addition of bugs.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，无论你的代码托管在哪里，始终可以对软件进行自动化测试，并确保你的项目在向前推进，而不是因为引入漏洞而停滞不前。
- en: '**Robert Collins on Testing**'
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**罗伯特·柯林斯关于测试**'
- en: Robert Collins is, among other things, the original author of the *Bazaar* distributed
    version control system. Today, he is a Distinguished Technologist at HP Cloud
    Services, where he works on OpenStack. Robert is also the author of many of the
    Python tools described in this book, such as fixtures, testscenarios, testrepository,
    and even python-subunit—you may have used one of his programs without knowing
    it!
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特·柯林斯不仅是*Bazaar*分布式版本控制系统的原创作者，还担任HP云服务的杰出技术专家，致力于OpenStack的工作。罗伯特还是本书中描述的许多Python工具的作者，比如fixtures、testscenarios、testrepository，甚至python-subunit——你可能在不知情的情况下使用过他的某个程序！
- en: '**What kind of testing policy would you advise using? Is it ever acceptable
    not to test code?**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**你建议使用什么样的测试策略？是否有时候可以不进行代码测试？**'
- en: 'I think testing is an engineering trade-off: you must consider the likelihood
    of a failure slipping through to production undetected, the cost and size of an
    undetected failure, and cohesion of the team doing the work. Take OpenStack, which
    has 1,600 contributors: it’s difficult to work with a nuanced policy with so many
    people with their own opinions. Generally speaking, a project needs some automated
    testing to check that the code will do what it is intended to do, and that what
    it is intended to do is what is needed. Often that requires functional tests that
    might be in different codebases. Unit tests are excellent for speed and pinning
    down corner cases. I think it is okay to vary the balance between styles of testing,
    as long as there is testing.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为测试是一个工程权衡：你必须考虑故障未被检测到而滑入生产环境的可能性、未被检测到的故障的成本和规模，以及执行工作的团队的凝聚力。以 OpenStack
    为例，它有 1,600 个贡献者：如此多人各有不同意见，很难协作制定微妙的政策。一般来说，一个项目需要一些自动化测试，以检查代码是否按预期工作，以及它是否做了所需的事情。通常这需要跨不同代码库的功能测试。单元测试非常适合快速定位和解决边界情况。我认为在测试风格之间调整平衡是可以的，只要有进行测试。
- en: 'Where the cost of testing is very high and the returns are very low, I think
    it’s fine to make an informed decision not to test, but that situation is relatively
    rare: most things can be tested reasonably cheaply, and the benefit of catching
    errors early is usually quite high.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试成本非常高，而收益非常低时，我认为做出不进行测试的知情决定是可以接受的，但这种情况相对较少：大多数事情可以以较低的成本进行合理的测试，且早期发现错误的收益通常很高。
- en: '**What are the best strategies when writing Python code to make testing manageable
    and improve the quality of the code?**'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '**编写 Python 代码时，哪些策略能使测试变得可管理并提高代码质量？**'
- en: Separate out concerns and don’t do multiple things in one place; this makes
    reuse natural, and that makes it easier to put test doubles in place. Take a purely
    functional approach when possible; for example, in a single method either calculate
    something or change some state, but avoid doing both. That way you can test all
    of the calculating behaviors without dealing with state changes, such as writing
    to a database or talking to an HTTP server. The benefit works the other way around
    too—you can replace the calculation logic for tests to provoke corner case behavior
    and use mocks and test doubles to check that the expected state propagation happens
    as desired. The most heinous things to test are deeply layered stacks with complex
    cross-layer behavioral dependencies. There you want to evolve the code so that
    the contract between layers is simple, predictable, and—most usefully for testing—replaceable.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 将不同的关注点分离开来，不要在一个地方做多个事情；这样可以让重用变得自然，并且让测试替代品的使用更加容易。尽可能采用纯粹的函数式方法；例如，在一个方法中要么进行计算，要么改变某些状态，但避免同时做两者。这样你可以仅测试所有的计算行为，而不涉及状态变化，比如写入数据库或与
    HTTP 服务器交互。反过来也有好处——你可以替换测试中的计算逻辑，激发边界情况行为，并使用 mocks 和测试替代品来检查预期的状态传播是否如愿发生。最难测试的情况是深层堆栈和复杂的跨层行为依赖。对于这种情况，你需要使代码演进，以确保各层之间的契约简单、可预测，并且——对测试最有用——可替代。
- en: '**What’s the best way to organize unit tests in source code?**'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何在源代码中组织单元测试最为合适？**'
- en: Have a clear hierarchy, like *$ROOT/$PACKAGE/tests*. I tend to do just one hierarchy
    for a whole source tree, for example *$ROOT/$PACKAGE/$SUBPACKAGE/tests*.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有清晰的层次结构，比如 *$ROOT / $PACKAGE / tests*。我倾向于为整个源代码树做一个层次结构，例如 *$ROOT / $PACKAGE
    / $SUBPACKAGE / tests*。
- en: 'Within tests, I often mirror the structure of the rest of the source tree:
    *$ROOT/$PACKAGE/foo.py* would be tested in *$ROOT/$PACKAGE/tests/test_foo.py*.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我经常镜像源代码树的结构：* $ROOT / $PACKAGE / foo.py* 会在 *$ROOT / $PACKAGE / tests
    / test_foo.py* 中进行测试。
- en: The rest of the tree should not import from the tests tree, except perhaps in
    the case of a test_suite/load_tests function in the top level __init__. This permits
    you to easily detach the tests for small-footprint installations.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 其他部分的代码不应导入测试代码树，除了可能在顶层的 __init__ 中使用 test_suite/load_tests 函数。这使得你可以轻松地将测试与小体积的安装隔离开来。
- en: '**What do you see as the future of unit-testing libraries and frameworks in
    Python?**'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**你如何看待 Python 中单元测试库和框架的未来？**'
- en: 'The significant challenges I see are these:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到的主要挑战有以下几点：
- en: The continued expansion of parallel capabilities in new machines, like phones
    with four CPUs. Existing unit test internal APIs are not optimized for parallel
    workloads. My work on the StreamResult Java class is aimed directly at resolving
    this.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新机器中并行能力的持续扩展，例如拥有四个CPU的手机。现有的单元测试内部API并未针对并行工作负载进行优化。我在StreamResult Java类上的工作正是直接解决这一问题。
- en: More complex scheduling support—a less ugly solution for the problems that class
    and module-scoped setup aim at.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更复杂的调度支持——为类和模块作用域设置目标提供一种不那么丑陋的解决方案。
- en: 'Finding some way to consolidate the vast variety of frameworks we have today:
    for integration testing, it would be great to be able to get a consolidated view
    across multiple projects that have different test runners in use.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找某种方法来整合我们今天所拥有的各种框架：对于集成测试来说，能够在多个使用不同测试运行器的项目之间获得一个整合视图将是非常有帮助的。
