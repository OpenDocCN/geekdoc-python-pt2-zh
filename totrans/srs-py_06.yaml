- en: '**6**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**UNIT TESTING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Many find unit testing to be arduous and time-consuming, and some people and
    projects have no testing policy. This chapter assumes that you see the wisdom
    of unit testing! Writing code that is not tested is fundamentally useless, as
    there’s no way to conclusively prove that it works. If you need convincing, I
    suggest you start by reading about the benefits of test-driven development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you’ll learn about the Python tools you can use to construct
    a comprehensive suite of tests that will make testing simpler and more automated.
    We’ll talk about how you can use tools to make your software rock solid and regression-free.
    We’ll cover creating reusable test objects, running tests in parallel, revealing
    untested code, and using virtual environments to make sure your tests are clean,
    as well as some other good-practice methods and ideas.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**The Basics of Testing**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing and running unit tests is uncomplicated in Python. The process is not
    intrusive or disruptive, and unit testing will greatly help you and other developers
    in maintaining your software. Here I’ll discuss some of the absolute basics of
    testing that will make things easier for you.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '***Some Simple Tests***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, you should store tests inside a `tests` submodule of the application
    or library they apply to. Doing so will allow you to ship the tests as part of
    your module so that they can be run or reused by anyone—even after your software
    is installed—without necessarily using the source package. Making the tests a
    submodule of your main module also prevents them from being installed by mistake
    in a top-level `tests` module.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Using a hierarchy in your test tree that mimics the hierarchy of your module
    tree will make the tests more manageable. This means that the tests covering the
    code of *mylib/foobar.py* should be stored inside *mylib/tests/test_foobar.py*.
    Consistent nomenclature makes things simpler when you’re looking for the tests
    related to a particular file. [Listing 6-1](ch06.xhtml#ch6list1) shows the simplest
    unit test you can write.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: A really simple test in test_true.py*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: This will simply assert that the behavior of the program is what you expect.
    To run this test, you need to load the *test_true.py* file and run the `test_true()`
    function defined within.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: However, writing and running an individual test for each of your test files
    and functions would be a pain. For small projects with simple usage, the `pytest`
    package comes to the rescue—once installed via `pip`, pytest provides the `pytest`
    command, which loads every file whose name starts with *test_* and then executes
    all functions within that start with `test_`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'With just the *test_true.py* file in our source tree, running `pytest` gives
    us the following output:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `-v` option tells `pytest` to be verbose and print the name of each test
    run on a separate line. If a test fails, the output changes to indicate the failure,
    accompanied by the whole traceback.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`选项告诉`pytest`以详细模式运行，并在单独的行上打印每个测试的名称。如果测试失败，输出会变更，显示失败信息，并伴随完整的回溯。'
- en: Let’s add a failing test this time, as shown in [Listing 6-2](ch06.xhtml#ch6list2).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们添加一个失败的测试，如[清单 6-2](ch06.xhtml#ch6list2)所示。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 6-2: A failing test in test_true.py*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-2：test_true.py中的失败测试*'
- en: 'If we run the test file again, here’s what happens:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行测试文件，结果如下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A test fails as soon as an `AssertionError` exception is raised; our `assert`
    test will raise an `AssertionError` when its argument is evaluated to something
    false (`False`, `None`, 0, etc.). If any other exception is raised, the test also
    errors out.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦抛出`AssertionError`异常，测试就会失败；当`assert`测试的参数被评估为假值（`False`、`None`、0等）时，它会抛出`AssertionError`异常。如果抛出其他异常，测试也会报错。
- en: Simple, isn’t it? While simplistic, a lot of small projects use this approach
    and it works very well. Those projects require no tools or libraries other than
    pytest and thus can rely on simple `assert` tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，不是吗？虽然简单，但很多小项目都使用这种方法，而且效果非常好。这些项目除了`pytest`外不需要任何工具或库，因此可以依赖简单的`assert`测试。
- en: 'As you start to write more sophisticated tests, pytest will help you understand
    what’s wrong in your failing tests. Imagine the following test:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写更复杂的测试时，`pytest`将帮助你理解失败测试中的问题。想象一下以下测试：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When `pytest` is run, it gives the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`pytest`时，它会显示如下输出：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This tells us that `a` and `b` are different and that this test does not pass.
    It also tells us exactly how they are different, making it easy to fix the test
    or code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们`a`和`b`是不同的，并且该测试没有通过。它还告诉我们它们具体的不同之处，使得修复测试或代码变得容易。
- en: '***Skipping Tests***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跳过测试***'
- en: If a test cannot be run, you will probably want to skip that test—for example,
    you may wish to run a test conditionally based on the presence or absence of a
    particular library. To that end, you can use the `pytest.skip()` function, which
    will mark the test as skipped and move on to the next one. The `pytest.mark.skip`
    decorator skips the decorated test function unconditionally, so you’ll use it
    when a test always needs to be skipped. [Listing 6-3](ch06.xhtml#ch6list3) shows
    how to skip a test using these methods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个测试无法运行，你可能想要跳过该测试——例如，你可能希望根据某个特定库的存在与否来有条件地运行测试。为此，你可以使用`pytest.skip()`函数，它会将测试标记为跳过，并继续执行下一个测试。`pytest.mark.skip`装饰器会无条件跳过被装饰的测试函数，因此当某个测试始终需要跳过时，你会使用它。[清单
    6-3](ch06.xhtml#ch6list3)展示了如何使用这些方法跳过测试。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-3: Skipping tests*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-3：跳过测试*'
- en: 'When executed, this test file will output the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，这个测试文件将输出以下内容：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output of the test run in [Listing 6-3](ch06.xhtml#ch6list3) indicates that,
    in this case, all the tests have been skipped. This information allows you to
    ensure you didn’t accidentally skip a test you expected to run.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 6-3](ch06.xhtml#ch6list3)中的测试运行输出表明，在这种情况下，所有测试都被跳过了。这些信息让你可以确保没有意外跳过你期望运行的测试。
- en: '***Running Particular Tests***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行特定测试***'
- en: When using `pytest`, you often want to run only a particular subset of your
    tests. You can select which tests you want to run by passing their directory or
    files as an argument to the `pytest` command line. For example, calling `pytest
    test_one.py` will only run the *test_one.py* test. Pytest also accepts a directory
    as argument, and in that case, it will recursively scan the directory and run
    any file that matches the *test_*.py* pattern.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pytest`时，你通常只想运行某一特定子集的测试。你可以通过将目录或文件作为参数传递给`pytest`命令行来选择运行的测试。例如，调用`pytest
    test_one.py`将只运行*test_one.py*测试。`pytest`也接受目录作为参数，在这种情况下，它会递归扫描该目录并运行任何匹配*test_*.py*模式的文件。
- en: You can also add a filter with the `-k` argument on the command line in order
    to execute only the test matching a name, as shown in [Listing 6-4](ch06.xhtml#ch6list4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在命令行中使用`-k`参数添加筛选器，以便仅执行与某个名称匹配的测试，如[清单 6-4](ch06.xhtml#ch6list4)所示。
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 6-4: Filtering tests run by name*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 6-4：按名称筛选运行的测试*'
- en: 'Names are not always the best way to filter which tests will run. Commonly,
    a developer would group tests by functionalities or types instead. Pytest provides
    a dynamic marking system that allows you to mark tests with a keyword that can
    be used as a filter. To mark tests in this way, use the `-m` option. If we set
    up a couple of tests like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 名称并不总是过滤将要运行的测试的最佳方式。通常，开发人员会根据功能或类型将测试分组。Pytest提供了一个动态标记系统，允许你使用关键字标记测试，并可以用作过滤器。要以这种方式标记测试，请使用`-m`选项。如果我们像这样设置几个测试：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'we can use the `-m` argument with `pytest` to run only one of those tests:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-m`参数和`pytest`只运行其中一个测试：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `-m` marker accepts more complex queries, so we can also run all tests
    that are *not* marked:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m`标记接受更复杂的查询，因此我们也可以运行所有*未*标记的测试：'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here pytest executed every test that was not marked as `dicttest`—in this case,
    the `test_something_else` test, which failed. The remaining marked test, `test_something`,
    was not executed and so is listed as `deselected`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里pytest执行了所有未标记为`dicttest`的测试——在这种情况下，`test_something_else`测试失败了。剩下的标记测试`test_something`没有执行，因此被列为`deselected`。
- en: Pytest accepts complex expressions composed of the `or`, `and`, and `not` keywords,
    allowing you to do more advanced filtering.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest接受由`or`、`and`和`not`关键字组成的复杂表达式，允许你进行更高级的过滤。
- en: '***Running Tests in Parallel***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***并行运行测试***'
- en: Test suites can take a long time to run. It’s not uncommon for a full suite
    of unit tests to take tens of minutes to run in large software projects. By default,
    pytest runs all tests serially, in an undefined order. Since most computers have
    several CPUs, you can usually speed things up if you split the list of tests and
    run them on multiple CPUs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件可能需要很长时间才能运行。在大型软件项目中，完整的单元测试套件通常需要几十分钟才能运行。默认情况下，pytest按顺序执行所有测试，顺序是未定义的。由于大多数计算机都有多个CPU，你通常可以通过将测试列表拆分并在多个CPU上运行它们来加速测试过程。
- en: To handle this approach, pytest provides the plugin `pytest-xdist`, which you
    can install with `pip`. This plugin extends the pytest command line with the `--numprocesses`
    argument (shortened as `-n`), which accepts as its argument the number of CPUs
    to use. Running `pytest -n 4` would run your test suite using four parallel processes,
    balancing the load across the available CPUs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种方法，pytest提供了插件`pytest-xdist`，你可以通过`pip`安装此插件。此插件通过`--numprocesses`参数（缩写为`-n`）扩展了pytest命令行，该参数的值为要使用的CPU数量。运行`pytest
    -n 4`将使用四个并行进程运行你的测试套件，在可用的CPU之间平衡负载。
- en: Because the number of CPUs can change from one computer to another, the plugin
    also accepts the `auto` keyword as a value. In this case, it will probe the machine
    to retrieve the number of CPUs available and start this number of processes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为CPU的数量可能因计算机而异，所以该插件还接受`auto`关键字作为值。在这种情况下，它会探测机器以获取可用的CPU数量，并启动相应数量的进程。
- en: '***Creating Objects Used in Tests with Fixtures***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Fixtures创建用于测试的对象***'
- en: In unit testing, you’ll often need to execute a set of common instructions before
    and after running a test, and those instructions will use certain components.
    For example, you might need an object that represents the configuration state
    of your application, and you’ll likely want that object to be initialized before
    each test, then reset to its default values when the test is achieved. Similarly,
    if your test relies on the temporary creation of a file, the file must be created
    before the test starts and deleted once the test is done. These components, known
    as *fixtures*, are set up before a test and cleaned up after the test has finished.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，你通常需要在运行测试前后执行一组常见的指令，这些指令将使用某些组件。例如，你可能需要一个表示应用程序配置状态的对象，并且你可能希望在每个测试之前初始化该对象，然后在测试完成后将其重置为默认值。同样，如果你的测试依赖于临时创建一个文件，那么该文件必须在测试开始之前创建，并在测试完成后删除。这些组件被称为*fixtures*，在测试之前进行设置，并在测试完成后进行清理。
- en: With pytest, fixtures are defined as simple functions. The fixture function
    should return the desired object(s) so that a test using that fixture can use
    that object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在pytest中，fixture被定义为简单的函数。fixture函数应返回所需的对象，以便使用该fixture的测试可以使用该对象。
- en: 'Here’s a simple fixture:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的fixture：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The database fixture is automatically used by any test that has `database` in
    its argument list. The `test_insert()` function will receive the result of the
    `database()` function as its first argument and use that result as it wants. When
    we use a fixture this way, we don’t need to repeat the database initialization
    code several times.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库fixture会自动被任何在其参数列表中包含`database`的测试使用。`test_insert()`函数将接收`database()`函数的结果作为第一个参数，并根据需要使用该结果。当我们以这种方式使用fixture时，我们不需要重复多次数据库初始化代码。
- en: Another common feature of code testing is tearing down after a test has used
    a fixture. For example, you may need to close a database connection. Implementing
    the fixture as a generator allows us to add teardown functionality, as shown in
    [Listing 6-5](ch06.xhtml#ch6list5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码测试的另一个常见功能是，在测试使用完fixture后进行清理。例如，你可能需要关闭数据库连接。将fixture实现为生成器允许我们添加清理功能，如[示例6-5](ch06.xhtml#ch6list5)所示。
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-5: Teardown functionality*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例6-5：清理功能*'
- en: Because we used the `yield` keyword and made `database` a generator, the code
    after the `yield` statement runs when the test is done. That code will close the
    database connection at the end of the test.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了`yield`关键字并使`database`成为一个生成器，所以`yield`语句之后的代码将在测试完成后运行。该代码会在测试结束时关闭数据库连接。
- en: 'However, closing a database connection for each test might impose an unnecessary
    runtime cost, as tests may be able to reuse that same connection. In that case,
    you can pass the `scope` argument to the fixture decorator, specifying the scope
    of the fixture:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为每个测试关闭数据库连接可能会增加不必要的运行时开销，因为测试可能能够重用相同的连接。在这种情况下，你可以通过将`scope`参数传递给装饰器来指定fixture的作用范围：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By specifying the `scope="module"` parameter, you initialize the fixture once
    for the whole module, and the same database connection will be passed to all test
    functions requesting a database connection.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定`scope="module"`参数，你可以在整个模块中初始化fixture一次，所有请求数据库连接的测试函数都会接收到相同的数据库连接。
- en: 'Finally, you can run some common code before and after your tests by marking
    fixtures as *automatically used* with the `autouse` keyword, rather than specifying
    them as an argument for each of the test functions. Specifying the `autouse=True`
    keyword argument to the `pytest.fixture()` function will make sure the fixture
    is called before running any test in the module or class it is defined in, as
    in this example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在测试前后运行一些公共代码，通过使用`autouse`关键字将fixtures标记为*自动使用*，而不是将其作为每个测试函数的参数来指定。向`pytest.fixture()`函数指定`autouse=True`关键字参数，可以确保在模块或类中定义的任何测试运行之前，都会调用该fixture，正如以下示例所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Such automatically enabled features are handy, but make sure not to abuse fixtures:
    they are run before each and every test covered by their scope, so they can slow
    down a test run significantly.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自动启用的功能很方便，但要确保不要滥用fixtures：它们会在其作用范围内的每个测试之前运行，因此可能会显著减慢测试运行速度。
- en: '***Running Test Scenarios***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行测试场景***'
- en: When unit testing, you may want to run the same error-handling test with several
    different objects that trigger that error, or you may want to run an entire test
    suite against different drivers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试时，你可能希望使用几个不同的对象来运行相同的错误处理测试，这些对象会触发该错误，或者你可能希望在不同的驱动程序上运行整个测试套件。
- en: We relied heavily on this latter approach when developing *Gnocchi*, a time
    series database. Gnocchi provides an abstract class that we call the *storage
    API*. Any Python class can implement this abstract base and register itself to
    become a driver. The software loads the configured storage driver when required
    and uses the implemented storage API to store or retrieve data. In this case,
    we need a class of unit tests that runs against each driver—thus running against
    each implementation of this storage API—to be sure all drivers conform to what
    the callers expect.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发*Gnocchi*（一个时间序列数据库）时，我们在很大程度上依赖了这种后者的方法。Gnocchi提供了一个我们称之为*存储API*的抽象类。任何Python类都可以实现这个抽象基类并注册自己成为一个驱动程序。软件在需要时加载配置的存储驱动程序，并使用实现的存储API来存储或检索数据。在这种情况下，我们需要一个单元测试类，它可以在每个驱动程序上运行——从而对每个存储API的实现进行测试——以确保所有驱动程序符合调用者的期望。
- en: 'An easy way to achieve this is by using *parameterized fixtures*, which will
    run all the tests that use them several times, once for each of the defined parameters.
    [Listing 6-6](ch06.xhtml#ch6list6) shows an example of using parameterized fixtures
    to run a single test twice with different parameters: once for `mysql` and once
    for `postgresql`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-6: Running a test using parameterized fixtures*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 6-6](ch06.xhtml#ch6list6), the `driver` fixture is parameterized
    with two different values, each the name of a database driver that is supported
    by the application. When `test_insert` is run, it is actually run twice: once
    with a MySQL database connection and once with a PostgreSQL database connection.
    This allows us to easily reuse the same test with different scenarios, without
    adding many lines of code.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '***Controlled Tests Using Mocking***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mock objects are simulated objects that mimic the behavior of real application
    objects, but in particular and controlled ways. These are especially useful in
    creating environments that describe precisely the conditions for which you would
    like to test code. You can replace all objects but one with mock objects to isolate
    the behavior of your focus object and create an enviroment for testing your code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: One use case is in writing an HTTP client, since it is likely impossible (or
    at least extremely complicated) to spawn the HTTP server and test it through all
    scenarios to return every possible value. HTTP clients are especially difficult
    to test for all failure scenarios.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library for creating mock objects in Python is `mock`. Starting
    with Python 3.3, `mock` has been merged into the Python Standard Library as `unittest.mock`.
    You can, therefore, use a snippet like the following to maintain backward compatibility
    between Python 3.3 and earlier versions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `mock` library is pretty simple to use. Any attribute accessed on a `mock.Mock`
    object is dynamically created at runtime. Any value can be set to such an attribute.
    [Listing 6-7](ch06.xhtml#ch6list7) shows `mock` being used to create a fake object
    with a fake attribute.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 6-7: Accessing the mock.Mock attribute*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: You can also dynamically create a method on a malleable object, as in [Listing
    6-8](ch06.xhtml#ch6list8) where we create a fake method that always returns 42
    and accepts anything as an argument.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 6-8: Creating methods on a mock.Mock object*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: In just a few lines, your `mock.Mock` object now has a `some_method()` method
    that returns 42\. It accepts any kind of argument, and there is no check on what
    the values are—yet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically created methods can also have (intentional) side effects. Rather
    than being boilerplate methods that just return a value, they can be defined to
    execute useful code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-9](ch06.xhtml#ch6list9) creates a fake method that has the side
    effect of printing the "`hello world`" string.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 6-9: Creating methods on a mock.Mock object with side effects*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: We assign an entire function to the `some_method` attribute ➊. This technique
    allows us to implement more complex scenarios in a test because we can plug any
    code needed for testing into a mock object. We then just need to pass this mock
    object to whichever function expects it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The `call_count` attribute ➋ is a simple way of checking the number of times
    a method has been called.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mock` library uses the action/assertion pattern: this means that once
    your test has run, it’s up to you to check that the actions you are mocking were
    correctly executed. [Listing 6-10](ch06.xhtml#ch6list10) applies the `assert()`
    method to our mock objects to perform these checks.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 6-10: Checking method calls*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We create a method with the arguments `foo` and `bar` to stand in as our tests
    by calling the method ➊. The usual way to check calls to a mock object is to use
    the `assert_called()` methods, such as `assert_called_once_with()` ➋. To these
    methods, you need to pass the values that you expect callers to use when calling
    your mock method. If the values passed are not the ones being used, then `mock`
    raises an `AssertionError`. If you don’t know what arguments may be passed, you
    can use `mock.ANY` as a value ➌; that will match any argument passed to your mock
    method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Th `mock` library can also be used to patch some function, method, or object
    from an external module. In [Listing 6-11](ch06.xhtml#ch6list11), we replace the
    `os.unlink()` function with a fake function we provide.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 6-11: Using mock.patch*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: When used as a context manager, `mock.patch()` replaces the target function
    with the function we provide so the code executed inside the context uses that
    patched method. With the `mock.patch()` method, it’s possible to change any part
    of an external piece of code, making it behave in a way that lets you test all
    conditions in your application, as shown in [Listing 6-12](ch06.xhtml#ch6list12).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 6-12: Using mock.patch() to test a set of behaviors*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-12](ch06.xhtml#ch6list12) implements a test suite that searches
    for all instances of the string “Python is a programming language” on the *[http://python.org/](http://python.org/)*
    web page ➊. There is no way to test negative scenarios (where this sentence is
    not on the web page) without modifying the page itself—something we’re not able
    to do, obviously. In this case, we’re using `mock` to cheat and change the behavior
    of the request so it returns a mocked reply with a fake page that doesn’t contain
    that string. This allows us to test the negative scenario in which *[http://python.org/](http://python.org/)*
    does not contain this sentence, making sure the program handles that case correctly.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: This example uses the decorator version of `mock.patch()` ➋. Using the decorator
    does not change the mocking behavior, but it is simpler when you need to use mocking
    within the context of an entire test function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Using mocking, we can simulate any problem, such as a web server returning a
    404 error, an I/O error, or a network latency issue. We can make sure code returns
    the correct values or raises the correct exception in every case, ensuring our
    code always behaves as expected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟（mocking），我们可以模拟任何问题，比如Web服务器返回404错误、I/O错误或网络延迟问题。我们可以确保代码在每种情况下都返回正确的值或抛出正确的异常，确保我们的代码始终按预期行为运行。
- en: '***Revealing Untested Code with coverage***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***揭示未测试的代码与覆盖率***'
- en: A great complement to unit testing, the `coverage` tool identifies whether any
    of your code has been missed during testing. It uses code analysis tools and tracing
    hooks to determine which lines of your code have been executed; when used during
    a unit test run, it can show you which parts of your codebase have been crossed
    over and which parts have not. Writing tests is useful, but having a way to know
    what part of your code you may have missed during the testing process is the cherry
    on the cake.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverage`工具是单元测试的一个极好补充，它能识别出在测试过程中是否漏掉了某些代码。它使用代码分析工具和追踪钩子来确定哪些代码行已经执行；在单元测试运行时，它能显示出代码库的哪些部分已被覆盖，哪些部分没有。编写测试是有用的，但知道在测试过程中可能遗漏了哪些代码是锦上添花。'
- en: Install the `coverage` Python module on your system via `pip` to have access
    to the `coverage` program command from your shell.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`pip`安装`coverage` Python模块，即可在终端中访问`coverage`命令。
- en: '**NOTE**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The command may also be named python-coverage, if you install coverage through
    your operating system installation software. This is the case on Debian, for example.*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你通过操作系统的软件包管理工具安装`coverage`，该命令也可能被命名为python-coverage。例如，在Debian上就是如此。*'
- en: Using `coverage` in stand-alone mode is straightforward. It can show you parts
    of your programs that are never run and which code might be “dead code,” that
    is, code that could be removed without modifying the normal workflow of the program.
    All the test tools we’ve talked about so far in this chapter are integrated with
    `coverage`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`coverage`独立模式非常简单。它能显示程序中从未执行过的部分，以及哪些代码可能是“死代码”，即那些可以删除而不会影响程序正常工作流的代码。我们在本章讨论的所有测试工具都与`coverage`集成。
- en: When using `pytest`, just install the `pytest-cov` plugin via `pip install pytest-pycov`
    and add a few option switches to generate a detailed code coverage output, as
    shown in [Listing 6-13](ch06.xhtml#ch6list13).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`pytest`时，只需通过`pip install pytest-pycov`安装`pytest-cov`插件，并添加一些选项开关来生成详细的代码覆盖率输出，如[清单6-13](ch06.xhtml#ch6list13)所示。
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 6-13: Using coverage with pytest*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-13：在pytest中使用coverage*'
- en: The `--cov` option enables the coverage report at the end of the test run. You
    need to pass the package name as an argument for the plugin to filter the coverage
    report properly. The output includes the lines of code that were not run and therefore
    have no tests. All you need to do now is spawn your favorite text editor and start
    writing tests for that code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cov`选项会在测试运行结束时启用覆盖率报告。你需要传递包名称作为参数，以便插件正确地过滤覆盖率报告。输出包括那些未执行的代码行，因此没有测试。现在你只需打开你最喜欢的文本编辑器，开始为那些代码编写测试。'
- en: However, `coverage` goes one better, allowing you to generate clear HTML reports.
    Simply add the `--cov-report=html` flag, and the *htmlcov* directory from which
    you ran the command will be populated with HTML pages. Each page will show you
    which parts of your source code were or were not run.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`coverage`更进一步，允许你生成清晰的HTML报告。只需添加`--cov-report=html`标志，然后运行该命令的*htmlcov*目录将会生成HTML页面。每个页面将显示你源代码中的哪些部分已被执行，哪些没有。
- en: If you want to be *that* person, you can use the option `--cover-fail-under=COVER_MIN_PERCENTAGE`,
    which will make the test suite fail if a minimum percentage of the code is not
    executed when the test suite is run. While having a good coverage percentage is
    a decent goal, and while the tool is useful to gain insight into the state of
    your test coverage, defining an arbitrary percentage value does not provide much
    insight. [Figure 6-1](ch06.xhtml#ch6fig1) shows an example of a coverage report
    with the percentage at the top.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想成为*那种*人，可以使用选项`--cover-fail-under=COVER_MIN_PERCENTAGE`，当测试套件运行时，如果代码的最低百分比未被执行，测试套件将失败。虽然有一个良好的覆盖率百分比是一个不错的目标，并且该工具有助于深入了解测试覆盖率的状态，但定义一个任意的百分比值并不能提供太多见解。[图6-1](ch06.xhtml#ch6fig1)展示了一个覆盖率报告的示例，顶部显示了百分比。
- en: For example, a code coverage score of 100 percent is a respectable goal, but
    it does not necessarily mean the code is entirely tested and you can rest. It
    only proves that your whole code path has been run; there is no indication that
    every possible condition has been tested.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，100% 的代码覆盖率是一个值得尊敬的目标，但这并不一定意味着代码已经完全测试过，你可以松一口气。它仅仅证明了你的整个代码路径已经运行过；并没有说明每一个可能的条件都已经被测试过。
- en: You should use coverage information to consolidate your test suite and add tests
    for any code that is currently not being run. This facilitates later project maintenance
    and increases your code’s overall quality.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用覆盖率信息来巩固你的测试套件，并为当前没有运行的代码添加测试。这有助于后续的项目维护，并提高代码的整体质量。
- en: '![image](../images/f06-01.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f06-01.jpg)'
- en: '*Figure 6-1: Coverage of ceilometer.publisher*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：ceilometer.publisher 的覆盖率*'
- en: '**Virtual Environments**'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**虚拟环境**'
- en: 'Earlier we mentioned the danger that your tests may not capture the absence
    of dependencies. Any application of significant size inevitably depends on external
    libraries to provide features the application needs, but there are many ways external
    libraries might cause issues on your operating system. Here are a few:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过一个风险，那就是你的测试可能无法捕捉到依赖缺失的问题。任何较大的应用程序不可避免地依赖于外部库来提供应用程序所需的功能，但外部库可能在你的操作系统上引发很多问题。以下是其中一些：
- en: Your system does not have the library you need packaged.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的系统没有打包你需要的库。
- en: Your system does not have the right *version* of the library you need packaged.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的系统没有打包你所需的正确 *版本* 的库。
- en: You need two different versions of the same library for two different applications.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要两个不同版本的相同库来支持两个不同的应用程序。
- en: These problems can happen when you first deploy your application or later on,
    while it’s running. Upgrading a Python library installed via your system manager
    might break your application in a snap without warning, for reasons as simple
    as an API change in the library being used by the application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能发生在你首次部署应用程序时，或者稍后在应用程序运行过程中。通过系统管理器升级一个 Python 库，可能会在没有任何警告的情况下迅速破坏你的应用程序，原因可能只是库的
    API 发生了变化，而该库正被应用程序使用。
- en: The solution is for each application to use a library directory that contains
    all the application’s dependencies. This directory is then used to load the needed
    Python modules rather than the system-installed ones.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是让每个应用程序使用一个包含所有应用程序依赖项的库目录。然后，该目录用于加载所需的 Python 模块，而不是系统安装的模块。
- en: Such a directory is known as a *virtual environment*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的目录被称为*虚拟环境*。
- en: '***Setting Up a Virtual Environment***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置虚拟环境***'
- en: The tool `virtualenv` handles virtual environments automatically for you. Until
    Python 3.2, you’ll find it in the `virtualenv` package that you can install using
    `pip install virtualenv`. If you use Python 3.3 or later, it’s available directly
    via Python under the `venv` name.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 工具 `virtualenv` 会为你自动处理虚拟环境。直到 Python 3.2，你可以通过安装 `virtualenv` 包来使用它，命令是 `pip
    install virtualenv`。如果你使用的是 Python 3.3 或更高版本，它可以通过 Python 的 `venv` 名称直接使用。
- en: 'To use the module, load it as the main program with a destination directory
    as its argument, like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该模块，像这样将其作为主程序加载，并以目标目录作为参数：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once run, `venv` creates a *lib/pythonX.Y* directory and uses it to install
    `pip` into the virtual environment, which will be useful to install further Python
    packages.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行，`venv` 会创建一个 *lib/pythonX.Y* 目录，并使用它将 `pip` 安装到虚拟环境中，这对于安装后续的 Python 包非常有用。
- en: 'You can then activate the virtual environment by “sourcing” the `activate`
    command. Use the following on Posix systems:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过“激活” `activate` 命令来激活虚拟环境。在 Posix 系统上，使用以下命令：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On Windows systems, use this code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统上，使用以下代码：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once you do that, your shell prompt should appear prefixed by the name of your
    virtual environment. Executing `python` will call the version of Python that has
    been copied into the virtual environment. You can check that it’s working by reading
    the `sys.path` variable and checking that it has your virtual environment directory
    as its first component.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，你的 shell 提示符应该会显示虚拟环境的名称。执行 `python` 将调用已经复制到虚拟环境中的 Python 版本。你可以通过查看 `sys.path`
    变量并确认它的第一个组件是虚拟环境目录来检查它是否正常工作。
- en: 'You can stop and leave the virtual environment at any time by calling the `deactivate`
    command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时通过调用 `deactivate` 命令来停止并退出虚拟环境：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That’s it. Also note that you are not forced to run `activate` if you want
    to use the Python installed in your virtual environment just once. Calling the
    `python` binary will also work:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, while we’re in our activated virtual environment, we do not have access
    to any of the modules installed and available on the main system. That is the
    point of using a virtual environment, but it does mean we probably need to install
    the packages we need. To do that, use the standard `pip` command to install each
    package, and the packages will install in the right place, without changing anything
    about your system:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Voilà! We can install all the libraries we need and then run our application
    from this virtual environment, without breaking our system. It’s easy to see how
    we can script this to automate the installation of a virtual environment based
    on a list of dependencies, as in [Listing 6-14](ch06.xhtml#ch6list14).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 6-14: Automatic virtual environment creation*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: It can still be useful to have access to your system-installed packages, so
    `virtualenv` allows you to enable them when creating your virtual environment
    by passing the `--system-site-packages` flag to the `virtualenv` command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Inside `myvenv`, you will find a *pyvenv.cfg*, the configuration file for this
    environment. It doesn’t have a lot of configuration options by default. You should
    recognize `include-system-site-package`, whose purpose is the same as the `--system-site-packages`
    of `virtualenv` that we described earlier.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: As you might guess, virtual environments are incredibly useful for automated
    runs of unit test suites. Their use is so widespread that a particular tool has
    been built to address it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '***Using virtualenv with tox***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the central uses of virtual environments is to provide a clean environment
    for running unit tests. It would be detrimental if you were under the impression
    that your tests were working, when they were not, for example, respecting the
    dependency list.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to ensure you’re accounting for all the dependencies would be to write
    a script to deploy a virtual environment, install `setuptools`, and then install
    all of the dependencies required for both your application/library runtime and
    unit tests. Luckily, this is such a popular use case that an application dedicated
    to this task has already been built: `tox`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The `tox` management tool aims to automate and standardize how tests are run
    in Python. To that end, it provides everything needed to run an entire test suite
    in a clean virtual environment, while also installing your application to check
    that the installation works.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using `tox`, you need to provide a configuration file named *tox.ini*
    that should be placed in the root directory of your project, beside your *setup.py*
    file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can then run `tox` successfully:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this instance, `tox` creates a virtual environment in *.tox/python* using
    the default Python version. It uses *setup.py* to create a distribution of your
    package, which it then installs inside this virtual environment. No commands are
    run, because we did not specify any in the configuration file. This alone is not
    particularly useful.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change this default behavior by adding a command to run inside our test
    environment. Edit *tox.ini* to include the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now `tox` runs the command `pytest`. However, since we do not have `pytest`
    installed in the virtual environment, this command will likely fail. We need to
    list `pytest` as a dependency to be installed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When run now, `tox` re-creates the environment, installs the new dependency,
    and runs the command `pytest`, which executes all of the unit tests. To add more
    dependencies, you can either list them in the `deps` configuration option, as
    is done here, or use the `-rfile` syntax to read from a file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '***Re-creating an Environment***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you’ll need to re-create an environment to, for example, ensure things
    work as expected when a new developer clones the source code repository and runs
    `tox` for the first time. For this, `tox` accepts a `--recreate` option that will
    rebuild the virtual environment from scratch based on parameters you lay out.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'You define the parameters for all virtual environments managed by `tox` in
    the `[testenv]` section of *tox.ini*. And, as mentioned, `tox` can manage multiple
    Python virtual environments—indeed, it is possible to run our tests under a Python
    version other than the default one by passing the `-e` flag to `tox`, like so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'By default, `tox` simulates any environment that matches an existing Python
    version: `py24`, `py25`, `py26`, `py27`, `py30`, `py31`, `py32`, `py33`, `py34`,
    `py35`, `py36`, `py37`, `jython`, and `pypy`! Furthermore, you can define your
    own environments. You just need to add another section named `[testenv:_envname_]`.
    If you want to run a particular command for just one of the environments, you
    can do so easily by listing the following in the *tox.ini* file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'By using `pytest --cov=myproject` under the `py36-coverage` section as shown
    here, you override the commands for the `py36-coverage` environment, meaning when
    you run `tox -e py36-coverage`, `pytest` is installed as part of the dependencies,
    but the command `pytest` is actually run instead with the coverage option. For
    that to work, the `pytest-cov` extension must be installed: to this end, we replace
    the `deps` value with the `deps` from `testenv` and add the `pytest-cov` dependency.
    Variable interpolation is also supported by `tox`, so you can refer to any other
    field from the *tox.ini* file and use it as a variable, the syntax being `{[env_name`]variable_name}.
    This allows us to avoid repeating the same things over and over again.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Different Python Versions***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also create a new environment with an unsupported version of Python
    right away with the following in *tox.ini*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When we run this, it will now (attempt to) use Python 2.1 to run the test suite—although
    since it is very unlikely you have this ancient Python version installed on your
    system, I doubt this would work for you!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s likely that you’ll want to support multiple Python versions, in which
    case it would be useful to have `tox` run all the tests for all the Python versions
    you want to support by default. You can do this by specifying the environment
    list you want to use when `tox` is run without arguments:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When `tox` is launched without any further arguments, all four environments
    listed are created, populated with the dependencies and the application, and then
    run with the command `pytest`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '***Integrating Other Tests***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can also use `tox` to integrate tests like `flake8`, as discussed in [Chapter
    1](ch01.xhtml#ch01). The following *tox.ini* file provides a PEP 8 environment
    that will install `flake8` and run it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this case, the `pep8` environment is run using the default version of Python,
    which is probably fine, though you can still specify the `basepython` option if
    you want to change that.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: When running `tox`, you’ll notice that all the environments are built and run
    sequentially. This can make the process very long, but since virtual environments
    are isolated, nothing prevents you from running `tox` commands in parallel. This
    is exactly what the `detox` package does, by providing a `detox` command that
    runs all of the default environments from *envlist* in parallel. You should `pip
    install` it!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing Policy**'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Embedding testing code in your project is an excellent idea, but how that code
    is run is also extremely important. Too many projects have test code lying around
    that fails to run for some reason or other. This topic is not strictly limited
    to Python, but I consider it important enough to emphasize here: you should have
    a zero-tolerance policy regarding untested code. No code should be merged without
    a proper set of unit tests to cover it.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The minimum you should aim for is that each of the commits you push passes all
    the tests. Automating this process is even better. For example, OpenStack relies
    on a specific workflow based on *Gerrit* (a web-based code review service) and
    *Zuul* (a continuous integration and delivery service). Each commit pushed goes
    through the code review system provided by Gerrit, and Zuul is in charge of running
    a set of testing jobs. Zuul runs the unit tests and various higher-level functional
    tests for each project. This code review, which is executed by a couple of developers,
    makes sure all code committed has associated unit tests.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using the popular GitHub hosting service, *Travis CI* is a tool that
    allows you to run tests after each push or merge or against pull requests that
    are submitted. While it is unfortunate that this testing is done post-push, it’s
    still a fantastic way to track regressions. Travis supports all significant Python
    versions out of the box, and it can be customized significantly. Once you’ve activated
    Travis on your project via the web interface at *[https://www.travis-ci.org/](https://www.travis-ci.org/)*,
    just add a *.travis.yml* file that will determine how the tests are run. [Listing
    6-15](ch06.xhtml#ch6list15) shows an example of a .*travis.yml* file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 6-15: A .travis.yml example file*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: With this file in place in your code repository and Travis enabled, the latter
    will spawn a set of jobs to test your code with the associated unit tests. It’s
    easy to see how you can customize this by simply adding dependencies and tests.
    Travis is a paid service, but the good news is that for open source projects,
    it’s entirely free!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The `tox-travis` package (*[https://pypi.python.org/pypi/tox-travis/](https://pypi.python.org/pypi/tox-travis/)*)
    is also worth looking into, as it will polish the integration between `tox` and
    Travis by running the correct `tox` target depending on the Travis environment
    being used. [Listing 6-16](ch06.xhtml#ch6list16) shows an example of a *.travis.yml*
    file that will install `tox-travis` before running `tox`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 6-16: A .travis.yml example file with tox-travis*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Using `tox-travis`, you can simply call `tox` as the script on Travis, and it
    will call `tox` with the environment you specify here in the *.travis.yml* file,
    building the necessary virtual environment, installing the dependency, and running
    the commands you specified in *tox.ini*. This makes it easy to use the same workflow
    both on your local development machine and on the Travis continuous integration
    platform.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: These days, wherever your code is hosted, it is always possible to apply some
    automatic testing of your software and to make sure your project is moving forward,
    not being held back by the addition of bugs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**Robert Collins on Testing**'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Robert Collins is, among other things, the original author of the *Bazaar* distributed
    version control system. Today, he is a Distinguished Technologist at HP Cloud
    Services, where he works on OpenStack. Robert is also the author of many of the
    Python tools described in this book, such as fixtures, `testscenarios`, `testrepository`,
    and even `python-subunit`—you may have used one of his programs without knowing
    it!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**What kind of testing policy would you advise using? Is it ever acceptable
    not to test code?**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'I think testing is an engineering trade-off: you must consider the likelihood
    of a failure slipping through to production undetected, the cost and size of an
    undetected failure, and cohesion of the team doing the work. Take OpenStack, which
    has 1,600 contributors: it’s difficult to work with a nuanced policy with so many
    people with their own opinions. Generally speaking, a project needs some automated
    testing to check that the code will do what it is intended to do, and that what
    it is intended to do is what is needed. Often that requires functional tests that
    might be in different codebases. Unit tests are excellent for speed and pinning
    down corner cases. I think it is okay to vary the balance between styles of testing,
    as long as there is testing.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Where the cost of testing is very high and the returns are very low, I think
    it’s fine to make an informed decision not to test, but that situation is relatively
    rare: most things can be tested reasonably cheaply, and the benefit of catching
    errors early is usually quite high.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the best strategies when writing Python code to make testing manageable
    and improve the quality of the code?**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Separate out concerns and don’t do multiple things in one place; this makes
    reuse natural, and that makes it easier to put test doubles in place. Take a purely
    functional approach when possible; for example, in a single method either calculate
    something or change some state, but avoid doing both. That way you can test all
    of the calculating behaviors without dealing with state changes, such as writing
    to a database or talking to an HTTP server. The benefit works the other way around
    too—you can replace the calculation logic for tests to provoke corner case behavior
    and use mocks and test doubles to check that the expected state propagation happens
    as desired. The most heinous things to test are deeply layered stacks with complex
    cross-layer behavioral dependencies. There you want to evolve the code so that
    the contract between layers is simple, predictable, and—most usefully for testing—replaceable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**What’s the best way to organize unit tests in source code?**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Have a clear hierarchy, like *$ROOT/$PACKAGE/tests*. I tend to do just one hierarchy
    for a whole source tree, for example *$ROOT/$PACKAGE/$SUBPACKAGE/tests*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Within tests, I often mirror the structure of the rest of the source tree:
    *$ROOT/$PACKAGE/foo.py* would be tested in *$ROOT/$PACKAGE/tests/test_foo.py*.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the tree should not import from the tests tree, except perhaps in
    the case of a `test_suite`/`load_tests` function in the top level `__init__`.
    This permits you to easily detach the tests for small-footprint installations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**What do you see as the future of unit-testing libraries and frameworks in
    Python?**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The significant challenges I see are these:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The continued expansion of parallel capabilities in new machines, like phones
    with four CPUs. Existing unit test internal APIs are not optimized for parallel
    workloads. My work on the StreamResult Java class is aimed directly at resolving
    this.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More complex scheduling support—a less ugly solution for the problems that class
    and module-scoped setup aim at.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finding some way to consolidate the vast variety of frameworks we have today:
    for integration testing, it would be great to be able to get a consolidated view
    across multiple projects that have different test runners in use.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
