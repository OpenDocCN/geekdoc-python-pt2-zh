- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**THE ABSTRACT SYNTAX TREE, HY, AND LISP-LIKE ATTRIBUTES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象语法树、Hy 和类 Lisp 的特性**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: The *abstract syntax tree (AST)* is a representation of the structure of the
    source code of any programming language. Every language, including Python, has
    a specific AST; Python’s AST is built by parsing a Python source file. Like any
    tree, this one is made of nodes linked together. A node can represent an operation,
    a statement, an expression, or even a module. Each node can contain references
    to other nodes that make up the tree.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象语法树（AST）* 是对任何编程语言源代码结构的表示。每种语言，包括 Python，都有其特定的 AST；Python 的 AST 通过解析 Python
    源文件构建。像任何树一样，它由相互连接的节点组成。一个节点可以表示一个操作、语句、表达式，甚至是一个模块。每个节点可以包含对其他构成树的节点的引用。'
- en: Python’s AST is not heavily documented and is thus hard to deal with at first
    glance, but understanding some deeper aspects of how Python is constructed can
    help you master its usage.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 AST 文档不多，因此一开始处理起来可能比较困难，但理解 Python 构建的深层次方面可以帮助你掌握它的使用。
- en: This chapter will examine the AST of some simple Python commands to get you
    familiar with the structure and how it’s used. Once you’re familiar with the AST,
    we’ll build a program that can check for wrongly declared methods using flake8
    and the AST. Finally, we’ll look at Hy, a Python-Lisp hybrid language built on
    the Python AST.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将检查一些简单 Python 命令的 AST，帮助你熟悉其结构和使用方式。一旦你熟悉了 AST，我们将构建一个程序，利用 flake8 和 AST
    检查错误声明的方法。最后，我们将介绍 Hy，这是一种基于 Python AST 构建的 Python-Lisp 混合语言。
- en: '**Looking at the AST**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查看 AST**'
- en: The easiest way to view the Python AST is to parse some Python code and dump
    the generated AST. For that, the Python ast module provides everything you need,
    as shown in [Listing 9-1](ch09.xhtml#ch9list1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Python AST 最简单的方法是解析一些 Python 代码并输出生成的 AST。为此，Python 的 ast 模块提供了所需的一切，正如
    [清单 9-1](ch09.xhtml#ch9list1) 中所示。
- en: '>>> import ast'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import ast'
- en: '>>> ast.parse'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ast.parse'
- en: <function parse at 0x7f062731d950>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <function parse at 0x7f062731d950>
- en: '>>> ast.parse("x = 42")'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ast.parse("x = 42")'
- en: <_ast.Module object at 0x7f0628a5ad10>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <_ast.Module object at 0x7f0628a5ad10>
- en: '>>> ast.dump(ast.parse("x = 42"))'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ast.dump(ast.parse("x = 42"))'
- en: '"Module(body=[Assign(targets=[Name(id=''x'', ctx=Store())], value=Num(n=42))])"'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '"Module(body=[Assign(targets=[Name(id=''x'', ctx=Store())], value=Num(n=42))])"'
- en: '*Listing 9-1: Using the ast module to dump the AST generated by parsing code*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-1：使用 ast 模块输出解析代码生成的 AST*'
- en: 'The ast.parse() function parses any string that contains Python code and returns
    an _ast.Module object. That object is actually the root of the tree: you can browse
    it to discover every node making up the tree. To visualize what the tree looks
    like, you can use the ast.dump() function, which will return a string representation
    of the whole tree.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ast.parse() 函数解析任何包含 Python 代码的字符串，并返回一个 _ast.Module 对象。该对象实际上是树的根节点：你可以浏览它，发现构成树的每个节点。为了可视化树的结构，你可以使用
    ast.dump() 函数，它将返回整个树的字符串表示。
- en: In [Listing 9-1](ch09.xhtml#ch9list1), the code x = 42 is parsed with ast.parse(),
    and the result is printed using ast.dump(). This abstract syntax tree can be rendered
    as shown in [Figure 9-1](ch09.xhtml#ch9fig1), which shows the structure of the
    Python assign command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 9-1](ch09.xhtml#ch9list1) 中，代码 x = 42 被 ast.parse() 解析，结果通过 ast.dump()
    输出。这个抽象语法树可以按 [图 9-1](ch09.xhtml#ch9fig1) 所示渲染，展示了 Python 赋值命令的结构。
- en: '![image](../images/f09-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f09-01.jpg)'
- en: '*Figure 9-1: The AST of the assign command in Python*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：Python 中赋值命令的 AST*'
- en: The AST always starts with a root element, which is usually an _ast.Module object.
    This module object contains a list of statements or expressions to evaluate in
    its *body* attribute and usually represents the content of a file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: AST 总是从根元素开始，通常是一个 _ast.Module 对象。这个模块对象包含一个语句或表达式的列表，在它的 *body* 属性中进行求值，通常表示一个文件的内容。
- en: As you can probably guess, the ast.Assign object shown in [Figure 9-1](ch09.xhtml#ch9fig1)
    represents an *assignment*, which is mapped to the = sign in the Python syntax.
    An ast.Assign object has a list of *targets* and a *value* to set the targets
    to. The list of targets in this case consists of one object, ast.Name, which represents
    a variable whose ID is *x*. The value is a number *n* with a value (in this case)
    42\. The ctx attribute stores a *context*, either ast.Store or ast.Load, depending
    on whether the variable is being used for reading or writing. In this case, the
    variable is being assigned a value, so an ast.Store context is used.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，图[9-1](ch09.xhtml#ch9fig1)中展示的ast.Assign对象表示一个*赋值*，它映射到Python语法中的=符号。ast.Assign对象有一个*targets*列表和一个*value*，用来给targets赋值。在此案例中，targets列表由一个ast.Name对象组成，它代表一个ID为*x*的变量。value是一个值为42的数字*n*。ctx属性存储一个*上下文*，它可以是ast.Store或ast.Load，取决于变量是用于读取还是写入。在此例中，变量正在被赋值，因此使用了ast.Store上下文。
- en: We could pass this AST to Python to be compiled and evaluated via the built-in
    compile() function. This function takes an AST as argument, the source filename,
    and a mode (either 'exec', 'eval', or 'single'). The source filename can be any
    name that you want your AST to appear to be from; it is common to use the string
    <input> as the source filename if the data does not come from a stored file, as
    shown in [Listing 9-2](ch09.xhtml#ch9list2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个AST传递给Python，利用内置的compile()函数进行编译和求值。此函数接受一个AST作为参数、源文件名和模式（可以是'exec'、'eval'或'single'）。源文件名可以是任何你希望AST来自的名称；如果数据不是来自存储文件，通常会使用字符串<input>作为源文件名，正如在[清单
    9-2](ch09.xhtml#ch9list2)中所示。
- en: '>>> compile(ast.parse("x = 42"), ''<input>'', ''exec'')'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> compile(ast.parse("x = 42"), ''<input>'', ''exec'')'
- en: <code object <module> at 0x111b3b0, file "<input>", line 1>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <code object <module> at 0x111b3b0, file "<input>", line 1>
- en: '>>> eval(compile(ast.parse("x = 42"), ''<input>'', ''exec''))'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> eval(compile(ast.parse("x = 42"), ''<input>'', ''exec''))'
- en: '>>> x'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x'
- en: '42'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: '*Listing 9-2: Using the compile() function to compile data that is not from
    a stored file*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-2：使用compile()函数编译非存储文件中的数据*'
- en: The modes stand for execute (exec), evaluate (eval), and single statement (single).
    The mode should match what has been given to ast.parse(), whose default is exec.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式分别代表执行（exec）、求值（eval）和单一语句（single）。模式应与提供给ast.parse()的内容匹配，默认模式为exec。
- en: The exec mode is the normal Python mode, used when an _ast.Module is the root
    of the tree.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: exec模式是Python的常规模式，当_ast.Module是树的根节点时使用。
- en: The eval mode is a special mode that expects a single ast.Expression as the
    tree.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: eval模式是一种特殊模式，期望树结构为单个ast.Expression。
- en: Finally, single is another special mode that expects a single statement or expression.
    If it gets an expression, sys.displayhook() will be called with the result, as
    when code is run in the interactive shell.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，single是一种特殊模式，期望一个单一的语句或表达式。如果它得到的是表达式，则会调用sys.displayhook()来显示结果，就像代码在交互式Shell中运行一样。
- en: The root of the AST is ast.Interactive, and its body attribute is a list of
    nodes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: AST的根节点是ast.Interactive，它的body属性是一个节点列表。
- en: We could build an AST manually using the classes provided in the ast module.
    Obviously, this is a very long way to write Python code and not a method I would
    recommend! Nonetheless, it’s fun to do and helpful for learning about the AST.
    Let’s see what programming with the AST would look like.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用ast模块提供的类手动构建一个AST。显然，这是一种非常冗长的写Python代码的方式，并不是我推荐的做法！然而，这样做很有趣，并且有助于了解AST。让我们来看看使用AST编程是什么样子的。
- en: '***Writing a Program Using the AST***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用AST编写程序***'
- en: Let’s write a good old "Hello world!" program in Python by building an abstract
    syntax tree manually.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过手动构建抽象语法树，写一个传统的“Hello World！”程序。
- en: ➊ >>> hello_world = ast.Str(s='hello world!', lineno=1, col_offset=1)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> hello_world = ast.Str(s='hello world!', lineno=1, col_offset=1)
- en: ➋ >>> print_name = ast.Name(id='print', ctx=ast.Load(), lineno=1, col_offset=1)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> print_name = ast.Name(id='print', ctx=ast.Load(), lineno=1, col_offset=1)
- en: ➌ >>> print_call = ast.Call(func=print_name, ctx=ast.Load(),
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> print_call = ast.Call(func=print_name, ctx=ast.Load(),
- en: '... args=[hello_world], keywords=[], lineno=1, col_offset=1)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '... args=[hello_world], keywords=[], lineno=1, col_offset=1)'
- en: ➍ >>> module = ast.Module(body=[ast.Expr(print_call, ... lineno=1, col_offset=1)],
    lineno=1, col_offset=1)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ >>> module = ast.Module(body=[ast.Expr(print_call, ... lineno=1, col_offset=1)],
    lineno=1, col_offset=1)
- en: ➎ >>> code = compile(module, '', 'exec')
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ >>> code = compile(module, '', 'exec')
- en: '>>> eval(code)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> eval(code)'
- en: hello world!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: hello world!
- en: '*Listing 9-3: Writing hello world! using the AST*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-3：使用AST编写“Hello World！”*'
- en: In [Listing 9-3](ch09.xhtml#ch9list3), we build the tree one leaf at a time,
    where each leaf is an element (whether a value or an instruction) of the program.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 9-3](ch09.xhtml#ch9list3) 中，我们一步步构建树，每个叶子节点都是程序的一个元素（无论是值还是指令）。
- en: 'The first leaf is a simple string ➊: the ast.Str represents a literal string,
    which here contains the hello world! text. The print_name variable ➋ contains
    an ast.Name object, which refers to a variable—in this case, the print variable
    that points to the print() function.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个叶子节点是一个简单的字符串 ➊：`ast.Str` 表示一个字面量字符串，这里包含了 "hello world!" 文本。`print_name`
    变量 ➋ 包含一个 `ast.Name` 对象，它引用了一个变量——在这个例子中是指向 `print()` 函数的 `print` 变量。
- en: The print_call variable ➌ contains a function call. It refers to the function
    name to call, the regular arguments to pass to the function call, and the keyword
    arguments. Which arguments are used depend on the functions being called. In this
    case, since it’s the print() function, we’ll pass the string we made and stored
    in hello_world.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_call` 变量 ➌ 包含一个函数调用。它指向要调用的函数名、传递给函数调用的常规参数以及关键字参数。使用哪些参数取决于调用的函数。在本例中，由于调用的是
    `print()` 函数，我们将传递我们制作并存储在 `hello_world` 中的字符串。'
- en: At last, we create an _ast.Module object ➍ to contain all this code as a list
    of one expression. We can compile _ast.Module objects using the compile() function
    ➎, which parses the tree and generates a native code object. These code objects
    are compiled Python code and can finally be executed by a Python virtual machine
    using eval!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个 _ast.Module 对象 ➍ 来包含所有这些代码，作为一个包含一个表达式的列表。我们可以使用 `compile()` 函数 ➎
    编译 _ast.Module 对象，这会解析树并生成本地代码对象。这些代码对象是已编译的 Python 代码，最终可以通过 Python 虚拟机使用 `eval`
    执行！
- en: 'This whole process is exactly what happens when you run Python on a *.py* file:
    once the text tokens are parsed, they are converted into a tree of ast objects,
    compiled, and evaluated.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程正是你在运行 Python *.py* 文件时发生的事情：一旦文本标记被解析，它们就会被转换为一个 AST 对象的树，进行编译并求值。
- en: '**NOTE**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The arguments lineno and col_offset represent the line number and column offset,
    respectively, of the source code that has been used to generate the AST. It doesn’t
    make much sense to set these values in this context since we are not parsing a
    source file, but it can be useful to be able to find the position of the code
    that generated the AST. For example, Python uses this information when generating
    backtraces. Indeed, Python refuses to compile an AST object that doesn’t provide
    this information, so we pass fake values to these. You could also use the ast.fix_missing_locations()
    function to set the missing values to the ones set on the parent node.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*参数 `lineno` 和 `col_offset` 分别表示生成 AST 的源代码的行号和列偏移量。在这个上下文中设置这些值没有太大意义，因为我们并没有解析源文件，但能够找到生成
    AST 的代码位置是有用的。例如，Python 在生成回溯信息时会使用这些信息。事实上，Python 拒绝编译没有提供这些信息的 AST 对象，因此我们将虚假的值传递给这些参数。你也可以使用
    `ast.fix_missing_locations()` 函数来将缺失的值设置为父节点上设置的值。*'
- en: '***The AST Objects***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***AST 对象***'
- en: You can view the whole list of objects available in the AST by reading the _ast
    module documentation (note the underscore).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读 _ast 模块文档（注意下划线）来查看 AST 中所有可用对象的完整列表。
- en: 'The objects are organized into two main categories: statements and expressions.
    *Statements* include types such as assert, assignment (=), augmented assignment
    (+=, /=, etc.), global, def, if, return, for, class, pass, import, raise, and
    so forth. Statements inherit from ast.stmt; they influence the control flow of
    a program and are often composed of expressions.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象分为两个主要类别：语句和表达式。*语句* 包括如 assert、赋值（=）、增强赋值（+=、/= 等）、global、def、if、return、for、class、pass、import、raise
    等类型。语句继承自 `ast.stmt`；它们影响程序的控制流，并且通常由表达式组成。
- en: '*Expressions* include types such as lambda, number, yield, name (variable),
    compare, and call. Expressions inherit from ast.expr; they differ from statements
    in that they usually produce a value and have no impact on the program flow.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式* 包括 lambda、数字、yield、名称（变量）、比较和调用等类型。表达式继承自 `ast.expr`；它们与语句的不同之处在于，它们通常会生成一个值并且不会影响程序流程。'
- en: There are also a few smaller categories, such as the ast.operator class, which
    defines standard operators such as *add* (+), *div* (/), and *right shift* (>>),
    and the ast.cmpop module, which defines comparisons operators.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些较小的类别，例如 `ast.operator` 类，它定义了标准运算符，如 *add*（+）、*div*（/）和 *right shift*（>>），以及
    `ast.cmpop` 模块，它定义了比较运算符。
- en: The simple example here should give you an idea of how to build an AST from
    scratch. It’s easy to then imagine how you might leverage this AST to construct
    a compiler that would parse strings and generate code, allowing you to implement
    your own syntax to Python! This is exactly what led to the development of the
    Hy project, which we’ll discuss later in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的简单示例应该能让你了解如何从零开始构建AST。接下来你可以想象，如何利用这个AST构建一个解析字符串并生成代码的编译器，从而实现你自己的Python语法！这正是促使Hy项目开发的原因，我们将在本章后续部分讨论。
- en: '***Walking Through an AST***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***遍历AST***'
- en: To follow how a tree is built or access particular nodes, you sometimes need
    to walk through your tree, browsing it and iterating over the nodes. You can do
    this with the ast.walk() function. Alternatively, the ast module also provides
    NodeTransformer, a class that you can subclass to walk through an AST and modify
    particular nodes. Using NodeTransformer makes it easy to change code dynamically,
    as shown in [Listing 9-4](ch09.xhtml#ch9list4).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪树的构建过程或访问特定节点，有时你需要遍历树，浏览并迭代节点。你可以使用ast.walk()函数来做到这一点。另外，ast模块还提供了NodeTransformer类，你可以继承这个类来遍历AST并修改特定节点。使用NodeTransformer使得动态更改代码变得容易，如[列表9-4](ch09.xhtml#ch9list4)所示。
- en: import ast
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: import ast
- en: 'class ReplaceBinOp(ast.NodeTransformer):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'class ReplaceBinOp(ast.NodeTransformer):'
- en: '"""Replace operation by addition in binary operation"""'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在二元操作中将操作替换为加法"""'
- en: 'def visit_BinOp(self, node):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'def visit_BinOp(self, node):'
- en: return ast.BinOp(left=node.left,
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: return ast.BinOp(left=node.left,
- en: op=ast.Add(),
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: op=ast.Add(),
- en: right=node.right)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: right=node.right)
- en: ➊ tree = ast.parse("x = 1/3")
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ tree = ast.parse("x = 1/3")
- en: ast.fix_missing_locations(tree)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ast.fix_missing_locations(tree)
- en: eval(compile(tree, '', 'exec'))
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: eval(compile(tree, '', 'exec'))
- en: print(ast.dump(tree))
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: print(ast.dump(tree))
- en: ➋ print(x)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ print(x)
- en: ➌ tree = ReplaceBinOp().visit(tree)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ tree = ReplaceBinOp().visit(tree)
- en: ast.fix_missing_locations(tree)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ast.fix_missing_locations(tree)
- en: print(ast.dump(tree))
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: print(ast.dump(tree))
- en: eval(compile(tree, '', 'exec'))
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: eval(compile(tree, '', 'exec'))
- en: ➍ print(x)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ print(x)
- en: '*Listing 9-4: Walking a tree with NodeTransformer to alter a node*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-4：通过NodeTransformer遍历树以修改节点*'
- en: The first tree object built ➊ is an AST that represents the expression x = 1/3.
    Once this is compiled and evaluated, the result of printing x at the end of the
    function ➋ is 0.33333, the expected result of 1/3.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个树对象 ➊ 构建的是一个表示表达式x = 1/3的AST。一旦这个AST被编译并执行，打印x的结果 ➋ 将是0.33333，这是1/3的预期结果。
- en: The second tree object ➌ is an instance of ReplaceBinOp, which inherits from
    ast.NodeTransformer. It implements its own version of the ast.NodeTransformer.visit()
    method and changes any ast.BinOp operation to an ast.BinOp that executes ast.Add.
    Concretely, this changes any binary operator (+, -, /, and so on) to the + operator.
    When this second tree is compiled and evaluated ➍, the result is now 4, which
    is the result of 1 + 3, because the / in the first object is replaced with +.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个树对象 ➌ 是ReplaceBinOp的实例，它继承自ast.NodeTransformer。它实现了自己版本的ast.NodeTransformer.visit()方法，并将任何ast.BinOp操作更改为执行ast.Add的ast.BinOp。具体而言，这将任何二元运算符（如
    +、-、/ 等）更改为 + 运算符。当第二个树被编译并执行 ➍ 后，结果变为4，这是1 + 3的结果，因为第一个对象中的 / 被替换成了 +。
- en: 'You can see the execution of the program here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到程序的执行：
- en: Module(body=[Assign(targets=[Name(id='x', ctx=Store())],
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Module(body=[Assign(targets=[Name(id='x', ctx=Store())],
- en: value=BinOp(left=Num(n=1), op=Div(), right=Num(n=3)))])
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: value=BinOp(left=Num(n=1), op=Div(), right=Num(n=3)))])
- en: '0.3333333333333333'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '0.3333333333333333'
- en: Module(body=[Assign(targets=[Name(id='x', ctx=Store())],
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Module(body=[Assign(targets=[Name(id='x', ctx=Store())],
- en: value=BinOp(left=Num(n=1), op=Add(), right=Num(n=3)))])
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: value=BinOp(left=Num(n=1), op=Add(), right=Num(n=3)))])
- en: '4'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '**NOTE**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you need to evaluate a string that should return a simple data type, you
    can use ast.literal_eval. As a safer alternative to eval, it prevents the input
    string from executing any code.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你需要评估一个返回简单数据类型的字符串，可以使用ast.literal_eval。作为eval的更安全替代方法，它防止输入字符串执行任何代码。*'
- en: '**Extending flake8 with AST Checks**'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**扩展flake8与AST检查**'
- en: In [Chapter 7](ch07.xhtml#ch07), you learned that methods that do not rely on
    the object state should be declared static with the @staticmethod decorator. The
    problem is that a lot of developers simply forget to do so. I’ve personally spent
    too much time reviewing code and asking people to fix this problem.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.xhtml#ch07)中，你学习了那些不依赖于对象状态的方法应该使用@staticmethod装饰器声明为静态方法。问题是，许多开发者忘记这么做。我个人花了太多时间检查代码并要求别人修复这个问题。
- en: We’ve seen how to use flake8 to do some automatic checking in the code. In fact,
    flake8 is extensible and can provide even more checks. We’ll write a flake8 extension
    that checks for static method declaration omission by analyzing the AST.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 flake8 对代码进行一些自动检查。事实上，flake8 是可扩展的，能够提供更多的检查功能。我们将编写一个 flake8 扩展，通过分析
    AST 来检查静态方法声明是否缺失。
- en: '[Listing 9-5](ch09.xhtml#ch9list5) shows an example of one class that omits
    the static declaration and one that correctly includes it. Write this program
    out and save it as *ast_ext.py*; we’ll use it in a moment to write our extension.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-5](ch09.xhtml#ch9list5)展示了一个省略静态声明的类和一个正确包含静态声明的类的例子。编写这个程序并将其保存为 *ast_ext.py*；我们稍后将用它来编写扩展。'
- en: 'class Bad(object):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Bad(object):'
- en: '# self is not used, the method does not need'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '# 未使用 self，该方法不需要'
- en: '# to be bound, it should be declared static'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '# 要绑定，应该声明为静态'
- en: 'def foo(self, a, b, c):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'def foo(self, a, b, c):'
- en: return a + b - c
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: return a + b - c
- en: 'class OK(object):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'class OK(object):'
- en: '# This is correct'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '# 这是正确的'
- en: '@staticmethod'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '@staticmethod'
- en: 'def foo(a, b, c):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'def foo(a, b, c):'
- en: return a + b - c
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: return a + b - c
- en: '*Listing 9-5: Omitting and including @staticmethod*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-5：省略和包括 @staticmethod*'
- en: 'Though the Bad.foo method works fine, strictly speaking it is more correct
    to write it as OK.foo (turn back to [Chapter 7](ch07.xhtml#ch07) for more detail
    on why). To check whether all the methods in a Python file are correctly declared,
    we need to do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Bad.foo 方法可以正常工作，但严格来说，更正确的写法是 OK.foo（关于为什么可以参考[第7章](ch07.xhtml#ch07)的更多细节）。要检查一个
    Python 文件中所有方法是否正确声明，我们需要执行以下操作：
- en: Iterate over all the statement nodes of the AST.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历 AST 的所有语句节点。
- en: Check that the statement is a class definition (ast.ClassDef).
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查语句是否为类定义（ast.ClassDef）。
- en: Iterate over all the function definitions (ast.FunctionDef) of that class statement
    to check whether it is already declared with @staticmethod.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历该类语句中的所有函数定义（ast.FunctionDef），检查是否已声明 @staticmethod。
- en: If the method is not declared static, check whether the first argument (self)
    is used somewhere in the method. If self is not used, the method can be tagged
    as potentially miswritten.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方法没有声明为静态，检查方法中是否使用了第一个参数（self）。如果没有使用self，则可以标记该方法为可能写错。
- en: The name of our project will be ast_ext. To register a new plugin in flake8,
    we need to create a packaged project with the usual *setup.py* and *setup.cfg*
    files. Then, we just need to add an entry point in the *setup.cfg* of our ast_ext
    project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的名称将是 ast_ext。为了在 flake8 中注册一个新的插件，我们需要创建一个带有常规 *setup.py* 和 *setup.cfg*
    文件的打包项目。然后，我们只需要在 ast_ext 项目的 *setup.cfg* 中添加一个入口点。
- en: '[entry_points]'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[entry_points]'
- en: flake8.extension =
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: flake8.extension =
- en: --snip--
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: H904 = ast_ext:StaticmethodChecker
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: H904 = ast_ext:StaticmethodChecker
- en: H905 = ast_ext:StaticmethodChecker
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: H905 = ast_ext:StaticmethodChecker
- en: '*Listing 9-6: Allowing flake8 plugins for our chapter*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-6：为我们章节允许 flake8 插件*'
- en: In [Listing 9-6](ch09.xhtml#ch9list6), we also register two flake8 error codes.
    As you’ll notice later, we are actually going to add an extra check to our code
    while we’re at it!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 9-6](ch09.xhtml#ch9list6) 中，我们还注册了两个 flake8 错误代码。如你所见，稍后我们将实际在代码中增加额外的检查！
- en: The next step is to write the plugin.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写插件。
- en: '***Writing the Class***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写类***'
- en: Since we are writing a flake8 check of the AST, the plugin needs to be a class
    following a certain signature, as shown in [Listing 9-7](ch09.xhtml#ch9list7).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在编写一个 flake8 的 AST 检查，插件需要是一个遵循特定签名的类，如 [示例 9-7](ch09.xhtml#ch9list7) 所示。
- en: 'class StaticmethodChecker(object):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 'class StaticmethodChecker(object):'
- en: 'def __init__(self, tree, filename):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, tree, filename):'
- en: self.tree = tree
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: self.tree = tree
- en: 'def run(self):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'def run(self):'
- en: pass
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '*Listing 9-7: The class for checking the AST*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-7：检查 AST 的类*'
- en: 'The default template is easy to understand: it stores the tree locally for
    use in the run() method, which will *yield* the problems that are discovered.
    The value that will be yielded must follow the expected PEP 8 signature: a tuple
    of the form (lineno, col_offset, error_string, code).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板很容易理解：它将树本地存储以供 run() 方法使用，该方法将 *yield* 发现的问题。将要返回的值必须遵循预期的 PEP 8 签名：一个形式为
    (lineno, col_offset, error_string, code) 的元组。
- en: '***Ignoring Irrelevant Code***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***忽略无关代码***'
- en: As indicated earlier, the ast module provides the walk() function, which allows
    you to iterate easily on a tree. We’ll use that to walk through the AST and find
    out what to check and what not to check.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ast 模块提供了 walk() 函数，允许你轻松遍历树。我们将利用它来遍历 AST，找出需要检查的内容和不需要检查的内容。
- en: First, let’s write a loop that ignores the statements that are not class definitions.
    Add this to your ast_ext project, as shown in [Listing 9-8](ch09.xhtml#ch9list8);
    code that should stay the same is grayed out.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个循环，忽略非类定义的语句。将其添加到您的 ast_ext 项目中，如[清单 9-8](ch09.xhtml#ch9list8)所示；不需要更改的代码已灰显。
- en: 'class StaticmethodChecker(object):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'class StaticmethodChecker(object):'
- en: 'def __init__(self, tree, filename):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, tree, filename):'
- en: self.tree = tree
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: self.tree = tree
- en: 'def run(self):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'def run(self):'
- en: 'for stmt in ast.walk(self.tree):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'for stmt in ast.walk(self.tree):'
- en: '# Ignore non-class'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '# 忽略非类的语句'
- en: 'if not isinstance(stmt, ast.ClassDef):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not isinstance(stmt, ast.ClassDef):'
- en: continue
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: '*Listing 9-8: Ignoring statements that are not class definitions*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-8：忽略非类定义的语句*'
- en: The code in [Listing 9-8](ch09.xhtml#ch9list8) is still not checking for anything,
    but now it knows how to ignore statements that are not class definitions. The
    next step is to set our checker to ignore anything that is not a function definition.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-8](ch09.xhtml#ch9list8) 中的代码仍然没有进行任何检查，但现在它知道如何忽略非类定义的语句。下一步是让我们的检查器忽略所有非函数定义的语句。'
- en: 'for stmt in ast.walk(self.tree):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'for stmt in ast.walk(self.tree):'
- en: '# Ignore non-class'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '# 忽略非类的语句'
- en: 'if not isinstance(stmt, ast.ClassDef):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not isinstance(stmt, ast.ClassDef):'
- en: continue
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: '# If it''s a class, iterate over its body member to find methods'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果是类，则遍历其成员体以查找方法'
- en: 'for body_item in stmt.body:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'for body_item in stmt.body:'
- en: '# Not a method, skip'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '# 不是方法，跳过'
- en: 'if not isinstance(body_item, ast.FunctionDef):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not isinstance(body_item, ast.FunctionDef):'
- en: continue
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: '*Listing 9-9: Ignoring statements that are not function definitions*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-9：忽略非函数定义的语句*'
- en: In [Listing 9-9](ch09.xhtml#ch9list9), we ignore irrelevant statements by iterating
    over the attributes of the class definition.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 9-9](ch09.xhtml#ch9list9)中，我们通过遍历类定义的属性来忽略不相关的语句。
- en: '***Checking for the Correct Decorator***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***检查正确的装饰器***'
- en: We’re all set to write the checking method, which is stored in the body_item
    attribute. First, we need to check whether the method that’s being checked is
    already declared as static. If it is, we don’t have to do any further checking
    and can bail out.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已准备好编写检查方法，它存储在 body_item 属性中。首先，我们需要检查被检查的方法是否已声明为静态。如果是，我们不需要做任何进一步的检查，可以直接退出。
- en: 'for stmt in ast.walk(self.tree):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'for stmt in ast.walk(self.tree):'
- en: '# Ignore non-class'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '# 忽略非类的语句'
- en: 'if not isinstance(stmt, ast.ClassDef):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not isinstance(stmt, ast.ClassDef):'
- en: continue
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: '# If it''s a class, iterate over its body member to find methods'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果是类，则遍历其成员体以查找方法'
- en: 'for body_item in stmt.body:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'for body_item in stmt.body:'
- en: '# Not a method, skip'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '# 不是方法，跳过'
- en: 'if not isinstance(body_item, ast.FunctionDef):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not isinstance(body_item, ast.FunctionDef):'
- en: continue
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: '# Check that it has a decorator'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查是否有装饰器'
- en: 'for decorator in body_item.decorator_list:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'for decorator in body_item.decorator_list:'
- en: if (isinstance(decorator, ast.Name)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: if (isinstance(decorator, ast.Name)
- en: 'and decorator.id == ''staticmethod''):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'and decorator.id == ''staticmethod''):'
- en: '# It''s a static function, it''s OK'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '# 它是一个静态函数，没问题'
- en: 'break else:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'break else:'
- en: '# Function is not static, we do nothing for now'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '# 函数不是静态的，我们暂时不做任何处理'
- en: Pass
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Pass
- en: '*Listing 9-10: Checking for the static decorator*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-10：检查静态装饰器*'
- en: Note that in [Listing 9-10](ch09.xhtml#ch9list10), we use the special for/else
    form of Python, where the else is evaluated unless we use break to exit the for
    loop. At this point, we’re able to detect whether a method is declared static.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[清单 9-10](ch09.xhtml#ch9list10)中，我们使用了 Python 的特殊 for/else 结构，其中除非使用 break
    退出 for 循环，否则 else 部分会被执行。在这一点上，我们已经能够检测方法是否声明为静态。
- en: '***Looking for self***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找 self***'
- en: The next step is to check whether the method that *isn’t* declared as static
    uses the self argument. First, check whether the method includes any arguments
    at all, as shown in [Listing 9-11](ch09.xhtml#ch9list11).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检查未声明为静态的方法是否使用了 self 参数。首先，检查方法是否包含任何参数，如[清单 9-11](ch09.xhtml#ch9list11)所示。
- en: --snip--
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: '# Check that it has a decorator'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查是否有装饰器'
- en: 'for decorator in body_item.decorator_list:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'for decorator in body_item.decorator_list:'
- en: if (isinstance(decorator, ast.Name)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: if (isinstance(decorator, ast.Name)
- en: 'and decorator.id == ''staticmethod''):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'and decorator.id == ''staticmethod''):'
- en: '# It''s a static function, it''s OK'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '# 它是一个静态函数，没问题'
- en: break
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: 'else:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: 'try:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: first_arg = body_item.args.args[0]
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: first_arg = body_item.args.args[0]
- en: 'except IndexError:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'except IndexError:'
- en: yield (
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: yield (
- en: body_item.lineno,
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: body_item.lineno,
- en: body_item.col_offset,
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: body_item.col_offset,
- en: '"H905: method misses first argument",'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '"H905: 方法缺少第一个参数",'
- en: '"H905",'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '"H905",'
- en: )
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '# Check next method'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查下一个方法'
- en: Continue
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Continue
- en: '*Listing 9-11: Checking the method for arguments*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-11：检查方法的参数*'
- en: 'We finally added a check! This try statement in [Listing 9-11](ch09.xhtml#ch9list11)
    grabs the first argument from the method signature. If the code fails to retrieve
    the first argument from the signature because a first argument doesn’t exist,
    we already know there’s a problem: you can’t have a bound method without the self
    argument. If the plugin detects that case, it raises the H905 error code we set
    earlier, signaling a method that misses its first argument.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于添加了一个检查！[Listing 9-11](ch09.xhtml#ch9list11)中的这个 try 语句抓取方法签名中的第一个参数。如果代码未能从签名中获取第一个参数，因为第一个参数不存在，我们已经知道有问题：没有
    self 参数就不能有绑定方法。如果插件检测到这种情况，它会引发我们之前设置的 H905 错误码，表示方法缺少第一个参数。
- en: '**NOTE**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*PEP 8 codes follow a particular format for error codes (a letter followed
    by a number), but there are no rules as to which code to pick. You could come
    up with any other code for this error, as long as it’s not already used by PEP
    8 or another extension.*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*PEP 8 错误码遵循特定的格式（字母后跟数字），但没有规定应该选择哪个错误码。你可以为这个错误选择任何其他的错误码，只要它没有被 PEP 8 或其他扩展使用。*'
- en: 'Now you know why we registered two error codes in *setup.cfg*: we had a good
    opportunity to kill two birds with one stone.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道我们为什么在*setup.cfg*中注册了两个错误码：我们有一个很好的机会，一石二鸟。
- en: The next step is to check whether the self argument is used in the code of the
    method.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检查方法的代码中是否使用了 self 参数。
- en: --snip--
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: 'try:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: first_arg = body_item.args.args[0]
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: first_arg = body_item.args.args[0]
- en: 'except IndexError:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'except IndexError:'
- en: yield (
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: yield (
- en: body_item.lineno,
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: body_item.lineno,
- en: body_item.col_offset,
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: body_item.col_offset,
- en: '"H905: method misses first argument",'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '"H905: 方法缺少第一个参数",'
- en: '"H905",'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '"H905",'
- en: )
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '# Check next method'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查下一个方法'
- en: continue
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: continue
- en: 'for func_stmt in ast.walk(body_item):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 body_item 中的 func_stmt，使用 ast.walk 遍历：
- en: '# The checking method must differ between Python 2 and Python 3'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查方法在 Python 2 和 Python 3 中的差异'
- en: 'if six.PY3:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '如果是 six.PY3:'
- en: if (isinstance(func_stmt, ast.Name)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (isinstance(func_stmt, ast.Name)
- en: 'and first_arg.arg == func_stmt.id):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '并且 first_arg.arg == func_stmt.id):'
- en: '# The first argument is used, it''s OK'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '# 第一个参数已使用，可以'
- en: break
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: 'else:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: if (func_stmt != first_arg
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (func_stmt != first_arg
- en: and isinstance(func_stmt, ast.Name)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 isinstance(func_stmt, ast.Name)
- en: 'and func_stmt.id == first_arg.id):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '和 func_stmt.id == first_arg.id):'
- en: '# The first argument is used, it''s OK'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '# 第一个参数已使用，可以'
- en: break
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: 'else:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: yield (
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: yield (
- en: body_item.lineno,
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: body_item.lineno,
- en: body_item.col_offset,
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: body_item.col_offset,
- en: '"H904: method should be declared static",'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '"H904: 方法应该声明为静态方法",'
- en: '"H904",'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '"H904",'
- en: )
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Listing 9-12: Checking the method for the self argument*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-12：检查方法是否使用 self 参数*'
- en: To check whether the self argument is used in the method’s body, the plugin
    in [Listing 9-12](ch09.xhtml#ch9list12) iterates recursively, using ast.walk on
    the body and looking for the use of the variable named self. If the variable isn’t
    found, the program finally yields the H904 error code. Otherwise, nothing happens,
    and the code is considered sane.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查方法体中是否使用了 self 参数，[Listing 9-12](ch09.xhtml#ch9list12)中的插件递归迭代，使用 ast.walk
    遍历方法体，查找名为 self 的变量。如果没有找到该变量，程序最终会返回 H904 错误码。否则，什么也不做，代码被认为是正常的。
- en: '**NOTE**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As you may have noticed, the code walks over the module AST definition several
    times. There might be some degree of optimization to browsing the AST in only
    one pass, but I’m not sure it’s worth it, given how the tool is actually used.
    I’ll leave that exercise to you, dear reader.*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如你可能已经注意到的，代码多次遍历模块的 AST 定义。可能有一定的优化空间，通过一次遍历来浏览 AST，但考虑到工具的实际使用情况，我不确定是否值得这样做。我把这个练习留给你，亲爱的读者。*'
- en: Knowing the Python AST is not strictly necessary for using Python, but it does
    give powerful insight into how the language is built and how it works. It thus
    gives you a better understanding of how the code you write is being used under
    the hood.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Python AST 对使用 Python 并非严格必要，但它确实提供了对语言构建和工作原理的强大洞察力。它让你更好地理解你写的代码在背后是如何被使用的。
- en: '**A Quick Introduction to Hy**'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Hy 快速介绍**'
- en: Now that you have a good understanding of how Python AST works, you can start
    dreaming of creating a new syntax for Python. You could parse this new syntax,
    build an AST out of it, and compile it down to Python code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地理解了 Python AST 的工作原理，你可以开始梦想为 Python 创建一种新的语法。你可以解析这种新语法，构建出 AST，并将其编译为
    Python 代码。
- en: 'This is exactly what Hy does. *Hy* is a Lisp dialect that parses a Lisp-like
    language and converts it to regular Python AST, making it fully compatible with
    the Python ecosystem. You could compare it to what Clojure is to Java. Hy could
    fill a book by itself, so we will only skim over it. Hy uses the syntax and some
    features of the Lisp family of languages: it’s functionally oriented, provides
    macros, and is easily extensible.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 Hy 所做的。*Hy* 是一种 Lisp 方言，它解析类似 Lisp 的语言并将其转换为常规的 Python AST，使其与 Python 生态系统完全兼容。你可以将其与
    Clojure 对 Java 的作用做类比。Hy 本身就能填满一本书，因此我们这里只做简单的概览。Hy 使用了 Lisp 家族语言的语法和一些特性：它是面向函数的，提供宏功能，并且易于扩展。
- en: If you’re not already familiar with Lisp—and you should be—the Hy syntax will
    look familiar. Once you install Hy (by running pip install hy), launching the
    hy interpreter will give you a standard REPL prompt from which you can start to
    interact with the interpreter, as shown in [Listing 9-13](ch09.xhtml#ch9list13).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉 Lisp——你应该熟悉——Hy 的语法看起来会很熟悉。一旦你安装了 Hy（运行 pip install hy），启动 hy 解释器会给你一个标准的
    REPL 提示符，你可以从中开始与解释器进行交互，如 [列表 9-13](ch09.xhtml#ch9list13) 所示。
- en: '% hy'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '% hy'
- en: hy 0.9.10
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: hy 0.9.10
- en: => (+ 1 2)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: => (+ 1 2)
- en: '3'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '*Listing 9-13: Interacting with the Hy interpreter*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-13：与 Hy 解释器的交互*'
- en: 'For those not familiar with the Lisp syntax, parentheses are used to construct
    lists. If a list is unquoted, it is evaluated: the first element must be a function,
    and the rest of the items from the list are passed as arguments. Here the code
    (+ 1 2) is equivalent to 1 + 2 in Python.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉 Lisp 语法的人来说，括号用于构建列表。如果列表没有加引号，它会被求值：第一个元素必须是一个函数，后续元素作为参数传入。这里的代码 (+
    1 2) 等同于 Python 中的 1 + 2。
- en: In Hy, most constructs, such as function definitions, are mapped from Python
    directly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hy 中，大多数构造，如函数定义，都直接映射自 Python。
- en: => (defn hello [name]
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: => (defn hello [name]
- en: '...  (print "Hello world!")'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '...  (print "你好，世界！")'
- en: '...  (print (% "Nice to meet you %s" name)))'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '...  (print (% "很高兴认识你 %s" name)))'
- en: => (hello "jd")
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: => (hello "jd")
- en: Hello world!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: Nice to meet you jd
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 很高兴认识你 jd
- en: '*Listing 9-14: Mapping a function definition from Python*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-14：从 Python 映射一个函数定义*'
- en: 'As shown in [Listing 9-14](ch09.xhtml#ch9list14), internally Hy parses the
    code provided, converts it to a Python AST, compiles it, and evaluates it. Fortunately,
    Lisp is an easy tree to parse: each pair of parentheses represents a node of the
    tree, meaning the conversion is actually easier than for the native Python syntax!'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 9-14](ch09.xhtml#ch9list14) 所示，Hy 在内部解析提供的代码，将其转换为 Python AST，编译并求值。幸运的是，Lisp
    是一种容易解析的树结构：每一对括号表示树的一个节点，这意味着转换实际上比原生 Python 语法更容易！
- en: Class definition is supported through the defclass construct, which is inspired
    by the Common Lisp Object System (CLOS).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义通过 defclass 构造来支持，这受到 Common Lisp 对象系统（CLOS）的启发。
- en: (defclass A [object]
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: (defclass A [object]
- en: '[[x 42] [y (fn [self value]'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[[x 42] [y (fn [self value]'
- en: (+ self.x value))]])
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: (+ self.x value))]])
- en: '*Listing 9-15: Defining a class with defclass*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-15：使用 defclass 定义一个类*'
- en: '[Listing 9-15](ch09.xhtml#ch9list15) defines a class named A, which inherits
    from object, with a class attribute x whose value is 42; then a method y returns
    the x attribute plus a value passed as argument.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-15](ch09.xhtml#ch9list15) 定义了一个名为 A 的类，它继承自 object，具有一个名为 x 的类属性，值为 42；然后一个方法
    y 返回 x 属性加上传入的值。'
- en: What’s really wonderful is that you can import *any Python library* directly
    into Hy and use it with no penalty. Use the import() function to import a module,
    as shown in [Listing 9-16](ch09.xhtml#ch9list16), just as you would with regular
    Python.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 真正神奇的是，你可以直接将*任何 Python 库*导入到 Hy 中，并且无需任何额外负担。使用 import() 函数导入模块，如 [列表 9-16](ch09.xhtml#ch9list16)
    所示，就像你在常规 Python 中那样使用。
- en: => (import uuid)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: => (import uuid)
- en: => (uuid.uuid4)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: => (uuid.uuid4)
- en: UUID('f823a749-a65a-4a62-b853-2687c69d0e1e')
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: UUID('f823a749-a65a-4a62-b853-2687c69d0e1e')
- en: => (str (uuid.uuid4))
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: => (str (uuid.uuid4))
- en: '''4efa60f2-23a4-4fc1-8134-00f5c271f809'''
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '''4efa60f2-23a4-4fc1-8134-00f5c271f809'''
- en: '*Listing 9-16: Importing regular Python modules*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-16：导入常规 Python 模块*'
- en: Hy also has more advanced constructs and macros. In [Listing 9-17](ch09.xhtml#ch9list17),
    admire what the cond() function can do for you instead of the classic but verbose
    if/elif/else.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Hy 还具有更高级的构造和宏功能。在 [列表 9-17](ch09.xhtml#ch9list17) 中，看看 cond() 函数能为你做什么，而不是经典但冗长的
    if/elif/else。
- en: (cond
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(> somevar 50)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[(> somevar 50)'
- en: (print "That variable is too big!")]
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: (print "那个变量太大了！")]
- en: '[(< somevar 10)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[(< somevar 10)'
- en: (print "That variable is too small!")]
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: (print "那个变量太小了！")]
- en: '[true'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[true'
- en: (print "That variable is jusssst right!")])
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: (print "那个变量正好！")]
- en: '*Listing 9-17: Using cond instead of if/elif/else*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-17：使用cond代替if/elif/else*'
- en: 'The cond macro has the following signature: (cond [condition_expression return_expression]
    ...). Each condition expression is evaluated, starting with the first: as soon
    as one of the condition expressions returns a true value, the return expression
    is evaluated and returned. If no return expression is provided, then the value
    of the condition expression is returned. Thus, cond is equivalent to an if/elif
    construct, except that it can return the value of the condition expression without
    having to evaluate it twice or store it in a temporary variable!'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: cond宏具有以下签名：(cond [condition_expression return_expression] ...)。每个条件表达式都会被依次评估：一旦某个条件表达式返回真值，就会评估并返回相应的返回表达式。如果没有提供返回表达式，则返回条件表达式的值。因此，cond等价于if/elif构造，只是它能够返回条件表达式的值，而无需对其进行两次评估或将其存储在临时变量中！
- en: Hy allows you to jump into the Lisp world without leaving your comfort zone
    too far behind you, since you’re still writing Python. The hy2py tool can even
    show you what your Hy code would look like once translated into Python. While
    Hy is not widely used, it is a great tool to show the potential of the Python
    language. If you’re interested in learning more, I suggest you check out the online
    documentation and join the community.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Hy让你可以在不远离舒适区的情况下进入Lisp世界，因为你依然在编写Python代码。hy2py工具甚至可以显示你的Hy代码转换成Python后会是什么样子。虽然Hy并不广泛使用，但它是展示Python语言潜力的一个很好的工具。如果你有兴趣了解更多，我建议你查看在线文档并加入社区。
- en: '**Summary**'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Just like any other programming language, Python source code can be represented
    using an abstract tree. You’ll rarely use the AST directly, but when you understand
    how it works, it can provide a helpful perspective.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他编程语言一样，Python源代码可以通过抽象语法树表示。你很少会直接使用AST，但当你理解它的工作原理时，它可以提供一种有用的视角。
- en: '**Paul Tagliamonte on the AST and Hy**'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Paul Tagliamonte谈AST和Hy**'
- en: Paul created Hy in 2013, and, as a Lisp lover, I joined him in this fabulous
    adventure. Paul is currently a developer at Sunlight Foundation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Paul在2013年创建了Hy，作为一个Lisp爱好者，我和他一起加入了这个精彩的冒险。Paul目前是Sunlight Foundation的开发人员。
- en: '**How did you learn to use the AST correctly, and do you have any advice for
    people looking at it?**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**你是如何学会正确使用AST的？对于想要学习AST的人，你有什么建议吗？**'
- en: The AST is extremely underdocumented, so most knowledge comes from generated
    ASTs that have been reverse engineered. By writing up simple Python scripts, one
    can use something similar to import ast; ast.dump(ast.parse("print foo")) to generate
    an equivalent AST to help with the task. With a bit of guesswork, and some persistence,
    it’s not untenable to build up a basic understanding this way.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: AST（抽象语法树）文档非常少，所以大部分知识都来自于经过逆向工程生成的AST。通过编写简单的Python脚本，可以使用类似`import ast; ast.dump(ast.parse("print
    foo"))`的方式生成一个等效的AST来帮助完成任务。只要有一点猜测和耐心，通过这种方式建立基础理解并非不可行。
- en: At some point, I’ll take on the task of documenting my understanding of the
    AST module, but I find writing code is the best way to learn the AST.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，我会承担起记录我对AST模块理解的任务，但我发现编写代码是学习AST的最佳方式。
- en: '**How does Python’s AST differ between versions and uses?**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python的AST在不同版本和用法之间有何不同？**'
- en: Python’s AST is not private, but it’s not a public interface either. No stability
    is guaranteed from version to version—in fact, there are some rather annoying
    differences between Python 2 and 3 and even within different Python 3 releases.
    In addition, different implementations may interpret the AST differently or even
    have a unique AST. Nothing says Jython, PyPy, or CPython must deal with the Python
    AST in the same way.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Python的AST不是私有的，但也不是公共接口。从版本到版本，无法保证稳定性——事实上，Python 2和3之间，甚至不同的Python 3版本之间，都存在一些相当烦人的差异。此外，不同的实现可能会以不同的方式解释AST，甚至有可能有独特的AST。没有任何规定Jython、PyPy或CPython必须以相同的方式处理Python
    AST。
- en: For instance, CPython can handle slightly out-of-order AST entries (by the lineno
    and col_offset), whereas PyPy will throw an assertion error. Though sometimes
    annoying, the AST is generally sane. It’s not impossible to build an AST that
    works on a vast number of Python instances. With a conditional or two, it’s only
    mildly annoying to create an AST that works on CPython 2.6 through 3.3 and PyPy,
    making this tool quite handy.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，CPython 可以处理稍微乱序的 AST 条目（通过 lineno 和 col_offset），而 PyPy 会抛出一个断言错误。虽然有时会让人恼火，但
    AST 一般是合理的。构建一个能在大量 Python 实例上工作的 AST 并非不可能。只要加上一些条件，创建一个能在 CPython 2.6 到 3.3
    以及 PyPy 上工作的 AST 只会稍微令人烦恼，这使得这个工具非常方便。
- en: '**What was your process in creating Hy?**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**你在创建 Hy 时的过程是什么？**'
- en: I started on Hy following a conversation about how useful it would be to have
    a Lisp that compiles to Python rather than Java’s JVM (Clojure). A few short days
    later, and I had the first version of Hy. This version resembled a Lisp and even
    worked like a proper Lisp in some ways, but it was slow. I mean, really slow.
    It was about an order of magnitude slower than native Python, since the Lisp runtime
    itself was implemented in Python.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始开发 Hy 是因为一次关于拥有一个编译成 Python 而不是 Java JVM（Clojure）语言的讨论。几天后，我就有了第一个版本的 Hy。这个版本像
    Lisp，甚至在某些方面像一个正常的 Lisp，然而它非常慢。我的意思是，真的非常慢。它比本地 Python 慢了一个数量级，因为 Lisp 的运行时本身是用
    Python 实现的。
- en: Frustrated, I almost gave up, but then a coworker suggested using the AST to
    implement the runtime, rather than implementing the runtime in Python. This suggestion
    was the catalyst for the entire project. I spent my entire holiday break in 2012
    hacking on Hy. A week or so later, I had something that resembled the current
    Hy codebase.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一度感到沮丧，我差点放弃，但后来有位同事建议使用抽象语法树（AST）来实现运行时，而不是在 Python 中实现运行时。这个建议成为了整个项目的催化剂。我在2012年的整个假期都在疯狂开发
    Hy。大约一周后，我有了一个类似当前 Hy 代码库的东西。
- en: Just after getting enough of Hy working to implement a basic Flask app, I gave
    a talk at Boston Python about the project, and the reception was incredibly warm—so
    warm, in fact, that I start to view Hy as a good way to teach people about Python
    internals, such as how the REPL works, PEP 302 import hooks, and the Python AST.
    This was a good introduction to the concept of code that writes code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在使 Hy 足够工作以实现一个基本的 Flask 应用之后，我在波士顿的 Python 会议上做了一个关于该项目的演讲，反响非常热烈——实际上，热烈到让我开始把
    Hy 视为一种很好的方式来教人们了解 Python 的内部机制，比如 REPL 是如何工作的，PEP 302 导入钩子，以及 Python 的 AST。这是代码生成代码概念的一个很好的介绍。
- en: I rewrote chunks of the compiler to fix some philosophical issues in the process,
    leading us to the current iteration of the codebase—which has stood up quite well!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我重写了编译器的一部分，以解决一些过程中的哲学问题，从而引导我们到了当前的代码库版本——这个版本的表现相当稳定！
- en: Learning Hy is also a good way to begin understanding how to read Lisp. Users
    can get comfortable with s-expressions in an environment they know and even use
    libraries they’re already using, easing the transition to other Lisps, such as
    Common Lisp, Scheme, or Clojure.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 Hy 也是开始理解如何阅读 Lisp 的一个好方法。用户可以在一个熟悉的环境中习惯 s 表达式，甚至使用他们已经在用的库，从而使得过渡到其他 Lisp（如
    Common Lisp、Scheme 或 Clojure）变得更加顺利。
- en: '**How interoperable with Python is Hy?**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hy 与 Python 的互操作性有多强？**'
- en: Hy is amazingly interoperable. So much so that pdb can properly debug Hy without
    you having to make any changes at all. I’ve written Flask apps, Django apps, and
    modules of all sorts with Hy. Python can import Python, Hy can import Hy, Hy can
    import Python, and Python can import Hy. This is what really makes Hy unique;
    other Lisp variants like Clojure are purely unidirectional. Clojure can import
    Java, but Java has one hell of a time importing Clojure.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Hy 的互操作性令人惊讶。如此之强，以至于 pdb 可以正确调试 Hy，而你无需做任何修改。我已经用 Hy 编写了 Flask 应用、Django 应用以及各种模块。Python
    可以导入 Python，Hy 可以导入 Hy，Hy 可以导入 Python，Python 也可以导入 Hy。这正是 Hy 独特之处；其他类似的 Lisp 变体，如
    Clojure，都是单向的。Clojure 可以导入 Java，但 Java 却很难导入 Clojure。
- en: Hy works by translating Hy code (in s-expressions) into the Python AST almost
    directly. This compilation step means the generated bytecode is fairly sane stuff,
    which means Python has a very hard time of even telling the module isn’t written
    in Python at all.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Hy 的工作方式是将 Hy 代码（以 s 表达式形式）几乎直接转换为 Python 的 AST。这一编译步骤意味着生成的字节码相当“理智”，也就是说 Python
    很难分辨出该模块根本不是用 Python 编写的。
- en: Common Lisp-isms, such as *earmuffs* or using-dashes are fully supported by
    translating them into a Python equivalent (in this case, *earmuffs* becomes EARMUFFS,
    and using-dashes becomes using_dashes), which means Python doesn’t have a hard
    time using them at all.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的 Lisp 特性，如 *earmuffs* 或使用连字符（using-dashes），通过将它们转换为 Python 等效形式得到了完全支持（在这种情况下，*earmuffs*
    变为 EARMUFFS，使用连字符变为 using_dashes），这意味着 Python 使用它们一点也不困难。
- en: Ensuring that we have really good interoperability is one of our highest priorities,
    so if you see any bugs—file them!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们有良好的互操作性是我们的首要任务之一，因此如果你发现任何漏洞，请及时报告！
- en: '**What are the advantages and disadvantages of choosing Hy?**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择 Hy 的优缺点是什么？**'
- en: One advantage of Hy is that it has a full macro system, which Python struggles
    with. Macros are special functions that alter the code during the compile step.
    This makes it easy to create new domain-specific languages, which are composed
    of the base language (in this case, Hy/Python) along with many macros that allow
    uniquely expressive and succinct code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Hy 的一个优势是它拥有完整的宏系统，而这一点是 Python 所无法做到的。宏是特殊的函数，它们在编译阶段改变代码。这使得创建新的领域特定语言变得容易，这些语言由基础语言（在这里是
    Hy/Python）和许多宏组成，允许编写出独特且简洁的代码。
- en: As for downsides, Hy, by virtue of being a Lisp written in s-expressions, suffers
    from the stigma of being hard to learn, read, or maintain. People might be averse
    to working on projects using Hy for fear of its complexity.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 至于缺点，Hy 作为一种用 s 表达式编写的 Lisp，承受着难学、难读、难维护的污名。人们可能会因为其复杂性而不愿使用 Hy 来进行项目开发。
- en: Hy is the Lisp everyone loves to hate. Python folks may not enjoy its syntax,
    and Lispers may avoid it because Hy uses Python objects directly, meaning the
    behavior of fundamental objects can sometimes be surprising to the seasoned Lisper.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Hy 是每个人都喜欢讨厌的 Lisp。Python 用户可能不喜欢它的语法，而 Lisp 爱好者可能会避开它，因为 Hy 直接使用 Python 对象，这意味着一些基本对象的行为可能会让经验丰富的
    Lisp 开发者感到惊讶。
- en: Hopefully people will look past its syntax and consider exploring parts of Python
    previously untouched.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 希望人们能够超越它的语法，考虑探索之前未触及的 Python 部分。
