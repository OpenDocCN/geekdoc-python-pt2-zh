["```py\nblink_comparator.py, part 1\nimport os\nfrom pathlib import Path\nimport numpy as np\nimport cv2 as cv\n\nMIN_NUM_KEYPOINT_MATCHES = 50\n```", "```py\nblink_comparator.py, part 2 \ndef main():\n    \"\"\"Loop through 2 folders with paired images, register & blink images.\"\"\"\n    night1_files = sorted(os.listdir('night_1'))\n    night2_files = sorted(os.listdir('night_2'))             \n    path1 = Path.cwd() / 'night_1'\n    path2 = Path.cwd() / 'night_2'\n    path3 = Path.cwd() / 'night_1_registered'\n```", "```py\n['1_bright_transient_left.png', '2_dim_transient_left.png', '3_diff_exposures_\nleft.png', '4_no_transient_left.png', '5_bright_transient_neg_left.png']\n```", "```py\nblink_comparator.py, part 3\nfor i, _ in enumerate(night1_files):    \n    img1 = cv.imread(str(path1 / night1_files[i]), cv.IMREAD_GRAYSCALE)\n    img2 = cv.imread(str(path2 / night2_files[i]), cv.IMREAD_GRAYSCALE)\n    print(\"Comparing {} to {}.\\n\".format(night1_files[i], night2_files[i]))\n ➊ kp1, kp2, best_matches = find_best_matches(img1, img2)\n    img_match = cv.drawMatches(img1, kp1, img2, kp2, \n                               best_matches, outImg=None)\n    height, width = img1.shape\n    cv.line(img_match, (width, 0), (width, height), (255, 255, 255), 1)\n ➋ QC_best_matches(img_match)  # Comment out to ignore.\n    img1_registered = register_image(img1, img2, kp1, kp2, best_matches)\n\n ➌ blink(img1, img1_registered, 'Check Registration', num_loops=5)  \n    out_filename = '{}_registered.png'.format(night1_files[i][:-4])\n    cv.imwrite(str(path3 / out_filename), img1_registered) # Will overwrite!\n    cv.destroyAllWindows()\n    blink(img1_registered, img2, 'Blink Comparator', num_loops=15)\n```", "```py\nW: 17,11: Unused variable 'infile' (unused-variable)\n```", "```py\nblink_comparator.py, part 4 \ndef find_best_matches(img1, img2):\n    \"\"\"Return list of keypoints and list of best matches for two images.\"\"\"\n    orb = cv.ORB_create(nfeatures=100)  #  Initiate ORB object.\n ➊ kp1, desc1 = orb.detectAndCompute(img1, mask=None)\n    kp2, desc2 = orb.detectAndCompute(img2, mask=None)    \n    bf = cv.BFMatcher(cv.NORM_HAMMING, crossCheck=True)\n ➋ matches = bf.match(desc1, desc2)\n    matches = sorted(matches, key=lambda x: x.distance)\n    best_matches = matches[:MIN_NUM_KEYPOINT_MATCHES]\n\n    return kp1, kp2, best_matches\n```", "```py\nV1 = [010010110100101101100--snip--]\nV2 = [100111100110010101101--snip--]\nV3 = [001101100011011101001--snip--]\n--snip--\n```", "```py\n1001011001010\n1100111001010\n```", "```py\nbest matches =  [<DMatch 0000028BEBAFBFB0>, <DMatch 0000028BEBB21090>, --snip--\n```", "```py\nblink_comparator.py, part 5\ndef QC_best_matches(img_match):\n    \"\"\"Draw best keypoint matches connected by colored lines.\"\"\"    \n    cv.imshow('Best {} Matches'.format(MIN_NUM_KEYPOINT_MATCHES), img_match)\n    cv.waitKey(2500)  # Keeps window active 2.5 seconds.\n```", "```py\nblink_comparator.py, part 6\ndef register_image(img1, img2, kp1, kp2, best_matches):\n    \"\"\"Return first image registered to second image.\"\"\"\n    if len(best_matches) >= MIN_NUM_KEYPOINT_MATCHES:\n        src_pts = np.zeros((len(best_matches), 2), dtype=np.float32)\n        dst_pts = np.zeros((len(best_matches), 2), dtype=np.float32)\n\n     ➊ for i, match in enumerate(best_matches):\n            src_pts[i, :] = kp1[match.queryIdx].pt\n            dst_pts[i, :] = kp2[match.trainIdx].pt            \n        h_array, mask = cv.findHomography(src_pts, dst_pts, cv.RANSAC)\n\n     ➋ height, width = img2.shape  # Get dimensions of image 2.\n        img1_warped = cv.warpPerspective(img1, h_array, (width, height))\n\n        return img1_warped\n\n    else:\n        print(\"WARNING: Number of keypoint matches < {}\\n\".format\n              (MIN_NUM_KEYPOINT_MATCHES))\n        return img1\n```", "```py\n>>> import numpy as np\n>>> ndarray = np.zeros((3, 2), dtype=np.float32)\n>>> ndarray\narray([[0., 0.],\n       [0., 0.],\n       [0., 0.]], dtype=float32)\n```", "```py\nComparing 2_dim_transient_left.png to 2_dim_transient_right.png.\nWARNING: Number of keypoint matches < 50\n```", "```py\nblink_comparator.py, part 7 \ndef blink(image_1, image_2, window_name, num_loops):\n    \"\"\"Replicate blink comparator with two images.\"\"\"\n    for _ in range(num_loops):\n        cv.imshow(window_name, image_1)\n        cv.waitKey(330)\n        cv.imshow(window_name, image_2)\n        cv.waitKey(330)\n\nif __name__ == '__main__':\n    main()\n```", "```py\ntransient_detector.py, part 1\nimport os\nfrom pathlib import Path\nimport cv2 as cv\n\nPAD = 5  # Ignore pixels this distance from edge\n```", "```py\ntransient_detector.py, part 2 \ndef find_transient(image, diff_image, pad):\n    \"\"\"Find and circle transients moving against a star field. \"\"\"\n    transient = False\n    height, width = diff_image.shape\n    cv.rectangle(image, (PAD, PAD), (width - PAD, height - PAD), 255, 1)\n    minVal, maxVal, minLoc, maxLoc = cv.minMaxLoc(diff_image)\n ➊ if pad < maxLoc[0] < width - pad and pad < maxLoc[1] < height - pad:\n        cv.circle(image, maxLoc, 10, 255, 0)\n        transient = True\n    return transient, maxLoc\n```", "```py\ntransient_detector.py, part 3\ndef main():\n    night1_files = sorted(os.listdir('night_1_registered_transients'))\n    night2_files = sorted(os.listdir('night_2'))             \n    path1 = Path.cwd() / 'night_1_registered_transients'\n    path2 = Path.cwd() / 'night_2'\n    path3 = Path.cwd() / 'night_1_2_transients'\n```", "```py\ntransient_detector.py, part 4 \nfor i, _ in enumerate(night1_files[:-1]):  # Leave off negative image   \n    img1 = cv.imread(str(path1 / night1_files[i]), cv.IMREAD_GRAYSCALE)\n    img2 = cv.imread(str(path2 / night2_files[i]), cv.IMREAD_GRAYSCALE)\n\n    diff_imgs1_2 = cv.absdiff(img1, img2)\n    cv.imshow('Difference', diff_imgs1_2)\n    cv.waitKey(2000)\n\n    temp = diff_imgs1_2.copy()\n    transient1, transient_loc1 = find_transient(img1, temp, PAD)\n    cv.circle(temp, transient_loc1, 10, 0, -1)\n\n    transient2, _ = find_transient(img1, temp, PAD)\n```", "```py\ntransient_detector.py, part 5\n        if transient1 or transient2:\n            print('\\nTRANSIENT DETECTED between {} and {}\\n'\n                  .format(night1_files[i], night2_files[i]))\n        ➊ font = cv.FONT_HERSHEY_COMPLEX_SMALL\n           cv.putText(img1, night1_files[i], (10, 25),\n                      font, 1, (255, 255, 255), 1, cv.LINE_AA)\n           cv.putText(img1, night2_files[i], (10, 55),\n                      font, 1, (255, 255, 255), 1, cv.LINE_AA)\n\n           blended = cv.addWeighted(img1, 1, diff_imgs1_2, 1, 0)\n           cv.imshow('Surveyed', blended)\n           cv.waitKey(2500)  \n\n         ➋ out_filename = '{}_DECTECTED.png'.format(night1_files[i][:-4])\n            cv.imwrite(str(path3 / out_filename), blended)  # Will overwrite!\n\n       else:\n           print('\\nNo transient detected between {} and {}\\n'\n                  .format(night1_files[i], night2_files[i]))\n\nif __name__ == '__main__':\n    main()\n```", "```py\nTRANSIENT DETECTED between 1_bright_transient_left_registered.png and 1_bright_transient_right.png\n\nTRANSIENT DETECTED between 2_dim_transient_left_registered.png and 2_dim_transient_right.png\n\nTRANSIENT DETECTED between 3_diff_exposures_left_registered.png and 3_diff_exposures_right.png\n\nTRANSIENT DETECTED between 4_single_transient_left_registered.png and 4_single_transient_right.png\n\nNo transient detected between 5_no_transient_left_registered.png and 5_no_transient_right.png\n```"]