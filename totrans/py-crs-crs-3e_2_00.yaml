- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Classes
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Object-oriented programming (OOP**)* is one of the most effective approaches
    to writing software. In object-oriented programming, you write *classes* that
    represent real-world things and situations, and you create *objects* based on
    these classes. When you write a class, you define the general behavior that a
    whole category of objects can have.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象编程（OOP）*是编写软件最有效的方法之一。在面向对象编程中，你编写代表现实世界事物和情境的*类*，并基于这些类创建*对象*。当你编写一个类时，你定义了一个整个类别的对象可以拥有的通用行为。'
- en: When you create individual objects from the class, each object is automatically
    equipped with the general behavior; you can then give each object whatever unique
    traits you desire. You’ll be amazed how well real-world situations can be modeled
    with object-oriented programming.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从类中创建单独的对象时，每个对象都会自动配备通用的行为；然后你可以为每个对象添加你想要的独特特性。你会惊讶于面向对象编程如何能够很好地模拟现实世界的情况。
- en: Making an object from a class is called *instantiation*, and you work with *instances*
    of a class. In this chapter you’ll write classes and create instances of those
    classes. You’ll specify the kind of information that can be stored in instances,
    and you’ll define actions that can be taken with these instances. You’ll also
    write classes that extend the functionality of existing classes, so similar classes
    can share common functionality, and you can do more with less code. You’ll store
    your classes in modules and import classes written by other programmers into your
    own program files.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从类中创建对象被称为*实例化*，你将与类的*实例*进行工作。在这一章中，你将编写类并创建这些类的实例。你将指定可以存储在实例中的信息类型，并定义可以对这些实例进行的操作。你还将编写扩展现有类功能的类，这样相似的类可以共享通用功能，让你用更少的代码做更多的事情。你将把你的类存储在模块中，并将其他程序员编写的类导入到你自己的程序文件中。
- en: Learning about object-oriented programming will help you see the world as a
    programmer does. It’ll help you understand your code—not just what’s happening
    line by line, but also the bigger concepts behind it. Knowing the logic behind
    classes will train you to think logically, so you can write programs that effectively
    address almost any problem you encounter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 学习面向对象编程将帮助你以程序员的视角来看待世界。它不仅能帮助你理解代码——不仅仅是逐行发生了什么，还能帮助你理解背后的更大概念。了解类的逻辑会训练你进行逻辑思考，从而让你能够编写有效解决几乎所有遇到的问题的程序。
- en: Classes also make life easier for you and the other programmers you’ll work
    with as you take on increasingly complex challenges. When you and other programmers
    write code based on the same kind of logic, you’ll be able to understand each
    other’s work. Your programs will make sense to the people you work with, allowing
    everyone to accomplish more.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类还使你和其他程序员在面对越来越复杂的挑战时，工作变得更加轻松。当你和其他程序员基于相同的逻辑编写代码时，你们能够相互理解对方的工作。你的程序将对与你合作的人有意义，从而使每个人能够做得更多。
- en: Creating and Using a Class
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用类
- en: You can model almost anything using classes. Let’s start by writing a simple
    class, `Dog`, that represents a dog—not one dog in particular, but any dog. What
    do we know about most pet dogs? Well, they all have a name and an age. We also
    know that most dogs sit and roll over. Those two pieces of information (name and
    age) and those two behaviors (sit and roll over) will go in our `Dog` class because
    they’re common to most dogs. This class will tell Python how to make an object
    representing a dog. After our class is written, we’ll use it to make individual
    instances, each of which represents one specific dog.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类来建模几乎任何事物。让我们从编写一个简单的`Dog`类开始，它代表一只狗——不是特定的某只狗，而是任何一只狗。我们对大多数宠物狗了解什么呢？嗯，它们都有一个名字和年龄。我们还知道大多数狗都会坐下并打滚。这两条信息（名字和年龄）和这两种行为（坐下和打滚）将被放入我们的`Dog`类中，因为它们是大多数狗的共性。这个类将告诉Python如何创建一个代表狗的对象。在我们写完这个类后，我们将使用它来创建单独的实例，每个实例代表一只特定的狗。
- en: Creating the Dog Class
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建狗类
- en: 'Each instance created from the `Dog` class will store a `name` and an `age`,
    and we’ll give each dog the ability to `sit()` and `roll_over()`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Dog`类创建的每个实例将存储一个`name`和一个`age`，我们还将为每只狗提供`sit()`和`roll_over()`的能力：
- en: '**dog.py**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**dog.py**'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There’s a lot to notice here, but don’t worry. You’ll see this structure throughout
    this chapter and have lots of time to get used to it. We first define a class
    called `Dog` ❶. By convention, capitalized names refer to classes in Python. There
    are no parentheses in the class definition because we’re creating this class from
    scratch. We then write a docstring describing what this class does.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多需要注意的地方，但不用担心。你将在本章中看到这种结构，并有充足的时间来适应它。我们首先定义了一个名为`Dog`的类❶。按照惯例，首字母大写的名称表示类。在类定义中没有括号，因为我们是从头开始创建这个类。接着，我们编写了一个文档字符串，描述这个类的功能。
- en: The __init__() Method
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: __init__() 方法
- en: A function that’s part of a class is a *method*. Everything you learned about
    functions applies to methods as well; the only practical difference for now is
    the way we’ll call methods. The `__init__()` method ❷ is a special method that
    Python runs automatically whenever we create a new instance based on the `Dog`
    class. This method has two leading underscores and two trailing underscores, a
    convention that helps prevent Python’s default method names from conflicting with
    your method names. Make sure to use two underscores on each side of `__init__()`.
    If you use just one on each side, the method won’t be called automatically when
    you use your class, which can result in errors that are difficult to identify.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 属于类的一部分的函数是*方法*。你学到的关于函数的所有知识同样适用于方法；目前唯一的实际区别是我们调用方法的方式。`__init__()`方法❷是一个特殊的方法，Python会在我们基于`Dog`类创建新实例时自动运行这个方法。这个方法的前后各有两个下划线，这是一个约定，用来防止Python默认的方法名称与你的方法名称发生冲突。确保在`__init__()`两边使用两个下划线。如果每边只使用一个，下划线方法就不会在使用类时自动调用，这可能会导致难以发现的错误。
- en: 'We define the `__init__()` method to have three parameters: `self`, `name`,
    and `age`. The `self` parameter is required in the method definition, and it must
    come first, before the other parameters. It must be included in the definition
    because when Python calls this method later (to create an instance of `Dog`),
    the method call will automatically pass the `self` argument. Every method call
    associated with an instance automatically passes `self`, which is a reference
    to the instance itself; it gives the individual instance access to the attributes
    and methods in the class. When we make an instance of `Dog`, Python will call
    the `__init__()` method from the `Dog` class. We’ll pass `Dog()` a name and an
    age as arguments; `self` is passed automatically, so we don’t need to pass it.
    Whenever we want to make an instance from the `Dog` class, we’ll provide values
    for only the last two parameters, `name` and `age`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`__init__()`方法，包含三个参数：`self`、`name`和`age`。`self`参数在方法定义中是必需的，并且必须排在其他参数之前。它必须包含在定义中，因为当Python稍后调用这个方法时（以创建`Dog`的实例），方法调用会自动传入`self`参数。每个与实例相关的调用都会自动传递`self`，它是对实例本身的引用；它让单个实例能够访问类中的属性和方法。当我们创建`Dog`的实例时，Python将调用`Dog`类的`__init__()`方法。我们将`Dog()`的名称和年龄作为参数传递；`self`会自动传递，所以我们不需要传递它。每当我们想从`Dog`类创建一个实例时，我们只需要为最后两个参数`name`和`age`提供值。
- en: The two variables defined in the body of the `__init__()` method each have the
    prefix `self` ❸. Any variable prefixed with `self` is available to every method
    in the class, and we’ll also be able to access these variables through any instance
    created from the class. The line `self.name = name` takes the value associated
    with the parameter `name` and assigns it to the variable `name`, which is then
    attached to the instance being created. The same process happens with `self.age
    = age`. Variables that are accessible through instances like this are called *attributes*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__()`方法的主体中定义的两个变量都有前缀`self`❸。任何以`self`为前缀的变量在类的每个方法中都可以使用，并且我们还可以通过从该类创建的任何实例来访问这些变量。`self.name
    = name`这一行将与参数`name`相关联的值赋给变量`name`，然后将其附加到正在创建的实例上。`self.age = age`也做了相同的处理。通过实例可以访问的变量被称为*属性*。
- en: 'The `Dog` class has two other methods defined: `sit()` and `roll_over()` ❹.
    Because these methods don’t need additional information to run, we just define
    them to have one parameter, `self`. The instances we create later will have access
    to these methods. In other words, they’ll be able to sit and roll over. For now,
    `sit()` and `roll_over()` don’t do much. They simply print a message saying the
    dog is sitting or rolling over. But the concept can be extended to realistic situations:
    if this class were part of a computer game, these methods would contain code to
    make an animated dog sit and roll over. If this class was written to control a
    robot, these methods would direct movements that cause a robotic dog to sit and
    roll over.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dog` 类定义了另外两个方法：`sit()` 和 `roll_over()` ❹。因为这些方法在运行时不需要额外的信息，我们只需定义它们有一个参数，即
    `self`。我们稍后创建的实例将能够访问这些方法。换句话说，它们将能够坐下和打滚。现在，`sit()` 和 `roll_over()` 并不会做太多事情。它们仅仅打印一条信息，说明狗狗正在坐下或打滚。但这个概念可以扩展到实际情况：如果这个类是某个电脑游戏的一部分，这些方法将包含代码来让动画中的狗狗坐下或打滚。如果这个类是为了控制机器人编写的，这些方法将指挥机器狗坐下和打滚。'
- en: Making an Instance from a Class
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从类中创建实例
- en: Think of a class as a set of instructions for how to make an instance. The `Dog`
    class is a set of instructions that tells Python how to make individual instances
    representing specific dogs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将类看作一套说明，告诉我们如何创建一个实例。`Dog` 类就是一套说明，它告诉 Python 如何创建代表特定狗狗的实例。
- en: 'Let’s make an instance representing a specific dog:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个代表特定狗狗的实例：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Dog` class we’re using here is the one we just wrote in the previous example.
    Here, we tell Python to create a dog whose name is `'Willie'` and whose age is
    `6` ❶. When Python reads this line, it calls the `__init__()` method in `Dog`
    with the arguments `'Willie'` and `6`. The `__init__()` method creates an instance
    representing this particular dog and sets the `name` and `age` attributes using
    the values we provided. Python then returns an instance representing this dog.
    We assign that instance to the variable `my_dog`. The naming convention is helpful
    here; we can usually assume that a capitalized name like `Dog` refers to a class,
    and a lowercase name like `my_dog` refers to a single instance created from a
    class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里使用的 `Dog` 类是我们在前一个示例中编写的类。在这里，我们告诉 Python 创建一只名叫 `'Willie'`、年龄为 `6` ❶ 的狗。当
    Python 读取这一行时，它会调用 `Dog` 中的 `__init__()` 方法，传入参数 `'Willie'` 和 `6`。`__init__()`
    方法创建一个代表这只特定狗狗的实例，并使用我们提供的值设置 `name` 和 `age` 属性。然后，Python 返回一个代表这只狗的实例，我们将这个实例赋给变量
    `my_dog`。命名约定在这里很有帮助；我们通常可以假设像 `Dog` 这样的首字母大写的名称指的是一个类，而像 `my_dog` 这样的全小写名称指的是从类创建的单个实例。
- en: Accessing Attributes
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问属性
- en: 'To access the attributes of an instance, you use dot notation. We access the
    value of `my_dog`’s attribute `name` ❷ by writing:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问实例的属性，使用点符号。我们通过以下方式访问 `my_dog` 的 `name` 属性 ❷ 的值：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Dot notation is used often in Python. This syntax demonstrates how Python finds
    an attribute’s value. Here, Python looks at the instance `my_dog` and then finds
    the attribute `name` associated with `my_dog`. This is the same attribute referred
    to as `self.name` in the class `Dog`. We use the same approach to work with the
    attribute `age` ❸.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 点符号在 Python 中使用频繁。这种语法展示了 Python 如何找到一个属性的值。这里，Python 查看实例 `my_dog`，然后找到与 `my_dog`
    关联的 `name` 属性。这与在 `Dog` 类中提到的 `self.name` 属性相同。我们用相同的方法来处理 `age` 属性 ❸。
- en: 'The output is a summary of what we know about `my_dog`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是我们关于 `my_dog` 的总结：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Calling Methods
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用方法
- en: 'After we create an instance from the class `Dog`, we can use dot notation to
    call any method defined in `Dog`. Let’s make our dog sit and roll over:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从 `Dog` 类创建一个实例之后，可以使用点符号调用 `Dog` 中定义的任何方法。让我们让狗狗坐下和打滚：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To call a method, give the name of the instance (in this case, `my_dog`) and
    the method you want to call, separated by a dot. When Python reads `my_dog.sit()`,
    it looks for the method `sit()` in the class `Dog` and runs that code. Python
    interprets the line `my_dog.roll_over()` in the same way.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用一个方法，给出实例的名称（在本例中是 `my_dog`）和你想调用的方法，中间用点（`.`）隔开。当 Python 读取 `my_dog.sit()`
    时，它会在 `Dog` 类中查找 `sit()` 方法并运行该代码。Python 以相同的方式解释 `my_dog.roll_over()` 这一行。
- en: 'Now Willie does what we tell him to:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Willie 按照我们的指示行动：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This syntax is quite useful. When attributes and methods have been given appropriately
    descriptive names like `name`, `age`, `sit()`, and `roll_over()`, we can easily
    infer what a block of code, even one we’ve never seen before, is supposed to do.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法非常有用。当属性和方法像`name`、`age`、`sit()`和`roll_over()`这样被赋予恰当的描述性名称时，我们可以轻松地推断出即使是我们从未见过的一段代码也应该做什么。
- en: Creating Multiple Instances
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建多个实例
- en: 'You can create as many instances from a class as you need. Let’s create a second
    dog called `your_dog`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要从类中创建任意多个实例。让我们创建第二只狗，叫做`your_dog`：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example we create a dog named Willie and a dog named Lucy. Each dog
    is a separate instance with its own set of attributes, capable of the same set
    of actions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一只名叫Willie的狗和一只名叫Lucy的狗。每只狗都是一个独立的实例，拥有自己的一组属性，能够执行相同的一组操作：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Even if we used the same name and age for the second dog, Python would still
    create a separate instance from the `Dog` class. You can make as many instances
    from one class as you need, as long as you give each instance a unique variable
    name or it occupies a unique spot in a list or dictionary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们为第二只狗使用相同的名字和年龄，Python仍然会从`Dog`类中创建一个单独的实例。你可以根据需要从一个类创建任意多的实例，只要为每个实例赋予一个唯一的变量名，或者它占据列表或字典中的一个唯一位置。
- en: Working with Classes and Instances
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类和实例
- en: You can use classes to represent many real-world situations. Once you write
    a class, you’ll spend most of your time working with instances created from that
    class. One of the first tasks you’ll want to do is modify the attributes associated
    with a particular instance. You can modify the attributes of an instance directly
    or write methods that update attributes in specific ways.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类来表示许多现实世界的情况。一旦你编写了一个类，你将大部分时间都花在与从该类创建的实例进行交互上。你首先想要做的任务之一就是修改与特定实例相关的属性。你可以直接修改实例的属性，或者编写方法以特定方式更新属性。
- en: The Car Class
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汽车类
- en: 'Let’s write a new class representing a car. Our class will store information
    about the kind of car we’re working with, and it will have a method that summarizes
    this information:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个表示汽车的新类。我们的类将存储我们正在使用的汽车类型信息，并且它将有一个方法来总结这些信息：
- en: '**car.py**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**car.py**'
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `Car` class, we define the `__init__()` method with the `self` parameter
    first ❶, just like we did with the `Dog` class. We also give it three other parameters:
    `make`, `model`, and `year`. The `__init__()` method takes in these parameters
    and assigns them to the attributes that will be associated with instances made
    from this class. When we make a new `Car` instance, we’ll need to specify a make,
    model, and year for our instance.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Car`类中，我们首先定义`__init__()`方法，并将`self`参数放在最前面❶，就像我们在`Dog`类中所做的那样。我们还为它提供了三个其他参数：`make`、`model`和`year`。`__init__()`方法接收这些参数并将它们分配给将与从此类创建的实例相关联的属性。当我们创建一个新的`Car`实例时，我们需要为我们的实例指定品牌、型号和年份。
- en: 'We define a method called `get_descriptive_name()` ❷ that puts a car’s `year`,
    `make`, and `model` into one string neatly describing the car. This will spare
    us from having to print each attribute’s value individually. To work with the
    attribute values in this method, we use `self.make`, `self.model`, and `self.year`.
    Outside of the class, we make an instance from the `Car` class and assign it to
    the variable `my_new_car` ❸. Then we call `get_descriptive_name()` to show what
    kind of car we have:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`get_descriptive_name()`的方法❷，它将一辆车的`year`、`make`和`model`组合成一个简洁的字符串来描述汽车。这将节省我们逐个打印每个属性值的麻烦。为了在这个方法中操作属性值，我们使用`self.make`、`self.model`和`self.year`。在类外部，我们从`Car`类创建一个实例，并将其赋值给变量`my_new_car`❸。然后我们调用`get_descriptive_name()`方法来显示我们拥有的是什么样的汽车：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To make the class more interesting, let’s add an attribute that changes over
    time. We’ll add an attribute that stores the car’s overall mileage.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让类更有趣，让我们添加一个随时间变化的属性。我们将添加一个属性，用来存储汽车的总里程。
- en: Setting a Default Value for an Attribute
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为属性设置默认值
- en: When an instance is created, attributes can be defined without being passed
    in as parameters. These attributes can be defined in the `__init__()` method,
    where they are assigned a default value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例被创建时，属性可以在不作为参数传递的情况下定义。这些属性可以在`__init__()`方法中定义，并为其分配默认值。
- en: 'Let’s add an attribute called `odometer_reading` that always starts with a
    value of 0\. We’ll also add a method `read_odometer()` that helps us read each
    car’s odometer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个名为`odometer_reading`的属性，它的初始值始终为0。我们还将添加一个方法`read_odometer()`，帮助我们读取每辆车的里程表：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This time, when Python calls the `__init__()` method to create a new instance,
    it stores the make, model, and year values as attributes, like it did in the previous
    example. Then Python creates a new attribute called `odometer_reading` and sets
    its initial value to 0 ❶. We also have a new method called `read_odometer()` ❷
    that makes it easy to read a car’s mileage.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当Python调用`__init__()`方法创建新实例时，它将像前一个示例中那样存储制造商、型号和年份作为属性。然后，Python创建一个名为`odometer_reading`的新属性，并将其初始值设置为0❶。我们还创建了一个新方法`read_odometer()`❷，它使读取汽车的里程数变得非常容易。
- en: 'Our car starts with a mileage of 0:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的车的初始里程为0：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Not many cars are sold with exactly 0 miles on the odometer, so we need a way
    to change the value of this attribute.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有汽车的里程表上显示完全为0的里程，因此我们需要一种方法来更改这个属性的值。
- en: Modifying Attribute Values
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改属性值
- en: 'You can change an attribute’s value in three ways: you can change the value
    directly through an instance, set the value through a method, or increment the
    value (add a certain amount to it) through a method. Let’s look at each of these
    approaches.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过三种方式修改属性值：可以通过实例直接修改值，或者通过方法设置值，或者通过方法增量修改值（即增加一定的数值）。让我们来看看这三种方法。
- en: Modifying an Attribute’s Value Directly
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 直接修改属性值
- en: 'The simplest way to modify the value of an attribute is to access the attribute
    directly through an instance. Here we set the odometer reading to 23 directly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 修改属性值的最简单方法是通过实例直接访问该属性。在这里，我们直接将里程表读数设置为23：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We use dot notation to access the car’s `odometer_reading` attribute, and set
    its value directly. This line tells Python to take the instance `my_new_car`,
    find the attribute `odometer_reading` associated with it, and set the value of
    that attribute to 23:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用点符号访问汽车的`odometer_reading`属性，并直接设置它的值。这行代码告诉Python，获取实例`my_new_car`，找到与其相关的`odometer_reading`属性，并将该属性的值设置为23：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Sometimes you’ll want to access attributes directly like this, but other times
    you’ll want to write a method that updates the value for you.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望直接访问属性值，但也有时你会希望编写一个方法来更新该值。
- en: Modifying an Attribute’s Value Through a Method
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过方法修改属性值
- en: It can be helpful to have methods that update certain attributes for you. Instead
    of accessing the attribute directly, you pass the new value to a method that handles
    the updating internally.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，方法可以帮助你更新某些属性。你不需要直接访问属性，而是将新值传递给方法，由方法内部处理更新。
- en: 'Here’s an example showing a method called `update_odometer()`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，展示了一个名为`update_odometer()`的方法：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The only modification to `Car` is the addition of `update_odometer()`. This
    method takes in a mileage value and assigns it to `self.odometer_reading`. Using
    the `my_new_car` instance, we call `update_odometer()` with `23` as an argument
    ❶. This sets the odometer reading to 23, and `read_odometer()` prints the reading:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Car`类的唯一修改是添加了`update_odometer()`方法。这个方法接受一个里程值并将其赋值给`self.odometer_reading`。通过`my_new_car`实例，我们调用`update_odometer()`并传入`23`作为参数❶。这将把里程表读数设置为23，接着`read_odometer()`打印出该读数：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can extend the method `update_odometer()` to do additional work every time
    the odometer reading is modified. Let’s add a little logic to make sure no one
    tries to roll back the odometer reading:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展`update_odometer()`方法，使其每次修改里程表读数时执行额外的操作。让我们添加一些逻辑，确保没有人试图回滚里程表读数：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now `update_odometer()` checks that the new reading makes sense before modifying
    the attribute. If the value provided for `mileage` is greater than or equal to
    the existing mileage, `self.odometer_reading`, you can update the odometer reading
    to the new mileage ❶. If the new mileage is less than the existing mileage, you’ll
    get a warning that you can’t roll back an odometer ❷.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`update_odometer()`会在修改属性之前检查新读数是否合理。如果提供的`mileage`值大于或等于现有的里程数`self.odometer_reading`，则可以将里程表读数更新为新的里程数❶。如果新里程数小于现有里程数，系统会发出警告，提示不能回滚里程表❷。
- en: Incrementing an Attribute’s Value Through a Method
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过方法增加属性值
- en: 'Sometimes you’ll want to increment an attribute’s value by a certain amount,
    rather than set an entirely new value. Say we buy a used car and put 100 miles
    on it between the time we buy it and the time we register it. Here’s a method
    that allows us to pass this incremental amount and add that value to the odometer
    reading:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望按一定的增量来修改属性值，而不是设置一个全新的值。假设我们购买了一辆二手车，并在购车和注册之间行驶了100英里。这里有一个方法，可以让我们传入这个增量并将其添加到里程表读数中：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The new method `increment_odometer()` takes in a number of miles, and adds
    this value to `self.odometer_reading`. First, we create a used car, `my_used_car`
    ❶. We set its odometer to 23,500 by calling `update_odometer()` and passing it
    `23_500` ❷. Finally, we call `increment_odometer()` and pass it `100` to add the
    100 miles that we drove between buying the car and registering it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 新的方法 `increment_odometer()` 接受一个里程数，并将其添加到 `self.odometer_reading`。首先，我们创建一个二手车
    `my_used_car` ❶。我们通过调用 `update_odometer()` 并传入 `23_500` ❷，将其里程表设置为 23,500。最后，我们调用
    `increment_odometer()` 并传入 `100`，以便将我们从购车到注册这段时间行驶的 100 英里加到里程表上：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can modify this method to reject negative increments so no one uses this
    function to roll back an odometer as well.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改此方法，以拒绝负数增量，防止有人使用此功能回调里程表。
- en: Inheritance
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: You don’t always have to start from scratch when writing a class. If the class
    you’re writing is a specialized version of another class you wrote, you can use
    *inheritance*. When one class *inherits* from another, it takes on the attributes
    and methods of the first class. The original class is called the *parent class*,
    and the new class is the *child class*. The child class can inherit any or all
    of the attributes and methods of its parent class, but it’s also free to define
    new attributes and methods of its own.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编写类时，你不一定要从头开始。如果你编写的类是你之前写的另一个类的特化版本，你可以使用 *继承*。当一个类 *继承* 另一个类时，它会继承第一个类的属性和方法。原始类称为
    *父类*，新类称为 *子类*。子类可以继承父类的部分或全部属性和方法，但它也可以自由地定义自己新的属性和方法。
- en: The __init__() Method for a Child Class
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子类的 `__init__()` 方法
- en: When you’re writing a new class based on an existing class, you’ll often want
    to call the `__init__()` method from the parent class. This will initialize any
    attributes that were defined in the parent `__init__()` method and make them available
    in the child class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你基于现有类编写新类时，通常会希望调用父类的 `__init__()` 方法。这将初始化父类 `__init__()` 方法中定义的任何属性，并使它们在子类中可用。
- en: As an example, let’s model an electric car. An electric car is just a specific
    kind of car, so we can base our new `ElectricCar` class on the `Car` class we
    wrote earlier. Then we’ll only have to write code for the attributes and behaviors
    specific to electric cars.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们来建模一辆电动汽车。电动汽车只是一种特殊类型的汽车，因此我们可以将新的 `ElectricCar` 类基于我们之前编写的 `Car` 类。这样，我们只需要为电动汽车特有的属性和行为编写代码。
- en: 'Let’s start by making a simple version of the `ElectricCar` class, which does
    everything the `Car` class does:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先做一个简单版的 `ElectricCar` 类，它完成 `Car` 类所做的所有工作：
- en: '**electric_car.py**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**electric_car.py**'
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We start with `Car` ❶. When you create a child class, the parent class must
    be part of the current file and must appear before the child class in the file.
    We then define the child class, `ElectricCar` ❷. The name of the parent class
    must be included in parentheses in the definition of a child class. The `__init__()`
    method takes in the information required to make a `Car` instance ❸.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `Car` ❶ 开始。当你创建一个子类时，父类必须位于当前文件中，并且必须出现在子类之前。然后，我们定义了子类 `ElectricCar` ❷。在定义子类时，父类的名称必须包含在括号内。`__init__()`
    方法接收创建 `Car` 实例所需的信息 ❸。
- en: The `super()` function ❹ is a special function that allows you to call a method
    from the parent class. This line tells Python to call the `__init__()` method
    from `Car`, which gives an `ElectricCar` instance all the attributes defined in
    that method. The name *super* comes from a convention of calling the parent class
    a *superclass* and the child class a *subclass*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`super()` 函数❹是一个特殊的函数，允许你调用父类的方法。这一行代码告诉 Python 调用 `Car` 类中的 `__init__()` 方法，从而为
    `ElectricCar` 实例赋予该方法中定义的所有属性。*super* 这个名字来源于一种约定，称父类为 *超类*，子类为 *子类*。'
- en: We test whether inheritance is working properly by trying to create an electric
    car with the same kind of information we’d provide when making a regular car.
    We make an instance of the `ElectricCar` class and assign it to `my_leaf` ❺. This
    line calls the `__init__()` method defined in `ElectricCar`, which in turn tells
    Python to call the `__init__()` method defined in the parent class `Car`. We provide
    the arguments `'nissan'`, `'leaf'`, and `2024`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过尝试使用与制作普通汽车时相同的信息创建一辆电动汽车来测试继承是否正常工作。我们创建了一个 `ElectricCar` 类的实例并将其赋值给 `my_leaf`
    ❺。这一行代码调用了 `ElectricCar` 中定义的 `__init__()` 方法，进而告诉 Python 调用父类 `Car` 中定义的 `__init__()`
    方法。我们提供了参数 `'nissan'`、`'leaf'` 和 `2024`。
- en: 'Aside from `__init__()`, there are no attributes or methods yet that are particular
    to an electric car. At this point we’re just making sure the electric car has
    the appropriate `Car` behaviors:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`__init__()`之外，尚未有任何特定于电动汽车的属性或方法。此时我们只是确保电动汽车具有适当的`Car`类行为：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `ElectricCar` instance works just like an instance of `Car`, so now we can
    begin defining attributes and methods specific to electric cars.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElectricCar`实例的行为和`Car`实例一样，因此现在我们可以开始定义特定于电动汽车的属性和方法。'
- en: Defining Attributes and Methods for the Child Class
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为子类定义属性和方法
- en: Once you have a child class that inherits from a parent class, you can add any
    new attributes and methods necessary to differentiate the child class from the
    parent class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个从父类继承的子类，你可以添加任何必要的新属性和方法，以便将子类与父类区分开来。
- en: 'Let’s add an attribute that’s specific to electric cars (a battery, for example)
    and a method to report on this attribute. We’ll store the battery size and write
    a method that prints a description of the battery:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个特定于电动汽车的属性（例如电池）以及一个报告此属性的方法。我们将存储电池大小并编写一个打印电池描述的方法：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We add a new attribute `self.battery_size` and set its initial value to `40`
    ❶. This attribute will be associated with all instances created from the `ElectricCar`
    class but won’t be associated with any instances of `Car`. We also add a method
    called `describe_battery()` that prints information about the battery ❷. When
    we call this method, we get a description that is clearly specific to an electric
    car:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的属性`self.battery_size`，并将其初始值设置为`40` ❶。这个属性将与从`ElectricCar`类创建的所有实例相关联，但不会与任何`Car`实例相关联。我们还添加了一个名为`describe_battery()`的方法，用于打印电池的信息
    ❷。当我们调用这个方法时，会得到一个明确针对电动汽车的描述：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There’s no limit to how much you can specialize the `ElectricCar` class. You
    can add as many attributes and methods as you need to model an electric car to
    whatever degree of accuracy you need. An attribute or method that could belong
    to any car, rather than one that’s specific to an electric car, should be added
    to the `Car` class instead of the `ElectricCar` class. Then anyone who uses the
    `Car` class will have that functionality available as well, and the `ElectricCar`
    class will only contain code for the information and behavior specific to electric
    vehicles.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElectricCar`类的专业化没有限制。你可以根据需要添加任意数量的属性和方法，以达到你需要的电动汽车建模精度。任何可以属于所有汽车的属性或方法，而不是特定于电动汽车的，应该添加到`Car`类中，而不是`ElectricCar`类中。这样，使用`Car`类的任何人都可以获得这些功能，而`ElectricCar`类将仅包含与电动汽车特定信息和行为相关的代码。'
- en: Overriding Methods from the Parent Class
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重写父类的方法
- en: You can override any method from the parent class that doesn’t fit what you’re
    trying to model with the child class. To do this, you define a method in the child
    class with the same name as the method you want to override in the parent class.
    Python will disregard the parent class method and only pay attention to the method
    you define in the child class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重写父类中不适合你在子类中建模的方法。为了做到这一点，你需要在子类中定义一个与父类中要重写的方法同名的方法。Python会忽略父类的方法，只关注你在子类中定义的方法。
- en: 'Say the class `Car` had a method called `fill_gas_tank()`. This method is meaningless
    for an all-electric vehicle, so you might want to override this method. Here’s
    one way to do that:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Car`类有一个名为`fill_gas_tank()`的方法。这个方法对于全电动汽车来说没有意义，所以你可能想要重写这个方法。下面是实现这一点的一种方式：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now if someone tries to call `fill_gas_tank()` with an electric car, Python
    will ignore the method `fill_gas_tank()` in `Car` and run this code instead. When
    you use inheritance, you can make your child classes retain what you need and
    override anything you don’t need from the parent class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有人尝试对电动汽车调用`fill_gas_tank()`，Python会忽略`Car`类中的`fill_gas_tank()`方法，而运行这段代码。当你使用继承时，你可以让子类保留你需要的内容，并重写你不需要的父类方法。
- en: Instances as Attributes
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例作为属性
- en: When modeling something from the real world in code, you may find that you’re
    adding more and more detail to a class. You’ll find that you have a growing list
    of attributes and methods and that your files are becoming lengthy. In these situations,
    you might recognize that part of one class can be written as a separate class.
    You can break your large class into smaller classes that work together; this approach
    is called *composition*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在用代码建模现实世界中的事物时，你可能会发现自己在不断向一个类中添加更多的细节。你会发现属性和方法的列表越来越长，文件也变得越来越冗长。在这种情况下，你可能会意识到某个类的部分内容可以作为单独的类来编写。你可以将一个大的类拆分为多个相互协作的小类，这种方法叫做*组合*。
- en: 'For example, if we continue adding detail to the `ElectricCar` class, we might
    notice that we’re adding many attributes and methods specific to the car’s battery.
    When we see this happening, we can stop and move those attributes and methods
    to a separate class called `Battery`. Then we can use a `Battery` instance as
    an attribute in the `ElectricCar` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们继续向`ElectricCar`类添加细节，可能会注意到我们正在添加许多与汽车电池相关的属性和方法。当我们看到这种情况时，可以停下来，将这些属性和方法移动到一个名为`Battery`的单独类中。然后我们可以在`ElectricCar`类中使用`Battery`实例作为属性：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We define a new class called `Battery` that doesn’t inherit from any other class.
    The `__init__()` method ❶ has one parameter, `battery_size`, in addition to `self`.
    This is an optional parameter that sets the battery’s size to 40 if no value is
    provided. The method `describe_battery()` has been moved to this class as well
    ❷.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Battery`的新类，它没有继承任何其他类。`__init__()`方法❶除了`self`之外，还有一个参数`battery_size`。这是一个可选参数，如果没有提供值，则将电池大小设为40。`describe_battery()`方法也已移到这个类中❷。
- en: In the `ElectricCar` class, we now add an attribute called `self.battery` ❸.
    This line tells Python to create a new instance of `Battery` (with a default size
    of 40, because we’re not specifying a value) and assign that instance to the attribute
    `self.battery`. This will happen every time the `__init__()` method is called;
    any `ElectricCar` instance will now have a `Battery` instance created automatically.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ElectricCar`类中，我们现在添加了一个名为`self.battery`的属性❸。这一行代码告诉Python创建一个新的`Battery`实例（默认大小为40，因为我们没有指定值），并将该实例分配给属性`self.battery`。每次调用`__init__()`方法时，这个操作都会发生；任何`ElectricCar`实例现在都会自动创建一个`Battery`实例。
- en: 'We create an electric car and assign it to the variable `my_leaf`. When we
    want to describe the battery, we need to work through the car’s `battery` attribute:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一辆电动汽车，并将其分配给变量`my_leaf`。当我们想描述电池时，我们需要通过汽车的`battery`属性来操作：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This line tells Python to look at the instance `my_leaf`, find its `battery`
    attribute, and call the method `describe_battery()` that’s associated with the
    `Battery` instance assigned to the attribute.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码告诉Python查看实例`my_leaf`，找到其`battery`属性，并调用与分配给该属性的`Battery`实例相关联的`describe_battery()`方法。
- en: 'The output is identical to what we saw previously:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与我们之前看到的完全相同：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This looks like a lot of extra work, but now we can describe the battery in
    as much detail as we want without cluttering the `ElectricCar` class. Let’s add
    another method to `Battery` that reports the range of the car based on the battery
    size:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是多余的工作，但现在我们可以详细描述电池，而不必让`ElectricCar`类变得臃肿。让我们向`Battery`中添加另一个方法，用于报告基于电池大小的汽车续航：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The new method `get_range()` performs some simple analysis. If the battery’s
    capacity is 40 kWh, `get_range()` sets the range to 150 miles, and if the capacity
    is 65 kWh, it sets the range to 225 miles. It then reports this value. When we
    want to use this method, we again have to call it through the car’s `battery`
    attribute ❶.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法`get_range()`执行一些简单的分析。如果电池的容量是40 kWh，`get_range()`将续航设定为150英里；如果容量是65 kWh，则设定为225英里。然后，它会报告这个值。当我们想使用这个方法时，我们需要通过汽车的`battery`属性再次调用它❶。
- en: 'The output tells us the range of the car based on its battery size:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们基于电池大小的汽车续航：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Modeling Real-World Objects
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实世界对象建模
- en: As you begin to model more complicated things like electric cars, you’ll wrestle
    with interesting questions. Is the range of an electric car a property of the
    battery or of the car? If we’re only describing one car, it’s probably fine to
    maintain the association of the method `get_range()` with the `Battery` class.
    But if we’re describing a manufacturer’s entire line of cars, we probably want
    to move `get_range()` to the `ElectricCar` class. The `get_range()` method would
    still check the battery size before determining the range, but it would report
    a range specific to the kind of car it’s associated with. Alternatively, we could
    maintain the association of the `get_range()` method with the battery but pass
    it a parameter such as `car_model`. The `get_range()` method would then report
    a range based on the battery size and car model.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始建模更复杂的事物，比如电动汽车时，你会遇到有趣的问题。电动汽车的续航是电池的属性，还是汽车的属性？如果我们只描述一辆车，可能保持`get_range()`方法与`Battery`类的关联是可以的。但如果我们在描述一家制造商的整个汽车系列，我们可能希望将`get_range()`方法移到`ElectricCar`类中。`get_range()`方法仍然会在确定续航之前检查电池大小，但它会报告一个特定于所关联汽车类型的续航。或者，我们可以保持`get_range()`方法与电池的关联，但传递一个像`car_model`这样的参数给它。`get_range()`方法然后会根据电池大小和汽车模型报告续航。
- en: This brings you to an interesting point in your growth as a programmer. When
    you wrestle with questions like these, you’re thinking at a higher logical level
    rather than a syntax-focused level. You’re thinking not about Python, but about
    how to represent the real world in code. When you reach this point, you’ll realize
    there are often no right or wrong approaches to modeling real-world situations.
    Some approaches are more efficient than others, but it takes practice to find
    the most efficient representations. If your code is working as you want it to,
    you’re doing well! Don’t be discouraged if you find you’re ripping apart your
    classes and rewriting them several times using different approaches. In the quest
    to write accurate, efficient code, everyone goes through this process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这带你进入作为程序员成长的一个有趣点。当你与这些问题作斗争时，你是在以更高的逻辑层次思考，而不是专注于语法层面。你思考的不是Python，而是如何用代码表示现实世界。当你达到这个层次时，你会意识到，建模现实世界情境时，通常没有对错之分。一些方法比其他方法更高效，但要找到最有效的表示方法需要实践。如果你的代码按照你希望的方式运行，那么你做得很好！如果你发现自己不断拆解类并用不同的方法重写它们，不要灰心。每个人在写出准确、高效的代码的过程中都会经历这一过程。
- en: Importing Classes
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入类
- en: As you add more functionality to your classes, your files can get long, even
    when you use inheritance and composition properly. In keeping with the overall
    philosophy of Python, you’ll want to keep your files as uncluttered as possible.
    To help, Python lets you store classes in modules and then import the classes
    you need into your main program.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为类添加更多功能时，即使在正确使用继承和组合的情况下，文件也可能变得很长。为了符合Python的整体哲学，你会希望保持文件尽可能简洁。为了帮助实现这一点，Python允许你将类存储在模块中，然后将需要的类导入到主程序中。
- en: Importing a Single Class
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入单个类
- en: 'Let’s create a module containing just the `Car` class. This brings up a subtle
    naming issue: we already have a file named *car.py* in this chapter, but this
    module should be named *car.py* because it contains code representing a car. We’ll
    resolve this naming issue by storing the `Car` class in a module named *car.py*,
    replacing the *car.py* file we were previously using. From now on, any program
    that uses this module will need a more specific filename, such as *my_car.py*.
    Here’s *car.py* with just the code from the class `Car`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个只包含`Car`类的模块。这引出了一个微妙的命名问题：在这一章中，我们已经有一个名为*car.py*的文件，但这个模块应该命名为*car.py*，因为它包含了代表汽车的代码。我们将通过将`Car`类存储在名为*car.py*的模块中来解决这个命名问题，取代我们之前使用的*car.py*文件。从现在起，任何使用这个模块的程序都需要一个更具体的文件名，比如*my_car.py*。以下是仅包含`Car`类代码的*car.py*：
- en: '**car.py**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**car.py**'
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We include a module-level docstring that briefly describes the contents of this
    module ❶. You should write a docstring for each module you create.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模块级别包含一个文档字符串，简要描述该模块的内容 ❶。你应该为你创建的每个模块编写文档字符串。
- en: 'Now we make a separate file called *my_car.py*. This file will import the `Car`
    class and then create an instance from that class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个单独的文件，名为*my_car.py*。这个文件将导入`Car`类，然后从这个类创建一个实例：
- en: '**my_car.py**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**my_car.py**'
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `import` statement ❶ tells Python to open the `car` module and import the
    class `Car`. Now we can use the `Car` class as if it were defined in this file.
    The output is the same as we saw earlier:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句❶告诉Python打开`car`模块并导入`Car`类。现在我们可以像在此文件中定义该类一样使用`Car`类。输出与我们之前看到的相同：'
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Importing classes is an effective way to program. Picture how long this program
    file would be if the entire `Car` class were included. When you instead move the
    class to a module and import the module, you still get all the same functionality,
    but you keep your main program file clean and easy to read. You also store most
    of the logic in separate files; once your classes work as you want them to, you
    can leave those files alone and focus on the higher-level logic of your main program.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 导入类是一种有效的编程方式。想象一下，如果将整个`Car`类包含在程序文件中，这个文件会有多长。相反，如果将类移动到模块中并导入该模块，你仍然可以获得相同的功能，但能保持主程序文件清晰易读。你还将大部分逻辑存储在单独的文件中；一旦你的类按照预期工作，你可以将这些文件保留不动，专注于主程序的更高层逻辑。
- en: Storing Multiple Classes in a Module
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在一个模块中存储多个类
- en: You can store as many classes as you need in a single module, although each
    class in a module should be related somehow. The classes `Battery` and `ElectricCar`
    both help represent cars, so let’s add them to the module *car.py*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个模块中存储尽可能多的类，尽管每个类应该以某种方式相关。`Battery`类和`ElectricCar`类都帮助表示汽车，因此我们将它们添加到模块*car.py*中。
- en: '**car.py**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**car.py**'
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we can make a new file called *my_electric_car.py*, import the `ElectricCar`
    class, and make an electric car:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新文件，命名为*my_electric_car.py*，导入`ElectricCar`类并制造一辆电动汽车：
- en: '**my_electric_car.py**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**my_electric_car.py**'
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This has the same output we saw earlier, even though most of the logic is hidden
    away in a module:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 即使大部分逻辑被隐藏在模块中，这仍然输出我们之前看到的结果：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Importing Multiple Classes from a Module
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从模块中导入多个类
- en: 'You can import as many classes as you need into a program file. If we want
    to make a regular car and an electric car in the same file, we need to import
    both classes, `Car` and `ElectricCar`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将所需的多个类导入到程序文件中。如果我们想在同一个文件中制作一辆常规汽车和一辆电动汽车，我们需要导入`Car`类和`ElectricCar`类：
- en: '**my_cars.py**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**my_cars.py**'
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You import multiple classes from a module by separating each class with a comma
    ❶. Once you’ve imported the necessary classes, you’re free to make as many instances
    of each class as you need.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过用逗号❶分隔每个类来从模块中导入多个类。一旦导入了必要的类，你可以根据需要创建每个类的任意数量的实例。
- en: 'In this example we make a gas-powered Ford Mustang ❷ and then an electric Nissan
    Leaf ❸:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一辆汽油驱动的福特野马❷，然后是电动的日产聆风❸：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Importing an Entire Module
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入整个模块
- en: You can also import an entire module and then access the classes you need using
    dot notation. This approach is simple and results in code that is easy to read.
    Because every call that creates an instance of a class includes the module name,
    you won’t have naming conflicts with any names used in the current file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以导入整个模块，然后使用点符号访问所需的类。这种方法简单，代码也容易阅读。因为每次创建类实例的调用都包括模块名称，所以你不会与当前文件中使用的任何名称发生命名冲突。
- en: 'Here’s what it looks like to import the entire `car` module and then create
    a regular car and an electric car:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是导入整个`car`模块并创建一辆常规汽车和一辆电动汽车的代码：
- en: '**my_cars.py**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**my_cars.py**'
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: First we import the entire `car` module ❶. We then access the classes we need
    through the `module_name`.`ClassName` syntax. We again create a Ford Mustang ❷,
    and a Nissan Leaf ❸.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入整个`car`模块❶。然后，我们通过`module_name`.`ClassName`语法访问所需的类。我们再次创建一辆福特野马❷和一辆日产聆风❸。
- en: Importing All Classes from a Module
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从模块中导入所有类
- en: 'You can import every class from a module using the following syntax:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下语法导入模块中的每个类：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This method is not recommended for two reasons. First, it’s helpful to be able
    to read the `import` statements at the top of a file and get a clear sense of
    which classes a program uses. With this approach it’s unclear which classes you’re
    using from the module. This approach can also lead to confusion with names in
    the file. If you accidentally import a class with the same name as something else
    in your program file, you can create errors that are hard to diagnose. I show
    this here because even though it’s not a recommended approach, you’re likely to
    see it in other people’s code at some point.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不推荐使用，原因有两个。首先，能够阅读文件顶部的`import`语句并清楚了解程序使用了哪些类是很有帮助的。采用这种方法时，模块中你使用了哪些类并不清晰。这个方法也可能导致文件中的命名混乱。如果你不小心导入了一个与程序文件中其他内容同名的类，可能会产生难以诊断的错误。我之所以在这里展示这种方法，是因为尽管它并不推荐，但你可能会在其他人的代码中看到它。
- en: If you need to import many classes from a module, you’re better off importing
    the entire module and using the `module_name.ClassName` syntax. You won’t see
    all the classes used at the top of the file, but you’ll see clearly where the
    module is used in the program. You’ll also avoid the potential naming conflicts
    that can arise when you import every class in a module.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从一个模块导入多个类，最好导入整个模块，并使用`module_name.ClassName`语法。虽然你在文件顶部看不到所有类，但你会清楚地看到模块在程序中的使用位置。而且，你也能避免导入模块中每个类时可能出现的命名冲突。
- en: Importing a Module into a Module
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模块导入到模块中
- en: Sometimes you’ll want to spread out your classes over several modules to keep
    any one file from growing too large and avoid storing unrelated classes in the
    same module. When you store your classes in several modules, you may find that
    a class in one module depends on a class in another module. When this happens,
    you can import the required class into the first module.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能希望将类分散到多个模块中，以防某个文件过大，同时避免将不相关的类存储在同一个模块中。当你将类存储在多个模块中时，可能会发现一个模块中的类依赖于另一个模块中的类。在这种情况下，你可以将所需的类导入到第一个模块中。
- en: 'For example, let’s store the `Car` class in one module and the `ElectricCar`
    and `Battery` classes in a separate module. We’ll make a new module called *electric_car.py*—replacing
    the *electric_car.py* file we created earlier—and copy just the `Battery` and
    `ElectricCar` classes into this file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将`Car`类存储在一个模块中，将`ElectricCar`和`Battery`类存储在另一个模块中。我们将创建一个新模块，叫做*electric_car.py*——替换我们之前创建的*electric_car.py*文件——并将`Battery`和`ElectricCar`类仅复制到这个文件中：
- en: '**electric_car.py**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**electric_car.py**'
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The class `ElectricCar` needs access to its parent class `Car`, so we import
    `Car` directly into the module. If we forget this line, Python will raise an error
    when we try to import the `electric_car` module. We also need to update the `Car`
    module so it contains only the `Car` class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElectricCar`类需要访问它的父类`Car`，因此我们直接将`Car`导入模块。如果我们忘记了这行代码，当尝试导入`electric_car`模块时，Python会抛出错误。我们还需要更新`Car`模块，使其只包含`Car`类：'
- en: '**car.py**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**car.py**'
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can import from each module separately and create whatever kind of car
    we need:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以分别从每个模块导入，并创建任何我们需要的汽车：
- en: '**my_cars.py**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**my_cars.py**'
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We import `Car` from its module, and `ElectricCar` from its module. We then
    create one regular car and one electric car. Both cars are created correctly:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从它的模块导入`Car`，并从它的模块导入`ElectricCar`。然后我们创建一辆普通汽车和一辆电动汽车。两辆车都创建得正确无误：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using Aliases
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用别名
- en: As you saw in Chapter 8, aliases can be quite helpful when using modules to
    organize your projects’ code. You can use aliases when importing classes as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第8章看到的，使用模块时，别名非常有帮助，能帮助你组织项目代码。你也可以在导入类时使用别名。
- en: 'As an example, consider a program where you want to make a bunch of electric
    cars. It might get tedious to type (and read) `ElectricCar` over and over again.
    You can give `ElectricCar` an alias in the import statement:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你有一个程序，你需要制造一堆电动汽车。反复输入（和读取）`ElectricCar`可能会变得很繁琐。你可以在导入语句中为`ElectricCar`起个别名：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now you can use this alias whenever you want to make an electric car:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每当你想制造电动汽车时，你可以使用这个别名：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can also give a module an alias. Here’s how to import the entire `electric_car`
    module using an alias:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为模块指定别名。以下是如何使用别名导入整个`electric_car`模块的方法：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now you can use this module alias with the full class name:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过模块别名来使用完整的类名：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finding Your Own Workflow
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找自己的工作流程
- en: As you can see, Python gives you many options for how to structure code in a
    large project. It’s important to know all these possibilities so you can determine
    the best ways to organize your projects as well as understand other people’s projects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Python为大型项目提供了多种代码结构选项。了解这些选项非常重要，这样你就能确定最佳的项目组织方式，同时也能理解他人的项目。
- en: When you’re starting out, keep your code structure simple. Try doing everything
    in one file and moving your classes to separate modules once everything is working.
    If you like how modules and files interact, try storing your classes in modules
    when you start a project. Find an approach that lets you write code that works,
    and go from there.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始编写代码时，保持代码结构简单。尝试将所有内容写在一个文件中，等一切正常后，再将类移到单独的模块中。如果你喜欢模块和文件之间的交互，试着在开始一个项目时将类存储在模块中。找到一种能让你编写有效代码的方法，并从那里出发。
- en: The Python Standard Library
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python标准库
- en: The *Python standard library* is a set of modules included with every Python
    installation. Now that you have a basic understanding of how functions and classes
    work, you can start to use modules like these that other programmers have written.
    You can use any function or class in the standard library by including a simple
    `import` statement at the top of your file. Let’s look at one module, `random`,
    which can be useful in modeling many real-world situations.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python标准库* 是随每个Python安装一起提供的一组模块。现在你已经基本理解了函数和类是如何工作的，你可以开始使用其他程序员编写的类似模块。你可以通过在文件顶部添加简单的`import`语句来使用标准库中的任何函数或类。我们来看一个模块，`random`，它在模拟许多现实世界的情况时非常有用。'
- en: One interesting function from the random module is `randint()`. This function
    takes two integer arguments and returns a randomly selected integer between (and
    including) those numbers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`random`模块的一个有趣函数是`randint()`。该函数接受两个整数参数，并返回这两个数字之间（包括这两个数字）的随机整数。
- en: 'Here’s how to generate a random number between 1 and 6:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何生成1到6之间的随机数：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Another useful function is `choice()`. This function takes in a list or tuple
    and returns a randomly chosen element:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的函数是`choice()`。这个函数接受一个列表或元组，并返回一个随机选择的元素：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `random` module shouldn’t be used when building security-related applications,
    but it works well for many fun and interesting projects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`random`模块不应在构建安全相关的应用程序时使用，但它在许多有趣的项目中表现良好。'
- en: Styling Classes
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式类
- en: A few styling issues related to classes are worth clarifying, especially as
    your programs become more complicated.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类的几个样式问题值得澄清，特别是当你的程序变得更加复杂时。
- en: Class names should be written in *CamelCase*. To do this, capitalize the first
    letter of each word in the name, and don’t use underscores. Instance and module
    names should be written in lowercase, with underscores between words.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 类名应使用*驼峰命名法（CamelCase）*。为此，将每个单词的首字母大写，且不要使用下划线。实例和模块名应使用小写字母，并在单词之间使用下划线。
- en: Every class should have a docstring immediately following the class definition.
    The docstring should be a brief description of what the class does, and you should
    follow the same formatting conventions you used for writing docstrings in functions.
    Each module should also have a docstring describing what the classes in a module
    can be used for.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类在类定义之后应有一个文档字符串。文档字符串应简短描述类的功能，你应该遵循编写函数文档字符串时使用的相同格式约定。每个模块也应有一个文档字符串，描述模块中的类的用途。
- en: You can use blank lines to organize code, but don’t use them excessively. Within
    a class you can use one blank line between methods, and within a module you can
    use two blank lines to separate classes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用空行来组织代码，但不要过度使用。在一个类内部，你可以在方法之间使用一行空行，而在模块中，你可以使用两行空行来分隔类。
- en: If you need to import a module from the standard library and a module that you
    wrote, place the import statement for the standard library module first. Then
    add a blank line and the import statement for the module you wrote. In programs
    with multiple import statements, this convention makes it easier to see where
    the different modules used in the program come from.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要导入标准库中的模块和你自己编写的模块，应先导入标准库模块的语句。然后添加一个空行，再导入你自己编写模块的语句。在有多个导入语句的程序中，这种约定能更容易地看到程序中使用的不同模块的来源。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to write your own classes. You learned how
    to store information in a class using attributes and how to write methods that
    give your classes the behavior they need. You learned to write `__init__()` methods
    that create instances from your classes with exactly the attributes you want.
    You saw how to modify the attributes of an instance directly and through methods.
    You learned that inheritance can simplify the creation of classes that are related
    to each other, and you learned to use instances of one class as attributes in
    another class to keep each class simple.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写自己的类。你学习了如何使用属性在类中存储信息，以及如何编写方法来赋予类所需的行为。你学习了如何编写`__init__()`方法，通过该方法可以根据你需要的属性创建类的实例。你了解了如何直接通过实例修改属性，也学会了通过方法来修改属性。你学会了继承可以简化创建相关类的过程，并且学会了如何使用一个类的实例作为另一个类的属性，从而保持每个类的简洁性。
- en: You saw how storing classes in modules and importing classes you need into the
    files where they’ll be used can keep your projects organized. You started learning
    about the Python standard library, and you saw an example based on the `random`
    module. Finally, you learned to style your classes using Python conventions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了如何将类存储在模块中，并将所需的类导入到使用它们的文件中，这样可以保持项目的组织性。你开始学习 Python 标准库，并且通过`random`模块的示例看到了它的应用。最后，你学会了如何使用
    Python 的约定来给类添加风格。
- en: In Chapter 10, you’ll learn to work with files so you can save the work you’ve
    done in a program and the work you’ve allowed users to do. You’ll also learn about
    *exceptions*, a special Python class designed to help you respond to errors when
    they arise.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在第十章中，你将学习如何处理文件，这样你就可以保存你在程序中完成的工作以及你允许用户执行的操作。你还将了解*异常*，这是一种特殊的 Python 类，旨在帮助你在错误发生时做出响应。
