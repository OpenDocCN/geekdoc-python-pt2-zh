- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Object-oriented programming (OOP**)* is one of the most effective approaches
    to writing software. In object-oriented programming, you write *classes* that
    represent real-world things and situations, and you create *objects* based on
    these classes. When you write a class, you define the general behavior that a
    whole category of objects can have.'
  prefs: []
  type: TYPE_NORMAL
- en: When you create individual objects from the class, each object is automatically
    equipped with the general behavior; you can then give each object whatever unique
    traits you desire. You’ll be amazed how well real-world situations can be modeled
    with object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Making an object from a class is called *instantiation*, and you work with *instances*
    of a class. In this chapter you’ll write classes and create instances of those
    classes. You’ll specify the kind of information that can be stored in instances,
    and you’ll define actions that can be taken with these instances. You’ll also
    write classes that extend the functionality of existing classes, so similar classes
    can share common functionality, and you can do more with less code. You’ll store
    your classes in modules and import classes written by other programmers into your
    own program files.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about object-oriented programming will help you see the world as a
    programmer does. It’ll help you understand your code—not just what’s happening
    line by line, but also the bigger concepts behind it. Knowing the logic behind
    classes will train you to think logically, so you can write programs that effectively
    address almost any problem you encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Classes also make life easier for you and the other programmers you’ll work
    with as you take on increasingly complex challenges. When you and other programmers
    write code based on the same kind of logic, you’ll be able to understand each
    other’s work. Your programs will make sense to the people you work with, allowing
    everyone to accomplish more.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Using a Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can model almost anything using classes. Let’s start by writing a simple
    class, `Dog`, that represents a dog—not one dog in particular, but any dog. What
    do we know about most pet dogs? Well, they all have a name and an age. We also
    know that most dogs sit and roll over. Those two pieces of information (name and
    age) and those two behaviors (sit and roll over) will go in our `Dog` class because
    they’re common to most dogs. This class will tell Python how to make an object
    representing a dog. After our class is written, we’ll use it to make individual
    instances, each of which represents one specific dog.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Dog Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each instance created from the `Dog` class will store a `name` and an `age`,
    and we’ll give each dog the ability to `sit()` and `roll_over()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dog.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There’s a lot to notice here, but don’t worry. You’ll see this structure throughout
    this chapter and have lots of time to get used to it. We first define a class
    called `Dog` ❶. By convention, capitalized names refer to classes in Python. There
    are no parentheses in the class definition because we’re creating this class from
    scratch. We then write a docstring describing what this class does.
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A function that’s part of a class is a *method*. Everything you learned about
    functions applies to methods as well; the only practical difference for now is
    the way we’ll call methods. The `__init__()` method ❷ is a special method that
    Python runs automatically whenever we create a new instance based on the `Dog`
    class. This method has two leading underscores and two trailing underscores, a
    convention that helps prevent Python’s default method names from conflicting with
    your method names. Make sure to use two underscores on each side of `__init__()`.
    If you use just one on each side, the method won’t be called automatically when
    you use your class, which can result in errors that are difficult to identify.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `__init__()` method to have three parameters: `self`, `name`,
    and `age`. The `self` parameter is required in the method definition, and it must
    come first, before the other parameters. It must be included in the definition
    because when Python calls this method later (to create an instance of `Dog`),
    the method call will automatically pass the `self` argument. Every method call
    associated with an instance automatically passes `self`, which is a reference
    to the instance itself; it gives the individual instance access to the attributes
    and methods in the class. When we make an instance of `Dog`, Python will call
    the `__init__()` method from the `Dog` class. We’ll pass `Dog()` a name and an
    age as arguments; `self` is passed automatically, so we don’t need to pass it.
    Whenever we want to make an instance from the `Dog` class, we’ll provide values
    for only the last two parameters, `name` and `age`.'
  prefs: []
  type: TYPE_NORMAL
- en: The two variables defined in the body of the `__init__()` method each have the
    prefix `self` ❸. Any variable prefixed with `self` is available to every method
    in the class, and we’ll also be able to access these variables through any instance
    created from the class. The line `self.name = name` takes the value associated
    with the parameter `name` and assigns it to the variable `name`, which is then
    attached to the instance being created. The same process happens with `self.age
    = age`. Variables that are accessible through instances like this are called *attributes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Dog` class has two other methods defined: `sit()` and `roll_over()` ❹.
    Because these methods don’t need additional information to run, we just define
    them to have one parameter, `self`. The instances we create later will have access
    to these methods. In other words, they’ll be able to sit and roll over. For now,
    `sit()` and `roll_over()` don’t do much. They simply print a message saying the
    dog is sitting or rolling over. But the concept can be extended to realistic situations:
    if this class were part of a computer game, these methods would contain code to
    make an animated dog sit and roll over. If this class was written to control a
    robot, these methods would direct movements that cause a robotic dog to sit and
    roll over.'
  prefs: []
  type: TYPE_NORMAL
- en: Making an Instance from a Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Think of a class as a set of instructions for how to make an instance. The `Dog`
    class is a set of instructions that tells Python how to make individual instances
    representing specific dogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make an instance representing a specific dog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Dog` class we’re using here is the one we just wrote in the previous example.
    Here, we tell Python to create a dog whose name is `'Willie'` and whose age is
    `6` ❶. When Python reads this line, it calls the `__init__()` method in `Dog`
    with the arguments `'Willie'` and `6`. The `__init__()` method creates an instance
    representing this particular dog and sets the `name` and `age` attributes using
    the values we provided. Python then returns an instance representing this dog.
    We assign that instance to the variable `my_dog`. The naming convention is helpful
    here; we can usually assume that a capitalized name like `Dog` refers to a class,
    and a lowercase name like `my_dog` refers to a single instance created from a
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Attributes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To access the attributes of an instance, you use dot notation. We access the
    value of `my_dog`’s attribute `name` ❷ by writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Dot notation is used often in Python. This syntax demonstrates how Python finds
    an attribute’s value. Here, Python looks at the instance `my_dog` and then finds
    the attribute `name` associated with `my_dog`. This is the same attribute referred
    to as `self.name` in the class `Dog`. We use the same approach to work with the
    attribute `age` ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is a summary of what we know about `my_dog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Calling Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After we create an instance from the class `Dog`, we can use dot notation to
    call any method defined in `Dog`. Let’s make our dog sit and roll over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To call a method, give the name of the instance (in this case, `my_dog`) and
    the method you want to call, separated by a dot. When Python reads `my_dog.sit()`,
    it looks for the method `sit()` in the class `Dog` and runs that code. Python
    interprets the line `my_dog.roll_over()` in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now Willie does what we tell him to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This syntax is quite useful. When attributes and methods have been given appropriately
    descriptive names like `name`, `age`, `sit()`, and `roll_over()`, we can easily
    infer what a block of code, even one we’ve never seen before, is supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Multiple Instances
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can create as many instances from a class as you need. Let’s create a second
    dog called `your_dog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example we create a dog named Willie and a dog named Lucy. Each dog
    is a separate instance with its own set of attributes, capable of the same set
    of actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Even if we used the same name and age for the second dog, Python would still
    create a separate instance from the `Dog` class. You can make as many instances
    from one class as you need, as long as you give each instance a unique variable
    name or it occupies a unique spot in a list or dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Classes and Instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use classes to represent many real-world situations. Once you write
    a class, you’ll spend most of your time working with instances created from that
    class. One of the first tasks you’ll want to do is modify the attributes associated
    with a particular instance. You can modify the attributes of an instance directly
    or write methods that update attributes in specific ways.
  prefs: []
  type: TYPE_NORMAL
- en: The Car Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a new class representing a car. Our class will store information
    about the kind of car we’re working with, and it will have a method that summarizes
    this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**car.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Car` class, we define the `__init__()` method with the `self` parameter
    first ❶, just like we did with the `Dog` class. We also give it three other parameters:
    `make`, `model`, and `year`. The `__init__()` method takes in these parameters
    and assigns them to the attributes that will be associated with instances made
    from this class. When we make a new `Car` instance, we’ll need to specify a make,
    model, and year for our instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a method called `get_descriptive_name()` ❷ that puts a car’s `year`,
    `make`, and `model` into one string neatly describing the car. This will spare
    us from having to print each attribute’s value individually. To work with the
    attribute values in this method, we use `self.make`, `self.model`, and `self.year`.
    Outside of the class, we make an instance from the `Car` class and assign it to
    the variable `my_new_car` ❸. Then we call `get_descriptive_name()` to show what
    kind of car we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To make the class more interesting, let’s add an attribute that changes over
    time. We’ll add an attribute that stores the car’s overall mileage.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a Default Value for an Attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an instance is created, attributes can be defined without being passed
    in as parameters. These attributes can be defined in the `__init__()` method,
    where they are assigned a default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add an attribute called `odometer_reading` that always starts with a
    value of 0\. We’ll also add a method `read_odometer()` that helps us read each
    car’s odometer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This time, when Python calls the `__init__()` method to create a new instance,
    it stores the make, model, and year values as attributes, like it did in the previous
    example. Then Python creates a new attribute called `odometer_reading` and sets
    its initial value to 0 ❶. We also have a new method called `read_odometer()` ❷
    that makes it easy to read a car’s mileage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our car starts with a mileage of 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Not many cars are sold with exactly 0 miles on the odometer, so we need a way
    to change the value of this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Attribute Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can change an attribute’s value in three ways: you can change the value
    directly through an instance, set the value through a method, or increment the
    value (add a certain amount to it) through a method. Let’s look at each of these
    approaches.'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying an Attribute’s Value Directly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The simplest way to modify the value of an attribute is to access the attribute
    directly through an instance. Here we set the odometer reading to 23 directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We use dot notation to access the car’s `odometer_reading` attribute, and set
    its value directly. This line tells Python to take the instance `my_new_car`,
    find the attribute `odometer_reading` associated with it, and set the value of
    that attribute to 23:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes you’ll want to access attributes directly like this, but other times
    you’ll want to write a method that updates the value for you.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying an Attribute’s Value Through a Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It can be helpful to have methods that update certain attributes for you. Instead
    of accessing the attribute directly, you pass the new value to a method that handles
    the updating internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example showing a method called `update_odometer()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The only modification to `Car` is the addition of `update_odometer()`. This
    method takes in a mileage value and assigns it to `self.odometer_reading`. Using
    the `my_new_car` instance, we call `update_odometer()` with `23` as an argument
    ❶. This sets the odometer reading to 23, and `read_odometer()` prints the reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extend the method `update_odometer()` to do additional work every time
    the odometer reading is modified. Let’s add a little logic to make sure no one
    tries to roll back the odometer reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now `update_odometer()` checks that the new reading makes sense before modifying
    the attribute. If the value provided for `mileage` is greater than or equal to
    the existing mileage, `self.odometer_reading`, you can update the odometer reading
    to the new mileage ❶. If the new mileage is less than the existing mileage, you’ll
    get a warning that you can’t roll back an odometer ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Incrementing an Attribute’s Value Through a Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes you’ll want to increment an attribute’s value by a certain amount,
    rather than set an entirely new value. Say we buy a used car and put 100 miles
    on it between the time we buy it and the time we register it. Here’s a method
    that allows us to pass this incremental amount and add that value to the odometer
    reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The new method `increment_odometer()` takes in a number of miles, and adds
    this value to `self.odometer_reading`. First, we create a used car, `my_used_car`
    ❶. We set its odometer to 23,500 by calling `update_odometer()` and passing it
    `23_500` ❷. Finally, we call `increment_odometer()` and pass it `100` to add the
    100 miles that we drove between buying the car and registering it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can modify this method to reject negative increments so no one uses this
    function to roll back an odometer as well.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don’t always have to start from scratch when writing a class. If the class
    you’re writing is a specialized version of another class you wrote, you can use
    *inheritance*. When one class *inherits* from another, it takes on the attributes
    and methods of the first class. The original class is called the *parent class*,
    and the new class is the *child class*. The child class can inherit any or all
    of the attributes and methods of its parent class, but it’s also free to define
    new attributes and methods of its own.
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() Method for a Child Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you’re writing a new class based on an existing class, you’ll often want
    to call the `__init__()` method from the parent class. This will initialize any
    attributes that were defined in the parent `__init__()` method and make them available
    in the child class.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s model an electric car. An electric car is just a specific
    kind of car, so we can base our new `ElectricCar` class on the `Car` class we
    wrote earlier. Then we’ll only have to write code for the attributes and behaviors
    specific to electric cars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by making a simple version of the `ElectricCar` class, which does
    everything the `Car` class does:'
  prefs: []
  type: TYPE_NORMAL
- en: '**electric_car.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We start with `Car` ❶. When you create a child class, the parent class must
    be part of the current file and must appear before the child class in the file.
    We then define the child class, `ElectricCar` ❷. The name of the parent class
    must be included in parentheses in the definition of a child class. The `__init__()`
    method takes in the information required to make a `Car` instance ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The `super()` function ❹ is a special function that allows you to call a method
    from the parent class. This line tells Python to call the `__init__()` method
    from `Car`, which gives an `ElectricCar` instance all the attributes defined in
    that method. The name *super* comes from a convention of calling the parent class
    a *superclass* and the child class a *subclass*.
  prefs: []
  type: TYPE_NORMAL
- en: We test whether inheritance is working properly by trying to create an electric
    car with the same kind of information we’d provide when making a regular car.
    We make an instance of the `ElectricCar` class and assign it to `my_leaf` ❺. This
    line calls the `__init__()` method defined in `ElectricCar`, which in turn tells
    Python to call the `__init__()` method defined in the parent class `Car`. We provide
    the arguments `'nissan'`, `'leaf'`, and `2024`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from `__init__()`, there are no attributes or methods yet that are particular
    to an electric car. At this point we’re just making sure the electric car has
    the appropriate `Car` behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `ElectricCar` instance works just like an instance of `Car`, so now we can
    begin defining attributes and methods specific to electric cars.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Attributes and Methods for the Child Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have a child class that inherits from a parent class, you can add any
    new attributes and methods necessary to differentiate the child class from the
    parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add an attribute that’s specific to electric cars (a battery, for example)
    and a method to report on this attribute. We’ll store the battery size and write
    a method that prints a description of the battery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a new attribute `self.battery_size` and set its initial value to `40`
    ❶. This attribute will be associated with all instances created from the `ElectricCar`
    class but won’t be associated with any instances of `Car`. We also add a method
    called `describe_battery()` that prints information about the battery ❷. When
    we call this method, we get a description that is clearly specific to an electric
    car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There’s no limit to how much you can specialize the `ElectricCar` class. You
    can add as many attributes and methods as you need to model an electric car to
    whatever degree of accuracy you need. An attribute or method that could belong
    to any car, rather than one that’s specific to an electric car, should be added
    to the `Car` class instead of the `ElectricCar` class. Then anyone who uses the
    `Car` class will have that functionality available as well, and the `ElectricCar`
    class will only contain code for the information and behavior specific to electric
    vehicles.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding Methods from the Parent Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can override any method from the parent class that doesn’t fit what you’re
    trying to model with the child class. To do this, you define a method in the child
    class with the same name as the method you want to override in the parent class.
    Python will disregard the parent class method and only pay attention to the method
    you define in the child class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say the class `Car` had a method called `fill_gas_tank()`. This method is meaningless
    for an all-electric vehicle, so you might want to override this method. Here’s
    one way to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now if someone tries to call `fill_gas_tank()` with an electric car, Python
    will ignore the method `fill_gas_tank()` in `Car` and run this code instead. When
    you use inheritance, you can make your child classes retain what you need and
    override anything you don’t need from the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Instances as Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When modeling something from the real world in code, you may find that you’re
    adding more and more detail to a class. You’ll find that you have a growing list
    of attributes and methods and that your files are becoming lengthy. In these situations,
    you might recognize that part of one class can be written as a separate class.
    You can break your large class into smaller classes that work together; this approach
    is called *composition*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we continue adding detail to the `ElectricCar` class, we might
    notice that we’re adding many attributes and methods specific to the car’s battery.
    When we see this happening, we can stop and move those attributes and methods
    to a separate class called `Battery`. Then we can use a `Battery` instance as
    an attribute in the `ElectricCar` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We define a new class called `Battery` that doesn’t inherit from any other class.
    The `__init__()` method ❶ has one parameter, `battery_size`, in addition to `self`.
    This is an optional parameter that sets the battery’s size to 40 if no value is
    provided. The method `describe_battery()` has been moved to this class as well
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ElectricCar` class, we now add an attribute called `self.battery` ❸.
    This line tells Python to create a new instance of `Battery` (with a default size
    of 40, because we’re not specifying a value) and assign that instance to the attribute
    `self.battery`. This will happen every time the `__init__()` method is called;
    any `ElectricCar` instance will now have a `Battery` instance created automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create an electric car and assign it to the variable `my_leaf`. When we
    want to describe the battery, we need to work through the car’s `battery` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This line tells Python to look at the instance `my_leaf`, find its `battery`
    attribute, and call the method `describe_battery()` that’s associated with the
    `Battery` instance assigned to the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is identical to what we saw previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks like a lot of extra work, but now we can describe the battery in
    as much detail as we want without cluttering the `ElectricCar` class. Let’s add
    another method to `Battery` that reports the range of the car based on the battery
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The new method `get_range()` performs some simple analysis. If the battery’s
    capacity is 40 kWh, `get_range()` sets the range to 150 miles, and if the capacity
    is 65 kWh, it sets the range to 225 miles. It then reports this value. When we
    want to use this method, we again have to call it through the car’s `battery`
    attribute ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output tells us the range of the car based on its battery size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Modeling Real-World Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you begin to model more complicated things like electric cars, you’ll wrestle
    with interesting questions. Is the range of an electric car a property of the
    battery or of the car? If we’re only describing one car, it’s probably fine to
    maintain the association of the method `get_range()` with the `Battery` class.
    But if we’re describing a manufacturer’s entire line of cars, we probably want
    to move `get_range()` to the `ElectricCar` class. The `get_range()` method would
    still check the battery size before determining the range, but it would report
    a range specific to the kind of car it’s associated with. Alternatively, we could
    maintain the association of the `get_range()` method with the battery but pass
    it a parameter such as `car_model`. The `get_range()` method would then report
    a range based on the battery size and car model.
  prefs: []
  type: TYPE_NORMAL
- en: This brings you to an interesting point in your growth as a programmer. When
    you wrestle with questions like these, you’re thinking at a higher logical level
    rather than a syntax-focused level. You’re thinking not about Python, but about
    how to represent the real world in code. When you reach this point, you’ll realize
    there are often no right or wrong approaches to modeling real-world situations.
    Some approaches are more efficient than others, but it takes practice to find
    the most efficient representations. If your code is working as you want it to,
    you’re doing well! Don’t be discouraged if you find you’re ripping apart your
    classes and rewriting them several times using different approaches. In the quest
    to write accurate, efficient code, everyone goes through this process.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you add more functionality to your classes, your files can get long, even
    when you use inheritance and composition properly. In keeping with the overall
    philosophy of Python, you’ll want to keep your files as uncluttered as possible.
    To help, Python lets you store classes in modules and then import the classes
    you need into your main program.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a Single Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create a module containing just the `Car` class. This brings up a subtle
    naming issue: we already have a file named *car.py* in this chapter, but this
    module should be named *car.py* because it contains code representing a car. We’ll
    resolve this naming issue by storing the `Car` class in a module named *car.py*,
    replacing the *car.py* file we were previously using. From now on, any program
    that uses this module will need a more specific filename, such as *my_car.py*.
    Here’s *car.py* with just the code from the class `Car`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**car.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We include a module-level docstring that briefly describes the contents of this
    module ❶. You should write a docstring for each module you create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we make a separate file called *my_car.py*. This file will import the `Car`
    class and then create an instance from that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**my_car.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `import` statement ❶ tells Python to open the `car` module and import the
    class `Car`. Now we can use the `Car` class as if it were defined in this file.
    The output is the same as we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Importing classes is an effective way to program. Picture how long this program
    file would be if the entire `Car` class were included. When you instead move the
    class to a module and import the module, you still get all the same functionality,
    but you keep your main program file clean and easy to read. You also store most
    of the logic in separate files; once your classes work as you want them to, you
    can leave those files alone and focus on the higher-level logic of your main program.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Multiple Classes in a Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can store as many classes as you need in a single module, although each
    class in a module should be related somehow. The classes `Battery` and `ElectricCar`
    both help represent cars, so let’s add them to the module *car.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '**car.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can make a new file called *my_electric_car.py*, import the `ElectricCar`
    class, and make an electric car:'
  prefs: []
  type: TYPE_NORMAL
- en: '**my_electric_car.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the same output we saw earlier, even though most of the logic is hidden
    away in a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Importing Multiple Classes from a Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can import as many classes as you need into a program file. If we want
    to make a regular car and an electric car in the same file, we need to import
    both classes, `Car` and `ElectricCar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**my_cars.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You import multiple classes from a module by separating each class with a comma
    ❶. Once you’ve imported the necessary classes, you’re free to make as many instances
    of each class as you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example we make a gas-powered Ford Mustang ❷ and then an electric Nissan
    Leaf ❸:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Importing an Entire Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also import an entire module and then access the classes you need using
    dot notation. This approach is simple and results in code that is easy to read.
    Because every call that creates an instance of a class includes the module name,
    you won’t have naming conflicts with any names used in the current file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what it looks like to import the entire `car` module and then create
    a regular car and an electric car:'
  prefs: []
  type: TYPE_NORMAL
- en: '**my_cars.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: First we import the entire `car` module ❶. We then access the classes we need
    through the `module_name`.`ClassName` syntax. We again create a Ford Mustang ❷,
    and a Nissan Leaf ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Importing All Classes from a Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can import every class from a module using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This method is not recommended for two reasons. First, it’s helpful to be able
    to read the `import` statements at the top of a file and get a clear sense of
    which classes a program uses. With this approach it’s unclear which classes you’re
    using from the module. This approach can also lead to confusion with names in
    the file. If you accidentally import a class with the same name as something else
    in your program file, you can create errors that are hard to diagnose. I show
    this here because even though it’s not a recommended approach, you’re likely to
    see it in other people’s code at some point.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to import many classes from a module, you’re better off importing
    the entire module and using the `module_name.ClassName` syntax. You won’t see
    all the classes used at the top of the file, but you’ll see clearly where the
    module is used in the program. You’ll also avoid the potential naming conflicts
    that can arise when you import every class in a module.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a Module into a Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you’ll want to spread out your classes over several modules to keep
    any one file from growing too large and avoid storing unrelated classes in the
    same module. When you store your classes in several modules, you may find that
    a class in one module depends on a class in another module. When this happens,
    you can import the required class into the first module.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s store the `Car` class in one module and the `ElectricCar`
    and `Battery` classes in a separate module. We’ll make a new module called *electric_car.py*—replacing
    the *electric_car.py* file we created earlier—and copy just the `Battery` and
    `ElectricCar` classes into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**electric_car.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The class `ElectricCar` needs access to its parent class `Car`, so we import
    `Car` directly into the module. If we forget this line, Python will raise an error
    when we try to import the `electric_car` module. We also need to update the `Car`
    module so it contains only the `Car` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**car.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can import from each module separately and create whatever kind of car
    we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**my_cars.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We import `Car` from its module, and `ElectricCar` from its module. We then
    create one regular car and one electric car. Both cars are created correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using Aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you saw in Chapter 8, aliases can be quite helpful when using modules to
    organize your projects’ code. You can use aliases when importing classes as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider a program where you want to make a bunch of electric
    cars. It might get tedious to type (and read) `ElectricCar` over and over again.
    You can give `ElectricCar` an alias in the import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use this alias whenever you want to make an electric car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also give a module an alias. Here’s how to import the entire `electric_car`
    module using an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use this module alias with the full class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Finding Your Own Workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, Python gives you many options for how to structure code in a
    large project. It’s important to know all these possibilities so you can determine
    the best ways to organize your projects as well as understand other people’s projects.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re starting out, keep your code structure simple. Try doing everything
    in one file and moving your classes to separate modules once everything is working.
    If you like how modules and files interact, try storing your classes in modules
    when you start a project. Find an approach that lets you write code that works,
    and go from there.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Standard Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Python standard library* is a set of modules included with every Python
    installation. Now that you have a basic understanding of how functions and classes
    work, you can start to use modules like these that other programmers have written.
    You can use any function or class in the standard library by including a simple
    `import` statement at the top of your file. Let’s look at one module, `random`,
    which can be useful in modeling many real-world situations.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting function from the random module is `randint()`. This function
    takes two integer arguments and returns a randomly selected integer between (and
    including) those numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to generate a random number between 1 and 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful function is `choice()`. This function takes in a list or tuple
    and returns a randomly chosen element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `random` module shouldn’t be used when building security-related applications,
    but it works well for many fun and interesting projects.
  prefs: []
  type: TYPE_NORMAL
- en: Styling Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A few styling issues related to classes are worth clarifying, especially as
    your programs become more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Class names should be written in *CamelCase*. To do this, capitalize the first
    letter of each word in the name, and don’t use underscores. Instance and module
    names should be written in lowercase, with underscores between words.
  prefs: []
  type: TYPE_NORMAL
- en: Every class should have a docstring immediately following the class definition.
    The docstring should be a brief description of what the class does, and you should
    follow the same formatting conventions you used for writing docstrings in functions.
    Each module should also have a docstring describing what the classes in a module
    can be used for.
  prefs: []
  type: TYPE_NORMAL
- en: You can use blank lines to organize code, but don’t use them excessively. Within
    a class you can use one blank line between methods, and within a module you can
    use two blank lines to separate classes.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to import a module from the standard library and a module that you
    wrote, place the import statement for the standard library module first. Then
    add a blank line and the import statement for the module you wrote. In programs
    with multiple import statements, this convention makes it easier to see where
    the different modules used in the program come from.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to write your own classes. You learned how
    to store information in a class using attributes and how to write methods that
    give your classes the behavior they need. You learned to write `__init__()` methods
    that create instances from your classes with exactly the attributes you want.
    You saw how to modify the attributes of an instance directly and through methods.
    You learned that inheritance can simplify the creation of classes that are related
    to each other, and you learned to use instances of one class as attributes in
    another class to keep each class simple.
  prefs: []
  type: TYPE_NORMAL
- en: You saw how storing classes in modules and importing classes you need into the
    files where they’ll be used can keep your projects organized. You started learning
    about the Python standard library, and you saw an example based on the `random`
    module. Finally, you learned to style your classes using Python conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 10, you’ll learn to work with files so you can save the work you’ve
    done in a program and the work you’ve allowed users to do. You’ll also learn about
    *exceptions*, a special Python class designed to help you respond to errors when
    they arise.
  prefs: []
  type: TYPE_NORMAL
