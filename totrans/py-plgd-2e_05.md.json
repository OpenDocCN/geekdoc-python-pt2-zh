["```py\n>>> `import numpy as np`\n>>> `import matplotlib.pyplot as plt`\n❶ >>> `x = np.array([[0, 0, 255], [255, 255, 0], [0, 255, 0]])`\n❷ >>> `plt.imshow(x, interpolation='nearest')`\n>>> `plt.show()`\n\n```", "```py\n>>> `np.random.choice([0, 255], 4*4, p=[0.1, 0.9]).reshape(4, 4)`\n\n```", "```py\narray([[255, 255, 255, 255],\n       [255, 255, 255, 255],\n       [255, 255, 255, 255],\n       [255, 255, 255, 0]])\n\n```", "```py\ngrid = np.zeros(N*N).reshape(N, N)\n\n```", "```py\ndef addGlider(i, j, grid):\n    \"\"\"adds a glider with top left cell at (i, j)\"\"\"\n  ❶ glider = np.array([[0, 0, 255],\n                       [255, 0, 255],\n                       [0, 255, 255]])\n  ❷ grid[i:i+3, j:j+3] = glider\n\n```", "```py\naddGlider(1, 1, grid)\n\n```", "```py\nif j == N-1:\n    right = grid[i, 0]\nelse:\n    right = grid[i, j+1]\n\n```", "```py\n>>> `N = 16`\n>>> `i1 = 14`\n>>> `i2 = 15`\n>>> `(i1+1)%N`\n15\n>>> `(i2+1)%N`\n0\n\n```", "```py\nright = grid[i, (j+1)%N]\n\n```", "```py\nbottom = grid[(i+1)%N, j]\n\n```", "```py\ntotal = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +\n             grid[(i-1)%N, j] + grid[(i+1)%N, j] +\n             grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +\n             grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)\n\n```", "```py\n# apply Conway's rules\nif grid[i, j] == ON:\n  ❶ if (total < 2) or (total > 3):\n        newGrid[i, j] = OFF\nelse:\n  ❷ if total == 3:\n        newGrid[i, j] = ON\n\n```", "```py\ndef main():\n    # command line arguments are in sys.argv[1], sys.argv[2], ...\n    # sys.argv[0] is the script name and can be ignored\n    # parse arguments\n  ❶ parser = argparse.ArgumentParser(description=\"Runs Conway's Game of Life\n                                     simulation.\")\n    # add arguments\n  ❷ parser.add_argument('--grid-size', dest='N', required=False)\n  ❸ parser.add_argument('--interval', dest='interval', required=False)\n  ❹ parser.add_argument('--glider', action='store_true', required=False)\n    args = parser.parse_args()\n\n```", "```py\n    # set grid size\n  ❶ N = 100\n    # set animation update interval\n  ❷ updateInterval = 50\n    if args.interval:\n        updateInterval = int(args.interval)\n    # declare grid\n    grid = np.array([])\n    # check if \"glider\" demo flag is specified\n  ❸ if args.glider:\n        grid = np.zeros(N*N).reshape(N, N)\n        addGlider(1, 1, grid)\n  ❹ else:\n        # set N if specified and valid\n        if args.N and int(args.N) > 8:\n            N = int(args.N)\n        # populate grid with random on/off - more off than on\n        grid = randomGrid(N)\n\n```", "```py\n    # set up the animation\n  ❶ fig, ax = plt.subplots()\n    img = ax.imshow(grid, interpolation='nearest')\n  ❷ ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N, ),\n                                  interval=updateInterval,\n                                  save_count=50)\n    plt.show()\n\n```", "```py\n$ `python conway.py`\n\n```", "```py\n$ `python conway.py --grid-size 32 --interval 500 --glider`\n\n```", "```py\n    8\n    0 0 0 255...\n\n    ```", "```py\n\"\"\"\nconway.py\nA simple Python/matplotlib implementation of Conway's Game of Life.\nAuthor: Mahesh Venkitachalam\n\"\"\"\nimport sys, argparse\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\ndef randomGrid(N):\n    \"\"\"returns a grid of NxN random values\"\"\"\n    return np.random.choice([255, 0], N*N, p=[0.2, 0.8]).reshape(N, N)\ndef addGlider(i, j, grid):\n    \"\"\"adds a glider with top left cell at (i, j)\"\"\"\n    glider = np.array([[0,    0, 255],\n                       [255,  0, 255],\n                       [0,  255, 255]])\n    grid[i:i+3, j:j+3] = glider\ndef update(frameNum, img, grid, N):\n    # copy grid since we require 8 neighbors for calculation\n    # and we go line by line\n    newGrid = grid.copy()\n    for i in range(N):\n        for j in range(N):\n            # compute 8-neighbor sum\n            # using toroidal boundary conditions - x and y wrap around\n            # so that the simulation takes place on a toroidal surface\n            total = int((grid[i, (j-1)%N] + grid[i, (j+1)%N] +\n                         grid[(i-1)%N, j] + grid[(i+1)%N, j] +\n                         grid[(i-1)%N, (j-1)%N] + grid[(i-1)%N, (j+1)%N] +\n                         grid[(i+1)%N, (j-1)%N] + grid[(i+1)%N, (j+1)%N])/255)\n            # apply Conway's rules\n            if grid[i, j]  == 255:\n                if (total < 2) or (total > 3):\n                    newGrid[i, j] = 0\n            else:\n                if total == 3:\n                    newGrid[i, j] = 255\n    # update data\n    img.set_data(newGrid)\n    grid[:] = newGrid[:]\n    # need to return a tuple here, since this callback\n    # function needs to return an iterable\n    return img,\n# main() function\ndef main():\n    # command line args are in sys.argv[1], sys.argv[2]...\n    # sys.argv[0] is the script name itself and can be ignored\n    # parse arguments\n    parser = argparse.ArgumentParser(description=\"Runs Conway's Game of Life\n                                     simulation.\")\n    # add arguments\n    parser.add_argument('--grid-size', dest='N', required=False)\n    parser.add_argument('--interval', dest='interval', required=False)\n    parser.add_argument('--glider', action='store_true', required=False)\n    parser.add_argument('--gosper', action='store_true', required=False)\n    args = parser.parse_args()\n    # set grid size\n    N = 100\n    # set animation update interval\n    updateInterval = 50\n    if args.interval:\n        updateInterval = int(args.interval)\n    # declare grid\n    grid = np.array([])\n    # check if \"glider\" demo flag is specified\n    if args.glider:\n        grid = np.zeros(N*N).reshape(N, N)\n        addGlider(1, 1, grid)\n    elif args.gosper:\n        grid = np.zeros(N*N).reshape(N, N)\n        addGosperGliderGun(10, 10, grid)\n    else:\n        # set N if specified and valid\n        if args.N and int(args.N) > 8:\n            N = int(args.N)\n        # populate grid with random on/off - more off than on\n        grid = randomGrid(N)\n    # set up animation\n    fig, ax = plt.subplots()\n    img = ax.imshow(grid, interpolation='nearest')\n    ani = animation.FuncAnimation(fig, update, fargs=(img, grid, N, ),\n                                  frames = 10,\n                                  interval=updateInterval)\n    plt.show()\n# call main\nif __name__ == '__main__':\n    main()\n\n```"]