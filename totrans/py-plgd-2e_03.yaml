- en: '[2](nsp-venkitachalam503045-0008.xhtml#rch02)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spirographs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can use a Spirograph toy (shown in [Figure 2-1](nsp-venkitachalam503045-0013.xhtml#fig2-1))
    to draw mathematical curves. The toy consists of two different-sized rings with
    plastic gear teeth, one large and one small. The small one has several holes.
    You put a pen or pencil through one of the holes and then rotate the smaller wheel
    inside the larger one (which has gear teeth on its inside), keeping the wheels
    in contact with each other, to draw an endless number of complex and wonderfully
    symmetric patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll use Python to create an animation of Spirograph-like
    curves. The program will use parametric equations to describe the motion of a
    Spirograph’s rings and draw the curves (which I call *spiros*). You’ll save the
    completed drawings as PNG image files. Either the program will draw random spiros
    or you can use command line options to draw a spiro with specific parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f02001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: A Spirograph toy'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you’ll learn how to draw spiros on your computer. You’ll also
    learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Use parametric equations to generate curves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Draw a curve as a series of straight lines using the `turtle` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Use a timer to animate graphics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Save graphics to image files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A word of caution: I’ve chosen to use the `turtle` module to draw spiros mainly
    for illustrative purposes and because it’s fun, but `turtle` is slow and not ideal
    for creating graphics when performance is critical. (What do you expect from turtles?)
    If you want to draw something quickly, there are better ways to do so, and you’ll
    explore some of these options in upcoming projects.'
  prefs: []
  type: TYPE_NORMAL
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0401)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project hinges around using *parametric equations*, equations that express
    the coordinates of the points on a curve as functions of one or more variables,
    called *parameters*. You’ll plug values for the parameters into equations to calculate
    points that form a spiro pattern. Then you’ll feed those points to the `turtle`
    module to draw the curves.
  prefs: []
  type: TYPE_NORMAL
- en: '[Understanding Parametric Equations](nsp-venkitachalam503045-0008.xhtml#rbh0401)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To understand how parametric equations work, we’ll begin with a simple example:
    a circle. Consider a circle with radius *r*, centered at the origin of a two-dimensional
    plane. That circle consists of all the points whose x- and y-coordinates satisfy
    the equation *x*² + *y*² = *r*². This isn’t a parametric equation, however. A
    parametric equation would give us all possible values of *x* and *y*, based on
    changes in some other variable (the parameter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* = *r* cos(θ)'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *r* sin(θ)'
  prefs: []
  type: TYPE_NORMAL
- en: Together, these equations are a *parametric* representation of our circle, where
    the parameter is θ, the angle of point (*x*, *y*) relative to the positive x-axis.
    Any value of (*x*, *y*) in these equations will satisfy the original *x*² + *y*²
    = *r*² equation. As you vary θ from 0 to 2π, the x- and y-coordinates generated
    by these equations will form the circle. [Figure 2-2](nsp-venkitachalam503045-0013.xhtml#fig2-2)
    shows this scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f02002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: Describing a circle with a parametric equation'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, these two equations apply to a circle centered at the origin of the
    coordinate system. You can put a circle at any point in the XY plane by translating
    the center of the circle from the point (0, 0) to the point (*a*, *b*). The more
    general parametric equations then become *x* = *a* + *r* cos(θ) and *y* = *b*
    + *r* sin(θ).
  prefs: []
  type: TYPE_NORMAL
- en: Developing parametric equations that model a Spirograph toy isn’t that much
    different from developing parametric equations for a circle, since at heart a
    Spirograph simply draws two interlocking circles. [Figure 2-3](nsp-venkitachalam503045-0013.xhtml#fig2-3)
    shows a mathematical model of Spirograph-like motion. The model has no gear teeth;
    they’re used in Spirograph toys only to prevent slippage, and in the ideal world
    of mathematical modeling, you don’t have to worry about anything slipping.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f02003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: A mathematical model of a Spirograph toy'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 2-3](nsp-venkitachalam503045-0013.xhtml#fig2-3), *C* is the center
    of the smaller circle, *P* is the pen’s tip, and *q* is the angle of *C* relative
    to the positive x-axis. The radius of the bigger circle is *R* and that of the
    smaller circle is *r*. You express the ratio of the radii as variable *k*, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m02001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Line segment ![](images/nsp-venkitachalam503045-m02002.jpg) tells you how far
    the pen tip is from the center of the smaller circle. You express the ratio of
    ![](images/nsp-venkitachalam503045-m02002.jpg) to the smaller circle’s radius
    *r* as the variable *l*, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m02003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now combine these variables into the following parametric equations
    that represent the x- and y-coordinates of point *P* (the pen) as the smaller
    circle rotates inside the larger one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m02004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](images/nsp-venkitachalam503045-m02005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'NOTE These curves are called *hypotrochoids*. Although the equations may look
    a bit scary, the derivation is pretty straightforward. See the Wikipedia page
    on Spirographs if you’d like to explore the math: [http://en.wikipedia.org/wiki/Spirograph](http://en.wikipedia.org/wiki/Spirograph).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-4](nsp-venkitachalam503045-0013.xhtml#fig2-4) shows an example curve
    drawn with these equations. For this curve, I set *R* to 220, *r* to 65, and *l*
    to 0.8\. By choosing different values for these three parameters and then incrementing
    angle θ, you can produce an endless variety of fascinating curves.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f02004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4: A sample curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only task left is to determine when to stop drawing, since Spirographs
    can require many revolutions of the smaller circle around the larger circle to
    form a complete pattern. You can calculate the *periodicity* of the Spirograph
    (how long before the Spirograph starts repeating itself) by looking at the ratio
    of the radii of the inner and outer circles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m02006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Reduce this fraction by dividing the numerator and denominator by the *greatest
    common divisor (**GCD)*. Then the numerator tells you how many periods the curve
    needs to complete itself. For example, in [Figure 2-4](nsp-venkitachalam503045-0013.xhtml#fig2-4),
    the GCD of (*r*, *R*) is 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m02007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This tells you that the curve will start repeating itself after 13 revolutions
    of the smaller circle around the larger circle. The 44 in the denominator tells
    you the number of times the smaller circle revolves around its own center, which
    gives you a hint as to the shape of the curve. If you count the petals (or lobes)
    in the drawing in [Figure 2-4](nsp-venkitachalam503045-0013.xhtml#fig2-4), you’ll
    see there are exactly 44!
  prefs: []
  type: TYPE_NORMAL
- en: Once you express the radii ratio in the reduced form *r*/*R*, the range for
    the parameter θ to draw the spiro is [0, 2π*r*]. This tells you when to stop drawing
    a particular spiro. In the case of [Figure 2-4](nsp-venkitachalam503045-0013.xhtml#fig2-4),
    you’d stop when θ reaches 26π (that is, 2π × 13). Without knowing the ending range
    of the angle, you’d end up looping around, repeating the curve unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: '[Drawing Curves with turtle Graphics](nsp-venkitachalam503045-0008.xhtml#rbh0402)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s `turtle` module doesn’t have a method for drawing curved lines. Instead,
    you’ll draw a spiro as a collection of straight lines between different points
    calculated with the parametric equations discussed in the previous section. As
    long as the change in angle θ from one point to the next is relatively small,
    the result will appear curved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, the following program draws a circle with `turtle`. It uses
    our basic parametric equations for a circle, *x* = *a* + *r* cos(θ) and *y* = *b* +
    *r* sin(θ), to calculate points along the circle, and it connects those points
    with straight lines. Technically, the program actually produces an *N*-sided polygon,
    but because the angle parameter will change in small increments, *N* will be very
    large, and the polygon will look like a circle. Enter the following code, save
    it as *drawcircle.py*, and run it in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: import turtle
  prefs: []
  type: TYPE_NORMAL
- en: draw the circle using turtle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def drawCircleTurtle(x, y, r):'
  prefs: []
  type: TYPE_NORMAL
- en: '# move to the start of circle'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.up()
  prefs: []
  type: TYPE_NORMAL
- en: ❶ turtle.setpos(x + r, y)
  prefs: []
  type: TYPE_NORMAL
- en: turtle.down()
  prefs: []
  type: TYPE_NORMAL
- en: '# draw the circle'
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for i in range(0, 365, 5):'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ a = math.radians(i)
  prefs: []
  type: TYPE_NORMAL
- en: ❹ turtle.setpos(x + r*math.cos(a), y + r*math.sin(a))
  prefs: []
  type: TYPE_NORMAL
- en: ❺ drawCircleTurtle(100, 100, 50)
  prefs: []
  type: TYPE_NORMAL
- en: turtle.mainloop()
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you define the `drawCircleTurtle()` function, whose parameters are the
    center of the circle to be drawn, (*x*, *y*), and the circle’s radius, *r*. The
    function starts by moving the turtle into position at the first point on the circle’s
    horizontal axis: (*x* + *r*, *y*) ❶. The calls to `up()` and `down()` prevent
    the turtle from drawing while it’s getting into position. Next, you start a loop
    using `range(0, 365, 5)`, which increments the variable `i` in steps of 5 from
    0 to 360 ❷. The `i` variable is the angle parameter you’ll pass into the parametric
    circle equations, but first you convert it from degrees to radians ❸. (Most computer
    programs require radians for angle-based calculations.)'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the next set of circle coordinates using the two parametric equations,
    and you set the turtle’s position accordingly ❹. This draws a straight line from
    the last turtle position to the newly calculated one. Since you’re changing the
    angle parameter by just 5 degrees at a time, the straight lines will create the
    appearance of a round circle.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your function, you call it to draw a circle ❺. Calling `turtle.mainloop()`
    keeps the `tkinter` window open so that you can admire your work. (`tkinter` is
    the default GUI library used by Python.)
  prefs: []
  type: TYPE_NORMAL
- en: You’re now ready to draw some spiros! You’ll use the same `turtle` approach
    illustrated earlier. All that has to change are the details of the parametric
    equations used to calculate the points.
  prefs: []
  type: TYPE_NORMAL
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0402)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll use the following to create your spiros:'
  prefs: []
  type: TYPE_NORMAL
- en: • The `turtle` module for drawing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • `Pillow`, a fork of the *Python Imaging Library (**PIL)*, to save the spiro
    images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0403)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First you’ll define a class `Spiro` to draw the curves. You can use this class
    either to draw a single curve with customizable parameters or as part of an animation
    that draws several random spiros concurrently. To coordinate the animation, you’ll
    define another class called `SpiroAnimator`. At the top level of the program,
    you’ll write a function to save your drawings as image files, and you’ll use the
    `main()` function to take in user input and set the drawing in motion.
  prefs: []
  type: TYPE_NORMAL
- en: To see the full project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0013.xhtml#ah0407)
    on [page 36](nsp-venkitachalam503045-0013.xhtml#p36). You can also download the
    code for this project from [https://github.com/mkvenkit/pp2e/blob/main/spirograph/spiro.py](https://github.com/mkvenkit/pp2e/blob/main/spirograph/spiro.py).
  prefs: []
  type: TYPE_NORMAL
- en: '[Drawing the Spiros](nsp-venkitachalam503045-0008.xhtml#rbh0403)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Spiro` class features methods for drawing an individual spiro pattern.
    Here’s the `Spiro` class’s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class Spiro:'
  prefs: []
  type: TYPE_NORMAL
- en: '# constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, xc, yc, col, R, r, l):'
  prefs: []
  type: TYPE_NORMAL
- en: '# create the turtle object'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ self.t = turtle.Turtle()
  prefs: []
  type: TYPE_NORMAL
- en: '# set the cursor shape'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.t.shape('turtle')
  prefs: []
  type: TYPE_NORMAL
- en: '# set the step in degrees'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.step = 5
  prefs: []
  type: TYPE_NORMAL
- en: '# set the drawing complete flag'
  prefs: []
  type: TYPE_NORMAL
- en: ❹ self.drawingComplete = False
  prefs: []
  type: TYPE_NORMAL
- en: '# set the parameters'
  prefs: []
  type: TYPE_NORMAL
- en: self.setparams(xc, yc, col, R, r, l)
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize the drawing'
  prefs: []
  type: TYPE_NORMAL
- en: self.restart()
  prefs: []
  type: TYPE_NORMAL
- en: The `Spiro` constructor creates a new `turtle` object ❶. This way, each individual
    `Spiro` object will have its own `turtle` object associated with it, meaning you
    can create multiple `Spiro` objects to draw a bunch of spiros simultaneously.
    You set the shape of the turtle cursor to a turtle ❷. (You’ll find other choices
    in the `turtle` documentation at [https://docs.python.org/3/library/turtle.xhtml](https://docs.python.org/3/library/turtle.xhtml).)
    You set the angle increment for the parametric drawing to 5 degrees ❸ and create
    a Boolean `drawingComplete` flag for indicating when the spiro is done ❹. This
    flag will be useful when multiple `Spiro` objects are drawing in tandem; it allows
    you to keep track of whether a particular spiro is complete. You finish the constructor
    by calling two setup methods, as discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: The Setup Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Spiro` class’s `setparams()` and `restart()` methods both help with some
    setup that needs to be done before a spiro pattern can be drawn. Let’s look at
    the `setparams()` method first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def setparams(self, xc, yc, col, R, r, l):'
  prefs: []
  type: TYPE_NORMAL
- en: '# the Spirograph parameters'
  prefs: []
  type: TYPE_NORMAL
- en: self.xc = xc
  prefs: []
  type: TYPE_NORMAL
- en: self.yc = yc
  prefs: []
  type: TYPE_NORMAL
- en: self.R = int(R)
  prefs: []
  type: TYPE_NORMAL
- en: self.r = int(r)
  prefs: []
  type: TYPE_NORMAL
- en: self.l = l
  prefs: []
  type: TYPE_NORMAL
- en: self.col = col
  prefs: []
  type: TYPE_NORMAL
- en: '# reduce r/R to its smallest form by dividing with the GCD'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ gcdVal = math.gcd(self.r, self.R)
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.nRot = self.r//gcdVal
  prefs: []
  type: TYPE_NORMAL
- en: '# get ratio of radii'
  prefs: []
  type: TYPE_NORMAL
- en: self.k = r/float(R)
  prefs: []
  type: TYPE_NORMAL
- en: '# set the color'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.color(*col)
  prefs: []
  type: TYPE_NORMAL
- en: '# store the current angle'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.a = 0
  prefs: []
  type: TYPE_NORMAL
- en: First you store the coordinates of the center of the spiro (`xc` and `yc`).
    Then you convert the radius of each circle (`R` and `r`) to an integer and store
    the values. You also store `l`, which defines the position of the pen, and `col`,
    which determines the spiro’s color. Next, you use the `gcd()` method from Python’s
    built-in `math` module to compute the GCD of the radii ❶. You use this information
    to determine the periodicity of the curve, which you save as `self.nRot` ❷. Finally,
    you set the starting value of the angle parameter, `a`, to `0` ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `restart()` method continues with the setup by resetting the drawing parameters
    for the `Spiro` object and getting it into position to draw a spiro. This method
    makes it possible to reuse the same `Spiro` object to draw multiple spiros, one
    after the other, as part of the program’s animation. The program will call `restart()`
    each time the object is ready to draw a new spiro. Here’s the method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def restart(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# set the flag'
  prefs: []
  type: TYPE_NORMAL
- en: self.drawingComplete = False
  prefs: []
  type: TYPE_NORMAL
- en: '# show the turtle'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.showturtle()
  prefs: []
  type: TYPE_NORMAL
- en: '# go to the first point'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ self.t.up()
  prefs: []
  type: TYPE_NORMAL
- en: ❷ R, k, l = self.R, self.k, self.l
  prefs: []
  type: TYPE_NORMAL
- en: a = 0.0
  prefs: []
  type: TYPE_NORMAL
- en: ❸ x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: ❹ self.t.setpos(self.xc + x, self.yc + y)
  prefs: []
  type: TYPE_NORMAL
- en: ❺ self.t.down()
  prefs: []
  type: TYPE_NORMAL
- en: You reset the `drawingComplete` flag to `False`, indicating the object is ready
    to draw a new spiro. Then you show the turtle cursor, in case it was hidden. Next
    lift up the pen ❶ so you can move to the first position at ❹ without drawing a
    line. At ❷, you’re just using some local variables to keep the code compact. Then
    you feed those variables to the spiro parametric equations to compute the x- and
    y-coordinates of the curve’s starting point, using `0` as an initial value for
    angle `a` ❸. Finally, once the turtle is in place, you set the pen down so the
    turtle can start drawing the spiro ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The draw() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you use command line options to set the parameters of a spiro, the program
    will draw just that one spiro, using the `Spiro` class’s `draw()` method. This
    method draws the entire spiro all in one go, as a continuous sequence of straight-line
    segments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# draw the rest of the points'
  prefs: []
  type: TYPE_NORMAL
- en: R, k, l = self.R, self.k, self.l
  prefs: []
  type: TYPE_NORMAL
- en: '❶ for i in range(0, 360*self.nRot + 1, self.step):'
  prefs: []
  type: TYPE_NORMAL
- en: a = math.radians(i)
  prefs: []
  type: TYPE_NORMAL
- en: ❷ x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.t.setpos(self.xc + x, self.yc + y)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Exception, exiting.")
  prefs: []
  type: TYPE_NORMAL
- en: exit(0)
  prefs: []
  type: TYPE_NORMAL
- en: '# drawing is now done so hide the turtle cursor'
  prefs: []
  type: TYPE_NORMAL
- en: ❹ self.t.hideturtle()
  prefs: []
  type: TYPE_NORMAL
- en: Here you iterate through the complete range of the parameter `i`, which is expressed
    in degrees as 360 times `nRot` ❶. You use the parametric equations to compute
    the x- and y-coordinates for each value of the `i` parameter ❷, calling the turtle’s
    `setpos()` method ❸ to draw the line from one point to the next. This method is
    enclosed in a `try` block so that if an exception arises—such as the user closing
    the window in the middle of the drawing process—you can catch it and exit gracefully.
    Finally, you hide the cursor because you’ve finished drawing ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The update() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you don’t use any command line options, the program will draw multiple random
    spiros as an animation. This approach requires some restructuring of the drawing
    code we just looked at. Instead of drawing an entire spiro in one go, you need
    a method that draws just a single-line segment of the spiro. Then you’ll call
    that method at every time step in the animation. This `update()` method of the
    `Spiro` class fits the bill:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# skip the rest of the steps if done'
  prefs: []
  type: TYPE_NORMAL
- en: '❶ if self.drawingComplete:'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '# increment the angle'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.a += self.step
  prefs: []
  type: TYPE_NORMAL
- en: '# draw a step'
  prefs: []
  type: TYPE_NORMAL
- en: R, k, l = self.R, self.k, self.l
  prefs: []
  type: TYPE_NORMAL
- en: '# set the angle'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ a = math.radians(self.a)
  prefs: []
  type: TYPE_NORMAL
- en: x = self.R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: y = self.R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: ❹ self.t.setpos(self.xc + x, self.yc + y)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Exception, exiting.")
  prefs: []
  type: TYPE_NORMAL
- en: exit(0)
  prefs: []
  type: TYPE_NORMAL
- en: '# if drawing is complete, set the flag'
  prefs: []
  type: TYPE_NORMAL
- en: '❺ if self.a >= 360*self.nRot:'
  prefs: []
  type: TYPE_NORMAL
- en: self.drawingComplete = True
  prefs: []
  type: TYPE_NORMAL
- en: '# drawing is now done so hide the turtle cursor'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.hideturtle()
  prefs: []
  type: TYPE_NORMAL
- en: You first check to see whether the `drawingComplete` flag is set ❶; if not,
    you continue through the rest of the code. You increment the current angle ❷,
    calculate the (*x*, *y*) position corresponding to the current angle ❸, and move
    the turtle there, drawing the line segment in the process ❹. This is just like
    the code inside the `for()` loop in the `draw()` method, except it happens only
    once.
  prefs: []
  type: TYPE_NORMAL
- en: When I discussed the Spirograph parametric equations, I talked about the periodicity
    of the curve. A Spirograph starts repeating itself after a certain angle. You
    finish the `update()` function by checking whether the angle has reached the full
    range computed for this particular curve ❺. If so, you set the `drawingComplete`
    flag because the spiro is finished. Finally, you hide the turtle cursor so you
    can see your beautiful creation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Coordinating the Animation](nsp-venkitachalam503045-0008.xhtml#rbh0404)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SpiroAnimator` class will let you draw several random spiros simultaneously
    as an animation. This class coordinates the activity of multiple `Spiro` objects
    with randomly assigned parameters, using a timer to regularly call each `Spiro`
    object’s `update()` method. This technique updates the graphics periodically and
    lets the program process events such as button presses, mouse clicks, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the `SpiroAnimator` class’s constructor first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'class SpiroAnimator:'
  prefs: []
  type: TYPE_NORMAL
- en: '# constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, N):'
  prefs: []
  type: TYPE_NORMAL
- en: '# set the timer value in milliseconds'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ self.deltaT = 10
  prefs: []
  type: TYPE_NORMAL
- en: '# get the window dimensions'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.width = turtle.window_width()
  prefs: []
  type: TYPE_NORMAL
- en: self.height = turtle.window_height()
  prefs: []
  type: TYPE_NORMAL
- en: '# restarting'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.restarting = False
  prefs: []
  type: TYPE_NORMAL
- en: '# create the Spiro objects'
  prefs: []
  type: TYPE_NORMAL
- en: self.spiros = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(N):'
  prefs: []
  type: TYPE_NORMAL
- en: '# generate random parameters'
  prefs: []
  type: TYPE_NORMAL
- en: ❹ rparams = self.genRandomParams()
  prefs: []
  type: TYPE_NORMAL
- en: '# set the spiro parameters'
  prefs: []
  type: TYPE_NORMAL
- en: ❺ spiro = Spiro(*rparams)
  prefs: []
  type: TYPE_NORMAL
- en: self.spiros.append(spiro)
  prefs: []
  type: TYPE_NORMAL
- en: '# call timer'
  prefs: []
  type: TYPE_NORMAL
- en: ❻ turtle.ontimer(self.update, self.deltaT)
  prefs: []
  type: TYPE_NORMAL
- en: The `SpiroAnimator` constructor sets `deltaT` to `10`, which is the time interval
    in milliseconds you’ll use for the timer ❶. You then store the dimensions of the
    turtle window ❷ and initialize a flag that will be used to indicate that a restart
    is in progress ❸. In a loop that repeats *N* times (`N` is passed into `SpiroAnimator`
    in the constructor), you create new `Spiro` objects ❺ and add them to a `spiros`
    list. Before creating each `Spiro` object, you call the `genRandomParams()` helper
    method ❹ to randomly assign the spiro’s parameters (we’ll look at this method
    next). The `rparams` here is a tuple that you need to pass into the `Spiro` constructor.
    However, the constructor expects multiple arguments, so you use the Python `*`
    operator to unpack the tuple into a series of arguments. Finally, you set the
    `turtle.ontimer()` method to call `update()` after `deltaT` milliseconds ❻, which
    sets the animation in motion.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Random Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll use the `genRandomParams()` method to generate random parameters to
    send to each `Spiro` object as it’s created to produce a wide variety of curves.
    You’ll also call this method each time a `Spiro` object finishes drawing a spiro
    and is ready to start drawing a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def genRandomParams(self):'
  prefs: []
  type: TYPE_NORMAL
- en: width, height = self.width, self.height
  prefs: []
  type: TYPE_NORMAL
- en: R = random.randint(50, min(width, height)//2)
  prefs: []
  type: TYPE_NORMAL
- en: r = random.randint(10, 9*R//10)
  prefs: []
  type: TYPE_NORMAL
- en: l = random.uniform(0.1, 0.9)
  prefs: []
  type: TYPE_NORMAL
- en: xc = random.randint(-width//2, width//2)
  prefs: []
  type: TYPE_NORMAL
- en: yc = random.randint(-height//2, height//2)
  prefs: []
  type: TYPE_NORMAL
- en: col = (random.random(),
  prefs: []
  type: TYPE_NORMAL
- en: random.random(),
  prefs: []
  type: TYPE_NORMAL
- en: random.random())
  prefs: []
  type: TYPE_NORMAL
- en: ❶ return (xc, yc, col, R, r, l)
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate random numbers, you use three methods from Python’s `random` module:
    `randint()`, which returns random integers in the specified range; `uniform()`,
    which does the same for floating-point numbers; and `random()`, which returns
    a float between 0 and 1\. You set `R` to a random integer between 50 and the value
    of half the smallest dimension of your window, and you set `r` to between 10 percent
    and 90 percent of `R`. Then you set `l` to a random fraction between 0.1 and 0.9.'
  prefs: []
  type: TYPE_NORMAL
- en: You next select a random point on the screen to place the center of the spiro
    by selecting random x- and y-coordinates (`xc` and `yc`) from within the screen
    boundaries. You assign a random color `col` to the curve by setting random values
    for the red, green, and blue color components (these are defined on a scale from
    0 to 1). Finally, all of your calculated parameters are returned as a tuple ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Restarting the Animation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `SpiroAnimator` class has its own `restart()` method for restarting the
    animation to draw a new set of spiros:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def restart(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# ignore restart if already in the middle of restarting'
  prefs: []
  type: TYPE_NORMAL
- en: '❶ if self.restarting:'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: self.restarting = True
  prefs: []
  type: TYPE_NORMAL
- en: 'for spiro in self.spiros:'
  prefs: []
  type: TYPE_NORMAL
- en: '# clear'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.clear()
  prefs: []
  type: TYPE_NORMAL
- en: '# generate random parameters'
  prefs: []
  type: TYPE_NORMAL
- en: rparams = self.genRandomParams()
  prefs: []
  type: TYPE_NORMAL
- en: '# set the spiro parameters'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.setparams(*rparams)
  prefs: []
  type: TYPE_NORMAL
- en: '# restart drawing'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.restart()
  prefs: []
  type: TYPE_NORMAL
- en: '# done restarting'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.restarting = False
  prefs: []
  type: TYPE_NORMAL
- en: This method loops through all the `Spiro` objects. For each one, you clear the
    previous drawing and randomly generate a new set of spiro parameters. Then you
    use the `Spiro` object’s setup methods, `setparams()` and `restart()`, to assign
    the new parameters and get the object ready to draw the next spiro. The `self.restarting`
    flag ❶ prevents this method from being called before it’s had a chance to complete,
    which could happen if the user repeatedly hits the spacebar. The flag is reset
    at the end of the method so that the next restart won’t be ignored ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Animation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code shows the `update()` method in `SpiroAnimator`, which is
    called by the timer every 10 milliseconds to update all the `Spiro` objects used
    in the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# update all spiros'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ nComplete = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for spiro in self.spiros:'
  prefs: []
  type: TYPE_NORMAL
- en: '# update'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ spiro.update()
  prefs: []
  type: TYPE_NORMAL
- en: '# count completed spiros'
  prefs: []
  type: TYPE_NORMAL
- en: '❸ if spiro.drawingComplete:'
  prefs: []
  type: TYPE_NORMAL
- en: nComplete += 1
  prefs: []
  type: TYPE_NORMAL
- en: '# restart if all spiros are complete'
  prefs: []
  type: TYPE_NORMAL
- en: '❹ if nComplete == len(self.spiros):'
  prefs: []
  type: TYPE_NORMAL
- en: self.restart()
  prefs: []
  type: TYPE_NORMAL
- en: '# call the timer'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: ❺ turtle.ontimer(self.update, self.deltaT)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Exception, exiting.")
  prefs: []
  type: TYPE_NORMAL
- en: exit(0)
  prefs: []
  type: TYPE_NORMAL
- en: The `update()` method uses a counter `nComplete` to track the number of `Spiro`
    objects that have finished drawing ❶. The method loops through the list of `Spiro`
    objects and updates them ❷, which draws one more line segment in each spiro. You
    increment the counter if a `Spiro` is done ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Outside the loop, you check the counter to determine whether all the objects
    have finished drawing ❹. If so, you restart the animation with fresh spiros by
    calling the `restart()` method. The `update()` method ends with a call to the
    `turtle` module’s `ontimer()` method ❺, which calls `update()` again after `deltaT`
    milliseconds. This is what keeps the animation going.
  prefs: []
  type: TYPE_NORMAL
- en: Showing or Hiding the Cursor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You use the following method of the `SpiroAnimator` class to toggle the turtle
    cursors on and off. Turning them off makes the drawing go more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'def toggleTurtles(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for spiro in self.spiros:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if spiro.t.isvisible():'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.t.hideturtle()
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.t.showturtle()
  prefs: []
  type: TYPE_NORMAL
- en: This method uses built-in `turtle` methods to hide the cursor if it’s visible
    or to show the cursor if it isn’t. Later, you’ll see how this `toggleTurtles()`
    method is triggered by keypresses while the animation is running.
  prefs: []
  type: TYPE_NORMAL
- en: '[Saving the Curves](nsp-venkitachalam503045-0008.xhtml#rbh0405)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After all your hard work generating spiros, it would be nice to have a way
    to save the results. The stand-alone `saveDrawing()` function saves the contents
    of the drawing window as a PNG image file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def saveDrawing():'
  prefs: []
  type: TYPE_NORMAL
- en: '# hide the turtle cursor'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ turtle.hideturtle()
  prefs: []
  type: TYPE_NORMAL
- en: '# generate unique filenames'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ dateStr = (datetime.now()).strftime("%d%b%Y-%H%M%S")
  prefs: []
  type: TYPE_NORMAL
- en: fileName = 'spiro-' + dateStr
  prefs: []
  type: TYPE_NORMAL
- en: print('saving drawing to {}.eps/png'.format(fileName))
  prefs: []
  type: TYPE_NORMAL
- en: '# get the tkinter canvas'
  prefs: []
  type: TYPE_NORMAL
- en: canvas = turtle.getcanvas()
  prefs: []
  type: TYPE_NORMAL
- en: '# save the drawing as a postscript image'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ canvas.postscript(file = fileName + '.eps')
  prefs: []
  type: TYPE_NORMAL
- en: '# use the Pillow module to convert the postscript image file to PNG'
  prefs: []
  type: TYPE_NORMAL
- en: ❹ img = Image.open(fileName + '.eps')
  prefs: []
  type: TYPE_NORMAL
- en: ❺ img.save(fileName + '.png', 'png')
  prefs: []
  type: TYPE_NORMAL
- en: '# show the turtle cursor'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.showturtle()
  prefs: []
  type: TYPE_NORMAL
- en: You hide the turtle cursors so that you won’t see them in the final drawing
    ❶. Then you use `datetime()` to generate unique, timestamp-based names for the
    image files (in the *day-month-year-hour-minute-second* format) ❷. You append
    this string to *spiro-* to generate the filename.
  prefs: []
  type: TYPE_NORMAL
- en: The `turtle` program uses user interface (UI) windows created by `tkinter`,
    and you use the `canvas` object of `tkinter` to save the window in the Embedded
    PostScript (EPS) file format ❸. Because EPS is vector based, you can use it to
    print your images at high resolution, but the PNG format is more versatile, so
    you use `Pillow` to open the EPS file ❹ and save it as a PNG file ❺. Finally,
    you unhide the turtle cursors.
  prefs: []
  type: TYPE_NORMAL
- en: '[Parsing Command Line Arguments and Initialization](nsp-venkitachalam503045-0008.xhtml#rbh0406)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most projects in this book have command line arguments for customizing the
    code. Rather than trying to parse them by hand and creating a mess, delegate this
    mundane task to Python’s `argparse` module. That’s what you do in the first part
    of the spiro program’s `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ parser = argparse.ArgumentParser(description=descStr)
  prefs: []
  type: TYPE_NORMAL
- en: '# add expected arguments'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ parser.add_argument('--sparams', nargs=3, dest='sparams', required=False,
  prefs: []
  type: TYPE_NORMAL
- en: 'help="The three arguments in sparams: R, r, l.")'
  prefs: []
  type: TYPE_NORMAL
- en: '# parse args'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ args = parser.parse_args()
  prefs: []
  type: TYPE_NORMAL
- en: You create an `ArgumentParser` object to manage the command line arguments ❶.
    Then you add the `--sparams` argument to the parser ❷. It consists of three components,
    for the *R*, *r*, and *l* parameters of a spiro. You use the `dest` option to
    specify the variable name the values should be stored under once the arguments
    are parsed, and `required=False` means this argument is optional. You call the
    `parse_args()` method ❸ to actually parse the arguments. This makes the arguments
    available as properties of the `args` object. In this case, the values of the
    `--sparams` argument will be available through `args.sparams`.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE You’ll follow the same basic pattern described here throughout the book
    to create and parse each project’s command line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` function continues by setting up some `turtle` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '# set the width of the drawing window to 80 percent of the screen width'
  prefs: []
  type: TYPE_NORMAL
- en: ❶ turtle.setup(width=0.8)
  prefs: []
  type: TYPE_NORMAL
- en: '# set the cursor shape to turtle'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.shape('turtle')
  prefs: []
  type: TYPE_NORMAL
- en: '# set the title to Spirographs!'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.title("Spirographs!")
  prefs: []
  type: TYPE_NORMAL
- en: '# add the key handler to save our drawings'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ turtle.onkey(saveDrawing, "s")
  prefs: []
  type: TYPE_NORMAL
- en: '# start listening'
  prefs: []
  type: TYPE_NORMAL
- en: ❸ turtle.listen()
  prefs: []
  type: TYPE_NORMAL
- en: '# hide the main turtle cursor'
  prefs: []
  type: TYPE_NORMAL
- en: ❹ turtle.hideturtle()
  prefs: []
  type: TYPE_NORMAL
- en: You use `setup()` to set the width of the drawing window to 80 percent of the
    screen width ❶. (You could also give `setup()` specific height and origin parameters.)
    Then you set the cursor shape to a turtle and set the title of the program window
    to *Spirographs!* Next, you use `onkey()` with your `saveDrawing()` function to
    instruct the program to save the drawing when you press the S key on your keyboard
    ❷. Calling `listen()` makes the drawing window listen for user events (like keypresses)
    ❸. Finally, you hide the turtle cursor ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the `main()` function proceeds as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '# check for any arguments sent to --sparams and draw the Spirograph'
  prefs: []
  type: TYPE_NORMAL
- en: '❶ if args.sparams:'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ params = [float(x) for x in args.sparams]
  prefs: []
  type: TYPE_NORMAL
- en: '# draw the Spirograph with the given parameters'
  prefs: []
  type: TYPE_NORMAL
- en: col = (0.0, 0.0, 0.0)
  prefs: []
  type: TYPE_NORMAL
- en: ❸ spiro = Spiro(0, 0, col, *params)
  prefs: []
  type: TYPE_NORMAL
- en: ❹ spiro.draw()
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: '# create the animator object'
  prefs: []
  type: TYPE_NORMAL
- en: ❺ spiroAnim = SpiroAnimator(4)
  prefs: []
  type: TYPE_NORMAL
- en: '# add a key handler to toggle the turtle cursor'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.onkey(spiroAnim.toggleTurtles, "t")
  prefs: []
  type: TYPE_NORMAL
- en: '# add a key handler to restart the animation'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.onkey(spiroAnim.restart, "space")
  prefs: []
  type: TYPE_NORMAL
- en: '# start the turtle main loop'
  prefs: []
  type: TYPE_NORMAL
- en: ❻ turtle.mainloop()
  prefs: []
  type: TYPE_NORMAL
- en: You first check whether any arguments were given to `--sparams` ❶; if so, the
    program will just draw the one spiro defined by those arguments. The arguments
    currently exist as strings, but you need them to be interpreted as numbers. You
    use a list comprehension to convert them into a list of floats ❷. (A *list comprehension*
    is a Python construct that lets you create a list in a compact and powerful way.
    For example, `a = [2*x for x in range(1, 5)]` creates a list of the first four
    even numbers.) Then you use the parameters to construct a `Spiro` object ❸ (with
    the help of the Python `*` operator, which unpacks the list into a series of arguments)
    and call `draw()` to draw the spiro ❹.
  prefs: []
  type: TYPE_NORMAL
- en: If no arguments were specified at the command line, you enter random animation
    mode. For this, you create a `SpiroAnimator` object ❺, passing it the argument
    `4`, which tells it to draw four spiros at once. Then you use two `onkey` calls
    to capture additional keypresses. Pressing the T key will show or hide the turtle
    cursors with the `toggleTurtles()` method, while pressing the spacebar (`space`)
    will call `restart()` to interrupt the animation at any point and start drawing
    four different random spiros. Finally, you call `mainloop()` to tell the `tkinter`
    window to stay open, listening for events ❻.
  prefs: []
  type: TYPE_NORMAL
- en: '[Running the Spirograph Animation](nsp-venkitachalam503045-0008.xhtml#rah0404)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now it’s time to run your program:'
  prefs: []
  type: TYPE_NORMAL
- en: $ `python spiro.py`
  prefs: []
  type: TYPE_NORMAL
- en: By default, the *spiro.py* program draws four random spiros simultaneously,
    as shown in [Figure 2-5](nsp-venkitachalam503045-0013.xhtml#fig2-5). Pressing
    S saves the drawing, pressing T toggles the cursors, and pressing the spacebar
    restarts the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f02005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-5: A sample run of *spiro.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the program again, this time passing in parameters at the command line
    to draw a particular spiro:'
  prefs: []
  type: TYPE_NORMAL
- en: $ `python spiro.py --sparams 300 100 0.9`
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-6](nsp-venkitachalam503045-0013.xhtml#fig2-6) shows the output. As
    you can see, this code draws a single spiro with the parameters specified by the
    user, in contrast to [Figure 2-5](nsp-venkitachalam503045-0013.xhtml#fig2-5),
    which displays an animation of several random spiros.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f02006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-6: A sample run of *spiro.py* with specific parameters'
  prefs: []
  type: TYPE_NORMAL
- en: Have fun experimenting with different parameters to see how they influence the
    resulting curves.
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0405)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you learned how to create Spirograph-like curves. You also
    learned how to adjust the input parameters to generate a variety of different
    curves and to animate them on the screen. I hope you enjoy creating these spiros.
    (You’ll find a surprise in [Chapter 13](nsp-venkitachalam503045-0028.xhtml#ch13),
    where you’ll learn how to project spiros onto a wall!)
  prefs: []
  type: TYPE_NORMAL
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0406)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some ways to experiment further with spiros:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Now that you know how to draw circles, write a program to draw random *spirals*.
    Find the equation for a *logarithmic spiral* in parametric form and then use it
    to draw the spirals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '2\. You might have noticed that the turtle cursor is always oriented to the right
    as the curves are drawn, but that’s not how turtles move! Orient the turtle so
    that, as the curve is being drawn, it faces in the direction of drawing. (Hint:
    calculate the direction vector between successive points for every step and reorient
    the turtle using the `turtle`.`setheading()` method.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0407)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the complete Spirograph program:'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.py
  prefs: []
  type: TYPE_NORMAL
- en: A Python program that simulates a Spirograph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Mahesh Venkitachalam'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: import random, argparse
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: import turtle
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: from PIL import Image
  prefs: []
  type: TYPE_NORMAL
- en: from datetime import datetime
  prefs: []
  type: TYPE_NORMAL
- en: a class that draws a spiro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Spiro:'
  prefs: []
  type: TYPE_NORMAL
- en: '# constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, xc, yc, col, R, r, l):'
  prefs: []
  type: TYPE_NORMAL
- en: '# create own turtle'
  prefs: []
  type: TYPE_NORMAL
- en: self.t = turtle.Turtle()
  prefs: []
  type: TYPE_NORMAL
- en: '# set cursor shape'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.shape('turtle')
  prefs: []
  type: TYPE_NORMAL
- en: '# set step in degrees'
  prefs: []
  type: TYPE_NORMAL
- en: self.step = 5
  prefs: []
  type: TYPE_NORMAL
- en: '# set drawing complete flag'
  prefs: []
  type: TYPE_NORMAL
- en: self.drawingComplete = False
  prefs: []
  type: TYPE_NORMAL
- en: '# set parameters'
  prefs: []
  type: TYPE_NORMAL
- en: self.setparams(xc, yc, col, R, r, l)
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize drawing'
  prefs: []
  type: TYPE_NORMAL
- en: self.restart()
  prefs: []
  type: TYPE_NORMAL
- en: '# set parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'def setparams(self, xc, yc, col, R, r, l):'
  prefs: []
  type: TYPE_NORMAL
- en: '# spirograph parameters'
  prefs: []
  type: TYPE_NORMAL
- en: self.xc = xc
  prefs: []
  type: TYPE_NORMAL
- en: self.yc = yc
  prefs: []
  type: TYPE_NORMAL
- en: self.R = int(R)
  prefs: []
  type: TYPE_NORMAL
- en: self.r = int(r)
  prefs: []
  type: TYPE_NORMAL
- en: self.l = l
  prefs: []
  type: TYPE_NORMAL
- en: self.col = col
  prefs: []
  type: TYPE_NORMAL
- en: '# reduce r/R to smallest form by dividing with GCD'
  prefs: []
  type: TYPE_NORMAL
- en: gcdVal = math.gcd(self.r, self.R)
  prefs: []
  type: TYPE_NORMAL
- en: self.nRot = self.r//gcdVal
  prefs: []
  type: TYPE_NORMAL
- en: '# get ratio of radii'
  prefs: []
  type: TYPE_NORMAL
- en: self.k = r/float(R)
  prefs: []
  type: TYPE_NORMAL
- en: '# set color'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.color(*col)
  prefs: []
  type: TYPE_NORMAL
- en: '# current angle'
  prefs: []
  type: TYPE_NORMAL
- en: self.a = 0
  prefs: []
  type: TYPE_NORMAL
- en: '# restart drawing'
  prefs: []
  type: TYPE_NORMAL
- en: 'def restart(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# set flag'
  prefs: []
  type: TYPE_NORMAL
- en: self.drawingComplete = False
  prefs: []
  type: TYPE_NORMAL
- en: '# show turtle'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.showturtle()
  prefs: []
  type: TYPE_NORMAL
- en: '# go to first point'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.up()
  prefs: []
  type: TYPE_NORMAL
- en: R, k, l = self.R, self.k, self.l
  prefs: []
  type: TYPE_NORMAL
- en: a = 0.0
  prefs: []
  type: TYPE_NORMAL
- en: x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.setpos(self.xc + x, self.yc + y)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Exception, exiting.")
  prefs: []
  type: TYPE_NORMAL
- en: exit(0)
  prefs: []
  type: TYPE_NORMAL
- en: self.t.down()
  prefs: []
  type: TYPE_NORMAL
- en: '# draw the whole thing'
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# draw rest of points'
  prefs: []
  type: TYPE_NORMAL
- en: R, k, l = self.R, self.k, self.l
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, 360*self.nRot + 1, self.step):'
  prefs: []
  type: TYPE_NORMAL
- en: a = math.radians(i)
  prefs: []
  type: TYPE_NORMAL
- en: x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.setpos(self.xc + x, self.yc + y)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Exception, exiting.")
  prefs: []
  type: TYPE_NORMAL
- en: exit(0)
  prefs: []
  type: TYPE_NORMAL
- en: '# done - hide turtle'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.hideturtle()
  prefs: []
  type: TYPE_NORMAL
- en: '# update by one step'
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# skip if done'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.drawingComplete:'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '# increment angle'
  prefs: []
  type: TYPE_NORMAL
- en: self.a += self.step
  prefs: []
  type: TYPE_NORMAL
- en: '# draw step'
  prefs: []
  type: TYPE_NORMAL
- en: R, k, l = self.R, self.k, self.l
  prefs: []
  type: TYPE_NORMAL
- en: '# set angle'
  prefs: []
  type: TYPE_NORMAL
- en: a = math.radians(self.a)
  prefs: []
  type: TYPE_NORMAL
- en: x = self.R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: y = self.R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.setpos(self.xc + x, self.yc + y)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Exception, exiting.")
  prefs: []
  type: TYPE_NORMAL
- en: exit(0)
  prefs: []
  type: TYPE_NORMAL
- en: '# check if drawing is complete and set flag'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.a >= 360*self.nRot:'
  prefs: []
  type: TYPE_NORMAL
- en: self.drawingComplete = True
  prefs: []
  type: TYPE_NORMAL
- en: '# done - hide turtle'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.hideturtle()
  prefs: []
  type: TYPE_NORMAL
- en: '# clear everything'
  prefs: []
  type: TYPE_NORMAL
- en: 'def clear(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# pen up'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.up()
  prefs: []
  type: TYPE_NORMAL
- en: '# clear turtle'
  prefs: []
  type: TYPE_NORMAL
- en: self.t.clear()
  prefs: []
  type: TYPE_NORMAL
- en: a class for animating spiros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class SpiroAnimator:'
  prefs: []
  type: TYPE_NORMAL
- en: '# constructor'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, N):'
  prefs: []
  type: TYPE_NORMAL
- en: '# timer value in milliseconds'
  prefs: []
  type: TYPE_NORMAL
- en: self.deltaT = 10
  prefs: []
  type: TYPE_NORMAL
- en: '# get window dimensions'
  prefs: []
  type: TYPE_NORMAL
- en: self.width = turtle.window_width()
  prefs: []
  type: TYPE_NORMAL
- en: self.height = turtle.window_height()
  prefs: []
  type: TYPE_NORMAL
- en: '# restarting'
  prefs: []
  type: TYPE_NORMAL
- en: self.restarting = False
  prefs: []
  type: TYPE_NORMAL
- en: '# create spiro objects'
  prefs: []
  type: TYPE_NORMAL
- en: self.spiros = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(N):'
  prefs: []
  type: TYPE_NORMAL
- en: '# generate random parameters'
  prefs: []
  type: TYPE_NORMAL
- en: rparams = self.genRandomParams()
  prefs: []
  type: TYPE_NORMAL
- en: '# set spiro params'
  prefs: []
  type: TYPE_NORMAL
- en: spiro = Spiro(*rparams)
  prefs: []
  type: TYPE_NORMAL
- en: self.spiros.append(spiro)
  prefs: []
  type: TYPE_NORMAL
- en: '# call timer'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.ontimer(self.update, self.deltaT)
  prefs: []
  type: TYPE_NORMAL
- en: '# restart spiro drawing'
  prefs: []
  type: TYPE_NORMAL
- en: 'def restart(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# ignore restart if already in the middle of restarting'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.restarting:'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: self.restarting = True
  prefs: []
  type: TYPE_NORMAL
- en: '# restart'
  prefs: []
  type: TYPE_NORMAL
- en: 'for spiro in self.spiros:'
  prefs: []
  type: TYPE_NORMAL
- en: '# clear'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.clear()
  prefs: []
  type: TYPE_NORMAL
- en: '# generate random parameters'
  prefs: []
  type: TYPE_NORMAL
- en: rparams = self.genRandomParams()
  prefs: []
  type: TYPE_NORMAL
- en: '# set spiro params'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.setparams(*rparams)
  prefs: []
  type: TYPE_NORMAL
- en: '# restart drawing'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.restart()
  prefs: []
  type: TYPE_NORMAL
- en: '# done restarting'
  prefs: []
  type: TYPE_NORMAL
- en: self.restarting = False
  prefs: []
  type: TYPE_NORMAL
- en: '# generate random parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'def genRandomParams(self):'
  prefs: []
  type: TYPE_NORMAL
- en: width, height = self.width, self.height
  prefs: []
  type: TYPE_NORMAL
- en: R = random.randint(50, min(width, height)//2)
  prefs: []
  type: TYPE_NORMAL
- en: r = random.randint(10, 9*R//10)
  prefs: []
  type: TYPE_NORMAL
- en: l = random.uniform(0.1, 0.9)
  prefs: []
  type: TYPE_NORMAL
- en: xc = random.randint(-width//2, width//2)
  prefs: []
  type: TYPE_NORMAL
- en: yc = random.randint(-height//2, height//2)
  prefs: []
  type: TYPE_NORMAL
- en: col = (random.random(),
  prefs: []
  type: TYPE_NORMAL
- en: random.random(),
  prefs: []
  type: TYPE_NORMAL
- en: random.random())
  prefs: []
  type: TYPE_NORMAL
- en: return (xc, yc, col, R, r, l)
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# update all spiros'
  prefs: []
  type: TYPE_NORMAL
- en: nComplete = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for spiro in self.spiros:'
  prefs: []
  type: TYPE_NORMAL
- en: '# update'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.update()
  prefs: []
  type: TYPE_NORMAL
- en: '# count completed ones'
  prefs: []
  type: TYPE_NORMAL
- en: 'if spiro.drawingComplete:'
  prefs: []
  type: TYPE_NORMAL
- en: nComplete+= 1
  prefs: []
  type: TYPE_NORMAL
- en: '# if all spiros are complete, restart'
  prefs: []
  type: TYPE_NORMAL
- en: 'if nComplete == len(self.spiros):'
  prefs: []
  type: TYPE_NORMAL
- en: self.restart()
  prefs: []
  type: TYPE_NORMAL
- en: '# call timer'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.ontimer(self.update, self.deltaT)
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Exception, exiting.")
  prefs: []
  type: TYPE_NORMAL
- en: exit(0)
  prefs: []
  type: TYPE_NORMAL
- en: '# toggle turtle on/off'
  prefs: []
  type: TYPE_NORMAL
- en: 'def toggleTurtles(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for spiro in self.spiros:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if spiro.t.isvisible():'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.t.hideturtle()
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: spiro.t.showturtle()
  prefs: []
  type: TYPE_NORMAL
- en: save spiros to image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def saveDrawing():'
  prefs: []
  type: TYPE_NORMAL
- en: '# hide turtle'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.hideturtle()
  prefs: []
  type: TYPE_NORMAL
- en: '# generate unique filename'
  prefs: []
  type: TYPE_NORMAL
- en: dateStr = (datetime.now()).strftime("%d%b%Y-%H%M%S")
  prefs: []
  type: TYPE_NORMAL
- en: fileName = 'spiro-' + dateStr
  prefs: []
  type: TYPE_NORMAL
- en: print('saving drawing to {}.eps/png'.format(fileName))
  prefs: []
  type: TYPE_NORMAL
- en: '# get tkinter canvas'
  prefs: []
  type: TYPE_NORMAL
- en: canvas = turtle.getcanvas()
  prefs: []
  type: TYPE_NORMAL
- en: '# save postscript image'
  prefs: []
  type: TYPE_NORMAL
- en: canvas.postscript(file = fileName + '.eps')
  prefs: []
  type: TYPE_NORMAL
- en: '# use PIL to convert to PNG'
  prefs: []
  type: TYPE_NORMAL
- en: img = Image.open(fileName + '.eps')
  prefs: []
  type: TYPE_NORMAL
- en: img.save(fileName + '.png', 'png')
  prefs: []
  type: TYPE_NORMAL
- en: '# show turtle'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.showturtle()
  prefs: []
  type: TYPE_NORMAL
- en: main() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '# use sys.argv if needed'
  prefs: []
  type: TYPE_NORMAL
- en: print('generating spirograph...')
  prefs: []
  type: TYPE_NORMAL
- en: '# create parser'
  prefs: []
  type: TYPE_NORMAL
- en: descStr = """This program draws spirographs using the Turtle module.
  prefs: []
  type: TYPE_NORMAL
- en: When run with no arguments, this program draws random spirographs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: 'R: radius of outer circle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'r: radius of inner circle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'l: ratio of hole distance to r.'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: parser = argparse.ArgumentParser(description=descStr)
  prefs: []
  type: TYPE_NORMAL
- en: '# add expected arguments'
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--sparams', nargs=3, dest='sparams', required=False,
  prefs: []
  type: TYPE_NORMAL
- en: 'help="The three arguments in sparams: R, r, l.")'
  prefs: []
  type: TYPE_NORMAL
- en: '# parse args'
  prefs: []
  type: TYPE_NORMAL
- en: args = parser.parse_args()
  prefs: []
  type: TYPE_NORMAL
- en: '# set to 80% screen width'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.setup(width=0.8)
  prefs: []
  type: TYPE_NORMAL
- en: '# set cursor shape'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.shape('turtle')
  prefs: []
  type: TYPE_NORMAL
- en: '# set title'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.title("Spirographs!")
  prefs: []
  type: TYPE_NORMAL
- en: '# add key handler for saving images'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.onkey(saveDrawing, "s")
  prefs: []
  type: TYPE_NORMAL
- en: '# start listening'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.listen()
  prefs: []
  type: TYPE_NORMAL
- en: '# hide main turtle cursor'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.hideturtle()
  prefs: []
  type: TYPE_NORMAL
- en: '# check args and draw'
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.sparams:'
  prefs: []
  type: TYPE_NORMAL
- en: params = [float(x) for x in args.sparams]
  prefs: []
  type: TYPE_NORMAL
- en: '# draw spirograph with given parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '# black by default'
  prefs: []
  type: TYPE_NORMAL
- en: col = (0.0, 0.0, 0.0)
  prefs: []
  type: TYPE_NORMAL
- en: spiro = Spiro(0, 0, col, *params)
  prefs: []
  type: TYPE_NORMAL
- en: spiro.draw()
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: '# create animator object'
  prefs: []
  type: TYPE_NORMAL
- en: spiroAnim = SpiroAnimator(4)
  prefs: []
  type: TYPE_NORMAL
- en: '# add key handler to toggle turtle cursor'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.onkey(spiroAnim.toggleTurtles, "t")
  prefs: []
  type: TYPE_NORMAL
- en: '# add key handler to restart animation'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.onkey(spiroAnim.restart, "space")
  prefs: []
  type: TYPE_NORMAL
- en: '# start turtle main loop'
  prefs: []
  type: TYPE_NORMAL
- en: turtle.mainloop()
  prefs: []
  type: TYPE_NORMAL
- en: call main
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
