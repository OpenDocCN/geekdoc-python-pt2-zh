- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: TRANSFORMING SHAPES WITH GEOMETRY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用几何学变换形状
- en: '*In the teahouse one day Nasrudin announced he was selling his house. When
    the other patrons asked him to describe it, he brought out a brick. “It’s just
    a collection of these.”—Idries Shah*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*有一天，纳斯鲁丁在茶馆里宣布他要卖掉自己的房子。当其他顾客让他描述房子时，他拿出了一块砖。“这只不过是这些东西的集合。”—伊德里斯·沙赫*'
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: In geometry class, everything you learn about involves dimensions in space using
    shapes. You typically start by examining one-dimensional lines and two-dimensional
    circles, squares, or triangles, then move on to three-dimensional objects like
    spheres and cubes. These days, creating geometric shapes is easy with technology
    and free software, though manipulating and changing the shapes you create can
    be more of a challenge.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在几何学课堂上，你所学的一切都涉及使用形状来表示空间中的维度。你通常从一维的直线和二维的圆形、正方形或三角形开始，然后转向三维的物体，如球体和立方体。如今，借助科技和免费的软件，创建几何形状变得很容易，但操控和改变你创建的形状可能会更具挑战性。
- en: In this chapter, you’ll learn how to manipulate and transform geometric shapes
    using the Processing graphics package. You’ll start with basic shapes like circles
    and triangles, which will allow you to work with complicated shapes like fractals
    and cellular automata in later chapters. You will also learn how to break down
    some complicated-looking designs into simple components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将学习如何使用 Processing 图形包来操控和变换几何形状。你将从基本的形状开始，如圆形和三角形，这将帮助你在后续章节中处理复杂的形状，如分形和细胞自动机。你还将学会如何将一些看似复杂的设计分解成简单的组成部分。
- en: DRAWING A CIRCLE
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制一个圆形
- en: Let’s start with a simple one-dimensional circle. Open a new sketch in Processing
    and save it as *geometry.pyde*. Then enter the code in [Listing 5-1](ch05.xhtml#ch05list1)
    to create a circle on the screen.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的一维圆开始。在 Processing 中打开一个新的草图，并将其保存为 *geometry.pyde*。然后输入 [列表 5-1](ch05.xhtml#ch05list1)
    中的代码，在屏幕上绘制一个圆形。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 5-1: Drawing a circle*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：绘制一个圆圈*'
- en: Before we draw the shape, we first define the size of our sketchbook, known
    as the *coordinate plane*. In this example, we use the `size()` function to say
    that our grid will be 600 pixels wide and 600 pixels tall.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制形状之前，我们首先定义草图的大小，称为 *坐标平面*。在这个例子中，我们使用 `size()` 函数设置我们的网格宽度为 600 像素，高度也为
    600 像素。
- en: With our coordinate plane set up, we then use the drawing function `ellipse()`
    to create our circle on this plane. The first two parameters, `200` and `100`,
    show where the center of the circle is located. Here, `200` is the x-coordinate
    and the second number, `100`, is the y-coordinate of this circle’s center, which
    places it at `(200,100)` on the plane.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好坐标平面后，我们使用绘图函数 `ellipse()` 在这个平面上绘制圆形。前两个参数，`200` 和 `100`，表示圆心的位置。这里，`200`
    是圆心的 x 坐标，第二个数值 `100` 是 y 坐标，这样圆心就位于平面上的 `(200,100)`。
- en: The last two parameters determine the width and height of the shape in pixels.
    In the example, the shape is 20 pixels wide and 20 pixels tall. Because the two
    parameters are the same, it means that the points on the circumference are equidistant
    from the center, forming a perfectly round circle.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个参数决定了形状的宽度和高度（单位：像素）。在这个例子中，形状的宽度为 20 像素，高度也是 20 像素。因为这两个参数相同，这意味着圆周上的各个点与中心的距离相等，从而形成一个完美的圆形。
- en: Click the **Run** button (it looks like a play symbol), and a new window with
    a small circle should open, like in [Figure 5-1](ch05.xhtml#ch05fig1).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **运行** 按钮（看起来像播放符号），一个包含小圆圈的新窗口应该会打开，像 [图 5-1](ch05.xhtml#ch05fig1) 中所示。
- en: '![image](../images/f078-01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f078-01.jpg)'
- en: '*Figure 5-1: The output of [Listing 5-1](ch05.xhtml#ch05list1) showing a small
    circle*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：[列表 5-1](ch05.xhtml#ch05list1)的输出显示一个小圆圈*'
- en: Processing has a number of functions you can use to draw shapes. Check out the
    full list at [*https://processing.org/reference/*](https://processing.org/reference/)
    to explore other shape functions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 提供了多个函数供你绘制形状。你可以查看完整的函数列表，访问 [*https://processing.org/reference/*](https://processing.org/reference/)
    来探索其他形状函数。
- en: Now that you know how to draw a circle in Processing, you’re almost ready to
    use these simple shapes to create dynamic, interactive graphics. In order to do
    that, you’ll first need to learn about location and transformations. Let’s start
    with location.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何在 Processing 中绘制圆形，你几乎可以使用这些简单的形状来创建动态的交互式图形。为了实现这一点，你首先需要了解位置和变换。让我们从位置开始。
- en: SPECIFYING LOCATION USING COORDINATES
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用坐标指定位置
- en: 'In [Listing 5-1](ch05.xhtml#ch05list1), we used the first two parameters of
    the `ellipse()` function to specify our circle’s location on the grid. Likewise,
    each shape we create using Processing needs a location that we specify with the
    coordinate system, where each point on the graph is represented by two numbers:
    (x,y). In traditional math graphs, the origin (where x=0 and y=0) is at the center
    of the graph, as shown in [Figure 5-2](ch05.xhtml#ch05fig2).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 5-1](ch05.xhtml#ch05list1)中，我们使用 `ellipse()` 函数的前两个参数来指定圆的位置。同样，使用 Processing
    创建的每个形状都需要一个位置，这个位置由坐标系指定，其中图中的每个点由两个数字表示：(x,y)。在传统的数学图表中，原点（即 x=0 和 y=0）位于图表的中心，如[图
    5-2](ch05.xhtml#ch05fig2)所示。
- en: '![image](../images/f079-01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f079-01.jpg)'
- en: '*Figure 5-2: A traditional coordinate system with the origin in the center*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：传统坐标系，原点在中心*'
- en: In computer graphics, however, the coordinate system is a little different.
    Its origin is in the top-left corner of the screen so that x and y increase as
    you move right and down, respectively, as you can see in [Figure 5-3](ch05.xhtml#ch05fig3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在计算机图形学中，坐标系稍有不同。它的原点位于屏幕的左上角，因此 x 和 y 坐标分别在向右和向下移动时增加，如[图 5-3](ch05.xhtml#ch05fig3)所示。
- en: '![image](../images/f079-02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f079-02.jpg)'
- en: '*Figure 5-3: The coordinate system for computer graphics, with the origin in
    the top-left corner*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：计算机图形学的坐标系，原点在左上角*'
- en: Each coordinate on this plane represents a pixel on the screen. As you can see,
    this means you don’t have to deal with negative coordinates. We’ll use functions
    to transform and translate increasingly complex shapes around this coordinate
    system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个平面上的每个坐标代表屏幕上的一个像素。如你所见，这意味着你不需要处理负坐标。我们将使用函数来转换并平移越来越复杂的形状。
- en: Drawing a single circle was fairly easy, but drawing multiple shapes can get
    complicated pretty quickly. For example, imagine drawing a design like the one
    shown in [Figure 5-4](ch05.xhtml#ch05fig4).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个单独的圆形相对简单，但绘制多个形状会很快变得复杂。例如，假设你需要绘制一个像[图 5-4](ch05.xhtml#ch05fig4)中所示的设计。
- en: '![image](../images/f080-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f080-01.jpg)'
- en: '*Figure 5-4: A circle made of circles*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：由圆组成的圆形*'
- en: Specifying the size and location of each individual circle and spacing them
    out perfectly evenly would involve entering many lines of similar code. Fortunately,
    you don’t really need to know the absolute x- and y-coordinates of each circle
    to do this. With Processing, you can easily place objects wherever you want on
    the grid.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要指定每个圆的大小和位置，并且将它们间隔均匀地排列，就需要输入很多类似的代码行。幸运的是，实际上你并不需要知道每个圆的绝对 x 和 y 坐标就能做到这一点。使用
    Processing，你可以轻松地将对象放置在网格的任何位置。
- en: Let’s see how you can do this using a simple example to start.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来看看如何实现这个功能。
- en: TRANSFORMATION FUNCTIONS
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变换函数
- en: You might remember doing transformations with pencil and paper in geometry class,
    which you performed on a collection of points to laboriously move a shape around.
    It’s much more fun when you let a computer do the transforming. In fact, there
    wouldn’t be any computer graphics worth looking at without transformations! Geometric
    transformations like translation and rotation let you change where and how your
    objects appear without altering the objects themselves. For example, you can use
    transformations to move a triangle to a different location or spin it around without
    changing its shape. Processing has a number of built-in transformation functions
    that make it easy to translate and rotate objects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得在几何课上用铅笔和纸做变换时，你需要对一组点进行繁琐的操作以移动形状。让计算机来进行变换要有趣得多。事实上，没有变换，计算机图形就不可能有什么可看的！几何变换，如平移和旋转，可以让你在不改变对象本身的情况下，改变对象出现的位置和方式。例如，你可以使用变换将三角形移动到另一个位置，或将其旋转而不改变其形状。Processing
    提供了许多内置的变换函数，使得平移和旋转对象变得非常简单。
- en: TRANSLATING OBJECTS WITH TRANSLATE()
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 TRANSLATE() 进行对象平移
- en: To *translate* means to move a shape on a grid so that all points of the shape
    move in the same direction and the same distance. In other words, translations
    let you move a shape on a grid without changing the shape itself and without tilting
    it in the slightest.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*平移*意味着将形状在网格上移动，使得形状的所有点都朝相同的方向和相同的距离移动。换句话说，平移让你在不改变形状本身且不倾斜形状的情况下，将形状在网格上移动。'
- en: Translating an object in math class involves manually changing the coordinates
    of all the points in the object. But in Processing, you translate an object by
    moving the *grid* itself, while the object’s coordinates stay the same! For an
    example of this, let’s put a rectangle on the screen. Revise your existing code
    in *geometry.pyde* with the code in [Listing 5-2](ch05.xhtml#ch05list2).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学课上，平移一个物体涉及手动改变物体上所有点的坐标。但在Processing中，平移物体是通过移动*网格*本身来实现的，而物体的坐标保持不变！举个例子，我们可以在屏幕上绘制一个矩形。请按照[清单
    5-2](ch05.xhtml#ch05list2)中的代码修改你现有的*geometry.pyde*代码。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-2: Drawing a rectangle to translate*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：绘制一个矩形以进行平移*'
- en: Here, we use the `rect()` function to draw the rectangle. The first two parameters
    are the x- and y-coordinates telling Processing where the top-left corner of the
    rectangle should be. The third and fourth parameters indicate its width and its
    height, respectively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`rect()`函数来绘制矩形。前两个参数是x和y坐标，告诉Processing矩形的左上角应该在哪里。第三和第四个参数分别表示矩形的宽度和高度。
- en: Run this code, and you should see the rectangle shown in [Figure 5-5](ch05.xhtml#ch05fig5).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，你应该能看到[图 5-5](ch05.xhtml#ch05fig5)中的矩形。
- en: '![image](../images/f081-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f081-01.jpg)'
- en: '*Figure 5-5: The default coordinate setup with the origin at the top left*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：默认坐标设置，原点位于左上角*'
- en: '**NOTE**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In these examples, I’m showing the grid for reference, but you won’t see it
    on your screen.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我展示了网格以供参考，但你在屏幕上是看不见它的。
- en: Now let’s tell Processing to translate the rectangle using the code in [Listing
    5-3](ch05.xhtml#ch05list3). Notice that we don’t change the coordinates of the
    rectangle.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过[清单 5-3](ch05.xhtml#ch05list3)中的代码来告诉Processing平移矩形。注意，我们并没有改变矩形的坐标。
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-3: Translating the rectangle*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：平移矩形*'
- en: 'Here, we use `translate()` to move the rectangle. We provide two parameters:
    the first tells Processing how far to move the grid in the horizontal (x) direction,
    and the second parameter is for how far to move the grid vertically, in the y-direction.
    So `translate(50,80)` should move the entire grid 50 pixels to the right and 80
    pixels down, as shown in [Figure 5-6](ch05.xhtml#ch05fig6).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`translate()`来平移矩形。我们提供两个参数：第一个参数告诉Processing在水平（x）方向上平移网格的距离，第二个参数表示在垂直方向（y）上平移的距离。因此，`translate(50,80)`将整个网格向右移动50像素并向下移动80像素，如[图
    5-6](ch05.xhtml#ch05fig6)所示。
- en: '![image](../images/f082-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f082-01.jpg)'
- en: '*Figure 5-6: Translating a rectangle by moving the grid 50 pixels to the right
    and 80 pixels down*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：通过将网格向右移动50像素并向下移动80像素来平移矩形*'
- en: Very often it’s useful (and easier!) to have the origin (0,0) in the center
    of the canvas. You can use `translate()` to easily move the origin to the center
    of your grid. You can also use it to change the width and height of your canvas
    if you want it bigger or smaller. Let’s explore Processing’s built-in `width`
    and `height` variables, which let you update the size of your canvas without having
    to change the numbers manually. To see this in action, update the existing code
    in [Listing 5-3](ch05.xhtml#ch05list3) so it looks like [Listing 5-4](ch05.xhtml#ch05list4).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，将原点(0,0)放在画布的中心是非常有用的（也更容易！）。你可以使用`translate()`轻松地将原点移动到网格的中心。如果你希望画布更大或更小，也可以用它来改变画布的宽度和高度。让我们来看看Processing内置的`width`和`height`变量，它们允许你更新画布的大小，而无需手动更改数字。为了演示这一点，请更新[清单
    5-3](ch05.xhtml#ch05list3)中的现有代码，使其像[清单 5-4](ch05.xhtml#ch05list4)那样。
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-4: Using the `width` and `height` variables to translate the rectangle*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4：使用`width`和`height`变量平移矩形*'
- en: Whatever numbers you put in the `size` declaration in the `setup()` function
    will become the “width” and “height” of the canvas. In this case, because I used
    `size(600,600)`, they’re both 600 pixels. When we change the `translate()` line
    to `translate(width/2, height/2)` using variables instead of specific numbers,
    we tell Processing to move the location (0,0) to the center of the display window,
    no matter what the size is. This means that if you change the size of the window,
    Processing will automatically update `width` and `height`, and you won’t have
    to go through all your code and change the numbers manually.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setup()` 函数中，您在 `size` 声明中输入的任何数字都会成为画布的“宽度”和“高度”。在这个例子中，由于我使用了 `size(600,600)`，它们的宽度和高度都是
    600 像素。当我们将 `translate()` 语句更改为 `translate(width/2, height/2)`，使用变量代替具体数字时，我们告诉
    Processing 将位置 (0,0) 移动到显示窗口的中心，无论窗口大小如何。这意味着，如果您改变窗口的大小，Processing 会自动更新 `width`
    和 `height`，您无需手动修改所有代码中的数字。
- en: Run the updated code, and you should see something like [Figure 5-7](ch05.xhtml#ch05fig7).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行更新后的代码，您应该会看到类似 [图 5-7](ch05.xhtml#ch05fig7) 的效果。
- en: '![image](../images/f083-01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f083-01.jpg)'
- en: '*Figure 5-7: The grid is translated to the center of the screen*.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：网格被平移到屏幕中心*。'
- en: Notice that the origin is still labeled as (0,0), which shows that we haven’t
    actually moved the origin point but rather the entire coordinate plane itself
    so that the origin point falls in the middle of our canvas.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，原点仍然标记为 (0,0)，这表明我们并没有真正移动原点，而是移动了整个坐标平面，使得原点位于画布的中心。
- en: ROTATING OBJECTS WITH ROTATE()
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `ROTATE()` 旋转物体
- en: In geometry, *rotation* is a kind of transformation that turns an object around
    a center point, as if it’s turning on an axis. The `rotate()` function in Processing
    rotates the grid around the origin (0,0). It takes a single number as its argument
    to specify the angle at which you want to rotate the grid around the point (0,0).
    The units for the rotation angle are radians, which you learn about in precalculus
    class. Instead of using 360 degrees to do a full rotation, we can use 2π (around
    6.28) radians. If you think in degrees, like I do, you can use the `radians()`
    function to easily convert your degrees to radians so you don’t have to do the
    math yourself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在几何学中，*旋转*是一种变换，它使物体围绕中心点旋转，就像它绕轴旋转一样。Processing 中的 `rotate()` 函数围绕原点 (0,0)
    旋转网格。它接受一个数字作为参数，用来指定您希望围绕点 (0,0) 旋转的角度。旋转角度的单位是弧度，这是您在预备微积分课中学到的内容。我们可以使用 2π（大约
    6.28）弧度代替 360 度来进行完整的旋转。如果您像我一样习惯用度数思考，可以使用 `radians()` 函数轻松将度数转换为弧度，这样就不必自己做数学计算了。
- en: To see how the `rotate()` function works, enter the code shown in [Figure 5-8](ch05.xhtml#ch05fig8)
    into your existing sketch by replacing the `translate()` code inside the `draw()`
    function with each of these examples, and then run them. [Figure 5-8](ch05.xhtml#ch05fig8)
    shows the results.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看 `rotate()` 函数如何工作，将 [图 5-8](ch05.xhtml#ch05fig8) 中显示的代码输入到现有草图中，替换 `draw()`
    函数中的 `translate()` 代码，然后运行它们。[图 5-8](ch05.xhtml#ch05fig8) 显示了结果。
- en: '![image](../images/f084-01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f084-01.jpg)'
- en: '*Figure 5-8: The grid always rotates around (0,0)*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：网格始终围绕 (0,0) 旋转*'
- en: On the left side of [Figure 5-8](ch05.xhtml#ch05fig8), the grid is rotated 20
    degrees around (0,0), which is at the top-left corner of the screen. In the example
    on the right, the origin is first translated 200 units to the right and 200 units
    down and *then* the grid is rotated.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 5-8](ch05.xhtml#ch05fig8) 的左侧，网格围绕 (0,0) 旋转了 20 度，而 (0,0) 位于屏幕的左上角。在右侧的例子中，原点首先向右平移
    200 个单位，向下平移 200 个单位，*然后* 网格进行了旋转。
- en: 'The `rotate()` function makes it easy to draw a circle of objects like the
    one in [Figure 5-4](ch05.xhtml#ch05fig4) using the following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotate()` 函数使得绘制一个物体圆形排列变得简单，就像 [图 5-4](ch05.xhtml#ch05fig4) 中那样，按照以下步骤操作：'
- en: Translate to where you want the center of the circle to be.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到您希望圆心所在的位置。
- en: Rotate the grid and put the objects along the circumference of the circle.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旋转网格并将物体放置在圆的周长上。
- en: Now that you know how to use transformation functions to manipulate the location
    of different objects on your canvas, let’s actually re-create [Figure 5-4](ch05.xhtml#ch05fig4)
    in Processing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经知道如何使用变换函数来操作画布上不同物体的位置，让我们在 Processing 中重新创建 [图 5-4](ch05.xhtml#ch05fig4)。
- en: DRAWING A CIRCLE OF CIRCLES
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制圆形中的圆形
- en: To create the circles arranged in a circle in [Figure 5-4](ch05.xhtml#ch05fig4),
    we’ll use a `for i in range()` loop to repeat the circles and make sure the circles
    are evenly spaced. First, let’s think about how many degrees should be between
    the circles to make a full circle, remembering that a circle is 360 degrees.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在[图 5-4](ch05.xhtml#ch05fig4)中创建排列成圆形的圆形，我们将使用 `for i in range()` 循环来重复绘制圆形，并确保圆形均匀分布。首先，我们要考虑两个圆形之间的角度应该是多少，记住圆形总共有
    360 度。
- en: Enter the code shown in [Listing 5-5](ch05.xhtml#ch05list5) to create this design.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输入[列表 5-5](ch05.xhtml#ch05list5)中显示的代码来创建这个设计。
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-5: Drawing a circular design*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：绘制圆形设计*'
- en: Note that the `translate(width/2,height/2)` function inside the `draw()` function
    translates the grid to the center of the screen. Then, we start a `for` loop to
    create an ellipse at a point on the grid, starting at (200,0), as you can see
    from the first two parameters of the function. Then we set the size of each small
    circle by setting both the `width` and `height` of the ellipse to `50`. Finally,
    we rotate the grid by 360/12, or 30 degrees, before creating the next ellipse.
    Note that we use `radians()` to convert 30 degrees into radians inside the `rotate()`
    function. This means that each circle will be 30 degrees away from the next one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`draw()` 函数中的 `translate(width/2,height/2)` 函数将坐标系平移到屏幕中心。然后，我们开始一个 `for`
    循环，在坐标系上的某个点创建一个椭圆，从 (200,0) 开始，如函数的前两个参数所示。接着，我们通过将椭圆的 `width` 和 `height` 都设置为
    `50` 来设定每个小圆形的大小。最后，我们在创建下一个椭圆之前，将坐标系旋转 360/12，即 30 度。请注意，我们在 `rotate()` 函数中使用
    `radians()` 将 30 度转换为弧度。这意味着每个圆形与下一个圆形相距 30 度。
- en: When you run this, you should see what’s shown in [Figure 5-9](ch05.xhtml#ch05fig9).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该会看到[图 5-9](ch05.xhtml#ch05fig9)中显示的内容。
- en: '![image](../images/f085-01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f085-01.jpg)'
- en: '*Figure 5-9: Using transformation to create a circular design*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-9：使用变换创建圆形设计*'
- en: We have successfully arranged a bunch of circles into a circular shape!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将一堆圆形排列成了一个圆形！
- en: DRAWING A CIRCLE OF SQUARES
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制方形的圆形
- en: 'Modify the program you wrote in [Listing 5-5](ch05.xhtml#ch05list5) and change
    the circles into squares. To do this, just change `ellipse` in the existing code
    to `rect` to make the circles into squares, as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你在[列表 5-5](ch05.xhtml#ch05list5)中写的程序，将圆形改为方形。为此，只需将现有代码中的`ellipse`改为`rect`，即可将圆形变为方形，如下所示：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That was easy!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！
- en: ANIMATING OBJECTS
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画化对象
- en: Processing is great for animating your objects to create dynamic graphics. For
    your first animation, you’ll use the `rotate()` function. Normally, `rotate` happens
    instantly, so you don’t get to see the action take place—only the result of the
    rotation. But this time, we’ll use a time variable `t`, which allows us to see
    the rotation unfold in real time!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 很适合为你的对象制作动画，创建动态图形。在你的第一个动画中，你将使用 `rotate()` 函数。通常，`rotate` 会立即发生，因此你无法看到旋转的过程——只能看到旋转的结果。但这次，我们将使用一个时间变量
    `t`，它允许我们实时看到旋转过程！
- en: CREATING THE T VARIABLE
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 `t` 变量
- en: Let’s use our circle of squares to write an animated program. To start, create
    the `t` variable and initialize it to 0 by adding t = 0 before the `setup()` function.
    Then insert the code in [Listing 5-6](ch05.xhtml#ch05list6) before the `for` loop.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这个方形的圆形来编写一个动画程序。首先，创建 `t` 变量，并通过在`setup()`函数前添加 `t = 0` 来初始化它。然后，将[列表 5-6](ch05.xhtml#ch05list6)中的代码插入到`for`循环之前。
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-6: Adding the `t` variable*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：添加 `t` 变量*'
- en: 'However, if you try to run this code, you’ll get the following error message:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试运行这段代码，你会看到以下错误信息：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is because Python doesn’t know whether we’re creating a new local variable
    named `t` *inside* the function that doesn’t have anything to do with the global
    variable `t` *outside* the function, or just calling the global variable. Because
    we want to use the global variable, add global t at the beginning of the `draw()`
    function so the program knows which one we’re referring to.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Python 无法确定我们是在函数内部创建一个与全局变量 `t` 无关的新的局部变量，还是在调用全局变量 `t`。由于我们希望使用全局变量，在
    `draw()` 函数的开始处添加 `global t`，这样程序就知道我们指的是哪一个。
- en: 'Enter the complete code shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输入此处显示的完整代码：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code starts `t` at 0, rotates the grid that number of degrees, increments
    `t` by 1, and then repeats. Run it, and you should see the squares start to rotate
    in a circular pattern, as in [Figure 5-10](ch05.xhtml#ch05fig10).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 `t` 从 0 开始，旋转网格相应的角度，然后将 `t` 增加 1，接着重复执行。运行它后，你应该会看到方块开始以圆形模式旋转，如 [图 5-10](ch05.xhtml#ch05fig10)
    所示。
- en: '![image](../images/f087-01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f087-01.jpg)'
- en: '*Figure 5-10: Making squares rotate in a circle*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-10：让方块围绕圆形旋转*'
- en: Pretty cool! Now let’s try rotating each individual square.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷！现在我们来试试旋转每个单独的方块。
- en: ROTATING THE INDIVIDUAL SQUARES
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旋转单个方块
- en: Because rotating is done around (0,0) in Processing, inside the loop we first
    have to translate to where each square needs to be, then rotate, and finally draw
    the square. Change the loop in your code to look like [Listing 5-7](ch05.xhtml#ch05list7).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在 Processing 中旋转是围绕 (0,0) 进行的，所以在循环内，我们首先要将坐标系平移到每个方块应在的位置，然后进行旋转，最后绘制方块。将代码中的循环更改为
    [清单 5-7](ch05.xhtml#ch05list7) 的样子。
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 5-7: Rotating each square*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-7：旋转每个方块*'
- en: This translates the grid to where we want to place the square, rotates the grid
    so the square rotates, and then draws the square using the `rect()` function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将网格平移到我们希望放置方块的位置，旋转网格使方块旋转，然后使用 `rect()` 函数绘制方块。
- en: SAVING ORIENTATION WITH PUSHMATRIX() AND POPMATRIX()
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `pushMatrix()` 和 `popMatrix()` 保存方向
- en: When you run [Listing 5-7](ch05.xhtml#ch05list7), you should see that it creates
    some strange behavior. The squares don’t rotate around the center, but keep moving
    around the screen instead, as shown in [Figure 5-11](ch05.xhtml#ch05fig11).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 [清单 5-7](ch05.xhtml#ch05list7) 时，你会看到它会产生一些奇怪的行为。方块没有围绕中心旋转，而是继续在屏幕上移动，就像在
    [图 5-11](ch05.xhtml#ch05fig11) 中所示。
- en: '![image](../images/f088-01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f088-01.jpg)'
- en: '*Figure 5-11: The squares are flying all over!*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-11：方块飞得四处乱窜！*'
- en: This is due to changing the center and changing the orientation of the grid
    so much. After translating to the location of the square, we need to rotate back
    to the center of the circle before translating to the next square. We could use
    another `translate()` function to undo the first one, but we might have to undo
    more transformations, and that could get confusing. Fortunately, there’s an easier
    way.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由于改变中心点和频繁改变网格方向所致。在平移到方块位置后，我们需要先旋转回圆心，然后再平移到下一个方块的位置。我们可以使用另一个 `translate()`
    函数来撤销第一个平移，但可能还需要撤销更多的变换，这样会变得有些混乱。幸运的是，有更简单的方法。
- en: 'Processing has two built-in functions that save the orientation of the grid
    at a certain point and then return to that orientation: `pushMatrix()` and `popMatrix()`.
    In this case, we want to save the orientation when we’re in the center of the
    screen. To do this, revise the loop to look like [Listing 5-8](ch05.xhtml#ch05list8).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 有两个内建函数，它们可以在某个特定点保存网格的方向，并且可以返回该方向：`pushMatrix()` 和 `popMatrix()`。在这种情况下，我们希望在屏幕中心时保存方向。为此，修改循环使其看起来像
    [清单 5-8](ch05.xhtml#ch05list8)。
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 5-8: Using `pushMatrix()` and `popMatrix()`*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-8：使用 `pushMatrix()` 和 `popMatrix()`*'
- en: The `pushMatrix()` function saves the position of the coordinate system at the
    center of the circle of squares. Then we translate to the location of the square,
    rotate the grid so the square will spin, and then draw the square. Then we use
    `popMatrix()` to return instantly to the center of the circle of squares and repeat
    for all 12 squares.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushMatrix()` 函数保存了方块圆环中心的坐标系位置。然后我们将坐标系平移到方块的位置，旋转网格使得方块旋转，最后绘制方块。然后我们使用
    `popMatrix()` 快速返回到方块圆环的中心，并对所有 12 个方块重复此过程。'
- en: ROTATING AROUND THE CENTER
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绕中心旋转
- en: 'The preceding code should work perfectly, but the rotation may look strange;
    that’s because Processing by default locates a rectangle at its top-left corner
    and rotates it about its top-left corner. This makes the squares look like they’re
    veering off the path of the larger circle. If you want your squares to rotate
    around their centers, add this line to your `setup()` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应该能够正常工作，但旋转效果可能看起来有点奇怪；这是因为 Processing 默认将矩形定位到其左上角并围绕左上角旋转。这使得方块看起来像是偏离了大圆的路径。如果你希望方块围绕它们的中心旋转，可以在
    `setup()` 函数中添加以下行：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that the all-uppercase `CENTER` in `rectMode()` matters. (You can also
    experiment with other types of `rectMode()`, like `CORNER`, `CORNERS`, and `RADIUS`.)
    Adding `rectMode(CENTER)` should make each square rotate around its center. If you
    want the squares to spin more quickly, change the `rotate()` line to increase
    the time in `t`, like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`rectMode()`中的全大写`CENTER`是很重要的。（你也可以尝试其他类型的`rectMode()`，比如`CORNER`、`CORNERS`和`RADIUS`。）添加`rectMode(CENTER)`应该让每个方格围绕其中心旋转。如果你想让方格旋转得更快，可以更改`rotate()`这一行，增加`t`中的时间，如下所示：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `5` is the frequency of the rotation. This means the program multiplies
    the value of `t` by 5 and rotates by the product. Therefore, the square will rotate
    five times as far as before. Change it to see what happens! Comment out the `rotate()`
    line outside the loop (by adding a hashtag at the beginning) to make the squares
    rotate in place, as shown in [Listing 5-9](ch05.xhtml#ch05list9).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`5`是旋转的频率。这意味着程序将`t`的值乘以5，然后根据乘积旋转。因此，方格将旋转之前的五倍。更改它，看看会发生什么！注释掉循环外的`rotate()`这一行（通过在前面加上一个井号），使方格围绕其中心旋转，如[列表5-9](ch05.xhtml#ch05list9)所示。
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 5-9: Commenting out a line instead of deleting it*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-9：注释掉一行代码而不是删除它*'
- en: Being able to use transformations like `translate()` and `rotate()` to create
    dynamic graphics is a very powerful technique, but it can produce unexpected results
    if you do things in the wrong order!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用`translate()`和`rotate()`等变换来创建动态图形是一项非常强大的技巧，但如果顺序错误，可能会产生意想不到的结果！
- en: CREATING AN INTERACTIVE RAINBOW GRID
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个交互式彩虹网格
- en: 'Now that you’ve learned how to create designs using loops and to rotate them
    in different ways, we’ll create something pretty awesome: a grid of squares whose
    rainbow colors follow your mouse cursor! The first step is to make a grid.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用循环创建设计，并以不同的方式旋转它们，我们将创造一些相当酷的东西：一个方格网，其中的彩虹颜色会随着你的鼠标光标移动！第一步是制作一个网格。
- en: DRAWING A GRID OF OBJECTS
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制一个物体网格
- en: Many tasks involved in math and in creating games like Minesweeper require a
    grid. Grids are necessary for some of the models and all the cellular automata
    we’ll create in later chapters, so it’s worth learning how to write code for making
    a grid that we can reuse. To begin with, we’ll make a 12 × 12 grid of squares,
    evenly sized and spaced. Making a grid this size may seem like a time-consuming
    task, but in fact it’s easy to do using a loop.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 许多涉及数学的任务以及像扫雷这样的游戏都需要使用网格。网格对于我们在后续章节中将创建的一些模型和所有的细胞自动机来说都是必要的，因此值得学习如何编写可重复使用的网格代码。首先，我们将制作一个12
    × 12的方格网，方格大小均匀且间隔相等。制作这个大小的网格可能看起来是一个费时的任务，但事实上，使用循环很容易实现。
- en: 'Open a new Processing sketch and save as *colorGrid.pyde*. Too bad we used
    the name “grid” previously. We’ll make a 20 × 20 grid of squares on a white background.
    The squares need to be `rect`, and we need to use a `for` loop within a `for`
    loop to make sure they are all the same size and spaced equally. Also, we need
    our 25 × 25 pixel squares to be drawn every 30 pixels, using this line:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的Processing草图并保存为*colorGrid.pyde*。真可惜我们之前用了“grid”这个名字。我们将在白色背景上制作一个20 ×
    20的方格网。方格需要是`rect`，并且我们需要在一个`for`循环内再嵌套一个`for`循环，确保它们的大小相同且均匀间隔。此外，我们需要让我们的25
    × 25像素的方格每30像素绘制一次，使用以下代码：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As the `x` and `y` variables go up by 1, squares are drawn at 50-pixel intervals
    in two dimensions. We’ll start off, as usual, by writing our `setup()` and `draw()`
    functions, as in the previous sketch (see [Listing 5-10](ch05.xhtml#ch05list10)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`x`和`y`变量每增加1，方格将在两个维度上按50像素的间隔绘制。我们将像往常一样，从编写`setup()`和`draw()`函数开始，就像在上一个草图中一样（参见[列表5-10](ch05.xhtml#ch05list10)）。
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 5-10: The standard structure for a Processing sketch: `setup()` and
    `draw()`*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-10：Processing草图的标准结构：`setup()`和`draw()`*'
- en: This sets the size of the window at 600 by 600 pixels, and sets the background
    color to white. Next we’ll create a nested loop, where two variables will both
    go from 0 to 19, for a total of 20 numbers, since we want 20 rows of 20 squares.
    [Listing 5-11](ch05.xhtml#ch05list11) shows the code that creates the grid.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将窗口的大小设置为600 × 600像素，并将背景颜色设置为白色。接下来，我们将创建一个嵌套循环，其中两个变量都从0到19，总共20个数字，因为我们需要20行20个方格。[列表5-11](ch05.xhtml#ch05list11)展示了创建网格的代码。
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 5-11: The code for a grid*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-11：网格的代码*'
- en: This should create a 20 × 20 grid of squares, as you can see in [Figure 5-12](ch05.xhtml#ch05fig12).
    Time to add some colors to our grid.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会创建一个20 × 20的方格网，如[图5-12](ch05.xhtml#ch05fig12)所示。现在是时候给我们的网格添加一些颜色了。
- en: '![image](../images/f091-01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f091-01.jpg)'
- en: '*Figure 5-12: A 20 × 20 grid!*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-12：一个20 × 20的网格！*'
- en: ADDING THE RAINBOW COLOR TO OBJECTS
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为对象添加彩虹色
- en: Processing’s `colorMode()` function helps us add some cool color to our sketches!
    It’s used to switch between the RGB and HSB modes. Recall that RGB uses three
    numbers indicating amounts of red, green, and blue. In HSB, the three numbers
    represent levels of hue, saturation, and brightness. The only one we need to change
    here is the first number, which represents the hue. The other two numbers can
    be the maximum value, 255\. [Figure 5-13](ch05.xhtml#ch05fig13) shows how to make
    rainbow colors by changing only the first value, the hue. Here, the 10 squares
    have the hue values shown in the figure, with 255 for saturation and 255 for brightness.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Processing的`colorMode()`函数帮助我们为草图添加一些酷炫的颜色！它用于在RGB和HSB模式之间切换。回想一下，RGB使用三个数字表示红、绿、蓝的数量；而在HSB中，三个数字分别表示色调、饱和度和亮度。这里我们需要改变的只有第一个数字，也就是色调值。其他两个数字可以设置为最大值255。[图
    5-13](ch05.xhtml#ch05fig13)展示了通过仅更改第一个值——色调来创建彩虹色。这里，10个方块的色调值如图所示，饱和度为255，亮度为255。
- en: '![image](../images/f091-02.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f091-02.jpg)'
- en: '*Figure 5-13: The colors of the rainbow using HSB mode and changing the hue
    value*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-13：使用HSB模式并更改色调值来显示彩虹色*'
- en: 'Since we’re locating the rectangles at `(30*x,30*y)` in [Listing 5-11](ch05.xhtml#ch05list11),
    we’ll create a variable that measures the distance of the mouse from that location:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在[代码清单 5-11](ch05.xhtml#ch05list11)中将矩形放置在`(30*x,30*y)`位置，我们将创建一个变量来测量鼠标与该位置的距离：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Processing has a `dist()` function that finds the distance between two points,
    and in this case it’s the distance between the square and the mouse. It saves
    the distance to a variable called `d`, and we’ll link the hue to that variable.
    [Listing 5-12](ch05.xhtml#ch05list12) shows the changes to the code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Processing有一个`dist()`函数，用来计算两点之间的距离，在这个例子中是方块和鼠标之间的距离。它将距离保存在一个叫做`d`的变量中，我们将色调与这个变量关联。[代码清单
    5-12](ch05.xhtml#ch05list12)展示了代码的变化。
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-12: Using the `dist()` function*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 5-12：使用`dist()`函数*'
- en: We insert the `colorMode()` function and pass `HSB` to it ➊. In the `draw()`
    function, we set the background to black first ➋. Then we calculate the distance
    from the mouse to the square, which is at `(30*x,30*y)` ➌. In the next line, we
    set the fill color using HSB numbers. The hue value is half the distance, while
    the saturation and brightness numbers are both 255, the maximum.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们插入`colorMode()`函数，并传递`HSB`给它 ➊。在`draw()`函数中，我们首先将背景设为黑色 ➋。然后我们计算鼠标与方块之间的距离，方块位于`(30*x,30*y)`位置
    ➌。接着，在下一行中，我们使用HSB值设置填充颜色。色调值是距离的一半，而饱和度和亮度都设为255，即最大值。
- en: 'The hue is the only thing we change: we update the hue according to the distance
    the rectangle is from the mouse. We do this with the `dist()` function, which
    takes four arguments: the x- and y-coordinates of two points. It returns the distance
    between the points.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 色调是我们唯一需要更改的：我们根据矩形与鼠标的距离来更新色调。我们用`dist()`函数来做到这一点，它有四个参数：两个点的x和y坐标，返回两个点之间的距离。
- en: Run this code and you should see a very colorful design that changes colors
    according to the mouse’s location, as shown in [Figure 5-14](ch05.xhtml#ch05fig14).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，你应该能看到一个非常多彩的设计，它会根据鼠标的位置变化颜色，如[图 5-14](ch05.xhtml#ch05fig14)所示。
- en: Now that you’ve learned how to add colors to your objects, let’s explore how
    we can create more complicated shapes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何为对象添加颜色，让我们来探讨如何创建更复杂的形状。
- en: '![image](../images/f092-01.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f092-01.jpg)'
- en: '*Figure 5-14: Adding colors to your grid*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-14：为网格添加颜色*'
- en: DRAWING COMPLEX PATTERNS USING TRIANGLES
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用三角形绘制复杂图案
- en: '![image](../images/f093-01.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f093-01.jpg)'
- en: '*Figure 5-15: Sketch of 90 rotating equilateral triangles by Roger Antonsen.
    See it in motion at* [https://rantonse.no/en/art/2016-11-30](https://rantonse.no/en/art/2016-11-30).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-15：Roger Antonsen绘制的90个旋转的等边三角形草图。查看动态图像请访问* [https://rantonse.no/en/art/2016-11-30](https://rantonse.no/en/art/2016-11-30)。'
- en: In this section, we create more complicated, Spirograph-style patterns using
    triangles. For example, take a look at the sketch made up of rotating triangles
    in [Figure 5-15](ch05.xhtml#ch05fig15), created by the University of Oslo’s Roger
    Antonsen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用三角形创建更复杂的、类似螺旋图形的模式。例如，看看[图 5-15](ch05.xhtml#ch05fig15)中的草图，它是由奥斯陆大学的Roger
    Antonsen创建的，包含旋转的三角形。
- en: The original design moves, but in this book you’ll have to imagine all the triangles
    rotating. This sketch blew me away! Although this design looks very complicated,
    it’s not that difficult to make. Remember Nasrudin’s joke about the brick from
    the beginning of the chapter? Like Nasrudin’s house, this complicated design is
    just a collection of identical shapes. But what shape? Antonsen gave us a helpful
    clue to creating this design when he named the sketch “90 Rotating Equilateral
    Triangles.” It tells us that all we have to do is figure out how to draw an equilateral
    triangle, rotate it, and then repeat that for a total of 90 triangles. Let’s first
    discuss how to draw an equilateral triangle using the `triangle()` function. To
    start, open a new Processing sketch and name it *triangles.pyde*. The code in
    [Listing 5-13](ch05.xhtml#ch05list13) shows one way to create a rotating triangle
    but not an equilateral one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 原始设计是会动的，但在本书中，你需要想象所有的三角形都在旋转。这幅草图让我震撼！虽然这个设计看起来非常复杂，但其实并不难制作。记得本章开头纳斯鲁丁的关于砖块的笑话吗？就像纳斯鲁丁的房子一样，这个复杂的设计其实只是由相同形状的图形组成。那么，是什么形状呢？安东森在命名这幅草图为“90个旋转的等边三角形”时给了我们一个有用的线索。这告诉我们，我们需要做的就是弄清楚如何画一个等边三角形，旋转它，然后重复这一过程，共画90个三角形。让我们先讨论一下如何使用`triangle()`函数画一个等边三角形。首先，打开一个新的Processing草图，并将其命名为*triangles.pyde*。[清单5-13](ch05.xhtml#ch05list13)中的代码展示了创建旋转三角形的一种方法，但并不是等边三角形。
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-13: Drawing a rotating triangle, but not the right kind*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单5-13：绘制旋转三角形，但不是正确的那种*'
- en: 'Listing 5-13 uses the lessons you learned previously: it creates a `t` variable
    (for time), translates to where we want the triangle to be, rotates the grid,
    and then draws the triangle. Finally, it increments `t`. When you run this code,
    you should see something like [Figure 5-16](ch05.xhtml#ch05fig16).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-13使用了你之前学到的知识：它创建了一个`t`变量（用于时间），平移到我们希望三角形所在的位置，旋转坐标网格，然后绘制三角形。最后，它递增`t`。运行这段代码后，你应该能看到类似于[图5-16](ch05.xhtml#ch05fig16)的效果。
- en: '![image](../images/f094-01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f094-01.jpg)'
- en: '*Figure 5-16: Rotating a triangle around one of its vertices*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-16：围绕一个顶点旋转三角形*'
- en: As you can see in [Figure 5-16](ch05.xhtml#ch05fig16), the triangle rotates
    around one of its *vertices*, or points, and thus creates a circle with the outer
    point. You’ll also notice that this is a right triangle (a triangle containing
    a 90-degree angle), not an equilateral one.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图5-16](ch05.xhtml#ch05fig16)所示，三角形围绕其*顶点*（或角点）旋转，从而形成一个外点构成的圆形。你还会注意到，这个是一个直角三角形（包含90度角的三角形），而不是等边三角形。
- en: To re-create Antonsen’s sketch, we need to draw an equilateral triangle, which
    is a triangle with equal sides. We also need to find the center of the equilateral
    triangle to be able to rotate it about its center. To do this, we need to find
    the location of the three vertices of the triangle. Let’s discuss how to draw
    an equilateral triangle by locating it at its center and specifying the location
    of its vertices.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新创建安东森的草图，我们需要绘制一个等边三角形，它是一个边长相等的三角形。我们还需要找到等边三角形的中心，以便能够围绕其中心旋转它。为此，我们需要找到三角形三个顶点的位置。接下来，让我们讨论如何通过定位三角形的中心来绘制等边三角形，并指定其顶点的位置。
- en: A 30-60-90 TRIANGLE
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 30-60-90 三角形
- en: '![image](../images/f094-02.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f094-02.jpg)'
- en: '*Figure 5-17: An equilateral triangle divided into three equal parts*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-17：一个被分成三个相等部分的等边三角形*'
- en: 'To find the location of the three vertices of our equilateral triangle, we’ll
    review a particular type of triangle you’ve likely seen in geometry class: the
    *30-60-90 triangle*, which is a special *right triangle*. First, we need an equilateral
    triangle, as shown in [Figure 5-17](ch05.xhtml#ch05fig17).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到我们等边三角形的三个顶点的位置，我们将复习一种你在几何课上可能见过的特殊三角形：*30-60-90三角形*，它是一种特殊的*直角三角形*。首先，我们需要一个等边三角形，如[图5-17](ch05.xhtml#ch05fig17)所示。
- en: 'This equilateral triangle is made up of three equal parts. The point in the
    middle is the center of the triangle, with the three dissecting lines meeting
    at 120 degree angles. To draw a triangle in Processing, we give the `triangle()`
    function six numbers: the x- and y-coordinates of all three vertices. To find
    the coordinates of the vertices of the equilateral triangle shown in [Figure 5-17](ch05.xhtml#ch05fig17),
    let’s cut the bottom triangle in half, as shown in [Figure 5-18](ch05.xhtml#ch05fig18).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个等边三角形由三个相等的部分组成。中间的点是三角形的中心，三条分割线在120度角相交。为了在Processing中绘制三角形，我们给`triangle()`函数六个数字：三个顶点的x和y坐标。为了找到[图5-17](ch05.xhtml#ch05fig17)中所示等边三角形的顶点坐标，我们将底部三角形对半切割，如[图5-18](ch05.xhtml#ch05fig18)所示。
- en: '![image](../images/f095-01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f095-01.jpg)'
- en: '*Figure 5-18: Dividing up the equilateral triangle into special triangles*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-18：将等边三角形划分为特殊三角形*'
- en: Dividing the bottom triangle in half creates two right triangles, which are
    classic 30-60-90 triangles. As you might recall, the ratio between the sides of
    a 30-60-90 triangle can be expressed as shown in [Figure 5-19](ch05.xhtml#ch05fig19).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将底部三角形对半切割会创建两个直角三角形，它们是经典的30-60-90三角形。如你所记得，30-60-90三角形的边长比可以像[图5-19](ch05.xhtml#ch05fig19)所示那样表示。
- en: '![image](../images/f095-02.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f095-02.jpg)'
- en: '*Figure 5-19: The ratios of the sides in a 30-60-90 triangle, from the legend
    on an SAT test*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-19：30-60-90三角形中边长的比例，来自SAT考试的图例*'
- en: If we call the length of the smaller leg *x*, the hypotenuse is twice that length,
    or 2*x*, and the longer leg is *x* times the square root of 3, or approximately
    1.732*x*. We’re going to be creating our function using the length from the center
    of the big equilateral triangle in [Figure 5-18](ch05.xhtml#ch05fig18) to one
    of its vertices, which happens to be the hypotenuse of the 30-60-90 triangle.
    That means we can measure everything in terms of that length. For example, if
    we call the hypotenuse `length`, then the smaller leg will be half that length,
    or `length/2`. Finally, the longer leg will be `length` divided by 2 times the
    square root of 3\. [Figure 5-20](ch05.xhtml#ch05fig20) zooms in on the 30-60-90
    triangle.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将较短的直角边的长度称为*x*，那么斜边是该长度的两倍，即2*x*，而较长的直角边是*x*乘以3的平方根，即大约1.732*x*。我们将使用从[图5-18](ch05.xhtml#ch05fig18)中大等边三角形的中心到其中一个顶点的长度来创建我们的函数，而该顶点恰好是30-60-90三角形的斜边。这意味着我们可以以该长度为单位来测量所有其他长度。例如，如果我们将斜边称为`length`，那么较短的直角边将是该长度的一半，即`length/2`。最后，较长的直角边将是`length`除以2乘以3的平方根。[图5-20](ch05.xhtml#ch05fig20)放大了30-60-90三角形。
- en: '![image](../images/f095-03.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f095-03.jpg)'
- en: '*Figure 5-20: The 30-60-90 triangle up close and personal*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-20：30-60-90三角形的近距离观察*'
- en: As you can see, a 30-60-90 triangle has internal angles of 30, 60, and 90 degrees,
    and the lengths of the sides are in known proportions. You may be familiar with
    this from the Pythagorean Theorem, which will come up again shortly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，30-60-90三角形的内部角度为30度、60度和90度，边长的比例是已知的。你可能对这个比例很熟悉，它出现在勾股定理中，稍后我们将再次提到。
- en: We’ll call the distance from the center of the larger equilateral triangle to
    its vertex the “length,” which is also the *hypotenuse* of the 30-60-90 triangle.
    You’ll need to know the ratios between the lengths of the sides of this special
    triangle in order to find the three vertices of the equilateral triangle with
    respect to the center—you can draw it (the big equilateral triangle we’re trying
    to draw) by specifying where each point of the triangle should be.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从较大等边三角形的中心到其顶点的距离称为“长度”，这也是30-60-90三角形的*斜边*。你需要知道这个特殊三角形的边长比例，以便找到相对于中心的等边三角形的三个顶点——你可以通过指定三角形每个点的位置来绘制它（我们要绘制的大等边三角形）。
- en: The shorter leg of the right triangle opposite the 30 degree angle is always
    half the hypotenuse, and the longer leg is the measure of the shorter leg times
    the square root of 3\. So if we use the center point for drawing the big equilateral
    triangle, the coordinates of the three vertices would be as shown in [Figure 5-21](ch05.xhtml#ch05fig21).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 直角三角形中与30度角相对的较短的直角边总是斜边的一半，而较长的直角边是较短的直角边乘以3的平方根。所以，如果我们使用中心点来绘制大的等边三角形，那么三个顶点的坐标将如[图5-21](ch05.xhtml#ch05fig21)所示。
- en: '![image](../images/f096-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f096-01.jpg)'
- en: '*Figure 5-21: The vertices of the equilateral triangle*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-21：等边三角形的顶点*'
- en: As you can see, because this triangle is made up of 30-60-90 triangles on all
    sides, we can use the special relation between them to figure out how far each
    vertex of the equilateral triangle should be from the origin.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，因为这个三角形由所有边上的30-60-90三角形组成，我们可以利用它们之间的特殊关系来确定每个等边三角形的顶点应该离原点多远。
- en: DRAWING AN EQUILATERAL TRIANGLE
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制等边三角形
- en: Now we can use the vertices we derived from the 30-60-90 triangle to create
    an equilateral triangle, using the code in [Listing 5-14](ch05.xhtml#ch05list14).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用从30-60-90三角形推导出的顶点来创建一个等边三角形，使用[列表 5-14](ch05.xhtml#ch05list14)中的代码。
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 5-14: The complete code for making a rotating equilateral triangle*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-14：制作旋转等边三角形的完整代码*'
- en: 'First, we write the `tri()` function to take the variable `length` ➊, which
    is the hypotenuse of the special 30-60-90 triangles we cut the equilateral triangle
    into. We then make a triangle using the three vertices we found. Inside the call
    to the `triangle()` function ➋, we specify the location of each of the three vertices
    of the triangle: `(0,-length)`, `(-length*sqrt(3)/2, length/2)`, and `(length*sqrt(3)/2,
    length/2)`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们编写`tri()`函数，传入变量`length` ➊，它是我们将等边三角形切割成的特殊30-60-90三角形的斜边。然后，我们使用找到的三个顶点来构建一个三角形。在对`triangle()`函数的调用
    ➋ 中，我们指定了三角形三个顶点的位置：`(0,-length)`、`(-length*sqrt(3)/2, length/2)`和`(length*sqrt(3)/2,
    length/2)`。
- en: When you run the code, you should see something like [Figure 5-22](ch05.xhtml#ch05fig22).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，你应该看到类似于[图 5-22](ch05.xhtml#ch05fig22)的内容。
- en: '![image](../images/f097-01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f097-01.jpg)'
- en: '*Figure 5-22: A rotating equilateral triangle!*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-22：一个旋转的等边三角形！*'
- en: 'Now we can cover up all the triangles created during rotation by adding this
    line to the beginning of the `draw()` function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在`draw()`函数的开头添加这一行来遮掩旋转过程中创建的所有三角形：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This should erase all the rotating triangles except for one, so we just have
    a single equilateral triangle on the screen. All we have to do is put 90 of them
    in a circle, just like we did earlier in this chapter, using the `rotate()` function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会擦除所有旋转三角形，除了一个，因此屏幕上只会显示一个等边三角形。我们只需要像本章之前那样，用`rotate()`函数将90个三角形放置在一个圆圈中。
- en: 'EXERCISE 5-1: SPIN CYCLE'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 5-1：旋转周期
- en: Create a circle of equilateral triangles in a Processing sketch and rotate them
    using the `rotate()` function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing草图中创建一个等边三角形的圆圈，并使用`rotate()`函数旋转它们。
- en: DRAWING MULTIPLE ROTATING TRIANGLES
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制多个旋转三角形
- en: Now that you’ve learned how to rotate a single equilateral triangle, we need
    to figure out how to arrange multiple equilateral triangles into a circle. This
    is similar to what you created while rotating squares, but this time we’ll use
    our `tri()` function. Enter the code in [Listing 5-15](ch05.xhtml#ch05list15)
    in place of the `def draw()` section in Processing and then run it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何旋转一个等边三角形，我们需要弄清楚如何将多个等边三角形排列成一个圆圈。这与旋转正方形时的创建方式类似，但这次我们将使用我们的`tri()`函数。将[列表
    5-15](ch05.xhtml#ch05list15)中的代码替换为Processing中的`def draw()`部分，然后运行它。
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 5-15: Creating 90 rotating triangles*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-15：创建90个旋转三角形*'
- en: At ➊, we use the `for` loop to arrange 90 triangles around the circle, making
    sure they’re evenly spaced by dividing 360 by 90\. Then at ➋ we use `pushMatrix()`
    to save this position before moving the grid around. At the end of the loop at
    ➌ we use `popMatrix()` to return to the saved position. In the `tri()` function
    at ➍, we add the `noFill()` line to make the triangles transparent.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们使用`for`循环将90个三角形排列在圆圈中，确保它们均匀间隔，通过将360除以90来实现。然后在 ➋ 处，我们使用`pushMatrix()`在移动网格之前保存当前位置。在循环末尾的
    ➌ 处，我们使用`popMatrix()`返回到保存的位置。在 ➍ 处的`tri()`函数中，我们添加了`noFill()`这一行来使三角形透明。
- en: Now we have 90 rotating transparent triangles, but they’re all rotating in exactly
    the same way. It’s kind of cool, but not as cool as Antonsen’s sketch yet. Next,
    you’ll learn how to make each triangle rotate a little differently from the adjacent
    ones to make the pattern more interesting.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了90个旋转的透明三角形，但它们的旋转方式完全相同。虽然有点酷，但还不如Antonsen的草图那么酷。接下来，你将学会如何让每个三角形与相邻的三角形稍微不同地旋转，以使图案更加有趣。
- en: PHASE-SHIFTING THE ROTATION
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旋转的相位偏移
- en: 'We can change the pattern in which the triangles rotate with a *phase shift*,
    which makes each triangle lag a little bit behind its neighbor, giving the sketch
    a “wave” or “cascade” effect. Each triangle has been assigned a number in the
    loop, represented by `i`. We need to add `i` to `t` in the `rotate(radians(t))`
    function, like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过*相位偏移*来改变三角形旋转的方式，这使得每个三角形在相邻的三角形后面稍微滞后，从而赋予图形“波浪”或“级联”效果。每个三角形在循环中都有一个编号，表示为`i`。我们需要在`rotate(radians(t))`函数中将`i`加到`t`上，像这样：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When you run this, you should see something like [Figure 5-23](ch05.xhtml#ch05fig23).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个代码时，你应该看到类似于[图5-23](ch05.xhtml#ch05fig23)的效果。
- en: '![image](../images/f099-01.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f099-01.jpg)'
- en: '*Figure 5-23: Rotating triangles with phase shift*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-23：带有相位偏移的旋转三角形*'
- en: 'Notice there’s a break in the pattern on the right side of the screen. This
    break in the pattern is caused by the phase shifts not matching up from the beginning
    triangle to the last triangle. We want a nice, seamless pattern, so we have to
    make the phase shifts add up to a multiple of 360 degrees to complete the circle.
    Because there are 90 triangles in the design, we’ll divide 360 by 90 and multiply
    that by `i`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到屏幕右侧的图案有一个断裂。这个图案的断裂是因为从第一个三角形到最后一个三角形的相位偏移没有对齐。我们希望有一个平滑无缝的图案，因此必须确保相位偏移加起来是360度的倍数，才能完成圆形。由于设计中有90个三角形，我们将360除以90，再乘以`i`：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It’s easy enough to calculate 360/90, which is 4, and then use that number to
    plug into the code, but I’m leaving the expression in because we’ll need it in
    case we want to change the number of triangles later. For now, this should create
    a nice seamless pattern, as shown in [Figure 5-24](ch05.xhtml#ch05fig24).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 计算360/90（即4）并将这个数字代入代码很容易，但我保留了这个表达式，因为如果以后我们想改变三角形的数量时，它会用得上。现在，这应该能够创建一个平滑的无缝图案，如[图5-24](ch05.xhtml#ch05fig24)所示。
- en: '![image](../images/f100-01.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f100-01.jpg)'
- en: '*Figure 5-24: Seamlessly rotating triangles with phase shift*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-24：带有相位偏移的无缝旋转三角形*'
- en: By making our phase shifts add up to a multiple of 360, we were able to remove
    the break in the pattern.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使我们的相位偏移加起来成为360的倍数，我们成功地去除了图案中的断裂。
- en: FINALIZING THE DESIGN
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完成设计
- en: To make the design look more like the one in [Figure 5-15](ch05.xhtml#ch05fig15),
    we need to change the phase shift a little. Play around with it yourself to see
    how you can change the look of the sketch!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让设计看起来更像[图5-15](ch05.xhtml#ch05fig15)中的设计，我们需要稍微调整相位偏移。自己试试看如何改变草图的外观！
- en: 'Here, we’re going to change the phase shift by multiplying `i` by 2, which
    will increase the shift between each triangle and its neighbor. Change the `rotate()`
    line in your code to the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过将`i`乘以2来改变相位偏移，这将增加每个三角形与相邻三角形之间的偏移。在代码中的`rotate()`行改为以下内容：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After making this change, run the code. As you can see in [Figure 5-25](ch05.xhtml#ch05fig25),
    our design now looks very close to the design we were trying to re-create.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 做出这个更改后，运行代码。正如[图5-25](ch05.xhtml#ch05fig25)所示，我们的设计现在看起来非常接近我们想要重新创建的设计。
- en: '![image](../images/f101-01.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f101-01.jpg)'
- en: '*Figure 5-25: Re-creation of Antonsen’s “90 Rotating Equilateral Triangles”
    from [Figure 5-15](ch05.xhtml#ch05fig15)*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-25：重新创建Antonsen的“90个旋转的等边三角形”，来自[图5-15](ch05.xhtml#ch05fig15)*'
- en: Now that you’ve learned how to re-create a complicated design like this, try
    the next exercise to test your transformation skills!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何重新创建这样的复杂设计，尝试下一个练习来测试你的变换技能！
- en: 'EXERCISE 5-2: RAINBOW TRIANGLES'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 练习5-2：彩虹三角形
- en: Color each triangle of the rotating triangle sketch using `stroke()`. It should
    look like this.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stroke()`为旋转三角形草图中的每个三角形上色。它应该像这样。
- en: '![image](../images/f101-02.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f101-02.jpg)'
- en: SUMMARY
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to draw shapes like circles, squares, and triangles
    and arrange them into different patterns using Processing’s built-in transformation
    functions. You also learned how to make your shapes dynamic by animating your
    graphics and adding color. Just like how Nasrudin’s house was just a collection
    of bricks, the complicated code examples in this chapter are just a collection
    of simpler shapes or functions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何绘制圆形、正方形和三角形，并使用Processing的内置变换函数将它们排列成不同的图案。你还学习了如何通过动画化图形和添加颜色使形状具有动态效果。就像Nasrudin的房子只是一堆砖块一样，本章中的复杂代码示例也只是一些更简单的形状或函数的组合。
- en: In the next chapter, you’ll build on what you learned in this chapter and expand
    your skills to using trigonometric functions like sine and cosine. You’ll draw
    even cooler designs and write new functions to create even more complicated behaviors,
    like leaving a trail and creating any shape from a bunch of vertices.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将基于本章所学的内容，扩展你的技能，学习使用三角函数，如正弦和余弦。你将绘制更加酷炫的设计，并编写新的函数，创造出更复杂的行为，比如留下轨迹并从一组顶点创建任意形状。
