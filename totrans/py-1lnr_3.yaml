- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: DATA SCIENCE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学**
- en: '![Image](Images/comm-1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/comm-1.jpg)'
- en: The ability to analyze real-world data is one of the most sought-after skills
    in the 21st century. With the help of powerful hardware capabilities, algorithms,
    and ubiquitous sensing, data scientists create meaning from massive-scale raw
    data of weather statistics, financial transactions, customer behavior, and so
    much else. The largest companies in the world today—Google, Facebook, Apple, and
    Amazon—are essentially huge data-processing entities, with data at the heart of
    their business models.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 分析现实世界数据的能力是 21 世纪最受追捧的技能之一。在强大硬件能力、算法和无处不在的传感技术的帮助下，数据科学家从天气统计、金融交易、客户行为等大量原始数据中提取有意义的信息。如今世界上最大的公司——谷歌、Facebook、苹果和亚马逊——本质上是庞大的数据处理实体，数据是它们商业模式的核心。
- en: This chapter equips you with the skills to process and analyze numerical data
    by using Python’s library for numerical calculations, *NumPy*. I’ll give you 10
    practical problems and explain how to solve them in a single line of NumPy code.
    Because NumPy is the basis of many high-level libraries for data science and machine
    learning (Pandas, scikit-learn, and TensorFlow, for example), carefully studying
    this chapter will increase your market value in today’s data-driven economy. So,
    give me your full attention!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你掌握使用 Python 的数值计算库*NumPy*来处理和分析数值数据的技能。我将给你提供 10 个实际问题，并解释如何用一行 NumPy
    代码来解决它们。因为 NumPy 是许多高层数据科学和机器学习库（如 Pandas、scikit-learn 和 TensorFlow 等）的基础，仔细学习本章将提升你在数据驱动的现代经济中的市场竞争力。所以，请集中注意力！
- en: '**Basic Two-Dimensional Array Arithmetic**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基本的二维数组运算**'
- en: Here you’ll solve a day-to-day accounting task in a single line of code. I’ll
    introduce some elementary functionalities of NumPy, Python’s wildly important
    library for numerical computations and data science.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将用一行代码解决一个日常的会计任务。我将介绍 NumPy 的一些基本功能，NumPy 是 Python 用于数值计算和数据科学的重要库。
- en: '***The Basics***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: At the heart of the NumPy library are *NumPy arrays*, which hold the data you
    want to manipulate, analyze, and visualize. Many higher-level data science libraries
    like Pandas build upon NumPy arrays, either implicitly or explicitly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 库的核心是*NumPy 数组*，它们存储你想要处理、分析和可视化的数据。许多更高级的数据科学库（如 Pandas）都建立在 NumPy 数组之上，或者隐式或显式地依赖于它。
- en: 'NumPy arrays are similar to Python lists but with some added bonuses. First,
    NumPy arrays have a smaller memory footprint and are faster in most instances.
    Second, NumPy arrays are more convenient when accessing more than two axes, known
    as *multidimensional* data (multidimensional lists are difficult to access and
    modify). Because a NumPy array can consist of more than one axis, we think of
    arrays in terms of *dimensions*: an array with two axes is a two-dimensional array.
    Third, NumPy arrays have more powerful access functionality, such as broadcasting,
    which you’ll learn more about in this chapter.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组类似于 Python 列表，但具有一些额外的优点。首先，NumPy 数组占用更少的内存，并且在大多数情况下运行速度更快。其次，当访问多个维度时，NumPy
    数组更加方便，这些数据被称为*多维*数据（多维列表难以访问和修改）。由于 NumPy 数组可以包含多个维度，我们通常从*维度*的角度来看待数组：具有两个轴的数组是二维数组。第三，NumPy
    数组具有更强大的访问功能，例如广播（broadcasting），你将在本章中学习到更多相关内容。
- en: '[Listing 3-1](#list3-1) exemplifies how to create one-dimensional, two-dimensional,
    and three-dimensional NumPy arrays.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-1](#list3-1) 举例说明如何创建一维、二维和三维 NumPy 数组。'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 3-1: Creating 1D, 2D, and 3D arrays in NumPy*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-1：在 NumPy 中创建一维、二维和三维数组*'
- en: 'You start by importing the NumPy library into the namespace by using the de
    facto standard name for the library: `np`. After importing the library, you create
    a NumPy array by passing a standard Python list as an argument to the function
    `np.array()`. A one-dimensional array corresponds to a simple list of numerical
    values (in fact, NumPy arrays can contain other data types too, but we’ll focus
    on numbers here). A two-dimensional array corresponds to a nested *list of lists*
    of numerical values. A three-dimensional array corresponds to a nested *list of
    lists of lists* of numerical values. The number of opening and closing brackets
    gives you the dimensionality of the NumPy array.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先通过使用该库的事实标准名称 `np` 将 NumPy 库导入到命名空间中。导入库后，你可以通过将一个标准的 Python 列表作为参数传递给 `np.array()`
    函数来创建一个 NumPy 数组。一维数组对应于一个简单的数字值列表（事实上，NumPy 数组也可以包含其他数据类型，但我们在这里重点讨论数字）。二维数组对应于一个嵌套的
    *列表的列表*，其中包含数字值。三维数组对应于一个嵌套的 *列表的列表的列表*，其中包含数字值。括号的开闭数量可以告诉你 NumPy 数组的维度。
- en: NumPy arrays are more powerful than built-in Python lists. For instance, you
    can calculate basic arithmetic operators `+`, `-`, `*`, and `/` on two NumPy arrays.
    These *element-wise operations* combine two arrays `a` and `b` (for example, adding
    them together with the `+` operator) by combining each element of array `a` with
    the corresponding element of array `b`. In other words, an element-wise operation
    aggregates two elements that are at the same positions in the arrays `a` and `b`.
    [Listing 3-2](#list3-2) shows examples of basic arithmetic operations on two-dimensional
    arrays.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组比内置的 Python 列表更强大。例如，你可以对两个 NumPy 数组进行基本的算术运算符 `+`、`-`、`*` 和 `/`。这些
    *按元素操作* 将两个数组 `a` 和 `b`（例如，用 `+` 运算符将它们相加）按元素组合在一起，即将数组 `a` 中的每个元素与数组 `b` 中对应位置的元素进行组合。换句话说，按元素操作会聚合数组
    `a` 和 `b` 中处于相同位置的两个元素。[清单 3-2](#list3-2) 展示了对二维数组进行基本算术操作的示例。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 3-2: Basic arithmetic array operations*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-2：基本算术数组操作*'
- en: '**NOTE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When you apply NumPy operators to integer arrays, they try to generate integer
    arrays as results too. Only when dividing two integer arrays by using the division
    operator, *`a / b`*, will the result be a float array. This is indicated by the
    decimal points: *`1.`*, *`0.`*, and *`0.5`*.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你将 NumPy 运算符应用于整数数组时，它们也会尽量生成整数数组作为结果。只有在使用除法运算符 *`a / b`* 对两个整数数组进行除法时，结果才会是浮动数组。通过小数点可以看出这一点：*`1.`*，*`0.`*，和
    *`0.5`*。*'
- en: 'If you look closely, you’ll find that each operation combines two corresponding
    NumPy arrays element-wise. When adding two arrays, the result is a new array:
    each new value is the sum of the corresponding value from the first and the second
    array. The same holds true when you use subtraction, multiplication, and division,
    as shown.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现每个操作都将两个对应的 NumPy 数组按元素进行组合。当对两个数组进行加法时，结果是一个新数组：每个新值是第一个和第二个数组中对应值的和。减法、乘法和除法也同样如此，如下所示。
- en: NumPy provides a lot more capabilities for manipulating arrays, including the
    `np.max()` function, which calculates the *maximum* value of all values in a NumPy
    array. The `np.min()` function calculates the *minimum* value of all values in
    a NumPy array. The `np.average()` function calculates the *average* value of all
    values in a NumPy array.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了更多用于操作数组的功能，包括 `np.max()` 函数，它计算 NumPy 数组中所有值的 *最大* 值。`np.min()` 函数计算
    NumPy 数组中所有值的 *最小* 值。`np.average()` 函数计算 NumPy 数组中所有值的 *平均* 值。
- en: '[Listing 3-3](#list3-3) gives an example of these three operations.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-3](#list3-3) 给出了这三种操作的示例。'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 3-3: Calculating the maximum, minimum, and average value of a NumPy
    array*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-3：计算 NumPy 数组的最大值、最小值和平均值*'
- en: 'The maximum value of all values in the NumPy array is 2, the minimum value
    is 0, and the average is (1 + 0 + 0 + 1 + 1 + 1 + 2 + 0 + 0) / 9 = 2/3\. NumPy
    has many more powerful tools, but this is already enough to solve the following
    problem: how do we find the maximum after-tax income in a group of people, given
    their yearly salary and tax rates?'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组中所有值的最大值是 2，最小值是 0，平均值是 (1 + 0 + 0 + 1 + 1 + 1 + 2 + 0 + 0) / 9 = 2/3。NumPy
    还有许多更强大的工具，但这些已经足够解决以下问题：如何根据人们的年薪和税率，找到他们的最大税后收入？
- en: '***The Code***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: Let’s tackle this problem by using the salary data of Alice, Bob, and Tim. It
    seems like Bob has enjoyed the highest salary in the last three years. But is
    he actually bringing home the most money, considering the individual tax rates
    of our three friends? Take a look at [Listing 3-4](#list3-4).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Alice、Bob和Tim的薪资数据来解决这个问题。似乎在过去三年中，Bob的薪水最高。但考虑到我们三位朋友的个人税率，他是否真的是拿到最多钱的人呢？看一下[列表
    3-4](#list3-4)。
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-4: One-liner solution using basic array arithmetic*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-4：使用基本数组运算的单行解决方案*'
- en: 'Take a guess: what’s the output of this code?'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看：这段代码的输出是什么？
- en: '***How It Works***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'After importing the NumPy library, you put the data into a two-dimensional
    NumPy array with three rows (one row for each person: Alice, Bob, and Tim) and
    three columns (one column for each year: 2017, 2018, and 2019). You have two two-dimensional
    arrays: `salaries` holds the yearly incomes, and `taxation` holds the taxation
    rates for each person and year.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入NumPy库后，你将数据放入一个具有三行（每行代表一个人：Alice、Bob和Tim）和三列（每列代表一年：2017年、2018年和2019年）的二维NumPy数组中。你有两个二维数组：`salaries`保存每年的收入，`taxation`保存每个人和每年的税率。
- en: To calculate the after-tax income, you need to deduct the tax (as a dollar amount)
    from the gross income stored in the array `salaries`. For this, you use the overloaded
    NumPy operators `-` and `*`, which perform element-wise computations on the NumPy
    arrays.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算税后收入，你需要从总收入中扣除税额（以美元为单位），而这些数据存储在`薪资`数组中。为此，你使用了重载的NumPy运算符`-`和`*`，它们对NumPy数组执行元素级的计算。
- en: The element-wise multiplication of two multidimensional arrays is called the
    *Hadamard product*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 两个多维数组的元素级乘法叫做*Hadamard积*。
- en: '[Listing 3-5](#list3-5) shows how the NumPy array looks after deducting the
    taxes from the gross incomes.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-5](#list3-5)展示了从总收入中扣除税费后，NumPy数组的样子。'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 3-5: Basic array arithmetic*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-5：基本数组运算*'
- en: Here, you can see that Bob’s large income is significantly reduced after paying
    40 percent and 50 percent tax rates, shown in the second row.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到Bob的高收入在支付了40%和50%的税率后显著减少，这在第二行中展示。
- en: The code snippet prints the maximum value of this resulting array. The `np.max()`
    function simply finds the maximum value in the array, which you store in `max_income`.
    Thus, the maximum value is Tim’s $90,000 income in 2017, which is taxed at only
    10 percent—the result of the one-liner is `81.` (again, the dot indicates the
    float data type).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段打印了这个结果数组的最大值。`np.max()`函数简单地找出数组中的最大值，并将其存储在`max_income`中。因此，最大值是Tim在2017年的$90,000收入，他只需缴纳10%的税——这段单行代码的结果是`81.`（再次说明，点表示浮动数据类型）。
- en: You’ve used NumPy’s basic element-wise array arithmetic to analyze the taxation
    rates of a group of people. Let’s use the same example data set in applying intermediate
    NumPy concepts such as slicing and broadcasting.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用了NumPy的基本元素级数组运算来分析一组人的税率。现在让我们使用相同的示例数据集来应用NumPy的中级概念，如切片和广播。
- en: '**Working with NumPy Arrays: Slicing, Broadcasting, and Array Types**'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用NumPy数组：切片、广播和数组类型**'
- en: 'This one-liner demonstrates the power of three interesting NumPy features:
    slicing, broadcasting, and array types. Our data is an array of multiple professions
    and salaries. You’ll use the three concepts in combination to increase the salaries
    of just the data scientists by 10 percent every other year.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码展示了三个有趣的NumPy特性的强大功能：切片、广播和数组类型。我们的数据是一个包含多种职业和薪资的数组。你将结合这三种概念，在每隔一年就将数据科学家的薪资提高10%。
- en: '***The Basics***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: The crux of our problem is being able to change specific values in a NumPy array
    with many rows. You want to change every other value for one single row. Let’s
    explore the basics you need to know to be able to solve this problem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们问题的核心是如何在具有多行的NumPy数组中更改特定的值。你想要更改单一行中的每隔一个值。让我们探索一下你需要了解的基础知识，才能解决这个问题。
- en: '**Slicing and Indexing**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**切片和索引**'
- en: 'Indexing and slicing in NumPy are similar to indexing and slicing in Python
    (see [Chapter 2](ch02.xhtml#ch02)): you can access elements of a one-dimensional
    array by using the bracket operation `[]` to specify the index or index range.
    For example, the indexing operation `x[3]` returns the fourth element of the NumPy
    array `x` (because you access the first element with index 0).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy中的索引和切片与Python中的索引和切片类似（参见[第2章](ch02.xhtml#ch02)）：你可以使用括号操作`[]`来指定索引或索引范围，从而访问一维数组的元素。例如，索引操作`x[3]`返回NumPy数组`x`的第四个元素（因为第一个元素的索引是0）。
- en: You can also use indexing for a multidimensional array by specifying the index
    for each dimension independently and using comma-separated indices to access the
    different dimensions. For example, the indexing operation `y[0,1,2]` would access
    the first element of the first axis, the second element of the second axis, and
    the third element of the third axis. Note that this syntax would be invalid for
    multidimensional Python lists.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过为每个维度独立指定索引，并使用逗号分隔的索引来访问不同的维度，从而对多维数组进行索引。例如，索引操作`y[0,1,2]`将访问第一个轴的第一个元素，第二个轴的第二个元素，以及第三个轴的第三个元素。请注意，这种语法对于多维Python列表是无效的。
- en: Let’s move on to *slicing* in NumPy. Study the examples in [Listing 3-6](#list3-6)
    to master one-dimensional slicing in NumPy, and feel free to go back to [Chapter
    2](ch02.xhtml#ch02) to revisit basic Python slicing if you have difficulties understanding
    these examples.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍NumPy中的*切片*。研究[清单3-6](#list3-6)中的示例，掌握NumPy中的一维切片，如果在理解这些示例时遇到困难，可以随时回顾[第2章](ch02.xhtml#ch02)中的基本Python切片知识。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 3-6: One-dimensional slicing examples*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-6：一维切片示例*'
- en: The next step is to fully understand multidimensional slicing. Much as for indexing,
    you apply one-dimensional slicing separately for each axis (comma-separated) to
    select a range of elements along this axis. Take your time to thoroughly understand
    the examples in [Listing 3-7](#list3-7).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是彻底理解多维切片。与索引类似，你分别对每个轴应用一维切片（以逗号分隔）来选择该轴上元素的范围。花些时间彻底理解[清单3-7](#list3-7)中的示例。
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 3-7: Multidimensional slicing examples*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-7：多维切片示例*'
- en: Study [Listing 3-7](#list3-7) until you understand multidimensional slicing.
    You can perform two-dimensional slicing by using the syntax `a[`*`slice1`*`,`
    *`slice2`*`]`. For any additional dimension, add a comma-separated slicing operation
    (using the `start:stop` or `start:stop:step` slicing operators). Each slice selects
    an independent subsequence of the elements in its respective dimension. If you
    understand this basic idea, going from one-dimensional to multidimensional slicing
    is trivial.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 研究[清单3-7](#list3-7)，直到你理解多维切片。你可以通过使用语法`a[`*`slice1`*`,` *`slice2`*`]`来执行二维切片。对于任何额外的维度，添加逗号分隔的切片操作（使用`start:stop`或`start:stop:step`切片操作符）。每个切片选择其各自维度中元素的独立子序列。如果你理解了这个基本概念，从一维切片到多维切片就变得非常简单。
- en: '**Broadcasting**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**广播**'
- en: '*Broadcasting* describes the automatic process of bringing two NumPy arrays
    into the same shape so that you can apply certain element-wise operations (see
    “Slicing and Indexing” on [page 46](#page_46)). Broadcasting is closely related
    to the *shape attribute* of NumPy arrays, which in turn is closely related to
    the concept of axes. So, let’s dive into axes, shapes, and broadcasting next.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*广播*描述了将两个NumPy数组自动转换为相同形状的过程，从而可以应用某些按元素操作（参见“切片与索引”[第46页](#page_46)）。广播与NumPy数组的*形状属性*密切相关，而形状属性又与轴的概念紧密相关。因此，接下来让我们深入探讨轴、形状和广播。'
- en: Each array comprises several *axes*, one for each dimension ([Listing 3-8](#list3-8)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组包含多个*轴*，每个维度对应一个轴（[清单3-8](#list3-8)）。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 3-8: Axes and dimensionality of three NumPy arrays*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-8：三个NumPy数组的轴和维度*'
- en: 'Here, you can see three arrays: `a`, `b`, and `c`. The array attribute `ndim`
    stores the number of axes of this particular array. You simply print it to the
    shell for each array. Array `a` is one-dimensional, array `b` is two-dimensional,
    and array `c` is three-dimensional. Every array has an associated shape attribute,
    a tuple that gives you the number of elements in each axis. For a two-dimensional
    array, there are two values in the tuple: the number of rows and the number of
    columns. For higher-dimensional arrays, the *i*-th tuple value specifies the number
    of elements of the *i*-th axis. The number of tuple elements is therefore the
    dimensionality of the NumPy array.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到三个数组：`a`、`b` 和 `c`。数组的属性 `ndim` 存储这个特定数组的轴数。你只需为每个数组打印它。数组 `a` 是一维的，数组
    `b` 是二维的，数组 `c` 是三维的。每个数组都有一个相关的形状属性，它是一个元组，表示每个轴上元素的数量。对于二维数组，元组中有两个值：行数和列数。对于高维数组，*i*
    第个元组值指定第 *i* 轴上元素的数量。因此，元组中的元素个数就是 NumPy 数组的维度。
- en: '**NOTE**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you increase the dimensionality of an array (for example, you move from
    2D to 3D arrays), the new axis becomes axis 0, and the* i*-th axis of the low-dimensional
    array becomes the (*i *+ 1)-th axis of the high-dimensional array.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你增加数组的维度（例如，从二维数组转为三维数组），新的轴将成为轴 0，而低维数组的第* i *个轴将成为高维数组的第（*i* + 1）个轴。*'
- en: '[Listing 3-9](#list3-9) gives the shape attributes of the same arrays from
    [Listing 3-8](#list3-8).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-9](#list3-9) 给出了与 [清单 3-8](#list3-8) 中相同数组的形状属性。'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 3-9: The shape property of 1D, 2D, and 3D NumPy arrays*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-9：1D、2D 和 3D NumPy 数组的形状属性*'
- en: 'Here, you can see that the `shape` attributes contain much more information
    than the `ndim` attributes. Every `shape` attribute is a tuple with the number
    of elements along each axis:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `shape` 属性包含的信息比 `ndim` 属性多得多。每个 `shape` 属性都是一个元组，表示每个轴上元素的数量：
- en: Array `a` is one-dimensional, so the `shape` tuple has only a single element
    that represents the number of columns (four elements).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组 `a` 是一维的，因此 `shape` 元组只有一个元素，表示列数（四个元素）。
- en: Array `b` is two-dimensional, so the `shape` tuple has two elements that enumerate
    the number of rows and columns.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组 `b` 是二维的，因此 `shape` 元组有两个元素，分别列出行数和列数。
- en: Array `c` is three-dimensional, so the `shape` tuple has three elements—one
    for each axis. Axis 0 has two elements (each element is a two-dimensional array),
    axis 1 has three elements (each is a one-dimensional array), and axis 2 has three
    elements (each is an integer value).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组 `c` 是三维的，因此 `shape` 元组包含三个元素——每个轴一个元素。轴 0 有两个元素（每个元素是一个二维数组），轴 1 有三个元素（每个是一个一维数组），轴
    2 有三个元素（每个是一个整数值）。
- en: 'Now that you understand the `shape` attribute, it’ll be easier to grasp the
    general idea of broadcasting: bringing two arrays into the same shape by rearranging
    the data. Let’s see how broadcasting works. Broadcasting automatically fixes element-wise
    operations of NumPy arrays with different shapes. For example, the multiplication
    operator `*` usually performs element-wise multiplication when applied to NumPy
    arrays. But what happens if the left and right data don’t match (say, the left
    operator is a NumPy array, while the right is a float value)? In this case, rather
    than throwing an error, NumPy automatically creates a new array from the right-side
    data. The new array has the same size and dimensionality as the array on the left
    and contains the same float values.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你理解了 `shape` 属性，理解广播的基本概念会更容易：通过重新排列数据，将两个数组转换为相同的形状。我们来看一下广播是如何工作的。广播自动修正形状不同的
    NumPy 数组之间的逐元素操作。例如，乘法运算符 `*` 通常在应用于 NumPy 数组时执行逐元素乘法。但如果左右数据不匹配会发生什么呢（比如，左边的操作数是一个
    NumPy 数组，而右边是一个浮点值）？在这种情况下，NumPy 会自动从右侧数据创建一个新数组。这个新数组的大小和维度与左边的数组相同，且包含相同的浮点值。
- en: Broadcasting, therefore, is the act of converting a low-dimensional array into
    a higher-dimensional array to perform element-wise operations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，广播是将低维数组转换为高维数组以执行逐元素操作的过程。
- en: '**Homogenous Values**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**同质值**'
- en: 'NumPy arrays are *homogeneous*, meaning all values have the same type. Here
    is a non-exclusive list of possible array data types:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组是 *同质的*，这意味着所有的值都有相同的类型。以下是可能的数组数据类型的非详尽列表：
- en: '**`bool`** The Boolean data type in Python (1 byte)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**`bool`** Python 中的布尔数据类型（1 字节）'
- en: '**`int`** The integer data type in Python (default size: 4 or 8 bytes)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**`int`** Python 中的整数数据类型（默认大小：4 或 8 字节）'
- en: '**`float`** The float data type in Python (default size: 8 bytes)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**`float`** Python 中的浮点数据类型（默认大小：8 字节）'
- en: '**`complex`** The complex data type in Python (default size: 16 bytes)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**`complex`** Python 中的复数数据类型（默认大小：16 字节）'
- en: '**`np.int8`** An integer data type (1 byte)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**`np.int8`** 一个整数数据类型（1 字节）'
- en: '**`np.int16`** An integer data type (2 bytes)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**`np.int16`** 一个整数数据类型（2 字节）'
- en: '**`np.int32`** An integer data type (4 bytes)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**`np.int32`** 一个整数数据类型（4 字节）'
- en: '**`np.int64`** An integer data type (8 bytes)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**`np.int64`** 一个整数数据类型（8 字节）'
- en: '**`np.float16`** A float data type (2 bytes)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**`np.float16`** 一个浮点数据类型（2 字节）'
- en: '**`np.float32`** A float data type (4 bytes)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**`np.float32`** 一个浮点数据类型（4 字节）'
- en: '**`np.float64`** A float data type (8 bytes)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**`np.float64`** 一个浮点数据类型（8 字节）'
- en: '[Listing 3-10](#list3-10) shows how to create NumPy arrays with different types.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-10](#list3-10)展示了如何创建具有不同类型的 NumPy 数组。'
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-10: NumPy arrays with different types*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-10：具有不同类型的 NumPy 数组*'
- en: This code has two arrays, `a` and `b`. The first array `a` is of data type `np.int16`.
    The numbers are of type integer (there is no “dot” after the number). Specifically,
    when printing out the `dtype` property of array `a`, you get the result `int16`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有两个数组，`a` 和 `b`。第一个数组 `a` 的数据类型是 `np.int16`。这些数字是整数类型（数字后面没有“点”）。具体来说，当打印数组
    `a` 的 `dtype` 属性时，你会得到 `int16` 结果。
- en: The second array `b` is of data type `float64`. So even if you create the array
    based on a list of integers, NumPy will convert the array type to `np.float64`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数组 `b` 的数据类型是 `float64`。所以，即使你基于一个整数列表创建数组，NumPy 也会将数组类型转换为 `np.float64`。
- en: 'There are two important takeaways here: NumPy gives you control over the data
    type, and the data type of a NumPy array is homogeneous.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的要点：NumPy 让你控制数据类型，并且 NumPy 数组的数据类型是同质的。
- en: '***The Code***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: You have data for a variety of professions, and you want to increase the salaries
    of just the data scientists by 10 percent every other year. [Listing 3-11](#list3-11)
    presents the code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多个职业的数据，并且你希望每隔一年仅增加数据科学家的薪水 10%。[清单 3-11](#list3-11)展示了代码。
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 3-11: One-liner solution using slicing and slice assignments*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-11：使用切片和切片赋值的单行解决方案*'
- en: Take a minute and think about the output of this code snippet. What would you
    expect to change? What’s the data type of the resulting array? What is the output
    of this code?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间思考一下这段代码片段的输出。你预期会有什么变化？结果数组的数据类型是什么？这段代码的输出是什么？
- en: '***How It Works***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: The code snippet places you in the year 2024\. First, you create a NumPy array
    with each row holding the expected yearly salaries of one professional (data scientist,
    product manager, designer, or software engineer). Each column gives the respective
    future years’ salaries in 2025, 2026, and 2027\. The resulting NumPy array has
    four rows and three columns.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将你放在 2024 年。首先，你创建了一个 NumPy 数组，每一行代表一个专业人员（数据科学家、产品经理、设计师或软件工程师）的预期年薪。每一列对应未来几年的薪水，分别是
    2025、2026 和 2027 年。最终的 NumPy 数组有四行三列。
- en: 'You have funds available to reinforce the most important professionals in the
    company. You believe in the future of data science, so you decide to reward the
    hidden heroes of your company: the data scientists. You need to update the NumPy
    array so that only the data scientists’ salaries increase by 10 percent every
    other year (non-cumulatively), starting from the year 2025.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你有资金可以加强公司中最重要的专业人才。你相信数据科学的未来，所以你决定奖励公司中那些隐藏的英雄：数据科学家。你需要更新 NumPy 数组，使得从 2025
    年起，每隔一年数据科学家的薪资增加 10%（非累积），并且是从 2025 年开始。
- en: 'You develop the following beautiful one-liner:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你开发了以下这个漂亮的单行代码：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It looks simple and clean, and provides the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来简单且简洁，提供以下输出：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Though simple, your one-liner has three interesting and advanced concepts at
    play.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管很简单，你的单行代码包含了三个有趣且高级的概念。
- en: '**Slicing**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**切片**'
- en: 'First, you use the concept of *slices* and *slice assignment*. In the example,
    you use slicing to get every other value of the first row from the NumPy array
    `employees`. Then, you perform some modifications and update every other value
    of the first row by using slice assignment. Slice assignment uses the same syntax
    as slicing, with one crucial difference: you select the slice on the left of the
    assignment. These elements will be replaced by the elements specified on the right
    of the assignment operation. In the code snippet, you replace the content of the
    first row in the NumPy array with the updated salary data.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用了*切片*和*切片赋值*的概念。在这个例子中，你通过切片获取了NumPy数组`employees`第一行的每隔一个值。然后，进行一些修改，通过切片赋值更新第一行的每隔一个值。切片赋值使用与切片相同的语法，但有一个关键区别：你选择赋值操作左边的切片。这些元素将被赋值操作右边指定的元素所替换。在代码片段中，你用更新后的薪资数据替换了NumPy数组中第一行的内容。
- en: '**Broadcasting**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**广播**'
- en: 'Second, you use broadcasting, which automatically fixes element-wise operations
    of NumPy arrays with different shapes. In the one-liner, the left operator is
    a NumPy array, while the right is a float value. Again, NumPy automatically creates
    a new array, making it the same size and dimensionality as the array on the left
    and filling it, conceptually, with copies of the float value. In reality, NumPy
    performs a computation that looks more like the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你使用了广播，它会自动调整不同形状的NumPy数组之间的逐元素操作。在这一行代码中，左侧操作符是一个NumPy数组，而右侧是一个浮动值。同样，NumPy会自动创建一个新数组，使其与左侧数组的大小和维度相同，并在概念上填充该数组为浮动值的副本。实际上，NumPy会执行的计算更像如下：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Array Types**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**数组类型**'
- en: 'Third, you may have realized that the resulting data type is not float but
    integer, even if you are performing floating-point arithmetic. When you create
    the array, NumPy realizes it contains only integer values, and so assumes it to
    be an integer array. Any operation you perform on the integer array won’t change
    the data type, and NumPy will round down to integer values. Again, you can access
    the array’s type by using the `dtype` property:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你可能已经意识到，结果数据类型不是浮动类型，而是整数类型，即使你正在执行浮点运算。当你创建数组时，NumPy发现它只包含整数值，因此认为它是一个整数数组。你对整数数组进行的任何操作都不会改变数据类型，NumPy会将值四舍五入为整数。同样，你可以通过使用`dtype`属性来访问数组的类型：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In summary, you’ve learned about slicing, slice assignments, broadcasting,
    and NumPy array types—quite an accomplishment in a one-liner code snippet. Let’s
    build upon that by solving a small data science problem with real-world impact:
    detecting outliers in pollution measurements of various cities.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你已经学习了切片、切片赋值、广播和NumPy数组类型——在一行代码中取得了相当大的成就。接下来，我们将基于这个知识，通过解决一个具有现实世界影响的小型数据科学问题来进一步探讨：检测各个城市污染测量中的异常值。
- en: '**Conditional Array Search, Filtering, and Broadcasting to Detect Outliers**'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**条件数组搜索、筛选和广播以检测异常值**'
- en: In this one-liner, you’ll explore air-quality data of cities. Specifically,
    given a two-dimensional NumPy array with pollution measurements (columns) for
    multiple cities (rows), you’ll find the cities that have above-average pollution
    measurements. The skills you’ll acquire by reading this section are important
    in finding outliers in data sets.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行代码中，你将探讨各个城市的空气质量数据。具体而言，给定一个二维的NumPy数组，其中包含多个城市（行）的污染测量值（列），你将找出那些污染测量值超过平均水平的城市。通过阅读本节，你将掌握在数据集中查找异常值的重要技巧。
- en: '***The Basics***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础概念***'
- en: 'The Air Quality Index (AQI) measures the danger of adverse health effects and
    is commonly used to compare differences in cities’ air quality. In this one-liner,
    you’re going to look at the AQI of four cities: Hong Kong, New York, Berlin, and
    Montreal.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 空气质量指数（AQI）衡量对健康的不良影响风险，通常用于比较城市空气质量的差异。在这一行代码中，你将查看四个城市的AQI：香港、纽约、柏林和蒙特利尔。
- en: The one-liner finds above-average polluted cities, defined as cities that have
    a peak AQI value that is above the overall average among all the measurements
    of all cities.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码找出污染超过平均水平的城市，定义为那些其峰值AQI超过所有城市所有测量值的总体平均值的城市。
- en: An important element of our solution will be to find elements in a NumPy array
    that meet a certain condition. This is a common problem in data science you’ll
    use very often.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决方案的一个重要部分将是找出满足特定条件的NumPy数组中的元素。这是数据科学中非常常见的问题，你将经常使用它。
- en: So, let’s explore how to find array elements that meet a specific condition.
    NumPy offers the function `nonzero()` that finds indices of elements in an array
    that are, well, not equal to zero. [Listing 3-12](#list3-12) gives an example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来探讨一下如何找到满足特定条件的数组元素。NumPy提供了一个函数`nonzero()`，用于查找数组中不等于零的元素的索引。[示例 3-12](#list3-12)给出了一个例子。
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 3-12: The nonzero function*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-12：非零函数*'
- en: 'The result is a tuple of two NumPy arrays:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含两个NumPy数组的元组：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first array gives the row indices, and the second gives the column indices
    of the nonzero elements. There are four nonzero elements in the two-dimensional
    array: 1, 2, 2, and 3, found at positions `X[0,0]`, `X[1,1]`, `X[1,2]`, and `X[2,0]`
    in the original array.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数组给出了行索引，第二个数组给出了非零元素的列索引。在这个二维数组中有四个非零元素：1、2、2 和 3，分别位于原数组中的`X[0,0]`、`X[1,1]`、`X[1,2]`和`X[2,0]`位置。
- en: 'Now, how can you use `nonzero()` to find elements that meet a certain condition
    in your array? You’ll use another great NumPy feature: Boolean array operations
    with broadcasting (see [Listing 3-13](#list3-13))!'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何使用`nonzero()`来查找数组中满足某个条件的元素呢？你将使用NumPy的另一个强大功能：结合广播的布尔数组操作（参见[示例 3-13](#list3-13)）！
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 3-13: Broadcasting and element-wise Boolean operators in NumPy*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-13：在NumPy中使用广播和逐元素布尔操作符*'
- en: Broadcasting occurs as the integer value `2` is copied (conceptually) into a
    new array with the same shape as the array. NumPy then performs an element-wise
    comparison of each integer against the value `2` and returns the resulting Boolean
    array.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 广播发生时，整数值`2`会被复制（在概念上）到一个具有与原数组相同形状的新数组中。然后，NumPy对每个整数与值`2`进行逐元素比较，并返回结果布尔数组。
- en: In our main code, you’ll combine the `nonzero()` and Boolean array operation
    features to find elements that meet a certain condition.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主代码中，你将结合`nonzero()`函数和布尔数组操作来查找满足特定条件的元素。
- en: '***The Code***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: In [Listing 3-14](#list3-14),  you’re finding cities with above-average pollution
    peaks from a set of data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 3-14](#list3-14)中，你正在从一组数据中找到具有高于平均值的污染峰值的城市。
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 3-14: One-liner solution using broadcasting, Boolean operators, and
    selective indexing*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-14：使用广播、布尔操作符和选择性索引的一行解决方案*'
- en: See if you can determine what the output of this code would be.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能否判断出这段代码的输出是什么。
- en: '***How It Works***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The data array `X` contains four rows (one row for each city) and six columns
    (one column for each measurement unit—in this case, days). The string array `cities`
    contains the four names of the cities in the order they occur in the data array.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 数据数组`X`包含四行（每行对应一个城市）和六列（每列对应一个测量单位——在本例中是天数）。字符串数组`cities`包含四个城市的名称，按数据数组中出现的顺序排列。
- en: 'Here is the one-liner that finds the cities with above-average observed AQI
    values:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个一行代码，用于查找具有高于平均值的AQI值的城市：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You first need to understand the parts before you can understand the whole.
    To better understand the one-liner, let’s deconstruct it by starting from within.
    At the heart of the one-liner is the Boolean array operation (see [Listing 3-15](#list3-15)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要先理解各个部分，才能理解整体。为了更好地理解这行代码，让我们从内部开始逐步分析。该一行代码的核心是布尔数组操作（参见[示例 3-15](#list3-15)）。
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 3-15: Boolean array operation using broadcasting*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-15：使用广播的布尔数组操作*'
- en: You use a Boolean expression to bring both operands to the same shape with broadcasting.
    You use the function `np.average()` to compute the average AQI value of all NumPy
    array elements. The Boolean expression then performs an element-wise comparison
    to come up with a Boolean array that contains `True` if the respective measurement
    observed is an above-average AQI value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用布尔表达式通过广播将两个操作数调整为相同的形状。然后使用`np.average()`函数计算所有NumPy数组元素的平均AQI值。布尔表达式随后执行逐元素比较，生成一个布尔数组，如果相应的测量值是高于平均的AQI值，则该位置为`True`。
- en: By generating this Boolean array, you know precisely which elements satisfy
    the condition of being above-average and which elements don’t.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过生成这个布尔数组，你可以精确知道哪些元素满足高于平均值的条件，哪些元素不满足。
- en: 'Recall that Python’s `True` value is represented by the integer `1`, and `False` is
    represented by `0`. In fact, the `True` and `False` objects are of type `bool`,
    which is a subclass of `int`. Thus, every Boolean value is also an integer value.
    With this, you can use the function `nonzero()` to find all row and column indices
    that meet the condition, like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 记得Python中的`True`值由整数`1`表示，而`False`值由`0`表示。事实上，`True`和`False`对象是`bool`类型，它是`int`的子类。因此，每个布尔值也是一个整数值。有了这个，你可以使用`nonzero()`函数找到满足条件的所有行和列索引，如下所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You have two tuples, the first giving the row indices of nonzero elements, and
    the second giving their respective column indices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个元组，第一个给出非零元素的行索引，第二个给出它们各自的列索引。
- en: 'We’re looking only for the names of the cities with above-average AQI values,
    and nothing else, so you need just the row indices. You can use these row indices
    to extract the string names from our string array by using *advanced indexing*,
    an indexing technique that allows you to define a sequence of array indices without
    requiring it to be a continuous slice. This way, you can access arbitrary elements
    from a given NumPy array by specifying either a sequence of integers (the indices
    to be selected) or a sequence of Booleans (to select the specific indices where
    the corresponding Boolean value is `True`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只关心那些空气质量指数（AQI）值高于平均值的城市名字，而不关心其他内容，所以你只需要行索引。你可以使用这些行索引通过*高级索引*从字符串数组中提取城市名字，*高级索引*是一种允许你定义一系列数组索引的索引技巧，无需它是连续的切片。这样，你可以通过指定整数序列（要选择的索引）或布尔序列（选择布尔值为`True`的特定索引）来访问给定NumPy数组中的任意元素：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You’ll notice many duplicates in the resulting sequence of strings, because
    Hong Kong and New York have multiple above-average AQI measurements.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在生成的字符串序列中有很多重复项，因为香港和纽约有多个AQI高于平均值的测量数据。
- en: 'Now, there is only one thing left to do: remove duplicates. You’ll do this
    by converting the sequence to a Python set, which is by default duplicate-free,
    giving a succinct summary of all city names with pollution that exceeded the average
    AQI values.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只剩下一件事要做：去除重复项。你可以通过将序列转换为Python集合来完成这项工作，集合默认是去重的，这样可以简洁地总结所有污染超过平均AQI值的城市名称。
- en: '**EXERCISE 3-1**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 3-1**'
- en: 'Go back to the taxation example in “Basic Two-Dimensional Array Arithmetic”
    on [page 42](#page_42) and pull the name of the person with the highest salary
    from the matrix by using this idea of selective Boolean indexing. Problem recap:
    How do we find the person with maximum after-tax income in a group of people,
    given their yearly salary and tax rates?'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 回到《基本二维数组运算》中的税务示例，参见[第42页](#page_42)，并通过使用选择性布尔索引的思路从矩阵中提取薪资最高的人的名字。问题回顾：在给定一组人的年薪和税率的情况下，我们如何找到税后收入最高的人？
- en: In summary, you learned about using Boolean expressions on NumPy arrays (using
    broadcasting again) and the `nonzero()` function to find rows or columns that
    satisfy certain conditions. After saving the environment in this one-liner, let’s
    move on and analyze influencers in social media.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你学习了如何在NumPy数组上使用布尔表达式（再次使用广播）和`nonzero()`函数来查找满足特定条件的行或列。在通过这行代码保存环境后，我们继续分析社交媒体中的网红。
- en: '**Boolean Indexing to Filter Two-Dimensional Arrays**'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**布尔索引过滤二维数组**'
- en: Here you’ll strengthen your knowledge of array indexing and broadcasting by
    pulling Instagram users with more than 100 million followers from a small data
    set. In particular, given a two-dimensional array of influencers (rows), with
    a first column that defines the influencer’s name as a string and a second column
    that defines the influencer’s follower count, you’ll find all influencer names
    with more than 100 million followers!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将通过从一个小数据集中提取Instagram用户（粉丝数超过1亿）来巩固你的数组索引和广播知识。具体来说，给定一个二维的网红数组（行），第一列定义了网红的名字（字符串），第二列定义了网红的粉丝数，你将找出所有粉丝数超过1亿的网红名字！
- en: '***The Basics***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: NumPy arrays enrich the basic list data type with additional functionality such
    as multidimensional slicing and multidimensional indexing. Have a look at the
    code snippet in [Listing 3-16](#list3-16).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组通过增加多维切片和多维索引等额外功能，丰富了基本的列表数据类型。看看[代码清单 3-16](#list3-16)中的代码片段。
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 3-16: Selective (Boolean) indexing in NumPy*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 3-16：NumPy中的选择性（布尔）索引*'
- en: 'You create two arrays: `a` contains two-dimensional numerical data (think of
    it as the *data array*), and `indices` contains Boolean values (think of it as
    the *indexing array*). A great feature of NumPy is that you can use the Boolean
    array for fine-grained access to the data array. In plain English, you create
    a new array containing only those elements of the data array `a` for which the
    indexing array `indices` contains `True` values at the respective array positions.
    For example, if `indices[i,j]==True`, the new array contains the value `a[i,j]`.
    Similarly, if `indices[i,j]==False`, the new array does not contain the value
    `a[i,j]`. Thus, the resulting array contains the three values `3`, `7`, and `8`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了两个数组：`a` 包含二维数值数据（可以将其视为 *数据数组*），`indices` 包含布尔值（可以将其视为 *索引数组*）。NumPy 的一个伟大特性是，你可以使用布尔数组对数据数组进行细粒度访问。简单来说，你创建一个新数组，其中仅包含那些在索引数组
    `indices` 中对应位置为 `True` 的数据数组 `a` 元素。例如，如果 `indices[i,j] == True`，则新数组包含 `a[i,j]`
    的值。类似地，如果 `indices[i,j] == False`，新数组则不包含 `a[i,j]` 的值。这样，结果数组包含三个值：`3`、`7` 和 `8`。
- en: In the following one-liner, you are going to use this feature for a toy analysis
    of a social network.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的这行代码中，你将使用这个特性对社交网络进行简单分析。
- en: '***The Code***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: In [Listing 3-17](#list3-17), you’ll find the names of the Instagram superstars
    with more than 100 million followers!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 3-17](#list3-17)中，你可以找到粉丝超过 1 亿的 Instagram 超级明星的名字！
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 3-17: One-liner solution using slicing, array types, and Boolean operators*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-17：使用切片、数组类型和布尔运算符的单行解决方案*'
- en: As usual, see if you can compute the result of this one-liner in your head before
    reading through the explanation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在阅读解释之前，看看你是否能在脑海中计算出这个单行代码的结果。
- en: '***How It Works***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理***'
- en: The data consists of a two-dimensional array, `inst`, and each row represents
    an Instagram influencer. The first column states their number of followers (in
    millions), and the second column states their Instagram name. From this data,
    you want to pull the names of the Instagram influencers with more than 100 million
    followers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 数据由一个二维数组 `inst` 组成，每一行代表一位 Instagram 网红。第一列表示他们的粉丝数（以百万为单位），第二列表示他们的 Instagram
    名称。根据这些数据，你想提取粉丝超过 1 亿的 Instagram 网红的名字。
- en: 'There are many ways to solve this in one line. The following approach is the
    easiest one:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方式有很多种，一行代码的最简单方法如下：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s deconstruct this one-liner step by step. The inner expression calculates
    a Boolean value that says whether each influencer has more than 100 million followers:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步分解这行代码。内部表达式计算出一个布尔值，表示每位网红的粉丝数是否超过 1 亿：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first column contains the number of followers, so you use slicing to access
    this data; `inst[:,0]` returns all rows in just the first column. However, because
    the data array contains mixed data types (integers and strings), NumPy automatically
    assigns a non-numerical data type to the array. The reason is that a numerical
    data type would not be able to capture the string data, so NumPy converts the
    data to a type that can represent all data in the array (string and numerical).
    You need to perform numerical comparisons on the first column of the data array
    to check whether each value is larger than 100, so you first convert the resulting
    array into a float type by using `.astype(float)`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列包含粉丝数，因此你使用切片来访问这些数据；`inst[:,0]` 返回所有行的第一列。但是，由于数据数组包含混合数据类型（整数和字符串），NumPy
    会自动将数组的类型设置为非数值类型。原因是数值类型无法表示字符串数据，所以 NumPy 将数据转换为可以表示数组中所有数据（字符串和数值）的类型。你需要对数据数组的第一列执行数值比较，检查每个值是否大于
    100，因此你首先通过 `.astype(float)` 将结果数组转换为浮点类型。
- en: Next, you check whether the values in the float type NumPy array are each larger
    than the integer value 100\. Here, NumPy again uses broadcasting to automatically
    bring the two operands into the same shape so it can do the comparison element-wise.
    The result is an array of Boolean values that shows that four influencers have
    more than 100 million followers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你检查浮点类型的 NumPy 数组中的值是否都大于整数值 100。这里，NumPy 再次使用广播机制自动将两个操作数转换为相同的形状，从而可以逐元素地进行比较。结果是一个布尔值数组，显示出四位网红的粉丝超过
    1 亿。
- en: 'You now take this Boolean array (also called a *mask index array*) to select
    the influencers with more than 100 million followers (the rows) by using Boolean
    indexing:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用这个布尔数组（也叫做 *掩码索引数组*）通过布尔索引来选择粉丝超过 1 亿的网红（即选择行）：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because you are interested only in the names of these influencers, you select
    the second column as the final result and store it in the `superstars` variable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你只对这些影响者的名字感兴趣，你选择第二列作为最终结果，并将其存储在`superstars`变量中。
- en: 'The influencers from our data set with more than 100 million Instagram followers
    are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据集中拥有超过1亿Instagram粉丝的影响者如下：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In summary, you’ve applied NumPy concepts such as slicing, broadcasting, Boolean
    indexing, and data type conversion to a small data science problem in social media
    analysis. Next, you’ll learn about a new application scenario in the Internet
    of Things.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你已经将NumPy的概念（如切片、广播、布尔索引和数据类型转换）应用于一个小型的数据科学问题，这个问题来自社交媒体分析。接下来，你将学习物联网中的新应用场景。
- en: '**Broadcasting, Slice Assignment, and Reshaping to Clean Every i-th Array Element**'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**广播、切片赋值和重塑以清理每个i-th数组元素**'
- en: Real-world data is seldom clean and may contain errors or missing values for
    a huge variety of reasons, including damaged or faulty sensors. In this section,
    you’ll learn about how to handle small cleaning tasks to eliminate erroneous data
    points.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的数据很少是干净的，可能由于多种原因（包括损坏或故障的传感器）而包含错误或缺失值。在这一部分，你将学习如何处理一些小的清理任务，以消除错误的数据点。
- en: '***The Basics***'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Say you’ve installed a temperature sensor in your garden to measure temperature
    data over many weeks. Every Sunday, you bring the temperature sensor in from the
    garden to digitize the sensor values. You’re aware that the Sunday sensor values
    are therefore faulty because for part of the day they measure the temperature
    in your home instead of outside.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在花园里安装了一个温度传感器，用来测量几周的温度数据。每个星期天，你都会把温度传感器从花园里带进屋内，以数字化传感器的值。你知道，星期天的传感器值是有问题的，因为在一天的部分时间里，它们测量的是你家里的温度，而不是外面的温度。
- en: You want to clean your data by replacing every Sunday sensor value with the
    average sensor value of the previous seven days (you include the Sunday value
    in the average computation because it’s not entirely faulty). Before diving into
    the code, let’s explore the most important concepts you need as a basic understanding.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你想通过将每个星期天的传感器值替换为过去七天的平均传感器值来清理数据（你将星期天的值包含在平均计算中，因为它并不是完全错误的）。在开始编写代码之前，我们先探讨一下你需要作为基本理解的最重要概念。
- en: '**Slice Assignment**'
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**切片赋值**'
- en: 'With NumPy’s slice assignment feature (see “[Working with NumPy Arrays: Slicing,
    Broadcasting, and Array Types](#lev-69)” on [page 46](#page_46)), you specify
    the values you want to replace on the left of the equation, and the values to
    replace them with on the right-hand side of the equation. [Listing 3-18](#list3-18)
    provides an example in case you need a small recap.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy的切片赋值功能（参见“[使用NumPy数组：切片、广播和数组类型](#lev-69)”第[46页](#page_46)），你在等式的左侧指定你想要替换的值，在等式的右侧指定替换这些值的内容。[代码清单
    3-18](#list3-18)提供了一个例子，以防你需要简单的回顾。
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 3-18: Simple Python list creation and slice assignment*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 3-18：简单的Python列表创建和切片赋值*'
- en: The code snippet creates an array containing the value `4` sixteen times. You
    use slice assignment to replace the last fifteen values with the value `42`. Recall
    that the notation `a[start:stop:step]` selects the sequence starting at index
    `start`, ending at index `stop` (exclusive), and considering only every `step`-th
    sequence element. If no arguments are specified, NumPy assumes default values.
    The notation `a[1::]` replaces all sequence elements but the first one. [Listing
    3-19](#list3-19) shows how to use slice assignment in combination with a feature
    you’ve already seen multiple times.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段创建了一个包含值`4`的数组，重复了16次。你使用切片赋值将最后15个值替换为值`42`。回想一下，`a[start:stop:step]`这种写法选择了从索引`start`开始，直到索引`stop`结束（不包括`stop`），并且只考虑每个`step`的元素。如果没有指定参数，NumPy会假定默认值。`a[1::]`表示替换所有序列元素，除了第一个。[代码清单
    3-19](#list3-19)展示了如何将切片赋值与一个你已经多次见过的功能结合使用。
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 3-19: Slice assignment in NumPy*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 3-19：NumPy中的切片赋值*'
- en: Here you replace every other value between index 1 and 8 (exclusive). You can
    see that you need to specify only a single value, `16`, to replace the selected
    elements, because of—you guessed it—*broadcasting*! The right side of the equation
    is automatically transformed into a NumPy array that is the same shape as the
    left array.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将替换索引1到8之间（不包括8）的每隔一个值。你可以看到，只需要指定一个单一的值`16`，就能替换选定的元素，因为——你猜对了——*广播*！等式右侧的内容会自动转换为一个与左侧数组形状相同的NumPy数组。
- en: '**Reshaping**'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**重塑**'
- en: 'Before diving into the one-liner, you need to learn about an important NumPy
    function: the `x.reshape((a,b))` function that transforms the NumPy array `x`
    into a new NumPy array with `a` rows and `b` columns (with shape `(a,b)`). Here’s
    an example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解单行代码之前，你需要学习一个重要的 NumPy 函数：`x.reshape((a,b))`，它将 NumPy 数组 `x` 转换为一个具有 `a`
    行和 `b` 列的新数组（形状为 `(a,b)`）。以下是一个示例：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the number of columns is unambiguous, you can also let NumPy do the work
    of figuring out the number of columns automatically. Let’s say you want to reshape
    an array with six elements into a two-dimensional array with two rows. NumPy can
    now figure out that it needs three columns to match the six elements in the original
    array. Here’s an example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列数是明确的，你也可以让 NumPy 自动计算列数。假设你想将一个包含六个元素的数组重新形状为一个具有两行的二维数组。NumPy 现在能够自动计算出需要三列，以匹配原始数组中的六个元素。下面是一个示例：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The shape value `-1` for the column argument indicates that NumPy should replace
    it with the correct number of columns (which is three in this case).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列参数的形状值 `-1` 表示 NumPy 应该将其替换为正确的列数（在本例中是三列）。
- en: '**The Axis Argument**'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**轴参数**'
- en: Finally, let’s consider the following code snippet that introduces the `axis`
    argument. Here is an array `solar_x` that contains daily stock prices of Elon
    Musk’s SolarX company. We want to calculate the average stock prices in the mornings,
    middays, and evenings. How can we achieve this?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑下面的代码片段，它引入了 `axis` 参数。这里有一个数组 `solar_x`，包含了埃隆·马斯克的 SolarX 公司每天的股价。我们想计算早晨、中午和晚上的平均股价。我们该如何实现呢？
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The array `solar_x` consists of stock prices of the SolarX company. It has two
    rows (one for each day) and three columns (one for each stock price). Say we want
    to calculate the average stock price in the mornings, the middays, and the evenings.
    Roughly speaking, we want to collapse together all values in each column by averaging
    them. In other words, we calculate the average along axis 0\. This is exactly
    what the keyword argument `axis=0` is doing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 `solar_x` 包含 SolarX 公司的股价。它有两行（每天一行）和三列（每列一个股价）。假设我们想计算早晨、中午和晚上的平均股价。大致来说，我们想将每列中的所有值通过平均值合并。换句话说，我们沿着轴
    0 计算平均值。这正是关键字参数 `axis=0` 的作用。
- en: '***The Code***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'This is everything you need to know to solve the following problem ([Listing
    3-20](#list3-20)): given an array of temperature values, replace every seventh
    temperature value with the average of the last seven days (including the seventh
    day’s temperature value).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你解决下列问题所需的所有知识（[示例 3-20](#list3-20)）：给定一个温度值数组，如何将每第七个温度值替换为过去七天的平均值（包括第七天的温度值）。
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 3-20: One-liner solution using the average and reshape operators,
    slice assignments, and the axis argument*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-20：使用平均值和重塑操作符、切片赋值以及轴参数的单行解决方案*'
- en: Can you calculate the output of this code snippet?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你能计算出这段代码的输出吗？
- en: '***How It Works***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: The data arrives in the shape of a one-dimensional array of sensor values.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以一维数组的形式到达，包含传感器值。
- en: First, you create the data array `tmp` with a one-dimensional sequence of sensor
    values. In every line, you define all seven sensor values for seven days of the
    week.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个数据数组 `tmp`，它是一个一维的传感器值序列。在每一行中，你定义了七天的传感器值。
- en: Second, you use slice assignment to replace all the Sunday values of this array.
    Because Sunday is the seventh day, you use the expression `tmp[6::7]` to select
    the respective Sunday values, starting from the seventh element in the original
    array `tmp`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你使用切片赋值来替换这个数组中的所有星期天的值。由于星期天是第七天，你使用表达式 `tmp[6::7]` 来选择相应的星期天值，从原始数组 `tmp`
    的第七个元素开始。
- en: 'Third, we *reshape* the one-dimensional sensor array into a two-dimensional
    array with seven columns and three rows, which makes it easier to calculate the
    weekly average temperature value to replace the Sunday data. Because of the reshaping,
    you can now merge all seven values of each row into a single average value. To
    reshape the array, you pass the tuple values `-1` and `7` to `tmp.reshape()`,
    which tells NumPy that the number of rows (*axis 0*) should be selected automatically.
    Roughly speaking, you specify seven columns, and NumPy creates an array with however
    many rows are needed to satisfy our condition of seven columns. In our case, it
    results in the following array after reshaping:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步，我们将一维传感器数组重新调整为一个具有七列三行的二维数组，这样可以更方便地计算每周的平均温度值来替换周日的数据。由于重塑，现在可以将每一行的七个值合并为一个平均值。要重塑数组，你将元组值`-1`和`7`传递给`tmp.reshape()`，这告诉NumPy自动选择行数（*轴
    0*）。大致来说，你指定了七列，NumPy会根据需要创建足够的行数，以满足七列的条件。在我们的例子中，重塑后得到如下数组：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You have one row per week and one column per weekday.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行代表一周，每一列代表一个工作日。
- en: 'Now you calculate the seven-day average by collapsing every row into a single
    average value by using the `np.average()` function with the axis argument: `axis=1`
    tells NumPy to collapse the second axis into a single average value. Note that
    the Sunday value is included in the average computation (see the problem formulation
    at the beginning of this section). This is the result of the right-hand side of
    the equation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你通过使用带有轴参数的`np.average()`函数计算七天的平均值：`axis=1`告诉NumPy将第二个轴压缩为一个单一的平均值。注意，周日的值已包含在平均值的计算中（参见本节开头的问题描述）。这是方程右侧的结果：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The goal of the one-liner is to replace the three Sunday temperature values.
    All other values should stay constant. Let’s see whether you achieved this objective.
    After replacing all Sunday sensor values, you get the following final result of
    the one-liner:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码的目标是替换三项周日的温度值。其他所有值应该保持不变。让我们看看你是否达成了这个目标。在替换完所有周日的传感器值后，你将得到以下一行代码的最终结果：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that you still have a one-dimensional NumPy array with all temperature
    sensor values. But now you’ve replaced the unrepresentative readings with more
    representative ones.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你仍然拥有一个一维的NumPy数组，里面存有所有的温度传感器值。但现在，你已经用更具代表性的读数替换了那些不代表性的数据。
- en: 'In summary, this one-liner is all about hammering down the concepts of array
    shapes and reshaping, and how to use the `axis` property for aggregator functions
    such as `np.average()`. While this application was rather specific, it will be
    useful in a range of situations. Next, you’ll learn about a super general concept:
    sorting in NumPy.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这行代码主要是要理解数组形状和重塑的概念，以及如何使用`axis`属性来进行聚合函数，如`np.average()`。虽然这个应用比较具体，但它在很多场景中都会有所帮助。接下来，你将学习一个超级通用的概念：在NumPy中排序。
- en: '**When to Use the sort() Function and When to Use the argsort() Function in
    NumPy**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**何时使用 sort() 函数以及何时使用 argsort() 函数**'
- en: Sorting is useful, even essential, in numerous situations. Say you search your
    bookshelf for *Python One-Liners*. It would be much easier to find the book if
    your bookshelf were alphabetically sorted by title.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 排序在许多情况下都是有用的，甚至是必不可少的。比如你在书架上搜索*Python单行代码*。如果你的书架按字母顺序排列，找书会更加轻松。
- en: This one-liner solution will show you how to use sorting in a single line of
    Python by using NumPy.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行代码的解决方案将展示如何通过NumPy在一行Python代码中实现排序。
- en: '***The Basics***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Sorting is at the heart of more advanced applications such as commercial computing,
    process scheduling in operating systems (priority queues), and search algorithms.
    Fortunately, NumPy provides various sorting algorithms. The default is the popular
    *Quicksort* algorithm. In [Chapter 6](ch06.xhtml#ch06), you’ll learn how to implement
    the Quicksort algorithm yourself. However, for this one-liner, you’ll take a higher-level
    approach, viewing the sorting function as a black box into which you’ll put a
    NumPy array to get out a sorted NumPy array.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是更高级应用的核心，比如商业计算、操作系统中的进程调度（优先级队列）和搜索算法。幸运的是，NumPy提供了多种排序算法。默认的排序算法是流行的*快速排序*算法。在[第6章](ch06.xhtml#ch06)中，你将学习如何实现快速排序算法。然而，对于这一行代码，你将采取更高层次的方法，将排序函数视为一个黑盒，你只需要将NumPy数组输入，得到一个排序后的NumPy数组。
- en: '[Figure 3-1](#ch03fig01) shows the algorithm transforming an unsorted array
    into a sorted array. This is the purpose of NumPy’s `sort()` function.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](#ch03fig01)展示了将一个未排序的数组转换为排序数组的算法。这是 NumPy 的 `sort()` 函数的目的。'
- en: '![images](Images/fig3-1.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig3-1.jpg)'
- en: '*Figure 3-1: The difference between the `sort()` and `argsort()` functions*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：`sort()`与`argsort()`函数的区别*'
- en: 'But often, it’s also important to get the array of indices that would transform
    the unsorted array into a sorted array. For example, the unsorted array element
    1 has index `7`. Because the array element 1 is the first element of the sorted
    array, its index `7` is the first element of the sorted indices. This is what
    NumPy’s `argsort()` function does: it creates a new array of the original index
    values after sorting (see the example in [Figure 3-1](#ch03fig01)). Roughly speaking,
    these indices would sort the elements in the original array. By using this array,
    you can reconstruct both the sorted and the original array.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常，获取将未排序数组转换为排序数组的索引数组也是很重要的。例如，未排序数组元素 1 的索引是 `7`。因为数组元素 1 是排序数组中的第一个元素，所以它的索引
    `7` 是排序索引数组中的第一个元素。这就是 NumPy 的 `argsort()` 函数的作用：它在排序后创建一个新的原始索引数组（见 [图 3-1](#ch03fig01)
    中的示例）。粗略来说，这些索引将排序原始数组中的元素。通过使用这个数组，你可以重建排序后的数组和原始数组。
- en: '[Listing 3-21](#list3-21) demonstrates the use of `sort()` and `argsort()`
    in NumPy.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-21](#list3-21)展示了如何在 NumPy 中使用 `sort()` 和 `argsort()`。'
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 3-21: The `sort()` and `argsort()` functions in NumPy*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-21：NumPy 中的 `sort()` 和 `argsort()` 函数*'
- en: You create an unsorted array `a`, sort it with `np.sort(a)`, and get the original
    indices in their new sorted order with `np.argsort(a)`. NumPy’s `sort()` function
    is different from Python’s `sorted()` function in that it can sort multidimensional
    arrays too!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个未排序的数组 `a`，用 `np.sort(a)` 对其进行排序，并用 `np.argsort(a)` 获取排序后的原始索引。NumPy 的
    `sort()` 函数与 Python 的 `sorted()` 函数不同，它也可以对多维数组进行排序！
- en: '[Figure 3-2](#ch03fig02) shows two ways of sorting a two-dimensional array.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-2](#ch03fig02)展示了排序二维数组的两种方式。'
- en: '![images](Images/fig3-2.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig3-2.jpg)'
- en: '*Figure 3-2: Sorting along an axis*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：沿一个轴进行排序*'
- en: 'The array has two axes: axis 0 (the rows) and axis 1 (the columns). You can
    sort along axis 0, known as *vertical sorting*, or along axis 1, known as *horizontal
    sorting*. In general, the `axis` keyword defines the direction along which you
    perform the NumPy operation. [Listing 3-22](#list3-22) shows technically how to
    do this.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有两个轴：轴 0（行）和轴 1（列）。你可以沿轴 0 排序，称为*垂直排序*，或者沿轴 1 排序，称为*水平排序*。通常，`axis` 关键字定义了你进行
    NumPy 操作的方向。[列表 3-22](#list3-22)展示了如何技术性地实现这一点。
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 3-22: Sorting along an axis*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-22：沿一个轴进行排序*'
- en: The optional `axis` argument helps you sort the NumPy array along a fixed direction.
    First, you sort by columns, starting with the smallest value. Then you sort by
    rows. This is the main strength of NumPy’s `sort()` function compared to Python’s
    built-in `sorted()` function.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 `axis` 参数帮助你沿固定方向对 NumPy 数组进行排序。首先，你按列排序，从最小值开始。然后按行排序。这是 NumPy 的 `sort()`
    函数相比于 Python 内建的 `sorted()` 函数的主要优势。
- en: '***The Code***'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: This one-liner will find the names of the top three students with the highest
    SAT scores. Note that you’ll ask for the student names and not the sorted SAT
    scores. Have a look at the data and see if you can find the one-liner solution
    yourself. When you’ve had a go at that, take a look at [Listing 3-23](#list3-23).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码将找到 SAT 成绩最高的前三个学生的名字。注意，你要求的是学生的名字，而不是排序后的 SAT 成绩。看看数据，看看你是否能自己找到这个单行解决方案。尝试一下后，看看
    [列表 3-23](#list3-23)。
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 3-23: One-liner solution using the `argsort()` function and slicing
    with negative step size*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-23：使用`argsort()`函数和带负步长切片的单行解决方案*'
- en: As usual, try to figure out the output.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，尝试推测输出结果。
- en: '***How It Works***'
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: Our initial data consists of the SAT scores of students as a one-dimensional
    data array, and another array with the corresponding names of the students. For
    example, John achieved a solid SAT score of 1100, while Frank achieved an excellent
    SAT score of 1412.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的初始数据由学生的 SAT 成绩组成，作为一个一维数据数组，另有一个对应学生姓名的数组。例如，John 获得了稳健的 1100 分 SAT 成绩，而
    Frank 获得了优异的 1412 分。
- en: The task is to find the names of the three most successful students. You’ll
    achieve this—not by simply sorting the SAT scores—but by running the `argsort()`
    function to get an array of the original indices in their new sorted positions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是找到三位最成功学生的姓名。你将通过运行`argsort()`函数，获取一个包含原始索引的新排序位置的数组，而不是仅仅排序SAT分数。
- en: 'Here is the output of the `argsort()` function on the SAT scores:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`argsort()`函数在SAT分数上的输出：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You need to retain the indexes because you need to be able to find the name
    of the student from the `students` array, which corresponds only to the original
    positions. Index 4 is at the first position of the output because Jane has the
    lowest SAT score, with 989 points. Note that both `sort()` and `argsort()` sort
    in an ascending manner, from lowest to highest values.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要保留索引，因为你需要根据`students`数组中对应的原始位置来查找学生姓名。索引4出现在输出的第一个位置，因为Jane的SAT分数最低，只有989分。请注意，`sort()`和`argsort()`都是按升序排序的，从最低值到最高值。
- en: 'Now that you have sorted indices, you need to get the names of the respective
    students by indexing the `student` array:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经排序了索引，接下来需要通过索引`student`数组来获取相应学生的姓名：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is a useful feature of the NumPy library: you can reorder a sequence by
    using advanced indexing. If you specify a sequence of indices, NumPy triggers
    advanced indexing and returns a new NumPy array with reordered elements as specified
    by your index sequence. For instance, the command `students[np.argsort(sat_scores)]`
    evaluates to `students[[4 3 0 1 6 5 2]]` so NumPy creates a new array as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是NumPy库的一个有用功能：你可以通过使用高级索引来重新排序序列。如果你指定一个索引序列，NumPy将触发高级索引并返回一个重新排序的NumPy数组，按你指定的索引顺序排列。例如，命令`students[np.argsort(sat_scores)]`的输出为`students[[4
    3 0 1 6 5 2]]`，因此NumPy创建了一个如下的新数组：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'From this, you know that Jane has the lowest SAT score, while Alice has the
    highest. The only thing left is to reverse the list and extract the top three
    students by using simple slicing:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从中你可以得知，Jane的SAT分数最低，而Alice的SAT分数最高。剩下的唯一任务就是反转列表，并通过简单的切片提取出前三名学生：
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Alice, Frank, and Carl have the highest SAT scores of 1543, 1412, and 1343,
    respectively.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Alice、Frank和Carl分别拥有1543、1412和1343的最高SAT分数。
- en: 'In summary, you’ve learned about the application of two important NumPy functions:
    `sort()` and `argsort()`. Next, you’ll improve your advanced understanding of
    NumPy indexing and slicing by using Boolean indexing and lambda functions in a
    practical data science problem.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你已经了解了两个重要的NumPy函数的应用：`sort()`和`argsort()`。接下来，你将通过在实际的数据科学问题中使用布尔索引和lambda函数，进一步提升你对NumPy索引和切片的深入理解。
- en: '**How to Use Lambda Functions and Boolean Indexing to Filter Arrays**'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何使用Lambda函数和布尔索引来过滤数组**'
- en: Real-world data is noisy. As a data scientist, you get paid to get rid of the
    noise, make the data accessible, and create meaning. Filtering data is therefore
    vital for real-world data science tasks. In this section, you’ll learn how to
    create a minimal filter function in a single line of code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的数据通常是噪声的。作为数据科学家，你的工作就是消除噪声，使数据易于访问，并创造出有意义的结论。因此，过滤数据对于现实世界的数据科学任务至关重要。在本节中，你将学习如何用一行代码创建一个最小的过滤函数。
- en: '***The Basics***'
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'To create a function in one line, you’ll need to use *lambda functions*. As
    you know from [Chapter 2](ch02.xhtml#ch02), lambda functions are anonymous functions
    that you can define in a single line of code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个一行的函数，你需要使用*lambda函数*。正如你在[第2章](ch02.xhtml#ch02)中所学，lambda函数是匿名函数，你可以在一行代码中定义它：
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You define a comma-separated list of arguments that serve as inputs. The lambda
    function then evaluates the expression and returns the result.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了一个由逗号分隔的参数列表作为输入。然后lambda函数评估表达式并返回结果。
- en: Let’s explore how to solve our problem by creating a filter function using the
    lambda function definition.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何通过创建一个使用lambda函数定义的过滤器函数来解决我们的难题。
- en: '***The Code***'
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'Consider the following problem, depicted in [Listing 3-24](#list3-24): create
    a filter function that takes a list of books `x` and a minimum rating `y` and
    returns a list of potential bestsellers that have higher than minimum rating,
    `y''>y`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的问题，见[示例 3-24](#list3-24)：创建一个过滤器函数，接受一本书的列表`x`和一个最小评分`y`，并返回评分高于最小评分`y'>y`的潜在畅销书列表。
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 3-24: One-liner solution using lambda functions, type conversion,
    and Boolean operators*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-24：使用lambda函数、类型转换和布尔运算符的一行解决方案*'
- en: Take a guess at the output of this code before moving on.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，先猜一下这段代码的输出。
- en: '***How It Works***'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The data consists of a two-dimensional NumPy array in which each row holds the
    name of the book title and the average user rating (a floating-point number between
    0.0 and 5.0). There are six books in the rated data set.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 数据由一个二维NumPy数组组成，其中每一行包含书籍的标题和平均用户评分（浮动数，范围在0.0到5.0之间）。评分数据集中有六本书。
- en: The goal is to create a filter function that takes as input the book rating
    data set `x` and a threshold rating `y`, and returns the books that have a higher
    rating than the threshold `y`. You set the threshold to 3.9.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是创建一个过滤函数，该函数接收书籍评分数据集`x`和阈值评分`y`作为输入，并返回评分高于阈值`y`的书籍。你将阈值设置为3.9。
- en: 'You achieve this by defining an anonymous lambda function that returns the
    result of the following expression:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过定义一个匿名的lambda函数来实现这一点，该函数返回以下表达式的结果：
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The array `x` is assumed to have two columns as our book rating array `books`.
    To access the potential bestsellers, you use an advanced indexing scheme similar
    to the one in [Listing 3-17](#list3-17).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数组`x`具有两列作为我们的书籍评分数组`books`。为了访问潜在的畅销书，你使用类似于[列表3-17](#list3-17)中的高级索引方案。
- en: First, you carve out the second column ➊ that holds the book ratings and convert
    it to a float array by using the `astype(float)` method ➋ on the NumPy array `x`.
    This is necessary because the initial array `x` consists of mixed data types (float
    and strings).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你提取第二列 ➊，它包含书籍评分，并通过对NumPy数组`x`使用`astype(float)`方法 ➋ 将其转换为浮动数组。这是必要的，因为初始数组`x`包含混合数据类型（浮动数和字符串）。
- en: 'Second, you create a Boolean array that holds the value `True` if the book
    at the respective row index has a rating larger than `y` ➌. Note that the float
    `y` is implicitly broadcasted to a new NumPy array so that both operands of the
    Boolean operator `>` have the same shape. At this point, you’ve created a Boolean
    array indicating for each book whether it can be considered a bestseller: `x[:,1].astype(float)>
    y = [ True True True False False True]`. So, the first three books and the last
    one are bestsellers.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你创建一个布尔数组，如果相应行索引的书籍评分大于`y`，则该数组的值为`True` ➌。请注意，浮动的`y`会隐式广播为一个新的NumPy数组，使得布尔运算符`>`的两个操作数具有相同的形状。此时，你已经创建了一个布尔数组，表示每本书是否可以被视为畅销书：`x[:,1].astype(float)>
    y = [ True True True False False True]`。因此，前两本书和最后一本书是畅销书。
- en: 'Third, we use the Boolean array as an indexing array on the original book rating
    array to carve out all the books that have above-threshold ratings. More specifically,
    we use Boolean indexing `x[[ True True True False False True]]` to get a subarray
    of the original array with only four books: the ones with `True` value. This results
    in the following final output of this one-liner:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们使用布尔数组作为原始书籍评分数组的索引数组，提取出所有评分超过阈值的书籍。更具体地说，我们使用布尔索引`x[[ True True True
    False False True]]`，从原始数组中获取一个仅包含四本书的子数组：即评分为`True`值的书籍。这将得到以下一行代码的最终输出：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In summary, you’ve learned how to filter data using only Boolean indexing and
    lambda functions. Next, you’ll dive into logical operators and learn a useful
    trick to write the logical and operation concisely.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你已经学会了如何仅使用布尔索引和lambda函数来过滤数据。接下来，你将深入学习逻辑运算符，并学会一个有用的技巧，以简洁地编写逻辑与操作。
- en: '**How to Create Advanced Array Filters with Statistics, Math, and Logic**'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何创建具有统计、数学和逻辑功能的高级数组过滤器**'
- en: 'This section shows you the most basic outlier detection algorithm: if an observed
    value deviates from the mean by more than the standard deviation, it is considered
    an *outlier*. You’ll work through an example of analyzing website data to determine
    the number of active users, the bounce rate, and the average session duration
    in seconds. (The *bounce rate* is the percentage of visitors who leave immediately
    after visiting only one website. A high bounce rate is a bad signal: it might
    indicate that a site is boring or irrelevant.) You’ll look at the data and identify
    outliers.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向你展示了最基本的异常值检测算法：如果观察值偏离均值超过标准差，它就被视为一个*异常值*。你将通过分析网站数据的一个示例，来确定活跃用户数、跳出率和平均会话时长（单位：秒）。(*跳出率*是指访问者在仅访问一个网站后立即离开的百分比。高跳出率是一个坏信号：它可能表明网站很无聊或不相关。)你将查看数据并识别异常值。
- en: '***The Basics***'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'To solve the outlier detection problem, you’ll first study three basic skills:
    understanding the mean and standard deviation, finding the absolute value, and
    performing the logical and operation.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决异常值检测问题，你首先需要学习三项基本技能：理解均值和标准差，计算绝对值，以及执行逻辑与操作。
- en: '**Understanding Mean and Standard Deviation**'
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**理解均值和标准差**'
- en: 'First, you’ll slowly develop our definition of an outlier by using basic statistics.
    You’ll make the basic assumption that all observed data is normally distributed
    around a mean value. For example, consider the following sequence of data values:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将通过使用基础统计学慢慢发展我们对异常值的定义。你会做出一个基本假设：所有观察到的数据都是围绕均值分布的。例如，考虑以下数据值序列：
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you plot the histogram of this sequence, you’ll get the result in [Figure
    3-3](#ch03fig03).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你绘制这个序列的直方图，你将得到[图 3-3](#ch03fig03)中的结果。
- en: 'The sequence seems to resemble a *normal distribution* with a *mean* value
    of 10 and a *standard deviation* of 1\. The mean, denoted with a μ symbol, is
    the average value of all sequence values. The standard deviation, denoted with
    a σ symbol, measures the variation of a data set around the mean value. By definition,
    if the data is truly normally distributed, 68.2 percent of all sample values fall
    into the standard deviation interval [ω[1] = μ – σ,ω[2] = μ + σ]. This provides
    a range for outliers: anything that doesn’t fall within the range is considered
    an outlier.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列似乎呈现出一个*正态分布*，其*均值*为10，*标准差*为1。均值，表示为μ符号，是所有序列值的平均值。标准差，表示为σ符号，衡量数据集围绕均值的变动程度。根据定义，如果数据确实是正态分布的，68.2%的样本值会落在标准差区间[ω[1]
    = μ – σ,ω[2] = μ + σ]内。这为异常值提供了一个范围：任何不在该范围内的值都被视为异常值。
- en: In the example, I generated the data from the normal distribution μ=10 and σ=1,
    which results in the interval ω[1] = μ – 1 = 9 and ω[2] = μ + 1 = 11\. In the
    following, you simply assume that *any observed value that is outside the interval
    marked by the standard deviation around the mean is an outlier*. For our data,
    this means that any value that doesn’t fall into the interval [9,11] is an outlier.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我从均值μ=10和标准差σ=1的正态分布中生成了数据，结果得到了区间ω[1] = μ – 1 = 9和ω[2] = μ + 1 = 11。在接下来的内容中，你可以简单地假设*任何超出均值周围标准差标记区间的观察值都是异常值*。对于我们的数据，这意味着任何不落在区间[9,11]内的值都是异常值。
- en: '![images](Images/fig3-3.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig3-3.jpg)'
- en: '*Figure 3-3: Histogram of the sequence of data values*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：数据值序列的直方图*'
- en: The simple code I used to generate the plot is shown in [Listing 3-25](#list3-25).
    Can you find the code lines that define the mean and standard deviation?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我用于生成该图的简单代码显示在[清单 3-25](#list3-25)中。你能找到定义均值和标准差的代码行吗？
- en: '[PRE50]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 3-25: Plotting the histogram by using the Matplotlib library*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-25：使用Matplotlib库绘制直方图*'
- en: This code shows how to plot a histogram by using Python’s Matplotlib library.
    However, this is not the focus of this section; I want to highlight only how you
    can create the preceding sequence of data values.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了如何使用Python的Matplotlib库绘制直方图。不过，这一部分的重点并不在此，我想强调的是如何创建前面提到的数据值序列。
- en: Simply import the NumPy library and use the module `np.random`, which provides
    a function `normal(mean, deviation, shape)` that creates a new NumPy array with
    values randomly drawn from the normal distribution with a given mean and standard
    deviation. This is where you set `mean=10.0` and `deviation=1.0` to create the
    data in the sequence. In this case, setting `shape=500` indicates that you’re
    interested in only a one-dimensional data array with 500 data points. The remaining
    code imports the special xkcd plot styling `plt.xkcd()`, plots the histogram based
    on the sequence using `plt.hist(sequence)`, styles the plot with annotations,
    and outputs the final plot.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 只需导入NumPy库并使用模块`np.random`，它提供了一个函数`normal(mean, deviation, shape)`，该函数会创建一个新的NumPy数组，其中的值是从具有给定均值和标准差的正态分布中随机抽取的。这就是你设置`mean=10.0`和`deviation=1.0`来创建数据序列的地方。在这个例子中，设置`shape=500`表示你只关心一个包含500个数据点的一维数据数组。剩余的代码导入了特殊的xkcd绘图样式`plt.xkcd()`，并使用`plt.hist(sequence)`根据序列绘制直方图，进行注释样式设置，并输出最终的图表。
- en: '**NOTE**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The name of the xkcd plot is taken from the popular web comic page xkcd ([https://xkcd.com/](https://xkcd.com/)).*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*xkcd绘图的名称来自于流行的网络漫画页面xkcd（[https://xkcd.com/](https://xkcd.com/)）。*'
- en: Before diving into the one-liner, let’s quickly explore the other two basic
    skills you’ll need to complete this task.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解一行代码之前，让我们快速回顾一下完成此任务所需的另外两项基本技能。
- en: '**Finding the Absolute Value**'
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查找绝对值**'
- en: Second, you need to turn negative values into positive, so you can check whether
    each outlier deviates more than the standard deviation from the mean. You are
    interested in only the absolute deviation, not in whether it’s positive or negative.
    This is known as taking the *absolute value*. The NumPy function in [Listing 3-26](#list3-26)
    creates a new NumPy array with the absolute values of the original.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你需要将负值转为正值，这样你就可以检查每个异常值是否偏离其均值超过标准差。你关心的只是绝对偏差，而不是它是正还是负。这就是所谓的取*绝对值*。[示例
    3-26](#list3-26)中的 NumPy 函数会创建一个包含原始数组绝对值的新 NumPy 数组。
- en: '[PRE51]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Listing 3-26: Calculating the absolute value in NumPy*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-26：在 NumPy 中计算绝对值*'
- en: The function `np.abs()` converts the negative values in a NumPy array into their
    positive counterparts.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.abs()`函数将 NumPy 数组中的负值转换为其正值。'
- en: '**Performing the Logical And Operation**'
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**执行逻辑与运算**'
- en: Third, the following NumPy function performs an element-wise *logical and* operation
    to combine two Boolean arrays `a` and `b` and give back an array that combines
    the *individual* Boolean values using the logical and operation (see [Listing
    3-27](#list3-27)).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，以下 NumPy 函数执行逐元素的*逻辑与*操作，将两个布尔数组`a`和`b`合并，并返回一个使用逻辑与操作合并*各个*布尔值的数组（见[示例 3-27](#list3-27)）。
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 3-27: The logical and operation applied to NumPy arrays*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-27：应用于 NumPy 数组的逻辑与操作*'
- en: You combine each element at index *i* of array `a` with element *i* of array
    `b` by using `np.logical_and(a, b)`. The result is an array of Boolean values
    that are `True` if both operands `a[`*`i`*`]` and `b[`*`i`*`]` are already `True`,
    and `False` otherwise. In this way, you can combine multiple Boolean arrays into
    a single Boolean array by using standard logical operations. One useful application
    of this is to combine *Boolean filter arrays* as done in the following one-liner.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过使用`np.logical_and(a, b)`将数组`a`中索引为*i*的每个元素与数组`b`中索引为*i*的元素组合在一起。结果是一个布尔值数组，当两个操作数`a[`*`i`*`]`和`b[`*`i`*`]`都为`True`时，结果为`True`，否则为`False`。通过这种方式，你可以使用标准的逻辑操作将多个布尔数组合并成一个布尔数组。这个操作的一个有用应用是将*布尔过滤器数组*组合在一起，如下所示的单行代码所做的那样。
- en: Note that you can also *multiply* two Boolean arrays `a` and `b`—and this is
    equivalent to the `np.logical_and(a, b)` operation. Python represents a `True`
    value as an integer value `1` (or really any integer value different from `0`)
    and a `False` value as an integer value `0`. If you multiply anything by `0`,
    you get `0`, and therefore `False`. That means you’ll receive a `True` result
    (an integer value `>1`) only when all operands are already `True`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你也可以*相乘*两个布尔数组`a`和`b`——这等同于`np.logical_and(a, b)`操作。Python 将`True`值表示为整数值`1`（或任何非零整数值），而将`False`值表示为整数值`0`。如果你将任何值与`0`相乘，结果将是`0`，因此是`False`。这意味着，只有当所有操作数都为`True`时，你才会得到一个`True`的结果（整数值`>1`）。
- en: With this information, you are now fully equipped to understand the following
    one-liner code snippet.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，你现在已经完全具备理解以下单行代码片段的能力。
- en: '***The Code***'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: This one-liner will find all outlier days for which the statistics deviate more
    than the standard deviation from their mean statistics.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将找到所有异常值日期，这些日期的统计值偏离其均值超过标准差。
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Listing 3-28: One-liner solution using the mean function, standard deviation,
    and Boolean operators with broadcasting*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-28：使用均值函数、标准差和布尔运算符与广播的单行解决方案*'
- en: Can you guess the output of this code snippet?
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出这段代码的输出吗？
- en: '***How It Works***'
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: The data set consists of rows that represent different days, and three columns
    that represent daily active users, bounce rate, and average session duration in
    seconds, respectively.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集由表示不同日期的行和三列组成，分别表示每日活跃用户、跳出率和平均会话时长（秒数）。
- en: For each column, you calculate the mean value and the standard deviation. For
    example, the mean value of the Daily Active Users column is 811.2, and its standard
    deviation is 152.97\. Note that you use the `axis` argument in the same way as
    in “[Broadcasting, Slice Assignment, and Reshaping to Clean Every *i*-th Array
    Element](#lev-81)” on [page 60](#page_60).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对每一列，你计算其均值和标准差。例如，"每日活跃用户"这一列的均值为811.2，标准差为152.97。请注意，你在这里使用`axis`参数的方式与“[广播、切片赋值和重塑以清理每个*i*索引元素](#lev-81)”中第[60页](#page_60)的做法相同。
- en: Our goal is to detect websites that are outliers in all three columns. For the
    Daily Active Users column, every observed value that is smaller than 811.2 – 152.97
    = 658.23 or larger than 811.2 + 152.23 = 963.43 is considered an outlier.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是检测出在所有三个列中都是异常值的网站。对于日活跃用户列，任何观察值小于 811.2 – 152.97 = 658.23 或大于 811.2
    + 152.23 = 963.43 的值都被视为异常值。
- en: 'However, you consider a whole *day* to be an outlier only if all three observed
    columns are outliers. You achieve this by combining the three Boolean arrays using
    the logical and operator. The result is only a single row for which all three
    columns are outliers:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你认为只有当所有三个观察到的列都是异常值时，*一天*才被认为是异常值。你通过使用逻辑与运算符将这三个布尔数组结合起来来实现这一点。结果是只有一行数据，且这三列都是异常值：
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In summary, you have learned about the NumPy’s logical and operator and how
    to use it to perform basic outlier detection, while making use of simple statistical
    measures from the NumPy library. Next, you’ll learn about a secret ingredient
    of Amazon’s success: coming up with relevant recommendations of products to buy.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你已经了解了 NumPy 的逻辑与运算符以及如何使用它进行基本的异常值检测，同时利用 NumPy 库中的简单统计量。接下来，你将学习亚马逊成功的一个秘密成分：如何提供相关的产品购买推荐。
- en: '**Simple Association Analysis: People Who Bought X Also Bought Y**'
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**简单的关联分析：购买 X 的人也购买了 Y**'
- en: Have you ever bought a product recommended by Amazon’s algorithms? The recommendation
    algorithms are often based on a technique called *association analysis*. In this
    section, you’ll learn about the basic idea of association analysis and how to
    dip your toe into the deep ocean of recommender systems.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有曾经购买过亚马逊算法推荐的产品？推荐算法通常基于一种叫做*关联分析*的技术。在这一节中，你将了解关联分析的基本概念，并如何踏入推荐系统的深海。
- en: '***The Basics***'
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: Association analysis is based on historical customer data, such as the “people
    who bought *x* also bought *y*” data on Amazon. This association of different
    products is a powerful marketing concept because it not only ties together related
    but complementary products, but also provides you with an element of *social proof*—knowing
    that other people have bought a product increases the psychological safety for
    you to buy the product yourself. This is an excellent tool for marketers.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 关联分析基于历史客户数据，例如亚马逊上的“购买了*x*的人也购买了*y*”数据。这种不同产品的关联是一个强大的营销概念，因为它不仅将相关但互补的产品联系在一起，还为你提供了*社会证明*——知道其他人也购买了某个产品，会增加你自己购买该产品的心理安全感。这是一个对营销人员非常有用的工具。
- en: Let’s have a look at a practical example in [Figure 3-4](#ch03fig04).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个实践例子，见 [图 3-4](#ch03fig04)。
- en: '![images](Images/fig3-4.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![images](Images/fig3-4.jpg)'
- en: '*Figure 3-4: Product-Customer matrix—which customer has bought which product?*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-4：产品-客户矩阵——哪个客户购买了哪个产品？*'
- en: 'The four customers Alice, Bob, Louis, and Larissa bought different combinations
    of the products: book, game, soccer ball, laptop, headphones. Imagine that you
    know every product bought by all four persons, but not whether Louis has bought
    the laptop. What do you think: is Louis likely to buy the laptop?'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 四个客户 Alice、Bob、Louis 和 Larissa 购买了不同组合的产品：书籍、游戏、足球、笔记本电脑、耳机。假设你知道这四个人购买的每个产品，但不知道
    Louis 是否购买了笔记本电脑。你认为 Louis 有可能购买笔记本电脑吗？
- en: Association analysis (or *collaborative filtering*) provides an answer to this
    problem. The underlying assumption is that if two people performed similar actions
    in the past (for example, bought a similar product), they are more likely to keep
    performing similar actions in the future. Louis has a similar buying behavior
    to Alice, and Alice bought the laptop. Thus, the recommender system predicts that
    Louis is likely to buy the laptop too.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 关联分析（或*协同过滤*）为这个问题提供了答案。其基本假设是，如果两个人过去做过类似的事情（例如，购买了相似的产品），他们在未来更有可能继续做类似的事情。Louis
    的购买行为与 Alice 相似，而 Alice 购买了笔记本电脑。因此，推荐系统预测 Louis 也可能购买笔记本电脑。
- en: The following code snippet simplifies this problem.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段简化了这个问题。
- en: '***The Code***'
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'Consider the following problem: what fraction of customers bought two ebooks
    together? Based on this data, the recommender system can offer customers a book
    “bundle” to buy if it sees that they originally intended to buy a single book.
    See [Listing 3-29](#list3-29).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题：有多少客户一起购买了两本电子书？基于这些数据，如果推荐系统发现客户原本只打算购买一本书，它就可以为客户提供一本“书籍捆绑”来购买。请参见
    [清单 3-29](#list3-29)。
- en: '[PRE55]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*Listing 3-29: One-liner solution using slicing, the axis argument, the shape
    property, and basic array arithmetic with broadcasting*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-29：使用切片、轴参数、形状属性以及带广播的基本数组运算的单行解决方案*'
- en: What is the output of this code snippet?
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出是什么？
- en: '***How It Works***'
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The basket data array contains one row per customer and one column per product.
    The first two products with column indices 0 and 1 are online courses, and the
    latter two with column indices 2 and 3 are ebooks. The value `1` in cell `(i,j)`
    indicates that customer `i` has bought the product `j`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 购物篮数据数组包含每个顾客一行，每个产品一列。前两个产品的列索引为0和1，是在线课程，后两个产品的列索引为2和3，是电子书。在单元格`(i,j)`中值为`1`表示顾客`i`购买了产品`j`。
- en: 'Our task is to find the fraction of customers who bought both ebooks, so we’re
    interested in only columns 2 and 3\. First, then, you carve out the relevant columns
    from the original array to get the following subarray:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是找到购买了两本电子书的顾客比例，所以我们只关心第2列和第3列。首先，你需要从原始数组中提取相关的列，得到以下子数组：
- en: '[PRE56]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This gives you an array of only the third and the fourth columns.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你一个只有第三列和第四列的数组。
- en: The NumPy `all()` function checks whether all values in a NumPy array evaluate
    to `True`. If this is the case, it returns `True`. Otherwise, it returns `False`.
    When used with the `axis` argument, the function performs this operation along
    the specified axis.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的`all()`函数检查NumPy数组中的所有值是否都评估为`True`。如果是，返回`True`，否则返回`False`。当与`axis`参数一起使用时，函数会沿指定的轴执行此操作。
- en: '**NOTE**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll notice that the `axis` argument is a recurring element for many NumPy
    functions, so it’s worth taking your time to understand the *`axis`* argument
    properly. The specified axis is collapsed into a single value based on the respective
    aggregator function (*`all()`* in this case).*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*你会注意到，`axis`参数是许多NumPy函数中的一个反复出现的元素，因此值得花时间深入理解*`axis`*参数。指定的轴会根据相应的聚合函数（此处为*`all()`*）被压缩为一个单一值。*'
- en: 'Thus, the result of applying the `all()` function on the subarray is the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用`all()`函数在子数组上的结果是：
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In plain English: only the fourth and the last customers have bought both ebooks.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的语言来说：只有第四位和最后一位顾客购买了两本电子书。
- en: Because you are interested in the fraction of customers, you sum over this Boolean
    array, giving you a total of 2, and divide by the number of customers, 8\. The
    result is 0.25, the fraction of customers who bought both ebooks.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你对顾客的比例感兴趣，所以你对这个布尔数组求和，得到总和为2，然后除以顾客的总数8\。结果是0.25，即购买了两本电子书的顾客比例。
- en: In summary, you’ve strengthened your understanding of NumPy fundamentals such
    as the `shape` attribute and the `axis` argument, as well as how to combine them
    to analyze copurchases of different products. Next, you’ll stay with this example
    and learn about more advanced array aggregation techniques using a combination
    of NumPy’s and Python’s special capabilities—that is, *broadcasting* and *list
    comprehension*.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你加深了对NumPy基础知识的理解，如`shape`属性和`axis`参数，以及如何将它们结合起来分析不同产品的共同购买情况。接下来，你将继续使用这个例子，学习使用NumPy和Python的特殊功能——即*广播*和*列表推导*——进行更高级的数组聚合技术。
- en: '**Intermediate Association Analysis to Find Bestseller Bundles**'
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**中级关联分析：寻找畅销商品组合**'
- en: Let’s explore the topic of association analysis in more detail.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨关联分析的主题。
- en: '***The Basics***'
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础知识***'
- en: 'Consider the example of the previous section: your customers purchase individual
    products from a corpus of four different products. Your company wants to upsell
    related products (offer a customer an additional, often related, product to buy).
    For each combination of products, you need to calculate how often they’ve been
    purchased by the same customer, and find the two products purchased together most
    often.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑上一节的例子：你的顾客从四种不同的产品中购买个别商品。你的公司希望通过促销相关产品（向顾客推荐额外的、通常相关的产品）来增加销量。对于每一对产品组合，你需要计算它们被同一顾客购买的频率，并找出最常一起购买的两种产品。
- en: For this problem, you’ve already learned everything you need to know, so let’s
    dive right in!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，你已经学会了所有需要了解的内容，我们直接开始吧！
- en: '***The Code***'
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: This one-liner aims to find the two items that were purchased most often together;
    see [Listing 3-30](#list3-30).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码旨在找到最常一起购买的两件商品；参见[列表 3-30](#list3-30)。
- en: '[PRE58]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Listing 3-30: One-liner solution using a lambda function as the `max()` function’s
    `key` parameter, list comprehension, and Boolean operators with broadcasting*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-30: 使用lambda函数作为`max()`函数的`key`参数，结合列表推导式和布尔运算符进行广播的单行解决方案*'
- en: What’s the output of this one-liner solution?
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码的输出是什么？
- en: '***How It Works***'
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'The data array consists of historical purchasing data with one row per customer
    and one column per product. Our goal is to get a list of tuples: each tuple describes
    a combination of products and how often that combination was bought together.
    For each list element, you want the first two tuple values to be column indices
    (the combination of two products) and the third tuple value to be the number of
    times these products were bought together. For example, the tuple `(0,1,4)` indicates
    that customers who bought *product 0* also bought *product 1* four times.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 数据数组包含历史购买数据，每一行代表一个顾客，每一列代表一个产品。我们的目标是获取一个元组列表：每个元组描述了产品组合及其一起购买的次数。对于每个列表元素，你希望前两个元组值为列索引（即两种产品的组合），第三个元组值为这两种产品一起购买的次数。例如，元组`(0,1,4)`表示购买*产品0*的顾客也购买了*产品1*，共四次。
- en: 'So how can you achieve this? Let’s break down the one-liner, reformatted a
    little here as it’s too wide to fit on a single line:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何实现这一点呢？让我们拆解一下这个单行代码，这里略微调整了一下格式，因为它太宽，无法放在一行内：
- en: '[PRE59]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can see in the outer format `[(..., ..., ...) for ... in ... for ... in
    ...]` that you create a list of tuples by using list comprehension (see [Chapter
    2](ch02.xhtml#ch02)). You’re interested in every unique combination of column
    indices of an array with four columns. Here’s the result of just the outer part
    of this one-liner:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到外部格式`[(..., ..., ...) for ... in ... for ... in ...]`，这是通过列表推导式创建元组列表（参见[第2章](ch02.xhtml#ch02)）。你关注的是一个四列数组中每一对独特的列索引组合。以下是该单行代码外部部分的结果：
- en: '[PRE60]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: So, there are six tuples in the list, each a unique combination of column indices.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，列表中有六个元组，每个都是独特的列索引组合。
- en: 'Knowing this, you can now dive into the third tuple element: the number of
    times these two products `i` and `j` have been bought together:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这一点后，你可以深入查看第三个元组元素：这两种产品`i`和`j`一起购买的次数：
- en: '[PRE61]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You use slicing to extract both columns `i` and `j` from the original NumPy
    array. Then you add them together element-wise. For the resulting array, you check
    element-wise whether the sum is equal to 2, which would indicate that there was
    a 1 in both columns and so both products have been purchased together. The result
    is a Boolean array with `True` values if two products have been purchased together
    by a single customer.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用切片从原始的NumPy数组中提取列`i`和`j`。然后，你将它们按元素相加。对于得到的数组，你按元素检查和是否等于2，这意味着在两个列中都有1，从而表示这两种产品被一起购买。结果是一个布尔数组，如果两个产品被同一个顾客一起购买，值为`True`。
- en: 'You store all resulting tuples in the list `copurchases`. Here are the elements
    of the list:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你将所有结果元组存储在列表`copurchases`中。以下是该列表的元素：
- en: '[PRE62]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now there is one thing left: find the two products that have been co-purchased
    most often:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下一件事：找出最常一起购买的两种产品：
- en: '[PRE63]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You use the `max()` function to find the maximum element in the list. You define
    a key function that takes a tuple and returns the third tuple value (number of
    copurchases), and then find the max out of those values. The result of the one-liner
    is as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`max()`函数找出列表中的最大元素。你定义了一个键函数，该函数接受一个元组并返回第三个元组值（共购次数），然后从这些值中找到最大值。单行代码的结果如下：
- en: '[PRE64]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The second and third products have been purchased together five times. No other
    product combination reaches copurchasing power this high. Hence, you can tell
    your boss to upsell *product 2* when selling *product 1*, and vice versa.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种和第三种产品一共被一起购买了五次。没有其他产品组合能达到这么高的共购频率。因此，你可以告诉你的老板，当销售*产品1*时，推荐*产品2*，反之亦然。
- en: In summary, you’ve learned about various core features of both Python and NumPy,
    such as broadcasting, list comprehension, lambda functions, and the key function.
    Often, the expressive power of your Python code emerges from the combination of
    multiple language elements, functions, and code tricks.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你已经了解了Python和NumPy的各种核心功能，如广播、列表推导式、lambda函数以及关键函数。通常，Python代码的表达力来自于多个语言元素、函数和代码技巧的结合。
- en: '**Summary**'
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned elementary NumPy basics such as array, shape, axis,
    type, broadcasting, advanced indexing, slicing, sorting, searching, aggregating,
    and statistics. You’ve also improved your basic Python skills by practicing important
    techniques such as list comprehension, logics, and lambda functions. Last but
    not least, you’ve improved your ability to read, understand, and write concise
    code quickly, while mastering fundamental data science problems on the way.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了基础的NumPy知识，如数组、形状、轴、类型、广播、先进索引、切片、排序、搜索、聚合和统计。通过练习重要的技巧，比如列表推导式、逻辑运算和lambda函数，你还提升了你的基本Python技能。最重要的是，你提升了快速阅读、理解并编写简洁代码的能力，同时在这个过程中掌握了基本的数据科学问题。
- en: Let’s keep this fast pace of studying various interesting topics in the Python
    space. Next, you’ll dive into the exciting topic of machine learning. You’ll learn
    about basic machine learning algorithms and how to leverage their powerful capabilities
    in a single line of code by using the popular scikit-learn library. Every machine
    learning expert knows this library very well. But fear not—your freshly acquired
    NumPy skills will help you greatly in understanding the code snippets covered
    next.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保持这种快速学习Python相关有趣话题的节奏。接下来，你将深入探索机器学习这个令人兴奋的主题。你将学习基本的机器学习算法，以及如何通过使用流行的scikit-learn库，用一行代码利用它们强大的功能。每个机器学习专家都对这个库非常熟悉。不过不用担心——你刚刚掌握的NumPy技能将极大帮助你理解接下来讲解的代码片段。
