- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DATA SCIENCE**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/comm-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ability to analyze real-world data is one of the most sought-after skills
    in the 21st century. With the help of powerful hardware capabilities, algorithms,
    and ubiquitous sensing, data scientists create meaning from massive-scale raw
    data of weather statistics, financial transactions, customer behavior, and so
    much else. The largest companies in the world today—Google, Facebook, Apple, and
    Amazon—are essentially huge data-processing entities, with data at the heart of
    their business models.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter equips you with the skills to process and analyze numerical data
    by using Python’s library for numerical calculations, *NumPy*. I’ll give you 10
    practical problems and explain how to solve them in a single line of NumPy code.
    Because NumPy is the basis of many high-level libraries for data science and machine
    learning (Pandas, scikit-learn, and TensorFlow, for example), carefully studying
    this chapter will increase your market value in today’s data-driven economy. So,
    give me your full attention!
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Two-Dimensional Array Arithmetic**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here you’ll solve a day-to-day accounting task in a single line of code. I’ll
    introduce some elementary functionalities of NumPy, Python’s wildly important
    library for numerical computations and data science.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the heart of the NumPy library are *NumPy arrays*, which hold the data you
    want to manipulate, analyze, and visualize. Many higher-level data science libraries
    like Pandas build upon NumPy arrays, either implicitly or explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy arrays are similar to Python lists but with some added bonuses. First,
    NumPy arrays have a smaller memory footprint and are faster in most instances.
    Second, NumPy arrays are more convenient when accessing more than two axes, known
    as *multidimensional* data (multidimensional lists are difficult to access and
    modify). Because a NumPy array can consist of more than one axis, we think of
    arrays in terms of *dimensions*: an array with two axes is a two-dimensional array.
    Third, NumPy arrays have more powerful access functionality, such as broadcasting,
    which you’ll learn more about in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-1](#list3-1) exemplifies how to create one-dimensional, two-dimensional,
    and three-dimensional NumPy arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-1: Creating 1D, 2D, and 3D arrays in NumPy*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You start by importing the NumPy library into the namespace by using the de
    facto standard name for the library: `np`. After importing the library, you create
    a NumPy array by passing a standard Python list as an argument to the function
    `np.array()`. A one-dimensional array corresponds to a simple list of numerical
    values (in fact, NumPy arrays can contain other data types too, but we’ll focus
    on numbers here). A two-dimensional array corresponds to a nested *list of lists*
    of numerical values. A three-dimensional array corresponds to a nested *list of
    lists of lists* of numerical values. The number of opening and closing brackets
    gives you the dimensionality of the NumPy array.'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy arrays are more powerful than built-in Python lists. For instance, you
    can calculate basic arithmetic operators `+`, `-`, `*`, and `/` on two NumPy arrays.
    These *element-wise operations* combine two arrays `a` and `b` (for example, adding
    them together with the `+` operator) by combining each element of array `a` with
    the corresponding element of array `b`. In other words, an element-wise operation
    aggregates two elements that are at the same positions in the arrays `a` and `b`.
    [Listing 3-2](#list3-2) shows examples of basic arithmetic operations on two-dimensional
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-2: Basic arithmetic array operations*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When you apply NumPy operators to integer arrays, they try to generate integer
    arrays as results too. Only when dividing two integer arrays by using the division
    operator, *`a / b`*, will the result be a float array. This is indicated by the
    decimal points: *`1.`*, *`0.`*, and *`0.5`*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look closely, you’ll find that each operation combines two corresponding
    NumPy arrays element-wise. When adding two arrays, the result is a new array:
    each new value is the sum of the corresponding value from the first and the second
    array. The same holds true when you use subtraction, multiplication, and division,
    as shown.'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy provides a lot more capabilities for manipulating arrays, including the
    `np.max()` function, which calculates the *maximum* value of all values in a NumPy
    array. The `np.min()` function calculates the *minimum* value of all values in
    a NumPy array. The `np.average()` function calculates the *average* value of all
    values in a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-3](#list3-3) gives an example of these three operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-3: Calculating the maximum, minimum, and average value of a NumPy
    array*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The maximum value of all values in the NumPy array is 2, the minimum value
    is 0, and the average is (1 + 0 + 0 + 1 + 1 + 1 + 2 + 0 + 0) / 9 = 2/3\. NumPy
    has many more powerful tools, but this is already enough to solve the following
    problem: how do we find the maximum after-tax income in a group of people, given
    their yearly salary and tax rates?'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s tackle this problem by using the salary data of Alice, Bob, and Tim. It
    seems like Bob has enjoyed the highest salary in the last three years. But is
    he actually bringing home the most money, considering the individual tax rates
    of our three friends? Take a look at [Listing 3-4](#list3-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-4: One-liner solution using basic array arithmetic*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a guess: what’s the output of this code?'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After importing the NumPy library, you put the data into a two-dimensional
    NumPy array with three rows (one row for each person: Alice, Bob, and Tim) and
    three columns (one column for each year: 2017, 2018, and 2019). You have two two-dimensional
    arrays: `salaries` holds the yearly incomes, and `taxation` holds the taxation
    rates for each person and year.'
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the after-tax income, you need to deduct the tax (as a dollar amount)
    from the gross income stored in the array `salaries`. For this, you use the overloaded
    NumPy operators `-` and `*`, which perform element-wise computations on the NumPy
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The element-wise multiplication of two multidimensional arrays is called the
    *Hadamard product*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-5](#list3-5) shows how the NumPy array looks after deducting the
    taxes from the gross incomes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-5: Basic array arithmetic*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that Bob’s large income is significantly reduced after paying
    40 percent and 50 percent tax rates, shown in the second row.
  prefs: []
  type: TYPE_NORMAL
- en: The code snippet prints the maximum value of this resulting array. The `np.max()`
    function simply finds the maximum value in the array, which you store in `max_income`.
    Thus, the maximum value is Tim’s $90,000 income in 2017, which is taxed at only
    10 percent—the result of the one-liner is `81.` (again, the dot indicates the
    float data type).
  prefs: []
  type: TYPE_NORMAL
- en: You’ve used NumPy’s basic element-wise array arithmetic to analyze the taxation
    rates of a group of people. Let’s use the same example data set in applying intermediate
    NumPy concepts such as slicing and broadcasting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with NumPy Arrays: Slicing, Broadcasting, and Array Types**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This one-liner demonstrates the power of three interesting NumPy features:
    slicing, broadcasting, and array types. Our data is an array of multiple professions
    and salaries. You’ll use the three concepts in combination to increase the salaries
    of just the data scientists by 10 percent every other year.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The crux of our problem is being able to change specific values in a NumPy array
    with many rows. You want to change every other value for one single row. Let’s
    explore the basics you need to know to be able to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Slicing and Indexing**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Indexing and slicing in NumPy are similar to indexing and slicing in Python
    (see [Chapter 2](ch02.xhtml#ch02)): you can access elements of a one-dimensional
    array by using the bracket operation `[]` to specify the index or index range.
    For example, the indexing operation `x[3]` returns the fourth element of the NumPy
    array `x` (because you access the first element with index 0).'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use indexing for a multidimensional array by specifying the index
    for each dimension independently and using comma-separated indices to access the
    different dimensions. For example, the indexing operation `y[0,1,2]` would access
    the first element of the first axis, the second element of the second axis, and
    the third element of the third axis. Note that this syntax would be invalid for
    multidimensional Python lists.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to *slicing* in NumPy. Study the examples in [Listing 3-6](#list3-6)
    to master one-dimensional slicing in NumPy, and feel free to go back to [Chapter
    2](ch02.xhtml#ch02) to revisit basic Python slicing if you have difficulties understanding
    these examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-6: One-dimensional slicing examples*'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to fully understand multidimensional slicing. Much as for indexing,
    you apply one-dimensional slicing separately for each axis (comma-separated) to
    select a range of elements along this axis. Take your time to thoroughly understand
    the examples in [Listing 3-7](#list3-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-7: Multidimensional slicing examples*'
  prefs: []
  type: TYPE_NORMAL
- en: Study [Listing 3-7](#list3-7) until you understand multidimensional slicing.
    You can perform two-dimensional slicing by using the syntax `a[`*`slice1`*`,`
    *`slice2`*`]`. For any additional dimension, add a comma-separated slicing operation
    (using the `start:stop` or `start:stop:step` slicing operators). Each slice selects
    an independent subsequence of the elements in its respective dimension. If you
    understand this basic idea, going from one-dimensional to multidimensional slicing
    is trivial.
  prefs: []
  type: TYPE_NORMAL
- en: '**Broadcasting**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Broadcasting* describes the automatic process of bringing two NumPy arrays
    into the same shape so that you can apply certain element-wise operations (see
    “Slicing and Indexing” on [page 46](#page_46)). Broadcasting is closely related
    to the *shape attribute* of NumPy arrays, which in turn is closely related to
    the concept of axes. So, let’s dive into axes, shapes, and broadcasting next.'
  prefs: []
  type: TYPE_NORMAL
- en: Each array comprises several *axes*, one for each dimension ([Listing 3-8](#list3-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-8: Axes and dimensionality of three NumPy arrays*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see three arrays: `a`, `b`, and `c`. The array attribute `ndim`
    stores the number of axes of this particular array. You simply print it to the
    shell for each array. Array `a` is one-dimensional, array `b` is two-dimensional,
    and array `c` is three-dimensional. Every array has an associated shape attribute,
    a tuple that gives you the number of elements in each axis. For a two-dimensional
    array, there are two values in the tuple: the number of rows and the number of
    columns. For higher-dimensional arrays, the *i*-th tuple value specifies the number
    of elements of the *i*-th axis. The number of tuple elements is therefore the
    dimensionality of the NumPy array.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you increase the dimensionality of an array (for example, you move from
    2D to 3D arrays), the new axis becomes axis 0, and the* i*-th axis of the low-dimensional
    array becomes the (*i *+ 1)-th axis of the high-dimensional array.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-9](#list3-9) gives the shape attributes of the same arrays from
    [Listing 3-8](#list3-8).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-9: The shape property of 1D, 2D, and 3D NumPy arrays*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see that the `shape` attributes contain much more information
    than the `ndim` attributes. Every `shape` attribute is a tuple with the number
    of elements along each axis:'
  prefs: []
  type: TYPE_NORMAL
- en: Array `a` is one-dimensional, so the `shape` tuple has only a single element
    that represents the number of columns (four elements).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array `b` is two-dimensional, so the `shape` tuple has two elements that enumerate
    the number of rows and columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array `c` is three-dimensional, so the `shape` tuple has three elements—one
    for each axis. Axis 0 has two elements (each element is a two-dimensional array),
    axis 1 has three elements (each is a one-dimensional array), and axis 2 has three
    elements (each is an integer value).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you understand the `shape` attribute, it’ll be easier to grasp the
    general idea of broadcasting: bringing two arrays into the same shape by rearranging
    the data. Let’s see how broadcasting works. Broadcasting automatically fixes element-wise
    operations of NumPy arrays with different shapes. For example, the multiplication
    operator `*` usually performs element-wise multiplication when applied to NumPy
    arrays. But what happens if the left and right data don’t match (say, the left
    operator is a NumPy array, while the right is a float value)? In this case, rather
    than throwing an error, NumPy automatically creates a new array from the right-side
    data. The new array has the same size and dimensionality as the array on the left
    and contains the same float values.'
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting, therefore, is the act of converting a low-dimensional array into
    a higher-dimensional array to perform element-wise operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Homogenous Values**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'NumPy arrays are *homogeneous*, meaning all values have the same type. Here
    is a non-exclusive list of possible array data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`bool`** The Boolean data type in Python (1 byte)'
  prefs: []
  type: TYPE_NORMAL
- en: '**`int`** The integer data type in Python (default size: 4 or 8 bytes)'
  prefs: []
  type: TYPE_NORMAL
- en: '**`float`** The float data type in Python (default size: 8 bytes)'
  prefs: []
  type: TYPE_NORMAL
- en: '**`complex`** The complex data type in Python (default size: 16 bytes)'
  prefs: []
  type: TYPE_NORMAL
- en: '**`np.int8`** An integer data type (1 byte)'
  prefs: []
  type: TYPE_NORMAL
- en: '**`np.int16`** An integer data type (2 bytes)'
  prefs: []
  type: TYPE_NORMAL
- en: '**`np.int32`** An integer data type (4 bytes)'
  prefs: []
  type: TYPE_NORMAL
- en: '**`np.int64`** An integer data type (8 bytes)'
  prefs: []
  type: TYPE_NORMAL
- en: '**`np.float16`** A float data type (2 bytes)'
  prefs: []
  type: TYPE_NORMAL
- en: '**`np.float32`** A float data type (4 bytes)'
  prefs: []
  type: TYPE_NORMAL
- en: '**`np.float64`** A float data type (8 bytes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-10](#list3-10) shows how to create NumPy arrays with different types.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-10: NumPy arrays with different types*'
  prefs: []
  type: TYPE_NORMAL
- en: This code has two arrays, `a` and `b`. The first array `a` is of data type `np.int16`.
    The numbers are of type integer (there is no “dot” after the number). Specifically,
    when printing out the `dtype` property of array `a`, you get the result `int16`.
  prefs: []
  type: TYPE_NORMAL
- en: The second array `b` is of data type `float64`. So even if you create the array
    based on a list of integers, NumPy will convert the array type to `np.float64`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important takeaways here: NumPy gives you control over the data
    type, and the data type of a NumPy array is homogeneous.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You have data for a variety of professions, and you want to increase the salaries
    of just the data scientists by 10 percent every other year. [Listing 3-11](#list3-11)
    presents the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-11: One-liner solution using slicing and slice assignments*'
  prefs: []
  type: TYPE_NORMAL
- en: Take a minute and think about the output of this code snippet. What would you
    expect to change? What’s the data type of the resulting array? What is the output
    of this code?
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code snippet places you in the year 2024\. First, you create a NumPy array
    with each row holding the expected yearly salaries of one professional (data scientist,
    product manager, designer, or software engineer). Each column gives the respective
    future years’ salaries in 2025, 2026, and 2027\. The resulting NumPy array has
    four rows and three columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have funds available to reinforce the most important professionals in the
    company. You believe in the future of data science, so you decide to reward the
    hidden heroes of your company: the data scientists. You need to update the NumPy
    array so that only the data scientists’ salaries increase by 10 percent every
    other year (non-cumulatively), starting from the year 2025.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You develop the following beautiful one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks simple and clean, and provides the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Though simple, your one-liner has three interesting and advanced concepts at
    play.
  prefs: []
  type: TYPE_NORMAL
- en: '**Slicing**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, you use the concept of *slices* and *slice assignment*. In the example,
    you use slicing to get every other value of the first row from the NumPy array
    `employees`. Then, you perform some modifications and update every other value
    of the first row by using slice assignment. Slice assignment uses the same syntax
    as slicing, with one crucial difference: you select the slice on the left of the
    assignment. These elements will be replaced by the elements specified on the right
    of the assignment operation. In the code snippet, you replace the content of the
    first row in the NumPy array with the updated salary data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Broadcasting**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Second, you use broadcasting, which automatically fixes element-wise operations
    of NumPy arrays with different shapes. In the one-liner, the left operator is
    a NumPy array, while the right is a float value. Again, NumPy automatically creates
    a new array, making it the same size and dimensionality as the array on the left
    and filling it, conceptually, with copies of the float value. In reality, NumPy
    performs a computation that looks more like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Array Types**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Third, you may have realized that the resulting data type is not float but
    integer, even if you are performing floating-point arithmetic. When you create
    the array, NumPy realizes it contains only integer values, and so assumes it to
    be an integer array. Any operation you perform on the integer array won’t change
    the data type, and NumPy will round down to integer values. Again, you can access
    the array’s type by using the `dtype` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In summary, you’ve learned about slicing, slice assignments, broadcasting,
    and NumPy array types—quite an accomplishment in a one-liner code snippet. Let’s
    build upon that by solving a small data science problem with real-world impact:
    detecting outliers in pollution measurements of various cities.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditional Array Search, Filtering, and Broadcasting to Detect Outliers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this one-liner, you’ll explore air-quality data of cities. Specifically,
    given a two-dimensional NumPy array with pollution measurements (columns) for
    multiple cities (rows), you’ll find the cities that have above-average pollution
    measurements. The skills you’ll acquire by reading this section are important
    in finding outliers in data sets.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Air Quality Index (AQI) measures the danger of adverse health effects and
    is commonly used to compare differences in cities’ air quality. In this one-liner,
    you’re going to look at the AQI of four cities: Hong Kong, New York, Berlin, and
    Montreal.'
  prefs: []
  type: TYPE_NORMAL
- en: The one-liner finds above-average polluted cities, defined as cities that have
    a peak AQI value that is above the overall average among all the measurements
    of all cities.
  prefs: []
  type: TYPE_NORMAL
- en: An important element of our solution will be to find elements in a NumPy array
    that meet a certain condition. This is a common problem in data science you’ll
    use very often.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s explore how to find array elements that meet a specific condition.
    NumPy offers the function `nonzero()` that finds indices of elements in an array
    that are, well, not equal to zero. [Listing 3-12](#list3-12) gives an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-12: The nonzero function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a tuple of two NumPy arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The first array gives the row indices, and the second gives the column indices
    of the nonzero elements. There are four nonzero elements in the two-dimensional
    array: 1, 2, 2, and 3, found at positions `X[0,0]`, `X[1,1]`, `X[1,2]`, and `X[2,0]`
    in the original array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how can you use `nonzero()` to find elements that meet a certain condition
    in your array? You’ll use another great NumPy feature: Boolean array operations
    with broadcasting (see [Listing 3-13](#list3-13))!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-13: Broadcasting and element-wise Boolean operators in NumPy*'
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting occurs as the integer value `2` is copied (conceptually) into a
    new array with the same shape as the array. NumPy then performs an element-wise
    comparison of each integer against the value `2` and returns the resulting Boolean
    array.
  prefs: []
  type: TYPE_NORMAL
- en: In our main code, you’ll combine the `nonzero()` and Boolean array operation
    features to find elements that meet a certain condition.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Listing 3-14](#list3-14),  you’re finding cities with above-average pollution
    peaks from a set of data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-14: One-liner solution using broadcasting, Boolean operators, and
    selective indexing*'
  prefs: []
  type: TYPE_NORMAL
- en: See if you can determine what the output of this code would be.
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The data array `X` contains four rows (one row for each city) and six columns
    (one column for each measurement unit—in this case, days). The string array `cities`
    contains the four names of the cities in the order they occur in the data array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the one-liner that finds the cities with above-average observed AQI
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You first need to understand the parts before you can understand the whole.
    To better understand the one-liner, let’s deconstruct it by starting from within.
    At the heart of the one-liner is the Boolean array operation (see [Listing 3-15](#list3-15)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-15: Boolean array operation using broadcasting*'
  prefs: []
  type: TYPE_NORMAL
- en: You use a Boolean expression to bring both operands to the same shape with broadcasting.
    You use the function `np.average()` to compute the average AQI value of all NumPy
    array elements. The Boolean expression then performs an element-wise comparison
    to come up with a Boolean array that contains `True` if the respective measurement
    observed is an above-average AQI value.
  prefs: []
  type: TYPE_NORMAL
- en: By generating this Boolean array, you know precisely which elements satisfy
    the condition of being above-average and which elements don’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that Python’s `True` value is represented by the integer `1`, and `False` is
    represented by `0`. In fact, the `True` and `False` objects are of type `bool`,
    which is a subclass of `int`. Thus, every Boolean value is also an integer value.
    With this, you can use the function `nonzero()` to find all row and column indices
    that meet the condition, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You have two tuples, the first giving the row indices of nonzero elements, and
    the second giving their respective column indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re looking only for the names of the cities with above-average AQI values,
    and nothing else, so you need just the row indices. You can use these row indices
    to extract the string names from our string array by using *advanced indexing*,
    an indexing technique that allows you to define a sequence of array indices without
    requiring it to be a continuous slice. This way, you can access arbitrary elements
    from a given NumPy array by specifying either a sequence of integers (the indices
    to be selected) or a sequence of Booleans (to select the specific indices where
    the corresponding Boolean value is `True`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice many duplicates in the resulting sequence of strings, because
    Hong Kong and New York have multiple above-average AQI measurements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there is only one thing left to do: remove duplicates. You’ll do this
    by converting the sequence to a Python set, which is by default duplicate-free,
    giving a succinct summary of all city names with pollution that exceeded the average
    AQI values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISE 3-1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the taxation example in “Basic Two-Dimensional Array Arithmetic”
    on [page 42](#page_42) and pull the name of the person with the highest salary
    from the matrix by using this idea of selective Boolean indexing. Problem recap:
    How do we find the person with maximum after-tax income in a group of people,
    given their yearly salary and tax rates?'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, you learned about using Boolean expressions on NumPy arrays (using
    broadcasting again) and the `nonzero()` function to find rows or columns that
    satisfy certain conditions. After saving the environment in this one-liner, let’s
    move on and analyze influencers in social media.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean Indexing to Filter Two-Dimensional Arrays**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here you’ll strengthen your knowledge of array indexing and broadcasting by
    pulling Instagram users with more than 100 million followers from a small data
    set. In particular, given a two-dimensional array of influencers (rows), with
    a first column that defines the influencer’s name as a string and a second column
    that defines the influencer’s follower count, you’ll find all influencer names
    with more than 100 million followers!
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NumPy arrays enrich the basic list data type with additional functionality such
    as multidimensional slicing and multidimensional indexing. Have a look at the
    code snippet in [Listing 3-16](#list3-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-16: Selective (Boolean) indexing in NumPy*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You create two arrays: `a` contains two-dimensional numerical data (think of
    it as the *data array*), and `indices` contains Boolean values (think of it as
    the *indexing array*). A great feature of NumPy is that you can use the Boolean
    array for fine-grained access to the data array. In plain English, you create
    a new array containing only those elements of the data array `a` for which the
    indexing array `indices` contains `True` values at the respective array positions.
    For example, if `indices[i,j]==True`, the new array contains the value `a[i,j]`.
    Similarly, if `indices[i,j]==False`, the new array does not contain the value
    `a[i,j]`. Thus, the resulting array contains the three values `3`, `7`, and `8`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following one-liner, you are going to use this feature for a toy analysis
    of a social network.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Listing 3-17](#list3-17), you’ll find the names of the Instagram superstars
    with more than 100 million followers!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-17: One-liner solution using slicing, array types, and Boolean operators*'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, see if you can compute the result of this one-liner in your head before
    reading through the explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The data consists of a two-dimensional array, `inst`, and each row represents
    an Instagram influencer. The first column states their number of followers (in
    millions), and the second column states their Instagram name. From this data,
    you want to pull the names of the Instagram influencers with more than 100 million
    followers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to solve this in one line. The following approach is the
    easiest one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s deconstruct this one-liner step by step. The inner expression calculates
    a Boolean value that says whether each influencer has more than 100 million followers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first column contains the number of followers, so you use slicing to access
    this data; `inst[:,0]` returns all rows in just the first column. However, because
    the data array contains mixed data types (integers and strings), NumPy automatically
    assigns a non-numerical data type to the array. The reason is that a numerical
    data type would not be able to capture the string data, so NumPy converts the
    data to a type that can represent all data in the array (string and numerical).
    You need to perform numerical comparisons on the first column of the data array
    to check whether each value is larger than 100, so you first convert the resulting
    array into a float type by using `.astype(float)`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you check whether the values in the float type NumPy array are each larger
    than the integer value 100\. Here, NumPy again uses broadcasting to automatically
    bring the two operands into the same shape so it can do the comparison element-wise.
    The result is an array of Boolean values that shows that four influencers have
    more than 100 million followers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You now take this Boolean array (also called a *mask index array*) to select
    the influencers with more than 100 million followers (the rows) by using Boolean
    indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Because you are interested only in the names of these influencers, you select
    the second column as the final result and store it in the `superstars` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The influencers from our data set with more than 100 million Instagram followers
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In summary, you’ve applied NumPy concepts such as slicing, broadcasting, Boolean
    indexing, and data type conversion to a small data science problem in social media
    analysis. Next, you’ll learn about a new application scenario in the Internet
    of Things.
  prefs: []
  type: TYPE_NORMAL
- en: '**Broadcasting, Slice Assignment, and Reshaping to Clean Every i-th Array Element**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Real-world data is seldom clean and may contain errors or missing values for
    a huge variety of reasons, including damaged or faulty sensors. In this section,
    you’ll learn about how to handle small cleaning tasks to eliminate erroneous data
    points.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Say you’ve installed a temperature sensor in your garden to measure temperature
    data over many weeks. Every Sunday, you bring the temperature sensor in from the
    garden to digitize the sensor values. You’re aware that the Sunday sensor values
    are therefore faulty because for part of the day they measure the temperature
    in your home instead of outside.
  prefs: []
  type: TYPE_NORMAL
- en: You want to clean your data by replacing every Sunday sensor value with the
    average sensor value of the previous seven days (you include the Sunday value
    in the average computation because it’s not entirely faulty). Before diving into
    the code, let’s explore the most important concepts you need as a basic understanding.
  prefs: []
  type: TYPE_NORMAL
- en: '**Slice Assignment**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With NumPy’s slice assignment feature (see “[Working with NumPy Arrays: Slicing,
    Broadcasting, and Array Types](#lev-69)” on [page 46](#page_46)), you specify
    the values you want to replace on the left of the equation, and the values to
    replace them with on the right-hand side of the equation. [Listing 3-18](#list3-18)
    provides an example in case you need a small recap.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-18: Simple Python list creation and slice assignment*'
  prefs: []
  type: TYPE_NORMAL
- en: The code snippet creates an array containing the value `4` sixteen times. You
    use slice assignment to replace the last fifteen values with the value `42`. Recall
    that the notation `a[start:stop:step]` selects the sequence starting at index
    `start`, ending at index `stop` (exclusive), and considering only every `step`-th
    sequence element. If no arguments are specified, NumPy assumes default values.
    The notation `a[1::]` replaces all sequence elements but the first one. [Listing
    3-19](#list3-19) shows how to use slice assignment in combination with a feature
    you’ve already seen multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-19: Slice assignment in NumPy*'
  prefs: []
  type: TYPE_NORMAL
- en: Here you replace every other value between index 1 and 8 (exclusive). You can
    see that you need to specify only a single value, `16`, to replace the selected
    elements, because of—you guessed it—*broadcasting*! The right side of the equation
    is automatically transformed into a NumPy array that is the same shape as the
    left array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reshaping**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Before diving into the one-liner, you need to learn about an important NumPy
    function: the `x.reshape((a,b))` function that transforms the NumPy array `x`
    into a new NumPy array with `a` rows and `b` columns (with shape `(a,b)`). Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If the number of columns is unambiguous, you can also let NumPy do the work
    of figuring out the number of columns automatically. Let’s say you want to reshape
    an array with six elements into a two-dimensional array with two rows. NumPy can
    now figure out that it needs three columns to match the six elements in the original
    array. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The shape value `-1` for the column argument indicates that NumPy should replace
    it with the correct number of columns (which is three in this case).
  prefs: []
  type: TYPE_NORMAL
- en: '**The Axis Argument**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, let’s consider the following code snippet that introduces the `axis`
    argument. Here is an array `solar_x` that contains daily stock prices of Elon
    Musk’s SolarX company. We want to calculate the average stock prices in the mornings,
    middays, and evenings. How can we achieve this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The array `solar_x` consists of stock prices of the SolarX company. It has two
    rows (one for each day) and three columns (one for each stock price). Say we want
    to calculate the average stock price in the mornings, the middays, and the evenings.
    Roughly speaking, we want to collapse together all values in each column by averaging
    them. In other words, we calculate the average along axis 0\. This is exactly
    what the keyword argument `axis=0` is doing.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is everything you need to know to solve the following problem ([Listing
    3-20](#list3-20)): given an array of temperature values, replace every seventh
    temperature value with the average of the last seven days (including the seventh
    day’s temperature value).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-20: One-liner solution using the average and reshape operators,
    slice assignments, and the axis argument*'
  prefs: []
  type: TYPE_NORMAL
- en: Can you calculate the output of this code snippet?
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The data arrives in the shape of a one-dimensional array of sensor values.
  prefs: []
  type: TYPE_NORMAL
- en: First, you create the data array `tmp` with a one-dimensional sequence of sensor
    values. In every line, you define all seven sensor values for seven days of the
    week.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you use slice assignment to replace all the Sunday values of this array.
    Because Sunday is the seventh day, you use the expression `tmp[6::7]` to select
    the respective Sunday values, starting from the seventh element in the original
    array `tmp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, we *reshape* the one-dimensional sensor array into a two-dimensional
    array with seven columns and three rows, which makes it easier to calculate the
    weekly average temperature value to replace the Sunday data. Because of the reshaping,
    you can now merge all seven values of each row into a single average value. To
    reshape the array, you pass the tuple values `-1` and `7` to `tmp.reshape()`,
    which tells NumPy that the number of rows (*axis 0*) should be selected automatically.
    Roughly speaking, you specify seven columns, and NumPy creates an array with however
    many rows are needed to satisfy our condition of seven columns. In our case, it
    results in the following array after reshaping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You have one row per week and one column per weekday.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you calculate the seven-day average by collapsing every row into a single
    average value by using the `np.average()` function with the axis argument: `axis=1`
    tells NumPy to collapse the second axis into a single average value. Note that
    the Sunday value is included in the average computation (see the problem formulation
    at the beginning of this section). This is the result of the right-hand side of
    the equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The goal of the one-liner is to replace the three Sunday temperature values.
    All other values should stay constant. Let’s see whether you achieved this objective.
    After replacing all Sunday sensor values, you get the following final result of
    the one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that you still have a one-dimensional NumPy array with all temperature
    sensor values. But now you’ve replaced the unrepresentative readings with more
    representative ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, this one-liner is all about hammering down the concepts of array
    shapes and reshaping, and how to use the `axis` property for aggregator functions
    such as `np.average()`. While this application was rather specific, it will be
    useful in a range of situations. Next, you’ll learn about a super general concept:
    sorting in NumPy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Use the sort() Function and When to Use the argsort() Function in
    NumPy**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sorting is useful, even essential, in numerous situations. Say you search your
    bookshelf for *Python One-Liners*. It would be much easier to find the book if
    your bookshelf were alphabetically sorted by title.
  prefs: []
  type: TYPE_NORMAL
- en: This one-liner solution will show you how to use sorting in a single line of
    Python by using NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sorting is at the heart of more advanced applications such as commercial computing,
    process scheduling in operating systems (priority queues), and search algorithms.
    Fortunately, NumPy provides various sorting algorithms. The default is the popular
    *Quicksort* algorithm. In [Chapter 6](ch06.xhtml#ch06), you’ll learn how to implement
    the Quicksort algorithm yourself. However, for this one-liner, you’ll take a higher-level
    approach, viewing the sorting function as a black box into which you’ll put a
    NumPy array to get out a sorted NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-1](#ch03fig01) shows the algorithm transforming an unsorted array
    into a sorted array. This is the purpose of NumPy’s `sort()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig3-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: The difference between the `sort()` and `argsort()` functions*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But often, it’s also important to get the array of indices that would transform
    the unsorted array into a sorted array. For example, the unsorted array element
    1 has index `7`. Because the array element 1 is the first element of the sorted
    array, its index `7` is the first element of the sorted indices. This is what
    NumPy’s `argsort()` function does: it creates a new array of the original index
    values after sorting (see the example in [Figure 3-1](#ch03fig01)). Roughly speaking,
    these indices would sort the elements in the original array. By using this array,
    you can reconstruct both the sorted and the original array.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-21](#list3-21) demonstrates the use of `sort()` and `argsort()`
    in NumPy.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-21: The `sort()` and `argsort()` functions in NumPy*'
  prefs: []
  type: TYPE_NORMAL
- en: You create an unsorted array `a`, sort it with `np.sort(a)`, and get the original
    indices in their new sorted order with `np.argsort(a)`. NumPy’s `sort()` function
    is different from Python’s `sorted()` function in that it can sort multidimensional
    arrays too!
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-2](#ch03fig02) shows two ways of sorting a two-dimensional array.'
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig3-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: Sorting along an axis*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The array has two axes: axis 0 (the rows) and axis 1 (the columns). You can
    sort along axis 0, known as *vertical sorting*, or along axis 1, known as *horizontal
    sorting*. In general, the `axis` keyword defines the direction along which you
    perform the NumPy operation. [Listing 3-22](#list3-22) shows technically how to
    do this.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-22: Sorting along an axis*'
  prefs: []
  type: TYPE_NORMAL
- en: The optional `axis` argument helps you sort the NumPy array along a fixed direction.
    First, you sort by columns, starting with the smallest value. Then you sort by
    rows. This is the main strength of NumPy’s `sort()` function compared to Python’s
    built-in `sorted()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This one-liner will find the names of the top three students with the highest
    SAT scores. Note that you’ll ask for the student names and not the sorted SAT
    scores. Have a look at the data and see if you can find the one-liner solution
    yourself. When you’ve had a go at that, take a look at [Listing 3-23](#list3-23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-23: One-liner solution using the `argsort()` function and slicing
    with negative step size*'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, try to figure out the output.
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our initial data consists of the SAT scores of students as a one-dimensional
    data array, and another array with the corresponding names of the students. For
    example, John achieved a solid SAT score of 1100, while Frank achieved an excellent
    SAT score of 1412.
  prefs: []
  type: TYPE_NORMAL
- en: The task is to find the names of the three most successful students. You’ll
    achieve this—not by simply sorting the SAT scores—but by running the `argsort()`
    function to get an array of the original indices in their new sorted positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output of the `argsort()` function on the SAT scores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You need to retain the indexes because you need to be able to find the name
    of the student from the `students` array, which corresponds only to the original
    positions. Index 4 is at the first position of the output because Jane has the
    lowest SAT score, with 989 points. Note that both `sort()` and `argsort()` sort
    in an ascending manner, from lowest to highest values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have sorted indices, you need to get the names of the respective
    students by indexing the `student` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a useful feature of the NumPy library: you can reorder a sequence by
    using advanced indexing. If you specify a sequence of indices, NumPy triggers
    advanced indexing and returns a new NumPy array with reordered elements as specified
    by your index sequence. For instance, the command `students[np.argsort(sat_scores)]`
    evaluates to `students[[4 3 0 1 6 5 2]]` so NumPy creates a new array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, you know that Jane has the lowest SAT score, while Alice has the
    highest. The only thing left is to reverse the list and extract the top three
    students by using simple slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Alice, Frank, and Carl have the highest SAT scores of 1543, 1412, and 1343,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, you’ve learned about the application of two important NumPy functions:
    `sort()` and `argsort()`. Next, you’ll improve your advanced understanding of
    NumPy indexing and slicing by using Boolean indexing and lambda functions in a
    practical data science problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How to Use Lambda Functions and Boolean Indexing to Filter Arrays**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Real-world data is noisy. As a data scientist, you get paid to get rid of the
    noise, make the data accessible, and create meaning. Filtering data is therefore
    vital for real-world data science tasks. In this section, you’ll learn how to
    create a minimal filter function in a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create a function in one line, you’ll need to use *lambda functions*. As
    you know from [Chapter 2](ch02.xhtml#ch02), lambda functions are anonymous functions
    that you can define in a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You define a comma-separated list of arguments that serve as inputs. The lambda
    function then evaluates the expression and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how to solve our problem by creating a filter function using the
    lambda function definition.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following problem, depicted in [Listing 3-24](#list3-24): create
    a filter function that takes a list of books `x` and a minimum rating `y` and
    returns a list of potential bestsellers that have higher than minimum rating,
    `y''>y`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-24: One-liner solution using lambda functions, type conversion,
    and Boolean operators*'
  prefs: []
  type: TYPE_NORMAL
- en: Take a guess at the output of this code before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The data consists of a two-dimensional NumPy array in which each row holds the
    name of the book title and the average user rating (a floating-point number between
    0.0 and 5.0). There are six books in the rated data set.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to create a filter function that takes as input the book rating
    data set `x` and a threshold rating `y`, and returns the books that have a higher
    rating than the threshold `y`. You set the threshold to 3.9.
  prefs: []
  type: TYPE_NORMAL
- en: 'You achieve this by defining an anonymous lambda function that returns the
    result of the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The array `x` is assumed to have two columns as our book rating array `books`.
    To access the potential bestsellers, you use an advanced indexing scheme similar
    to the one in [Listing 3-17](#list3-17).
  prefs: []
  type: TYPE_NORMAL
- en: First, you carve out the second column ➊ that holds the book ratings and convert
    it to a float array by using the `astype(float)` method ➋ on the NumPy array `x`.
    This is necessary because the initial array `x` consists of mixed data types (float
    and strings).
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you create a Boolean array that holds the value `True` if the book
    at the respective row index has a rating larger than `y` ➌. Note that the float
    `y` is implicitly broadcasted to a new NumPy array so that both operands of the
    Boolean operator `>` have the same shape. At this point, you’ve created a Boolean
    array indicating for each book whether it can be considered a bestseller: `x[:,1].astype(float)>
    y = [ True True True False False True]`. So, the first three books and the last
    one are bestsellers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, we use the Boolean array as an indexing array on the original book rating
    array to carve out all the books that have above-threshold ratings. More specifically,
    we use Boolean indexing `x[[ True True True False False True]]` to get a subarray
    of the original array with only four books: the ones with `True` value. This results
    in the following final output of this one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In summary, you’ve learned how to filter data using only Boolean indexing and
    lambda functions. Next, you’ll dive into logical operators and learn a useful
    trick to write the logical and operation concisely.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to Create Advanced Array Filters with Statistics, Math, and Logic**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section shows you the most basic outlier detection algorithm: if an observed
    value deviates from the mean by more than the standard deviation, it is considered
    an *outlier*. You’ll work through an example of analyzing website data to determine
    the number of active users, the bounce rate, and the average session duration
    in seconds. (The *bounce rate* is the percentage of visitors who leave immediately
    after visiting only one website. A high bounce rate is a bad signal: it might
    indicate that a site is boring or irrelevant.) You’ll look at the data and identify
    outliers.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To solve the outlier detection problem, you’ll first study three basic skills:
    understanding the mean and standard deviation, finding the absolute value, and
    performing the logical and operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding Mean and Standard Deviation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, you’ll slowly develop our definition of an outlier by using basic statistics.
    You’ll make the basic assumption that all observed data is normally distributed
    around a mean value. For example, consider the following sequence of data values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If you plot the histogram of this sequence, you’ll get the result in [Figure
    3-3](#ch03fig03).
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence seems to resemble a *normal distribution* with a *mean* value
    of 10 and a *standard deviation* of 1\. The mean, denoted with a μ symbol, is
    the average value of all sequence values. The standard deviation, denoted with
    a σ symbol, measures the variation of a data set around the mean value. By definition,
    if the data is truly normally distributed, 68.2 percent of all sample values fall
    into the standard deviation interval [ω[1] = μ – σ,ω[2] = μ + σ]. This provides
    a range for outliers: anything that doesn’t fall within the range is considered
    an outlier.'
  prefs: []
  type: TYPE_NORMAL
- en: In the example, I generated the data from the normal distribution μ=10 and σ=1,
    which results in the interval ω[1] = μ – 1 = 9 and ω[2] = μ + 1 = 11\. In the
    following, you simply assume that *any observed value that is outside the interval
    marked by the standard deviation around the mean is an outlier*. For our data,
    this means that any value that doesn’t fall into the interval [9,11] is an outlier.
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig3-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: Histogram of the sequence of data values*'
  prefs: []
  type: TYPE_NORMAL
- en: The simple code I used to generate the plot is shown in [Listing 3-25](#list3-25).
    Can you find the code lines that define the mean and standard deviation?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-25: Plotting the histogram by using the Matplotlib library*'
  prefs: []
  type: TYPE_NORMAL
- en: This code shows how to plot a histogram by using Python’s Matplotlib library.
    However, this is not the focus of this section; I want to highlight only how you
    can create the preceding sequence of data values.
  prefs: []
  type: TYPE_NORMAL
- en: Simply import the NumPy library and use the module `np.random`, which provides
    a function `normal(mean, deviation, shape)` that creates a new NumPy array with
    values randomly drawn from the normal distribution with a given mean and standard
    deviation. This is where you set `mean=10.0` and `deviation=1.0` to create the
    data in the sequence. In this case, setting `shape=500` indicates that you’re
    interested in only a one-dimensional data array with 500 data points. The remaining
    code imports the special xkcd plot styling `plt.xkcd()`, plots the histogram based
    on the sequence using `plt.hist(sequence)`, styles the plot with annotations,
    and outputs the final plot.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The name of the xkcd plot is taken from the popular web comic page xkcd ([https://xkcd.com/](https://xkcd.com/)).*'
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the one-liner, let’s quickly explore the other two basic
    skills you’ll need to complete this task.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Absolute Value**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Second, you need to turn negative values into positive, so you can check whether
    each outlier deviates more than the standard deviation from the mean. You are
    interested in only the absolute deviation, not in whether it’s positive or negative.
    This is known as taking the *absolute value*. The NumPy function in [Listing 3-26](#list3-26)
    creates a new NumPy array with the absolute values of the original.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-26: Calculating the absolute value in NumPy*'
  prefs: []
  type: TYPE_NORMAL
- en: The function `np.abs()` converts the negative values in a NumPy array into their
    positive counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performing the Logical And Operation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Third, the following NumPy function performs an element-wise *logical and* operation
    to combine two Boolean arrays `a` and `b` and give back an array that combines
    the *individual* Boolean values using the logical and operation (see [Listing
    3-27](#list3-27)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-27: The logical and operation applied to NumPy arrays*'
  prefs: []
  type: TYPE_NORMAL
- en: You combine each element at index *i* of array `a` with element *i* of array
    `b` by using `np.logical_and(a, b)`. The result is an array of Boolean values
    that are `True` if both operands `a[`*`i`*`]` and `b[`*`i`*`]` are already `True`,
    and `False` otherwise. In this way, you can combine multiple Boolean arrays into
    a single Boolean array by using standard logical operations. One useful application
    of this is to combine *Boolean filter arrays* as done in the following one-liner.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can also *multiply* two Boolean arrays `a` and `b`—and this is
    equivalent to the `np.logical_and(a, b)` operation. Python represents a `True`
    value as an integer value `1` (or really any integer value different from `0`)
    and a `False` value as an integer value `0`. If you multiply anything by `0`,
    you get `0`, and therefore `False`. That means you’ll receive a `True` result
    (an integer value `>1`) only when all operands are already `True`.
  prefs: []
  type: TYPE_NORMAL
- en: With this information, you are now fully equipped to understand the following
    one-liner code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This one-liner will find all outlier days for which the statistics deviate more
    than the standard deviation from their mean statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-28: One-liner solution using the mean function, standard deviation,
    and Boolean operators with broadcasting*'
  prefs: []
  type: TYPE_NORMAL
- en: Can you guess the output of this code snippet?
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The data set consists of rows that represent different days, and three columns
    that represent daily active users, bounce rate, and average session duration in
    seconds, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: For each column, you calculate the mean value and the standard deviation. For
    example, the mean value of the Daily Active Users column is 811.2, and its standard
    deviation is 152.97\. Note that you use the `axis` argument in the same way as
    in “[Broadcasting, Slice Assignment, and Reshaping to Clean Every *i*-th Array
    Element](#lev-81)” on [page 60](#page_60).
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to detect websites that are outliers in all three columns. For the
    Daily Active Users column, every observed value that is smaller than 811.2 – 152.97
    = 658.23 or larger than 811.2 + 152.23 = 963.43 is considered an outlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you consider a whole *day* to be an outlier only if all three observed
    columns are outliers. You achieve this by combining the three Boolean arrays using
    the logical and operator. The result is only a single row for which all three
    columns are outliers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In summary, you have learned about the NumPy’s logical and operator and how
    to use it to perform basic outlier detection, while making use of simple statistical
    measures from the NumPy library. Next, you’ll learn about a secret ingredient
    of Amazon’s success: coming up with relevant recommendations of products to buy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Association Analysis: People Who Bought X Also Bought Y**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you ever bought a product recommended by Amazon’s algorithms? The recommendation
    algorithms are often based on a technique called *association analysis*. In this
    section, you’ll learn about the basic idea of association analysis and how to
    dip your toe into the deep ocean of recommender systems.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Association analysis is based on historical customer data, such as the “people
    who bought *x* also bought *y*” data on Amazon. This association of different
    products is a powerful marketing concept because it not only ties together related
    but complementary products, but also provides you with an element of *social proof*—knowing
    that other people have bought a product increases the psychological safety for
    you to buy the product yourself. This is an excellent tool for marketers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at a practical example in [Figure 3-4](#ch03fig04).
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/fig3-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: Product-Customer matrix—which customer has bought which product?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The four customers Alice, Bob, Louis, and Larissa bought different combinations
    of the products: book, game, soccer ball, laptop, headphones. Imagine that you
    know every product bought by all four persons, but not whether Louis has bought
    the laptop. What do you think: is Louis likely to buy the laptop?'
  prefs: []
  type: TYPE_NORMAL
- en: Association analysis (or *collaborative filtering*) provides an answer to this
    problem. The underlying assumption is that if two people performed similar actions
    in the past (for example, bought a similar product), they are more likely to keep
    performing similar actions in the future. Louis has a similar buying behavior
    to Alice, and Alice bought the laptop. Thus, the recommender system predicts that
    Louis is likely to buy the laptop too.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet simplifies this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following problem: what fraction of customers bought two ebooks
    together? Based on this data, the recommender system can offer customers a book
    “bundle” to buy if it sees that they originally intended to buy a single book.
    See [Listing 3-29](#list3-29).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-29: One-liner solution using slicing, the axis argument, the shape
    property, and basic array arithmetic with broadcasting*'
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of this code snippet?
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The basket data array contains one row per customer and one column per product.
    The first two products with column indices 0 and 1 are online courses, and the
    latter two with column indices 2 and 3 are ebooks. The value `1` in cell `(i,j)`
    indicates that customer `i` has bought the product `j`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our task is to find the fraction of customers who bought both ebooks, so we’re
    interested in only columns 2 and 3\. First, then, you carve out the relevant columns
    from the original array to get the following subarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This gives you an array of only the third and the fourth columns.
  prefs: []
  type: TYPE_NORMAL
- en: The NumPy `all()` function checks whether all values in a NumPy array evaluate
    to `True`. If this is the case, it returns `True`. Otherwise, it returns `False`.
    When used with the `axis` argument, the function performs this operation along
    the specified axis.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You’ll notice that the `axis` argument is a recurring element for many NumPy
    functions, so it’s worth taking your time to understand the *`axis`* argument
    properly. The specified axis is collapsed into a single value based on the respective
    aggregator function (*`all()`* in this case).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the result of applying the `all()` function on the subarray is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In plain English: only the fourth and the last customers have bought both ebooks.'
  prefs: []
  type: TYPE_NORMAL
- en: Because you are interested in the fraction of customers, you sum over this Boolean
    array, giving you a total of 2, and divide by the number of customers, 8\. The
    result is 0.25, the fraction of customers who bought both ebooks.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, you’ve strengthened your understanding of NumPy fundamentals such
    as the `shape` attribute and the `axis` argument, as well as how to combine them
    to analyze copurchases of different products. Next, you’ll stay with this example
    and learn about more advanced array aggregation techniques using a combination
    of NumPy’s and Python’s special capabilities—that is, *broadcasting* and *list
    comprehension*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Intermediate Association Analysis to Find Bestseller Bundles**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s explore the topic of association analysis in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the example of the previous section: your customers purchase individual
    products from a corpus of four different products. Your company wants to upsell
    related products (offer a customer an additional, often related, product to buy).
    For each combination of products, you need to calculate how often they’ve been
    purchased by the same customer, and find the two products purchased together most
    often.'
  prefs: []
  type: TYPE_NORMAL
- en: For this problem, you’ve already learned everything you need to know, so let’s
    dive right in!
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This one-liner aims to find the two items that were purchased most often together;
    see [Listing 3-30](#list3-30).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-30: One-liner solution using a lambda function as the `max()` function’s
    `key` parameter, list comprehension, and Boolean operators with broadcasting*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the output of this one-liner solution?
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The data array consists of historical purchasing data with one row per customer
    and one column per product. Our goal is to get a list of tuples: each tuple describes
    a combination of products and how often that combination was bought together.
    For each list element, you want the first two tuple values to be column indices
    (the combination of two products) and the third tuple value to be the number of
    times these products were bought together. For example, the tuple `(0,1,4)` indicates
    that customers who bought *product 0* also bought *product 1* four times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So how can you achieve this? Let’s break down the one-liner, reformatted a
    little here as it’s too wide to fit on a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see in the outer format `[(..., ..., ...) for ... in ... for ... in
    ...]` that you create a list of tuples by using list comprehension (see [Chapter
    2](ch02.xhtml#ch02)). You’re interested in every unique combination of column
    indices of an array with four columns. Here’s the result of just the outer part
    of this one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: So, there are six tuples in the list, each a unique combination of column indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing this, you can now dive into the third tuple element: the number of
    times these two products `i` and `j` have been bought together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You use slicing to extract both columns `i` and `j` from the original NumPy
    array. Then you add them together element-wise. For the resulting array, you check
    element-wise whether the sum is equal to 2, which would indicate that there was
    a 1 in both columns and so both products have been purchased together. The result
    is a Boolean array with `True` values if two products have been purchased together
    by a single customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You store all resulting tuples in the list `copurchases`. Here are the elements
    of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now there is one thing left: find the two products that have been co-purchased
    most often:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You use the `max()` function to find the maximum element in the list. You define
    a key function that takes a tuple and returns the third tuple value (number of
    copurchases), and then find the max out of those values. The result of the one-liner
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The second and third products have been purchased together five times. No other
    product combination reaches copurchasing power this high. Hence, you can tell
    your boss to upsell *product 2* when selling *product 1*, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, you’ve learned about various core features of both Python and NumPy,
    such as broadcasting, list comprehension, lambda functions, and the key function.
    Often, the expressive power of your Python code emerges from the combination of
    multiple language elements, functions, and code tricks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned elementary NumPy basics such as array, shape, axis,
    type, broadcasting, advanced indexing, slicing, sorting, searching, aggregating,
    and statistics. You’ve also improved your basic Python skills by practicing important
    techniques such as list comprehension, logics, and lambda functions. Last but
    not least, you’ve improved your ability to read, understand, and write concise
    code quickly, while mastering fundamental data science problems on the way.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s keep this fast pace of studying various interesting topics in the Python
    space. Next, you’ll dive into the exciting topic of machine learning. You’ll learn
    about basic machine learning algorithms and how to leverage their powerful capabilities
    in a single line of code by using the popular scikit-learn library. Every machine
    learning expert knows this library very well. But fear not—your freshly acquired
    NumPy skills will help you greatly in understanding the code snippets covered
    next.
  prefs: []
  type: TYPE_NORMAL
