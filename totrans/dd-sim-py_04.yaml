- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Syntax Crash Course
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Python is an unusual mix of common and unique concepts. Before diving into the
    intricacies of the language, you must first grasp its essential syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn most of the essential syntactic structures you’ll
    encounter in Python, and you’ll also become familiar with the basic mathematical
    and logical features of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Python developers will point newcomers to the official Python tutorial,
    which is an excellent introduction to the language’s structure. While I’ll cover
    all of these concepts in this book in depth, the tutorial is still a good resource
    worth reading: [https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/).'
  prefs: []
  type: TYPE_NORMAL
- en: Hello, World!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It won’t feel like a proper introduction to the language without the classic
    Hello World program. In Python, it’s written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-1: *hello_world.py*'
  prefs: []
  type: TYPE_NORMAL
- en: There’s nothing novel here. You call the `print()` function to write text to
    the console, and you pass data in a string, wrapped in quotes as an argument.
    You can pass whatever sort of data you like, and it will be output on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can also get input from the console with the `input()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-2: *hello_input.py*'
  prefs: []
  type: TYPE_NORMAL
- en: I use the `input()` function and pass my prompt as a string ❶. When I run that
    code, Python greets me using the name I entered on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Statements and Expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each line of code in Python that ends with a line break is a *statement*, sometimes
    more specifically known as a *simple statement*. Unlike in many C-inspired languages,
    you don’t need to end a line in Python with a special character.
  prefs: []
  type: TYPE_NORMAL
- en: A section of code that evaluates to a single value is called an *expression*.
    In Python, you can put expressions nearly anywhere a value is expected. The expression
    is evaluated down to a value, and that value is used in that position in the statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in one statement, I can create a variable, and in another statement,
    I can print its contents to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-3: *hello_statements.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: I assign the expression `"Hello, world!"` to `message`, and then I pass the
    expression `message` to `print()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever need to place multiple statements on the same line, you can separate
    them with a semicolon (`;`). To demonstrate this, here are the same two statements
    as earlier, but packed onto one line, with a semicolon to separate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-4: *hello_statements.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: While this is valid code, using this technique is somewhat discouraged. The
    Python philosophy places a high value on readability, and the placement of multiple
    statements on the same line often detracts from that.
  prefs: []
  type: TYPE_NORMAL
- en: Stick to placing one statement per line, unless you have a specific reason to
    do otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The Importance of Whitespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re looking at a sample of Python source code, the first thing that
    will probably jump out at you is the use of indentation for nesting. A *compound
    statement* is made up of one or more *clauses*, each of which consists of a line
    of code called a *header* and a block of code called a *suite*, which is associated
    with the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this program prints different messages, depending on whether a
    `name` is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-5: *hello_conditional.py*'
  prefs: []
  type: TYPE_NORMAL
- en: I set up a conditional statement with an `if` header ❶, after which I have a
    suite made up of two indented lines of code, which “belongs” to the header. These
    lines of code are executed only if the conditional expression in the header is
    evaluated to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: The unindented line ❷ is not part of the suite that belongs to the conditional
    statement, and it will be run every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I nest deeper, I need to add more indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-6: *weather_nested_conditional.py*'
  prefs: []
  type: TYPE_NORMAL
- en: The first `print` statement is indented twice, which is how Python knows that
    it belongs to both preceding conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: Given the importance of whitespace, the “tabs versus spaces” war is fairly common
    in Python world. You’ll remember from Chapter 2 that the PEP 8 style guide stresses
    using either four spaces or a single tab per indentation level. ***Consistency
    is key!*** Python really doesn’t care whether you use tabs, two spaces, four spaces,
    or even seven spaces (although that’s probably a step too far) for each level
    of indentation. The point is to be consistent within any and every given block
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: You should use only one indentation style throughout your project, even if your
    situation provides a technical loophole. Don’t mix tabs and spaces. Chances are
    your IDE has tools to help you with this.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity’s sake, I’ll use the PEP 8 convention of four spaces throughout
    my code examples. While I’d recommend you follow this same convention—you can
    even configure your editor to insert four spaces each time you hit the Tab key—if
    you have a strong preference for tabs, you’re welcome to use those instead. It
    really doesn’t matter.
  prefs: []
  type: TYPE_NORMAL
- en: Doing Nothing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On occasion, you will need to insert a statement that has absolutely no effect.
    This is particularly useful when you need to put a syntactically valid placeholder
    where a suite of code will exist later. For this purpose, Python provides the
    `pass` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I can employ the `pass` keyword as a placeholder in my `if raining`
    conditional, until I’m able to write the final code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-7: *raining_pass.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Just remember, `pass` does absolutely nothing. That’s the only reason it exists.
  prefs: []
  type: TYPE_NORMAL
- en: Comments and Docstrings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write comments in Python, precede the line with a hash (`#`). Everything
    between the hash and the end of the line is a comment and will be ignored by the
    interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-8: *comments.py*'
  prefs: []
  type: TYPE_NORMAL
- en: If you ran this program, the `print` statements would both execute. The rest
    of the second `print` statement, from the hash onward, is an inline comment ❶
    and would be ignored by the interpreter. All the other lines are only comments.
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Officially, there is no syntax for “multiline” comments; you just comment each
    line. There is one special exception: the *docstring*. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-9: *docstrings.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I define a function that would (theoretically) make tea, and I place the description
    of the function inside a docstring.
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings exist to provide documentation for functions, classes, and modules,
    especially public ones. They conventionally begin and end with three quotation
    marks (`"""`), allowing the string to automatically span multiple lines. You would
    typically place docstrings at the top, inside of whatever they’re defining, such
    as in the function above.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important distinctions between comments and docstrings:'
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings are string literals, and they are seen by the interpreter; comments
    are ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docstrings are used in automatic documentation generation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docstrings are generally only docstrings when they appear at the top of the
    module, function, class, or method they define. Comments can live anywhere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is perfectly possible to use a triple-quoted string literal to write a sort
    of “multiline comment,” but it’s not recommended, since a string literal can easily
    get left in a place where Python will try to use it as a value.
  prefs: []
  type: TYPE_NORMAL
- en: In short, use docstrings as intended, and stick with comments for everything
    else. Many Python IDEs have hotkeys for toggling comments on a selection, which
    can save you a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can access these docstrings later in my code. For instance, given the previous
    example, I can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-10: *docstrings.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings have their own style conventions, which are outlined in depth in
    PEP 257.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have already noticed that Python doesn’t have a distinct keyword for
    declaring a new variable (technically called a *name* in this language; see Chapter
    5). Here, I define two variables—`name` and `points`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-11: *variables.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Python is *dynamically typed*, meaning the data type of a value is determined
    when it is evaluated. This contrasts with statically typed languages, in which
    you declare the data type initially. (C++ and Java are both statically typed.)
  prefs: []
  type: TYPE_NORMAL
- en: With Python, you can assign a value to a name anytime, by using the assignment
    operator (`=`). It infers the data type. If the name is a new variable, Python
    will create it; if the name already exists, Python will change the value. It’s
    a pretty straightforward system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, there are only two rules to follow with Python variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a variable before you access it; otherwise, you’ll get an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t change what kind of data you’re storing in the variable, even when replacing
    a value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python is considered a *strongly typed language*, meaning you usually can’t
    magically combine data of different types. For example, it won’t allow you to
    add an integer and a string together. On the other hand, *weakly typed* languages
    let you do practically anything with different data types, and they try to figure
    out how to do what you asked for. (JavaScript is weakly typed.) There’s an entire
    spectrum between those last two terms and plenty of debate about what behaviors
    qualify under which name. While Python is decidedly in the “strongly typed” camp,
    it still has weaker typing than some languages.
  prefs: []
  type: TYPE_NORMAL
- en: Python is, however, *weakly bound*, so it is possible to assign a value of a
    different type to an existing variable. While this is technically permissible,
    it is strongly discouraged, as it can produce confusing code.
  prefs: []
  type: TYPE_NORMAL
- en: What About Constants?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python doesn’t have any formally defined constants. In keeping with PEP 8, you
    would indicate a variable is intended to be treated as a constant by using all-caps
    names with underscores. This naming convention is sometimes humorously referred
    to as *screaming snake case* for the all-caps (screaming) and the underscores
    (snakes). For example, the name `INTEREST_RATE` indicates that you don’t want
    the variable redefined or changed in any way. While the interpreter itself won’t
    prevent the variable from being modified, your linter will usually complain if
    you do.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has all the math functionality you would expect from a good programming
    language; its excellent support for both simple and complicated mathematics is
    one of the reasons Python is popular for scientific programming, data processing,
    and statistical analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Meet the Number Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before I get into the operations, you should be aware of the three data types
    used for storing numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '*Integers* (`int`) store whole numbers. In Python, integers are always signed
    and effectively have no maximum value. Integers use decimal base (base-10) by
    default, but they can also be specified in binary (`0b101010`), octal (`0o52`),
    or hexadecimal (`0x2A`).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Floating-point numbers* (`float`) store numbers with a decimal part (for example,
    `3.141592`). You can also use scientific notation (for example, `2.49e4`). Internally,
    values are stored as double-precision, IEEE 754 floating-point numbers, which
    are subject to the limits inherent in that format. (For more insight into the
    limits and gotchas of floating-point arithmetic, read the article “What Every
    Computer Scientist Should Know About Floating-Point Arithmetic” by David Goldberg:
    [https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.xhtml](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.xhtml)*.*)'
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify an invalid number with `float("nan")`, a number larger
    than the largest possible value with `float("inf")`, or a number smaller than
    the smallest possible value with `float("-inf")`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I wrapped the special values in quotes. This is necessary if you
    want to use these values without *importing* the `math` module (see Chapter 4
    for more about importing). If you have imported the `math` module (see “The `math`
    Module” subsection below), you can use the constants `nan`, `inf`, and so forth,
    instead of the quoted versions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Complex numbers* (`complex`) can store imaginary numbers by appending `j`
    to the value, as in `42j`. You can combine a real part with the imaginary part,
    using addition: `24+42j`.'
  prefs: []
  type: TYPE_NORMAL
- en: In case you missed it in math class, an imaginary number has the square root
    of negative one as one of its factors, even though this value is utterly impossible;
    there is no value that you can multiply by itself to get negative one! Yet imaginary
    numbers definitely show up in real-world math. Spooky, no?
  prefs: []
  type: TYPE_NORMAL
- en: '*Decimal* and *Fraction* are two of the additional object types for storing
    numeric data. `Decimal` stores fixed-point decimal numbers, while `Fraction` does
    the same for fractions. To use either, you’ll need to import them first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief example that uses both types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-12: *fractions_and_decimals.py*'
  prefs: []
  type: TYPE_NORMAL
- en: The `float()` function turns `Fraction` and `Decimal` objects into floats.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python has the usual operators, with a couple of additions that may not be familiar
    to some developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a bit of code that will demonstrate the math operators. I’ll wrap each
    equation inside a `print()` statement, so you can run the code and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-13: *math_operators.py*'
  prefs: []
  type: TYPE_NORMAL
- en: The *unary* (one-operand) negative operator flips the sign of whatever follows
    it. The `abs()` function is technically considered a unary operator as well. The
    rest of the operators here are *binary*, meaning they accept two operands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-14: *augmented_assignment_operators.py*'
  prefs: []
  type: TYPE_NORMAL
- en: If you need both floor division (`//`) and modulo (`%`) on the same operands,
    Python provides the `divmod()` function to efficiently perform the calculation,
    returning the two results in a tuple. Thus, `c = divmod(a, b)` is the same as
    `c = (a // b, a % b)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python also has `bitwise` operators, which I’ll list below for those readers
    already familiar with bitwise arithmetic. I won’t introduce these concepts until
    Chapter 12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-15: *bitwise_operators.py*'
  prefs: []
  type: TYPE_NORMAL
- en: The math Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python provides plenty of additional functions in the `math` module, along
    with the five most common math constants: `pi`, `tau`, `e`, `inf`, and `nan`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-16: *math_constants.py*'
  prefs: []
  type: TYPE_NORMAL
- en: All five constants are floats and can be directly used as such ❶. The official
    documentation provides a complete list of everything available in the `math` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might remember a little trick from high school trigonometry, where you
    could calculate the height of something using your distance to it and the angle
    from your vantage point to the top of the object. Here’s a way to calculate that
    with Python, using the `math` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-17: *surveying_height.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I use two functions from the `math` module: `math.radians()` ❶ and `math.tan()`
    ❷. The `round()` function ❸ is built into the language itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python’s clean, obvious syntax for logical expressions is one of the attractive
    elements of the language. Here, I’ll cover conditional statements and expressions,
    as well as the comparison and logic operators.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conditionals are compound statements composed of `if`, `elif`, and `else` clauses,
    each made up of a header and a suite. As with most languages, you can have as
    many `elif` conditionals in Python as you want, sandwiched between `if` and (optionally)
    `else`. Here’s a really simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-18: *conditional_greet.py*'
  prefs: []
  type: TYPE_NORMAL
- en: This conditional statement is made up of three clauses. The `if` clause evaluates
    first, and if the expression in its header evaluates to `True`, its suite runs,
    printing `"Hello!"` Otherwise, it evaluates the expression in the `elif` header
    next. If none of the expressions evaluate to `True`, then the `else` clause runs.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice you don’t need to wrap the conditional expressions, such as `command
    == "greet"`, in parentheses, although you may do so anyway if it helps clarify
    your code. You’ll see an example of this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re looking for something similar to the `switch` statement from your
    favorite programming language, see the “Structural Pattern Matching” section toward
    the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python has all the comparison operators you’d expect. Take a look at these
    in the context of comparing two integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-19: *comparison_operators.py*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Python has operators for `equals`, `not equals`, `less than`,
    `less than or equals`, `greater than`, and `greater than or equals`.
  prefs: []
  type: TYPE_NORMAL
- en: No surprises there, but what about boolean comparisons? This is where Python
    takes a different line.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean, None, and Identity Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python offers the values `True` and `False`, which are the two values for boolean
    (type `bool`) variables. It also has a dedicated `None` value (type `NoneType`),
    which serves in the capacity of a “null” value.
  prefs: []
  type: TYPE_NORMAL
- en: You check for these values in a very different way than with other data types.
    Instead of the comparison operators, use the special *identity operator* `is`.
    (I’ll also use the logical operator `not` below, which I’ll discuss separately
    in a bit.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-20: *boolean_identity_operators.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Aside from being a little high in sodium, that code shows the many ways of testing
    boolean values and checking for `None`.
  prefs: []
  type: TYPE_NORMAL
- en: You can test if a variable is set to `True`, `False`, or `None` by comparing
    with the `is` operator. You can also invert the logic with `is not`.
  prefs: []
  type: TYPE_NORMAL
- en: Most commonly, when testing against `True`, you can use the variable as the
    entire condition ❶. For `False`, invert that condition test with `not` ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Take particular note of the last condition, which illustrates an important gotcha
    with the `is` operator ❸. It actually compares the identity of the variables,
    rather than the value. This is particularly troublesome, as the logic looks sound
    but is a bug waiting for a place to happen. That probably doesn’t mean much to
    you yet, but rest assured, I’ll cover this concept in depth in Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, you can take this rule for granted: use `is` *only* for comparing
    directly to `None`, and use regular comparison operators for everything else.
    In practice, we usually say `if spam` or `if not spam`, instead of directly comparing
    to `True` or `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: Truthiness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most expressions and values in Python can be evaluated to a `True` or `False`
    value. This is typically done by using the value as an expression by itself, although
    you can also pass it to the `bool()` function to convert it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-21: *truthiness.py*'
  prefs: []
  type: TYPE_NORMAL
- en: When an expression will evaluate to `True`, it is considered “truthy.” When
    it will evaluate to `False`, it is “falsey.” The `None` constant, values representing
    zero, and empty collections are all considered “falsey,” while most other values
    are “truthy.”
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’re coming from a language where logical operators are a little more
    difficult to remember, you’ll find Python refreshing: it simply uses the keywords
    `and`, `or`, and `not`!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-22: *logical_operators.py*'
  prefs: []
  type: TYPE_NORMAL
- en: With the `and` condition, both expressions must evaluate to `True`. With the
    `or` condition, one or the other (or both) must evaluate to `True`. The third
    condition adds `not` to the picture, requiring that `eggs` be `False` and `spam`
    be `True`.
  prefs: []
  type: TYPE_NORMAL
- en: I could have omitted the parentheses on the third condition, as `not` takes
    precedence and so is evaluated before `and`. However, the parentheses help to
    clarify my intended logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, you can use the `not` keyword to invert any conditional expression,
    such as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-23: *not_operators.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both comparisons do the same thing; the issue becomes readability. In this
    case, the expression using `not` is less readable because your eyes might skip
    over the `not` keyword, so you might not catch what’s happening in the code. The
    condition employing the `!=` operator is preferred for readability. While you
    might find situations where `not` is the best way to invert your conditional logic,
    remember The Zen of Python: ***Readability counts!***'
  prefs: []
  type: TYPE_NORMAL
- en: The Walrus Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python 3.8 introduced *assignment expressions*, which allow you to assign a
    value to a variable and use that variable in another expression at the same time.
    This is possible with the so-called *walrus operator* (`:=`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-24: *walrus.py*'
  prefs: []
  type: TYPE_NORMAL
- en: With the walrus operator, Python first evaluates the expression on the left
    (`7+5`) and then assigns it to the variable `eggs`. The assignment expression
    is enclosed in parentheses for readability, although I technically could have
    omitted them.
  prefs: []
  type: TYPE_NORMAL
- en: The assignment expression is then evaluated to a single value, namely the value
    of `eggs`, which is used in the comparison. Since the value is `12`, the condition
    evaluates to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: What’s interesting about the assignment expression is that `eggs` is now a valid
    variable in the outer scope, so I can print its value outside of the conditional.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is potentially useful in many scenarios, not only in conditional
    expressions, as above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment expressions and the walrus operator were defined in PEP 572, which
    also contains an in-depth discussion about when and where this feature should
    be used. Two particularly useful style rules are put forth by this PEP:'
  prefs: []
  type: TYPE_NORMAL
- en: If either assignment statements or assignment expressions can be used, then
    prefer statements; they are clear declarations of intent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If using assignment expressions would lead to ambiguity about execution order,
    then restructure to use statements instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of the writing of this book, Python assignment expressions are still in their
    infancy. A lot of debate and controversy still surrounds them. In any case, resist
    the temptation to abuse the walrus operator to cram as much logic onto one line
    as possible. You should always aim for readability and clarity in your code, above
    all else.
  prefs: []
  type: TYPE_NORMAL
- en: Ellipsis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One seldom-used piece of syntax is the *Ellipsis*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is sometimes used by various libraries and modules, but seldom consistently.
    For example, it’s used with multidimensional arrays in the NumPy third-party library
    and when working with type hints from the built-in `typing` module. When you see
    it come up, consult the documentation for whatever module you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few things to know about strings as you move forward. Here, I’ll
    cover the three kinds of strings: string literals, raw strings, and formatted
    strings.'
  prefs: []
  type: TYPE_NORMAL
- en: String Literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are multiple ways of defining a *string literal*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-25: *string_literals.py*'
  prefs: []
  type: TYPE_NORMAL
- en: You can wrap a literal in double quotes (`"`), single quotes (`'`), or triple
    quotes (`"""`) of either type. You may remember from earlier that there’s something
    special about triple quotes, but I’ll come back to that in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 8 addresses the use of single and double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, single-quoted strings and double-quoted strings are the same. This
    PEP does not make a recommendation for this. Pick a rule and stick to it. When
    a string contains single or double quote characters, however, use the other one
    to avoid backslashes in the string. It improves readability.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The advice about placing quotes inside a string comes in handy when dealing
    with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-26: *escaping_quotes.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: This version escapes the double quotes I want to include in the string literal
    itself. The backslash (`\`) before the quotes means I want the string to contain
    that *literal character*, not to have Python treat the double quote as the boundary
    of a string. The string literal must always be wrapped in matching quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to avoid backslashes in this scenario, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-27: *escaping_quotes.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: This second version wraps the literal in single quotes, so the double quotes
    will be automatically interpreted as part of the string literal. That approach
    is much more readable. By wrapping the string in single quotes, Python will assume
    the double quotes are characters in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only time you’d really need to escape either single or double quotes with
    backslashes would be if you had both types of quotes in the string at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-28: *escaping_quotes.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: Personally, in cases like that, I’d prefer to use (and escape) the double quotes,
    because they don’t evade my attention like an apostrophe would tend to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have the option to use triple quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-29: *escaping_quotes.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that triple quotes define *multiline string literals*. In other words,
    I can use them to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-30: *multiline_string.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Everything, including newlines and leading whitespace, is literal in triple
    quotes. If I `print("parrot")`, it will display exactly like this in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The only exception occurs when you use a backslash (`\`) to escape a particular
    character, like I did with that newline at the beginning ❶. It is conventional
    to escape the first newline after the opening triple quotes, just to make the
    code look cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `textwrap` module has some functions for working with multiline
    strings, including tools that allow you remove leading indentation (`textwrap.dedent`).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can *concatenate* (combine) string literals, simply by writing
    them next to one another, without any operators between them. For example, `spam
    = "Hello " "world" "!"` is valid, resulting in the string `Hello world!.` If you
    wrap the assignment expression in parentheses, you can even span multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: Raw Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Raw strings* constitute another form of string literal, wherein the backslash
    (`\`) is always treated as a literal character. They’re preceded with an `r`,
    such as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-31: *raw_string.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The backslash is treated like a literal character, which means that nothing
    can be escaped inside of a raw string. The output of that line of code looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This has implications for what type of quotes you use, so beware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare these two lines and their outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-32: *raw_or_not.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first string is ordinary, so `\n` is treated as a normal escape sequence:
    specifically, the newline character. That line break appears in the output, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The second string is a raw string, so the backslash (`\`) is treated as a literal
    character in its own right. The output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is particularly useful for regular expression patterns, where you’re likely
    to have plenty of backslashes that you want as part of the *pattern*, not interpreted
    by Python before it gets there. ***Always use raw strings for regular expression
    patterns.***
  prefs: []
  type: TYPE_NORMAL
- en: Formatted Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A third kind of string literal is a *formatted string* or *f-string*, which
    is new as of Python 3.6 (defined in PEP 498). It allows you to insert the values
    of variables into a string in a very elegant manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I wanted to include the value of a variable in a string without an f-string,
    the code might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-33: *cheese_shop.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: The `str()` function converts the value passed to it into a string, and then
    the three strings are *concatenated*, or combined, into one, using the `+` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Using f-strings, this code becomes more elegant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-34: *cheese_shop.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: You precede the string literal with an `f`. Inside, you can substitute a variable
    by wrapping it in curly braces (`{ }`). The `f` tells Python to interpret and
    evaluate as an expression anything in the string that’s wrapped in curly braces.
    This means you’re not limited to variables in those curly braces. You can put
    just about any valid Python code in there, including math, function calls, conditional
    expressions, or whatever you need.
  prefs: []
  type: TYPE_NORMAL
- en: As of Python 3.8, you can even display both the expression *and* its result
    by appending a trailing equal sign (`=`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-35: *expression_fstring.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of gotchas when using f-strings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if you want to wrap an expression in literal curly braces, you must
    use two curly braces (`{{ }}`) for every one you want displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-36: *literal_curly_braces.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an odd number of braces, one pair will be ignored. So, if I used
    five pairs, the result would be the same as if I only had four: two literal pairs
    would be printed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you cannot use backslashes within an expression in an f-string. This
    makes it difficult to escape quotes inside expressions. For example, this would
    not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To get around this, I’d need to use triple quotes on the outside of the string,
    to ensure I can employ both single and double quotes inside of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Backslashes have other roles. The documentation points out the following problematic
    situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There’s no direct way around this limitation. Instead, you’d have to evaluate
    that expression in advance, assign the result to a name, and use it in the f-string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Third, and perhaps least surprising, you cannot put comments inside of f-string
    expressions; the hash (`#`) symbol isn’t allowed, except as a string literal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, you can never use f-strings as docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: These small wrinkles aside, f-strings are incredibly straightforward to work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Format Specifications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides arbitrary expressions, f-strings support *format specifications*, which
    allow you to control how values are displayed. This is a fairly in-depth topic
    that could easily become a main section on its own, so I will entrust you to the
    guidance of the documentation for the bulk of it. I’ll breeze over the essentials
    herein.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after the expression, you may choose to include one of three special
    flags: `!r`, `!a`, or `!s` (although that last one is the default behavior, so
    it can be omitted in most cases). These determine which function is used to fetch
    the string representation of some value: `repr()`, `ascii()`, or `str()`, respectively
    (see “String Conversion” below).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the format specification itself, which always begins with a colon
    (`:`), followed by one or more flags. These have to be specified in a particular
    order to work, although any of them may be omitted if they’re not desired:'
  prefs: []
  type: TYPE_NORMAL
- en: Align An alignment flag, specifying left (`<`), right (`>`), center (`^`), or
    (if numeric) split with the sign aligned left but the digits aligned right (`=`).
    This is optionally preceded by a character that will be used to fill any blank
    space in the alignment.
  prefs: []
  type: TYPE_NORMAL
- en: Sign A flag controlling when the sign is displayed on a number. The plus (`+`)
    flag displays the sign on both positive and negative numbers, while the minus
    (`–`) flag only displays it on negative numbers. A third option is to show a leading
    space on positive numbers and a sign on negative numbers (space).
  prefs: []
  type: TYPE_NORMAL
- en: Alternative form The hash (`#`) flag turns on the “alternative form,” which
    has different meanings for different types (see documentation).
  prefs: []
  type: TYPE_NORMAL
- en: Leading zeros The zero (`0`) flag causes leading zeros to be displayed (unless
    a fill character is specified for alignment).
  prefs: []
  type: TYPE_NORMAL
- en: Width The width of the output string in characters. This is where the alignment
    comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping A flag controlling whether numbers should separate thousands with a
    comma (`,`) or an underscore (`_`). If omitted, no separator is used. If enabled,
    the underscore separator also appears every four digits in octal, hexadecimal,
    and binary numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Precision A dot (`.`), followed by an integer for decimal precision.
  prefs: []
  type: TYPE_NORMAL
- en: Type A flag controlling how numbers are displayed; common options include binary
    (`b`), character (`c`), decimal (`d`), hexadecimal (`x`), exponent notation (`e`),
    fixed-point (`f`), and general (`g`). There are more (see documentation).
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is a bit abstract, so here are a few quick examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-37: *formatting_strings.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete details about the format specification can be found in the official
    Python documentation: [https://docs.python.org/3/library/string.xhtml#format-string-syntax](https://docs.python.org/3/library/string.xhtml#format-string-syntax).'
  prefs: []
  type: TYPE_NORMAL
- en: Another useful reference is [https://pyformat.info](https://pyformat.info),
    although as of this writing, it only shows the format specification in the context
    of the old `format()` function. You will need to apply it to f-strings yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Previous String-Formatting Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re reading older Python code, you may encounter the two previous forms
    of string formatting: `%` notation and the newer `format()`. These have both been
    superseded by f-strings, which have superior performance. That’s because they’re
    parsed and converted to bytecode *before* the code is run.'
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself needing to rewrite a `format()` call as an f-string, the
    process is thankfully quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example. I’ll start out with a couple of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-38: *format_to_fstring.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the advent of f-strings, if I wanted to print out a message containing
    the values of those two variables, I’d have used `format()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-39: *format_to_fstring.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: In the old format, a string literal ❶ would contain sets of curly braces, optionally
    containing the format specifications. The `format()` function would be called
    on that string literal (or on a name referencing it). Then, the expressions to
    be evaluated would be passed to the `format()` function in order ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'That would have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting this to an f-string is as simple as moving the expressions into
    the string literal in order and then prepending an `f` to the literal to make
    it an f-string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-40: *format_to_fstring.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: The output is the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, with `format()`, you could refer to the index of the expression
    in the argument list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-41: *format_to_fstring.py:3a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert this code to an f-string, you substitute the expressions in place
    of the indices in the string literal, which you (again) turn into an f-string
    by prepending an `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-42: *format_to_fstring.py:3b*'
  prefs: []
  type: TYPE_NORMAL
- en: Converting from `%` notation is a little less trivial, but most Python 3 code
    uses `format()` anyway. If you find yourself needing to do this, [https://pyformat.info](https://pyformat.info)
    does an excellent job of comparing `%` notation and `format()`.
  prefs: []
  type: TYPE_NORMAL
- en: Template Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Template strings* constitute one more alternative to f-strings that is worth
    knowing about, especially as it still fulfills some use cases, including internationalizing
    user interfaces. Personally, I find template strings a bit more reusable. On the
    other hand, the drawback is that they’re considerably more limited in terms of
    formatting.'
  prefs: []
  type: TYPE_NORMAL
- en: If you know how they work, you’ll be equipped to decide for yourself which tool
    is best for your particular situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a template string for greeting a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-43: *template_string.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: To use template strings, I first have to import `Template` from the `string`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then I can create a new `Template` and pass it a string literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-44: *template_string.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: I can name my fields whatever I want, preceding each with a dollar sign (`$`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I call the `substitute()` function on the template I created (`s`)
    and pass expressions to each of the fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-45: *template_string.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished string is returned, and in this case, it is passed to `print()`
    and displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of odd syntax rules with template strings. First, to show
    a literal dollar sign in the string literal, use two dollar signs (`$$`). Second,
    to substitute an expression as part of a word, wrap the name of the field in curly
    braces (`{ }`). Both of these rules are demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-46: *template_string.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There’s a handful of additional abilities contained within string templates,
    but I’ll entrust you to the official Python documentation for the rest of that.
  prefs: []
  type: TYPE_NORMAL
- en: String Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I previously mentioned that there are three ways to get the string representation
    of a value: `str()`, `repr()`, and `ascii()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first function, `str()`, is the one you’ll use most often, as it returns
    the *human-readable* representation of the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, `repr()` returns the *canonical string representation* of the
    value: that is, (usually) the value as Python sees it. In the case of many basic
    data types, this will return the same thing as `str()`, but when used on most
    objects, the output contains additional information useful in debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ascii()` function is the same as `repr()`, except that the string literal
    it returns is completely ASCII-compatible, having escaped any non-ASCII (for example,
    Unicode) characters.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll return to this concept in Chapter 7, when I start defining my own objects.
  prefs: []
  type: TYPE_NORMAL
- en: A Note on String Concatenation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point, I’ve been using the addition (`+`) operator for concatenating
    strings together. This is acceptable in basic situations.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is seldom the most efficient solution, especially when combining
    multiple strings. Therefore, it is recommended to prefer the `join()` method,
    which is called on a string or string literal instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a comparison between the two. I start with a couple of string variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-47: *concat_strings.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, you’ve seen concatenation with the addition (`+`) operator, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-48: *concat_strings.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, I can use the `join()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-49: *concat_strings.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: I call the `join()` method on the string that will appear between each piece.
    In this case, I use an empty string. The `join()` method accepts a *tuple* of
    strings—an array-like structure wrapped in parentheses, and therefore, the double
    set of parentheses in the code. I’ll introduce tuples in an upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Typical concatenation with `+` or the `join()` function has the same result,
    but the latter function will be *as fast or faster*, especially when you’re using
    other implementations of Python besides CPython. Therefore, whenever you need
    to concatenate and f-strings aren’t right for the job, you should consider using
    `join()` instead of the `+` or `+=` operators. In practice, f-strings are the
    fastest, but `join()` is your next-best option.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python functions are *first-class citizens*, which means they can be treated
    like any other object. Even so, you call them as you would in any other programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of a very basic function, which prints a selected type of
    joke to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'I start with the function header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-50: *joke_function.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I declared the function with the `def` keyword, followed by the name of the
    function. Parameters are named in the parentheses after the function name. The
    entire header is concluded with a colon (`:`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the header, indented one level, is the *suite* (or body) of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-51: *joke_function.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You call functions in much the same way as in most languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-52: *joke_function.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll go into depth on functions and their many cousins in Chapter 6.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python fully supports object-oriented programming. In fact, one of the language’s
    design principles is that “everything is an object,” at least behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot more to classes than meets the eye, but for now, you should just
    get an absolutely bare-bones familiarity with the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class contains a joke of a selected type and displays it on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-53: *joke_class.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I define the class using the `class` keyword, the name of the class, and a colon
    (`:`) at the end of the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is followed by the suite of the class, indented one level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-54: *joke_class.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: The initializer, which is similar in purpose to the constructor in other OOP
    languages, is a member function, or *method*, with the name `__init__()` and at
    least one parameter, `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-55: *joke_class.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions that belong to the class are called methods and are part of the class
    suite. Methods must accept at least one parameter: `self`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You would use this class like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-56: *joke_class.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: You create a new instance of the `Joke` class by passing the string `"lethal"`
    to its *initializer*, the `__init__()` from earlier. The new object is stored
    in the variable `lethal_joke`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you use the *dot operator* (`.`) to call the function `tell()` within
    the object. Take note that you didn’t have to pass any argument for `self`. That’s
    done automatically when you call the function in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll discuss classes and objects in detail in Chapter 7 and further in Chapter
    13.
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python offers error and exception handling functionality through the `try` compound
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if I wanted to get a number from the user, I couldn’t reliably
    predict what they would type in. Trying to convert a string, like `"spam"`, to
    an integer would cause an error. I can use error handling to take a different
    action if it isn’t possible to convert the user `input`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-57: *try_except.py*'
  prefs: []
  type: TYPE_NORMAL
- en: I get a string from the user, and then in the `try` clause, I attempt to convert
    it to an integer with the `int()` function. That would raise a `ValueError` exception
    if the string it’s trying to convert is not a valid whole number (base 10).
  prefs: []
  type: TYPE_NORMAL
- en: If that exception is raised, I catch it in the `except` clause and handle the
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the last line would always be run.
  prefs: []
  type: TYPE_NORMAL
- en: There are additional features and subtleties to the `try` statement, including
    `finally` and `else` clauses, which I’ll cover in Chapter 8. For now, it’s better
    to avoid these concepts rather than use them incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two of Python’s most common built-in data structures, called *collections*,
    are tuples and lists.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lists* constitute the most array-like collection in Python. In CPython, they
    are implemented as variable-length arrays, not as linked lists like the name might
    suggest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a list of strings with names of cheeses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-58: *cheese_list.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: You enclose a list literal in square brackets, separating each item in the list
    with commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access or reassign the values of individual items with the same bracket
    notation used by most programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-59: *cheese_list.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: A *tuple* is somewhat similar to a list, but with a few key differences. First,
    a tuple cannot have items added, reassigned, or removed after its creation. Attempting
    to modify the contents of a tuple with bracket notation will result in a `TypeError`.
    This is because tuples, unlike lists, are *immutable*, effectively meaning their
    contents cannot be modified (see Chapter 5 for the full explanation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-60: *knight_tuple.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You enclose tuple literals in parentheses (`( )`), instead of brackets (`[
    ]`). Nevertheless, you still use bracket notation to access individual items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-61: *knight_tuple.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said, you cannot change the items of a tuple after creation, such as if
    you tried to reassign the first item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-62: *knight_tuple.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: The guideline is to use tuples for collections of items of different types (*heterogeneous*
    collections) and to use lists for collections of items of the same type (*homogeneous*
    collections).
  prefs: []
  type: TYPE_NORMAL
- en: I’ll discuss these collections, and many more, in Chapter 9.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has two basic loop types: *while* and *for*.'
  prefs: []
  type: TYPE_NORMAL
- en: while Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` loop probably looks familiar from other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-63: *while_loop.py*'
  prefs: []
  type: TYPE_NORMAL
- en: I start the loop with the `while` keyword, follow it with the condition to test,
    and finish the header with a colon (`:`). As long as that condition evaluates
    to `True`, the code in the suite of the loop is executed.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to keep running a loop until some condition is met, use `while`
    loops. These are particularly useful when you don’t know how many iterations of
    the loop will take place before the condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: Loop Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can manually control the loop, using two keywords. The `continue` keyword
    abandons the current iteration and jumps to the next one. The `break` keyword
    exits the loop altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common scenario where you may use these keywords is in an infinite loop
    used for running a game or a user interface. For example, here’s a very simple
    command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-64: *loop_control.py*'
  prefs: []
  type: TYPE_NORMAL
- en: The loop `while True` is inherently infinite; `True` is always `True`. That’s
    the behavior I actually want here, since I want to keep iterating until the user
    enters the string `"exit"`, at which point, I manually end the loop with `break`.
    (By the way, if you’ve been waiting for a `do-while` loop, this is effectively
    the way to recreate that behavior.)
  prefs: []
  type: TYPE_NORMAL
- en: The command `"sing"` has a different behavior, after which I’d want to immediately
    go to the top and prompt the user for another command, skipping the last print
    statement. The `continue` keyword does exactly that, immediately abandoning the
    current iteration and jumping back to the top of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: for Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s `for` loop is a little different from loops in many languages. It’s
    generally used for iterating over a range, list, or other collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-65: *for_loop.py*'
  prefs: []
  type: TYPE_NORMAL
- en: I start the loop header with the `for` keyword. Technically, this kind of loop
    is a `for`-`in` (or “`for`-`each`”) loop, meaning the loop iterates once for each
    item in the given range, list, or other collection. This means the loop needs
    something to iterate over—in this case, a special object called `range()`—which
    iterates over a range of values, returning each one in turn. I’ve specified that
    I want the range to start with the value `1` and end before `11`. The local variable
    `i` will refer to the current item for each iteration. Finally, the `in` keyword
    precedes the thing I’m iterating over—that is, before `range()` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: As long as there are items to iterate over, the code belonging to the loop will
    be executed—in this case, printing out the value of the current item. The loop
    stops when the last item is iterated over.
  prefs: []
  type: TYPE_NORMAL
- en: Running this code would print the numbers 1 through 10.
  prefs: []
  type: TYPE_NORMAL
- en: This only scratches the surface of loops. See Chapter 9 for more.
  prefs: []
  type: TYPE_NORMAL
- en: Structural Pattern Matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many years, developers coming to Python from languages like C, C++, Java,
    or Javascript would ask if there was a Python equivalent to the `switch`/`case`
    statement (or `match`/`case` in Scala, `case`/`when` in Ruby, and so on). They’d
    always be disappointed to hear a resounding “No!” Python only had conditional
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: At long last, Python 3.10 gained *structural pattern matching* via PEP 634\.
    This provides conditional logic that is at least syntactically similar to `switch`
    statements of other languages. In short, you test a single *subject*, such as
    a variable, against one or more *patterns*. If the subject matches the pattern,
    the associated suite of code runs.
  prefs: []
  type: TYPE_NORMAL
- en: Literal Patterns and Wildcards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the most basic use case, you can check a variable against different possible
    values. These are called *literal patterns*. For example, perhaps I want to display
    different messages, depending on a user’s `input` `lunch` `order`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-66: *pattern_match.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: The value of `lunch_order` is compared to each case until it matches one. Once
    a match is found, the case’s suite is run, and the match statement is finished;
    the value won’t be checked against additional patterns once it matches one. So,
    if the user inputs `"pizza"`, the `"Pizza` `time!"` message is displayed. Similarly,
    if they input `"taco"`, the message `"Taco,` `taco,` `TACO,` `tacotacotaco!"`
    is displayed instead.
  prefs: []
  type: TYPE_NORMAL
- en: The underscore (`_`) in the last case is the *wildcard*, which will match any
    value. This serves as a fallback case, and it must come last, as it will match
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: Or Patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A single case can cover multiple possible values. One way to do this is with
    an *or pattern*, where possible literal values are separated by the bar character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-67: *pattern_match.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern will match if the user enters either `"salad"` or `"soup"` at the
    prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Capture Patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One particularly helpful feature of structural pattern matching is the ability
    to capture part or all of the subject. For example, it isn’t very helpful in our
    example that the fallback case only says `"Yummy."`. Instead, I’d like to have
    a default message announcing the user’s selection. To do that, I write a *capture
    pattern* like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-68: *pattern_match.py:1c*'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern acts like a wildcard, except the value of `lunch_order` is captured
    as `order`. Now, no matter what the user enters, if it doesn’t match any of the
    previous patterns, the value will be captured and displayed in the message here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Capture patterns don’t just have to capture the entire value. For example,
    I can write a pattern that matches a tuple or list (a *sequence*) and then captures
    only part of that sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-69: *pattern_match.py:1d*'
  prefs: []
  type: TYPE_NORMAL
- en: In this version, if the lunch order has a space, I split the string into two
    parts, which are stored in a list. Then, if the second item in the sequence has
    the value `"ice cream"`, the first part is captured as `flavor`. Thus, the code
    can account for Bojan if he decides to break down and have strawberry ice cream
    for lunch. (And I’m not stopping him!)
  prefs: []
  type: TYPE_NORMAL
- en: 'The capture pattern feature has one surprising downside: all *unqualified*
    names in patterns—that is, any bare variable names with no dots—will be used to
    capture. This means that if you want to use the value assigned to some variable,
    it must be *qualified*, meaning you must access it within some class or module
    with the dot operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-70: *pattern_match.py:1e*'
  prefs: []
  type: TYPE_NORMAL
- en: Guard Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One last trick I’ll demonstrate with pattern matching is the *guard statement*,
    an additional conditional statement that must be satisfied for a pattern to match.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the current version of my lunch order example, using the logic
    to split the order by spaces means the code doesn’t behave very nicely with other
    foods with spaces in them. Also, if I enter `"rocky road ice cream"`, it won’t
    match the current ice cream pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of splitting my string by spaces, I can write a pattern with a guard
    statement that looks for the words *ice cream* in the lunch order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-71: *pattern_match_object.py:1f*'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern here captures the value as `ice_cream`, but only if the guard statement
    `if 'ice cream' in ice_cream` is satisfied. In that case, I use `.replace()` to
    remove the words *ice cream* from the captured value, leaving me with only the
    name of the flavor. I also use `.strip()` to remove any leading or trailing whitespace
    from the new string. Finally, I print out my message.
  prefs: []
  type: TYPE_NORMAL
- en: More About Structural Pattern Matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are quite a few other tricks and techniques that work with structural
    pattern matching. They work with objects (see Chapter 7), with dictionaries via
    mapping patterns (see Chapter 9), and even by support nesting patterns within
    other patterns.
  prefs: []
  type: TYPE_NORMAL
- en: As with many Python techniques, pattern matching feels like “magic,” and there’s
    a strong temptation to use it everywhere possible. Resist this urge! Structural
    pattern matching is very useful for checking a single subject against multiple
    possible patterns, but as you can even see from the “ice cream” situation in the
    lunch order example, it quickly reaches its limits as the possible values of the
    subject get more elaborate. As a rule, if you’re unsure whether you need structural
    pattern matching in a particular situation, stick with conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn even more, read PEP 636, which serves as the official tutorial for
    this topic and demonstrates all of the functionality available with this language
    feature: [https://peps.python.org/pep-0636/](https://peps.python.org/pep-0636/).'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should now have a feeling for Python’s syntax and a basic familiarity with
    its key structures. If you were to stop here, you could probably write Python
    code that at least works. In fact, many developers new to the language do indeed
    work with about this much information, implicitly bringing the habits and practices
    of whatever language they know best.
  prefs: []
  type: TYPE_NORMAL
- en: There is a profound difference between valid code and idiomatic, Pythonic code.
    Writing the latter is the focus of this book.
  prefs: []
  type: TYPE_NORMAL
