- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Syntax Crash Course
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 语法速成班
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Python is an unusual mix of common and unique concepts. Before diving into the
    intricacies of the language, you must first grasp its essential syntax.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种常见概念与独特概念的独特结合。在深入探讨语言的复杂性之前，你必须首先掌握其基本语法。
- en: In this chapter, you’ll learn most of the essential syntactic structures you’ll
    encounter in Python, and you’ll also become familiar with the basic mathematical
    and logical features of the language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习大部分在 Python 中遇到的基本语法结构，并且你还将熟悉该语言的基本数学和逻辑特性。
- en: 'Most Python developers will point newcomers to the official Python tutorial,
    which is an excellent introduction to the language’s structure. While I’ll cover
    all of these concepts in this book in depth, the tutorial is still a good resource
    worth reading: [https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Python 开发者会推荐新手阅读官方 Python 教程，这是对语言结构的一个很好的介绍。虽然我将在本书中深入讲解这些概念，但该教程仍然是一个值得阅读的好资源：[https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/)。
- en: Hello, World!
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: 'It won’t feel like a proper introduction to the language without the classic
    Hello World program. In Python, it’s written like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有经典的 Hello World 程序，就感觉不像是对语言的正式介绍。在 Python 中，它是这样写的：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: *hello_world.py*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-1: *hello_world.py*'
- en: There’s nothing novel here. You call the `print()` function to write text to
    the console, and you pass data in a string, wrapped in quotes as an argument.
    You can pass whatever sort of data you like, and it will be output on the console.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新奇的地方。你调用 `print()` 函数将文本写入控制台，并且你将数据作为字符串传递，字符串用引号括起来作为参数。你可以传递任何类型的数据，数据将被输出到控制台。
- en: 'I can also get input from the console with the `input()` function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以使用 `input()` 函数从控制台获取输入：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: *hello_input.py*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-2: *hello_input.py*'
- en: I use the `input()` function and pass my prompt as a string ❶. When I run that
    code, Python greets me using the name I entered on the console.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `input()` 函数并将提示作为字符串传递❶。当我运行这段代码时，Python 会根据我在控制台输入的名字向我问好。
- en: Statements and Expression
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句与表达式
- en: Each line of code in Python that ends with a line break is a *statement*, sometimes
    more specifically known as a *simple statement*. Unlike in many C-inspired languages,
    you don’t need to end a line in Python with a special character.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，每行以换行符结尾的代码是一个*语句*，有时更具体地称为*简单语句*。与许多受 C 语言影响的语言不同，你不需要在 Python 中用特殊字符结束一行代码。
- en: A section of code that evaluates to a single value is called an *expression*.
    In Python, you can put expressions nearly anywhere a value is expected. The expression
    is evaluated down to a value, and that value is used in that position in the statement.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 评估为单一值的代码段称为*表达式*。在 Python 中，你几乎可以在任何需要值的地方放置表达式。表达式会被计算出一个值，然后该值会在语句中作为对应位置的值使用。
- en: 'For example, in one statement, I can create a variable, and in another statement,
    I can print its contents to the console:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一行语句中，我可以创建一个变量，在另一行语句中将它的内容打印到控制台：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: *hello_statements.py:1a*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-3: *hello_statements.py:1a*'
- en: I assign the expression `"Hello, world!"` to `message`, and then I pass the
    expression `message` to `print()`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我将表达式 `"Hello, world!"` 赋值给 `message`，然后将表达式 `message` 传递给 `print()`。
- en: 'If you ever need to place multiple statements on the same line, you can separate
    them with a semicolon (`;`). To demonstrate this, here are the same two statements
    as earlier, but packed onto one line, with a semicolon to separate them:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将多个语句放在同一行，你可以使用分号（`;`）将它们分开。为了演示这一点，这里是之前的两个语句，但它们被放在一行中，并使用分号分隔：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-4: *hello_statements.py:1b*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-4: *hello_statements.py:1b*'
- en: While this is valid code, using this technique is somewhat discouraged. The
    Python philosophy places a high value on readability, and the placement of multiple
    statements on the same line often detracts from that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码是有效的，但使用这种技巧是有些不推荐的。Python 的哲学非常重视代码的可读性，而将多个语句放在同一行通常会降低可读性。
- en: Stick to placing one statement per line, unless you have a specific reason to
    do otherwise.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有特定原因，否则请保持每行只放一个语句。
- en: The Importance of Whitespace
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空白字符的重要性
- en: When you’re looking at a sample of Python source code, the first thing that
    will probably jump out at you is the use of indentation for nesting. A *compound
    statement* is made up of one or more *clauses*, each of which consists of a line
    of code called a *header* and a block of code called a *suite*, which is associated
    with the header.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看 Python 源代码示例时，首先可能会注意到的是缩进的使用来表示嵌套。一个 *复合语句* 由一个或多个 *子句* 组成，每个子句包含一行代码，称为
    *头部*，以及与头部相关联的一段代码块，称为 *语句块*。
- en: 'For example, this program prints different messages, depending on whether a
    `name` is specified:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个程序根据是否指定了 `name` 来打印不同的消息：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-5: *hello_conditional.py*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-5：*hello_conditional.py*
- en: I set up a conditional statement with an `if` header ❶, after which I have a
    suite made up of two indented lines of code, which “belongs” to the header. These
    lines of code are executed only if the conditional expression in the header is
    evaluated to `True`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了一个条件语句，首先是一个 `if` 头部 ❶，然后是由两行缩进代码组成的语句块，这些代码“属于”这个头部。只有在条件表达式的结果为 `True`
    时，这些代码才会执行。
- en: The unindented line ❷ is not part of the suite that belongs to the conditional
    statement, and it will be run every time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那行未缩进的代码 ❷ 不是条件语句的语句块的一部分，它将每次都执行。
- en: 'As I nest deeper, I need to add more indentation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我进行更深的嵌套时，我需要添加更多的缩进：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-6: *weather_nested_conditional.py*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-6：*weather_nested_conditional.py*
- en: The first `print` statement is indented twice, which is how Python knows that
    it belongs to both preceding conditional statements.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `print` 语句缩进了两次，这样 Python 就知道它属于前两个条件语句。
- en: Given the importance of whitespace, the “tabs versus spaces” war is fairly common
    in Python world. You’ll remember from Chapter 2 that the PEP 8 style guide stresses
    using either four spaces or a single tab per indentation level. ***Consistency
    is key!*** Python really doesn’t care whether you use tabs, two spaces, four spaces,
    or even seven spaces (although that’s probably a step too far) for each level
    of indentation. The point is to be consistent within any and every given block
    of code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到空白的重要性，关于“Tab 键和空格”的争论在 Python 社区中非常常见。你可能还记得第二章中提到的 PEP 8 风格指南强调每个缩进级别使用四个空格或一个
    Tab 键。***一致性是关键！*** Python 并不关心你使用的是 Tab 键、两个空格、四个空格，还是甚至七个空格（尽管那可能有点过头），关键是要在每一个代码块中保持一致性。
- en: You should use only one indentation style throughout your project, even if your
    situation provides a technical loophole. Don’t mix tabs and spaces. Chances are
    your IDE has tools to help you with this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在整个项目中只使用一种缩进风格，即使在你的情境下有技术漏洞。不要混用 Tab 键和空格。你的 IDE 很可能提供了帮助你处理这个问题的工具。
- en: For simplicity’s sake, I’ll use the PEP 8 convention of four spaces throughout
    my code examples. While I’d recommend you follow this same convention—you can
    even configure your editor to insert four spaces each time you hit the Tab key—if
    you have a strong preference for tabs, you’re welcome to use those instead. It
    really doesn’t matter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，我将在我的代码示例中使用 PEP 8 规范的四个空格缩进。虽然我建议你遵循相同的规范——你甚至可以配置编辑器，在每次按下 Tab 键时自动插入四个空格——如果你偏好使用
    Tab 键，当然也可以选择使用它们。这其实并不重要。
- en: Doing Nothing
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么也不做
- en: On occasion, you will need to insert a statement that has absolutely no effect.
    This is particularly useful when you need to put a syntactically valid placeholder
    where a suite of code will exist later. For this purpose, Python provides the
    `pass` keyword.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要插入一个完全没有任何效果的语句。当你需要在将来某处插入一段代码时，这个语句非常有用，尤其是在语法上有效的占位符位置。为了这个目的，Python
    提供了 `pass` 关键字。
- en: 'For example, I can employ the `pass` keyword as a placeholder in my `if raining`
    conditional, until I’m able to write the final code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我编写的 `if raining` 条件语句中，我可以使用 `pass` 关键字作为占位符，直到我能够编写最终代码：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-7: *raining_pass.py*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-7：*raining_pass.py*
- en: Just remember, `pass` does absolutely nothing. That’s the only reason it exists.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`pass` 完全什么也不做。这就是它存在的唯一原因。
- en: Comments and Docstrings
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释和文档字符串
- en: To write comments in Python, precede the line with a hash (`#`). Everything
    between the hash and the end of the line is a comment and will be ignored by the
    interpreter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中编写注释时，在行首加上井号（`#`）。井号与行尾之间的所有内容都是注释，将会被解释器忽略。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-8: *comments.py*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-8：*comments.py*
- en: If you ran this program, the `print` statements would both execute. The rest
    of the second `print` statement, from the hash onward, is an inline comment ❶
    and would be ignored by the interpreter. All the other lines are only comments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，两个 `print` 语句都会执行。第二个 `print` 语句的其余部分，从哈希符号开始，是一个内联注释❶，会被解释器忽略。其他所有的行只是注释。
- en: Docstrings
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档字符串
- en: 'Officially, there is no syntax for “multiline” comments; you just comment each
    line. There is one special exception: the *docstring*. It looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 官方来说，Python 没有“多行”注释的语法；你只能注释每一行。有一个特殊的例外：*文档字符串*。它是这样的：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-9: *docstrings.py:1*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-9: *docstrings.py:1*'
- en: I define a function that would (theoretically) make tea, and I place the description
    of the function inside a docstring.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个理论上可以煮茶的函数，并将函数的描述放在文档字符串中。
- en: Docstrings exist to provide documentation for functions, classes, and modules,
    especially public ones. They conventionally begin and end with three quotation
    marks (`"""`), allowing the string to automatically span multiple lines. You would
    typically place docstrings at the top, inside of whatever they’re defining, such
    as in the function above.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串用于为函数、类和模块提供文档，特别是公共的那些。它们通常以三个引号（`"""`）开始和结束，允许字符串自动跨越多行。你通常会将文档字符串放在它们所定义内容的顶部，例如上面的函数中。
- en: 'There are three important distinctions between comments and docstrings:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注释和文档字符串之间有三个重要的区别：
- en: Docstrings are string literals, and they are seen by the interpreter; comments
    are ignored.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串是字符串字面量，它们会被解释器看到；而注释则会被忽略。
- en: Docstrings are used in automatic documentation generation.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串用于自动文档生成。
- en: Docstrings are generally only docstrings when they appear at the top of the
    module, function, class, or method they define. Comments can live anywhere.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档字符串通常只有在出现在它们所定义的模块、函数、类或方法的顶部时，才算作文档字符串。注释可以出现在任何地方。
- en: It is perfectly possible to use a triple-quoted string literal to write a sort
    of “multiline comment,” but it’s not recommended, since a string literal can easily
    get left in a place where Python will try to use it as a value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三引号字符串字面量来编写一种“多行注释”是完全可行的，但不推荐这样做，因为字符串字面量很容易被留在某个地方，Python 会试图将其作为一个值使用。
- en: In short, use docstrings as intended, and stick with comments for everything
    else. Many Python IDEs have hotkeys for toggling comments on a selection, which
    can save you a lot of time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，按照预期使用文档字符串，对于其他情况则使用注释。许多 Python IDE 都有切换选定代码的注释的快捷键，这可以为你节省大量时间。
- en: 'I can access these docstrings later in my code. For instance, given the previous
    example, I can do this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在代码中稍后访问这些文档字符串。例如，给定前面的示例，我可以这样做：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-10: *docstrings.py:2*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-10: *docstrings.py:2*'
- en: Docstrings have their own style conventions, which are outlined in depth in
    PEP 257.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串有自己的一套风格规范，这些规范在 PEP 257 中有详细说明。
- en: Declaring Variables
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'You may have already noticed that Python doesn’t have a distinct keyword for
    declaring a new variable (technically called a *name* in this language; see Chapter
    5). Here, I define two variables—`name` and `points`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Python 没有一个专门的关键字来声明新变量（在这门语言中，变量被称为*名称*；参见第 5 章）。在这里，我定义了两个变量——`name`
    和 `points`：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-11: *variables.py*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-11: *variables.py*'
- en: Python is *dynamically typed*, meaning the data type of a value is determined
    when it is evaluated. This contrasts with statically typed languages, in which
    you declare the data type initially. (C++ and Java are both statically typed.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是 *动态类型语言*，意味着一个值的数据类型是在其被求值时确定的。这与静态类型语言不同，在静态类型语言中，你需要先声明数据类型。（C++
    和 Java 都是静态类型语言。）
- en: With Python, you can assign a value to a name anytime, by using the assignment
    operator (`=`). It infers the data type. If the name is a new variable, Python
    will create it; if the name already exists, Python will change the value. It’s
    a pretty straightforward system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以随时通过使用赋值运算符（`=`）为一个名称赋值。Python 会推断数据类型。如果这个名称是一个新变量，Python 会创建它；如果名称已经存在，Python
    会改变其值。这是一个非常直接的系统。
- en: 'In general, there are only two rules to follow with Python variables:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Python 变量遵循的规则只有两条：
- en: Define a variable before you access it; otherwise, you’ll get an error.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在访问变量之前，先定义它；否则你会得到一个错误。
- en: Don’t change what kind of data you’re storing in the variable, even when replacing
    a value.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使在替换值时，也不要改变你在变量中存储的数据类型。
- en: Python is considered a *strongly typed language*, meaning you usually can’t
    magically combine data of different types. For example, it won’t allow you to
    add an integer and a string together. On the other hand, *weakly typed* languages
    let you do practically anything with different data types, and they try to figure
    out how to do what you asked for. (JavaScript is weakly typed.) There’s an entire
    spectrum between those last two terms and plenty of debate about what behaviors
    qualify under which name. While Python is decidedly in the “strongly typed” camp,
    it still has weaker typing than some languages.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Python被认为是*强类型语言*，意味着通常不能随意将不同类型的数据结合在一起。例如，它不会允许你将整数和字符串相加。另一方面，*弱类型*语言允许你几乎做任何事情，即使数据类型不同，它们也会尝试搞清楚如何执行你要求的操作。（例如JavaScript就是弱类型的。）这两者之间存在整个光谱，并且对于哪些行为属于哪个名称，有很多争论。虽然Python无疑属于“强类型”阵营，但它的类型检查还是比某些语言要弱。
- en: Python is, however, *weakly bound*, so it is possible to assign a value of a
    different type to an existing variable. While this is technically permissible,
    it is strongly discouraged, as it can produce confusing code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python是*弱类型*的，因此可以将不同类型的值赋给现有变量。虽然从技术上讲是允许的，但强烈不建议这样做，因为这可能会产生混淆的代码。
- en: What About Constants?
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 那么常量呢？
- en: Python doesn’t have any formally defined constants. In keeping with PEP 8, you
    would indicate a variable is intended to be treated as a constant by using all-caps
    names with underscores. This naming convention is sometimes humorously referred
    to as *screaming snake case* for the all-caps (screaming) and the underscores
    (snakes). For example, the name `INTEREST_RATE` indicates that you don’t want
    the variable redefined or changed in any way. While the interpreter itself won’t
    prevent the variable from being modified, your linter will usually complain if
    you do.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有正式定义的常量。根据PEP 8的规定，你可以通过使用全大写字母和下划线命名来表示某个变量应当作为常量处理。这种命名约定有时幽默地被称为*screaming
    snake case*（尖叫蛇式命名），因为它的全大写字母（尖叫）和下划线（蛇）。例如，`INTEREST_RATE`这个名字表示你不希望该变量被重新定义或改变。虽然解释器本身不会阻止变量被修改，但如果你这样做，通常你的代码检查工具会发出警告。
- en: Mathematics
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学
- en: Python has all the math functionality you would expect from a good programming
    language; its excellent support for both simple and complicated mathematics is
    one of the reasons Python is popular for scientific programming, data processing,
    and statistical analysis.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有你从一门优秀编程语言中期待的所有数学功能；它对简单和复杂数学的卓越支持是Python在科学编程、数据处理和统计分析中受欢迎的原因之一。
- en: Meet the Number Types
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解数字类型
- en: Before I get into the operations, you should be aware of the three data types
    used for storing numbers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入操作之前，你应该了解三种用于存储数字的数据类型。
- en: '*Integers* (`int`) store whole numbers. In Python, integers are always signed
    and effectively have no maximum value. Integers use decimal base (base-10) by
    default, but they can also be specified in binary (`0b101010`), octal (`0o52`),
    or hexadecimal (`0x2A`).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数*（`int`）存储整数。在Python中，整数总是有符号的，实际上没有最大值限制。整数默认使用十进制（base-10），但也可以指定为二进制（`0b101010`）、八进制（`0o52`）或十六进制（`0x2A`）。'
- en: '*Floating-point numbers* (`float`) store numbers with a decimal part (for example,
    `3.141592`). You can also use scientific notation (for example, `2.49e4`). Internally,
    values are stored as double-precision, IEEE 754 floating-point numbers, which
    are subject to the limits inherent in that format. (For more insight into the
    limits and gotchas of floating-point arithmetic, read the article “What Every
    Computer Scientist Should Know About Floating-Point Arithmetic” by David Goldberg:
    [https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.xhtml](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.xhtml)*.*)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮点数*（`float`）存储带有小数部分的数字（例如，`3.141592`）。你也可以使用科学记数法（例如，`2.49e4`）。在内部，数值以双精度IEEE
    754浮点数的形式存储，这些数值受到该格式固有限制的约束。（想了解浮点运算的限制和陷阱，可以阅读David Goldberg的文章《每个计算机科学家都应该知道的浮点运算》：[https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.xhtml](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.xhtml)*。*)'
- en: You can also specify an invalid number with `float("nan")`, a number larger
    than the largest possible value with `float("inf")`, or a number smaller than
    the smallest possible value with `float("-inf")`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`float("nan")`指定一个无效数字，使用`float("inf")`指定一个比最大值还大的数字，或者使用`float("-inf")`指定一个比最小值还小的数字。
- en: Notice that I wrapped the special values in quotes. This is necessary if you
    want to use these values without *importing* the `math` module (see Chapter 4
    for more about importing). If you have imported the `math` module (see “The `math`
    Module” subsection below), you can use the constants `nan`, `inf`, and so forth,
    instead of the quoted versions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我将特殊值用引号括起来。如果你想在不 *导入* `math` 模块的情况下使用这些值，这是必要的（关于导入的更多内容，请参见第 4 章）。如果你已经导入了
    `math` 模块（请参见下面的“数学模块”小节），你可以使用常量 `nan`、`inf` 等，而不是带引号的版本。
- en: '*Complex numbers* (`complex`) can store imaginary numbers by appending `j`
    to the value, as in `42j`. You can combine a real part with the imaginary part,
    using addition: `24+42j`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*复数*（`complex`）可以通过在值后面添加 `j` 来存储虚数，例如 `42j`。你可以将实部与虚部结合，使用加法：`24+42j`。'
- en: In case you missed it in math class, an imaginary number has the square root
    of negative one as one of its factors, even though this value is utterly impossible;
    there is no value that you can multiply by itself to get negative one! Yet imaginary
    numbers definitely show up in real-world math. Spooky, no?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在数学课上错过了，它的虚数是负一的平方根，尽管这个值是完全不可能的；没有任何值可以自己与自己相乘得到负一！然而，虚数在现实世界的数学中确实出现。吓人吧？
- en: '*Decimal* and *Fraction* are two of the additional object types for storing
    numeric data. `Decimal` stores fixed-point decimal numbers, while `Fraction` does
    the same for fractions. To use either, you’ll need to import them first.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*Decimal* 和 *Fraction* 是用于存储数字数据的两种附加对象类型。`Decimal` 存储定点小数，而 `Fraction` 存储分数。要使用它们，你需要先导入它们。'
- en: 'Here’s a brief example that uses both types:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简短的示例，展示了如何使用这两种类型：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 3-12: *fractions_and_decimals.py*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-12: *fractions_and_decimals.py*'
- en: The `float()` function turns `Fraction` and `Decimal` objects into floats.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`float()` 函数将 `Fraction` 和 `Decimal` 对象转换为浮点数。'
- en: Operators
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作符
- en: Python has the usual operators, with a couple of additions that may not be familiar
    to some developers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Python 拥有常见的操作符，还增加了一些可能对某些开发者来说不太熟悉的操作符。
- en: 'Here’s a bit of code that will demonstrate the math operators. I’ll wrap each
    equation inside a `print()` statement, so you can run the code and see the results:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有段代码展示了数学操作符。我会将每个等式包装在 `print()` 语句中，这样你就可以运行代码并查看结果：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 3-13: *math_operators.py*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-13: *math_operators.py*'
- en: The *unary* (one-operand) negative operator flips the sign of whatever follows
    it. The `abs()` function is technically considered a unary operator as well. The
    rest of the operators here are *binary*, meaning they accept two operands.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*一元*（单操作数）负号操作符会翻转其后的数值的符号。`abs()` 函数在技术上也被认为是一种一元操作符。这里的其余操作符是 *二元*，即它们接受两个操作数。'
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 3-14: *augmented_assignment_operators.py*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-14: *augmented_assignment_operators.py*'
- en: If you need both floor division (`//`) and modulo (`%`) on the same operands,
    Python provides the `divmod()` function to efficiently perform the calculation,
    returning the two results in a tuple. Thus, `c = divmod(a, b)` is the same as
    `c = (a // b, a % b)`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对同一操作数进行整数除法（`//`）和取余（`%`）操作，Python 提供了 `divmod()` 函数，可以高效地执行计算，并以元组的形式返回两个结果。因此，`c
    = divmod(a, b)` 与 `c = (a // b, a % b)` 是等价的。
- en: 'Python also has `bitwise` operators, which I’ll list below for those readers
    already familiar with bitwise arithmetic. I won’t introduce these concepts until
    Chapter 12:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还拥有 `bitwise` 操作符，下面我会列出它们，供那些已经熟悉位运算的读者参考。我直到第 12 章才会介绍这些概念：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 3-15: *bitwise_operators.py*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-15: *bitwise_operators.py*'
- en: The math Module
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学模块
- en: 'Python provides plenty of additional functions in the `math` module, along
    with the five most common math constants: `pi`, `tau`, `e`, `inf`, and `nan`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在 `math` 模块中提供了大量附加函数，以及五个最常见的数学常量：`pi`、`tau`、`e`、`inf` 和 `nan`。
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 3-16: *math_constants.py*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-16: *math_constants.py*'
- en: All five constants are floats and can be directly used as such ❶. The official
    documentation provides a complete list of everything available in the `math` module.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有五个常量都是浮点数，可以直接作为浮点数使用❶。官方文档提供了 `math` 模块中所有可用项的完整列表。
- en: 'You might remember a little trick from high school trigonometry, where you
    could calculate the height of something using your distance to it and the angle
    from your vantage point to the top of the object. Here’s a way to calculate that
    with Python, using the `math` module:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得高中的三角函数中有一个小技巧，通过你与物体的距离以及你视角到物体顶部的角度，可以计算出物体的高度。以下是使用 Python 和 `math`
    模块来计算这个问题的方法：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 3-17: *surveying_height.py*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-17: *surveying_height.py*'
- en: 'I use two functions from the `math` module: `math.radians()` ❶ and `math.tan()`
    ❷. The `round()` function ❸ is built into the language itself.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了 `math` 模块中的两个函数：`math.radians()` ❶ 和 `math.tan()` ❷。`round()` 函数 ❸ 是语言内置的。
- en: Logic
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑
- en: Python’s clean, obvious syntax for logical expressions is one of the attractive
    elements of the language. Here, I’ll cover conditional statements and expressions,
    as well as the comparison and logic operators.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python 干净、直观的逻辑表达式语法是该语言的一大亮点。在这里，我将介绍条件语句和表达式，以及比较和逻辑操作符。
- en: Conditionals
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Conditionals are compound statements composed of `if`, `elif`, and `else` clauses,
    each made up of a header and a suite. As with most languages, you can have as
    many `elif` conditionals in Python as you want, sandwiched between `if` and (optionally)
    `else`. Here’s a really simple example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句是由 `if`、`elif` 和 `else` 语句组成的复合语句，每个语句包括一个头部和一个代码块。与大多数语言一样，你可以在 Python
    中有任意数量的 `elif` 条件语句，插在 `if` 和（可选的）`else` 之间。这里是一个非常简单的示例：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 3-18: *conditional_greet.py*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-18: *conditional_greet.py*'
- en: This conditional statement is made up of three clauses. The `if` clause evaluates
    first, and if the expression in its header evaluates to `True`, its suite runs,
    printing `"Hello!"` Otherwise, it evaluates the expression in the `elif` header
    next. If none of the expressions evaluate to `True`, then the `else` clause runs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件语句由三个部分组成。`if` 部分首先进行评估，如果其头部表达式的结果为 `True`，则执行其代码块，打印 `"Hello!"`；否则，接下来评估
    `elif` 部分的表达式。如果没有任何表达式的结果为 `True`，则执行 `else` 部分。
- en: You’ll notice you don’t need to wrap the conditional expressions, such as `command
    == "greet"`, in parentheses, although you may do so anyway if it helps clarify
    your code. You’ll see an example of this shortly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，不需要将条件表达式（例如 `command == "greet"`）用括号括起来，尽管如果有助于明确代码，你可以这样做。稍后你将看到一个示例。
- en: If you’re looking for something similar to the `switch` statement from your
    favorite programming language, see the “Structural Pattern Matching” section toward
    the end of this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找类似于你最喜欢的编程语言中的`switch`语句，请查看本章末尾的“结构化模式匹配”部分。
- en: Comparison Operators
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较操作符
- en: 'Python has all the comparison operators you’d expect. Take a look at these
    in the context of comparing two integers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了你期望的所有比较操作符。看看这些操作符如何在比较两个整数的情况下工作：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 3-19: *comparison_operators.py*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-19: *comparison_operators.py*'
- en: As you can see, Python has operators for `equals`, `not equals`, `less than`,
    `less than or equals`, `greater than`, and `greater than or equals`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python 提供了`equals`、`not equals`、`less than`、`less than or equals`、`greater
    than`和`greater than or equals`的操作符。
- en: No surprises there, but what about boolean comparisons? This is where Python
    takes a different line.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么惊讶的，但布尔值比较怎么样呢？这就是 Python 与众不同的地方。
- en: Boolean, None, and Identity Operators
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值、None 和身份操作符
- en: Python offers the values `True` and `False`, which are the two values for boolean
    (type `bool`) variables. It also has a dedicated `None` value (type `NoneType`),
    which serves in the capacity of a “null” value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了 `True` 和 `False` 两个布尔值（类型 `bool`）。它还有一个专用的 `None` 值（类型 `NoneType`），用作“空”值。
- en: You check for these values in a very different way than with other data types.
    Instead of the comparison operators, use the special *identity operator* `is`.
    (I’ll also use the logical operator `not` below, which I’ll discuss separately
    in a bit.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你会以与其他数据类型完全不同的方式检查这些值。与比较操作符不同，使用特殊的*身份操作符* `is`。 （下面我还会使用逻辑操作符 `not`，稍后我会单独讨论。）
- en: 'Here’s an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 3-20: *boolean_identity_operators.py*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-20: *boolean_identity_operators.py*'
- en: Aside from being a little high in sodium, that code shows the many ways of testing
    boolean values and checking for `None`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有点高盐之外，代码展示了测试布尔值和检查 `None` 的多种方法。
- en: You can test if a variable is set to `True`, `False`, or `None` by comparing
    with the `is` operator. You can also invert the logic with `is not`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过与 `is` 操作符进行比较来测试变量是否设置为 `True`、`False` 或 `None`。你还可以使用 `is not` 来反转逻辑。
- en: Most commonly, when testing against `True`, you can use the variable as the
    entire condition ❶. For `False`, invert that condition test with `not` ❷.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况是，当测试 `True` 时，你可以将变量作为整个条件 ❶。对于 `False`，可以使用 `not` 来反转该条件测试 ❷。
- en: Take particular note of the last condition, which illustrates an important gotcha
    with the `is` operator ❸. It actually compares the identity of the variables,
    rather than the value. This is particularly troublesome, as the logic looks sound
    but is a bug waiting for a place to happen. That probably doesn’t mean much to
    you yet, but rest assured, I’ll cover this concept in depth in Chapter 5.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意最后一个条件，它说明了使用 `is` 运算符时的一个重要陷阱 ❸。它实际上比较的是变量的身份，而不是值。这是特别棘手的，因为逻辑看起来是正确的，但实际上是一个潜在的
    bug。可能这对你来说暂时没有太大意义，但请放心，我将在第五章深入讲解这一概念。
- en: 'For now, you can take this rule for granted: use `is` *only* for comparing
    directly to `None`, and use regular comparison operators for everything else.
    In practice, we usually say `if spam` or `if not spam`, instead of directly comparing
    to `True` or `False`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以记住这个规则：**仅**在与 `None` 直接比较时使用 `is`，对于其他所有情况使用常规比较运算符。在实践中，我们通常会说 `if spam`
    或 `if not spam`，而不是直接与 `True` 或 `False` 进行比较。
- en: Truthiness
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值真值性
- en: Most expressions and values in Python can be evaluated to a `True` or `False`
    value. This is typically done by using the value as an expression by itself, although
    you can also pass it to the `bool()` function to convert it explicitly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，大多数表达式和数值都可以评估为 `True` 或 `False`。通常，直接使用该值作为表达式来进行评估，尽管你也可以将其传递给
    `bool()` 函数以明确转换。
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 3-21: *truthiness.py*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-21: *truthiness.py*'
- en: When an expression will evaluate to `True`, it is considered “truthy.” When
    it will evaluate to `False`, it is “falsey.” The `None` constant, values representing
    zero, and empty collections are all considered “falsey,” while most other values
    are “truthy.”
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表达式评估为 `True` 时，它被认为是“真值”。当它评估为 `False` 时，它是“假值”。`None` 常量、表示零的值和空集合都被认为是“假值”，而大多数其他值则是“真值”。
- en: Logical Operators
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'If you’re coming from a language where logical operators are a little more
    difficult to remember, you’ll find Python refreshing: it simply uses the keywords
    `and`, `or`, and `not`!'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自一个逻辑运算符更难记住的编程语言，你会发现 Python 刷新了你的记忆：它简单地使用关键字 `and`、`or` 和 `not`！
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 3-22: *logical_operators.py*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-22: *logical_operators.py*'
- en: With the `and` condition, both expressions must evaluate to `True`. With the
    `or` condition, one or the other (or both) must evaluate to `True`. The third
    condition adds `not` to the picture, requiring that `eggs` be `False` and `spam`
    be `True`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `and` 条件，两个表达式必须都计算为 `True`。对于 `or` 条件，其中一个或两个表达式必须计算为 `True`。第三个条件增加了 `not`，要求
    `eggs` 为 `False`，而 `spam` 为 `True`。
- en: I could have omitted the parentheses on the third condition, as `not` takes
    precedence and so is evaluated before `and`. However, the parentheses help to
    clarify my intended logic.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以省略第三个条件中的括号，因为 `not` 运算符的优先级更高，因此会在 `and` 之前进行计算。然而，括号有助于明确我的逻辑意图。
- en: 'In practice, you can use the `not` keyword to invert any conditional expression,
    such as in the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以使用 `not` 关键字来反转任何条件表达式，例如以下示例：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 3-23: *not_operators.py*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-23: *not_operators.py*'
- en: 'Both comparisons do the same thing; the issue becomes readability. In this
    case, the expression using `not` is less readable because your eyes might skip
    over the `not` keyword, so you might not catch what’s happening in the code. The
    condition employing the `!=` operator is preferred for readability. While you
    might find situations where `not` is the best way to invert your conditional logic,
    remember The Zen of Python: ***Readability counts!***'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个比较做的是一样的事；问题在于可读性。在这种情况下，使用 `not` 的表达式可读性较差，因为你的眼睛可能会跳过 `not` 关键字，所以你可能没有注意到代码中发生了什么。使用
    `!=` 运算符的条件更易读。虽然你可能会遇到一些情况，在这些情况下 `not` 是反转条件逻辑的最佳方法，但请记住 Python 的禅意：***可读性优先！***
- en: The Walrus Operator
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 海象运算符
- en: Python 3.8 introduced *assignment expressions*, which allow you to assign a
    value to a variable and use that variable in another expression at the same time.
    This is possible with the so-called *walrus operator* (`:=`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.8 引入了 *赋值表达式*，它允许你将一个值赋给一个变量，并在同一时间使用该变量进行其他表达式的计算。这是通过所谓的 *海象运算符*（`:=`）实现的。
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 3-24: *walrus.py*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-24: *walrus.py*'
- en: With the walrus operator, Python first evaluates the expression on the left
    (`7+5`) and then assigns it to the variable `eggs`. The assignment expression
    is enclosed in parentheses for readability, although I technically could have
    omitted them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用海象运算符时，Python 首先计算左侧的表达式（`7+5`），然后将其赋值给变量 `eggs`。赋值表达式被括号包裹起来以提高可读性，尽管从技术上讲我本可以省略它们。
- en: The assignment expression is then evaluated to a single value, namely the value
    of `eggs`, which is used in the comparison. Since the value is `12`, the condition
    evaluates to `True`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，赋值表达式被计算为一个单一的值，即`eggs`的值，这个值用于比较。由于值为`12`，因此条件计算结果为`True`。
- en: What’s interesting about the assignment expression is that `eggs` is now a valid
    variable in the outer scope, so I can print its value outside of the conditional.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式的有趣之处在于，`eggs`现在是外部作用域中的一个有效变量，所以我可以在条件外打印它的值。
- en: This feature is potentially useful in many scenarios, not only in conditional
    expressions, as above.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性在许多场景中都非常有用，不仅仅是在条件表达式中，如上所示。
- en: 'Assignment expressions and the walrus operator were defined in PEP 572, which
    also contains an in-depth discussion about when and where this feature should
    be used. Two particularly useful style rules are put forth by this PEP:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式和海象运算符是在PEP 572中定义的，该文档也对何时以及在哪里使用此功能进行了深入讨论。该PEP提出了两条特别有用的风格规则：
- en: If either assignment statements or assignment expressions can be used, then
    prefer statements; they are clear declarations of intent.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以使用赋值语句或赋值表达式，优先使用语句；它们是意图的明确声明。
- en: If using assignment expressions would lead to ambiguity about execution order,
    then restructure to use statements instead.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用赋值表达式会导致执行顺序产生歧义，那么应当重构为使用语句代替。
- en: As of the writing of this book, Python assignment expressions are still in their
    infancy. A lot of debate and controversy still surrounds them. In any case, resist
    the temptation to abuse the walrus operator to cram as much logic onto one line
    as possible. You should always aim for readability and clarity in your code, above
    all else.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本书编写时，Python的赋值表达式仍处于起步阶段，围绕它有很多争议和讨论。无论如何，抵制使用海象运算符将尽可能多的逻辑塞进一行的诱惑。你应该始终把代码的可读性和清晰度放在首位。
- en: Ellipsis
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 省略号
- en: 'One seldom-used piece of syntax is the *Ellipsis*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一种很少使用的语法是*省略号*：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is sometimes used by various libraries and modules, but seldom consistently.
    For example, it’s used with multidimensional arrays in the NumPy third-party library
    and when working with type hints from the built-in `typing` module. When you see
    it come up, consult the documentation for whatever module you’re using.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是各种库和模块偶尔使用的语法，但并不总是统一使用。例如，在NumPy第三方库中，它用于多维数组，且在使用内置`typing`模块中的类型提示时也会遇到。当你看到这种用法时，请查阅你所使用的模块的文档。
- en: Strings
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'There are a few things to know about strings as you move forward. Here, I’ll
    cover the three kinds of strings: string literals, raw strings, and formatted
    strings.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有几个关于字符串的知识点需要了解。在这里，我将介绍三种类型的字符串：字符串字面量、原始字符串和格式化字符串。
- en: String Literals
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: 'There are multiple ways of defining a *string literal*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*字符串字面量*有多种方式：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 3-25: *string_literals.py*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-25: *string_literals.py*'
- en: You can wrap a literal in double quotes (`"`), single quotes (`'`), or triple
    quotes (`"""`) of either type. You may remember from earlier that there’s something
    special about triple quotes, but I’ll come back to that in a moment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将字面量包裹在双引号（`"`）、单引号（`'`）或三重引号（`"""`）中，任意一种类型都可以。你可能还记得，三重引号有些特别，我稍后会回到这个话题。
- en: 'PEP 8 addresses the use of single and double quotes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8规范了单引号和双引号的使用：
- en: In Python, single-quoted strings and double-quoted strings are the same. This
    PEP does not make a recommendation for this. Pick a rule and stick to it. When
    a string contains single or double quote characters, however, use the other one
    to avoid backslashes in the string. It improves readability.
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Python中，单引号字符串和双引号字符串是相同的。PEP并没有对此做出推荐。选择一个规则并遵循它。然而，当字符串中包含单引号或双引号字符时，使用另一种引号以避免在字符串中出现反斜杠。这可以提高可读性。
- en: 'The advice about placing quotes inside a string comes in handy when dealing
    with something like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理类似的情况时，关于将引号放入字符串的建议会非常有用：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 3-26: *escaping_quotes.py:1a*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-26: *escaping_quotes.py:1a*'
- en: This version escapes the double quotes I want to include in the string literal
    itself. The backslash (`\`) before the quotes means I want the string to contain
    that *literal character*, not to have Python treat the double quote as the boundary
    of a string. The string literal must always be wrapped in matching quotes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本转义了我希望在字符串字面量中包含的双引号。反斜杠（`\`）放在引号前，表示我希望字符串包含那个*字面字符*，而不是让Python将双引号视为字符串的边界。字符串字面量必须始终用匹配的引号包裹。
- en: 'It is possible to avoid backslashes in this scenario, however:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以避免使用反斜杠，但也有可能：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 3-27: *escaping_quotes.py:1b*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-27: *escaping_quotes.py:1b*'
- en: This second version wraps the literal in single quotes, so the double quotes
    will be automatically interpreted as part of the string literal. That approach
    is much more readable. By wrapping the string in single quotes, Python will assume
    the double quotes are characters in the string.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第二版本将字面量用单引号括起来，这样双引号会自动被解释为字符串字面量的一部分。这个方法更易于阅读。通过将字符串用单引号括起来，Python 会假设双引号是字符串中的字符。
- en: 'The only time you’d really need to escape either single or double quotes with
    backslashes would be if you had both types of quotes in the string at once:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正需要用反斜杠转义单引号或双引号的情况是，如果字符串中同时包含两种引号：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 3-28: *escaping_quotes.py:2a*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-28: *escaping_quotes.py:2a*'
- en: Personally, in cases like that, I’d prefer to use (and escape) the double quotes,
    because they don’t evade my attention like an apostrophe would tend to do.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，在这种情况下，我更喜欢使用（并转义）双引号，因为它们不像撇号那样容易让我忽视。
- en: 'You also have the option to use triple quotes:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以选择使用三重引号：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 3-29: *escaping_quotes.py:2b*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-29: *escaping_quotes.py:2b*'
- en: 'Remember that triple quotes define *multiline string literals*. In other words,
    I can use them to do this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，三重引号定义了 *多行字符串字面量*。换句话说，我可以用它们来做这个：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 3-30: *multiline_string.py*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-30: *multiline_string.py*'
- en: Everything, including newlines and leading whitespace, is literal in triple
    quotes. If I `print("parrot")`, it will display exactly like this in the terminal.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在三重引号中，一切内容，包括换行符和前导空格，都是字面量。如果我 `print("parrot")`，它将在终端中精确地显示如下：
- en: The only exception occurs when you use a backslash (`\`) to escape a particular
    character, like I did with that newline at the beginning ❶. It is conventional
    to escape the first newline after the opening triple quotes, just to make the
    code look cleaner.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外情况是当你使用反斜杠 (`\`) 来转义某个特定字符时，就像我在开始时用换行符做的那样 ❶。通常情况下，在开启三重引号后的第一个换行符需要转义，以使代码看起来更简洁。
- en: The built-in `textwrap` module has some functions for working with multiline
    strings, including tools that allow you remove leading indentation (`textwrap.dedent`).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `textwrap` 模块提供了一些处理多行字符串的函数，包括允许你去除前导缩进的工具（`textwrap.dedent`）。
- en: Alternatively, you can *concatenate* (combine) string literals, simply by writing
    them next to one another, without any operators between them. For example, `spam
    = "Hello " "world" "!"` is valid, resulting in the string `Hello world!.` If you
    wrap the assignment expression in parentheses, you can even span multiple lines.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以 *连接*（合并）字符串字面量，只需将它们写在一起，中间不加任何运算符。例如，`spam = "Hello " "world" "!"` 是有效的，结果是字符串
    `Hello world!`。如果你将赋值表达式括在括号中，甚至可以跨越多行。
- en: Raw Strings
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始字符串
- en: '*Raw strings* constitute another form of string literal, wherein the backslash
    (`\`) is always treated as a literal character. They’re preceded with an `r`,
    such as in this example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始字符串* 是另一种字符串字面量形式，其中反斜杠 (`\`) 总是作为字面字符处理。它们之前会加上 `r`，例如在这个例子中：'
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 3-31: *raw_string.py*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-31: *raw_string.py*'
- en: 'The backslash is treated like a literal character, which means that nothing
    can be escaped inside of a raw string. The output of that line of code looks like
    this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠被视为字面字符，这意味着在原始字符串中没有任何字符可以被转义。那行代码的输出如下所示：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This has implications for what type of quotes you use, so beware.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这会影响你使用哪种类型的引号，所以要小心。
- en: 'Compare these two lines and their outputs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两行及其输出：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 3-32: *raw_or_not.py*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-32: *raw_or_not.py*'
- en: 'The first string is ordinary, so `\n` is treated as a normal escape sequence:
    specifically, the newline character. That line break appears in the output, like
    this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符串是普通的，因此 `\n` 被视为一个正常的转义序列：具体来说，就是换行符。该换行符会出现在输出中，如下所示：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The second string is a raw string, so the backslash (`\`) is treated as a literal
    character in its own right. The output would be as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字符串是原始字符串，因此反斜杠 (`\`) 被视为字面字符。输出如下所示：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is particularly useful for regular expression patterns, where you’re likely
    to have plenty of backslashes that you want as part of the *pattern*, not interpreted
    by Python before it gets there. ***Always use raw strings for regular expression
    patterns.***
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于正则表达式模式特别有用，因为你可能会有很多反斜杠，而这些反斜杠应该作为 *模式* 的一部分，而不是在到达那里之前被 Python 解释。***总是使用原始字符串处理正则表达式模式。***
- en: Formatted Strings
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化字符串
- en: A third kind of string literal is a *formatted string* or *f-string*, which
    is new as of Python 3.6 (defined in PEP 498). It allows you to insert the values
    of variables into a string in a very elegant manner.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种字符串字面量是*格式化字符串*或*f-字符串*，它是 Python 3.6 中新增的（在 PEP 498 中定义）。它允许你以一种非常优雅的方式将变量的值插入到字符串中。
- en: 'If I wanted to include the value of a variable in a string without an f-string,
    the code might look like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想在不使用 f-字符串的情况下将变量的值包含到字符串中，代码可能是这样的：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 3-33: *cheese_shop.py:1a*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-33: *cheese_shop.py:1a*'
- en: The `str()` function converts the value passed to it into a string, and then
    the three strings are *concatenated*, or combined, into one, using the `+` operator.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()`函数将传递给它的值转换为字符串，然后这三个字符串会通过`+`操作符被*连接*成一个字符串。'
- en: Using f-strings, this code becomes more elegant.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 f-字符串后，这段代码变得更加优雅。
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 3-34: *cheese_shop.py:1b*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-34: *cheese_shop.py:1b*'
- en: You precede the string literal with an `f`. Inside, you can substitute a variable
    by wrapping it in curly braces (`{ }`). The `f` tells Python to interpret and
    evaluate as an expression anything in the string that’s wrapped in curly braces.
    This means you’re not limited to variables in those curly braces. You can put
    just about any valid Python code in there, including math, function calls, conditional
    expressions, or whatever you need.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你在字符串字面量前加上一个`f`。在其中，你可以通过将变量包裹在大括号（`{ }`）中来进行替换。这个`f`告诉 Python 将字符串中被大括号包裹的部分视为表达式进行解释和计算。这意味着你在大括号中不仅限于使用变量。你几乎可以在其中放入任何有效的
    Python 代码，包括数学运算、函数调用、条件表达式，或者任何你需要的东西。
- en: As of Python 3.8, you can even display both the expression *and* its result
    by appending a trailing equal sign (`=`).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.8 开始，你甚至可以通过在后面加上等号（`=`）来显示表达式*及*其结果。
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 3-35: *expression_fstring.py*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-35: *expression_fstring.py*'
- en: 'There are a couple of gotchas when using f-strings:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 f-字符串时有几个常见问题：
- en: 'First, if you want to wrap an expression in literal curly braces, you must
    use two curly braces (`{{ }}`) for every one you want displayed:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你想在字面量大括号中包裹一个表达式，你必须使用两个大括号（`{{ }}`）来表示每一个你想显示的大括号：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 3-36: *literal_curly_braces.py*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-36: *literal_curly_braces.py*'
- en: 'If you have an odd number of braces, one pair will be ignored. So, if I used
    five pairs, the result would be the same as if I only had four: two literal pairs
    would be printed.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有奇数个大括号，其中一对将被忽略。所以，如果我使用了五对大括号，结果将和只有四对大括号时一样：会打印出两对字面量大括号。
- en: 'Second, you cannot use backslashes within an expression in an f-string. This
    makes it difficult to escape quotes inside expressions. For example, this would
    not work:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你不能在 f-字符串的表达式中使用反斜杠。这使得在表达式内部转义引号变得困难。例如，这样的代码将不起作用：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To get around this, I’d need to use triple quotes on the outside of the string,
    to ensure I can employ both single and double quotes inside of the expression.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个问题，我需要在字符串外部使用三引号，确保我可以在表达式内部使用单引号和双引号。
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Backslashes have other roles. The documentation points out the following problematic
    situation:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠有其他用途。文档中指出了以下问题情况：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There’s no direct way around this limitation. Instead, you’d have to evaluate
    that expression in advance, assign the result to a name, and use it in the f-string.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 没有直接的方法可以绕过这个限制。相反，你必须先计算该表达式，将结果赋值给一个变量，并在 f-字符串中使用它。
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Third, and perhaps least surprising, you cannot put comments inside of f-string
    expressions; the hash (`#`) symbol isn’t allowed, except as a string literal.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，可能最不令人惊讶的一点是，你不能在 f-字符串表达式中放置注释；哈希符号（`#`）是禁止使用的，除非作为字符串字面量。
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Lastly, you can never use f-strings as docstrings.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你不能将 f-字符串用作文档字符串。
- en: These small wrinkles aside, f-strings are incredibly straightforward to work
    with.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些小瑕疵，f-字符串的使用非常直接。
- en: Format Specifications
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 格式规范
- en: Besides arbitrary expressions, f-strings support *format specifications*, which
    allow you to control how values are displayed. This is a fairly in-depth topic
    that could easily become a main section on its own, so I will entrust you to the
    guidance of the documentation for the bulk of it. I’ll breeze over the essentials
    herein.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 除了任意表达式，f-字符串还支持*格式规范*，它允许你控制值的显示方式。这是一个相当深入的话题，可能会成为一个独立的章节，因此我会将详细内容交给文档中的指导部分。这里我会简单介绍其中的要点。
- en: 'Immediately after the expression, you may choose to include one of three special
    flags: `!r`, `!a`, or `!s` (although that last one is the default behavior, so
    it can be omitted in most cases). These determine which function is used to fetch
    the string representation of some value: `repr()`, `ascii()`, or `str()`, respectively
    (see “String Conversion” below).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式之后，您可以选择包括三个特殊标志中的一个：`!r`、`!a` 或 `!s`（尽管最后一个是默认行为，因此在大多数情况下可以省略）。这些标志决定使用哪个函数来获取某个值的字符串表示：分别是
    `repr()`、`ascii()` 或 `str()`（请参阅下面的“字符串转换”部分）。
- en: 'Next comes the format specification itself, which always begins with a colon
    (`:`), followed by one or more flags. These have to be specified in a particular
    order to work, although any of them may be omitted if they’re not desired:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是格式说明本身，它总是以冒号（`:`）开头，后跟一个或多个标志。这些标志必须按照特定顺序指定才能生效，尽管如果不需要，任何标志都可以省略：
- en: Align An alignment flag, specifying left (`<`), right (`>`), center (`^`), or
    (if numeric) split with the sign aligned left but the digits aligned right (`=`).
    This is optionally preceded by a character that will be used to fill any blank
    space in the alignment.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐 一个对齐标志，指定左对齐（`<`）、右对齐（`>`）、居中（`^`），或（如果是数字）将符号左对齐而数字右对齐（`=`）。这之前可以选择一个字符，用于填充对齐中的空白空间。
- en: Sign A flag controlling when the sign is displayed on a number. The plus (`+`)
    flag displays the sign on both positive and negative numbers, while the minus
    (`–`) flag only displays it on negative numbers. A third option is to show a leading
    space on positive numbers and a sign on negative numbers (space).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 一个控制何时显示数字符号的标志。加号（`+`）标志会在正数和负数上都显示符号，而减号（`–`）标志仅在负数上显示符号。第三种选择是对正数显示前导空格，对负数显示符号（空格）。
- en: Alternative form The hash (`#`) flag turns on the “alternative form,” which
    has different meanings for different types (see documentation).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 替代形式 哈希（`#`）标志开启“替代形式”，该形式在不同类型中有不同的含义（请参阅文档）。
- en: Leading zeros The zero (`0`) flag causes leading zeros to be displayed (unless
    a fill character is specified for alignment).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 前导零 零（`0`）标志会导致显示前导零（除非为对齐指定了填充字符）。
- en: Width The width of the output string in characters. This is where the alignment
    comes into play.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度 输出字符串的宽度，单位为字符。此处是对齐起作用的地方。
- en: Grouping A flag controlling whether numbers should separate thousands with a
    comma (`,`) or an underscore (`_`). If omitted, no separator is used. If enabled,
    the underscore separator also appears every four digits in octal, hexadecimal,
    and binary numbers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 分组 一个标志控制数字是否使用逗号（`,`）或下划线（`_`）分隔千位数。如果省略，则不使用分隔符。如果启用，八进制、十六进制和二进制数字每四位数字也会使用下划线分隔符。
- en: Precision A dot (`.`), followed by an integer for decimal precision.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 精度 一个点（`.`），后跟一个整数，表示小数精度。
- en: Type A flag controlling how numbers are displayed; common options include binary
    (`b`), character (`c`), decimal (`d`), hexadecimal (`x`), exponent notation (`e`),
    fixed-point (`f`), and general (`g`). There are more (see documentation).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 A 标志控制数字的显示方式；常见选项包括二进制（`b`）、字符（`c`）、十进制（`d`）、十六进制（`x`）、指数表示法（`e`）、定点数（`f`）和通用格式（`g`）。还有更多选项（请参阅文档）。
- en: 'All that is a bit abstract, so here are a few quick examples:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容有些抽象，以下是几个快速示例：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 3-37: *formatting_strings.py*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-37: *formatting_strings.py*'
- en: 'Complete details about the format specification can be found in the official
    Python documentation: [https://docs.python.org/3/library/string.xhtml#format-string-syntax](https://docs.python.org/3/library/string.xhtml#format-string-syntax).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明的完整细节可以在官方 Python 文档中找到：[https://docs.python.org/3/library/string.xhtml#format-string-syntax](https://docs.python.org/3/library/string.xhtml#format-string-syntax)。
- en: Another useful reference is [https://pyformat.info](https://pyformat.info),
    although as of this writing, it only shows the format specification in the context
    of the old `format()` function. You will need to apply it to f-strings yourself.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的参考是 [https://pyformat.info](https://pyformat.info)，尽管截至目前，它仅显示了在旧的 `format()`
    函数上下文中的格式说明。您需要自己将其应用于 f-strings。
- en: Previous String-Formatting Methods
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 之前的字符串格式化方法
- en: 'If you’re reading older Python code, you may encounter the two previous forms
    of string formatting: `%` notation and the newer `format()`. These have both been
    superseded by f-strings, which have superior performance. That’s because they’re
    parsed and converted to bytecode *before* the code is run.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在阅读旧版的Python代码，你可能会遇到两种以前的字符串格式化方式：`%`符号和更新的`format()`。这两者已经被f-string所取代，f-string具有更优的性能。因为它们是在代码执行之前就被解析并转换为字节码。
- en: If you find yourself needing to rewrite a `format()` call as an f-string, the
    process is thankfully quite simple.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要将一个`format()`调用重写为f-string，幸运的是这个过程非常简单。
- en: 'Here’s an example. I’ll start out with a couple of variables:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例。我将从几个变量开始：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 3-38: *format_to_fstring.py:1*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-38: *format_to_fstring.py:1*'
- en: 'Before the advent of f-strings, if I wanted to print out a message containing
    the values of those two variables, I’d have used `format()`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在f-string出现之前，如果我想要打印出包含这两个变量值的消息，我会使用`format()`：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 3-39: *format_to_fstring.py:2a*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-39: *format_to_fstring.py:2a*'
- en: In the old format, a string literal ❶ would contain sets of curly braces, optionally
    containing the format specifications. The `format()` function would be called
    on that string literal (or on a name referencing it). Then, the expressions to
    be evaluated would be passed to the `format()` function in order ❷.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧格式中，字符串字面量 ❶ 将包含一对大括号，可能包含格式化说明符。然后，`format()`函数会被调用来处理该字符串字面量（或其引用的名称）。接着，将按顺序将要评估的表达式传递给`format()`函数
    ❷。
- en: 'That would have the following output:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE48]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Converting this to an f-string is as simple as moving the expressions into
    the string literal in order and then prepending an `f` to the literal to make
    it an f-string:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为f-string的操作很简单，只需按顺序将表达式放入字符串字面量中，然后在字面量前加上`f`以使其成为f-string：
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 3-40: *format_to_fstring.py:2b*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-40: *format_to_fstring.py:2b*'
- en: The output is the same as before.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 输出和之前一样。
- en: 'Optionally, with `format()`, you could refer to the index of the expression
    in the argument list:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以使用`format()`来引用参数列表中表达式的索引：
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Listing 3-41: *format_to_fstring.py:3a*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-41: *format_to_fstring.py:3a*'
- en: 'That produces this output:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To convert this code to an f-string, you substitute the expressions in place
    of the indices in the string literal, which you (again) turn into an f-string
    by prepending an `f`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此代码转换为f-string，你只需将表达式替换为字符串字面量中的索引，然后通过在字面量前加上`f`来将其转换为f-string：
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 3-42: *format_to_fstring.py:3b*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-42: *format_to_fstring.py:3b*'
- en: Converting from `%` notation is a little less trivial, but most Python 3 code
    uses `format()` anyway. If you find yourself needing to do this, [https://pyformat.info](https://pyformat.info)
    does an excellent job of comparing `%` notation and `format()`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从`%`符号格式转换稍微复杂一些，但大多数Python 3代码依然使用`format()`。如果你需要进行这种转换，[https://pyformat.info](https://pyformat.info)非常出色地对比了`%`符号和`format()`的区别。
- en: Template Strings
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板字符串
- en: '*Template strings* constitute one more alternative to f-strings that is worth
    knowing about, especially as it still fulfills some use cases, including internationalizing
    user interfaces. Personally, I find template strings a bit more reusable. On the
    other hand, the drawback is that they’re considerably more limited in terms of
    formatting.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板字符串*是f-string的另一个替代选择，值得了解，尤其是在它仍然能满足一些使用场景，包括界面国际化。就个人而言，我觉得模板字符串在可重用性方面稍微强一些。另一方面，它的缺点是格式化方面的功能比较有限。'
- en: If you know how they work, you’ll be equipped to decide for yourself which tool
    is best for your particular situation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解它们是如何工作的，你将能够自己判断哪种工具最适合你的具体情况。
- en: 'Here’s a template string for greeting a user:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于问候用户的模板字符串：
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 3-43: *template_string.py:1*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-43: *template_string.py:1*'
- en: To use template strings, I first have to import `Template` from the `string`
    module.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用模板字符串，我首先需要从`string`模块导入`Template`。
- en: 'Then I can create a new `Template` and pass it a string literal:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以创建一个新的`Template`并将一个字符串字面量传递给它：
- en: '[PRE54]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listing 3-44: *template_string.py:2*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-44: *template_string.py:2*'
- en: I can name my fields whatever I want, preceding each with a dollar sign (`$`).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以随意命名我的字段，在每个字段前加上美元符号（`$`）。
- en: 'Finally, I call the `substitute()` function on the template I created (`s`)
    and pass expressions to each of the fields:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我调用模板上创建的`substitute()`函数（`s`），并将表达式传递给每个字段：
- en: '[PRE55]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Listing 3-45: *template_string.py:3*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-45: *template_string.py:3*'
- en: 'The finished string is returned, and in this case, it is passed to `print()`
    and displayed:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最终字符串被返回，在这个例子中，它被传递给`print()`并显示出来：
- en: '[PRE56]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'There are a couple of odd syntax rules with template strings. First, to show
    a literal dollar sign in the string literal, use two dollar signs (`$$`). Second,
    to substitute an expression as part of a word, wrap the name of the field in curly
    braces (`{ }`). Both of these rules are demonstrated below:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串有几个奇怪的语法规则。首先，要在字符串字面量中显示字面量的美元符号，使用两个美元符号（`$$`）。其次，要在一个单词中替换一个表达式，需将字段名包裹在花括号（`{
    }`）中。下面演示了这两个规则：
- en: '[PRE57]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 3-46: *template_string.py:4*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-46：*template_string.py:4*
- en: 'That outputs the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE58]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There’s a handful of additional abilities contained within string templates,
    but I’ll entrust you to the official Python documentation for the rest of that.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模板包含一些额外的功能，但剩下的部分我会交给你参考官方Python文档。
- en: String Conversion
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串转换
- en: 'I previously mentioned that there are three ways to get the string representation
    of a value: `str()`, `repr()`, and `ascii()`.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，有三种方法可以获取一个值的字符串表示：`str()`、`repr()`和`ascii()`。
- en: The first function, `str()`, is the one you’ll use most often, as it returns
    the *human-readable* representation of the value.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`str()`是你最常使用的，它返回值的*人类可读*表示形式。
- en: 'By contrast, `repr()` returns the *canonical string representation* of the
    value: that is, (usually) the value as Python sees it. In the case of many basic
    data types, this will return the same thing as `str()`, but when used on most
    objects, the output contains additional information useful in debugging.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`repr()`返回值的*规范字符串表示*：也就是（通常）Python所看到的值。在许多基本数据类型的情况下，这将返回与`str()`相同的内容，但在大多数对象上使用时，输出包含对调试有用的额外信息。
- en: The `ascii()` function is the same as `repr()`, except that the string literal
    it returns is completely ASCII-compatible, having escaped any non-ASCII (for example,
    Unicode) characters.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`ascii()`函数与`repr()`相同，不同之处在于它返回的字符串字面量是完全兼容ASCII的，已经转义了所有非ASCII字符（例如Unicode字符）。'
- en: I’ll return to this concept in Chapter 7, when I start defining my own objects.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第七章回到这个概念，当时我开始定义我自己的对象。
- en: A Note on String Concatenation
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串连接的注意事项
- en: Up to this point, I’ve been using the addition (`+`) operator for concatenating
    strings together. This is acceptable in basic situations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直在使用加号（`+`）运算符来连接字符串。这在基本情况下是可以接受的。
- en: However, this is seldom the most efficient solution, especially when combining
    multiple strings. Therefore, it is recommended to prefer the `join()` method,
    which is called on a string or string literal instead.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这通常不是最有效的解决方案，特别是在组合多个字符串时。因此，建议优先使用`join()`方法，它是作用于字符串或字符串字面量的。
- en: 'Here’s a comparison between the two. I start with a couple of string variables:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两者的对比。我先定义了几个字符串变量：
- en: '[PRE59]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 3-47: *concat_strings.py:1*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-47：*concat_strings.py:1*
- en: 'So far, you’ve seen concatenation with the addition (`+`) operator, like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到过使用加号（`+`）运算符连接字符串，如下所示：
- en: '[PRE60]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Listing 3-48: *concat_strings.py:2a*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-48：*concat_strings.py:2a*
- en: 'Alternatively, I can use the `join()` method:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我可以使用`join()`方法：
- en: '[PRE61]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 3-49: *concat_strings.py:2b*'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-49：*concat_strings.py:2b*
- en: I call the `join()` method on the string that will appear between each piece.
    In this case, I use an empty string. The `join()` method accepts a *tuple* of
    strings—an array-like structure wrapped in parentheses, and therefore, the double
    set of parentheses in the code. I’ll introduce tuples in an upcoming section.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我在每个片段之间会出现的字符串上调用`join()`方法。在这个例子中，我使用了一个空字符串。`join()`方法接受一个*元组*的字符串——一个类似数组的结构，括在圆括号内，因此代码中有一对圆括号。我将在接下来的部分介绍元组。
- en: Typical concatenation with `+` or the `join()` function has the same result,
    but the latter function will be *as fast or faster*, especially when you’re using
    other implementations of Python besides CPython. Therefore, whenever you need
    to concatenate and f-strings aren’t right for the job, you should consider using
    `join()` instead of the `+` or `+=` operators. In practice, f-strings are the
    fastest, but `join()` is your next-best option.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`+`或`join()`函数的典型连接方式结果相同，但后者通常会*更快或一样快*，尤其是在使用CPython以外的其他Python实现时。因此，每当你需要连接字符串且f-strings不适合时，应该考虑使用`join()`，而不是`+`或`+=`运算符。在实际应用中，f-strings是最快的，但`join()`是下一个最佳选择。
- en: Functions
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: Python functions are *first-class citizens*, which means they can be treated
    like any other object. Even so, you call them as you would in any other programming
    language.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Python 函数是*一等公民*，这意味着它们可以像其他任何对象一样被对待。即便如此，你仍然可以像在其他任何编程语言中一样调用它们。
- en: Here’s an example of a very basic function, which prints a selected type of
    joke to the terminal.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的函数示例，它会将选择的笑话类型打印到终端。
- en: 'I start with the function header:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我从函数头开始：
- en: '[PRE62]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Listing 3-50: *joke_function.py:1*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-50: *joke_function.py:1*'
- en: I declared the function with the `def` keyword, followed by the name of the
    function. Parameters are named in the parentheses after the function name. The
    entire header is concluded with a colon (`:`).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我用 `def` 关键字声明了函数，接着是函数的名称。参数在函数名后的括号中命名。整个头部以冒号（`:`）结束。
- en: 'Below the header, indented one level, is the *suite* (or body) of the function:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部下面，缩进一级，是函数的*代码块*（或主体）：
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Listing 3-51: *joke_function.py:2*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-51: *joke_function.py:2*'
- en: 'You call functions in much the same way as in most languages:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用函数的方式和大多数语言差不多：
- en: '[PRE64]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 3-52: *joke_function.py:3*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-52: *joke_function.py:3*'
- en: I’ll go into depth on functions and their many cousins in Chapter 6.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第6章深入讲解函数及其众多变种。
- en: Classes and Objects
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象
- en: Python fully supports object-oriented programming. In fact, one of the language’s
    design principles is that “everything is an object,” at least behind the scenes.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Python 完全支持面向对象编程。实际上，Python 语言的设计原则之一就是“万物皆对象”，至少在幕后是这样。
- en: There’s a lot more to classes than meets the eye, but for now, you should just
    get an absolutely bare-bones familiarity with the syntax.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 类有更多内容，比眼见的要复杂得多，但目前你应该仅仅对语法有一个基本的了解。
- en: 'The following class contains a joke of a selected type and displays it on demand:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类包含一个特定类型的笑话，并根据需要展示它：
- en: '[PRE65]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Listing 3-53: *joke_class.py:1*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-53: *joke_class.py:1*'
- en: I define the class using the `class` keyword, the name of the class, and a colon
    (`:`) at the end of the header.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `class` 关键字定义类，接着是类名，并在头部末尾加上冒号（`:`）。
- en: 'This is followed by the suite of the class, indented one level:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是类的代码块，缩进一级：
- en: '[PRE66]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Listing 3-54: *joke_class.py:2*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-54: *joke_class.py:2*'
- en: The initializer, which is similar in purpose to the constructor in other OOP
    languages, is a member function, or *method*, with the name `__init__()` and at
    least one parameter, `self`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器，功能上类似于其他面向对象编程语言中的构造函数，是一个成员函数或*方法*，名为 `__init__()`，并且至少有一个参数，`self`。
- en: '[PRE67]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 3-55: *joke_class.py:3*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-55: *joke_class.py:3*'
- en: 'Functions that belong to the class are called methods and are part of the class
    suite. Methods must accept at least one parameter: `self`.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 属于类的函数称为方法，它们是类的一部分。方法必须接受至少一个参数：`self`。
- en: 'You would use this class like so:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样使用这个类：
- en: '[PRE68]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 3-56: *joke_class.py:4*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-56: *joke_class.py:4*'
- en: You create a new instance of the `Joke` class by passing the string `"lethal"`
    to its *initializer*, the `__init__()` from earlier. The new object is stored
    in the variable `lethal_joke`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过将字符串 `"lethal"` 传递给它的*初始化器* `__init__()` 来创建 `Joke` 类的新实例。新对象会存储在变量 `lethal_joke`
    中。
- en: Then, you use the *dot operator* (`.`) to call the function `tell()` within
    the object. Take note that you didn’t have to pass any argument for `self`. That’s
    done automatically when you call the function in this manner.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你使用*点操作符* (`.`) 来调用对象中的函数 `tell()`。请注意，你不需要为 `self` 传递任何参数。当你以这种方式调用函数时，`self`
    会自动传递。
- en: I’ll discuss classes and objects in detail in Chapter 7 and further in Chapter
    13.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第7章和第13章中详细讨论类和对象。
- en: Error Handling
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: Python offers error and exception handling functionality through the `try` compound
    statement.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通过 `try` 复合语句提供了错误和异常处理功能。
- en: For example, if I wanted to get a number from the user, I couldn’t reliably
    predict what they would type in. Trying to convert a string, like `"spam"`, to
    an integer would cause an error. I can use error handling to take a different
    action if it isn’t possible to convert the user `input`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想从用户那里获取一个数字，我无法可靠地预测他们会输入什么。如果我试图将一个字符串（如 `"spam"`）转换为整数，将会引发错误。我可以使用错误处理来采取不同的行动，若无法转换用户的
    `input`。
- en: '[PRE69]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Listing 3-57: *try_except.py*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-57: *try_except.py*'
- en: I get a string from the user, and then in the `try` clause, I attempt to convert
    it to an integer with the `int()` function. That would raise a `ValueError` exception
    if the string it’s trying to convert is not a valid whole number (base 10).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我从用户获取一个字符串，然后在 `try` 子句中，我尝试使用 `int()` 函数将其转换为整数。如果该字符串不能被转换为有效的整数（十进制），则会抛出
    `ValueError` 异常。
- en: If that exception is raised, I catch it in the `except` clause and handle the
    failure.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出该异常，我会在 `except` 子句中捕获它并处理失败。
- en: In any case, the last line would always be run.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，最后一行都会被执行。
- en: There are additional features and subtleties to the `try` statement, including
    `finally` and `else` clauses, which I’ll cover in Chapter 8. For now, it’s better
    to avoid these concepts rather than use them incorrectly.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 语句还有其他特性和细微差别，包括 `finally` 和 `else` 子句，我将在第 8 章中讲解。现在，最好避免使用这些概念，以免错误使用。'
- en: Tuples and Lists
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组和列表
- en: Two of Python’s most common built-in data structures, called *collections*,
    are tuples and lists.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Python 最常用的两个内置数据结构，称为 *collections*，是元组和列表。
- en: '*Lists* constitute the most array-like collection in Python. In CPython, they
    are implemented as variable-length arrays, not as linked lists like the name might
    suggest.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* 是 Python 中最像数组的集合。在 CPython 中，它们实现为可变长度的数组，而不是像名称所暗示的那样的链表。'
- en: 'For example, here is a list of strings with names of cheeses:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个包含奶酪名称的字符串列表：
- en: '[PRE70]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Listing 3-58: *cheese_list.py:1*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-58: *cheese_list.py:1*'
- en: You enclose a list literal in square brackets, separating each item in the list
    with commas.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 你用方括号包围列表字面量，并用逗号分隔列表中的每一项。
- en: 'You can access or reassign the values of individual items with the same bracket
    notation used by most programming languages:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用大多数编程语言常用的相同括号表示法来访问或重新赋值单个项的值：
- en: '[PRE71]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 3-59: *cheese_list.py:2*'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-59: *cheese_list.py:2*'
- en: A *tuple* is somewhat similar to a list, but with a few key differences. First,
    a tuple cannot have items added, reassigned, or removed after its creation. Attempting
    to modify the contents of a tuple with bracket notation will result in a `TypeError`.
    This is because tuples, unlike lists, are *immutable*, effectively meaning their
    contents cannot be modified (see Chapter 5 for the full explanation).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组* 与列表有些相似，但有一些关键的不同之处。首先，元组在创建后不能添加、重新赋值或删除项。尝试用括号表示法修改元组的内容会导致 `TypeError`
    错误。这是因为元组不同于列表，它们是 *不可变的*，实际上意味着它们的内容不能被修改（详细解释请参见第 5 章）。'
- en: 'Here is an example of a tuple:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个元组的示例：
- en: '[PRE72]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Listing 3-60: *knight_tuple.py:1*'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-60: *knight_tuple.py:1*'
- en: 'You enclose tuple literals in parentheses (`( )`), instead of brackets (`[
    ]`). Nevertheless, you still use bracket notation to access individual items:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你用圆括号（`( )`）包围元组字面量，而不是方括号（`[ ]`）。尽管如此，你仍然使用方括号表示法来访问单个项：
- en: '[PRE73]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Listing 3-61: *knight_tuple.py:2*'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-61: *knight_tuple.py:2*'
- en: 'As I said, you cannot change the items of a tuple after creation, such as if
    you tried to reassign the first item:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，创建元组后不能修改元组中的项，例如，如果你尝试重新赋值第一个项：
- en: '[PRE74]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Listing 3-62: *knight_tuple.py:3*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-62: *knight_tuple.py:3*'
- en: The guideline is to use tuples for collections of items of different types (*heterogeneous*
    collections) and to use lists for collections of items of the same type (*homogeneous*
    collections).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 指导原则是使用元组来存储不同类型（*异构*）的项，而使用列表来存储相同类型（*同构*）的项。
- en: I’ll discuss these collections, and many more, in Chapter 9.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第 9 章讨论这些集合，以及更多内容。
- en: Loops
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'Python has two basic loop types: *while* and *for*.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两种基本的循环类型：*while* 循环和 *for* 循环。
- en: while Loop
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while 循环
- en: 'The `while` loop probably looks familiar from other languages:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环可能在其他编程语言中也很常见：'
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 3-63: *while_loop.py*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-63: *while_loop.py*'
- en: I start the loop with the `while` keyword, follow it with the condition to test,
    and finish the header with a colon (`:`). As long as that condition evaluates
    to `True`, the code in the suite of the loop is executed.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我用 `while` 关键字开始循环，接着写出要测试的条件，并以冒号（`:`）结束条件部分。只要该条件为 `True`，循环体中的代码就会执行。
- en: When you need to keep running a loop until some condition is met, use `while`
    loops. These are particularly useful when you don’t know how many iterations of
    the loop will take place before the condition is met.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要不断运行循环直到满足某个条件时，可以使用 `while` 循环。特别是在你不知道循环会执行多少次才满足条件时，`while` 循环非常有用。
- en: Loop Control
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环控制
- en: You can manually control the loop, using two keywords. The `continue` keyword
    abandons the current iteration and jumps to the next one. The `break` keyword
    exits the loop altogether.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动控制循环，使用两个关键字。`continue` 关键字放弃当前迭代并跳到下一次迭代。`break` 关键字则完全退出循环。
- en: 'One common scenario where you may use these keywords is in an infinite loop
    used for running a game or a user interface. For example, here’s a very simple
    command prompt:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的使用这些关键字的场景是在用于运行游戏或用户界面的无限循环中。例如，下面是一个非常简单的命令提示符：
- en: '[PRE76]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Listing 3-64: *loop_control.py*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-64: *loop_control.py*'
- en: The loop `while True` is inherently infinite; `True` is always `True`. That’s
    the behavior I actually want here, since I want to keep iterating until the user
    enters the string `"exit"`, at which point, I manually end the loop with `break`.
    (By the way, if you’ve been waiting for a `do-while` loop, this is effectively
    the way to recreate that behavior.)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True` 循环是固有的无限循环；`True` 永远为 `True`。这正是我在这里需要的行为，因为我希望继续迭代，直到用户输入字符串
    `"exit"`，此时我会使用 `break` 手动结束循环。（顺便说一句，如果你一直在等待 `do-while` 循环，这实际上是重新创建该行为的方法。）'
- en: The command `"sing"` has a different behavior, after which I’d want to immediately
    go to the top and prompt the user for another command, skipping the last print
    statement. The `continue` keyword does exactly that, immediately abandoning the
    current iteration and jumping back to the top of the loop.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `"sing"` 有不同的行为，在这种情况下，我希望立刻回到循环顶部并提示用户输入另一个命令，跳过最后的打印语句。`continue` 关键字正是做到了这一点，立即放弃当前迭代并跳回循环顶部。
- en: for Loop
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环
- en: Python’s `for` loop is a little different from loops in many languages. It’s
    generally used for iterating over a range, list, or other collection.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `for` 循环与许多语言中的循环略有不同。它通常用于遍历一个范围、列表或其他集合。
- en: '[PRE77]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Listing 3-65: *for_loop.py*'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-65: *for_loop.py*'
- en: I start the loop header with the `for` keyword. Technically, this kind of loop
    is a `for`-`in` (or “`for`-`each`”) loop, meaning the loop iterates once for each
    item in the given range, list, or other collection. This means the loop needs
    something to iterate over—in this case, a special object called `range()`—which
    iterates over a range of values, returning each one in turn. I’ve specified that
    I want the range to start with the value `1` and end before `11`. The local variable
    `i` will refer to the current item for each iteration. Finally, the `in` keyword
    precedes the thing I’m iterating over—that is, before `range()` in this example.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 `for` 关键字开始定义循环头。严格来说，这种循环是 `for`-`in`（或者说是“`for`-`each`”）循环，意味着该循环会对给定范围、列表或其他集合中的每个项目进行一次迭代。这也意味着循环需要有一个可迭代的对象——在此例中是一个特殊的对象
    `range()`——它会遍历一系列值，并依次返回每个值。我指定了范围从值 `1` 开始，到 `11` 之前结束。局部变量 `i` 将在每次迭代时引用当前的项。最后，`in`
    关键字出现在我要迭代的对象之前——在这个例子中就是 `range()`。
- en: As long as there are items to iterate over, the code belonging to the loop will
    be executed—in this case, printing out the value of the current item. The loop
    stops when the last item is iterated over.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有项可以迭代，循环中属于该部分的代码就会被执行——在本例中，就是打印当前项的值。循环在最后一项被迭代完时停止。
- en: Running this code would print the numbers 1 through 10.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码将打印出数字 1 到 10。
- en: This only scratches the surface of loops. See Chapter 9 for more.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是循环的冰山一角。更多内容请参见第 9 章。
- en: Structural Pattern Matching
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构模式匹配
- en: For many years, developers coming to Python from languages like C, C++, Java,
    or Javascript would ask if there was a Python equivalent to the `switch`/`case`
    statement (or `match`/`case` in Scala, `case`/`when` in Ruby, and so on). They’d
    always be disappointed to hear a resounding “No!” Python only had conditional
    statements.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，从 C、C++、Java 或 Javascript 等语言转到 Python 的开发者常常会问，Python 是否有类似于 `switch`/`case`
    语句的功能（在 Scala 中是 `match`/`case`，在 Ruby 中是 `case`/`when`，等等）。他们总是会失望地得到一个响亮的“没有！”答案。Python
    只有条件语句。
- en: At long last, Python 3.10 gained *structural pattern matching* via PEP 634\.
    This provides conditional logic that is at least syntactically similar to `switch`
    statements of other languages. In short, you test a single *subject*, such as
    a variable, against one or more *patterns*. If the subject matches the pattern,
    the associated suite of code runs.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Python 3.10 通过 PEP 634 引入了 *结构模式匹配*。这提供了与其他语言中的 `switch` 语句至少在语法上相似的条件逻辑。简而言之，你可以将一个单一的
    *主题*（例如变量）与一个或多个 *模式* 进行测试。如果主题与模式匹配，相关的代码块就会运行。
- en: Literal Patterns and Wildcards
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字面模式和通配符
- en: 'In the most basic use case, you can check a variable against different possible
    values. These are called *literal patterns*. For example, perhaps I want to display
    different messages, depending on a user’s `input` `lunch` `order`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的用例中，你可以将变量与不同的可能值进行比较。这些称为*字面模式*。例如，也许我想根据用户的`input` `lunch` `order` 显示不同的消息：
- en: '[PRE78]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Listing 3-66: *pattern_match.py:1a*'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-66：*pattern_match.py:1a*
- en: The value of `lunch_order` is compared to each case until it matches one. Once
    a match is found, the case’s suite is run, and the match statement is finished;
    the value won’t be checked against additional patterns once it matches one. So,
    if the user inputs `"pizza"`, the `"Pizza` `time!"` message is displayed. Similarly,
    if they input `"taco"`, the message `"Taco,` `taco,` `TACO,` `tacotacotaco!"`
    is displayed instead.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`lunch_order`的值会与每个情况进行比较，直到匹配一个。一旦找到匹配，匹配的代码块就会执行，匹配语句就结束了；一旦匹配了某个模式，值将不会再与其他模式进行检查。因此，如果用户输入`"pizza"`，则会显示消息`"Pizza`
    `time!"`。同样，如果他们输入`"taco"`，则会显示消息`"Taco,` `taco,` `TACO,` `tacotacotaco!"`。'
- en: The underscore (`_`) in the last case is the *wildcard*, which will match any
    value. This serves as a fallback case, and it must come last, as it will match
    anything.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况中的下划线（`_`）是*通配符*，它可以匹配任何值。它作为一个后备情况，必须放在最后，因为它会匹配任何内容。
- en: Or Patterns
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 或者模式
- en: 'A single case can cover multiple possible values. One way to do this is with
    an *or pattern*, where possible literal values are separated by the bar character:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 单个情况可以覆盖多个可能的值。一种方法是使用*或模式*，其中可能的字面值由竖线字符分隔：
- en: '[PRE79]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Listing 3-67: *pattern_match.py:1b*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-67：*pattern_match.py:1b*
- en: This pattern will match if the user enters either `"salad"` or `"soup"` at the
    prompt.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在提示符处输入`"salad"`或`"soup"`，这个模式将匹配。
- en: Capture Patterns
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获模式
- en: 'One particularly helpful feature of structural pattern matching is the ability
    to capture part or all of the subject. For example, it isn’t very helpful in our
    example that the fallback case only says `"Yummy."`. Instead, I’d like to have
    a default message announcing the user’s selection. To do that, I write a *capture
    pattern* like this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式匹配的一个特别有用的功能是能够捕获部分或全部主体。例如，在我们的例子中，后备情况仅显示`"Yummy."`并没有多大帮助。相反，我希望有一个默认的消息来宣布用户的选择。为此，我写了一个*捕获模式*，像这样：
- en: '[PRE80]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Listing 3-68: *pattern_match.py:1c*'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-68：*pattern_match.py:1c*
- en: This pattern acts like a wildcard, except the value of `lunch_order` is captured
    as `order`. Now, no matter what the user enters, if it doesn’t match any of the
    previous patterns, the value will be captured and displayed in the message here.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式就像一个通配符，唯一不同的是`lunch_order`的值会被捕获为`order`。现在，无论用户输入什么，如果它不匹配任何先前的模式，值将被捕获并在这里的消息中显示出来。
- en: 'Capture patterns don’t just have to capture the entire value. For example,
    I can write a pattern that matches a tuple or list (a *sequence*) and then captures
    only part of that sequence:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获模式不仅仅是捕获整个值。例如，我可以编写一个匹配元组或列表（*序列*）的模式，然后仅捕获序列的一部分：
- en: '[PRE81]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Listing 3-69: *pattern_match.py:1d*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-69：*pattern_match.py:1d*
- en: In this version, if the lunch order has a space, I split the string into two
    parts, which are stored in a list. Then, if the second item in the sequence has
    the value `"ice cream"`, the first part is captured as `flavor`. Thus, the code
    can account for Bojan if he decides to break down and have strawberry ice cream
    for lunch. (And I’m not stopping him!)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，如果午餐订单中有空格，我将字符串拆分为两部分，这些部分存储在一个列表中。然后，如果序列中的第二个项目的值是`"ice cream"`，则第一部分将被捕获为`flavor`。因此，代码可以处理Bojan如果决定午餐吃草莓冰激凌的情况。（而且我不会阻止他！）
- en: 'The capture pattern feature has one surprising downside: all *unqualified*
    names in patterns—that is, any bare variable names with no dots—will be used to
    capture. This means that if you want to use the value assigned to some variable,
    it must be *qualified*, meaning you must access it within some class or module
    with the dot operator:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获模式的一个意外缺点是：所有*无资格*的名称在模式中——即任何没有点号的裸变量名——将被用于捕获。这意味着，如果你想使用某个变量赋值的值，它必须是*有资格的*，也就是说，你必须在某个类或模块内使用点操作符来访问它：
- en: '[PRE82]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 3-70: *pattern_match.py:1e*'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-70：*pattern_match.py:1e*
- en: Guard Statements
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 守卫语句
- en: One last trick I’ll demonstrate with pattern matching is the *guard statement*,
    an additional conditional statement that must be satisfied for a pattern to match.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示的最后一个技巧是模式匹配中的*守卫语句*，这是一个额外的条件语句，只有满足条件时，模式才会匹配。
- en: For example, in the current version of my lunch order example, using the logic
    to split the order by spaces means the code doesn’t behave very nicely with other
    foods with spaces in them. Also, if I enter `"rocky road ice cream"`, it won’t
    match the current ice cream pattern.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我当前的午餐订单示例中，使用逻辑来通过空格分割订单意味着代码在处理包含空格的其他食物时表现得不太好。而且，如果我输入 `"rocky road
    ice cream"`，它将无法匹配当前的冰激凌模式。
- en: Instead of splitting my string by spaces, I can write a pattern with a guard
    statement that looks for the words *ice cream* in the lunch order.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以写一个带有保护语句的模式，查找午餐订单中的*冰激凌*这个词，而不是通过空格来分割我的字符串。
- en: '[PRE83]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Listing 3-71: *pattern_match_object.py:1f*'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3-71: *pattern_match_object.py:1f*'
- en: The pattern here captures the value as `ice_cream`, but only if the guard statement
    `if 'ice cream' in ice_cream` is satisfied. In that case, I use `.replace()` to
    remove the words *ice cream* from the captured value, leaving me with only the
    name of the flavor. I also use `.strip()` to remove any leading or trailing whitespace
    from the new string. Finally, I print out my message.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的模式将值捕获为`ice_cream`，但仅在满足保护语句`if 'ice cream' in ice_cream`时才会如此。在这种情况下，我使用`.replace()`来从捕获的值中删除*冰激凌*这两个字，只保留口味名称。我还使用`.strip()`来去除新字符串的前导和尾随空白。最后，我打印出我的信息。
- en: More About Structural Pattern Matching
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于结构模式匹配的更多内容
- en: There are quite a few other tricks and techniques that work with structural
    pattern matching. They work with objects (see Chapter 7), with dictionaries via
    mapping patterns (see Chapter 9), and even by support nesting patterns within
    other patterns.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他技巧和技术可以与结构模式匹配一起使用。它们适用于对象（参见第7章），通过映射模式适用于字典（参见第9章），甚至可以支持在其他模式中嵌套模式。
- en: As with many Python techniques, pattern matching feels like “magic,” and there’s
    a strong temptation to use it everywhere possible. Resist this urge! Structural
    pattern matching is very useful for checking a single subject against multiple
    possible patterns, but as you can even see from the “ice cream” situation in the
    lunch order example, it quickly reaches its limits as the possible values of the
    subject get more elaborate. As a rule, if you’re unsure whether you need structural
    pattern matching in a particular situation, stick with conditional statements.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多 Python 技巧一样，模式匹配感觉像是“魔法”，并且有强烈的诱惑想要在所有可能的地方使用它。抵制这种冲动！结构模式匹配非常适合检查一个主题与多个可能模式的匹配，但正如你在午餐订单示例中的“冰激凌”情况所看到的那样，当主题的可能值变得更加复杂时，它很快就达到了它的局限性。作为一个规则，如果你不确定是否需要在某个特定情境中使用结构模式匹配，那就坚持使用条件语句。
- en: 'To learn even more, read PEP 636, which serves as the official tutorial for
    this topic and demonstrates all of the functionality available with this language
    feature: [https://peps.python.org/pep-0636/](https://peps.python.org/pep-0636/).'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多内容，请阅读PEP 636，它作为该主题的官方教程，演示了此语言特性提供的所有功能：[https://peps.python.org/pep-0636/](https://peps.python.org/pep-0636/)。
- en: Wrapping Up
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You should now have a feeling for Python’s syntax and a basic familiarity with
    its key structures. If you were to stop here, you could probably write Python
    code that at least works. In fact, many developers new to the language do indeed
    work with about this much information, implicitly bringing the habits and practices
    of whatever language they know best.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对 Python 的语法有了一定的感觉，并且对其关键结构有了基本的了解。如果你在此停止，你可能已经能够编写至少能正常工作的 Python 代码。事实上，许多新接触该语言的开发者，确实是基于这些信息在工作，隐性地带入了他们最熟悉的语言的习惯和实践。
- en: There is a profound difference between valid code and idiomatic, Pythonic code.
    Writing the latter is the focus of this book.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 有效代码与符合 Python 习惯的代码之间存在着深刻的区别。编写后者是本书的重点。
