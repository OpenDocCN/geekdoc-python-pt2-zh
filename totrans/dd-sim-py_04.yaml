- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Syntax Crash Course
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Python is an unusual mix of common and unique concepts. Before diving into the
    intricacies of the language, you must first grasp its essential syntax.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn most of the essential syntactic structures you’ll
    encounter in Python, and you’ll also become familiar with the basic mathematical
    and logical features of the language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Python developers will point newcomers to the official Python tutorial,
    which is an excellent introduction to the language’s structure. While I’ll cover
    all of these concepts in this book in depth, the tutorial is still a good resource
    worth reading: [https://docs.python.org/3/tutorial/](https://docs.python.org/3/tutorial/).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Hello, World!
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It won’t feel like a proper introduction to the language without the classic
    Hello World program. In Python, it’s written like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: *hello_world.py*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: There’s nothing novel here. You call the `print()` function to write text to
    the console, and you pass data in a string, wrapped in quotes as an argument.
    You can pass whatever sort of data you like, and it will be output on the console.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'I can also get input from the console with the `input()` function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: *hello_input.py*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: I use the `input()` function and pass my prompt as a string ❶. When I run that
    code, Python greets me using the name I entered on the console.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Statements and Expression
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each line of code in Python that ends with a line break is a *statement*, sometimes
    more specifically known as a *simple statement*. Unlike in many C-inspired languages,
    you don’t need to end a line in Python with a special character.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: A section of code that evaluates to a single value is called an *expression*.
    In Python, you can put expressions nearly anywhere a value is expected. The expression
    is evaluated down to a value, and that value is used in that position in the statement.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in one statement, I can create a variable, and in another statement,
    I can print its contents to the console:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: *hello_statements.py:1a*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: I assign the expression `"Hello, world!"` to `message`, and then I pass the
    expression `message` to `print()`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever need to place multiple statements on the same line, you can separate
    them with a semicolon (`;`). To demonstrate this, here are the same two statements
    as earlier, but packed onto one line, with a semicolon to separate them:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-4: *hello_statements.py:1b*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: While this is valid code, using this technique is somewhat discouraged. The
    Python philosophy places a high value on readability, and the placement of multiple
    statements on the same line often detracts from that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Stick to placing one statement per line, unless you have a specific reason to
    do otherwise.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The Importance of Whitespace
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re looking at a sample of Python source code, the first thing that
    will probably jump out at you is the use of indentation for nesting. A *compound
    statement* is made up of one or more *clauses*, each of which consists of a line
    of code called a *header* and a block of code called a *suite*, which is associated
    with the header.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看 Python 源代码示例时，首先可能会注意到的是缩进的使用来表示嵌套。一个 *复合语句* 由一个或多个 *子句* 组成，每个子句包含一行代码，称为
    *头部*，以及与头部相关联的一段代码块，称为 *语句块*。
- en: 'For example, this program prints different messages, depending on whether a
    `name` is specified:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个程序根据是否指定了 `name` 来打印不同的消息：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-5: *hello_conditional.py*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-5：*hello_conditional.py*
- en: I set up a conditional statement with an `if` header ❶, after which I have a
    suite made up of two indented lines of code, which “belongs” to the header. These
    lines of code are executed only if the conditional expression in the header is
    evaluated to `True`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了一个条件语句，首先是一个 `if` 头部 ❶，然后是由两行缩进代码组成的语句块，这些代码“属于”这个头部。只有在条件表达式的结果为 `True`
    时，这些代码才会执行。
- en: The unindented line ❷ is not part of the suite that belongs to the conditional
    statement, and it will be run every time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那行未缩进的代码 ❷ 不是条件语句的语句块的一部分，它将每次都执行。
- en: 'As I nest deeper, I need to add more indentation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我进行更深的嵌套时，我需要添加更多的缩进：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-6: *weather_nested_conditional.py*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-6：*weather_nested_conditional.py*
- en: The first `print` statement is indented twice, which is how Python knows that
    it belongs to both preceding conditional statements.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `print` 语句缩进了两次，这样 Python 就知道它属于前两个条件语句。
- en: Given the importance of whitespace, the “tabs versus spaces” war is fairly common
    in Python world. You’ll remember from Chapter 2 that the PEP 8 style guide stresses
    using either four spaces or a single tab per indentation level. ***Consistency
    is key!*** Python really doesn’t care whether you use tabs, two spaces, four spaces,
    or even seven spaces (although that’s probably a step too far) for each level
    of indentation. The point is to be consistent within any and every given block
    of code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到空白的重要性，关于“Tab 键和空格”的争论在 Python 社区中非常常见。你可能还记得第二章中提到的 PEP 8 风格指南强调每个缩进级别使用四个空格或一个
    Tab 键。***一致性是关键！*** Python 并不关心你使用的是 Tab 键、两个空格、四个空格，还是甚至七个空格（尽管那可能有点过头），关键是要在每一个代码块中保持一致性。
- en: You should use only one indentation style throughout your project, even if your
    situation provides a technical loophole. Don’t mix tabs and spaces. Chances are
    your IDE has tools to help you with this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在整个项目中只使用一种缩进风格，即使在你的情境下有技术漏洞。不要混用 Tab 键和空格。你的 IDE 很可能提供了帮助你处理这个问题的工具。
- en: For simplicity’s sake, I’ll use the PEP 8 convention of four spaces throughout
    my code examples. While I’d recommend you follow this same convention—you can
    even configure your editor to insert four spaces each time you hit the Tab key—if
    you have a strong preference for tabs, you’re welcome to use those instead. It
    really doesn’t matter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，我将在我的代码示例中使用 PEP 8 规范的四个空格缩进。虽然我建议你遵循相同的规范——你甚至可以配置编辑器，在每次按下 Tab 键时自动插入四个空格——如果你偏好使用
    Tab 键，当然也可以选择使用它们。这其实并不重要。
- en: Doing Nothing
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么也不做
- en: On occasion, you will need to insert a statement that has absolutely no effect.
    This is particularly useful when you need to put a syntactically valid placeholder
    where a suite of code will exist later. For this purpose, Python provides the
    `pass` keyword.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要插入一个完全没有任何效果的语句。当你需要在将来某处插入一段代码时，这个语句非常有用，尤其是在语法上有效的占位符位置。为了这个目的，Python
    提供了 `pass` 关键字。
- en: 'For example, I can employ the `pass` keyword as a placeholder in my `if raining`
    conditional, until I’m able to write the final code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我编写的 `if raining` 条件语句中，我可以使用 `pass` 关键字作为占位符，直到我能够编写最终代码：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-7: *raining_pass.py*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-7：*raining_pass.py*
- en: Just remember, `pass` does absolutely nothing. That’s the only reason it exists.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`pass` 完全什么也不做。这就是它存在的唯一原因。
- en: Comments and Docstrings
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释和文档字符串
- en: To write comments in Python, precede the line with a hash (`#`). Everything
    between the hash and the end of the line is a comment and will be ignored by the
    interpreter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中编写注释时，在行首加上井号（`#`）。井号与行尾之间的所有内容都是注释，将会被解释器忽略。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-8: *comments.py*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-8：*comments.py*
- en: If you ran this program, the `print` statements would both execute. The rest
    of the second `print` statement, from the hash onward, is an inline comment ❶
    and would be ignored by the interpreter. All the other lines are only comments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Officially, there is no syntax for “multiline” comments; you just comment each
    line. There is one special exception: the *docstring*. It looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-9: *docstrings.py:1*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: I define a function that would (theoretically) make tea, and I place the description
    of the function inside a docstring.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings exist to provide documentation for functions, classes, and modules,
    especially public ones. They conventionally begin and end with three quotation
    marks (`"""`), allowing the string to automatically span multiple lines. You would
    typically place docstrings at the top, inside of whatever they’re defining, such
    as in the function above.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important distinctions between comments and docstrings:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings are string literals, and they are seen by the interpreter; comments
    are ignored.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docstrings are used in automatic documentation generation.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docstrings are generally only docstrings when they appear at the top of the
    module, function, class, or method they define. Comments can live anywhere.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is perfectly possible to use a triple-quoted string literal to write a sort
    of “multiline comment,” but it’s not recommended, since a string literal can easily
    get left in a place where Python will try to use it as a value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: In short, use docstrings as intended, and stick with comments for everything
    else. Many Python IDEs have hotkeys for toggling comments on a selection, which
    can save you a lot of time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'I can access these docstrings later in my code. For instance, given the previous
    example, I can do this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-10: *docstrings.py:2*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings have their own style conventions, which are outlined in depth in
    PEP 257.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Variables
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have already noticed that Python doesn’t have a distinct keyword for
    declaring a new variable (technically called a *name* in this language; see Chapter
    5). Here, I define two variables—`name` and `points`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-11: *variables.py*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Python is *dynamically typed*, meaning the data type of a value is determined
    when it is evaluated. This contrasts with statically typed languages, in which
    you declare the data type initially. (C++ and Java are both statically typed.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: With Python, you can assign a value to a name anytime, by using the assignment
    operator (`=`). It infers the data type. If the name is a new variable, Python
    will create it; if the name already exists, Python will change the value. It’s
    a pretty straightforward system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, there are only two rules to follow with Python variables:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Define a variable before you access it; otherwise, you’ll get an error.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t change what kind of data you’re storing in the variable, even when replacing
    a value.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python is considered a *strongly typed language*, meaning you usually can’t
    magically combine data of different types. For example, it won’t allow you to
    add an integer and a string together. On the other hand, *weakly typed* languages
    let you do practically anything with different data types, and they try to figure
    out how to do what you asked for. (JavaScript is weakly typed.) There’s an entire
    spectrum between those last two terms and plenty of debate about what behaviors
    qualify under which name. While Python is decidedly in the “strongly typed” camp,
    it still has weaker typing than some languages.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Python is, however, *weakly bound*, so it is possible to assign a value of a
    different type to an existing variable. While this is technically permissible,
    it is strongly discouraged, as it can produce confusing code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: What About Constants?
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python doesn’t have any formally defined constants. In keeping with PEP 8, you
    would indicate a variable is intended to be treated as a constant by using all-caps
    names with underscores. This naming convention is sometimes humorously referred
    to as *screaming snake case* for the all-caps (screaming) and the underscores
    (snakes). For example, the name `INTEREST_RATE` indicates that you don’t want
    the variable redefined or changed in any way. While the interpreter itself won’t
    prevent the variable from being modified, your linter will usually complain if
    you do.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Mathematics
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has all the math functionality you would expect from a good programming
    language; its excellent support for both simple and complicated mathematics is
    one of the reasons Python is popular for scientific programming, data processing,
    and statistical analysis.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Meet the Number Types
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before I get into the operations, you should be aware of the three data types
    used for storing numbers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '*Integers* (`int`) store whole numbers. In Python, integers are always signed
    and effectively have no maximum value. Integers use decimal base (base-10) by
    default, but they can also be specified in binary (`0b101010`), octal (`0o52`),
    or hexadecimal (`0x2A`).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '*Floating-point numbers* (`float`) store numbers with a decimal part (for example,
    `3.141592`). You can also use scientific notation (for example, `2.49e4`). Internally,
    values are stored as double-precision, IEEE 754 floating-point numbers, which
    are subject to the limits inherent in that format. (For more insight into the
    limits and gotchas of floating-point arithmetic, read the article “What Every
    Computer Scientist Should Know About Floating-Point Arithmetic” by David Goldberg:
    [https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.xhtml](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.xhtml)*.*)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify an invalid number with `float("nan")`, a number larger
    than the largest possible value with `float("inf")`, or a number smaller than
    the smallest possible value with `float("-inf")`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I wrapped the special values in quotes. This is necessary if you
    want to use these values without *importing* the `math` module (see Chapter 4
    for more about importing). If you have imported the `math` module (see “The `math`
    Module” subsection below), you can use the constants `nan`, `inf`, and so forth,
    instead of the quoted versions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '*Complex numbers* (`complex`) can store imaginary numbers by appending `j`
    to the value, as in `42j`. You can combine a real part with the imaginary part,
    using addition: `24+42j`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In case you missed it in math class, an imaginary number has the square root
    of negative one as one of its factors, even though this value is utterly impossible;
    there is no value that you can multiply by itself to get negative one! Yet imaginary
    numbers definitely show up in real-world math. Spooky, no?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '*Decimal* and *Fraction* are two of the additional object types for storing
    numeric data. `Decimal` stores fixed-point decimal numbers, while `Fraction` does
    the same for fractions. To use either, you’ll need to import them first.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief example that uses both types:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 3-12: *fractions_and_decimals.py*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The `float()` function turns `Fraction` and `Decimal` objects into floats.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python has the usual operators, with a couple of additions that may not be familiar
    to some developers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a bit of code that will demonstrate the math operators. I’ll wrap each
    equation inside a `print()` statement, so you can run the code and see the results:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 3-13: *math_operators.py*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The *unary* (one-operand) negative operator flips the sign of whatever follows
    it. The `abs()` function is technically considered a unary operator as well. The
    rest of the operators here are *binary*, meaning they accept two operands.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 3-14: *augmented_assignment_operators.py*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: If you need both floor division (`//`) and modulo (`%`) on the same operands,
    Python provides the `divmod()` function to efficiently perform the calculation,
    returning the two results in a tuple. Thus, `c = divmod(a, b)` is the same as
    `c = (a // b, a % b)`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Python also has `bitwise` operators, which I’ll list below for those readers
    already familiar with bitwise arithmetic. I won’t introduce these concepts until
    Chapter 12:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 3-15: *bitwise_operators.py*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The math Module
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python provides plenty of additional functions in the `math` module, along
    with the five most common math constants: `pi`, `tau`, `e`, `inf`, and `nan`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 3-16: *math_constants.py*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: All five constants are floats and can be directly used as such ❶. The official
    documentation provides a complete list of everything available in the `math` module.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'You might remember a little trick from high school trigonometry, where you
    could calculate the height of something using your distance to it and the angle
    from your vantage point to the top of the object. Here’s a way to calculate that
    with Python, using the `math` module:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 3-17: *surveying_height.py*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'I use two functions from the `math` module: `math.radians()` ❶ and `math.tan()`
    ❷. The `round()` function ❸ is built into the language itself.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了 `math` 模块中的两个函数：`math.radians()` ❶ 和 `math.tan()` ❷。`round()` 函数 ❸ 是语言内置的。
- en: Logic
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑
- en: Python’s clean, obvious syntax for logical expressions is one of the attractive
    elements of the language. Here, I’ll cover conditional statements and expressions,
    as well as the comparison and logic operators.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python 干净、直观的逻辑表达式语法是该语言的一大亮点。在这里，我将介绍条件语句和表达式，以及比较和逻辑操作符。
- en: Conditionals
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Conditionals are compound statements composed of `if`, `elif`, and `else` clauses,
    each made up of a header and a suite. As with most languages, you can have as
    many `elif` conditionals in Python as you want, sandwiched between `if` and (optionally)
    `else`. Here’s a really simple example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句是由 `if`、`elif` 和 `else` 语句组成的复合语句，每个语句包括一个头部和一个代码块。与大多数语言一样，你可以在 Python
    中有任意数量的 `elif` 条件语句，插在 `if` 和（可选的）`else` 之间。这里是一个非常简单的示例：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 3-18: *conditional_greet.py*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-18: *conditional_greet.py*'
- en: This conditional statement is made up of three clauses. The `if` clause evaluates
    first, and if the expression in its header evaluates to `True`, its suite runs,
    printing `"Hello!"` Otherwise, it evaluates the expression in the `elif` header
    next. If none of the expressions evaluate to `True`, then the `else` clause runs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条件语句由三个部分组成。`if` 部分首先进行评估，如果其头部表达式的结果为 `True`，则执行其代码块，打印 `"Hello!"`；否则，接下来评估
    `elif` 部分的表达式。如果没有任何表达式的结果为 `True`，则执行 `else` 部分。
- en: You’ll notice you don’t need to wrap the conditional expressions, such as `command
    == "greet"`, in parentheses, although you may do so anyway if it helps clarify
    your code. You’ll see an example of this shortly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，不需要将条件表达式（例如 `command == "greet"`）用括号括起来，尽管如果有助于明确代码，你可以这样做。稍后你将看到一个示例。
- en: If you’re looking for something similar to the `switch` statement from your
    favorite programming language, see the “Structural Pattern Matching” section toward
    the end of this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找类似于你最喜欢的编程语言中的`switch`语句，请查看本章末尾的“结构化模式匹配”部分。
- en: Comparison Operators
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较操作符
- en: 'Python has all the comparison operators you’d expect. Take a look at these
    in the context of comparing two integers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了你期望的所有比较操作符。看看这些操作符如何在比较两个整数的情况下工作：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 3-19: *comparison_operators.py*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-19: *comparison_operators.py*'
- en: As you can see, Python has operators for `equals`, `not equals`, `less than`,
    `less than or equals`, `greater than`, and `greater than or equals`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python 提供了`equals`、`not equals`、`less than`、`less than or equals`、`greater
    than`和`greater than or equals`的操作符。
- en: No surprises there, but what about boolean comparisons? This is where Python
    takes a different line.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么惊讶的，但布尔值比较怎么样呢？这就是 Python 与众不同的地方。
- en: Boolean, None, and Identity Operators
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔值、None 和身份操作符
- en: Python offers the values `True` and `False`, which are the two values for boolean
    (type `bool`) variables. It also has a dedicated `None` value (type `NoneType`),
    which serves in the capacity of a “null” value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了 `True` 和 `False` 两个布尔值（类型 `bool`）。它还有一个专用的 `None` 值（类型 `NoneType`），用作“空”值。
- en: You check for these values in a very different way than with other data types.
    Instead of the comparison operators, use the special *identity operator* `is`.
    (I’ll also use the logical operator `not` below, which I’ll discuss separately
    in a bit.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你会以与其他数据类型完全不同的方式检查这些值。与比较操作符不同，使用特殊的*身份操作符* `is`。 （下面我还会使用逻辑操作符 `not`，稍后我会单独讨论。）
- en: 'Here’s an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 3-20: *boolean_identity_operators.py*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 3-20: *boolean_identity_operators.py*'
- en: Aside from being a little high in sodium, that code shows the many ways of testing
    boolean values and checking for `None`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有点高盐之外，代码展示了测试布尔值和检查 `None` 的多种方法。
- en: You can test if a variable is set to `True`, `False`, or `None` by comparing
    with the `is` operator. You can also invert the logic with `is not`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过与 `is` 操作符进行比较来测试变量是否设置为 `True`、`False` 或 `None`。你还可以使用 `is not` 来反转逻辑。
- en: Most commonly, when testing against `True`, you can use the variable as the
    entire condition ❶. For `False`, invert that condition test with `not` ❷.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况是，当测试 `True` 时，你可以将变量作为整个条件 ❶。对于 `False`，可以使用 `not` 来反转该条件测试 ❷。
- en: Take particular note of the last condition, which illustrates an important gotcha
    with the `is` operator ❸. It actually compares the identity of the variables,
    rather than the value. This is particularly troublesome, as the logic looks sound
    but is a bug waiting for a place to happen. That probably doesn’t mean much to
    you yet, but rest assured, I’ll cover this concept in depth in Chapter 5.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, you can take this rule for granted: use `is` *only* for comparing
    directly to `None`, and use regular comparison operators for everything else.
    In practice, we usually say `if spam` or `if not spam`, instead of directly comparing
    to `True` or `False`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Truthiness
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most expressions and values in Python can be evaluated to a `True` or `False`
    value. This is typically done by using the value as an expression by itself, although
    you can also pass it to the `bool()` function to convert it explicitly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 3-21: *truthiness.py*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: When an expression will evaluate to `True`, it is considered “truthy.” When
    it will evaluate to `False`, it is “falsey.” The `None` constant, values representing
    zero, and empty collections are all considered “falsey,” while most other values
    are “truthy.”
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’re coming from a language where logical operators are a little more
    difficult to remember, you’ll find Python refreshing: it simply uses the keywords
    `and`, `or`, and `not`!'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 3-22: *logical_operators.py*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: With the `and` condition, both expressions must evaluate to `True`. With the
    `or` condition, one or the other (or both) must evaluate to `True`. The third
    condition adds `not` to the picture, requiring that `eggs` be `False` and `spam`
    be `True`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: I could have omitted the parentheses on the third condition, as `not` takes
    precedence and so is evaluated before `and`. However, the parentheses help to
    clarify my intended logic.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, you can use the `not` keyword to invert any conditional expression,
    such as in the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 3-23: *not_operators.py*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Both comparisons do the same thing; the issue becomes readability. In this
    case, the expression using `not` is less readable because your eyes might skip
    over the `not` keyword, so you might not catch what’s happening in the code. The
    condition employing the `!=` operator is preferred for readability. While you
    might find situations where `not` is the best way to invert your conditional logic,
    remember The Zen of Python: ***Readability counts!***'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The Walrus Operator
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python 3.8 introduced *assignment expressions*, which allow you to assign a
    value to a variable and use that variable in another expression at the same time.
    This is possible with the so-called *walrus operator* (`:=`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 3-24: *walrus.py*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: With the walrus operator, Python first evaluates the expression on the left
    (`7+5`) and then assigns it to the variable `eggs`. The assignment expression
    is enclosed in parentheses for readability, although I technically could have
    omitted them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The assignment expression is then evaluated to a single value, namely the value
    of `eggs`, which is used in the comparison. Since the value is `12`, the condition
    evaluates to `True`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: What’s interesting about the assignment expression is that `eggs` is now a valid
    variable in the outer scope, so I can print its value outside of the conditional.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: This feature is potentially useful in many scenarios, not only in conditional
    expressions, as above.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment expressions and the walrus operator were defined in PEP 572, which
    also contains an in-depth discussion about when and where this feature should
    be used. Two particularly useful style rules are put forth by this PEP:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: If either assignment statements or assignment expressions can be used, then
    prefer statements; they are clear declarations of intent.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If using assignment expressions would lead to ambiguity about execution order,
    then restructure to use statements instead.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of the writing of this book, Python assignment expressions are still in their
    infancy. A lot of debate and controversy still surrounds them. In any case, resist
    the temptation to abuse the walrus operator to cram as much logic onto one line
    as possible. You should always aim for readability and clarity in your code, above
    all else.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Ellipsis
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One seldom-used piece of syntax is the *Ellipsis*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is sometimes used by various libraries and modules, but seldom consistently.
    For example, it’s used with multidimensional arrays in the NumPy third-party library
    and when working with type hints from the built-in `typing` module. When you see
    it come up, consult the documentation for whatever module you’re using.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few things to know about strings as you move forward. Here, I’ll
    cover the three kinds of strings: string literals, raw strings, and formatted
    strings.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: String Literals
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are multiple ways of defining a *string literal*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 3-25: *string_literals.py*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: You can wrap a literal in double quotes (`"`), single quotes (`'`), or triple
    quotes (`"""`) of either type. You may remember from earlier that there’s something
    special about triple quotes, but I’ll come back to that in a moment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 8 addresses the use of single and double quotes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In Python, single-quoted strings and double-quoted strings are the same. This
    PEP does not make a recommendation for this. Pick a rule and stick to it. When
    a string contains single or double quote characters, however, use the other one
    to avoid backslashes in the string. It improves readability.
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The advice about placing quotes inside a string comes in handy when dealing
    with something like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 3-26: *escaping_quotes.py:1a*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: This version escapes the double quotes I want to include in the string literal
    itself. The backslash (`\`) before the quotes means I want the string to contain
    that *literal character*, not to have Python treat the double quote as the boundary
    of a string. The string literal must always be wrapped in matching quotes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to avoid backslashes in this scenario, however:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 3-27: *escaping_quotes.py:1b*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: This second version wraps the literal in single quotes, so the double quotes
    will be automatically interpreted as part of the string literal. That approach
    is much more readable. By wrapping the string in single quotes, Python will assume
    the double quotes are characters in the string.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The only time you’d really need to escape either single or double quotes with
    backslashes would be if you had both types of quotes in the string at once:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 3-28: *escaping_quotes.py:2a*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Personally, in cases like that, I’d prefer to use (and escape) the double quotes,
    because they don’t evade my attention like an apostrophe would tend to do.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have the option to use triple quotes:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 3-29: *escaping_quotes.py:2b*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that triple quotes define *multiline string literals*. In other words,
    I can use them to do this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 3-30: *multiline_string.py*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Everything, including newlines and leading whitespace, is literal in triple
    quotes. If I `print("parrot")`, it will display exactly like this in the terminal.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The only exception occurs when you use a backslash (`\`) to escape a particular
    character, like I did with that newline at the beginning ❶. It is conventional
    to escape the first newline after the opening triple quotes, just to make the
    code look cleaner.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `textwrap` module has some functions for working with multiline
    strings, including tools that allow you remove leading indentation (`textwrap.dedent`).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can *concatenate* (combine) string literals, simply by writing
    them next to one another, without any operators between them. For example, `spam
    = "Hello " "world" "!"` is valid, resulting in the string `Hello world!.` If you
    wrap the assignment expression in parentheses, you can even span multiple lines.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Raw Strings
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Raw strings* constitute another form of string literal, wherein the backslash
    (`\`) is always treated as a literal character. They’re preceded with an `r`,
    such as in this example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 3-31: *raw_string.py*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The backslash is treated like a literal character, which means that nothing
    can be escaped inside of a raw string. The output of that line of code looks like
    this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This has implications for what type of quotes you use, so beware.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare these two lines and their outputs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 3-32: *raw_or_not.py*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'The first string is ordinary, so `\n` is treated as a normal escape sequence:
    specifically, the newline character. That line break appears in the output, like
    this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The second string is a raw string, so the backslash (`\`) is treated as a literal
    character in its own right. The output would be as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is particularly useful for regular expression patterns, where you’re likely
    to have plenty of backslashes that you want as part of the *pattern*, not interpreted
    by Python before it gets there. ***Always use raw strings for regular expression
    patterns.***
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Formatted Strings
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A third kind of string literal is a *formatted string* or *f-string*, which
    is new as of Python 3.6 (defined in PEP 498). It allows you to insert the values
    of variables into a string in a very elegant manner.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'If I wanted to include the value of a variable in a string without an f-string,
    the code might look like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 3-33: *cheese_shop.py:1a*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The `str()` function converts the value passed to it into a string, and then
    the three strings are *concatenated*, or combined, into one, using the `+` operator.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Using f-strings, this code becomes more elegant.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 3-34: *cheese_shop.py:1b*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: You precede the string literal with an `f`. Inside, you can substitute a variable
    by wrapping it in curly braces (`{ }`). The `f` tells Python to interpret and
    evaluate as an expression anything in the string that’s wrapped in curly braces.
    This means you’re not limited to variables in those curly braces. You can put
    just about any valid Python code in there, including math, function calls, conditional
    expressions, or whatever you need.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: As of Python 3.8, you can even display both the expression *and* its result
    by appending a trailing equal sign (`=`).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 3-35: *expression_fstring.py*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of gotchas when using f-strings:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if you want to wrap an expression in literal curly braces, you must
    use two curly braces (`{{ }}`) for every one you want displayed:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 3-36: *literal_curly_braces.py*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an odd number of braces, one pair will be ignored. So, if I used
    five pairs, the result would be the same as if I only had four: two literal pairs
    would be printed.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you cannot use backslashes within an expression in an f-string. This
    makes it difficult to escape quotes inside expressions. For example, this would
    not work:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To get around this, I’d need to use triple quotes on the outside of the string,
    to ensure I can employ both single and double quotes inside of the expression.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Backslashes have other roles. The documentation points out the following problematic
    situation:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There’s no direct way around this limitation. Instead, you’d have to evaluate
    that expression in advance, assign the result to a name, and use it in the f-string.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Third, and perhaps least surprising, you cannot put comments inside of f-string
    expressions; the hash (`#`) symbol isn’t allowed, except as a string literal.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Lastly, you can never use f-strings as docstrings.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: These small wrinkles aside, f-strings are incredibly straightforward to work
    with.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Format Specifications
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides arbitrary expressions, f-strings support *format specifications*, which
    allow you to control how values are displayed. This is a fairly in-depth topic
    that could easily become a main section on its own, so I will entrust you to the
    guidance of the documentation for the bulk of it. I’ll breeze over the essentials
    herein.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after the expression, you may choose to include one of three special
    flags: `!r`, `!a`, or `!s` (although that last one is the default behavior, so
    it can be omitted in most cases). These determine which function is used to fetch
    the string representation of some value: `repr()`, `ascii()`, or `str()`, respectively
    (see “String Conversion” below).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the format specification itself, which always begins with a colon
    (`:`), followed by one or more flags. These have to be specified in a particular
    order to work, although any of them may be omitted if they’re not desired:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Align An alignment flag, specifying left (`<`), right (`>`), center (`^`), or
    (if numeric) split with the sign aligned left but the digits aligned right (`=`).
    This is optionally preceded by a character that will be used to fill any blank
    space in the alignment.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Sign A flag controlling when the sign is displayed on a number. The plus (`+`)
    flag displays the sign on both positive and negative numbers, while the minus
    (`–`) flag only displays it on negative numbers. A third option is to show a leading
    space on positive numbers and a sign on negative numbers (space).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Alternative form The hash (`#`) flag turns on the “alternative form,” which
    has different meanings for different types (see documentation).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Leading zeros The zero (`0`) flag causes leading zeros to be displayed (unless
    a fill character is specified for alignment).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Width The width of the output string in characters. This is where the alignment
    comes into play.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Grouping A flag controlling whether numbers should separate thousands with a
    comma (`,`) or an underscore (`_`). If omitted, no separator is used. If enabled,
    the underscore separator also appears every four digits in octal, hexadecimal,
    and binary numbers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Precision A dot (`.`), followed by an integer for decimal precision.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Type A flag controlling how numbers are displayed; common options include binary
    (`b`), character (`c`), decimal (`d`), hexadecimal (`x`), exponent notation (`e`),
    fixed-point (`f`), and general (`g`). There are more (see documentation).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is a bit abstract, so here are a few quick examples:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 3-37: *formatting_strings.py*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete details about the format specification can be found in the official
    Python documentation: [https://docs.python.org/3/library/string.xhtml#format-string-syntax](https://docs.python.org/3/library/string.xhtml#format-string-syntax).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Another useful reference is [https://pyformat.info](https://pyformat.info),
    although as of this writing, it only shows the format specification in the context
    of the old `format()` function. You will need to apply it to f-strings yourself.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Previous String-Formatting Methods
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re reading older Python code, you may encounter the two previous forms
    of string formatting: `%` notation and the newer `format()`. These have both been
    superseded by f-strings, which have superior performance. That’s because they’re
    parsed and converted to bytecode *before* the code is run.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself needing to rewrite a `format()` call as an f-string, the
    process is thankfully quite simple.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example. I’ll start out with a couple of variables:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 3-38: *format_to_fstring.py:1*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the advent of f-strings, if I wanted to print out a message containing
    the values of those two variables, I’d have used `format()`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 3-39: *format_to_fstring.py:2a*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: In the old format, a string literal ❶ would contain sets of curly braces, optionally
    containing the format specifications. The `format()` function would be called
    on that string literal (or on a name referencing it). Then, the expressions to
    be evaluated would be passed to the `format()` function in order ❷.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'That would have the following output:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Converting this to an f-string is as simple as moving the expressions into
    the string literal in order and then prepending an `f` to the literal to make
    it an f-string:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 3-40: *format_to_fstring.py:2b*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The output is the same as before.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, with `format()`, you could refer to the index of the expression
    in the argument list:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Listing 3-41: *format_to_fstring.py:3a*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'That produces this output:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To convert this code to an f-string, you substitute the expressions in place
    of the indices in the string literal, which you (again) turn into an f-string
    by prepending an `f`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 3-42: *format_to_fstring.py:3b*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Converting from `%` notation is a little less trivial, but most Python 3 code
    uses `format()` anyway. If you find yourself needing to do this, [https://pyformat.info](https://pyformat.info)
    does an excellent job of comparing `%` notation and `format()`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Template Strings
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Template strings* constitute one more alternative to f-strings that is worth
    knowing about, especially as it still fulfills some use cases, including internationalizing
    user interfaces. Personally, I find template strings a bit more reusable. On the
    other hand, the drawback is that they’re considerably more limited in terms of
    formatting.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: If you know how they work, you’ll be equipped to decide for yourself which tool
    is best for your particular situation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a template string for greeting a user:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 3-43: *template_string.py:1*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: To use template strings, I first have to import `Template` from the `string`
    module.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Then I can create a new `Template` and pass it a string literal:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listing 3-44: *template_string.py:2*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: I can name my fields whatever I want, preceding each with a dollar sign (`$`).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I call the `substitute()` function on the template I created (`s`)
    and pass expressions to each of the fields:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Listing 3-45: *template_string.py:3*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished string is returned, and in this case, it is passed to `print()`
    and displayed:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'There are a couple of odd syntax rules with template strings. First, to show
    a literal dollar sign in the string literal, use two dollar signs (`$$`). Second,
    to substitute an expression as part of a word, wrap the name of the field in curly
    braces (`{ }`). Both of these rules are demonstrated below:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 3-46: *template_string.py:4*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There’s a handful of additional abilities contained within string templates,
    but I’ll entrust you to the official Python documentation for the rest of that.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: String Conversion
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I previously mentioned that there are three ways to get the string representation
    of a value: `str()`, `repr()`, and `ascii()`.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: The first function, `str()`, is the one you’ll use most often, as it returns
    the *human-readable* representation of the value.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, `repr()` returns the *canonical string representation* of the
    value: that is, (usually) the value as Python sees it. In the case of many basic
    data types, this will return the same thing as `str()`, but when used on most
    objects, the output contains additional information useful in debugging.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The `ascii()` function is the same as `repr()`, except that the string literal
    it returns is completely ASCII-compatible, having escaped any non-ASCII (for example,
    Unicode) characters.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: I’ll return to this concept in Chapter 7, when I start defining my own objects.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: A Note on String Concatenation
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point, I’ve been using the addition (`+`) operator for concatenating
    strings together. This is acceptable in basic situations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: However, this is seldom the most efficient solution, especially when combining
    multiple strings. Therefore, it is recommended to prefer the `join()` method,
    which is called on a string or string literal instead.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a comparison between the two. I start with a couple of string variables:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 3-47: *concat_strings.py:1*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, you’ve seen concatenation with the addition (`+`) operator, like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Listing 3-48: *concat_strings.py:2a*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, I can use the `join()` method:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 3-49: *concat_strings.py:2b*'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: I call the `join()` method on the string that will appear between each piece.
    In this case, I use an empty string. The `join()` method accepts a *tuple* of
    strings—an array-like structure wrapped in parentheses, and therefore, the double
    set of parentheses in the code. I’ll introduce tuples in an upcoming section.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Typical concatenation with `+` or the `join()` function has the same result,
    but the latter function will be *as fast or faster*, especially when you’re using
    other implementations of Python besides CPython. Therefore, whenever you need
    to concatenate and f-strings aren’t right for the job, you should consider using
    `join()` instead of the `+` or `+=` operators. In practice, f-strings are the
    fastest, but `join()` is your next-best option.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python functions are *first-class citizens*, which means they can be treated
    like any other object. Even so, you call them as you would in any other programming
    language.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of a very basic function, which prints a selected type of
    joke to the terminal.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'I start with the function header:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Listing 3-50: *joke_function.py:1*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: I declared the function with the `def` keyword, followed by the name of the
    function. Parameters are named in the parentheses after the function name. The
    entire header is concluded with a colon (`:`).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the header, indented one level, is the *suite* (or body) of the function:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Listing 3-51: *joke_function.py:2*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'You call functions in much the same way as in most languages:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 3-52: *joke_function.py:3*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: I’ll go into depth on functions and their many cousins in Chapter 6.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Classes and Objects
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python fully supports object-oriented programming. In fact, one of the language’s
    design principles is that “everything is an object,” at least behind the scenes.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot more to classes than meets the eye, but for now, you should just
    get an absolutely bare-bones familiarity with the syntax.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class contains a joke of a selected type and displays it on demand:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Listing 3-53: *joke_class.py:1*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: I define the class using the `class` keyword, the name of the class, and a colon
    (`:`) at the end of the header.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'This is followed by the suite of the class, indented one level:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Listing 3-54: *joke_class.py:2*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: The initializer, which is similar in purpose to the constructor in other OOP
    languages, is a member function, or *method*, with the name `__init__()` and at
    least one parameter, `self`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 3-55: *joke_class.py:3*'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions that belong to the class are called methods and are part of the class
    suite. Methods must accept at least one parameter: `self`.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'You would use this class like so:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 3-56: *joke_class.py:4*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: You create a new instance of the `Joke` class by passing the string `"lethal"`
    to its *initializer*, the `__init__()` from earlier. The new object is stored
    in the variable `lethal_joke`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Then, you use the *dot operator* (`.`) to call the function `tell()` within
    the object. Take note that you didn’t have to pass any argument for `self`. That’s
    done automatically when you call the function in this manner.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: I’ll discuss classes and objects in detail in Chapter 7 and further in Chapter
    13.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python offers error and exception handling functionality through the `try` compound
    statement.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: For example, if I wanted to get a number from the user, I couldn’t reliably
    predict what they would type in. Trying to convert a string, like `"spam"`, to
    an integer would cause an error. I can use error handling to take a different
    action if it isn’t possible to convert the user `input`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Listing 3-57: *try_except.py*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: I get a string from the user, and then in the `try` clause, I attempt to convert
    it to an integer with the `int()` function. That would raise a `ValueError` exception
    if the string it’s trying to convert is not a valid whole number (base 10).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: If that exception is raised, I catch it in the `except` clause and handle the
    failure.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the last line would always be run.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: There are additional features and subtleties to the `try` statement, including
    `finally` and `else` clauses, which I’ll cover in Chapter 8. For now, it’s better
    to avoid these concepts rather than use them incorrectly.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Tuples and Lists
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two of Python’s most common built-in data structures, called *collections*,
    are tuples and lists.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '*Lists* constitute the most array-like collection in Python. In CPython, they
    are implemented as variable-length arrays, not as linked lists like the name might
    suggest.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a list of strings with names of cheeses:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Listing 3-58: *cheese_list.py:1*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: You enclose a list literal in square brackets, separating each item in the list
    with commas.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access or reassign the values of individual items with the same bracket
    notation used by most programming languages:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 3-59: *cheese_list.py:2*'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: A *tuple* is somewhat similar to a list, but with a few key differences. First,
    a tuple cannot have items added, reassigned, or removed after its creation. Attempting
    to modify the contents of a tuple with bracket notation will result in a `TypeError`.
    This is because tuples, unlike lists, are *immutable*, effectively meaning their
    contents cannot be modified (see Chapter 5 for the full explanation).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a tuple:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Listing 3-60: *knight_tuple.py:1*'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'You enclose tuple literals in parentheses (`( )`), instead of brackets (`[
    ]`). Nevertheless, you still use bracket notation to access individual items:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Listing 3-61: *knight_tuple.py:2*'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said, you cannot change the items of a tuple after creation, such as if
    you tried to reassign the first item:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Listing 3-62: *knight_tuple.py:3*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: The guideline is to use tuples for collections of items of different types (*heterogeneous*
    collections) and to use lists for collections of items of the same type (*homogeneous*
    collections).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: I’ll discuss these collections, and many more, in Chapter 9.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has two basic loop types: *while* and *for*.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: while Loop
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` loop probably looks familiar from other languages:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 3-63: *while_loop.py*'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: I start the loop with the `while` keyword, follow it with the condition to test,
    and finish the header with a colon (`:`). As long as that condition evaluates
    to `True`, the code in the suite of the loop is executed.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: When you need to keep running a loop until some condition is met, use `while`
    loops. These are particularly useful when you don’t know how many iterations of
    the loop will take place before the condition is met.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Loop Control
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can manually control the loop, using two keywords. The `continue` keyword
    abandons the current iteration and jumps to the next one. The `break` keyword
    exits the loop altogether.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'One common scenario where you may use these keywords is in an infinite loop
    used for running a game or a user interface. For example, here’s a very simple
    command prompt:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Listing 3-64: *loop_control.py*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: The loop `while True` is inherently infinite; `True` is always `True`. That’s
    the behavior I actually want here, since I want to keep iterating until the user
    enters the string `"exit"`, at which point, I manually end the loop with `break`.
    (By the way, if you’ve been waiting for a `do-while` loop, this is effectively
    the way to recreate that behavior.)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: The command `"sing"` has a different behavior, after which I’d want to immediately
    go to the top and prompt the user for another command, skipping the last print
    statement. The `continue` keyword does exactly that, immediately abandoning the
    current iteration and jumping back to the top of the loop.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: for Loop
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s `for` loop is a little different from loops in many languages. It’s
    generally used for iterating over a range, list, or other collection.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Listing 3-65: *for_loop.py*'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: I start the loop header with the `for` keyword. Technically, this kind of loop
    is a `for`-`in` (or “`for`-`each`”) loop, meaning the loop iterates once for each
    item in the given range, list, or other collection. This means the loop needs
    something to iterate over—in this case, a special object called `range()`—which
    iterates over a range of values, returning each one in turn. I’ve specified that
    I want the range to start with the value `1` and end before `11`. The local variable
    `i` will refer to the current item for each iteration. Finally, the `in` keyword
    precedes the thing I’m iterating over—that is, before `range()` in this example.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: As long as there are items to iterate over, the code belonging to the loop will
    be executed—in this case, printing out the value of the current item. The loop
    stops when the last item is iterated over.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Running this code would print the numbers 1 through 10.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: This only scratches the surface of loops. See Chapter 9 for more.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Structural Pattern Matching
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many years, developers coming to Python from languages like C, C++, Java,
    or Javascript would ask if there was a Python equivalent to the `switch`/`case`
    statement (or `match`/`case` in Scala, `case`/`when` in Ruby, and so on). They’d
    always be disappointed to hear a resounding “No!” Python only had conditional
    statements.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: At long last, Python 3.10 gained *structural pattern matching* via PEP 634\.
    This provides conditional logic that is at least syntactically similar to `switch`
    statements of other languages. In short, you test a single *subject*, such as
    a variable, against one or more *patterns*. If the subject matches the pattern,
    the associated suite of code runs.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Literal Patterns and Wildcards
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the most basic use case, you can check a variable against different possible
    values. These are called *literal patterns*. For example, perhaps I want to display
    different messages, depending on a user’s `input` `lunch` `order`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Listing 3-66: *pattern_match.py:1a*'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The value of `lunch_order` is compared to each case until it matches one. Once
    a match is found, the case’s suite is run, and the match statement is finished;
    the value won’t be checked against additional patterns once it matches one. So,
    if the user inputs `"pizza"`, the `"Pizza` `time!"` message is displayed. Similarly,
    if they input `"taco"`, the message `"Taco,` `taco,` `TACO,` `tacotacotaco!"`
    is displayed instead.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The underscore (`_`) in the last case is the *wildcard*, which will match any
    value. This serves as a fallback case, and it must come last, as it will match
    anything.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Or Patterns
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A single case can cover multiple possible values. One way to do this is with
    an *or pattern*, where possible literal values are separated by the bar character:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Listing 3-67: *pattern_match.py:1b*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: This pattern will match if the user enters either `"salad"` or `"soup"` at the
    prompt.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Capture Patterns
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One particularly helpful feature of structural pattern matching is the ability
    to capture part or all of the subject. For example, it isn’t very helpful in our
    example that the fallback case only says `"Yummy."`. Instead, I’d like to have
    a default message announcing the user’s selection. To do that, I write a *capture
    pattern* like this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Listing 3-68: *pattern_match.py:1c*'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: This pattern acts like a wildcard, except the value of `lunch_order` is captured
    as `order`. Now, no matter what the user enters, if it doesn’t match any of the
    previous patterns, the value will be captured and displayed in the message here.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'Capture patterns don’t just have to capture the entire value. For example,
    I can write a pattern that matches a tuple or list (a *sequence*) and then captures
    only part of that sequence:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Listing 3-69: *pattern_match.py:1d*'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: In this version, if the lunch order has a space, I split the string into two
    parts, which are stored in a list. Then, if the second item in the sequence has
    the value `"ice cream"`, the first part is captured as `flavor`. Thus, the code
    can account for Bojan if he decides to break down and have strawberry ice cream
    for lunch. (And I’m not stopping him!)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'The capture pattern feature has one surprising downside: all *unqualified*
    names in patterns—that is, any bare variable names with no dots—will be used to
    capture. This means that if you want to use the value assigned to some variable,
    it must be *qualified*, meaning you must access it within some class or module
    with the dot operator:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 3-70: *pattern_match.py:1e*'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Guard Statements
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One last trick I’ll demonstrate with pattern matching is the *guard statement*,
    an additional conditional statement that must be satisfied for a pattern to match.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the current version of my lunch order example, using the logic
    to split the order by spaces means the code doesn’t behave very nicely with other
    foods with spaces in them. Also, if I enter `"rocky road ice cream"`, it won’t
    match the current ice cream pattern.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Instead of splitting my string by spaces, I can write a pattern with a guard
    statement that looks for the words *ice cream* in the lunch order.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Listing 3-71: *pattern_match_object.py:1f*'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: The pattern here captures the value as `ice_cream`, but only if the guard statement
    `if 'ice cream' in ice_cream` is satisfied. In that case, I use `.replace()` to
    remove the words *ice cream* from the captured value, leaving me with only the
    name of the flavor. I also use `.strip()` to remove any leading or trailing whitespace
    from the new string. Finally, I print out my message.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: More About Structural Pattern Matching
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are quite a few other tricks and techniques that work with structural
    pattern matching. They work with objects (see Chapter 7), with dictionaries via
    mapping patterns (see Chapter 9), and even by support nesting patterns within
    other patterns.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: As with many Python techniques, pattern matching feels like “magic,” and there’s
    a strong temptation to use it everywhere possible. Resist this urge! Structural
    pattern matching is very useful for checking a single subject against multiple
    possible patterns, but as you can even see from the “ice cream” situation in the
    lunch order example, it quickly reaches its limits as the possible values of the
    subject get more elaborate. As a rule, if you’re unsure whether you need structural
    pattern matching in a particular situation, stick with conditional statements.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn even more, read PEP 636, which serves as the official tutorial for
    this topic and demonstrates all of the functionality available with this language
    feature: [https://peps.python.org/pep-0636/](https://peps.python.org/pep-0636/).'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should now have a feeling for Python’s syntax and a basic familiarity with
    its key structures. If you were to stop here, you could probably write Python
    code that at least works. In fact, many developers new to the language do indeed
    work with about this much information, implicitly bringing the habits and practices
    of whatever language they know best.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: There is a profound difference between valid code and idiomatic, Pythonic code.
    Writing the latter is the focus of this book.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
