- en: '**12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FILES AND FOLDERS**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Files let you store data in a persistent and sharable manner. It’s all but impossible
    to do any real work without them. Python comes with many modules and methods for
    working with files, folders, and directory paths. These let you read and write
    text files; preserve complex data after you exit your program; create, move, and
    delete folders; and perform other system-level tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll use the built-in operating system (`os`), path library
    (`pathlib`), and shell utilities (`shutil`) modules to work with files, folders,
    and directory paths. We’ll then use built-in functions to open, read, write, and
    close text files, and the built-in `pickle`, `shelve`, and `json` modules to preserve
    and store more complex data types such as Python lists and dictionaries. Finally,
    we’ll look at ways to handle exceptions when opening files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a New Spyder Project**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s make a new Spyder project to use in this chapter. If you need a refresher
    on Spyder projects, see “Using Project Files and Folders” on [page 68](ch04.xhtml#ch00lev1sec25).
  prefs: []
  type: TYPE_NORMAL
- en: To begin, start Spyder (either from the Start menu or from Anaconda Navigator)
    and then, in the top toolbar, click **Projects** ▸ **New Project**. In the Create
    New Project dialog that opens ([Figure 12-1](ch12.xhtml#ch012fig1)), make sure
    the Location box includes your home directory, set the Project name to **file_play**,
    and then click the **Create** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/12fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: The Spyder Create New Project dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: You should now see this new folder in Spyder’s File Explorer pane.
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Directory Paths**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you can work with files and folders (also called *directories*), you’ll
    need to know how to find them and where to save them. And to do that, you’ll need
    an address, otherwise known as a *directory path*.
  prefs: []
  type: TYPE_NORMAL
- en: A directory path is a string of characters used to uniquely identify a location
    in a directory structure. A path starts with a root directory designated by a
    letter (such as *C:\*) in Windows and a forward slash (*/*) in Unix-based systems.
    Additional drives in Windows are assigned a different letter than *C*, those in
    macOS are placed under */volume*, and those in Unix under */mnt* (for “mount”).
  prefs: []
  type: TYPE_NORMAL
- en: Pathnames appear differently depending on the operating system. Windows separates
    folders with a backslash (*\*), whereas macOS and Unix systems use a forward slash
    (*/*). Folders and filenames are also case sensitive in Unix.
  prefs: []
  type: TYPE_NORMAL
- en: These differences between operating systems can pose problems if you’re trying
    to write code that can run on any system. If you’re writing a program in Windows
    and enter pathnames with backslashes, other platforms won’t recognize the paths.
    Fortunately, Python provides standard library modules such as `os` and `pathlib`
    to help you deal with this.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Operating System Module***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The operating system (`os`) module has been described as a “junk drawer for
    system-related stuff.” [Table 12-1](ch12.xhtml#ch012tab1) summarizes some of the
    most used methods in this module. For a complete list of the methods and details
    about their use, visit the documentation at *[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-1:** Useful `os` Module Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `os.getcwd()` | Return location of the current working directory (cwd) |'
  prefs: []
  type: TYPE_TB
- en: '| `os.chdir()` | Change cwd to a specified path |'
  prefs: []
  type: TYPE_TB
- en: '| `os.getsize()` | Return the size of a file in bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `os.listdir()` | Return list of files and folders inside specified directory
    (defaults to cwd) |'
  prefs: []
  type: TYPE_TB
- en: '| `os.mkdir()` | Create a new directory based on a specified path |'
  prefs: []
  type: TYPE_TB
- en: '| `os.makedirs()` | Create multiple nested directories based on a specified
    path |'
  prefs: []
  type: TYPE_TB
- en: '| `os.rename()` | Rename a specified file or directory |'
  prefs: []
  type: TYPE_TB
- en: '| `os.rmdir()` | Delete an empty directory |'
  prefs: []
  type: TYPE_TB
- en: '| `os.walk()` | Generate filenames in a directory tree |'
  prefs: []
  type: TYPE_TB
- en: '| `os.path.join()` | Join path components and return a string that contains
    a concatenated path |'
  prefs: []
  type: TYPE_TB
- en: '| `os.path.split()` | Split a pathname into a head and tail (tail=last pathname
    component) |'
  prefs: []
  type: TYPE_TB
- en: '| `os.path.abspath()` | Return a normalized absolute version of a specified
    path |'
  prefs: []
  type: TYPE_TB
- en: '| `os.path.normpath()` | Correct path separators for the system in use |'
  prefs: []
  type: TYPE_TB
- en: '| `os.path.isdir()` | Check whether a specified path corresponds to an existing
    directory |'
  prefs: []
  type: TYPE_TB
- en: '| `os.path.isfile()` | Check whether a specified path corresponds to an existing
    file |'
  prefs: []
  type: TYPE_TB
- en: '| `os.path.isabs()` | Check whether a specified path is absolute or not |'
  prefs: []
  type: TYPE_TB
- en: '| `os.path.exists()` | Check whether a specified path exists or not |'
  prefs: []
  type: TYPE_TB
- en: 'Several of these `os` methods are helpful for discovering pathnames you didn’t
    already know. For example, to determine the name of the directory in which you’re
    currently working (called the *current working directory*, or *cwd*), import the
    `os` module and enter the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you used the `os.getcwd()` method to get the path to your current
    working directory (your path will be different). This is a Windows example, so
    backslashes separate directory names, and, because this is a string, the backslashes
    must be escaped with a backslash (see “Escape Sequences” on [page 190](ch07.xhtml#ch00lev3sec16)
    for a refresher on the escape sequence). The `os.getcwd()` method will insert
    these backslashes for you, but they will cause problems if you try to use this
    path with another operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The current working directory is assigned to a *process* (a running instance
    of a program) when that process starts up. For a Python program, the current working
    directory is always the folder that contains the running program.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `os.chdir()` to move from the current working directory to another
    directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this new directory becomes the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you work in Windows and don’t want to type the double backslash, you can
    enter an `r` before the pathname argument string to convert it to a raw string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To make your program compatible with all operating systems, use the `os.path.join()`
    method and pass it the folder names and filenames without a separator character,
    as separate strings. The `os.path` methods are aware of the system you’re using
    and return the proper separators. This allows for platform-independent manipulation
    of file and folder names. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, you assigned a pathname, as a string, to the `path` variable.
    Notice how you can safely use forward slashes in Windows. Next, you made a new
    path variable (`path2`) using the `os.path.join()` method. Even though the output
    in line `Out[15]` looks messy, the `os.path.join()` method knows which operating
    system you’re using and corrects the separators as needed (lines `In[16]` - `Out[17])`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also take an existing path with the wrong separators and *normalize*
    it to the system you’re using with `os.normpath()`. Here’s an example in which
    Unix forward slashes are changed to Windows backslashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '***Absolute vs. Relative Paths***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The full directory path, from the drive to the current file or folder, is called
    the *absolute path*. You can use shortcuts, called *relative paths*, to make working
    with directories easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Relative paths are interpreted from the perspective of the current working
    directory. Whereas absolute paths start with a forward slash or drive label, relative
    paths do not. In the following code snippet, you can change directories without
    entering an absolute path because Python is aware of folders within the current
    working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Behind the scenes, the relative path is joined to the path leading to the current
    working directory to make the complete absolute path shown in line `Out[23]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows, macOS, and Linux, you can identify folders and save yourself some
    typing by using dot (`.`) and dot-dot (`..`). For example, in Windows, `.\` refers
    to the current working directory, and `..\` refers to the parent directory that
    holds the current working directory. You can also use a dot to get the absolute
    path to your current working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If a file, folder, or user-defined module that you need to access is stored
    in the same folder as your code, you can simply refer to the item’s name in your
    code, without the need for a path or a “dot” shortcut. Following is an example
    in which we create multiple nested folders within the *file_play* folder. Because
    *file_play* is the current working directory and these folders will exist within
    it, there’s no need to include a file path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `os.makedirs()` method created three nested folders (*test1*,
    *test2*, and *test3*) using a raw string. You should now see three folders in
    your Spyder project in the File Explorer pane ([Figure 12-2](ch12.xhtml#ch012fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/12fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: The three new folders in the Spyder project*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The pathlib Module***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `os` module is widely used, and you should familiarize yourself with its
    methods and syntax. But it treats paths as strings, which can be cumbersome and
    requires you to use functionality from across the standard library (it takes three
    modules just to gather and move files between directories).
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to use the smaller and more focused `pathlib` module. This
    module treats paths as objects rather than strings, and gathers the necessary
    path functionality in one place. It’s also agnostic to the operating system, making
    it useful for writing cross-platform programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module’s `Path` and `PurePath` classes not only help you work with directory
    paths, they also duplicate useful `os` module methods for tasks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the current working directory: `Path.cwd()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Making directories: `Path.mkdir()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Renaming directories: `Path.rename()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Removing directories: `Path.rmdir()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Path classes in pathlib are divided into *pure* paths and concrete paths.
    PurePath objects act like strings and provide path-handling operations such as
    editing the path, joining paths, finding the parent path, and so on, but they
    don’t access a filesystem. Concrete paths inherit from PurePath and provide both
    pure path operations and new methods to do system calls on path objects. Concrete
    paths let you access the filesystem to search directories, remove directories,
    write to files, and so on.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-2](ch12.xhtml#ch012tab2) summarizes some of the more useful methods
    available through the `pathlib` module. For the full list, visit the documentation
    at *[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)*.
    This documentation also includes a complete mapping of various `os` methods to
    their corresponding `Path` and `PurePath` equivalents.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-2:** Useful `Path` and `PurePath` Methods for Working with Paths'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.cwd()` | Return path object for the cwd |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.exists()` | Return Boolean that indicates whether path points to existing
    file or folder |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.home()` | Return path object representing the user’s home directory
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PurePath.is_absolute()` | Return Boolean that indicates whether the path
    is absolute or not |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.is_dir()` | Return `True` if the given path points to a directory (or
    symbolic link) |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.iterdir()` | Yield contents of a given directory |'
  prefs: []
  type: TYPE_TB
- en: '| `PurePath.joinpath()` | Combine a given path with each of the other arguments
    in turn |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.mkdir()` | Create a new directory at the given path |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.readlink()` | Return path for given symbolic link |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.resolve()` | Make path absolute, resolving any symbolic links; return
    new path |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.rmdir()` | Remove an empty directory |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.unlink()` | Remove a file or symbolic link |'
  prefs: []
  type: TYPE_TB
- en: 'Here’s how to make a path variable using `Path`. Start by importing the class
    from the module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `Path` returned a `WindowsPath` object. If you’re using macOS or
    Linux, you should see a `PosixPath` object. Also note that although the `WindowsPath`
    object displays with forward slashes, it employs proper Windows backslashes behind
    the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`Path` includes methods that can make your code more readable and convenient
    to write. Suppose that you want to append a path to your home directory. Rather
    than type in the full path, you can just use the `home()` method to get the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can do all this in one line and use forward slashes rather
    than commas to separate path components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry about those forward slashes if you’re using Windows. As demonstrated
    previously, the path object is aware of the platform in use and will return the
    correct format for that system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `Path` object includes handy attributes for working with files and folders.
    These let you get information like the `stem` of a path or a file’s `name` or
    extension (`suffix`). The `parent` attribute, for example, returns the most immediate
    ancestor of a given file path. In the following example, we get the path *leading
    up to* the text file in the `another_path` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access this attribute multiple times to walk up the ancestry tree of
    a given file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, `pathlib` gives you access to basic filesystem operations
    like moving, renaming, and removing files and folders. These methods don’t warn
    you or wait for confirmation before executing, so you’ll want to be very careful
    when using them. Otherwise, you could easily delete or overwrite data that you
    want to keep.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Shell Utilities Module***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The built-in shell utilities module (`shutil`) provides high-level functions
    for working with files and folders, such as copying, moving, and deleting. [Table
    12-3](ch12.xhtml#ch012tab3) summarizes a few of the most popular methods. For
    a list of all of the available methods, along with detailed instructions for their
    use, visit the documentation at *[https://docs.python.org/3/library/shutil.html](https://docs.python.org/3/library/shutil.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-3:** Useful `shutil` Module Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `copy()` | Copy a file (if path is included, will copy to a new directory)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `copy2()` | Same as `copy()` but preserves all the metadata of the source
    file |'
  prefs: []
  type: TYPE_TB
- en: '| `copytree()` | Recursively copy an entire directory tree rooted at a source
    directory to a new destination directory and return the destination directory
    path |'
  prefs: []
  type: TYPE_TB
- en: '| `disk_usage()` | Return disk usage statistics about a file system as a named
    tuple with the attributes total, used, and free, in bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `move()` | Move a file or directory to another location and return the destination
    |'
  prefs: []
  type: TYPE_TB
- en: '| `rmtree()` | Delete an entire directory tree (very dangerous) |'
  prefs: []
  type: TYPE_TB
- en: '| `make_archive()` | Create an archive file (zip or tar) and return its name
    |'
  prefs: []
  type: TYPE_TB
- en: 'Here’s an example in which I get the current disk usage on my system using
    a dot to represent the absolute path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, we move the *test2* folder to a new location under the
    *file_play* folder. To accomplish this, we pass the current path (with the current
    working directory represented by a dot folder), followed by the target path, to
    the `move()` method (note that the path is configured for Windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You should see this update reflected in Spyder’s File Explorer (compare [Figure
    12-2](ch12.xhtml#ch012fig2) to [Figure 12-3](ch12.xhtml#ch012fig3)). Child folders
    move with parent folders, so the *test3* folder remains beneath *test2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/12fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: The test2 folder moved beneath the file_play folder*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Always be careful when using shutil methods; no warnings are provided, and
    unexpected behavior can result. The rmtree() method is especially dangerous because
    it permanently deletes folders and their contents. You can wipe much of your system,
    lose important documents unrelated to Python projects, and break your computer!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a feel for manipulating files and folders using Python, it’s
    time to start writing and reading files. We’ll begin with simple text files and
    then move on to more sophisticated data structures.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '1.  The ''.'' folder represents:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  The current working directory
  prefs: []
  type: TYPE_NORMAL
- en: b.  The parent directory for the current working directory
  prefs: []
  type: TYPE_NORMAL
- en: c.  The absolute path
  prefs: []
  type: TYPE_NORMAL
- en: d.  The child directory for the current working directory
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Which method should you be particularly careful about using?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `shutil.move()`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `shutil.copytree()`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `Path.resolve()`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `shutil.rmtree()`
  prefs: []
  type: TYPE_NORMAL
- en: '3.  True or false: a relative directory path is relative with respect to the
    root directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '4.  You can use the `os.path.join()` method to:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Return a directory path as an object rather than a string
  prefs: []
  type: TYPE_NORMAL
- en: b.  Return a directory path as a list rather than a string
  prefs: []
  type: TYPE_NORMAL
- en: c.  Return the proper path separators for your operating system
  prefs: []
  type: TYPE_NORMAL
- en: d.  Correct existing path separators for your operating system
  prefs: []
  type: TYPE_NORMAL
- en: 5.  The `pathlib` module treats paths as ___________ .
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Text Files**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *plaintext* file consists of human-readable characters encoded using some
    standard such as ASCII, with no formatting information other than space, tab,
    and newline characters. Some examples of plaintext files are text files (*.txt*),
    Python files (*.py*), and comma-separated values files (*.csv*). Plaintext files
    are cross-platform. You can open and read one using both Window’s Notepad and
    macOS’s TextEdit app.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s standard library includes built-in functions for reading and writing
    text files. The `pathlib` module also includes methods for working with text files.
    In the sections that follow, we’ll first use the built-in functions, and then
    we’ll look at the `pathlib` alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reading a Text File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using Python, you can read strings from a text file in multiple ways. For example,
    you can read individual characters, complete lines, the whole file, and so on.
    To demonstrate, open your system’s text editor and enter the following. Be sure
    to press ENTER after the first two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Save the file in the *file_play* folder as *lines.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can double-click a text file in the Spyder File Explorer to edit and review
    its contents. You can also generate text files using File ▸ New file on the top
    toolbar. Use the Save as command to choose the .txt extension.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the console, enter the following to open, read, and close the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we used the built-in `open()` function to open the file and
    assign its contents to the `f` variable (short for “file”). The `open()` function
    took two arguments. The first was the name of the text file. Because this file
    is in the current working directory, you didn’t need to include a path. For files
    not in the current working directory, you would need to pass either an absolute
    or relative path.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument was an *access mode*, which sets the type of operations
    possible in the opened file, such as read, write, append, and so on. The `'r'`
    informs Python that you want to open the file as *read-only*. This protects the
    file from modification. Although read-only is the default mode, explicitly including
    the `'r'` argument makes your intention clear. [Table 12-4](ch12.xhtml#ch012tab4)
    includes some common file access modes in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-4:** Selected Text File Access Modes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mode** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `''r''` | Read from a text file. Raise an exception if the file doesn’t exist.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `''w''` | Write to a text file. Creates a new file, else overwrites existing
    files. |'
  prefs: []
  type: TYPE_TB
- en: '| `''x''` | Write to a text file but return an error if the file already exists.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `''a''` | Append to a text file. Create a new file if one doesn’t exist.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `''r+''` | Permit read and write mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `''b''` | Add to mode for binary files (such as `''rb''`). |'
  prefs: []
  type: TYPE_TB
- en: The `open()` function returned a `File` object of type `_io.TextIOWrapper`.
    This is a type of object like a list or a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at some of the file object methods for reading files ([Table
    12-5](ch12.xhtml#ch012tab5)). These are called on a file object using dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-5:** Selected File Object Methods and Attributes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `close()` | Close a file. |'
  prefs: []
  type: TYPE_TB
- en: '| `closed` | Attribute that returns `True` if a file is closed. |'
  prefs: []
  type: TYPE_TB
- en: '| `read()` | Read the specified number of characters from a file and return
    a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `readline()` | Read the specified number of characters from a file and return
    a string. By default, return all characters from the current position to the end
    of a line. |'
  prefs: []
  type: TYPE_TB
- en: '| `readlines()` | Read all the lines in a file and return them as items in
    a list. |'
  prefs: []
  type: TYPE_TB
- en: '| `seek()` | Change the position of the file pointer to a specific position
    within the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `tell()` | Return the current position of the file read/write pointer within
    a file. |'
  prefs: []
  type: TYPE_TB
- en: '| `write()` | Write the specified string to a file. |'
  prefs: []
  type: TYPE_TB
- en: '| `writelines()` | Write the strings in a specified list to a file. |'
  prefs: []
  type: TYPE_TB
- en: Among the most important methods is `close()`. Closing files before terminating
    the process is a good practice. If you don’t close files, you could run out of
    file descriptors (numbers that uniquely identify open files in a computer’s operating
    system), lock the files from further access in Windows, corrupt the files, or
    lose data if you are writing to the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To close a file, call `close()` using dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can work with file objects only while they’re open. After a file object
    is closed, you can no longer work with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at ways to get the file contents. In the following console
    snippet, open the file again and use the `read()` method to read the first character.
    This method returns a `string` data type (remember, in the console you can use
    the up and down arrow keys to retrieve previous commands):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing the `read()` method the value `1` returned the first character in the
    file. But passing it `10` did not return the first 10 characters in the file.
    That’s because `read()` remembers where it left off. To find the current position
    in the file, use the `tell()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To manually change the position of the pointer in the file, pass the `seek()`
    method a number, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To restart at the beginning, you must either close and reopen the file or use
    `seek()` to return to the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t specify the number of characters to read, Python returns the entire
    file. This is not a problem for small files, but it can become an issue with very
    large files. To demonstrate reading the entire file, reopen the file and call
    the `read()` method with no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the file object includes the newline escape sequence (`\n`). This
    lets it know how to print the lines correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `readline()` method to read a line at a time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, “lines” are defined by the presence of the newline escape sequence
    (`\n`). Like the `read()` function, `readline()` remembers where it left off,
    so to start back at the beginning, you must close and reopen the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful when you’re using `readline()`. Don’t assume that the value you
    pass it represents a line; it actually represents a character, just as with the
    `read()` method. In fact, you can duplicate the results from lines `In[48]-In[49]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To read in a whole file at once, you can use the `readlines()` method. Unlike
    the previous methods, which return strings, this method reads the file into a
    list. Each line in the file becomes a separate item in the list. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the output is a list, you can get its length, iterate over it, and
    so on, as with any list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding methods, the end-of-line (EOL) markers are preserved. These
    are control characters used by character-encoding specifications such as ASCII
    to signify the end of a line of text. If you don’t want these, you can strip them
    out using list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Compare the previous output to that in line `Out[71`.] The newline characters
    (`\n`) are gone. The `rstrip()` string method removes specified trailing characters
    from the right side of a string. If no character is specified, it removes any
    newline characters or whitespace at the end of a line.
  prefs: []
  type: TYPE_NORMAL
- en: '***Closing Files Using the with Statement***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because closing files is so important (and easily overlooked), Python provides
    the `with` statement, which automatically closes files after a nested block of
    code. In this example, we load the text file using the `with` statement and the
    `open()` function, and then we use the `read()` method to get the complete contents
    of the file and assign them to the `lines` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever possible, try to use a `with` statement when opening files to ensure
    that the file is closed properly. To check that a file is closed, you can use
    its closed attribute, which returns `True` or `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '***Writing to a Text File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can write a string to a text file using the `write()` and `writelines()`
    file object methods ([Table 12-5](ch12.xhtml#ch012tab5)). Let’s try this out using
    a haiku poem by yours truly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write to a file, you first must open it using the write (`''w''`) file access
    mode (see [Table 12-4](ch12.xhtml#ch012tab4)). Enter the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Calling `open()` on a file in write mode either creates a new file with the
    specified name (if one doesn’t exist) or completely overwrites an existing file
    with the same name, erasing its contents. In this case, we need only to enter
    a filename because we’re writing to the current working directory. To write elsewhere,
    you need to either change directories using the `chdir()` method or include a
    directory path with the filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a file object, we can write strings to it, using a newline
    character where we want carriage returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The output represents the number of characters in each string, including the
    newline character. Closing the file at the end frees up system resources and prevents
    you from accidently writing more data to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check that it worked by using the `read()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Remember, when you open a file using the `with` statement, it closes automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entering lines one by one is tedious. The `writelines()` method lets you *write*
    a list of strings into a file, much like the `readlines()` method offers the ability
    to *read* a text file into a list. The following example creates a new haiku as
    a list, overwrites the existing *haiku.txt* file, writes the list to the file
    and then reads the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops, we forgot to attribute the haiku to the master Issa. No problem. With
    the append (`''a''`) file access mode, you can add strings to an existing text
    file without overwriting the original contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `writelines()` to generate new file contents on the fly, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we filtered the `poem` list so that only lines beginning with
    `C` were written to the new file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reading and Writing Text Files Using pathlib***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Path` class of the `pathlib` module also provides methods for working with
    files and folders ([Table 12-6](ch12.xhtml#ch012tab6)). These methods incorporate
    built-in functions like `open()` and can make simple reading and writing exercises
    more convenient (assuming that you like working with path objects).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-6:** Some Useful `Path` Methods for Working with Files and Folders'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.glob()` | Yield all matchings files for a given pattern (such as *.py)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.is_file()` | Return `True` if given path points to a regular file (or
    symbolic link) |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.open()` | Open a file based on name or path + name |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.read_bytes()` | Return the contents of a given file as a bytes object
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.read_text()` | Return the contents of a given file as a string and
    close the file |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.rename()` | Rename a file or directory and return new path |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.replace()` | Rename a file or directory unconditionally and return
    new path |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.touch()` | Create a file at the given path |'
  prefs: []
  type: TYPE_TB
- en: '| `Path.write_text()` | Open a specified file in text mode, write to it, and
    then close the file |'
  prefs: []
  type: TYPE_TB
- en: 'The `Path.read_text()` method calls `open()` behind the scenes and returns
    a file’s contents as a string. It also closes the file automatically, like the
    `with` statement. Here’s an example in the console using the *lines.txt* file
    from earlier in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that you first must create a path object (`p`). For users unfamiliar with
    `pathlib`, this can be confusing compared to the more tradition file-opening techniques
    reviewed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a file in the `test1` folder and write to it using `Path`.
    In the console, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `Path.write_text()` method takes a string as an argument. Like `open()`,
    it will overwrite an existing file with the same name. Unlike `open()`, it doesn’t
    permit use of an append mode. It will, however, close the file automatically.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about `pathlib` at *[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Which statements or methods close a text file?
  prefs: []
  type: TYPE_NORMAL
- en: a.  The `with` statement
  prefs: []
  type: TYPE_NORMAL
- en: b.  The `Path.read_text()` method
  prefs: []
  type: TYPE_NORMAL
- en: c.  The `Path.write_text()` method
  prefs: []
  type: TYPE_NORMAL
- en: d.  The `close()` method
  prefs: []
  type: TYPE_NORMAL
- en: e.  All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Rename the *another_haiku.txt* file created in the previous section to *haiku_2.txt*.
    Use either the `os` or `pathlib` modules.
  prefs: []
  type: TYPE_NORMAL
- en: 8.  Print the *haiku.txt* file starting at the 15th character.
  prefs: []
  type: TYPE_NORMAL
- en: 9.  Which file-access mode is used to add text to an existing text file?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `w`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `r`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `a`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `b`
  prefs: []
  type: TYPE_NORMAL
- en: '10.  True or false: The `os.writelines()` method writes a list to a file; the
    `Path.write_text()` method writes a string to a file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Complex Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Text files are convenient and popular, but they’re hardly the only game in town.
    The various file-writing methods we’ve reviewed so far accept only strings, or
    lists of strings, as input. But Python includes many different data types, such
    as dictionaries, that you’ll use in your everyday work, and you’ll need a way
    to save these, as well.
  prefs: []
  type: TYPE_NORMAL
- en: To save these other data types, you need to use *data serialization*. This process
    converts structured data such as a Python dictionary into a storable and sharable
    format. This format retains the information needed to reconstruct the object in
    memory when it’s read from storage or transmitted. This process is called *de-serialization*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll look at modules, like `pickle` and `json`, that serialize
    and deserialize data. The `pickle` module is Python’s native serialization module.
    It converts objects into an ordered sequence of bytes (0s and 1s) known as a *byte
    stream*. Pickling and unpickling allow us to easily transfer data from one server
    or system to another and then store it in a file or database.
  prefs: []
  type: TYPE_NORMAL
- en: The `json` module converts Python objects to a serialized representation known
    as *JavaScript Object Notation*, or *JSON* for short, and deserializes them on
    demand. We used `json` for pretty-printing dictionaries back in [Chapter 9](ch09.xhtml).
    It works with just about every language.
  prefs: []
  type: TYPE_NORMAL
- en: These two modules have their strengths and weaknesses ([Table 12-7](ch12.xhtml#ch012tab7)).
    Pickling works on most Python objects and data types, whereas JSON is limited
    to certain objects and data types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-7:** Pickle vs. JSON for Serialization'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Characteristic** | **Pickle** | **JSON** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Storage format | Byte stream | Human-readable string object |'
  prefs: []
  type: TYPE_TB
- en: '| Python objects | All objects | Limited to certain objects |'
  prefs: []
  type: TYPE_TB
- en: '| Python data types | Almost every data type | Only lists, dictionaries, nulls,
    Booleans, numbers, strings, arrays, and JSON objects |'
  prefs: []
  type: TYPE_TB
- en: '| Compatibility | Python only | Language independent |'
  prefs: []
  type: TYPE_TB
- en: '| Speed | Relatively Slow | Relatively fast |'
  prefs: []
  type: TYPE_TB
- en: '| Security | Has security issues | Safe and secure |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pickling is less secure than using JSON. You should be very careful about
    unpickling data from an unknown source, as it may contain malicious data. Pickling
    is also intended for relatively short-term data storage because revisions to the
    module might not always be backward compatible.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Pickling Data***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To pickle something means to preserve it. The `pickle` module (*[https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html)*)
    pickles Python data objects in binary files. Unlike text files, humans cannot
    read binary files.
  prefs: []
  type: TYPE_NORMAL
- en: Pickling is a lot like writing strings to a file, only you write pickled objects.
    The access modes are the same except for the addition of a `'b'` for “binary”
    ([Table 12-8](ch12.xhtml#ch012tab8)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-8:** Selected Binary File Access Modes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mode** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `''rb''` | Read from a binary file. |'
  prefs: []
  type: TYPE_TB
- en: '| `''wb''` | Write to a binary file. Create or overwrite file, as required.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `''ab''` | Append to a binary file. Create or modify file, as required. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s pickle some lists. In the console, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After importing the `pickle` module and creating two dragon lists, we opened
    a new binary file called *dragons.dat*. Next, we stored the two lists in this
    file using the `pickle.dump()` function, passing it the name of the list and the
    name of the file object as arguments. Finally, we closed the file (you should
    see it in your *file_play* folder).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pickle.dump()` function wrote each list to the file as a separate object.
    To retrieve these objects, we open the file again, in binary mode, and call the
    `pickle.load()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `pickle.load()` function accepts the file object as an argument and returns
    (or unpickles) the first pickled object, assigning it to the variable `dragon_prefix`.
    The next call to `pickle.load()` returns the next pickled object. One thing to
    note here is that you don’t need to know the original names of the lists (like
    “dragon_prefix”) to extract the data. You could have called these “poodledoodle”
    and “snickerdoodle,” and you would have retrieved the same lists in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you want to retrieve the pickled objects in some other order, such
    as retrieving only the dragon suffixes? For that, you’ll need the `shelve` module,
    which takes pickling a step further.
  prefs: []
  type: TYPE_NORMAL
- en: '***Shelving Pickled Data***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *database* is a special file for storing data. Most databases resemble Python
    dictionaries, in that they map keys to values. Unlike a dictionary, however, databases
    persist after a program ends.
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with the `dbm` module for creating and updating database files.
    This module has a limitation, though, as its keys and values must be either strings
    or bytes. The pickle module helps overcome this limitation by transforming multiple
    data types into strings suitable for use in a database.
  prefs: []
  type: TYPE_NORMAL
- en: Because the need to store non-string objects in a database is so common, the
    functionality has been incorporated into a module called `shelve` that helps you
    store and access pickled objects in a file. It builds on `pickle` and implements
    a serialization dictionary in which objects are pickled with an associated key,
    composed of strings. The keys let you load your shelved data file and randomly
    access the values, composed of pickled objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `shelve` module produces a *shelf*, which is a persistent, dictionary-like
    object. Although it’s possible to directly pickle a dictionary, using the `shelve`
    module is more memory efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Because this process involves the pickle module, loading a shelf can execute
    unexpected code, so it’s unsafe to load a shelf from an untrusted source.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how shelving works using the dragon data from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: After importing the module, we used the `shelve.open()` method to create a new
    shelf named `dragon_shelf` in the current working directory, assigned it to the
    variable `s`, and then got the data type of `s`. To create the shelf, we used
    the `'c'` access mode. Other `shelve` access modes are listed in [Table 12-9](ch12.xhtml#ch012tab9).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-9:** Shelve Access Modes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mode** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `''c''` | Open a shelf for reading and writing, creating it if necessary
    |'
  prefs: []
  type: TYPE_TB
- en: '| `''n''` | Create a new, empty shelf open for reading and writing, overwriting
    if needed |'
  prefs: []
  type: TYPE_TB
- en: '| `''r''` | Open an existing shelf for reading only |'
  prefs: []
  type: TYPE_TB
- en: '| `''w''` | Open an existing shelf for reading and writing |'
  prefs: []
  type: TYPE_TB
- en: Now, let’s add the dragon data to the shelf using a key-value combination. This
    will pickle the data behind the scenes. Although we create the list here, we could
    just as easily use a variable name assigned to a list, as we did in the earlier
    `pickle.dump()` example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Closing the shelf *synchronizes* the data by ensuring that any data in the memory
    cache, or buffer, is written to the disk. It then releases system resources by
    clearing the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Two things to note here are that `shelve` will automatically add a *.dat* extension
    to the filename, and it will create additional files that support the shelf (highlighted
    in gray in [Figure 12-4](ch12.xhtml#ch012fig4)). These additional files are operating
    system specific. On macOS, for example, you might see only a file named *dragon_shelf.db*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/12fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: Files related to dragon_shelf in Windows*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Binary files in Spyder’s File Explorer include “01” on the file icon. The
    text file icon uses two straight lines.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s reopen the shelf and retrieve some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: After opening the *dragon_shelf* file in read-only mode, you can see that the
    `prefix` key refers to a `list` object. You can also print the `suffix` list first,
    despite it being the second list loaded into the shelf. Compare this to the `pickle.load()`
    method from the previous section, which returns pickled objects in order.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Shelves Using the with Statement**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Shelving a large volume of data can use a lot of memory, so it’s important
    to close a shelf when you’re finished. Because this easily can be overlooked,
    Python lets you use the `with` statement when opening shelves so that the files
    automatically close after some action. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `with` statement closed the shelf after its block executed, subsequent
    actions on `s` will raise a `ValueError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '**Using Shelve Methods**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Shelf objects support most of methods and operations supported by dictionaries
    ([Table 12-10](ch12.xhtml#ch012tab10)). This is by design and is intended to ease
    the transition from dictionary-based scripts to those requiring persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you forget the key names in a shelf or if you’re using a shelf that you
    didn’t create, you can use the `keys()` method to retrieve the names. Note that
    you need to convert the output into a list with the `list()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**Table 12-10:** Shelve Module Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `close()` | Synchronize and close the shelf object |'
  prefs: []
  type: TYPE_TB
- en: '| `get()` | Return shelf values associated with a key |'
  prefs: []
  type: TYPE_TB
- en: '| `items()` | Return shelf key-value pairs as tuples |'
  prefs: []
  type: TYPE_TB
- en: '| `keys()` | Return list of shelf keys |'
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | Remove specified shelf key and return associated shelf value |'
  prefs: []
  type: TYPE_TB
- en: '| `sync()` | Write back all entries in the cache if shelf was opened with writeback
    set to `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `update()` | Update shelf from another dict or iterable |'
  prefs: []
  type: TYPE_TB
- en: '| `values()` | Return list of shelf values |'
  prefs: []
  type: TYPE_TB
- en: 'Some other methods return an iterable that you can loop over. Here’s an example
    using the `items()` method, which returns the key-value pairs as tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the output yielded an object name, not the key-value pairs that you
    probably expected. To get the key-value tuples, loop over the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about `shelve` and its methods at *[https://docs.python.org/3/library/shelve.html](https://docs.python.org/3/library/shelve.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Storing Data with JSON***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using the `json` module (*[https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html)*),
    you can store data as a single human-readable string. Here’s an example of a Python
    dictionary stored in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '′{″key1″: ″value1″, ″key2″: ″value2″, ″key3″: ″value3″}′'
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks just like a regular Python dictionary except for one thing: it’s enclosed
    in single quotes, making the whole thing a string.'
  prefs: []
  type: TYPE_NORMAL
- en: Compared to `pickle` and `shelve`, the `json` module offers a faster and more
    secure way to store and retrieve complex Python data types. It supports fewer
    data types than `pickle`, however, because it’s limited to dictionaries, lists,
    nulls, Boolean values, numbers (integers and floats), strings, and JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: JSON will also help you access information on the worldwide web. As a lightweight
    data-interchange format that’s easy for humans to read and for machines to parse,
    the application programming interfaces (APIs) for many websites pass data using
    JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: '**Saving Data in JSON Format**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To see how `json` works, let’s create a Python dictionary for the crew capacity
    of three famous spacecraft and save it in JSON format. Enter the following in
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `json.dumps()` method turns the dictionary into a JSON string. You can write
    JSON strings to persistent files using the `open()` function in write mode, as
    you’ve done before. The new *capsules_data.json* file should show up in the Spyder
    File Explorer pane ([Figure 12-5](ch12.xhtml#ch012fig5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/12fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-5: The capsules_data.json file in the File Explorer pane*'
  prefs: []
  type: TYPE_NORMAL
- en: Note how Spyder uses a special icon to denote the file. Because it’s human-readable,
    you can open it and read its contents just like a text file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading Data in JSON Format**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now, let’s open, load, and use the JSON file. We’ll continue to work in the
    console, but this following example could easily be done in a saved program written
    in a text editor or Jupyter Notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '**Saving Tuples in JSON Format**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There is no concept of a tuple in the JSON format. If you save a tuple in JSON
    format, you’ll receive a list. In the console, enter the following to see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In simple cases, you can handle this by converting the output back into a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: For more sophisticated cases, you’ll want to do an online search for using tuples
    with JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '***Catching Exceptions When Opening Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Reading and writing files falls under the category of user interactions, and
    as we saw in [Chapter 10](ch10.xhtml), a lot of things can go wrong when users
    get involved. For working with files, these include trying to open files or use
    paths that don’t exist, trying to open files or folders without the proper permissions,
    trying to open a folder instead of a file, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: These problems can’t be fixed within your code, but you can catch these exceptions
    and provide the user with some helpful advice, rather than allow the program to
    crash and spew gobbledygook all over the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the common file-loading errors fall under the operating system exception
    class called `OSError`. These include the errors shown in [Table 12-11](ch12.xhtml#ch012tab11).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 12-11:** Common Errors Associated with File Loading'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Subclass** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `BlockingIOError` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `ChildProcessError` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `ConnectionError` | `BrokenPipeError` |'
  prefs: []
  type: TYPE_TB
- en: '| `ConnectionError` | `ConnectionAbortedError` |'
  prefs: []
  type: TYPE_TB
- en: '| `ConnectionError` | `ConnectionRefusedError` |'
  prefs: []
  type: TYPE_TB
- en: '| `ConnectionError` | `ConnectionResetError` |'
  prefs: []
  type: TYPE_TB
- en: '| `FileExistsError` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `FileNotFoundError` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `InterruptedError` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `IsADirectoryError` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `NotADirectoryError` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `PermissionError` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `ProcessLookupError` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `TimeOutError` |  |'
  prefs: []
  type: TYPE_TB
- en: Here’s an example in which we use `OSError` to catch the exception thrown by
    a nonexistent file (*fluffybunnyfeet.lol*). For a refresher on using `try` and
    `except`, see [Chapter 10](ch10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `except` clause printed a useful message informing the user that the file
    doesn’t exist (as this was a `FileNotFoundError`). The `finally` clause let the
    user know that the file loading process has terminated. Note that the `finally`
    block executes regardless of the outcome, whereas the `else` code block executes
    only for a successful outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a successful outcome using the *haiku.txt* file that we
    created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: For more on Python’s built-in exceptions, visit the documentation at *[https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html).*
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Storage Solutions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your data is sufficiently complex, it might require more powerful storage
    solutions. The *eXtensible Markup Language (XML)* is designed to store and transport
    small to medium amounts of data and is widely used for sharing structured information.
    *YAML* is another human-readable data-serialization language used for configuration
    files and in applications where data is being stored or transmitted. It has a
    minimal syntax compared to XML. *SQLite* is a lightweight database that can provide
    a relational database management system with zero-configuration. *Hierarchical
    Data Format (HDF5)* is for storing large volumes of scientific array data. Covering
    these storage systems is beyond the scope of this book, but you can find copious
    information for each online.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '11.  True or false: The `shelve` module helps you to store and access pickled
    objects in a file.'
  prefs: []
  type: TYPE_NORMAL
- en: '12.  Of the methods for saving and loading complex data discussed in this chapter,
    the most secure is:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  Pickling
  prefs: []
  type: TYPE_NORMAL
- en: b.  Syncing
  prefs: []
  type: TYPE_NORMAL
- en: c.  JSON format
  prefs: []
  type: TYPE_NORMAL
- en: d.  Shelving
  prefs: []
  type: TYPE_NORMAL
- en: 13.  Rewrite the crew capacity program from the “Storing Data with JSON” section
    of this chapter so that it automatically prints the name of the capsule and the
    grammatically correct version of “seat” (*seat* or *seats*) depending on the number
    of crew members.
  prefs: []
  type: TYPE_NORMAL
- en: 14.  Use the console to investigate how JSON handles quotation marks. Use the
    lists `["don't", "do"]` and `['don\'t', 'do']`.
  prefs: []
  type: TYPE_NORMAL
- en: 15.  Built-in Python exceptions for opening and closing files fall under which
    exception class?
  prefs: []
  type: TYPE_NORMAL
- en: a.  `IOError`
  prefs: []
  type: TYPE_NORMAL
- en: b.  `FileNotFoundError`
  prefs: []
  type: TYPE_NORMAL
- en: c.  `PermissionError`
  prefs: []
  type: TYPE_NORMAL
- en: d.  `OSError`
  prefs: []
  type: TYPE_NORMAL
- en: 16.  Use Python modules to move a copy of the *lines.txt* file to the *test1*
    folder and then archive it as a ZIP file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Files let you save your work—including variables you assign in a program—in
    a persistent and sharable manner. To work with files, you need a base understanding
    of how your computer’s filesystem works, how to manipulate directory paths, and
    how to open, read, and write files.
  prefs: []
  type: TYPE_NORMAL
- en: The *absolute* directory path refers to the full directory path, starting with
    the root directory (such as *C:\* on windows). The *relative* directory is defined
    relative to the current working directory. You can use shortcuts, such as “*.*”
    for the absolute directory and “*.\*” for the current working directory, to make
    working with directories easier.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s built-in `os`, `pathlib`, and `shutil` modules include useful high-level
    methods for working with files and folders. These methods execute without warning,
    however, so you’ll need to be careful when moving, renaming, or deleting data.
  prefs: []
  type: TYPE_NORMAL
- en: Python has other built-in tools for working with human-readable text files.
    To read a file, you first must open it as a file object using the `open()`function.
    Methods such as `read()` and `readlines()` can then be called on this object.
    To write to a file, you must open it in write mode and then call methods like
    `write()` and `writelines()`. To add data to an existing file without overwriting
    its contents, you must open it in append mode.
  prefs: []
  type: TYPE_NORMAL
- en: You should always close files when you’re through with them to release system
    resources and protect the file from being accidently overwritten. You can manually
    close files using the `close()` method, or automatically by opening the file using
    a `with` statement.
  prefs: []
  type: TYPE_NORMAL
- en: More complex data, such as Python dictionaries and lists, can be saved in binary
    format using the `pickle` module, or as human-readable strings using the `json`
    module. The `shelve` module helps you to store and access pickled objects in a
    *shelf* file, which is a persistent, dictionary-like object that assigns each
    pickled object a unique *key* name. Using the JSON format is faster and more secure
    than pickling, but not all Python objects and data types can be stored with JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s important to understand the basic tools for file and folder management
    with Python, if much of your work involves data stored on disk, you’ll want to
    read about the *Python Data Analysis Library*, otherwise known as *pandas*. This
    library contains high-level tools for moving data from disk into Python data structures
    and back again. Many file formats are accommodated, including Excel, CSV, TXT,
    SQL, HTML, JSON, Pickle, and HDF5\. We look at pandas in [Chapters 15](ch15.xhtml)
    and [20](ch20.xhtml).
  prefs: []
  type: TYPE_NORMAL
