<html><head></head><body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_387"/><span class="big">15</span><br/>STRUCTURAL MODELS</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">In this part of the book, we’ll focus on solving truss structures. Truss structures are used to support the roof of industrial warehouses (see <a href="ch15.xhtml#ch15fig1">Figure 15-1</a>) and long-span bridges. This is a real engineering problem that is a good example of building an application that reads data from a file, builds a model out of that data, solves a system of linear equations, and presents the results graphically in a diagram.</p>&#13;
<p class="indent">Since solving truss structures is a big topic, we’ll break it down into several chapters. This first one will give you a rough introduction to the basics of mechanics of materials; it’s not meant to explain the concepts from scratch but should serve as a refresher. Once we’ve gone through the basics, we’ll implement two classes to model truss structures: nodes and bars. As we’ve seen in earlier chapters, the first step of solving a problem in code is to have a set of primitives that represent the entities involved in the solution.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_388"/><img src="../images/15fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig1"><em>Figure 15-1: A warehouse roof is a good example of a truss structure.</em></p>&#13;
<h3 class="h3" id="ch00lev1sec87"><strong>Solving Structural Problems</strong></h3>&#13;
<p class="noindent">Let’s begin with a few definitions. A <em>structure</em> is a set of resistant elements built to withstand the external application of loads, as well as their own weight. A <em>truss structure</em> is a structure in which the resistant elements are bars joined by pins in both ends, and the external forces are applied only where those bars join: at the nodes.</p>&#13;
<p class="indent">When working out a structural problem, we’re most interested in two things. First, can the bars of the structure handle the forces acting on them and avoid collapse? Second, how big are the displacements of the structure once it’s deformed under the action of the external loads? The first is an obvious concern: if any of the bars in the structure break, the structure may collapse, which could have catastrophic consequences (think: collapsing warehouse roofs or bridges). Our analysis should make sure this never happens.</p>&#13;
<p class="indent">The second concern is less obvious, but important nevertheless. If a structure is deformed enough for the naked eye to notice, even if the structure is safe and won’t collapse, people around or below it may get anxious. Think about how you would feel if you saw your living room’s ceiling noticeably curved. Keeping the deformation of the structure between some limits impacts the comfort of its users.</p>&#13;
<p class="indent">The solution we’re after should include the amount of stress on each bar, as well as the global displacements of the structure. We’ll code up the actual solution in the next chapter; here, we’ll define the solution model. We can expect our solution model to include these two quantities: the amount of mechanical stress on each bar and the node displacements.</p>&#13;
<p class="indent">Before we can do that, though, we’ll need to dive into the world of structural analysis. Be prepared to write lots of code. We’re about to solve a serious engineering problem, so the payoff for our hard work will be high.</p>&#13;
<h3 class="h3" id="ch00lev1sec88"><strong>Structural Member Internal Forces</strong></h3>&#13;
<p class="noindent">Let’s begin by quickly recapping how elastic bodies respond to the application of external forces. This is a topic typically taught in mechanics of materials, a classic subject in mechanical engineering courses. If you’ve <span epub:type="pagebreak" id="page_389"/>extensively studied this subject, feel free to skip this section or browse through it as a refresher. If not, this section is for you. Your mechanics knowledge should be enough to follow the text, but we can’t possibly cover everything in detail. You can refer to [3], one of my all-time favorites on the subject. Books on statics also cover this topic with some detail. I recommend you take a look at [9] or [11].</p>&#13;
<h4 class="h4" id="ch00lev2sec156"><strong><em>Elastic Bodies Subject to External Forces</em></strong></h4>&#13;
<p class="noindent">Let’s use an I beam as an example of an elastic body and apply an external system of balanced forces to it. These are forces whose sum equals zero: <img class="inline" src="../images/f00389-p1.jpg" alt="Image"/>. <a href="ch15.xhtml#ch15fig2">Figure 15-2</a> shows the beam.</p>&#13;
<div class="image"><img src="../images/15fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig2"><em>Figure 15-2: A beam subject to external forces</em></p>&#13;
<p class="indent">When external forces are applied to this elastic body, its atoms will fight back in an attempt to preserve the relative distances between themselves. If the external loads want to separate the atoms, they’ll try to hold each other tighter. If they’re pushed together, they’ll try not to get too close. This “fighting back” makes up the <em>internal forces</em>: forces inside the body itself that exist in response to the application of external forces.</p>&#13;
<p class="indent">To study the effects of these forces on the body, let’s take our beam from <a href="ch15.xhtml#ch15fig2">Figure 15-2</a> and virtually cut it with a plane, like in <a href="ch15.xhtml#ch15fig3">Figure 15-3</a>.</p>&#13;
<div class="image"><img src="../images/15fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig3"><em>Figure 15-3: A section of a beam subject to external forces</em></p>&#13;
<p class="indent">Let’s remove the right chunk of the beam and analyze what happens in the left part’s cross section. Since the entire beam was in static equilibrium before we cut it, the left chunk should be in static equilibrium as well. To preserve this equilibrium, we must account for the distribution of internal <span epub:type="pagebreak" id="page_390"/>forces that the now removed right chunk exerted on the left one. These forces appear because the atoms in the left chunk have been separated from their neighbors in the right chunk. The force that pulled them together needs to be added to the cut section so that the atoms stay in the same equilibrium state as before.</p>&#13;
<p class="indent">These forces are distributed over the whole cut surface and represented in <a href="ch15.xhtml#ch15fig4">Figure 15-4</a>.</p>&#13;
<div class="image"><img src="../images/15fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig4"><em>Figure 15-4: Analyzing equilibrium in a section</em></p>&#13;
<p class="indent">The distribution of forces over an area is referred to as <em>stress</em>. The net effect of the stress can be substituted with an equivalent system of a resulting force <img class="inline" src="../images/Rvictor_caps.jpg" alt="Image"/> and moment <img class="inline" src="../images/mvictor.jpg" alt="Image"/>. Each of the components of this equivalent force and moment produces a different effect on the beam. Let’s break the components down.</p>&#13;
<h4 class="h4" id="ch00lev2sec157"><strong><em>Axial and Shear Forces</em></strong></h4>&#13;
<p class="noindent">The equivalent internal force <img class="inline" src="../images/Rvictor_caps.jpg" alt="Image"/> can be broken down into an equivalent system of two forces, one that is normal to the section, <img class="inline" src="../images/RNvictorit_Cap.jpg" alt="Image"/>, and one tangent to it, <img class="inline" src="../images/Rtvictorit_Cap.jpg" alt="Image"/> (see <a href="ch15.xhtml#ch15fig5">Figure 15-5</a>).</p>&#13;
<div class="image"><img src="../images/15fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig5"><em>Figure 15-5: Equivalent internal forces in the section of a beam</em></p>&#13;
<p class="indent">If the elastic body has a prismatic shape (one of its sides is considerably longer than the other two) and we cut a section normal to its directrix, the resulting normal force <img class="inline" src="../images/RNvictorit_Cap.jpg" alt="Image"/> we obtain is referred to as the <em>axial force</em>. The name reflects the fact that this force is aligned with the prism’s main axis or directrix. Prismatic bodies are common in structural analysis; beams and columns are good examples.</p>&#13;
<p class="indent">The axial force can either elongate or compress the body. An axial force that pulls the body apart is called a <em>tension force</em>, whereas one that compresses it is known as a <em>compression force</em>. <a href="ch15.xhtml#ch15fig6">Figure 15-6</a> shows two prismatic bodies subject to these forces.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_391"/><img src="../images/15fig06.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig6"><em>Figure 15-6: Tension and compression forces</em></p>&#13;
<p class="indent">The <em>shear force</em> is the force tangent to the cross section (see <a href="ch15.xhtml#ch15fig7">Figure 15-7</a>) and thus can be further decomposed into two components: <img class="inline" src="../images/rtxvictor_cap.jpg" alt="Image"/> and <img class="inline" src="../images/rtyvictor_cap.jpg" alt="Image"/> (see the diagram on the right of <a href="ch15.xhtml#ch15fig5">Figure 15-5</a>). These two components have the same effect: they try to shear the body apart. <a href="ch15.xhtml#ch15fig7">Figure 15-7</a> shows the effect of shearing forces applied to a prismatic body.</p>&#13;
<div class="image"><img src="../images/15fig07.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig7"><em>Figure 15-7: Shear force</em></p>&#13;
<p class="indent">In summary, the equivalent internal force in a cross section of the body may have a normal component that either elongates or compresses it; it may also have a tangent component that shears it. These are the two ways internal forces can produce deformations on a body.</p>&#13;
<h4 class="h4" id="ch00lev2sec158"><strong><em>Bending and Torsional Moments</em></strong></h4>&#13;
<p class="noindent">We studied the possible effects of the resulting internal force on a given cross section. What effects does the resulting moment produce? As you can see in <a href="ch15.xhtml#ch15fig8">Figure 15-8</a>, the resulting moment <img class="inline" src="../images/mvictor.jpg" alt="Image"/> can be decomposed into a moment normal to the cross section, <img class="inline" src="../images/mnvictorit_cap.jpg" alt="Image"/>, and a moment tangent to it, <img class="inline" src="../images/mtvictorit_cap.jpg" alt="Image"/>.</p>&#13;
<div class="image"><img src="../images/15fig08.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig8"><em>Figure 15-8: Equivalent internal moments in the section of a beam</em></p>&#13;
<p class="indent">These moments bend the body in arbitrary ways, but if we choose a prismatic body and cut it normal to its directrix (the same thing that we did with the forces), the moments we obtain have a predictable and well-defined effect. The moment normal to the surface, <img class="inline" src="../images/mnvictorit_cap.jpg" alt="Image"/>, generates a torsional (twisting) effect on the prism and thus receives the name of <em>torsional moment</em>.</p>&#13;
<p class="indent">Once again, the moment tangent to the section can be further broken down into two subcomponents: <img class="inline" src="../images/mtxvictorit_cap.jpg" alt="Image"/> and <img class="inline" src="../images/mtyvictorit_cap.jpg" alt="Image"/> (see the right illustration in <span epub:type="pagebreak" id="page_392"/><a href="ch15.xhtml#ch15fig8">Figure 15-8</a>). These two moments have a similar effect: they bend the prism and hence are called <em>bending moments</em>. <a href="ch15.xhtml#ch15fig9">Figure 15-9</a> illustrates this effect.</p>&#13;
<div class="image"><img src="../images/15fig09.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig9"><em>Figure 15-9: Bending moment</em></p>&#13;
<p class="indent">To summarize, the equivalent internal moment on a cross section of the body may have a normal component that tends to twist it around its directrix (the torsional moment) and may also have two tangent moments that tend to bend the prism (the bending moments).</p>&#13;
<p class="indent">Let’s now analyze in detail how prismatic bars behave when subject to axial forces. Then, we’ll see how, by using a group of these resistant prisms, we can build structures that can withstand the application of heavy loads.</p>&#13;
<h3 class="h3" id="ch00lev1sec89"><strong>Tension and Compression</strong></h3>&#13;
<p class="noindent">Let’s focus our analysis on axial forces: those aligned with the axis of a prismatic resistant body. As we’ll see in the next section, the structures we’ll solve are made of only prismatic elements (bars) subject to axial forces.</p>&#13;
<h4 class="h4" id="ch00lev2sec159"><strong><em>Hooke’s Law</em></strong></h4>&#13;
<p class="noindent">It’s been experimentally proven that within some limits, the elongation of a prismatic bar is proportional to the axial force applied to it. This linear relation is known as <em>Hooke’s law</em>. Let’s suppose a bar with length <em>l</em> and cross section <em>A</em> is subject to a pair of external forces <img class="inline" src="../images/fvictorit.jpg" alt="Image"/> and –<img class="inline" src="../images/fvictorit.jpg" alt="Image"/>, like in <a href="ch15.xhtml#ch15fig10">Figure 15-10</a>.</p>&#13;
<div class="image"><img src="../images/15fig10.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig10"><em>Figure 15-10: A bar subject to axial forces</em></p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15eqa01">Equation 15.1</a> gives Hooke’s law.</p>&#13;
<div class="equationc" id="ch15eqa01"><img src="../images/15eqa01.jpg" alt="Image"/></div>&#13;
<p class="noindent">In this equation,</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><em>δ</em>    is the total elongation of the bar.</p>&#13;
<p class="noindentin"><em>F</em>    is the <img class="inline" src="../images/fvictorit.jpg" alt="Image"/> force’s magnitude.</p>&#13;
<p class="noindentin"><em>E</em>    is the proportionality constant or Young’s modulus, which is specific to the material.</p>&#13;
</div>&#13;
<p class="indent">Hooke’s law states that the total elongation <em>δ</em> of a bar subject to a pair of external forces is (1) directly proportional to the magnitude of the forces <span epub:type="pagebreak" id="page_393"/>and the bar’s length and is (2) inversely proportional to its cross section and Young’s modulus. The longer a bar or the stronger the force applied is, the greater the elongation produced will be. Conversely, the bigger the cross section values are or Young’s modulus is, the smaller the elongation will be.</p>&#13;
<p class="indent">Recall that when a force is distributed over an area, the intensity of such force per unit area is known as <em>stress</em>. Stress is usually denoted by the Greek letter <em>σ</em> (see <a href="ch15.xhtml#ch15eqa02">Equation 15.2</a>).</p>&#13;
<div class="equationc" id="ch15eqa02"><img src="../images/15eqa02.jpg" alt="Image"/></div>&#13;
<p class="indent">By convention, the stress is positive for tensile forces and negative for compression forces. The stress is a useful quantity in mechanical design; it’s used to determine whether a given component (in a structure or machine, for example) will break down during operation. The stress values a given material can undergo before failure are well studied.</p>&#13;
<p class="indent">We define <em>strain</em> as the elongation per unit length, a dimensionless quantity denoted by the Greek letter <em>ϵ</em> (see <a href="ch15.xhtml#ch15eqa03">Equation 15.3</a>).</p>&#13;
<div class="equationc" id="ch15eqa03"><img src="../images/15eqa03.jpg" alt="Image"/></div>&#13;
<p class="indent">Using the equations for the stress and strain, Hooke’s law from <a href="ch15.xhtml#ch15eqa01">Equation 15.1</a> can be rewritten as shown in <a href="ch15.xhtml#ch15eqa04">Equation 15.4</a>.</p>&#13;
<div class="equationc" id="ch15eqa04"><img src="../images/15eqa04.jpg" alt="Image"/></div>&#13;
<p class="indent">Interestingly, by introducing stress and strain, the relation between the external actions applied to a resistant body (forces) and their effects (elongations) no longer depends on the area or length of the body. We’ve effectively removed all dimensional parameters from the equation. The proportionality constant in <a href="ch15.xhtml#ch15eqa04">Equation 15.4</a> (<em>E</em>) is Young’s modulus, which is a characteristic of materials. For structural steels, for example, <em>E</em> is around 200 GPa, that is, 200 ⋅ 10<sup>9</sup> <em>Pa</em>. We can therefore predict the mechanical behavior of bodies by applying experimental results obtained for the material in use. To do this, we use <em>stress-strain diagrams</em>, which plot the stress versus the strain for a given material.</p>&#13;
<h4 class="h4" id="ch00lev2sec160"><strong><em>Stress-Strain Diagrams</em></strong></h4>&#13;
<p class="noindent">Stress-strain diagrams plot the stress versus the strain for a given material and are obtained by performing tension or compression tests (see [3] for more details). We use these diagrams to predict the behavior of resistant bodies made of the same material. Recall that since we introduced the quantities stress and strain, every dimensional term has disappeared from Hooke’s equation, meaning that once we’ve experimentally determined the strain and stress a material undergoes under a given load, we can use those results for any bodies made of the same material, regardless of their shape or size.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15fig11">Figure 15-11</a> is a plot of the approximate stress-strain diagram for structural steels. Note this graph is not to scale.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_394"/><img src="../images/15fig11.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig11"><em>Figure 15-11: The stress-strain diagram for structural steel</em></p>&#13;
<p class="indent">This diagram has an initial linear region that holds up to a given stress value known as the <em>proportional limit</em>, depicted by point A. For stress values greater than the proportionality limit, the stress-strain relation is no longer linear. The proportional limit is typically between 210 MPa and 350 MPa for structural steels—three orders of magnitude smaller than Young’s modulus. This region is modeled by Hooke’s law and the linear relation <em>σ</em> = <em>Eϵ</em>. We’ll center our analysis here.</p>&#13;
<p class="indent">With a small stress increment after A, the proportional limit, we reach point B, the <em>yield stress</em> or <em>yield strength</em>. After the yield stress, big elongations happen without an increase in the stress. This phenomenon is called the <em>yielding</em> of the material.</p>&#13;
<p class="indent">After a noticeable amount of strain, we reach point C, and the material appears to harden. The stress must continue to increase to reach point D, which is the maximum amount of stress structural steel can withstand. We call this stress value the <em>ultimate stress</em> or <em>ultimate strength</em>. From this point, the material will acquire bigger strains with a reduction in the stress value.</p>&#13;
<p class="indent">The point E is where the material fractures. The amount of strain the material can take before it fractures can be called the <em>fracture strain</em>. This is the point of complete mechanical failure, but if you think about it, after the ultimate stress is reached (point D), it’s likely that the material will fracture anyway. The ultimate stress is typically used as the maximum value of stress a given material can absorb before failure.</p>&#13;
<p class="indent">Now that we have a good understanding of how resistant bodies respond to tensile stresses, let’s look at truss structures.</p>&#13;
<h3 class="h3" id="ch00lev1sec90"><strong>Plane Trusses</strong></h3>&#13;
<p class="noindent">There are many structural typologies, but we’ll focus our analysis on the simplest of them: plane trusses.</p>&#13;
<p class="indent">A <em>plane truss</em> structure is a structure contained in a plane whose resistant bodies are bars subject only to axial forces and whose own weight can be ignored. There are two conditions that allow this.</p>&#13;
<ul>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_395"/>Bars must be joined by pins at their ends.</li>&#13;
<li class="noindent">External loads must always be applied to nodes.</li>&#13;
</ul>&#13;
<p class="indent">A <em>node</em> is the point where several bar ends meet. Nodes join bar ends together in frictionless unions, meaning the rotation of the bars around the node is not constrained.</p>&#13;
<p class="indent">Plane trusses are made of triangles: three bars pinned at their ends. The triangle is the simplest rigid frame; bars joined to form a polygon of four or more sides form nonrigid frames. <a href="ch15.xhtml#ch15fig12">Figure 15-12</a> shows how a plane truss made of four bars can be moved from its original position and thus isn’t considered rigid. Simply by adding a new bar and creating two subtriangles, the structure becomes rigid.</p>&#13;
<div class="image"><img src="../images/15fig12.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig12"><em>Figure 15-12: Example of a polygonal plane truss</em></p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15fig13">Figure 15-13</a> is an example of a plane truss. The structure is made of eight nodes (N1, N2, . . . , N8) and thirteen bars. Nodes 1 and 5 have external supports or constraints applied. Nodes 6, 7, and 8 have external loads applied to them.</p>&#13;
<div class="image"><img src="../images/15fig13.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig13"><em>Figure 15-13: A plane truss structure</em></p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15fig14">Figure 15-14</a> is the diagram resulting from the structural analysis of the plane truss described in <a href="ch15.xhtml#ch15fig13">Figure 15-13</a>. It was produced by the very application we’ll build in this part of the book.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_396"/><img src="../images/15fig14.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig14"><em>Figure 15-14: A plane truss structure solution diagram</em></p>&#13;
<p class="indent">In this diagram, we can appreciate the structure’s deformed geometry because it has been scaled to be noticeable. Node displacements tend to be very small (around two orders of magnitude smaller than the dimension of the structural bars), so a diagram depicting the nonscaled node displacements may be hard to tell apart from the original geometry.</p>&#13;
<p class="indent">You’ll notice there’s a lot of information in <a href="ch15.xhtml#ch15fig14">Figure 15-14</a>. Every bar is labeled with the stress it’s subject to, though the font size of the labels in this figure is small, so the labels may not be easy to read. Positive numbers are tension stresses, and negative are compression. The bars are also colored in green or red depending on the load they’re subject to: green for tension and red for compression. Since the book is printed in black and white, you won’t be able to tell the colors apart, but once you’ve developed the complete application, you’ll produce the figure with your own code and will be able to explore all the details in it.</p>&#13;
<p class="indent">Let’s now study the mechanical response of the bars that make up plane trusses. They have an interesting particularity we’ve already mentioned: they develop axial stresses only.</p>&#13;
<h3 class="h3" id="ch00lev1sec91"><strong>Two-Force Members</strong></h3>&#13;
<p class="noindent">As we’ve already discussed, plane truss bars are pinned at their ends, and loads are always applied at the nodes; because of this, the bars are subject only to axial forces. We can apply an external force only to the ends of the bar, using the contact of the pinned joint with the node. Because these unions are frictionless, they can only transmit forces to bars and just in the direction of the bar’s directrix.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15fig15">Figure 15-15</a> shows how an external force applied to a node is transferred to the bars. These forces are aligned with the bars’ directrices and thus produce axial stresses only.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_397"/><img src="../images/15fig15.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig15"><em>Figure 15-15: The transmission of forces in a node</em></p>&#13;
<p class="indent">Since bars have two pinned ends where external forces are applied, they are subject to two forces. To be in equilibrium, such a body requires the two forces to be collinear, equal in magnitude and with opposite directions. In the case of a bar (a long prismatic body), these two forces have to be in the direction of the bar’s directrix (<a href="ch15.xhtml#ch15fig16">Figure 15-16</a>) and, hence, produce axial stresses only. We call these bars with two collinear forces applied <em>two-force members</em> (see <a href="ch15.xhtml#ch15fig16">Figure 15-16</a>).</p>&#13;
<div class="image"><img src="../images/15fig16.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig16"><em>Figure 15-16: A two-force member</em></p>&#13;
<p class="indent">The forces applied to the bar in <a href="ch15.xhtml#ch15fig16">Figure 15-16</a> are labeled <img class="inline" src="../images/fvictorit.jpg" alt="Image"/> and –<img class="inline" src="../images/fvictorit.jpg" alt="Image"/> to signify that the two forces must be equal in magnitude and point in opposite directions. In this case, the forces would produce tension stresses on the bar.</p>&#13;
<p class="indent">Thanks to Hooke’s law, we know how materials respond to the external application of loads. We’ve also explored two-force members, and we’ve seen that the bars in plane trusses are two-force members. Let’s now derive a set of equations to relate these two forces with the displacements they produce on such two-force members.</p>&#13;
<h3 class="h3" id="ch00lev1sec92"><strong>Stiffness Matrices in Global Coordinates</strong></h3>&#13;
<p class="noindent">Going back to the original formulation of Hooke’s law in <a href="ch15.xhtml#ch15eqa01">Equation 15.1</a>, we can isolate the force term to get the following:</p>&#13;
<div class="equationc"><img src="../images/f0397-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Here, the term <img class="inline" src="../images/f00397-p1.jpg" alt="Image"/> is the bar’s proportionality constant relating the force applied, <em>F</em>, with the elongation it produces, <em>δ</em>. This term also receives the name <em>stiffness</em>. As you can see, the stiffness depends on the bar’s Young’s modulus (<em>E</em>), which is material dependent, and geometry (<em>A</em> and <em>l</em>).</p>&#13;
<p class="indent">Now look at the bar in <a href="ch15.xhtml#ch15fig17">Figure 15-17</a>. If we consider a local system of reference whose x-axis is aligned with the bar directrix, this bar has two <em>degrees of freedom (DOF)</em>, in other words, two different ways it can independently move. These are the displacements in the local x-axis of both nodes, denoted by <img class="inline" src="../images/f00397-p2.jpg" alt="Image"/> and <img class="inline" src="../images/f00397-p3.jpg" alt="Image"/>. Each node has a force applied: <em>F</em><sub>1</sub> and <em>F</em><sub>2</sub>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_398"/><em>A note on the nomenclature: we’ll use primes to label DOFs referred to by the bar’s local system of coordinates. For example,</em> <img class="inline" src="../images/ui1victor.jpg" alt="Image"/> <em>refers to the</em> x <em>displacement of the node 1 referred to the bar’s local system of reference:</em> (x<sup>′</sup>,y<sup>′</sup>)<em>. By contrast, nonprime values, such as</em> u<sub>1</sub><em>, are referred to the global system of reference:</em> (x,y).</p>&#13;
</div>&#13;
<div class="image"><img src="../images/15fig17.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig17"><em>Figure 15-17: A bar with two degrees of freedom</em></p>&#13;
<p class="indent">Using the previous equation, we can relate the force in each node to the displacements <img class="inline" src="../images/f00397-p2.jpg" alt="Image"/> and <img class="inline" src="../images/f00397-p3.jpg" alt="Image"/> like so:</p>&#13;
<div class="equationc"><img src="../images/f0398-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">The two equations above can be written in matrix notation (<a href="ch15.xhtml#ch15eqa05">Equation 15.5</a>),</p>&#13;
<div class="equationc" id="ch15eqa05"><img src="../images/15eqa05.jpg" alt="Image"/></div>&#13;
<p class="noindent">where [<em>k</em><sup>′</sup>] is referred to as the local <em>stiffness matrix</em> for the bar. This stiffness matrix relates the displacements in the two nodes of the bar with the external forces applied to them, all in the bar’s local system of reference. Using this local system of reference, the bar has only two degrees of freedom, which are the displacements of each of the two nodes in the local x-axis direction (<img class="inline" src="../images/f00397-p2.jpg" alt="Image"/> and <img class="inline" src="../images/f00397-p3.jpg" alt="Image"/>).</p>&#13;
<p class="indent">Let’s now consider a bar rotated with respect to the global system of coordinates. Take <a href="ch15.xhtml#ch15fig18">Figure 15-18</a> as an example. This bar has its own local system of reference (<em>x</em><sup>′</sup>, <em>y</em><sup>′</sup>), which forms an angle of <em>θ</em> with respect to the global system of reference (<em>x,y</em>).</p>&#13;
<div class="image"><img src="../images/15fig18.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig18"><em>Figure 15-18: A bar’s local reference frame</em></p>&#13;
<p class="indent">From the global system of reference’s perspective, each node of the bar has two degrees of freedom: each node can move in both the x and y directions. <span epub:type="pagebreak" id="page_399"/>Projected in this system of reference, the four DOFs are <em>u</em><sub>1</sub>, <em>v</em><sub>1</sub>, <em>u</em><sub>2</sub>, and <em>v</em><sub>2</sub>.</p>&#13;
<p class="indent">To transform the bar’s local stiffness matrix [<em>k</em><sup>′</sup>] into a global [<em>k</em>] stiffness matrix, we have to apply a transformation matrix. We can find such a matrix by breaking down the local displacements <img class="inline" src="../images/f00397-p2.jpg" alt="Image"/> and <img class="inline" src="../images/f00397-p3.jpg" alt="Image"/> into their global components. <a href="ch15.xhtml#ch15fig19">Figure 15-19</a> shows this operation.</p>&#13;
<div class="image"><img src="../images/15fig19.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig19"><em>Figure 15-19: The local displacement projections</em></p>&#13;
<p class="indent">Let’s find a mathematical expression to compute the global displacements based on their local counterparts:</p>&#13;
<div class="equationc"><img src="../images/f0399-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Written in its matrix form, it looks like</p>&#13;
<div class="equationc"><img src="../images/f0399-02.jpg" alt="Image"/></div>&#13;
<p class="noindent">where [<em>L</em>] is the transformation matrix. To compute the global stiffness matrix from the local [<em>k</em><sup>′</sup>], we can use the following equation (refer to [2] or [10] for the details on how to derive this expression),</p>&#13;
<p class="noindentc">[<em>k</em>] = [<em>L</em>]<sup>′</sup>[<em>k</em>]<sup>′</sup>[<em>L</em>]</p>&#13;
<p class="noindent">which, shortening the notation to <em>c</em> = cos<em>θ</em> and <em>s</em> = sin<em>θ</em>, yields <a href="ch15.xhtml#ch15eqa06">Equation 15.6</a>.</p>&#13;
<div class="equationc" id="ch15eqa06"><img src="../images/15eqa06.jpg" alt="Image"/></div>&#13;
<p class="indent">We now have a system of equations that relates the external forces applied to a bar’s nodes to their displacements in global coordinates (see <a href="ch15.xhtml#ch15eqa07">Equation 15.7</a>).</p>&#13;
<div class="equationc" id="ch15eqa07"><img src="../images/15eqa07.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_400"/>Let’s now use this knowledge to start building our structural model in code.</p>&#13;
<h3 class="h3" id="ch00lev1sec93"><strong>Original Structure Model</strong></h3>&#13;
<p class="noindent">In our <em>Mechanics</em> project, create a new Python package named <em>structures</em>. In <em>structures</em>, create another package: <em>model</em>. Here’s where we’ll define the classes that make up the structural model. Create another package in <em>structures</em> named <em>solution</em>. This is where we’ll have the classes that model the resolved structure. Also create a <em>tests</em> folder in <em>structures</em> to contain the unit tests we’ll develop. Your project’s structure should look something like this:</p>&#13;
<p class="pre2">    Mechanics<br/>      |- apps<br/>      |- eqs<br/>      |- geom2d<br/>      |- graphic<br/>      |- structures<br/>      |    |- model<br/>      |    |   |- __init__.py<br/>      |    |- solution<br/>      |    |   |- __init__.py<br/>      |    |- tests<br/>      |    |   |- __init__.py<br/>      |    |- __init__.py<br/>      |- utils</p>&#13;
<p class="indent">The next step is to create a class that represents structural nodes.</p>&#13;
<h4 class="h4" id="ch00lev2sec161"><strong><em>The Node Class</em></strong></h4>&#13;
<p class="noindent">Create a new file in <em>model</em> named <em>node.py</em> and enter the code in <a href="ch15.xhtml#ch15lis1">Listing 15-1</a>. This is the basic definition for a structural node.</p>&#13;
<pre>import operator&#13;
from functools import reduce&#13;
&#13;
from geom2d import Point, Vector&#13;
&#13;
&#13;
class StrNode:&#13;
&#13;
    def __init__(&#13;
        self,&#13;
     <span class="ent">➊</span> _id: int,&#13;
        position: Point,&#13;
        loads=None,&#13;
        dx_constrained=False,&#13;
        dy_constrained=False&#13;
    <span epub:type="pagebreak" id="page_401"/>):&#13;
        self.id = _id&#13;
        self.position = position&#13;
     <span class="ent">➋</span> self.loads = loads or []&#13;
        self.dx_constrained = dx_constrained&#13;
        self.dy_constrained = dy_constrained&#13;
&#13;
    @property&#13;
    def loads_count(self):&#13;
        return len(self.loads)&#13;
&#13;
    @property&#13;
    def net_load(self):&#13;
     <span class="ent">➌</span> return reduce(&#13;
            operator.add,&#13;
            self.loads,&#13;
            Vector(0, 0)&#13;
        )</pre>&#13;
<p class="caption"><a id="ch15lis1"/><em>Listing 15-1: Structure node class</em></p>&#13;
<p class="indent">In this listing, we define the new class <span class="literal">StrNode</span>. This class defines an <span class="literal">id</span>, which will serve to identify each of its instances.</p>&#13;
<p class="indent">Note that the parameter passed to the constructor uses an underscore: <span class="literal">_id</span> <span class="ent">➊</span>. Python already has an <span class="literal">id</span> global function defined, so if we named our parameter the same (instead of using the underscore), we’d be shadowing the global <span class="literal">id</span> function definition inside the constructor. This means <span class="literal">id</span> wouldn’t refer to Python’s function inside the constructor but to our passed-in value instead. Although we’re not using Python’s <span class="literal">id</span> function inside this class’s constructor, we’ll try to avoid shadowing global functions.</p>&#13;
<p class="indent">The <span class="literal">StrNode</span> also includes an instance of the <span class="literal">Point</span> class that determines the node’s position and a list of loads applied to the node with a default value of <span class="literal">None</span>. The structure may have quite a few nodes without external loads applied to them; thus, we make the <span class="literal">loads</span> argument optional (and provide a default value of <span class="literal">None</span>). When the <span class="literal">loads</span> argument is <span class="literal">None</span>, we assign the <span class="literal">self.loads</span> attribute an empty list (<span class="literal">[]</span>) <span class="ent">➋</span>.</p>&#13;
<p class="indent">You might be wondering how the <span class="literal">or</span> operator works in <span class="ent">➋</span>:</p>&#13;
<pre>self.loads = loads or []</pre>&#13;
<p class="noindent">The <span class="literal">or</span> operator returns the first “truthy” value from its operands or <span class="literal">None</span>. Take a look at the following examples:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">'Hello' or 'Good bye'</span>&#13;
'Hello'&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">None or 'Good bye'</span>&#13;
'Good bye'&#13;
&#13;
<span epub:type="pagebreak" id="page_402"/>&gt;&gt;&gt; <span class="codestrong1">False or True</span>&#13;
True&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">False or 'Hello'</span>&#13;
'Hello'&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">False or None</span>&#13;
# nothing returned here&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">False or None or 'Hi'</span>&#13;
'Hi'</pre>&#13;
<p class="noindent">As you might have guessed, in a boolean context, <span class="literal">None</span> is evaluated as “falsy.”</p>&#13;
<p class="indent">There are two more attributes that we have to pass the constructor; these are given a default value in the constructor: <span class="literal">dx_constrained</span> and <span class="literal">dy_constrained</span>. These attributes determine whether the displacements in the x and y directions are externally constrained. We initialize them as <span class="literal">False</span>, which means the node isn’t externally constrained unless we say otherwise.</p>&#13;
<p class="indent">We’ve defined two properties in the class: <span class="literal">loads_count</span> and <span class="literal">net_load</span>. The first, <span class="literal">loads_count</span>, simply returns the length of the <span class="literal">loads</span> list.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you remember the law of Demeter from <a href="ch05.xhtml#ch05">Chapter 5</a>, anyone from outside the</em> <span class="literal">StrNode</span> <em>class who wants to know the number of loads applied to the node should be able to ask</em> <span class="literal">StrNode</span> <em>directly. But asking</em> <span class="literal">StrNode</span> <em>to return the list of loads and then use the</em> <span class="literal">len</span> <em>function to get its length would violate this important principle.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">net_load</span> property uses <span class="literal">reduce</span> to compute the sum of all the loads <span class="ent">➌</span>. Note that we’re passing in a third argument to the <span class="literal">reduce</span> function: <span class="literal">Vector(0, 0)</span>. This third argument is the initial value for the reduction. In the perfectly valid case that the list of loads is empty, we’ll return this initial value. Otherwise, the first step in the reduction process will combine this initial value with the list’s first item. If we didn’t provide an initial value, reducing the loads list would raise the following error:</p>&#13;
<pre>TypeError: reduce() of empty sequence with no initial value</pre>&#13;
<p class="indent">Next, we’ll add a method to add loads to the node’s list of loads; enter the method in <a href="ch15.xhtml#ch15lis2">Listing 15-2</a>.</p>&#13;
<pre>class StrNode:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def add_load(self, load: Vector):&#13;
       self.loads.append(load)</pre>&#13;
<p class="caption"><a id="ch15lis2"/><em>Listing 15-2: Adding loads to the node</em></p>&#13;
<p class="indent">Lastly, let’s implement the equality comparison for the <span class="literal">StrNode</span> class. There are a few attributes in the class, but we’ll consider two nodes equal <span epub:type="pagebreak" id="page_403"/>only if they are located at equal positions in the plane. This comparison deems overlapping nodes to be equal, regardless of their other attributes.</p>&#13;
<p class="indent">If we want nodes in a structure to be truly unique, we could rely on an equality comparison that compares all of the attributes of a node, including the list of loads and external constraints. In our case, we’re interested only in making sure that we have no overlapping nodes, though. If we included more fields in the equality check, it could happen that two overlapping nodes (nodes with the same position) were evaluated as different because they have a different list of loads. We’d be allowing two overlapping nodes to exist in the structure.</p>&#13;
<p class="indent">Enter the <span class="literal">__eq__</span> method implementation in <a href="ch15.xhtml#ch15lis3">Listing 15-3</a>.</p>&#13;
<pre>class StrNode:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, StrNode):&#13;
            return False&#13;
&#13;
        return self.position == other.position</pre>&#13;
<p class="caption"><a id="ch15lis3"/><em>Listing 15-3: Nodes equality</em></p>&#13;
<p class="indent">Our <span class="literal">StrNode</span> class is now ready! <a href="ch15.xhtml#ch15lis4">Listing 15-4</a> contains the resulting <span class="literal">StrNode</span> class.</p>&#13;
<pre>import operator&#13;
from functools import reduce&#13;
&#13;
from geom2d import Point, Vector&#13;
&#13;
&#13;
class StrNode:&#13;
&#13;
    def __init__(&#13;
            self,&#13;
            _id: int,&#13;
            position: Point,&#13;
            loads=None,&#13;
            dx_constrained=False,&#13;
            dy_constrained=False&#13;
    ):&#13;
        self.id = _id&#13;
        self.position = position&#13;
        self.loads = loads or []&#13;
        self.dx_constrained = dx_constrained&#13;
        <span epub:type="pagebreak" id="page_404"/>self.dy_constrained = dy_constrained&#13;
&#13;
    @property&#13;
    def loads_count(self):&#13;
        return len(self.loads)&#13;
&#13;
    @property&#13;
    def net_load(self):&#13;
        return reduce(&#13;
            operator.add,&#13;
            self.loads,&#13;
            Vector(0, 0)&#13;
        )&#13;
&#13;
    def add_load(self, load: Vector):&#13;
        self.loads.append(load)&#13;
&#13;
    def __eq__(self, other):&#13;
        if self is other:&#13;
            return True&#13;
&#13;
        if not isinstance(other, StrNode):&#13;
            return False&#13;
&#13;
        return self.position == other.position</pre>&#13;
<p class="caption"><a id="ch15lis4"/><em>Listing 15-4: Node class result</em></p>&#13;
<p class="indent">Let’s now implement a class to represent structural bars.</p>&#13;
<h4 class="h4" id="ch00lev2sec162"><strong><em>The Bar Class</em></strong></h4>&#13;
<p class="noindent">Structural bars are defined between two nodes modeled by the <span class="literal">StrNode</span> class. Bars need to store values for the two resistant properties required for the stiffness matrix calculation (<a href="ch15.xhtml#ch15eqa06">Equation 15.6</a>): the Young’s modulus and cross section.</p>&#13;
<h5 class="h5" id="ch00lev3sec72"><strong>Implementing the Bar Class</strong></h5>&#13;
<p class="noindent">In <em>model</em> create a new file named <em>bar.py</em> and enter the initial definition for the <span class="literal">StrBar</span> class (<a href="ch15.xhtml#ch15lis5">Listing 15-5</a>).</p>&#13;
<pre>from geom2d import Segment&#13;
from .node import StrNode&#13;
&#13;
&#13;
class StrBar:&#13;
&#13;
    def __init__(&#13;
            self,&#13;
            <span epub:type="pagebreak" id="page_405"/>_id: int,&#13;
            start_node: StrNode,&#13;
            end_node: StrNode,&#13;
            cross_section: float,&#13;
            young_mod: float&#13;
    ):&#13;
        self.id = _id&#13;
        self.start_node = start_node&#13;
        self.end_node = end_node&#13;
        self.cross_section = cross_section&#13;
        self.young_mod = young_mod&#13;
&#13;
    @property&#13;
    def geometry(self):&#13;
        return Segment(&#13;
            self.start_node.position,&#13;
            self.end_node.position&#13;
        )&#13;
&#13;
    @property&#13;
    def length(self):&#13;
        return self.geometry.length</pre>&#13;
<p class="caption"><a id="ch15lis5"/><em>Listing 15-5: Structure bar class</em></p>&#13;
<p class="indent">In this listing we define the <span class="literal">StrBar</span> class with five attributes: the ID that serves as identifier, the start and end nodes, the cross section value, and the Young’s modulus value. These are passed in to the constructor and stored inside the class.</p>&#13;
<p class="indent">We also define two properties using the <span class="literal">@property</span> decorator: <span class="literal">geometry</span> and <span class="literal">length</span>. The geometry of the bar is a segment going from the start node position to the end node position, and the length of the bar is this segment’s length.</p>&#13;
<p class="indent">The last thing we need to implement is a method to compute the bar’s stiffness matrix in global coordinates as defined in <a href="ch15.xhtml#ch15eqa06">Equation 15.6</a>. Enter the method in <a href="ch15.xhtml#ch15lis6">Listing 15-6</a>.</p>&#13;
<pre><span class="codestrong1">from eqs import Matrix</span>&#13;
from geom2d import Segment&#13;
from .node import StrNode&#13;
&#13;
&#13;
class StrBar:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def global_stiffness_matrix(self) -&gt; Matrix:&#13;
        direction = self.geometry.direction_vector&#13;
        eal = self.young_mod * self.cross_section / self.length&#13;
        c = direction.cosine&#13;
        <span epub:type="pagebreak" id="page_406"/>s = direction.sine&#13;
&#13;
        c2_eal = (c ** 2) * eal&#13;
        s2_eal = (s ** 2) * eal&#13;
        sc_eal = (s * c) * eal&#13;
&#13;
        return Matrix(4, 4).set_data([&#13;
            c2_eal, sc_eal, -c2_eal, -sc_eal,&#13;
            sc_eal, s2_eal, -sc_eal, -s2_eal,&#13;
            -c2_eal, -sc_eal, c2_eal, sc_eal,&#13;
            -sc_eal, -s2_eal, sc_eal, s2_eal&#13;
        ])</pre>&#13;
<p class="caption"><a id="ch15lis6"/><em>Listing 15-6: Bar stiffness matrix in global coordinates</em></p>&#13;
<p class="indent">Don’t forget to import <span class="literal">Matrix</span>, shown here:</p>&#13;
<pre>from eqs import Matrix</pre>&#13;
<p class="indent">We’ve added the <span class="literal">global_stiffness_matrix</span> method. This method creates a 4 × 4 matrix and sets its values to the appropriate stiffness terms as given in <a href="ch15.xhtml#ch15eqa06">Equation 15.6</a> and repeated here for convenience:</p>&#13;
<div class="equationc"><img src="../images/f0406-01.jpg" alt="Image"/></div>&#13;
<p class="indent">To compute each of the values, we first get the bar geometry’s direction vector and get its sine and cosine. Because every term in [<em>k</em>] is multiplied by <img class="inline" src="../images/f00397-p1.jpg" alt="Image"/>, we compute it and store the result in the <span class="literal">eal</span> variable. From the sixteen terms in the matrix, there are really only three different values we need to compute. These are stored in <span class="literal">c2_eal</span>, <span class="literal">s2_eal</span>, and <span class="literal">sc_eal</span>, and they are later referenced in the <span class="literal">set_data</span> method.</p>&#13;
<h5 class="h5" id="ch00lev3sec73"><strong>Testing the Bar Class</strong></h5>&#13;
<p class="noindent">The stiffness matrix computation is core to our structural analysis problem; a bug in this code would result in completely incorrect results, like, for instance, huge deformations in the bars. Let’s add a unit test to make sure all the terms in the stiffness matrix are computed correctly. We first need to create a new test file in the <em>structures/tests</em> directory named <em>bar_test.py</em>. In the file, enter the code in <a href="ch15.xhtml#ch15lis7">Listing 15-7</a>.</p>&#13;
<pre>import unittest&#13;
from math import sqrt&#13;
&#13;
from eqs import Matrix&#13;
from geom2d import Point&#13;
from structures.model.node import StrNode&#13;
from structures.model.bar import StrBar&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_407"/>class BarTest(unittest.TestCase):&#13;
    section = sqrt(5)&#13;
    young = 5&#13;
&#13;
    node_a = StrNode(1, Point(0, 0))&#13;
    node_b = StrNode(2, Point(2, 1))&#13;
    bar = StrBar(1, node_a, node_b, section, young)&#13;
&#13;
    def test_global_stiffness_matrix(self):&#13;
        expected = Matrix(4, 4).set_data([&#13;
            4, 2, -4, -2,&#13;
            2, 1, -2, -1,&#13;
            -4, -2, 4, 2,&#13;
            -2, -1, 2, 1&#13;
        ])&#13;
        actual = self.bar.global_stiffness_matrix()&#13;
        self.assertEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch15lis7"/><em>Listing 15-7: Testing the bar’s stiffness matrix</em></p>&#13;
<p class="indent">In this test we create a bar with nodes located at (0, 0) and (2, 1), a section of <img class="inline" src="../images/f00407-p1.jpg" alt="Image"/>, and a Young’s modulus of 5. We chose these numbers so all the values in the expected stiffness matrix would be integers, which makes it convenient for us to write the assertion, particularly in this case: <img class="inline" src="../images/f00407-p2.jpg" alt="Image"/>, <img class="inline" src="../images/f00407-p3.jpg" alt="Image"/>, and <img class="inline" src="../images/f00407-p4.jpg" alt="Image"/>.</p>&#13;
<p class="indent">You can run the test from the IDE by clicking the green play button or from the shell.</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest structures/tests/bar_test.py</span></pre>&#13;
<p class="noindent">This should produce the following output:</p>&#13;
<pre>Ran 1 test in 0.000s&#13;
&#13;
OK</pre>&#13;
<p class="indent">Your <span class="literal">StrBar</span> class should look similar to <a href="ch15.xhtml#ch15lis8">Listing 15-8</a>.</p>&#13;
<pre>from eqs import Matrix&#13;
from geom2d import Segment&#13;
from .node import StrNode&#13;
&#13;
&#13;
class StrBar:&#13;
&#13;
    def __init__(&#13;
            self,&#13;
            <span epub:type="pagebreak" id="page_408"/>_id: int,&#13;
            start_node: StrNode,&#13;
            end_node: StrNode,&#13;
            cross_section: float,&#13;
            young_mod: float&#13;
    ):&#13;
        self.id = _id&#13;
        self.start_node = start_node&#13;
        self.end_node = end_node&#13;
        self.cross_section = cross_section&#13;
        self.young_mod = young_mod&#13;
&#13;
    @property&#13;
    def geometry(self):&#13;
        return Segment(&#13;
            self.start_node.position,&#13;
            self.end_node.position&#13;
        )&#13;
&#13;
    @property&#13;
    def length(self):&#13;
        return self.geometry.length&#13;
&#13;
    def global_stiffness_matrix(self) -&gt; Matrix:&#13;
        direction = self.geometry.direction_vector&#13;
        eal = self.young_mod * self.cross_section / self.length&#13;
        c = direction.cosine&#13;
        s = direction.sine&#13;
&#13;
        c2_eal = (c ** 2) * eal&#13;
        s2_eal = (s ** 2) * eal&#13;
        sc_eal = (s * c) * eal&#13;
&#13;
        return Matrix(4, 4).set_data([&#13;
            c2_eal, sc_eal, -c2_eal, -sc_eal,&#13;
            sc_eal, s2_eal, -sc_eal, -s2_eal,&#13;
            -c2_eal, -sc_eal, c2_eal, sc_eal,&#13;
            -sc_eal, -s2_eal, sc_eal, s2_eal&#13;
        ])</pre>&#13;
<p class="caption"><a id="ch15lis8"/><em>Listing 15-8: Bar class result</em></p>&#13;
<p class="indent">We need one last class to bundle nodes and bars together: the structure itself.</p>&#13;
<h4 class="h4" id="ch00lev2sec163"><strong><em>The Structure Class</em></strong></h4>&#13;
<p class="noindent">Create a new Python file named <em>structure.py</em> in <em>structures/model</em> and enter the <span class="literal">Structure</span> class’s code (<a href="ch15.xhtml#ch15lis9">Listing 15-9</a>).<span epub:type="pagebreak" id="page_409"/></p>&#13;
<pre>from functools import reduce&#13;
&#13;
from .node import StrNode&#13;
from .bar import StrBar&#13;
&#13;
&#13;
class Structure:&#13;
    def __init__(self, nodes: [StrNode], bars: [StrBar]):&#13;
        self.__bars = bars&#13;
        self.__nodes = nodes&#13;
&#13;
    @property&#13;
    def nodes_count(self):&#13;
        return len(self.__nodes)&#13;
&#13;
    @property&#13;
    def bars_count(self):&#13;
        return len(self.__bars)&#13;
&#13;
    @property&#13;
    def loads_count(self):&#13;
        return reduce(&#13;
            lambda count, node: count + node.loads_count,&#13;
            self.__nodes,&#13;
            0&#13;
        )</pre>&#13;
<p class="caption"><a id="ch15lis9"/><em>Listing 15-9: Structure class</em></p>&#13;
<p class="indent">This class is quite simple at the moment, but in a later chapter, we’ll write the code responsible for assembling the structure’s global stiffness matrix, generating the system of equations, solving it, and creating the solution. For now, all the class does is store a list of nodes and a list of bars passed in to the constructor, along with a few computations that deal with the number of items it holds.</p>&#13;
<p class="indent">The <span class="literal">loads_count</span> property sums the load count from every node. To accomplish this, we pass a <span class="literal">lambda</span> function as the first argument to the <span class="literal">reduce</span> function. This <span class="literal">lambda</span> takes two arguments: the current count of loads and the next node in the <span class="literal">self.__nodes</span> list. This reduction requires an initial value (which is the third argument, the <span class="literal">0</span>), which we add the first node’s count to. Without this initial value, the reduction couldn’t take place, because the <span class="literal">reduce</span> function wouldn’t know what value the <span class="literal">lambda</span>’s first parameter, <span class="literal">count</span>, had for the first iteration.</p>&#13;
<p class="indent">We now have the complete model that defines the structure!</p>&#13;
<h4 class="h4" id="ch00lev2sec164"><span epub:type="pagebreak" id="page_410"/><strong><em>Creating a Structure from the Python Shell</em></strong></h4>&#13;
<p class="noindent">Let’s try to construct the truss structure in <a href="ch15.xhtml#ch15fig20">Figure 15-20</a> using our model classes.</p>&#13;
<div class="image"><img src="../images/15fig20.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig20"><em>Figure 15-20: Example truss structure</em></p>&#13;
<p class="indent">To define the structure, first import the following classes in the Python shell:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d import Point, Vector</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from structures.model.node import StrNode</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from structures.model.bar import StrBar</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from structures.model.structure import Structure</span></pre>&#13;
<p class="noindent">Then enter the following code:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">node_one = StrNode(1, Point(0, 0), None, True, True)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">node_two = StrNode(2, Point(100, 0), None, False, True)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">node_three = StrNode(3, Point(100, 100), (Vector(50, -100)))</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">bar_one = (1, node_one, node_two, 20, 20000000)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">bar_two = (2, node_two, node_three, 20, 20000000)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">bar_three = (3, node_three, node_one, 20, 20000000)</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">structure = Structure(&#13;
    (node_one, node_two, node_three),&#13;
    (bar_one, bar_two, bar_three)&#13;
)</span></pre>&#13;
<p class="indent">As you can see, creating the model for a truss structure in code is a piece of cake. In any case, we’ll most often load the model from an external definition file, as we’ll learn in <a href="ch17.xhtml#ch17">Chapter 17</a>. Working an example by hand, nevertheless, is a great exercise to understand how our model classes work.</p>&#13;
<p class="indent">To finish this chapter, let’s create the model for the structure’s solution: the classes that will store the node displacements and bar stresses.</p>&#13;
<h3 class="h3" id="ch00lev1sec94"><span epub:type="pagebreak" id="page_411"/><strong>The Structure Solution Model</strong></h3>&#13;
<p class="noindent">We’ll tackle resolving the structure in the next chapter, but we’ll prepare the classes to store the solution values here. For now, let’s imagine we have the resolution algorithm ready and require the solution classes to store the solution’s data.</p>&#13;
<p class="indent">When we resolve a structure, we first obtain the node displacements in global coordinates. From the new positions of the structure’s nodes, we can compute all the rest (strains, stresses, and reaction values). We need a new class to represent displaced nodes, which are similar to the nodes we’ve just defined using the <span class="literal">StrNode</span> class, but with the addition of a displacement vector.</p>&#13;
<p class="indent">These node displacements will elongate or compress the structure’s bars. Remember that bars develop strains and stresses, which are their mechanical response to being extended or compressed. The strain and stress values are important pieces of data in the structural solution: they’ll determine whether the structure can withstand the loads applied to it.</p>&#13;
<p class="indent">We’ll create a new class to represent the solution bars as well. This class will reference the displaced nodes and compute the strain and stress values.</p>&#13;
<h4 class="h4" id="ch00lev2sec165"><strong><em>The Solution Nodes</em></strong></h4>&#13;
<p class="noindent">Let’s create the class that represents nodes in the structure’s solution. In the <em>structures/solution</em> package, create a new file named <em>node.py</em> and enter the code in <a href="ch15.xhtml#ch15lis10">Listing 15-10</a>.</p>&#13;
<pre>from geom2d import Vector&#13;
from structures.model.node import StrNode&#13;
&#13;
&#13;
class StrNodeSolution:&#13;
    def __init__(&#13;
            self,&#13;
            original_node: StrNode,&#13;
            global_disp: Vector&#13;
    ):&#13;
        self.__original_node = original_node&#13;
        self.global_disp = global_disp&#13;
&#13;
    @property&#13;
 <span class="ent">➊</span> def id(self):&#13;
        return self.__original_node.id&#13;
&#13;
    @property&#13;
 <span class="ent">➋</span> def original_pos(self):&#13;
        return self.__original_node.position&#13;
&#13;
    @property&#13;
 <span epub:type="pagebreak" id="page_412"/><span class="ent">➌</span> def is_constrained(self):&#13;
        return self.__original_node.dx_constrained \&#13;
               or self.__original_node.dy_constrained&#13;
&#13;
    @property&#13;
 <span class="ent">➍</span> def loads(self):&#13;
        return self.__original_node.loads&#13;
&#13;
    @property&#13;
 <span class="ent">➎</span> def is_loaded(self):&#13;
       return self.__original_node.loads_count &gt; 0&#13;
&#13;
    @property&#13;
 <span class="ent">➏</span> def net_load(self):&#13;
        return self.__original_node.net_load</pre>&#13;
<p class="caption"><a id="ch15lis10"/><em>Listing 15-10: Solution node class</em></p>&#13;
<p class="indent">This listing declares the <span class="literal">StrNodeSolution</span> class. As you can see, this class’s constructor gets passed the original node and its displacement vector in global coordinates—that’s all we need. The original node is kept private to the class (<span class="literal">__original_node</span>), but some of its properties are exposed. For example, the <span class="literal">id</span> property <span class="ent">➊</span> simply returns the original node’s ID, and the same goes for <span class="literal">loads</span>.</p>&#13;
<p class="indent">The <span class="literal">original_pos</span> property <span class="ent">➋</span> returns the original node’s position: the position before applying the displacement obtained as part of the structure’s resolution. The naming here is important, as we’ll shortly add another property to expose the new position of the node after being displaced.</p>&#13;
<p class="indent">The <span class="literal">is_constrained</span> property <span class="ent">➌</span> checks whether the original node had any of its degrees of freedom (the displacement in x or y) externally constrained. We’ll use this information to know whether a reaction force needs to be computed for the node or not. <em>Reaction forces</em> are those external forces exerted by the supports or constraints in a node. We want to know the magnitude of the force a support absorbs to properly design and dimension this support.</p>&#13;
<p class="indent">Lastly, we have three properties related to the external loads: <span class="literal">loads</span> <span class="ent">➍</span>, <span class="literal">is_loaded</span> <span class="ent">➎</span>, and <span class="literal">net_load</span> <span class="ent">➏</span>. The first simply returns the original node’s list of forces. We’ll use this information when drawing the solution to a vector image like in <a href="ch15.xhtml#ch15fig14">Figure 15-14</a>. Property <span class="literal">is_loaded</span> lets us know whether the node has any load applied. This property will be handy when we need to check which solution nodes have a load applied to them to draw those loads to the result diagram. Property <span class="literal">net_load</span> returns the original node’s net load, which we’ll use to compute the reaction force in the node.</p>&#13;
<h5 class="h5" id="ch00lev3sec74"><strong>Displaced Position</strong></h5>&#13;
<p class="noindent">Let’s include the displaced position as a property. Since displacements tend to be orders of magnitude smaller than the structure’s dimensions, we’ll want to include a method that scales the displacement vector to plot the <span epub:type="pagebreak" id="page_413"/>resulting deformed geometry. This ensures that we’ll be able to tell the deformed geometry apart from the original geometry in the resulting diagram.</p>&#13;
<p class="indent">Enter the code shown in <a href="ch15.xhtml#ch15lis11">Listing 15-11</a> in the <span class="literal">StrNodeSolution</span> class.</p>&#13;
<pre>class StrNodeSolution:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   @property&#13;
   def displaced_pos(self):&#13;
       return self.original_pos.displaced(self.global_disp)&#13;
&#13;
   def displaced_pos_scaled(self, scale=1):&#13;
       return self.original_pos.displaced(self.global_disp, scale)</pre>&#13;
<p class="caption"><a id="ch15lis11"/><em>Listing 15-11: Solution node displacement</em></p>&#13;
<p class="indent">The <span class="literal">displaced_pos</span> method returns the position of the original node after applying the <span class="literal">global_disp</span> vector to it. The <span class="literal">displaced_pos_scaled</span> method does something similar, but with a scale value that will allow us to increase the displacement’s size.</p>&#13;
<h5 class="h5" id="ch00lev3sec75"><strong>The End Result</strong></h5>&#13;
<p class="noindent">If you’ve followed along, your <span class="literal">StrNodeSolution</span> class should look like <a href="ch15.xhtml#ch15lis12">Listing 15-12</a>.</p>&#13;
<pre>from geom2d import Vector&#13;
from structures.model.node import StrNode&#13;
&#13;
&#13;
class StrNodeSolution:&#13;
    def __init__(&#13;
            self,&#13;
            original_node: StrNode,&#13;
            global_disp: Vector&#13;
    ):&#13;
        self.__original_node = original_node&#13;
        self.global_disp = global_disp&#13;
&#13;
    @property&#13;
    def id(self):&#13;
        return self.__original_node.id&#13;
&#13;
    @property&#13;
    def original_pos(self):&#13;
        return self.__original_node.position&#13;
&#13;
    @property&#13;
    def is_constrained(self):&#13;
        return self.__original_node.dx_constrained \&#13;
               or self.__original_node.dy_constrained <span epub:type="pagebreak" id="page_414"/>&#13;
&#13;
    @property&#13;
    def loads(self):&#13;
        return self.__original_node.loads&#13;
&#13;
    @property&#13;
    def is_loaded(self):&#13;
        return self.__original_node.loads_count &gt; 0&#13;
&#13;
    @property&#13;
    def displaced_pos(self):&#13;
        return self.original_pos.displaced(self.global_disp)&#13;
&#13;
    def displaced_position_scaled(self, scale=1):&#13;
        return self.original_pos.displaced(self.global_disp, scale)</pre>&#13;
<p class="caption"><a id="ch15lis12"/><em>Listing 15-12: Solution node class result</em></p>&#13;
<p class="indent">Let’s now implement the bar’s solution class.</p>&#13;
<h4 class="h4" id="ch00lev2sec166"><strong><em>The Solution Bars</em></strong></h4>&#13;
<p class="noindent">Knowing the displacements of a bar’s nodes is all we need to compute its strain and axial stress. We’ll explain why this is as we develop the <span class="literal">StrBarSolution</span> class.</p>&#13;
<p class="indent">Create a new file in <em>structures/solution</em> named <em>bar.py</em> and enter the code in <a href="ch15.xhtml#ch15lis13">Listing 15-13</a>.</p>&#13;
<pre>from structures.model.bar import StrBar&#13;
from .node import StrNodeSolution&#13;
&#13;
&#13;
class StrBarSolution:&#13;
    def __init__(&#13;
            self,&#13;
            original_bar: StrBar,&#13;
            start_node: StrNodeSolution,&#13;
            end_node: StrNodeSolution&#13;
    ):&#13;
        if original_bar.start_node.id != start_node.id:&#13;
            raise ValueError('Wrong start node')&#13;
&#13;
        if original_bar.end_node.id != end_node.id:&#13;
            raise ValueError('Wrong end node')&#13;
&#13;
        self.__original_bar = original_bar&#13;
        self.start_node = start_node&#13;
        self.end_node = end_node&#13;
&#13;
    <span epub:type="pagebreak" id="page_415"/>@property&#13;
    def id(self):&#13;
        return self.__original_bar.id&#13;
&#13;
    @property&#13;
    def cross_section(self):&#13;
        return self.__original_bar.cross_section&#13;
&#13;
    @property&#13;
    def young_mod(self):&#13;
        return self.__original_bar.young_mod</pre>&#13;
<p class="caption"><a id="ch15lis13"/><em>Listing 15-13: Solution bar class</em></p>&#13;
<p class="indent">The <span class="literal">StrBarSolution</span> class is initialized with the original bar and the two solution nodes. In the constructor, we check that we got the correct solution nodes passed in by comparing their IDs with the original bar nodes’ IDs. If we detect a wrong node is being passed, we raise a <span class="literal">ValueError</span> that will halt execution. If we continued executing the program, the results would be incorrect because the solution bar would be linked with nodes it wasn’t connected to in the original definition of the structure. This will prevent us from making mistakes when constructing the structure’s solution classes.</p>&#13;
<p class="indent">The class also defines the <span class="literal">id</span>, <span class="literal">cross_section</span>, and <span class="literal">young_mod</span> properties. These simply return the original bar’s values.</p>&#13;
<h5 class="h5" id="ch00lev3sec76"><strong>Elongation, Stress, and Strain</strong></h5>&#13;
<p class="noindent">Let’s now work out the strain and stress values one step at a time. The stress can be derived from the strain (using <a href="ch15.xhtml#ch15eqa04">Equation 15.4</a>), so we’ll start with the strain. The strain is the bar’s elongation per unit of length (see <a href="ch15.xhtml#ch15eqa03">Equation 15.3</a>), so we need to find out this elongation value. For this, we first want to know both the bar’s original and resulting geometries. Enter the properties shown in <a href="ch15.xhtml#ch15lis14">Listing 15-14</a>.</p>&#13;
<pre><span class="codestrong1">from geom2d import Segment</span>&#13;
from structures.model.bar import StrBar&#13;
from .node import StrNodeSolution&#13;
&#13;
&#13;
class StrBarSolution:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   @property&#13;
   def original_geometry(self):&#13;
       return self.__original_bar.geometry&#13;
&#13;
   @property&#13;
   def final_geometry(self):&#13;
       return Segment(&#13;
           <span epub:type="pagebreak" id="page_416"/>self.start_node.displaced_pos,&#13;
           self.end_node.displaced_pos&#13;
       )</pre>&#13;
<p class="caption"><a id="ch15lis14"/><em>Listing 15-14: Solution bar geometry</em></p>&#13;
<p class="indent">The original geometry was already a property in <span class="literal">StrBar</span>. The final geometry is also a segment, this time between the displaced start and end nodes. It’s important to understand that since the bars of a truss structure are two-force members, they’re only subject to axial forces. Thus, the directrix of the bars will always remain a straight segment. <a href="ch15.xhtml#ch15fig21">Figure 15-21</a> depicts the original bar and the deformed bar that results when displacing the position of the original nodes <img class="inline" src="../images/u1victorit.jpg" alt="Image"/> and <img class="inline" src="../images/u2victorit.jpg" alt="Image"/>.</p>&#13;
<div class="image"><img src="../images/15fig21.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig21"><em>Figure 15-21: A bar’s length increment</em></p>&#13;
<p class="indent">Assuming the original bar had a length of <em>l</em><sub><em>o</em></sub> and that <em>l</em><sub><em>f</em></sub> is the final length, the elongation of the bar is simply <em>Δl</em> = <em>l</em><sub><em>f</em></sub> <em>– l</em><sub><em>o</em></sub>. The elongation value will be positive if the bar stretches and negative if it compresses. Note that this agrees with our stress sign convention: positive for tension and negative for compression. Enter the properties in <a href="ch15.xhtml#ch15lis15">Listing 15-15</a>.</p>&#13;
<pre>class StrBarSolution:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   @property&#13;
   def original_length(self):&#13;
       return self.original_geometry.length&#13;
&#13;
   @property&#13;
   def final_length(self):&#13;
       return self.final_geometry.length&#13;
&#13;
   @property&#13;
   def elongation(self):&#13;
       return self.final_length - self.original_length</pre>&#13;
<p class="caption"><a id="ch15lis15"/><em>Listing 15-15: Solution bar length</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_417"/>Now that we know the bar’s elongation, we can easily compute the strain and also the stress. Enter the <span class="literal">strain</span> and <span class="literal">stress</span> properties in the <span class="literal">StrBarSolution</span> class as in <a href="ch15.xhtml#ch15lis16">Listing 15-16</a>.</p>&#13;
<pre>class StrBarSolution:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   @property&#13;
   def strain(self):&#13;
       return self.elongation / self.original_length&#13;
&#13;
   @property&#13;
   def stress(self):&#13;
       return self.young_mod * self.strain</pre>&#13;
<p class="caption"><a id="ch15lis16"/><em>Listing 15-16: Bar strain and stress</em></p>&#13;
<p class="indent">Finally! As you can see, the strain, given by <a href="ch15.xhtml#ch15eqa03">Equation 15.3</a>, is the quotient between the bar’s elongation and the original length. With the strain value we can obtain the stress by simple multiplication with the material’s Young’s modulus. This is Hooke’s law as formulated in <a href="ch15.xhtml#ch15eqa04">Equation 15.4</a>.</p>&#13;
<h5 class="h5" id="ch00lev3sec77"><strong>Internal Forces</strong></h5>&#13;
<p class="noindent">To compute the reaction forces, we’ll use the static equilibrium condition in each of the nodes: the net force in a node is always zero. In this sum of forces, every bar that is connected to the node exerts a force equal in value and opposite in direction to its internal force (this is illustrated in <a href="ch15.xhtml#ch15fig23">Figure 15-23</a>). This internal force is computed as the bar’s stress times its cross section (see <a href="ch15.xhtml#ch15eqa02">Equation 15.2</a>).</p>&#13;
<p class="indent">We need both the magnitude and the direction of the internal force in each of the bar’s nodes, because, if you recall, for this two-force member to be in equilibrium, the forces in both ends need to have equal magnitude and opposite directions. Let’s see how we’d go about doing this.</p>&#13;
<p class="indent">Enter the code in <a href="ch15.xhtml#ch15lis17">Listing 15-17</a>.</p>&#13;
<pre>from geom2d import Segment, <span class="codestrong1">make_vector_between</span>&#13;
from structures.model.bar import StrBar&#13;
from .node import StrNodeSolution&#13;
&#13;
&#13;
class StrBarSolution:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    @property&#13;
    def internal_force_value(self):&#13;
        return self.stress * self.cross_section&#13;
&#13;
    def force_in_node(self, node: StrNodeSolution):&#13;
     <span class="ent">➊</span> if node is self.start_node:&#13;
            <span epub:type="pagebreak" id="page_418"/>return make_vector_between(&#13;
                self.end_node.displaced_pos,&#13;
                self.start_node.displaced_pos&#13;
            ).with_length(&#13;
                self.internal_force_value&#13;
            )&#13;
     <span class="ent">➋</span> elif node is self.end_node:&#13;
            return make_vector_between(&#13;
                self.start_node.displaced_pos,&#13;
                self.end_node.displaced_pos&#13;
            ).with_length(&#13;
                self.internal_force_value&#13;
            )&#13;
&#13;
        raise ValueError(&#13;
            f'Bar {self.id} does not know about node {node.id}'&#13;
        )</pre>&#13;
<p class="caption"><a id="ch15lis17"/><em>Listing 15-17: Bar internal force</em></p>&#13;
<p class="indent">In this code, we first define the <span class="literal">internal_force_value</span> property, which yields the magnitude, positive or negative, of the internal force computed according to <a href="ch15.xhtml#ch15eqa02">Equation 15.2</a>.</p>&#13;
<p class="indent">Then comes the <span class="literal">force_in_node</span> method, which, given either the start or end node of the bar, returns the force vector in that node. The magnitude of the force vector is <span class="literal">internal_force_value</span> in both cases. It’s the direction that changes depending on the passed-in node.</p>&#13;
<p class="indent">Our sign convention is that tension forces are considered positive and compression forces negative. If we choose the direction of the internal force to be positive in each of the nodes, the force vector will always have the correct direction. This is because later we’ll give it a length of <span class="literal">internal_force_value</span>, which is negative for a compressing force, and, as you know, assigning a negative length to one of our <span class="literal">Vector</span> instances reverses its direction.</p>&#13;
<p class="indent">Look back at the code. If the passed-in node is the start node <span class="ent">➊</span>, the force vector is created to go from the end node’s final position to the start’s. Then, the resulting vector is scaled according to <span class="literal">internal_force_value</span>.</p>&#13;
<p class="indent">Conversely, if the passed-in node is the end node <span class="ent">➋</span>, the force vector is the opposite, but the scaling part remains the same.</p>&#13;
<p class="indent">Lastly, if the passed-in node is neither of the two bar nodes, we raise an error.</p>&#13;
<h5 class="h5" id="ch00lev3sec78"><strong>Bar Has Node?</strong></h5>&#13;
<p class="noindent">We’re almost done with the bar solution class; we just need two more methods, and our class will be ready. The first one checks whether any node in the structure is one of the end nodes in the bar. We’ll use this method to draw the results. Enter the method in <a href="ch15.xhtml#ch15lis18">Listing 15-18</a>.</p>&#13;
<pre>class StrBarSolution:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   <span epub:type="pagebreak" id="page_419"/>def has_node(self, node: StrNodeSolution):&#13;
       return node is self.start_node or node is self.end_node</pre>&#13;
<p class="caption"><a id="ch15lis18"/><em>Listing 15-18: Bar has node?</em></p>&#13;
<p class="indent">Lastly, we need a method to generate the bar’s final geometry but with a scale applied to the displacements.</p>&#13;
<h5 class="h5" id="ch00lev3sec79"><strong>Scaled Final Geometry</strong></h5>&#13;
<p class="noindent">If you remember, we already implemented a method in the <span class="literal">StrNodeSolution</span> class that yields its position with a scale applied to the displacement. Let’s harness this implementation to build the segment representing the deformed bar’s geometry with a scale applied. Enter the code in <a href="ch15.xhtml#ch15lis19">Listing 15-19</a>.</p>&#13;
<pre>class StrBarSolution:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def final_geometry_scaling_displacement(self, scale: float):&#13;
       return Segment(&#13;
           self.start_node.displaced_pos_scaled(scale),&#13;
           self.end_node.displaced_pos_scaled(scale)&#13;
       )</pre>&#13;
<p class="caption"><a id="ch15lis19"/><em>Listing 15-19: Bar scaled geometry</em></p>&#13;
<p class="indent">The <span class="literal">final_geometry_scaling_displacement</span> method returns a segment whose end points are the bar nodes’ final positions with a scale applied to the displacement vector. This is the segment we’ll draw to the result plot to visualize how the original bar got displaced from its original position.</p>&#13;
<p class="indent">Again, because the displacements are fairly small compared to the size of the structure itself, we’ll want to scale the node displacements so we can clearly see how the structure gets deformed in the solution diagram.</p>&#13;
<h5 class="h5" id="ch00lev3sec80"><strong>The End Result</strong></h5>&#13;
<p class="noindent">If you followed along, your <span class="literal">StrBarSolution</span> should look like <a href="ch15.xhtml#ch15lis20">Listing 15-20</a>.</p>&#13;
<pre>from geom2d import Segment, make_vector_between&#13;
from structures.model.bar import StrBar&#13;
from .node import StrNodeSolution&#13;
&#13;
&#13;
class StrBarSolution:&#13;
    def __init__(&#13;
            self,&#13;
            original_bar: StrBar,&#13;
            start_node: StrNodeSolution,&#13;
            end_node: StrNodeSolution&#13;
    ):&#13;
        if original_bar.start_node.id != start_node.id:&#13;
            <span epub:type="pagebreak" id="page_420"/>raise ValueError('Wrong start node')&#13;
&#13;
        if original_bar.end_node.id != end_node.id:&#13;
            raise ValueError('Wrong end node')&#13;
&#13;
        self.__original_bar = original_bar&#13;
        self.start_node = start_node&#13;
        self.end_node = end_node&#13;
&#13;
    @property&#13;
    def id(self):&#13;
        return self.__original_bar.id&#13;
&#13;
    @property&#13;
    def cross_section(self):&#13;
        return self.__original_bar.cross_section&#13;
&#13;
    @property&#13;
    def young_mod(self):&#13;
        return self.__original_bar.young_mod&#13;
&#13;
    @property&#13;
    def original_geometry(self):&#13;
        return self.__original_bar.geometry&#13;
&#13;
    @property&#13;
    def final_geometry(self):&#13;
        return Segment(&#13;
            self.start_node.displaced_pos,&#13;
            self.end_node.displaced_pos&#13;
        )&#13;
&#13;
    @property&#13;
    def original_length(self):&#13;
        return self.original_geometry.length&#13;
&#13;
    @property&#13;
    def final_length(self):&#13;
        return self.final_geometry.length&#13;
&#13;
    @property&#13;
    def elongation(self):&#13;
        return self.final_length - self.original_length&#13;
&#13;
    @property&#13;
    def strain(self):&#13;
        return self.elongation / self.original_length&#13;
&#13;
    <span epub:type="pagebreak" id="page_421"/>@property&#13;
    def stress(self):&#13;
        return self.young_mod * self.strain&#13;
&#13;
    @property&#13;
    def internal_force_value(self):&#13;
        return self.stress * self.cross_section&#13;
&#13;
    def force_in_node(self, node: StrNodeSolution):&#13;
        if node is self.start_node:&#13;
            return make_vector_between(&#13;
                self.end_node.displaced_pos,&#13;
                self.start_node.displaced_pos&#13;
            ).with_length(&#13;
                self.internal_force_value&#13;
            )&#13;
        elif node is self.end_node:&#13;
            return make_vector_between(&#13;
                self.start_node.displaced_pos,&#13;
                self.end_node.displaced_pos&#13;
            ).with_length(&#13;
                self.internal_force_value&#13;
            )&#13;
&#13;
        raise ValueError(&#13;
            f'Bar {self.id} does not know about node {node.id}'&#13;
        )&#13;
&#13;
    def has_node(self, node: StrNodeSolution):&#13;
        return node is self.start_node or node is self.end_node&#13;
&#13;
    def final_geometry_scaling_displacement(self, scale: float):&#13;
        return Segment(&#13;
            self.start_node.displaced_position_scaled(scale),&#13;
            self.end_node.displaced_position_scaled(scale)&#13;
        )</pre>&#13;
<p class="caption"><a id="ch15lis20"/><em>Listing 15-20: Solution bar class result</em></p>&#13;
<p class="indent">There’s one last class we want to define: the structure solution.</p>&#13;
<h4 class="h4" id="ch00lev2sec167"><strong><em>The Structure Solution</em></strong></h4>&#13;
<p class="noindent">Just as we had a class for the original structure model, we want a class representing the structure’s solution. The goal of this class is to put the solution nodes and bars together.</p>&#13;
<p class="indent">Create a new file in the <em>structures/solution</em> folder named <em>structure.py</em>. In the file, enter the basic definition for the class (<a href="ch15.xhtml#ch15lis21">Listing 15-21</a>).<span epub:type="pagebreak" id="page_422"/></p>&#13;
<pre>from .bar import StrBarSolution&#13;
from .node import StrNodeSolution&#13;
&#13;
&#13;
class StructureSolution:&#13;
    def __init__(&#13;
            self,&#13;
            nodes: [StrNodeSolution],&#13;
            bars: [StrBarSolution]&#13;
    ):&#13;
        self.nodes = nodes&#13;
        self.bars = bars</pre>&#13;
<p class="caption"><a id="ch15lis21"/><em>Listing 15-21: Structure solution class</em></p>&#13;
<p class="indent">The <span class="literal">StructureSolution</span> class is initialized with the list of nodes and bars that make up the solution. This is similar to the original structure’s definition. But because we’re using this class to generate results—reports and diagrams—we’ll need some additional attributes.</p>&#13;
<h5 class="h5" id="ch00lev3sec81"><strong>Structure Rectangular Bounds</strong></h5>&#13;
<p class="noindent">When plotting the structural analysis results, we’ll want to know how much space we need to draw the complete structure. Knowing the rectangular bounds of the entire structure will allow us to compute the viewBox for the SVG plot later. Let’s compute these bounds and add in some margin as well (see <a href="ch15.xhtml#ch15fig22">Figure 15-22</a>) so that there’s some extra room for drawing things like the arrows that represent loads.</p>&#13;
<div class="image"><img src="../images/15fig22.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig22"><em>Figure 15-22: Bounding a structure</em></p>&#13;
<p class="indent">In the class, enter the <span class="literal">bounds_rect</span> method (<a href="ch15.xhtml#ch15lis22">Listing 15-22</a>).</p>&#13;
<pre><span class="codestrong1">from geom2d import make_rect_containing_with_margin</span>&#13;
from .bar import StrBarSolution&#13;
from .node import StrNodeSolution&#13;
&#13;
&#13;
class StructureSolution:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def bounds_rect(self, margin: float, scale=1):&#13;
        d_pos = [&#13;
            <span epub:type="pagebreak" id="page_423"/>node.displaced_pos_scaled(scale)&#13;
            for node in self.nodes&#13;
        ]&#13;
        return make_rect_containing_with_margin(d_pos, margin)</pre>&#13;
<p class="caption"><a id="ch15lis22"/><em>Listing 15-22: Structure graphical bounds</em></p>&#13;
<p class="indent">We first import the <span class="literal">make_rect_containing_with_margin</span> function. We implemented this function in <a href="part02.xhtml#part02">Part II</a> of the book; it creates a <span class="literal">Rect</span> primitive containing all the passed-in points, along with some margin.</p>&#13;
<p class="indent">The <span class="literal">bounds_rect</span> method we’ve written initializes the <span class="literal">d_pos</span> variable as a list with all the structure nodes’ displaced positions and passes it to the function, which generates the rectangle. Note that we’re using the scaled version of the displacements to make sure the rectangular bounds contain all the nodes in the positions where they’ll be drawn.</p>&#13;
<h5 class="h5" id="ch00lev3sec82"><strong>Node Reaction Forces</strong></h5>&#13;
<p class="noindent">Lastly, because the <span class="literal">StructureSolution</span> class has access to all the nodes and bars of the structure, it will be in charge of calculating the reaction forces for each of the nodes. The <span class="literal">StrNodeSolution</span> class couldn’t do this computation itself, as it doesn’t have access to the list of bars that meet in that node.</p>&#13;
<p class="indent">Now how do we go about computing the reaction force in a node? Let’s suppose we have a node like that in <a href="ch15.xhtml#ch15fig23">Figure 15-23</a>. Two bars, bar 1 and bar 2, meet in this node and are subject to internal forces <img class="inline" src="../images/f1victorit.jpg" alt="Image"/> and <img class="inline" src="../images/f2victorit.jpg" alt="Image"/>, respectively. An external load <img class="inline" src="../images/qvictorit.jpg" alt="Image"/> is applied to the node as well. This node is externally constrained, and <img class="inline" src="../images/Rvictor_caps.jpg" alt="Image"/> is the reaction force we’re after.</p>&#13;
<div class="image"><img src="../images/15fig23.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch15fig23"><em>Figure 15-23: The reaction forces in a node</em></p>&#13;
<p class="indent">From these quantities, only <img class="inline" src="../images/Rvictor_caps.jpg" alt="Image"/> is unknown. The bar internal forces, <img class="inline" src="../images/f1victorit.jpg" alt="Image"/> and <img class="inline" src="../images/f2victorit.jpg" alt="Image"/>, are computed using the <span class="literal">force_in_node</span> method we implemented in <a href="ch15.xhtml#ch15lis17">Listing 15-17</a>, and the external load <img class="inline" src="../images/qvictorit.jpg" alt="Image"/> is given as part of the problem’s statement.</p>&#13;
<p class="indent">Provided the node is under static equilibrium, the following condition must be held.<span epub:type="pagebreak" id="page_424"/></p>&#13;
<div class="equationc"><img src="../images/f0424-01.jpg" alt="Image"/></div>&#13;
<p class="indent">You may have noticed that in this condition the bar forces appear with a negative sign. Those are the reaction forces the node receives from the bars’ forces, in accordance with Newton’s third law. If a bar is subject to a pair of forces that compress it, the bar pulls the node toward itself. On the other hand, if a bar tends to expand, it’ll push the nodes away from itself.</p>&#13;
<p class="indent">We can easily isolate <img class="inline" src="../images/Rvictor_caps.jpg" alt="Image"/> from the previous equation,</p>&#13;
<div class="equationc"><img src="../images/f0424-02.jpg" alt="Image"/></div>&#13;
<p class="noindent">or in a more generic fashion (<a href="ch15.xhtml#ch15eqa08">Equation 15.8</a>),</p>&#13;
<div class="equationc" id="ch15eqa08"><img src="../images/15eqa08.jpg" alt="Image"/></div>&#13;
<p class="noindent">where <img class="inline" src="../images/f00424-p1.jpg" alt="Image"/> is the sum of all bar forces, and <img class="inline" src="../images/f00424-p2.jpg" alt="Image"/> is the sum of all external loads applied to the node (the node’s net load).</p>&#13;
<p class="indent">Let’s implement this in our class. Enter the code in <a href="ch15.xhtml#ch15lis23">Listing 15-23</a>.</p>&#13;
<pre><span class="codestrong1">import operator</span>&#13;
<span class="codestrong1">from functools import reduce</span>&#13;
&#13;
from geom2d import make_rect_containing_with_margin, <span class="codestrong1">Vector</span>&#13;
from .bar import StrBarSolution&#13;
from .node import StrNodeSolution&#13;
&#13;
&#13;
&#13;
class StructureSolution:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
&#13;
    def reaction_for_node(self, node: StrNodeSolution):&#13;
     <span class="ent">➊</span> if not node.is_constrained:&#13;
            return Vector(0, 0)&#13;
&#13;
&#13;
     <span class="ent">➋</span> forces = [&#13;
            bar.force_in_node(node)&#13;
            for bar in self.bars&#13;
            if bar.has_node(node)&#13;
        ]&#13;
&#13;
&#13;
        if node.is_loaded:&#13;
         <span class="ent">➌</span> forces.append(node.net_load.opposite())&#13;
&#13;
&#13;
     <span class="ent">➍</span> return reduce(operator.add, forces)</pre>&#13;
<p class="caption"><a id="ch15lis23"/><em>Listing 15-23: Node reaction force</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_425"/>We’ve defined the <span class="literal">reaction_for_node</span> method, which, given a node, computes its reaction force. Don’t forget that reaction forces exist only for those nodes that have external supports or constraints. That’s in fact the first thing we check <span class="ent">➊</span>: if the node is not constrained, we return a zero vector (meaning no reaction force).</p>&#13;
<p class="indent">The second step is to search for all bars in the structure that are linked to the passed-in node and get their internal forces in that given node <span class="ent">➋</span>. We do this using a list comprehension that iterates through all the bars in the structure, filtering those that pass the <span class="literal">bar.has_node(node)</span> test and finally mapping each of them to its internal force in the given node. This is the <img class="inline" src="../images/f00424-p1.jpg" alt="Image"/> in <a href="ch15.xhtml#ch15eqa08">Equation 15.8</a>.</p>&#13;
<p class="indent">Next, we append the net external load to the <span class="literal">forces</span> list if the node is externally loaded <span class="ent">➌</span>. Note that the net load received from the node appears with a negative sign in <a href="ch15.xhtml#ch15eqa08">Equation 15.8</a>, which is why we call the <span class="literal">opposite</span> method on it. Also note that we don’t need to sum these loads (as the <img class="inline" src="../images/f00424-p2.jpg" alt="Image"/> in <a href="ch15.xhtml#ch15eqa08">Equation 15.8</a> suggests) because the <span class="literal">StrNodeSolution</span> class already does that for us and provides us with the net load.</p>&#13;
<p class="indent">Lastly, all the forces in the list are summed using the <span class="literal">reduce</span> function with the <span class="literal">operator.add</span> operator <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch00lev3sec83"><strong>The End Result</strong></h5>&#13;
<p class="noindent">For your reference, <a href="ch15.xhtml#ch15lis24">Listing 15-24</a> shows the complete <span class="literal">StructureSolution</span> class implementation.</p>&#13;
<pre>import operator&#13;
from functools import reduce&#13;
&#13;
from geom2d import make_rect_containing_with_margin, Vector&#13;
from .bar import StrBarSolution&#13;
from .node import StrNodeSolution&#13;
&#13;
&#13;
class StructureSolution:&#13;
    def __init__(&#13;
            self,&#13;
            nodes: [StrNodeSolution],&#13;
            bars: [StrBarSolution]&#13;
    ):&#13;
        self.nodes = nodes&#13;
        self.bars = bars&#13;
&#13;
    def bounds_rect(self, margin: float, scale=1):&#13;
        d_pos = [&#13;
            node.displaced_pos_scaled(scale)&#13;
            for node in self.nodes&#13;
        ]&#13;
        return make_rect_containing_with_margin(d_pos, margin)&#13;
&#13;
    <span epub:type="pagebreak" id="page_426"/>def reaction_for_node(self, node: StrNodeSolution):&#13;
        if not node.is_constrained:&#13;
            return Vector(0, 0)&#13;
&#13;
        forces = [&#13;
            bar.force_in_node(node)&#13;
            for bar in self.bars&#13;
            if bar.has_node(node)&#13;
        ]&#13;
&#13;
        if node.is_loaded:&#13;
            forces.append(node.net_load.opposite())&#13;
&#13;
        return reduce(operator.add, forces)</pre>&#13;
<p class="caption"><a id="ch15lis24"/><em>Listing 15-24: Structure solution class result</em></p>&#13;
<p class="indent">It’s important to unit test this class to make sure we haven’t made any mistakes. Nevertheless, to test it, we need to learn about an advanced testing technique: mocking. We’ll be exploring this topic in the next chapter, so we’ll come back to this implementation.</p>&#13;
<h3 class="h3" id="ch00lev1sec95"><strong>Summary</strong></h3>&#13;
<p class="noindent">We started this chapter reviewing some mechanics of materials topics such as the internal forces developed by elastic bodies as a response to being externally loaded. We introduced the concepts of stress and strain, both central to structural analysis. We were particularly interested in the axial stresses developed in prismatic bodies, as those are crucial in plane truss structures, the focus of this part of the book.</p>&#13;
<p class="indent">We then took a look at plane trusses and their particularities and formulated the relation between forces and displacements on a bar using the concept of a stiffness matrix. As we’ll see in the next chapter, these matrices play a crucial role in the resolution of the structure.</p>&#13;
<p class="indent">Lastly, we implemented the structure’s modeling classes: <span class="literal">StrNode</span>, <span class="literal">StrBar</span>, and <span class="literal">Structure</span>. We implemented the structure’s solution classes as well: <span class="literal">StrNodeSolution</span>, <span class="literal">StrBarSolution</span>, and <span class="literal">StructureSolution</span>. These two sets of classes represent the structure as originally designed and the structure solution, including the stress value for each bar and the displacements of every node. We’ll cover how we go from the original definition to the solution in the next chapter.</p>&#13;
</body></html>