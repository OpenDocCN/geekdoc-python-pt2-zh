- en: '[12](nsp-venkitachalam503045-0008.xhtml#rch12)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[12](nsp-venkitachalam503045-0008.xhtml#rch12)'
- en: Karplus-Strong on a Raspberry Pi Pico
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在树莓派Pico上实现Karplus-Strong算法
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: 'In [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04), you learned how to
    make plucked string sounds using the Karplus-Strong algorithm. You saved the generated
    sounds as WAV files and played notes from a pentatonic musical scale on your computer.
    In this chapter, you’ll learn how to shrink that project to fit on a tiny piece
    of hardware: the Raspberry Pi Pico.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)中，你学会了如何使用Karplus-Strong算法制作拨弦音。你将生成的声音保存为WAV文件，并在电脑上播放五声音阶的音符。在这一章中，你将学习如何将该项目缩减以适应一块小型硬件：树莓派Pico。
- en: The Pico (see [Figure 12-1](nsp-venkitachalam503045-0027.xhtml#fig12-1)) is
    built using an RP2040 microcontroller chip, which has just 264KB of random access
    memory (RAM). Compare that to the tens of gigabytes of RAM on the typical personal
    computer! The Pico also has 2MB of flash memory on a separate chip, in contrast
    to a normal computer’s hundreds of gigabytes of hard disk space. Despite these
    limitations, however, the Pico is still extremely capable. It can perform many
    useful services, while also being much cheaper and less power-hungry than a regular
    computer. Your watch, your air conditioning unit, your clothes dryer, your car,
    your phone—tiny microcontrollers like the RP2040 are everywhere!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Pico（见[图12-1](nsp-venkitachalam503045-0027.xhtml#fig12-1)）使用RP2040微控制器芯片构建，该芯片仅具有264KB的随机存取内存（RAM）。与典型个人计算机的数十GB内存相比，这差距非常大！Pico还具有2MB的闪存，位于一个独立的芯片上，而普通计算机的硬盘空间通常有数百GB。尽管存在这些限制，Pico仍然非常强大。它可以执行许多有用的任务，同时比普通计算机便宜且能耗低。你的手表、空调、衣物干燥机、汽车、手机——像RP2040这样的微控制器无处不在！
- en: '![](images/nsp-venkitachalam503045-f12001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12001.jpg)'
- en: 'Figure 12-1: The Raspberry Pi Pico'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-1：树莓派Pico
- en: 'The goal for this project is to use the Raspberry Pi Pico to create a musical
    instrument with five buttons. Pressing each button will play a note from a pentatonic
    scale, generated with the Karplus-Strong algorithm. Some of the concepts you’ll
    learn from this project are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的目标是使用树莓派Pico创建一个五个按钮的乐器。每按一个按钮，就会播放五声音阶中的一个音符，该音符由Karplus-Strong算法生成。通过这个项目，你将学习到以下一些概念：
- en: • Programming a microcontroller using MicroPython, an implementation of Python
    optimized to run on devices like the Pico
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用MicroPython编程微控制器，MicroPython是专为像Pico这样的设备优化的Python实现
- en: • Building a simple audio circuit on a breadboard using the Pico
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用Pico在面包板上构建简单的音频电路
- en: • Using the I2S digital audio protocol and an I2S amplifier to send audio data
    to a speaker
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用I2S数字音频协议和I2S放大器将音频数据发送到扬声器
- en: • Implementing the Karplus-Strong algorithm from [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04)
    on a resource-constrained microcontroller
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在资源受限的微控制器上实现[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)中的Karplus-Strong算法
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1401)'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah1401)'
- en: 'We discussed the Karplus-Strong algorithm in detail in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04),
    so we won’t revisit it here. Instead, we’ll focus on what makes this version of
    the project different. Your program from [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04)
    was designed to run on a laptop or desktop computer. Thanks to the computer’s
    ample RAM and hard disk resources, it had no problems creating WAV files using
    the Karplus-Strong algorithm and playing audio through speakers with `pyaudio`.
    The challenge now is to fit the project code onto a resource-constrained Raspberry
    Pi Pico. This will require the following modifications:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)中详细讨论了Karplus-Strong算法，因此在这里不再重复。相反，我们将重点关注此版本项目的不同之处。你在[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)中的程序是为了在笔记本电脑或台式机上运行而设计的。由于电脑拥有充足的内存和硬盘资源，因此它能够轻松使用Karplus-Strong算法生成WAV文件并通过扬声器播放音频，使用`pyaudio`库没有任何问题。现在的挑战是将项目代码适配到资源受限的树莓派Pico上。这将需要以下修改：
- en: • Using a smaller audio sampling rate to reduce memory requirements
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用较小的音频采样率以减少内存需求
- en: • Using a simple binary file to store raw generated samples rather than a WAV
    file
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用简单的二进制文件存储原始生成的样本，而不是WAV文件
- en: • Using the I2S protocol to send out the audio data to an external audio amplifier
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用I2S协议将音频数据发送到外部音频放大器
- en: • Using memory management techniques to avoid copying the same data repeatedly
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用内存管理技术以避免重复复制相同的数据
- en: We’ll discuss the specifics of these modifications as they arise.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在修改过程中详细讨论这些细节。
- en: '[Input and Output](nsp-venkitachalam503045-0008.xhtml#rbh1401)'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[输入与输出](nsp-venkitachalam503045-0008.xhtml#rbh1401)'
- en: To make the project interactive, you’ll want the Pico to generate sounds in
    response to user input. You’ll need to wire five push buttons to the Pico for
    this purpose, since the Pico doesn’t have a keyboard or mouse. (You’ll use a sixth
    push button to run the program.) We also need to figure out how to produce the
    sound output, since unlike a personal computer, the Pico board doesn’t have any
    built-in speakers. [Figure 12-2](nsp-venkitachalam503045-0027.xhtml#fig12-2) shows
    a block diagram of the project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使项目具有互动性，你需要让Pico根据用户输入生成声音。为此，你需要将五个按钮连接到Pico，因为Pico没有键盘或鼠标。（你将使用第六个按钮来运行程序。）我们还需要弄清楚如何产生声音输出，因为与个人计算机不同，Pico板没有内置扬声器。[图12-2](nsp-venkitachalam503045-0027.xhtml#fig12-2)展示了项目的框图。
- en: '![](images/nsp-venkitachalam503045-f12002.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12002.jpg)'
- en: 'Figure 12-2: A block diagram of the project'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-2：项目的框图
- en: When you press a button, the MicroPython code running on the Pico will generate
    a plucked string sound using the Karplus-Strong algorithm. The digital sound samples
    produced by the algorithm will be sent to a separate MAX98357A amplifier board,
    which decodes the digital data into an analog audio signal. The MAX98357A also
    amplifies the analog signal, which allows you to connect its output to an external
    8-ohm speaker so you can hear the audio. [Figure 12-3](nsp-venkitachalam503045-0027.xhtml#fig12-3)
    shows the Adafruit MAX98357A board.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下按钮时，运行在Pico上的MicroPython代码将使用Karplus-Strong算法生成一个拨弦音效。算法生成的数字音频样本将被发送到一个独立的MAX98357A放大器板，该板将数字数据解码为模拟音频信号。MAX98357A还会放大模拟信号，使你能够将其输出连接到外部8欧姆扬声器，从而听到音频。[图12-3](nsp-venkitachalam503045-0027.xhtml#fig12-3)展示了Adafruit
    MAX98357A板。
- en: '![](images/nsp-venkitachalam503045-f12003.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12003.jpg)'
- en: 'Figure 12-3: An Adafruit MAX98357A I2S amplifier board'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-3：Adafruit MAX98357A I2S放大器板
- en: The Pi Pico needs to send data to the amplifier board in a certain format for
    it to successfully be interpreted as an audio signal. Enter the I2S protocol.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Pi Pico需要以特定的格式将数据发送到放大器板，才能成功地将其解读为音频信号。这时就需要使用I2S协议。
- en: '[The I2S Protocol](nsp-venkitachalam503045-0008.xhtml#rbh1402)'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[I2S协议](nsp-venkitachalam503045-0008.xhtml#rbh1402)'
- en: The *Inter-IC Sound (I2S) protocol* is a standard for sending digital audio
    data between devices. It’s a simple, convenient way to get quality audio output
    from a microcontroller. The protocol transmits audio using three digital signals,
    which are shown in [Figure 12-4](nsp-venkitachalam503045-0027.xhtml#fig12-4).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*Inter-IC Sound (I2S)协议*是一个标准，用于在设备之间发送数字音频数据。这是一种简单且便捷的方式，可以从微控制器获取高质量的音频输出。该协议通过三种数字信号来传输音频，具体如[图12-4](nsp-venkitachalam503045-0027.xhtml#fig12-4)所示。'
- en: '![](images/nsp-venkitachalam503045-f12004.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12004.jpg)'
- en: 'Figure 12-4: The I2S protocol'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-4：I2S协议
- en: The first signal, SCK, is the *clock*, a signal that alternates between high
    and low at a fixed speed. This sets the rate of data transmission. Next, WS is
    the *word select* signal. It steadily alternates between high and low to indicate
    which audio channel, left or right, is being sent at any given moment. Finally,
    SD is the *serial data* signal, which carries the actual audio information, in
    the form of N-bit binary values representing the amplitude of the sound.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个信号，SCK，是*时钟*信号，它以固定的速度在高低电平之间交替。这设定了数据传输的速率。接下来，WS是*字选择*信号。它稳步地在高低电平之间交替，指示当前传输的是左声道还是右声道。最后，SD是*串行数据*信号，它携带实际的音频信息，以N位二进制值的形式表示声音的幅度。
- en: To understand how this works, let’s consider an example. Say you want to send
    stereo audio at a sampling rate of 16,000 Hz and you want the amplitude of each
    sound sample to be a 16-bit value. The frequency of WS should be the same as the
    sampling rate, since that’s the rate at which you’re sending each amplitude value.
    This way, the WS signal will alternate between high and low 16,000 times per second;
    when it’s high, SD will send the amplitude value of one audio channel, and when
    it’s low, SD will send the amplitude value of the other audio channel. Since each
    amplitude value for each channel is made up of 16 bits, SD has to transmit at
    a rate that’s 16 × 2 = 32 times faster than the sampling rate. The clock controls
    the rate of transmission, so SCK’s frequency must be 16,000 Hz × 32 = 512,000 Hz.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这如何工作，我们来看一个例子。假设你想以16,000 Hz的采样率发送立体声音频，并且希望每个声音样本的幅度是16位值。WS的频率应该与采样率相同，因为这是你发送每个幅度值的速率。这样，WS信号每秒会在高低之间交替16,000次；当它为高时，SD会发送一个音频通道的幅度值；当它为低时，SD会发送另一个音频通道的幅度值。由于每个通道的幅度值由16位组成，SD必须以比采样率快16
    × 2 = 32倍的速率传输。时钟控制传输速率，因此SCK的频率必须是16,000 Hz × 32 = 512,000 Hz。
- en: For this project, the Pico will be the I2S transmitter, so it will generate
    the SCK, WS, and SD signals. MicroPython actually has a fully implemented `I2S`
    module for the Pico, so much of the work generating the signals will be done for
    you, behind the scenes. As you’ve already seen, the Pico will send the signals
    to a MAX98357A board, which is specifically designed to receive audio data through
    the I2S protocol. Then the board converts the I2S data into an analog audio signal
    that can be played through a speaker.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，Pico将充当I2S发射器，因此它将生成SCK、WS和SD信号。MicroPython实际上为Pico提供了一个完全实现的`I2S`模块，因此大部分生成信号的工作将由你幕后完成。如你所见，Pico将信号发送到MAX98357A板，该板专门设计用于通过I2S协议接收音频数据。然后该板将I2S数据转换为模拟音频信号，可以通过扬声器播放。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1402)'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah1402)'
- en: 'You’ll program the project for the Raspberry Pi Pico using MicroPython. You’ll
    need the following hardware:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用MicroPython为Raspberry Pi Pico编写项目代码。你将需要以下硬件：
- en: • One Raspberry Pi Pico board based on the RP2040 chip
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一块基于RP2040芯片的Raspberry Pi Pico开发板
- en: • One Adafruit MAX98357A I2S breakout board
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个Adafruit MAX98357A I2S扩展板
- en: • One 8-ohm speaker
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个8欧姆扬声器
- en: • Six push buttons
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 六个按键
- en: • Five 10 kΩ resistors
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 五个10 kΩ电阻
- en: • One breadboard
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一块面包板
- en: • An assortment of hookup wires
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一组连接线
- en: • One Micro USB cable for uploading code to the Pico
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一根Micro USB线，用于上传代码到Pico
- en: '[Hardware Setup](nsp-venkitachalam503045-0008.xhtml#rbh1403)'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件设置](nsp-venkitachalam503045-0008.xhtml#rbh1403)'
- en: You’ll assemble the hardware on a breadboard. [Figure 12-5](nsp-venkitachalam503045-0027.xhtml#fig12-5)
    shows the hookup.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在面包板上组装硬件。[图 12-5](nsp-venkitachalam503045-0027.xhtml#fig12-5)显示了连接方式。
- en: '![](images/nsp-venkitachalam503045-f12005.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12005.jpg)'
- en: 'Figure 12-5: The hardware hookup'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-5：硬件连接
- en: '[Figure 12-6](nsp-venkitachalam503045-0027.xhtml#fig12-6) shows a pin diagram
    of the Pico from the official datasheet, which is a handy reference for your hookup.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-6](nsp-venkitachalam503045-0027.xhtml#fig12-6)显示了Pico的引脚图，来自官方数据手册，是一个方便的连接参考。'
- en: '![](images/nsp-venkitachalam503045-f12006.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12006.jpg)'
- en: 'Figure 12-6: A pin diagram from the Raspberry Pi Pico datasheet'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-6：来自Raspberry Pi Pico数据手册的引脚图
- en: '[Table 12-1](nsp-venkitachalam503045-0027.xhtml#tab12-1) summarizes the electrical
    connections you need to implement on the breadboard. [Figure 12-5](nsp-venkitachalam503045-0027.xhtml#fig12-5)
    shows these connections.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12-1](nsp-venkitachalam503045-0027.xhtml#tab12-1)总结了你需要在面包板上实现的电气连接。[图 12-5](nsp-venkitachalam503045-0027.xhtml#fig12-5)显示了这些连接。'
- en: 'Table 12-1: Electrical Connections'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1：电气连接
- en: '| Pico pin | Connection |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Pico引脚 | 连接 |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GP3 | Push button 1 (other pin to VDD via 10 kΩ resistor) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| GP3 | 按钮 1（另一引脚通过10 kΩ电阻连接到VDD） |'
- en: '| GP4 | Push button 2 (other pin to VDD via 10 kΩ resistor) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| GP4 | 按钮 2（另一引脚通过10 kΩ电阻连接到VDD） |'
- en: '| GP5 | Push button 3 (other pin to VDD via 10 kΩ resistor) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| GP5 | 按钮 3（另一引脚通过10 kΩ电阻连接到VDD） |'
- en: '| GP6 | Push button 4 (other pin to VDD via 10 kΩ resistor) |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| GP6 | 按钮 4（另一引脚通过10 kΩ电阻连接到VDD） |'
- en: '| GP7 | Push button 5 (other pin to VDD via 10 kΩ resistor) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| GP7 | 按钮 5（另一引脚通过10 kΩ电阻连接到VDD） |'
- en: '| RUN | Push button 6 (other pin to GND) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| RUN | 按钮 6（另一引脚连接到GND） |'
- en: '| GP0 | MAX98357A BCLK |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| GP0 | MAX98357A BCLK |'
- en: '| GP1 | MAX98357A LRC |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| GP1 | MAX98357A LRC |'
- en: '| GP2 | MAX98357A DIN |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| GP2 | MAX98357A DIN |'
- en: '| GND | MAX98357A GND |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| GND | MAX98357A GND |'
- en: '| 3V3(OUT) | MAX98357A Vin |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 3V3(OUT) | MAX98357A Vin |'
- en: Once you’ve hooked up the hardware, your project should look like [Figure 12-7](nsp-venkitachalam503045-0027.xhtml#fig12-7).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你连接了硬件，你的项目应该会像 [图 12-7](nsp-venkitachalam503045-0027.xhtml#fig12-7) 中那样。
- en: '![](images/nsp-venkitachalam503045-f12007.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12007.jpg)'
- en: 'Figure 12-7: The fully built hardware'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-7：完整搭建的硬件
- en: Before you start using your Pico, however, you need to set up MicroPython.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在开始使用 Pico 之前，你需要先设置 MicroPython。
- en: '[MicroPython Setup](nsp-venkitachalam503045-0008.xhtml#rbh1404)'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[MicroPython 设置](nsp-venkitachalam503045-0008.xhtml#rbh1404)'
- en: 'Setting up your Raspberry Pi Pico with MicroPython is quite straightforward.
    Follow these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的 Raspberry Pi Pico 和 MicroPython 是相当简单的。请按照以下步骤操作：
- en: 1\. Visit [https://micropython.org](https://micropython.org), go to the Download
    page, and find the Raspberry Pi Pico.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 访问 [https://micropython.org](https://micropython.org)，进入下载页面，找到 Raspberry
    Pi Pico。
- en: 2\. Download the UF2 binary file (version 1.18 or later) containing the MicroPython
    implementation for the Pico.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 下载包含 Pico 的 MicroPython 实现的 UF2 二进制文件（版本 1.18 或更高）。
- en: 3\. Press the white BOOTSEL button on the Pico, and while holding this button
    down, use your Micro USB cable to connect the Pico to your computer. Then release
    the button.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 按下 Pico 上的白色 BOOTSEL 按钮，同时按住此按钮，用你的 Micro USB 电缆将 Pico 连接到电脑。然后松开按钮。
- en: 4\. You should see a folder called *RPI-RP2* pop up on your computer. Drag and
    drop the UF2 file into this folder.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 你应该会看到一个名为 *RPI-RP2* 的文件夹出现在你的电脑上。将 UF2 文件拖放到这个文件夹中。
- en: Once the copying is done and the Pico reboots, you’re all set to code the Pico
    using MicroPython!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦复制完成并且 Pico 重启，你就可以开始使用 MicroPython 编程 Pico 了！
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1403)'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1403)'
- en: The code consists of some initial setup, followed by functions for generating
    and playing the five notes. Then everything comes together in the program’s `main()`
    function. To see the full program, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0027.xhtml#ah1407)
    on [page 275](nsp-venkitachalam503045-0027.xhtml#p275). The code is also available
    on GitHub at [https://github.com/mkvenkit/pp2e/blob/main/karplus_pico/karplus_pico.py](https://github.com/mkvenkit/pp2e/blob/main/karplus_pico/karplus_pico.py).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包括一些初始设置，接着是用于生成和播放五个音符的函数。然后，所有内容都将在程序的 `main()` 函数中汇总。要查看完整的程序，请跳到 [“完整代码”](nsp-venkitachalam503045-0027.xhtml#ah1407)
    第 [275 页](nsp-venkitachalam503045-0027.xhtml#p275)。代码也可以在 GitHub 上找到：[https://github.com/mkvenkit/pp2e/blob/main/karplus_pico/karplus_pico.py](https://github.com/mkvenkit/pp2e/blob/main/karplus_pico/karplus_pico.py)。
- en: '[Setting Up](nsp-venkitachalam503045-0008.xhtml#rbh1405)'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置](nsp-venkitachalam503045-0008.xhtml#rbh1405)'
- en: 'The code begins with some basic setup. First, import the required MicroPython
    modules:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 代码以一些基本的设置开始。首先，导入所需的 MicroPython 模块：
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You import the `time` module for its “sleep” functionality to create timed pauses
    during the execution of the code. The `array` module will let you create arrays
    for sending the sound data via I2S. An array is a more efficient version of a
    Python list, since it requires all members to be of the same data type. You’ll
    use the `random` module to fill the initial buffer with random values (the first
    step in the Karplus-Strong algorithm), and you’ll use the `os` module to check
    if a note has already been saved in the filesystem. Finally, the `I2S` module
    will let you send sound data, and the `Pin` module lets you set up the pin outputs
    of the Pico.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你导入了 `time` 模块来使用其“sleep”功能，以便在代码执行过程中创建定时暂停。`array` 模块让你可以创建数组，通过 I2S 发送声音数据。数组是
    Python 列表的高效版本，因为它要求所有成员具有相同的数据类型。你将使用 `random` 模块填充初始缓冲区，使用随机值（这是 Karplus-Strong
    算法的第一步），并且使用 `os` 模块检查某个音符是否已经在文件系统中保存。最后，`I2S` 模块将让你发送声音数据，`Pin` 模块则让你设置 Pico
    的引脚输出。
- en: 'You complete the setup by declaring some useful information:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过声明一些有用的信息来完成设置：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here you define a dictionary `pmNotes` that maps the name of a note to its integer
    frequency value ❶. You’ll use the names of the notes to save files containing
    the sound data, and you’ll use the frequency values to generate the sounds using
    the Karplus-Strong algorithm. You also define a dictionary `btnNotes` that maps
    the ID of each push button (represented as the integers 0 through 4) to a tuple
    that has the corresponding note name and frequency value ❷. This dictionary controls
    which note is played when the user presses each button.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你定义了一个字典`pmNotes`，它将音符的名称映射到其整数频率值❶。你将使用音符的名称来保存包含声音数据的文件，使用频率值来通过 Karplus-Strong
    算法生成声音。你还定义了一个字典`btnNotes`，它将每个按键的ID（以整数0到4表示）映射到一个元组，元组包含对应的音符名称和频率值❷。这个字典控制了用户按下每个按钮时播放的音符。
- en: Finally, you define the sampling rate as 16,000 Hz ❸. This is the number of
    sound amplitude values per second that you’ll be sending out via I2S. Notice that
    this is much lower than the sampling rate of 44,100 Hz used in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04).
    This is because of the limited memory on the Pico compared to a standard computer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将采样率定义为16,000 Hz❸。这意味着每秒将有16,000个声音幅度值通过 I2S 输出。请注意，这比在[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)中使用的44,100
    Hz采样率要低得多。这是因为与标准计算机相比，Pico 的内存有限。
- en: '[Generating the Notes](nsp-venkitachalam503045-0008.xhtml#rbh1406)'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[生成音符](nsp-venkitachalam503045-0008.xhtml#rbh1406)'
- en: 'You generate the five notes of the pentatonic scale with the help of two functions:
    `generate_note()` and `create_notes()`. The `generate_note()` function uses the
    Karplus-Strong algorithm to calculate the amplitude values for a single note,
    while `create_notes()` coordinates generating all five notes and saving their
    sample data to the Pico’s filesystem. Let’s consider the `generate_note()` function
    first. (You implemented a similar function in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04),
    so this might be a good time to review the original implementation.)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过两个函数：`generate_note()`和`create_notes()`来生成五个音阶音符。`generate_note()`函数使用 Karplus-Strong
    算法来计算单个音符的幅度值，而`create_notes()`函数则协调生成所有五个音符并将它们的样本数据保存到 Pico 的文件系统中。我们先来看一下`generate_note()`函数。（你在[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)中实现了一个类似的函数，因此这可能是复习原始实现的好时机。）
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function starts by setting `nSamples`, the length of the samples buffer
    that will hold the final audio data, to `SR`, the sampling rate. Since `SR` is
    the number of samples per second, this implies that you’ll be creating a one-second
    audio clip. Then you compute `N`, the number of samples in the Karplus-Strong
    ring buffer, by dividing the sampling rate by the frequency of the note being
    generated.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先设置`nSamples`，即将保存最终音频数据的样本缓冲区的长度，等于`SR`，即采样率。由于`SR`是每秒的样本数，这意味着你将创建一个持续一秒钟的音频片段。然后，你通过将采样率除以正在生成的音符的频率，来计算
    Karplus-Strong 环形缓冲区中的样本数`N`。
- en: Next, you initialize your buffers. First you create the ring buffer with random
    initial values ❶. The `random.random()` method returns values in the range [0.0,
    1.0], so `2*random.random() - 1` scales the values to the range [−1.0, 1.0]. Remember,
    you need both positive and negative amplitudes for the algorithm. Notice that
    you’re implementing the ring buffer as a regular Python list, instead of as a
    `deque` object like you used in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04).
    MicroPython’s `deque` implementation has restrictions and doesn’t give you what
    you need for a ring buffer. Instead, you’ll just use the regular `append()` and
    `pop()` list methods to add and remove elements from the buffer. You also create
    the samples buffer as an `array` object of length `nSamples` filled with zeros
    ❷. The `'h'` argument specifies that each element in this array is a *signed short*,
    a 16-bit value that can be positive or negative. Since each sample will be represented
    by a 16-bit value, this is exactly what you need.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你初始化缓冲区。首先，你创建了一个带有随机初始值的环形缓冲区❶。`random.random()`方法返回[0.0, 1.0]范围内的值，因此`2*random.random()
    - 1`将这些值缩放到[−1.0, 1.0]范围内。记住，你需要正负幅度值来进行算法。注意，你将环形缓冲区实现为普通的 Python 列表，而不是像在[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)中使用的`deque`对象。MicroPython
    的`deque`实现有一些限制，无法满足环形缓冲区的需求。因此，你将使用普通的`append()`和`pop()`列表方法来向缓冲区添加和移除元素。你还创建了一个样本缓冲区，作为一个长度为`nSamples`的`array`对象，初始值为零❷。`'h'`参数指定该数组中的每个元素是一个*带符号短整型*，即一个16位值，可以是正数或负数。由于每个样本将由16位值表示，因此这正是你需要的。
- en: Next, you iterate over the items in the `samples` array and build up the audio
    clip using the Karplus-Strong algorithm. You take the first sample value in the
    ring buffer and scale it from range [−1.0, 1.0] to range [−32767, 32767] ❸. (The
    range of a 16-bit signed short is [−32767, 32768]. You scale the amplitude values
    to be as high as possible, which will give you the highest possible volume of
    sound output.) Then you calculate an attenuated average of the first two samples
    in the ring buffer ❹. (Here, `0.4975` is the same as `0.995*0.5` from the original
    implementation.) You use `append()` to add the new amplitude value to the end
    of the ring buffer, while using `pop()` to remove the first element, thus maintaining
    the buffer’s fixed size. At the end of the loop, the samples buffer is full, so
    you return it for further processing ❺.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你遍历 `samples` 数组中的项目，并使用 Karplus-Strong 算法构建音频片段。你取环形缓冲区中的第一个样本值，并将其从范围
    [−1.0, 1.0] 缩放到范围 [−32767, 32767] ❸。（16 位有符号短整型的范围是 [−32767, 32768]。你将幅度值缩放到尽可能高，这样可以获得最高的音量输出。）然后，你计算环形缓冲区中前两个样本的衰减平均值
    ❹。（这里，`0.4975` 与原始实现中的 `0.995*0.5` 相同。）你使用 `append()` 将新的幅度值添加到环形缓冲区的末尾，同时使用 `pop()`
    移除第一个元素，从而保持缓冲区的固定大小。循环结束时，样本缓冲区已满，因此你将其返回以便进一步处理 ❺。
- en: NOTE Using `append()` and `pop()` to update the ring buffer works, but it isn’t
    an efficient method of computation. We’ll look more at optimization in [“Experiments!”](nsp-venkitachalam503045-0027.xhtml#ah1406)
    on [page 273](nsp-venkitachalam503045-0027.xhtml#p273).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 使用 `append()` 和 `pop()` 来更新环形缓冲区是有效的，但这并不是一种高效的计算方法。我们将在 [“实验！”](nsp-venkitachalam503045-0027.xhtml#ah1406)
    中进一步探讨优化，在 [第 273 页](nsp-venkitachalam503045-0027.xhtml#p273)。
- en: 'Now let’s consider the `create_notes()` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下 `create_notes()` 函数：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You don’t want to have to run the Karplus-Strong algorithm every time the user
    presses a button to play a note, as that would be too slow. Instead, this function
    creates the notes the first time the code is run and stores them in the Pico’s
    filesystem as *.bin* files. Then, as soon as the user presses a button, you’ll
    be able to read the appropriate file and output the sound data via I2S.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想每次用户按下按钮播放音符时都运行 Karplus-Strong 算法，因为那样会太慢。相反，这个函数在第一次运行代码时创建音符，并将它们以 *.bin*
    文件的形式存储在 Pico 的文件系统中。然后，一旦用户按下按钮，你就能读取相应的文件，并通过 I2S 输出声音数据。
- en: You begin by using the `os` module to list the files on the Pico ❶. (There’s
    no “hard disk” on the Pico. Rather, a flash chip on the Pico board is used to
    store data, and MicroPython provides a way to access this data like a normal filesystem.)
    Then you iterate through the items in the `pmNotes` dictionary, which maps note
    names to frequencies ❷. For each note, you generate a filename based on its name
    in the dictionary (for example, *C4.bin*) ❸. If a file with that name exists in
    the directory ❹, you’ve generated that note already, so you can skip to the next
    one. Otherwise, you generate the sound samples for that note using the `generate_note()`
    function ❺. Then you create a binary file with the appropriate name ❻ and write
    the samples to it ❼. Finally, you clean up by closing the file ❽.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先使用 `os` 模块列出 Pico 上的文件 ❶。（Pico 上没有“硬盘”，而是 Pico 板上的闪存芯片用于存储数据，MicroPython
    提供了一种像普通文件系统一样访问这些数据的方法。）然后你遍历 `pmNotes` 字典中的项目，该字典将音符名称映射到频率 ❷。对于每个音符，你根据字典中的名称生成文件名（例如
    *C4.bin*） ❸。如果该目录中已经存在该名称的文件 ❹，则说明你已经生成了该音符，可以跳到下一个音符。否则，你使用 `generate_note()`
    函数生成该音符的声音样本 ❺。然后，你创建一个适当名称的二进制文件 ❻ 并将样本写入其中 ❼。最后，通过关闭文件来进行清理 ❽。
- en: The first time you run the code, `create_notes()` will run the `generate_note()`
    function to create a file for each note using the Karplus-Strong algorithm. This
    will create the files *C4.bin*, *Eb.bin*, *F.bin*, *G.bin*, and *Bb.bin* on the
    Pico. On subsequent runs, the function will find these files still in place, so
    it won’t need to create them again.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行代码时，`create_notes()` 会运行 `generate_note()` 函数，为每个音符创建一个文件，使用 Karplus-Strong
    算法。这将会在 Pico 上创建 *C4.bin*、*Eb.bin*、*F.bin*、*G.bin* 和 *Bb.bin* 文件。在随后的运行中，函数会发现这些文件仍然存在，因此不需要重新创建它们。
- en: '[Playing a Note](nsp-venkitachalam503045-0008.xhtml#rbh1407)'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[播放音符](nsp-venkitachalam503045-0008.xhtml#rbh1407)'
- en: 'The `play_note()` function plays one of the notes from the pentatonic scale
    by outputting the samples using the I2S protocol. Here’s the definition:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`play_note()` 函数通过使用 I2S 协议输出样本来播放五声音阶中的一个音符。以下是定义：'
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The function has two arguments: `note`, a tuple in the form `(''C4'', 262)`
    conveying the note name and frequency, and `audio_out`, an instance of the `I2S`
    module used for sound output. You first create the appropriate *.bin* filename
    based on the name of the note to be played ❶. Then you open the file ❷. You expect
    the file to exist at this point, so if the open fails, you just return from the
    function.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有两个参数：`note`，一个元组，形式为`('C4', 262)`，表示音符名称和频率；`audio_out`，是一个`I2S`模块的实例，用于声音输出。你首先根据要播放的音符名称创建适当的*.bin*文件名
    ❶。然后打开该文件 ❷。你期望此时文件已经存在，因此如果打开失败，直接从函数返回。
- en: The rest of the function outputs the audio data via I2S, working in batches
    of 1,000 samples. To mediate the data transfer, you create a MicroPython `bytearray`
    of 1,000 samples ❸ and a `memoryview` of the samples ❹. This is a MicroPython
    optimization technique to prevent the whole array from being copied when a slice
    of the array is passed into other functions such as `file_samples.readinto()`
    and `audio_out.write()`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分通过I2S输出音频数据，按1,000个样本为一批进行工作。为了调解数据传输，你创建了一个MicroPython的`bytearray`，包含1,000个样本
    ❸，并且创建了一个样本的`memoryview` ❹。这是一个MicroPython优化技术，可以避免在将数组切片传递给`file_samples.readinto()`和`audio_out.write()`等函数时，整个数组被复制。
- en: NOTE A *slice* of an array represents a range of values within that array. For
    example, `a[100:200]` is a slice representing array values `a[100]` through `a[199]`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：数组的*切片*表示数组中一段值的范围。例如，`a[100:200]`是一个切片，表示数组中`a[100]`到`a[199]`的值。
- en: Next, you start a `while` loop to read samples from the file ❺. In the loop,
    you read a batch of samples from the file into the `memoryview` object using the
    `readinto()` method ❻, which returns the number of samples read (`num_read`).
    You output the samples from the `memoryview` object via I2S using the `audio_out.write()`
    method ❽. The `[:num_read]` slice notation ensures you write out the same number
    of samples you read in. You handle any exceptions at ❾. You’re done outputting
    data when you get to the point where zero samples are read into the `memoryview`
    object ❼, in which case you can break out of the `while` loop and close the *.bin*
    file ❿.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你开始一个`while`循环，从文件中读取样本 ❺。在循环中，你使用`readinto()`方法 ❻将一批样本读取到`memoryview`对象中，该方法返回读取的样本数量（`num_read`）。你通过I2S使用`audio_out.write()`方法
    ❽将样本从`memoryview`对象输出。`[:num_read]`的切片表示法确保你输出与读取的样本数量相同。你在❾处处理任何异常。当`memoryview`对象中读取到零个样本时
    ❼，即已完成数据输出，你可以跳出`while`循环并关闭*.bin*文件 ❿。
- en: '[Writing the main() Function](nsp-venkitachalam503045-0008.xhtml#rbh1408)'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[编写main()函数](nsp-venkitachalam503045-0008.xhtml#rbh1408)'
- en: 'Now let’s look at the `main()` function, which brings all the code together:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`main()`函数，它将所有代码结合在一起：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function starts by setting up the Pico’s onboard LED ❶. It’s toggled ON
    at the start to indicate the Pico is busy initializing. Next, you call the `create_notes()`
    function ❷. As we discussed, this function will create the *.bin* files for the
    notes only if they don’t already exist in the filesystem. To manage the audio
    output, you instantiate the `I2S` module as `audio_out` ❸. The module requires
    a number of input parameters. The first parameter is the I2S ID, which is `0`
    for the Raspberry Pi Pico. Next come the pin numbers corresponding to the clock
    (SCK), word select (WS), and data (SD) signals. We discussed these signals in
    [“I2S Protocol”](nsp-venkitachalam503045-0027.xhtml#bh1402) [on page 262](nsp-venkitachalam503045-0027.xhtml#p262).
    You then set the I2S mode to `TX`, indicating this is an I2S transmitter. Next,
    you set `bits` to `16`, indicating the number of bits per sample, and `format`
    to `MONO`, since there’s only one audio output channel. You set the sampling rate
    to `SR`, and lastly, you set the value for the internal I2S buffer `ibuf` to `2000`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数开始时设置了Pico的板载LED ❶。它在开始时被切换为开启状态，以指示Pico正在忙于初始化。接下来，调用`create_notes()`函数 ❷。正如我们所讨论的，这个函数只有在*.bin*文件在文件系统中不存在的情况下才会创建相应的音符文件。为了管理音频输出，你实例化了`I2S`模块为`audio_out`
    ❸。该模块需要一些输入参数。第一个参数是I2S ID，对于Raspberry Pi Pico来说是`0`。接下来是与时钟（SCK）、字选择（WS）和数据（SD）信号对应的引脚编号。我们在[“I2S协议”](nsp-venkitachalam503045-0027.xhtml#bh1402)
    [第262页](nsp-venkitachalam503045-0027.xhtml#p262)中讨论了这些信号。然后你将I2S模式设置为`TX`，表示这是一个I2S发送器。接着，将`bits`设置为`16`，表示每个样本的位数，`format`设置为`MONO`，因为只有一个音频输出通道。将采样率设置为`SR`，最后，将内部I2S缓冲区`ibuf`的值设置为`2000`。
- en: NOTE A smooth audio experience requires an uninterrupted stream of data output.
    MicroPython uses a special hardware module in the Pico called Direct Memory Access
    (DMA) for this. DMA can transfer data from the memory to the I2S output without
    involving the CPU directly. The CPU just needs to keep an internal buffer (`ibuf`
    in the code) filled with data and is free to do other things while the DMA is
    doing its job. The size of the internal buffer is typically set to at least twice
    the size of the audio output so the DMA doesn’t run out of data to transfer, which
    would result in distorted audio. In this case, you’ll be transferring 1,000 bytes
    to I2S at a time, so you set `ibuf` to twice that.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：流畅的音频体验需要一个不断输出数据的流。MicroPython利用Pico中的一个特殊硬件模块，称为直接内存访问（DMA）来实现这一点。DMA可以将数据从内存传输到I2S输出，而不直接涉及CPU。CPU只需要保持内部缓冲区（代码中的`ibuf`）充满数据，并且可以在DMA执行任务时自由地做其他事情。内部缓冲区的大小通常设置为至少是音频输出大小的两倍，以避免DMA没有足够的数据进行传输，从而导致音频失真。在本例中，你将一次传输1,000字节到I2S，因此你将`ibuf`设置为它的两倍。
- en: Next, you need to set up the buttons so that notes will play when the buttons
    are pressed. For this, you create a list of `Pin` objects called `btns` ❹. For
    each button in the list, you specify the pin number, the data direction of the
    pin (`Pin.IN`, or input, in this case), and whether the pin has a pull-up resistor.
    In this case, all the push button pins have a 10 kΩ resistor pull-up on them.
    This means that by default the pins’ voltages are “pulled up” to VDD, or 3.3 V,
    and when the buttons are pushed, the voltage drops to GND, or 0 V. You’ll use
    this fact to detect button presses.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要设置按钮，以便在按钮按下时播放音符。为此，你创建一个`Pin`对象的列表，名为`btns`❹。对于列表中的每个按钮，你需要指定引脚号、引脚的数据方向（在此情况下为`Pin.IN`，即输入），以及引脚是否具有上拉电阻。在本例中，所有按钮的引脚上都有一个10
    kΩ的上拉电阻。这意味着默认情况下，引脚的电压会被“拉高”到VDD，即3.3 V，而当按钮被按下时，电压会下降到GND，即0 V。你将利用这一点来检测按钮按下。
- en: Once the setup is done, you play a C4 note using the `play_note()` function
    to indicate the Pico is ready to accept button presses ❺, and you also toggle
    the onboard LED to OFF ❻. Then you start a `while` loop to monitor for button
    presses. Within this loop, you use a `for` loop to check whether any of the five
    buttons have a value of `0`, indicating the button is pressed. If so, you look
    up the note corresponding to that button in the `btnNotes` dictionary and play
    it using `play_note()` ❼. Once the note is done playing, you break out of the
    `for` loop and wait for 0.2 seconds ❽ before continuing with the outer `while`
    loop.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置完成，你可以通过`play_note()`函数播放一个C4音符，表示Pico已准备好接受按钮按下的操作❺，同时你也将板载LED关闭❻。然后，你启动一个`while`循环来监测按钮的按下。在这个循环中，你使用`for`循环检查五个按钮中是否有任何一个按钮的值为`0`，表示该按钮被按下。如果是这样，你会在`btnNotes`字典中查找对应按钮的音符，并通过`play_note()`播放该音符❼。音符播放完成后，你会跳出`for`循环，等待0.2秒❽后继续执行外部的`while`循环。
- en: '[Running the Pico Code](nsp-venkitachalam503045-0008.xhtml#rah1404)'
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行Pico代码](nsp-venkitachalam503045-0008.xhtml#rah1404)'
- en: 'Now you’re ready to test your project! To run the code on the Pico, it’s useful
    to install two pieces of software. The first is Thonny, an open source, easy-to-use
    Python integrated development environment (IDE), which you can download from [https://thonny.org](https://thonny.org).
    Thonny makes it easy to copy your project code to the Raspberry Pi Pico and manage
    files on the Pico. A typical development cycle is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好测试你的项目了！为了在Pico上运行代码，安装两个软件是很有帮助的。第一个是Thonny，一个开源且易于使用的Python集成开发环境（IDE），你可以从[https://thonny.org](https://thonny.org)下载。Thonny使得将你的项目代码复制到Raspberry
    Pi Pico并管理Pico上的文件变得非常容易。一个典型的开发周期如下：
- en: 1\. Connect your Pico to your computer via USB.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 通过USB将Pico连接到你的计算机。
- en: 2\. Open Thonny. Click the Python version number in the bottom-right of the
    window and change the interpreter to **MicroPython (Raspberry Pi Pico)**.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 打开Thonny。点击窗口右下角的Python版本号，将解释器更改为**MicroPython (Raspberry Pi Pico)**。
- en: 3\. Copy your code to Thonny and click the red **Stop/Restart** button to stop
    the code from running on the Pico. This will show the Python interpreter at the
    bottom of the IDE.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 将你的代码复制到Thonny中，点击红色的**停止/重启**按钮，停止代码在Pico上的运行。这将显示IDE底部的Python解释器。
- en: 4\. Edit your code in Thonny.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 在Thonny中编辑你的代码。
- en: 5\. When you’re ready to save the file, select **File‣Save As**, and you’ll
    be prompted to save it on the Raspberry Pi Pico. The next dialog will also list
    the files on the Pico. Save your code as *main.py*. You can also use this dialog
    to right-click and delete existing files on the Pico.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5. 当你准备好保存文件时，选择**文件‣另存为**，系统会提示你将文件保存在树莓派Pico上。接下来的对话框也会列出Pico上的文件。将你的代码保存为*main.py*。你还可以使用此对话框右键点击并删除Pico上的现有文件。
- en: 6\. After saving the file, press the extra push button you hooked up to the
    RUN pin on the Pico, and your code will start running.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6. 在保存文件后，按下你连接到Pico上的RUN引脚的额外按键，你的代码就会开始运行。
- en: 7\. Anytime you want to edit the code, click the **Stop/Restart** button in
    the IDE and Thonny will drop you to the Python interpreter on the Pico.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7. 每次你想编辑代码时，点击IDE中的**停止/重启**按钮，Thonny会将你带到Pico上的Python解释器。
- en: The other useful piece of software for working with the Pico is CoolTerm, which
    you can download from [http://freeware.the-meiers.org](http://freeware.the-meiers.org).
    CoolTerm lets you monitor the Pico’s serial output. All print statements from
    your program will end up here. To use CoolTerm, ensure that you aren’t “stopped”
    in Thonny. The Pico code should be in the running state, since the Pico can’t
    connect to both Thonny and CoolTerm at the same time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对Pico工作非常有用的软件是CoolTerm，你可以从[http://freeware.the-meiers.org](http://freeware.the-meiers.org)下载它。CoolTerm可以让你监控Pico的串行输出。你程序中的所有打印语句都会出现在这里。使用CoolTerm时，请确保Thonny没有“停止”状态。Pico的代码应该处于运行状态，因为Pico不能同时连接Thonny和CoolTerm。
- en: Once you have the code running, press the push buttons one by one and you’ll
    hear the notes of a nice pentatonic scale coming out of your speaker. [Figure
    12-8](nsp-venkitachalam503045-0027.xhtml#fig12-8) shows the serial output for
    a typical session.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码开始运行，依次按下按钮，你将会听到从扬声器中传出的美妙五声音阶音符。[图12-8](nsp-venkitachalam503045-0027.xhtml#fig12-8)展示了典型会话的串行输出。
- en: '![](images/nsp-venkitachalam503045-f12008.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f12008.jpg)'
- en: 'Figure 12-8: A sample Raspberry Pi Pico output in CoolTerm'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-8：CoolTerm中树莓派Pico的输出示例
- en: See what melodies you can compose and play using your digital instrument’s five
    push buttons!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能用数字乐器的五个按键来组成和演奏什么旋律！
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1405)'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah1405)'
- en: In this chapter, you adapted your Karplus-Strong algorithm implementation from
    [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04) to run on a tiny microcontroller
    and built a digital musical instrument using a Raspberry Pi Pico. You learned
    how to run Python (in the form of MicroPython) on the Pico, as well as how to
    transmit audio data using the I2S protocol. You also learned about the limitations
    of adapting code from a personal computer to a resource-constrained device like
    the Pico.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将你的Karplus-Strong算法实现从[第4章](nsp-venkitachalam503045-0016.xhtml#ch04)移植到一个微型控制器上，并使用树莓派Pico构建了一个数字乐器。你学习了如何在Pico上运行Python（以MicroPython的形式），以及如何使用I2S协议传输音频数据。你还了解了将代码从个人电脑移植到像Pico这样资源有限的设备时的局限性。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1406)'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah1406)'
- en: 1\. The MAX98357A I2S board lets you increase the volume (gain) of the output.
    Look at the datasheet of this board and try to boost the sound coming from the
    speaker.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. MAX98357A I2S板可以让你增加输出音量（增益）。查看该板的 datasheet，并尝试提升从扬声器传出的声音。
- en: '2\. The current implementation of `generate_note()` isn’t very fast. It didn’t
    matter that much for this project, because you generate the notes only once. Still,
    can you make the method faster? Here are a few strategies to try:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 当前的`generate_note()`实现速度并不是很快。对于这个项目来说，这个问题并不算太重要，因为你只需要生成一次音符。然而，你能让这个方法更快吗？这里有一些策略可以尝试：
- en: a. Instead of using `append()` and `pop()` operations on the `buf` list, turn
    the list into a circular buffer by keeping tracking of the current position in
    the list and incrementing it using the modulo operation `%N`.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 不要在`buf`列表上使用`append()`和`pop()`操作，而是通过跟踪当前列表的位置并使用模运算`%N`来使列表变成循环缓冲区。
- en: b. Use integer operations instead of floating point. You’ll have to think about
    how the initial random values will be generated and scaled.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 使用整数操作代替浮点数操作。你需要考虑如何生成和缩放初始随机值。
- en: 'The Language Reference page in the MicroPython documentation ([https://docs.micropython.org](https://docs.micropython.org/))
    has an article on maximizing the speed of your code. The documentation also suggests
    how you can test your results. First, define a function to measure timing:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MicroPython文档中的语言参考页面（[https://docs.micropython.org](https://docs.micropython.org/)）有一篇关于如何最大化代码速度的文章。文档还建议了如何测试你的结果。首先，定义一个函数来测量时间：
- en: '[PRE6]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then use `timed_function()` as a *decorator* for the function you want to time:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后将`timed_function()`作为*装饰器*应用于你想要计时的函数：
- en: '[PRE7]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you call `generateNote()` in your main code, you’ll see something like
    this in the serial output:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在主代码中调用`generateNote()`时，你会在串口输出中看到类似这样的内容：
- en: '[PRE8]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 3\. When you press a hardware push button, it doesn’t just go from ON to OFF,
    or the reverse. The spring-loaded contacts inside the button bounce between ON
    and OFF multiple times in a fraction of a second, triggering multiple software
    events for one physical press of the button. Think about how this could affect
    your project, and then read up on *debouncing*, a class of techniques for mitigating
    the problem. What steps can you take to debounce your buttons?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 当你按下硬件按钮时，它并不会直接从开到关，或反向切换。按钮内部的弹簧接触点会在开和关之间反复跳动，发生多次开关操作，在极短的时间内触发多个软件事件。想一想这会如何影响你的项目，然后了解一下*去抖动*，这是一类减少此问题的技术。你可以采取哪些步骤来去抖动你的按钮？
- en: 4\. When you press a button, a new note isn’t played until the current note
    is done playing. How can you abruptly stop playing the current note when a new
    button is pressed and switch to playing the new note immediately?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 当你按下按钮时，直到当前音符播放完毕，才会播放新的音符。如果在按下新按钮时你想立刻停止当前音符的播放并切换到新音符，应该怎么做？
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah1407)'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah1407)'
- en: Here’s the full code listing for this project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个项目的完整代码列表。
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
