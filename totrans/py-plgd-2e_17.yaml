- en: '[12](nsp-venkitachalam503045-0008.xhtml#rch12)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Karplus-Strong on a Raspberry Pi Pico
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04), you learned how to
    make plucked string sounds using the Karplus-Strong algorithm. You saved the generated
    sounds as WAV files and played notes from a pentatonic musical scale on your computer.
    In this chapter, you’ll learn how to shrink that project to fit on a tiny piece
    of hardware: the Raspberry Pi Pico.'
  prefs: []
  type: TYPE_NORMAL
- en: The Pico (see [Figure 12-1](nsp-venkitachalam503045-0027.xhtml#fig12-1)) is
    built using an RP2040 microcontroller chip, which has just 264KB of random access
    memory (RAM). Compare that to the tens of gigabytes of RAM on the typical personal
    computer! The Pico also has 2MB of flash memory on a separate chip, in contrast
    to a normal computer’s hundreds of gigabytes of hard disk space. Despite these
    limitations, however, the Pico is still extremely capable. It can perform many
    useful services, while also being much cheaper and less power-hungry than a regular
    computer. Your watch, your air conditioning unit, your clothes dryer, your car,
    your phone—tiny microcontrollers like the RP2040 are everywhere!
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f12001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: The Raspberry Pi Pico'
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal for this project is to use the Raspberry Pi Pico to create a musical
    instrument with five buttons. Pressing each button will play a note from a pentatonic
    scale, generated with the Karplus-Strong algorithm. Some of the concepts you’ll
    learn from this project are:'
  prefs: []
  type: TYPE_NORMAL
- en: • Programming a microcontroller using MicroPython, an implementation of Python
    optimized to run on devices like the Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Building a simple audio circuit on a breadboard using the Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Using the I2S digital audio protocol and an I2S amplifier to send audio data
    to a speaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Implementing the Karplus-Strong algorithm from [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04)
    on a resource-constrained microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1401)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We discussed the Karplus-Strong algorithm in detail in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04),
    so we won’t revisit it here. Instead, we’ll focus on what makes this version of
    the project different. Your program from [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04)
    was designed to run on a laptop or desktop computer. Thanks to the computer’s
    ample RAM and hard disk resources, it had no problems creating WAV files using
    the Karplus-Strong algorithm and playing audio through speakers with `pyaudio`.
    The challenge now is to fit the project code onto a resource-constrained Raspberry
    Pi Pico. This will require the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: • Using a smaller audio sampling rate to reduce memory requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Using a simple binary file to store raw generated samples rather than a WAV
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Using the I2S protocol to send out the audio data to an external audio amplifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Using memory management techniques to avoid copying the same data repeatedly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll discuss the specifics of these modifications as they arise.
  prefs: []
  type: TYPE_NORMAL
- en: '[Input and Output](nsp-venkitachalam503045-0008.xhtml#rbh1401)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make the project interactive, you’ll want the Pico to generate sounds in
    response to user input. You’ll need to wire five push buttons to the Pico for
    this purpose, since the Pico doesn’t have a keyboard or mouse. (You’ll use a sixth
    push button to run the program.) We also need to figure out how to produce the
    sound output, since unlike a personal computer, the Pico board doesn’t have any
    built-in speakers. [Figure 12-2](nsp-venkitachalam503045-0027.xhtml#fig12-2) shows
    a block diagram of the project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f12002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: A block diagram of the project'
  prefs: []
  type: TYPE_NORMAL
- en: When you press a button, the MicroPython code running on the Pico will generate
    a plucked string sound using the Karplus-Strong algorithm. The digital sound samples
    produced by the algorithm will be sent to a separate MAX98357A amplifier board,
    which decodes the digital data into an analog audio signal. The MAX98357A also
    amplifies the analog signal, which allows you to connect its output to an external
    8-ohm speaker so you can hear the audio. [Figure 12-3](nsp-venkitachalam503045-0027.xhtml#fig12-3)
    shows the Adafruit MAX98357A board.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f12003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: An Adafruit MAX98357A I2S amplifier board'
  prefs: []
  type: TYPE_NORMAL
- en: The Pi Pico needs to send data to the amplifier board in a certain format for
    it to successfully be interpreted as an audio signal. Enter the I2S protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '[The I2S Protocol](nsp-venkitachalam503045-0008.xhtml#rbh1402)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Inter-IC Sound (I2S) protocol* is a standard for sending digital audio
    data between devices. It’s a simple, convenient way to get quality audio output
    from a microcontroller. The protocol transmits audio using three digital signals,
    which are shown in [Figure 12-4](nsp-venkitachalam503045-0027.xhtml#fig12-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f12004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-4: The I2S protocol'
  prefs: []
  type: TYPE_NORMAL
- en: The first signal, SCK, is the *clock*, a signal that alternates between high
    and low at a fixed speed. This sets the rate of data transmission. Next, WS is
    the *word select* signal. It steadily alternates between high and low to indicate
    which audio channel, left or right, is being sent at any given moment. Finally,
    SD is the *serial data* signal, which carries the actual audio information, in
    the form of N-bit binary values representing the amplitude of the sound.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this works, let’s consider an example. Say you want to send
    stereo audio at a sampling rate of 16,000 Hz and you want the amplitude of each
    sound sample to be a 16-bit value. The frequency of WS should be the same as the
    sampling rate, since that’s the rate at which you’re sending each amplitude value.
    This way, the WS signal will alternate between high and low 16,000 times per second;
    when it’s high, SD will send the amplitude value of one audio channel, and when
    it’s low, SD will send the amplitude value of the other audio channel. Since each
    amplitude value for each channel is made up of 16 bits, SD has to transmit at
    a rate that’s 16 × 2 = 32 times faster than the sampling rate. The clock controls
    the rate of transmission, so SCK’s frequency must be 16,000 Hz × 32 = 512,000 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, the Pico will be the I2S transmitter, so it will generate
    the SCK, WS, and SD signals. MicroPython actually has a fully implemented `I2S`
    module for the Pico, so much of the work generating the signals will be done for
    you, behind the scenes. As you’ve already seen, the Pico will send the signals
    to a MAX98357A board, which is specifically designed to receive audio data through
    the I2S protocol. Then the board converts the I2S data into an analog audio signal
    that can be played through a speaker.
  prefs: []
  type: TYPE_NORMAL
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1402)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll program the project for the Raspberry Pi Pico using MicroPython. You’ll
    need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • One Raspberry Pi Pico board based on the RP2040 chip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One Adafruit MAX98357A I2S breakout board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One 8-ohm speaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Six push buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Five 10 kΩ resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • An assortment of hookup wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One Micro USB cable for uploading code to the Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hardware Setup](nsp-venkitachalam503045-0008.xhtml#rbh1403)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll assemble the hardware on a breadboard. [Figure 12-5](nsp-venkitachalam503045-0027.xhtml#fig12-5)
    shows the hookup.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f12005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-5: The hardware hookup'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-6](nsp-venkitachalam503045-0027.xhtml#fig12-6) shows a pin diagram
    of the Pico from the official datasheet, which is a handy reference for your hookup.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f12006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-6: A pin diagram from the Raspberry Pi Pico datasheet'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-1](nsp-venkitachalam503045-0027.xhtml#tab12-1) summarizes the electrical
    connections you need to implement on the breadboard. [Figure 12-5](nsp-venkitachalam503045-0027.xhtml#fig12-5)
    shows these connections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-1: Electrical Connections'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pico pin | Connection |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GP3 | Push button 1 (other pin to VDD via 10 kΩ resistor) |'
  prefs: []
  type: TYPE_TB
- en: '| GP4 | Push button 2 (other pin to VDD via 10 kΩ resistor) |'
  prefs: []
  type: TYPE_TB
- en: '| GP5 | Push button 3 (other pin to VDD via 10 kΩ resistor) |'
  prefs: []
  type: TYPE_TB
- en: '| GP6 | Push button 4 (other pin to VDD via 10 kΩ resistor) |'
  prefs: []
  type: TYPE_TB
- en: '| GP7 | Push button 5 (other pin to VDD via 10 kΩ resistor) |'
  prefs: []
  type: TYPE_TB
- en: '| RUN | Push button 6 (other pin to GND) |'
  prefs: []
  type: TYPE_TB
- en: '| GP0 | MAX98357A BCLK |'
  prefs: []
  type: TYPE_TB
- en: '| GP1 | MAX98357A LRC |'
  prefs: []
  type: TYPE_TB
- en: '| GP2 | MAX98357A DIN |'
  prefs: []
  type: TYPE_TB
- en: '| GND | MAX98357A GND |'
  prefs: []
  type: TYPE_TB
- en: '| 3V3(OUT) | MAX98357A Vin |'
  prefs: []
  type: TYPE_TB
- en: Once you’ve hooked up the hardware, your project should look like [Figure 12-7](nsp-venkitachalam503045-0027.xhtml#fig12-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f12007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-7: The fully built hardware'
  prefs: []
  type: TYPE_NORMAL
- en: Before you start using your Pico, however, you need to set up MicroPython.
  prefs: []
  type: TYPE_NORMAL
- en: '[MicroPython Setup](nsp-venkitachalam503045-0008.xhtml#rbh1404)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting up your Raspberry Pi Pico with MicroPython is quite straightforward.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Visit [https://micropython.org](https://micropython.org), go to the Download
    page, and find the Raspberry Pi Pico.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Download the UF2 binary file (version 1.18 or later) containing the MicroPython
    implementation for the Pico.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Press the white BOOTSEL button on the Pico, and while holding this button
    down, use your Micro USB cable to connect the Pico to your computer. Then release
    the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. You should see a folder called *RPI-RP2* pop up on your computer. Drag and
    drop the UF2 file into this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the copying is done and the Pico reboots, you’re all set to code the Pico
    using MicroPython!
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1403)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code consists of some initial setup, followed by functions for generating
    and playing the five notes. Then everything comes together in the program’s `main()`
    function. To see the full program, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0027.xhtml#ah1407)
    on [page 275](nsp-venkitachalam503045-0027.xhtml#p275). The code is also available
    on GitHub at [https://github.com/mkvenkit/pp2e/blob/main/karplus_pico/karplus_pico.py](https://github.com/mkvenkit/pp2e/blob/main/karplus_pico/karplus_pico.py).
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Up](nsp-venkitachalam503045-0008.xhtml#rbh1405)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code begins with some basic setup. First, import the required MicroPython
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You import the `time` module for its “sleep” functionality to create timed pauses
    during the execution of the code. The `array` module will let you create arrays
    for sending the sound data via I2S. An array is a more efficient version of a
    Python list, since it requires all members to be of the same data type. You’ll
    use the `random` module to fill the initial buffer with random values (the first
    step in the Karplus-Strong algorithm), and you’ll use the `os` module to check
    if a note has already been saved in the filesystem. Finally, the `I2S` module
    will let you send sound data, and the `Pin` module lets you set up the pin outputs
    of the Pico.
  prefs: []
  type: TYPE_NORMAL
- en: 'You complete the setup by declaring some useful information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here you define a dictionary `pmNotes` that maps the name of a note to its integer
    frequency value ❶. You’ll use the names of the notes to save files containing
    the sound data, and you’ll use the frequency values to generate the sounds using
    the Karplus-Strong algorithm. You also define a dictionary `btnNotes` that maps
    the ID of each push button (represented as the integers 0 through 4) to a tuple
    that has the corresponding note name and frequency value ❷. This dictionary controls
    which note is played when the user presses each button.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you define the sampling rate as 16,000 Hz ❸. This is the number of
    sound amplitude values per second that you’ll be sending out via I2S. Notice that
    this is much lower than the sampling rate of 44,100 Hz used in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04).
    This is because of the limited memory on the Pico compared to a standard computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Generating the Notes](nsp-venkitachalam503045-0008.xhtml#rbh1406)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You generate the five notes of the pentatonic scale with the help of two functions:
    `generate_note()` and `create_notes()`. The `generate_note()` function uses the
    Karplus-Strong algorithm to calculate the amplitude values for a single note,
    while `create_notes()` coordinates generating all five notes and saving their
    sample data to the Pico’s filesystem. Let’s consider the `generate_note()` function
    first. (You implemented a similar function in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04),
    so this might be a good time to review the original implementation.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The function starts by setting `nSamples`, the length of the samples buffer
    that will hold the final audio data, to `SR`, the sampling rate. Since `SR` is
    the number of samples per second, this implies that you’ll be creating a one-second
    audio clip. Then you compute `N`, the number of samples in the Karplus-Strong
    ring buffer, by dividing the sampling rate by the frequency of the note being
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you initialize your buffers. First you create the ring buffer with random
    initial values ❶. The `random.random()` method returns values in the range [0.0,
    1.0], so `2*random.random() - 1` scales the values to the range [−1.0, 1.0]. Remember,
    you need both positive and negative amplitudes for the algorithm. Notice that
    you’re implementing the ring buffer as a regular Python list, instead of as a
    `deque` object like you used in [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04).
    MicroPython’s `deque` implementation has restrictions and doesn’t give you what
    you need for a ring buffer. Instead, you’ll just use the regular `append()` and
    `pop()` list methods to add and remove elements from the buffer. You also create
    the samples buffer as an `array` object of length `nSamples` filled with zeros
    ❷. The `'h'` argument specifies that each element in this array is a *signed short*,
    a 16-bit value that can be positive or negative. Since each sample will be represented
    by a 16-bit value, this is exactly what you need.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you iterate over the items in the `samples` array and build up the audio
    clip using the Karplus-Strong algorithm. You take the first sample value in the
    ring buffer and scale it from range [−1.0, 1.0] to range [−32767, 32767] ❸. (The
    range of a 16-bit signed short is [−32767, 32768]. You scale the amplitude values
    to be as high as possible, which will give you the highest possible volume of
    sound output.) Then you calculate an attenuated average of the first two samples
    in the ring buffer ❹. (Here, `0.4975` is the same as `0.995*0.5` from the original
    implementation.) You use `append()` to add the new amplitude value to the end
    of the ring buffer, while using `pop()` to remove the first element, thus maintaining
    the buffer’s fixed size. At the end of the loop, the samples buffer is full, so
    you return it for further processing ❺.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE Using `append()` and `pop()` to update the ring buffer works, but it isn’t
    an efficient method of computation. We’ll look more at optimization in [“Experiments!”](nsp-venkitachalam503045-0027.xhtml#ah1406)
    on [page 273](nsp-venkitachalam503045-0027.xhtml#p273).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s consider the `create_notes()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You don’t want to have to run the Karplus-Strong algorithm every time the user
    presses a button to play a note, as that would be too slow. Instead, this function
    creates the notes the first time the code is run and stores them in the Pico’s
    filesystem as *.bin* files. Then, as soon as the user presses a button, you’ll
    be able to read the appropriate file and output the sound data via I2S.
  prefs: []
  type: TYPE_NORMAL
- en: You begin by using the `os` module to list the files on the Pico ❶. (There’s
    no “hard disk” on the Pico. Rather, a flash chip on the Pico board is used to
    store data, and MicroPython provides a way to access this data like a normal filesystem.)
    Then you iterate through the items in the `pmNotes` dictionary, which maps note
    names to frequencies ❷. For each note, you generate a filename based on its name
    in the dictionary (for example, *C4.bin*) ❸. If a file with that name exists in
    the directory ❹, you’ve generated that note already, so you can skip to the next
    one. Otherwise, you generate the sound samples for that note using the `generate_note()`
    function ❺. Then you create a binary file with the appropriate name ❻ and write
    the samples to it ❼. Finally, you clean up by closing the file ❽.
  prefs: []
  type: TYPE_NORMAL
- en: The first time you run the code, `create_notes()` will run the `generate_note()`
    function to create a file for each note using the Karplus-Strong algorithm. This
    will create the files *C4.bin*, *Eb.bin*, *F.bin*, *G.bin*, and *Bb.bin* on the
    Pico. On subsequent runs, the function will find these files still in place, so
    it won’t need to create them again.
  prefs: []
  type: TYPE_NORMAL
- en: '[Playing a Note](nsp-venkitachalam503045-0008.xhtml#rbh1407)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `play_note()` function plays one of the notes from the pentatonic scale
    by outputting the samples using the I2S protocol. Here’s the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The function has two arguments: `note`, a tuple in the form `(''C4'', 262)`
    conveying the note name and frequency, and `audio_out`, an instance of the `I2S`
    module used for sound output. You first create the appropriate *.bin* filename
    based on the name of the note to be played ❶. Then you open the file ❷. You expect
    the file to exist at this point, so if the open fails, you just return from the
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the function outputs the audio data via I2S, working in batches
    of 1,000 samples. To mediate the data transfer, you create a MicroPython `bytearray`
    of 1,000 samples ❸ and a `memoryview` of the samples ❹. This is a MicroPython
    optimization technique to prevent the whole array from being copied when a slice
    of the array is passed into other functions such as `file_samples.readinto()`
    and `audio_out.write()`.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE A *slice* of an array represents a range of values within that array. For
    example, `a[100:200]` is a slice representing array values `a[100]` through `a[199]`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you start a `while` loop to read samples from the file ❺. In the loop,
    you read a batch of samples from the file into the `memoryview` object using the
    `readinto()` method ❻, which returns the number of samples read (`num_read`).
    You output the samples from the `memoryview` object via I2S using the `audio_out.write()`
    method ❽. The `[:num_read]` slice notation ensures you write out the same number
    of samples you read in. You handle any exceptions at ❾. You’re done outputting
    data when you get to the point where zero samples are read into the `memoryview`
    object ❼, in which case you can break out of the `while` loop and close the *.bin*
    file ❿.
  prefs: []
  type: TYPE_NORMAL
- en: '[Writing the main() Function](nsp-venkitachalam503045-0008.xhtml#rbh1408)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s look at the `main()` function, which brings all the code together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The function starts by setting up the Pico’s onboard LED ❶. It’s toggled ON
    at the start to indicate the Pico is busy initializing. Next, you call the `create_notes()`
    function ❷. As we discussed, this function will create the *.bin* files for the
    notes only if they don’t already exist in the filesystem. To manage the audio
    output, you instantiate the `I2S` module as `audio_out` ❸. The module requires
    a number of input parameters. The first parameter is the I2S ID, which is `0`
    for the Raspberry Pi Pico. Next come the pin numbers corresponding to the clock
    (SCK), word select (WS), and data (SD) signals. We discussed these signals in
    [“I2S Protocol”](nsp-venkitachalam503045-0027.xhtml#bh1402) [on page 262](nsp-venkitachalam503045-0027.xhtml#p262).
    You then set the I2S mode to `TX`, indicating this is an I2S transmitter. Next,
    you set `bits` to `16`, indicating the number of bits per sample, and `format`
    to `MONO`, since there’s only one audio output channel. You set the sampling rate
    to `SR`, and lastly, you set the value for the internal I2S buffer `ibuf` to `2000`.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE A smooth audio experience requires an uninterrupted stream of data output.
    MicroPython uses a special hardware module in the Pico called Direct Memory Access
    (DMA) for this. DMA can transfer data from the memory to the I2S output without
    involving the CPU directly. The CPU just needs to keep an internal buffer (`ibuf`
    in the code) filled with data and is free to do other things while the DMA is
    doing its job. The size of the internal buffer is typically set to at least twice
    the size of the audio output so the DMA doesn’t run out of data to transfer, which
    would result in distorted audio. In this case, you’ll be transferring 1,000 bytes
    to I2S at a time, so you set `ibuf` to twice that.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to set up the buttons so that notes will play when the buttons
    are pressed. For this, you create a list of `Pin` objects called `btns` ❹. For
    each button in the list, you specify the pin number, the data direction of the
    pin (`Pin.IN`, or input, in this case), and whether the pin has a pull-up resistor.
    In this case, all the push button pins have a 10 kΩ resistor pull-up on them.
    This means that by default the pins’ voltages are “pulled up” to VDD, or 3.3 V,
    and when the buttons are pushed, the voltage drops to GND, or 0 V. You’ll use
    this fact to detect button presses.
  prefs: []
  type: TYPE_NORMAL
- en: Once the setup is done, you play a C4 note using the `play_note()` function
    to indicate the Pico is ready to accept button presses ❺, and you also toggle
    the onboard LED to OFF ❻. Then you start a `while` loop to monitor for button
    presses. Within this loop, you use a `for` loop to check whether any of the five
    buttons have a value of `0`, indicating the button is pressed. If so, you look
    up the note corresponding to that button in the `btnNotes` dictionary and play
    it using `play_note()` ❼. Once the note is done playing, you break out of the
    `for` loop and wait for 0.2 seconds ❽ before continuing with the outer `while`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[Running the Pico Code](nsp-venkitachalam503045-0008.xhtml#rah1404)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you’re ready to test your project! To run the code on the Pico, it’s useful
    to install two pieces of software. The first is Thonny, an open source, easy-to-use
    Python integrated development environment (IDE), which you can download from [https://thonny.org](https://thonny.org).
    Thonny makes it easy to copy your project code to the Raspberry Pi Pico and manage
    files on the Pico. A typical development cycle is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Connect your Pico to your computer via USB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Open Thonny. Click the Python version number in the bottom-right of the
    window and change the interpreter to **MicroPython (Raspberry Pi Pico)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Copy your code to Thonny and click the red **Stop/Restart** button to stop
    the code from running on the Pico. This will show the Python interpreter at the
    bottom of the IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Edit your code in Thonny.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5\. When you’re ready to save the file, select **File‣Save As**, and you’ll
    be prompted to save it on the Raspberry Pi Pico. The next dialog will also list
    the files on the Pico. Save your code as *main.py*. You can also use this dialog
    to right-click and delete existing files on the Pico.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6\. After saving the file, press the extra push button you hooked up to the
    RUN pin on the Pico, and your code will start running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 7\. Anytime you want to edit the code, click the **Stop/Restart** button in
    the IDE and Thonny will drop you to the Python interpreter on the Pico.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other useful piece of software for working with the Pico is CoolTerm, which
    you can download from [http://freeware.the-meiers.org](http://freeware.the-meiers.org).
    CoolTerm lets you monitor the Pico’s serial output. All print statements from
    your program will end up here. To use CoolTerm, ensure that you aren’t “stopped”
    in Thonny. The Pico code should be in the running state, since the Pico can’t
    connect to both Thonny and CoolTerm at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the code running, press the push buttons one by one and you’ll
    hear the notes of a nice pentatonic scale coming out of your speaker. [Figure
    12-8](nsp-venkitachalam503045-0027.xhtml#fig12-8) shows the serial output for
    a typical session.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f12008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-8: A sample Raspberry Pi Pico output in CoolTerm'
  prefs: []
  type: TYPE_NORMAL
- en: See what melodies you can compose and play using your digital instrument’s five
    push buttons!
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1405)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you adapted your Karplus-Strong algorithm implementation from
    [Chapter 4](nsp-venkitachalam503045-0016.xhtml#ch04) to run on a tiny microcontroller
    and built a digital musical instrument using a Raspberry Pi Pico. You learned
    how to run Python (in the form of MicroPython) on the Pico, as well as how to
    transmit audio data using the I2S protocol. You also learned about the limitations
    of adapting code from a personal computer to a resource-constrained device like
    the Pico.
  prefs: []
  type: TYPE_NORMAL
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1406)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1\. The MAX98357A I2S board lets you increase the volume (gain) of the output.
    Look at the datasheet of this board and try to boost the sound coming from the
    speaker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '2\. The current implementation of `generate_note()` isn’t very fast. It didn’t
    matter that much for this project, because you generate the notes only once. Still,
    can you make the method faster? Here are a few strategies to try:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Instead of using `append()` and `pop()` operations on the `buf` list, turn
    the list into a circular buffer by keeping tracking of the current position in
    the list and incrementing it using the modulo operation `%N`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: b. Use integer operations instead of floating point. You’ll have to think about
    how the initial random values will be generated and scaled.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Language Reference page in the MicroPython documentation ([https://docs.micropython.org](https://docs.micropython.org/))
    has an article on maximizing the speed of your code. The documentation also suggests
    how you can test your results. First, define a function to measure timing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then use `timed_function()` as a *decorator* for the function you want to time:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you call `generateNote()` in your main code, you’ll see something like
    this in the serial output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 3\. When you press a hardware push button, it doesn’t just go from ON to OFF,
    or the reverse. The spring-loaded contacts inside the button bounce between ON
    and OFF multiple times in a fraction of a second, triggering multiple software
    events for one physical press of the button. Think about how this could affect
    your project, and then read up on *debouncing*, a class of techniques for mitigating
    the problem. What steps can you take to debounce your buttons?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. When you press a button, a new note isn’t played until the current note
    is done playing. How can you abruptly stop playing the current note when a new
    button is pressed and switch to playing the new note immediately?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah1407)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the full code listing for this project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
