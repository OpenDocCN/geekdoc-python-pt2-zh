<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header1401" class="chapter" epub:type="chapter" id="ch14" role="doc-chapter">
<header id="header1401">
<h1 class="cn"><span aria-label=" Page 311. " class="page" epub:type="pagebreak" id="p311" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch14">14</a></h1>
<h1 class="ct">IoT Garden</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">We live in an era where our phones talk to light bulbs and where toothbrushes want to access the internet. This is possible through the <i>Internet of Things (</i><span class="idx" data-term="IoT"/><i>IoT</i><span class="idx" data-term="internet of things"/><i>)</i>, networks of everyday devices embedded with sensors that communicate with each other and the internet, usually in a wireless fashion. In this chapter, you’ll build your own IoT sensor network to monitor the temperature and humidity conditions in your garden. The network will consist of one or more low-power devices running Python code and transmitting real-time sensor data wirelessly to a Raspberry Pi. The Pi will log the data and make it available over a local web server. You’ll be able to view the sensor data through a web browser, as well as <span aria-label=" Page 312. " class="page" epub:type="pagebreak" id="p312" role="doc-pagebreak"/>receive real-time alerts on your mobile device when extreme conditions occur.</p>
<p>Some of the concepts you’ll learn about through this project are:</p>
<ul style="list-style-type:none">
<li class="blf">• Putting together a low-power IoT sensor network</li>
<li class="bl">• Understanding the basics of the Bluetooth Low Energy (BLE) protocol</li>
<li class="bl">• Building a BLE scanner on the Raspberry Pi</li>
<li class="bl">• Using a SQLite database to store sensor data</li>
<li class="bl">• Running a web server on the Pi using <code>Bottle</code></li>
<li class="bl">• Using If This Then That (IFTTT) to send alerts to your mobile phone</li>
</ul>
<section>
<h2 class="ah" id="ah1601"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1601">How It Works</a></h2>
<p class="paft">The IoT devices you’ll use for this project are Adafruit BLE Sense boards, which have built-in temperature and humidity sensors. The devices periodically take measurements and transmit the sensor data wirelessly using Bluetooth Low Energy (BLE), which we’ll discuss soon. This data is picked up by the Raspberry Pi running a BLE scanner. The Pi uses a database to store and retrieve the data, and it also runs a web server so it can display the data on a web page. Additionally, the Pi has logic to detect anomalies in the temperature and humidity data and to send an alert to a user’s mobile device via the IFTTT service when such anomalies occur. <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#fig14-1">Figure 14-1</a> summarizes the architecture of the project.</p>
<figure class="figure" id="fig14-1">
<p class="fig"><img alt="" height="861" src="images/nsp-venkitachalam503045-f14001.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 14-1:</span> <span class="idx" data-level1="architecture" data-term="IoT garden"/>The IoT garden system architecture</p>
</figcaption>
</figure>
<p><span aria-label=" Page 313. " class="page" epub:type="pagebreak" id="p313" role="doc-pagebreak"/>You may wonder why you need the Raspberry Pi at all. Why can’t the sensor devices talk directly to the internet instead of going through the Pi? The answer lies in power consumption. If the devices were talking directly to the internet via a protocol like Wi-Fi, they would typically consume more than 10 times the power compared to using BLE. This is important, because IoT devices are usually powered by batteries, and we expect them to last a very long time. The arrangement in <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#fig14-1">Figure 14-1</a>, where you have a network of low-power wireless devices talking to a gateway (the Raspberry Pi, in this case), is a common architecture in the world of IoT.</p>
<p>Another feature of this project’s architecture is that your data remains in your hands—inside a database on your Pi, to be precise. You aren’t blasting it over the internet, but rather confining it to your local network. This may not be critical for basic garden data, but it’s still good to know that an IoT device doesn’t always <i>need</i> to send everything over the internet for it to be useful. Privacy and security are two good reasons for exposing your data to the internet only when it’s really necessary. In this case, you’ll still make use of the internet a little bit to send the IFTTT alerts.</p>
<section>
<h3 class="bh" id="bh1601"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1601"><span class="idx" data-term="Bluetooth Low Energy"/>Bluetooth Low Energy</a></h3>
<p class="paft"><span class="idx" data-term="BLE"/>BLE is a subset of the same wireless technology standard that enables Bluetooth headphones and speakers, but it’s optimized for low-power, battery-operated devices. BLE is how your smartphone speaks to your smartwatch or your fitness tracker, for example. Devices that communicate over BLE can be categorized as either <span class="idx" data-level1="central" data-term="BLE"/><i>central</i> or <span class="idx" data-level1="peripheral" data-term="BLE"/><i>peripheral</i>. Usually, central devices are more capable hardware such as laptops and phones, while peripheral devices are less capable hardware such as fitness bands and beacons. In this project, the Raspberry Pi is the central device, and the Adafruit BLE Sense boards are the peripherals.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> The distinction between central and peripheral devices isn’t always clear-cut. Modern BLE chips allow the same piece of hardware to function as a central device, a peripheral, or a combination of both.</p>
<p>A BLE peripheral makes its presence known via <span class="idx" data-level1="advertisement" data-term="BLE"/><i>advertisement packets</i>, as shown in <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#fig14-2">Figure 14-2</a>. These packets of data, which are typically sent out every few milliseconds, contain information such as the name of the peripheral, its transmission power, its manufacturer data, whether the central device can connect to it, and so on. The central device continuously scans for advertisement packets, and it can use information in the packets to establish communication with the peripheral.</p>
<figure class="figure" id="fig14-2">
<p class="fig"><span aria-label=" Page 314. " class="page" epub:type="pagebreak" id="p314" role="doc-pagebreak"/><img alt="" height="329" src="images/nsp-venkitachalam503045-f14002.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 14-2:</span> The BLE advertising scheme</p>
</figcaption>
</figure>
<p>The amount of data in an advertisement packet is limited to just 31 bytes to conserve the peripheral’s battery, but the peripheral can optionally send an additional packet of information via a separate transmission called a <span class="idx" data-level1="scan response" data-term="BLE"/><i>scan response</i>. The peripheral indicates whether a scan response is available as part of its normal advertisement packet. If the central device wants the extra data, it then sends a scan response request, which prompts the peripheral to take a break from sending advertisement packets and send the scan response instead. For this project, though, you need very little data from the sensors, so you can just put the temperature and humidity data directly in the advertisement packets.</p>
<p>On the Raspberry Pi side, you’ll build a BLE scanner using <span class="idx" data-term="BlueZ"/>BlueZ, the official Bluetooth protocol stack on Linux. Specifically, you’ll make use of the following three command line programs:</p>
<p class="pcust2"><span class="hemb"><span class="idx" data-level1="hciconfig" data-term="BlueZ"/>hciconfig</span> Resets BLE on the Pi during program initialization</p>
<p class="pcust2"><span class="hemb"><span class="idx" data-level1="hcitool" data-term="BlueZ"/>hcitool</span>       Scans for BLE peripherals</p>
<p class="pcust2"><span class="hemb"><span class="idx" data-level1="hcidump" data-term="BlueZ"/>hcidump</span>       Reads the advertisement data from the BLE peripherals</p>
<p><code>hciconfig</code> and <code>hcitool</code> come as part of the Raspberry Pi OS installation, but you’ll need to install <code>hcidump</code> from a terminal, as follows:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo apt-get install bluez-hcidump</code></p>
</div>
<p>Here’s what a typical command line session on the Raspberry Pi looks like with these tools. First, run <code>hcidump</code> in a shell to get ready to output data packets once the scan begins:</p>
<div class="codeline">
<p class="clf">pi@iotsensors:~ $ <code class="b">sudo hcidump --raw</code></p>
<p class="cl">HCI sniffer - Bluetooth packet analyzer ver 5.50</p>
<p class="cll">device: hci0 snap_len: 1500 filter: 0xffffffff</p>
</div>
<p>This tells you that <code>hcidump</code> is waiting for BLE input. Next, run the <code>lescan</code> command with <code>hcitool</code> in a different shell to start scanning for BLE devices:</p>
<div class="codeline">
<p class="clf">pi@iotsensors:~ $ <code class="b">sudo hcitool lescan</code></p>
<p class="cl">LE Scan...</p>
<p class="cl">DE:74:03:D9:3D:8B (unknown)</p>
<p class="cl">DE:74:03:D9:3D:8B IOTG1</p>
<p class="cl">36:D2:35:5A:BF:B0 (unknown)</p>
<p class="cl">8C:79:F5:8C:AE:DA (unknown)</p>
<p class="cl"><span aria-label=" Page 315. " class="page" epub:type="pagebreak" id="p315" role="doc-pagebreak"/>5D:9F:EC:A0:09:51 (unknown)</p>
<p class="cl">5D:9F:EC:A0:09:51 (unknown)</p>
<p class="cl">60:80:0A:83:18:40 (unknown)</p>
<p class="cll">--<code class="i">snip</code>--</p>
</div>
<p>This indicates that the scanner has detected a whole lot of BLE devices (they’re everywhere these days!). The moment you run the <code>lescan</code> command, <code>hcidump</code> starts printing out advertisement packet data, so your <code>hcidump</code> shell should now be full of messages like the following:</p>
<div class="codeline">
<p class="clf">&lt; 01 0B 20 07 01 10 00 10 00 00 00</p>
<p class="cl">&gt; 04 0E 04 01 0B 20 00</p>
<p class="cl">&lt; 01 0C 20 02 01 01</p>
<p class="cl">&gt; 04 0E 04 01 0C 20 00</p>
<p class="cl">&gt; 04 3E 1B 02 01 02 01 8B 3D D9 03 74 DE 0F 0E FF 22 08 0A 31</p>
<p class="cl">  FE 49 4F 54 47 31 1B 36 30 CB</p>
<p class="cl">&gt; 04 3E 16 02 01 04 01 8B 3D D9 03 74 DE 0A 02 0A 00 06 09 49</p>
<p class="cl">  4F 54 47 31 CB</p>
<p class="cl">&gt; 04 3E 23 02 01 03 01 03 58 0A 00 6A 35 17 16 FF 06 00 01 09</p>
<p class="cl">  21 0A 13 71 DA 7D 1A 00 52 6F 63 69 6E 61 6E 74 65 C5</p>
<p class="cl">&gt; 04 3E 1F 02 01 03 01 B9 D4 AE 7E 01 0E 13 12 FF 06 00 01 09</p>
<p class="cll">  21 0A 9E 54 20 C5 51 48 6D 61 6E 64 6F BE</p>
</div>
<p>The messages are output as hexadecimal bytes (rather than human-readable text) because you started <code>hcidump</code> with the <code>--raw</code> option.</p>
<p>This example illustrated using the BlueZ tools manually at the command line. For the project, you’ll instead execute the commands from inside the Python code running on your Pi. The Python code will also read the advertisement packets and get the sensor data.</p>
</section>
<section>
<h3 class="bh" id="bh1602"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1602">The <span class="idx" data-term="Bottle"/>Bottle Web Framework</a></h3>
<p class="paft"><span class="idx" data-term="bottle module"/>To monitor the sensor data via a web interface, you’ll need to have the Pi run a web server. To do this, you’ll use <code>Bottle</code>, a Python web framework with a simple interface. (In fact, the entire library consists of a single source file named <i>bottle.py</i>.) Here’s the code needed to serve a simple web page from a Pi using <code>Bottle</code>:</p>
<div class="codeline">
<p class="clf">from bottle import route, run</p>
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ @route('/hello')</p>
<p class="cl">def hello():</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ return "Hello Bottle World!"</p>
<p class="cl2s"><!--<ccust1>3</ccust1>-->❸ <span class="idx" data-level1="run" data-term="bottle module"/>run(host='<code class="i">iotgarden.local</code>', port=<code class="i">8080</code>, debug=True)</p>
</div>
<p>This code first defines a route to a URL or path (in this case, <code>/hello</code>) where the client can send data requests <!--<ccust1>1</ccust1>-->❶, and it uses the <span class="idx" data-level1="route" data-term="bottle module"/><code>route()</code> method from <code>Bottle</code> as a Python decorator to bind to the <code>hello()</code> function, which will act as a handler for that route. This way, when the user navigates to the route, <code>Bottle</code> will call the <code>hello()</code> function, which returns a string <!--<ccust1>2</ccust1>-->❷. The <code>run()</code> method <!--<ccust1>3</ccust1>-->❸ starts the <code>Bottle</code> server, which can now accept connections <span aria-label=" Page 316. " class="page" epub:type="pagebreak" id="p316" role="doc-pagebreak"/>from clients. Here we’re assuming that the server is running on port 8080 on a Pi called <code>iotgarden</code>. Notice that the <code>debug</code> flag is set to <code>True</code> to make it easier to diagnose problems.</p>
<p><span class="idx" data-level1="running" data-term="bottle module"/>Run this code on your Wi-Fi–connected Pi, open a browser on any computer connected to the local network, and visit <i>http://&lt;iotgarden&gt;.local:8080/hello/</i>, substituting in your Pi’s name as appropriate. <code>Bottle</code> should serve you a web page with the text “Hello Bottle World!” With just a few lines of code, you’ve created a web server.</p>
<aside aria-labelledby="bxheader1401" class="box" id="bx01">
<div class="bxheader" id="bxheader1401">
<p class="bxh">Python Decorators</p>
</div>
<p class="bxaft">A <i><span class="idx" data-term="decorator"/>decorator</i> in Python is <code>@</code> syntax that takes a function as an argument (such as <code>route()</code> in our <code>Bottle</code> example) and returns another function (such as <code>hello()</code>). A decorator provides a convenient way to “wrap” one function using another function. For example, this code</p>
<p class="bx1f">@wrapper</p>
<p class="bx1">def myFunc():</p>
<p class="bx1l">    return 'hi'</p>
<p class="bxcon">is equivalent to doing the following:</p>
<p class="bx1s">myFunc = wrapper(myFunc)</p>
<p class="bxl">Functions are first-class objects in Python that can be passed like variables.</p>
</aside>
<p>Note that you’ll be using <code>Bottle</code> routing functions slightly differently in your project compared to this simple example, because you’ll be binding the routes to class methods rather than free functions like <code>hello()</code> shown previously. There will be more on this later.</p>
</section>
<section>
<h3 class="bh" id="bh1603"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1603"><span class="idx" data-term="SQLite"/>The SQLite Database</a></h3>
<p class="paft">You need a place to store the sensor data so you can retrieve it in the future. You could write the data to a text file, but the retrieval process would quickly get cumbersome. Instead, you’ll store the data with SQLite, a lightweight, easy-to-use database perfect for embedded systems like the Raspberry Pi. To access SQLite in Python, you’ll use the <span class="idx" data-term="sqlite3"/><code>sqlite3</code> library.</p>
<p>SQLite databases are manipulated using SQL, a standard language for database systems. The SQL statements are written as strings in your Python code. You don’t need to be a SQL expert to use SQLite for this project, however. You’ll need only a few commands, which we’ll discuss as they arise. To get a feel for how it works, let’s look at a simple example of using SQLite in a Python interpreter session. First, here’s how to create a database and add some entries to it:</p>
<div class="codeline1">
<p class="cl1f"><span aria-label=" Page 317. " class="page" epub:type="pagebreak" id="p317" role="doc-pagebreak"/>&gt;&gt;&gt; <code class="b">import sqlite3</code></p>
<p class="cl1">&gt;&gt;&gt; <code class="b">con = sqlite3.</code><span class="idx" data-level1="connect" data-term="sqlite module"/><code class="b">connect('test.db')</code> <!--<ccust1>1</ccust1>-->❶</p>
<p class="cl1">&gt;&gt;&gt; <code class="b">cur = con.</code><span class="idx" data-level1="cursor" data-term="sqlite module"/><code class="b">cursor()</code> <!--<ccust1>2</ccust1>-->❷</p>
<p class="cl1">&gt;&gt;&gt; <code class="b">cur.</code><span class="idx" data-level1="execute" data-term="sqlite module"/><code class="b">execute("</code><span class="idx" data-level1="CREATE TABLE" data-term="sqlite module"/><code class="b">CREATE TABLE sensor_data (</code><span class="idx" data-level1="TS" data-term="sqlite module"/><code class="b">TS datetime,</code> <span class="idx" data-level1="ID" data-term="sqlite module"/><code class="b">ID text,</code> <span class="idx" data-level1="VAL" data-term="sqlite module"/><code class="b">VAL numeric)")</code> <!--<ccust1>3</ccust1>-->❸</p>
<p class="cl1">&gt;&gt;&gt; <code class="b">for i in range(10):</code></p>
<p class="cl1">...   <code class="b">cur.execute("INSERT into sensor_data VALUES (datetime('now'),'ABC', ?)", (i, ))</code> <!--<ccust1>4</ccust1>-->❹</p>
<p class="cl1">&gt;&gt;&gt; <code class="b">con.</code><span class="idx" data-level1="commit" data-term="sqlite module"/><code class="b">commit()</code> <!--<ccust1>5</ccust1>-->❺</p>
<p class="cl1">&gt;&gt;&gt; <code class="b">con.</code><span class="idx" data-level1="close" data-term="sqlite module"/><code class="b">close()</code></p>
<p class="cl1l">&gt;&gt;&gt; <code class="b">exit()</code></p>
</div>
<p>Here you call the <code>sqlite3.connect()</code> method with the name of the database (<code>test.db</code> in this case) <!--<ccust1>1</ccust1>-->❶. This method either returns a connection to an existing database or creates a new one if the database with the given name doesn’t exist. Then you create a <i>cursor</i> using the connection object <!--<ccust1>2</ccust1>-->❷. This is a construct that lets you interact with the database to create tables, make new entries, and retrieve data. You use the cursor to execute a SQL statement that creates a database table called <code>sensor_data</code> with the following columns: <code>TS</code> (timestamp), which is of the type <code>datetime</code>; <code>ID</code> of type <code>text</code>; and <code>VAL</code> of type <code>numeric</code> <!--<ccust1>3</ccust1>-->❸. Next, you add 10 entries to this database by executing SQL <code>INSERT</code> statements in a <code>for</code> loop. Each statement adds the entry with the current timestamp, the string <code>'ABC'</code>, and the loop index <code>i</code> <!--<ccust1>4</ccust1>-->❹. The <code>?</code> is a formatting placeholder used by SQLite, and the actual values are specified using a tuple. Finally, you commit the changes to the database to make them permanent <!--<ccust1>5</ccust1>-->❺, before closing the database connection.</p>
<p>Now let’s retrieve some values from the database:</p>
<div class="codeline">
<p class="clf">&gt;&gt;&gt; <code class="b">con = sqlite3.</code><span class="idx" data-level1="connect" data-term="sqlite module"/><code class="b">connect('test.db')</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">cur = con.</code><span class="idx" data-level1="cursor" data-term="sqlite module"/><code class="b">cursor()</code></p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ &gt;&gt;&gt; <code class="b">cur.</code><span class="idx" data-level1="execute" data-term="sqlite module"/><code class="b">execute("</code><span class="idx" data-level1="SELECT" data-term="sqlite module"/><code class="b">SELECT * FROM sensor_data WHERE VAL &gt; 5")</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">print(cur.</code><span class="idx" data-level1="fetchall" data-term="sqlite module"/><code class="b">fetchall())</code></p>
<p class="cl">[('2021-10-16 13:01:22', 'ABC', 6), ('2021-10-16 13:01:22', 'ABC', 7),</p>
<p class="cll"> ('2021-10-16 13:01:22', 'ABC', 8), ('2021-10-16 13:01:22', 'ABC', 9)]</p>
</div>
<p>Once again, you establish a connection to the database and create a cursor to interact with it. Then you execute a <code>SELECT</code> SQL query to retrieve some data <!--<ccust1>1</ccust1>-->❶. In this query, you ask for all rows (<code>SELECT *</code>) from the <code>sensor_data</code> table for which the entry in the <code>VAL</code> column is greater than <code>5</code>. You print the results of the query, which are accessible through the cursor’s <code>fetchall()</code> method.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah1602"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1602"><span class="idx" data-level1="requirements" data-term="IoT garden"/>Requirements</a></h2>
<p class="paft">On the Raspberry Pi, you’ll need the <code>bottle</code> module to create a web server, the <code>sqlite3</code> module to work with a SQLite database, and <code>matplotlib</code> to plot the sensor data. The BLE Sense boards don’t have enough computing power to run a full version of Python, so instead you’ll program them using CircuitPython, an open source derivative of MicroPython maintained by Adafruit. We’re using CircuitPython for this project, rather than MicroPython as you saw in <a class="xref" href="nsp-venkitachalam503045-0027.xhtml#ch12">Chapter 12</a>, since the former has more library support for the Adafruit-made devices.</p>
<p><span aria-label=" Page 318. " class="page" epub:type="pagebreak" id="p318" role="doc-pagebreak"/>You’ll also need the following hardware for this project:</p>
<ul style="list-style-type:none">
<li class="blf">• One or more Adafruit <span class="idx" data-level1="Feather Bluefruit nRF52840 " data-term="Adafruit"/>Feather Bluefruit <span class="idx" data-term="nRF52840"/>nRF52840 Sense boards, as per your need</li>
<li class="bl">• One Raspberry Pi 3B+ (or newer) board with SD card and power supply adapter</li>
<li class="bll">• One 3.7 V LiPo battery or USB power supply per BLE Sense board</li>
</ul>
<p><a class="xref" href="nsp-venkitachalam503045-0029.xhtml#fig14-3">Figure 14-3</a> shows the required hardware.</p>
<figure class="figure" id="fig14-3">
<p class="fig"><img alt="" height="993" src="images/nsp-venkitachalam503045-f14003.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 14-3:</span> <span class="idx" data-level1="hardware" data-term="IoT garden"/>The hardware required for the project</p>
</figcaption>
</figure>
<p>You can hook up your Raspberry Pi indoors, close to your garden, and place your BLE Sense boards with suitable power supply units and protective enclosures in the garden.</p>
<section>
<h3 class="bh" id="bh1604"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1604">Raspberry Pi Setup</a></h3>
<p class="paft"><span class="idx" data-level1="Raspberry Pi setup" data-term="IoT garden"/>To start this project, you’ll need to set up your Raspberry Pi. Please follow the instructions in <a class="xref" href="nsp-venkitachalam503045-0032.xhtml#appb">Appendix B</a>. The project code that follows assumes that you’ve named you Pi <code>iotgarden</code>, which allows you to access it on the network as <code>iotgarden.local</code>.</p>
</section>
<section>
<h3 class="bh" id="bh1605"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1605"><span class="idx" data-term="CircuitPython"/>CircuitPython Setup</a></h3>
<p class="paft">To install CircuitPython, follow these steps for each of your Adafruit BLE Sense boards:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Visit <a class="url-i" href="https://circuitpython.org/downloads">https://circuitpython.org/downloads</a>, search for your Bluefruit Sense board, and download the board’s CircuitPython installer file, which has a <i>.uf2</i> extension. Take note of the CircuitPython version number you’re downloading.</li>
<li class="nl"><span aria-label=" Page 319. " class="page" epub:type="pagebreak" id="p319" role="doc-pagebreak"/>2. Connect the Adafuit board to a USB port on your computer and double-click the Reset button on the board. The LED on the board should turn green, and you should see a new drive appear on your computer called FTHRSNSBOOT.</li>
<li class="nll">3. Drag the <i>.uf2</i> file into the FTHRSNSBOOT drive. Once the file is copied, the LED on the board will flash, and a new drive called CIRCUITPY will appear on your computer.</li>
</ol>
<p>Next, you need to install the required Adafruit libraries on your board. Here’s how:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Visit <a class="url-i" href="https://circuitpython.org/libraries">https://circuitpython.org/libraries</a> and download the <i>.zip</i> file with the library bundle corresponding to your version of CircuitPython.</li>
<li class="nl">2. Unzip the downloaded file and copy the following files/folders into a folder called <i>lib</i> inside the CIRCUITPY drive. (Create the <i>lib</i> folder if it doesn’t exist.)
              <ul style="list-style-type:none">
<li class="bl1">◦ <i>adafruit_apds9960</i></li>
<li class="bl1">◦ <i>adafruit_ble</i></li>
<li class="bl1">◦ <i>adafruit_bme280</i></li>
<li class="bl1">◦ <i>adafruit_bmp280.mpy</i></li>
<li class="bl1">◦ <i>adafruit_bus_device</i></li>
<li class="bl1">◦ <i>adafruit_lis3mdl.mpy</i></li>
<li class="bl1">◦ <i>adafruit_lsm6ds</i></li>
<li class="bl1">◦ <i>adafruit_register</i></li>
<li class="bl1">◦ <i>adafruit_sht31d.mpy</i></li>
<li class="bl1">◦ <i>neopixel.mpy</i></li>
</ul>
</li>
<li class="nll">3. Press Reset on the board and you’re all set to use the board for this project.</li>
</ol>
<p>By default, CircuitPython will run code from any file in CIRCUITPY named <i>code.py</i>. You’ll need to copy to the drive the <i>ble_sensors.py</i> file discussed in the following section and rename it <i>code.py</i> to run the project.</p>
</section>
<section>
<h3 class="bh" id="bh1606"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1606">If This Then That Setup</a></h3>
<p class="paft"><span class="idx" data-term="IFTTT setup"/>IFTTT<span class="idx" data-term="IFTTT setup"/> is a web service that lets you create automated responses to specific actions. You’ll use IFTTT to send alerts to your mobile phone when something is really off with the temperature or humidity levels your sensors are picking up. Follow these steps to get set up to receive IFTTT alerts:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Visit the IFTTT website (<a class="url-i" href="https://ifttt.com">https://ifttt.com</a>) and sign up for an account.</li>
<li class="nl">2. Download the IFTTT app to your smartphone and set it up.</li>
<li class="nl">3. While signed into your IFTTT account in your browser, click <b>Create</b>. Then click the <b>Add</b> button in the If This box.</li>
<li class="nl"><span aria-label=" Page 320. " class="page" epub:type="pagebreak" id="p320" role="doc-pagebreak"/>4. Search for and select <b>Webhooks</b> on the Choose a Service page that comes up. Then select <b>Receive a Web Request with a JSON Payload</b>.</li>
<li class="nl">5. Under Event Name, enter <b>TH_alert</b> (note the capitalization) and press <b>Create Trigger</b>.</li>
<li class="nl">6. You should now be back on the Create page. Click the <b>Add</b> button in the Then That box.</li>
<li class="nl">7. Search for and select <b>Notifications</b>. Then click <b>Send a Notification from the IFTTT App</b>.</li>
<li class="nl">8. In the page that comes up, add the text “T/H Alert!” to the Message box. Then click <b>Add Ingredient</b> and select <b>OccuredAt</b>. Click <b>Add Ingredient</b> again and select <b>JsonPayload</b>.</li>
<li class="nll">9. Click the <b>Create Action</b> button to return to the Create screen. Then click <b>Continue</b> and <b>Finish</b> to finalize the alert.</li>
</ol>
<p>You’ll need your IFTTT key to trigger alerts from your Python code. To look it up, follow these steps:</p>
<ol style="list-style-type:none">
<li class="nlf">1. On the IFTTT website, click the round account icon in the top-right corner of the screen and select <b>My Services</b>.</li>
<li class="nl">2. Click the <b>Webhooks</b> link, and then click the <b>Documentation</b> button.</li>
<li class="nl">3. A page should load with your key written across the top. Take note of the key. You’ll also find information on this page about how to send a test alert to your smartphone. Be sure to fill in <b>TH_alert</b> as the event name if you run a test.</li>
</ol>
</section>
</section>
<section>
<h2 class="ah" id="ah1603"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1603">The Code</a></h2>
<p class="paft"><span class="idx" data-level1="code files" data-term="IoT garden"/>The code for this project is spread over these Python files:</p>
<p class="pcust2"><span class="bi">ble_sensors.py</span> The CircuitPython code that runs in the Adafruit BLE Sense boards. It reads from the temperature and humidity sensors and puts the data in BLE advertisement packets.</p>
<p class="pcust2"><span class="bi">BLEScanner.py</span> Implements the BLE scanner on the Raspberry Pi, using BlueZ tools to read advertisement data. This code also sends the IFTTT alerts.</p>
<p class="pcust2"><span class="bi">server.py</span> Implements the <code>Bottle</code> web server on the Raspberry Pi.</p>
<p class="pcust2"><span class="bi">iotgarden.py</span> The main program file. This code sets up the SQLite database and starts the BLE scanner and the web server.</p>
<p>In addition to the Python files, the project has a subfolder called <i>static</i> with some extra files used by the <code>Bottle</code> web server:</p>
<p class="pcust2"><span class="bi">static/style.css</span> The style sheet for the HTML returned by the server</p>
<p class="pcust2"><span class="bi">static/server.js</span> The JavaScript code returned by the server that fetches sensor data</p>
<p><span aria-label=" Page 321. " class="page" epub:type="pagebreak" id="p321" role="doc-pagebreak"/>The full code for the project is available at <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/iotgarden">https://github.com/mkvenkit/pp2e/tree/main/iotgarden</a>.</p>
<section>
<h3 class="bh" id="bh1607"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1607">The CircuitPython Code</a></h3>
<p class="paft"><span class="idx" data-level1="CircuitPython code" data-term="IoT garden"/>The CircuitPython code running on the BLE Sense board has a straightforward purpose: it reads data from the built-in temperature and humidity sensors and puts that data in the board’s BLE advertisement packets. This deceptively simple task requires you to import a surprising number of modules. To see the complete code listing, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#ah1607">“The Complete CircuitPython Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#p343">page 343</a>. The code is also available at <a class="url-i" href="https://github.com/mkvenkit/pp2e/blob/main/iotgarden/ble_sensors/ble_sensors.py">https://github.com/mkvenkit/pp2e/blob/main/iotgarden/ble_sensors/ble_sensors.py</a>.</p>
<div class="codeline">
<p class="clf">import time, struct</p>
<p class="cl">import board</p>
<p class="cl">import <span class="idx" data-level1="adafruit_bmp280" data-term="IoT garden"/>adafruit_bmp280</p>
<p class="cl">import <span class="idx" data-level1="adafruit_sht31d" data-term="IoT garden"/>adafruit_sht31d</p>
<p class="cl">from <span class="idx" data-level1="adafruit_ble" data-term="IoT garden"/>adafruit_ble import BLERadio</p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ from adafruit_ble.advertising import Advertisement, LazyObjectField</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ from adafruit_ble.advertising.standard import ManufacturerData,</p>
<p class="cl">                                              ManufacturerDataField</p>
<p class="cl">import _bleio</p>
<p class="cll">import <span class="idx" data-level1="neopixel" data-term="neopixel"/>neopixel</p>
</div>
<p>You import Python’s built-in <code>time</code> and <code>struct</code> modules for sleeping and packing data, respectively. The <code>board</code> module gives you access to the <code>I2C</code> library, which allows the BLE chip on the board to communicate with the sensors using the I<sup>2</sup>C protocol (pronounced<code/> “eye-squared-C”). The <code>adafruit_bmp280</code> and <code>adafruit_sht31d</code> modules are required for communicating with the sensors, and the <code>BLERadio</code> class is for enabling BLE and sending advertisement packets. The imports at <!--<ccust1>1</ccust1>-->❶ and <!--<ccust1>2</ccust1>-->❷ give you access to the Adafruit BLE advertising modules necessary for creating your own custom advertisement packets featuring the sensor data. Additionally, you’ll use the <code>_bleio</code> module to get the MAC address of the device and <code>neopixel</code> to control the board’s LED.</p>
<section>
<h4 class="ch" id="ch1601">Preparing BLE Packets</h4>
<p class="paft">Next, define a class called <code>IOTGAdvertisement</code> to help create the BLE advertisement packets. The <code>adafruit_ble</code> library already has an <code>Advertisement</code> class that handles BLE advertisements. You create <code>IOTGAdvertisement</code> as a subclass of <code>Advertisement</code> to use the parent class’s features while adding your own customization:</p>
<div class="codeline">
<p class="clf">class IOTGAdvertisement(<span class="idx" data-level1="Advertisement" data-term="adafruit_ble"/>Advertisement):</p>
<p class="cl">    flags = None</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ match_prefixes = (</p>
<p class="cl">        struct.pack(</p>
<p class="cl">            "&lt;BHBH",  # prefix format</p>
<p class="cl">            0xFF,     # 0xFF is "Manufacturer Specific Data" as per BLE spec</p>
<p class="cl">            0x0822,   # 2-byte company ID</p>
<p class="cl">            struct.calcsize("&lt;H9s"), # data format</p>
<p class="cl"><span aria-label=" Page 322. " class="page" epub:type="pagebreak" id="p322" role="doc-pagebreak"/>            0xabcd # our ID</p>
<p class="cl">        ), # comma required - a tuple is expected</p>
<p class="cl">    )</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ manufacturer_data = <span class="idx" data-level1="LazyObjectField" data-term="adafruit_ble"/>LazyObjectField(</p>
<p class="cl">        ManufacturerData,</p>
<p class="cl">        "manufacturer_data",</p>
<p class="cl">        advertising_data_type=0xFF, # 0xFF is "Manufacturer Specific Data"</p>
<p class="cl">                                    # as per BLE spec</p>
<p class="cl">        company_id=0x0822,          # 2-byte company ID</p>
<p class="cl">        key_encoding="&lt;H",</p>
<p class="cl">    )</p>
<p class="cl">    # set manufacturer data field</p>
<p class="cll">  <!--<ccust1>3</ccust1>-->❸ md_field = <span class="idx" data-level1="ManufacturerDataField" data-term="adafruit_ble"/>ManufacturerDataField(0xabcd, "&lt;9s")</p>
</div>
<p>The BLE standard is very particular, so this code may look intricate, but all it’s really doing is putting some custom data in the advertisement packet. First you fill a tuple called <code>match_prefixes</code> <!--<ccust1>1</ccust1>-->❶, which the <code>adafruit_ble</code> library will use to manage various fields in the advertisement packet. The tuple has only one element, a packed structure of bytes that you create using the Python <code>struct</code> module. Next, you define the <code>manufacturer_data</code> field <!--<ccust1>2</ccust1>-->❷, which will use the format described at <!--<ccust1>1</ccust1>-->❶. The manufacturer data field is a standard part of a BLE advertisement packet that has some space for whatever custom data the manufacturer (or the user) wants to include. Finally, you create a custom <code>ManufacturerDataField</code> object <!--<ccust1>3</ccust1>-->❸, which you’ll keep updating as sensor values change.</p>
</section>
<section>
<h4 class="ch" id="ch1602">Reading and Sending Data</h4>
<p class="paft">The <code>main()</code> function of the CircuitPython program reads and sends the sensor data. The function begins with some initializations:</p>
<div class="codeline">
<p class="clf">def main():</p>
<p class="cl">    # initialize I2C</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ i2c = board.<span class="idx" data-level1="I2C" data-term="board module"/>I2C()</p>
<p class="clf">    # initialize sensors</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ bmp280 = <span class="idx" data-level1="Adafruit_BMP280_I2C" data-term="adafruit_bmp280"/>adafruit_bmp280.Adafruit_BMP280_I2C(i2c)</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ sht31d = adafruit_sht31d.<span class="idx" data-level1="SHT31D" data-term="adafruit_sht31d"/>SHT31D(i2c)</p>
<p class="clf">    # initialize BLE</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ ble = <span class="idx" data-level1="BLERadio" data-term="adafruit_ble"/>BLERadio()</p>
<p class="clf">    # create custom advertisement object</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ advertisement = IOTGAdvertisement()</p>
<p class="cl">    # append first 2 hex bytes (4 characters) of MAC address to name</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ addr_bytes = <span class="idx" data-term="_bleio"/>_bleio.adapter.address.address_bytes</p>
<p class="cl">    name = "{0:02x}{1:02x}".format(addr_bytes[5], addr_bytes[4]).upper()</p>
<p class="cl">    # set device name</p>
<p class="cll">  <!--<ccust1>7</ccust1>-->❼ ble.name = "IG" + name</p>
</div>
<p>First you initialize the <code>I2C</code> module <!--<ccust1>1</ccust1>-->❶ so the BLE chip can communicate with the sensors. Then you initialize the modules for the temperature <span aria-label=" Page 323. " class="page" epub:type="pagebreak" id="p323" role="doc-pagebreak"/>(<code>bmp280</code>) <!--<ccust1>2</ccust1>-->❷ and humidity (<code>sht31d</code>) <!--<ccust1>3</ccust1>-->❸ sensors. You also initialize the BLE radio <!--<ccust1>4</ccust1>-->❹, which is required for transmitting the advertisement packets, and create an instance of your custom <code>IOTGAdvertisement</code> class <!--<ccust1>5</ccust1>-->❺.</p>
<p>Next, you set the name of the BLE device to the string <code>IG</code> (for IoT Garden) followed by the first four hexadecimal digits (or two bytes) of the device’s <span class="idx" data-term="MAC address"/>MAC address <!--<ccust1>7</ccust1>-->❼. For example, if the MAC address of the device is <code>de:74:03:d9:3d:8b</code>, the name of the device will be set to <code>IGDE74</code>. To do this, you first get the MAC address as bytes <!--<ccust1>6</ccust1>-->❻. The bytes are in reverse order of the string representation, however—in our example MAC address, for instance, the first byte would be <code>0x8b</code>. What you’re looking for are the first two bytes, <code>0xde</code> and <code>0x74</code>, which are at indices <code>5</code> and <code>4</code> in <code>address_bytes</code>, respectively. You use string formatting to convert these bytes to string representation and convert them to uppercase using <code>upper()</code>.</p>
<p>Now let’s look at the rest of the initialization:</p>
<div class="codeline">
<p class="clf">    # set initial value</p>
<p class="cl">    # will use only first 5 chars of name</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ advertisement.md_field = ble.name[:5] + "0000"</p>
<p class="cl">    # BLE advertising interval in seconds</p>
<p class="cl">    BLE_ADV_INT = 0.2</p>
<p class="cl">    # start BLE advertising</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ ble.<span class="idx" data-level1="start_advertising" data-term="adafruit_ble"/>start_advertising(advertisement, interval=<span class="idx" data-level1="BLE_ADV_INT" data-term="adafruit_ble"/>BLE_ADV_INT)</p>
<p class="clf">    # set up NeoPixels and turn them all off</p>
<p class="cl">     pixels = neopixel.NeoPixel(board.NEOPIXEL, 1,</p>
<p class="cll">                                brightness=0.1, auto_write=False)</p>
</div>
<p>Here you set an initial value for your custom manufacturer data <!--<ccust1>1</ccust1>-->❶. For this, you concatenate the first five characters of the device name followed by four bytes of zeros. You’ll update the first two bytes with the sensor data. As for the remaining two bytes, there’s an exercise waiting for you in <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#ah1606">“Experiments!”</a> on <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#p343">page 343</a> where you can put them to use.</p>
<p>Next, you set the BLE advertisement interval (<code>BLE_ADV_INT</code>) to <code>0.2</code>, meaning the device will send out an advertisement packet every 0.2 seconds. Then you call the method to start sending advertisement packets <!--<ccust1>2</ccust1>-->❷, passing your custom advertisement class and the time interval as arguments. You also initialize the <code>neopixel</code> library to control the LED on the board. The <code>board.NEOPIXEL</code> argument sets the pin number for the neopixel LED, and <code>1</code> represents the number of LEDs on the board. The brightness setting is <code>0.1</code> (the maximum being <code>1.0</code>), and setting the <code>auto_write</code> flag to <code>False</code> means you’ll need to call the <code>show()</code> method explicitly for the values to take. (You’ll see this in action soon.)</p>
<p>The <code>main()</code> function continues with a loop that reads the sensor data and updates the BLE packets:</p>
<div class="codeline">
<p class="clf">    # main loop</p>
<p class="cl">    while True:</p>
<p class="cl">        # print values - this will be available on serial</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ print("Temperature: {:.1f} C".format(bmp280.temperature))</p>
<p class="cl">        print("Humidity: {:.1f} %".format(sht31d.relative_humidity))</p>
<p class="cl">        # get sensor data</p>
<p class="cl"><span aria-label=" Page 324. " class="page" epub:type="pagebreak" id="p324" role="doc-pagebreak"/>      <!--<ccust1>2</ccust1>-->❷ T = int(bmp280.temperature)+ 40</p>
<p class="cl">        H = int(sht31d.relative_humidity)</p>
<p class="cl">        # stop advertising</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ ble.<span class="idx" data-level1="stop_advertising" data-term="adafruit_ble"/>stop_advertising()</p>
<p class="cl">        # update advertisement data</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ advertisement.md_field = ble.name[:5] + chr(T) + chr(H) + "00"</p>
<p class="cl">        # start advertising</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ ble.start_advertising(advertisement, interval=BLE_ADV_INT)</p>
<p class="cl">        # blink neopixel LED</p>
<p class="cl">        pixels.fill((255, 255, 0))</p>
<p class="cl">        pixels.<span class="idx" data-level1="show" data-term="neopixel"/>show()</p>
<p class="cl">        time.sleep(0.1)</p>
<p class="cl">        pixels.fill((0, 0, 0))</p>
<p class="cl">        pixels.show()</p>
<p class="cl">        # sleep for 2 seconds</p>
<p class="cll">      <!--<ccust1>6</ccust1>-->❻ time.sleep(2)</p>
</div>
<p>You begin the loop by printing out the values read by the sensors <!--<ccust1>1</ccust1>-->❶. You can use this output to confirm that your sensors are putting out reasonable values. To see the values, connect the board via USB to your computer and use a serial terminal application such as CoolTerm, as explained in <a class="xref" href="nsp-venkitachalam503045-0027.xhtml#ch12">Chapter 12</a>. The output should look something like this:</p>
<div class="codeline">
<p class="clf">Temperature: 26.7 C</p>
<p class="cll">Humidity: 55.6 %</p>
</div>
<p>Next, you read the temperature and humidity values from the sensors <!--<ccust1>2</ccust1>-->❷, converting both to integers since you have only one byte to represent each value. You add 40 to the temperature to accommodate negative values. The BMP280 temperature sensor on the board has a range of −40°C to 85°C, so adding 40 converts this range to [0, 125]. You’ll be back to the correct range on the Raspberry Pi once the data is parsed from the BLE advertisement data.</p>
<p>You have to stop BLE advertising <!--<ccust1>3</ccust1>-->❸ so you can change the data in the packets. Then you set the manufacturer data field with the first five characters of the device name, followed by one byte each of temperature and humidity values <!--<ccust1>4</ccust1>-->❹. You’re using <code>chr()</code> here to encode each 1-byte value into a character. You also set the last two bytes in the data field to be zeros. Now that you’ve updated the sensor values in the packet, you restart advertising <!--<ccust1>5</ccust1>-->❺. This way, the scanner on the Pi will pick up the new sensor values from the BLE board.</p>
<p>To provide a visual indicator that the device is alive, you blink its neopixel LED by turning it on for 0.1 second. The <code>fill()</code> method sets a color using an (R, G, B) tuple, and <code>show()</code> sets the value to the LED. Finally, you add a two-second delay before restarting the loop and checking the sensors again <!--<ccust1>6</ccust1>-->❻. During that delay, the board will continue sending out the same advertisement packet every 0.2 seconds, as per its advertisement interval.</p>
<p class="pcust1"><span aria-label=" Page 325. " class="page" epub:type="pagebreak" id="p325" role="doc-pagebreak"/><span class="ccust3">NOTE</span> When you’ve tested the code and are ready to deploy your IoT device, I recommend commenting out the <code>print()</code> statements and the neopixel code to conserve power. Remember, BLE is all about low energy!</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1608"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1608"><span class="idx" data-level1="BLE scanner" data-term="IoT garden"/>The BLE Scanner Code</a></h3>
<p class="paft">The code to have your Raspberry Pi listen for and process sensor data over BLE is encapsulated in a class called <code>BLEScanner</code>. To see the complete code listing, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#ah1608">“The Complete BLE Scanner Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#p345">page 345</a>. You’ll also find this code in the book’s GitHub repository at <a class="url-i" href="https://github.com/mkvenkit/pp2e/blob/main/iotgarden/BLEScanner.py">https://github.com/mkvenkit/pp2e/blob/main/iotgarden/BLEScanner.py</a>.</p>
<p>Here’s the constructor for this class:</p>
<div class="codeline">
<p class="clf">class BLEScanner:</p>
<p class="cl">    def __init__(self, dbname):</p>
<p class="cl">        """BLEScanner constructor"""</p>
<p class="cl">        self.T = 0</p>
<p class="cl">        self.H = 0</p>
<p class="cl">        # max values</p>
<p class="cl">        self.TMAX = 30</p>
<p class="cl">        self.HMIN = 20</p>
<p class="cl">        # timestamp for last alert</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ self.last_alert = time.time()</p>
<p class="cl">        # alert interval in seconds</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.ALERT_INT = 60</p>
<p class="cl">        # scan interval in seconds</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ self.SCAN_INT = 10</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ self._dbname = dbname</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ self.hcitool = None</p>
<p class="cl">        self.hcidump = None</p>
<p class="cl">      <!--<ccust1>6</ccust1>-->❻ self.task = None</p>
<p class="cl">        # -----------------------------------------------</p>
<p class="cl">        # peripheral allow list - add your devices here!</p>
<p class="cl">        # -----------------------------------------------</p>
<p class="cll">      <!--<ccust1>7</ccust1>-->❼ self.allowlist = ["<code class="i">DE:74:03:D9:3D:8B</code>"]</p>
</div>
<p>You start by defining instance variables <code>T</code> and <code>H</code> to keep track of the latest temperature and humidity values read from the sensors. Then you set threshold values for triggering the automated alerts. If the temperature goes above <code>TMAX</code> or the humidity goes below <code>HMIN</code>, the program will issue an alert using IFTTT. You create the <code>last_alert</code> variable at <!--<ccust1>1</ccust1>-->❶ to store the time when the most recent alert was sent, and at <!--<ccust1>2</ccust1>-->❷ you set the minimum interval between alerts. This is so you don’t keep sending yourself alerts continuously when an alert condition is met. At <!--<ccust1>3</ccust1>-->❸, you set the scan interval in seconds to control how often the Pi will scan for BLE devices. Next, you save the name of the SQLite database that was passed into the constructor <!--<ccust1>4</ccust1>-->❹. You need this to save values from the sensors.</p>
<p>At <!--<ccust1>5</ccust1>-->❺ and the following line, you create a couple of instance variables to store process IDs for the <code>hcitool</code> and <code>hcidump</code> programs, which will run later. At <!--<ccust1>6</ccust1>-->❻, you create a <code>task</code> instance variable. Later, you’ll be creating a <span aria-label=" Page 326. " class="page" epub:type="pagebreak" id="p326" role="doc-pagebreak"/>separate thread to run this task, which will be doing the scanning, while the main thread of the program runs the web server. Finally, at <!--<ccust1>7</ccust1>-->❼ you create a list of the BLE devices you want to listen to. When you run the BLE scanner, you’re likely to pick up many BLE peripherals, not just the Adafruit Sense boards. Keeping a list with your sensor device IDs makes the BLE data easier to parse. Later in the chapter, I’ll show you how to look up the device IDs so you can add them here to your allowlist.</p>
<section>
<h4 class="ch" id="ch1603">Working with the BlueZ Tools</h4>
<p class="paft">As we discussed in <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#bh1601">“Bluetooth Low Energy”</a> on <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#p313">page 313</a>, this project uses BlueZ, Linux’s official Bluetooth protocol stack, to scan for BLE data. The <code>BLEScanner</code> class needs methods for working with these tools. First we’ll examine the <code>start_scan()</code> method, which sets up the BlueZ tools for BLE scanning.</p>
<div class="codeline">
<p class="clf"><span class="idx" data-level1="starting the scan" data-term="BlueZ"/>def start_scan(self):</p>
<p class="cl">    """starts the BlueZ tools required for scanning"""</p>
<p class="cl">    print("BLE scan started...")</p>
<p class="cl">    # reset device</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ ret = subprocess.run(['sudo', '-n', 'hciconfig', 'hci0', 'reset'],</p>
<p class="cl">                         stdout=subprocess.DEVNULL)</p>
<p class="cl">    print(ret)</p>
<p class="clf">    # start hcitool process</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ self.hcitool = subprocess.Popen(['sudo', '-n', 'hcitool',</p>
<p class="cl">                                     'lescan', '--duplicates'],</p>
<p class="cl">                                    stdout=subprocess.DEVNULL)</p>
<p class="cl">    # start hcidump process</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ self.hcidump = subprocess.Popen(['sudo', '-n', 'hcidump', '--raw'],</p>
<p class="cll">                                    stdout=subprocess.PIPE)</p>
</div>
<p>First you reset the BLE device of the Raspberry Pi using the <code>hciconfig</code> tool <!--<ccust1>1</ccust1>-->❶. You use the Python <code>subprocess</code> module to run this process. The <code>subprocess.run()</code> method takes the process arguments as a list, so this call executes the command <code>sudo -n hciconfig hci0 reset</code>. The output of this process <code>stdout</code> is set to <code>DEVNULL</code>, which just means you don’t care about messages printed out by this command. (The <code>-n</code> flag in <code>sudo</code> makes it noninteractive.) You next use a different <code>subprocess</code> method called <code>Popen()</code> to run the command <code>sudo -n hcitool lescan --duplicates</code> <!--<ccust1>2</ccust1>-->❷. This process scans for BLE peripheral devices. The <code>--duplicates</code> flag ensures that the same device can come up in the scan list repeatedly. You need this, since the sensor data in the advertisement packets keeps changing, and you need the latest values.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> The difference between <code>subprocess.run()</code> and <code>subprocess.Popen()</code> is that the former waits for the process to complete, whereas the latter returns immediately while the process runs in the background.</p>
<p>Finally, you use <code>subprocess.Popen()</code> to run another command: <code>sudo -n hcidump --raw</code> <!--<ccust1>3</ccust1>-->❸. As we discussed earlier in the chapter, this command intercepts and prints out the advertisement data as hexadecimal bytes. Notice <span aria-label=" Page 327. " class="page" epub:type="pagebreak" id="p327" role="doc-pagebreak"/>that <code>stdout</code> is set to <code>subprocess.PIPE</code> in this case. This means you can read the output from this process similar to how you read the contents of a file. More on this in <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#ch1604">“Parsing the Data”</a> below.</p>
<p>Now let’s look at the <code>stop_scan()</code> method, which kills the processes begun in the <code>start_scan()</code> method when you’re ready to stop scanning for BLE packets.</p>
<div class="codeline">
<p class="clf"><span class="idx" data-level1="stopping the scan" data-term="BlueZ"/>def stop_scan(self):</p>
<p class="cl">    """stops BLE scan by killing BlueZ tools processes"""</p>
<p class="cl">    subprocess.run(['sudo', 'kill', str(self.hcidump.pid), '-s', 'SIGINT'])</p>
<p class="cl">    subprocess.run(['sudo', '-n', 'kill', str(self.hcitool.pid),</p>
<p class="cl">                     '-s', "SIGINT"])</p>
<p class="cll">    print("BLE scan stopped.")</p>
</div>
<p>Here you kill off the <code>hcidump</code> and <code>hcitool</code> processes using <code>pid</code>, their process IDs. The command <code>sudo -n kill pid -s SIGINT</code> kills a process with the given <code>pid</code> by sending it the <code>SIGINT</code> interrupt signal.</p>
</section>
<section>
<h4 class="ch" id="ch1604">Parsing the Data</h4>
<p class="paft"><span class="idx" data-level1="parsing data" data-term="BlueZ"/>The scanner needs methods for parsing the BLE data it receives. First we’ll consider the <code>parse_hcidump()</code> method, which parses the output from the <code>hcidump</code> process:</p>
<div class="codeline">
<p class="clf">def parse_hcidump(self):</p>
<p class="cl">    data = ""</p>
<p class="cl">    (macid, name, T, H) = (None, None, None, None)</p>
<p class="cl">    while True:</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ line = self.hcidump.stdout.readline()</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ line = line.<span class="idx" data-level1="decode" data-term="string module"/>decode()</p>
<p class="cl">        if line.<span class="idx" data-level1="startswith" data-term="string module"/>startswith('&gt; '):</p>
<p class="cl">            data = line[2:]</p>
<p class="cl">        elif line.startswith('&lt; '):</p>
<p class="cl">            data = ""</p>
<p class="cl">        else:</p>
<p class="cl">            if data:</p>
<p class="cl">              <!--<ccust1>3</ccust1>-->❸ data += line</p>
<p class="cl">              <!--<ccust1>4</ccust1>-->❹ data = " ".join(data.<span class="idx" data-level1="split" data-term="string module"/>split())</p>
<p class="cl">              <!--<ccust1>5</ccust1>-->❺ fields = self.parse_data(data)</p>
<p class="cl">                    success = False</p>
<p class="cl">                  <!--<ccust1>6</ccust1>-->❻ try:</p>
<p class="cl">                        macid = fields["macid"]</p>
<p class="cl">                        T = fields["T"]</p>
<p class="cl">                        H = fields["H"]</p>
<p class="cl">                        name = fields["name"]</p>
<p class="cl">                        success = True</p>
<p class="cl">                    except KeyError:</p>
<p class="cl">                        # skip this error, since this indicates</p>
<p class="cl">                        # invalid data</p>
<p class="cl">                      <!--<ccust1>7</ccust1>-->❼ pass</p>
<p class="cl">                    if success:</p>
<p class="cll">                      <!--<ccust1>8</ccust1>-->❽ return (macid, name, T, H)</p>
</div>
<p><span aria-label=" Page 328. " class="page" epub:type="pagebreak" id="p328" role="doc-pagebreak"/>Within a <code>while</code> loop, you start reading one line at a time from <code>self.hcidump.stdout</code> using the <code>readline()</code> method <!--<ccust1>1</ccust1>-->❶, much like you’d read lines from a file. To understand the code that follows, it helps to know a bit about the data being parsed. This is what a typical output from <span class="idx" data-level1="hcidump output" data-term="BlueZ"/><code>hcidump</code> looks like:</p>
<div class="codeline">
<p class="clf">&gt; 04 3E 1B 02 01 02 01 8B 3D D9 03 74 DE 0F 0E FF 22 08 0A 31</p>
<p class="cll">  FE 49 4F 54 47 31 1B 36 30 CB</p>
</div>
<p>The output is split across two lines, and it starts with a <i>&gt;</i> character. You want to take these two lines and combine them to get a single string such as <code>"04 3E 1B 02 01 02 01 8B 3D D9 03 74 DE 0F 0E FF 22 08 0A 31 FE 49 4F 54 47 31 1B 36 30 CB"</code>. To do this, you convert the bytes output from <code>readline()</code> to a string using the <code>decode()</code> method <!--<ccust1>2</ccust1>-->❷. Then you use some logic to build up the final string that you want. If the line starts with <code>&gt;</code>, you know it’s the first of the set of two lines making up an <code>hcidump</code> entry, so you store the line and go on to the next one. Lines that start with <code>&lt;</code> are ignored. If a line starts with neither <code>&gt;</code> nor <code>&lt;</code>, then it’s the second line of the advertisement, and you join the lines together <!--<ccust1>3</ccust1>-->❸.</p>
<p>The resulting data will have newline characters in the middle and the end. You get rid of those using a combination of the <code>split()</code> and <code>join()</code> string methods <!--<ccust1>4</ccust1>-->❹. This example illustrates how the scheme works:</p>
<div class="codeline">
<p class="clf">&gt;&gt;&gt; <code class="b">x = "ab cd\n ef\tff\r\n"</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">x.split()</code></p>
<p class="cl">['ab', 'cd', 'ef', 'ff']</p>
<p class="cl">&gt;&gt;&gt; <code class="b">" ".join(x.split())</code></p>
<p class="cll">'ab cd ef ff'</p>
</div>
<p>Notice from the first line of output how the <code>split()</code> method automatically splits up the string at the whitespace characters, producing a list of substrings and removing the whitespace characters in the process. This gets rid of the unwanted newline characters, but it also gets rid of the spaces, which you want to keep. That’s where the <code>join()</code> method comes in. It merges the list items back into a single string, with a space between each substring, as you can see in the second output line.</p>
<p>Returning to the <code>parse_hcidump()</code> method, you now have a complete BLE advertisement packet stored as a string in variable <code>data</code>. You call the <code>parse_data()</code> method on this string to get the device details in the form of a <code>fields</code> dictionary <!--<ccust1>5</ccust1>-->❺. We’ll look at this method soon. Then you retrieve the MAC ID, name, temperature, and humidity values from the dictionary. This code is enclosed in a <code>try</code> block <!--<ccust1>6</ccust1>-->❻ in case the data isn’t what you expect. In that case, an exception will be thrown, and you skip that advertisement packet by calling <code>pass</code> <!--<ccust1>7</ccust1>-->❼. If you successfully retrieve all the values, they’re returned as a tuple <!--<ccust1>8</ccust1>-->❽.</p>
<p>Now let’s take a look at the <code>parse_data()</code> method you used in <code>parse_hcidump()</code> to build the <code>fields</code> dictionary:</p>
<div class="codeline">
<p class="clf">def parse_data(self, data):</p>
<p class="cl">    fields = {}</p>
<p class="cl"><span aria-label=" Page 329. " class="page" epub:type="pagebreak" id="p329" role="doc-pagebreak"/>    # parse MACID</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ x = [int(val, 16) for val in data.split()]</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ macid = ":".join([format(val, '02x').upper() for val in x[7:13][::-1]])</p>
<p class="cl">    # check if MACID is in allowlist</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ if macid in self.allowlist:</p>
<p class="cl">        # look at 6th byte to see PDU type</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ if (x[5] == 0x02): # ADV_IND</p>
<p class="cl">          <!--<ccust1>5</ccust1>-->❺ fields["macid"] = macid</p>
<p class="cl">            # parse data</p>
<p class="cl">          <!--<ccust1>6</ccust1>-->❻ fields["T"] = x[26]</p>
<p class="cl">            fields["H"] = x[27]</p>
<p class="cl">          <!--<ccust1>7</ccust1>-->❼ name = "".join([format(val, '02x').upper() for val in x[21:26]])</p>
<p class="cl">          <!--<ccust1>8</ccust1>-->❽ name = <span class="idx" data-level1="fromhex" data-term="BlueZ"/>bytearray<span class="idx" data-level1="fromhex" data-term="bytearray"/>.fromhex(name).decode()</p>
<p class="cl">            fields["name"] = name</p>
<p class="cll">    return fields</p>
</div>
<p>You start by defining an empty dictionary <code>fields</code>, where you’ll store the parsed data. Then you split the data into a list of hexadecimal values <!--<ccust1>1</ccust1>-->❶ and extract the MAC ID of the peripheral that sent the advertisement packet <!--<ccust1>2</ccust1>-->❷. Here’s a sample run of these statements to illustrate how they work:</p>
<div class="codeline">
<p class="clf">&gt;&gt;&gt; <code class="b">data = "04 3E 1C 02 01 02 01 8B 3D D9 03 74 DE 10 0F FF 22</code></p>
<p class="cl"><code class="b">            08 0B 31 FE 49 4F 54 47 31 61 62 63 64 BD"</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">x = [int(val, 16) for val in data.split()]</code></p>
<p class="cl">&gt;&gt;&gt; <code class="b">x</code></p>
<p class="cl">[4, 62, 28, 2, 1, 2, 1, 139, 61, 217, 3, 116, 222, 16, 15, 255, 34,</p>
<p class="cl"> 8, 11, 49, 254, 73, 79, 84, 71, 49, 97, 98, 99, 100, 189]</p>
<p class="cl">&gt;&gt;&gt; <code class="b">x[7:13][::-1</code>]</p>
<p class="cl">[222, 116, 3, 217, 61, 139]</p>
<p class="cl">&gt;&gt;&gt; <code class="b">[format(val, '02x').upper() for val in x[7:13][::-1]]</code></p>
<p class="cl">['DE', '74', '03', 'D9', '3D', '8B']</p>
<p class="cl">&gt;&gt;&gt; <code class="b">":".join([format(val, '02x').upper() for val in x[7:13][::-1]])</code></p>
<p class="cll">'DE:74:03:D9:3D:8B'</p>
</div>
<p>Notice how the data is first split into a list of decimal numbers (<code>x</code>). Then you use a list comprehension and <code>format()</code> to create two-character string representations of the numbers, taking just bytes 7 through 12 to extract the MAC ID. The <code>[::-1]</code> reverses the MAC ID, since it comes in the opposite order in the packet data. Finally, the <code>join()</code> method merges the bytes making up the MAC ID into a single string, using colons as separators.</p>
<p>Continuing with <code>parse_data()</code>, you check if the extracted MAC ID matches a device on your allowlist <!--<ccust1>3</ccust1>-->❸. If not, you ignore the data. Then you check the fifth byte in the data to ensure that the packet type is <code>ADV_IND</code> <!--<ccust1>4</ccust1>-->❹. This ensures that the data is a regular advertisement packet, and not a scan response. Next, you store the MAC ID in the <code>fields</code> dictionary <!--<ccust1>5</ccust1>-->❺, along with the temperature and humidity values <!--<ccust1>6</ccust1>-->❻, which you read from the appropriate indices in the data list. You also read the five-character device name you put in the BLE packet <!--<ccust1>7</ccust1>-->❼, similar to how you read the MAC ID. Then you call <code>decode()</code> to convert the bytes to a string <!--<ccust1>8</ccust1>-->❽. Finally, you return the <code>fields</code> dictionary to the caller.</p>
</section>
<section>
<h4 class="ch" id="ch1605"><span aria-label=" Page 330. " class="page" epub:type="pagebreak" id="p330" role="doc-pagebreak"/>Sending Alerts</h4>
<p class="paft"><span class="idx" data-level1="sending alerts" data-term="IFTTT"/>Once you’ve parsed the data from a BLE advertisement packet, you need to send an IFTTT alert if the sensor readings are concerning. Define a <code>send_alert()</code> method for this purpose:</p>
<div class="codeline">
<p class="clf">def send_alert(self):</p>
<p class="cl">    # check T, H</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ delta = time.time() - self.last_alert</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ if ((self.T &gt; self.TMAX) or (self.H &lt; self.HMIN)) and</p>
<p class="cl">                                     (delta &gt; self.ALERT_INT):</p>
<p class="cl">        print("Triggering IFTTT alert!")</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ key = '<code class="i">ABCDEF</code>' # USE YOUR KEY HERE!</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ url = 'https://maker.ifttt.com/trigger/TH_alert/json/with/key/' + key</p>
<p class="cl">        json_data = {"T": self.T, "H": self.H}</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ r = requests.<span class="idx" data-level1="post" data-term="requests module"/>post(url, data = json_data)</p>
<p class="cl">        # save last alert</p>
<p class="cll">        self.last_alert = time.<span class="idx" data-level1="time" data-term="time module"/>time()</p>
</div>
<p>First you compute how much time has elapsed since the last time an IFTTT alert was sent <!--<ccust1>1</ccust1>-->❶. Then you check your alert conditions <!--<ccust1>2</ccust1>-->❷. An alert will be triggered either if the current temperature is above <code>TMAX</code> or if the humidity has fallen below <code>HMIN</code>, provided a sufficient amount of time has passed since the last alert. Since the goal is to monitor the health of your garden, checking if it’s too hot or too dry makes sense, but you’re welcome to modify this check with your own alert criteria. You next put together the IFTTT Webhooks URL <!--<ccust1>4</ccust1>-->❹, using your user key set at <!--<ccust1>3</ccust1>-->❸. (Make sure your key matches the one you obtained in <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#bh1606">“If This Then That Setup”</a> <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#p319">on page 319</a>.) Then you set up a simple JSON string with the sensor data and post it to the IFTTT URL <!--<ccust1>5</ccust1>-->❺. You finish by updating the <code>last_alert</code> instance variable with the current time, for future use.</p>
</section>
<section>
<h4 class="ch" id="ch1606">Conducting a Scan</h4>
<p class="paft">The <code>scan_task()</code> method coordinates all the activity required to conduct a BLE scan. This method also stores the scanned data to the SQLite database. Here’s the method definition:</p>
<div class="codeline">
<p class="clf">def scan_task(self):</p>
<p class="cl">    """the scanning task which is run on a separate thread"""</p>
<p class="cl">    # start BLE scan</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ self.start_scan()</p>
<p class="cl">    # get data</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ (macid, name, self.T, self.H) = self.parse_hcidump()</p>
<p class="cl">    # correct temperature offset</p>
<p class="cl">    self.T = self.T - 40</p>
<p class="cl">    print(self.T, self.H)</p>
<p class="cl">    # stop BLE scan</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ self.stop_scan()</p>
<p class="clf">    # send alert if required</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ self.send_alert()</p>
<p class="cl"><span aria-label=" Page 331. " class="page" epub:type="pagebreak" id="p331" role="doc-pagebreak"/>    # write to db</p>
<p class="cl">    # connect to database</p>
<p class="cl">    con = sqlite3.connect(self._dbname)</p>
<p class="cl">    cur = con.cursor()</p>
<p class="cl">    devID = macid</p>
<p class="cl">    # add data</p>
<p class="cl">    with con:</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ cur.execute("INSERT INTO iotgarden_data VALUES (?, ?, ?, ?, ?)",</p>
<p class="cl">                (devID, name, datetime.now(), self.T, self.H))</p>
<p class="cl">    # commit changes</p>
<p class="cl">    con.commit()</p>
<p class="cl">    # close db</p>
<p class="cl">    con.close()</p>
<p class="cl">    # schedule the next task</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ self.task = Timer(self.SCAN_INT, self.scan_task)</p>
<p class="cll">  <!--<ccust1>7</ccust1>-->❼ self.task.start()</p>
</div>
<p>This method harnesses methods you’ve already defined. First you start the BlueZ tools by calling <code>start_scan()</code> <!--<ccust1>1</ccust1>-->❶. Then you call <code>parse_hcidump()</code> to parse the advertisement data <!--<ccust1>2</ccust1>-->❷, storing the retrieved values in a tuple. Right after that, you correct for the temperature offset added in the IoT device by subtracting <code>40</code>. (Recall that this offset was to accommodate negative temperature values.) Calling <code>stop_scan()</code> stops the BLE scanning <!--<ccust1>3</ccust1>-->❸, and calling <code>send_alert()</code> sends an IFTTT alert if required <!--<ccust1>4</ccust1>-->❹.</p>
<p>Next, you establish a connection to your SQLite database, allowing you to insert a row of values consisting of the MAC ID, device name, current time, temperature, and humidity level <!--<ccust1>5</ccust1>-->❺. You then create a <code>Timer</code> object from the <code>threading</code> module and set it up to call the same <code>scan_task()</code> method after a time interval <code>SCAN_INT</code> <!--<ccust1>6</ccust1>-->❻. Finally, you start the timer <!--<ccust1>7</ccust1>-->❼. This way, once the time interval has passed, <code>scan_task()</code> will be executed in a new thread that will run parallel to the rest of the program, and the cycle will be repeated.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1609"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1609">The <span class="idx" data-level1="web server complete code" data-term="IoT garden"/>Web Server Code</a></h3>
<p class="paft">In this section, we’ll look at the code in <i>server.py</i>, which implements a web server on the Raspberry Pi using <code>Bottle</code>. This code will generate a web page displaying the latest sensor values, as well as a plot of the data. Along with Python, you’ll be using small doses of HTML, CSS, and JavaScript in your code, but you don’t need to be an expert in web development to understand the project. At a high level, HTML provides <i>structure</i> for a web page, CSS determines the <i>style</i> of presentation, and JavaScript facilitates <i>actions</i> on the page.</p>
<p>To see the complete code listing, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#ah1609">“The Complete Python Web Server Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#p349">page 349</a>. You can also find this code at <a class="url-i" href="https://github.com/mkvenkit/pp2e/blob/main/iotgarden/server.py">https://github.com/mkvenkit/pp2e/blob/main/iotgarden/server.py</a>.</p>
<section>
<h4 class="ch" id="ch1607"><span aria-label=" Page 332. " class="page" epub:type="pagebreak" id="p332" role="doc-pagebreak"/>Creating and Running the Server</h4>
<p class="paft">The Python code to manage the web server is encapsulated in a class called <code>IOTGServer</code>. Here’s the class’s constructor:</p>
<div class="codeline">
<p class="clf">class IOTGServer:</p>
<p class="cl">    def __init__(self, dbname, host, port):</p>
<p class="cl">        self._dbname = dbname</p>
<p class="cl">        self._host = host</p>
<p class="cl">        self._port = port</p>
<p class="cl">        # create bottle object</p>
<p class="cll">      <!--<ccust1>1</ccust1>-->❶ self._app = <span class="idx" data-level1="creation" data-term="board module"/>Bottle()</p>
</div>
<p>The <code>IOTGServer</code> constructor takes in and stores the database name, hostname, and port number. The constructor also creates a <code>Bottle</code> instance <!--<ccust1>1</ccust1>-->❶, which you’ll use to implement the web server.</p>
<p><span class="idx" data-level1="bottle module" data-level2="create routes" data-term="IoT garden"/>We briefly explored how the <code>Bottle</code> web framework works earlier in the chapter. As you saw, using <code>Bottle</code> involves defining routes to web resources and binding those routes to handler functions that will be called when someone visits that route. The <code>IOTGServer</code> class’s <code>run()</code> method does just that.</p>
<div class="codeline">
<p class="clf">def run(self):</p>
<p class="cl">    # ----------</p>
<p class="cl">    # add routes:</p>
<p class="cl">    # ----------</p>
<p class="cl">    # T/H data</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ self._app.<span class="idx" data-level1="route" data-term="board module"/>route('/thdata')(self.thdata)</p>
<p class="cl">    # plot image</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ self._app.route('/image/&lt;macid&gt;')(self.plot_image)</p>
<p class="cl">    # static files - CSS, JavaScript</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ self._app.route('/static/&lt;filename&gt;')(self.st_file)</p>
<p class="cl">    # main HTML page</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ self._app.route('/')(self.main_page)</p>
<p class="clf">    # start server</p>
<p class="cll">  <!--<ccust1>5</ccust1>-->❺ self._app.run(host=self._host, port=self._port)</p>
</div>
<p>You start by creating four routes, pairing each with its own handler method. The <code>/thdata</code> route <!--<ccust1>1</ccust1>-->❶ returns the latest sensor data for all scanned devices in JSON format. The <code>/image/&lt;macid&gt;</code> route <!--<ccust1>2</ccust1>-->❷ is for an image showing a plot of the sensor data. The plot image will be dynamically created from values in the SQLite database using <code>matplotlib</code>. The <code>&lt;macid&gt;</code> portion of the route uses <code>Bottle</code> URL template syntax to create a placeholder for your device’s MAC ID. As you’ll see later, the actual ID will be filled in by the JavaScript code. The route at <!--<ccust1>3</ccust1>-->❸ is a little different: <code>Bottle</code> allows you to <span class="idx" data-level1="serving static files" data-term="board module"/>serve <i>static</i> files (files that you already have on disk) using the <code>/static</code> keyword in the route. In this case, you’ll be serving JavaScript and CSS files using this scheme. Finally, the <code>/</code> route <!--<ccust1>4</ccust1>-->❹ is for the main HTML page, which will be loaded when you run the server. The method ends with a call to the <code>run()</code> method on the <code>Bottle</code> instance to start the server <!--<ccust1>5</ccust1>-->❺.</p>
</section>
<section>
<h4 class="ch" id="ch1608"><span aria-label=" Page 333. " class="page" epub:type="pagebreak" id="p333" role="doc-pagebreak"/>Serving the Main Page</h4>
<p class="paft"><span class="idx" data-level1="bottle module" data-level2="main HTML page" data-term="IoT garden"/>Now we’ll look at <code>main_page()</code>, the handler method bound to the <code>Bottle</code> route for the main HTML page. This method will be called when the user navigates to <i>http://&lt;iotgarden&gt;.local:8080/</i> in a web browser.</p>
<div class="codeline">
<p class="clf">    def main_page(self):</p>
<p class="cl">        """main HTML page"""</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ response.content_type = 'text/html'</p>
<p class="cl">        strHTML = """</p>
<p class="cl">&lt;!DOCTYPE html&gt;</p>
<p class="cl">&lt;html&gt;</p>
<p class="cl">&lt;head&gt;</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ &lt;link href="static/style.css" rel="stylesheet"&gt;</p>
<p class="cl2"><!--<ccust1>3</ccust1>-->❸ &lt;script src="static/server.js"&gt;&lt;/script&gt;</p>
<p class="cl">&lt;/head&gt;</p>
<p class="cl">&lt;body&gt;</p>
<p class="cl">&lt;div id = "title"&gt;The IoT Garden &lt;/div&gt;</p>
<p class="cl">&lt;hr/&gt;</p>
<p class="cl2"><!--<ccust1>4</ccust1>-->❹ &lt;div id="sensors"&gt;&lt;/div&gt;</p>
<p class="cl">&lt;/body&gt;</p>
<p class="cl">&lt;/html&gt;"""</p>
<p class="cll">        return strHTML</p>
</div>
<p>You set the content type of the response the method will return to be either text or HTML <!--<ccust1>1</ccust1>-->❶. Then you put together the HTML as a multiline string declared within triple quotes (<code>"""</code>). In the HTML code, you load a CSS style sheet file <!--<ccust1>2</ccust1>-->❷ and JavaScript file <!--<ccust1>3</ccust1>-->❸. These files, which will help style the page and fetch the latest sensor data, will be served using the <code>/static</code> route we discussed earlier. You next declare an empty <code>&lt;div&gt;</code> element <!--<ccust1>4</ccust1>-->❹, which is a section or division in an HTML document, assigning it an ID of <code>sensors</code>. This will be populated dynamically by the code in the JavaScript file, as you’ll see later.</p>
<p>Here’s the <code>/static</code> route’s handler method, which serves the JavaScript and CSS files for the main page:</p>
<div class="codeline">
<p class="clf">def st_file(self, filename):</p>
<p class="cl">    """serves static files"""</p>
<p class="cll">    return static_file(filename, root='./static')</p>
</div>
<p>The JavaScript and CSS files are in a <i>/static</i> subfolder with respect to the Python code. You use the <code>Bottle</code> framework’s <code>static_file()</code> method to serve the file from this subfolder with the given filename.</p>
</section>
<section>
<h4 class="ch" id="ch1609">Retrieving the Sensor Data</h4>
<p class="paft"><span class="idx" data-level1="sensor data" data-term="IoT garden"/>As you’ve seen, there are two <code>Bottle</code> routes associated with sensor data: <code>/image/&lt;macid&gt;</code>, which retrieves a plot of a device’s data, and <code>/thdata</code>, which retrieves the most recent sensor data for all devices. We’ll look at the handler methods associated with those routes now, starting with the <code>plot_image()</code> method, which is bound to the <code>/image/&lt;macid&gt;</code> route.</p>
<div class="codeline">
<p class="clf"><span aria-label=" Page 334. " class="page" epub:type="pagebreak" id="p334" role="doc-pagebreak"/>def plot_image(self, macid):</p>
<p class="cl">    """create a plot of sensor data by reading database"""</p>
<p class="cl">    # get data</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ data = self.get_data(macid)</p>
<p class="cl">    # create plot</p>
<p class="cl">    plt.legend(['T', 'H'], loc='upper left')</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ plt.plot(data)</p>
<p class="cl">    # save to a buffer</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ buf = io.<span class="idx" data-level1="BytesIO" data-term="Io module"/>BytesIO()</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ plt.savefig(buf, format='png')</p>
<p class="cl">    # reset stream position to start</p>
<p class="cl">    buf.seek(0)</p>
<p class="cl">    # read image data as bytes</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ img_data = buf.read()</p>
<p class="cl">    # set response type</p>
<p class="cl">    response.content_type = 'image/png'</p>
<p class="cl">    # return image data as bytes</p>
<p class="cll">  <!--<ccust1>6</ccust1>-->❻ return img_data</p>
</div>
<p>The method takes in the MAC ID of the device whose sensor data you want to plot. You call the <code>get_data()</code> helper method <!--<ccust1>1</ccust1>-->❶, which we’ll look at next, to retrieve that device’s data from the SQLite database. The method returns a list of tuples with temperature and humidity readings in the form <code>[(T, H), (T, H), ...]</code>. You use <code>matplotlib</code> to plot this data <!--<ccust1>2</ccust1>-->❷.</p>
<p>Normally, you’d call <code>plt.show()</code> to display a <code>matplotlib</code> plot on your computer, but in this case, your web server needs to send this data out as image bytes so the plot can be viewed in a browser. You use Python’s <code>io.BytesIO</code> module to create a buffer that will act as a file stream to hold the image data <!--<ccust1>3</ccust1>-->❸ and then save the plot to buffer in the PNG format <!--<ccust1>4</ccust1>-->❹. Next, you reset the stream with <code>buf.seek(0)</code>, which in turn sets you up to read the image bytes from the beginning <!--<ccust1>5</ccust1>-->❺. After setting the response return type to a PNG image, you return the image bytes <!--<ccust1>6</ccust1>-->❻.</p>
<p>Here’s the <code>get_data()</code> method that you called as part of <code>plot_image()</code>. It retrieves all temperature and humidity readings from the device with the given MAC ID.</p>
<div class="codeline">
<p class="clf">def get_data(self, macid):</p>
<p class="cl">    # connect to database</p>
<p class="cl">    con = sqlite3.connect(self._dbname)</p>
<p class="cl">    cur = con.cursor()</p>
<p class="cl">    data = []</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ for row in cur.execute("SELECT * FROM iotgarden_data</p>
<p class="cl">                        where DEVID = :dev_id LIMIT 100", {"dev_id" : macid}):</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ data.append((row[3], row[4]))</p>
<p class="cl">    # commit changes</p>
<p class="cl">    con.commit()</p>
<p class="cl">    # close db</p>
<p class="cl">    con.close()</p>
<p class="cls">    return data</p>
</div>
<p><span aria-label=" Page 335. " class="page" epub:type="pagebreak" id="p335" role="doc-pagebreak"/>After establishing a connection to your SQLite database, you issue a query to get the 100 most recent rows in the database with a <code>DEVID</code> equal to the MAC ID passed into this method <!--<ccust1>1</ccust1>-->❶. The rows returned from the database have fields in the form <code>(DEVID, NAME, TS, T, H)</code>. You pick up just the last two elements of each row (a temperature reading and a humidity reading) and append them as a tuple to the <code>data</code> list <!--<ccust1>2</ccust1>-->❷. You end up with the list of tuples that the <code>plot_image()</code> method expects.</p>
<p><span class="idx" data-level1="get sensor data" data-term="IoT garden"/>The other handler method that works with sensor data is <code>thdata()</code>, the handler for the <code>/thdata</code> route. This method returns the latest temperature and humidity values for each of your Adafruit BLE peripheral devices:</p>
<div class="codeline">
<p class="clf">def thdata(self):</p>
<p class="cl">    """connect to database and retrieve latest sensor data"""</p>
<p class="cl">    # connect to database</p>
<p class="cl">    con = sqlite3.connect(self._dbname)</p>
<p class="cl">    cur = con.cursor()</p>
<p class="cl">    macid = ""</p>
<p class="cl">    name = ""</p>
<p class="clf">    # set up a device list</p>
<p class="cl">    devices = []</p>
<p class="clf">    # get unique device list from db</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ devid_list = cur.execute("SELECT DISTINCT DEVID FROM iotgarden_data")</p>
<p class="cl">    for devid in devid_list:</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ for row in cur.execute("SELECT * FROM iotgarden_data</p>
<p class="cl">            where DEVID = :devid ORDER BY TS DESC LIMIT 1",</p>
<p class="cl">            {"devid" : devid[0]}):</p>
<p class="cl">          <!--<ccust1>3</ccust1>-->❸ devices.append({'macid': macid, 'name': name, 'T' : T, 'H': H})</p>
<p class="clf">        # commit changes</p>
<p class="cl">    con.commit()</p>
<p class="cl">    # close db</p>
<p class="cl">    con.close()</p>
<p class="cl">    # return device dictionary</p>
<p class="cll">  <!--<ccust1>4</ccust1>-->❹ return {"devices" : devices}</p>
</div>
<p>Here you run the following query on your SQLite database: <code>SELECT DISTINCT DEVID FROM iotgarden_data</code> <!--<ccust1>1</ccust1>-->❶. This returns all the unique device IDs in the database. For example, if you have three Adafruit boards set up for this project, the query will return the device IDs for all three of them. For each device ID you’ve found, you run the following database query: <code>SELECT * FROM iotgarden_data where DEVID = :devid ORDER BY TS DESC LIMIT 1</code> <!--<ccust1>2</ccust1>-->❷. This gets you the latest (by timestamp) row of data available for the given device ID. You add the retrieved information into a <code>devices</code> list <!--<ccust1>3</ccust1>-->❸. Each element in the list is a dictionary. This list is mapped to a <code>"devices"</code> key in a dictionary and returned <!--<ccust1>4</ccust1>-->❹. The format followed here is JSON—a nested dictionary of lists and dictionaries—which will be convenient to parse in the JavaScript code.</p>
</section>
<section>
<h4 class="ch" id="ch1610"><span aria-label=" Page 336. " class="page" epub:type="pagebreak" id="p336" role="doc-pagebreak"/>The JavaScript</h4>
<p class="paft"><span class="idx" data-level1="JavaScript" data-term="IoT garden"/>Next, let’s take a look at the JavaScript code in file <i>static/server.js</i>. This file is included in the HTML returned by the <code>main_page()</code> handler method, so the JavaScript code will run locally in a web browser on the user’s machine (typically not the Raspberry Pi) when they visit the main project page. The code uses <code>Bottle</code> paths to dynamically add the sensor data to the home page’s HTML.</p>
<div class="codeline">
<p class="clf">// async function that fetches data from server</p>
<p class="cl">async function fetch_data() {</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ let response = await fetch('thdata');</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ devices_json = await response.json();</p>
<p class="cl">    console.log('updating HTML...');</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ devices = devices_json["devices"];</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ let strHTML = "";</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ var ts = new <span class="idx" data-level1="JavaScript" data-level2="Date" data-term="IoT garden"/>Date().getTime();</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ for (let i = 0; i &lt; devices.length; i++) {</p>
<p class="cl">        // console.log(devices[i].macid)</p>
<p class="cl">        strHTML = '&lt;div class="thdata"&gt;';</p>
<p class="cl">        strHTML += '&lt;span&gt;' + devices[i].name + '(' + devices[i].macid</p>
<p class="cl">            + '): &lt;/span&gt;';</p>
<p class="cl">        strHTML += '&lt;span&gt;T = ' + devices[i].T +</p>
<p class="cl">                   ' C (' + (9.0*devices[i].T/5.0 + 32.0) + ' F),&lt;/span&gt;';</p>
<p class="cl">        strHTML += '&lt;span&gt; H = ' + devices[i].H + ' % &lt;/span&gt;';</p>
<p class="cl">        strHTML += '&lt;/div&gt;'; // thdata</p>
<p class="cl">        // create image div</p>
<p class="cl">      <!--<ccust1>7</ccust1>-->❼ strHTML += '&lt;div class="imdiv"&gt;&lt;img src="image/' +</p>
<p class="cl">            devices[i]["macid"] + '?ts=' + ts + '"&gt;&lt;/div&gt;';</p>
<p class="cl">        // add divider</p>
<p class="cl">        strHTML += '&lt;hr/&gt;';</p>
<p class="cl">    }</p>
<p class="clf">    // set HTML data</p>
<p class="cl">  <!--<ccust1>8</ccust1>-->❽ document.<span class="idx" data-level1="JavaScript" data-level2="getElementById" data-term="IoT garden"/>getElementById("sensors").innerHTML = strHTML;</p>
<p class="cll">};</p>
</div>
<p>You first define a JavaScript function called <code>fetch_data()</code>. The <span class="idx" data-level1="JavaScript" data-level2="async" data-term="IoT garden"/><code>async</code> keyword in the definition indicates that you can call the <span class="idx" data-level1="JavaScript" data-level2="await" data-term="IoT garden"/><code>await</code> method from this function. <code>async</code> and <code>await</code> are modern JavaScript features that facilitate asynchronous programming. An example of asynchronous programming is when you request data from a server over a network, as you’ll be doing here. You don’t know when you’ll get a response from the server, and you don’t want to wait around for it. With <code>async</code> and <code>await</code>, you can go off and do other things and get notified when the response arrives. But when you get the response, it could be useful data, or it could indicate an error.</p>
<p>You make an asynchronous call using <code>await</code> to get the <code>/thdata</code> resource using the JavaScript <code>fetch()</code> method <!--<ccust1>1</ccust1>-->❶. When this call reaches the server, it will end up calling the route handler <code>thdata()</code> in the <code>IOTGarden</code> class in <i>server.py</i>. You then make another asynchronous call <!--<ccust1>2</ccust1>-->❷ to get the response from the call <!--<ccust1>1</ccust1>-->❶. This call will return only when the response is received. <span aria-label=" Page 337. " class="page" epub:type="pagebreak" id="p337" role="doc-pagebreak"/>You expect that response to be JSON data, and you retrieve the contents of the <code>"devices"</code> key from the data <!--<ccust1>3</ccust1>-->❸. This will be a list of sensor data values from your devices.</p>
<p>Next, you create an empty string that you’ll use to build up the HTML for showing the sensor data <!--<ccust1>4</ccust1>-->❹. You use the JavaScript <code>Date()</code> method to get a current timestamp <!--<ccust1>5</ccust1>-->❺, which you’ll soon put to use in a little trick to ensure that the plot image loads correctly. Then you loop through all the devices <!--<ccust1>6</ccust1>-->❻ and create the required HTML. Notice especially how you create an HTML <code>&lt;img&gt;</code> element for displaying the <code>matplotlib</code> plot <!--<ccust1>7</ccust1>-->❼, supplying the <code>Bottle</code> route <code>/image/&lt;macid&gt;</code> as the location from which the image should be retrieved.</p>
<p>Once you’ve built up the HTML string, you add it to the home page’s HTML <!--<ccust1>8</ccust1>-->❽. Specifically, you set the HTML into the <code>&lt;div&gt;</code> with the ID of <code>"sensors"</code>. This was the empty <code>&lt;div&gt;</code> you created in <code>main_page()</code>, the <code>IOTGarden</code> class’s handler method for the main page route in the server.</p>
<p>To better illustrate what the code in the <code>for</code> loop at <!--<ccust1>6</ccust1>-->❻ is doing, here’s an example of the output HTML string produced in one iteration through the loop. Note that the output has been formatted for readability.</p>
<div class="codeline">
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ &lt;div class="thdata"&gt;</p>
<p class="cl">    &lt;span&gt;IGDE74(DE:74:03:D9:3D:8B): &lt;/span&gt;</p>
<p class="cl">    &lt;span&gt;T = 26 C, (73.4 F),&lt;/span&gt;</p>
<p class="cl">    &lt;span&gt;H = 55 % &lt;/span&gt;</p>
<p class="cl">&lt;/div&gt;</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ &lt;div class="imdiv"&gt;</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ &lt;img src="image/DE:74:03:D9:3D:8B?ts=1635673486192"&gt;</p>
<p class="cl">&lt;/div&gt;</p>
<p class="cl2l"><!--<ccust1>4</ccust1>-->❹ &lt;hr&gt;</p>
</div>
<p>You first have a <code>&lt;div&gt;</code> of class <code>thdata</code> <!--<ccust1>1</ccust1>-->❶, which contains three <code>&lt;span&gt;</code> elements holding the device name and MAC ID, the latest temperature reading, and the latest humidity reading. Then you have another <code>&lt;div&gt;</code> of class <code>imdiv</code> <!--<ccust1>2</ccust1>-->❷. This <code>&lt;div&gt;</code> contains the <code>&lt;img&gt;</code> element for displaying the plot <!--<ccust1>3</ccust1>-->❸. The <code>src</code> of this element is set as <code>image/DE:74:03:D9:3D:8B?ts=1635673486192</code>. The first part of this, <code>image/DE:74:03:D9:3D:8B</code>, is the route to the <code>plot_image()</code> method in <code>IOTGarden</code>, which takes the device’s MAC ID as an argument. The <code>ts</code> part is a current timestamp, which tricks the browser into not caching the image. Browsers use caching to skip loading web resources that they think they’ve already loaded recently, but you want to ensure that the plot image gets updated regularly. Adding the timestamp to the image’s URL makes the URL different every time, so the browser will keep retrieving this resource.</p>
<p>The HTML string ends with a horizontal line <!--<ccust1>4</ccust1>-->❹ to act as a separator between data for each device. If you have multiple Adafruit BLE devices, you’d see a similar block of HTML for the next device after this first one.</p>
<p>The <i>static/server.js</i> file concludes with this JavaScript code:</p>
<div class="codeline">
<p class="clf">// fetch once on load</p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ window.<span class="idx" data-level1="JavaScript" data-level2="onload" data-term="IoT garden"/>onload = function() {</p>
<p class="cl">    fetch_data();</p>
<p class="cl">};</p>
<p class="clf"><span aria-label=" Page 338. " class="page" epub:type="pagebreak" id="p338" role="doc-pagebreak"/>// now fetch data every 30 seconds</p>
<p class="cl2l"><!--<ccust1>2</ccust1>-->❷ <span class="idx" data-level1="JavaScript" data-level2="setInterval" data-term="IoT garden"/>setInterval(fetch_data, 30000)</p>
</div>
<p>Here you set an anonymous function to be called as soon as the web page loads <!--<ccust1>1</ccust1>-->❶. This function will call <code>fetch_data()</code>, the asynchronous function you defined earlier. This ensures that sensor data will be displayed immediately when the user visits the page. You use the JavaScript <code>setInterval()</code> function <!--<ccust1>2</ccust1>-->❷ to call <code>fetch_data()</code> every 30,000 milliseconds—or every 30 seconds, that is. This way the user will see real-time updates to both the plot and the latest sensor readings.</p>
</section>
<section>
<h4 class="ch" id="ch1611">The CSS</h4>
<p class="paft"><span class="idx" data-level1="CSS" data-term="IoT garden"/>CSS controls the appearance of a web page through a <i>style sheet</i>, which sets rules for how different HTML elements should be rendered. These rules rely on a <i>box model</i>, where every element in your HTML is considered a rectangular box. You can control almost every aspect of a box’s appearance by specifying colors, transparency, margins, borders, text fonts, layout qualifiers, and so on. The CSS rules for the project’s main page are in the file <i>static/style.css</i>.</p>
<div class="codeline">
<p class="clf">html {</p>
<p class="cl">    background-color: gray;</p>
<p class="cl">}</p>
<p class="clf">body {</p>
<p class="cl">    min-height: 100vh;</p>
<p class="cl">    max-width: 800px;</p>
<p class="cl">    background-color: #444444;</p>
<p class="cl">    margin-left: auto;</p>
<p class="cl">    margin-right: auto;</p>
<p class="cl">    margin-top: 0;</p>
<p class="cl">}</p>
<p class="clf">h1 {</p>
<p class="cl">    color: #aaaaaa;</p>
<p class="cl">    font-family: "Times New Roman", Times, serif;</p>
<p class="cl">}</p>
<p class="clf">#title {</p>
<p class="cl">    font-family: "Times New Roman", Times, serif;</p>
<p class="cl">    font-size: 40px;</p>
<p class="cl">    text-align: center;</p>
<p class="cl">}</p>
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ .thdata {</p>
<p class="cl">    display: flex;</p>
<p class="cl">    justify-content: center;</p>
<p class="cl">    width: 80%;</p>
<p class="cl">    color: #aaaaaa;</p>
<p class="cl">    font-family: Arial, Helvetica, sans-serif;</p>
<p class="cl">    font-size: 24px;</p>
<p class="cl">    margin: auto;</p>
<p class="cl">}</p>
<p class="cl2f"><span aria-label=" Page 339. " class="page" epub:type="pagebreak" id="p339" role="doc-pagebreak"/><!--<ccust1>2</ccust1>-->❷ .imdiv {</p>
<p class="cl">    display: flex;</p>
<p class="cl">    justify-content: center;</p>
<p class="cll">}</p>
</div>
<p>We won’t dwell on the details of this CSS file, but notice the code blocks at <!--<ccust1>1</ccust1>-->❶ and <!--<ccust1>2</ccust1>-->❷. These lay out rules for the display of HTML elements with a <code>class</code> attribute of <code>thdata</code> and <code>imdiv</code>, respectively. These are <code>&lt;div&gt;</code> elements generated by the JavaScript file we just looked at.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1610"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1610">The Main Program File</a></h3>
<p class="paft">The main program file <i>iotgarden.py</i> coordinates all the code running on the Raspberry Pi. This file is responsible for creating and managing the SQLite database, starting the BLE scanner, running the <code>Bottle</code> web server, and accepting command line arguments. To see the complete code listing, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#ah1610">“The Complete Main Program Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#p351">page 351</a>. You can also find this code at <a class="url-i" href="https://github.com/mkvenkit/pp2e/blob/main/iotgarden/iotgarden.py">https://github.com/mkvenkit/pp2e/blob/main/iotgarden/iotgarden.py</a>.</p>
<section>
<h4 class="ch" id="ch1612">The Database Setup</h4>
<p class="paft"><span class="idx" data-level1="sqlite setup" data-term="IoT garden"/>The main program uses function <code>setup_db()</code> to prepare the SQLite database. You’ll call this function the first time you run the code, or anytime you want to clear the database of old data and start fresh.</p>
<div class="codeline">
<p class="clf">def setup_db(dbname):</p>
<p class="cl">    """set up the database"""</p>
<p class="cl">    # connect to database - will create new if needed</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ con = sqlite3.connect(dbname)</p>
<p class="cl">    cur = con.cursor()</p>
<p class="cl">    # drop if table exists</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ cur.execute("DROP TABLE IF EXISTS iotgarden_data")</p>
<p class="cl">    # create table</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ cur.execute("CREATE TABLE iotgarden_data(DEVID TEXT, NAME TEXT,</p>
<p class="cll">                 TS DATETIME, T NUMERIC, H NUMERIC)")</p>
</div>
<p>You start by connecting to the SQLite database with a given name and path <!--<ccust1>1</ccust1>-->❶. If the database doesn’t exist yet, this call will create it. You clear off the <code>iotgarden_data</code> table if it already exists in the database <!--<ccust1>2</ccust1>-->❷. Then you create a new table of that name <!--<ccust1>3</ccust1>-->❸. The table is given the following fields: <code>DEVID</code> (a text field for the device’s MAC ID), <code>NAME</code> (a text field for the name of the device), <code>TS</code> (a timestamp of type <code>DATETIME</code>), and numeric <code>T</code> (temperature) and <code>H</code> (humidity) fields.</p>
<p>The main program also has a utility function <code>print_db()</code> for listing the current contents of the database. This can be useful for debugging purposes, or if you want to view all the sensor data as simple text output rather than a graphical plot.</p>
<div class="codeline">
<p class="clf">def print_db(dbname):</p>
<p class="cl">    """prints contents of database"""</p>
<p class="cl">    # connect to database</p>
<p class="cl">    con = sqlite3.connect(dbname)</p>
<p class="cl"><span aria-label=" Page 340. " class="page" epub:type="pagebreak" id="p340" role="doc-pagebreak"/>    cur = con.cursor()</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ for row in cur.execute("SELECT * FROM iotgarden_data"):</p>
<p class="cll">       print(row)</p>
</div>
<p>After connecting to the database, you execute a query to gather all rows from the table of sensor data <!--<ccust1>1</ccust1>-->❶, which you then print out, one row at a time.</p>
</section>
<section>
<h4 class="ch" id="ch1613">The main() Function</h4>
<p class="paft">Now let’s look at the <code>main()</code> function:</p>
<div class="codeline">
<p class="clf">def main():</p>
<p class="cl">    print("starting iotgarden...")</p>
<p class="cl">    # set up cmd line argument parser</p>
<p class="cl">    parser = argparse.<span class="idx" data-level1="ArgumentParser" data-term="argparse"/>ArgumentParser(description="iotgarden.")</p>
<p class="cl">    # add arguments</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ parser.<span class="idx" data-level1="ArgumentParser" data-level2="add_argument" data-term="argparse module"/>add_argument('--createdb', action='store_true', required=False)</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ parser.add_argument('--lsdb', action='store_true', required=False)</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ parser.add_argument('--hostname', dest='hostname', required=False)</p>
<p class="cl">    args = parser.<span class="idx" data-level1="ArgumentParser" data-level2="parse_args" data-term="argparse module"/>parse_args()</p>
<p class="clf">    # set database name</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ dbname = 'iotgarden.db'</p>
<p class="clf">    if (args.createdb):</p>
<p class="cl">        print("Setting up database...")</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ setup_db(dbname)</p>
<p class="cl">        print("done. exiting.")</p>
<p class="cl">        exit(0)</p>
<p class="clf">    if (args.lsdb):</p>
<p class="cl">        print("Listing database contents...")</p>
<p class="cl">      <!--<ccust1>6</ccust1>-->❻ print_db(dbname)</p>
<p class="cl">        print("done. exiting.")</p>
<p class="cl">        exit(0)</p>
<p class="cl">    # set hostname</p>
<p class="cl">  <!--<ccust1>7</ccust1>-->❼ hostname = 'iotgarden.local'</p>
<p class="cl">    if (args.hostname):</p>
<p class="cl">        hostname = args.hostname</p>
<p class="clf">    # create BLE scanner</p>
<p class="cl">  <!--<ccust1>8</ccust1>-->❽ bs = BLEScanner(dbname)</p>
<p class="cl">    # start BLE</p>
<p class="cl">    bs.start()</p>
<p class="clf">    # create server</p>
<p class="cl">  <!--<ccust1>9</ccust1>-->❾ server = IOTGServer(dbname, hostname, 8080)</p>
<p class="cl">    # run server</p>
<p class="cll">    server.run()</p>
</div>
<p>You use a <code>parser</code> object to add command line options for creating or resetting the database <!--<ccust1>1</ccust1>-->❶ and for printing out the database contents <!--<ccust1>2</ccust1>-->❷. <span aria-label=" Page 341. " class="page" epub:type="pagebreak" id="p341" role="doc-pagebreak"/>You also add a <code>--hostname</code> option <!--<ccust1>3</ccust1>-->❸, which lets you use a different hostname—this is useful if you name your Pi something other than <code>iotgarden</code>.</p>
<p>Next, you declare the filename for the SQLite database <!--<ccust1>4</ccust1>-->❹. Then, if the <code>--createdb</code> command line option was used, you call the <code>setup_db()</code> function discussed earlier <!--<ccust1>5</ccust1>-->❺. You print out the database contents if the <code>--lsdb</code> command line option is set <!--<ccust1>6</ccust1>-->❻. You then set the hostname to <code>iotgarden.local</code> by default <!--<ccust1>7</ccust1>-->❼, but you override this if a different hostname was set in the command line.</p>
<p>To finish, you create an object of your <code>BLEScanner</code> class <!--<ccust1>8</ccust1>-->❽ and set it in motion with its <code>start()</code> method. Similarly, you create the <code>Bottle</code> server <!--<ccust1>9</ccust1>-->❾ and launch it by calling the <code>run()</code> method. The scanner and web server will run in parallel with each other.</p>
</section>
</section>
</section>
<section>
<h2 class="ah" id="ah1604"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1604">Running the IoT Garden</a></h2>
<p class="paft"><span class="idx" data-level1="running" data-term="IoT garden"/>The code for this project lives in two places. First, there’s the CircuitPython code in <i>ble_sensors.py</i>, which needs to be renamed <i>code.py</i> and uploaded to the Adafruit BLE Sense boards, as discussed in <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#bh1605">“CircuitPython Setup”</a> on <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#p318">page 318</a>. Once you get each BLE board up and running, you’ll need to determine its MAC address. For this, connect the board to power, and run the following on your Raspberry Pi:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo hcitool lescan</code></p>
</div>
<p>Here’s my output as an example:</p>
<div class="codeline">
<p class="clf">LE Scan...</p>
<p class="cl">57:E0:F5:93:AD:B1 (unknown)</p>
<p class="cl">57:E0:F5:93:AD:B1 (unknown)</p>
<p class="cl">DE:74:03:D9:3D:8B (unknown)</p>
<p class="cl">DE:74:03:D9:3D:8B IOTG1</p>
<p class="cl">27:FE:36:49:F0:2E (unknown)</p>
<p class="cl">7A:17:EB:3C:04:A5 (unknown)</p>
<p class="cll">7A:17:EB:3C:04:A5 (unknown)</p>
</div>
<p>Here, my board’s MAC ID <code>DE:74:03:D9:3D:8B</code> appears next to <code>IOTG1</code>. (It will likely be a different ID for you.) Take note of this ID and add it to the allowlist in your BLE scanner code.</p>
<p>The rest of the code goes on the Raspberry Pi, which you can work with using SSH and VS Code, as discussed in <a class="xref" href="nsp-venkitachalam503045-0032.xhtml#appb">Appendix B</a>. When you’re ready to try it, run the following from the code directory:</p>
<div class="codeline">
<p class="cls">$ <code class="b">sudo python iotgarden.py</code></p>
</div>
<p>You’ll see a stream of messages on your shell similar to the following output:</p>
<div class="codeline">
<p class="clf">starting iotgarden...</p>
<p class="cl">BLE scan started...</p>
<p class="cl"><span aria-label=" Page 342. " class="page" epub:type="pagebreak" id="p342" role="doc-pagebreak"/>CompletedProcess(args=['sudo', 'hciconfig', 'hci0', 'reset'], returncode=0)</p>
<p class="cl">04 3E 1C 02 01 02 01 8B 3D D9 03 74 DE 10 0F FF 22 08 0B CD AB 49 4F 54 47 31</p>
<p class="cl">1A 3A 30 30 C9 26 58</p>
<p class="cl">BLE scan stopped.</p>
<p class="cl">Bottle v0.12.19 server starting up (using WSGIRefServer())...</p>
<p class="cl">Listening on http://iotgarden.local:8080/</p>
<p class="cll">Hit Ctrl-C to quit.</p>
</div>
<p>Now, open a browser window on any computer on the same local network, and navigate to <i>http://&lt;iotgarden&gt;.local:8080/</i>, substituting your Raspberry Pi name as appropriate. You should see output similar to <a class="xref" href="nsp-venkitachalam503045-0029.xhtml#fig14-4">Figure 14-4</a>.</p>
<figure class="figure" id="fig14-4">
<p class="fig"><img alt="" height="875" src="images/nsp-venkitachalam503045-f14004.jpg" style="width:95%; height:auto;" width="1198"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 14-4:</span> The browser output from the IoT garden project</p>
</figcaption>
</figure>
<p>The browser output will show a web page with the device ID and the latest temperature and humidity values, along with a graph of the latest 100 values from the device. This information will be repeated for each device that you have configured. The graph will refresh automatically every 30 seconds to show you the latest data.</p>
<p>If you don’t want to wait for an exceptionally hot or dry day to <span class="idx" data-level1="IFTTT alert" data-term="IoT garden"/>test the IFTTT alert system, put your finger on the temperature sensor (or warm it up slightly using any other method, taking care not to damage the board) so that it exceed the temperature threshold <code>self.TMAX</code> set in <i>BLEScanner.py</i>. You should see a message like this in your shell on the Raspberry Pi:</p>
<div class="codeline">
<p class="cls">Triggering IFTTT alert!</p>
</div>
<p>In a few seconds, you should also get an alert on the IFTTT app on your phone.</p>
</section>
<section>
<h2 class="ah" id="ah1605"><span aria-label=" Page 343. " class="page" epub:type="pagebreak" id="p343" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1605">Summary</a></h2>
<p class="paft">We’ve covered a lot of ground in this chapter! You learned about a multitier IoT architecture consisting of hardware, software, and the cloud. You learned how to use CircuitPython to get data from sensors and transmit it via the BLE wireless protocol. You also learned how to run a simple web server on your Raspberry Pi and how to display sensor data in a web browser using HTML, JavaScript, and CSS. You even learned how to get live alerts from your IoT garden using the IFTTT service.</p>
</section>
<section>
<h2 class="ah" id="ah1606"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1606">Experiments!</a></h2>
<ol style="list-style-type:none">
<li class="nl">1. For simplicity, the web page you created to display your sensor data is quite limited, but it provides a good framework you can build on to create more sophisticated visualizations of the data, especially since you’re using a structured database like SQLite to store the sensor values. Here are a few suggestions to improve the page:
            <ul style="list-style-type:none">
<li class="bl1">◦ Instead of showing data from all the BLE Sense boards at once, create a pull-down menu to select the board whose data you want to display.</li>
<li class="bl1">◦ Implement a way to set how many days of data you want to show in the plot. You can use the JavaScript <span class="idx" data-level1="JavaScript" data-level2="DatePicker" data-term="IoT garden"/>DatePicker, along with a custom <code>Bottle</code> route and a special SQLite query to implement this.</li>
<li class="bl1">◦ Customize your JavaScript code to update the latest sensor values every few seconds and only refresh the plot on a longer time scale.</li>
</ul>
</li>
<li class="nl">2. You wrote the CircuitPython code to transmit the temperature and humidity data as single-byte integers, but what if you want more accuracy? How could you transmit a value like <code>26.54</code> over BLE? (Hint: there are two unused bytes in the manufacturer data field of the BLE packet. For a value like <code>26.54</code>, you could store the <code>54</code> in a byte and divide it by <code>100</code> upon receipt in the BLE scanner code.)</li>
<li class="nl">3. Power consumption is a major concern in IoT. Think about how you can save battery power on the devices. One method is to slow down the BLE advertisement interval. Another option you can explore is to use the Arduino C++ library instead of CircuitPython on the Adafruit boards. This will allow you to reduce the power consumption of the device by putting it to deep sleep during times when it isn’t reading the sensor data or transmitting BLE messages.</li>
</ol>
</section>
<section>
<h2 class="ah" id="ah1607"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1607">The Complete CircuitPython Code</a></h2>
<p class="paft"><span class="idx" data-level1="CircuitPython code" data-term="IoT garden"/>Here’s the complete <i>ble_sensors.py</i> code listing:</p>
<div class="codeline1">
<p class="cl1f">"""</p>
<p class="cl1">ble_sensors.py</p>
<p class="cl1f"><span aria-label=" Page 344. " class="page" epub:type="pagebreak" id="p344" role="doc-pagebreak"/>CircuitPython code for Adafruit BLE Sense boards. This program reads</p>
<p class="cl1">data from the built-in Temperature and Humidity sensors, and puts the</p>
<p class="cl1">data in the BLE advertisement packet.</p>
<p class="cl1f">Author: Mahesh Venkitachalam</p>
<p class="cl1">"""</p>
<p class="cl1f">import time</p>
<p class="cl1">import struct</p>
<p class="cl1">import board</p>
<p class="cl1">import adafruit_bmp280</p>
<p class="cl1">import adafruit_sht31d</p>
<p class="cl1">from adafruit_ble import BLERadio</p>
<p class="cl1">from adafruit_ble.advertising import Advertisement, LazyObjectField</p>
<p class="cl1">from adafruit_ble.advertising.standard import ManufacturerData, ManufacturerDataField</p>
<p class="cl1">import _bleio</p>
<p class="cl1">import neopixel</p>
<p class="cl1f"># derived from adafruit_ble class Advertisement</p>
<p class="cl1">class IOTGAdvertisement(Advertisement):</p>
<p class="cl1">    flags = None</p>
<p class="cl1">    match_prefixes = (</p>
<p class="cl1">        struct.pack(</p>
<p class="cl1">            "&lt;BHBH",  # prefix format</p>
<p class="cl1">            0xFF,     # 0xFF is "Manufacturer Specific Data" as per BLE spec</p>
<p class="cl1">            0x0822,   # 2-byte company ID</p>
<p class="cl1">            struct.calcsize("&lt;H9s"), # data format</p>
<p class="cl1">            0xabcd # our ID</p>
<p class="cl1">        ), # comma required - a tuple is expected</p>
<p class="cl1">    )</p>
<p class="cl1">    manufacturer_data = LazyObjectField(</p>
<p class="cl1">        ManufacturerData,</p>
<p class="cl1">        "manufacturer_data",</p>
<p class="cl1">        advertising_data_type=0xFF, # 0xFF is "Manufacturer Specific Data" as per BLE spec</p>
<p class="cl1">        company_id=0x0822,          # 2-byte company ID</p>
<p class="cl1">        key_encoding="&lt;H",</p>
<p class="cl1">    )</p>
<p class="cl1">    # set manufacturer data field</p>
<p class="cl1">    md_field = ManufacturerDataField(0xabcd, "&lt;9s")</p>
<p class="cl1f">def main():</p>
<p class="cl1f">    # initialize I2C</p>
<p class="cl1">    i2c = board.I2C()</p>
<p class="cl1f">    # initialize sensors</p>
<p class="cl1">    bmp280 = adafruit_bmp280.Adafruit_BMP280_I2C(i2c)</p>
<p class="cl1">    sht31d = adafruit_sht31d.SHT31D(i2c)</p>
<p class="cl1f">    # initialize BLE</p>
<p class="cl1">    ble = BLERadio()</p>
<p class="cl1f">    # create custom advertisement object</p>
<p class="cl1">    advertisement = IOTGAdvertisement()</p>
<p class="cl1">    # append first 2 hex bytes (4 characters) of MAC address to name</p>
<p class="cl1"><span aria-label=" Page 345. " class="page" epub:type="pagebreak" id="p345" role="doc-pagebreak"/>    addr_bytes = _bleio.adapter.address.address_bytes</p>
<p class="cl1">    name = "{0:02x}{1:02x}".format(addr_bytes[5], addr_bytes[4]).upper()</p>
<p class="cl1">    # set device name</p>
<p class="cl1">    ble.name = "IG" + name</p>
<p class="cl1f">    # set initial value</p>
<p class="cl1">    # will use only first 5 chars of name</p>
<p class="cl1">    advertisement.md_field = ble.name[:5] + "0000"</p>
<p class="cl1">    # BLE advertising interval in seconds</p>
<p class="cl1">    BLE_ADV_INT = 0.2</p>
<p class="cl1">    # start BLE advertising</p>
<p class="cl1">    ble.start_advertising(advertisement, interval=BLE_ADV_INT)</p>
<p class="cl1f">    # set up NeoPixels and turn them all off</p>
<p class="cl1">    pixels = neopixel.NeoPixel(board.NEOPIXEL, 1,</p>
<p class="cl1">                               brightness=0.1, auto_write=False)</p>
<p class="cl1f">    # main loop</p>
<p class="cl1">    while True:</p>
<p class="cl1">        # print values - this will be available on serial</p>
<p class="cl1">        print("Temperature: {:.1f} C".format(bmp280.temperature))</p>
<p class="cl1">        print("Humidity: {:.1f} %".format(sht31d.relative_humidity))</p>
<p class="cl1">        # get sensor data</p>
<p class="cl1">        # BMP280 range is -40 to 85 deg C, so add an offset to support</p>
<p class="cl1">        # negative temperatures</p>
<p class="cl1">        T = int(bmp280.temperature) + 40</p>
<p class="cl1">        H = int(sht31d.relative_humidity)</p>
<p class="cl1">        # stop advertising</p>
<p class="cl1">        ble.stop_advertising()</p>
<p class="cl1">        # update advertisement data</p>
<p class="cl1">        advertisement.md_field = ble.name[:5] + chr(T) + chr(H) + "00"</p>
<p class="cl1">        # start advertising</p>
<p class="cl1">        ble.start_advertising(advertisement, interval=BLE_ADV_INT)</p>
<p class="cl1">        # blink neopixel LED</p>
<p class="cl1">        pixels.fill((255, 255, 0))</p>
<p class="cl1">        pixels.show()</p>
<p class="cl1">        time.sleep(0.1)</p>
<p class="cl1">        pixels.fill((0, 0, 0))</p>
<p class="cl1">        pixels.show()</p>
<p class="cl1f">        # sleep for 2 seconds</p>
<p class="cl1">        time.sleep(2)</p>
<p class="cl1f"># call main</p>
<p class="cl1">if __name__ == "__main__":</p>
<p class="cl1">    main()</p>
</div>
</section>
<section>
<h2 class="ah" id="ah1608"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1608">The Complete BLE Scanner Code</a></h2>
<p class="paft"><span class="idx" data-level1="BLE scanner" data-level2="complete code" data-term="IoT garden"/>Here’s the complete listing for the BLE scanner code, in file <i>BLEScanner.py</i>:</p>
<div class="codeline1">
<p class="cl1f">"""</p>
<p class="cl1">BLEScanner.py</p>
<p class="cl1f"><span aria-label=" Page 346. " class="page" epub:type="pagebreak" id="p346" role="doc-pagebreak"/>This class uses BlueZ hciconfig, hcitool, and hcidump tools to parse</p>
<p class="cl1">advertisement data from BLE peripherals. It then stores them in a database.</p>
<p class="cl1">This class also sends alerts via the IFTTT service.</p>
<p class="cl1f">Author: Mahesh Venkitachalam</p>
<p class="cl1">"""</p>
<p class="cl1f">import sqlite3</p>
<p class="cl1">import subprocess</p>
<p class="cl1">from threading import Timer</p>
<p class="cl1">import sys</p>
<p class="cl1">import os</p>
<p class="cl1">import time</p>
<p class="cl1">import requests</p>
<p class="cl1">from datetime import datetime</p>
<p class="cl1f">class BLEScanner:</p>
<p class="cl1">    def __init__(self, dbname):</p>
<p class="cl1">        """BLEScanner constructor"""</p>
<p class="cl1">        self.T = 0</p>
<p class="cl1">        self.H = 0</p>
<p class="cl1">        # max values</p>
<p class="cl1">        self.TMAX = 30</p>
<p class="cl1">        self.HMIN = 20</p>
<p class="cl1">        # time stamp for last alert</p>
<p class="cl1">        self.last_alert = time.time()</p>
<p class="cl1">        # alert interval in seconds</p>
<p class="cl1">        self.ALERT_INT = 60</p>
<p class="cl1">        # scan interval in seconds</p>
<p class="cl1">        self.SCAN_INT = 10</p>
<p class="cl1">        self._dbname = dbname</p>
<p class="cl1">        self.hcitool = None</p>
<p class="cl1">        self.hcidump = None</p>
<p class="cl1">        self.task = None</p>
<p class="cl1">        # -----------------------------------------------</p>
<p class="cl1">        # peripheral allow list - add your devices here!</p>
<p class="cl1">        # -----------------------------------------------</p>
<p class="cl1">        self.allowlist = ["DE:74:03:D9:3D:8B"]</p>
<p class="cl1f">    def start(self):</p>
<p class="cl1">        """start BLE scan"""</p>
<p class="cl1">        # start task</p>
<p class="cl1">        self.scan_task()</p>
<p class="cl1f">    def stop(self):</p>
<p class="cl1">        """stop BLE scan"""</p>
<p class="cl1">        # stop timer</p>
<p class="cl1">        self.task.cancel()</p>
<p class="cl1f">    def send_alert(self):</p>
<p class="cl1">        """send IFTTT alert if sensor data has exceeded the thresholds"""</p>
<p class="cl1">        # check T, H</p>
<p class="cl1">        delta = time.time() - self.last_alert</p>
<p class="cl1">        # print("delta: ", delta)</p>
<p class="cl1">        if ((self.T &gt; self.TMAX) or (self.H &lt; self.HMIN)) and (delta &gt; self.ALERT_INT):</p>
<p class="cl1"><span aria-label=" Page 347. " class="page" epub:type="pagebreak" id="p347" role="doc-pagebreak"/>            print("Triggering IFTTT alert!")</p>
<p class="cl1">            key = '6zmfaOBei1DgdmlOgOi6C' # USE YOUR KEY HERE!</p>
<p class="cl1">            url = 'https://maker.ifttt.com/trigger/TH_alert/json/with/key/' + key</p>
<p class="cl1">            json_data = {"T": self.T, "H": self.H}</p>
<p class="cl1">            r = requests.post(url, data = json_data)</p>
<p class="cl1">            # save last alert</p>
<p class="cl1">            self.last_alert = time.time()</p>
<p class="cl1f">    def start_scan(self):</p>
<p class="cl1">        """starts the BlueZ tools required for scanning"""</p>
<p class="cl1">        print("BLE scan started...")</p>
<p class="cl1">        # reset device</p>
<p class="cl1">        ret = subprocess.run(['sudo', '-n', 'hciconfig', 'hci0', 'reset'],</p>
<p class="cl1">                             stdout=subprocess.DEVNULL)</p>
<p class="cl1">        print(ret)</p>
<p class="cl1f">        # start hcitool process</p>
<p class="cl1">        self.hcitool = subprocess.Popen(['sudo', '-n', 'hcitool', 'lescan', '--duplicates'],</p>
<p class="cl1">                                        stdout=subprocess.DEVNULL)</p>
<p class="cl1f">        # start hcidump process</p>
<p class="cl1">        self.hcidump = subprocess.Popen(['sudo', '-n', 'hcidump', '--raw'],</p>
<p class="cl1">                                        stdout=subprocess.PIPE)</p>
<p class="cl1f">    def stop_scan(self):</p>
<p class="cl1">        """stops BLE scan by killing BlueZ tools processes."""</p>
<p class="cl1">        subprocess.run(['sudo', 'kill', str(self.hcidump.pid), '-s', 'SIGINT'])</p>
<p class="cl1">        subprocess.run(['sudo', '-n', 'kill', str(self.hcitool.pid), '-s', "SIGINT"])</p>
<p class="cl1">        print("BLE scan stopped.")</p>
<p class="cl1f">    def parse_data(self, data):</p>
<p class="cl1">        """parses hcdump string and outputs MACID, name, manufacturer data"""</p>
<p class="cl1">        fields = {}</p>
<p class="cl1">        # parse MACID</p>
<p class="cl1">        x = [int(val, 16) for val in data.split()]</p>
<p class="cl1">        macid = ":".join([format(val, '02x').upper() for val in x[7:13][::-1]])</p>
<p class="cl1">        # check if MACID is in allowlist</p>
<p class="cl1">        if macid in self.allowlist:</p>
<p class="cl1">            # look at 6th byte to see PDU type</p>
<p class="cl1">            if (x[5] == 0x02): # ADV_IND</p>
<p class="cl1">                print(data)</p>
<p class="cl1">                fields["macid"] = macid</p>
<p class="cl1">                # set pkt type</p>
<p class="cl1">                #fields["ptype"] = "ADV_IND"</p>
<p class="cl1">                # parse data</p>
<p class="cl1">                fields["T"] = x[26]</p>
<p class="cl1">                fields["H"] = x[27]</p>
<p class="cl1">                name = "".join([format(val, '02x').upper() for val in x[21:26]])</p>
<p class="cl1">                name = bytearray.fromhex(name).decode()</p>
<p class="cl1">                fields["name"] = name</p>
<p class="cl1">        return fields</p>
<p class="cl1f">    def parse_hcidump(self):</p>
<p class="cl1">        """parse output from hcidump"""</p>
<p class="cl1">        data = ""</p>
<p class="cl1"><span aria-label=" Page 348. " class="page" epub:type="pagebreak" id="p348" role="doc-pagebreak"/>        (macid, name, T, H) = (None, None, None, None)</p>
<p class="cl1">        while True:</p>
<p class="cl1">            line = self.hcidump.stdout.readline()</p>
<p class="cl1">            line = line.decode()</p>
<p class="cl1">            if line.startswith('&gt; '):</p>
<p class="cl1">                data = line[2:]</p>
<p class="cl1">            elif line.startswith('&lt; '):</p>
<p class="cl1">                data = ""</p>
<p class="cl1">            else:</p>
<p class="cl1">                if data:</p>
<p class="cl1">                    # concatenate lines</p>
<p class="cl1">                    data += line</p>
<p class="cl1">                    # a tricky way to remove whitespace</p>
<p class="cl1">                    data = " ".join(data.split())</p>
<p class="cl1">                    # parse data</p>
<p class="cl1">                    fields = self.parse_data(data)</p>
<p class="cl1">                    success = False</p>
<p class="cl1">                    try:</p>
<p class="cl1">                        macid = fields["macid"]</p>
<p class="cl1">                        T = fields["T"]</p>
<p class="cl1">                        H = fields["H"]</p>
<p class="cl1">                        name = fields["name"]</p>
<p class="cl1">                        success = True</p>
<p class="cl1">                    except KeyError:</p>
<p class="cl1">                        # skip this error, since this indicates</p>
<p class="cl1">                        # invalid data</p>
<p class="cl1">                        pass</p>
<p class="cl1">                    if success:</p>
<p class="cl1">                        return (macid, name, T, H)</p>
<p class="cl1f">    def scan_task(self):</p>
<p class="cl1">        """the scanning task which is run on a separate thread"""</p>
<p class="cl1">        # start BLE scan</p>
<p class="cl1">        self.start_scan()</p>
<p class="cl1">        # get data</p>
<p class="cl1">        (macid, name, self.T, self.H) = self.parse_hcidump()</p>
<p class="cl1">        # correct temperature offset</p>
<p class="cl1">        self.T = self.T - 40</p>
<p class="cl1">        print(self.T, self.H)</p>
<p class="cl1">        # stop BLE scan</p>
<p class="cl1">        self.stop_scan()</p>
<p class="cl1f">        # send alert if required</p>
<p class="cl1">        self.send_alert()</p>
<p class="cl1f">        # write to db</p>
<p class="cl1">        # connect to database</p>
<p class="cl1">        con = sqlite3.connect(self._dbname)</p>
<p class="cl1">        cur = con.cursor()</p>
<p class="cl1">        devID = macid</p>
<p class="cl1">        # add data</p>
<p class="cl1">        with con:</p>
<p class="cl1">            cur.execute("INSERT INTO iotgarden_data VALUES (?, ?, ?, ?, ?)",</p>
<p class="cl1">                (devID, name, datetime.now(), self.T, self.H))</p>
<p class="cl1">        # commit changes</p>
<p class="cl1"><span aria-label=" Page 349. " class="page" epub:type="pagebreak" id="p349" role="doc-pagebreak"/>        con.commit()</p>
<p class="cl1">        # close db</p>
<p class="cl1">        con.close()</p>
<p class="cl1f">        # schedule the next task</p>
<p class="cl1">        self.task = Timer(self.SCAN_INT, self.scan_task)</p>
<p class="cl1">        self.task.start()</p>
<p class="cl1f"># use this for testing the class independently</p>
<p class="cl1">def main():</p>
<p class="cl1">    print("starting BLEScanner...")</p>
<p class="cl1">    bs = BLEScanner("iotgarden.db")</p>
<p class="cl1">    bs.start()</p>
<p class="cl1">    data = None</p>
<p class="cl1">    while True:</p>
<p class="cl1">        try:</p>
<p class="cl1">            (macid, name, T, H) = bs.parse_hcidump()</p>
<p class="cl1">            # exit(0)</p>
<p class="cl1">        except:</p>
<p class="cl1">            bs.stop()</p>
<p class="cl1">            print("stopped. Exiting")</p>
<p class="cl1">            exit(0)</p>
<p class="cl1f">        print(macid, name, T, H)</p>
<p class="cl1">        time.sleep(10)</p>
<p class="cl1f">if __name__ == '__main__':</p>
<p class="cl1">    main()</p>
</div>
</section>
<section>
<h2 class="ah" id="ah1609"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1609">The Complete Python Web Server Code</a></h2>
<p class="paft"><span class="idx" data-level1="bottle module" data-level2="complete code" data-term="IoT garden"/>Before we move on to the JavaScript and CSS files that round out the web server code, here’s a complete listing of the Python portion of the web server code, in file <i>server.py</i>.</p>
<div class="codeline1">
<p class="cl1f">"""</p>
<p class="cl1">server.py</p>
<p class="cl1f">This program creates a Bottle.py based web server. It also creates a</p>
<p class="cl1">plot from the sensor data.</p>
<p class="cl1f">Author: Mahesh Venkitachalam</p>
<p class="cl1">"""</p>
<p class="cl1f">from bottle import Bottle, route, template, response, static_file</p>
<p class="cl1">from matplotlib import pyplot as plt</p>
<p class="cl1">import io</p>
<p class="cl1">import sqlite3</p>
<p class="cl1f">class IOTGServer:</p>
<p class="cl1f">    def __init__(self, dbname, host, port):</p>
<p class="cl1">        """constructor for IGServer"""</p>
<p class="cl1"><span aria-label=" Page 350. " class="page" epub:type="pagebreak" id="p350" role="doc-pagebreak"/>        self._dbname = dbname</p>
<p class="cl1">        self._host = host</p>
<p class="cl1">        self._port = port</p>
<p class="cl1">        # create bottle object</p>
<p class="cl1">        self._app = Bottle()</p>
<p class="cl1f">    def get_data(self, macid):</p>
<p class="cl1">        # connect to database</p>
<p class="cl1">        con = sqlite3.connect(self._dbname)</p>
<p class="cl1">        cur = con.cursor()</p>
<p class="cl1">        data = []</p>
<p class="cl1">        for row in cur.execute("SELECT * FROM iotgarden_data where DEVID = :dev_id LIMIT 100",</p>
<p class="cl1">                               {"dev_id" : macid}):</p>
<p class="cl1">            data.append((row[3], row[4]))</p>
<p class="cl1">        # commit changes</p>
<p class="cl1">        con.commit()</p>
<p class="cl1">        # close db</p>
<p class="cl1">        con.close()</p>
<p class="cl1f">        return data</p>
<p class="cl1f">    def plot_image(self, macid):</p>
<p class="cl1">        """create a plot of sensor data by reading database"""</p>
<p class="cl1">        # get data</p>
<p class="cl1">        data = self.get_data(macid)</p>
<p class="cl1">        # create plot</p>
<p class="cl1">        plt.legend(['T', 'H'], loc='upper left')</p>
<p class="cl1">        plt.plot(data)</p>
<p class="cl1">        # save to a buffer</p>
<p class="cl1">        buf = io.BytesIO()</p>
<p class="cl1">        plt.savefig(buf, format='png')</p>
<p class="cl1">        # reset stream position to start</p>
<p class="cl1">        buf.seek(0)</p>
<p class="cl1">        # read image data as bytes</p>
<p class="cl1">        img_data = buf.read()</p>
<p class="cl1">        # set response type</p>
<p class="cl1">        response.content_type = 'image/png'</p>
<p class="cl1">        # return image data as bytes</p>
<p class="cl1">        return img_data</p>
<p class="cl1f">    def main_page(self):</p>
<p class="cl1">        """main HTML page"""</p>
<p class="cl1">        response.content_type = 'text/html'</p>
<p class="cl1">        strHTML = """</p>
<p class="cl1">&lt;!DOCTYPE html&gt;</p>
<p class="cl1">&lt;html&gt;</p>
<p class="cl1">&lt;head&gt;</p>
<p class="cl1">&lt;link href="static/style.css" rel="stylesheet"&gt;</p>
<p class="cl1">&lt;script src="static/server.js"&gt;&lt;/script&gt;</p>
<p class="cl1">&lt;/head&gt;</p>
<p class="cl1">&lt;body&gt;</p>
<p class="cl1">&lt;div id = "title"&gt;The IoT Garden &lt;/div&gt;</p>
<p class="cl1">&lt;hr/&gt;</p>
<p class="cl1">&lt;div id="sensors"&gt;&lt;/div&gt;</p>
<p class="cl1"><span aria-label=" Page 351. " class="page" epub:type="pagebreak" id="p351" role="doc-pagebreak"/>&lt;/body&gt;</p>
<p class="cl1">&lt;/html&gt;"""</p>
<p class="cl1">        return strHTML</p>
<p class="cl1f">    def thdata(self):</p>
<p class="cl1">        """connect to database and retrieve latest sensor data"""</p>
<p class="cl1">        # connect to database</p>
<p class="cl1">        con = sqlite3.connect(self._dbname)</p>
<p class="cl1">        cur = con.cursor()</p>
<p class="cl1">        # set up a device list</p>
<p class="cl1">        devices = []</p>
<p class="cl1">        # get unique device list from db</p>
<p class="cl1">        devid_list = cur.execute("SELECT DISTINCT DEVID FROM iotgarden_data")</p>
<p class="cl1">        # print(devid_list)</p>
<p class="cl1">        for devid in devid_list:</p>
<p class="cl1">            for row in cur.execute("SELECT * FROM iotgarden_data where DEVID = :devid</p>
<p class="cl1">                ORDER BY TS DESC LIMIT 1",</p>
<p class="cl1">                {"devid" : devid[0]}):</p>
<p class="cl1">                devices.append({'macid': row[0], 'name': row[1], 'T' : row[3], 'H': row[4]})</p>
<p class="cl1f">         # commit changes</p>
<p class="cl1">        con.commit()</p>
<p class="cl1">        # close db</p>
<p class="cl1">        con.close()</p>
<p class="cl1">        # return device dictionary</p>
<p class="cl1">        return {"devices" : devices}</p>
<p class="cl1f">    def st_file(self, filename):</p>
<p class="cl1">        """serves static files"""</p>
<p class="cl1">        return static_file(filename, root='./static')</p>
<p class="cl1f">    def run(self):</p>
<p class="cl1">        # ----------</p>
<p class="cl1">        # add routes:</p>
<p class="cl1">        # ----------</p>
<p class="cl1">        # T/H data</p>
<p class="cl1">        self._app.route('/thdata')(self.thdata)</p>
<p class="cl1">        # plot image</p>
<p class="cl1">        self._app.route('/image/&lt;macid&gt;')(self.plot_image)</p>
<p class="cl1">        # static files - CSS, JavaScript</p>
<p class="cl1">        self._app.route('/static/&lt;filename&gt;')(self.st_file)</p>
<p class="cl1">        # main HTML page</p>
<p class="cl1">        self._app.route('/')(self.main_page)</p>
<p class="cl1f">        # start server</p>
<p class="cl1">        self._app.run(host=self._host, port=self._port)</p>
</div>
</section>
<section>
<h2 class="ah" id="ah1610"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1610">The Complete Main Program Code</a></h2>
<p class="paft"><span class="idx" data-level1="complete code" data-term="IoT garden"/>Here’s a listing for the complete main program code in file <i>iotgarden.py</i>.</p>
<div class="codeline">
<p class="clf">"""</p>
<p class="cl">iotgarden.py</p>
<p class="clf"><span aria-label=" Page 352. " class="page" epub:type="pagebreak" id="p352" role="doc-pagebreak"/>Main program for the IoT Garden project. Sets up database, starts the Bottle</p>
<p class="cl">web server, and the BLE scanner.</p>
<p class="clf">Author: Mahesh Venkitachalam</p>
<p class="cl">"""</p>
<p class="clf">import argparse</p>
<p class="cl">import sqlite3</p>
<p class="cl">from BLEScanner import BLEScanner</p>
<p class="cl">from server import IOTGServer</p>
<p class="clf">def print_db(dbname):</p>
<p class="cl">    """prints contents of database"""</p>
<p class="cl">    # connect to database</p>
<p class="cl">    con = sqlite3.connect(dbname)</p>
<p class="cl">    cur = con.cursor()</p>
<p class="cl">    for row in cur.execute("SELECT * FROM iotgarden_data"):</p>
<p class="cl">        print(row)</p>
<p class="clf">def setup_db(dbname):</p>
<p class="cl">    """set up the database"""</p>
<p class="cl">    # connect to database - will create new if needed</p>
<p class="cl">    con = sqlite3.connect(dbname)</p>
<p class="cl">    cur = con.cursor()</p>
<p class="cl">    # drop if table exists</p>
<p class="cl">    cur.execute("DROP TABLE IF EXISTS iotgarden_data")</p>
<p class="cl">    # create table</p>
<p class="cl">    cur.execute("CREATE TABLE iotgarden_data(DEVID TEXT, NAME TEXT,</p>
<p class="cl">                 TS DATETIME, T NUMERIC, H NUMERIC)")</p>
<p class="clf">def main():</p>
<p class="cl">    print("starting iotgarden...")</p>
<p class="clf">    # set up cmd line argument parser</p>
<p class="cl">    parser = argparse.ArgumentParser(description="iotgarden.")</p>
<p class="cl">    # add arguments</p>
<p class="cl">    parser.add_argument('--createdb', action='store_true', required=False)</p>
<p class="cl">    parser.add_argument('--lsdb', action='store_true', required=False)</p>
<p class="cl">    parser.add_argument('--hostname', dest='hostname', required=False)</p>
<p class="cl">    args = parser.parse_args()</p>
<p class="clf">    # set database name</p>
<p class="cl">    dbname = 'iotgarden.db'</p>
<p class="clf">    if (args.createdb):</p>
<p class="cl">        print("Setting up database...")</p>
<p class="cl">        setup_db(dbname)</p>
<p class="cl">        print("done. exiting.")</p>
<p class="cl">        exit(0)</p>
<p class="clf">    if (args.lsdb):</p>
<p class="cl">        print("Listing database contents...")</p>
<p class="cl">        print_db(dbname)</p>
<p class="cl">        print("done. exiting.")</p>
<p class="cl">        exit(0)</p>
<p class="clf"><span aria-label=" Page 353. " class="page" epub:type="pagebreak" id="p353" role="doc-pagebreak"/>    # set hostname</p>
<p class="cl">    hostname = 'iotgarden.local'</p>
<p class="cl">    if (args.hostname):</p>
<p class="cl">        hostname = args.hostname</p>
<p class="clf">    # create BLE scanner</p>
<p class="cl">    bs = BLEScanner(dbname)</p>
<p class="cl">    # start BLE</p>
<p class="cl">    bs.start()</p>
<p class="clf">    # create server</p>
<p class="cl">    server = IOTGServer(dbname, hostname, 8080)</p>
<p class="cl">    # run server</p>
<p class="cl">    server.run()</p>
<p class="clf"># call main</p>
<p class="cl">if __name__ == "__main__":</p>
<p class="cl">    main()</p>
</div>
</section>
</section>
</div></body></html>