- en: concepts of Python and OOP, such as the
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: Python 和面向对象编程（OOP）的概念，例如
- en: lifetime of an object (including deleting an
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的生命周期（包括删除一个
- en: object) and class variables, that didn’t fit well
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对象）和类变量，不太适合
- en: in the earlier chapters in this section. To tie all of this
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的前几章中讨论过。将这一切
- en: together, we’ll build a small game. I’ll also introduce
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一起，我们将构建一个小型游戏。我还将介绍
- en: slots, a memory management technique for objects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽，这是对象的内存管理技术。
- en: This chapter should give you a better understanding
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章应能帮助你更好地理解
- en: of how your code can affect the way that memory is
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码如何影响内存管理的方式
- en: used by objects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 被对象使用。
- en: '**Object Lifetime**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象生命周期**'
- en: I[n Chapter 2, I d](index_split_000.html#p50)efined an object as “Data, plus
    code that acts on that data, over time.” I’ve talked quite a bit about data (instance
    variables) and the
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我定义了一个对象为“数据，加上对数据的操作代码，随着时间推移。”我已经讲了很多关于数据（实例变量）和
- en: code that acts on that data (methods), but I haven’t explained much about
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 操作该数据的代码（方法），但我还没有详细解释过
- en: the time aspect. That will be my focus here.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 时间方面。这将是我在这里关注的重点。
- en: You already know that a program can create an object at any time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道，程序可以随时创建一个对象。
- en: Often, a program will create one or more objects at startup and use those
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序会在启动时创建一个或多个对象，并使用这些
- en: objects throughout its operation. However, in many cases a program will
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对象在其操作过程中不断使用。然而，在许多情况下，程序将
- en: want to create an object when it needs it, but release or remove the object
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序需要时，想要创建一个对象，但在不需要时释放或删除该对象
- en: when it’s done using it to free up the resources that the object uses (mem-
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完毕后释放对象所用资源（内存等）的方法
- en: 'ory, files, network connections, and so on). Here are a few examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 内存、文件、网络连接等资源）。以下是一些示例：
- en: • A “transaction” object that’s used while a customer is making an
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个“交易”对象，在客户进行电子购买时使用
- en: electronic purchase. When the purchase is completed, the object is
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 电子购买。当购买完成时，对象被
- en: destroyed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 被销毁。
- en: • An object to handle communication over the internet that’s released
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个处理互联网通信的对象，在完成后被释放
- en: when the communication is completed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当通信完成时。
- en: • Transient objects in a game. The program could instantiate many cop-
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: • 游戏中的瞬态对象。程序可以实例化许多副本
- en: ies of bad guys, aliens, spaceships, and so on; as the player destroys each
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 恶棍、外星人、宇宙飞船等的系列；当玩家摧毁每一个
- en: one, the program can eliminate the underlying object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦不再使用，程序可以消除底层对象。
- en: The period of time from the instantiation of an object until it is destroyed
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象实例化到销毁之间的时间段
- en: is known as the object’s *lifetime*. To understand the lifetime of an object,
    you first need to know about a related underlying concept having to do with the
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为对象的*生命周期*。要理解对象的生命周期，首先需要了解一个相关的底层概念，涉及
- en: 'implementation of objects in Python (and some other OOP languages): the'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中对象的实现（以及一些其他面向对象语言）：对
- en: reference count.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数。
- en: '***Reference Count***'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '***引用计数***'
- en: There are a number of different implementations of Python. The following
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有多种不同的实现方式。以下是
- en: discussion of reference counts applies to the official version released by the
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数的讨论适用于由
- en: Python Software Foundation—the version downloaded from [*python.org*—](python.org)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python 软件基金会——从[*python.org*](python.org)下载的版本
- en: that’s commonly known as *CPython*. Other implementations of Python may
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常被称为*CPython*。Python 的其他实现可能
- en: use a different approach.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的方法。
- en: Part of the philosophy of Python is that programmers should never
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的哲学之一是程序员永远不应该
- en: have to worry about the details of managing memory. Python takes care of
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你无需担心管理内存的细节。Python 会处理这些
- en: that for you. However, having a basic idea of how Python manages memory
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 如何管理内存的基本了解会对你有帮助
- en: will be helpful in understanding how and when objects are released back to
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于理解对象何时以及如何被释放回
- en: the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 系统。
- en: Whenever a program instantiates an object from a class, Python allo-
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每当程序从类中实例化一个对象时，Python 会允许
- en: cates memory for the storage of the instance variables defined in the class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建内存以存储在类中定义的实例变量。
- en: Each object also contains an extra internal field called a *reference count*,
    which keeps track of how many different variables refer to that object. I
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象还包含一个额外的内部字段，称为*引用计数*，它跟踪有多少不同的变量引用该对象。
- en: show how this works in Listing 11-1\.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 展示这个如何在清单 11-1 中工作\。
- en: '**242** Chapter 11'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**242** 第11章'
- en: '![Image 30](index-272_1.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Image 30](index-272_1.png)'
- en: '**File: ReferenceCount.py**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：ReferenceCount.py**'
- en: Reference count example
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用计数示例
- en: '1 class Square():'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '1 class Square():'
- en: 'def __init__(self, width, color):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, width, color):'
- en: self.width = width
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = width
- en: self.color = color
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: self.color = color
- en: Instantiate an object
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化一个对象
- en: 2 oSquare1 = Square(5, 'red')
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 2 oSquare1 = Square(5, '红色')
- en: print(oSquare1)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: print(oSquare1)
- en: Reference count of the Square object is 1
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Square 对象的引用计数是 1
- en: Now set another variable to the same object
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在设置另一个变量引用相同的对象
- en: 3 oSquare2 = oSquare1
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 3 oSquare2 = oSquare1
- en: print(oSquare2)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: print(oSquare2)
- en: Reference count of the Square object is 2
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Square 对象的引用计数为 2
- en: '*Listing 11-1: A simple Square class for demonstrating reference counting*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-1：一个简单的 Square 类，用于演示引用计数*'
- en: We can use Python Tuto[r ( *http://pythontutor.com/*) t](http://pythontutor.com/)o
    step through our code. We start with a simple Square class 1 containing a few
    instance variables. We then instantiate an object and assign it to the variable
    oSquare1 2\.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python Tutor（*http://pythontutor.com/*）逐步执行代码。我们从一个简单的 Square 类开始，类中包含几个实例变量。然后，我们实例化一个对象并将其赋值给变量
    oSquare1 2\。
- en: 'Figure 11-1 shows what we see after instantiating the first object: as you
    can'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1 显示了我们在实例化第一个对象后的结果：如你所见
- en: see, the variable oSquare1 refers to an instance of the Square class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看，变量 oSquare1 引用的是 Square 类的一个实例。
- en: '*Figure 11-1: A single variable (oSquare1) referring to an object*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：单个变量（oSquare1）引用一个对象*'
- en: Next, we set a second variable to refer to the same Square object 3
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置第二个变量来引用相同的 Square 对象 3
- en: and print the value of the new variable. Note that the statement oSquare2 =
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 并打印新变量的值。请注意，语句 oSquare2 =
- en: oSquare1 does not make a new copy of the Square object! Figure 11-2 shows
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: oSquare1 并不会创建一个新的 Square 对象！图 11-2 显示了
- en: what we see after executing these two lines.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这两行代码后的结果。
- en: Managing Memory Used by Objects **243**
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象使用的内存 **243**
- en: '![Image 31](index-273_1.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片 31](index-273_1.png)'
- en: '*Figure 11-2: Two variables referring to the same object*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：两个变量引用相同的对象*'
- en: The variables oSquare1 and oSquare2 both refer to the same Square object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 oSquare1 和 oSquare2 都引用相同的 Square 对象。
- en: You can also see in the top box that the two calls to print() show the same
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在上面的框中看到，两次调用 print() 显示相同的
- en: memory address. Therefore, the reference count of the object is now 2\. If
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 内存地址。因此，该对象的引用计数现在是 2。如果
- en: 'we were to assign another variable:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们给另一个变量赋值：
- en: 'oSquare3 = oSquare2 # or oSquare1'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'oSquare3 = oSquare2 # 或 oSquare1'
- en: the reference count would be incremented to 3 (because all three variables
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数将增加到 3（因为所有三个变量
- en: would refer to the same object), and so on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 会引用相同的对象，以此类推。
- en: The reference count of an object is important because when it reaches
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的引用计数很重要，因为当它达到
- en: zero, Python marks the relevant memory as no longer in use by the pro-
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用计数降为零时，Python 会将相关内存标记为不再使用。
- en: gram. This is known as being *marked as garbage*. Python has a garbage col-
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 程序。这被称为 *被标记为垃圾*。Python 有一个垃圾回收机制，
- en: lector that runs to reclaim any blocks of memory that have been marked as
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 清理器会运行以回收所有标记为垃圾的内存块。
- en: garbage; I’ll discuss that later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾；稍后我会在本章讨论它。
- en: The Python Standard Library contains the getrefcount() function,
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库包含 getrefcount() 函数，
- en: which returns the number of variables that refer to an object. Here, we use
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值是引用该对象的变量数量。这里我们使用
- en: it to see the reference count after the first instantiation of a Square object
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可以查看首次实例化 Square 对象后的引用计数
- en: 'from the Square class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Square 类的：
- en: oSquare1 = Square(5, 'red')
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: oSquare1 = Square(5, '红色')
- en: print('Reference count is', sys.getrefcount(oSquare1))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: print('引用计数为', sys.getrefcount(oSquare1))
- en: This prints a count of 2\. This may be surprising—you likely expected
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出 2 的计数。这可能让你感到惊讶——你可能预期
- en: that the count would be 1\. However, as the documentation of this func-
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 计数应该是 1。不过，正如该函数文档中所述：
- en: tion explains, “The count returned is generally one higher than you might
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数解释道：“返回的计数通常比你预期的多一个。”
- en: expect, because it includes the (temporary) reference as an argument to
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的，因为它包含了作为参数传递的（临时）引用。
- en: getrefcount().”
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: getrefcount()。”
- en: '**244** Chapter 11'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**244** 第 11 章'
- en: '**Incrementing the Reference Count**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**增加引用计数**'
- en: 'There are a few ways that an object’s reference count is incremented:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以增加一个对象的引用计数：
- en: '1\. When an additional variable is assigned to refer to the same object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 当给另一个变量赋值来引用相同的对象时：
- en: oSquare2 = oSquare1
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: oSquare2 = oSquare1
- en: 2\. When an object is passed into a function and therefore a local param-
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 当一个对象被传递到函数中时，它会作为一个局部参数：
- en: 'eter variable is set to refer to the object:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 参数变量被设置为引用该对象：
- en: 'def myFunctionOrMethod(oLocalSquareParam):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'def myFunctionOrMethod(oLocalSquareParam):'
- en: oLocalSquareParam now refers to wherever the argument refers to
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: oLocalSquareParam 现在引用了参数引用的对象
- en: '*<body of myFunctionOrMethod>*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*<myFunctionOrMethod 函数体>*'
- en: 'myFunctionOrMethod(oSquare1) # call the function and pass in the object'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'myFunctionOrMethod(oSquare1) # 调用函数并传入对象'
- en: '3\. When an object is put into a container such as a list or a dictionary:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 当一个对象被放入容器中，例如列表或字典时：
- en: myList = [oSquare1, someValue, someOtherValue]
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: myList = [oSquare1, someValue, someOtherValue]
- en: If oSquare1 already refers to an object, after executing this line, the list
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 oSquare1 已经引用了一个对象，执行这行代码后，列表
- en: contains an additional reference to the same Square object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 包含对同一个 Square 对象的额外引用。
- en: '**Decrementing the Reference Count**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**递减引用计数**'
- en: Decrementing the reference count also happens in a few ways. To demon-
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数的递减也有几种方式。为了演示
- en: 'strate this, let’s create an object and increment its reference count:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 演示这一点，我们创建一个对象并增加它的引用计数：
- en: oSquare1 = Square(20, BLACK)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: oSquare1 = Square(20, BLACK)
- en: oSquare2 = oSquare1
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: oSquare2 = oSquare1
- en: myList = [oSquare1]
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: myList = [oSquare1]
- en: 'myFunctionOrMethod(oSquare1) # call the function and pass in the object'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'myFunctionOrMethod(oSquare1) # 调用函数并传入对象'
- en: When myFunctionOrMethod() starts, the reference to the object is copied
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当 myFunctionOrMethod() 开始时，引用对象会被复制
- en: into a local parameter variable for use inside the function. The reference
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 进入一个局部参数变量，供函数内部使用。引用
- en: 'count of this Square object is currently 4: two object variables, one copy'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Square 对象的引用计数目前为 4：两个对象变量，一个副本
- en: inside a list, plus a local parameter variable inside the function. This refer-
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，以及函数内的局部参数变量。这个引用
- en: 'ence count can be decremented:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数可以递减：
- en: '1\. When any variable that refers to an object is reassigned. For example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 当任何引用对象的变量被重新赋值时。例如：
- en: oSquare2 = 5
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: oSquare2 = 5
- en: 2\. Whenever a local variable that refers to an object goes out of scope.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 每当一个引用对象的局部变量超出作用域时。
- en: When a variable is created inside of a function or method, the scope of
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量在函数或方法内创建时，它的作用域
- en: that variable is limited to that function or method. When the execution
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该变量的作用域仅限于该函数或方法。当执行
- en: Managing Memory Used by Objects **245**
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象所使用的内存 **245**
- en: of the current function or method ends, that variable literally goes away. In
    this example, when myFunctionOrMethod() ends, the local variable
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当前函数或方法的结束，那个变量会真的消失。在这个例子中，当 myFunctionOrMethod() 结束时，局部变量
- en: that refers to the object is eliminated.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 引用该对象的变量被消除。
- en: 3\. When an object is removed from a container like a list, tuple, or diction-
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 当一个对象从像列表、元组或字典这样的容器中移除时：
- en: 'ary, for example with:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 数组，例如这样：
- en: myList.pop()
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: myList.pop()
- en: Calling the remove() method of a list would also decrement the refer-
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 调用列表的 remove() 方法也会递减引用
- en: ence count.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数。
- en: 4\. When you use the del statement to explicitly delete a variable that refers
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 当你使用 del 语句显式删除引用对象的变量时
- en: to an object. This eliminates the variable and reduces the reference
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 指向对象。这消除了该变量并减少了引用
- en: 'count of the object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象的引用计数：
- en: 'del oSquare3 # delete the variable'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'del oSquare3 # 删除该变量'
- en: 5\. If the reference count of the object’s container (in this case, myList)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 如果对象容器（在这种情况下是 myList）的引用计数
- en: 'goes to zero:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数降为零：
- en: 'del myList # where myList has an element that refers to an object'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'del myList # 当 myList 中的元素引用了一个对象时'
- en: If you have a variable that refers to an object, and you want to keep the
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个引用对象的变量，并且你希望保持
- en: variable but lose the reference to the object, you can execute a statement
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 变量，但失去对对象的引用，你可以执行一个语句
- en: 'like the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 像下面这样：
- en: oSquare1 = None
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: oSquare1 = None
- en: That keeps the variable name, but lowers the reference count of the
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这保持了变量名，但降低了引用计数
- en: object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。
- en: '**Death Notice**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**死亡通知**'
- en: When the reference count of an object goes to zero, Python knows that the
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象的引用计数降到零时，Python 知道该
- en: object can be safely deleted. Right before destroying an object, Python calls
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以安全地被删除。在销毁一个对象之前，Python 会调用
- en: a magic method of that object named __del__() to inform the object of its
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象有一个魔术方法 __del__()，用来通知对象其
- en: impending demise.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 即将到来的终结。
- en: In any class, you can write your own version of the __del__() method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何类中，你都可以写一个自己的 __del__() 方法版本。
- en: In your version, you can include any code you want your object to execute
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的版本中，你可以包含任何你希望对象执行的代码
- en: (ha! interesting word choice here) before the object disappears forever. For
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: （哈哈！这个词选择挺有意思的）在对象永远消失之前。为了
- en: example, your object may want to close a file, close a network connection,
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你的对象可能需要关闭文件，关闭网络连接，
- en: and so on.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: When an object is deleted, Python checks to see if any of its instance
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被删除时，Python会检查它的实例变量
- en: variables refer to other objects. If so, the reference counts of those objects
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 变量引用其他对象。如果是这样，这些对象的引用计数
- en: are also decremented. If this results in another object’s reference count
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 也会减少引用计数。如果这导致另一个对象的引用计数
- en: going to zero, then that object is deleted as well. This type of chained or
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当计数为零时，该对象也会被删除。此类型的链式或
- en: '*cascading* deletion can go on as many layers deep as is necessary. Listing
    11-2'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*级联*删除可以深入多层，直到需要为止。示例11-2'
- en: provides an example.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个示例。
- en: '**246** Chapter 11'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**第246页** 第11章'
- en: '**File: DeleteExample_Teacher_Student.py**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：DeleteExample_Teacher_Student.py**'
- en: Student class
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学生类
- en: 'class Student():'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'class 学生():'
- en: 'def __init__(self, name):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name):'
- en: self.name = name
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: print('Creating Student object', self.name)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: print('创建学生对象', self.name)
- en: '1 def __del__(self):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '1 def __del__(self):'
- en: print('In the __del__ method for student:', self.name)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: print('在学生的__del__方法中:', self.name)
- en: Teacher class
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教师类
- en: 'class Teacher():'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'class 教师():'
- en: 'def __init__(self):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: print('Creating the Teacher object')
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在创建教师对象')
- en: 2 self.oStudent1 = Student('Joe')
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 2 self.oStudent1 = 学生('Joe')
- en: self.oStudent2 = Student('Sue')
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: self.oStudent2 = 学生('Sue')
- en: self.oStudent3 = Student('Chris')
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: self.oStudent3 = 学生('Chris')
- en: '3 def __del__(self):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '3 def __del__(self):'
- en: print('In the __del__ method for Teacher')
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: print('在教师的__del__方法中')
- en: Instantiate the Teacher object (that creates Student objects)
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化教师对象（创建学生对象）
- en: 4 oTeacher = Teacher()
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 4 oTeacher = 教师()
- en: Delete the Teacher object
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除教师对象
- en: 5 del oTeacher
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 5 del oTeacher
- en: '*Listing 11-2: Classes demonstrating __del__() methods*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例11-2：展示__del__()方法的类*'
- en: Here we have two classes, Student and Teacher. The main code instanti-
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有两个类，学生和教师。主要代码实例化—
- en: ates one Teacher object 4, and its __init__() method creates three instances
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个教师对象4，其__init__()方法创建了三个实例
- en: of the Student class 2, one each for Joe, Sue, and Chris. Therefore, after
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 学生类2中的对象，每个分别是Joe、Sue和Chris。因此，在
- en: starting up, the Teacher object has three instance variables that are Student
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时，教师对象有三个实例变量，它们是学生
- en: 'objects. The output from the first part is:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。第一部分的输出为：
- en: Creating the Teacher object
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建教师对象
- en: Creating Student object Joe
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建学生对象 Joe
- en: Creating Student object Sue
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建学生对象 Sue
- en: Creating Student object Chris
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正在创建学生对象 Chris
- en: Next, the main code uses the del statement to delete the Teacher
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，主要代码使用del语句删除教师
- en: object 5\. Since we wrote a __del__() method in the Teacher class 3, that
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对象5。由于我们在教师类3中编写了__del__()方法，
- en: method of the Teacher *object* is called—which, for demonstration purposes,
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 教师*对象*的__del__()方法被调用——为了演示目的，
- en: only prints a message.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 仅打印一条消息。
- en: When the Teacher object is deleted, Python sees that it contains three
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当教师对象被删除时，Python会看到它包含三个
- en: other objects (the three Student objects). So, Python lowers the reference
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 其他对象（这三个学生对象）。因此，Python降低了引用
- en: count of each of those objects from 1 to 0\.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些对象的计数从1递减到0\。
- en: Once this happens, the __del__() method of the Student objects is
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生这种情况，学生对象的__del__()方法就会被调用。
- en: called 1, and each outputs a message. The memory used by all three of
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用1，并且每个输出一条消息。所有三个对象使用的内存：
- en: Managing Memory Used by Objects **247**
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象使用的内存 **247**
- en: 'the Student objects is then marked as garbage. The output from the end of the
    program is:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，学生对象会被标记为垃圾。程序结束时的输出是：
- en: In the __del__ method for Teacher
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在教师的__del__方法中
- en: 'In the __del__ method for student: Joe'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在学生的__del__方法中：Joe
- en: 'In the __del__ method for student: Sue'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在学生的__del__方法中：Sue
- en: 'In the __del__ method for student: Chris'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在学生的__del__方法中：Chris
- en: Because Python keeps track of reference counts for all objects, you
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python会跟踪所有对象的引用计数，你
- en: rarely, if ever, have to worry about memory management in Python and
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你几乎不需要担心内存管理
- en: rarely need to include a __del__() method. However, you might consider
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常不需要包括__del__()方法。然而，你可能会考虑
- en: using a del statement to explicitly tell Python to delete objects that use
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用del语句显式告诉Python删除使用该语句的对象。
- en: a very large amount of memory when you are no longer using them. For
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不再使用它们，可能会占用大量内存。对于
- en: example, you might want to delete an object that loads a large number of
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能想删除一个加载大量记录的对象，
- en: records from a database, or loads many images, when you are done using it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中加载记录，或者加载许多图像，当你不再使用它时。
- en: Also, it is not guaranteed that Python will call the __del__() method when
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python 不保证在调用 __del__() 方法时
- en: a program exits, so you should avoid putting any program-ending critical
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 程序退出时，你应该避免放置任何会影响程序结束的关键
- en: code in this method.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在这个方法中。
- en: '***Garbage Collection***'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '***垃圾回收***'
- en: When an object is deleted, either through the reference count going to zero
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象被删除时，要么是引用计数归零
- en: or though the explicit use of a del statement, as the programmer you should
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过显式使用 del 语句，作为程序员你应该
- en: consider the object inaccessible.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑该对象不可访问。
- en: However, the specific implementation of the garbage collector is com-
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，垃圾回收器的具体实现是复杂的
- en: pletely up to Python. The details of the algorithm that decides when the
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 完全由 Python 决定。决定何时进行垃圾回收的算法细节
- en: actual garbage collection code runs are not important to you as the pro-
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的垃圾回收代码是否运行对你作为程序员并不重要
- en: grammer. It may run when your program instantiates an object and Python
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，它可能在你的程序实例化对象时运行，而 Python
- en: needs to allocate memory, or at random times, or at certain scheduled
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 需要分配内存，或者在随机时间，或者在某些计划的时刻
- en: times. The algorithm may change from one release of Python to another.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 算法可能会从一个版本的 Python 变动到另一个版本。
- en: Whichever it is, Python will take care of garbage collection, and you needn’t
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是哪种情况，Python 会处理垃圾回收，你不需要
- en: worry about the specifics.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心具体细节。
- en: '**Class Variables**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**类变量**'
- en: I have talked extensively about how instance variables are defined in a class
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经广泛讲解了如何在类中定义实例变量
- en: and how each object instantiated from a class gets its own set of all the
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 并且每个从类实例化的对象都有自己的一组所有
- en: instance variables. The prefix self. is used to identify each instance vari-
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量。前缀 self. 用于标识每个实例变量。
- en: able. However, you can also create *class variables* at the class level.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 可用。然而，你也可以在类级别创建*类变量*。
- en: '**class variable**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**类变量**'
- en: A variable that is defined in and owned by a class . Only one of each class
    variable exists, independent of how many instances of that class are created .
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由类定义和拥有的变量。每个类变量只有一个，无论创建多少个该类的实例。
- en: You create a class variable with an assignment statement, which by conven-
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过赋值语句创建类变量，这在约定上
- en: 'tion is placed between the class statement and the first def statement, like
    so:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分代码放在类声明和第一个def语句之间，如下所示：
- en: 'class MyDemoClass():'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MyDemoClass():'
- en: 'myClassVariable = 0 # create a class variable and assign 0 to it'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'myClassVariable = 0 # 创建一个类变量并将其赋值为 0'
- en: '**248** Chapter 11'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**248** 第11章'
- en: 'def __init__(self, *<otherParameters>* ):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, *<otherParameters>* ):'
- en: More code here
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这里是更多的代码
- en: Because this class variable is owned by the class, in methods of the class
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个类变量是由类拥有的，在类的方法中
- en: you would refer to it as MyDemoClass.myClassVariable. Every object instantiated
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你将其称为 MyDemoClass.myClassVariable。每个实例化的对象
- en: from a class has access to all class variables defined in the class.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从类中获取对象可以访问该类中定义的所有类变量。
- en: 'There are two typical uses for class variables: defining a constant and'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量有两个典型的用途：定义常量和
- en: creating a counter.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个计数器。
- en: '***Class Variable Constants***'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '***类变量常量***'
- en: 'You can create a class variable to be used as a constant, like so:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个类变量作为常量，像这样：
- en: 'class MyClass():'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'class MyClass():'
- en: 'DEGREES_IN_CIRCLE = 360 # creating a class variable constant'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'DEGREES_IN_CIRCLE = 360 # 创建一个类变量常量'
- en: To access this constant in methods of the class, you would write
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要在类的方法中访问这个常量，你应该写
- en: MyClass.DEGREES_IN_CIRCLE.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: MyClass.DEGREES_IN_CIRCLE。
- en: As a reminder, Python does not actually have constants. Instead, there
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，Python 实际上没有常量。相反，那里
- en: is a convention among Python programmers that any variable whose name
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 程序员中有一个约定：任何变量的名称
- en: consists of all uppercase letters, with words separated by underscores, is
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由所有大写字母组成，单词之间用下划线分隔，是一种
- en: meant to be treated as a constant. That is, this type of variable should
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着应该将其视为常量。也就是说，这种类型的变量应该
- en: never be reassigned.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不应重新赋值。
- en: We can also use class variable constants to save on resources (memory
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用类变量常量来节省资源（内存
- en: and time). Imagine we’re writing a game where we create many instances
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 而且是时间问题）。假设我们正在编写一个游戏，我们创建了很多实例
- en: of a SpaceShip class. We create a picture of a spaceship and place the file
    in
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个 SpaceShip 类的实例。我们创建了一张飞船的图片并将文件放在
- en: a folder named *images*. Before considering class variables, the __init__()
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为*images*的文件夹。在考虑类变量之前，__init__()
- en: method of our SpaceShip class would start by instantiating an Image object
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 SpaceShip 类的方法会从实例化一个 Image 对象开始
- en: 'like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: 'class SpaceShip():'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SpaceShip():'
- en: 'def __init__(self, window, ...):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, ...):'
- en: self.image = pygwidgets.Image(window, (0, 0),
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: self.image = pygwidgets.Image(window, (0, 0),
- en: '''images/ship.png'')'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/ship.png'')'
- en: This technique works fine. However, coding it this way means that not
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技术工作得很好。然而，以这种方式编码意味着不是
- en: only does every object instantiated from the SpaceShip class have to take the
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 每个从 SpaceShip 类实例化的对象都必须共享
- en: time to load the image, but each object takes up all the memory needed to
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 加载图像的时间，但每个对象占用所有所需的内存
- en: represent a copy of the same image. Instead, we can have the class load the
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 表示相同图像的副本。相反，我们可以让类加载图像
- en: image once, and each SpaceShip object then uses the single image kept in
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图像一次加载，然后每个 SpaceShip 对象使用该图像
- en: 'the class, like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 类中，如下所示：
- en: 'class SpaceShip():'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SpaceShip():'
- en: SPACE_SHIP_IMAGE = pygame.image.load('images/ship.png')
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: SPACE_SHIP_IMAGE = pygame.image.load('images/ship.png')
- en: 'def __init__(self, window, ...):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, ...):'
- en: self.image = pygwidgets.Image(window, (0, 0),
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: self.image = pygwidgets.Image(window, (0, 0),
- en: SpaceShip.SPACE_SHIP_IMAGE)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: SpaceShip.SPACE_SHIP_IMAGE)
- en: An Image object (in pygwidgets, as used here) can use either a path
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图像对象（在 pygwidgets 中，如此处所用）可以使用一个路径
- en: to an image or an already loaded image. Allowing the class to load
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 指向图像或已加载的图像。允许类加载
- en: Managing Memory Used by Objects **249**
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象使用的内存 **249**
- en: the image only *once* makes startup faster and results in lower memory usage.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图像仅加载 *一次* 可以加速启动，并减少内存使用。
- en: '***Class Variables for Counting***'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '***用于计数的类变量***'
- en: A second way to use a class variable is to keep track of how many objects
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类变量的第二种方式是跟踪已实例化的对象数量
- en: have been instantiated from a class. Listing 11-3 shows an example.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 已从类实例化的对象数。列出 11-3 显示了一个示例。
- en: '**File: ClassVariable.py**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：ClassVariable.py**'
- en: Sample class
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sample 类
- en: 'class Sample():'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Sample():'
- en: '1 nObjects = 0 # this is a class variable of the Sample class'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '1 nObjects = 0 # 这是 Sample 类的一个类变量'
- en: 'def __init__(self, name):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name):'
- en: self.name = name
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: 2 Sample.nObjects = Sample.nObjects + 1
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 2 Sample.nObjects = Sample.nObjects + 1
- en: 'def howManyObjects(self):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'def howManyObjects(self):'
- en: 3 print('There are', Sample.nObjects, 'Sample objects')
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 3 print('There are', Sample.nObjects, 'Sample objects')
- en: 'def __del__(self):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __del__(self):'
- en: 4 Sample.nObjects = Sample.nObjects - 1
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 4 Sample.nObjects = Sample.nObjects - 1
- en: Instantiate 4 objects
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化 4 个对象
- en: oSample1 = Sample('A')
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: oSample1 = Sample('A')
- en: oSample2 = Sample('B')
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: oSample2 = Sample('B')
- en: oSample3 = Sample('C')
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: oSample3 = Sample('C')
- en: oSample4 = Sample('D')
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: oSample4 = Sample('D')
- en: Delete 1 object
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除 1 个对象
- en: del oSample3
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: del oSample3
- en: See how many we have
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 看看我们有多少个
- en: oSample1.howManyObjects()
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: oSample1.howManyObjects()
- en: '*Listing 11-3: Using a class variable for counting objects instantiated from
    a class* In the Sample class, nObjects is a class variable because it is defined'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 11-3：使用类变量来计算从类实例化的对象数* 在 Sample 类中，nObjects 是一个类变量，因为它被定义'
- en: in the class scope, typically between the class statement and the first def
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在类作用域内，通常位于类声明与第一个 def 之间
- en: statement 1\. It is used to count the number of Sample objects that exist
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 语句 1。它用于计算现存的 Sample 对象的数量
- en: and is initialized to zero. All methods refer to this variable using the
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 并且初始化为零。所有方法都通过该变量来引用
- en: name Sample.nObjects. Whenever a Sample object is instantiated, the count
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 Sample.nObjects。每当一个 Sample 对象被实例化时，计数
- en: is incremented 2\. When one is deleted, the count is decremented 4\.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 计数增加 2。当一个被删除时，计数减少 4。
- en: The howManyObjects() method reports the current count 3\.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: howManyObjects() 方法报告当前计数 3。
- en: The main code creates four objects, then deletes one. When run, this
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 主要代码创建了四个对象，然后删除了一个。运行时，这个
- en: 'program outputs:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出：
- en: There are 3 Sample objects
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 有 3 个 Sample 对象
- en: '**250** Chapter 11'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**250** 第 11 章'
- en: '![Image 32](index-280_1.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图像 32](index-280_1.png)'
- en: '**Putting It All Together: Balloon Sample Program**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**将一切整合在一起：气球示例程序**'
- en: In this section, we’ll take a number of different concepts we’ve covered and
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将结合我们覆盖的多个概念
- en: put them all together in a relatively simple game—at least, simple from the
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们组合在一起，形成一个相对简单的游戏——至少，从
- en: user’s point of view. The game will present some number of balloons in
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的视角。游戏会展示一些气球
- en: three sizes that move upward in the window. The goal for the user is to pop
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 三种大小的气球会向上移动。用户的目标是打破
- en: as many balloons as possible before they float off the top of the window.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能多地弹爆气球，直到它们浮到窗口的顶部。
- en: Small balloons are worth 30 points, medium balloons are worth 20 points,
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 小气球值 30 分，中等气球值 20 分，
- en: and large balloons are worth 10 points.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 大气球值 10 分。
- en: The game could be extended to include many levels with faster-moving
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏可以扩展，加入更多的关卡和更快移动的气球。
- en: balloons, but for now, there is only a single level. The size and location
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 气球有多个，但目前只有一个关卡。大小和位置
- en: of each balloon is chosen at random. Before each round, a Start button
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 每个气球的类型是随机选择的。在每一轮开始之前，会有一个开始按钮。
- en: becomes available that allows the user to play again. Figure 11-3 is a screen-
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家完成当前回合，系统会允许用户再次玩。图 11-3 是游戏运行中的截图。
- en: shot of the game in action.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏运行中的一张截图。
- en: '*Figure 11-3: A screenshot of the Bal oon game*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：气球游戏截图*'
- en: Managing Memory Used by Objects **251**
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象使用的内存 **251**
- en: '![Image 33](index-281_1.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片 33](index-281_1.png)'
- en: Figure 11-4 shows the project folder for the game.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4 显示了游戏的项目文件夹。
- en: '*Figure 11-4: The Bal oon game project folder*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4：气球游戏项目文件夹*'
- en: 'The game is implemented with four Python source files:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 该游戏由四个 Python 源文件实现：
- en: '***Main_BalloonGame.py***Main code, runs the main loop'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '***Main_BalloonGame.py*** 主代码，运行主循环'
- en: '***BalloonMgr.py***Contains the BalloonMgr class that handles all Balloon objects'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '***BalloonMgr.py*** 包含了处理所有气球对象的 BalloonMgr 类'
- en: '***Balloon.py***Contains the Balloon class and BalloonSmall, BalloonMedium,
    and BalloonLarge subclasses'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '***Balloon.py*** 包含了 Balloon 类以及 BalloonSmall、BalloonMedium 和 BalloonLarge
    子类'
- en: '***BalloonConstants.py***Contains constants used by more than one file Figure
    11-5 shows an object diagram of the implementation.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '***BalloonConstants.py*** 包含多个文件使用的常量 图 11-5 显示了该实现的对象图。'
- en: Main code
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 主代码
- en: BalloonMgr
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 气球管理器
- en: Balloon
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 气球
- en: Balloon
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 气球
- en: Balloon
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 气球
- en: …
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: Balloon
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 气球
- en: '*Figure 11-5: An object diagram of the Bal oon game*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：气球游戏的对象图*'
- en: The main code (found in *Main_BalloonGame.py*) instantiates a single
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 主要代码（位于 *Main_BalloonGame.py*）实例化一个单独的
- en: balloon manager (oBalloonMgr) object from the BalloonMgr class. The balloon
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 气球管理器（oBalloonMgr）对象来自 BalloonMgr 类。气球
- en: '**252** Chapter 11'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**252** 第 11 章'
- en: manager then instantiates a number of balloons, each chosen randomly from the
    BalloonSmall, BalloonMedium, and BalloonLarge classes, and keeps this
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然后气球管理器实例化若干气球，每个气球从 BalloonSmall、BalloonMedium 和 BalloonLarge 类中随机选择，并保持这个
- en: list of objects in an instance variable. Each Balloon object sets its own speed,
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量中的对象列表。每个气球对象设置自己的速度，
- en: point value, and random starting position off the bottom of the window.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 每个气球的点数和从窗口底部随机起始位置。
- en: Given this structure, the main code is responsible for presenting the over-
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这种结构，主代码负责呈现总数。
- en: all user interface. It only communicates with the oBalloonMgr. The oBalloonMgr
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用户界面。它只与 oBalloonMgr 进行通信。oBalloonMgr
- en: talks to all the Balloon objects. Therefore, the main code doesn’t even know
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有气球对象交互。因此，主代码甚至不知道
- en: that the Balloon objects exist. It relies on the balloon manager to take care
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使气球对象存在。它依赖于气球管理器来处理
- en: of them. Let’s walk through the different parts of the program and see how
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起走一遍程序的不同部分，看看它们是如何工作的。
- en: each piece works.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 每一部分是如何工作的。
- en: '***Module of Constants***'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '***常量模块***'
- en: This organization introduces a new technique for working with multiple
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组织结构引入了一个新技术，用于处理多个模块之间的交互。
- en: Python files, each of which is commonly referred to as a *module*. If you find
    yourself in a situation where multiple Python modules require access to
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Python 文件，每个通常称为 *模块*。如果你发现自己处于多个 Python 模块需要访问
- en: the same constants, a good solution is to create a module of constants and
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免多个文件中都包含相同的常量，一个好的解决方案是创建一个常量模块。
- en: import that module into all modules that use the constants. Listing 11-4
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 导入该模块到所有使用这些常量的模块中。列表 11-4
- en: shows some constants defined in *BalloonConstants.py*.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了一些在 *BalloonConstants.py* 中定义的常量。
- en: '**File: BalloonGame/BalloonConstants.py**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：BalloonGame/BalloonConstants.py**'
- en: Constants used by more than one Python module
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个 Python 模块共享的常量
- en: 'N_BALLOONS = 15 # number of balloons in a round of the game'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 'N_BALLOONS = 15 # 一轮游戏中的气球数量'
- en: 'BALLOON_MISSED = ''Missed'' # balloon went off the top'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 'BALLOON_MISSED = ''错过'' # 气球飞出了顶部'
- en: 'BALLOON_MOVING = ''Balloon Moving'' # balloon is moving'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 'BALLOON_MOVING = ''气球移动中'' # 气球正在移动'
- en: '*Listing 11-4: A module of constants that’s imported by other modules*'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-4：一个被其他模块导入的常量模块*'
- en: This is just a simple Python file that contains constants shared by more
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的 Python 文件，包含了多个 Python 文件共享的常量。
- en: than one module. The main code needs to know how many balloons there
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 比一个模块更多。主代码需要知道有多少个气球。
- en: are in order to display that number. The balloon manager needs to know
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 是为了显示该数字。气球管理器需要知道
- en: the number so it can instantiate the correct number of Balloon objects.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 数字，以便可以实例化正确数量的气球对象。
- en: This approach makes it extremely simple to modify the number of Balloon
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使得修改气球数量变得非常简单
- en: objects. If we added levels with different numbers of balloons, we could
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。如果我们增加不同气球数量的关卡，我们可以
- en: build a list or a dictionary in this file alone, and all other files would have
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 只在这个文件中构建一个列表或字典，其他所有文件都会
- en: access to that information.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 获取这些信息。
- en: The other two constants are used in each Balloon object as status indica-
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个常量在每个气球对象中作为状态指示符使用。
- en: tors as the balloon moves up the window. When I get to the discussion of
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: tors随着气球向上移动窗口。我在讨论
- en: the game play, you’ll see that the balloon manager (oBalloonMgr) asks each
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏过程中，你会看到气球管理器（oBalloonMgr）向每个
- en: Balloon object for its status, and each responds with one of these two con-
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 气球对象的状态，每个都以这两种方式之一做出响应——
- en: stants. Placing shared constants in a module and importing that module
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 常量。将共享常量放在模块中，并导入该模块
- en: in modules that use the constants is a simple and effective technique for
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用常量的模块中，这是一个简单且有效的技巧
- en: ensuring that different parts of a program use consistent values. This is a
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 确保程序的不同部分使用一致的值。这是一个
- en: good example of applying the Don’t Repeat Yourself (DRY) principle by
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 是应用“不要重复自己”（DRY）原则的一个好例子
- en: only defining values in a single place.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 只在一个地方定义值。
- en: Managing Memory Used by Objects **253**
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象占用的内存 **253**
- en: '***Main Program Code***'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '***主程序代码***'
- en: The main code of our sample program, shown in Listing 11-5, follows the
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例程序的主代码，如第11-5行所示，遵循了
- en: 12-step template I’ve used throughout this book. It shows the user’s score,
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书中使用的12步模板。它显示了用户的分数，
- en: the game status, and a Start button at the bottom of the window, and it
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏状态，并在窗口底部有一个开始按钮，它
- en: reacts to the user clicking the Start button.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 对用户点击开始按钮的响应。
- en: '**File: BalloonGame/Main_BalloonGame.py**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：BalloonGame/Main_BalloonGame.py**'
- en: Balloon game main code
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 气球游戏主代码
- en: 1 - Import packages
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: from pygame.locals import *
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import pygwidgets
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: import sys
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import pygame
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from BalloonMgr import *
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: from BalloonMgr import *
- en: 2 - Define constants
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 - 定义常量
- en: BLACK = (0, 0, 0)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: GRAY = (200, 200, 200)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: GRAY = (200, 200, 200)
- en: BACKGROUND_COLOR = (0, 180, 180)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: BACKGROUND_COLOR = (0, 180, 180)
- en: WINDOW_WIDTH = 640
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 640
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 640
- en: PANEL_HEIGHT = 60
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: PANEL_HEIGHT = 60
- en: USABLE_WINDOW_HEIGHT = WINDOW_HEIGHT - PANEL_HEIGHT
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: USABLE_WINDOW_HEIGHT = WINDOW_HEIGHT - PANEL_HEIGHT
- en: FRAMES_PER_SECOND = 30
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: 3 - Initialize the world
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等
- en: oScoreDisplay = pygwidgets.DisplayText(window, (10, USABLE_WINDOW_HEIGHT + 25),
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: oScoreDisplay = pygwidgets.DisplayText(window, (10, USABLE_WINDOW_HEIGHT + 25),
- en: '''Score: 0'', textColor=BLACK,'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '''得分: 0'', textColor=BLACK,'
- en: backgroundColor=None, width=140, fontSize=24)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: backgroundColor=None, width=140, fontSize=24)
- en: oStatusDisplay = pygwidgets.DisplayText(window, (180, USABLE_WINDOW_HEIGHT +
    25),
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: oStatusDisplay = pygwidgets.DisplayText(window, (180, USABLE_WINDOW_HEIGHT +
    25),
- en: ''''', textColor=BLACK, backgroundColor=None,'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ''''', textColor=BLACK, backgroundColor=None,'
- en: width=300, fontSize=24)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: width=300, fontSize=24)
- en: oStartButton = pygwidgets.TextButton(window,
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: oStartButton = pygwidgets.TextButton(window,
- en: (WINDOW_WIDTH - 110, USABLE_WINDOW_HEIGHT + 10),
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: (WINDOW_WIDTH - 110, USABLE_WINDOW_HEIGHT + 10),
- en: '''Start'')'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '''开始'')'
- en: 5 - Initialize variables
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: oBalloonMgr = BalloonMgr(window, WINDOW_WIDTH, USABLE_WINDOW_HEIGHT)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: oBalloonMgr = BalloonMgr(window, WINDOW_WIDTH, USABLE_WINDOW_HEIGHT)
- en: 'playing = False 1 # wait until user clicks Start'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 'playing = False 1 # 等待用户点击开始'
- en: 6 - Loop forever
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 无限循环
- en: 'while True:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: nPointsEarned = 0
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: nPointsEarned = 0
- en: 'for event in pygame.event.get():'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: '**254** Chapter 11'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**254** 第11章'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'if playing: 2'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 'if playing: 2'
- en: oBalloonMgr.handleEvent(event)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: oBalloonMgr.handleEvent(event)
- en: theScore = oBalloonMgr.getScore()
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: theScore = oBalloonMgr.getScore()
- en: 'oScoreDisplay.setValue(''Score: '' + str(theScore))'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 'oScoreDisplay.setValue(''得分: '' + str(theScore))'
- en: 'elif oStartButton.handleEvent(event): 3'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif oStartButton.handleEvent(event): 3'
- en: oBalloonMgr.start()
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: oBalloonMgr.start()
- en: 'oScoreDisplay.setValue(''Score: 0'')'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 'oScoreDisplay.setValue(''得分: 0'')'
- en: playing = True
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: playing = True
- en: oStartButton.disable()
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: oStartButton.disable()
- en: 8 - Do any "per frame" actions
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”操作
- en: 'if playing: 4'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 'if playing: 4'
- en: oBalloonMgr.update()
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: oBalloonMgr.update()
- en: nPopped = oBalloonMgr.getCountPopped()
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: nPopped = oBalloonMgr.getCountPopped()
- en: nMissed = oBalloonMgr.getCountMissed()
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: nMissed = oBalloonMgr.getCountMissed()
- en: 'oStatusDisplay.setValue(''Popped: '' + str(nPopped) +'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 'oStatusDisplay.setValue(''已爆炸: '' + str(nPopped) +'
- en: ''' Missed: '' + str(nMissed) +'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: ''' 弹破气球数: '' + str(nMissed) +'
- en: ''' Out of: '' + str(N_BALLOONS))'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: ''' 剩余气球数: '' + str(N_BALLOONS))'
- en: 'if (nPopped + nMissed) == N_BALLOONS: 5'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 (nPopped + nMissed) == N_BALLOONS: 5'
- en: playing = False
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: playing = False
- en: oStartButton.enable()
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: oStartButton.enable()
- en: 9 - Clear the window
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清空窗口
- en: window.fill(BACKGROUND_COLOR)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BACKGROUND_COLOR)
- en: 10 - Draw all window elements
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: 'if playing: 6'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 playing: 6'
- en: oBalloonMgr.draw()
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: oBalloonMgr.draw()
- en: pygame.draw.rect(window, GRAY, pygame.Rect(0,
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.rect(window, GRAY, pygame.Rect(0,
- en: USABLE_WINDOW_HEIGHT, WINDOW_WIDTH, PANEL_HEIGHT))
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: USABLE_WINDOW_HEIGHT, WINDOW_WIDTH, PANEL_HEIGHT))
- en: oScoreDisplay.draw()
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: oScoreDisplay.draw()
- en: oStatusDisplay.draw()
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: oStatusDisplay.draw()
- en: oStartButton.draw()
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: oStartButton.draw()
- en: 11 - Update the window
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢速度
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 'clock.tick(FRAMES_PER_SECOND) # 使 pygame 等待'
- en: '*Listing 11-5: The Bal oon game’s main code*'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 11-5: 气球游戏的主代码*'
- en: The code is based on a single Boolean variable, playing, set to False by
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 代码基于一个布尔变量 playing，初始值为 False
- en: default to let the user begin the game by pressing Start 1\.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 默认让用户按下开始按钮来开始游戏 1\。
- en: When playing is True, the main code calls the handleEvent() method 2
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当 playing 为 True 时，主代码调用 handleEvent() 方法 2
- en: of the balloon manager, oBalloonMgr, to handle all events. We call the bal-
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在气球管理器的 oBalloonMgr 中处理所有事件。我们调用气球管理器
- en: loon manager’s getScore() method to get the score, and we update the score
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 使用气球管理器的 getScore() 方法获取分数，并更新分数
- en: field’s text.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 字段的文本。
- en: Managing Memory Used by Objects **255**
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象使用的内存 **255**
- en: When the game is over, the program waits for the user to press the Start button
    3\. When the button is clicked, the balloon manager is told to start
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏结束时，程序等待用户按下开始按钮 3\. 按下按钮时，气球管理器开始工作
- en: the game, and the user interface is updated.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束时，用户界面会更新。
- en: In every frame, if the game is running, we send the update() message
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧，如果游戏正在运行，我们发送 update() 消息
- en: to the balloon manager 4, triggering it to pass on the update() message to
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 向气球管理器发送更新消息 4，触发它将 update() 消息传递给
- en: all balloons. Then we ask the balloon manager for the numbers of balloons
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 所有气球。然后我们询问气球管理器气球的数量
- en: remaining and balloons popped. We use that information to update the
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余气球和已弹破的气球。我们使用这些信息来更新
- en: user interface.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面。
- en: When the user pops all balloons or the last balloon floats off the top
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户弹破所有气球或最后一个气球漂浮到顶部时
- en: of the window, we set the playing variable to False and enable the Start
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口关闭时，我们将 playing 变量设置为 False，并启用开始按钮
- en: button 5\.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮 5\。
- en: The drawing code is very straightforward 6\. We tell the balloon man-
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制代码非常简单 6\. 我们告诉气球管理器
- en: ager to draw, which triggers all the balloons to draw themselves. Then we
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 使气球绘制，触发所有气球自行绘制。然后我们
- en: draw the bottom bar with its status data and the Start button.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制底部栏，显示状态数据和开始按钮。
- en: '***Bal oon Manager***'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '***气球管理器***'
- en: The balloon manager is responsible for keeping track of all balloons,
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '气球管理器负责跟踪所有气球， '
- en: including creating the Balloon objects, telling each one to draw itself, tell-
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '包括创建 Balloon 对象，告诉每个对象绘制自己，告诉每个对象移动， '
- en: ing each to move, and keeping track of how many were popped and missed.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 并使每个气球移动，跟踪弹破和错过的数量。
- en: Listing 11-6 contains the code of the BalloonMgr class.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 11-6 包含了 BalloonMgr 类的代码。
- en: '**File: BalloonGame/BalloonMgr.py**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：BalloonGame/BalloonMgr.py**'
- en: BalloonMgr class
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BalloonMgr 类
- en: import pygame
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: import random
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: from pygame.locals import *
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 从 pygame.locals 导入 *
- en: import pygwidgets
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: from BalloonConstants import *
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 从 BalloonConstants 导入 *
- en: from Balloon import *
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Balloon 导入 *
- en: BalloonMgr manages a list of Balloon objects
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 气球管理器管理一个气球对象列表
- en: 'class BalloonMgr():'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 'class BalloonMgr():'
- en: '1 def __init__(self, window, maxWidth, maxHeight):'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '1 def __init__(self, window, maxWidth, maxHeight):'
- en: self.window = window
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.maxWidth = maxWidth
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: self.maxWidth = maxWidth
- en: self.maxHeight = maxHeight
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: self.maxHeight = maxHeight
- en: '2 def start(self):'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def start(self):'
- en: self.balloonList = []
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: self.balloonList = []
- en: self.nPopped = 0
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: self.nPopped = 0
- en: self.nMissed = 0
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: self.nMissed = 0
- en: '3 for balloonNum in range(0, N_BALLOONS):'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 3 对于 balloonNum 在 0 到 N_BALLOONS 范围内：
- en: randomBalloonClass = random.choice((BalloonSmall,
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: randomBalloonClass = random.choice((BalloonSmall,
- en: BalloonMedium,
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: BalloonMedium,
- en: BalloonLarge))
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: BalloonLarge))
- en: oBalloon = randomBalloonClass(self.window, self.maxWidth,
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: oBalloon = randomBalloonClass(self.window, self.maxWidth,
- en: self.maxHeight, balloonNum)
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: self.maxHeight, balloonNum)
- en: '**256** Chapter 11'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '**256** 第11章'
- en: self.balloonList.append(oBalloon)
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: self.balloonList.append(oBalloon)
- en: 'def handleEvent(self, event):'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 'def handleEvent(self, event):'
- en: '4 if event.type == MOUSEBUTTONDOWN:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 4 如果 event.type == MOUSEBUTTONDOWN：
- en: Go 'reversed' so topmost balloon gets popped
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以“反向”方式进行，这样最上面的气球会先被弹破
- en: 'for oBalloon in reversed(self.balloonList):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 'for oBalloon in reversed(self.balloonList):'
- en: wasHit, nPoints = oBalloon.clickedInside(event.pos)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: wasHit, nPoints = oBalloon.clickedInside(event.pos)
- en: 'if wasHit:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '如果wasHit:'
- en: 'if nPoints > 0: # remove this balloon'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '如果nPoints > 0: # 移除这个气球'
- en: self.balloonList.remove(oBalloon)
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: self.balloonList.remove(oBalloon)
- en: self.nPopped = self.nPopped + 1
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: self.nPopped = self.nPopped + 1
- en: self.score = self.score + nPoints
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: self.score = self.score + nPoints
- en: 'return # no need to check others'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 'return # 无需检查其他内容'
- en: '5 def update(self):'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '5 def update(self):'
- en: 'for oBalloon in self.balloonList:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 'for oBalloon in self.balloonList:'
- en: status = oBalloon.update()
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: status = oBalloon.update()
- en: 'if status == BALLOON_MISSED:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '如果status == BALLOON_MISSED:'
- en: Balloon went off the top, remove it
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 气球从顶部飞出时，移除它
- en: self.balloonList.remove(oBalloon)
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: self.balloonList.remove(oBalloon)
- en: self.nMissed = self.nMissed + 1
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: self.nMissed = self.nMissed + 1
- en: '6 def getScore(self):'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '6 def getScore(self):'
- en: return self.score
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: return self.score
- en: '7 def getCountPopped(self):'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '7 def getCountPopped(self):'
- en: return self.nPopped
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: return self.nPopped
- en: '8 def getCountMissed(self):'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '8 def getCountMissed(self):'
- en: return self.nMissed
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: return self.nMissed
- en: '9 def draw(self):'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '9 def draw(self):'
- en: 'for oBalloon in self.balloonList:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 'for oBalloon in self.balloonList:'
- en: oBalloon.draw()
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: oBalloon.draw()
- en: '*Listing 11-6: The BalloonMgr class*'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-6: 气球管理器类*'
- en: When instantiated, the balloon manager is told the width and height of
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化时，气球管理器会被告知窗口的宽度和高度
- en: the window 1, and it saves this information in instance variables.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口1，并将此信息保存在实例变量中。
- en: The concept behind the start() method 2 is important. Its purpose
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: start()方法2背后的概念非常重要。它的目的是
- en: is to initialize any instance variables needed for one round of the game,
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 目的是初始化一轮游戏所需的任何实例变量，
- en: so it’s called whenever the user starts a round of the game. In this game,
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 所以它会在用户开始一轮游戏时被调用。在这个游戏中，
- en: start() resets the count of popped balloons and the count of missed bal-
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: start()重置已爆气球和漏气球的计数——
- en: loons. It then goes through a loop that creates all the Balloon objects (ran-
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 气球。然后，它会通过一个循环创建所有气球对象（随机
- en: domly chosen among three different sizes using three different classes)
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 随机从三种不同的尺寸中选择，使用三种不同的类）
- en: and stores them in a list 3\. Whenever the method creates a Balloon object,
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 并将它们存储在一个列表中3。当该方法创建一个气球对象时，
- en: it passes the window and the width and height of the window. (For future
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 它传递窗口以及窗口的宽度和高度。（为了未来
- en: expansion, each Balloon object is given a unique number.)
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展，每个气球对象都被赋予一个唯一的编号。）
- en: Each time through the main loop, the main code calls the handleEvent()
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过主循环时，主代码都会调用handleEvent()
- en: method of the balloon manager 4\. Here, we check if the user has clicked
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 气球管理器的方法4。在这里，我们检查用户是否已点击
- en: on any Balloon. If the event detected was a MOUSEDOWNEVENT, the code loops
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何气球上。如果检测到的事件是MOUSEDOWNEVENT，代码将循环
- en: through all the Balloon objects, asking each one if the click occurred inside
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历所有气球对象，询问每个气球点击是否发生在内部
- en: that balloon. Each Balloon returns a Boolean indicating if it was hit and, if
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 该气球。每个气球返回一个布尔值，表示它是否被击中，如果
- en: Managing Memory Used by Objects **257**
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象使用的内存 **257**
- en: so, the number of points the user should get for popping it. (The code is set
    up this way for future expansion, as discussed in the note at the end of this
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是用户应该因打爆它而获得的积分。（代码是这样设置的，方便未来扩展，正如文末的说明所提到的那样）
- en: section.) The balloon manager then uses the remove() method to eliminate
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 部分。）然后，气球管理器使用remove()方法将其消除
- en: that Balloon from its list, increments the number of popped balloons, and
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中移除该气球，增加已爆炸气球的数量，并
- en: updates the score.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 更新分数。
- en: In each iteration of the main loop, the main code also calls the update()
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环的每次迭代中，主代码还会调用update()
- en: method of the balloon manager 5, which passes this call on to all of the
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 气球管理器的方法5，将此调用传递给所有
- en: balloons, telling them to update themselves. Each balloon moves up the
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 气球，告诉它们更新自己。每个气球向上移动
- en: 'screen based on its own speed setting and returns its status: either that it
    is'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 根据自身的速度设置更新屏幕，并返回其状态：即它是否
- en: still moving (BALLOON_MOVING) or that it has moved beyond the top of the win-
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 仍在移动（BALLOON_MOVING），或者它已经移动到窗口顶部之外——
- en: dow (BALLOON_MISSED). If a balloon was missed, the balloon manager removes
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: dow (BALLOON_MISSED)。如果气球被漏掉，气球管理器将移除
- en: that balloon from its list and increments its count of missed balloons.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中移除该气球并增加漏气球的数量。
- en: The balloon manager provides three getter methods that allow the
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 气球管理器提供了三个getter方法，允许
- en: main code to get the score 6, the number of popped balloons 7, and the
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 主代码获取分数6、被打爆的气球数量7，以及
- en: number of missed balloons 8\.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 漏掉气球的数量8\。
- en: Each time through the main loop, the main code calls the balloon
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过主循环时，主代码都会调用气球
- en: manager’s draw() method 9\. The balloon manager doesn’t have anything
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器的draw()方法9. 气球管理器没有任何东西
- en: to draw by itself, but loops though all the Balloon objects and calls the draw()
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 由自身绘制，但会遍历所有Balloon对象并调用draw()
- en: method of each. (Notice the polymorphism here. The balloon manager has
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 每个的method。（注意这里的多态性。气球管理器有
- en: a draw() method, and each Balloon object has a draw() method.)
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 每个气球对象都有一个draw()方法。)
- en: '**N O T E**'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As a challenge, try to expand this game to include a new type (subclass) of
    Balloon, a* *MegaBalloon. The difference is that a MegaBalloon will take three
    clicks to pop. Artwork* *is included in the download for this game.*'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为挑战，尝试扩展此游戏，添加一种新的气球类型（子类），如* *MegaBalloon。不同之处在于，MegaBalloon需要三次点击才能爆炸。游戏的*
    *艺术作品包含在下载文件中。*'
- en: '***Bal oon Class and Objects***'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '***气球类和对象***'
- en: Finally, we have the balloon classes. To reinforce the concept of inheri-
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了气球类。为了强化继承的概念
- en: 'tance fro[m Chapter 10, t](index_split_004.html#p240)he *Balloon.py* module
    includes an abstract base class named Balloon and three subclasses: BalloonSmall,
    BalloonMedium, and'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 来自第10章的内容，[Balloon.py](index_split_004.html#p240)模块包括一个抽象基类Balloon和三个子类：BalloonSmall、BalloonMedium和
- en: BalloonLarge. The balloon manager instantiates Balloon objects from these
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: BalloonLarge。气球管理器从这些子类实例化Balloon对象
- en: subclasses. The subclasses each only include an __init__() method, which
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 子类。每个子类仅包含一个__init__()方法，定义
- en: overrides and then calls the abstract method __init__() in the Balloon
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 重写并调用抽象方法__init__()在Balloon
- en: class. Each balloon image will start at some randomized location (below
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: class。每个气球图像将从某个随机位置开始（位于
- en: the bottom of the window) and will move up a few pixels in every frame.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的底部）并且会在每一帧中向上移动几个像素。
- en: Listing 11-7 shows the code of the Balloon class and its subclasses.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-7展示了Balloon类及其子类的代码。
- en: '**File: BalloonGame/Balloon.py**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：BalloonGame/Balloon.py**'
- en: Balloon base class and 3 subclasses
  id: totrans-608
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Balloon基类和3个子类
- en: import pygame
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: import random
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: from pygame.locals import *
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import pygwidgets
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: from BalloonConstants import *
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: from BalloonConstants import *
- en: from abc import ABC, abstractmethod
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: from abc import ABC, abstractmethod
- en: '**258** Chapter 11'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '**258** 第11章'
- en: '1 class Balloon(ABC):'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '1 class Balloon(ABC):'
- en: popSoundLoaded = False
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: popSoundLoaded = False
- en: 'popSound = None # load when first balloon is created'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 'popSound = None  # 在第一个气球创建时加载'
- en: '@abstractmethod'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '@abstractmethod'
- en: 2 def __init__(self, window, maxWidth, maxHeight, ID,
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 2 def __init__(self, window, maxWidth, maxHeight, ID,
- en: 'oImage, size, nPoints, speedY):'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: oImage、大小、nPoints、speedY）：
- en: self.window = window
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.ID = ID
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: self.ID = ID
- en: self.balloonImage = oImage
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: self.balloonImage = oImage
- en: self.size = size
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: self.size = size
- en: self.nPoints = nPoints
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: self.nPoints = nPoints
- en: self.speedY = speedY
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: self.speedY = speedY
- en: 'if not Balloon.popSoundLoaded: # load first time only'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not Balloon.popSoundLoaded:  # 仅首次加载'
- en: Balloon.popSoundLoaded = True
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: Balloon.popSoundLoaded = True
- en: Balloon.popSound = pygame.mixer.Sound('sounds/balloonPop.wav')
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: Balloon.popSound = pygame.mixer.Sound('sounds/balloonPop.wav')
- en: balloonRect = self.balloonImage.getRect()
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: balloonRect = self.balloonImage.getRect()
- en: self.width = balloonRect.width
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = balloonRect.width
- en: self.height = balloonRect.height
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = balloonRect.height
- en: Position so balloon is within the width of the window,
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置，使气球位于窗口宽度内，
- en: but below the bottom
  id: totrans-635
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但位于底部以下
- en: self.x = random.randrange(maxWidth - self.width)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = random.randrange(maxWidth - self.width)
- en: self.y = maxHeight + random.randrange(75)
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = maxHeight + random.randrange(75)
- en: self.balloonImage.setLoc((self.x, self.y))
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: self.balloonImage.setLoc((self.x, self.y))
- en: '3 def clickedInside(self, mousePoint):'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '3 def clickedInside(self, mousePoint):'
- en: myRect = pygame.Rect(self.x, self.y, self.width, self.height)
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: myRect = pygame.Rect(self.x, self.y, self.width, self.height)
- en: 'if myRect.collidepoint(mousePoint):'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 'if myRect.collidepoint(mousePoint):'
- en: Balloon.popSound.play()
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: Balloon.popSound.play()
- en: 'return True, self.nPoints # True here means it was hit'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 'return True, self.nPoints  # True表示已被点击'
- en: 'else:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: 'return False, 0 # not hit, no points'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 'return False, 0  # 没有碰撞，没有得分'
- en: '4 def update(self):'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '4 def update(self):'
- en: 'self.y = self.y - self.speedY # update y position by speed'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.y = self.y - self.speedY  # 按照速度更新y位置'
- en: self.balloonImage.setLoc((self.x, self.y))
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: self.balloonImage.setLoc((self.x, self.y))
- en: 'if self.y < -self.height: # off the top of the window'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.y < -self.height:  # 离开窗口顶部'
- en: return BALLOON_MISSED
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: return BALLOON_MISSED
- en: 'else:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return BALLOON_MOVING
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: return BALLOON_MOVING
- en: '5 def draw(self):'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '5 def draw(self):'
- en: self.balloonImage.draw()
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: self.balloonImage.draw()
- en: '6 def __del__(self):'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '6 def __del__(self):'
- en: print(self.size, 'Balloon', self.ID, 'is going away')
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: print(self.size, '气球', self.ID, '正在离开')
- en: '7 class BalloonSmall(Balloon):'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '7 class BalloonSmall(Balloon):'
- en: balloonImage = pygame.image.load('images/redBalloonSmall.png')
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: balloonImage = pygame.image.load('images/redBalloonSmall.png')
- en: 'def __init__(self, window, maxWidth, maxHeight, ID):'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, maxWidth, maxHeight, ID):'
- en: oImage = pygwidgets.Image(window, (0, 0),
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: oImage = pygwidgets.Image(window, (0, 0),
- en: BalloonSmall.balloonImage)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: BalloonSmall.balloonImage)
- en: Managing Memory Used by Objects **259**
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象使用的内存 **259**
- en: super().__init__(window, maxWidth, maxHeight, ID,
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: super().__init__(window, maxWidth, maxHeight, ID,
- en: oImage, 'Small', 30, 3.1)
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: oImage, 'Small', 30, 3.1)
- en: '8 class BalloonMedium(Balloon):'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '8 class BalloonMedium(Balloon):'
- en: balloonImage = pygame.image.load('images/redBalloonMedium.png')
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: balloonImage = pygame.image.load('images/redBalloonMedium.png')
- en: 'def __init__(self, window, maxWidth, maxHeight, ID):'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, maxWidth, maxHeight, ID):'
- en: oImage = pygwidgets.Image(window, (0, 0),
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: oImage = pygwidgets.Image(window, (0, 0),
- en: BalloonMedium.balloonImage)
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: BalloonMedium.balloonImage)
- en: super().__init__(window, maxWidth, maxHeight, ID,
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: super().__init__(window, maxWidth, maxHeight, ID,
- en: oImage, 'Medium', 20, 2.2)
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: oImage, 'Medium', 20, 2.2)
- en: '9 class BalloonLarge(Balloon):'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '9 class BalloonLarge(Balloon):'
- en: balloonImage = pygame.image.load('images/redBalloonLarge.png')
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: balloonImage = pygame.image.load('images/redBalloonLarge.png')
- en: 'def __init__(self, window, maxWidth, maxHeight, ID):'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, maxWidth, maxHeight, ID):'
- en: oImage = pygwidgets.Image(window, (0, 0),
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: oImage = pygwidgets.Image(window, (0, 0),
- en: BalloonLarge.balloonImage)
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: BalloonLarge.balloonImage)
- en: super().__init__(window, maxWidth, maxHeight, ID,
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: super().__init__(window, maxWidth, maxHeight, ID,
- en: oImage, 'Large', 10, 1.5)
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: oImage, 'Large', 10, 1.5)
- en: '*Listing 11-7: The Balloon classes*'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-7: 气球类*'
- en: The Balloon class is an abstract class 1, so the BalloonMgr instanti-
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 气球类是一个抽象类 1，因此 BalloonMgr 会实例化。
- en: ates objects (randomly) from the BalloonSmall 7, BalloonMedium 8, and
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 随机生成对象（BalloonSmall 7、BalloonMedium 8 和
- en: BalloonLarge 9 classes. Each of those classes creates a pygwidgets Image object,
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: BalloonLarge 9 类。每个类都会创建一个 pygwidgets 图像对象。
- en: then calls the __init__() method in the Balloon base class. We differentiate
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用气球基类中的 `__init__()` 方法。我们通过
- en: the balloons with the arguments representing the image, size, number of
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 使用气球的图像、大小、数量等参数。
- en: points, and speed.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 分数和速度。
- en: The __init__() method in the Balloon class 2 stores the information
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法在气球类 2 中存储信息。'
- en: about each balloon in instance variables. We get the rectangle of the bal-
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 获取每个气球的矩形信息。
- en: loon image and remember its width and height. We set a randomized
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 会记住气球的图像以及其宽度和高度。我们设置一个随机化的
- en: horizontal position that will ensure that the balloon image will fully show
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 水平位置会确保气球图像完全显示。
- en: within the window.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口内。
- en: Every time a MOUSEDOWNEVENT happens, the balloon manager loops
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发生 MOUSEDOWNEVENT 事件时，气球管理器会循环。
- en: through the Balloon objects and calls the clickedInside() method of each 3\.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历气球对象并调用每个 3\ 的 `clickedInside()` 方法。
- en: The code here checks to see if the MOUSEDOWNEVENT that was detected hap-
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码检查检测到的 MOUSEDOWNEVENT 是否发生在当前气球内。
- en: pened inside the current balloon. If it did, the Balloon plays the pop sound
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生了，它会播放爆炸音效。
- en: and returns a Boolean to say that it was clicked on, as well as the number of
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回一个布尔值，表示气球是否被点击，以及点击的次数。
- en: points that balloon was worth. If it was not hit, it returns False and zero.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 气球所值的分数。如果没有被点击，则返回 False 和零。
- en: In each frame, the balloon manager calls the update() method of each
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中，气球管理器会调用每个气球的 `update()` 方法。
- en: Balloon 4, which updates that Balloon’s y position by subtracting its own
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 气球 4，它通过减去自身的 y 坐标来更新气球的 y 位置。
- en: speed in order to move higher in the window. After changing the position,
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 速度，以便使气球更高地移动到窗口中。改变位置后，
- en: the update() method returns either BALLOON_MISSED (if it has moved completely
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()` 方法返回 BALLOON_MISSED（如果气球已完全移出窗口顶部）或 BALLOON_MOVING（表示气球仍在游戏中）。'
- en: off the top of the window) or BALLOON_MOVING (to indicate that it is still in
    play).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 如果气球已完全移出窗口顶部，返回 BALLOON_MISSED，否则返回 BALLOON_MOVING（表示气球仍在播放）。
- en: The draw() method simply draws the image of the balloon at the appro-
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()` 方法简单地在合适的位置绘制气球的图像。'
- en: priate (x, y) location 5\. Although the y position is kept as a floating-point
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 合适的 (x, y) 位置 5\。虽然 y 坐标保持为浮动小数。
- en: value, pygame automatically converts it to an integer for pixel placement in
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 数值，pygame 会自动将其转换为整数，用于像素位置的放置。
- en: the window.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口内。
- en: The last method, __del__() 6, has been added for debugging and for
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的方法 `__del__()` 6 被添加用于调试和未来开发。
- en: future development. Whenever the balloon manager deletes a balloon,
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 每当气球管理器删除一个气球时，
- en: the __del__() method of that Balloon object is called. For demonstration
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 当该气球对象被删除时，会调用 `__del__()` 方法。此方法用于演示。
- en: '**260** Chapter 11'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '**260** 第 11 章'
- en: purposes, for now it simply prints a message that displays the balloon’s size
    and ID number.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 目前仅用于打印显示气球的大小和 ID 号码的消息。
- en: When the program is run and the user starts clicking on the balloons,
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行并且用户开始点击气球时，
- en: 'we see output like this in the shell or console window:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 shell 或控制台窗口中看到类似这样的输出：
- en: Small Balloon 2 is going away
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 小气球 2 正在消失
- en: Small Balloon 8 is going away
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 小气球 8 正在消失
- en: Small Balloon 3 is going away
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 小气球 3 正在消失
- en: Small Balloon 7 is going away
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 小气球 7 正在消失
- en: Small Balloon 9 is going away
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 小气球 9 正在消失
- en: Small Balloon 12 is going away
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 小气球 12 正在消失
- en: Small Balloon 11 is going away
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 小气球 11 正在消失
- en: Small Balloon 6 is going away
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 小气球 6 正在消失
- en: Medium Balloon 14 is going away
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 中气球 14 正在消失
- en: Large Balloon 1 is going away
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 大气球 1 正在消失
- en: Medium Balloon 10 is going away
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 中气球 10 正在消失
- en: Medium Balloon 13 is going away
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 中气球 13 正在消失
- en: Medium Balloon 0 is going away
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 中气球 0 正在消失
- en: Medium Balloon 4 is going away
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 中气球 4 正在消失
- en: Large Balloon 5 is going away
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 大气球 5 正在消失
- en: When the game is over, the program waits for the user to click on the
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏结束时，程序等待用户点击
- en: Start button. When that button is clicked, the balloon manager re-creates
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 开始按钮。当按钮被点击时，气球管理器重新创建
- en: the list of Balloon objects and resets its instance variables, and the game
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 气球对象的列表重置其实例变量，游戏
- en: begins again.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 再次开始。
- en: '**Managing Memory: Slots**'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存管理：插槽**'
- en: As we have discussed, when you instantiate an object, Python must allocate
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所讨论的，当你实例化一个对象时，Python 必须分配
- en: space for the instance variables defined in the class. By default, Python does
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 用于类中定义的实例变量的空间。默认情况下，Python 会
- en: 'this using a dictionary with a special name: __dict__. To see this in action,'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过一个特殊名称的字典实现：__dict__。要查看其作用，
- en: 'you can add this line to the end of the __init__() method of any class:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何类的 __init__() 方法末尾添加这一行：
- en: print(self.__dict__)
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: print(self.__dict__)
- en: A dictionary is an excellent way to represent all the instance vari-
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是表示所有实例变量的绝佳方式
- en: ables because it is dynamic—it can grow whenever Python encounters an
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是动态的——它可以在 Python 遇到新的实例变量时增长
- en: instance variable that it has not seen before in a class. While I recommend
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 Python 遇到一个在类中未见过的实例变量时，都会动态添加。虽然我推荐
- en: that you initialize all your instance variables in your __init__() method, you
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保在 __init__() 方法中初始化所有实例变量，确保
- en: can in fact define instance variables in any method, and those instance vari-
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你可以在任何方法中定义实例变量，并且这些实例变量
- en: ables will be added when the method is executed for the first time. While
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 执行方法时，新的实例变量会被添加到字典中。虽然
- en: I personally think the following is a bad idea, it demonstrates the ability
    to
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人认为下面的做法不太好，它展示了对
- en: 'add an instance variable to an object dynamically:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 动态地为对象添加实例变量：
- en: myObject = MyClass()
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: myObject = MyClass()
- en: myObject.someInstanceVariable = 5
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: myObject.someInstanceVariable = 5
- en: In order to allow for this dynamic capability, dictionaries are typically
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许这种动态功能，字典通常
- en: implemented starting with enough empty space to represent some number
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 实现时从足够的空白空间开始，以表示一些数量的实例变量
- en: of instance variables (the exact number is an internal detail of Python).
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量的列表（确切数量是 Python 的内部细节）。
- en: Managing Memory Used by Objects **261**
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象使用的内存 **261**
- en: Whenever a new instance variable is encountered, it’s added to the dictionary.
    If the dictionary runs out of space, Python adds more. This generally
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 每当遇到新的实例变量时，它会被添加到字典中。如果字典空间不足，Python 会增加更多空间。通常情况下，
- en: works well, and programmers do not experience any problems with this
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法是可行的，而且程序员通常不会遇到问题
- en: implementation.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 实现。
- en: However, imagine you have a class like the following with two instance
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设你有一个如下所示的类，其中包含两个实例
- en: variables created in the __init__() method, and you know that you will not
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 在 __init__() 方法中创建的变量，并且你知道你不会
- en: 'need to add any more instance variables:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要再添加任何实例变量：
- en: 'class Point():'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Point():'
- en: 'def __init__(self, x, y):'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, x, y):'
- en: self.x = x
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = x
- en: self.y = y
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = y
- en: More methods
  id: totrans-762
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多方法
- en: Now, let’s assume that you need to instantiate a very large number
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你需要实例化大量的对象
- en: (hundreds of thousands, or even millions) of objects from this class. A case
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: （成百上千，甚至百万）个该类的对象。一个例子
- en: like this could cumulatively account for a large amount of wasted memory
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的方法可能会累计占用大量浪费的内存
- en: space (RAM).
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 空间（内存）的需求。
- en: To combat this potential waste, Python gives us a different approach,
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这种潜在的浪费，Python 给我们提供了不同的方法，
- en: known as *slots*, to represent the instance variables. The idea is that you
    can tell Python the names of all the instance variables up front, and Python
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为*槽（slots）*，用于表示实例变量。这个想法是你可以提前告诉Python所有实例变量的名称，然后Python
- en: will use a data structure that allocates exactly enough space for just those
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用一种数据结构，仅为这些
- en: instance variables. To use slots, you need to include the special class vari-
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量。要使用槽（slots），你需要包含特殊的类变量。
- en: 'able __slots__ to define a list of variables:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用__slots__来定义一个变量列表：
- en: __slots__ = [ *<instanceVar1>* , *<instanceVar2>* , ... *<instanceVarN>* ]
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: __slots__ = [ *<instanceVar1>* , *<instanceVar2>* , ... *<instanceVarN>* ]
- en: 'Here is what a modified version of our example class would look like:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们示例类修改版的样子：
- en: 'class PointWithSlots():'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '类 PointWithSlots():'
- en: Define slots for only two instance variables
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为两个实例变量定义槽
- en: __slots__ = ['x', 'y']
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: __slots__ = ['x', 'y']
- en: 'def __init__(self, x, y):'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, x, y):'
- en: self.x = x
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = x
- en: self.y = y
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = y
- en: print(x, y)
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: print(x, y)
- en: These two classes will work identically, but objects instantiated from
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类将以相同的方式工作，但从
- en: PointWithSlots will take up considerably less memory. To demonstrate the
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: PointWithSlots将占用显著更少的内存。为了演示
- en: difference, we’ll add this line to the end of the __init__() method of both
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示区别，我们将在两个__init__()方法的末尾添加这一行
- en: 'classes:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 类：
- en: Try to create an additional instance variable
  id: totrans-785
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试创建一个额外的实例变量
- en: self.color = 'black'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: self.color = 'black'
- en: Now when we try to instantiate an object from both classes, the
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们尝试从这两个类实例化一个对象时，
- en: Point class has no problem adding another instance variable, but the
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: Point类没有问题可以添加另一个实例变量，但
- en: 'PointWithSlots class fails with the following error:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: PointWithSlots类会因以下错误而失败：
- en: 'AttributeError: ''PointWithSlots'' object has no attribute ''color'''
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 'AttributeError: ''PointWithSlots''对象没有属性''color'''
- en: '**262** Chapter 11'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '**262** 第11章'
- en: Using slots is highly memory-efficient at the expense of a loss of dynamic instance
    variables. If you’re dealing with a very large number of
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 使用槽（slots）在牺牲动态实例变量的情况下，具有非常高的内存效率。如果你处理的是大量的
- en: objects from a class, this trade-off may very well be worthwhile.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 从类中创建对象时，这种权衡可能是值得的。
- en: '**Summary**'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter focused on a few concepts that didn’t readily fit in the previ-
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论了一些在之前章节中没有直接涉及的概念。
- en: ous chapters. First, I discussed the circumstances under which you might
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 各个章节。首先，我讨论了在什么情况下你可能会遇到
- en: want to delete an object. We looked at reference counts and how they track
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 想要删除一个对象时。我们查看了引用计数及其如何追踪
- en: how many variables refer to the same object, which led to a discussion of
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 多少变量引用同一个对象，这引发了对
- en: object lifetimes and garbage collection. When the reference count goes to
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 对象生命周期和垃圾回收。当引用计数为零时，
- en: zero, the object is available for garbage collection. If a class has a __del__()
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用计数为零时，该对象可以被垃圾回收。如果类有__del__()
- en: method, then any objects created from the class can use the __del__()
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 方法，那么从该类创建的任何对象都可以使用__del__()
- en: method for any cleanup that they might want to do.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 方法来处理它们可能想要进行的任何清理工作。
- en: Next, I discussed how class variables are different from instance
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我讨论了类变量与实例变量的区别。
- en: variables. Every object instantiated from a class gets its own set of all the
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 变量。每个从类实例化的对象都会获得自己的一套所有
- en: instance variables in the class. However, there is only one of each class
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的实例变量。然而，每个类中只有一个
- en: variable, and that is accessible by all objects created from the class. Class
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 变量，这对从类创建的所有对象都是可访问的。类
- en: variables are often used as constants or counters, or for loading something
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 变量通常用作常量、计数器，或用于加载某些内容。
- en: large and making it available to all objects instantiated from the class.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 大小并将其提供给所有从该类实例化的对象。
- en: To put a number of techniques and concepts together, we built a
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将多种技巧和概念结合起来，我们构建了一个
- en: balloon-popping game and organized it very efficiently. We had one file
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 气球爆炸游戏，并且组织得非常高效。我们有一个文件
- en: that contained only constants used by other files. The main code con-
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 仅包含其他文件使用的常量的那个文件。主代码由
- en: sisted of the main loop and a status display, and the balloon manager
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 主要循环和状态显示组成，而气球管理器
- en: did the work of managing the objects. Such a division of labor allows for
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 负责管理对象的工作。这种分工方式允许
- en: splitting up the game into smaller, logical pieces. The role of each part is
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 将游戏分成更小的、逻辑清晰的部分。每一部分的角色是
- en: well defined, making the overall program more manageable.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的定义，使整个程序更易于管理。
- en: Finally, I explained how a technique called slots allows for a memory-
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我解释了一种名为插槽的技术，允许实现内存
- en: efficient representation of instance variables.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量的高效表示方式。
- en: Managing Memory Used by Objects **263**
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 管理对象使用的内存 **263**
- en: '**PART IV**'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '**第四部分**'
- en: '**U S I N G O O P I N G A M E**'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用面向对象的游戏**'
- en: '**D E V E L O P M E N T**'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发**'
- en: In this part of the book, we’ll build some sample
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们将构建一些示例
- en: games using pygwidgets. I’ll also introduce the pyghelpers
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pygwidgets构建游戏。我还会介绍pyghelpers
- en: module, which includes a number of classes and func-
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 模块，包括许多类和函数。
- en: tions that can be useful in building game programs.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在构建游戏程序时非常有用的类和函数。
- en: '[Chapter 12 re](#p296)visits the Higher or Lower game fro[m Chapter 1\. W](index_split_000.html#p32)e’ll
    build a version of the game with a graphical user interface, and I’ll introduce
    Deck and Card classes that can be reused in any card game program.'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章 re](#p296)回顾了第1章中的高低游戏。我们将构建一个带有图形用户界面的游戏版本，并介绍可以在任何卡牌游戏程序中重用的Deck和Card类。'
- en: '[Chapter 13 f](#p310)ocuses on timers. We’ll build a number of different timer
    classes that allow your program to keep running while concurrently checking for
    a certain time limit.'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '[第13章 f](#p310)聚焦于定时器。我们将构建多个不同的定时器类，允许你的程序在运行的同时并发地检查时间限制。'
- en: '[Chapter 14 d](#p324)iscusses different animation classes you can use to show
    sequences of images. This will allow you to easily build more artistic games'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章 d](#p324)讨论了不同的动画类，可以用来显示图像序列。这将使你能够轻松构建更具艺术感的游戏。'
- en: and programs.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 和程序。
- en: '[Chapter 15 i](index_split_006.html#p340)ntroduces an approach to building
    a program that can contain many scenes, like a start scene, a play scene, and
    a game over scene. I’ll'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '[第15章 i](index_split_006.html#p340)介绍了一种构建可以包含多个场景的方法，比如开始场景、游戏场景和游戏结束场景。我将'
- en: show a SceneMgr class that is designed to manage any number of program-
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个SceneMgr类，用于管理程序中的任意数量的场景。
- en: mer-built scenes, and we’ll use it to build a Rock, Paper, Scissors game.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的场景，并将使用它来构建一个石头、剪刀、布游戏。
- en: '[Chapter 16 d](index_split_006.html#p370)emonstrates how to show and react
    to different types of dialog boxes. You’ll then use everything you’ve learned
    to build a fully functioning animated game.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '[第16章 d](index_split_006.html#p370)演示了如何显示并响应不同类型的对话框。然后你将使用所学内容来构建一个完全功能的动画游戏。'
- en: '[Chapter 17 i](index_split_007.html#p396)ntroduces the concept of design patterns,
    using the model, view, controller pattern as an example. It then provides a short
    wrap-up for'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17章 i](index_split_007.html#p396)介绍了设计模式的概念，以模型-视图-控制器模式为例。然后简要总结'
- en: the book.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的内容。
- en: '**12**'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**C A R D G A M E S**'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '**扑克牌游戏**'
- en: In the remaining chapters of this book,
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余章节中，
- en: we’ll build a few demo programs using
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用pygame和pygwidgets构建一些演示程序。
- en: pygame and pygwidgets. Each program will
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: pygame和pygwidgets。每个程序将
- en: present one or more reusable classes and show
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 展示一个或多个可重用的类，并展示
- en: how they can be used in a sample project.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在示例项目中使用这些类。
- en: I[n Chapter 1, I p](index_split_000.html#p32)resented a text-based Higher or
    Lower card game. In this chapter we’ll create a GUI version of the game, as shown
    in Figure 12-1\.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章，我](index_split_000.html#p32)介绍了一个基于文本的高低游戏。在这一章中，我们将创建游戏的GUI版本，如图12-1所示。'
- en: 'To quickly recap the game rules: we start with seven cards face down'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾游戏规则：我们从七张牌开始，牌面朝下
- en: and one card face up. The player guesses whether the next card to be
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 和一张翻面的牌。玩家猜测下一张牌是否
- en: turned over will be higher or lower than the last visible card by pressing
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 翻转的牌比上一张可见牌大或小，玩家按下按钮来判断。
- en: Lower or Higher. When the game is over, the user can click New Game to
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 高低游戏结束时，用户可以点击“新游戏”按钮来
- en: start a new round of the game. The player starts with 100 points, gains 15
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 开始新一轮游戏。玩家从100分开始，答对得15分，答错扣10分。
- en: points for a correct answer, and loses 10 points for an incorrect answer.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家答对得15分，答错扣10分。
- en: '![Image 34](index-297_1.png)'
  id: totrans-850
  prefs: []
  type: TYPE_IMG
  zh: '![图片 34](index-297_1.png)'
- en: '*Figure 12-1: The user interface of the Higher or Lower game*'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：高低游戏的用户界面*'
- en: '**The Card Class**'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '**Card类**'
- en: In the original text-based version of the game, the code dealing with the
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的基于文本的游戏版本中，处理牌堆的代码
- en: deck of cards was not easily reusable in other projects. To solve this prob-
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 这副扑克牌无法在其他项目中轻松重用。为了解决这个问题，
- en: lem, here we’ll create a highly reusable Deck class that manages cards from
    a
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将在这里创建一个高度可重用的Deck类，用于管理来自一副扑克牌的牌。
- en: Card class.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: Card类。
- en: To represent a card in pygame, we need to store the following data in
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: 'instance variables for each Card object:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: • Rank (ace, 2, 3, … 10, jack, queen, king)
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: • Suit (clubs, hearts, diamonds, spades)
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: • Value (1, 2, 3, … 12, 13)
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '• Name (built using the rank and suit: for example, 7 of clubs)'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: • Image of the back of the card (a single image shared by all Card objects)
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: • Image of the front of the card (a unique image for each Card object)
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: Each card must be able to perform the following behaviors, for which
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: 'we will create methods:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: • Mark itself as concealed (face down)
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: • Mark itself as revealed (face up)
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: • Return its name
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: • Return its value
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: • Set and get its location in the window
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: • Draw itself (either the revealed image or the concealed image)
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '**268** Chapter 12'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: 'While the following card behaviors are not used in the Higher or Lower game,
    we’ll add these too in case they are needed in some other game:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: • Return its rank
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: • Return its suit
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: Listing 12-1 shows the code of the Card class.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: '**File: HigherOrLower/Card.py**'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: Card class
  id: totrans-879
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: import pygwidgets
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: 'class Card():'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: 1 BACK_OF_CARD_IMAGE = pygame.image.load('images/BackOfCard.png')
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '2 def __init__(self, window, rank, suit, value):'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: self.rank = rank
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: self.suit = suit
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: self.cardName = rank + ' of ' + suit
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: self.value = value
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: 3 fileName = 'images/' + self.cardName + '.png'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: Set some starting location; use setLoc below to change
  id: totrans-891
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 self.images = pygwidgets.ImageCollection(window, (0, 0),
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '{''front'': fileName,'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '''back'': Card.BACK_OF_CARD_IMAGE}, ''back'')'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '5 def conceal(self):'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: self.images.replace('back')
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '6 def reveal(self):'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: self.images.replace('front')
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '7 def getName(self):'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: return self.cardName
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: 'def getValue(self):'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: return self.value
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: 'def getSuit(self):'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: return self.suit
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: 'def getRank(self):'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: return self.rank
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '8 def setLoc(self, loc): # call the setLoc method of the ImageCollection'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: self.images.setLoc(loc)
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: Card Games **269**
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: '9 def getLoc(self): # get the location from the ImageCollection loc = self.images.getLoc()'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: return loc
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: 'a def draw(self):'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: self.images.draw()
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12-1: The Card class*'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: The Card class assumes that image files for all 52 cards, plus an image
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: for the back of all the cards, are available in a folder named *images* inside
    the project folder. If you download the files associated with this chapter,
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: you will see that the *images* folder contains the full set of . *png* files.
    The files are available via my GitHub repository at [*https://github.com/IrvKalb/*](https://github.com/IrvKalb/Object-Oriented-Python-Code/)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '[*Object-Oriented-Python-Code*](https://github.com/IrvKalb/Object-Oriented-Python-Code/)
    */*.'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: The class loads the image of the back of the cards once and saves it in a
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: class variable 1\. That image is available to all Card objects.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: When called for each card, the __init__() method 2 starts by storing
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: the window; building and storing the name of the card; and storing its
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: rank, value, and suit in instance variables. It then builds the path to the
    file
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: in the *images* folder that contains the image for that specific card 3\. For
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 在*images*文件夹中，包含该特定卡片3的图像。对于
- en: example, if the rank is ace and the suit is spades, we build a path of *images/*
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果等级是ace且花色是黑桃，我们构建一个路径，存放在*images/*
- en: '*Ace of Spades.png*. We use an ImageCollection object to remember the paths'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ace of Spades.png*。我们使用一个ImageCollection对象来记住这些路径'
- en: to both the front and back images 4; we’ll use 'back' to say that we want to
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 用于正面和背面图像4；我们会使用'back'来表示我们希望
- en: show the back of the card as the starting image.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 显示卡片的背面作为起始图像。
- en: The conceal() method 5 tells ImageCollection to set the back of the card
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: conceal()方法5告诉ImageCollection将卡片背面设置为
- en: as the current image. The reveal() method 6 tells ImageCollection to set the
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 作为当前图像。reveal()方法6告诉ImageCollection设置
- en: front of the card as the current image.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 将卡片的正面作为当前图像。
- en: The getName(), getValue(), getSuit(), and getRank() methods 7 are getter
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: getName()、getValue()、getSuit()和getRank()方法7是getter
- en: methods that allow the caller to retrieve the name, value, suit, and rank of
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 允许调用者获取卡片的名称、值、花色和等级的方法
- en: the given card.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的卡片。
- en: The setLoc() method sets a new location for the card 8, and getLoc()
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: setLoc()方法为卡片8设置新位置，getLoc()
- en: retrieves the current location 9\. The location is kept in the ImageCollection.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 检索当前的位置9。位置保存在ImageCollection中。
- en: Finally, draw() a draws the image of the card in the window. More spe-
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，draw()在窗口中绘制卡片的图像。更具体地说
- en: cifically, it tells the ImageCollection to draw the currently indicated image
    at
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，它告诉ImageCollection在当前指示的位置绘制图像
- en: the remembered location.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 记住的位置。
- en: '**The Deck Class**'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '**Deck类**'
- en: A Deck object is a classic example of an object manager object. Its job is to
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: Deck对象是对象管理器对象的经典示例。它的工作是
- en: create and manage 52 Card objects. Listing 12-2 contains the code of our
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并管理52张卡片对象。清单12-2包含我们的代码
- en: Deck class.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: Deck类。
- en: '**File: HigerOrLower/Deck.py**'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：HigerOrLower/Deck.py**'
- en: Deck class
  id: totrans-945
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Deck类
- en: import random
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: from Card import *
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: from Card import *
- en: '**270** Chapter 12'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '**270** 第12章'
- en: 'class Deck():'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Deck():'
- en: 1 SUIT_TUPLE = ('Diamonds', 'Clubs', 'Hearts', 'Spades')
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 1 SUIT_TUPLE = ('Diamonds', 'Clubs', 'Hearts', 'Spades')
- en: This dict maps each card rank to a value for a standard deck
  id: totrans-951
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这个字典将每个卡片的等级映射到一个标准牌组的值
- en: STANDARD_DICT = {'Ace':1, '2':2, '3':3, '4':4, '5':5,
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: STANDARD_DICT = {'Ace':1, '2':2, '3':3, '4':4, '5':5,
- en: '''6'':6, ''7'':7, ''8'': 8, ''9'':9, ''10'':10,'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '''6'':6, ''7'':7, ''8'': 8, ''9'':9, ''10'':10,'
- en: '''Jack'':11, ''Queen'':12, ''King'':13}'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '''Jack'':11, ''Queen'':12, ''King'':13}'
- en: '2 def __init__(self, window, rankValueDict=STANDARD_DICT):'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def __init__(self, window, rankValueDict=STANDARD_DICT):'
- en: rankValueDict defaults to STANDARD_DICT, but you can call it
  id: totrans-956
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rankValueDict默认为STANDARD_DICT，但你可以调用它
- en: with a different dict, e.g., a special dict for Blackjack
  id: totrans-957
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用一个不同的字典，例如，适用于二十一点的特殊字典
- en: self.startingDeckList = []
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: self.startingDeckList = []
- en: self.playingDeckList = []
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: self.playingDeckList = []
- en: 'for suit in Deck.SUIT_TUPLE:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个花色，在Deck.SUIT_TUPLE中：
- en: '3 for rank, value in rankValueDict.items():'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 3 对于rank, value在rankValueDict.items()中：
- en: oCard = Card(window, rank, suit, value)
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: oCard = Card(window, rank, suit, value)
- en: self.startingDeckList.append(oCard)
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: self.startingDeckList.append(oCard)
- en: self.shuffle()
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: self.shuffle()
- en: '4 def shuffle(self):'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '4 def shuffle(self):'
- en: Copy the starting deck and save it in the playing deck list
  id: totrans-966
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制起始牌组并将其保存在游戏牌组列表中
- en: self.playingDeckList = self.startingDeckList.copy()
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: self.playingDeckList = self.startingDeckList.copy()
- en: 'for oCard in self.playingDeckList:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 对于self.playingDeckList中的每个oCard：
- en: oCard.conceal()
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: oCard.conceal()
- en: random.shuffle(self.playingDeckList)
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: random.shuffle(self.playingDeckList)
- en: '5 def getCard(self):'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '5 def getCard(self):'
- en: 'if len(self.playingDeckList) == 0:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 如果self.playingDeckList的长度为0：
- en: raise IndexError('No more cards')
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: raise IndexError('没有更多的卡片')
- en: Pop one card off the deck and return it
  id: totrans-974
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从牌组中弹出一张卡片并返回
- en: oCard = self.playingDeckList.pop()
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: oCard = self.playingDeckList.pop()
- en: return oCard
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: return oCard
- en: '6 def returnCardToDeck(self, oCard):'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '6 def returnCardToDeck(self, oCard):'
- en: Put a card back into the deck
  id: totrans-978
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一张卡片放回牌组
- en: self.deckList.insert(0, oCard)
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: self.deckList.insert(0, oCard)
- en: '*Listing 12-2: A Deck class that manages 52 Card objects*'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-2：一个管理52张卡片对象的Deck类*'
- en: We begin the Deck class by creating a few class variables 1 that we’ll
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一些类变量1来开始Deck类，这些变量将
- en: use to create 52 cards with the proper suits and values. There are only four
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来创建52张具有正确花色和值的卡片。只有四种
- en: methods.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。
- en: To the __init__() method 2, we pass a reference to the window and an
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 对__init__()方法2，我们传递了一个窗口的引用和一个
- en: optional dictionary that maps card ranks to their values. If none is passed
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的字典，将卡片的等级映射到它们的值。如果没有传递
- en: in, we use the dictionary for a standard deck of values. We build a deck
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个字典来表示标准的牌组值。我们构建一副牌
- en: of 52 cards, saved in self.startingDeckList, by iterating through all suits,
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 52张卡片，保存在self.startingDeckList中，通过遍历所有花色，
- en: then iterating through all card ranks and values. In the inner for loop 3,
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 然后遍历所有卡片的等级和值。在内层的for循环3中，
- en: we use a call to the items() method of a dictionary that allows us to eas-
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用字典的items()方法调用，它允许我们轻松
- en: ily get the key and value (here, the rank and value) in a single statement.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以在一个语句中轻松获取键和值（在这里是等级和值）。
- en: Each time through the inner loop we instantiate a Card object, passing the
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 每次进入内循环时，我们实例化一个Card对象，并传入
- en: rank, suit, and value of the new card. We append each Card object to the
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 新卡片的等级、花色和数值。我们将每个Card对象附加到
- en: list self.startingDeckList to create a full deck of cards.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 列表self.startingDeckList来创建一副完整的卡组。
- en: Card Games **271**
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 卡牌游戏 **271**
- en: The final step is to call the shuffle() method 4 to randomize the
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是调用shuffle()方法4来随机化
- en: 'deck. The purpose of this method may seem obvious: to shuffle the deck.'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 卡组。这个方法的目的似乎很明显：洗牌。
- en: However, it does an extra little trick. The __init__() method built the
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它做了一些额外的小技巧。__init__()方法构建了
- en: self.startingDeckList, and that work should only be done once. So, when-
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: self.startingDeckList，并且这项工作应该只做一次。所以，当
- en: ever we shuffle the deck, rather than re-creating all the Card objects, we
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 每次洗牌时，我们不会重新创建所有的Card对象，而是
- en: make a copy of the starting deck list, save it in self.playingDeckList, and
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 创建初始卡组列表的副本，保存在self.playingDeckList中，并
- en: shuffle that. The copy is what will be used and manipulated as the game
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 洗牌。复制的是将被用作游戏中操作的卡组。
- en: runs. With this approach, we can remove cards from self.playingDeckList
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时。通过这种方法，我们可以从self.playingDeckList中移除卡片
- en: and not have to worry about adding them back into the deck later or reload-
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 然后不必担心稍后将它们重新添加回卡组或重新加载-
- en: ing cards. The two lists, self.startingDeckList and self.playingDeckList, share
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 交换卡片。两个列表self.startingDeckList和self.playingDeckList共享
- en: references to the same 52 Card objects.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 引用相同的52个Card对象。
- en: Note that when we call shuffle() for subsequent runs of the game, some
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们在游戏的后续运行中调用shuffle()时，一些
- en: of the Card objects may be in the “revealed” state. So, before proceeding, we
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: Card对象的状态可能是“已揭示”状态。所以，在继续之前，我们
- en: iterate through the entire deck and call the conceal() method on each card,
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历整个卡组并在每张卡片上调用conceal()方法，
- en: so that all cards will initially appear face down. The shuffle() method fin-
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 使所有的卡片初始时都显示为面朝下。shuffle()方法通过
- en: ishes by randomizing the cards in the playing deck using random.shuffle().
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用random.shuffle()随机化卡组，洗牌操作完成。
- en: The getCard() method 5 retrieves a card from the deck. It first checks
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: getCard()方法5从卡组中获取一张卡片。它首先检查
- en: to see if the deck is empty and, if so, raises an exception. Otherwise, since
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 以查看卡组是否为空，如果是，则引发异常。否则，既然
- en: the deck is already shuffled, it pops a card off the deck and returns that
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 如果卡组已经洗牌，它会从卡组中弹出一张卡片并返回该
- en: card to the caller.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 返回卡片给调用者。
- en: Together, Deck and Card provide a highly reusable combination of classes
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: Deck和Card一起提供了一个高度可复用的类组合。
- en: that can be used in most card games. The Higher or Lower game only uses
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于大多数卡牌游戏的卡片。高低游戏仅使用
- en: eight cards for each round and shuffles the entire deck at the start of each
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 每回合抽取八张卡片，并在每轮开始时洗牌整副卡组。
- en: game. Therefore, in this game it is not possible for the Deck object to run
    out
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏。因此，在这个游戏中，Deck对象不可能会用尽
- en: of cards. For a card game where you need to know if the deck runs out of
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片。对于一款需要知道卡组是否用尽的卡牌游戏，
- en: cards, you can build a try block around the call to getCard() and use an except
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片时，你可以在调用getCard()时构建一个try块，并使用except
- en: clause to catch an exception. The choice of what to do there is up to you.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 使用try-except语句来捕获异常。如何处理异常由你决定。
- en: While not used in this game, the returnCardToDeck() method 6 allows
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个游戏中没有使用，returnCardToDeck()方法6允许
- en: you to put a card back into the deck.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 让你将卡片放回卡组。
- en: '**The Higher or Lower Game**'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '**高低游戏**'
- en: 'The code of the actual game is fairly simple: the main code implements the'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 实际游戏的代码相当简单：主代码实现了
- en: main loop, and a Game object contains the logic for the game itself.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环，而Game对象包含游戏逻辑本身。
- en: '***Main Program***'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '***主程序***'
- en: Listing 12-3 is the main program that sets up the world and contains the
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12-3是设置游戏世界并包含主要程序的代码。
- en: main loop. It also creates the Game object that runs the game.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环。它还创建了一个Game对象来运行游戏。
- en: '**File: HigherOrLower/Main_HigherOrLower.py**'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：HigherOrLower/Main_HigherOrLower.py**'
- en: Higher or Lower - pygame version
  id: totrans-1031
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高低游戏 - pygame版本
- en: Main program
  id: totrans-1032
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主程序
- en: '--- snip ---'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 剪切 ---'
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-1034
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、音效等。
- en: 1 background = pygwidgets.Image(window, (0, 0),
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 1 background = pygwidgets.Image(window, (0, 0),
- en: '**272** Chapter 12'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '**272** 第12章'
- en: '''images/background.png'')'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/background.png'')'
- en: newGameButton = pygwidgets.TextButton(window, (20, 530),
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: newGameButton = pygwidgets.TextButton(window, (20, 530),
- en: '''New Game'', width=100, height=45)'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '''New Game'', width=100, height=45)'
- en: higherButton = pygwidgets.TextButton(window, (540, 520),
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: higherButton = pygwidgets.TextButton(window, (540, 520),
- en: '''Higher'', width=120, height=55)'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '''Higher'', width=120, height=55)'
- en: lowerButton = pygwidgets.TextButton(window, (340, 520),
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: lowerButton = pygwidgets.TextButton(window, (340, 520),
- en: '''Lower'', width=120, height=55)'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '''Lower'', width=120, height=55)'
- en: quitButton = pygwidgets.TextButton(window, (880, 530),
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: quitButton = pygwidgets.TextButton(window, (880, 530),
- en: '''Quit'', width=100, height=45)'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '''Quit'', width=100, height=45)'
- en: 5 - Initialize variables
  id: totrans-1046
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: 2 oGame = Game(window)
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 2 oGame = Game(window)
- en: 6 - Loop forever
  id: totrans-1048
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永远循环
- en: 'while True:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-1050
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: if ((event.type == QUIT) or
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 如果((event.type == QUIT) 或者
- en: ((event.type == KEYDOWN) and (event.key == K_ESCAPE)) or
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: ((event.type == KEYDOWN) and (event.key == K_ESCAPE)) or
- en: '(quitButton.handleEvent(event))):'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '(quitButton.handleEvent(event))):'
- en: pygame.quit()
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: '3 if newGameButton.handleEvent(event):'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '3 如果newGameButton.handleEvent(event):'
- en: oGame.reset()
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: oGame.reset()
- en: lowerButton.enable()
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: lowerButton.enable()
- en: higherButton.enable()
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: higherButton.enable()
- en: 'if higherButton.handleEvent(event):'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '如果higherButton.handleEvent(event):'
- en: gameOver = oGame.hitHigherOrLower(HIGHER)
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: gameOver = oGame.hitHigherOrLower(HIGHER)
- en: 'if gameOver:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '如果gameOver:'
- en: higherButton.disable()
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: higherButton.disable()
- en: lowerButton.disable()
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: lowerButton.disable()
- en: 'if lowerButton.handleEvent(event):'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '如果lowerButton.handleEvent(event):'
- en: gameOver = oGame.hitHigherOrLower(LOWER)
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: gameOver = oGame.hitHigherOrLower(LOWER)
- en: 'if gameOver:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '如果gameOver:'
- en: higherButton.disable()
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: higherButton.disable()
- en: lowerButton.disable()
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: lowerButton.disable()
- en: 8 - Do any "per frame" actions
  id: totrans-1071
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”操作
- en: 9 - Clear the window before drawing it again
  id: totrans-1072
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 在重新绘制之前清除窗口
- en: 4 background.draw()
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 4 background.draw()
- en: 10 - Draw the window elements
  id: totrans-1074
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制窗口元素
- en: Tell the game to draw itself
  id: totrans-1075
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告诉游戏绘制自身
- en: 5 oGame.draw()
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 5 oGame.draw()
- en: Draw remaining user interface components
  id: totrans-1077
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制剩余的用户界面组件
- en: newGameButton.draw()
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: newGameButton.draw()
- en: higherButton.draw()
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: higherButton.draw()
- en: lowerButton.draw()
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: lowerButton.draw()
- en: quitButton.draw()
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: quitButton.draw()
- en: Card Games **273**
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: Card Games **273**
- en: 11 - Update the window
  id: totrans-1083
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-1085
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微放慢一下
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 12-3: The main code of the Higher or Lower game*'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-3：Higher or Lower 游戏的主代码*'
- en: The main program loads the background image and builds four but-
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序加载背景图像并构建四个按钮-
- en: tons 1, then instantiates the Game object 2\.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为1，则实例化Game对象2\。
- en: In the main loop, we listen for any of the buttons being pressed 3, and
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，我们监听按钮的按下事件3，且
- en: when one is, we call the appropriate method in the Game object.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 当其中一个被触发时，我们调用Game对象中的相应方法。
- en: At the bottom of the loop, we draw the window elements 4, starting
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环底部，我们绘制窗口元素4，从
- en: with the background. Most significantly, we call the draw() method of the
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 带有背景。最重要的是，我们调用了`draw()`方法
- en: Game object 5\. As you will see, the Game object passes this message on to each
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: Game对象5\。正如你所见，Game对象将此消息传递给每个
- en: of the Card objects. Finally, we draw all four buttons.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: Card对象的最终绘制。最后，我们绘制所有四个按钮。
- en: '***Game Object***'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '***游戏对象***'
- en: The Game object handles the actual game logic. Listing 12-4 contains the
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: Game对象处理实际游戏逻辑。列表12-4包含了
- en: code of the Game class.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: Game类的代码。
- en: '**File: HigherOrLower/Game.py**'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：HigherOrLower/Game.py**'
- en: Game class
  id: totrans-1100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Game类
- en: import pygwidgets
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: from Constants import *
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: from Constants import *
- en: from Deck import *
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: from Deck import *
- en: from Card import *
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: from Card import *
- en: 'class Game():'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Game():'
- en: CARD_OFFSET = 110
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: CARD_OFFSET = 110
- en: CARDS_TOP = 300
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: CARDS_TOP = 300
- en: CARDS_LEFT = 75
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: CARDS_LEFT = 75
- en: NCARDS = 8
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: NCARDS = 8
- en: POINTS_CORRECT = 15
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: POINTS_CORRECT = 15
- en: POINTS_INCORRECT = 10
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: POINTS_INCORRECT = 10
- en: 'def __init__(self, window): 1'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window): 1'
- en: self.window = window
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.oDeck = Deck(self.window)
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: self.oDeck = Deck(self.window)
- en: self.score = 100
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: self.score = 100
- en: self.scoreText = pygwidgets.DisplayText(window, (450, 164),
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: self.scoreText = pygwidgets.DisplayText(window, (450, 164),
- en: '''Score: '' + str(self.score),'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '''Score: '' + str(self.score),'
- en: fontSize=36, textColor=WHITE,
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=36, textColor=WHITE,
- en: justified='right')
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: justified='right')
- en: self.messageText = pygwidgets.DisplayText(window, (50, 460),
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: self.messageText = pygwidgets.DisplayText(window, (50, 460),
- en: ''''', width=900, justified=''center'','
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: ''''', width=900, justified=''center'','
- en: fontSize=36, textColor=WHITE)
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=36, textColor=WHITE)
- en: self.loserSound = pygame.mixer.Sound("sounds/loser.wav")
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: self.loserSound = pygame.mixer.Sound("sounds/loser.wav")
- en: '**274** Chapter 12'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '**274** 第12章'
- en: self.winnerSound = pygame.mixer.Sound("sounds/ding.wav") self.cardShuffleSound
    = pygame.mixer.Sound("sounds/cardShuffle.wav")
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: self.winnerSound = pygame.mixer.Sound("sounds/ding.wav") self.cardShuffleSound
    = pygame.mixer.Sound("sounds/cardShuffle.wav")
- en: self.cardXPositionsList = []
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: self.cardXPositionsList = []
- en: thisLeft = Game.CARDS_LEFT
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: thisLeft = Game.CARDS_LEFT
- en: Calculate the x positions of all cards, once
  id: totrans-1128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算所有卡片的 x 位置，一次性完成
- en: 'for cardNum in range(Game.NCARDS):'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 'for cardNum in range(Game.NCARDS):'
- en: self.cardXPositionsList.append(thisLeft)
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: self.cardXPositionsList.append(thisLeft)
- en: thisLeft = thisLeft + Game.CARD_OFFSET
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: thisLeft = thisLeft + Game.CARD_OFFSET
- en: 'self.reset() # start a round of the game'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.reset() # 开始一轮游戏'
- en: 'def reset(self): 2 # this method is called when a new round starts'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 'def reset(self): 2 # 这个方法在新一轮开始时被调用'
- en: self.cardShuffleSound.play()
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: self.cardShuffleSound.play()
- en: self.cardList = []
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: self.cardList = []
- en: self.oDeck.shuffle()
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: self.oDeck.shuffle()
- en: 'for cardIndex in range(0, Game.NCARDS): # deal out cards'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 'for cardIndex in range(0, Game.NCARDS): # 发牌'
- en: oCard = self.oDeck.getCard()
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: oCard = self.oDeck.getCard()
- en: self.cardList.append(oCard)
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: self.cardList.append(oCard)
- en: thisXPosition = self.cardXPositionsList[cardIndex]
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: thisXPosition = self.cardXPositionsList[cardIndex]
- en: oCard.setLoc((thisXPosition, Game.CARDS_TOP))
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: oCard.setLoc((thisXPosition, Game.CARDS_TOP))
- en: self.showCard(0)
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: self.showCard(0)
- en: self.cardNumber = 0
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: self.cardNumber = 0
- en: self.currentCardName, self.currentCardValue = \
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: self.currentCardName, self.currentCardValue = \
- en: self.getCardNameAndValue(self.cardNumber)
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: self.getCardNameAndValue(self.cardNumber)
- en: self.messageText.setValue('Starting card is ' + self.currentCardName +
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: self.messageText.setValue('起始牌是 ' + self.currentCardName +
- en: '''. Will the next card be higher or lower?'')'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '''. 下一张牌会更大还是更小？'')'
- en: 'def getCardNameAndValue(self, index):'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getCardNameAndValue(self, index):'
- en: oCard = self.cardList[index]
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: oCard = self.cardList[index]
- en: theName = oCard.getName()
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: theName = oCard.getName()
- en: theValue = oCard.getValue()
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: theValue = oCard.getValue()
- en: return theName, theValue
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: return theName, theValue
- en: 'def showCard(self, index):'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 'def showCard(self, index):'
- en: oCard = self.cardList[index]
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: oCard = self.cardList[index]
- en: oCard.reveal()
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: oCard.reveal()
- en: 'def hitHigherOrLower(self, higherOrLower): 3'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 'def hitHigherOrLower(self, higherOrLower): 3'
- en: self.cardNumber = self.cardNumber + 1
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: self.cardNumber = self.cardNumber + 1
- en: self.showCard(self.cardNumber)
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: self.showCard(self.cardNumber)
- en: nextCardName, nextCardValue = self.getCardNameAndValue(self.cardNumber)
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: nextCardName, nextCardValue = self.getCardNameAndValue(self.cardNumber)
- en: 'if higherOrLower == HIGHER:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 'if higherOrLower == HIGHER:'
- en: 'if nextCardValue > self.currentCardValue:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 'if nextCardValue > self.currentCardValue:'
- en: self.score = self.score + Game.POINTS_CORRECT
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: self.score = self.score + Game.POINTS_CORRECT
- en: self.messageText.setValue('Yes, the ' + nextCardName + ' was higher')
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: self.messageText.setValue('是的，' + nextCardName + ' 更大')
- en: self.winnerSound.play()
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: self.winnerSound.play()
- en: 'else:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: self.score = self.score – Game.POINTS_INCORRECT
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: self.score = self.score – Game.POINTS_INCORRECT
- en: self.messageText.setValue('No, the ' + nextCardName + ' was not higher')
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: self.messageText.setValue('不，' + nextCardName + ' 并不更大')
- en: self.loserSound.play()
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: self.loserSound.play()
- en: Card Games **275**
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片游戏 **275**
- en: 'else: # user hit the Lower button'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 'else: # 用户点击了“更小”按钮'
- en: 'if nextCardValue < self.currentCardValue:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 'if nextCardValue < self.currentCardValue:'
- en: self.score = self.score + Game.POINTS_CORRECT
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: self.score = self.score + Game.POINTS_CORRECT
- en: self.messageText.setValue('Yes, the ' + nextCardName + ' was lower')
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: self.messageText.setValue('是的，' + nextCardName + ' 更小')
- en: self.winnerSound.play()
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: self.winnerSound.play()
- en: 'else:'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: self.score = self.score – Game.POINTS_INCORRECT
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: self.score = self.score – Game.POINTS_INCORRECT
- en: self.messageText.setValue('No, the ' + nextCardName + ' was not lower')
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: self.messageText.setValue('不，' + nextCardName + ' 并不更小')
- en: self.loserSound.play()
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: self.loserSound.play()
- en: 'self.scoreText.setValue(''Score: '' + str(self.score))'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.scoreText.setValue(''分数: '' + str(self.score))'
- en: 'self.currentCardValue = nextCardValue # set up for the next card'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.currentCardValue = nextCardValue # 为下一张牌设置'
- en: 'done = (self.cardNumber == (Game.NCARDS - 1)) # did we reach the last card?'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 'done = (self.cardNumber == (Game.NCARDS - 1)) # 我们是否已经到达最后一张牌？'
- en: return done
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: return done
- en: 'def draw(self): 4'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw(self): 4'
- en: Tell each card to draw itself
  id: totrans-1184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告诉每一张牌自己绘制自己
- en: 'for oCard in self.cardList:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 'for oCard in self.cardList:'
- en: oCard.draw()
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: oCard.draw()
- en: self.scoreText.draw()
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: self.scoreText.draw()
- en: self.messageText.draw()
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: self.messageText.draw()
- en: '*Listing 12-4: The Game object that runs the game*'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-4：运行游戏的 Game 对象*'
- en: In the __init__() method 1, we initialize a number of instance variables
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 __init__() 方法 1 中，我们初始化了多个实例变量
- en: that only need to be set up once. We create the Deck object, set the starting
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 这只需要设置一次。我们创建Deck对象并设置起始
- en: score, and create a DisplayText object for displaying the score and the result
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 分数，并创建了一个 DisplayText 对象，用于显示分数和结果
- en: of each move. We also load a number of sound files for use during play.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步的操作。我们还加载了若干个音频文件供游戏过程中使用。
- en: Lastly, we call the reset() method 2, which contains any code needed for
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用了 reset() 方法 2，其中包含了新一轮所需的任何代码
- en: 'one play of the game: that is, to shuffle the deck, play the shuffling sound,'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的一次操作：也就是说，洗牌，播放洗牌音效，
- en: deal out eight cards, display them in previously computed positions, and
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 发牌八张卡片，将它们显示在之前计算的位置，并
- en: show the face of the first card.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 显示第一张卡片的正面。
- en: When the user presses the Higher or Lower button, the main code calls
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下“Higher”或“Lower”按钮时，主程序调用
- en: hitHigherOrLower() 3, which turns over the next card, compares the value
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: hitHigherOrLower() 3，它翻转下一张卡片，比较值
- en: with the previous face-up card, and awards or subtracts points.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的正面朝上的卡片一起，并奖励或扣除积分。
- en: The draw() method 4 iterates through all the cards in the current game,
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: draw() 方法 4 遍历当前游戏中的所有卡片，
- en: telling each to draw itself (by calling each Card object’s draw() method). It
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉每个对象绘制自己（通过调用每个 Card 对象的 draw() 方法）。它
- en: then draws the text of the score and the feedback for the current move.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后绘制当前回合的分数和反馈文本。
- en: '**Testing with __name__**'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 __name__ 进行测试**'
- en: When you write a class, it’s always a good idea to write some test code
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写类时，最好编写一些测试代码
- en: to ensure that an object created from that class will work correctly. As a
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 确保从该类创建的对象能正确工作。作为一个
- en: reminder, any file containing Python code is called a *module*. A standard
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：任何包含 Python 代码的文件都称为 *模块*。一个标准的
- en: practice is to write one or more classes in a module, then use an import
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 常见做法是编写一个或多个类在一个模块中，然后使用 import
- en: statement to bring that module into some other module. When you write a
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 声明语句将该模块引入另一个模块。当你编写一个
- en: module that contains a class (or classes), you can add some test code that’s
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一个类（或多个类）的模块，你可以添加一些测试代码，
- en: '**276** Chapter 12'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '**276** 第12章'
- en: intended to run *only* when the module is run as the main program, and doesn’t
    run in the typical case when the module is imported by another
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在模块作为主程序运行时执行，而在模块被其他模块导入时不会运行，
- en: Python file.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: Python 文件。
- en: In a project with multiple Python modules, you typically have one main
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个包含多个 Python 模块的项目中，你通常会有一个主模块
- en: module and several other modules. When your program runs, Python cre-
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 和多个其他模块。当你的程序运行时，Python 会创建
- en: ates the special variable __name__ in every module. In whichever module is
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个模块中，Python 都会创建一个特殊变量 __name__。无论哪个模块
- en: given control first, Python sets the value of __name__ to the string '__main__'.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制权交给第一个时，Python 会将 __name__ 的值设置为字符串 '__main__'。
- en: Therefore, you can write code to check the value of __name__ and execute
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以编写代码检查 __name__ 的值，并执行
- en: some test code only if a module is running as the main program.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当模块作为主程序运行时，才执行一些测试代码。
- en: I’ll use the Deck class as an example. At the end of *Deck.py*, after the
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以 Deck 类为例。在 *Deck.py* 的结尾，在
- en: code of the class, I’ve added this code to create an instance of the Deck class
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 类的代码，我已经添加了这段代码来创建 Deck 类的实例
- en: 'and print out the cards that it creates:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 并输出它创建的卡片：
- en: '--- snip code of the Deck class ---'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 截取 Deck 类的代码 ---'
- en: 'if __name__ == ''__main__'':'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: Main code to test the Deck class
  id: totrans-1225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主程序测试 Deck 类
- en: import pygame
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: Constants
  id: totrans-1227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: WINDOW_WIDTH = 100
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 100
- en: WINDOW_HEIGHT = 100
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 100
- en: pygame.init()
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: oDeck = Deck(window)
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: oDeck = Deck(window)
- en: 'for i in range(1, 53):'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(1, 53):'
- en: oCard = oDeck.getCard()
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: oCard = oDeck.getCard()
- en: 'print(''Name: '', oCard.getName(), '' Value:'', oCard.getValue())'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(''姓名: '', oCard.getName(), '' 值:'', oCard.getValue())'
- en: This checks if the *Deck.py* file is running as the main program. In the
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查 *Deck.py* 文件是否作为主程序运行。在
- en: typical case where the Deck class is imported by some other module, the
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: typical情况下，Deck 类由其他模块导入，
- en: value of __name__ will be 'Deck', so this code does nothing. But if we run
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: __name__ 的值将是 'Deck'，所以这段代码什么也不做。但如果我们运行
- en: '*Deck.py* as the main program, for testing purposes only, Python sets the'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '*Deck.py* 作为主程序运行时，仅用于测试，Python 设置'
- en: value of __name__ to '__main__' and this test code runs.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 将 __name__ 的值设置为 '__main__'，然后这段测试代码运行。
- en: In the test code, we build a minimal pygame program that creates
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码中，我们构建了一个最小化的pygame程序，创建了
- en: an instance of the Deck class, then prints out the name and value of all 52
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: Deck 类的实例，然后打印出所有 52 张卡片的名称和值
- en: 'cards. The output of running *Deck.py* as the main program looks like this
    in the shell or console window:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片。运行 *Deck.py* 作为主程序时，输出在终端或控制台窗口中如下所示：
- en: 'Name: 4 of Spades Value: 4'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '姓名: 4 的黑桃 值: 4'
- en: 'Name: 4 of Diamonds Value: 4'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '姓名: 4 的钻石 值: 4'
- en: 'Name: Jack of Hearts Value: 11'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '姓名: 红心杰克 值: 11'
- en: 'Name: 8 of Spades Value: 8'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '姓名: 8 的黑桃 值: 8'
- en: 'Name: 10 of Diamonds Value: 10'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '姓名: 10 的钻石 值: 10'
- en: 'Name: 3 of Clubs Value: 3'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '姓名: 3 的梅花 值: 3'
- en: 'Name: Jack of Diamonds Value: 11'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '姓名: 钻石杰克 值: 11'
- en: 'Name: 9 of Spades Value: 9'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Ace of Diamonds Value: 1'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: 2 of Clubs Value: 2'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: 7 of Clubs Value: 7'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: Card Games **277**
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: 4 of Clubs Value: 4'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: 8 of Hearts Value: 8'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: 3 of Diamonds Value: 3'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: 7 of Spades Value: 7'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: 7 of Diamonds Value: 7'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: King of Diamonds Value: 13'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: 10 of Spades Value: 10'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Ace of Hearts Value: 1'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: 8 of Diamonds Value: 8'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: Queen of Diamonds Value: 12'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: Code like this is useful for testing that the class is generally working as
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: we expect, without having to deal with a larger main program to instanti-
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: ate it. It gives us a quick way to make sure the class isn’t broken. Depending
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: on our needs, we could go further and add some example code to illustrate
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: typical calls to the methods of the class.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Card Games**'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: There are many card games that use a standard 52-card deck. We could
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: use the Deck and Card classes as is to build games like Bridge, Hearts, Gin
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: Rummy, and most Solitaire games. However, there are some card games
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: that use different card values or different numbers of cards. Let’s look at
    a
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: few examples and see how our classes could be adapted for these cases.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: '***Blackjack Deck***'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: While a deck for Blackjack, also known as 21, uses the same cards as a stan-
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: 'dard deck, the *values* of the cards are different: the card values for 10,
    jack, queen, and king are all 10\. The __init__() method of the Deck class starts'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: 'like this:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, rankValueDict=STANDARD_DICT):'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: To create a Blackjack deck, you would only need to supply a different
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: 'dictionary for rankValueDict, like this:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: blackJackDict = {'Ace':1, '2':2, '3':3, '4':4, '5':5,
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: '''6'':6, ''7'':7, ''8'': 8, ''9'':9, ''10'':10,'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: '''Jack'':10, ''Queen'':10, ''King'':10}'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: oBlackjackDeck = Deck(window, rankValueDict=blackJackDict)
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: Once you create the oBlackjackDeck this way, you can then call the exist-
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: ing shuffle() and getCard() methods with no change. In the implementation
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: of Blackjack, you would also have to deal with the fact that an ace can have
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: a value of 1 or 11\. But that, as we say, is an exercise left to the reader!
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: '**278** Chapter 12'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: '***Games with Unusual Card Decks***'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of card games that do not use a standard deck of 52
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: cards. The game of canasta requires at least two decks with jokers, for a
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: total of 108 cards. A pinochle deck consists of two copies of 9, 10, jack,
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: queen, king, and ace for each suit, for a total of 48 cards.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: For games like these, you could still use the Deck class, but you would
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: need to create a subclass with Deck as the base class. The new CanastaDeck
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: or PinochleDeck class would need to have its own __init__() method that
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: builds a deck as a list consisting of the appropriate Card objects. However,
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: the shuffle() and getCard() methods could be inherited from the Deck class.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, a CanastaDeck or PinochleDeck class would subclass the Deck class
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: and consist of only an __init__() method.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we built a GUI version of the Higher or Lower card game
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: fro[m Chapter 1 u](index_split_000.html#p32)sing highly reusable Deck and Card
    classes. The main code instantiates a Game object, which creates a Deck object
    that instantiates 52 Card
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 [第 1 章](index_split_000.html#p32) 使用高度可重用的 Deck 和 Card 类。主程序实例化一个 Game 对象，它创建一个
    Deck 对象，后者实例化 52 张 Card
- en: objects, one for each card in the resulting deck. Each Card object is respon-
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 对象，每张卡片都会在结果牌组中有一个。每个 Card 对象负责
- en: sible for drawing its appropriate image in the window and can respond to
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 负责在窗口中绘制相应图像，并能响应
- en: queries about its name, rank, suit, and value. The Game class, which contains
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 关于它的名称、等级、花色和数值的查询。Game 类包含
- en: the logic of the game, is separate from the main code, which runs the
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的逻辑与主代码是分开的，后者运行的是
- en: main loop.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环。
- en: I demonstrated how Python creates a special variable called __name__
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 我演示了 Python 如何创建一个叫做 __name__ 的特殊变量
- en: and gives it different values depending on whether a file is being run as
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 并根据文件是否作为主程序运行，赋予其不同的值
- en: the main program or not. You can use this feature to add some test code
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序或不包含。你可以利用这个功能添加一些测试代码
- en: that runs when you run the file as a main program (to test the code in the
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将文件作为主程序运行时（用于测试代码）
- en: module), but will not run in the typical case when the file is imported by
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 模块），但在文件被作为模块导入时通常不会运行
- en: another module.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个模块。
- en: Finally, I showed how you can build different types of card decks,
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我展示了如何构建不同类型的卡片牌组，
- en: depending on how different they are from the Deck class.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据它们与 Deck 类的差异来进行调整。
- en: Card Games **279**
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 卡牌游戏 **279**
- en: '**13**'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: '**13**'
- en: '**T I M E R S**'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: '**计时器**'
- en: This chapter is about timers. A *timer*
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的是计时器。一个 *计时器*
- en: allows your program to count or wait for
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你的程序进行计数或等待
- en: a given amount of time before moving on
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前的给定时间
- en: to perform some other action. In the world of
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 执行其他操作。在
- en: text-based Python programs, this is easily achieved
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文本的 Python 程序，这很容易实现
- en: with time.sleep() by specifying a number of seconds
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 time.sleep() 来指定秒数
- en: to sleep. To pause for two and a half seconds, you
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序暂停。为了暂停两秒半，你
- en: 'could write:'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 可以写成：
- en: import time
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: import time
- en: time.sleep(2.5)
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(2.5)
- en: However, in the world of pygame, and event-driven programming in
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 pygame 世界里，以及事件驱动编程中，
- en: general, the user should always be able to interact with the program, so
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，用户应该始终能够与程序进行交互，所以
- en: pausing in this way is inappropriate. A call to time.sleep() would make the
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式暂停是不合适的。调用 time.sleep() 会使得
- en: program nonreactive during the sleeping period.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 在睡眠期间，程序将变得无响应。
- en: '![Image 35](index-311_1.png)'
  id: totrans-1339
  prefs: []
  type: TYPE_IMG
  zh: '![图 35](index-311_1.png)'
- en: '![Image 36](index-311_2.png)'
  id: totrans-1340
  prefs: []
  type: TYPE_IMG
  zh: '![图 36](index-311_2.png)'
- en: Instead, the main loop needs to continue to run at whatever frame
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，主循环需要继续以任意帧速率运行
- en: rate you have chosen. You need a way for the program to continue to loop,
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的速率。你需要一种方式让程序继续循环，
- en: but also count time from a given starting point to some time in the future.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 但也能从给定的起点计时到未来某个时间。
- en: 'There are three different ways this can be accomplished:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过三种不同的方法实现：
- en: • Measure time by counting frames.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过计算帧数来衡量时间。
- en: • Use pygame to create an event that is issued in the future.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 pygame 创建一个将来触发的事件。
- en: • Remember a start time and continuously check for the elapsed time.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: • 记住开始时间，并持续检查已过去的时间。
- en: I will quickly discuss the first two, but I’ll focus on the third, as it pro-
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 我会简要讨论前两者，但我会重点讲解第三种方法，因为它提供了
- en: vides the cleanest and most accurate approach.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 提供最简洁且最准确的方法。
- en: '**Timer Demonstration Program**'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '**计时器演示程序**'
- en: To illustrate the different approaches, I’ll use different implementations of
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示不同的方法，我将使用不同实现的
- en: the test program shown in Figure 13-1\.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 13-1 所示的测试程序。
- en: '*Figure 13-1: The timer demonstration program*'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：计时器演示程序*'
- en: When the user clicks Start, a 2.5-second timer starts and the window
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击开始时，2.5 秒的计时器开始，窗口
- en: changes to look like Figure 13-2\.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 会变更为如图 13-2 所示的样式\。
- en: '*Figure 13-2: The message displayed while the timer is running*'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：计时器运行时显示的消息*'
- en: For two and a half seconds, the Start button becomes disabled and a
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 在两秒半的时间内，开始按钮会被禁用，窗口
- en: message is displayed below the buttons. When the time expires, the mes-
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 消息会显示在按钮下方。当时间到期时，消息消失，
- en: sage goes away and the Start button is re-enabled. Independent of the timer
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 消息消失，开始按钮重新启用。与计时器
- en: running, anything else that the user wants to do in the program still needs
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行时，用户在此期间希望做的其他操作仍然需要
- en: to be responsive. In this example, clicking Click Me prints a message to the
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 以响应为目标。在这个示例中，点击“点击我”会打印一条消息到
- en: shell window, whether the timer is running or not.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: shell 窗口，无论计时器是否正在运行。
- en: '**282** Chapter 13'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '**282** 第 13 章'
- en: '**Three Approaches for Implementing Timers**'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现计时器的三种方法**'
- en: In this section, I’ll discuss three different approaches to implementing tim-
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将讨论实现计时器的三种不同方法。
- en: 'ers: counting frames, generating a pygame event, and checking for elapsed'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 方法：计数帧、生成 pygame 事件，并检查经过的时间。
- en: time. To make these concepts clear, the following code examples are built
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 时间。为了使这些概念更加清晰，以下代码示例进行了构建
- en: directly in the main loop.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在主循环中。
- en: '***Counting Frames***'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '***计数帧***'
- en: A straightforward approach to creating a timer is to count the number of
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 创建计时器的一个直接方法是计数
- en: frames that go by. One frame is the same as one loop iteration. If you know
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 经过的帧数。如果你知道
- en: the frame rate of a program, you can calculate how long to wait by multiply-
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的帧率，你可以通过将帧率乘以来计算等待的时间
- en: ing the time to wait by the frame rate. The following code shows the key
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 根据帧率计算等待的时间。以下代码展示了关键
- en: 'parts of the implementation:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的各个部分：
- en: '**File: InLineTimerExamples/CountingFrames.py**'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：InLineTimerExamples/CountingFrames.py**'
- en: 'FRAMES_PER_SECOND = 30 # takes 1/30th of a second for each frame'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 'FRAMES_PER_SECOND = 30 # 每帧需要 1/30 秒'
- en: TIMER_LENGTH = 2.5
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: TIMER_LENGTH = 2.5
- en: '--- snip ---'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 略 ---'
- en: timerRunning = False
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: timerRunning = False
- en: 'This code shows what happens when the user clicks the Start button:'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了用户点击“开始”按钮时会发生什么：
- en: 'if startButton.handleEvent(event):'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 startButton.handleEvent(event):'
- en: timerRunning = True
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: timerRunning = True
- en: 'nFramesElapsed = 0 # initialize a counter'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 'nFramesElapsed = 0 # 初始化计数器'
- en: nFramesToWait = int(FRAMES_PER_SECOND * TIMER_LENGTH)
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: nFramesToWait = int(FRAMES_PER_SECOND * TIMER_LENGTH)
- en: startButton.disable()
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: startButton.disable()
- en: timerMessage.show()
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: timerMessage.show()
- en: The program calculates that it should wait for 75 frames (2.5 seconds
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 程序计算出它应该等待 75 帧（即 2.5 秒）
- en: × 30 frames per second), and we set timerRunning to True to indicate that the
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: × 每秒 30 帧），并将 timerRunning 设置为 True，表示
- en: timer has started. Inside the main loop, we use this code to check for when
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器已经启动。在主循环中，我们使用这段代码来检查何时
- en: 'the timer ends:'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器结束时：
- en: 'if timerRunning:'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 timerRunning:'
- en: 'nFramesElapsed = nFramesElapsed + 1 # increment the counter'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 'nFramesElapsed = nFramesElapsed + 1 # 增加计数器'
- en: 'if nFramesElapsed >= nFramesToWait:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 nFramesElapsed >= nFramesToWait:'
- en: startButton.enable()
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: startButton.enable()
- en: timerMessage.hide()
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: timerMessage.hide()
- en: print('Timer ended by counting frames')
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: print('计时器通过计数帧结束')
- en: timerRunning = False
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: timerRunning = False
- en: When the timer ends, we re-enable the Start button, hide the message,
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 当计时器结束时，我们重新启用“开始”按钮，隐藏消息，
- en: and reset the timerRunning variable. (If you prefer, you could set the count
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 并重置 timerRunning 变量。（如果你愿意，你可以设置计数器）
- en: to the number of frames to wait and count down to zero instead.) This
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 而是根据帧数来等待并倒计时到零。）这个
- en: approach works fine, but it is tied to the program’s frame rate.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法效果不错，但它依赖于程序的帧率。
- en: Timers **283**
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器 **283**
- en: '***Timer Event***'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '***计时器事件***'
- en: As a second approach, we’ll take advantage of pygame’s built-in timer.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二种方法，我们将利用 pygame 内置的计时器。
- en: Pygame allows you to add a new event to the event queue—this is known
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 允许你向事件队列添加一个新的事件——这被称为
- en: as *posting* an event. Specifically, we’ll ask pygame to create and post a timer
    event. We only need to specify how far into the future we want the event to
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 就是*发布*一个事件。具体来说，我们将请求 pygame 创建并发布一个计时器事件。我们只需要指定希望事件发生的未来时间。
- en: happen. After the given amount of time, pygame will issue a timer event in
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发生。给定时间后，pygame 会在事件队列中发出计时器事件
- en: the main loop, in the same way that it issues other standard events such as
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，类似于它发出其他标准事件（例如
- en: KEYUP, KEYDOWN, MOUSEBUTTONUP, MOUSEBUTTONDOWN, and so on. Your code will need
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: KEYUP、KEYDOWN、MOUSEBUTTONUP、MOUSEBUTTONDOWN 等。你的代码需要
- en: to look for and react to this type of event.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 去寻找并响应这种类型的事件。
- en: The following documentation is fro[m *https://www.pygame.org/docs/ref/*](https://www.pygame.org/docs/ref/time.html)
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文档来源于[*https://www.pygame.org/docs/ref/*](https://www.pygame.org/docs/ref/time.html)
- en: '[*time.html*:](https://www.pygame.org/docs/ref/time.html)'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '[*time.html*:](https://www.pygame.org/docs/ref/time.html)'
- en: pygame.time.set_timer()
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.time.set_timer()
- en: '*Repeatedly create an event on the event queue*'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: '*重复在事件队列中创建事件*'
- en: set_timer(eventid, milliseconds) -> None
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: set_timer(eventid, milliseconds) -> None
- en: set_timer(eventid, milliseconds, once) -> None
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: set_timer(eventid, milliseconds, once) -> None
- en: Set an event type to appear on the event queue every given number of
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个事件类型，在事件队列中每隔指定的帧数出现
- en: milliseconds. The first event will not appear until the amount of time
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: has passed.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: Every event type can have a separate timer attached to it. It is best to
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: use the value between pygame.USEREVENT and pygame.NUMEVENTS.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: To disable the timer for an event, set the milliseconds argument to 0\.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: If the once argument is True, then only send the timer once.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: Every event type in pygame is represented by unique identifier. As of
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: pygame 2.0, you can now make a call to pygame.event.custom_type() to get an
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: identifier for a custom event.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: '**File: InLineTimerExamples /TimerEvent.py**'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: 'TIMER_EVENT_ID = pygame.event.custom_type() # new in pygame 2.0'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: 'TIMER_LENGTH = 2.5 # seconds'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks Start, the code creates and posts the timer event:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: 'if startButton.handleEvent(event):'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: pygame.time.set_timer(TIMER_EVENT_ID,
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: int(TIMER_LENGTH * 1000), True)
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip disable button, show message ---'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: The value calculated is 2,500 milliseconds. True means that the timer
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: should only run once (generate only one event). We now need code in the
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: 'event loop that checks for the event happening:'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == TIMER_EVENT_ID:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip enable button, hide message ---'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: '**284** Chapter 13'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: Since we specified True in the call to set the timer, this event is issued only
    once. If we want to repeat events every 2,500 milliseconds, we could set
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: the last argument in the original call to False (or just let it default to False).
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: To end repeated timer events, we would make a call to set_timer() and pass
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: 0 (zero) as the second argument.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: '***Building a Timer by Calculating Elapsed Time***'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: The third approach for implementing a timer uses the current time as a
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: starting point. We can then continuously query the current time and per-
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: form a simple subtraction to calculate the elapsed time. The code shown
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: for this example runs in the main loop; later, we’ll extract the timer-related
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: code and build a reusable Timer class.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: 'The time module of the Python Standard Library has this function:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: time.time()
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: Calling this function returns the current time in seconds as a floating-
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: point number. The value returned is the number of seconds that have passed
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: since “epoch time,” which is defined as 00:00:00 UTC on January 1, 1970\.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: The code in Listing 13-1 creates a timer by remembering the time when
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: the user clicks Start. While the timer is running, we check in every frame to
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: see if the desired amount of time has elapsed. You’ve already seen the user
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: interface, so I’ll omit those details and some of the setup code for brevity.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: '**File: InLineTimerExamples/ElapsedTime.py**'
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: Timer in the main loop
  id: totrans-1461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: 'TIMER_LENGTH = 2.5 # seconds'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: timerRunning = False
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-1466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-1468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: '1 if startButton.handleEvent(event):'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: 'timeStarted = time.time() # remember the start time'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: startButton.disable()
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: timerMessage.show()
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: print('Starting timer')
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: timerRunning = True
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: Timers **285**
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: 'if clickMeButton.handleEvent(event):'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: print('Other button was clicked')
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-1482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 if timerRunning: # if the timer is running'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: elapsed = time.time() - timeStarted
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: '3 if elapsed >= TIMER_LENGTH: # True here means timer has ended'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: startButton.enable()
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: timerMessage.hide()
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: print('Timer ended')
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: timerRunning = False
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window
  id: totrans-1490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(WHITE)
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  id: totrans-1492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: headerMessage.draw()
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: startButton.draw()
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: clickMeButton.draw()
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: timerMessage.draw()
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-1497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-1499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-1: A timer built into the main loop*'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: 'The important variables to notice in this program are:'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: '**TIMER_LENGTH** A constant that says how long we want our timer to run'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: '**timerRunning** A Boolean that tells us whether the timer is running'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: '**timeStarted** The time at which the user pressed the Start button'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks Start, timerRunning is set to True 1\. We initialize the
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: variable startTime to the current time. We then disable the Start button and
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: show the message below the buttons.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: Each time through the loop, if the timer is running 2, we subtract
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: the starting time from the current time to see how much time has elapsed
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: since the timer started. When the amount of time elapsed becomes greater
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: than or equal to TIMER_LENGTH, whatever action we want to happen when the
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: time is up can happen. In this sample program, we enable the Start but-
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: ton, remove the bottom message, print a short text output, and reset the
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: timerRunning variable to False 3\.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: The code in Listing 13-1 works fine . . . for a single timer. However, this
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: is a book on object-oriented programming, so we want this to be scalable.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: To generalize the functionality, we’ll turn the timing code into a class.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: We’ll take the important variables, turn them into instance variables, and
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: split the code into methods. That way, we can define and use any number
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: '**286** Chapter 13'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: of timers in a program. The Timer class, along with other classes used to display
    timing in pygame programs, are available in a module named
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing pyghelpers**'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: To install pyghelpers, open the command line and enter the following two
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: 'commands:'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: '**python3 -m pip install -U pip --user**'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: '**python3 -m pip install -U pyghelpers --user**'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: These commands download and install pyghelpers from PyPI into a
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: folder that is available to all your Python programs. Once installed, you can
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: use pyghelpers by including the following statement at the beginning of your
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: 'programs:'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: import pyghelpers
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: You can then instantiate objects from the classes in the module and call
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: the methods of those objects. The most current documentation of pyghelpers
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: is at [*https://pyghelpers.readthedocs.io/en/latest/*](https://pyghelpers.readthedocs.io/en/latest/),
    and the source code is available via my GitHub repository at [*https://github.com/IrvKalb/pyghelpers/*](https://github.com/IrvKalb/pyghelpers).
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: '**The Timer Class**'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: Listing 13-2 contains the code of a very simple timer as a class. This code
    is
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: built into the pyghelpers package as the Timer class (I’ve omitted some of the
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: documentation here for brevity).
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: '**File: (Available as part of the pyghelpers module)**'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: Timer class
  id: totrans-1542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Timer():'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, timeInSeconds, nickname=None, callBack=None):'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: self.timeInSeconds = timeInSeconds
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: self.nickname = nickname
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: self.callBack = callBack
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: self.savedSecondsElapsed = 0.0
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: self.running = False
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: '2 def start(self, newTimeInSeconds=None):'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: Timers **287**
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: 'if newTimeInSeconds != None:'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: self.timeInSeconds = newTimeInSeconds
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: self.running = True
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: self.startTime = time.time()
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: '3 def update(self):'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: 'if not self.running:'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: return False
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: self.savedSecondsElapsed = time.time() - self.startTime
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.savedSecondsElapsed < self.timeInSeconds:'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: 'return False # running but hasn''t reached limit'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: 'else: # timer has finished'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: self.running = False
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.callBack is not None:'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: self.callBack(self.nickname)
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: 'return True # True here means that the timer has ended'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: '4 def getTime(self):'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.running:'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: self.savedSecondsElapsed = time.time() - self.startTime
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: return self.savedSecondsElapsed
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: '5 def stop(self):'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: '"""Stops the timer"""'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: 'self.getTime() # remembers final self.savedSecondsElapsed'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: self.running = False
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-2: A simple Timer class*'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: When you create a Timer object, the only required argument is the num-
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: ber of seconds you want the timer to run 1\. You can optionally supply a
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: nickname for the timer and a function or method to be called back when
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: the time has elapsed. If you specify a callback, the nickname will be passed
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: in when the callback happens.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: You call the start() method 2 to start the timer running. The Timer
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: object remembers the start time in the instance variable self.startTime.
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: The update() method 3 must be called every time through the main
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: loop. If the timer is running and the appropriate amount of time has
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: elapsed, this method returns True. In any other call, this method returns
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: False.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: If a Timer is running, calling getTime() 4 returns how much time has
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: elapsed for that Timer. You can call the stop() method 5 to immediately
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: stop the Timer.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: We can now rewrite the timer demonstration program shown in
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13-1 to use this Timer class from the pyghelpers package. Listing 13-3
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: shows how we use a Timer object in the code.
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: '**288** Chapter 13'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: '**File: TimerObjectExamples/SimpleTimerExample.py**'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: Simple timer example
  id: totrans-1599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: '1 oTimer = pyghelpers.Timer(TIMER_LENGTH) # create a Timer object'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-1602
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-1604
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: 'if startButton.handleEvent(event):'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: '2 oTimer.start() # start the timer'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: startButton.disable()
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: timerMessage.show()
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: print('Starting timer')
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: 'if clickMeButton.handleEvent(event):'
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: print('Other button was clicked')
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-1616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3 if oTimer.update(): # True here means timer has ended'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: startButton.enable()
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: timerMessage.hide()
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: print('Timer ended')
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the screen
  id: totrans-1621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(WHITE)
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all screen elements
  id: totrans-1623
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: headerMessage.draw()
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: startButton.draw()
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: clickMeButton.draw()
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: timerMessage.draw()
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the screen
  id: totrans-1628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-1630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-3: A main program that uses an instance of the Timer class*'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: Again, I’ve cut the setup code. Before the main loop starts, we create a
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: Timer object 1\. When the user clicks Start, we call oTimer.start() 2 to start
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: the timer running.
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: Timers **289**
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 37](index-319_1.png)'
  id: totrans-1637
  prefs: []
  type: TYPE_IMG
- en: Each time through the loop, we call the update() method of the Timer
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: object 3\. There are two ways to know when the timer ends. The simple
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: way is to check for this call returning True. The sample code in Listing 13-3
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: uses this approach. Alternatively, if we specified a value for callBack in the
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: __init__() call, when the timer finished, whatever was specified as the
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: callBack value would be called back. In most cases, I would suggest using
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: the first approach.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: There are two advantages to using a Timer class. First, it hides the details
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: of the timing code; you only create a Timer object when you want to, and
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: you call the methods of that object. Second, you can create as many Timer
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: objects as you wish, and each will run independently.
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: '**Displaying Time**'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: Many programs will need to count and display time to the user. For exam-
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: ple, in a game, the elapsed time might be constantly displayed and updated,
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: or the user might have a set amount of time to complete a task, requiring a
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: countdown timer. I’ll demonstrate how to do both of these using the Slider
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: Puzzle game pictured in Figure 13-3\.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13-3: The Slider Puzzle user interface*'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: When you start this game, the tiles are randomly rearranged, and there
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: is one empty black space. The goal of the game is to move tiles one at a time
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: to put them in order from 1 to 15\. You are only allowed to click a tile that
    is
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: horizontally or vertically adjacent to the empty square. Clicking a valid tile
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: swaps it with the space. I won’t get into the details of the full implementa-
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: tion of the game (although the source code is available online, with the rest
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: of the book’s resources). Instead, I will focus on how to integrate a timer.
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: The pyghelpers package contains two classes that allow programmers to
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: track time. The first is CountUpTimer, which starts at zero and counts up indef-
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: initely, or until you tell it to stop. The second is CountDownTimer, which starts
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: at a given amount of time and counts down to zero. I’ve built a version of
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: '**290** Chapter 13'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: the game for each. The first version lets the user see how long it takes them
    to solve the puzzle. In the second one, the user is given a certain amount of
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: time when they start the game, and if they have not completed it when the
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: timer reaches zero, they lose the game.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: '***CountUpTimer***'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: With the CountUpTimer class, you create a timer object and tell it when to
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: start. Then, in every frame, you can call one of three different methods to
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: get the time elapsed in different formats.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: Listing 13-4 contains the implementation of the CountUpTimer class from
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers. The code is a good example of how the different methods of a
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: class share instance variables.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: '**File: (Available as part of the pyghelpers module)**'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: CountUpTimer class
  id: totrans-1679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class CountUpTimer():'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self): 1'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: self.running = False
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: self.savedSecondsElapsed = 0.0
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: 'self.secondsStart = 0 # safeguard'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: 'def start(self): 2'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: 'self.secondsStart = time.time() # get the current seconds and save the value'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: self.running = True
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: self.savedSecondsElapsed = 0.0
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: 'def getTime(self): 3'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: '"""Returns the time elapsed as a float"""'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: 'if not self.running:'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: 'return self.savedSecondsElapsed # do nothing'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: self.savedSecondsElapsed = time.time() - self.secondsStart
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: 'return self.savedSecondsElapsed # returns a float'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: 'def getTimeInSeconds(self): 4'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: '"""Returns the time elapsed as an integer number of seconds"""'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: nSeconds = int(self.getTime())
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: return nSeconds
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: Updated version using fStrings
  id: totrans-1701
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def getTimeInHHMMSS(self, nMillisecondsDigits=0): 5'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: nSeconds = self.getTime()
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: mins, secs = divmod(nSeconds, 60)
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: hours, mins = divmod(int(mins), 60)
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: 'if nMillisecondsDigits > 0:'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: Timers **291**
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: secondsWidth = nMillisecondsDigits + 3
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: secondsWidth = 2
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: 'if hours > 0:'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: output =
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: f'{hours:d}:{mins:02d}:{secs:0{secondsWidth}.{nMillisecondsDigits}f}'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: 'elif mins > 0:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: output = f'{mins:d}:{secs:0{secondsWidth}.{nMillisecondsDigits}f}'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: output = f'{secs:.{nMillisecondsDigits}f}'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: return output
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: 'def stop(self): 6'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: '"""Stops the timer"""'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: 'self.getTime() # remembers final self.savedSecondsElapsed'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: self.running = False
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 13-4: The CountUpTimer class*'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation depends on three key instance variables 1:'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: • self.running is a Boolean that indicates whether the timer is running or
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: not.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: • self.savedSecondsElapsed is a float that represents the elapsed time of a
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: timer.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: • self.secondsStart is the time that the timer started running.
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: The client calls the start() method 2 to start a timer. In response, the
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: method calls time.time(), stores the start time in self.secondsStart, and sets
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: self.running to True to indicate that the timer is running.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: The client can call any of these three methods to get the elapsed time
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: 'associated with the timer, in different formats:'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: • getTime() 3 returns the elapsed time as a floating-point number.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: • getTimeInSeconds() 4 returns the elapsed time as an integer number of
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: seconds.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: • getTimeInHHMMSS() 5 returns the elapsed time as a formatted string.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: The getTime() method calls time.time() to get the current time and
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: subtracts the starting time to get the elapsed time. The other two meth-
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: ods each make a call to the getTime() method of this class to calculate the
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: 'elapsed time, then do different processing on the output: getTimeInSeconds()'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: converts the time into an integer number of seconds, and getTimeInHHMMSS()
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: formats the time into a string in *hours:minutes:seconds* format. The output
    of each of these methods is intended to be sent to a DisplayText object (defined
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: in the pygwidgets package) to be shown in the window.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: The stop() method 6 can be called to stop the timer (for example,
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: when the user completes the puzzle).
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: '**292** Chapter 13'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: The main file for this version of the Slider Puzzle game is available with the
    rest of the book’s resources, at *SliderPuzzles/Main_SliderPuzzleCountUp.py*.
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: It instantiates a CountUpTimer object before the main loop begins and saves
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: it in the variable oCountUpTimer. It then calls the start() method right away.
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: It also creates a DisplayText field to display the time. Each time through the
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: main loop, the main code calls the getTimeInHHMMSS() method and shows the
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: 'result in the field:'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: 'timeToShow = oCountUpTimer.getTimeInHHMMSS() # ask the Timer object for the
    elapsed time oTimerDisplay.setValue(''Time: '' + timeToShow) # put that into a
    text field'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: The variable oTimerDisplay is an instance of the pygwidgets.DisplayText
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: class. The setValue() method of the DisplayText class is optimized to check
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: whether the new text to be displayed is the same as the previous text.
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, even though we are telling the field to display the amount of
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: time 30 times every second, there is not much work done until the time
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: changes, once per second.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: The game code checks for a solved puzzle and, when the puzzle is
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: solved, calls the stop() method to freeze the time. If the user clicks the
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: Restart button to start a new game, the game calls start() to restart the
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: timer object.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: '***CountDownTimer***'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: The CountDownTimer class has some subtle differences. Instead of counting up
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: from zero, you initialize a CountDownTimer by providing a starting number of
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: seconds, and it counts down from that value. The interface for creating a
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: 'CountDownTimer looks like this:'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: CountDownTimer(nStartingSeconds, stopAtZero=True, nickname=None,
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: 'callBack=None):'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: There is a second optional parameter, stopAtZero, that defaults to True—
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: which assumes that you want the timer to stop when it reaches zero. You can
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: also optionally specify a function or method as a callback when the timer
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: reaches zero. Lastly, you can supply a nickname to be used if and when a
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: callback is made.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: The client calls the start() method to begin counting down.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: From the client’s point of view, the getTime(), getTimeInSeconds(),
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: getTimeInHHMMSS(), and stop() methods appear identical to their counter-
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: parts in the CountUpTimer class.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: CountDownTimer has an additional method named ended(). The applica-
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: tion needs to call the ended() method every time through its main loop. It
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: returns False while the timer is active, but returns True when the timer ends
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: (that is, reaches zero).
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: The countdown version of the Slider Puzzle game’s main file is available
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: with the book’s resources, at *SliderPuzzles/Main_SliderPuzzleCountDown.py*.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: The code is very similar to the previous version that counts up, but
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: this version creates an instance of CountDownTimer instead and supplies a set
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: Timers **293**
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: number of seconds it allows to solve the puzzle. It also calls getTimeInHHMMSS(2)
    every frame and updates the time with two decimal digits. Finally, it includes
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: a call to the ended() method in every frame to see if the time has run out.
    If
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: the timer ends before the user has solved the puzzle, it plays a sound and
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: displays a message telling the user that they ran out of time.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gave you a number of ways to handle timing in programs. I
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: 'discussed three different approaches: first by counting frames, second by'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: creating a custom event, and finally by remembering a start time and sub-
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: tracting it from the current time to get the time elapsed.
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: Using the third approach, we built a generic reusable Timer class (which
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: you can find in the pyghelpers package). I also showed two additional classes
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: from this package, CountUpTimer and CountDownTimer, that can be used to han-
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: dle timing in programs where you want to show a timer to the user.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: '**294** Chapter 13'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: '**14**'
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: '**A N I M A T I O N**'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about animation—
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: s pecifically, traditional image animation.
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: On a very simple level, you can think of
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: 'this like a flip-book: a series of images, each'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: slightly different from the previous one, that are
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: shown in succession. The user sees each image for a
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: short amount of time and experiences the illusion of
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: movement. Animation provides a good opportunity
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: for building a class because the mechanics of display-
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: ing the images over time are well understood and
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: easily coded.
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: To show the general principles, we’ll begin by implementing two anima-
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
- en: 'tion classes: a SimpleAnimation class based on a series of individual image
    files,'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: and a SimpleSpriteSheetAnimation class built using a single file that contains
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
- en: a sequence of many images. Then I’ll show you two more-robust animation classes
    from the pygwidgets package, Animation and SpriteSheetAnimation, and
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: explain how they are built using a common base class.
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: '**Building Animation Classes**'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind an animation class is relatively straightforward. The
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
- en: client will provide an ordered set of images and an amount of time. The cli-
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: ent code will tell the animation when to start playing and will periodically
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
- en: tell the animation to update itself. The images in the animation will be dis-
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: played in order, each for the given amount of time.
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
- en: '***SimpleAnimation Class***'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: The general technique is to begin by loading the complete set of images,
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: storing them in a list, and displaying the first image. When the client tells
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: the animation to start, the animation begins tracking time. Each time the
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: object is told to update itself, our code checks to see if the specified amount
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: of time has passed and, if so, displays the next image in the sequence.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: When the animation is finished, we display the first image again.
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Class**'
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-1 contains the code of a SimpleAnimation class, which handles an
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: animation made up of separate image files. To keep things clearly orga-
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: nized, I strongly recommend that you place all the image files associated
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: with an animation in a subfolder inside an *images* folder inside your project
    folder. The examples given here will use this structure, and the associated
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
- en: art and main code are available with the rest of the book’s resources.
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: '**File: SimpleAnimation/SimpleAnimation.py**'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
- en: SimpleAnimation class
  id: totrans-1844
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
- en: import time
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: 'class SimpleAnimation():'
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, loc, picPaths durationPerImage): 1'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: self.loc = loc
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: self.imagesList = []
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: 'for picPath in picPaths:'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: 'image = pygame.image.load(picPath) # load an image'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: 'image = pygame.Surface.convert_alpha(image) 2 # optimize blitting'
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: self.imagesList.append(image)
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: self.playing = False
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: self.durationPerImage = durationPerImage
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: self.nImages = len(self.imagesList)
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: '**296** Chapter 14'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: self.index = 0
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
- en: 'def play(self): 3'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.playing:'
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: self.playing = True
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: self.imageStartTime = time.time()
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: self.index = 0
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self): 4'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
- en: 'if not self.playing:'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
- en: How much time has elapsed since we started showing this image
  id: totrans-1870
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.elapsed = time.time() - self.imageStartTime
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: If enough time has elapsed, move on to the next image
  id: totrans-1872
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if self.elapsed > self.durationPerImage:'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: self.index = self.index + 1
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.index < self.nImages: # move on to next image'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
- en: self.imageStartTime = time.time()
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
- en: 'else: # animation is finished'
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: self.playing = False
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: 'self.index = 0 # reset to the beginning'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self): 5'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
- en: Assumes that self.index has been set earlier - in the update() method.
  id: totrans-1881
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is used as the index into the imagesList to find the current image.
  id: totrans-1882
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'theImage = self.imagesList[self.index] # choose the image to show'
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: 'self.window.blit(theImage, self.loc) # show it'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-1: The SimpleAnimation class*'
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
- en: When a client instantiates a SimpleAnimation object, it must pass in the
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: 'following:'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
- en: '**window** The window to draw into.'
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
- en: '**loc** The location in the window to draw the images.'
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: '**picPaths** A list or tuple of paths to images. The images will be dis-'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: played in the order given here.
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
- en: '**durationPerImage** How long (in seconds) to show each image.'
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
- en: In the __init__() method 1, we save these parameter variables into sim-
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
- en: ilarly named instance variables. The method loops through the list of paths,
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
- en: loads each image, and saves the resulting images into a list. A list is a perfect
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
- en: way to represent an ordered set of images. The class will use the self.index
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
- en: variable to keep track of the current image in the list.
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
- en: The format of an image in a file is different from the format of an image
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
- en: when displayed on the screen. The call to convert_alpha() 2 converts from the
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
- en: file format to the screen format to optimize performance when showing an
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
- en: image in the window. The actual drawing is done later, in the draw() method.
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
- en: Animation **297**
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
- en: The play() method 3 starts an animation running. It first checks to see if the
    animation is already running, and if it is, the method just returns.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
