- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: TWO PYTHON PARADIGMS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 两种 Python 编程范式
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common01.jpg)'
- en: Now that we’ve explored some topics in the Python programming language, let’s
    learn about the two main paradigms we can use to write code. In this second chapter
    on Python, we’ll discuss the functional and object-oriented programming paradigms
    and the benefits each brings. We’ll wrap up with a brief look at type hints. Let’s
    get started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了一些 Python 编程语言的主题，接下来让我们了解可以用来编写代码的两种主要范式。在本章的第二部分中，我们将讨论函数式编程和面向对象编程范式，并探讨每种范式带来的好处。最后，我们将简要介绍类型提示。让我们开始吧。
- en: '**Functional Programming**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数式编程**'
- en: Functional programming is a programming paradigm, which means that it’s a style
    of writing code we can decide to adhere to. For us to say “we’re writing functional-style
    code” we have to follow some simple rules that define what functional programming
    is about.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种编程范式，意味着它是一种我们可以选择遵循的编写代码的风格。要说“我们正在编写函数式风格的代码”，我们必须遵循一些简单的规则，来定义什么是函数式编程。
- en: The central elements of the functional programming paradigm are pure functions
    and the immutability of data. We’ll break these concepts down in the next sections.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程范式的核心元素是纯函数和数据的不可变性。我们将在接下来的章节中详细分析这些概念。
- en: Not all programming languages have good support for writing functional-style
    code. For example, languages like C have no good support for it. On the other
    hand, there are languages, like Haskell, that are purely functional, meaning you
    can only write functional-style code. By design, Python isn’t a functional language,
    but it does have support for the functional programming style.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的编程语言都能很好地支持函数式风格的编程。例如，像 C 这样的语言对其支持并不好。另一方面，也有一些语言，比如 Haskell，完全是函数式的，意味着你只能编写函数式风格的代码。按设计，Python
    不是一门函数式语言，但它确实支持函数式编程风格。
- en: Let’s learn about pure functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来了解一下纯函数。
- en: '***Pure Functions***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***纯函数***'
- en: 'Let’s quickly review the syntax for a Python function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下 Python 函数的语法：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The definition of a function starts with the def keyword followed by the name
    of the function and the input parameters inside parentheses. A colon (:) marks
    the end of the function header. The code in the body of the function is indented
    one level.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的定义以 `def` 关键字开始，后面是函数名和括号中的输入参数。冒号（:）标志着函数头的结束。函数体中的代码需要缩进一级。
- en: 'A function, in the functional programming paradigm, is similar to the mathematical
    concept of a function: a mapping of some input to some output. We say a function
    is *pure* if'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程范式中，函数类似于数学中函数的概念：将某些输入映射到某些输出。如果一个函数是*纯*的，我们就说它是纯函数：
- en: It consistently returns the same outputs for the same set of inputs.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于相同的一组输入，它始终返回相同的输出。
- en: It doesn’t have side effects.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有副作用。
- en: 'A *side effect* happens when something outside the body of the function is
    mutated by the function. A side effect also occurs when the function’s inputs
    are modified by the function, because a pure function never modifies its inputs.
    For example, the following function is pure:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*副作用* 是指函数体外的某些东西被函数改变了。当函数修改输入时，也会发生副作用，因为纯函数永远不会修改其输入。例如，以下函数就是纯函数：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Given the same input points p and q, the output is always the same vector,
    and nothing outside the function’s body is modified. In contrast, the following
    code is an impure version of make_vector:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 给定相同的输入点 p 和 q，输出始终是相同的向量，且函数体外的任何内容都没有被修改。相比之下，以下代码是 `make_vector` 的不纯版本：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous snippet uses the shared state of last_point, which is mutated every
    time make_vector is called. This mutation is a side effect of the function. The
    returned vector depends on the last_point shared state, so the function doesn’t
    return the same vector consistently for the same input point.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段使用了 `last_point` 的共享状态，每次调用 `make_vector` 时都会改变这个状态。这种变化是函数的副作用。返回的向量依赖于
    `last_point` 的共享状态，因此该函数对于相同的输入点不会始终返回相同的向量。
- en: '***Immutability***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不可变性***'
- en: As you saw in the previous example, one key aspect of functional programming
    is *immutability*. Something is immutable if it doesn’t change with time. If we
    decide to write code in the functional programming style, we make the firm decision
    of avoiding data mutations and modeling our programs using pure functions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在之前的例子中所见，函数式编程的一个关键特点是*不可变性*。如果某个事物随时间不会改变，我们就称它为不可变的。如果我们决定使用函数式编程风格编写代码，那么我们就要坚定地避免数据变更，并通过纯函数来建模我们的程序。
- en: 'Let’s take a look at an example. Imagine we had defined a point and a vector
    in the plane using dictionaries:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。假设我们使用字典在平面上定义了一个点和一个向量：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we wanted to compute the point resulting from displacing the existing point
    by the vector, we could do it in a functional way by creating a new point using
    a function. Here’s an example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想计算通过向量位移现有点得到的新点，可以通过创建一个新点的函数来以函数式的方式实现。下面是一个例子：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function is pure: given the same point and vector inputs, the resulting
    displaced point is consistently the same, and there is nothing that escapes the
    function’s body that is mutated in any sense, not even the function parameters.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是纯粹的：给定相同的点和向量输入，结果的位移点始终相同，而且函数体内没有任何被变更的内容，甚至函数参数也没有被改变。
- en: 'If we run this function, passing in the point and vector defined earlier, we
    get the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个函数，并传入之前定义的点和向量，我们将得到如下结果：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Conversely, a nonfunctional way of solving this case could involve mutating
    the original point using a function like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，解决这个问题的一种非函数式方式可能会涉及使用如下的函数来修改原始点：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function mutates the point it receives as an argument, which violates one
    of the key rules of the functional style.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会修改它接收到的点，这违反了函数式编程风格的一个关键规则。
- en: Note the use of in_place in the function name. This is a commonly used naming
    convention that implies that the changes will happen by mutating the original
    object. We’ll adhere to this naming convention throughout the book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意函数名中使用了 `in_place`。这是一个常见的命名约定，表示变化将通过修改原始对象来发生。在本书中，我们将遵循这一命名约定。
- en: 'Now let’s see how we’d go about using this displace_point_in_place function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用这个 `displace_point_in_place` 函数：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the function isn’t returning anything, which is a sign that
    the function isn’t pure, because to do some kind of useful operation it must have
    mutated something somewhere. In this case, that “something” is our point, whose
    coordinates have been updated.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这个函数没有返回任何值，这是一个迹象，表明该函数不是纯函数，因为要进行某种有用的操作，它必须修改某些内容。在这种情况下，这个“某些内容”就是我们的点，它的坐标已经被更新。
- en: An important benefit of the functional style is that by respecting the immutability
    of data structures, we avoid unintended side effects. When you mutate an object,
    you may not be aware of all the places in your code where that object is referenced.
    If there are other parts in the code relying on that object’s state, there may
    be side effects you are not aware of. So, after the object was mutated, your program
    may behave differently than expected. These kinds of errors are extremely hard
    to hunt down and can require hours of debugging.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的一大优势是，通过尊重数据结构的不变性，我们避免了意外的副作用。当你修改一个对象时，你可能并不清楚代码中所有引用该对象的地方。如果代码中的其他部分依赖于该对象的状态，可能会出现你未察觉的副作用。因此，在对象被修改后，程序的行为可能会与预期不同。这类错误极难追踪，可能需要数小时的调试。
- en: If we minimize the number of mutations in our project, we make it more reliable
    and less error prone.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们最小化项目中的变更次数，我们将使其更加可靠，减少错误的发生。
- en: 'Let’s now take a look at a special kind of function that has a central role
    in functional programming: the lambda function.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下在函数式编程中占据核心地位的一类特殊函数：lambda 函数。
- en: '***Lambdas***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Lambda 函数***'
- en: Back in the 1930s, a mathematician named Alonzo Church invented lambda calculus,
    a theory about functions and how they are applied to their arguments. Lambda calculus
    is the core of functional programming.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 回到20世纪30年代，一位名叫阿隆佐·丘奇的数学家发明了 lambda 演算，这是关于函数以及函数如何应用于其参数的理论。Lambda 演算是函数式编程的核心。
- en: In Python, a *lambda function*, or *lambda*, is an anonymous, typically short
    function defined on a single line. We’ll find lambdas to be useful when passing
    functions as parameters to other functions, for instance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，*lambda 函数*，或者称为*lambda*，是一个匿名的、通常是短小的一行函数。我们会发现，lambda 在将函数作为参数传递给其他函数时非常有用。
- en: 'We define a lambda function in Python using the lambda keyword followed by
    the arguments (separated by commas), a colon, and the function’s expression body:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Python 中定义一个 lambda 函数，使用 `lambda` 关键字，后跟参数（用逗号分隔），冒号和函数的表达式体：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The expression’s result is the returned value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的结果就是返回值。
- en: 'A lambda function to sum two numbers can be written as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 求两个数之和的 lambda 函数可以写成如下形式：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is equivalent to the regular Python function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于常规的 Python 函数：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Lambdas are going to appear in the next sections; we’ll see there how they’re
    used in several contexts. The place we’ll be using lambdas the most is as arguments
    to the filter, map, and reduce functions, as we’ll discuss in “Filter, Map, and
    Reduce” on [page 29](ch02.xhtml#ch00lev2sec22).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数将在接下来的章节中出现；我们将看到它们如何在多个场景中使用。我们最常使用 lambda 函数的地方是作为 filter、map 和 reduce
    函数的参数，正如我们在“Filter、Map 和 Reduce”中讨论的那样，见 [第29页](ch02.xhtml#ch00lev2sec22)。
- en: '***Higher-Order Functions***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***高阶函数***'
- en: A *higher-order* function is a function that either receives a function (or
    functions) as input parameters or returns a function as its result.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*高阶*函数是指一个函数，它要么接收一个（或多个）函数作为输入参数，要么返回一个函数作为结果。'
- en: Let’s take a look at examples for both cases.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看两个情况的例子。
- en: '**Functions As Function Arguments**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**函数作为函数参数**'
- en: 'Imagine we want to write a function that can run a function a given number
    of times. We could implement this as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想写一个函数，使其能够运行另一个函数指定的次数。我们可以这样实现：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, the repeat_fn function’s first parameter is another function,
    which is executed as many times as the second argument times dictates. Then, we
    define another function to simply print the string "Hi there!" to the screen:
    say_hi. The result of calling the repeat_fn function and passing it say_hi is
    those five greetings.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，repeat_fn 函数的第一个参数是另一个函数，它会根据第二个参数指定的次数执行。然后，我们定义了另一个函数来简单地打印字符串“Hi there!”到屏幕上：say_hi。调用
    repeat_fn 函数并传递 say_hi 的结果就是这五次问候。
- en: 'We could rewrite the previous example using an anonymous lambda function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用匿名 lambda 函数来重写前面的例子：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This spares us from having to define a named function to print the message.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们不必定义一个命名函数来打印信息。
- en: '**Functions As Function Return Values**'
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**函数作为函数返回值**'
- en: 'Let’s take a look at a function that returns another function. Imagine we want
    to define validation functions that validate if a given string contains a sequence
    of characters. We can write a function named make_contains_validator that takes
    a sequence and returns a function to validate strings that contain that sequence:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个返回另一个函数的例子。假设我们想定义一些验证函数，用于验证给定的字符串是否包含某个字符序列。我们可以写一个名为 make_contains_validator
    的函数，它接收一个字符序列并返回一个函数来验证包含该序列的字符串：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can use this function to generate validation functions, like the following
    one,
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个函数来生成验证函数，例如以下的这个，
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'which can be used to check whether the passed-in strings contain the @ character:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可以用来检查传入的字符串是否包含 @ 字符：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Higher-order functions are a useful resource we’ll use throughout the book.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是一个非常有用的工具，我们将在本书中多次使用它。
- en: '***Functions Inside Other Functions***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数嵌套在其他函数内***'
- en: 'Another convenient technique we’ll use throughout this book is defining a function
    inside another function. There are two good reasons we may want to do this: for
    one, it gives the inner function access to everything inside the outer function,
    without needing to pass that information as parameters; and also, the inner function
    may define some logic that we don’t want to expose to the outside world.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中还将使用的另一种便捷技巧是将函数定义在另一个函数内。我们可能会这么做的两个主要原因是：首先，它让内部函数可以访问外部函数内的所有内容，而无需将这些信息作为参数传递；其次，内部函数可能定义了一些我们不想暴露给外部的逻辑。
- en: 'A function can be defined inside another function using the regular syntax.
    Let’s take a look at an example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用常规语法在一个函数内部定义另一个函数。让我们来看一个例子：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the inner_fn function is defined inside the outer_fn function, and thus,
    it can’t be accessed from outside this host function, only from within its body.
    The inner_fn function has access to everything defined inside outer_fn, including
    the function parameters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，inner_fn 函数是在 outer_fn 函数内部定义的，因此它不能从外部访问，只能在其函数体内访问。inner_fn 函数可以访问 outer_fn
    内定义的所有内容，包括函数参数。
- en: 'Defining subfunctions inside of functions is useful when a function’s logic
    grows complex and it can be broken down into smaller tasks. Of course, we could
    also split the function into smaller functions all defined at the same level.
    In this case, to signal that those subfunctions are not meant to be imported and
    consumed from outside the module, we’ll follow Python’s standard and name those
    functions starting with two underscores:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部定义子函数在函数逻辑变得复杂并且可以分解成更小任务时非常有用。当然，我们也可以将函数拆分成多个在同一层级定义的小函数。在这种情况下，为了表明这些子函数并非用于外部导入和使用，我们将遵循
    Python 的标准，命名这些函数时以两个下划线开头：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that Python has no access modifiers (public, private, . . .); thus, all
    the code written at the top level of a module, that is, a Python file, can be
    imported and used.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python 没有访问修饰符（如 public、private 等）；因此，模块顶部编写的所有代码，即 Python 文件中的代码，都可以被导入并使用。
- en: Remember that the two underscores are just a convention that we have to respect.
    Nothing really prevents us from importing and using that code. If we import a
    function that starts with two underscores, we have to understand that the function
    was not written by its authors to be used from the outside, and we may get unexpected
    results if we call that function. By defining our subfunctions within the functions
    that call them, we prevent this behavior.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，两个下划线只是我们需要遵循的一种约定。实际上并没有什么可以阻止我们导入并使用这段代码。如果我们导入了一个以两个下划线开头的函数，我们必须理解，该函数并不是由其作者编写供外部使用的，如果我们调用这个函数，可能会得到意想不到的结果。通过在调用它们的函数内部定义子函数，我们可以防止这种情况发生。
- en: '***Filter, Map, and Reduce***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***过滤、映射与归约***'
- en: 'In functional programming, we never mutate a collection’s items, but instead
    always create a new collection to reflect the changes of an operation over that
    collection. There are three operations that form the cornerstone of functional
    programming and can accomplish every modification to a collection we can ever
    think of: filter, map, and reduce.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们从不修改集合的元素，而是总是创建一个新的集合，以反映操作对该集合的更改。有三个操作构成了函数式编程的基石，可以完成我们所能想到的对集合的任何修改：过滤、映射和归约。
- en: '**Filter**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**过滤**'
- en: The *filter* operation takes a collection and creates a new collection where
    some items may have been left out. The items are filtered according to a *predicate
    function*, which is a function that accepts one argument and returns either True
    or False depending on whether that argument passes a given test.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*filter* 操作接受一个集合，并创建一个新的集合，其中可能会排除某些项。项是根据 *谓词函数* 进行过滤的，谓词函数是一个接受一个参数并根据该参数是否通过给定测试返回
    True 或 False 的函数。'
- en: '[Figure 2-1](ch02.xhtml#ch2fig1) illustrates the filter operation.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](ch02.xhtml#ch2fig1) 说明了过滤操作。'
- en: '![Image](../images/02fig01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig01.jpg)'
- en: '*Figure 2-1: Filtering a collection*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：过滤集合*'
- en: '[Figure 2-1](ch02.xhtml#ch2fig1) shows a source collection made of four elements:
    A, B, C, and D. Below the collection is a box representing the predicate function,
    which determines which elements to keep and which to discard. Each element in
    the collection is passed to the predicate, and only those that pass the test are
    included in the resulting collection.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](ch02.xhtml#ch2fig1) 显示了一个由四个元素组成的源集合：A、B、C 和 D。集合下方是一个框，表示谓词函数，用于确定保留哪些元素，丢弃哪些元素。集合中的每个元素都会传递给谓词函数，只有通过测试的元素才会被包含在结果集合中。'
- en: 'There are two ways we can filter collections in Python: using the filter global
    function and, if the collection is a list, using list comprehensions. We’ll focus
    on the filter function here; we’ll cover list comprehensions in the next section.
    Python’s filter function receives a function (the predicate) and collection as
    parameters:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，有两种方法可以过滤集合：使用全局 filter 函数，或者如果集合是列表的话，使用列表推导式。我们在这里专注于 filter 函数；列表推导式将在下一节中介绍。Python
    的 filter 函数接收一个函数（谓词）和一个集合作为参数：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s write a predicate lambda function to test whether a number is even:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个谓词 lambda 函数来测试一个数字是否是偶数：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let’s use our lambda function to filter a list of numbers and obtain a
    new collection with only even numbers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用我们的 lambda 函数来过滤一组数字，并获取一个只包含偶数的新集合：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One thing to note is that the filter function doesn’t return a list, but rather
    an iterator. Iterators allow for iteration over a collection of items, one at
    a time. If you want to know more about Python iterators and how they work under
    the hood, please refer to the documentation at [*https://docs.python.org/3/library/stdtypes.html#typeiter*](https://docs.python.org/3/library/stdtypes.html#typeiter)
    and [*https://docs.python.org/3/glossary.html#term-iterator*](https://docs.python.org/3/glossary.html#term-iterator).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，filter函数并不返回列表，而是返回一个迭代器。迭代器允许逐项遍历一个集合。如果你想了解更多关于Python迭代器及其底层工作原理的信息，请参考[*https://docs.python.org/3/library/stdtypes.html#typeiter*](https://docs.python.org/3/library/stdtypes.html#typeiter)和[*https://docs.python.org/3/glossary.html#term-iterator*](https://docs.python.org/3/glossary.html#term-iterator)。
- en: 'We can consume all the iterator values and put them into a list using the list
    function we saw earlier. We can also consume the iterator using a for loop:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用之前看到的list函数消耗所有的迭代器值并将它们放入一个列表中。我们也可以使用for循环消耗迭代器：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Map**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**映射（Map）**'
- en: The *map* operation creates a new collection by taking each item in the source
    collection and running it through a function, storing the results in a new collection.
    The new collection is the same size as the source collection.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*map*操作通过将源集合中的每个项目传递给一个函数并将结果存储在一个新集合中来创建一个新集合。新集合的大小与源集合相同。'
- en: '[Figure 2-2](ch02.xhtml#ch2fig2) illustrates the map operation.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-2](ch02.xhtml#ch2fig2)展示了map操作。'
- en: '![Image](../images/02fig02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig02.jpg)'
- en: '*Figure 2-2: Mapping a collection*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-2：映射一个集合*'
- en: We run our source collection made of items A, B, C, and D through a mapping
    function, illustrated within a rectangle in [Figure 2-2](ch02.xhtml#ch2fig2);
    the result of the mapping is stored in a new collection.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将由项A、B、C和D组成的源集合传入一个映射函数，这个映射函数在[图2-2](ch02.xhtml#ch2fig2)中的矩形框内进行说明；映射的结果存储在一个新集合中。
- en: We can map a collection either using the global map function or, if we have
    a list, using list comprehensions. We’ll discuss list comprehensions in a moment;
    for now, let’s study how to map collections using the map function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过全局map函数映射一个集合，或者如果我们有一个列表，也可以使用列表推导式。稍后我们会讨论列表推导式；现在，让我们先学习如何使用map函数映射集合。
- en: 'The map global function receives two parameters: a mapping function and a source
    collection:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: map全局函数接收两个参数：一个映射函数和一个源集合：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is how we would map a list of names to their length:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何将一个名字列表映射到其长度的方式：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As with the filter function, map returns an iterator that can be consumed into
    a list using the list function. In the previous example, the resulting list contains
    the number of letters in each of the names in the names list: five letters in
    *Angel*, six letters in *Alvaro*, and so on. We’ve mapped each name into a number
    representing its length.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 和filter函数一样，map函数返回一个迭代器，可以通过list函数将其转换为列表。在之前的示例中，生成的列表包含了names列表中每个名字的字母数：*Angel*有五个字母，*Alvaro*有六个字母，依此类推。我们将每个名字映射成一个表示其长度的数字。
- en: '**Reduce**'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**归约（Reduce）**'
- en: The *reduce* operation is the most complex, but at the same time, it’s the most
    versatile of the three. It creates a new collection that can have fewer items
    than, more items than, or the same number of items as the original. To construct
    this new collection, it first applies a reducer function to the first and second
    elements. It then applies the reducer function to the third element *and* the
    result of the first application. It then applies the reducer function to the fourth
    element and the result of the second application. In this way, the results accumulate.
    A figure will help here. Take a look at [Figure 2-3](ch02.xhtml#ch2fig3).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*reduce*操作是最复杂的，但同时也是三者中最灵活的。它创建一个新集合，新集合中的项数可能比原始集合少，可能更多，或者与原始集合相同。为了构建这个新集合，首先将归约函数应用于第一个和第二个元素。然后，它将归约函数应用于第三个元素*和*第一次应用的结果。接着，它将归约函数应用于第四个元素和第二次应用的结果。这样，结果逐步累积。这里可以通过一张图来帮助理解，看看[图2-3](ch02.xhtml#ch2fig3)。'
- en: '![Image](../images/02fig03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/02fig03.jpg)'
- en: '*Figure 2-3: Reducing a collection*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-3：归约一个集合*'
- en: 'The reduction function in this example concatenates every element in the collection
    (A, B, C, and D) into a single element: ABCD.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的归约函数将集合中的每个元素（A、B、C和D）连接成一个单一元素：ABCD。
- en: 'The reducer function takes two parameters: the accumulated result and an item
    in the collection:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 归约函数接收两个参数：累积结果和集合中的一个项：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The function is expected to return the accumulated result after the new item
    has been processed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数期望在处理完新项后返回累积结果。
- en: 'There’s no global reduce function provided by Python, but there is a package
    named *functools* with some useful operations for working with higher-order functions,
    including a reduce function. This function doesn’t return an iterator, but rather
    it returns the resulting collection or item directly. The function’s signature
    looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有提供全局的 `reduce` 函数，但有一个名为 *functools* 的包，它包含一些有用的操作，用于处理高阶函数，包括一个 `reduce`
    函数。这个函数不会返回一个迭代器，而是直接返回结果集合或项。这个函数的签名如下：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s work with an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来进行说明：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this example, the reduce function returned a single item: ’ABCD’, the result
    of concatenating each letter in the collection. To start the reduction process,
    the reduce function takes the first two letters, *A* and *B*, and concatenates
    them into *AB*. For this first step, Python uses the initial item of the collection
    (*A*) as the accumulated result and applies the reducer to it and the second item.
    Then, it moves to the third letter, *C*, and concatenates it with the current
    accumulated result *AB*, thus producing the new result: *ABC*. The last step does
    the same with the *D* letter to produce the result *ABCD*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`reduce` 函数返回了一个单一的项：’ABCD’，它是将集合中每个字母连接起来的结果。为了开始归约过程，`reduce` 函数取了前两个字母，*A*
    和 *B*，并将它们连接成 *AB*。对于这个第一步，Python 将集合的初始项 (*A*) 作为累积结果，并将归约器应用于它和第二项。然后，它移到第三个字母
    *C*，并将其与当前的累积结果 *AB* 连接，从而生成新的结果：*ABC*。最后一步对 *D* 字母做同样的操作，生成结果 *ABCD*。
- en: 'What happens when the accumulated result and the items of the collection have
    different types? In that case, we can’t take the first item as the accumulated
    result, and thus the reduce function expects us to provide a third argument to
    use as the starting accumulated result:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当累积结果和集合中的项具有不同类型时会发生什么？在这种情况下，我们不能将第一个项作为累积结果，因此 `reduce` 函数希望我们提供第三个参数，作为起始的累积结果：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For example, imagine that we have the collection of names from earlier and
    we want to reduce it to obtain the total sum of the lengths of those names. In
    this case, the accumulated result is numeric, whereas the items in the collection
    are strings; we can’t use the first item as the accumulated length. If we forget
    to provide reduce with the start result, Python is nice enough to remind us by
    raising an error:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有之前的名字集合，我们想要将其归约为这些名字的总长度。在这种情况下，累积结果是数字类型，而集合中的项是字符串；我们不能将第一个项作为累积长度。如果我们忘记给
    `reduce` 提供起始结果，Python 会通过引发错误提醒我们：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For this case, we should pass 0 as the initial accumulated length:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，我们应该传递 0 作为初始的累积长度：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'One interesting note here is that if the accumulated result and the items of
    the collection have different types, you can always concatenate a map with a reduce
    to obtain the same result. For example, in the previous exercise we could have
    also done the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的注释：如果累积结果和集合中的项具有不同类型，你总是可以将 `map` 和 `reduce` 结合起来，以获得相同的结果。例如，在前面的练习中，我们也可以这样做：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this code we first map the names list into a list of the name lengths: lengths.
    Then, we reduce the lengths list to sum all the values, with no starting value
    necessary.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先将名字列表映射为名字长度的列表：`lengths`。然后，我们将 `lengths` 列表归约，求出所有值的总和，不需要提供起始值。
- en: 'When reducing items using a common operation—like a sum of two numbers or a
    concatenation of two strings—we don’t need to write a lambda function ourselves;
    we can simply pass the reduce function an existing Python function. For example,
    when reducing numbers, there’s a useful module provided by Python named *operator.py*.
    This module defines functions to operate with numbers, among others. Using this
    module, we can simplify our previous example to the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用常见操作（如两个数字的和或两个字符串的连接）归约项时，我们不需要自己编写 lambda 函数；我们可以简单地将现有的 Python 函数传递给 `reduce`
    函数。例如，当对数字进行归约时，Python 提供了一个有用的模块，名为 *operator.py*。这个模块定义了用于数字操作的函数等。使用这个模块，我们可以简化之前的例子，如下所示：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code is shorter and more readable, so we’ll prefer this form throughout
    the book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更简洁、更易读，因此我们将在本书中优先使用这种形式。
- en: 'The operator.add function is defined by Python as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator.add` 函数由 Python 定义如下：'
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, this function is equivalent to the lambda function we defined
    to sum two numbers. We’ll see more examples of functions defined by Python that
    can be used with reduce throughout the book.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个函数等同于我们定义的用于求和两个数字的 lambda 函数。我们将在全书中看到更多由 Python 定义的可以与 reduce 一起使用的函数示例。
- en: So far, all of our examples have reduced collections to a single value, but
    the reduce operation can do much more. In fact, both the filter and map operations
    are specializations of the reduce operation. We can filter and map a collection
    using only a reduce operation. But this isn’t something we’ll stop to analyze
    here; try to figure it out on your own if you feel motivated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的示例都将集合缩减为单一值，但 reduce 操作可以做更多事情。事实上，filter 和 map 操作都是 reduce 操作的特例。我们可以仅使用
    reduce 操作来筛选和映射一个集合。但这不是我们此处要分析的内容；如果你有兴趣，可以自行尝试理解。
- en: 'Let’s see an example where we want to create a new collection based on the
    names list, where every item is the concatenation of all the previous names with
    the current name separated by the hyphen character (-). The result we’re looking
    for should be something like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，假设我们想要基于名字列表创建一个新集合，每个项都是之前所有名字与当前名字用连字符 (-) 连接起来的结果。我们期望得到的结果应该是这样的：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can do this using the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来实现：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we use compute_next_name to determine the next item in the sequence. The
    lambda used inside reduce concatenates the accumulated result, which is the list
    of stitched-together names, with a new list consisting of the new item. The initial
    solution, an empty list, needs to be provided, since once again the type of each
    item in the list (string) is different from the result (list of strings).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 compute_next_name 来确定序列中的下一个项。reduce 中使用的 lambda 函数将累积结果（即已连接的名字列表）与一个新列表（由新项组成）进行连接。由于列表中每项的类型（字符串）与结果（字符串列表）不同，因此需要提供初始解决方案——一个空列表。
- en: As you can see, the reduce operation is very versatile.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，reduce 操作非常灵活多变。
- en: '***List Comprehensions***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表推导式***'
- en: As mentioned earlier, we can filter and map lists in Python using list comprehensions.
    This form is typically preferred over the filter and map functions when dealing
    with lists, as its syntax is more concise and readable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用列表推导式在 Python 中筛选和映射列表。处理列表时，通常偏爱这种形式，因为它的语法更加简洁和易读，优于 filter 和 map
    函数。
- en: 'A list comprehension to map items has the following structure:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 映射项的列表推导式结构如下：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are two parts to it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两部分：
- en: for *<item>* in *<list>* is the for loop that iterates over the items in *<list>*.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: for *<item>* in *<list>* 是在 *<list>* 中迭代项目的 for 循环。
- en: '*<expression>* is a mapping expression to map *<item>* into something else.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<expression>* 是一个映射表达式，用来将 *<item>* 映射为其他内容。'
- en: 'Let’s repeat the exercise we did earlier where we mapped a list of names to
    a list of the lengths of each name, this time using a list comprehension:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复一下之前做的练习，这次我们使用列表推导式将名字列表映射到每个名字的长度列表：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'I hope you see why Python programmers favor list comprehensions over the map
    function; the example almost reads like plain English: “length of name for (each)
    name in names.” In the example, for name in names iterates over the names in the
    original list and then uses the length of each name (len(name)) as the result.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你明白为什么 Python 程序员更偏爱列表推导式而非 map 函数；这个例子几乎就像是普通英语：“每个名字的长度，在 names 中的每个名字”。在这个例子中，for
    name in names 迭代原始列表中的名字，并使用每个名字的长度 (len(name)) 作为结果。
- en: 'To filter a list using a list comprehension we can add an if clause at the
    end of the comprehension:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用列表推导式筛选列表，我们可以在推导式末尾添加一个 if 子句：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we wanted to, for example, filter a list of names, this time keeping only
    those that start with *A*, we could write the following list comprehension:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要，例如，筛选一个名字列表，这次只保留以 *A* 开头的名字，我们可以写出以下列表推导式：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Note two things from this example: the mapping expression is the name itself
    (an identity mapping, which is the same as no mapping), and the filter uses the
    string startswith method. This method returns True only if the string has the
    given argument as a prefix.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中注意两点：映射表达式是名字本身（一个身份映射，相当于没有映射），并且筛选使用了字符串的 startswith 方法。此方法只有在字符串具有给定的前缀时才会返回
    True。
- en: 'We can filter and map in the same list comprehension. For example, let’s say
    we want to take our list of names and filter out those that have more than five
    letters and then construct a new list whose elements are a tuple of the original
    name and its length. We could do this easily:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在同一个列表推导式中同时进行过滤和映射。例如，假设我们想从名字列表中筛选出那些字母超过五个的名字，然后构建一个新列表，其中的元素是原始名字及其长度的元组。我们可以轻松实现：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For comparison’s sake, let’s see what this would look like if we decided to
    use the filter and map functions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于比较，让我们看看如果我们选择使用 `filter` 和 `map` 函数，会是什么样子：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the result is the same, but the list comprehension version is
    simpler and more readable. What’s easier to read is easier to maintain, so list
    comprehensions are going to be our preferred way of filtering and mapping lists.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果是相同的，但列表推导式版本更简单且更具可读性。更容易阅读的代码也更容易维护，因此，列表推导式将成为我们过滤和映射列表的首选方式。
- en: 'Let’s now turn our attention to the second paradigm we’ll be exploring in this
    chapter: object-oriented programming.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向本章将要探讨的第二个范式：面向对象编程。
- en: '**Object-Oriented Programming**'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**面向对象编程**'
- en: 'In the previous section, we talked about functional programming and some functional
    patterns. Now we’ll learn about another paradigm: the *object-oriented paradigm*.
    As the function is to functional programming, the object is to object-oriented
    programming. So, first things first: What’s an object?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们讨论了函数式编程和一些函数式编程模式。现在我们将学习另一种编程范式：*面向对象范式*。就像函数对函数式编程的重要性一样，面向对象编程中的对象也扮演着类似的角色。那么，首先，我们来看看：什么是对象？
- en: There are several ways we could describe what an object is. I’m going to deviate
    from the standard academic definition of an object in object-oriented programming
    theory and try a rather unconventional explanation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式来描述对象是什么。我将偏离面向对象编程理论中的标准学术定义，尝试一种不太传统的解释。
- en: From a practical standpoint, we can think of objects as experts on a given subject.
    We can ask them questions, and they will give us information; or we can request
    that they do things for us, and they will do them. Our questions or requests may
    require complex operations, but these experts hide the complexity from us so that
    we don’t need to worry about the details—we just care about getting the job done.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际的角度来看，我们可以把对象看作是某一特定领域的专家。我们可以向它们提问，它们会给我们信息；或者我们可以请求它们为我们做一些事情，它们就会执行这些任务。我们的提问或请求可能涉及复杂的操作，但这些专家会将复杂性隐藏起来，以便我们无需担心细节——我们只关心任务能否完成。
- en: For example, think of a dentist. When you go to the dentist, you don’t need
    to know anything about dentistry yourself. You rely on the dentist’s expertise
    to get your cavities fixed. You can also ask the dentist questions about your
    teeth, and the dentist will respond using a language that you can understand,
    hiding the real complexity of the subject. In this example, the dentist would
    be an object you’d rely on for odontology-related tasks or queries.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，想象一下去看牙医。当你去看牙医时，你不需要了解任何牙科知识。你依赖牙医的专业技能来修复你的蛀牙。你也可以向牙医询问关于牙齿的问题，牙医会用你能理解的语言回答你，隐藏了牙科的真正复杂性。在这个例子中，牙医就是你依赖的对象，用来处理与牙科相关的任务或查询。
- en: To request things from an object, we call one of the object’s *methods*. Methods
    are functions that belong to a given object and have access to the object’s internals.
    The object itself has some memory that contains data that is typically hidden
    to the outside world, although the object may decide to expose some of this data
    in the form of *properties*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要向对象请求某些操作，我们会调用对象的*方法*。方法是属于某个对象的函数，并且能够访问该对象的内部数据。对象本身有一些内存，用来存储通常对外部世界隐藏的数据，尽管该对象可能决定以*属性*的形式公开其中的一部分数据。
- en: '**NOTE**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A method is a function that belongs to a class: it’s part of the class definition.
    It needs to be called (executed) on the instance of the class where it’s defined.
    By contrast, a function doesn’t belong to any class; it works on its own.*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法是属于类的函数：它是类定义的一部分。它需要在定义它的类的实例上被调用（执行）。与此相对，函数不属于任何类；它是独立工作的。*'
- en: In Python’s parlance, any function or variable in an object is called an *attribute*.
    Both properties and methods are attributes. We’ll be using these equivalent terms
    throughout this chapter and the rest of the book.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 的术语中，对象中的任何函数或变量都被称为*属性*。无论是属性还是方法，它们都是属性。在本章和本书的其余部分，我们将使用这些等价的术语。
- en: Let’s now get practical and see how we can define and work with objects in Python.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实际操作一下，看看如何在Python中定义和使用对象。
- en: '***Classes***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类***'
- en: A *class* defines how objects are constructed and what characteristics and knowledge
    they have. Some people like to compare classes to blueprints; they are general
    descriptions of what information the object holds and what it can do. Objects
    and classes are related but distinct; if the class is the blueprint, the object
    is the finished building.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*类*定义了对象的构造方式以及它们具有什么特征和知识。有些人喜欢将类比作蓝图；它们是对象包含什么信息以及可以做什么的通用描述。对象和类是相关但不同的；如果类是蓝图，那么对象就是完成的建筑。'
- en: 'We define a new class in Python using the reserved class keyword. By convention,
    class names start with an uppercase letter and use an uppercase letter at the
    start of every new word (this case is commonly known as *Pascal case*). Let’s
    create a class that models a coffee machine:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用保留的class关键字在Python中定义一个新类。按照惯例，类名以大写字母开头，并且每个新单词的首字母也大写（这种情况通常称为*Pascal命名法*）。让我们创建一个模拟咖啡机的类：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this listing we define a new class representing a coffee machine. We can
    use this class to generate new coffee machine objects, in a process referred to
    as *instantiation*. When we instantiate a class, we create a new object of that
    class. A class is instantiated by calling its name as if it were a function that’s
    returning the instantiated object:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们定义了一个表示咖啡机的新类。我们可以使用这个类生成新的咖啡机对象，这个过程称为*实例化*。当我们实例化一个类时，我们创建了该类的一个新对象。实例化一个类的方法是调用其名称，仿佛它是一个返回实例化对象的函数：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we have the machine object whose functionality is defined by the Coffee
    Machine class (which is still empty, but we’ll complete it in the following sections).
    When a class is instantiated, its __init__ function is called. Inside this __init__
    function, we can perform one-time initialization tasks. For example, here we add
    a count of the number of brewed coffees and set it to zero:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了机器对象，其功能由咖啡机类定义（目前还为空，但我们将在接下来的部分中完成它）。当一个类被实例化时，它的__init__函数会被调用。在这个__init__函数内部，我们可以执行一次性的初始化任务。例如，这里我们添加了酿造咖啡的数量并将其设置为零：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice the two underscores at the beginning of __coffees_brewed. If you remember
    from our discussion on access levels earlier, in Python, by default, everything
    is visible to the outside. The double underscore naming pattern is used to signify
    that something is private and no one is expected to access it directly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意__coffees_brewed前面的两个下划线。如果你还记得我们之前讨论的访问级别，Python 中默认所有内容对外部可见。双下划线命名规则用于表示某些内容是私有的，外部不应该直接访问它。
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, we don’t want the outside world to access __coffees_brewed; they
    could change the coffees brewed count at will!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不希望外部世界访问__coffees_brewed；否则他们就可以随意更改酿造的咖啡数量！
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So if we can’t access __coffees_brewed, how do we know how many coffees our
    machine has brewed? The answer is properties. Properties are a class’s read-only
    attributes. Before we can discuss properties, however, we have some syntax to
    cover.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们无法访问__coffees_brewed，我们如何知道我们的机器已经酿造了多少杯咖啡呢？答案是属性。属性是类的只读属性。然而，在讨论属性之前，我们需要先了解一些语法。
- en: '**self**'
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**self**'
- en: If you look at the previous example, you’ll see that we make frequent use of
    a variable named self. We could use any other name for this variable, but self
    is used by convention. As you saw earlier, we pass it to the definition of every
    function inside the class, including the initializer. Thanks to this first parameter,
    self, we gain access to whatever is defined in the class. In the __init__ function,
    for example, we append the __coffees_brewed variable to self; from that point
    on, this variable exists in the object.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下前面的例子，你会发现我们频繁使用一个名为self的变量。我们本可以为这个变量使用任何其他名字，但按照惯例，使用self。正如你之前看到的，我们将其传递给类内每个函数的定义，包括初始化函数。多亏了这个第一个参数self，我们能够访问类中定义的任何内容。例如，在__init__函数中，我们将__coffees_brewed变量附加到self上；从那时起，这个变量就存在于对象中了。
- en: 'The variable self needs to appear as the first parameter in the definition
    of every function inside the class, but it doesn’t need to be passed as the first
    argument when we call those functions on instances of the class. For example,
    to instantiate the CoffeeMachine class, we wrote the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 变量self需要作为每个函数定义中的第一个参数，但在我们调用这些函数时，不需要将其作为第一个参数传递给类的实例。例如，要实例化CoffeeMachine类，我们写了以下代码：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The initializer was called without parameters (no self here). If you think
    about it, how could we possibly pass the initializer as self in this case if we
    haven’t yet initialized the object? As it turns out, Python takes care of that
    for us: we’ll never need to pass self to the initializer or any of the object’s
    methods or properties.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器在没有参数的情况下被调用（这里没有self）。如果你仔细想想，在这种情况下我们怎么可能把初始化器作为self传递呢，毕竟我们还没有初始化对象？事实证明，Python为我们处理了这个问题：我们永远不需要将self传递给初始化器或任何对象的方法或属性。
- en: 'The self reference is how different attributes of a class have access to the
    other definitions in the class. For example, in the brew_coffee method we’ll write
    later, we use self to access the __coffees_brewed count:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`self`引用是不同属性如何访问类中其他定义的方式。例如，在我们稍后编写的`brew_coffee`方法中，我们会用`self`来访问`__coffees_brewed`计数：'
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With an understanding of self, we can move on to properties.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了`self`后，我们可以继续了解属性。
- en: '**Class Properties**'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**类属性**'
- en: 'An object’s *property* is a read-only attribute that returns some data. A property
    of an object is accessed using *dot notation*: *object.property*. Following our
    coffee machine example, we could add a coffees_brewed property (the number of
    coffees brewed by the machine), like so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的*属性*是一个只读属性，用于返回一些数据。对象的属性通过*点表示法*来访问：*object.property*。以我们的咖啡机为例，我们可以添加一个`coffees_brewed`属性（表示咖啡机已经煮过的咖啡数量），代码如下：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then we could access it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样访问它：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Properties are defined as functions using the @property decorator:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 属性通过使用`@property`装饰器来定义为函数：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Properties shouldn’t accept any parameter (except for the customary self),
    and they should return something. A property that doesn’t return anything or expects
    parameters is conceptually wrong: properties should just be read-only data we
    request the object to give us.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 属性不应接受任何参数（除了习惯性的self），并且它们应该返回某些内容。一个不返回任何内容或期望参数的属性在概念上是错误的：属性应仅仅是我们请求对象提供的只读数据。
- en: We mentioned that @property is an example of a decorator. Python decorators
    allow us to modify a function’s behavior. The @property modifies the function
    of a class so that it can be consumed as if it were an attribute of the class.
    We won’t use any other decorators in this book, so we won’t cover them here, but
    I encourage you to read up on them if you’re interested.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，`@property`是一个装饰器的例子。Python装饰器允许我们修改函数的行为。`@property`修改了类函数，使其可以像类的属性一样被使用。在本书中我们不会使用其他装饰器，因此这里不做详细介绍，但如果你感兴趣，建议你阅读相关资料。
- en: 'Properties get us information about an object. For instance, if we wanted to
    know whether a given instance of a CoffeeMachine has brewed at least one coffee,
    we could include a property like the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 属性帮助我们获取有关对象的信息。例如，如果我们想知道某个`CoffeeMachine`实例是否至少煮过一杯咖啡，我们可以添加一个如下的属性：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can now ask instances of the CoffeeMachine class whether they’ve brewed
    at all:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以询问`CoffeeMachine`类的实例是否已经煮过咖啡：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This machine hasn’t prepared any coffee yet, so how can we ask a CoffeeMachine
    instance to brew a coffee for us? We use methods.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这台机器还没有准备任何咖啡，那么我们怎么能让一个`CoffeeMachine`实例为我们煮咖啡呢？我们使用方法。
- en: '**Class Methods**'
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**类方法**'
- en: 'Properties allow us to know something about an object: they answer our queries.
    To request an object to perform some task for us, we use methods. A *method* is
    nothing more than a function that belongs to a class and has access to the attributes
    defined in that class. In our CoffeeMachine class example, let’s write a method
    to request it to brew some coffee:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 属性让我们了解关于对象的信息：它们回答我们的查询。为了请求对象为我们执行某些任务，我们使用方法。*方法*不过是属于类的一个函数，它能够访问类中定义的属性。在我们的`CoffeeMachine`类示例中，我们可以写一个方法来请求它煮些咖啡：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Methods get self as their first parameter, which gives them access to everything
    defined inside the class. As we discussed earlier, when calling a method on an
    object, we never pass self ourselves; Python does it for us.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 方法将self作为第一个参数，这使得它们能够访问类中定义的所有内容。如前所述，在调用对象的方法时，我们永远不需要自己传递self；Python会自动为我们处理。
- en: '**NOTE**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Note that properties are like methods decorated with* @property*. Both properties
    and methods expect* self *as their first argument. When calling a method, we use
    parentheses and optionally pass it arguments, but properties are accessed without
    parentheses.*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，属性就像是带有`@property`装饰器的方法。属性和方法都期望`self`作为它们的第一个参数。当调用方法时，我们使用括号并可选择传递参数，但属性是通过不带括号的方式来访问的。*'
- en: 'We can call the brew_coffee method on an instance of the class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类的实例上调用`brew_coffee`方法：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now that we’ve brewed our first coffee, we can ask the instance this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经煮好了第一杯咖啡，我们可以向实例提问如下：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you see, methods have to be called on a particular instance of a class (an
    object). This object will be the one responding to the request. So, whereas functions
    are called without a particular receiver, like
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，方法必须在类的特定实例（对象）上调用。这个对象将响应请求。因此，函数是直接调用的，没有特定的接收者，像
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: methods have to be called on an object, like
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 方法必须在对象上调用，像
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Objects can only respond to the methods defined in the class that created them.
    If a method (or any attribute for that matter) is called on an object but this
    method wasn’t defined in the class, an AttributeError is raised. Let’s try this.
    Let’s order our coffee machine to brew tea even though we never gave it the instructions
    on how to do so:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只能响应在创建它们的类中定义的方法。如果在对象上调用了一个方法（或任何属性），但该方法没有在类中定义，则会引发AttributeError。让我们试试看。尽管我们从未给咖啡机提供过如何泡茶的指令，仍然让它尝试泡茶：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Okay, our object complained: we never told it we expected it to know how to
    prepare tea. Here’s the key to its complaint:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们的对象抱怨了：我们从未告诉它我们希望它知道如何准备茶。以下是它抱怨的关键：
- en: '''CoffeeMachine'' object has no attribute ''brew_tea'''
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '''CoffeeMachine'' 对象没有 ''brew_tea'' 属性'
- en: 'Lesson learned: don’t ever request an object to do something it wasn’t taught;
    it’ll just freak out and make your program fail.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 经验教训：永远不要要求一个对象做它没有被教过的事情；它会崩溃并导致程序失败。
- en: 'Methods can accept any number of parameters, which in our class have to be
    defined after the first mandatory argument: self. For example, let’s add a method
    to our CoffeeMachine class that allows us to fill it with a given amount of water.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以接受任意数量的参数，在我们的类中，这些参数必须在第一个强制性参数：self 之后定义。例如，让我们为我们的CoffeeMachine类添加一个方法，允许我们用指定量的水来填充它。
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can fill the coffee machine instance by calling our new method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用新方法来填充咖啡机实例：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: One last thing to know about methods before we move on is how powerful their
    dynamic dispatch nature is. When a method is called on an object, Python will
    check whether the object responds to that method or not, but, and here’s the key,
    Python doesn’t care about the object’s class as long as this class has the requested
    method defined.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，关于方法要知道的最后一件事是它们动态分发的强大特性。当在对象上调用方法时，Python 会检查该对象是否响应该方法，但是，关键是，Python
    不关心对象的类，只要该类定义了请求的方法。
- en: 'We can use this feature to define different objects that respond to the same
    method (by same method we mean same name and arguments) and use them interchangeably.
    For instance, we could define a new, more modern coffee-producer entity:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这个特性定义不同的对象，这些对象可以响应相同的方法（这里的相同方法指的是相同的名称和参数），并且可以互换使用。例如，我们可以定义一个新的、更现代的咖啡生产者实体：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we can write a function that expects a coffee producer (any object whose
    class defines a brew_cofee() method) and does something with it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以写一个函数，期望一个咖啡生产者（任何定义了 brew_cofee() 方法的对象），并对其进行操作：
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This function works with both an instance of CoffeeMachine and CoffeeHipster:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数适用于 CoffeeMachine 和 CoffeeHipster 的实例：
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: For this technique to work, we need to make sure that the methods have the same
    signature, that is, they’re called the same and expect exactly the same parameters
    with the same names.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此技术有效，我们需要确保方法具有相同的签名，即它们的名称相同，并且期望完全相同的参数和相同的名称。
- en: '***Magic Methods***'
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***魔法方法***'
- en: There are some special methods our classes may define that are known as *magic
    methods* or *dunder methods* (short for *double underscore*). These methods aren’t
    typically called by us directly, but Python uses them under the hood, as we’ll
    see in the following examples.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类可以定义一些特殊的方法，这些方法被称为*魔法方法*或*双下划线方法*（简称*dunder方法*）。这些方法通常不会直接由我们调用，但 Python
    会在幕后使用它们，正如我们将在以下示例中看到的那样。
- en: 'We’ve already used one such method: __init__, which we used as the initializer
    when instantiating objects. This __init__ method defines the code that’s executed
    when a new instance of a class is created.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用过一个这样的函数：__init__，它作为初始化函数在实例化对象时使用。这个__init__方法定义了当类的新实例被创建时执行的代码。
- en: 'One prominent use case for magic methods (which we’ll use a lot throughout
    the book) is overloading operators. Let’s see this through an example. Imagine
    we implement a class to represent complex numbers:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法方法的一个显著用途（我们将在本书中广泛使用）是重载运算符。通过一个例子来看这个问题。假设我们实现了一个类来表示复数：
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'How would we go about implementing the addition operation on ComplexNum instances?
    A first option could be including a method called plus:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们该如何实现 ComplexNum 实例的加法操作呢？一个选项是定义一个名为 plus 的方法：
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'which we could use like so:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用：
- en: '[PRE66]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is okay, but it would be nicer if we could instead use the + operator
    like we do with any other number:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这样写也可以，但如果我们能像对待其他数字一样使用 + 运算符，那就更好了：
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Python includes a magic method, __add__; if we implement that method, then
    we can use the + operator as shown earlier, and Python will call this __add__
    method under the hood. So if we rename our plus method __add__, we can automatically
    add ComplexNums using the + operator:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包含了一个魔法方法，__add__；如果我们实现这个方法，就可以像之前一样使用 + 运算符，Python 会在后台调用这个 __add__
    方法。因此，如果我们将我们的加法方法重命名为 __add__，就可以使用 + 运算符自动添加 ComplexNum 实例：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'There are more magic methods we can implement in our classes to perform subtraction,
    division, comparisons, and more. You can take a brief look at [Table 4-1](ch04.xhtml#ch4tab1)
    on [page 70](ch04.xhtml#ch4tab1) for a reference of the operations we can implement
    with magic methods. For example, subtracting two of our complex numbers using
    the - operator would be as simple as implementing the __sub__ method:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类中实现更多魔法方法来执行减法、除法、比较等操作。你可以参考 [表 4-1](ch04.xhtml#ch4tab1) 和 [第70页](ch04.xhtml#ch4tab1)
    中的内容，查看我们可以通过魔法方法实现的操作。例如，使用 - 运算符对两个复数进行减法操作，实际上只需要实现 __sub__ 方法：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now we can use the - operator:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 - 运算符：
- en: '[PRE70]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'What about comparing two instances for equality using the == operator? Simply
    implement the __eq__ magic method:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何用 == 运算符比较两个实例的相等性呢？只需要实现 __eq__ 魔法方法：
- en: '[PRE71]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now we can easily compare complex numbers:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松比较复数了：
- en: '[PRE72]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We’ll be using some magic methods throughout the book; they really improve the
    readability of the code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们会使用一些魔法方法；它们能大大提高代码的可读性。
- en: Let’s now change topics and learn about type hints.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们换个话题，来学习类型提示。
- en: '**Type Hints**'
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**类型提示**'
- en: Python *type hints* are a small help we can use when writing code to make sure
    we don’t mistype the name of a method or property of a class.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 *类型提示* 是我们在编写代码时可以用来确保不输入错误方法名或属性名的小帮助。
- en: 'For example, let’s use the implementation of a complex number from the previous
    section:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，我们可以使用前一节中实现的复数类：
- en: '[PRE73]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now say that we write a function that takes an instance of ComplexNum as an
    argument, and we want to extract the imaginary part of the number, but we’re a
    bit sleepy and mistakenly write the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们写了一个函数，接受一个 ComplexNum 实例作为参数，并且我们想要提取复数的虚部，但我们有点困倦，不小心写了以下代码：
- en: '[PRE74]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Did you spot the typo? Well, since we know nothing about the complex argument,
    there’s no visual clue our IDE can give us. As far as the IDE knows, imaginry
    is a perfectly valid attribute name, and it won’t be until we run the program
    and pass a complex number that we get an error.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到拼写错误了吗？由于我们对复数参数没有任何了解，IDE 也无法给出任何视觉提示。就 IDE 来看，imaginery 是一个完全有效的属性名，直到我们运行程序并传递一个复数，才会报错。
- en: 'Python is a dynamically typed language: it uses type information at runtime.
    For example, it checks whether a given type of object responds to a method at
    runtime, and if it doesn’t, an error is raised:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种动态类型语言：它在运行时使用类型信息。例如，它会检查一个对象在运行时是否响应某个方法，如果没有，就会抛出错误：
- en: 'AttributeError: ''ComplexNum'' object has no attribute ''imaginry'''
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'AttributeError: ''ComplexNum'' 对象没有属性 ''imaginry'''
- en: A bit unfortunate, isn’t it? In this case, we know that this function only expects
    instances of the ComplexNum class, so it would be nice if our IDE warned us about
    that property being mistyped. And in fact, we can do this using type hints.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有点遗憾，不是吗？在这种情况下，我们知道这个函数只接受 ComplexNum 类的实例，所以如果我们的 IDE 能提醒我们关于属性名的错误输入就好了。事实上，我们可以通过类型提示来实现这一点。
- en: 'In a function or method definition, a type hint goes after the argument name,
    separated by a colon:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数或方法定义中，类型提示位于参数名后面，用冒号分隔：
- en: '[PRE75]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: As you can see, the IDE has signaled to us that ComplexNum has no attribute
    named imaginry.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，IDE 已经提示我们 ComplexNum 类没有名为 imaginry 的属性。
- en: 'In addition to the types we define using classes, we can use Python’s built-in
    types as type hints. For instance, the complex-number initializer expecting two
    floating-point numbers could be written like so:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们使用类定义的类型外，我们还可以使用 Python 的内建类型作为类型提示。例如，复数初始化器期望两个浮点数，可以这样写：
- en: '[PRE76]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'And now our IDE would warn us if we tried to instantiate the class with the
    wrong parameter types:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试使用错误的参数类型实例化类，我们的集成开发环境（IDE）会提醒我们：
- en: '[PRE77]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We can use float for floating-point numbers, int for integers, and str for strings.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `float` 来表示浮点数，`int` 来表示整数，`str` 来表示字符串。
- en: 'These type hints help us during development but have no effect at runtime.
    We’ll be using type hints in many places throughout the book: it takes no time
    to add them, and we get a bit of extra safety.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型提示在开发过程中对我们有所帮助，但在运行时没有任何影响。我们将在本书中的许多地方使用类型提示：它们不需要额外时间来添加，而且能为我们提供一些额外的安全性。
- en: '**Summary**'
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'We discussed two programming paradigms in this chapter: functional programming
    and object-oriented programming. Of course, both of these are huge topics, and
    whole books could be, and have been, written about them. We only scratched the
    surface.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了两种编程范式：函数式编程和面向对象编程。当然，这两者都是庞大的话题，关于它们可以，且已经，写成整本书。我们仅仅触及了表面。
- en: We also talked about magic methods and type hints, two techniques we’ll use
    extensively throughout the book.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了魔法方法和类型提示，这是本书中我们将广泛使用的两种技术。
- en: In the next chapter, we’ll discuss the command line. After that, we’ll start
    writing code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论命令行。之后，我们将开始编写代码。
