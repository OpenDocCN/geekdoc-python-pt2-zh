- en: '2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TWO PYTHON PARADIGMS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve explored some topics in the Python programming language, let’s
    learn about the two main paradigms we can use to write code. In this second chapter
    on Python, we’ll discuss the functional and object-oriented programming paradigms
    and the benefits each brings. We’ll wrap up with a brief look at type hints. Let’s
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional Programming**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional programming is a programming paradigm, which means that it’s a style
    of writing code we can decide to adhere to. For us to say “we’re writing functional-style
    code” we have to follow some simple rules that define what functional programming
    is about.
  prefs: []
  type: TYPE_NORMAL
- en: The central elements of the functional programming paradigm are pure functions
    and the immutability of data. We’ll break these concepts down in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Not all programming languages have good support for writing functional-style
    code. For example, languages like C have no good support for it. On the other
    hand, there are languages, like Haskell, that are purely functional, meaning you
    can only write functional-style code. By design, Python isn’t a functional language,
    but it does have support for the functional programming style.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn about pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Pure Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s quickly review the syntax for a Python function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The definition of a function starts with the def keyword followed by the name
    of the function and the input parameters inside parentheses. A colon (:) marks
    the end of the function header. The code in the body of the function is indented
    one level.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function, in the functional programming paradigm, is similar to the mathematical
    concept of a function: a mapping of some input to some output. We say a function
    is *pure* if'
  prefs: []
  type: TYPE_NORMAL
- en: It consistently returns the same outputs for the same set of inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t have side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A *side effect* happens when something outside the body of the function is
    mutated by the function. A side effect also occurs when the function’s inputs
    are modified by the function, because a pure function never modifies its inputs.
    For example, the following function is pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the same input points p and q, the output is always the same vector,
    and nothing outside the function’s body is modified. In contrast, the following
    code is an impure version of make_vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous snippet uses the shared state of last_point, which is mutated every
    time make_vector is called. This mutation is a side effect of the function. The
    returned vector depends on the last_point shared state, so the function doesn’t
    return the same vector consistently for the same input point.
  prefs: []
  type: TYPE_NORMAL
- en: '***Immutability***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you saw in the previous example, one key aspect of functional programming
    is *immutability*. Something is immutable if it doesn’t change with time. If we
    decide to write code in the functional programming style, we make the firm decision
    of avoiding data mutations and modeling our programs using pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example. Imagine we had defined a point and a vector
    in the plane using dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to compute the point resulting from displacing the existing point
    by the vector, we could do it in a functional way by creating a new point using
    a function. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is pure: given the same point and vector inputs, the resulting
    displaced point is consistently the same, and there is nothing that escapes the
    function’s body that is mutated in any sense, not even the function parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this function, passing in the point and vector defined earlier, we
    get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, a nonfunctional way of solving this case could involve mutating
    the original point using a function like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function mutates the point it receives as an argument, which violates one
    of the key rules of the functional style.
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of in_place in the function name. This is a commonly used naming
    convention that implies that the changes will happen by mutating the original
    object. We’ll adhere to this naming convention throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see how we’d go about using this displace_point_in_place function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the function isn’t returning anything, which is a sign that
    the function isn’t pure, because to do some kind of useful operation it must have
    mutated something somewhere. In this case, that “something” is our point, whose
    coordinates have been updated.
  prefs: []
  type: TYPE_NORMAL
- en: An important benefit of the functional style is that by respecting the immutability
    of data structures, we avoid unintended side effects. When you mutate an object,
    you may not be aware of all the places in your code where that object is referenced.
    If there are other parts in the code relying on that object’s state, there may
    be side effects you are not aware of. So, after the object was mutated, your program
    may behave differently than expected. These kinds of errors are extremely hard
    to hunt down and can require hours of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: If we minimize the number of mutations in our project, we make it more reliable
    and less error prone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now take a look at a special kind of function that has a central role
    in functional programming: the lambda function.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Lambdas***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Back in the 1930s, a mathematician named Alonzo Church invented lambda calculus,
    a theory about functions and how they are applied to their arguments. Lambda calculus
    is the core of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, a *lambda function*, or *lambda*, is an anonymous, typically short
    function defined on a single line. We’ll find lambdas to be useful when passing
    functions as parameters to other functions, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a lambda function in Python using the lambda keyword followed by
    the arguments (separated by commas), a colon, and the function’s expression body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The expression’s result is the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lambda function to sum two numbers can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the regular Python function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Lambdas are going to appear in the next sections; we’ll see there how they’re
    used in several contexts. The place we’ll be using lambdas the most is as arguments
    to the filter, map, and reduce functions, as we’ll discuss in “Filter, Map, and
    Reduce” on [page 29](ch02.xhtml#ch00lev2sec22).
  prefs: []
  type: TYPE_NORMAL
- en: '***Higher-Order Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *higher-order* function is a function that either receives a function (or
    functions) as input parameters or returns a function as its result.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at examples for both cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions As Function Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Imagine we want to write a function that can run a function a given number
    of times. We could implement this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the repeat_fn function’s first parameter is another function,
    which is executed as many times as the second argument times dictates. Then, we
    define another function to simply print the string "Hi there!" to the screen:
    say_hi. The result of calling the repeat_fn function and passing it say_hi is
    those five greetings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite the previous example using an anonymous lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This spares us from having to define a named function to print the message.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions As Function Return Values**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s take a look at a function that returns another function. Imagine we want
    to define validation functions that validate if a given string contains a sequence
    of characters. We can write a function named make_contains_validator that takes
    a sequence and returns a function to validate strings that contain that sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can use this function to generate validation functions, like the following
    one,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'which can be used to check whether the passed-in strings contain the @ character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Higher-order functions are a useful resource we’ll use throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: '***Functions Inside Other Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another convenient technique we’ll use throughout this book is defining a function
    inside another function. There are two good reasons we may want to do this: for
    one, it gives the inner function access to everything inside the outer function,
    without needing to pass that information as parameters; and also, the inner function
    may define some logic that we don’t want to expose to the outside world.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can be defined inside another function using the regular syntax.
    Let’s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the inner_fn function is defined inside the outer_fn function, and thus,
    it can’t be accessed from outside this host function, only from within its body.
    The inner_fn function has access to everything defined inside outer_fn, including
    the function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining subfunctions inside of functions is useful when a function’s logic
    grows complex and it can be broken down into smaller tasks. Of course, we could
    also split the function into smaller functions all defined at the same level.
    In this case, to signal that those subfunctions are not meant to be imported and
    consumed from outside the module, we’ll follow Python’s standard and name those
    functions starting with two underscores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that Python has no access modifiers (public, private, . . .); thus, all
    the code written at the top level of a module, that is, a Python file, can be
    imported and used.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the two underscores are just a convention that we have to respect.
    Nothing really prevents us from importing and using that code. If we import a
    function that starts with two underscores, we have to understand that the function
    was not written by its authors to be used from the outside, and we may get unexpected
    results if we call that function. By defining our subfunctions within the functions
    that call them, we prevent this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '***Filter, Map, and Reduce***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In functional programming, we never mutate a collection’s items, but instead
    always create a new collection to reflect the changes of an operation over that
    collection. There are three operations that form the cornerstone of functional
    programming and can accomplish every modification to a collection we can ever
    think of: filter, map, and reduce.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filter**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *filter* operation takes a collection and creates a new collection where
    some items may have been left out. The items are filtered according to a *predicate
    function*, which is a function that accepts one argument and returns either True
    or False depending on whether that argument passes a given test.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-1](ch02.xhtml#ch2fig1) illustrates the filter operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: Filtering a collection*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-1](ch02.xhtml#ch2fig1) shows a source collection made of four elements:
    A, B, C, and D. Below the collection is a box representing the predicate function,
    which determines which elements to keep and which to discard. Each element in
    the collection is passed to the predicate, and only those that pass the test are
    included in the resulting collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways we can filter collections in Python: using the filter global
    function and, if the collection is a list, using list comprehensions. We’ll focus
    on the filter function here; we’ll cover list comprehensions in the next section.
    Python’s filter function receives a function (the predicate) and collection as
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s write a predicate lambda function to test whether a number is even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s use our lambda function to filter a list of numbers and obtain a
    new collection with only even numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note is that the filter function doesn’t return a list, but rather
    an iterator. Iterators allow for iteration over a collection of items, one at
    a time. If you want to know more about Python iterators and how they work under
    the hood, please refer to the documentation at [*https://docs.python.org/3/library/stdtypes.html#typeiter*](https://docs.python.org/3/library/stdtypes.html#typeiter)
    and [*https://docs.python.org/3/glossary.html#term-iterator*](https://docs.python.org/3/glossary.html#term-iterator).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can consume all the iterator values and put them into a list using the list
    function we saw earlier. We can also consume the iterator using a for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Map**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *map* operation creates a new collection by taking each item in the source
    collection and running it through a function, storing the results in a new collection.
    The new collection is the same size as the source collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-2](ch02.xhtml#ch2fig2) illustrates the map operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: Mapping a collection*'
  prefs: []
  type: TYPE_NORMAL
- en: We run our source collection made of items A, B, C, and D through a mapping
    function, illustrated within a rectangle in [Figure 2-2](ch02.xhtml#ch2fig2);
    the result of the mapping is stored in a new collection.
  prefs: []
  type: TYPE_NORMAL
- en: We can map a collection either using the global map function or, if we have
    a list, using list comprehensions. We’ll discuss list comprehensions in a moment;
    for now, let’s study how to map collections using the map function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The map global function receives two parameters: a mapping function and a source
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we would map a list of names to their length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the filter function, map returns an iterator that can be consumed into
    a list using the list function. In the previous example, the resulting list contains
    the number of letters in each of the names in the names list: five letters in
    *Angel*, six letters in *Alvaro*, and so on. We’ve mapped each name into a number
    representing its length.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduce**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *reduce* operation is the most complex, but at the same time, it’s the most
    versatile of the three. It creates a new collection that can have fewer items
    than, more items than, or the same number of items as the original. To construct
    this new collection, it first applies a reducer function to the first and second
    elements. It then applies the reducer function to the third element *and* the
    result of the first application. It then applies the reducer function to the fourth
    element and the result of the second application. In this way, the results accumulate.
    A figure will help here. Take a look at [Figure 2-3](ch02.xhtml#ch2fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Reducing a collection*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reduction function in this example concatenates every element in the collection
    (A, B, C, and D) into a single element: ABCD.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reducer function takes two parameters: the accumulated result and an item
    in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The function is expected to return the accumulated result after the new item
    has been processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s no global reduce function provided by Python, but there is a package
    named *functools* with some useful operations for working with higher-order functions,
    including a reduce function. This function doesn’t return an iterator, but rather
    it returns the resulting collection or item directly. The function’s signature
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s work with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the reduce function returned a single item: ’ABCD’, the result
    of concatenating each letter in the collection. To start the reduction process,
    the reduce function takes the first two letters, *A* and *B*, and concatenates
    them into *AB*. For this first step, Python uses the initial item of the collection
    (*A*) as the accumulated result and applies the reducer to it and the second item.
    Then, it moves to the third letter, *C*, and concatenates it with the current
    accumulated result *AB*, thus producing the new result: *ABC*. The last step does
    the same with the *D* letter to produce the result *ABCD*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when the accumulated result and the items of the collection have
    different types? In that case, we can’t take the first item as the accumulated
    result, and thus the reduce function expects us to provide a third argument to
    use as the starting accumulated result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, imagine that we have the collection of names from earlier and
    we want to reduce it to obtain the total sum of the lengths of those names. In
    this case, the accumulated result is numeric, whereas the items in the collection
    are strings; we can’t use the first item as the accumulated length. If we forget
    to provide reduce with the start result, Python is nice enough to remind us by
    raising an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For this case, we should pass 0 as the initial accumulated length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'One interesting note here is that if the accumulated result and the items of
    the collection have different types, you can always concatenate a map with a reduce
    to obtain the same result. For example, in the previous exercise we could have
    also done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code we first map the names list into a list of the name lengths: lengths.
    Then, we reduce the lengths list to sum all the values, with no starting value
    necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When reducing items using a common operation—like a sum of two numbers or a
    concatenation of two strings—we don’t need to write a lambda function ourselves;
    we can simply pass the reduce function an existing Python function. For example,
    when reducing numbers, there’s a useful module provided by Python named *operator.py*.
    This module defines functions to operate with numbers, among others. Using this
    module, we can simplify our previous example to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code is shorter and more readable, so we’ll prefer this form throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operator.add function is defined by Python as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this function is equivalent to the lambda function we defined
    to sum two numbers. We’ll see more examples of functions defined by Python that
    can be used with reduce throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all of our examples have reduced collections to a single value, but
    the reduce operation can do much more. In fact, both the filter and map operations
    are specializations of the reduce operation. We can filter and map a collection
    using only a reduce operation. But this isn’t something we’ll stop to analyze
    here; try to figure it out on your own if you feel motivated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example where we want to create a new collection based on the
    names list, where every item is the concatenation of all the previous names with
    the current name separated by the hyphen character (-). The result we’re looking
    for should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use compute_next_name to determine the next item in the sequence. The
    lambda used inside reduce concatenates the accumulated result, which is the list
    of stitched-together names, with a new list consisting of the new item. The initial
    solution, an empty list, needs to be provided, since once again the type of each
    item in the list (string) is different from the result (list of strings).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the reduce operation is very versatile.
  prefs: []
  type: TYPE_NORMAL
- en: '***List Comprehensions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned earlier, we can filter and map lists in Python using list comprehensions.
    This form is typically preferred over the filter and map functions when dealing
    with lists, as its syntax is more concise and readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list comprehension to map items has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two parts to it:'
  prefs: []
  type: TYPE_NORMAL
- en: for *<item>* in *<list>* is the for loop that iterates over the items in *<list>*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<expression>* is a mapping expression to map *<item>* into something else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s repeat the exercise we did earlier where we mapped a list of names to
    a list of the lengths of each name, this time using a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'I hope you see why Python programmers favor list comprehensions over the map
    function; the example almost reads like plain English: “length of name for (each)
    name in names.” In the example, for name in names iterates over the names in the
    original list and then uses the length of each name (len(name)) as the result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To filter a list using a list comprehension we can add an if clause at the
    end of the comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to, for example, filter a list of names, this time keeping only
    those that start with *A*, we could write the following list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Note two things from this example: the mapping expression is the name itself
    (an identity mapping, which is the same as no mapping), and the filter uses the
    string startswith method. This method returns True only if the string has the
    given argument as a prefix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can filter and map in the same list comprehension. For example, let’s say
    we want to take our list of names and filter out those that have more than five
    letters and then construct a new list whose elements are a tuple of the original
    name and its length. We could do this easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For comparison’s sake, let’s see what this would look like if we decided to
    use the filter and map functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the result is the same, but the list comprehension version is
    simpler and more readable. What’s easier to read is easier to maintain, so list
    comprehensions are going to be our preferred way of filtering and mapping lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now turn our attention to the second paradigm we’ll be exploring in this
    chapter: object-oriented programming.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-Oriented Programming**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we talked about functional programming and some functional
    patterns. Now we’ll learn about another paradigm: the *object-oriented paradigm*.
    As the function is to functional programming, the object is to object-oriented
    programming. So, first things first: What’s an object?'
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways we could describe what an object is. I’m going to deviate
    from the standard academic definition of an object in object-oriented programming
    theory and try a rather unconventional explanation.
  prefs: []
  type: TYPE_NORMAL
- en: From a practical standpoint, we can think of objects as experts on a given subject.
    We can ask them questions, and they will give us information; or we can request
    that they do things for us, and they will do them. Our questions or requests may
    require complex operations, but these experts hide the complexity from us so that
    we don’t need to worry about the details—we just care about getting the job done.
  prefs: []
  type: TYPE_NORMAL
- en: For example, think of a dentist. When you go to the dentist, you don’t need
    to know anything about dentistry yourself. You rely on the dentist’s expertise
    to get your cavities fixed. You can also ask the dentist questions about your
    teeth, and the dentist will respond using a language that you can understand,
    hiding the real complexity of the subject. In this example, the dentist would
    be an object you’d rely on for odontology-related tasks or queries.
  prefs: []
  type: TYPE_NORMAL
- en: To request things from an object, we call one of the object’s *methods*. Methods
    are functions that belong to a given object and have access to the object’s internals.
    The object itself has some memory that contains data that is typically hidden
    to the outside world, although the object may decide to expose some of this data
    in the form of *properties*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A method is a function that belongs to a class: it’s part of the class definition.
    It needs to be called (executed) on the instance of the class where it’s defined.
    By contrast, a function doesn’t belong to any class; it works on its own.*'
  prefs: []
  type: TYPE_NORMAL
- en: In Python’s parlance, any function or variable in an object is called an *attribute*.
    Both properties and methods are attributes. We’ll be using these equivalent terms
    throughout this chapter and the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now get practical and see how we can define and work with objects in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '***Classes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *class* defines how objects are constructed and what characteristics and knowledge
    they have. Some people like to compare classes to blueprints; they are general
    descriptions of what information the object holds and what it can do. Objects
    and classes are related but distinct; if the class is the blueprint, the object
    is the finished building.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a new class in Python using the reserved class keyword. By convention,
    class names start with an uppercase letter and use an uppercase letter at the
    start of every new word (this case is commonly known as *Pascal case*). Let’s
    create a class that models a coffee machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this listing we define a new class representing a coffee machine. We can
    use this class to generate new coffee machine objects, in a process referred to
    as *instantiation*. When we instantiate a class, we create a new object of that
    class. A class is instantiated by calling its name as if it were a function that’s
    returning the instantiated object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the machine object whose functionality is defined by the Coffee
    Machine class (which is still empty, but we’ll complete it in the following sections).
    When a class is instantiated, its __init__ function is called. Inside this __init__
    function, we can perform one-time initialization tasks. For example, here we add
    a count of the number of brewed coffees and set it to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notice the two underscores at the beginning of __coffees_brewed. If you remember
    from our discussion on access levels earlier, in Python, by default, everything
    is visible to the outside. The double underscore naming pattern is used to signify
    that something is private and no one is expected to access it directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we don’t want the outside world to access __coffees_brewed; they
    could change the coffees brewed count at will!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So if we can’t access __coffees_brewed, how do we know how many coffees our
    machine has brewed? The answer is properties. Properties are a class’s read-only
    attributes. Before we can discuss properties, however, we have some syntax to
    cover.
  prefs: []
  type: TYPE_NORMAL
- en: '**self**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you look at the previous example, you’ll see that we make frequent use of
    a variable named self. We could use any other name for this variable, but self
    is used by convention. As you saw earlier, we pass it to the definition of every
    function inside the class, including the initializer. Thanks to this first parameter,
    self, we gain access to whatever is defined in the class. In the __init__ function,
    for example, we append the __coffees_brewed variable to self; from that point
    on, this variable exists in the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable self needs to appear as the first parameter in the definition
    of every function inside the class, but it doesn’t need to be passed as the first
    argument when we call those functions on instances of the class. For example,
    to instantiate the CoffeeMachine class, we wrote the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The initializer was called without parameters (no self here). If you think
    about it, how could we possibly pass the initializer as self in this case if we
    haven’t yet initialized the object? As it turns out, Python takes care of that
    for us: we’ll never need to pass self to the initializer or any of the object’s
    methods or properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The self reference is how different attributes of a class have access to the
    other definitions in the class. For example, in the brew_coffee method we’ll write
    later, we use self to access the __coffees_brewed count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With an understanding of self, we can move on to properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class Properties**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An object’s *property* is a read-only attribute that returns some data. A property
    of an object is accessed using *dot notation*: *object.property*. Following our
    coffee machine example, we could add a coffees_brewed property (the number of
    coffees brewed by the machine), like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we could access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Properties are defined as functions using the @property decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Properties shouldn’t accept any parameter (except for the customary self),
    and they should return something. A property that doesn’t return anything or expects
    parameters is conceptually wrong: properties should just be read-only data we
    request the object to give us.'
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that @property is an example of a decorator. Python decorators
    allow us to modify a function’s behavior. The @property modifies the function
    of a class so that it can be consumed as if it were an attribute of the class.
    We won’t use any other decorators in this book, so we won’t cover them here, but
    I encourage you to read up on them if you’re interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties get us information about an object. For instance, if we wanted to
    know whether a given instance of a CoffeeMachine has brewed at least one coffee,
    we could include a property like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now ask instances of the CoffeeMachine class whether they’ve brewed
    at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This machine hasn’t prepared any coffee yet, so how can we ask a CoffeeMachine
    instance to brew a coffee for us? We use methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class Methods**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Properties allow us to know something about an object: they answer our queries.
    To request an object to perform some task for us, we use methods. A *method* is
    nothing more than a function that belongs to a class and has access to the attributes
    defined in that class. In our CoffeeMachine class example, let’s write a method
    to request it to brew some coffee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Methods get self as their first parameter, which gives them access to everything
    defined inside the class. As we discussed earlier, when calling a method on an
    object, we never pass self ourselves; Python does it for us.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Note that properties are like methods decorated with* @property*. Both properties
    and methods expect* self *as their first argument. When calling a method, we use
    parentheses and optionally pass it arguments, but properties are accessed without
    parentheses.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the brew_coffee method on an instance of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve brewed our first coffee, we can ask the instance this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you see, methods have to be called on a particular instance of a class (an
    object). This object will be the one responding to the request. So, whereas functions
    are called without a particular receiver, like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: methods have to be called on an object, like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects can only respond to the methods defined in the class that created them.
    If a method (or any attribute for that matter) is called on an object but this
    method wasn’t defined in the class, an AttributeError is raised. Let’s try this.
    Let’s order our coffee machine to brew tea even though we never gave it the instructions
    on how to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, our object complained: we never told it we expected it to know how to
    prepare tea. Here’s the key to its complaint:'
  prefs: []
  type: TYPE_NORMAL
- en: '''CoffeeMachine'' object has no attribute ''brew_tea'''
  prefs: []
  type: TYPE_NORMAL
- en: 'Lesson learned: don’t ever request an object to do something it wasn’t taught;
    it’ll just freak out and make your program fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods can accept any number of parameters, which in our class have to be
    defined after the first mandatory argument: self. For example, let’s add a method
    to our CoffeeMachine class that allows us to fill it with a given amount of water.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fill the coffee machine instance by calling our new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: One last thing to know about methods before we move on is how powerful their
    dynamic dispatch nature is. When a method is called on an object, Python will
    check whether the object responds to that method or not, but, and here’s the key,
    Python doesn’t care about the object’s class as long as this class has the requested
    method defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this feature to define different objects that respond to the same
    method (by same method we mean same name and arguments) and use them interchangeably.
    For instance, we could define a new, more modern coffee-producer entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write a function that expects a coffee producer (any object whose
    class defines a brew_cofee() method) and does something with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This function works with both an instance of CoffeeMachine and CoffeeHipster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: For this technique to work, we need to make sure that the methods have the same
    signature, that is, they’re called the same and expect exactly the same parameters
    with the same names.
  prefs: []
  type: TYPE_NORMAL
- en: '***Magic Methods***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are some special methods our classes may define that are known as *magic
    methods* or *dunder methods* (short for *double underscore*). These methods aren’t
    typically called by us directly, but Python uses them under the hood, as we’ll
    see in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already used one such method: __init__, which we used as the initializer
    when instantiating objects. This __init__ method defines the code that’s executed
    when a new instance of a class is created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One prominent use case for magic methods (which we’ll use a lot throughout
    the book) is overloading operators. Let’s see this through an example. Imagine
    we implement a class to represent complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'How would we go about implementing the addition operation on ComplexNum instances?
    A first option could be including a method called plus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'which we could use like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This is okay, but it would be nicer if we could instead use the + operator
    like we do with any other number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Python includes a magic method, __add__; if we implement that method, then
    we can use the + operator as shown earlier, and Python will call this __add__
    method under the hood. So if we rename our plus method __add__, we can automatically
    add ComplexNums using the + operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'There are more magic methods we can implement in our classes to perform subtraction,
    division, comparisons, and more. You can take a brief look at [Table 4-1](ch04.xhtml#ch4tab1)
    on [page 70](ch04.xhtml#ch4tab1) for a reference of the operations we can implement
    with magic methods. For example, subtracting two of our complex numbers using
    the - operator would be as simple as implementing the __sub__ method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the - operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'What about comparing two instances for equality using the == operator? Simply
    implement the __eq__ magic method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can easily compare complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We’ll be using some magic methods throughout the book; they really improve the
    readability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now change topics and learn about type hints.
  prefs: []
  type: TYPE_NORMAL
- en: '**Type Hints**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python *type hints* are a small help we can use when writing code to make sure
    we don’t mistype the name of a method or property of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s use the implementation of a complex number from the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now say that we write a function that takes an instance of ComplexNum as an
    argument, and we want to extract the imaginary part of the number, but we’re a
    bit sleepy and mistakenly write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Did you spot the typo? Well, since we know nothing about the complex argument,
    there’s no visual clue our IDE can give us. As far as the IDE knows, imaginry
    is a perfectly valid attribute name, and it won’t be until we run the program
    and pass a complex number that we get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is a dynamically typed language: it uses type information at runtime.
    For example, it checks whether a given type of object responds to a method at
    runtime, and if it doesn’t, an error is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: 'AttributeError: ''ComplexNum'' object has no attribute ''imaginry'''
  prefs: []
  type: TYPE_NORMAL
- en: A bit unfortunate, isn’t it? In this case, we know that this function only expects
    instances of the ComplexNum class, so it would be nice if our IDE warned us about
    that property being mistyped. And in fact, we can do this using type hints.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a function or method definition, a type hint goes after the argument name,
    separated by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the IDE has signaled to us that ComplexNum has no attribute
    named imaginry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the types we define using classes, we can use Python’s built-in
    types as type hints. For instance, the complex-number initializer expecting two
    floating-point numbers could be written like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'And now our IDE would warn us if we tried to instantiate the class with the
    wrong parameter types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We can use float for floating-point numbers, int for integers, and str for strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'These type hints help us during development but have no effect at runtime.
    We’ll be using type hints in many places throughout the book: it takes no time
    to add them, and we get a bit of extra safety.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We discussed two programming paradigms in this chapter: functional programming
    and object-oriented programming. Of course, both of these are huge topics, and
    whole books could be, and have been, written about them. We only scratched the
    surface.'
  prefs: []
  type: TYPE_NORMAL
- en: We also talked about magic methods and type hints, two techniques we’ll use
    extensively throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll discuss the command line. After that, we’ll start
    writing code.
  prefs: []
  type: TYPE_NORMAL
