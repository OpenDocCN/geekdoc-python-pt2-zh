- en: '**1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PYTHON REFRESHER**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/comm-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The purpose of this chapter is to refresh your knowledge of basic Python data
    structures, keywords, control flow operations, and other fundamentals. I wrote
    this book for intermediate Python programmers who want to reach the next level
    of programming expertise. To get to the expert level, you need a thorough study
    of the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics allows you to take a step back and see the bigger picture—an
    important skill whether you want to become tech lead at Google, a computer science
    professor, or just a great programmer. For instance, computer science professors
    will often have an incredibly profound knowledge of the basics in their field
    that allows them to argue from first principles and identify research gaps, rather
    than being blinded by the latest state-of-the-art technology. This chapter presents
    the most important Python basics, which serve as a foundation for the more advanced
    topics in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Data Structures**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A thorough understanding of data structures is one of the most fundamental skills
    you can acquire as a programmer. It will help you no matter whether you create
    machine learning projects, work on large code bases, set up and manage websites,
    or write algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '***Numerical Data Types and Structures***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The two most important numerical data types are the integer and float. An *integer*
    is a positive or negative number without a floating point (for example, 3). A
    *float* is a positive or negative number with floating-point precision (for example,
    3.14159265359). Python offers a wide variety of built-in numerical operations,
    as well as functionality to convert between those numerical data types. Study
    the examples in [Listing 1-1](#list1-1) carefully to master these highly important
    numerical operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-1: The numerical data types*'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the operators are self-explanatory. Note that the `//` operator performs
    integer division. The result is an integer value that is rounded down (for example,
    `3 // 2 == 1`).
  prefs: []
  type: TYPE_NORMAL
- en: '***Booleans***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A variable of type *Boolean* can take only two values—either `False` or `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, Boolean and integer data types are closely related: the Boolean
    data type internally uses integer values (by default, the Boolean value `False`
    is represented by integer `0`, and the Boolean value `True` is represented by
    integer `1`). [Listing 1-2](#list1-2) gives an example of these two Boolean keywords.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-2: The Boolean values `False` and `True`*'
  prefs: []
  type: TYPE_NORMAL
- en: After evaluating the given expressions, variable `x` refers to the Boolean value
    `False`, and variable `y` refers to the Boolean value `True`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Booleans with three important keywords to create more-complicated
    expressions in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Keywords: and, or, not**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Boolean expressions represent basic logical operators. Using them in combination
    with only the following three keywords, you can craft a wide variety of potentially
    complicated expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`and`** The expression `x and y` evaluates to `True` if value `x` is `True`
    *and* value `y` is `True`. If either of those is `False`, the overall expression
    becomes `False` too.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`or`** The expression `x or y` evaluates to `True` if value `x` is `True`
    *or* value `y` is `True` (or both values are `True`). If even just one of those
    is `True`, the overall expression becomes `True` too.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`not`** The expression `not x` evaluates to `True` if value `x` is `False`.
    Otherwise, the expression evaluates to `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following Python code in [Listing 1-3](#list1-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-3: The keywords `and`, `or`, and `not`*'
  prefs: []
  type: TYPE_NORMAL
- en: By using these three keywords, you can express all the logical expressions you’ll
    ever need.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean Operator Precedence**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The order that Boolean operators are applied is an important aspect of understanding
    Boolean logic. For example, consider the natural language statement `"it rains
    and it''s cold or windy"`. We can interpret this in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`"(it rains and it''s cold) or windy"`** In this case, the statement would
    be `True` if it is windy—even if it doesn’t rain.'
  prefs: []
  type: TYPE_NORMAL
- en: '**`and "it rains and (it''s cold or windy)"`** In this case, however, the statement
    would be `False` if it doesn’t rain—no matter whether it’s cold or windy.'
  prefs: []
  type: TYPE_NORMAL
- en: The order of Boolean operators matters. The correct interpretation of this statement
    would be the first one because the `and` operator takes precedence before the
    `or` operator. Let’s consider the code snippet in [Listing 1-4](#list1-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-4: The Boolean data type*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code shows two important points. First, Boolean operators are ordered
    by priority—the operator `not` has the highest priority, followed by the operator
    `and`, followed by the operator `or`. Second, the following values are automatically
    evaluated to `False`: the keyword `None`, the integer value `0`, the float value
    `0.0`, empty strings, or empty container types.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Strings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python *strings* are sequences of characters. Strings are immutable and so
    cannot be changed after creation. While other ways to create strings exist, these
    are the five most commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single quotes** `''Yes''`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Double quotes** `"Yes"`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Triple quotes for multiline strings** `''''''Yes''''''` or `"""Yes"""`'
  prefs: []
  type: TYPE_NORMAL
- en: '**The string method** `str(5) == ''5''` is `True`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concatenation** `''Py'' + ''thon''` becomes `''Python''`'
  prefs: []
  type: TYPE_NORMAL
- en: Often, you’ll explicitly want to use *whitespace characters* in strings. The
    most frequently used whitespace characters are the newline character `\n`, the
    space character `\s`, and the tab character `\t`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-5](#list1-5) shows the most important string methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-5: The string data type*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This non-exclusive list of string methods shows that the string data type is
    powerful, and you can solve many common string problems with built-in Python functionality.
    If in doubt about how to achieve a certain result regarding string problems, consult
    the online reference listing all built-in string methods: [*https://docs.python.org/3/library/string.html#module-string*](https://docs.python.org/3/library/string.html#module-string).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Booleans, integers, floats, and strings are the most important basic data types
    in Python. But often, you’ll need to *structure* data items rather than just create
    them. In those cases, container types are the answer. But before we dive into
    container data structures, let’s quickly learn about an important special data
    type: `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Keyword None***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The keyword `None` is a Python constant and it means *the absence of a value*.
    Other programming languages such as Java use the value `null` instead. However,
    the term `null` often confuses beginners, who assume it’s equal to the integer
    value `0`. Instead, Python uses the keyword `None`, as shown as [Listing 1-6](#list1-6),
    to indicate that it’s different from any numerical value for zero, an empty list,
    or an empty string. An interesting fact is that the value `None` is the only value
    in the `NoneType` data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-6: Using the keyword `None`*'
  prefs: []
  type: TYPE_NORMAL
- en: This code shows several examples of the `None` data value (and what it is not).
    If you don’t define a return value for a function, the default return value is
    `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Container Data Structures**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python ships with *container data types* that can handle complex operations
    efficiently while being easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lists***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *list* is a container data type that stores a sequence of elements. Unlike
    strings, lists are *mutable*—you can modify them at runtime. I can best describe
    the list data type with a series of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet shows how to create a list by using square brackets and how
    to populate it with three integer elements. You can also see that lists can have
    repeated elements. The `len()` function returns the number of elements in a list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Keyword: is**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The keyword `is` simply checks whether both variables refer to the same object
    in memory. This can confuse Python newcomers. [Listing 1-7](#list1-7) checks whether
    two integers and two lists refer to the same object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-7: Using the keyword `is`*'
  prefs: []
  type: TYPE_NORMAL
- en: If you create two lists—even if they contain the same elements—they still refer
    to two different list objects in memory. Modifying one list object does not affect
    the other list object. We say that lists are *mutable* because you can modify
    them after creation. Therefore, if you check whether one list refers to the same
    object in memory, the result is `False`. However, integer values are *immutable*,
    so there is no risk of one variable changing the object that will then accidentally
    change all other variables. The reason is that you cannot change the integer object
    `3`—trying it will only create a new integer object and leave the old one unmodified.
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding Elements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Python provides three common ways to add elements to an existing list: *append*,
    *insert*, or *list concatenation*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: All three operations generate the same list `[1, 2, 2, 4]`. But the *append*
    operation is the fastest because it neither has to traverse the list to insert
    an element at the correct position (as with *insert*), nor create a new list out
    of two sublists (as with *list concatenation*). Roughly speaking, you use the
    insert operation only if you want to add an element at a specific position in
    the list that is not the last position. And you use the list concatenation operation
    to concatenate two lists of arbitrary length. Note that a fourth method, `extend()`,
    allows you to append multiple elements to the given list in an efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: '**Removing Elements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can easily remove an element *`x`* from a list by using the `list` method
    `remove(`*`x`*`)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The method operates on the list object itself, rather than creating a new list
    with the changes made. In the previous code example, we create a list object named
    `l` and modify this exact object in memory by removing an element. This saves
    memory overhead by reducing redundant copies of the same list data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reversing Lists**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can reverse the order of list elements by using the method `list.reverse()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Reversing the list also modifies the original list object and does not merely
    create a new list object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting Lists**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can sort list elements by using the method `list.sort()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again, sorting the list modifies the original list object. The resulting list
    is sorted in an ascending manner. Lists containing string objects would be sorted
    in an ascending lexicographical manner (from `'a'` to `'z'`). In general, the
    sorting function assumes that two objects can be compared. Roughly speaking, if
    you can calculate `a > b` for objects `a` and `b` of any data type, Python can
    also sort the list `[a, b]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexing List Elements**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can find out the index of a specified list element *`x`* by using the method
    `list.index(`*`x`*`)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The method `index(`*`x`*`)` finds the first occurrence of the element *`x`*
    in the list and returns its index. Like other major programming languages, Python
    assigns index 0 to the first sequence and index *i*–1 to the *i*-th sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '***Stacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *stack* data structure works intuitively as a first-in, first-out (FIFO)
    structure. Think of it as a stack of paperwork: you place every new paper on the
    top of a pile of old papers, and when you work through the stack, you keep removing
    the topmost document. The stack is still a fundamental data structure in computer
    science, used in operating system management, algorithms, syntax parsing, and
    backtracking.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python lists can be used intuitively as stacks with the list operations `append()`
    to add to the stack and `pop()` to remove the most recently added item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Because of the efficiency of the list implementation, there is usually no need
    to import external stack libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *set* data structure is a basic collection data type in Python and many
    other programming languages. Popular languages for distributed computing (for
    example, MapReduce or Apache Spark) even focus almost exclusively on set operations
    as programming primitives. So what is a set exactly? A set is an unordered collection
    of unique elements. Let’s break this definition into its main pieces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Collection**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A set is a collection of elements like a list or a tuple. The collection consists
    of either primitive elements (integers, floats, strings), or complex elements
    (objects, tuples). However, all data types in a set must be *hashable*, meaning
    that they have an associated hash value. A hash value of an object never changes
    and is used to compare the object to other objects. Let’s look at an example in
    [Listing 1-8](#list1-8), which creates a set from three strings after checking
    their hash values. You try to create a set of lists, but fail because lists are
    not hashable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-8: The set data type allows for only hashable elements.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a set of strings because strings are *hashable*. But you cannot
    create a set of lists, because lists are *unhashable*. The reason is that the
    hash value depends on the content of the item, and lists are *mutable*; if you
    change the list data type, the hash value must change too. Because mutable data
    types are not hashable, you cannot use them in sets.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unordered**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Unlike lists, elements in a set have no fixed order. Regardless of the order
    in which you put stuff into the set, you can never be sure in which order the
    set stores these elements. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I put in the hero first, but my interpreter prints the enemy first (the Python
    interpreter is on the dark side, obviously). Note that your interpreter may print
    yet another order of the set elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unique**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'All elements in the set must be unique. Formally, each of two values `x, y`
    in the set with `x!=y` have different hash values `hash(x)!=hash(y)`. Because
    every two elements `x` and `y` in the set are different, you cannot create an
    army of Harry Potter clones to fight Lord V.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: No matter how often you put the same value into the same set, the set stores
    only one instance of this value. The reason is that those heroes have the same
    hash value, and a set contains at most one element per hash value. An extension
    of the normal set data structure is the *multiset data structure*, which can store
    multiple instances of the same value. However, it is seldom used in practice.
    In contrast, you will use sets in almost any nontrivial code project—for example,
    to intersect a set of customers with a set of persons who visited a store, which
    will return a new set of customers who also visited the store.
  prefs: []
  type: TYPE_NORMAL
- en: '***Dictionaries***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *dictionary* is a useful data structure for storing `(`*`key, value`*`)`
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can read and write elements by specifying the key within brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `keys()` and `values()` functions to access all keys and values of
    the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Access the `(`*`key, value`*`)` pairs of a dictionary with the `items()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This way, it’s easy to iterate over all keys and all values in a dictionary
    without accessing them individually.
  prefs: []
  type: TYPE_NORMAL
- en: '***Membership***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use the keyword `in` to check whether the set, list, or dictionary contains
    an element (see [Listing 1-9](#list1-9)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-9: Using the keyword `in`*'
  prefs: []
  type: TYPE_NORMAL
- en: You use the keyword `in` to test membership of the integer value `42` ➊ in a
    list of integer values or to test membership of a string value `"21"` in a set
    of strings ➋. We say *x* is a *member* of *y* if element *x* appears in the collection
    *y*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking set membership is faster than checking list membership: to check whether
    element *x* appears in list *y*, you need to traverse the whole list until you
    find *x* or have checked all elements. However, sets are implemented much like
    dictionaries: to check whether element *x* appears in set *y*, Python internally
    performs one operation *`y`*`[hash(`*`x`*`)]` and checks whether the return value
    is not `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***List and Set Comprehension***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*List comprehension* is a popular Python feature that helps you quickly create
    and modify lists. The simple formula is `[` *`expression`* `+` *`context`* `]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expression** Tells Python what to do with each element in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context** Tells Python which list elements to select. The context consists
    of an arbitrary number of `for` and `if` statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the list comprehension statement `[x for x in range(3)]`, the
    first part `x` is the (identity) expression, and the second part `for x in` `range(3)`
    is the context. The statement creates the list `[0, 1, 2]`. The `range()` function
    returns a range of subsequent integer values 0, 1, and 2—when used with one argument
    as in the example. Another code example for list comprehension is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Set comprehension is like list comprehension, but creates a set rather than
    a list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Control Flow**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Control flow* functionality allows you to make decisions in your code. Algorithms
    are often compared to cooking recipes that consist of a sequential list of commands:
    fill the pot with water, add salt, add rice, drain the water, and serve the rice.
    As it is, without a *conditional execution*, the sequence of commands would take
    only a few seconds to execute, and the rice would not be ready for sure. For example,
    you would fill in water, salt, and rice and immediately get rid of the water without
    waiting for the water to be hot and the rice to be soft.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to respond in a different way to different circumstances: you need
    to put the rice in the pot only *if* the water is hot, and you need to remove
    the water from the pot only *if* the rice is soft. It’s almost impossible to write
    programs in a way that anticipates what happens deterministically in the real
    world. Instead, you need to write programs that respond differently if different
    conditions are met.'
  prefs: []
  type: TYPE_NORMAL
- en: '***if, else, and elif***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The keywords `if`, `else`, and `elif` (see [Listing 1-10](#list1-10)) enable
    you to perform conditional execution of different code branches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-10: Using the keywords `if`, `else`, and `elif`*'
  prefs: []
  type: TYPE_NORMAL
- en: This first takes the user input, converts it into an integer, and stores it
    in the variable `x` ➊. It then tests whether the variable value is larger than
    ➋, equal to ➌, or smaller than ➍ the value `3`. In other words, the code responds
    to real-world input that is *unpredictable* in a differentiated manner.
  prefs: []
  type: TYPE_NORMAL
- en: '***Loops***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To allow for repeated execution of code snippets, Python uses two types of
    loops: `for` loops and `while` loops. Using these, you can easily write a program
    consisting only of two lines of code that execute forever. This repetition would
    be difficult otherwise (an alternative is *recursion*.)'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 1-11](#list1-11), you can see both loop variants in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-11: Using the keywords `for` and `while`*'
  prefs: []
  type: TYPE_NORMAL
- en: Both loop variants print the integers `0`, `1`, and `2` to the shell, but accomplish
    the task in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop declares a loop variable `i` that iteratively takes on all values
    in the list `[0, 1, 2]`. It keeps running until it runs out of values.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop executes the loop body as long as a particular condition is
    met—in our case, while `j < 3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two fundamental ways of terminating a loop: you can define a loop
    condition that eventually evaluates to `False`, or use the keyword `break` at
    the exact position in the loop body. [Listing 1-12](#list1-12) shows an example
    of the latter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-12: Using the keyword `break`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You create a `while` loop with a loop condition that will always evaluate to
    `True`. So, at first sight, it seems to run forever. An infinite `while` loop
    is common practice when, for example, developing web servers that forever repeat
    the following procedure: wait for a new web request and serve the request. However,
    in some cases, you’ll still want to terminate the loop prematurely. In the web
    server example, you would stop serving files for security reasons when your server
    detects that it is under attack. In these cases, you can use the keyword `break`
    to stop the loop and execute the code that follows immediately. In [Listing 1-12](#list1-12),
    the code executes `print("hello world")` after the loop ends prematurely.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to force the Python interpreter to skip certain areas in
    the loop without ending it prematurely. For example, you may want to skip malicious
    web requests instead of halting the server completely. You can achieve this by
    using the `continue` statement, which finishes the current loop iteration and
    brings the execution flow back to the loop condition (see [Listing 1-13](#list1-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-13: Using the keyword `continue`*'
  prefs: []
  type: TYPE_NORMAL
- en: This code executes forever without executing the `print` statement once. The
    reason is that the `continue` statement finishes the current loop iteration and
    takes it back to the start, so execution never reaches the `print` statement.
    Code that never executes is known as *dead code*. For this reason, the `continue`
    statement (as well as the `break` statement) is commonly used under a certain
    condition by using a conditional if-else environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Functions* help you to reuse code snippets at your leisure: write them once
    but use them often. You define a function with the keyword `def`, a function name,
    and a set of arguments to customize the execution of the function body. Calling
    the function with two sets of arguments can drastically change the result of the
    function. For example, you can define the function `square(`*`x`*`)` that returns
    the square number of input argument *`x`*. Calling `square(10)` results in *10
    × 10 = 100* while calling `square(100)` results in *100 × 100 = 10,000*.'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `return` terminates the function and passes the flow of execution
    to the caller of the function. You can also provide an optional value after the
    `return` keyword to specify the function result (see [Listing 1-14](#list1-14)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-14: Using the keyword `return`*'
  prefs: []
  type: TYPE_NORMAL
- en: You create a function `appreciate()` that calculates how much a given investment
    appreciates at a given percentage of return. In the code, you calculate how much
    an investment of $10,000 appreciates in one year when assuming an interest rate
    of 5 percent. The result is $10,500\. You use the keyword `return` to specify
    that the result of the function should be the sum of the original investment and
    the nominal interest of this investment. The return value of the function `appreciate()`
    is of type float.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lambdas**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You use the keyword `lambda` to define lambda functions in Python. *Lambda
    functions* are anonymous functions that are not defined in the namespace. Roughly
    speaking, they are functions without names, intended for single use. The syntax
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A lambda function can have one or multiple arguments, separated by commas. After
    the colon (`:`), you define the return expression that may (or may not) use the
    defined argument. The return expression can be any expression or even another
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda functions play a major role in Python. You’ll see them a lot in practical
    code projects: for example, to make code shorter and more concise, or to create
    arguments of various Python functions (such as `map()` or `reduce()`). Consider
    the code in [Listing 1-15](#list1-15).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-15: Using the keyword `lambda`*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you create a lambda function that takes a value `x` and returns the result
    of the expression `x + 3`. The result is a function object that can be called
    like any other function. Because of its semantics, you denote this function as
    an *incrementor function*. When calling this incrementor function with the argument
    `x=3`—the suffix `(3)` within the print statement in [Listing 1-15](#list1-15)—the
    result is the integer value `6`. This book uses lambda functions heavily, so make
    sure you understand them properly (though you will also have opportunities to
    improve your intuitive understanding of lambda functions).
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter gave you a concise Python crash course to refresh your basic Python
    education. You studied the most important Python data structures and how to use
    them in code examples. You learned how to control the program execution flow by
    using if-elif-else statements, as well as `while` and `for` loops. You revisited
    the basic data types in Python—Boolean, integer, float, and string—and saw which
    built-in operations and functions are commonly used. Most code snippets in practice
    and nontrivial algorithms are built around more-powerful container types such
    as lists, stacks, sets, and dictionaries. By studying the given examples, you
    learned how to add, remove, insert, and reorder elements. You also learned about
    membership operators and list comprehension: an efficient and powerful built-in
    method to create lists programmatically in Python. Finally, you learned about
    functions and how to define them (including the anonymous lambda function). Now,
    you are ready for the first 10 basic Python one-liners.'
  prefs: []
  type: TYPE_NORMAL
