["```py\nNode {\n    String: name\n    Array of Nodes: neighbors\n}\n```", "```py\nEdge {\n    Integer: to_node\n    Integer: from_node\n    Float: weight\n}\n\nNode {\n    String: name\n    Integer: id\n    Array of Edges: edges\n}\n```", "```py\nGraph {\n    Integer: num_nodes\n    Array of Nodes: nodes\n}\n```", "```py\nDijkstras(Graph: G, Integer: from_node_index):\n  ❶ Array: distance = inf for each node id in G\n    Array: last = -1 for each node in G\n    Set: unvisited = set of all node indices in G\n    distance[from_node_index] = 0.0\n\n  ❷ WHILE unvisited is NOT empty:\n      ❸ Integer: next_index = the node index in unvisited\n                              with the minimal distance\n        Node: current = G.nodes[next_index]\n        Remove next_index from unvisited\n\n      ❹ FOR EACH edge IN current.edges:\n          ❺ Float: new_dist = distance[edge.from_node] + \n                              edge.weight\n          ❻ IF new_dist < distance[edge.to_node]:\n                distance[edge.to_node] = new_dist\n                last[edge.to_node] = edge.from_node\n```", "```py\nPrims(Graph G):\n  ❶ Array: distance = inf for each node in G\n    Array: last = -1 for each node in G\n    Set: unvisited = set of all node indices in G\n    Set: mst_edges = empty set\n\n  ❷ WHILE unvisited is NOT empty:\n      ❸ Integer: next_id = the node index in unvisited with\n                           the minimal distance\n      ❹ IF last[next_id] != -1:\n            Add the edge between last[next_id] and\n            next_id to mst_edges\n        Remove next_id from unvisited\n\n        Node: current = G.nodes[next_id]\n      ❺ FOR EACH edge IN current.edges:\n            IF edge.to_node is in unvisited:\n                IF edge.weight < distance[edge.to_node]:\n                    distance[edge.to_node] = edge.weight \n                    last[edge.to_node] = current.id\n    return mst_edges\n```", "```py\nKahns(Graph G):\n  ❶ Array: sorted = empty array to store result\n    Array: count = 0 for each node in G\n    Stack: next = empty stack for the next nodes to add\n\n    # Count the incoming edges.\n  ❷ FOR EACH node IN G.nodes:\n         FOR EACH edge IN node.edges:\n            count[edge.to_node] = count[edge.to_node] + 1\n\n    # Find the initial nodes without incoming edges.\n  ❸ FOR EACH node IN G.nodes:\n        IF count[node.id] == 0:\n            next.Push(node)\n\n    # Iteratively process the remaining nodes without \n    # incoming connections.\n  ❹ WHILE NOT next.IsEmpty():\n        Node: current = next.Pop()\n        Append current to the end of sorted\n      ❺ FOR EACH edge IN current.edges:\n            count[edge.to_node] = count[edge.to_node] - 1\n          ❻ IF count[edge.to_node] == 0:\n                next.Push(G.nodes[edge.to_node])\n\n    return sorted\n```"]