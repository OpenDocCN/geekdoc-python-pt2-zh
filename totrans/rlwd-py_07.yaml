- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SELECTING MARTIAN LANDING SITES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Landing a spacecraft on Mars is extraordinarily difficult and fraught with peril.
    No one wants to lose a billion-dollar probe, so engineers must emphasize operational
    safety. They may spend years searching satellite images for the safest landing
    sites that satisfy mission objectives. And they have a lot of ground to cover.
    Mars has almost the same amount of dry land as Earth!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing an area this large requires the help of computers. In this chapter,
    you’ll use Python and the Jet Propulsion Laboratory’s pride and joy, the Mars
    Orbiter Laser Altimeter (MOLA) map, to choose and rank candidate landing sites
    for a Mars lander. To load and extract useful information from the MOLA map, you’ll
    use the Python Imaging Library, OpenCV, tkinter, and NumPy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**How to Land on Mars**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to land a probe on Mars, including with parachutes, balloons,
    retro rockets, and jet packs. Regardless of the method, most landings follow the
    same basic safety rules.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The first rule is to target low-lying areas. A probe may enter the Martian atmosphere
    going as fast as 27,000 kilometers per hour (kph). Slowing it down for a soft
    landing requires a nice thick atmosphere. But the Martian atmosphere is thin—roughly
    1 percent the density of Earth’s. To find enough of it to make a difference, you
    need to aim for the lowest elevations, where the air is denser and the flight
    through it takes as long as possible.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Unless you have a specialty probe, like one designed for a polar cap, you’ll
    want to land near the equator. Here, you’ll find plenty of sunshine to feed the
    probe’s solar panels, and temperatures stay warm enough to protect the probe’s
    delicate machinery.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: You’ll want to avoid sites covered in boulders that can destroy the probe, prevent
    its panels from opening, block its robotic arm, or leave it tilted away from the
    sun. For similar reasons, you’ll want to stay away from areas with steep slopes,
    such as those found on the rims of craters. From a safety standpoint, flatter
    is better, and boring is beautiful.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Another challenge of landing on Mars is that you can’t be very precise. It’s
    hard to fly 50 million kilometers or more, graze the atmosphere, and land exactly
    where you intended. Inaccuracies in interplanetary navigation, along with variances
    in Martian atmospheric properties, make hitting a small target very uncertain.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, NASA runs lots of computer simulations for each landing coordinate.
    Each simulation run produces a coordinate, and the scatter of points that results
    from thousands of runs forms an elliptical shape with the long axis parallel to
    the probe’s flight path. These *landing ellipses* can be quite large ([Figure
    7-1](ch07.xhtml#ch07fig1)), though the accuracy improves with each new mission.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: Scaled comparison of 1997 Mars Pathfinder landing site (left) with
    Southern California (right)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The 2018 *InSight* lander had a landing ellipse of only 130 km × 27 km. The
    probability of the probe landing somewhere within that ellipse was around 99 percent.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2018 年的 *InSight* 着陆器的着陆椭圆仅为 130 km × 27 km。探测器在该椭圆范围内着陆的概率约为 99%。
- en: '**The MOLA Map**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**MOLA 地图**'
- en: To identify suitable landing spots, you’ll need a map of Mars. Between 1997
    and 2001, a tool aboard the *Mars Global Surveyor* (*MGS*) spacecraft shined a
    laser on Mars and timed its reflection 600 million times. From these measurements,
    researchers led by Maria Zuber and David Smith produced a detailed global topography
    map known as MOLA ([Figure 7-2](ch07.xhtml#ch07fig2)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别合适的着陆点，你需要一张火星地图。在 1997 年至 2001 年之间，*Mars Global Surveyor* (*MGS*) 太空船上的一台工具向火星发射激光，并反射计时
    6 亿次。通过这些测量，由玛丽亚·祖伯（Maria Zuber）和大卫·史密斯（David Smith）领导的研究人员制作了一张详细的全球地形图，被称为 MOLA
    ([图 7-2](ch07.xhtml#ch07fig2))。
- en: '![Image](../images/fig07-02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-02.jpg)'
- en: 'Figure 7-2: MOLA shaded relief map of Mars'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：火星的 MOLA 阴影地形图
- en: To see the spectacular color version of MOLA, along with a legend, go to the
    Wikipedia page for the *Mars Global Surveyor*. The blues in this map correspond
    to where oceans and seas probably existed on Mars billions of years ago. Their
    distribution is based on a combination of elevation and diagnostic surface features,
    like ancient shorelines.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 MOLA 的精彩彩色版本以及图例，请访问 *Mars Global Surveyor* 的维基百科页面。地图中的蓝色区域对应于数十亿年前火星上可能存在的海洋和海域。这些区域的分布是基于海拔和诊断性地表特征的组合，比如古老的海岸线。
- en: The laser measurements for MOLA have a vertical positional accuracy of around
    3 to 13 m and a horizontal positional accuracy of about 100 m. Pixel resolution
    is 463 m per pixel. By itself, the MOLA map lacks the detail needed to safely
    choose a final landing ellipse, but it’s perfect for the scoping work you’ll be
    asked to do.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MOLA 的激光测量垂直定位精度约为 3 至 13 米，水平定位精度约为 100 米。像素分辨率为每像素 463 米。单独看，MOLA 地图缺乏选择最终着陆椭圆所需的详细信息，但它非常适合进行你将要执行的范围划定工作。
- en: '**Project #10: Selecting Martian Landing Sites**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #10：选择火星着陆点**'
- en: Let’s pretend you’re a NASA summer intern working on the Orpheus Project, a
    mission designed to listen for marsquakes and study the interior of the planet,
    much like the 2018 Mars *InSight* mission. Because the purpose of Orpheus is to
    study the interior of Mars, interesting features of the planet’s surface aren’t
    that important. Safety is the prime concern, making this mission an engineer’s
    dream come true.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是 NASA 夏季实习生，正在参与 Orpheus 项目，这个任务旨在探测火星震动并研究火星内部，就像 2018 年的火星 *InSight* 任务一样。因为
    Orpheus 的目的是研究火星的内部，所以火星表面的有趣特征并不那么重要。安全性是首要关注点，这使得这个任务成为工程师梦寐以求的机会。
- en: Your job is to find at least a dozen regions from which NASA staff can select
    smaller candidate landing ellipses. According to your supervisor, the regions
    should be rectangles 670 km long (E–W) and 335 km wide (N–S). To address safety
    concerns, the regions should straddle the equator between 30° N and 30° S latitude,
    lie at low elevations, and be as smooth and flat as possible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是找到至少十二个区域，供 NASA 的工作人员选择较小的候选着陆椭圆。根据你的主管的要求，这些区域应为长 670 km（东西方向）和宽 335
    km（南北方向）的矩形。为了应对安全问题，这些区域应横跨赤道，位于 30°N 和 30°S 纬度之间，处于低海拔，并且尽可能平坦光滑。
- en: THE OBJECTIVE
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Write a Python program that uses an image of the MOLA map to choose the 20 safest
    670 km × 335 km regions near the Martian equator from which to select landing
    ellipses for the *Orpheus* lander.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，利用 MOLA 地图中的图像选择靠近火星赤道的 20 个最安全的 670 km × 335 km 区域，从中选择 *Orpheus*
    着陆器的着陆椭圆。
- en: '***The Strategy***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: First, you’ll need a way to divide the MOLA digital map into rectangular regions
    and extract statistics on elevation and surface roughness. This means you’ll be
    working with pixels, so you’ll need imaging tools. And since NASA is always containing
    costs, you’ll want to use free, open source libraries like OpenCV, the Python
    Imaging Library (PIL), tkinter, and NumPy. For an over-view and installation instructions,
    see “Installing the Python Libraries” on [page 6](ch01.xhtml#page_6) for OpenCV
    and NumPy, and see “The Word Cloud and PIL Modules” on [page 65](ch03.xhtml#page_65)
    for PIL. The tkinter module comes preinstalled with Python.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一种方法将 MOLA 数字地图划分为矩形区域，并提取高程和表面粗糙度的统计数据。这意味着您将处理像素，因此需要图像处理工具。由于 NASA
    总是注重成本控制，您将希望使用免费且开源的库，如 OpenCV、Python 图像库（PIL）、tkinter 和 NumPy。有关概述和安装说明，请参阅
    OpenCV 和 NumPy 在[第 6 页](ch01.xhtml#page_6)的“安装 Python 库”，以及 PIL 在[第 65 页](ch03.xhtml#page_65)的“文字云和
    PIL 模块”。tkinter 模块随 Python 一起预安装。
- en: 'To honor the elevation constraints, you can simply calculate the average elevation
    for each region. For measuring how smooth a surface is at a given scale, you have
    lots of choices, some of them quite sophisticated. Besides basing smoothness on
    elevation data, you can look for differential shadowing in stereo images; the
    amount of scattering in radar, laser, and microwave reflections; thermal variations
    in infrared images; and so on. Many roughness estimates involve tedious analyses
    along *transects*, which are lines drawn on the planet’s surface along which variations
    in height are measured and scrutinized. Since you’re not really a summer intern
    with three months to burn, you’re going to keep things simple and use two common
    measurements that you’ll apply to each rectangular region: standard deviation
    and peak-to-valley.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尊重高程约束，您可以简单地计算每个区域的平均高程。对于在给定尺度下测量表面平滑度，您有很多选择，其中一些相当复杂。除了基于高程数据来衡量平滑度，您还可以通过立体图像中的差异阴影、雷达、激光和微波反射中的散射量、红外图像中的热变化等来进行测量。许多粗糙度估算涉及沿*横断面*进行繁琐的分析，横断面是绘制在地球表面上的线，沿着这些线测量并检查高度变化。由于您并不是一个有三个月时间的暑期实习生，因此您将保持简单，使用两种常见的度量方法，并将其应用于每个矩形区域：标准差和峰谷值。
- en: '*Standard deviation*, also called *root-mean-square* by physical scientists,
    is a measure of the spread in a set of numbers. A low standard deviation indicates
    that the values in a set are close to the average value; a high standard deviation
    indicates they are spread out over a wider range. A map region with a low standard
    deviation for elevation means that the area is flattish, with little variance
    from the average elevation value.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准差*，也被物理科学家称为*均方根*，是衡量一组数字分散程度的指标。低标准差表明一组中的值接近平均值；高标准差则表明它们分布在更广泛的范围内。具有低标准差的高程地图区域意味着该区域相对平坦，高程值与平均值的差异很小。'
- en: 'Technically, the standard deviation for a population of samples is the square
    root of the average of the squared deviations from the mean, represented by the
    following formula:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，样本群体的标准差是均值的平方偏差的平均值的平方根，表示如下公式：
- en: '![Image](../images/equ_page_154_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/equ_page_154_01.jpg)'
- en: where σ is the standard deviation, *N* is the number of samples, *h*[*i*] is
    the current height sample, and *h*[*0*] is the mean of all the heights.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，σ 是标准差，*N* 是样本数量，*h*[*i*] 是当前的高度样本，*h*[*0*] 是所有高度的平均值。
- en: The *peak-to-valley* statistic is the difference in height between the highest
    and lowest points on a surface. It captures the maximum elevation change for the
    surface. This is important as a surface may have a relatively low standard deviation—suggesting
    smoothness—yet contain a significant hazard, as shown in the cross section in
    [Figure 7-3](ch07.xhtml#ch07fig3).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*峰谷值*统计是指表面上最高点与最低点之间的高度差。它捕捉了表面上的最大高度变化。这一点很重要，因为一个表面可能具有相对较低的标准差——暗示着平滑——但仍然可能包含显著的危险，如[图
    7-3](ch07.xhtml#ch07fig3)中的横截面所示。'
- en: '![Image](../images/fig07-03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-03.jpg)'
- en: 'Figure 7-3: A surface profile (black line) with standard deviation (StD) and
    peak-to-valley (PV) statistics'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：表面剖面（黑线）与标准差（StD）和峰谷值（PV）统计数据
- en: You can use the standard deviation and peak-to-valley statistics as comparative
    metrics. For each rectangular region, you’re looking for the lowest values of
    each statistic. And because each statistic records something slightly different,
    you’ll find the best 20 rectangular regions based on each statistic and then select
    only the rectangles that overlap to find the best rectangles overall.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准差和峰谷统计数据作为比较指标。对于每个矩形区域，你需要寻找每个统计数据的最低值。由于每个统计数据记录的是略有不同的内容，你将基于每个统计数据找到最佳的
    20 个矩形区域，然后只选择那些重叠的矩形，最终找到最佳的矩形区域。
- en: '***The Site Selector Code***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***站点选择器代码***'
- en: The *site_selector.py* program uses a grayscale image of the MOLA map ([Figure
    7-4](ch07.xhtml#ch07fig4)) to select the landing site rectangles and the shaded
    color map ([Figure 7-2](ch07.xhtml#ch07fig2)) to post them. Elevation is represented
    by a single channel in the grayscale image, so it’s easier to use than the three-channel
    (RGB) color image.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*site_selector.py* 程序使用 MOLA 地图的灰度图像（[图 7-4](ch07.xhtml#ch07fig4)）来选择着陆点矩形，并使用阴影颜色图（[图
    7-2](ch07.xhtml#ch07fig2)）显示它们。高程通过灰度图像中的单通道表示，因此比三通道（RGB）彩色图像更容易使用。'
- en: '![Image](../images/fig07-04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig07-04.jpg)'
- en: 'Figure 7-4: Mars MGS MOLA Digital Elevation Model 463m v2 (mola_1024x501.png)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：火星 MGS MOLA 数字高程模型 463m v2 (mola_1024x501.png)
- en: You can find the program, the grayscale image (*mola_1024x501.png*), and the
    color image (*mola_color_1024x506.png*) in the *Chapter_7* folder, downloadable
    from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
    Keep these files together in the same folder and don’t rename them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *Chapter_7* 文件夹中找到程序、灰度图像 (*mola_1024x501.png*) 和彩色图像 (*mola_color_1024x506.png*)，该文件夹可以从
    *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*
    下载。请将这些文件保存在同一文件夹中，并且不要重命名它们。
- en: '**NOTE**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The MOLA map comes in multiple file sizes and resolutions. You’re using the
    smallest size here to speed up the download and run times.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*MOLA 地图有多种文件大小和分辨率。这里使用的是最小的文件尺寸，以加快下载和运行时间。*'
- en: '**Importing Modules and Assigning User Input Constants**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块并分配用户输入常量**'
- en: '[Listing 7-1](ch07.xhtml#ch07list1) imports modules and assigns constants that
    represent user input parameters. These include image filenames, the dimensions
    of the rectangular regions, a maximum elevation limit, and the number of candidate
    rectangles to consider.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-1](ch07.xhtml#ch07list1) 导入模块并分配代表用户输入参数的常量。这些包括图像文件名、矩形区域的尺寸、最大高程限制以及考虑的候选矩形数量。'
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: Importing modules and assigning user input constants'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-1：导入模块并分配用户输入常量
- en: 'Start by importing the tkinter module. This is Python’s default GUI library
    for developing desktop applications. You’ll use it to make the final display:
    a window with the color MOLA map at the top and a text description of the posted
    rectangles at the bottom. Most Windows, macOS, and Linux machines come with tkinter
    already installed. If you don’t have it or need the latest version, you can download
    and install it from *[https://www.activestate.com/](https://www.activestate.com/)*.
    Online documentation for the module can be found at *[https://docs.python.org/3/library/tk.html](https://docs.python.org/3/library/tk.html)*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入 tkinter 模块。这是 Python 默认的 GUI 库，用于开发桌面应用程序。你将使用它来制作最终的显示窗口：顶部是彩色 MOLA 地图，底部是已发布矩形的文本描述。大多数
    Windows、macOS 和 Linux 机器都已安装 tkinter。如果你没有安装，或者需要最新版本，可以从 *[https://www.activestate.com/](https://www.activestate.com/)*
    下载并安装。该模块的在线文档可以在 *[https://docs.python.org/3/library/tk.html](https://docs.python.org/3/library/tk.html)*
    找到。
- en: Next, import the Image and ImageTK modules from the Python Imaging Library.
    The Image module provides a class that represents a PIL image. It also provides
    factory functions, including functions to load images from files and create new
    images. The ImageTK module contains support for creating and modifying tkinter’s
    BitmapImage and PhotoImage objects from PIL images. Again, you’ll use these at
    the end of the program to place the color map and some descriptive text in a summary
    window. Finally, finish the imports with NumPy and OpenCV.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从 Python 图像库中导入 Image 和 ImageTK 模块。Image 模块提供了一个表示 PIL 图像的类，并且提供了工厂函数，包括从文件加载图像和创建新图像的函数。ImageTK
    模块包含用于从 PIL 图像创建和修改 tkinter 的 BitmapImage 和 PhotoImage 对象的支持。再次强调，你将在程序结束时使用这些模块将彩色地图和一些描述性文本放入总结窗口中。最后，导入
    NumPy 和 OpenCV。
- en: Now, assign some constants that represent user input that won’t change as the
    program runs. First, use the OpenCV imread() method to load the grayscale MOLA
    image. Note that you have to use the cv.IMREAD_GRAYSCALE flag, as the method loads
    images in color by default. Repeat the code without the flag to load the color
    image. Then add constants for the rectangle size. In the next listing, you’ll
    convert these dimensions to pixels for use with the map image.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Next, to ensure the rectangles target smooth areas at low elevations, you should
    limit the search to lightly cratered, flat terrain. These regions are believed
    to represent old ocean bottoms. Thus, you’ll want to set the maximum elevation
    limit to a grayscale value of 55, which corresponds closely to the areas thought
    to be remnants of ancient shorelines (see [Figure 7-5](ch07.xhtml#ch07fig5)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-5: MOLA map with pixel values ≤ 55 colored black to represent ancient
    Martian oceans'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Now, specify the number of rectangles to display, represented by the NUM_CANDIDATES
    variable. Later, you’ll select these from a sorted list of rectangle statistics.
    Complete the user input constants by assigning a constant to hold the Martian
    circumference, in kilometers. You’ll use this later to determine the number of
    pixels per kilometer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '**Assigning Derived Constants and Creating the screen Object**'
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-2](ch07.xhtml#ch07list2) assigns constants that are derived from
    other constants. These values will update automatically if the user changes the
    previous constants, for example, to test different rectangle sizes or elevation
    limits. The listing ends by creating tkinter screen and canvas objects for the
    final display.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-2: Assigning derived constants and setting up the tkinter screen'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Start by unpacking the height and width of the image using the shape attribute.
    OpenCV stores images as NumPy ndarrays, which are *n*-dimensional arrays—or tables—of
    elements of the same type. For an image array, shape is a tuple of the number
    of rows, columns, and channels. The height represents the number of pixel rows
    in the image, and the width represents the number of pixel columns in the image.
    Channels represent the number of components used to represent each pixel (such
    as red, green, and blue). For grayscale images with one channel, shape is just
    a tuple of the area’s height and width.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: To convert the rectangle dimensions from kilometers to pixels, you need to know
    how many pixels there are per kilometer. So, divide the image width by the circumference
    to get the pixels per kilometer at the equator. Then convert width and height
    into pixels. You’ll use these to derive values for index slicing later, so make
    sure they are integers by using int(). The value of these constants should now
    be 32 and 16, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: You want to limit your search to the warmest and sunniest areas, which straddle
    the equator between 30° north latitude and 30° south latitude ([Figure 7-6](ch07.xhtml#ch07fig6)).
    In terms of climatic criteria, this region corresponds to the tropics on Earth.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-6: Latitude ( y-axis) and longitude ( x-axis) on Mars'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Latitude values start at 0° at the equator and end at 90° at the poles. To find
    30° north, all you need to do is divide the image height by 3 ➊. To get to 30°
    south, double the number of pixels it took to get to 30° north.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Restricting the search to the equatorial region of Mars has a beneficial side
    effect. The MOLA map you’re using is based on a *cylindrical projection*, used
    to transfer the surface of a globe onto a flat plane. This causes converging lines
    of longitude to be parallel, badly distorting features near the poles. You may
    have noticed this on wall maps of the earth, where Greenland looks like a continent
    and Antarctica is impossibly huge (see [Figure 7-7](ch07.xhtml#ch07fig7)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this distortion is minimized near the equator, so you don’t have
    to factor it into the rectangle dimensions. You can verify this by checking the
    shape of craters on the MOLA map. So long as they’re nice and circular—rather
    than oval—projection-related effects can be ignored.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-7: Forcing lines of longitude to be parallel distorts the size of
    features near the poles.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll need to divide up the map into rectangular regions. A logical place
    to begin is the upper-left corner, tucked under the 30° north latitude line ([Figure
    7-8](ch07.xhtml#ch07fig8)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-08.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-8: Position of the first numbered rectangle'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The program will draw this first rectangle, number it, and calculate the elevation
    statistics within it. It will then move the rectangle eastward and repeat the
    process. How far you move the rectangle each time is defined by the STEP_X and
    STEP_Y constants and depends on something called *aliasing*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing is a resolution issue. It occurs when you don’t take enough samples
    to identify all the important surface features in an area. This can cause you
    to “skip over” a feature, such as a crater, and fail to recognize it. For example,
    in [Figure 7-9](ch07.xhtml#ch07fig9)A, there’s a suitably smooth landing ellipse
    between two large craters. However, as laid out in [Figure 7-9](ch07.xhtml#ch07fig9)B,
    no rectan-gular region corresponds to this ellipse; both rectangles in the vicinity
    partially sample a crater rim. As a result, none of the drawn rectangles contains
    a suitable landing ellipse, even though one exists in the vicinity. With this
    arrangement of rectangles, the ellipse in [Figure 7-9](ch07.xhtml#ch07fig9)A is
    *aliased*. But shift each rectangle by half its width, as in [Figure 7-9](ch07.xhtml#ch07fig9)C,
    and the smooth area is properly sampled and recognized.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-09.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-9: Example of aliasing due to rectangle positioning'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The rule of thumb to avoid aliasing effects is to make the step size less than
    or equal to half the width of the smallest feature you want to identify. For this
    project, use half the rectangle width so the displays don’t become too busy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to look ahead to the final display. Create a screen instance of
    the tkinter Tk() class ➋. The tkinter application is Python’s wrapper of the GUI
    toolkit Tk, originally written in a computer language called TCL. It needs the
    screen window to link to an underlying tcl/tk interpreter that translates tkinter
    commands into tcl/tk commands.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Next, create a tkinter canvas object. This is a rectangular drawing area designed
    for complex layouts of graphics, text, widgets, and frames. Pass it the screen
    object, set its width equal to the MOLA image, and set its height equal to the
    height of the MOLA image plus 130\. The extra padding beneath the image will hold
    the text summarizing the statistics for the displayed rectangles.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: It’s more typical to place the tkinter code just described at the *end* of programs,
    rather than at the beginning. I chose to put it near the top to make the code
    explanation easier to follow. You can also embed this code within the function
    that makes the final display. However, this can cause problems for macOS users.
    For macOS 10.6 or newer, the Apple-supplied Tcl/Tk 8.5 has serious bugs that can
    cause application crashes (see *[https://www.python.org/download/mac/tcltk/](https://www.python.org/download/mac/tcltk/)*).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining and Initializing a Search Class**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-3](ch07.xhtml#ch07list3) defines a class that you’ll use to search
    for suitable rectangular regions. It then defines the class’s __init__() initialization
    method, used to instantiate new objects. For a quick overview of OOP, see “Defining
    the Search Class” on [page 10](ch01.xhtml#page_10), where you also define a search
    class.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 7-3: Defining the Search class and __init__() method'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Define a class called Search. Then define the __init__() method used to create
    new objects. The name parameter will allow you to give a personalized name to
    each object when you create it later in the main() function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re ready to start assigning attributes. Start by linking the object’s
    name with the argument you’ll provide when you create the object. Then assign
    four empty dictionaries to hold important statistics for each rectangle ➊. These
    include the rectangle’s corner-point coordinates and its mean elevation, peak-to-valley,
    and standard deviation statistics. For a key, all these dictionaries will use
    consecutive numbers, starting with 1\. You’ll want to filter the statistics to
    find the lowest values, so set up two empty lists to hold these ➋. Note that I
    use the term ptp, rather than ptv, to represent the peak-to-valley statistic.
    That’s to be consistent with the NumPy built-in method for this calculation, which
    is called *peak-to-peak*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the program, you’ll place rectangles that occur in both the sorted
    standard deviation and peak-to-valley lists in a new list named high_graded_rects.
    This list will contain the numbers of the rectangles with the lowest combined
    scores. These rectangles will be the best places to look for landing ellipses.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating Rectangle Statistics**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Still in the Search class, [Listing 7-4](ch07.xhtml#ch07list4) defines a method
    that calculates statistics in a rectangle, adds the statistics to the appropriate
    dictionary, and then moves to the next rectangle and repeats the process. The
    method honors the elevation limit by using the rectangles in low-lying areas only
    to populate the dictionaries.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-4: Calculating rectangle statistics and moving the rectangle'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Define the run_rect_stats() method, which takes self as an argument. Then assign
    local variables for the upper-left and lower-right corners of each rectangle.
    Initialize them using a combination of coordinates and constants. This will place
    the first rectangle along the left side of the image with its top boundary at
    30° north latitude.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Keep track of the rectangles by numbering them, starting with 1\. These numbers
    will serve as the keys for the dictionaries used to record coordinates and stats.
    You’ll also use them to identify the rectangles on the map, as demonstrated earlier
    in [Figure 7-8](ch07.xhtml#ch07fig8).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Now, start a while loop that will automate the process of moving the rectangles
    and recording their statistics. This loop will run until more than half of a rectangle
    extends below latitude 30° south, at which time the loop will break.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, OpenCV stores images as NumPy arrays. To calculate
    the stats within the active rectangle, rather than the whole image, create a subarray
    using normal slicing ➊. Call this subarray rect_img, for “rectangular image.”
    Then, add the rectangle number and these coordinates to the rect_coords dictionary.
    You’ll want to keep a record of these coordinates for the NASA staff, who’ll use
    your rectangles as the starting point for more detailed investigations later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Next, start a conditional to check that the current rectangle is at or below
    the maximum elevation limit specified for the project. As part of this statement,
    use NumPy to calculate the mean elevation for the rect_img subarray.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: If the rectangle passes the elevation test, populate the three dictionaries
    with the coordinates, peak-to-valley, and standard deviation statistics, as appropriate.
    Note that you can perform the calculation as part of the process, using np.ptp
    for peak-to-valley and np.std for standard deviation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Next, advance the rect_num variable by 1 and move the rectangle. Move the upper-left
    *x*-coordinate by the step size and then shift the lower-right *x*-coordinate
    by the width of the rectangle. You don’t want the rectangle to extend past the
    right side of the image, so check whether lr_x is greater than the image width
    ➋. If it is, set the upper-left *x*-coordinate to 0 to move the rectangle back
    to the starting position on the left side of the screen. Then move its *y*-coordinates
    down so that the new rectangles move along a new row. If the bottom of this new
    row is more than half a rectangle height below 30° south latitude, you’ve fully
    sampled the search area and can end the loop ➌.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Between 30° north and south latitude, the image is bounded on both sides by
    relatively high, cratered terrain that isn’t suitable for a landing site (see
    [Figure 7-6](ch07.xhtml#ch07fig6)). Thus, you can ignore the final step that shifts
    the rectangle by one-half its width. Otherwise, you would need to add code that
    wraps a rectangle from one side of the image to the other and calculates the statistics
    for each part. We’ll take a closer look at this situation in the final challenge
    project at the end of the chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '*When you draw something on an image, such as a rectangle, the drawing becomes
    part of the image. The altered pixels will be included in any NumPy analyses you
    run, so be sure to calculate any statistics before you annotate the image.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking the Rectangle Locations**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Still indented under the Search class, [Listing 7-5](ch07.xhtml#ch07list5) defines
    a method that performs quality control. It prints the coordinates of all the rectangles
    and then draws them on the MOLA map. This will let you verify that the search
    area has been fully evaluated and the rectangle size is what you expected it to
    be.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-5: Drawing all the rectangles on the MOLA map as a quality control
    step'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining a method to draw the rectangles on the image. Anything you
    draw on an image in OpenCV becomes part of the image, so first make a copy of
    the image in the local space.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: You’ll want to provide NASA with a printout of the identification number and
    coordinates for each rectangle. To print these in numerical order, sort the items
    in the rect_coords dictionary using a lambda function. If you haven’t used a lambda
    function before, you can find a short description on [page 107](ch05.xhtml#page_107)
    in [Chapter 5](ch05.xhtml).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Print a header for the list and then start a for loop through the keys and
    values in the newly sorted dictionary. The key is the rectangle number, and the
    value is the list of coordinates, as shown in the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use the OpenCV rectangle() method to draw the rectangles on the image. Pass
    it the image on which to draw, the rectangle coordinates, a color, and a line
    width. Access the coordinates directly from the rect_coords dictionary using the
    key and the list index (0 = upper-left *x*, 1 = upper-left *y*, 2 = lower-right
    *x*, 3 = lower-right *y*).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: To display the image, call the OpenCV imshow() method and pass it a name for
    the window and the image variable. The rectangles should cover Mars in a band
    centered on the equator ([Figure 7-10](ch07.xhtml#ch07fig10)). Leave the window
    up for three seconds and then destroy it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-10: All 1,260 rectangles drawn by the draw_qc_rects() method'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: If you compare [Figure 7-10](ch07.xhtml#ch07fig10) to [Figure 7-8](ch07.xhtml#ch07fig8),
    you may notice that the rect-angles appear smaller than expected. This is because
    you stepped the rectangles across and down the image using half the rectangle
    width and height so that they overlap each other.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorting the Statistics and High Grading the Rectangles**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Continuing with the Search class definition, [Listing 7-6](ch07.xhtml#ch07list6)
    defines a method to find the rectangles with the best potential landing sites.
    The method sorts the dictionaries containing the rectangle statistics, makes lists
    of the top rectangles based on the peak-to-valley and standard deviation statistics,
    and then makes a list of any rectangles shared between these two lists. The shared
    rectangles will be the best candidates for landing sites, as they’ll have the
    smallest peak-to-valley and standard deviation statistics.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-6: Sorting and high grading the rectangles based on their statistics'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Define a method called sort_stats(). Sort the rect_ptps dictionary with a lambda
    function that sorts the values rather than the keys. The values in this dictionary
    are the peak-to-valley measurements. This should create a list of tuples, with
    the rectangle number at index 0 and the peak-to-valley value at index 1.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Next, use list comprehension to populate the self.ptp_filtered attribute with
    the rectangle numbers in the ptp_sorted list. Use index slicing to select only
    the first 20 values, as stipulated by the NUM_CANDIDATES constant. You now have
    the 20 rectangles with the lowest peak-to-valley scores. Repeat this same basic
    code for standard deviation, producing a list of the 20 rectangles with the lowest
    standard deviation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Finish the method by looping through the rectangle numbers in the std_filtered
    list and comparing them to those in the ptp_filtered list. Append matching numbers
    to the high_graded_rects instance attribute you created previously with the __init__()
    method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing the Filtered Rectangles on the Map**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-7](ch07.xhtml#ch07list7), still indented under the Search class,
    defines a method that draws the 20 best rectangles on the grayscale MOLA map.
    You’ll call this method in the main() function.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-7: Drawing filtered rectangles and latitude lines on MOLA map'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining the method, which in this case takes multiple arguments. Besides
    self, the method will need a loaded image and a list of rectangle numbers. Use
    a local variable to copy the image and then start looping through the rectangle
    numbers in the filtered_rect_list. With each loop, draw a rectangle by using the
    rectangle number to access the corner coordinates in the rect_coords dictionary.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: So you can tell one rectangle from another, use OpenCV’s putText() method to
    post the rectangle number in the bottom-left corner of each rectangle. It needs
    the image, the text (as a string), coordinates for the upper-left *x* and lower-right
    *x*, a font, a line width, and a color.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Next, draw the annotated latitude limits, starting with the text for 30° north
    ➊. Then draw the line using OpenCV’s line() method. It takes as arguments an image,
    a pair of (*x*, *y*) coordinates for the start and end of the line, a color, and
    a thickness. Repeat these basic instructions for 30° south latitude.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: End the method by returning the annotated image. The best rectangles, based
    on the peak-to-valley and standard deviation statistics, are shown in [Figures
    7-11](ch07.xhtml#ch07fig11) and [7-12](ch07.xhtml#ch07fig12), respectively.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: These two figures show the top 20 rectangles for each statistic. That doesn’t
    mean they always agree. The rectangle with the lowest standard deviation may not
    appear in the peak-to-valley figure due to the presence of a single small crater.
    To find the flattest, smoothest rectangles, you need to identify the rectangles
    that appear in both figures and show them in their own display.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-11.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-11: The 20 rectangles with the lowest peak-to-valley scores'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-12.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-12: The 20 rectangles with the lowest standard deviations'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Final Color Display**'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-8](ch07.xhtml#ch07list8) finishes the Search class by defining a
    method to summarize the best rectangles. It uses tkinter to make a summary window
    with the rectangles posted on the color MOLA image. It also prints the rectangles’
    statistics below the image as text objects. This adds a little work, but it’s
    a cleaner-looking solution than posting the summarized stats directly on the image
    with OpenCV.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 7-8: Making the final display using the color MOLA map'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: After defining the method, give the tkinter screen window a title that links
    to the name of your search object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Then, to make the final color image for display, name a local variable img_color_rects
    and call the draw_filtered_rects() method. Pass it the color MOLA image and the
    list of high-graded rectangles. This will return the colored image with the final
    rectangles and latitude limits.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Before you can post this new color image in the tkinter canvas, you need to
    convert the colors from OpenCV’s Blue-Green-Red (BGR) format to the Red-Green-Blue
    (RGB) format used by tkinter. Do this with the OpenCV cvtColor() method. Pass
    it the image variable and the COLOR_BGR2RGB flag ➊. Name the result img_converted.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the image is still a NumPy array. To convert to a tkinter- compatible
    photo image, you need to use the PIL ImageTk module’s PhotoImage class and the
    Image module’s fromarray() method. Pass the method the RGB image variable you
    created in the previous step.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: With the image finally tkinter ready, place it in the canvas using the create_image()
    method. Pass the method the coordinates of the upper-left corner of the canvas
    (0, 0), the converted image, and a northwest anchor direction.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Now all that’s left is to add the summary text. Start by assigning coordinates
    for the bottom-left corner of the first text object ➋. Then begin looping through
    the rectangle numbers in the high-graded rectangle list. Use the create_text()
    method to place the text in the canvas. Pass it a pair of coordinates, a left-justified
    anchor direction, the default font, and a text string. Get the statistics by accessing
    the different dictionaries using the rectangle number, designated k for “key.”
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Increment the text box’s *y*-coordinate by 15 after drawing each text object.
    Then write a conditional to check that the text is greater than or within 10 pixels
    of the bottom of the canvas ➌. You can obtain the height of the canvas using the
    cget() method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: If the text is too close to the bottom of the canvas, you need to start a new
    column. Shift the txt_x variable over by 300 and reset txt_y to the image height
    plus 20.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Finish the method definition by packing the canvas and then calling the screen
    object’s mainloop(). Packing optimizes the placement of objects in the canvas.
    The mainloop() is an infinite loop that runs tkinter, waits for an event to occur,
    and processes the event until the window is closed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '*The height of the color image (506 pixels) is slightly larger than that of
    the grayscale image (501 pixels). I chose to ignore this, but if you’re a stickler
    for accuracy, you can use OpenCV to shrink the height of the color image using
    IMG_COLOR = cv.resize(IMG_COLOR, (1024, 501), interpolation = cv.INTER_AREA).*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Program with main()**'
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 7-9](ch07.xhtml#ch07list9) defines a main() function to run the program.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-9: Defining and calling the main() function used to run the program'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Start by instantiating an app object from the Search class. Name it 670x335
    km to document the size of the rectangular regions being investigated. Next, call
    the Search methods in order. Run the statistics on the rectangles and draw the
    quality control rectangles. Sort the statistics from smallest to largest and then
    draw the rectangles with the best peak-to-valley and standard deviation statistics.
    Show the results ➊ and finish the function by making the final summary display.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Back in the global space, add the code that lets the program run as an imported
    module or in stand-alone mode ➋.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-13](ch07.xhtml#ch07fig13) shows the final display. It includes the
    high-graded rectangles and the summary statistics sorted based on standard deviation.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-13.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-13: Final display with high-graded rectangles and summary statistics
    sorted by standard deviation'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '***Results***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After you’ve made the final display, the first thing you should do is perform
    a sanity check. Make sure that the rectangles are within the allowed latitude
    and elevation limits and that they appear to be in smooth terrain. Likewise, the
    rectangles based on the peak-to-valley and standard deviation statistics, shown
    in [Figures 7-11](ch07.xhtml#ch07fig11) and [7-12](ch07.xhtml#ch07fig12), respectively,
    should match the constraints and mostly pick the same rectangles.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: As noted previously, the rectangles in [Figures 7-11](ch07.xhtml#ch07fig11)
    and [7-12](ch07.xhtml#ch07fig12) don’t perfectly overlap. That’s because you’re
    using two different metrics for smoothness. One thing you can be sure of, though,
    is that the rectangles that do overlap will be the smoothest of all the rectangles.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: While all the rectangle locations look reasonable in the final display, the
    concentration of rectangles on the far-west side of the map is particularly encouraging.
    This is the smoothest terrain in the search area ([Figure 7-14](ch07.xhtml#ch07fig14)),
    and your program clearly recognized it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: This project focused on safety concerns, but scientific objectives drive site
    selection for most missions. In the practice projects at the end of the chapter,
    you’ll get a chance to incorporate an additional constraint— geology—into the
    site selection equation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-14: The very smooth terrain west of the Olympus Mons lava fields'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you used Python, OpenCV, the Python Imaging Library, NumPy,
    and tkinter to load, analyze, and display an image. Because OpenCV treats images
    as NumPy arrays, you can easily extract information from parts of an image and
    evaluate it with Python’s many scientific libraries.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The dataset you used was quick to download and fast to run. While a real intern
    would have used a larger and more rigorous dataset, such as one composed of millions
    of actual elevation measurements, you got to see how the process works with little
    effort and reasonable results.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Jet Propulsion Laboratory has several short and fun videos about landing
    on Mars. Find them with online searches for *Mars in a Minute: How Do You Choose
    a Landing Site?*, *Mars in a Minute: How Do You Get to Mars?*, and *Mars in a
    Minute: How Do You Land on Mars?*.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '*Mapping Mars: Science, Imagination, and the Birth of a World* (Picador, 2002),
    by Oliver Morton, tells the story of the contemporary exploration of Mars, including
    the creation of the MOLA map.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '*The Atlas of Mars: Mapping Its Geography and Geology* (Cambridge University
    Press, 2019), by Kenneth Coles, Kenneth Tanaka, and Philip Christensen, is a spectacular
    all-purpose reference atlas of Mars that includes maps of topography, geology,
    mineralogy, thermal properties, near-surface water-ice, and more.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The data page for the MOLA map used in Project 10 is at *[https://astrogeology.usgs.gov/search/map/Mars/GlobalSurveyor/MOLA/Mars_MGS_MOLA_DEM_mosaic_global_463m/](https://astrogeology.usgs.gov/search/map/Mars/GlobalSurveyor/MOLA/Mars_MGS_MOLA_DEM_mosaic_global_463m/)*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Detailed Martian datasets are available on the Mars Orbital Data Explorer site
    produced by the PDS Geoscience Node at Washington University in St. Louis (*[https://ode.rsl.wustl.edu/mars/index.aspx](https://ode.rsl.wustl.edu/mars/index.aspx)*).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Confirming That Drawings Become Part of an Image**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a Python program that verifies that drawings added to an image, such as
    text, lines, rectangles, and so on, become part of that image. Use NumPy to calculate
    the mean, standard deviation, and peak-to-valley statistics on a rectangular region
    in the MOLA grayscale image, but don’t draw the rectangle outline. Then draw a
    white line around the region and rerun the statistics. Do the two runs agree?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: You can find a solution, *practice_confirm_drawing_part_of_image.py*, in the
    appendix or *Chapter_7* folder, downloadable from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Extracting an Elevation Profile**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An elevation profile is a two-dimensional, cross-sectional view of a landscape.
    It provides a side view of a terrain’s relief along a line drawn between locations
    on a map. Geologists can use profiles to study the smoothness of a surface and
    visualize its topography. For this practice project, draw a west-to-east profile
    that passes through the caldera of the largest volcano in the solar system, Olympus
    Mons ([Figure 7-15](ch07.xhtml#ch07fig15)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-15.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-15: Vertically exaggerated west-east profile through Olympus Mons'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Use the *Mars MGS MOLA - MEX HRSC Blended DEM Global 200m v2* map shown in [Figure
    7-15](ch07.xhtml#ch07fig15). This version has better lateral resolution than the
    one you used for Project 10\. It also uses the full elevation range in the MOLA
    data. You can find a copy, *mola_1024x512_200mp.jpg*, in the *Chapter_7* folder,
    downloadable from the book’s website. A solution, *practice_profile_olympus.py*,
    is available in the same folder and in the appendix.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Plotting in 3D**'
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mars is an asymmetrical planet, with the southern hemisphere dominated by ancient
    cratered highlands and the north characterized by smooth, flat lowlands. To make
    this more apparent, use the 3D plotting functionality in matplotlib to display
    the *mola_1024x512_200mp.jpg* image you used in the previous practice project
    ([Figure 7-16](ch07.xhtml#ch07fig16)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-16.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-16: A 3D contour plot of Mars, looking toward the west'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: With matplotlib, you can make 3D relief plots using points, lines, contours,
    wireframes, and surfaces. Although the plots are somewhat crude, you can generate
    them quickly. You can also use the mouse to interactively grab the plot and change
    the viewpoint. They are particularly useful for people who have trouble visualizing
    topography from 2D maps.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 7-16](ch07.xhtml#ch07fig16), the exaggerated vertical scale makes
    the elevation difference from south to north easy to see. It’s also easy to spot
    the tallest mountain (Olympus Mons) and the deepest crater (Hellas Planitia).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: You can reproduce the plot in [Figure 7-16](ch07.xhtml#ch07fig16)—sans annotation—with
    the *practice_3d_plotting.py* program in the appendix or *Chapter_7* folder, downloadable
    from the book’s website. The map image can be found in the same folder.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Mixing Maps**'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make up a new project that adds a bit of science to the site selection process.
    Combine the MOLA map with a color geology map and find the smoothest rectangular
    regions within the volcanic deposits at Tharsis Montes (see arrow in [Figure 7-17](ch07.xhtml#ch07fig17)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-17.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-17: Geological map of Mars. The arrow points to the Tharsis volcanic
    deposits.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Since the Tharsis Montes region lies at a high altitude, focus on finding the
    flattest and smoothest parts of the volcanic deposits, rather than targeting the
    lowest elevations. To isolate the volcanic deposits, consider thresholding a grayscale
    version of the map. *Thresholding* is a segmentation technique that partitions
    an image into a foreground and a background.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: With thresholding, you convert a grayscale image into a binary image where pixels
    above or between specified threshold values are set to 1 and all others are set
    to 0\. You can use this binary image to filter the MOLA map, as shown in [Figure
    7-18](ch07.xhtml#ch07fig18).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-18.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-18: Filtered MOLA map over the Tharsis Montes region, with ptp (left)
    and std (right) rectangles'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: You can find the geological map, *Mars_Global_Geology_Mariner9_1024.jpg*, in
    the *Chapter_7* folder, downloadable from the book’s website. The volcanic deposits
    will be light pink in color. For the elevation map, use *mola_1024x512_200mp.jpg*
    from the “Extracting an Elevation Profile” practice project on [page 172](ch07.xhtml#page_172).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: A solution, contained in *practice_geo_map_step_1of2.py* and *practice_geo_map_step_2of2.py*,
    can be found in the same folder and in the appendix. Run the *practice_geo_map_step_1of2.py*
    program first to generate the filter for step 2.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Making It Three in a Row**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Edit the “Extracting an Elevation Profile” project so that the profile passes
    through the three volcanoes on Tharsis Montes, as shown in [Figure 7-19](ch07.xhtml#ch07fig19).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-19.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-19: Diagonal profile through the three volcanoes on Tharsis Montes'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Other interesting features to profile are Valles Marineris, a canyon nine times
    as long and four times as deep as the Grand Canyon, and Hellas Planitia, considered
    the third or fourth largest impact crater in the solar system ([Figure 7-19](ch07.xhtml#ch07fig19)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Wrapping Rectangles**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Edit the *site_selector.py* code so that it accommodates rectangle dimensions
    that don’t divide evenly into the width of the MOLA image. One way to do this
    is to add code that splits the rectangle into two pieces (one along the right
    edge of the map and the other along the left edge), calculates statistics for
    each, and then recombines them into a full rectangle. Another approach is to duplicate
    the image and “stitch” it to the original image, as shown in [Figure 7-20](ch07.xhtml#ch07fig20).
    This way, you won’t have to split the rectangles; just decide when to stop stepping
    them across the map.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig07-20.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-20: The grayscale MOLA image duplicated and repeated'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Of course, for efficiency, you don’t have to duplicate the whole map. You only
    need a strip along the eastern margin wide enough to accommodate the final overlapping
    rectangle.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
