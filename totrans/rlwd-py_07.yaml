- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: SELECTING MARTIAN LANDING SITES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 选择火星着陆点
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Landing a spacecraft on Mars is extraordinarily difficult and fraught with peril.
    No one wants to lose a billion-dollar probe, so engineers must emphasize operational
    safety. They may spend years searching satellite images for the safest landing
    sites that satisfy mission objectives. And they have a lot of ground to cover.
    Mars has almost the same amount of dry land as Earth!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在火星上着陆是一项极其困难且充满风险的任务。没有人希望失去一颗价值十亿的探测器，因此工程师必须强调操作安全。他们可能会花费数年时间通过卫星图像寻找最安全的着陆点，以满足任务目标。而且他们需要覆盖的区域非常广阔，火星的干旱土地几乎与地球一样多！
- en: Analyzing an area this large requires the help of computers. In this chapter,
    you’ll use Python and the Jet Propulsion Laboratory’s pride and joy, the Mars
    Orbiter Laser Altimeter (MOLA) map, to choose and rank candidate landing sites
    for a Mars lander. To load and extract useful information from the MOLA map, you’ll
    use the Python Imaging Library, OpenCV, tkinter, and NumPy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 分析如此大范围的区域需要计算机的帮助。在本章中，你将使用Python语言和喷气推进实验室（Jet Propulsion Laboratory）骄傲的成果——火星轨道激光测高仪（MOLA）地图，来选择和排名火星着陆器的候选着陆点。为了加载和提取MOLA地图中的有用信息，你将使用Python
    Imaging Library、OpenCV、tkinter和NumPy。
- en: '**How to Land on Mars**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何在火星上着陆**'
- en: There are many ways to land a probe on Mars, including with parachutes, balloons,
    retro rockets, and jet packs. Regardless of the method, most landings follow the
    same basic safety rules.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将探测器着陆到火星表面的方法有很多，包括降落伞、气球、反向火箭和喷气背包。无论采用哪种方法，大多数着陆操作都遵循相同的基本安全规则。
- en: The first rule is to target low-lying areas. A probe may enter the Martian atmosphere
    going as fast as 27,000 kilometers per hour (kph). Slowing it down for a soft
    landing requires a nice thick atmosphere. But the Martian atmosphere is thin—roughly
    1 percent the density of Earth’s. To find enough of it to make a difference, you
    need to aim for the lowest elevations, where the air is denser and the flight
    through it takes as long as possible.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个规则是目标选择低洼地区。探测器可能以每小时27,000公里的速度进入火星大气层。为了实现软着陆，必须通过厚厚的大气层减速。然而，火星的大气层非常稀薄——其密度大约是地球大气的1%。为了找到足够的密度以产生影响，你需要瞄准最低的海拔区域，在那里空气更稠密，飞行所需的时间也最长。
- en: Unless you have a specialty probe, like one designed for a polar cap, you’ll
    want to land near the equator. Here, you’ll find plenty of sunshine to feed the
    probe’s solar panels, and temperatures stay warm enough to protect the probe’s
    delicate machinery.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有专门的探测器，例如为极地冰帽设计的探测器，否则你会希望选择靠近赤道的地区着陆。这里，你将能获得充足的阳光来为探测器的太阳能面板提供能量，并且温度足够温暖，可以保护探测器的精密机械设备。
- en: You’ll want to avoid sites covered in boulders that can destroy the probe, prevent
    its panels from opening, block its robotic arm, or leave it tilted away from the
    sun. For similar reasons, you’ll want to stay away from areas with steep slopes,
    such as those found on the rims of craters. From a safety standpoint, flatter
    is better, and boring is beautiful.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要避免选择那些被巨石覆盖的地方，因为巨石可能会摧毁探测器，阻止其面板展开，挡住其机械臂，或让探测器倾斜，无法面向太阳。出于类似的原因，你还应该避开那些陡坡区域，比如火山口边缘的地方。从安全的角度来看，越平坦越好，而无聊的地方则是美丽的。
- en: Another challenge of landing on Mars is that you can’t be very precise. It’s
    hard to fly 50 million kilometers or more, graze the atmosphere, and land exactly
    where you intended. Inaccuracies in interplanetary navigation, along with variances
    in Martian atmospheric properties, make hitting a small target very uncertain.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个着陆火星的挑战是精确度有限。要飞行超过5000万公里，穿越大气层，并精确地在预定位置着陆是非常困难的。星际导航的误差以及火星大气特性的变化，使得在小范围内命中目标变得非常不确定。
- en: Consequently, NASA runs lots of computer simulations for each landing coordinate.
    Each simulation run produces a coordinate, and the scatter of points that results
    from thousands of runs forms an elliptical shape with the long axis parallel to
    the probe’s flight path. These *landing ellipses* can be quite large ([Figure
    7-1](ch07.xhtml#ch07fig1)), though the accuracy improves with each new mission.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，NASA会对每个着陆坐标进行大量计算机模拟。每次模拟运行都会生成一个坐标，成千上万次运行的散点会形成一个椭圆形状，其长轴与探测器的飞行路径平行。这些*着陆椭圆*可能非常大（见[图
    7-1](ch07.xhtml#ch07fig1)），尽管随着每次新任务的推进，准确性会有所提高。
- en: '![Image](../images/fig07-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-01.jpg)'
- en: 'Figure 7-1: Scaled comparison of 1997 Mars Pathfinder landing site (left) with
    Southern California (right)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-1：1997年火星探路者着陆点（左）与南加州（右）的对比图
- en: The 2018 *InSight* lander had a landing ellipse of only 130 km × 27 km. The
    probability of the probe landing somewhere within that ellipse was around 99 percent.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2018 年的 *InSight* 着陆器的着陆椭圆仅为 130 km × 27 km。探测器在该椭圆范围内着陆的概率约为 99%。
- en: '**The MOLA Map**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**MOLA 地图**'
- en: To identify suitable landing spots, you’ll need a map of Mars. Between 1997
    and 2001, a tool aboard the *Mars Global Surveyor* (*MGS*) spacecraft shined a
    laser on Mars and timed its reflection 600 million times. From these measurements,
    researchers led by Maria Zuber and David Smith produced a detailed global topography
    map known as MOLA ([Figure 7-2](ch07.xhtml#ch07fig2)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别合适的着陆点，你需要一张火星地图。在 1997 年至 2001 年之间，*Mars Global Surveyor* (*MGS*) 太空船上的一台工具向火星发射激光，并反射计时
    6 亿次。通过这些测量，由玛丽亚·祖伯（Maria Zuber）和大卫·史密斯（David Smith）领导的研究人员制作了一张详细的全球地形图，被称为 MOLA
    ([图 7-2](ch07.xhtml#ch07fig2))。
- en: '![Image](../images/fig07-02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-02.jpg)'
- en: 'Figure 7-2: MOLA shaded relief map of Mars'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：火星的 MOLA 阴影地形图
- en: To see the spectacular color version of MOLA, along with a legend, go to the
    Wikipedia page for the *Mars Global Surveyor*. The blues in this map correspond
    to where oceans and seas probably existed on Mars billions of years ago. Their
    distribution is based on a combination of elevation and diagnostic surface features,
    like ancient shorelines.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 MOLA 的精彩彩色版本以及图例，请访问 *Mars Global Surveyor* 的维基百科页面。地图中的蓝色区域对应于数十亿年前火星上可能存在的海洋和海域。这些区域的分布是基于海拔和诊断性地表特征的组合，比如古老的海岸线。
- en: The laser measurements for MOLA have a vertical positional accuracy of around
    3 to 13 m and a horizontal positional accuracy of about 100 m. Pixel resolution
    is 463 m per pixel. By itself, the MOLA map lacks the detail needed to safely
    choose a final landing ellipse, but it’s perfect for the scoping work you’ll be
    asked to do.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MOLA 的激光测量垂直定位精度约为 3 至 13 米，水平定位精度约为 100 米。像素分辨率为每像素 463 米。单独看，MOLA 地图缺乏选择最终着陆椭圆所需的详细信息，但它非常适合进行你将要执行的范围划定工作。
- en: '**Project #10: Selecting Martian Landing Sites**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #10：选择火星着陆点**'
- en: Let’s pretend you’re a NASA summer intern working on the Orpheus Project, a
    mission designed to listen for marsquakes and study the interior of the planet,
    much like the 2018 Mars *InSight* mission. Because the purpose of Orpheus is to
    study the interior of Mars, interesting features of the planet’s surface aren’t
    that important. Safety is the prime concern, making this mission an engineer’s
    dream come true.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是 NASA 夏季实习生，正在参与 Orpheus 项目，这个任务旨在探测火星震动并研究火星内部，就像 2018 年的火星 *InSight* 任务一样。因为
    Orpheus 的目的是研究火星的内部，所以火星表面的有趣特征并不那么重要。安全性是首要关注点，这使得这个任务成为工程师梦寐以求的机会。
- en: Your job is to find at least a dozen regions from which NASA staff can select
    smaller candidate landing ellipses. According to your supervisor, the regions
    should be rectangles 670 km long (E–W) and 335 km wide (N–S). To address safety
    concerns, the regions should straddle the equator between 30° N and 30° S latitude,
    lie at low elevations, and be as smooth and flat as possible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是找到至少十二个区域，供 NASA 的工作人员选择较小的候选着陆椭圆。根据你的主管的要求，这些区域应为长 670 km（东西方向）和宽 335
    km（南北方向）的矩形。为了应对安全问题，这些区域应横跨赤道，位于 30°N 和 30°S 纬度之间，处于低海拔，并且尽可能平坦光滑。
- en: THE OBJECTIVE
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Write a Python program that uses an image of the MOLA map to choose the 20 safest
    670 km × 335 km regions near the Martian equator from which to select landing
    ellipses for the *Orpheus* lander.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，利用 MOLA 地图中的图像选择靠近火星赤道的 20 个最安全的 670 km × 335 km 区域，从中选择 *Orpheus*
    着陆器的着陆椭圆。
- en: '***The Strategy***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: First, you’ll need a way to divide the MOLA digital map into rectangular regions
    and extract statistics on elevation and surface roughness. This means you’ll be
    working with pixels, so you’ll need imaging tools. And since NASA is always containing
    costs, you’ll want to use free, open source libraries like OpenCV, the Python
    Imaging Library (PIL), tkinter, and NumPy. For an over-view and installation instructions,
    see “Installing the Python Libraries” on [page 6](ch01.xhtml#page_6) for OpenCV
    and NumPy, and see “The Word Cloud and PIL Modules” on [page 65](ch03.xhtml#page_65)
    for PIL. The tkinter module comes preinstalled with Python.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一种方法将 MOLA 数字地图划分为矩形区域，并提取高程和表面粗糙度的统计数据。这意味着您将处理像素，因此需要图像处理工具。由于 NASA
    总是注重成本控制，您将希望使用免费且开源的库，如 OpenCV、Python 图像库（PIL）、tkinter 和 NumPy。有关概述和安装说明，请参阅
    OpenCV 和 NumPy 在[第 6 页](ch01.xhtml#page_6)的“安装 Python 库”，以及 PIL 在[第 65 页](ch03.xhtml#page_65)的“文字云和
    PIL 模块”。tkinter 模块随 Python 一起预安装。
- en: 'To honor the elevation constraints, you can simply calculate the average elevation
    for each region. For measuring how smooth a surface is at a given scale, you have
    lots of choices, some of them quite sophisticated. Besides basing smoothness on
    elevation data, you can look for differential shadowing in stereo images; the
    amount of scattering in radar, laser, and microwave reflections; thermal variations
    in infrared images; and so on. Many roughness estimates involve tedious analyses
    along *transects*, which are lines drawn on the planet’s surface along which variations
    in height are measured and scrutinized. Since you’re not really a summer intern
    with three months to burn, you’re going to keep things simple and use two common
    measurements that you’ll apply to each rectangular region: standard deviation
    and peak-to-valley.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尊重高程约束，您可以简单地计算每个区域的平均高程。对于在给定尺度下测量表面平滑度，您有很多选择，其中一些相当复杂。除了基于高程数据来衡量平滑度，您还可以通过立体图像中的差异阴影、雷达、激光和微波反射中的散射量、红外图像中的热变化等来进行测量。许多粗糙度估算涉及沿*横断面*进行繁琐的分析，横断面是绘制在地球表面上的线，沿着这些线测量并检查高度变化。由于您并不是一个有三个月时间的暑期实习生，因此您将保持简单，使用两种常见的度量方法，并将其应用于每个矩形区域：标准差和峰谷值。
- en: '*Standard deviation*, also called *root-mean-square* by physical scientists,
    is a measure of the spread in a set of numbers. A low standard deviation indicates
    that the values in a set are close to the average value; a high standard deviation
    indicates they are spread out over a wider range. A map region with a low standard
    deviation for elevation means that the area is flattish, with little variance
    from the average elevation value.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准差*，也被物理科学家称为*均方根*，是衡量一组数字分散程度的指标。低标准差表明一组中的值接近平均值；高标准差则表明它们分布在更广泛的范围内。具有低标准差的高程地图区域意味着该区域相对平坦，高程值与平均值的差异很小。'
- en: 'Technically, the standard deviation for a population of samples is the square
    root of the average of the squared deviations from the mean, represented by the
    following formula:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，样本群体的标准差是均值的平方偏差的平均值的平方根，表示如下公式：
- en: '![Image](../images/equ_page_154_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/equ_page_154_01.jpg)'
- en: where σ is the standard deviation, *N* is the number of samples, *h*[*i*] is
    the current height sample, and *h*[*0*] is the mean of all the heights.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，σ 是标准差，*N* 是样本数量，*h*[*i*] 是当前的高度样本，*h*[*0*] 是所有高度的平均值。
- en: The *peak-to-valley* statistic is the difference in height between the highest
    and lowest points on a surface. It captures the maximum elevation change for the
    surface. This is important as a surface may have a relatively low standard deviation—suggesting
    smoothness—yet contain a significant hazard, as shown in the cross section in
    [Figure 7-3](ch07.xhtml#ch07fig3).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*峰谷值*统计是指表面上最高点与最低点之间的高度差。它捕捉了表面上的最大高度变化。这一点很重要，因为一个表面可能具有相对较低的标准差——暗示着平滑——但仍然可能包含显著的危险，如[图
    7-3](ch07.xhtml#ch07fig3)中的横截面所示。'
- en: '![Image](../images/fig07-03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-03.jpg)'
- en: 'Figure 7-3: A surface profile (black line) with standard deviation (StD) and
    peak-to-valley (PV) statistics'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：表面剖面（黑线）与标准差（StD）和峰谷值（PV）统计数据
- en: You can use the standard deviation and peak-to-valley statistics as comparative
    metrics. For each rectangular region, you’re looking for the lowest values of
    each statistic. And because each statistic records something slightly different,
    you’ll find the best 20 rectangular regions based on each statistic and then select
    only the rectangles that overlap to find the best rectangles overall.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准差和峰谷统计数据作为比较指标。对于每个矩形区域，你需要寻找每个统计数据的最低值。由于每个统计数据记录的是略有不同的内容，你将基于每个统计数据找到最佳的
    20 个矩形区域，然后只选择那些重叠的矩形，最终找到最佳的矩形区域。
- en: '***The Site Selector Code***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***站点选择器代码***'
- en: The *site_selector.py* program uses a grayscale image of the MOLA map ([Figure
    7-4](ch07.xhtml#ch07fig4)) to select the landing site rectangles and the shaded
    color map ([Figure 7-2](ch07.xhtml#ch07fig2)) to post them. Elevation is represented
    by a single channel in the grayscale image, so it’s easier to use than the three-channel
    (RGB) color image.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*site_selector.py* 程序使用 MOLA 地图的灰度图像（[图 7-4](ch07.xhtml#ch07fig4)）来选择着陆点矩形，并使用阴影颜色图（[图
    7-2](ch07.xhtml#ch07fig2)）显示它们。高程通过灰度图像中的单通道表示，因此比三通道（RGB）彩色图像更容易使用。'
- en: '![Image](../images/fig07-04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig07-04.jpg)'
- en: 'Figure 7-4: Mars MGS MOLA Digital Elevation Model 463m v2 (mola_1024x501.png)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：火星 MGS MOLA 数字高程模型 463m v2 (mola_1024x501.png)
- en: You can find the program, the grayscale image (*mola_1024x501.png*), and the
    color image (*mola_color_1024x506.png*) in the *Chapter_7* folder, downloadable
    from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
    Keep these files together in the same folder and don’t rename them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *Chapter_7* 文件夹中找到程序、灰度图像 (*mola_1024x501.png*) 和彩色图像 (*mola_color_1024x506.png*)，该文件夹可以从
    *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*
    下载。请将这些文件保存在同一文件夹中，并且不要重命名它们。
- en: '**NOTE**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The MOLA map comes in multiple file sizes and resolutions. You’re using the
    smallest size here to speed up the download and run times.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*MOLA 地图有多种文件大小和分辨率。这里使用的是最小的文件尺寸，以加快下载和运行时间。*'
- en: '**Importing Modules and Assigning User Input Constants**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块并分配用户输入常量**'
- en: '[Listing 7-1](ch07.xhtml#ch07list1) imports modules and assigns constants that
    represent user input parameters. These include image filenames, the dimensions
    of the rectangular regions, a maximum elevation limit, and the number of candidate
    rectangles to consider.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-1](ch07.xhtml#ch07list1) 导入模块并分配代表用户输入参数的常量。这些包括图像文件名、矩形区域的尺寸、最大高程限制以及考虑的候选矩形数量。'
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: Importing modules and assigning user input constants'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-1：导入模块并分配用户输入常量
- en: 'Start by importing the tkinter module. This is Python’s default GUI library
    for developing desktop applications. You’ll use it to make the final display:
    a window with the color MOLA map at the top and a text description of the posted
    rectangles at the bottom. Most Windows, macOS, and Linux machines come with tkinter
    already installed. If you don’t have it or need the latest version, you can download
    and install it from *[https://www.activestate.com/](https://www.activestate.com/)*.
    Online documentation for the module can be found at *[https://docs.python.org/3/library/tk.html](https://docs.python.org/3/library/tk.html)*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入 tkinter 模块。这是 Python 默认的 GUI 库，用于开发桌面应用程序。你将使用它来制作最终的显示窗口：顶部是彩色 MOLA 地图，底部是已发布矩形的文本描述。大多数
    Windows、macOS 和 Linux 机器都已安装 tkinter。如果你没有安装，或者需要最新版本，可以从 *[https://www.activestate.com/](https://www.activestate.com/)*
    下载并安装。该模块的在线文档可以在 *[https://docs.python.org/3/library/tk.html](https://docs.python.org/3/library/tk.html)*
    找到。
- en: Next, import the Image and ImageTK modules from the Python Imaging Library.
    The Image module provides a class that represents a PIL image. It also provides
    factory functions, including functions to load images from files and create new
    images. The ImageTK module contains support for creating and modifying tkinter’s
    BitmapImage and PhotoImage objects from PIL images. Again, you’ll use these at
    the end of the program to place the color map and some descriptive text in a summary
    window. Finally, finish the imports with NumPy and OpenCV.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从 Python 图像库中导入 Image 和 ImageTK 模块。Image 模块提供了一个表示 PIL 图像的类，并且提供了工厂函数，包括从文件加载图像和创建新图像的函数。ImageTK
    模块包含用于从 PIL 图像创建和修改 tkinter 的 BitmapImage 和 PhotoImage 对象的支持。再次强调，你将在程序结束时使用这些模块将彩色地图和一些描述性文本放入总结窗口中。最后，导入
    NumPy 和 OpenCV。
- en: Now, assign some constants that represent user input that won’t change as the
    program runs. First, use the OpenCV imread() method to load the grayscale MOLA
    image. Note that you have to use the cv.IMREAD_GRAYSCALE flag, as the method loads
    images in color by default. Repeat the code without the flag to load the color
    image. Then add constants for the rectangle size. In the next listing, you’ll
    convert these dimensions to pixels for use with the map image.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分配一些常量来表示程序运行过程中不会改变的用户输入。首先，使用 OpenCV 的 imread() 方法加载灰度的 MOLA 图像。请注意，必须使用
    cv.IMREAD_GRAYSCALE 标志，因为该方法默认加载彩色图像。没有使用该标志的代码将加载彩色图像。然后，添加矩形大小的常量。在接下来的列表中，你将把这些尺寸转换为像素，以便在地图图像中使用。
- en: Next, to ensure the rectangles target smooth areas at low elevations, you should
    limit the search to lightly cratered, flat terrain. These regions are believed
    to represent old ocean bottoms. Thus, you’ll want to set the maximum elevation
    limit to a grayscale value of 55, which corresponds closely to the areas thought
    to be remnants of ancient shorelines (see [Figure 7-5](ch07.xhtml#ch07fig5)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了确保矩形定位在低海拔的平坦区域，你应该将搜索限制在轻微坑洼的平坦地形上。这些区域被认为代表古老的海洋底部。因此，你将设置最大海拔限制为灰度值55，这与被认为是古代海岸线遗迹的区域非常接近（参见[图
    7-5](ch07.xhtml#ch07fig5)）。
- en: '![Image](../images/fig07-05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/fig07-05.jpg)'
- en: 'Figure 7-5: MOLA map with pixel values ≤ 55 colored black to represent ancient
    Martian oceans'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-5：MOLA地图，像素值 ≤ 55 的区域被涂黑，以表示古老的火星海洋
- en: Now, specify the number of rectangles to display, represented by the NUM_CANDIDATES
    variable. Later, you’ll select these from a sorted list of rectangle statistics.
    Complete the user input constants by assigning a constant to hold the Martian
    circumference, in kilometers. You’ll use this later to determine the number of
    pixels per kilometer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，指定要显示的矩形数量，由NUM_CANDIDATES变量表示。稍后，你将从一个排序后的矩形统计数据列表中选择这些矩形。通过为火星周长（以公里为单位）分配一个常量，来完成用户输入常量的设置。你稍后将使用这个常量来确定每公里的像素数。
- en: '**Assigning Derived Constants and Creating the screen Object**'
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分配派生常量并创建屏幕对象**'
- en: '[Listing 7-2](ch07.xhtml#ch07list2) assigns constants that are derived from
    other constants. These values will update automatically if the user changes the
    previous constants, for example, to test different rectangle sizes or elevation
    limits. The listing ends by creating tkinter screen and canvas objects for the
    final display.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-2](ch07.xhtml#ch07list2) 分配了从其他常量派生的常量。这些值会在用户更改前述常量时自动更新，例如测试不同的矩形大小或海拔限制。该列表最终通过创建
    tkinter 屏幕和画布对象来完成最终显示。'
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-2: Assigning derived constants and setting up the tkinter screen'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-2：分配派生常量并设置 tkinter 屏幕
- en: Start by unpacking the height and width of the image using the shape attribute.
    OpenCV stores images as NumPy ndarrays, which are *n*-dimensional arrays—or tables—of
    elements of the same type. For an image array, shape is a tuple of the number
    of rows, columns, and channels. The height represents the number of pixel rows
    in the image, and the width represents the number of pixel columns in the image.
    Channels represent the number of components used to represent each pixel (such
    as red, green, and blue). For grayscale images with one channel, shape is just
    a tuple of the area’s height and width.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 shape 属性解包图像的高度和宽度。OpenCV将图像存储为NumPy的ndarray，这些是*n*维数组——也就是同类元素的表格。对于图像数组，shape是一个包含行数、列数和通道数的元组。高度表示图像中的像素行数，宽度表示图像中的像素列数。通道表示用来表示每个像素的组件数量（例如红、绿、蓝）。对于只有一个通道的灰度图像，shape只是表示区域的高度和宽度的元组。
- en: To convert the rectangle dimensions from kilometers to pixels, you need to know
    how many pixels there are per kilometer. So, divide the image width by the circumference
    to get the pixels per kilometer at the equator. Then convert width and height
    into pixels. You’ll use these to derive values for index slicing later, so make
    sure they are integers by using int(). The value of these constants should now
    be 32 and 16, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将矩形的尺寸从公里转换为像素，你需要知道每公里的像素数。所以，将图像的宽度除以周长，以获得赤道上的每公里像素数。然后将宽度和高度转换为像素。你将在后续的索引切片中使用这些值，因此请确保它们是整数，可以通过使用
    int() 来确保。现在，这些常量的值应该分别是 32 和 16。
- en: You want to limit your search to the warmest and sunniest areas, which straddle
    the equator between 30° north latitude and 30° south latitude ([Figure 7-6](ch07.xhtml#ch07fig6)).
    In terms of climatic criteria, this region corresponds to the tropics on Earth.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你想将搜索范围限制在最温暖和最阳光明媚的区域，这些区域位于赤道之间，纬度在30°北和30°南之间（参见[图7-6](ch07.xhtml#ch07fig6)）。就气候标准而言，这个区域对应于地球的热带。
- en: '![Image](../images/fig07-06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-06.jpg)'
- en: 'Figure 7-6: Latitude ( y-axis) and longitude ( x-axis) on Mars'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-6：火星的纬度（y轴）和经度（x轴）
- en: Latitude values start at 0° at the equator and end at 90° at the poles. To find
    30° north, all you need to do is divide the image height by 3 ➊. To get to 30°
    south, double the number of pixels it took to get to 30° north.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 纬度值从赤道的0°开始，到极地的90°结束。要找到30°北纬，你只需要将图像的高度除以3 ➊。要到达30°南纬，只需将到达30°北纬所需的像素数翻倍。
- en: Restricting the search to the equatorial region of Mars has a beneficial side
    effect. The MOLA map you’re using is based on a *cylindrical projection*, used
    to transfer the surface of a globe onto a flat plane. This causes converging lines
    of longitude to be parallel, badly distorting features near the poles. You may
    have noticed this on wall maps of the earth, where Greenland looks like a continent
    and Antarctica is impossibly huge (see [Figure 7-7](ch07.xhtml#ch07fig7)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将搜索范围限制在火星的赤道区域有一个有益的副作用。你正在使用的MOLA地图基于*圆柱投影*，该投影用于将地球表面转移到平面上。这导致经线收敛并变得平行，从而严重扭曲了靠近极地的地物。你可能在地球的墙面地图上注意到这种情况，格林兰岛看起来像一个大陆，南极洲巨大得不可思议（参见[图7-7](ch07.xhtml#ch07fig7)）。
- en: Fortunately, this distortion is minimized near the equator, so you don’t have
    to factor it into the rectangle dimensions. You can verify this by checking the
    shape of craters on the MOLA map. So long as they’re nice and circular—rather
    than oval—projection-related effects can be ignored.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种扭曲在赤道附近最小化，因此你不必将其考虑在矩形的维度中。你可以通过检查MOLA地图上的火山口形状来验证这一点。只要它们是圆形的——而不是椭圆形的——就可以忽略与投影相关的效应。
- en: '![Image](../images/fig07-07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-07.jpg)'
- en: 'Figure 7-7: Forcing lines of longitude to be parallel distorts the size of
    features near the poles.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-7：强迫经线平行会扭曲靠近极地的地物大小。
- en: Next, you’ll need to divide up the map into rectangular regions. A logical place
    to begin is the upper-left corner, tucked under the 30° north latitude line ([Figure
    7-8](ch07.xhtml#ch07fig8)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要将地图划分成矩形区域。一个合逻辑的起点是左上角，位于30°北纬线下方（参见[图7-8](ch07.xhtml#ch07fig8)）。
- en: '![Image](../images/fig07-08.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-08.jpg)'
- en: 'Figure 7-8: Position of the first numbered rectangle'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-8：第一个编号矩形的位置
- en: The program will draw this first rectangle, number it, and calculate the elevation
    statistics within it. It will then move the rectangle eastward and repeat the
    process. How far you move the rectangle each time is defined by the STEP_X and
    STEP_Y constants and depends on something called *aliasing*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将绘制第一个矩形，编号并计算其中的高度统计数据。然后它会将矩形向东移动，并重复这一过程。每次移动矩形的距离由STEP_X和STEP_Y常量定义，并且与称为*别名效应*的现象有关。
- en: Aliasing is a resolution issue. It occurs when you don’t take enough samples
    to identify all the important surface features in an area. This can cause you
    to “skip over” a feature, such as a crater, and fail to recognize it. For example,
    in [Figure 7-9](ch07.xhtml#ch07fig9)A, there’s a suitably smooth landing ellipse
    between two large craters. However, as laid out in [Figure 7-9](ch07.xhtml#ch07fig9)B,
    no rectan-gular region corresponds to this ellipse; both rectangles in the vicinity
    partially sample a crater rim. As a result, none of the drawn rectangles contains
    a suitable landing ellipse, even though one exists in the vicinity. With this
    arrangement of rectangles, the ellipse in [Figure 7-9](ch07.xhtml#ch07fig9)A is
    *aliased*. But shift each rectangle by half its width, as in [Figure 7-9](ch07.xhtml#ch07fig9)C,
    and the smooth area is properly sampled and recognized.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 别名效应是一个分辨率问题。当你没有足够多的样本来识别某一地区所有重要的地表特征时，就会发生这种情况。这可能导致你“跳过”某个特征，比如火山口，从而未能识别出来。例如，在[图7-9](ch07.xhtml#ch07fig9)A中，在两个大火山口之间有一个适当平滑的着陆椭圆。然而，如[图7-9](ch07.xhtml#ch07fig9)B所示，任何一个矩形区域都没有对应这个椭圆；该区域内的两个矩形都部分采样了一个火山口的边缘。因此，虽然在附近存在一个适合的着陆椭圆，但绘制的矩形中没有一个包含该椭圆。在这种矩形布局下，[图7-9](ch07.xhtml#ch07fig9)A中的椭圆*产生了别名效应*。但是，如果将每个矩形移动其宽度的一半，如[图7-9](ch07.xhtml#ch07fig9)C所示，平滑区域将被正确采样并识别出来。
- en: '![Image](../images/fig07-09.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-09.jpg)'
- en: 'Figure 7-9: Example of aliasing due to rectangle positioning'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-9：由于矩形位置引起的别名效应示例
- en: The rule of thumb to avoid aliasing effects is to make the step size less than
    or equal to half the width of the smallest feature you want to identify. For this
    project, use half the rectangle width so the displays don’t become too busy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 避免别名效应的经验法则是将步长设置为小于或等于你想要识别的最小特征的宽度的一半。对于这个项目，使用矩形宽度的一半，这样显示不会显得过于拥挤。
- en: Now it’s time to look ahead to the final display. Create a screen instance of
    the tkinter Tk() class ➋. The tkinter application is Python’s wrapper of the GUI
    toolkit Tk, originally written in a computer language called TCL. It needs the
    screen window to link to an underlying tcl/tk interpreter that translates tkinter
    commands into tcl/tk commands.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候展望最终显示的效果了。创建一个 tkinter Tk() 类的屏幕实例 ➋。tkinter 应用程序是 Python 对 GUI 工具包 Tk
    的封装，Tk 最初是用一种叫做 TCL 的计算机语言编写的。它需要一个屏幕窗口来连接到底层的 tcl/tk 解释器，将 tkinter 命令翻译成 tcl/tk
    命令。
- en: Next, create a tkinter canvas object. This is a rectangular drawing area designed
    for complex layouts of graphics, text, widgets, and frames. Pass it the screen
    object, set its width equal to the MOLA image, and set its height equal to the
    height of the MOLA image plus 130\. The extra padding beneath the image will hold
    the text summarizing the statistics for the displayed rectangles.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个 tkinter 画布对象。这是一个矩形绘图区域，旨在支持复杂的图形、文本、控件和框架布局。将屏幕对象传递给它，将其宽度设置为 MOLA
    图像的宽度，并将其高度设置为 MOLA 图像的高度加上 130。图像下方的额外填充区域将用来显示总结矩形统计数据的文本。
- en: It’s more typical to place the tkinter code just described at the *end* of programs,
    rather than at the beginning. I chose to put it near the top to make the code
    explanation easier to follow. You can also embed this code within the function
    that makes the final display. However, this can cause problems for macOS users.
    For macOS 10.6 or newer, the Apple-supplied Tcl/Tk 8.5 has serious bugs that can
    cause application crashes (see *[https://www.python.org/download/mac/tcltk/](https://www.python.org/download/mac/tcltk/)*).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，应该将刚才描述的 tkinter 代码放在程序的*最后*，而不是放在开始部分。我选择将其放在接近顶部的位置，以便更容易理解代码的解释。你也可以将这段代码嵌入到生成最终显示的函数中。然而，这可能会给
    macOS 用户带来问题。对于 macOS 10.6 或更高版本，Apple 提供的 Tcl/Tk 8.5 存在严重的 bug，可能导致应用程序崩溃（详见
    *[https://www.python.org/download/mac/tcltk/](https://www.python.org/download/mac/tcltk/)*）。
- en: '**Defining and Initializing a Search Class**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义和初始化 Search 类**'
- en: '[Listing 7-3](ch07.xhtml#ch07list3) defines a class that you’ll use to search
    for suitable rectangular regions. It then defines the class’s __init__() initialization
    method, used to instantiate new objects. For a quick overview of OOP, see “Defining
    the Search Class” on [page 10](ch01.xhtml#page_10), where you also define a search
    class.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-3](ch07.xhtml#ch07list3) 定义了一个类，你将用它来搜索合适的矩形区域。接着定义了类的 __init__() 初始化方法，用于实例化新对象。有关面向对象编程（OOP）的快速概述，请参见
    [第 10 页](ch01.xhtml#page_10)的“定义 Search 类”部分，在那里你也将定义一个搜索类。'
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 7-3: Defining the Search class and __init__() method'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-3：定义 Search 类和 __init__() 方法
- en: Define a class called Search. Then define the __init__() method used to create
    new objects. The name parameter will allow you to give a personalized name to
    each object when you create it later in the main() function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 Search 的类。然后定义 __init__() 方法，用于创建新对象。name 参数将允许你在稍后的 main() 函数中创建对象时为每个对象赋予个性化的名称。
- en: Now you’re ready to start assigning attributes. Start by linking the object’s
    name with the argument you’ll provide when you create the object. Then assign
    four empty dictionaries to hold important statistics for each rectangle ➊. These
    include the rectangle’s corner-point coordinates and its mean elevation, peak-to-valley,
    and standard deviation statistics. For a key, all these dictionaries will use
    consecutive numbers, starting with 1\. You’ll want to filter the statistics to
    find the lowest values, so set up two empty lists to hold these ➋. Note that I
    use the term ptp, rather than ptv, to represent the peak-to-valley statistic.
    That’s to be consistent with the NumPy built-in method for this calculation, which
    is called *peak-to-peak*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你准备好开始分配属性了。首先将对象的名称与创建对象时提供的参数关联。然后，分配四个空字典来保存每个矩形的重要统计数据 ➊。这些包括矩形的角点坐标及其平均海拔、峰谷高度差和标准差统计数据。作为键，这些字典将使用连续的数字，从
    1 开始。你将需要过滤这些统计数据以找到最低值，因此设置两个空列表来存储这些 ➋。注意，我使用 ptp 这个术语，而不是 ptv，来表示峰谷高度差统计数据。这样做是为了与
    NumPy 内置方法中用于此计算的*峰值到峰值*一致。
- en: At the end of the program, you’ll place rectangles that occur in both the sorted
    standard deviation and peak-to-valley lists in a new list named high_graded_rects.
    This list will contain the numbers of the rectangles with the lowest combined
    scores. These rectangles will be the best places to look for landing ellipses.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序结束时，您将把同时出现在排序后的标准差和峰值到谷值列表中的矩形放入一个名为 `high_graded_rects` 的新列表中。这个列表将包含得分最低的矩形编号。这些矩形将是寻找着陆椭圆的最佳地点。
- en: '**Calculating Rectangle Statistics**'
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**计算矩形统计数据**'
- en: Still in the Search class, [Listing 7-4](ch07.xhtml#ch07list4) defines a method
    that calculates statistics in a rectangle, adds the statistics to the appropriate
    dictionary, and then moves to the next rectangle and repeats the process. The
    method honors the elevation limit by using the rectangles in low-lying areas only
    to populate the dictionaries.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 Search 类中，[列表 7-4](ch07.xhtml#ch07list4) 定义了一个方法，该方法计算矩形中的统计数据，将统计数据添加到相应的字典中，然后移动到下一个矩形并重复该过程。该方法通过仅使用低洼地区的矩形来填充字典，从而遵守了海拔限制。
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-4: Calculating rectangle statistics and moving the rectangle'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-4：计算矩形统计数据并移动矩形
- en: Define the run_rect_stats() method, which takes self as an argument. Then assign
    local variables for the upper-left and lower-right corners of each rectangle.
    Initialize them using a combination of coordinates and constants. This will place
    the first rectangle along the left side of the image with its top boundary at
    30° north latitude.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `run_rect_stats()` 方法，该方法将 `self` 作为参数。然后为每个矩形的左上角和右下角分配局部变量。通过将坐标和常数结合来初始化这些变量。这样可以将第一个矩形放置在图像的左侧，且其上边界位于
    30° 北纬。
- en: Keep track of the rectangles by numbering them, starting with 1\. These numbers
    will serve as the keys for the dictionaries used to record coordinates and stats.
    You’ll also use them to identify the rectangles on the map, as demonstrated earlier
    in [Figure 7-8](ch07.xhtml#ch07fig8).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为矩形编号来跟踪这些矩形，编号从 1 开始。这些编号将作为字典的键，用于记录坐标和统计数据。您还将用它们来标识地图上的矩形，正如之前在 [图 7-8](ch07.xhtml#ch07fig8)
    中演示的那样。
- en: Now, start a while loop that will automate the process of moving the rectangles
    and recording their statistics. This loop will run until more than half of a rectangle
    extends below latitude 30° south, at which time the loop will break.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动一个 `while` 循环，该循环将自动执行移动矩形和记录统计数据的过程。该循环会一直运行，直到矩形的超过一半部分延伸到 30° 南纬以下，届时循环将终止。
- en: As mentioned previously, OpenCV stores images as NumPy arrays. To calculate
    the stats within the active rectangle, rather than the whole image, create a subarray
    using normal slicing ➊. Call this subarray rect_img, for “rectangular image.”
    Then, add the rectangle number and these coordinates to the rect_coords dictionary.
    You’ll want to keep a record of these coordinates for the NASA staff, who’ll use
    your rectangles as the starting point for more detailed investigations later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，OpenCV 将图像存储为 NumPy 数组。为了计算活动矩形中的统计数据，而不是整张图像，可以使用常规切片 ➊ 创建一个子数组。将此子数组命名为
    `rect_img`，即“矩形图像”。然后，将矩形编号和这些坐标添加到 `rect_coords` 字典中。您需要为 NASA 的工作人员保留这些坐标记录，他们将使用您的矩形作为后续更详细调查的起点。
- en: Next, start a conditional to check that the current rectangle is at or below
    the maximum elevation limit specified for the project. As part of this statement,
    use NumPy to calculate the mean elevation for the rect_img subarray.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，开始一个条件判断，检查当前矩形是否在指定的项目最大海拔限制以下或等于该限制。作为此语句的一部分，使用 NumPy 来计算 `rect_img`
    子数组的平均海拔。
- en: If the rectangle passes the elevation test, populate the three dictionaries
    with the coordinates, peak-to-valley, and standard deviation statistics, as appropriate.
    Note that you can perform the calculation as part of the process, using np.ptp
    for peak-to-valley and np.std for standard deviation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩形通过了海拔测试，按照需要填充三个字典，分别包含坐标、峰值到谷值的差值和标准差统计数据。请注意，您可以将计算过程作为步骤的一部分进行，使用 `np.ptp`
    来计算峰值到谷值的差值，使用 `np.std` 来计算标准差。
- en: Next, advance the rect_num variable by 1 and move the rectangle. Move the upper-left
    *x*-coordinate by the step size and then shift the lower-right *x*-coordinate
    by the width of the rectangle. You don’t want the rectangle to extend past the
    right side of the image, so check whether lr_x is greater than the image width
    ➋. If it is, set the upper-left *x*-coordinate to 0 to move the rectangle back
    to the starting position on the left side of the screen. Then move its *y*-coordinates
    down so that the new rectangles move along a new row. If the bottom of this new
    row is more than half a rectangle height below 30° south latitude, you’ve fully
    sampled the search area and can end the loop ➌.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将rect_num变量增加1并移动矩形。将左上角的*x*坐标按步长移动，然后将右下角的*x*坐标按矩形的宽度进行平移。您不希望矩形越过图像的右侧，因此需要检查lr_x是否大于图像的宽度➋。如果是，设置左上角的*x*坐标为0，将矩形移回屏幕左侧的起始位置。然后将其*y*坐标向下移动，以便新矩形沿着新的一行移动。如果这一新行的底部距离南纬30°超过半个矩形的高度，您就已经完全采样了搜索区域，可以结束循环➌。
- en: Between 30° north and south latitude, the image is bounded on both sides by
    relatively high, cratered terrain that isn’t suitable for a landing site (see
    [Figure 7-6](ch07.xhtml#ch07fig6)). Thus, you can ignore the final step that shifts
    the rectangle by one-half its width. Otherwise, you would need to add code that
    wraps a rectangle from one side of the image to the other and calculates the statistics
    for each part. We’ll take a closer look at this situation in the final challenge
    project at the end of the chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在南北纬30°之间，图像两侧被相对较高、坑洼的地形所限制，这些区域不适合作为着陆点（见[图7-6](ch07.xhtml#ch07fig6)）。因此，您可以忽略最后一步，即将矩形向其宽度的一半方向平移。否则，您将需要添加代码，将矩形从图像的一侧移动到另一侧，并计算每个部分的统计数据。我们将在本章末的最终挑战项目中更详细地了解这种情况。
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When you draw something on an image, such as a rectangle, the drawing becomes
    part of the image. The altered pixels will be included in any NumPy analyses you
    run, so be sure to calculate any statistics before you annotate the image.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*当您在图像上绘制某些东西时，例如矩形，该绘制将成为图像的一部分。改变后的像素将在您运行的任何NumPy分析中包含，因此请确保在注释图像之前先计算任何统计数据。*'
- en: '**Checking the Rectangle Locations**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查矩形位置**'
- en: Still indented under the Search class, [Listing 7-5](ch07.xhtml#ch07list5) defines
    a method that performs quality control. It prints the coordinates of all the rectangles
    and then draws them on the MOLA map. This will let you verify that the search
    area has been fully evaluated and the rectangle size is what you expected it to
    be.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索类下仍然缩进，[列表7-5](ch07.xhtml#ch07list5)定义了一个执行质量控制的方法。它打印出所有矩形的坐标，然后在MOLA地图上绘制它们。这将帮助您验证搜索区域是否已完全评估，并且矩形的大小是否符合预期。
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-5: Drawing all the rectangles on the MOLA map as a quality control
    step'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-5：作为质量控制步骤在MOLA地图上绘制所有矩形
- en: Start by defining a method to draw the rectangles on the image. Anything you
    draw on an image in OpenCV becomes part of the image, so first make a copy of
    the image in the local space.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义一个方法，在图像上绘制矩形。在OpenCV中，您在图像上绘制的任何东西都会成为图像的一部分，因此首先需要在本地空间中复制图像。
- en: You’ll want to provide NASA with a printout of the identification number and
    coordinates for each rectangle. To print these in numerical order, sort the items
    in the rect_coords dictionary using a lambda function. If you haven’t used a lambda
    function before, you can find a short description on [page 107](ch05.xhtml#page_107)
    in [Chapter 5](ch05.xhtml).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要向NASA提供每个矩形的标识号码和坐标的打印输出。为了按数字顺序打印这些信息，请使用lambda函数对rect_coords字典中的项进行排序。如果您之前没有使用过lambda函数，可以在[第107页](ch05.xhtml#page_107)的[第5章](ch05.xhtml)中找到简短的说明。
- en: 'Print a header for the list and then start a for loop through the keys and
    values in the newly sorted dictionary. The key is the rectangle number, and the
    value is the list of coordinates, as shown in the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为列表打印一个标题，然后开始通过新排序的字典中的键和值进行循环。键是矩形编号，值是坐标列表，如下所示的输出：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use the OpenCV rectangle() method to draw the rectangles on the image. Pass
    it the image on which to draw, the rectangle coordinates, a color, and a line
    width. Access the coordinates directly from the rect_coords dictionary using the
    key and the list index (0 = upper-left *x*, 1 = upper-left *y*, 2 = lower-right
    *x*, 3 = lower-right *y*).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenCV的rectangle()方法在图像上绘制矩形。传入绘制的图像、矩形坐标、颜色和线宽。通过直接从rect_coords字典中使用键和列表索引（0
    = 左上角*x*，1 = 左上角*y*，2 = 右下角*x*，3 = 右下角*y*）来访问坐标。
- en: To display the image, call the OpenCV imshow() method and pass it a name for
    the window and the image variable. The rectangles should cover Mars in a band
    centered on the equator ([Figure 7-10](ch07.xhtml#ch07fig10)). Leave the window
    up for three seconds and then destroy it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示图像，调用OpenCV的imshow()方法，并传入窗口的名称和图像变量。矩形应覆盖在以赤道为中心的带状区域内的火星图像上（[图7-10](ch07.xhtml#ch07fig10)）。保持窗口显示三秒钟，然后销毁它。
- en: '![Image](../images/fig07-10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig07-10.jpg)'
- en: 'Figure 7-10: All 1,260 rectangles drawn by the draw_qc_rects() method'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-10：draw_qc_rects()方法绘制的所有1,260个矩形
- en: If you compare [Figure 7-10](ch07.xhtml#ch07fig10) to [Figure 7-8](ch07.xhtml#ch07fig8),
    you may notice that the rect-angles appear smaller than expected. This is because
    you stepped the rectangles across and down the image using half the rectangle
    width and height so that they overlap each other.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将[图7-10](ch07.xhtml#ch07fig10)与[图7-8](ch07.xhtml#ch07fig8)进行比较，你可能会注意到矩形看起来比预期的小。这是因为你使用矩形的宽度和高度的一半步进地移动矩形，在图像上水平和垂直排列，导致它们相互重叠。
- en: '**Sorting the Statistics and High Grading the Rectangles**'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**排序统计数据并高评分矩形**'
- en: Continuing with the Search class definition, [Listing 7-6](ch07.xhtml#ch07list6)
    defines a method to find the rectangles with the best potential landing sites.
    The method sorts the dictionaries containing the rectangle statistics, makes lists
    of the top rectangles based on the peak-to-valley and standard deviation statistics,
    and then makes a list of any rectangles shared between these two lists. The shared
    rectangles will be the best candidates for landing sites, as they’ll have the
    smallest peak-to-valley and standard deviation statistics.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 继续定义Search类，[列表7-6](ch07.xhtml#ch07list6)定义了一个方法，用于寻找具有最佳潜在着陆点的矩形。该方法对包含矩形统计数据的字典进行排序，根据峰谷值和标准差统计数据制作矩形的前几个列表，然后制作这两个列表之间共享的矩形列表。共享的矩形将是着陆点的最佳候选者，因为它们将具有最小的峰谷值和标准差。
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-6: Sorting and high grading the rectangles based on their statistics'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-6：基于统计数据对矩形进行排序和高评分
- en: Define a method called sort_stats(). Sort the rect_ptps dictionary with a lambda
    function that sorts the values rather than the keys. The values in this dictionary
    are the peak-to-valley measurements. This should create a list of tuples, with
    the rectangle number at index 0 and the peak-to-valley value at index 1.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为sort_stats()的方法。使用一个lambda函数对rect_ptps字典进行排序，该函数根据值进行排序，而不是键。字典中的值是峰谷测量值。这将创建一个包含元组的列表，元组的第0个索引是矩形编号，第1个索引是峰谷值。
- en: Next, use list comprehension to populate the self.ptp_filtered attribute with
    the rectangle numbers in the ptp_sorted list. Use index slicing to select only
    the first 20 values, as stipulated by the NUM_CANDIDATES constant. You now have
    the 20 rectangles with the lowest peak-to-valley scores. Repeat this same basic
    code for standard deviation, producing a list of the 20 rectangles with the lowest
    standard deviation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用列表推导式将矩形编号填充到self.ptp_filtered属性中，矩形编号来自ptp_sorted列表。使用索引切片选择前20个值，如NUM_CANDIDATES常量所规定。你现在得到了20个具有最低峰谷值的矩形。对标准差进行相同的基本代码处理，生成具有最低标准差的20个矩形的列表。
- en: Finish the method by looping through the rectangle numbers in the std_filtered
    list and comparing them to those in the ptp_filtered list. Append matching numbers
    to the high_graded_rects instance attribute you created previously with the __init__()
    method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遍历std_filtered列表中的矩形编号，并将其与ptp_filtered列表中的编号进行比较来完成该方法。将匹配的编号附加到你之前使用__init__()方法创建的high_graded_rects实例属性中。
- en: '**Drawing the Filtered Rectangles on the Map**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在地图上绘制过滤后的矩形**'
- en: '[Listing 7-7](ch07.xhtml#ch07list7), still indented under the Search class,
    defines a method that draws the 20 best rectangles on the grayscale MOLA map.
    You’ll call this method in the main() function.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7-7](ch07.xhtml#ch07list7)，仍然位于Search类下，定义了一个方法，用于在灰度MOLA地图上绘制20个最佳矩形。你将在main()函数中调用此方法。'
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-7: Drawing filtered rectangles and latitude lines on MOLA map'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-7：在 MOLA 地图上绘制过滤后的矩形和纬度线
- en: Start by defining the method, which in this case takes multiple arguments. Besides
    self, the method will need a loaded image and a list of rectangle numbers. Use
    a local variable to copy the image and then start looping through the rectangle
    numbers in the filtered_rect_list. With each loop, draw a rectangle by using the
    rectangle number to access the corner coordinates in the rect_coords dictionary.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义方法，该方法需要多个参数。除了 self，方法还需要加载的图像和一个矩形编号的列表。使用一个局部变量复制图像，然后开始循环遍历 `filtered_rect_list`
    中的矩形编号。每次循环时，通过使用矩形编号访问 `rect_coords` 字典中的角落坐标来绘制矩形。
- en: So you can tell one rectangle from another, use OpenCV’s putText() method to
    post the rectangle number in the bottom-left corner of each rectangle. It needs
    the image, the text (as a string), coordinates for the upper-left *x* and lower-right
    *x*, a font, a line width, and a color.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分一个矩形和另一个矩形，使用 OpenCV 的 `putText()` 方法在每个矩形的左下角显示矩形编号。该方法需要图像、文本（字符串形式）、左上角
    *x* 和右下角 *x* 的坐标、字体、线宽和颜色。
- en: Next, draw the annotated latitude limits, starting with the text for 30° north
    ➊. Then draw the line using OpenCV’s line() method. It takes as arguments an image,
    a pair of (*x*, *y*) coordinates for the start and end of the line, a color, and
    a thickness. Repeat these basic instructions for 30° south latitude.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，绘制标注的纬度限制，从 30° 北纬的文本开始 ➊。然后使用 OpenCV 的 `line()` 方法绘制该线。该方法需要传入一个图像、一对 (*x*,
    *y*) 坐标表示线段的起点和终点，一个颜色和一个厚度。对 30° 南纬的纬线执行相同的操作。
- en: End the method by returning the annotated image. The best rectangles, based
    on the peak-to-valley and standard deviation statistics, are shown in [Figures
    7-11](ch07.xhtml#ch07fig11) and [7-12](ch07.xhtml#ch07fig12), respectively.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回标注后的图像来结束该方法。基于峰谷得分和标准差统计数据，最佳矩形分别显示在 [图 7-11](ch07.xhtml#ch07fig11) 和 [7-12](ch07.xhtml#ch07fig12)
    中。
- en: These two figures show the top 20 rectangles for each statistic. That doesn’t
    mean they always agree. The rectangle with the lowest standard deviation may not
    appear in the peak-to-valley figure due to the presence of a single small crater.
    To find the flattest, smoothest rectangles, you need to identify the rectangles
    that appear in both figures and show them in their own display.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两幅图展示了每个统计数据的前 20 个矩形。这并不意味着它们总是相同的。由于单个小陨石坑的存在，标准差最低的矩形可能不会出现在峰谷图中。为了找到最平坦、最平滑的矩形，你需要识别出同时出现在这两幅图中的矩形，并在自己的显示区域中展示它们。
- en: '![Image](../images/fig07-11.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig07-11.jpg)'
- en: 'Figure 7-11: The 20 rectangles with the lowest peak-to-valley scores'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-11：标准差最低的 20 个峰谷得分矩形
- en: '![Image](../images/fig07-12.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig07-12.jpg)'
- en: 'Figure 7-12: The 20 rectangles with the lowest standard deviations'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-12：标准差最低的 20 个矩形
- en: '**Making the Final Color Display**'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**制作最终的彩色显示**'
- en: '[Listing 7-8](ch07.xhtml#ch07list8) finishes the Search class by defining a
    method to summarize the best rectangles. It uses tkinter to make a summary window
    with the rectangles posted on the color MOLA image. It also prints the rectangles’
    statistics below the image as text objects. This adds a little work, but it’s
    a cleaner-looking solution than posting the summarized stats directly on the image
    with OpenCV.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-8](ch07.xhtml#ch07list8) 通过定义一个方法总结最佳矩形，完成了 Search 类的实现。它使用 tkinter 创建一个总结窗口，并将矩形显示在彩色
    MOLA 图像上。它还在图像下方打印矩形的统计数据作为文本对象。虽然这增加了一些工作量，但比直接在图像上用 OpenCV 显示总结的统计数据要干净得多。'
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 7-8: Making the final display using the color MOLA map'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-8：使用彩色 MOLA 地图制作最终显示
- en: After defining the method, give the tkinter screen window a title that links
    to the name of your search object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 定义方法后，为 tkinter 屏幕窗口设置一个标题，标题链接到你的搜索对象名称。
- en: Then, to make the final color image for display, name a local variable img_color_rects
    and call the draw_filtered_rects() method. Pass it the color MOLA image and the
    list of high-graded rectangles. This will return the colored image with the final
    rectangles and latitude limits.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了制作最终的彩色图像用于显示，命名一个局部变量 `img_color_rects` 并调用 `draw_filtered_rects()` 方法。将彩色
    MOLA 图像和评分较高的矩形列表作为参数传入。这将返回包含最终矩形和纬度限制的彩色图像。
- en: Before you can post this new color image in the tkinter canvas, you need to
    convert the colors from OpenCV’s Blue-Green-Red (BGR) format to the Red-Green-Blue
    (RGB) format used by tkinter. Do this with the OpenCV cvtColor() method. Pass
    it the image variable and the COLOR_BGR2RGB flag ➊. Name the result img_converted.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在您将这个新彩色图像显示到tkinter画布之前，您需要将图像的颜色从OpenCV的蓝绿红（BGR）格式转换为tkinter使用的红绿蓝（RGB）格式。可以使用OpenCV的cvtColor()方法来完成此转换。将图像变量和COLOR_BGR2RGB标志➊传递给该方法。将结果命名为img_converted。
- en: At this point, the image is still a NumPy array. To convert to a tkinter- compatible
    photo image, you need to use the PIL ImageTk module’s PhotoImage class and the
    Image module’s fromarray() method. Pass the method the RGB image variable you
    created in the previous step.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，图像仍然是NumPy数组。要转换为tkinter兼容的照片图像，您需要使用PIL ImageTk模块的PhotoImage类和Image模块的fromarray()方法。将您在前一步中创建的RGB图像变量传递给该方法。
- en: With the image finally tkinter ready, place it in the canvas using the create_image()
    method. Pass the method the coordinates of the upper-left corner of the canvas
    (0, 0), the converted image, and a northwest anchor direction.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在图像已准备好用于tkinter，使用create_image()方法将其放置在画布中。将画布的左上角坐标（0, 0）、转换后的图像和西北锚点方向传递给该方法。
- en: Now all that’s left is to add the summary text. Start by assigning coordinates
    for the bottom-left corner of the first text object ➋. Then begin looping through
    the rectangle numbers in the high-graded rectangle list. Use the create_text()
    method to place the text in the canvas. Pass it a pair of coordinates, a left-justified
    anchor direction, the default font, and a text string. Get the statistics by accessing
    the different dictionaries using the rectangle number, designated k for “key.”
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是添加总结文本。首先为第一个文本对象➋的左下角分配坐标。然后开始遍历高等级矩形列表中的矩形编号。使用create_text()方法将文本放入画布中。传递给它一对坐标、左对齐的锚点方向、默认字体和文本字符串。通过使用矩形编号（用k表示“key”）访问不同的字典来获取统计信息。
- en: Increment the text box’s *y*-coordinate by 15 after drawing each text object.
    Then write a conditional to check that the text is greater than or within 10 pixels
    of the bottom of the canvas ➌. You can obtain the height of the canvas using the
    cget() method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制每个文本对象后，将文本框的*y*坐标增加15。然后写一个条件语句，检查文本是否大于或位于画布底部10像素以内➌。您可以使用cget()方法获取画布的高度。
- en: If the text is too close to the bottom of the canvas, you need to start a new
    column. Shift the txt_x variable over by 300 and reset txt_y to the image height
    plus 20.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本离画布底部太近，您需要开始新的一列。将txt_x变量向右移动300，并将txt_y重置为图像的高度加20。
- en: Finish the method definition by packing the canvas and then calling the screen
    object’s mainloop(). Packing optimizes the placement of objects in the canvas.
    The mainloop() is an infinite loop that runs tkinter, waits for an event to occur,
    and processes the event until the window is closed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 完成方法定义后，通过打包画布并调用屏幕对象的mainloop()来结束。打包优化了画布中对象的排列。mainloop()是一个无限循环，运行tkinter，等待事件发生并处理该事件，直到窗口关闭。
- en: '**NOTE**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The height of the color image (506 pixels) is slightly larger than that of
    the grayscale image (501 pixels). I chose to ignore this, but if you’re a stickler
    for accuracy, you can use OpenCV to shrink the height of the color image using
    IMG_COLOR = cv.resize(IMG_COLOR, (1024, 501), interpolation = cv.INTER_AREA).*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*彩色图像的高度（506像素）略大于灰度图像的高度（501像素）。我选择忽略这一点，但如果你对准确性有严格要求，可以使用OpenCV通过`IMG_COLOR
    = cv.resize(IMG_COLOR, (1024, 501), interpolation = cv.INTER_AREA)`来缩小彩色图像的高度。*'
- en: '**Running the Program with main()**'
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用main()运行程序**'
- en: '[Listing 7-9](ch07.xhtml#ch07list9) defines a main() function to run the program.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-9](ch07.xhtml#ch07list9)定义了一个main()函数来运行程序。'
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-9: Defining and calling the main() function used to run the program'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-9：定义并调用用于运行程序的main()函数
- en: Start by instantiating an app object from the Search class. Name it 670x335
    km to document the size of the rectangular regions being investigated. Next, call
    the Search methods in order. Run the statistics on the rectangles and draw the
    quality control rectangles. Sort the statistics from smallest to largest and then
    draw the rectangles with the best peak-to-valley and standard deviation statistics.
    Show the results ➊ and finish the function by making the final summary display.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Search 类实例化一个 app 对象开始。命名为 670x335 km，以记录所研究的矩形区域的大小。接下来，按顺序调用 Search 方法。运行矩形的统计信息并绘制质量控制矩形。将统计信息从小到大排序，然后绘制具有最佳峰谷差和标准差统计信息的矩形。显示结果
    ➊，并通过生成最终的汇总显示来完成函数。
- en: Back in the global space, add the code that lets the program run as an imported
    module or in stand-alone mode ➋.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 返回全局空间，添加代码让程序能够以导入模块或独立模式运行 ➋。
- en: '[Figure 7-13](ch07.xhtml#ch07fig13) shows the final display. It includes the
    high-graded rectangles and the summary statistics sorted based on standard deviation.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-13](ch07.xhtml#ch07fig13) 显示了最终的显示结果。它包括按标准差排序的高评分矩形和汇总统计信息。'
- en: '![Image](../images/fig07-13.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig07-13.jpg)'
- en: 'Figure 7-13: Final display with high-graded rectangles and summary statistics
    sorted by standard deviation'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '图 7-13: 最终显示，包含按标准差排序的高评分矩形和汇总统计信息'
- en: '***Results***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: After you’ve made the final display, the first thing you should do is perform
    a sanity check. Make sure that the rectangles are within the allowed latitude
    and elevation limits and that they appear to be in smooth terrain. Likewise, the
    rectangles based on the peak-to-valley and standard deviation statistics, shown
    in [Figures 7-11](ch07.xhtml#ch07fig11) and [7-12](ch07.xhtml#ch07fig12), respectively,
    should match the constraints and mostly pick the same rectangles.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完成最终显示后，首先要做的是进行合理性检查。确保矩形位于允许的纬度和海拔范围内，并且看起来位于平滑的地形上。同样，基于峰谷差和标准差统计信息的矩形，如在
    [图 7-11](ch07.xhtml#ch07fig11) 和 [图 7-12](ch07.xhtml#ch07fig12) 中所示，应符合约束条件，并且大多数情况下选择相同的矩形。
- en: As noted previously, the rectangles in [Figures 7-11](ch07.xhtml#ch07fig11)
    and [7-12](ch07.xhtml#ch07fig12) don’t perfectly overlap. That’s because you’re
    using two different metrics for smoothness. One thing you can be sure of, though,
    is that the rectangles that do overlap will be the smoothest of all the rectangles.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，[图 7-11](ch07.xhtml#ch07fig11) 和 [图 7-12](ch07.xhtml#ch07fig12) 中的矩形并没有完全重叠。这是因为你使用了两种不同的平滑度度量。虽然如此，你可以确定的是，重叠的矩形将是所有矩形中最平滑的。
- en: While all the rectangle locations look reasonable in the final display, the
    concentration of rectangles on the far-west side of the map is particularly encouraging.
    This is the smoothest terrain in the search area ([Figure 7-14](ch07.xhtml#ch07fig14)),
    and your program clearly recognized it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最终显示中的所有矩形位置看起来都合理，但在地图的远西侧，矩形的集中分布尤为令人鼓舞。这是搜索区域中最平滑的地形（[图 7-14](ch07.xhtml#ch07fig14)），你的程序显然识别了这一点。
- en: This project focused on safety concerns, but scientific objectives drive site
    selection for most missions. In the practice projects at the end of the chapter,
    you’ll get a chance to incorporate an additional constraint— geology—into the
    site selection equation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目重点关注安全问题，但科学目标在大多数任务的站点选择中起主导作用。在本章结尾的实践项目中，你将有机会将额外的约束条件——地质——纳入站点选择的方程中。
- en: '![Image](../images/fig07-14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig07-14.jpg)'
- en: 'Figure 7-14: The very smooth terrain west of the Olympus Mons lava fields'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '图 7-14: 奥林帕斯山熔岩区以西的非常平滑地形'
- en: '**Summary**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**摘要**'
- en: In this chapter, you used Python, OpenCV, the Python Imaging Library, NumPy,
    and tkinter to load, analyze, and display an image. Because OpenCV treats images
    as NumPy arrays, you can easily extract information from parts of an image and
    evaluate it with Python’s many scientific libraries.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你使用了 Python、OpenCV、Python Imaging Library、NumPy 和 tkinter 来加载、分析和显示图像。因为
    OpenCV 将图像视为 NumPy 数组，你可以轻松地从图像的某些部分提取信息，并使用 Python 的众多科学库对其进行评估。
- en: The dataset you used was quick to download and fast to run. While a real intern
    would have used a larger and more rigorous dataset, such as one composed of millions
    of actual elevation measurements, you got to see how the process works with little
    effort and reasonable results.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的数据集下载迅速且运行快速。虽然一个真正的实习生会使用一个更大、更严格的数据集，例如由数百万个实际海拔测量值组成的数据集，但你能够在较少的工作量下看到这个过程如何运行，并获得合理的结果。
- en: '**Further Reading**'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: 'The Jet Propulsion Laboratory has several short and fun videos about landing
    on Mars. Find them with online searches for *Mars in a Minute: How Do You Choose
    a Landing Site?*, *Mars in a Minute: How Do You Get to Mars?*, and *Mars in a
    Minute: How Do You Land on Mars?*.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '喷气推进实验室有几个简短而有趣的视频，讲述火星着陆的过程。通过在线搜索 *Mars in a Minute: How Do You Choose a
    Landing Site?*、*Mars in a Minute: How Do You Get to Mars?* 和 *Mars in a Minute:
    How Do You Land on Mars?* 可以找到这些视频。'
- en: '*Mapping Mars: Science, Imagination, and the Birth of a World* (Picador, 2002),
    by Oliver Morton, tells the story of the contemporary exploration of Mars, including
    the creation of the MOLA map.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mapping Mars: Science, Imagination, and the Birth of a World*（《火星制图：科学、想象与一个世界的诞生》，Picador，2002），由奥利弗·莫顿（Oliver
    Morton）著作，讲述了当代火星探索的故事，包括 MOLA 地图的制作。'
- en: '*The Atlas of Mars: Mapping Its Geography and Geology* (Cambridge University
    Press, 2019), by Kenneth Coles, Kenneth Tanaka, and Philip Christensen, is a spectacular
    all-purpose reference atlas of Mars that includes maps of topography, geology,
    mineralogy, thermal properties, near-surface water-ice, and more.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*The Atlas of Mars: Mapping Its Geography and Geology*（《火星地图集：制图其地理与地质》，剑桥大学出版社，2019），由肯尼斯·科尔斯（Kenneth
    Coles）、肯尼斯·田中（Kenneth Tanaka）和菲利普·克里斯滕森（Philip Christensen）编著，是一本精彩的火星通用参考地图集，包含了地形学、地质学、矿物学、热学性质、近地表水冰等多种地图。'
- en: The data page for the MOLA map used in Project 10 is at *[https://astrogeology.usgs.gov/search/map/Mars/GlobalSurveyor/MOLA/Mars_MGS_MOLA_DEM_mosaic_global_463m/](https://astrogeology.usgs.gov/search/map/Mars/GlobalSurveyor/MOLA/Mars_MGS_MOLA_DEM_mosaic_global_463m/)*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 用于项目 10 的 MOLA 地图的数据页面位于 *[https://astrogeology.usgs.gov/search/map/Mars/GlobalSurveyor/MOLA/Mars_MGS_MOLA_DEM_mosaic_global_463m/](https://astrogeology.usgs.gov/search/map/Mars/GlobalSurveyor/MOLA/Mars_MGS_MOLA_DEM_mosaic_global_463m/)*。
- en: Detailed Martian datasets are available on the Mars Orbital Data Explorer site
    produced by the PDS Geoscience Node at Washington University in St. Louis (*[https://ode.rsl.wustl.edu/mars/index.aspx](https://ode.rsl.wustl.edu/mars/index.aspx)*).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 详细的火星数据集可以在由圣路易斯华盛顿大学 PDS 地质学节点提供的火星轨道数据浏览器网站上找到 (*[https://ode.rsl.wustl.edu/mars/index.aspx](https://ode.rsl.wustl.edu/mars/index.aspx)*).
- en: '**Practice Project: Confirming That Drawings Become Part of an Image**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：确认绘图成为图像的一部分**'
- en: Write a Python program that verifies that drawings added to an image, such as
    text, lines, rectangles, and so on, become part of that image. Use NumPy to calculate
    the mean, standard deviation, and peak-to-valley statistics on a rectangular region
    in the MOLA grayscale image, but don’t draw the rectangle outline. Then draw a
    white line around the region and rerun the statistics. Do the two runs agree?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，验证添加到图像中的绘图内容（如文本、线条、矩形等）是否成为该图像的一部分。使用 NumPy 计算 MOLA 灰度图像中矩形区域的均值、标准差和峰谷统计数据，但不要绘制矩形的边框。然后在该区域周围绘制一条白色线条，并重新运行统计数据。这两次运行的结果一致吗？
- en: You can find a solution, *practice_confirm_drawing_part_of_image.py*, in the
    appendix or *Chapter_7* folder, downloadable from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附录或 *Chapter_7* 文件夹中找到解决方案 *practice_confirm_drawing_part_of_image.py*，该文件可以从
    *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*
    下载。
- en: '**Practice Project: Extracting an Elevation Profile**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：提取海拔剖面**'
- en: An elevation profile is a two-dimensional, cross-sectional view of a landscape.
    It provides a side view of a terrain’s relief along a line drawn between locations
    on a map. Geologists can use profiles to study the smoothness of a surface and
    visualize its topography. For this practice project, draw a west-to-east profile
    that passes through the caldera of the largest volcano in the solar system, Olympus
    Mons ([Figure 7-15](ch07.xhtml#ch07fig15)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 海拔剖面是景观的二维横截面视图。它提供了地图上两个位置之间绘制的线条上的地形起伏的侧面视图。地质学家可以使用剖面来研究表面的平滑度，并可视化其地形。在本练习项目中，绘制一个从西到东的剖面，经过太阳系最大火山奥林匹斯山的火山口（[图
    7-15](ch07.xhtml#ch07fig15)）。
- en: '![Image](../images/fig07-15.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-15.jpg)'
- en: 'Figure 7-15: Vertically exaggerated west-east profile through Olympus Mons'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-15：经过奥林匹斯山的垂直夸张的东西向剖面
- en: Use the *Mars MGS MOLA - MEX HRSC Blended DEM Global 200m v2* map shown in [Figure
    7-15](ch07.xhtml#ch07fig15). This version has better lateral resolution than the
    one you used for Project 10\. It also uses the full elevation range in the MOLA
    data. You can find a copy, *mola_1024x512_200mp.jpg*, in the *Chapter_7* folder,
    downloadable from the book’s website. A solution, *practice_profile_olympus.py*,
    is available in the same folder and in the appendix.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[图 7-15](ch07.xhtml#ch07fig15)中显示的 *Mars MGS MOLA - MEX HRSC Blended DEM Global
    200m v2* 地图。这个版本比你在项目 10 中使用的地图具有更好的横向分辨率。它还使用了 MOLA 数据中的全部高程范围。你可以在 *Chapter_7*
    文件夹中找到一个副本，*mola_1024x512_200mp.jpg*，并可以从本书网站下载。解决方案 *practice_profile_olympus.py*
    可在同一文件夹和附录中找到。
- en: '**Practice Project: Plotting in 3D**'
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：3D 绘图**'
- en: Mars is an asymmetrical planet, with the southern hemisphere dominated by ancient
    cratered highlands and the north characterized by smooth, flat lowlands. To make
    this more apparent, use the 3D plotting functionality in matplotlib to display
    the *mola_1024x512_200mp.jpg* image you used in the previous practice project
    ([Figure 7-16](ch07.xhtml#ch07fig16)).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 火星是一个不对称的行星，南半球以古老的陨石坑高原为主，北半球则是平滑、平坦的低地。为了更好地展示这一点，可以使用 matplotlib 的 3D 绘图功能，显示你在前一个实践项目中使用的
    *mola_1024x512_200mp.jpg* 图像（[图 7-16](ch07.xhtml#ch07fig16)）。
- en: '![Image](../images/fig07-16.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-16.jpg)'
- en: 'Figure 7-16: A 3D contour plot of Mars, looking toward the west'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-16：火星的 3D 等高线图，朝向西方
- en: With matplotlib, you can make 3D relief plots using points, lines, contours,
    wireframes, and surfaces. Although the plots are somewhat crude, you can generate
    them quickly. You can also use the mouse to interactively grab the plot and change
    the viewpoint. They are particularly useful for people who have trouble visualizing
    topography from 2D maps.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 matplotlib，你可以通过点、线、等高线、网格框和表面来制作 3D 地形图。虽然这些图形有些粗糙，但你可以快速生成它们。你还可以使用鼠标交互式地抓取图形并改变视角。它们对于那些难以从
    2D 地图中想象地形的人特别有用。
- en: In [Figure 7-16](ch07.xhtml#ch07fig16), the exaggerated vertical scale makes
    the elevation difference from south to north easy to see. It’s also easy to spot
    the tallest mountain (Olympus Mons) and the deepest crater (Hellas Planitia).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 7-16](ch07.xhtml#ch07fig16)中，夸大的垂直比例使得从南到北的高程差异容易观察到。你还可以轻松识别出最高的山（奥林帕斯山）和最深的陨石坑（赫拉斯平原）。
- en: You can reproduce the plot in [Figure 7-16](ch07.xhtml#ch07fig16)—sans annotation—with
    the *practice_3d_plotting.py* program in the appendix or *Chapter_7* folder, downloadable
    from the book’s website. The map image can be found in the same folder.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用附录中的 *practice_3d_plotting.py* 程序，或 *Chapter_7* 文件夹中的相同程序（可以从本书网站下载）来重现[图
    7-16](ch07.xhtml#ch07fig16)中的图表—不带注释。地图图像可以在同一文件夹中找到。
- en: '**Practice Project: Mixing Maps**'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：混合地图**'
- en: Make up a new project that adds a bit of science to the site selection process.
    Combine the MOLA map with a color geology map and find the smoothest rectangular
    regions within the volcanic deposits at Tharsis Montes (see arrow in [Figure 7-17](ch07.xhtml#ch07fig17)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目，将一些科学元素添加到选址过程中。将 MOLA 地图与彩色地质地图结合，找到塔尔西斯山脉火山沉积物中最平坦的矩形区域（见[图 7-17](ch07.xhtml#ch07fig17)中的箭头）。
- en: '![Image](../images/fig07-17.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-17.jpg)'
- en: 'Figure 7-17: Geological map of Mars. The arrow points to the Tharsis volcanic
    deposits.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-17：火星的地质地图。箭头指向塔尔西斯火山沉积物。
- en: Since the Tharsis Montes region lies at a high altitude, focus on finding the
    flattest and smoothest parts of the volcanic deposits, rather than targeting the
    lowest elevations. To isolate the volcanic deposits, consider thresholding a grayscale
    version of the map. *Thresholding* is a segmentation technique that partitions
    an image into a foreground and a background.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于塔尔西斯山脉区域位于较高的海拔，重点应放在寻找火山沉积物中最平坦、最光滑的部分，而不是最低的海拔。为了隔离火山沉积物，可以考虑对地图进行灰度阈值处理。*阈值处理*是一种分割技术，用于将图像分成前景和背景。
- en: With thresholding, you convert a grayscale image into a binary image where pixels
    above or between specified threshold values are set to 1 and all others are set
    to 0\. You can use this binary image to filter the MOLA map, as shown in [Figure
    7-18](ch07.xhtml#ch07fig18).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用阈值处理，你可以将灰度图像转换为二值图像，其中高于或在指定阈值之间的像素设置为 1，其他所有像素设置为 0。你可以使用这个二值图像来过滤 MOLA
    地图，如[图 7-18](ch07.xhtml#ch07fig18)所示。
- en: '![Image](../images/fig07-18.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig07-18.jpg)'
- en: 'Figure 7-18: Filtered MOLA map over the Tharsis Montes region, with ptp (left)
    and std (right) rectangles'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-18：塔尔西斯山脉区域的 MOLA 滤波地图，左侧为 ptp 矩形，右侧为 std 矩形
- en: You can find the geological map, *Mars_Global_Geology_Mariner9_1024.jpg*, in
    the *Chapter_7* folder, downloadable from the book’s website. The volcanic deposits
    will be light pink in color. For the elevation map, use *mola_1024x512_200mp.jpg*
    from the “Extracting an Elevation Profile” practice project on [page 172](ch07.xhtml#page_172).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*Chapter_7*文件夹中找到地质图*Mars_Global_Geology_Mariner9_1024.jpg*，该文件可以从书籍的网站上下载。火山沉积物的颜色将是浅粉色的。对于高度图，请使用“提取高度剖面”练习项目中的*mola_1024x512_200mp.jpg*，可以在[第
    172 页](ch07.xhtml#page_172)找到。
- en: A solution, contained in *practice_geo_map_step_1of2.py* and *practice_geo_map_step_2of2.py*,
    can be found in the same folder and in the appendix. Run the *practice_geo_map_step_1of2.py*
    program first to generate the filter for step 2.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案包含在*practice_geo_map_step_1of2.py*和*practice_geo_map_step_2of2.py*文件中，可以在同一文件夹中找到，也可以在附录中查看。首先运行*practice_geo_map_step_1of2.py*程序来生成第
    2 步的滤镜。
- en: '**Challenge Project: Making It Three in a Row**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：三连击**'
- en: Edit the “Extracting an Elevation Profile” project so that the profile passes
    through the three volcanoes on Tharsis Montes, as shown in [Figure 7-19](ch07.xhtml#ch07fig19).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑“提取高度剖面”项目，使得剖面通过位于塔尔西斯山脉的三座火山，如[图 7-19](ch07.xhtml#ch07fig19)所示。
- en: '![Image](../images/fig07-19.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig07-19.jpg)'
- en: 'Figure 7-19: Diagonal profile through the three volcanoes on Tharsis Montes'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-19：穿过塔尔西斯山脉三座火山的对角线剖面
- en: Other interesting features to profile are Valles Marineris, a canyon nine times
    as long and four times as deep as the Grand Canyon, and Hellas Planitia, considered
    the third or fourth largest impact crater in the solar system ([Figure 7-19](ch07.xhtml#ch07fig19)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有趣的地貌特征包括瓦莱斯·马里内里斯，这是一个长度是大峡谷的九倍、深度是大峡谷的四倍的峡谷，以及赫拉斯平原，它被认为是太阳系中第三或第四大撞击坑（[图
    7-19](ch07.xhtml#ch07fig19)）。
- en: '**Challenge Project: Wrapping Rectangles**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目：包裹矩形**'
- en: Edit the *site_selector.py* code so that it accommodates rectangle dimensions
    that don’t divide evenly into the width of the MOLA image. One way to do this
    is to add code that splits the rectangle into two pieces (one along the right
    edge of the map and the other along the left edge), calculates statistics for
    each, and then recombines them into a full rectangle. Another approach is to duplicate
    the image and “stitch” it to the original image, as shown in [Figure 7-20](ch07.xhtml#ch07fig20).
    This way, you won’t have to split the rectangles; just decide when to stop stepping
    them across the map.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑*site_selector.py*代码，使其适应不能整除 MOLA 图像宽度的矩形尺寸。实现这一点的一种方法是添加代码，将矩形分割成两部分（一个沿地图的右边缘，另一个沿左边缘），分别计算每个部分的统计数据，然后将它们重新组合成一个完整的矩形。另一种方法是复制图像并将其“拼接”到原始图像上，如[图
    7-20](ch07.xhtml#ch07fig20)所示。这样，你就不需要拆分矩形；只需决定何时停止将它们移动 across 地图即可。
- en: '![Image](../images/fig07-20.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig07-20.jpg)'
- en: 'Figure 7-20: The grayscale MOLA image duplicated and repeated'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-20：重复的灰度 MOLA 图像
- en: Of course, for efficiency, you don’t have to duplicate the whole map. You only
    need a strip along the eastern margin wide enough to accommodate the final overlapping
    rectangle.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了提高效率，你不需要复制整个地图。你只需要沿着东侧边缘保留一条宽度足够容纳最终重叠矩形的条带。
