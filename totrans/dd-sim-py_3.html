<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="part">
<span class="PartNumber"><span epub:type="pagebreak" title="211" id="Page_211"/>Part III</span><br/>
<span class="PartTitle">DATA AND FLOW</span></h1>
</header>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="213" id="Page_213"/>9</span><br/>
<span class="ChapterTitle">Collections and Iteration</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">Looping through an array is one of the most elementary algorithms in programming. Often, it’s one of the first things a new developer does after “Hello, world!” The very principle of starting indices at zero was probably the first paradigm shift you encountered while learning to code. Yet, this is Python; loops and containers here operate on a whole different level.</p>
<p>In this chapter, I’ll cover Python loops and then explore the various collections Python offers for storing and organizing data. Next, I’ll define the concepts of iterables and iterators and start putting them to work in the context of loops. Then, I’ll provide an overview of several iteration tools. Finally, I’ll implement my own iterable class.</p>
<p>Grab a mug of your favorite beverage, and let’s go!</p>
<h2 id="h1-500920c09-0001"><span epub:type="pagebreak" title="214" id="Page_214"/>Loops</h2>
<p class="BodyFirst">Python has two types of loops: <code>while</code> and <code>for</code>. As you’ll see in this chapter, they are not meant to be interchangeable. Rather each has unique purposes.</p>
<h3 id="h2-500920c09-0001">while Loops</h3>
<p class="BodyFirst">The <code>while</code> loop is the most traditional of the loops. As long as the expression in its header evaluates to <code>True</code>, the suite of the loop is executed. For example, the following loop keeps prompting the user to enter a valid number until they do so:</p>
<pre><code>number = None
while number is None:
    try:
        number = int(input("Enter a number: "))
    except ValueError:
        print("You must enter a number.")

print(f"You entered {number}")</code></pre>
<p class="CodeListingCaption"><a id="listing9-1">Listing 9-1</a>: <em>get_number.py:1a</em></p>
<p>As long as the value of <code>number</code> is <code>None</code>, the suite of the <code>while</code> loop keeps repeating. I request input from the user with <code>input()</code> and attempt to convert it to an integer with <code>int()</code>. However, if the user has typed in anything other than a valid integer, a <code>ValueError</code> will be raised, and no new value will be assigned to <code>number</code>. Thus, the loop will repeat.</p>
<p>As soon as the user enters a valid integer, the loop exits and the number is printed to the screen.</p>
<p>Here’s an example output of this program:</p>
<pre><code>Enter a number: forty
You must enter a number.
Enter a number: 
You must enter a number.
Enter a number: 40
You entered 40</code></pre>
<p>If I want to provide a mechanism for quitting instead of entering a number, I could use the <code>break</code> keyword to exit the loop manually. Here, I allow the user to quit by entering a <em>q</em> instead of a number:</p>
<pre><code>number = None
while number is None:
    try:
        <b>raw = </b>input("Enter a number <b>('q' to quit):</b> ")
        <b>if raw == 'q':</b>
<b>            break</b>
        number = <b>int(raw)</b>
    except ValueError:
<span epub:type="pagebreak" title="215" id="Page_215"/>        print("You must enter a number.")

print(f"You entered {number}")</code></pre>
<p class="CodeListingCaption"><a id="listing9-2">Listing 9-2</a>: <em>get_number.py:1b</em></p>
<p>I get the raw input first and check for the string value <code>'q'</code>. If I find it, I escape the loop manually with <code class="bold">break</code>. Otherwise, I attempt to convert the input to an integer as before.</p>
<p>There’s one problem with this approach, as seen in the output:</p>
<pre><code>Enter a number ('q' to quit): foo
You must enter a number.
Enter a number ('q' to quit): q
You entered None</code></pre>
<p>The last line of output isn’t right. I want the program to quit right away instead.</p>
<p>To fix this, I use a little-known feature of loops in Python: the <code>else</code> clause. When a Python loop finishes normally, the <code>else</code> suite is run; however, it is <em>not</em> run if the loop is aborted with a <code>break</code>, <code>return</code>, or raised exception.</p>
<p>By moving my final print statement to the <code>else</code> clause of the loop, I ensure it only runs if a valid number is entered:</p>
<pre><code>number = None
while number is None:
    try:
        raw = input("Enter a number ('q' to quit): ")
        if raw == 'q':
            break
        number = int(raw)
    except ValueError:
        print("You must enter a number.")
<b>else:</b>
<b>    print(f"You entered {number}")</b></code></pre>
<p class="CodeListingCaption"><a id="listing9-3">Listing 9-3</a>: <em>get_number.py:1c</em></p>
<p>Running this code demonstrates the new behavior:</p>
<pre><code>Enter a number ('q' to quit): q</code></pre>
<p>Upon encountering a <em>q</em>, the loop exits immediately, without executing the last <code>print()</code> statement.</p>
<h3 id="h2-500920c09-0002">for Loops</h3>
<p class="BodyFirst">For the majority of this chapter, I’ll focus on the mechanics of the <code>for</code> loop. For now, it will suffice for you to understand that the purpose of a <code>for</code> loop is to traverse through, or <em>iterate over</em>, a collection of values.</p>
<p>Like <code>while</code>, the <code>for</code> loop has an <code>else</code> clause that is only executed when the loop finishes normally, and not when it is manually aborted with <code>break</code>, <code>return</code>, or a raised exception.</p>
<p><span epub:type="pagebreak" title="216" id="Page_216"/>A simplistic example will be enough for now:</p>
<pre><code>numbers = ["One", "Two", "Three"]

for number in numbers:
    print(number)
else:
    print("We're done!")</code></pre>
<p class="CodeListingCaption"><a id="listing9-4">Listing 9-4</a>: <em>print_list.py</em></p>
<p>I define a list of strings, which I assign to <code>numbers</code>. Then, I loop through each value in <code>numbers</code> and print each out to the terminal. When I’m done, I announce that fact with another message.</p>
<p>Here’s the output:</p>
<pre><code>One
Two
Three
We're done!</code></pre>
<p>For the rest of this chapter, I’ll unpack everything happening behind the scenes here, which is surprisingly vast. You will learn how to utilize iteration to its fullest potential in your code.</p>
<h2 id="h1-500920c09-0002">Collections</h2>
<p class="BodyFirst">A <em>collection</em> is a container object containing one or more <em>items</em> organized in some fashion. Each item is bound to a value; the values themselves are not contained within the collection object. There are five fundamental types of collections in Python, each with multiple variations: <code>tuple</code>, <code>list</code>, <code>deque</code>, <code>set</code>, and <code>dict</code> (dictionary).</p>
<p>Once you understand how each collection behaves, using collections effectively is simply a matter of memorizing their methods; in lieu of that, most Python developers rely on the documentation. In a pinch, you can also run <code>help(</code><var>collection</var><code>)</code> in a Python interactive shell, where <var>collection</var> is the collection you want more information about.</p>
<h3 id="h2-500920c09-0003">Tuples</h3>
<p class="BodyFirst">As you know from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> and the usages since, a <em>tuple</em> is a <em>sequence</em> (an array-like collection) that is <em>immutable</em>, meaning that once it is created, its items cannot be added, removed, or reordered. </p>
<p>Conventionally, tuples are used for heterogeneously typed, sequentially ordered data, such as when you need to keep different but associated values together. For example, here’s a tuple containing a customer name, a coffee order, and an order size, in ounces:</p>
<pre><code>order = ("Jason", "pumpkin spice latte", 12)</code></pre>
<p class="CodeListingCaption"><a id="listing9-5">Listing 9-5</a>: <em>order_tuple.py:1</em></p>
<p><span epub:type="pagebreak" title="217" id="Page_217"/>You define a tuple as a comma-separated sequence of values, enclosed in parentheses.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2>	<p class="BoxBodyFirst">In many cases, the parentheses around a tuple are technically optional. They are only used to disambiguate the tuple from its surroundings, such as when passing a tuple to an argument. It’s good practice to always include them.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>Because the contents of a tuple are <em>ordered</em>, you can access individual items by index, or <em>subscript</em>, specified in square brackets:</p>
<pre><code>print(order[1])  # prints "pumpkin spice latte"</code></pre>
<p class="CodeListingCaption"><a id="listing9-6">Listing 9-6</a>: <em>order_tuple.py:2</em></p>
<p>If you need a tuple with a single item, leave a trailing comma after the item, like so:</p>
<pre><code>orders = ("pumpkin spice latte",)</code></pre>
<p>This is primarily useful when one of your functions is expected to return a tuple, but you don’t know in advance how many elements you’ll need to return in that tuple.</p>
<p>Since tuples are immutable, they don’t offer any built-in methods for adding, changing, or removing items. You define a tuple once, in its entirety, up front, and then you access the items it contains.</p>
<h3 id="h2-500920c09-0004">Named Tuples</h3>
<p class="BodyFirst">The <code>collections</code> module provides a strange little variant of the tuple called the <em>named tuple</em>, which allows you to define a tuple-like collection with named fields. Like a normal tuple, a named tuple is an immutable collection. Its primary use is adding keys to the values, while still retaining its subscriptable behavior:</p>
<pre><code>from collections import namedtuple

CoffeeOrder = namedtuple( <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> "CoffeeOrder", <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>('item', 'addons', 'to_go'))

order = CoffeeOrder('pumpkin spice latte', ('whipped cream',), True)
print( <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> order.item)  # prints 'pumpkin spice latte'
print( <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> order[2])    # prints 'True'</code></pre>
<p class="CodeListingCaption"><a id="listing9-7">Listing 9-7</a>: <em>coffeeorder_namedtuple.py</em></p>
<p>I define a new <code>namedtuple</code> with the type name <code>CoffeeOrder</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which I also bind to the name <code>CoffeeOrder</code>. I name three fields in that named tuple: <code>item</code>, <code>addons</code>, and <code>to_go</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p>Next, I create a new instance of the named tuple by passing the values to the <code>CoffeeOrder</code> initializer, and I bind the instance to <code>order</code>. I can access the values within <code>order</code> by field name <span class="CodeAnnotation" aria-label="annotation3">❸</span> or by subscript <span class="CodeAnnotation" aria-label="annotation4">❹</span>. </p>
<p><span epub:type="pagebreak" title="218" id="Page_218"/>In practice, most Pythonistas prefer dictionaries or classes to named tuples, but all three have their place.</p>
<h3 id="h2-500920c09-0005">Lists</h3>
<p class="BodyFirst"><em>Lists</em> are sequence collections that are <em>mutable</em>, meaning items can be added, removed, and reordered. Conventionally, lists are used for homogeneously typed, sequentially ordered data, such as this list of specials at the fictional Uncomment Café:</p>
<pre><code>specials = ["pumpkin spice latte", "caramel macchiato", "mocha cappuccino"]</code></pre>
<p class="CodeListingCaption"><a id="listing9-8">Listing 9-8</a>: <em>specials_list.py:1</em></p>
<p>You define a list as a comma-separated sequence, enclosed in square brackets. As with tuples, you can access individual items via their index, specified in square brackets:</p>
<pre><code>print(specials[1])      # prints "caramel macchiato"</code></pre>
<p class="CodeListingCaption"><a id="listing9-9">Listing 9-9</a>: <em>specials_list.py:2</em></p>
<p>You can use lists as arrays, stacks, or queues. Here are a few of the most commonly used methods on <code>list</code>:</p>
<pre><code>drink = specials.pop()  # return and remove last item
print(drink)            # prints "mocha cappuccino"
print(specials)         # prints ['pumpkin spice latte', 'caramel macchiato']</code></pre>
<p class="CodeListingCaption"><a id="listing9-10">Listing 9-10</a>: <em>specials_list.py:3</em></p>
<p>I use <code>pop()</code> to return and remove items from the list. If I don’t pass an index to <code>pop()</code>, the last item is removed by default.</p>
<p>If I pass an index as an argument to <code>pop()</code>, the indicated item is removed instead:</p>
<pre><code>drink = specials.pop(1)  # return and remove item [1]
print(drink)             # prints "caramel macchiato"
print(specials)          # prints ['pumpkin spice latte']</code></pre>
<p class="CodeListingCaption"><a id="listing9-11">Listing 9-11</a>: <em>specials_list.py:4</em></p>
<p>I can also add new items to the end of the list, using <code>append()</code>:</p>
<pre><code>specials.append("cold brew")  # inserts item at end
print(specials)               # prints ['pumpkin spice latte', 'cold brew']</code></pre>
<p class="CodeListingCaption"><a id="listing9-12">Listing 9-12</a>: <em>specials_list.py:5</em></p>
<p>The new item, <code>"cold brew"</code>, is passed to <code>append()</code>, and it is added at the end of the list.</p>
<p><span epub:type="pagebreak" title="219" id="Page_219"/>If I want to add an item somewhere else in the list, I can use <code>insert()</code>:</p>
<pre><code>specials.insert(1, "americano")  # inserts as item [1]
print(specials)                  # prints ['pumpkin spice latte', 'americano', 'cold brew']</code></pre>
<p class="CodeListingCaption"><a id="listing9-13">Listing 9-13</a>: <em>specials_list.py:6</em></p>
<p>The first argument is a target index, <code>1</code>, and the new item, <code>"americano"</code>, is the second argument.</p>
<p>These are the three most common methods for modifying lists. Python has more, many of which are quite interesting. As I’ve mentioned, the official documentation is your best resource for learning all the available methods.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2>	<p class="BoxBodyFirst">If you want a traditional dynamically sized array, which compactly stores exactly one data type, check out the <code>array</code> module: <a href="https://docs.python.org/3/library/array.html" class="LinkURL">https://docs.python.org/3/library/array.html</a>. In practice, this is seldom needed.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c09-0006">Deques</h3>
<p class="BodyFirst">The <code>collections</code> module provides another sequence, <em>deque</em> (pronounced “deck”), which is optimized for accessing the first and last items. This makes it a good option to use as a stack or queue when performance especially matters.</p>
<p>In this example, I’ll use <code>deque</code> to track the people waiting in line at the Uncomment Café:</p>
<pre><code>from collections import deque
customers = deque(['Daniel', 'Denis'])</code></pre>
<p class="CodeListingCaption"><a id="listing9-14">Listing 9-14</a>: <em>customers_deque.py:1</em></p>
<p>After I import <code>deque</code> from <code>collections</code>, I create a new <code>deque</code>, which I bind to <code>customers</code>. I pass a list of two customers as the list’s initial value, although I could have omitted this and started with an empty deque instead.</p>
<p>Simon enters the café and gets in line, so I add him to the end of the <code>deque</code> with <code>append()</code>:</p>
<pre><code>customers.append('Simon')
print(customers)  # prints deque(['Daniel', 'Denis', 'Simon'])</code></pre>
<p class="CodeListingCaption"><a id="listing9-15">Listing 9-15</a>: <em>customers_deque.py:2</em></p>
<p>Then, the barista helps the next person in line, so I return and remove the first customer, Daniel, from the front (“left”) of the line, using <code>popleft()</code>:</p>
<pre><code>customer = customers.popleft()
print(customer)   # prints 'Daniel'
print(customers)  # prints deque(['Denis', 'Simon'])</code></pre>
<p class="CodeListingCaption"><a id="listing9-16">Listing 9-16</a>: <em>customers_deque.py:3</em></p>
<p><span epub:type="pagebreak" title="220" id="Page_220"/>There are once again two people in line. James slips in front of everyone else (how rude!), so I append him to the “left” of the <code>deque</code> with <code>appendleft()</code>:</p>
<pre><code>customers.appendleft('James')
print(customers)  # prints deque(['James', 'Denis', 'Simon'])</code></pre>
<p class="CodeListingCaption"><a id="listing9-17">Listing 9-17</a>: <em>customers_deque.py:4</em></p>
<p>But that’s okay by Simon, because the last person in line wins a free drink. I return and remove the last item from the deque:</p>
<pre><code>last_in_line = customers.pop()
print(last_in_line)  # prints 'Simon'</code></pre>
<p class="CodeListingCaption"><a id="listing9-18">Listing 9-18</a>: <em>customers_deque.py:5</em></p>
<p>After all this, the deque only has James and Denis:</p>
<pre><code>print(customers)  # prints deque(['James', 'Denis'])</code></pre>
<p class="CodeListingCaption"><a id="listing9-19">Listing 9-19</a>: <em>customers_deque.py:6</em></p>
<h3 id="h2-500920c09-0007">Sets</h3>
<p class="BodyFirst">A <em>set</em> is a built-in, mutable, <em>unordered</em> collection, in which all items are guaranteed to be unique. If you try to add an item that already exists in the set, the new duplicate will be discarded. You’ll primarily use a set for fast inclusion checks and various operations relating to set theory (math), especially in large data sets.</p>
<p>Every value stored in a set must be <em>hashable</em>, which the Python documentation defines as having “a hash value that never changes during its lifetime.” Hashable objects implement the special method <code>__hash__()</code>. All the built-in immutable types are hashable, since they never change value throughout their lifetime. However, many mutable types are not hashable.</p>
<p>I’ll use a set to run a raffle at the Uncomment Café, where each customer can only enter once:</p>
<pre><code>raffle = {'James', 'Denis', 'Simon'}</code></pre>
<p class="CodeListingCaption"><a id="listing9-20">Listing 9-20</a>: <em>raffle_set.py:1</em></p>
<p>I first define the set as a comma-separated sequence of values, surrounded by curly braces (<code>{}</code>). In this case, I provide three initial values.</p>
<p>As customers come in, I add their names to the set with <code>add()</code>. If their name is already in the set, such as in the case of Denis, it won’t be added another time if I try to add it:</p>
<pre><code>raffle.add('Daniel')
raffle.add('Denis')
print(raffle)  # prints {'Daniel', 'Denis', 'Simon', 'James'}</code></pre>
<p class="CodeListingCaption"><a id="listing9-21">Listing 9-21</a>: <em>raffle_set.py:2</em></p>
<p><span epub:type="pagebreak" title="221" id="Page_221"/>The <code>print</code> statement shows the current items in the set. Just remember that sets are <em>unordered</em>, so there is no guarantee of the order in which the items will appear.</p>
<p>I can remove items from the set using <code>discard()</code>. Since Simon won something earlier, I’ll remove his name:</p>
<pre><code>raffle.discard('Simon')
print(raffle)  # prints {'Daniel', 'Denis', 'James'}</code></pre>
<p class="CodeListingCaption"><a id="listing9-22">Listing 9-22</a>: <em>raffle_set.py:3</em></p>
<p>I could have also used <code>remove()</code> to remove a value, but that raises a <code>KeyError</code> if the specified value is not in the set; <code>discard()</code> never raises an error.</p>
<p>Finally, I return and remove an arbitrary item from the set with <code>pop()</code>:</p>
<pre><code>winner = raffle.pop()
print(winner)  # prints arbitrary item of set, e.g. 'Denis'</code></pre>
<p class="CodeListingCaption"><a id="listing9-23">Listing 9-23</a>: <em>raffle_set.py:4</em></p>
<p>Be aware, <em>arbitrary</em> does not mean <em>random</em>! The <code>pop()</code> method always returns and removes whichever item happens to be in the first position in the set. Because <code>set</code> is unordered and Python makes no guarantees about the internal sequence of the items, you cannot trust <code>set</code> for reliable randomness.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">To specify an empty set, you would use <code>set()</code>, as an empty pair of curly braces (<code>{ }</code>) specifies an empty dictionary instead.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c09-0008">frozenset</h3>
<p class="BodyFirst">The immutable twin to <code>set</code> is <code>frozenset</code>, which works in much the same manner. They differ in the same way that <code>list</code> and <code>tuple</code> do: once created, a <code>frozenset</code> cannot have items added or removed.</p>
<p>To demonstrate this, I’ll create a <code>frozenset</code> for storing all previous prizewinners and use that as part of the next raffle:</p>
<pre><code>raffle = {'Kyle', 'Denis', 'Jason'}
prev_winners = frozenset({'Denis', 'Simon'})</code></pre>
<p class="CodeListingCaption"><a id="listing9-24">Listing 9-24</a>: <em>raffle_frozenset.py:1</em></p>
<p>A <code>frozenset</code> is specified by passing a set literal (shown here), an existing set, or another linear collection to the <code>frozenset()</code> initializer. After I initially define <code>prev_winners</code>, I cannot change the contents of the <code>frozenset</code>—it’s immutable. The regular set, <code>raffle</code>, can still be modified.</p>
<p>One of the most exciting features of <code>set</code> and <code>frozenset</code> is that they both support <em>set mathematics</em>. You can use math and logic operators for finding the union (<code>|</code>), intersection (<code>&amp;</code>), difference (<code>-</code>), and symmetric difference (<code>^</code>). It’s also useful for testing if one set is a subset (<code>&lt;</code> or <code>&lt;=</code>) or superset (<code>&gt;</code> or <code>&gt;=</code>) <span epub:type="pagebreak" title="222" id="Page_222"/>of the other. The documentation also outlines several other functions for combining and comparing sets of either type.</p>
<p>In my example, I’ll remove all the previous winners (<code>prev_winners</code>) from the <code>raffle</code> set using the <code>-=</code> operator:</p>
<pre><code>raffle -= prev_winners  # remove previous winners
print(raffle)           # prints {'Jason', 'Kyle'}</code></pre>
<p class="CodeListingCaption"><a id="listing9-25">Listing 9-25</a>: <em>raffle_frozenset.py:2</em></p>
<p>Then I can <code>pop()</code> an arbitrary item off of <code>raffle</code> to find my winner:</p>
<pre><code>winner = raffle.pop()
print(winner)  # prints arbitrary item of set, e.g. 'Kyle'</code></pre>
<p class="CodeListingCaption"><a id="listing9-26">Listing 9-26</a>: <em>raffle_frozenset.py:3</em></p>
<p>Yay for Kyle! He wins a three-day, one-night trip to Antarctica, courtesy of Frozen Set Airlines. (Bundle up, buddy.)</p>
<h3 id="h2-500920c09-0009">Dictionaries</h3>
<p class="BodyFirst">A <em>dictionary</em> (type <code>dict</code>) is a mutable collection that stores data in <em>key-value</em> pairs, instead of in linear fashion. This associative manner of storage is known as <em>mapping</em>. Keys can be virtually any type, as long as that type is hashable. It’s easiest to remember that hashable types are virtually always immutable.</p>
<p>The value in the pair can be anything. Looking up a value by key is particularly fast, regardless of the amount of data in the dictionary. (In other languages, this type of collection is referred to as a <em>hashmap</em>; in CPython, the dictionary is implemented as a hash table.)</p>
<p>I’ll use a dictionary to store the menu at the Uncomment Café:</p>
<pre><code>menu = {"drip": 1.95, "cappuccino": 2.95}</code></pre>
<p class="CodeListingCaption"><a id="listing9-27">Listing 9-27</a>: <em>menu_dict.py:1</em></p>
<p>I create the dictionary as a sequence of comma-separated key-value pairs, wrapped in curly braces, with a colon (<code>:</code>) separating the key and value in each pair. In this case, the key is a string that is the name of the drink, and the value is a floating-point number representing the price.</p>
<p>I access individual items by key, specified in square brackets (<code>[ ]</code>):</p>
<pre><code>print(menu["drip"])  # prints 1.95</code></pre>
<p class="CodeListingCaption"><a id="listing9-28">Listing 9-28</a>: <em>menu_dict.py:2</em></p>
<p>If the key being accessed is not in the dictionary, a <code>KeyError</code> is raised.</p>
<p><span epub:type="pagebreak" title="223" id="Page_223"/>I can add or modify items by assigning a value to a key specified in square brackets. Here, I’ll add the <code>"americano"</code> key to the menu, with a price value of <code>2.49</code>:</p>
<pre><code>menu["americano"] = 2.49
print(menu)  # prints {'drip': 1.95, 'cappuccino': 2.95, 'americano': 2.49}</code></pre>
<p class="CodeListingCaption"><a id="listing9-29">Listing 9-29</a>: <em>menu_dict.py:3</em></p>
<p>For whatever reason, the Americano isn’t terribly popular at the café, so I wind up removing it from the dictionary, using the <code>del</code> operator on the key:</p>
<pre><code>del menu["americano"]  # removes "americano" from dictionary
print(menu)            # prints {'drip': 1.95, 'cappuccino': 2.95}</code></pre>
<p class="CodeListingCaption"><a id="listing9-30">Listing 9-30</a>: <em>menu_dict.py:4</em></p>
<p>Once again, if the key specified in the square brackets were not in the dictionary, a <code>KeyError</code> would be raised.</p>
<h3 id="h2-500920c09-0010">Check or Except?</h3>
<p class="BodyFirst">There’s a bit of debate about whether one should check for a key in a dictionary directly with the <code>in</code> operator or use a <code>try</code> statement with a <code>KeyError</code> instead.</p>
<p>Here’s the EAFP (“Easier to Ask Forgiveness than Permission”) approach, using <code>try</code>:</p>
<pre><code>menu = {'drip': 1.95, 'cappuccino': 2.95, 'americano': 2.49}


def checkout(order):
    try:
        print(f"Your total is { <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> menu[order]}")
    except KeyError:
        print("That item is not on the menu.")


checkout("drip")  # prints "Your total is 1.95"
checkout("tea")   # prints "That item is not on the menu."</code></pre>
<p class="CodeListingCaption"><a id="listing9-31">Listing 9-31</a>: <em>checkout_dict_eafp.py</em></p>
<p>Within a <code>try</code> statement, I try to access the value in the dictionary <code>menu</code> associated with the key <code>order</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the key is invalid, a <code>KeyError</code> will be raised and I will catch it in the <code>except</code> clause. I can then take the appropriate action.</p>
<p>This approach is better suited to instances where invalid keys are an <em>exceptional</em> situation (thus, “exceptions”). Typically, an <code>except</code> clause is a more expensive operation in terms of performance, but it’s an expense that is completely justified for handling errors and other exceptional situations.</p>
<p><span epub:type="pagebreak" title="224" id="Page_224"/>Here’s the LBYL (“Look Before You Leap”) approach, using the <code>in</code> operator:</p>
<pre><code>menu = {'drip': 1.95, 'cappuccino': 2.95, 'americano': 2.49}


def checkout(order):
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> if order in menu:
        print(f"Your total is { <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> menu[order]}")
    else:
        print("That item is not on the menu.")


checkout("drip")  # prints "Your total is 1.95"
checkout("tea")   # prints "That item is not on the menu."</code></pre>
<p class="CodeListingCaption"><a id="listing9-32">Listing 9-32</a>: <em>checkout_dict_lbyl.py</em></p>
<p>In this approach, I check whether <code>order</code> is a key in the <code>menu</code> dictionary before I do anything <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If it’s there, I can safely access the value associated with the key <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This approach may be preferable if you expect to frequently check for invalid keys, since either outcome is reasonably likely. Failure is more the <em>rule</em> than the <em>exception</em>, so it’s better for both scenarios to have roughly the same performance.</p>
<p>The LBYL approach is generally frowned upon when an invalid key is an exceptional situation, because it has to look in the dictionary for a valid key twice: once when checking and once when accessing. By contrast, the EAFP approach only has to access a valid key once, since it handles the possible <code>KeyError</code>.</p>
<p>As with all issues of performance, you can’t know for sure until you profile the code. You can rely on the assumptions herein, unless you specifically need the logic structure of one approach or the other. However, if performance is critical, profile the code (see <span class="xref" itemid="xref_target_Chapter 19">Chapter 19</span>).</p>
<h3 id="h2-500920c09-0011">Dictionary Variants</h3>
<p class="BodyFirst">Python has a <code>collections</code> module that offers a few variations on the built-in <code>dict</code>. Here are the three most common variations, along with their unique behavior:</p>
<ol class="none">
<li><code>defaultdict</code> allows you to specify a callable that produces a default value. If you attempt to access the value on an undefined key, a new key-value pair will be defined, using this default value.</li>
<li><code>OrderedDict</code> has extra functionality for tracking and managing the order of key-value pairs. Since Python 3.7, the built-in <code>dict</code> also officially preserves insertion order, but <code>OrderedDict</code> is specifically <em>optimized</em> for reordering and has additional behaviors for it.</li>
<li><code>Counter</code> is designed specifically for counting hashable objects; the object is the key, and the count is an integer value. Other languages call this type of collection a <em>multiset</em>.</li>
</ol>
<p><span epub:type="pagebreak" title="225" id="Page_225"/>You should only use one of these specialized dictionary types if you actually need its behavior, so I won’t go into more detail here. Each is optimized for a specific use case and is not likely to have optimal performance in other scenarios. The official documentation is your best bet if you need further details: <a href="https://docs.python.org/3/library/collections.html" class="LinkURL">https://docs.python.org/3/library/collections.html</a>.</p>
<h2 id="h1-500920c09-0003">Unpacking Collections</h2>
<p class="BodyFirst">All collections can be <em>unpacked</em> into multiple variables, meaning each item is assigned to its own name. For example, I can unpack a deque of three customers into three separate variables. I first create the deque of customers:</p>
<pre><code>from collections import deque

customers = deque(['Kyle', 'Simon', 'James'])</code></pre>
<p class="CodeListingCaption"><a id="listing9-33">Listing 9-33</a>: <em>unpack_customers.py:1a</em></p>
<p>Next, to unpack the deque. I place a comma-separated list of names to unpack into, in order, on the left side of an assignment operator:</p>
<pre><code>first, second, third = customers
print(first)   # prints 'Kyle'
print(second)  # prints 'Simon'
print(third)   # prints 'James'</code></pre>
<p class="CodeListingCaption"><a id="listing9-34">Listing 9-34</a>: <em>unpack_customers.py:2a</em></p>
<p>Sometimes, you’ll see this left-hand part wrapped in parentheses, but using parentheses isn’t required when unpacking a linear collection like this. (I’ll demonstrate where parentheses fit into unpacking a dictionary in the next section.) I place the collection I’m unpacking on the right side of the assignment operator.</p>
<p>There’s one major limitation to unpacking: you have to know how many values you’re unpacking! To demonstrate this, I’ll go back and add one more customer to the deque with the <code>append()</code> method:</p>
<pre><code>from collections import deque

customers = deque(['Kyle', 'Simon', 'James'])
<b>customers.append('Daniel')</b></code></pre>
<p class="CodeListingCaption"><a id="listing9-35">Listing 9-35</a>: <em>unpack_customers.py:1b</em></p>
<p>If I were to specify too many or too few names on the left, a <code>ValueError</code> would be raised. Since my deque contains four values, trying to unpack into three names fails:</p>
<pre><code>first, second, third = customers  <b># raises ValueError</b>
print(first)                      # never reached
<span epub:type="pagebreak" title="226" id="Page_226"/>print(second)                     # never reached
print(third)                      # never reached</code></pre>
<p class="CodeListingCaption"><a id="listing9-36">Listing 9-36</a>: <em>unpack_customers.py:2b</em></p>
<p>To fix this, I could specify a fourth name on the left. However, for this example, I want to ignore the fourth value. I can ignore any item by unpacking it into an underscore:</p>
<pre><code>first, second, third<b>, _</b> = customers
print(first)    # prints 'Kyle'
print(second)   # prints 'Simon'
print(third)    # prints 'James'</code></pre>
<p class="CodeListingCaption"><a id="listing9-37">Listing 9-37</a>: <em>unpack_customers.py:2c</em></p>
<p>The underscore (<code>_</code>), when used as a name, conventionally indicates that the value should be ignored. I can use the underscore as many times as I need, such as if I want to ignore the last two values in the collection:</p>
<pre><code>first, second, <b>_, _</b> = customers
print(first)   # prints 'Kyle'
print(second)  # prints 'Simon'</code></pre>
<p class="CodeListingCaption"><a id="listing9-38">Listing 9-38</a>: <em>unpack_customers.py:2d</em></p>
<p>Only the first two values in <code>customers</code> will be unpacked, and the second two will be effectively ignored.</p>
<p>By the way, if you ever need to unpack a collection that only contains one value, leave a trailing comma after the name you’re unpacking into:</p>
<pre><code>baristas = ('Jason'<b>,</b>)
barista, = baristas
print(barista)  # prints 'Jason'</code></pre>
<h3 id="h2-500920c09-0012">Starred Expressions</h3>
<p class="BodyFirst">If you have no idea how many additional values there are in the collection, you can capture multiple unpacked values using a <em>starred expression</em>:</p>
<pre><code>first, second, <b>*rest</b> = customers
print(first)    # prints 'Kyle'
print(second)   # prints 'Simon'
print(<b>rest</b>)     # prints ['James', 'Daniel']</code></pre>
<p class="CodeListingCaption"><a id="listing9-39">Listing 9-39</a>: <em>unpack_customers.py:2e</em></p>
<p>The first two values are unpacked into <code>first</code> and <code>second</code>, and the remainder (if any) are packed into a list assigned to <code>rest</code>. As long as the collection being unpacked has at least two values, one for each of the nonstarred <span epub:type="pagebreak" title="227" id="Page_227"/>names on the left, this will work. If there are only two values in the collection, <code>rest</code> will be an empty list.</p>
<p>You can use starred expressions anywhere in the unpacking list, including the beginning. Here’s an example where I unpack the <code>first</code> and <code>last</code> values individually and pack all the rest into a list named <code>middle:</code></p>
<pre><code>first, *middle, last = customers
print(first)    # prints 'Kyle'
print(middle)   # prints ['Simon', 'James']
print(last)     # prints 'Daniel'</code></pre>
<p class="CodeListingCaption"><a id="listing9-40">Listing 9-40</a>: <em>unpack_customers.py:3</em></p>
<p>You can even use starred expressions to ignore multiple values:</p>
<pre><code>*_, second_to_last, last = customers
print(second_to_last)  # prints 'James'
print(last)            # prints 'Daniel'</code></pre>
<p class="CodeListingCaption"><a id="listing9-41">Listing 9-41</a>: <em>unpack_customers.py:4</em></p>
<p>By preceding the underscore with an asterisk, I capture multiple values but ignore them, instead of packing them into a list. In this scenario, I unpack the last two values in the collection.</p>
<p>You can only have one starred expression per unpacking statement, because starred expressions are <em>greedy</em>—consuming as many values as they’re allowed. Python unpacks values into all the other names before evaluating the starred expression. Using multiple starred expressions in the same statement makes no sense, since it’s impossible to tell where one stops and another starts.</p>
<h3 id="h2-500920c09-0013">Unpacking Dictionaries</h3>
<p class="BodyFirst">Dictionaries can be unpacked like any other built-in type of collection. By default, only the keys are unpacked, as seen when I unpack the dictionary representing the café menu.</p>
<p>I start by defining my dictionary:</p>
<pre><code>menu = {'drip': 1.95, 'cappuccino': 2.95, 'americano': 2.49}</code></pre>
<p class="CodeListingCaption"><a id="listing9-42">Listing 9-42</a>: <em>unpack_menu.py:1</em></p>
<p>Then, I unpack the dictionary:</p>
<pre><code>a, b, c = menu
print(a)  # prints 'drip'
print(b)  # prints 'cappuccino'
print(c)  # prints 'americano'</code></pre>
<p class="CodeListingCaption"><a id="listing9-43">Listing 9-43</a>: <em>unpack_menu.py:2a</em></p>
<p><span epub:type="pagebreak" title="228" id="Page_228"/>If I want the values instead, I must unpack using a <em>dictionary view</em>, which provides access to the keys and/or values in a dictionary. In this case, I use the <code>values()</code> dictionary view:</p>
<pre><code>a, b, c = <b>menu.values()</b>
print(a)  # prints 1.95
print(b)  # prints 2.95
print(c)  # prints 2.49</code></pre>
<p class="CodeListingCaption"><a id="listing9-44">Listing 9-44</a>: <em>unpack_menu.py:2b</em></p>
<p>I can unpack the keys and values together by unpacking from the <code>items()</code> dictionary view. This returns each key-value pair as a tuple:</p>
<pre><code>a, b, c = <b>menu.items()</b>
print(a)  # prints ('drip', 1.95)
print(b)  # prints ('cappuccino', 2.95)
print(c)  # prints ('americano', 2.49)</code></pre>
<p class="CodeListingCaption"><a id="listing9-45">Listing 9-45</a>: <em>unpack_menu.py:2c</em></p>
<p>I can also unpack each of the key-value tuples in the same statement by using parentheses around a pair of names a tuple will be unpacked into:</p>
<pre><code>(a_name, a_price), (b_name, b_price), *_ = menu.items()
print(a_name)    # prints 'drip'
print(a_price)   # prints 1.95
print(b_name)    # prints 'cappuccino'
print(b_price)   # prints 2.95</code></pre>
<p class="CodeListingCaption"><a id="listing9-46">Listing 9-46</a>: <em>unpack_menu.py:3</em></p>
<p>For brevity, I chose to only unpack the first two items in the <code>menu</code> dictionary and ignore the rest. I unpack the first tuple from <code>menu.items()</code> into the pair <code>(a_name, a_price)</code>, so the first item of the tuple is stored in <code>a_name</code> and the second item is stored in <code>a_price</code>. The same thing happens with the second key-value pair in the dictionary.</p>
<p>You can use this unpacking strategy with parentheses to unpack two-dimensional collections, such as a list of tuples or a tuple of sets.</p>
<h2 id="h1-500920c09-0004">Structural Pattern Matching on Collections</h2>
<p class="BodyFirst">Starting from Python 3.10, it is possible to perform structural pattern matching on tuples, lists, and dictionaries.</p>
<p>In patterns, tuples and lists are interchangeable. They are both matched against sequence patterns<em>. Sequence patterns</em> use the same syntax as unpacking, including the ability to use starred expressions. For example, I could <span epub:type="pagebreak" title="229" id="Page_229"/>match on the first and last elements of a sequence and ignore everything in the middle:</p>
<pre><code>order = ['venti', 'no whip', 'mocha latte', 'for here']

match order:
    case ('tall', *drink, 'for here'):
        drink = ' '.join(drink)
        print(f"Filling ceramic mug with {drink}.")
    case ['grande', *drink, 'to go']:
        drink = ' '.join(drink)
        print(f"Filling large paper cup with {drink}.")
    case ('venti', *drink, 'for here'):
        drink = ' '.join(drink)
        print(f"Filling extra large tumbler with {drink}.")</code></pre>
<p class="CodeListingCaption"><a id="listing9-47">Listing 9-47</a>: <em>match_coffee_sequence.py</em></p>
<p>Sequence patterns are the same, whether enclosed in parentheses or square brackets. The list <code>order</code> is compared against each pattern. For each, the first and last items are checked, and the rest of the items are captured via wildcard as <code>drink</code>. Within each case, I join together the elements in <code>drink</code> to determine what to fill the chosen vessel with.</p>
<p>I could also pattern match against specific values in a dictionary, using a <em>mapping pattern</em>. Here’s almost the same example, reworked to used a dictionary instead:</p>
<pre><code>order = {
    'size': 'venti',
    'notes': 'no whip',
    'drink': 'mocha latte',
    'serve': 'for here'
}

match order:
    case {'size': 'tall', 'serve': 'for here', 'drink': drink}:
        print(f"Filling ceramic mug with {drink}.")
    case {'size': 'grande', 'serve': 'to go', 'drink': drink}:
        print(f"Filling large paper cup with {drink}.")
    case {'size': 'venti', 'serve': 'for here', 'drink': drink}:
        print(f"Filling extra large tumbler with {drink}.")</code></pre>
<p class="CodeListingCaption"><a id="listing9-48">Listing 9-48</a>: <em>match_coffee_dictionary.py:1a</em></p>
<p>Mapping patterns are wrapped in curly braces. Only the keys I specify in the pattern are checked, while any other keys are ignored. In this version, I check the <code>'size'</code> and <code>'serve'</code> keys, as well as the value associated with the key <code>'drink'</code>, which I capture as <code>drink</code>.</p>
<p><span epub:type="pagebreak" title="230" id="Page_230"/>If you run this version of the code, versus the previous one, you’ll notice that I’m leaving the <code>'notes'</code> off (for example, <code>'no whip'</code>). To fix that, I could capture all remaining keys via wildcard instead, like this:</p>
<pre><code>order = {
    'size': 'venti',
    'notes': 'no whip',
    'drink': 'mocha latte',
    'serve': 'for here'
}

match order:
    case {'size': 'tall', 'serve': 'for here', <b>**rest}</b>:
        <b>drink = f"{rest['notes']} {rest['drink']}"</b>
        print(f"Filling ceramic mug with {drink}.")
    case {'size': 'grande', 'serve': 'to go', <b>**rest}</b>:
        <b>drink = f"{rest['notes']} {rest['drink']}"</b>
        print(f"Filling large paper cup with {drink}.")
    case {'size': 'venti', 'serve': 'for here', <b>**rest}</b>:
        <b>drink = f"{rest['notes']} {rest['drink']}"</b>
        print(f"Filling extra large tumbler with {drink}.")</code></pre>
<p class="CodeListingCaption"><a id="listing9-49">Listing 9-49</a>: <em>match_coffee_dictionary.py:1b</em></p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2>	<p class="BoxBodyFirst">Because any keys not explicitly listed in the mapping pattern are ignored anyway, the wildcard for ignoring all remaining keys without capturing them, two asterisks and an underscore (<code>**_</code>), is not legal in mapping patterns.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>Although I chose to demonstrate capturing with a wildcard in a mapping pattern, it is worth noting that I can still directly access the subject, <code>order</code>, from within any of the cases. In this particular example, I could have just as easily written the code like this:</p>
<pre><code>match order:
    case {'size': 'tall', 'serve': 'for here'}:
        drink = f"{<b>order</b>['notes']} {<b>order</b>['drink']}"
        print(f"Filling ceramic mug with {drink}.")
    case {'size': 'grande', 'serve': 'to go'}:
        drink = f"{<b>order</b>['notes']} {<b>order</b>['drink']}"
        print(f"Filling large paper cup with {drink}.")
    case {'size': 'venti', 'serve': 'for here'}:
        drink = f"{<b>order</b>['notes']} {<b>order</b>['drink']}"
        print(f"Filling extra large tumbler with {drink}.")</code></pre>
<p class="CodeListingCaption"><a id="listing9-50">Listing 9-50</a>: <em>match_coffee_dictionary.py:1c</em></p>
<p>As before, any keys omitted from each mapping pattern are ignored for purposes of pattern matching.</p>
<h2 id="h1-500920c09-0005"><span epub:type="pagebreak" title="231" id="Page_231"/>Accessing by Index or Key</h2>
<p class="BodyFirst">Many collections are <em>subscriptable</em>, meaning individual items can be accessed via an index specified in square brackets. You’ve already seen this with lists:</p>
<pre><code>specials = ["pumpkin spice latte", "caramel macchiato", "mocha cappuccino"]
print(specials[1])  # prints "caramel macchiato"
specials[1] = "drip"
print(specials[1])  # prints "drip"</code></pre>
<p class="CodeListingCaption"><a id="listing9-51">Listing 9-51</a>: <em>subscript_specials.py:1a</em></p>
<p>Subscriptable collection classes implement the special methods <code>__getitem__()</code>, <code>__setitem__()</code>, and <code>__delitem__()</code>, where each accepts a single-integer argument. You can see this in action by using the special methods directly, instead of the square-bracket notation from a moment ago. This code is functionally identical to the above:</p>
<pre><code>specials = ["pumpkin spice latte", "caramel macchiato", "mocha cappuccino"]
print(<b>specials.__getitem__(1)</b>)  # prints "caramel macchiato"
<b>specials.__setitem__(1, "drip")</b>
print(<b>specials.__getitem__(1)</b>)  # prints "drip"</code></pre>
<p class="CodeListingCaption"><a id="listing9-52">Listing 9-52</a>: <em>subscript_specials.py:1b</em></p>
<p>These same special methods are implemented by the <code>dict</code> class, except that they accept a <em>key</em> as the sole argument. Because dictionaries don’t have a formal “index,” they are not considered subscriptable collections.</p>
<h2 id="h1-500920c09-0006">Slice Notation</h2>
<p class="BodyFirst"><em>Slice notation</em> allows you to access specific items or ranges of items in a list or tuple. Of the five fundamental types of collections, only <code>tuple</code> and <code>list</code> can be sliced. Neither <code>set</code> nor <code>dict</code> is subscriptable, so slice notation won’t work on them. While <code>deque</code> is subscriptable, it cannot be sliced using slice notation, because of how it is implemented.</p>
<p>To take a <em>slice</em> of a list or tuple, you use square brackets around the slice notation, which generally consists of three parts, separated by colons:</p>
<pre><code>[<var>start</var>:<var>stop</var>:<var>step</var>]</code></pre>
<p>The <em>inclusive</em> index of the first item you want to include in the slice is <var>start</var>. The <em>exclusive</em> index, <var>stop</var>, is <em>just past</em> where the slice stops. The <var>step</var> part allows you to skip over items and even reverse the order.</p>
<p>You aren’t required to specify all three arguments, but be mindful of the colons. If you want a slice, as opposed to a single element accessed by index, you must <em>always</em> include the colon separating <var>start</var> and <var>stop</var>, even if you don’t specify one or the other: (<code>[</code><var>start</var><code>:</code><var>stop</var><code>]</code>, <code>[</code><var>start</var><code>:]</code>, <code>[:</code><var>stop</var><code>]</code>).</p>
<p>Similarly, if you define <var>step</var>, you must precede it with its own colon: (<code>[:</code><var>stop</var><code>:</code><var>step</var><code>]</code>, <code>[::</code><var>step</var><code>]</code>, <code>[</code><var>start</var><code>::</code><var>step</var><code>]</code>).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2><span epub:type="pagebreak" title="232" id="Page_232"/>GOTCHA Alert</h2>	<p class="BoxBodyFirst">Slice notation never returns an <code>IndexError</code>! If the notation is invalid for the list or tuple in question, or if it is otherwise ill-formed, it will return an empty list <code>[]</code>. You should always test your slice notation before relying on it.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>That’s rather theoretical, so here are some practical examples, using a list of coffee orders:</p>
<pre><code>orders = [
    "caramel macchiato",
    "drip",
    "pumpkin spice latte",
    "drip",
    "cappuccino",
    "americano",
    "mocha latte",
]</code></pre>
<p class="CodeListingCaption"><a id="listing9-53">Listing 9-53</a>: <em>slice_orders.py:1</em></p>
<h3 id="h2-500920c09-0014">Start and Stop</h3>
<p class="BodyFirst">By specifying the start and stop for a slice, I can specify a range:</p>
<pre><code>three_four_five = orders[3:6]
print(three_four_five)  # prints ['drip', 'cappuccino', 'americano']</code></pre>
<p class="CodeListingCaption"><a id="listing9-54">Listing 9-54</a>: <em>slice_orders.py:2</em></p>
<p>The slice starts at index <code>3</code> and ends just before <code>6</code>, so it includes the items at indices <code>3</code>, <code>4</code>, and <code>5</code>. <code/></p>
<p>One important rule: <var>start</var> must always refer to an item that comes before <var>stop</var>. By default, lists are traversed first to last, so the <var>start</var> must be less than <var>stop</var>.</p>
<p>A slice doesn’t require all three arguments. If you leave out <var>start</var>, the slice begins at the first element. If you leave off <var>stop</var>, the slice finishes with the final element.</p>
<p>If I wanted all the items in the list except the first four, I’d use this:</p>
<pre><code>after_third = orders[4:]
print(after_third)  # print ['cappuccino', 'americano', 'mocha latte']</code></pre>
<p class="CodeListingCaption"><a id="listing9-55">Listing 9-55</a>: <em>slice_orders.py:3</em></p>
<p>I start at index <code>4</code>. Then, since I didn’t specify a <var>stop </var>after the required colon, the slice includes the rest of the items up to the very end of the list.</p>
<p>I can access the first two items in the list this way:</p>
<pre><code>next_two = orders[:2]
print(next_two)  # prints ['caramel macchiato', 'drip']</code></pre>
<p class="CodeListingCaption"><a id="listing9-56">Listing 9-56</a>: <em>slice_orders.py:4</em></p>
<p><span epub:type="pagebreak" title="233" id="Page_233"/>I didn’t specify a start before the colon, so it defaults to the beginning of the list. The end, which is <em>exclusive</em>, is <code>2</code>, so the slice includes all items before index <code>2</code>. This gives me the first two items in the list.</p>
<h3 id="h2-500920c09-0015">Negative Indices</h3>
<p class="BodyFirst">I can also use negative numbers as indices, which enable me to count backward from the end of the list or tuple. For example, an index of <code>-1</code> refers to the last item in the list:</p>
<pre><code>print(orders[-1])  # prints 'mocha latte'</code></pre>
<p class="CodeListingCaption"><a id="listing9-57">Listing 9-57</a>: <em>slice_orders.py:5</em></p>
<p>Negative indices work with slicing, too. For example, if I wanted to get the three orders at the end of the list, I could use this:</p>
<pre><code>last_three = orders[-3:]
print(last_three)  # prints ['cappuccino', 'americano', 'mocha latte']</code></pre>
<p class="CodeListingCaption"><a id="listing9-58">Listing 9-58</a>: <em>slice_orders.py:6</em></p>
<p>The slice starts at the third index from the end (<code>-3</code>) and goes to the end. When determining negative indices, remember that <code>-1</code> is the last item—that is, it’s one index before the “end,” which <em>has</em> no index.</p>
<p>If I wanted the third-from-last and second-from-last orders, but not the last order, I could define both <var>start</var> and <var>stop</var> as negative indices:</p>
<pre><code>last_two_but_one = orders[-3:-1]
print(last_two_but_one)  # prints ['cappuccino', 'americano']</code></pre>
<p class="CodeListingCaption"><a id="listing9-59">Listing 9-59</a>: <em>slice_orders.py:7</em></p>
<p>Remember, the <var>start</var> index must always come before the <var>stop</var>, and lists are traversed from left to right, by default. Thus, the <var>start</var> must be <code>-3</code>, or third-from-end, and the <var>stop </var>must be <code>-1</code>; so the last included index is <code>-2</code>, or second-from-end.</p>
<h3 id="h2-500920c09-0016">Steps</h3>
<p class="BodyFirst">By default, lists are traversed first to last, from the lowest index to the highest, one by one. The third part of the slice notation, <var>step</var>, lets you change that behavior so you can better control which values are included in the slice, and in what order.</p>
<p>For example, I could create a slice containing every other coffee order, starting from the second order, by setting the <var>step</var> part to <code>2</code>:</p>
<pre><code>every_other = orders[1::2]
print(every_other)  # prints ['drip', 'drip', 'americano']</code></pre>
<p class="CodeListingCaption"><a id="listing9-60">Listing 9-60</a>: <em>slice_orders.py:8</em></p>
<p><span epub:type="pagebreak" title="234" id="Page_234"/>I <var>start</var> the slice at index <code>1</code>. Since I haven’t specified a <var>stop</var> index, the slice goes to the end of the list. The <var>step</var> argument of <code>2</code> tells Python to grab every second item. With the <code>orders</code> list, that means the slice will consist of the items at indices <code>1</code>, <code>3</code>, and <code>5</code>.</p>
<p>A negative <var>step</var> argument reverses the direction the list or tuple is read in. For example, a <var>step</var> of <code>-1</code>, with no <var>start</var> or <var>stop</var>, will return a reversed version of the entire <code>orders</code> list:</p>
<pre><code>reverse = orders[::-1]</code></pre>
<p class="CodeListingCaption"><a id="listing9-61">Listing 9-61</a>: <em>slice_orders.py:9</em></p>
<p>You’ll notice I had to precede the <code>-1</code> with two colons, to delineate that no values had been specified for <var>start</var> or <var>stop</var>. Otherwise, Python would have no way to know that the <code>-1</code> was for the third argument.</p>
<p>I can even get a reversed version of the data sliced in <a href="#listing9-60" id="listinganchor9-60">Listing 9-60</a>, although there’s a bit of a trick to it. Here’s the code:</p>
<pre><code>every_other_reverse = orders[-2::-2]
print(every_other_reverse)  # prints ['americano', 'drip', 'drip']</code></pre>
<p class="CodeListingCaption"><a id="listing9-62">Listing 9-62</a>: <em>slice_orders.py:10</em></p>
<p>The <var>step</var> of <code>-2</code> means the slice grabs every other value in reverse order. The list is traversed from right to left. That changes the behavior of <var>start</var> and <var>stop</var>. I <var>start</var> at the second-to-last item (<code>-2</code>), but because I omitted a value for <var>stop</var>, it defaults to the beginning of the list, instead of the end. If I left off both <var>start</var> and <var>stop</var>, I’d get every other value in reverse, starting from the last item.</p>
<p>This reversed behavior radically affects what values are used for <var>start</var> and <var>stop</var>, and this misunderstanding can easily result in bugs. For example, if I want the third, fourth, and fifth items in reverse order, my first attempt might look like the following, which would <em>not</em> work:</p>
<pre><code>three_to_five_reverse = orders[3:6:-1]  # WRONG! Returns empty list.
print(three_to_five_reverse)            # prints []</code></pre>
<p class="CodeListingCaption"><a id="listing9-63">Listing 9-63</a>: <em>slice_orders.py:11a</em></p>
<p>The negative <var>step</var> value means I’m traversing the list in reverse order. Remember that <var>start</var> must always be traversed before <var>stop</var>.</p>
<p>If I traverse the list from ending to beginning, then I have to reverse the <var>start</var> and <var>stop</var> values, like so:</p>
<pre><code>three_to_five_reverse = orders[<b>5:2</b>:-1]
print(three_to_five_reverse)  # prints ['americano', 'cappuccino', 'drip']</code></pre>
<p class="CodeListingCaption"><a id="listing9-64">Listing 9-64</a>: <em>slice_orders.py:11b</em></p>
<p><span epub:type="pagebreak" title="235" id="Page_235"/>Moving backward through the list, the slice starts at index <code>5</code> and stops at index <code>2</code>, which is not included.</p>
<h3 id="h2-500920c09-0017">Copy with Slice</h3>
<p class="BodyFirst">One more thing to know about slices is that they always return a new list or tuple with the selected items; the original list or tuple still exists as it was. This code creates a perfect shallow copy of the list:</p>
<pre><code>order_copy = orders[:]</code></pre>
<p class="CodeListingCaption"><a id="listing9-65">Listing 9-65</a>: <em>slice_orders.py:12</em></p>
<p>Since neither <var>start</var> nor <var>stop</var> is specified, the slice includes all items.</p>
<h3 id="h2-500920c09-0018">Slice Objects</h3>
<p class="BodyFirst">You can also directly create a <code>slice</code> object for reuse by using the <code>slice()</code> initializer method.</p>
<pre><code>my_slice = slice(3, 5, 2)  # same as [3:5:2]
print(my_slice)</code></pre>
<p>The <var>start</var>, <var>stop</var>, and (optionally) <var>step</var> values are passed as positional arguments. In practice, this approach is more limited than regular slice notation, since it is not possible to omit the <var>stop</var> value.</p>
<p>In any case, I can now use <code>my_slice</code> in place of slice notation, such as in the <code>print()</code> statement above.</p>
<h3 id="h2-500920c09-0019">Slicing on Custom Objects</h3>
<p class="BodyFirst">If you want to implement slicing in your own objects, you’ll only need to accept a slice object as an argument on the same special methods needed to make the object subscriptable: <code>__getitem__(self, sliced)</code>, <code>__setitem__(self, sliced)</code>, and <code>__delitem__(self, sliced)</code>. Then, you can get the three parts of the slice object with <code>sliced.start</code>, <code>sliced.stop</code>, and <code>sliced.step</code>.</p>
<p>A decent example for this would be pretty involved, so I’ll leave this explanation here.</p>
<h3 id="h2-500920c09-0020">Using islice</h3>
<p class="BodyFirst">You can still slice a deque or any collection that isn’t subscriptable by using <code>itertools.islice()</code>, which behaves the same as slice notation, except that it doesn’t support negative values for any of the parameters.</p>
<p>The arguments that <code>islice()</code> accepts are ordered, so you have to remember the order:</p>
<pre><code>islice(<var>collection</var>, <var>start</var>, <var>stop</var>, <var>step</var>)</code></pre>
<p><span epub:type="pagebreak" title="236" id="Page_236"/>For example, <code>islice()</code> can take a slice from a dictionary, which cannot be sliced by ordinary slice notation because it isn’t subscriptable. Here, I get every other item from the dictionary:</p>
<pre><code>from itertools import islice

menu = {'drip': 1.95, 'cappuccino': 2.95, 'americano': 2.49}

menu = dict(islice( <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> menu.items(), 0, 3, 2))  # same as [0:3:2]
print(menu)</code></pre>
<p class="CodeListingCaption"><a id="listing9-66">Listing 9-66</a>: <em>islice_orders.py</em></p>
<p>I pass the dictionary as a list of tuples to the <code>islice</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, followed by the <var>start</var>, <var>stop</var>, and <var>step</var> values necessary to take every other item. Then, I create a new dictionary from the <code>islice</code> and bind it to <code>menu</code>. Running that code produces the following output:</p>
<pre><code>{'drip': 1.95, 'americano': 2.49}</code></pre>
<h2 id="h1-500920c09-0007">The in Operator</h2>
<p class="BodyFirst">You can use the <code>in</code> operator to quickly check whether a particular value is contained in any collection.</p>
<p>As before, I’ll start with a list of orders:</p>
<pre><code>orders = [
    "caramel macchiato",
    "drip",
    "pumpkin spice latte",
    "drip",
    "cappuccino",
    "americano",
    "mocha cappuccino",
]</code></pre>
<p class="CodeListingCaption"><a id="listing9-67">Listing 9-67</a>: <em>in_orders.py:1</em></p>
<p>For example, I might need to see if anyone wants a mocha cappuccino in my <code>orders</code> list before I open the new bottle of chocolate syrup:</p>
<pre><code>if "mocha cappuccino" in orders:
    print("open chocolate syrup bottle")</code></pre>
<p class="CodeListingCaption"><a id="listing9-68">Listing 9-68</a>: <em>in_orders.py:2</em></p>
<p>I place the value I’m looking for to the left of the <code>in</code> operator and the collection I’m searching to the right. The operator returns <code>True</code> if at least one instance of the value is found in the collection; otherwise, it returns <code>False</code>.</p>
<p><span epub:type="pagebreak" title="237" id="Page_237"/>You can also check whether a list omits a specific item. For example, I might decide to shut off the coffee maker if no one wants any drip coffee right now. I can check if there are any orders for <code>"drip"</code> with this code:</p>
<pre><code>if "drip" not in orders:
    print("shut off percolator")</code></pre>
<p class="CodeListingCaption"><a id="listing9-69">Listing 9-69</a>: <em>in_orders.py:3</em></p>
<p>The addition of <code>not</code> inverts the <code>in</code> condition, so the expression evaluates to <code>True</code> if the value is <em>not</em> found in the collection.</p>
<p>You can add support for the <code>in</code> operator to your custom classes by implementing the special method <code>__contains__()</code>.</p>
<h2 id="h1-500920c09-0008">Checking Collection Length</h2>
<p class="BodyFirst">To find out how many items a collection contains, use the <code>len()</code> function. That’s all there is to it. For example, if I have a list of waiting customers, I can find out how many customers are standing in line:</p>
<pre><code>customers = ['Glen', 'Todd', 'Newman']
print(len(customers))  # prints 3</code></pre>
<p class="CodeListingCaption"><a id="listing9-70">Listing 9-70</a>: <em>len_customers.py</em></p>
<p>The <code>len()</code> function returns the number of items in <code>customers</code> as an integer. Since there are three items in <code>customers</code>, the value <code>3</code> is returned. In the case of a dictionary, <code>len()</code> would return the number of key-value pairs.</p>
<p>You’ll use <code>len()</code> less than you might expect when you employ iteration, which changes the way you traverse through collections such that you seldom need to know the length.</p>
<p>You don’t even need <code>len()</code> when testing whether a collection is empty. If a collection contains content, it is “truthy,” meaning it can be evaluated directly to <code>True</code>. Otherwise, if the collection is empty, it is “falsey,” meaning it evaluates directly to <code>False</code>. I’ll use this to see if there are any customers in the café right now.</p>
<pre><code>customers = []

if <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> customers:  # if not empty...
    print("There are customers.")
else:
    print("Quiet day.")

print(bool(customers))</code></pre>
<p class="CodeListingCaption"><a id="listing9-71">Listing 9-71</a>: <em>no_customers.py</em></p>
<p><span epub:type="pagebreak" title="238" id="Page_238"/>Because <code>customers</code> is empty, it is “falsey,” meaning it evaluates to <code>False</code> in a boolean context, such as when used as an expression <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Therefore, when the above program is run, the following is displayed:</p>
<pre><code>Quiet day.
False</code></pre>
<p>Sure enough, if I directly cast <code>customers</code> to a boolean value, it prints <code>False</code>.</p>
<p>Usually, the only time you’ll use <code>len()</code> is when you need the length of a collection as a piece of data in its own right, such as when calculating the average number of orders per day for the week:</p>
<pre><code>orders_per_day = [56, 41, 49, 22, 71, 43, 18]
average_orders = sum(orders_per_day) // len(orders_per_day)
print(average_orders)</code></pre>
<p class="CodeListingCaption"><a id="listing9-72">Listing 9-72</a>: <em>average_orders.py</em></p>
<p>The <code>average_orders</code> is printed to the screen:</p>
<pre><code>42</code></pre>
<h2 id="h1-500920c09-0009">Iteration</h2>
<p class="BodyFirst">All collections in Python are designed to work with <em>iteration</em>, by which you can directly access items on demand, one by one. Iteration patterns aren’t even limited to collections. You can leverage this concept to generate or process data <em>iteratively</em>: “on demand,” instead of all up front. You’ll see this in depth in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>.</p>
<p>Before you can start using iteration effectively, you must understand how it actually works. Then, you can use it to access, sort, and process items in collections.</p>
<h3 id="h2-500920c09-0021">Iterables and Iterators</h3>
<p class="BodyFirst">One of the most compelling features of Python is its approach to iteration, by way of two fairly straightforward concepts: <em>iterables</em> and <em>iterators</em>.</p>
<p>An <em>iterable</em> is any object whose items or values can be accessed one at a time, on demand. For example, a list is an iterable; you can iterate over each item in the list, one by one. For an object to be iterable, it must have an associated iterator, which is returned from the object’s instance method <code>__iter__()</code>.</p>
<p>An <em>iterator</em> is the object that performs the actual iteration, providing ready access to the next item in the iterable it is traversing. To be an iterable, an object needs to implement the special method <code>__next__()</code>, which accepts no parameters and returns a value. This method advances to the next item in the iterable it traverses and returns that value.</p>
<p><span epub:type="pagebreak" title="239" id="Page_239"/>Iterators must also implement the method <code>__iter__()</code>, which returns the iterator object itself (usually <code>self</code>). This convention is necessary so that code that accepts an iterable can also accept an iterator without any difficulty, as you’ll see shortly.</p>
<p>That’s really all there is to it! All collections are iterables, and each has at least one dedicated companion iterator class.</p>
<p>I’ll implement a custom iterator class later in this chapter.</p>
<h3 id="h2-500920c09-0022">Manually Using Iterators</h3>
<p class="BodyFirst">Before introducing automatic iteration, it’s helpful to understand what is going on behind the scenes when using an iterator.</p>
<p>To demonstrate this, I’ll traverse the values in a list, using an iterator I manually access and control. I’ll go through this example twice: once, directly calling the special methods; and another time, allowing Python to call them implicitly.</p>
<p>I’ll start by defining a list, which is an iterable:</p>
<pre><code>specials = ["pumpkin spice latte", "caramel macchiato", "mocha cappuccino"]</code></pre>
<p class="CodeListingCaption"><a id="listing9-73">Listing 9-73</a>: <em>specials_iteration.py:1</em></p>
<p>To iterate over the collection, I first acquire an iterator:</p>
<pre><code>first_iterator = specials.__iter__()
second_iterator = specials.__iter__()
print(type(first_iterator))</code></pre>
<p class="CodeListingCaption"><a id="listing9-74">Listing 9-74</a>: <em>specials_iteration.py:2</em></p>
<p>A list, like all iterables, implements the special method <code>__iter__()</code>, which returns an iterator object for this list. I acquire two separate iterators here, each of which can operate independently of the other.</p>
<p>When I check the data type of <code>first_iterator</code>, I see it’s an instance of the class <code>list_iterator</code>, as seen in the output:</p>
<pre><code>&lt;class 'list_iterator'&gt;</code></pre>
<p>I use the iterator object to access the items in the list <code>specials</code>:</p>
<pre><code>item = first_iterator.__next__()
print(item)</code></pre>
<p class="CodeListingCaption"><a id="listing9-75">Listing 9-75</a>: <em>specials_iteration.py:3</em></p>
<p>The first call to the iterator’s <code>__next__()</code> method advances to the first item in the list and returns its value, which I bind to <code>item</code> and print to the screen, outputting the following:</p>
<pre><code>pumpkin spice latte</code></pre>
<p><span epub:type="pagebreak" title="240" id="Page_240"/>A subsequent call advances to and returns the second item:</p>
<pre><code>item = first_iterator.__next__()
print(item)</code></pre>
<p class="CodeListingCaption"><a id="listing9-76">Listing 9-76</a>: <em>specials_iteration.py:4</em></p>
<p>That outputs the following:</p>
<pre><code>caramel macchiato</code></pre>
<p>Each iterator tracks its position in the iterable separately. If I call the <code>__next__()</code> method on <code>second_iterator</code>, it advances to and returns the first item in the list:</p>
<pre><code>item = second_iterator.__next__()
print(item)</code></pre>
<p class="CodeListingCaption"><a id="listing9-77">Listing 9-77</a>: <em>manual_iteration.py:5</em></p>
<p>Printing <code>item</code> shows the first item in the list:</p>
<pre><code>pumpkin spice latte</code></pre>
<p>Yet <code>first_iterator</code> still remembers its own position and can be advanced to the third item in the list:</p>
<pre><code>item = first_iterator.__next__()
print(item)</code></pre>
<p class="CodeListingCaption"><a id="listing9-78">Listing 9-78</a>: <em>specials_iteration.py:6</em></p>
<p>That prints the value of the third item:</p>
<pre><code>mocha cappuccino</code></pre>
<p>Once an iterator has run through all the items in the iterable being traversed, calling <code>__next__()</code> again raises the special exception <code>StopIteration</code>:</p>
<pre><code>item = first_iterator.__next__()  # raises StopIteration</code></pre>
<p class="CodeListingCaption"><a id="listing9-79">Listing 9-79</a>: <em>specials_iteration.py:7</em></p>
<p>Thankfully, I don’t need to call <code>__iter__()</code> and <code>__next__()</code> manually, in any case. Instead, I can use Python’s built-in functions <code>iter()</code> and <code>next()</code> and pass in the iterable or iterator, respectively. The special methods will be invoked behind the scenes.</p>
<p>Here’s that same example again, but now using those built-in functions:</p>
<pre><code>first_iterator = <b>iter(specials)</b>
second_iterator = <b>iter(specials)</b>
print(type(first_iterator))  # prints &lt;class 'list_iterator'&gt;

<span epub:type="pagebreak" title="241" id="Page_241"/>item = <b>next(first_iterator)</b>
print(item)                  # prints "pumpkin spice latte"

item = <b>next(first_iterator)</b>
print(item)                  # prints "caramel macchiato"

item = <b>next(second_iterator)</b>
print(item)                  # prints "pumpkin spice latte"

item = <b>next(first_iterator)</b>
print(item)                  # prints "mocha cappuccino"

item = <b>next(first_iterator)</b>  # raises StopIteration</code></pre>
<p class="CodeListingCaption"><a id="listing9-80">Listing 9-80</a>: <em>specials_iteration.py:2b-7b</em></p>
<p>As you can see, there’s a lot of repetition in this manual approach, which suggests that I could use a loop to handle iteration. In fact, using a <code>for</code> loop is the standard way to work with iteration, as it calls <code>iter()</code> and <code>next()</code> implicitly, so I don’t have to. However, to drive the underlying mechanics home first, I’ll wrap this same manual iteration logic in a <code>while</code> loop:</p>
<pre><code>specials = ["pumpkin spice latte", "caramel macchiato", "mocha cappuccino"]
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> iterator = iter(specials)

while True:
    try:
        item = <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> next(iterator)
  <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> except StopIteration:
        break
    else:
        print(item)</code></pre>
<p class="CodeListingCaption"><a id="listing9-81">Listing 9-81</a>: <em>specials_iteration_v2.py</em></p>
<p>I first acquire an iterator for the <code>specials</code> list <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, in an infinite <code>while</code> loop, I try to access the next value in the iterable by passing the iterator to <code>next()</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If this raises the <code>StopIteration</code> exception <span class="CodeAnnotation" aria-label="annotation3">❸</span>, I know I’ve traversed all the items in the <code>specials</code> list, and I break out of the loop with the <code>break</code> keyword. Otherwise, I print out the <code>item</code> I receive from the iterator.</p>
<p>Although it’s helpful to understand how to manually handle iterators, you will seldom need to! A <code>for</code> loop would almost always handle the example in <a href="#listing9-81" id="listinganchor9-81">Listing 9-81</a>:</p>
<pre><code>specials = ["pumpkin spice latte", "caramel macchiato", "mocha cappuccino"]

for item in specials:
    print(item)</code></pre>
<p class="CodeListingCaption"><a id="listing9-82">Listing 9-82</a>: <em>specials_iteration_v3.py</em></p>
<p>This eliminates the need to directly acquire an iterator. I’ll cover this approach next.</p>
<h3 id="h2-500920c09-0023"><span epub:type="pagebreak" title="242" id="Page_242"/>Iterating with for Loops</h3>
<p class="BodyFirst">One very helpful rule for loops and iteration in Python is that <em>you never need a counter variable for loop control</em>. In other words, virtually none of the traditional loop algorithms you’re used to apply here! Python always has a better way, mainly because iterables can directly control <code>for</code> loops.</p>
<p>Take another look at that queue of people at the Uncomment Café. For each person in line, the barista would take an order, make it, and deliver it. Here’s how I would do that. (For expediency of example, this code merely announces that each order is ready.)</p>
<pre><code>customers = ['Newman', 'Daniel', 'Simon', 'James', 'William',
             'Kyle', 'Jason', 'Devin', 'Todd', 'Glen', 'Denis']

for customer in customers:
    # Take order
    # Make drink
    print(f"Order for { <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> customer}!")</code></pre>
<p class="CodeListingCaption"><a id="listing9-83">Listing 9-83</a>: <em>iterate_orders_list.py</em></p>
<p>I loop through the <code>customers</code> list, which is an iterable. On each iteration, I bind each current item to <code>customer</code> so it works in the suite of the loop like any other variable <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<p>For each item in the list, I print a string announcing the order for the <code>customer</code> for that iteration. Here’s the output of that code (truncated):</p>
<pre><code>Order for Newman!
Order for Daniel!
Order for Simon!
<var># --snip--</var></code></pre>
<p>A linear collection is pretty straightforward (no pun intended). Iterables with multiple values in any given item, such as from the <code>items()</code> dictionary view or from a two-dimensional list, must be treated differently.</p>
<p>To demonstrate this, I’ll rewrite <code>customers</code> as a list of tuples, with each tuple containing a name and a coffee order. Then, I’ll loop through them to announce their order:</p>
<pre><code>customers = [
    ('Newman', 'tea'),
    ('Daniel', 'lemongrass tea'),
    ('Simon', 'chai latte'),
    ('James', 'medium roast drip, milk, 2 sugar substitutes'),
    ('William', 'french press'),
    ('Kyle', 'mocha cappuccino'),
    ('Jason', 'pumpkin spice latte'),
    ('Devin', 'double-shot espresso'),
    ('Todd', 'dark roast drip'),
    ('Glen', 'americano, no sugar, heavy cream'),
    ('Denis', 'cold brew')
]

<span epub:type="pagebreak" title="243" id="Page_243"/>for <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> customer, drink in customers:
    print(f"Making {drink}...")
    print(f"Order for {customer}!")</code></pre>
<p class="CodeListingCaption"><a id="listing9-84">Listing 9-84</a>: <em>iterate_orders_dict.py:1</em></p>
<p>In the <code>for</code> loop, I iterate over the list <code>customers</code>. On the left, I unpack each tuple item on the list into two names: <code>customer</code> and <code>drink</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<p>Here’s the resulting output:</p>
<pre><code>Making tea...
Order for Newman!
Making lemongrass tea...
Order for Daniel!
Making chai latte...
Order for Simon!
<var># --snip--</var></code></pre>
<h3 id="h2-500920c09-0024">Sorting Collections in Loops</h3>
<p class="BodyFirst">Loops also allow you to do more advanced processing of this data. For example, let’s say everyone could submit their orders through an app. (We are programmers, after all.)</p>
<p>I might want to sort the list of orders alphabetically, so I can search through them more easily. However, I still want to follow a first-come, first-served rule. Therefore, I don’t want to modify the original <code>customers</code> list, since its sequence still matters:</p>
<pre><code>for _, drink in <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> sorted(customers, <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> key=lambda x: <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> x[1]):
    print(f"{drink}")</code></pre>
<p class="CodeListingCaption"><a id="listing9-85">Listing 9-85</a>: <em>iterate_orders_dict.py:2</em></p>
<p>The <code>sorted()</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span> function returns a list of the sorted items from whatever collection is passed to it. By default, it will sort by the first value in an item, in ascending order. In this case, the first item is the customer name, but I want to sort by the name of the drink ordered instead. I change this behavior by passing a callable <em>key function</em> to the <code>key=</code> named argument <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This callable, a <code>lambda</code> in this case, must accept an item as an argument and return the value I want to sort that item by. In this case, I want to sort by the second item in each tuple, which I return via <code>x[1]</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Through all of this, <code>customers</code> remains unchanged.</p>
<p>You’ll also notice that I use the underscore in the unpacking list to ignore the first value in each tuple, the customer name, because I don’t need it in this loop. This is usually the best way to pick and choose items from a small tuple in a <code>for</code> loop. On the other hand, if each item were a collection with many subitems, it might work better to bind the entire item to one name and access what I need from it in the suite of the loop.</p>
<p><span epub:type="pagebreak" title="244" id="Page_244"/>Running that code, I get this output for this part:</p>
<pre><code>americano, no sugar, heavy cream
chai latte
cold brew
<var># --snip--</var></code></pre>
<h3 id="h2-500920c09-0025">Enumerating Loops</h3>
<p class="BodyFirst">You never need a counter variable for loop control. This will come as a major paradigm shift to many developers, who are used to C-style loop control. You may wonder what to do if you need the index itself.</p>
<p>Python offers <code>enumerate()</code> for such situations. The added benefit of using this function instead of manual indices is that it works with all iterables, even those that aren’t subscriptable.</p>
<p>I’ll use <code>enumerate()</code> to see the order of each person in line, along with their order:</p>
<pre><code>for number, <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> (customer, drink) in enumerate(customers, start=1):
    print(f"#{number}. {customer}: {drink}")</code></pre>
<p class="CodeListingCaption"><a id="listing9-86">Listing 9-86</a>: <em>iterate_orders_dict.py:3</em></p>
<p>Here, <code>enumerate()</code> returns a tuple with the count (which is sometimes, coincidentally, the index) as an integer in the first position and the item from the collection in the second. By default, the count would start at 0, but I want the first person in line to be displayed as “<code>#1</code>”—so I override this default by passing <code>1</code> to <code>start=</code>.</p>
<p>Since my collection consists of tuples, I have to use compound unpacking with parentheses to get each item from within the tuple item <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Once I have the number, the customer name, and the drink, I compose those pieces together into a single <code>print</code> statement.</p>
<p>The output of this part of the code looks like this:</p>
<pre><code>#1. Newman: tea
#2. Daniel: lemongrass tea
#3. Simon: chai latte
<var># --snip--</var></code></pre>
<h3 id="h2-500920c09-0026">Mutation in Loops</h3>
<p class="BodyFirst">You’ll notice that I’ve been using a <code>list</code> for my queue of customers, whereas before, I used a <code>deque</code> and removed customers from the queue after serving them. This is preferable, so I’ll start by defining the <code>customers</code> deque:</p>
<pre><code>from collections import deque

customers = deque([
<span epub:type="pagebreak" title="245" id="Page_245"/>    ('Newman', 'tea'),
    ('Daniel', 'lemongrass tea'),
    ('Simon', 'chai latte'),
    ('James', 'medium roast drip, milk, 2 sugar substitutes'),
    ('William', 'french press'),
    ('Kyle', 'mocha cappuccino'),
    ('Jason', 'pumpkin spice latte'),
    ('Devin', 'double-shot espresso'),
    ('Todd', 'dark roast drip'),
    ('Glen', 'americano, no sugar, heavy cream'),
    ('Denis', 'cold brew')
])</code></pre>
<p class="CodeListingCaption"><a id="listing9-87">Listing 9-87</a>: <em>process_orders.py:1</em></p>
<p>Combining the knowledge so far, you might think, “Aha! I only need to use a <code>deque</code> and <code>popleft()</code> after each customer.” Yet, if I try to follow that approach, it won’t run:</p>
<pre><code>for customer, drink in customers:
    print(f"Making {drink}...")
    print(f"Order for {customer}!")
    customers.popleft()  # RuntimeError</code></pre>
<p class="CodeListingCaption"><a id="listing9-88">Listing 9-88</a>: <em>process_orders.py:2a</em></p>
<p>The issue here is that I’m mutating the collection while I’m iterating over it! This can confuse the iterator, potentially causing all sorts of undefined behavior, so Python tries not to allow it. Attempting to mutate a collection while iterating over it, whether you’re adding, removing, or reordering items, usually raises a <code>RuntimeError</code>.</p>
<p>There are two ways to fix this problem. The first is to make a copy of the collection before iterating over it:</p>
<pre><code>for customer, drink in <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> customers<b>.copy()</b>:
    print(f"Making {drink}...")
    print(f"Order for {customer}!")
  <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> customers.popleft()

<b>print(customers)  # prints deque([])</b></code></pre>
<p class="CodeListingCaption"><a id="listing9-89">Listing 9-89</a>: <em>process_orders.py:2b</em></p>
<p>I had to use the <code>copy()</code> method, since deques don’t support the slice notation that would have allowed the snazzier colon in square brackets (<code>[:]</code>). Because the loop is iterating over a copy of the collection <span class="CodeAnnotation" aria-label="annotation1">❶</span>, I am free to mutate the original however I like <span class="CodeAnnotation" aria-label="annotation2">❷</span>, although this is seldom considered the ideal solution.</p>
<p>Since I want to remove items until the collection is emptied, I can use a <code>while</code> loop instead of a <code>for</code> loop:</p>
<pre><code><b>while customers:</b>
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> <b>customer, drink = </b><span class="CodeAnnotationCode" aria-label="annotation2">❷</span> <b>customers.popleft()</b>
<span epub:type="pagebreak" title="246" id="Page_246"/>    print(f"Making {drink}...")
    print(f"Order for {customer}!")</code></pre>
<p class="CodeListingCaption"><a id="listing9-90">Listing 9-90</a>: <em>process_orders.py:2c</em></p>
<p>The <code>while</code> loop iterates until the collection <code>customers</code> indicates it is empty by evaluating to <code>False</code>. On each iteration, I use <code>popleft()</code> to access the next item, since that both returns and removes the item from the collection <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Unpacking is done in the suite of the loop <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<p>On the other hand, if I wanted to expand or reorder the contents of a collection while iterating over it, I’d need to create a new collection.</p>
<p>To demonstrate this, here is a rather convoluted example. For every drink ordered, I want to create a second serving of the same drink later. (I’ll leave the purpose behind this to your imagination.) In my first attempt at this, I’ll do this the wrong way, which won’t work.</p>
<p>As usual, I start by defining my list:</p>
<pre><code>orders = ["pumpkin spice latte", "caramel macchiato", "mocha cappuccino"]</code></pre>
<p>Here, I’m attempting to add the same drink to the end of the list I’m iterating over:</p>
<pre><code>for order in orders:
    # ... do whatever ...
    orders.append(order)  # creates infinite loop!

print(orders)</code></pre>
<p class="CodeListingCaption"><a id="listing9-91">Listing 9-91</a>: <em>double_orders.py:2a</em></p>
<p>This example is particularly evil because, unlike the prior example, a <code>RuntimeError</code> is not raised when I attempt to mutate <code>orders</code> from within the suite of the loop. Instead, because there’s always a new item at the end of the list <code>orders</code>, the loop keeps running until the program runs out of memory and dies. Yuck.</p>
<p>To correct this, I need to create a new list for appending to:</p>
<pre><code><b>new_orders = orders[:]</b>
for order in orders:
    # ... do whatever ...
    <b>new_orders.</b>append(order)
<b>orders = new_orders</b>

print(orders)</code></pre>
<p class="CodeListingCaption"><a id="listing9-92">Listing 9-92</a>: <em>double_orders.py:2b</em></p>
<p>I define <code>new_orders</code> as a copy of <code>orders</code>, using slice notation to create the exact copy. Then, I iterate over <code>orders</code>, but I append to <code>new_orders</code>. Finally, when I’m done, I rebind <code>orders</code> to the new list, throwing the old list away.</p>
<h3 id="h2-500920c09-0027"><span epub:type="pagebreak" title="247" id="Page_247"/>Loop Nesting and Alternatives</h3>
<p class="BodyFirst">As you might expect, you can nest loops. One situation where I might use this would be when running a coffee-tasting event where I wanted each guest to taste each type of coffee. Here’s a program to tell me who to give what sample to.</p>
<p>I start by defining two lists: one of samples and the other of guests:</p>
<pre><code>samples = ['Costa Rica', 'Kenya', 'Vietnam', 'Brazil']
guests = ['Denis', 'William', 'Todd', 'Daniel', 'Glen']</code></pre>
<p class="CodeListingCaption"><a id="listing9-93">Listing 9-93</a>: <em>tasting_lists.py:1</em></p>
<p>Now I iterate over both lists at once:</p>
<pre><code>for sample in samples:
    for guest in guests:
        print(f"Give sample of {sample} coffee to {guest}.")</code></pre>
<p class="CodeListingCaption"><a id="listing9-94">Listing 9-94</a>: <em>tasting_lists.py:2a</em></p>
<p>The outer loop iterates over the list <code>samples</code>. For each item in <code>samples</code>, the inner loop iterates over the list of <code>guests</code>, giving each one a sample.</p>
<p>Running that code produces the following output (truncated for brevity):</p>
<pre><code>Give sample of Costa Rica coffee to Denis.
Give sample of Costa Rica coffee to William.
Give sample of Costa Rica coffee to Todd.
Give sample of Costa Rica coffee to Daniel.
Give sample of Costa Rica coffee to Glen.
Give sample of Kenya coffee to Denis.
Give sample of Kenya coffee to William.
<var># --snip--</var></code></pre>
<p>Using nested loops is seldom considered the best solution in Python, for a couple of reasons. First, nesting itself is something Python developers like to avoid, as suggested by The Zen of Python:</p>
<blockquote class="blockquote">
<p class="Blockquote">Flat is better than nested.</p>
</blockquote>
<p>Nested structures are less readable and more <em>brittle</em>, meaning they are easily mistyped, due to their reliance on multiple levels of indentation. Python developers conventionally like to avoid any unnecessary nesting. A readable solution that is <em>flatter</em> (with less nesting) will almost invariably be preferred.</p>
<p>Second, <em>it’s impossible to break out of nested loops</em>. The <code>continue</code> and <code>break</code> keywords can only control the loop they’re directly in, not any outer or inner loops thereof. There are some “clever” ways around this, like putting the nested loop in a function and breaking out of the function by using a <code>return</code> statement. However, these hacks add complexity, nesting layers, or both, and they are thus discouraged.</p>
<p><span epub:type="pagebreak" title="248" id="Page_248"/>Instead, anytime you’re thinking of using a nested loop, consider whether there are any viable alternatives. In the case of my example, I can achieve the same result as before in a single loop by using the <code>product()</code> function from the incredibly versatile <code>itertools</code> module (which I’ll introduce properly later):</p>
<pre><code><b>from itertools import product  # Put this line at top of module</b>

<b>for </b><span class="CodeAnnotationCode" aria-label="annotation1">❶</span> <b>sample, guest in </b><span class="CodeAnnotationCode" aria-label="annotation2">❷</span> <b>product(samples, guests):</b>
    print(f"Give sample of {sample} coffee to {guest}.")</code></pre>
<p class="CodeListingCaption"><a id="listing9-95">Listing 9-95</a>: <em>tasting_lists.py:2b</em></p>
<p>The <code>itertools.product()</code> function combines two or more iterables into a single iterable that contains tuples with every possible combination of items <span class="CodeAnnotation" aria-label="annotation2">❷</span>. I unpack each of these tuples into names I can use to access the individual values in the suite of the loop <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<p>The output is the exact same as before.</p>
<p>Between the built-in iteration functions and the <code>itertools</code> module, Python has functions to cover most common situations where nested loops might ordinarily be used. If nothing already exists to do what you want, you can always write your own iterable function (called a <em>generator</em>; see <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>) or an iterable class (see later in this chapter).</p>
<p>It may be impossible to avoid nested loops in most cases, but you’ll often find there is a cleaner, flatter solution.</p>
<h2 id="h1-500920c09-0010">Iteration Tools</h2>
<p class="BodyFirst">Python has a whole bevy of handy tools for iterating over containers. For most of these, the official documentation is your friend. I’ll skim through some of the most common and useful tools here.</p>
<h3 id="h2-500920c09-0028">Basic Built-in Tools</h3>
<p class="BodyFirst">A number of iteration tools are built into the language itself. Each of these requires you to pass at least a single iterable.</p>
<ul>
<li><code>all()</code> returns <code>True</code> if every item in the iterable evaluates to <code>True</code>.</li>
<li><code>any()</code> returns <code>True</code> if any item in the iterable evaluates to <code>True</code>.</li>
<li><code>enumerate()</code> (seen earlier) is an iterable that returns a tuple for each item in the iterable you pass to it. The first value in the tuple is the item’s “index,” and the second is the item value itself. This even works with iterables that aren’t subscriptable. This tool optionally accepts a <code>start=</code> argument, which defines the integer value to use as the first index.</li>
<li><code>max()</code> returns the largest item in the iterable. It optionally accepts a <code>key=</code> argument, which is usually a callable specifying what part of a collection item to sort on.</li>
<li><code>min()</code> is the same as <code>max()</code>, except that it returns the smallest item in the iterable.</li>
<li><span epub:type="pagebreak" title="249" id="Page_249"/><code>range()</code> is an iterable that returns a sequence of integers from an optional starting value (default <code>0</code>) to one less than an ending value. An optional third argument can define the step. The <code>range(3)</code> iterable produces the values <code>(0,1,2)</code>, while <code>range(2,5)</code> produces the values <code>(2,3,4)</code>, and <code>range(1,6,2)</code> produces the values <code>(1,3,5)</code>.</li>
<li><code>reversed()</code> returns an iterator that iterates through the iterable, backward.<br/>
<code>sorted()</code> returns a list containing all the items of the iterable, sorted. It optionally accepts a <code>key=</code> argument, which is used in the same way as on <code>max()</code>.</li>
<li><code>sum()</code> returns the sum of all the items in the iterable, so long as all the items are numeric values. It optionally accepts a <code>start=</code> argument, which is the initial value of the sum.</li>
</ul>
<p>The last three built-in iterables I’ll cover are more complicated, so I’ll detail each in the following subsections.</p>
<h3 id="h2-500920c09-0029">Filter</h3>
<p class="BodyFirst">The <code>filter</code> iterable allows you to search for values in an iterable that fit a particular criterion. Say I have a list of orders and I want to find out how many of them call for drip coffee:</p>
<pre><code>orders = ['cold brew', 'lemongrass tea', 'chai latte', 'medium drip',
          'french press', 'mocha cappuccino', 'pumpkin spice latte',
          'double-shot espresso', 'dark roast drip', 'americano']

drip_orders = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> list( <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> filter( <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> lambda s: 'drip' in s, <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> orders))

print(f'There are { <span class="CodeAnnotationCode" aria-label="annotation5">❺</span> len(drip_orders)} orders for drip coffee.')</code></pre>
<p class="CodeListingCaption"><a id="listing9-96">Listing 9-96</a>: <em>orders_filter.py</em></p>
<p>To create the <code>filter</code> instance, I call its initializer <span class="CodeAnnotation" aria-label="annotation2">❷</span> and pass two arguments: the callable to use for filtering <span class="CodeAnnotation" aria-label="annotation3">❸</span> and the iterable being filtered <span class="CodeAnnotation" aria-label="annotation4">❹</span>. I convert this <code>filter</code> iterable to a list <span class="CodeAnnotation" aria-label="annotation1">❶</span> before assigning that list to <code>drip_orders</code>.</p>
<p>Remember, the callable you use for filtering can be a function, a lambda, or anything else that can be treated as a function. Whatever the callable is, it should return a value that can be evaluated to a boolean, indicating whether the value passed to it should be included in the end result. In this case, that filtering callable will be a lambda, which returns <code>True</code> if the string <code>'drip'</code> is anywhere in the value passed to it <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Because the logic is simple, the lambda makes sense, but if I had wanted more complicated test logic, I would have written a proper function instead. The <code>filter</code> iterable will contain those items that pass the test specified by the lambda.</p>
<p>Finally, I print out the number of items in <code>drip_orders</code> <span class="CodeAnnotation" aria-label="annotation5">❺</span>, which is the number of items that <code>filter</code> extracted from <code>orders</code>.</p>
<p>It just goes to show, you can even make a coffee filter with Python!</p>
<h3 id="h2-500920c09-0030"><span epub:type="pagebreak" title="250" id="Page_250"/>Map</h3>
<p class="BodyFirst">The <code>map</code> iterable will pass every item in an iterable to a callable as an argument. Then, it will pass the returned value back as its own current iterative value.</p>
<p>In my café, I can define a function for brewing and then use <code>map()</code> to apply that function to each of the pending orders.</p>
<p>I’ll start by defining my orders list:</p>
<pre><code>orders = ['cold brew', 'lemongrass tea', 'chai latte', 'medium drip',
          'french press', 'mocha cappuccino', 'pumpkin spice latte',
          'double-shot espresso', 'dark roast drip', 'americano']</code></pre>
<p class="CodeListingCaption"><a id="listing9-97">Listing 9-97</a>: <em>brew_map.py:1</em></p>
<p>I’ll also define a function to handle brewing:</p>
<pre><code>def brew(order):
    print(f"Making {order}...")
    return order</code></pre>
<p class="CodeListingCaption"><a id="listing9-98">Listing 9-98</a>: <em>brew_map.py:2</em></p>
<p>This function accepts an order as its sole argument, and then it returns that same order after it has been “made.”</p>
<p>I want to call <code>brew()</code> for each item in <code>orders</code>, passing each current order as an argument. For that, I’ll use <code>map()</code>:</p>
<pre><code>for order in map(brew, orders):
    print(f"One {order} is ready!")</code></pre>
<p class="CodeListingCaption"><a id="listing9-99">Listing 9-99</a>: <em>brew_map.py:3</em></p>
<p>In my <code>for</code> loop, I create an instance of the <code>map</code> iterable, passing the <code>brew()</code> function and the <code>orders</code> collection to the <code>map</code> initializer.</p>
<p>For each item in <code>orders</code>, the <code>brew()</code> function is called, and the item is passed as the argument. The value returned by <code>brew()</code> is then passed back by the <code>map</code> to the loop, which binds it to <code>order</code>, so it can be used in the suite of the loop. This process repeats until every item in <code>orders</code> has been iterated over.</p>
<p>You can also use <code>map()</code> with multiple iterables, with the current item of each being used as one of the arguments to the callable. Once one of the iterators has run out of values, <code>map</code> is done. Here’s how I would use it to add the cost and tip for multiple orders:</p>
<pre><code>from operator import add

cost = [5.95, 4.95, 5.45, 3.45, 2.95]
tip = [0.25, 1.00, 2.00, 0.15, 0.00]

for total in map(add, cost, tip):
    print(f'{total:.02f}')</code></pre>
<p class="CodeListingCaption"><a id="listing9-100">Listing 9-100</a>: <em>grand_total_map.py</em></p>
<p><span epub:type="pagebreak" title="251" id="Page_251"/>I have two lists: <code>cost</code> contains the price of each order, and <code>tip</code> contains the tip given for each order. In the loop, I create a <code>map</code> that calls the <code>operator.add()</code> function, passing the current item from <code>cost</code> as the first argument and the current item from <code>tip</code> as the second argument. The sum of the two values is returned and bound to <code>total</code>. I print that <code>total</code> value out, formatting it to display values to two decimal places.</p>
<p>Running that code outputs this:</p>
<pre><code>6.20
5.95
7.45
3.60
2.95</code></pre>
<h3 id="h2-500920c09-0031">Zip</h3>
<p class="BodyFirst">The <code>zip</code> iterable combines multiple iterables together. On each iteration, it takes the next value for each iterable in turn and packs them all together into a tuple. Once one of the iterables has been exhausted, <code>zip</code> stops.</p>
<p>This is particularly useful if you want to create a dictionary from multiple lists, although you could populate any collection using <code>zip</code>.</p>
<p>Here, I start with two lists. One list represents the regular customers, and one represents their usual orders. I want to turn this into a dictionary, so I can look up “the usual” by customer name:</p>
<pre><code>regulars = ['William', 'Devin', 'Kyle', 'Simon', 'Newman']
usuals = ['french press', 'double-shot espresso', 'mocha cappuccino',
          'chai latte', 'tea', 'drip']

usual_orders = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> dict( <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> zip( <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> regulars, <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> usuals))</code></pre>
<p class="CodeListingCaption"><a id="listing9-101">Listing 9-101</a>: <em>usuals_zip.py</em></p>
<p>I create a <code>zip</code> iterable <span class="CodeAnnotation" aria-label="annotation2">❷</span> whose items are tuples derived from the items in the <code>regulars</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span> and <code>usuals</code> <span class="CodeAnnotation" aria-label="annotation4">❹</span> iterables: <code>('William', 'french press')</code>, <code>('Devin', 'double-shot espresso')</code>, and so forth. Then, I pass this iterable to the <code>dict()</code> initializer <span class="CodeAnnotation" aria-label="annotation1">❶</span>, creating a dictionary (<code>usual_orders</code>) with the first item of each tuple as the key and the second item of each tuple as the value.</p>
<p>I’ll demonstrate that this works by looking up and printing Devin’s usual order:</p>
<pre><code>print(usual_orders['Devin'])  # prints 'double-shot espresso'</code></pre>
<p class="CodeListingCaption"><a id="listing9-102">Listing 9-102</a>: <em>usuals_zip.py</em></p>
<p>The dictionary contains five items, since the shortest iterable, <code>regulars</code>, had five items. As a result, the excess item in <code>usuals</code> (namely, <code>'drip'</code>) is ignored by <code>zip</code>.</p>
<h3 id="h2-500920c09-0032"><span epub:type="pagebreak" title="252" id="Page_252"/>Itertools</h3>
<p class="BodyFirst">The <code>itertools</code> module contains many useful classes for working with iteration. Very few Python developers memorize all of these. They instead refer to the documentation via the website or the <code>help()</code> command, whenever the topic comes up.</p>
<p>Here are a few highlights. Understand that I’ll skip most of the optional arguments, for the sake of brevity:</p>
<ol class="none">
<li><code>accumulate</code> repeatedly performs a two-argument function and uses the result of each call as the first argument for the next call. The current item in the iterable is the second argument. On each iteration, the current result is returned. By default, this uses the <code>operator.add()</code> function.</li>
<li><code>chain</code> produces a list containing each item from each iterable passed to it, in order. <code>chain([1,2,3], [4,5,6])</code> would produce <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, and <code>6</code>.</li>
<li><code>combinations</code> produces every possible subsequence of items in the provided iterable, with the specified number of items in each combination. <code>combinations([1,2,3], 2)</code> would produce <code>(1, 2)</code>, <code>(1, 3)</code>, and <code>(2, 3)</code>.</li>
<li><code>dropwhile</code> drops (skips) items in an iterable as long as some expression evaluates to <code>True</code>, and then it returns every item after that. So <code>dropwhile(lambda n:n!=42, [5,6,42,7,53])</code> would produce <code>42</code>, <code>7</code>, and <code>53</code>, since the predicate lambda returns <code>True</code> until it encounters the value <code>42</code>.</li>
<li><code>filterfalse</code> is the same as <code>filter</code>, except that it works in exactly the opposite manner: the callable must return <code>False</code> to include the item.</li>
<li><code>islice</code> performs slices on nonsubscriptable iterables. It is identical in behavior to slicing, except that it doesn’t support negative values for the <var>start</var>, <var>stop</var>, or <var>step</var>.</li>
<li><code>permutations</code> produces every possible permutation of the items in the provided iterable, with the specified number of items in each permutation. <code>permutations([1,2,3], 2)</code> would produce <code>(1, 2)</code>, <code>(1, 3)</code>, <code>(2, 1)</code>, <code>(2, 3)</code>, <code>(3, 1)</code>, and <code>(3, 2)</code>.</li>
<li><code>product</code> produces the Cartesian product of the provided iterables. <code>product([1,2], [3,4])</code> would produce <code>(1, 3)</code>, <code>(1, 4)</code>, <code>(2, 3)</code>, and <code>(2, 4)</code>.</li>
<li><code>starmap</code> behaves like <code>map</code>, except that it passes each item in the provided iterator as a starred argument. <code>starmap(func, [(1,2), (3,4)]</code> would call <code>func(1,2)</code> and then <code>func(3,4)</code>.</li>
<li><code>takewhile</code> behaves in exactly the opposite way as does <code>dropwhile</code>. It takes items from the provided iterator, as long as the provided predicate evaluates to <code>True</code>. As soon as the predicate evaluates to <code>False</code>, it ignores the rest of the items.</li>
</ol>
<p>There are a few more classes in <code>itertools</code> besides these. Read the documentation for more information!</p>
<h2 id="h1-500920c09-0011"><span epub:type="pagebreak" title="253" id="Page_253"/>Custom Iterable Classes</h2>
<p class="BodyFirst">Though Python offers plenty of collections and other iterables, there may arise a situation when you need to write your <em>own</em> iterable class. Thankfully, this is not difficult.</p>
<p>Often, you’ll write two classes: an <em>iterable</em> and a corresponding <em>iterator</em>. This is a matter of separation of concerns: the iterable is responsible for storing or generating values, while the iterator is responsible for tracking the current position in that iterable. This allows you to make multiple independent iterator instances for the same iterable.</p>
<p>There are situations where it is beneficial for a single class to be both an iterable and an iterator. One such situation occurs when the iterable object’s data is nonreproducible, such as with data streamed over a network. Another case is infinite iterators, which I’ll revisit in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>.</p>
<p>For now, I’ll stick with the typical two-class approach. Here’s a simple iterable class that I can use for tracking café patrons and the details of their orders. (In the real world, I probably wouldn’t solve the problem with a custom iterable class like this, but it works as an example.)</p>
<p>I’ll start by defining the iterable class for tracking customers:</p>
<pre><code>class CafeQueue:

    def __init__(self):
        self._queue = []
        self._orders = {}
        self._togo = {}</code></pre>
<p class="CodeListingCaption"><a id="listing9-103">Listing 9-103</a>: <em>cafequeue.py:1</em></p>
<p>The class will have three instance attributes: <code>_queue</code>, a list containing customer names; <code>_orders</code>, a dictionary storing customer orders; and <code>_togo</code>, a dictionary storing whether the customer wants their order to go or not.</p>
<p>To make the class iterable, I define the <code>__iter__()</code> special method:</p>
<pre><code>    def __iter__(self):
        return CafeQueueIterator(self)</code></pre>
<p class="CodeListingCaption"><a id="listing9-104">Listing 9-104</a>: <em>cafequeue.py:2</em></p>
<p>The <code>__iter__()</code> method must return an instance of the corresponding iterator class. (I’ll define this class in a moment.)</p>
<p>To make this iterable class useful, I’d like to do some other things with it, besides iterate over its data. The <code>add_customer()</code> instance method will allow me to add a new customer:</p>
<pre><code>    def add_customer(self, customer, *orders, to_go=True):
        self._queue.append(customer)
        self._orders[customer] = tuple(orders)
        self._togo[customer] = to_go</code></pre>
<p class="CodeListingCaption"><a id="listing9-105">Listing 9-105</a>: <em>cafequeue.py:3</em></p>
<p><span epub:type="pagebreak" title="254" id="Page_254"/>I will want to check how many customers are in line by using the <code>len()</code> built-in function, so I must define the <code>__len__()</code> special instance method:</p>
<pre><code>    def __len__(self):
        return len(self._queue)</code></pre>
<p class="CodeListingCaption"><a id="listing9-106">Listing 9-106</a>: <em>cafequeue.py:4</em></p>
<p>Remember, <code>len()</code> is only for when I actually need to work with the length of the queue itself. For example, if I wanted an LCD display in the cafe to show how many customers are in line, the code for that display could use <code>len()</code> on a <code>CafeQueue</code> object to get that data. Even so, I never use <code>len()</code> directly in the loop header as part of iteration.</p>
<p>Finally, I’d like to check whether a particular customer is in the queue, so I define the <code>__contains__()</code> special method:</p>
<pre><code>    def __contains__(self, customer):
        return (customer in self._queue)</code></pre>
<p class="CodeListingCaption"><a id="listing9-107">Listing 9-107</a>: <em>cafequeue.py:5</em></p>
<p>Now that I have the <code>CafeQueue</code> class, I can define the corresponding iterator class, which I’m calling <code>CafeQueueIterator</code>. Ordinarily, these two classes would be defined in the same module, as I’ve done here.</p>
<p>I’ll start with the iterator’s initializer:</p>
<pre><code>class CafeQueueIterator:

    def __init__(self, <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> cafe_queue):
        self._cafe = cafe_queue
        self._position = 0</code></pre>
<p class="CodeListingCaption"><a id="listing9-108">Listing 9-108</a>: <em>cafequeue.py:6</em></p>
<p>This iterator class is responsible for keeping track of its own position in the iterable. The initializer receives a single argument: the iterable instance associated with the iterator instance <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<p> This is why, in the iterable’s <code>__iter__()</code> method, I can use the line <code>return CafeQueueIterator(self)</code> (see <a href="#listing9-108" id="listinganchor9-108">Listing 9-108</a>). I pass the iterable instance to the iterator initializer, where it is stored as the instance attribute <code>_cafe</code>.</p>
<p>An iterator class must define the special method <code>__next__()</code>, which returns the next item in the iterable:</p>
<pre><code>    def __next__(self):
        try:
            customer = self._cafe._queue[self._position]
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> except IndexError:
          <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> raise StopIteration

        orders = self._cafe._orders[customer]
        togo = self._cafe._togo[customer]

<span epub:type="pagebreak" title="255" id="Page_255"/>      <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> self._position += 1

      <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> return (customer, orders, togo)</code></pre>
<p class="CodeListingCaption"><a id="listing9-109">Listing 9-109</a>: <em>cafequeue.py:7</em></p>
<p>The <code>__next__()</code> method is responsible for keeping track of the iterator’s position in the iterable. Iterables can be infinite (something I’ll cover in depth in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>), so there is no built-in means of stopping iteration. In <code>__next__()</code>, if I’ve iterated over all the items in the iterable <span class="CodeAnnotation" aria-label="annotation1">❶</span>, I raise <code>StopIteration</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Otherwise, after retrieving the current item from the iterable, I must update the iterator’s position <span class="CodeAnnotation" aria-label="annotation3">❸</span> before finally returning the item <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>
<p>Each item contains multiple elements, so I pack the data for an item into a tuple: <code>(</code><var>customer</var><code>, </code><var>orders</var><code>, </code><var>to_go</var><code>)</code>. This can be unpacked in a <code>for</code> loop during iteration. If you look at the <code>CafeQueue</code> class again (<a href="#listing9-103" id="listinganchor9-103">Listing 9-103</a>), you’ll notice that <code>orders</code> will be a tuple of varying length, containing each order for the customer.</p>
<p>The special method <code>__iter__()</code> must also be defined in an iterator class. This method is always expected to return an iterator, but since this instance <em>is</em> an iterator, <code>__iter__()</code> only needs to return <code>self</code>.</p>
<pre><code>    def __iter__(self):
        return self</code></pre>
<p class="CodeListingCaption"><a id="listing9-110">Listing 9-110</a>: <em>cafequeue.py:8</em></p>
<p>Now that I have both my iterable (<code>CafeQueue</code>) and iterator (<code>CafeQueueIterator</code>) classes written, I can use them like any other collection. I create a new <code>CafeQueue</code> and populate it with data:</p>
<pre><code>queue = CafeQueue()
queue.add_customer('Newman', 'tea', 'tea', 'tea', 'tea', to_go=False)
queue.add_customer('James', 'medium roast drip, milk, 2 sugar substitutes')
queue.add_customer('Glen', 'americano, no sugar, heavy cream')
queue.add_customer('Jason', 'pumpkin spice latte', to_go=False)</code></pre>
<p class="CodeListingCaption"><a id="listing9-111">Listing 9-111</a>: <em>cafequeue.py:9</em></p>
<p>Before I iterate over the collection, I’ll test using <code>len()</code> and <code>in</code>:</p>
<pre><code>print(len(queue))       # prints 4
print('Glen' in queue)  # prints True
print('Kyle' in queue)  # prints False</code></pre>
<p class="CodeListingCaption"><a id="listing9-112">Listing 9-112</a>: <em>cafequeue.py:10</em></p>
<p>I can see how many customers are in the queue with <code>len()</code> and check for individual customers using <code>in</code>. All’s well, so far!</p>
<p>I want to use this new iterable to automate making and delivering orders to the customers. Remember that each item in the iterable will be a tuple <code>(</code><var>customers</var><code>, </code><var>orders</var><code>, </code><var>to_go</var><code>)</code> and that <var>orders</var> is itself a tuple of unknown length. Although it’s simple in this example, you can imagine that brewing <span epub:type="pagebreak" title="256" id="Page_256"/>an order could theoretically be quite involved, so I’ll use the stand-alone <code>brew()</code> function from <a href="#listing9-98" id="listinganchor9-98">Listing 9-98</a> to handle each order:</p>
<pre><code>def brew(order):
    print(f"(Making {order}...)")
    return order</code></pre>
<p class="CodeListingCaption"><a id="listing9-113">Listing 9-113</a>: <em>cafequeue.py:11</em></p>
<p>Nothing remarkable there.</p>
<p>So then, here’s the loop for working with the <code>CafeQueue</code> instance <code>queue</code>:</p>
<pre><code>for customer, orders, to_go in queue:
   <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> for order in orders: brew(order)
    if to_go:
        print(f"Order for {customer}!")
    else:
        print(f"(Takes order to {customer})")</code></pre>
<p class="CodeListingCaption"><a id="listing9-114">Listing 9-114</a>: <em>cafequeue.py:12</em></p>
<p>The <code>for</code> loop iterates over <code>queue</code>, unpacking each item tuple into three names: <code>customer</code>, <code>orders</code>, and <code>to_go</code>.</p>
<p>I use a nested loop to pass each item in the <code>orders</code> tuple to the <code>brew()</code> function <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This particular <code>for</code> loop is pretty simple, so I can write it as a flat statement.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">I didn’t use <code>map(brew, orders)</code> because it wouldn’t actually print anything by itself. Rather <code>map()</code> creates a generator that would have to be iterated over anyway, so the <code>for</code> loop is the better technique in this case.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Finally, I use <code>to_go</code> to determine whether to announce the order is ready or to take it out to the customer’s table.</p>
<h2 id="h1-500920c09-0012">Wrapping Up</h2>
<p class="BodyFirst">Iteration simplifies how one works with loops and collections. Practically any class can be an iterable if it defines an <code>__iter__()</code> method, which returns a corresponding iterator object. An iterator class keeps track of its position in traversing its corresponding iterable, and it must have a <code>__next__()</code> method for returning the next item in the iterable. All Python collections are iterables, and the language offers a number of useful iterator classes, including many in the <code>itertools</code> module.</p>
<p>Python’s <code>for</code> loop is designed specifically for working with iterables and iterators; it handles the calls to <code>__iter__()</code> and <code>__next__()</code> behind the scenes, allowing you to focus on what you want to do with each item instead.</p>
<p>Now’s a good time to get a coffee refill before we dive into the next chapter, wherein I’ll introduce the related concepts of <em>infinite iterators</em>, <em>generators</em>, and <em>generator expressions</em>. (Bring me back a pumpkin spice latte while you’re up there, hey?)</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="257" id="Page_257"/>10</span><br/>
<span class="ChapterTitle">Generators and Comprehensions</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">In the previous chapter, we escaped all the headaches of traditional index-based loops. However, we haven’t yet completely escaped the nested loop.</p>
<p>The solution is to employ <em>generator expressions</em>, which allow you to rewrite the entire logic of a loop in a single statement. You can even create lists in this manner, with the much-loved <em>list comprehensions</em>. Before I get there, I’ll introduce <em>generators</em>, which provide a more compact alternative to custom iterable classes in many situations. You’ll also encounter the oft-overshadowed cousin of the generator, the humble <em>simple coroutine</em>, which provides an iterative solution for inputs.</p>
<h2 id="h1-500920c10-0001">Lazy Evaluation and Eager Iterables</h2>
<p class="BodyFirst">The features I cover in this chapter all build on the principles of iterators, and many utilize the concept of <em>lazy evaluation,</em> which describes a process in which an iterator does not provide the next value until it is requested. <span epub:type="pagebreak" title="258" id="Page_258"/>This behavior, paired with the fact that iterators do not care how many items are possible in their iterable, provides the power behind generator objects.</p>
<p>While <em>iterators</em> are lazy, the definition of an iterable is not! Understanding this distinction is important when you’re writing code that works with large amounts of data. Incorrectly defining an iterable can lock your program in an infinite loop. In some cases, you can even chew through all available system memory and raise a <code>MemoryError</code> or even crash your machine. (I crashed my system twice while writing this chapter.)</p>
<p>For example, collection literals are incredibly <em>eager</em>, in that they evaluate all of their items upon creation. Programmer Kyle Keen demonstrates this phenomenon with the following example, which I’ve restructured slightly for clarity:</p>
<pre><code>import time
sleepy = ['no pause', time.sleep(1), time.sleep(2)]
# ...three second pause...
print(sleepy[0])  # prints 'no pause'</code></pre>
<p class="CodeListingCaption"><a id="listing10-1">Listing 10-1</a>: <em>sleepy.py:1a</em></p>
<p>Python eagerly evaluates each of the expressions in the list literal before assigning it to <code>sleepy</code>, which means it calls the two <code>time.sleep()</code> functions.</p>
<p>This behavior can mean that collections have the potential to become a performance bottleneck when working with a lot of data or particularly complex expressions.</p>
<p>Thus, you must choose your approaches carefully! One of the best ways to handle large amounts of data is to use either generators or <em>generator expressions</em>, which I’ll cover shortly.</p>
<h2 id="h1-500920c10-0002">Infinite Iterators</h2>
<p class="BodyFirst">Lazy evaluation makes it possible to have <em>infinite iterators</em>, which provide values on demand without ever being exhausted. This behavior is very important to some features I cover in this chapter.</p>
<p>The <code>itertools</code> module offers three infinite iterators:</p>
<ul>
<li><code>count()</code> counts from the given numeric value, <code>start</code>, adding the optional <code>step</code> value each time. So, <code>count(5, 2)</code> would produce the values <code>5</code>, <code>7</code>, <code>9</code>, <code>11</code>, and so on, forever.</li>
<li><code>cycle()</code> cycles through each item in the given iterable, infinitely. Therefore, <code>cycle([1,2,3])</code> would produce <code>1</code>, <code>2</code>, <code>3</code>, <code>1</code>, <code>2</code>, <code>3</code>, on and on, forever.</li>
<li><code>repeat()</code> repeats the given value, either endlessly or up to an optionally specified number of times. Therefore, <code>repeat(42)</code> would produce the value <code>42</code> forever, while <code>repeat(42, 10)</code> would produce the value <code>42</code> up to <code>10</code> times.</li>
</ul>
<p><span epub:type="pagebreak" title="259" id="Page_259"/>However, as I mentioned earlier, the very behavior that makes infinite iterators useful also makes them dangerous: they have no brakes! When passed to a <code>for</code> loop that has no <code>break</code> statement, the loop becomes infinite. When unpacked with a starred expression or used to create a collection, the Python interpreter locks up or even crashes the system. Use infinite iterators with caution!</p>
<h2 id="h1-500920c10-0003">Generators</h2>
<p class="BodyFirst">A powerful alternative to the iterator class is the <em>generator function</em>, which looks like an ordinary function, except for its use of a special <code>yield</code> keyword. When a generator function is called directly, it returns a <em>generator iterator</em> (also known as a <em>generator object</em>) that encapsulates the logic from the suite of the generator function.</p>
<p>On each iteration, the generator iterator will run up to (and including) a <code>yield</code> statement, and then it will wait for another call to the special method <code>__next__()</code>, which Python implicitly creates behind the scenes. You will recall from <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> that <code>__next__()</code> is the special method responsible for providing the next value in an iterator; it is called anytime an iterator object is passed to the <code>next()</code> function or used in a <code>for</code> loop. Once a generator iterator receives the call to <code>__next__()</code>, it will continue running until it hits another <code>yield</code>.</p>
<p>For example, I can use a generator to generate license plate numbers:</p>
<pre><code>from itertools import product
from string import ascii_uppercase as alphabet


def gen_license_plates():
    for letters in <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> product(alphabet, repeat=3):
        letters = <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> "".join(letters)
        if letters == 'GOV':
            continue

      <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> for numbers in range(1000):
            yield f'{letters} {numbers:03}'</code></pre>
<p class="CodeListingCaption"><a id="listing10-2">Listing 10-2</a>: <em>license_generator.py:1</em></p>
<p>I declare the <code>gen_license_plates()</code> generator function like any other function.</p>
<p>To generate all the possible combinations of letters, I use the <code>itertool.product</code> iterable. The predefined string <code>string.ascii_uppercase</code>, which I’m locally renaming to <code>alphabet</code>, will provide the values for each letter within an iterable collection (a string).</p>
<p>I iterate over all the possible combinations of three letters by initializing a <code>product</code> iterator <span class="CodeAnnotation" aria-label="annotation1">❶</span> that iterates over the <code>alphabet</code> string three times, concatenated. I join the three letters into a single string <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p>Before I iterate over the numbers, I ensure that <code>letters</code> is not equal to the string <code>'GOV'</code>. If it is, the generator will skip that iteration of letter <span epub:type="pagebreak" title="260" id="Page_260"/>combinations, as I imagine in this scenario that <code>'GOV'</code> is reserved for government vehicles only.</p>
<p>Finally, I iterate over all possible numbers, <code>000 to 999</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>
<p>The line that makes this function a generator is the <code>yield</code> statement. Every time this line is reached in the program execution, the value is returned, and then the generator waits for another call to <code>__next__()</code>. When <code>__next__()</code> is called again, the generator resumes exactly where it left off, thereby producing and yielding the next value.</p>
<p>I must call my generator function to create the generator iterator I want to use, which I’ll bind to a name:</p>
<pre><code>license_plates = gen_license_plates()</code></pre>
<p class="CodeListingCaption"><a id="listing10-3">Listing 10-3</a>: <em>license_generator.py:2</em></p>
<p>The name <code>license_plates</code> is now bound to the generator iterator created by <code>gen_license_plates()</code>. This is the object with the <code>__next__()</code> method.</p>
<p>I can treat <code>license_plates</code> the same as any iterator. For example, I’ll loop through all possible license plates, although this will take a long time to execute:</p>
<pre><code>for plate in license_plates:
    print(plate)</code></pre>
<p class="CodeListingCaption"><a id="listing10-4">Listing 10-4</a>: <em>license_generator.py:3a</em></p>
<p>That outputs the following (redacted):</p>
<pre><code>AAA 000
AAA 001
AAA 002
<var># --snip--</var>
ZZZ 997
ZZZ 998
ZZZ 999</code></pre>
<p>Most real-world scenarios wouldn’t want all the possible numbers at once. Here’s a more practical usage:</p>
<pre><code>registrations = {}


def new_registration(owner):
    if owner not in registrations:
        plate = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> next(license_plates)
        registrations[owner] = plate
        return plate
    return None</code></pre>
<p class="CodeListingCaption"><a id="listing10-5">Listing 10-5</a>: <em>license_generator.py:3b</em></p>
<p>I define a function, <code>new_registration()</code>, which handles all of the logic for a new license plate registration. If the name is not already in the system, it <span epub:type="pagebreak" title="261" id="Page_261"/>retrieves the next plate from the iterator <code>license_plates</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and stores it in the <code>registrations</code> dictionary, with the given <code>owner</code> as the key. Then, it returns the plate number for convenience. If the name is already in the system, it will return <code>None</code>.</p>
<p>To make the example a little more interesting, I’m manually fast-forwarding through a few thousand license plates:</p>
<pre><code># Fast-forward through several results for testing purposes.
for _ in range(4441888):
    next(license_plates)</code></pre>
<p class="CodeListingCaption"><a id="listing10-6">Listing 10-6</a>: <em>license_generator.py:4</em></p>
<p>Now, I’ll put the <code>new_registration()</code> function to use:</p>
<pre><code>name = "Jason C. McDonald"
my_plate = new_registration(name)
print(my_plate)
print(registrations[name])</code></pre>
<p class="CodeListingCaption"><a id="listing10-7">Listing 10-7</a>: <em>license_plates.py:5</em></p>
<p>I use the <code>new_registration()</code> function to register myself at this fictional DMV, and then I store the returned license plate number in <code>my_plate</code>, which I print out. I also directly check the <code>registrations</code> dictionary, to see what license plate was registered to me. </p>
<p>The output of this program is as follows:</p>
<pre><code>GOW 888
GOW 888</code></pre>
<h3 id="h2-500920c10-0001">Generators vs. Iterator Classes</h3>
<p class="BodyFirst">Recall that a <code>__next__()</code> method in an iterator class will raise the<code> StopIteration</code> exception to announce that there are no more items to iterate over. Generators don’t require that exception to be explicitly raised; what’s more, since Python 3.5, they don’t even allow it. When the generator function terminates, either by reaching its end or explicitly with a <code>return</code> statement, <code>StopIteration</code> is raised automatically, behind the scenes.</p>
<h4 id="h3-500920c10-0001">As an Iterator Class</h4>
<p class="BodyFirst">To demonstrate this, I’ll write an iterator class that randomly generates traffic on a freeway. Once it’s working, I’ll rewrite it as a generator function.</p>
<p>I’ll start by defining a couple of lists of possibilities:</p>
<pre><code>from random import choice

colors = ['red', 'green', 'blue', 'silver', 'white', 'black']
vehicles = ['car', 'truck', 'semi', 'motorcycle', None]</code></pre>
<p class="CodeListingCaption"><a id="listing10-8">Listing 10-8</a>: <em>traffic_generator_class.py:1</em></p>
<p><span epub:type="pagebreak" title="262" id="Page_262"/>Next, I create a <code>Traffic</code> class for my iterator:</p>
<pre><code>class Traffic:
    def __iter__(self):
        return self</code></pre>
<p class="CodeListingCaption"><a id="listing10-9">Listing 10-9</a>: <em>traffic_generator_class.py:3</em></p>
<p>I don’t need an initializer, since I have no instance attributes. I make this class an iterable by defining the <code>__iter__()</code> special method, which returns <code>self</code>.</p>
<p>I also need to define <code>__next__()</code> for this class to be an iterator:</p>
<pre><code>    def __next__(self):
        vehicle = choice(vehicles)

        if vehicle is None:
            raise StopIteration

        color = choice(colors)

        return f"{color} {vehicle}"</code></pre>
<p class="CodeListingCaption"><a id="listing10-10">Listing 10-10</a>: <em>traffic_generator_class.py:4</em></p>
<p>In the <code>__next__()</code> special method, I randomly select a vehicle from the global <code>vehicles</code> list, using <code>random.choice()</code>. If I select the item <code>None</code> from that list, I raise the<code> StopIteration</code> exception to indicate an end (gap) in the stream of traffic. Otherwise, I select a random color from the global <code>colors</code> list, and then I return a formatted string containing the vehicle and color.</p>
<p>I can use my <code>Traffic</code> iterator as follows:</p>
<pre><code># merge into traffic
count = 0
for count, vehicle in enumerate(Traffic(), start=1):
    print(f"Wait for {vehicle}...")

print(f"Merged after {count} vehicles!")</code></pre>
<p class="CodeListingCaption"><a id="listing10-11">Listing 10-11</a>: <em>traffic_generator_class.py:5</em></p>
<p>I iterate over each vehicle, print out its description, and keep count of how many vehicles have passed. Once <code>StopIteration</code> is raised by <code>Traffic()</code>, the loop ends and the final <code>print()</code> statement is run. One example output of this code is as follows:</p>
<pre><code>Wait for green car...
Wait for red truck...
Wait for silver car...
Merged after 3 vehicles!</code></pre>
<p>That works fine, but the iterator class has a lot of extra boilerplate. Instead, I can write the iterator as a generator function, which I’ll do next.</p>
<h4 id="h3-500920c10-0002"><span epub:type="pagebreak" title="263" id="Page_263"/>As a Generator Function</h4>
<p class="BodyFirst">As before, I’ll reuse the lists from the previous example to define a couple of lists containing possibilities:</p>
<pre><code>from random import choice

colors = ['red', 'green', 'blue', 'silver', 'white', 'black']
vehicles = ['car', 'truck', 'semi', 'motorcycle', None]</code></pre>
<p class="CodeListingCaption"><a id="listing10-12">Listing 10-12</a>: <em>traffic_generator.py:1</em></p>
<p>Now, I’ll define the <code>traffic()</code> generator function:</p>
<pre><code>def traffic():
    while True:
        vehicle = choice(vehicles)

        if vehicle is None:
            return

        color = choice(colors)
        yield f"{color} {vehicle}"</code></pre>
<p class="CodeListingCaption"><a id="listing10-13">Listing 10-13</a>: <em>traffic_generator.py:2</em></p>
<p>I declare this generator function like any other function, although I must structure it to run continuously, the same as if I were going to <code>print()</code> each item. I accomplish this with an infinite loop. As soon as the function returns, either implicitly by reaching its end (which is not possible in this case) or via a <code>return</code> statement, the iterator will raise <code>StopIteration</code> behind the scenes.</p>
<p>Since I don’t know how much traffic is going to be randomly generated, I want this generator function to run indefinitely, until it selects a <code>None</code> value from <code>vehicles</code>. Then, instead of raising <code>StopIteration</code>, I exit the function with <code>return</code> to indicate that iteration is finished. Since Python 3.5, raising <code>StopIteration</code> within a generator function will raise a <code>RuntimeError</code> instead.</p>
<p>The usage is the same as before, except that I’m now iterating over the generator, not the iterator class:</p>
<pre><code># merge into traffic
count = 0
for count, vehicle in enumerate(<b>traffic()</b>, start=1):
    print(f"Wait for {vehicle}...")

print(f"Merged after {count} vehicles!")</code></pre>
<p class="CodeListingCaption"><a id="listing10-14">Listing 10-14</a>: <em>traffic_generator.py:3</em></p>
<p>The output is effectively the same as before (although remember, it’s random):</p>
<pre><code>Wait for white truck...
Wait for silver semi...
Merged after 2 vehicles!</code></pre>
<h3 id="h2-500920c10-0002"><span epub:type="pagebreak" title="264" id="Page_264"/>Closing Generators</h3>
<p class="BodyFirst">Generators, like any iterators, can be infinite. However, when you’re done with an iterator, you should close it, since leaving it sitting idle in memory for the rest of your program would be a waste of resources.</p>
<p>To demonstrate this, here’s my traffic generator, rewritten to be infinite. I start by using the lists I wrote for the earlier example:</p>
<pre><code>from random import choice

colors = ['red', 'green', 'blue', 'silver', 'white', 'black']
vehicles = ['car', 'truck', 'semi', 'motorcycle', None]</code></pre>
<p class="CodeListingCaption"><a id="listing10-15">Listing 10-15</a>: <em>traffic_infinite_generator.py:1</em></p>
<p>Here’s my rewritten traffic generator function, which is the same as <a href="#listing10-13" id="listinganchor10-13">Listing 10-13</a>, except that I’ve dropped the <code>return</code> logic:</p>
<pre><code>def traffic():
    while True:
        vehicle = choice(vehicles)
        color = choice(colors)
        yield f"{color} {vehicle}"</code></pre>
<p class="CodeListingCaption"><a id="listing10-16">Listing 10-16</a>: <em>traffic_infinite_generator.py:2a</em></p>
<p>Since the function can never reach its end and has no <code>return</code> statement, the generator is an infinite iterator.</p>
<p>I can use this generator in whatever way I want. For example, I could write a function for a car wash that uses the generator but limits how many vehicles can be washed:</p>
<pre><code>def car_wash(traffic, limit):
    count = 0
    for vehicle in traffic:
        print(f"Washing {vehicle}.")
        count += 1
        if count &gt;= limit:
            traffic.close()</code></pre>
<p class="CodeListingCaption"><a id="listing10-17">Listing 10-17</a>: <em>traffic_infinite_generator.py:3</em></p>
<p>I would pass a <code>traffic</code> iterator to the <code>car_wash()</code> function, along with an integer value bound to <code>limit</code> representing how many vehicles can be washed. The function iterates over traffic, washing each car, and keeping count.</p>
<p>Once the limit has been reached (or surpassed), I don’t want to keep the <code>traffic</code> iterable around anymore, especially as it may have been instantiated right in the argument list, so I close it. This causes<code> GeneratorExit</code> to be raised within the generator, which in turn causes <code>StopIteration</code> to be raised—ending the loop, and thus, the function.</p>
<p><span epub:type="pagebreak" title="265" id="Page_265"/>Now that I’ve written the generator and the function using it, here’s how I put the two together:</p>
<pre><code>car_wash(traffic(), 10)</code></pre>
<p class="CodeListingCaption"><a id="listing10-18">Listing 10-18</a>: <em>traffic_infinite_generator.py:4a</em></p>
<p>A new iterator is created from the <code>traffic()</code> generator function and passed right to the <code>car_wash()</code> function. When the function is finished, it also closes the iterator. It can now be cleaned up by the garbage collector.</p>
<p>A new iterator can still be created from the <code>traffic()</code> generator function, but the old iterator is exhausted.</p>
<p>I can create a generator iterator instead and use it in <code>car_wash()</code>, which ultimately closes it:</p>
<pre><code><b>queue = traffic()</b>
car_wash(<b>queue</b>, 10)</code></pre>
<p class="CodeListingCaption"><a id="listing10-19">Listing 10-19</a>: <em>traffic_infinite_generator.py:4b</em></p>
<p>Since the <code>car_wash()</code> function closes the iterator <code>queue</code>, I can no longer pass it to <code>next()</code> to get a result, as you can see if I add this erroneous line:</p>
<pre><code><b>next(queue)</b>  # raises StopIteration, since car_wash called close()</code></pre>
<p>Leaving out the error, running that code produces something like the following redacted output:</p>
<pre><code>Washing red motorcycle.
Washing red semi.
<var># --snip--</var>
Washing green semi.
Washing red truck.</code></pre>
<h3 id="h2-500920c10-0003">Behavior on Close</h3>
<p class="BodyFirst">Rather than exiting quietly, I can have the generator do something else when it is closed explicitly. I accomplish this by catching the <code>GeneratorExit</code> exception:</p>
<pre><code>def traffic():
    while True:
        vehicle = choice(vehicles)
        color = choice(colors)
        <b>try:</b>
            yield f"{color} {vehicle}"
        <b>except GeneratorExit:</b>
            <b>print("No more vehicles.")</b>
            <b>raise</b></code></pre>
<p class="CodeListingCaption"><a id="listing10-20">Listing 10-20</a>: <em>traffic_infinite_generator.py:2b</em></p>
<p><span epub:type="pagebreak" title="266" id="Page_266"/>I wrap my <code>yield</code> statement in a <code>try</code> clause. When <code>traffic.close()</code> is called, <code>GeneratorExit</code> is raised at the <code>yield</code> statement the generator is waiting at. I can catch this exception and do whatever I like, such as print out a message. Most important is that I must re-raise the <code>GeneratorExit</code> exception, or else the generator will never actually close!</p>
<p>Without making any changes to the usage of this generator (Listings 10-17 and 10-19), running the code shows this new behavior at work:</p>
<pre><code>Washing green semi.
Washing black truck.
<var># --snip--</var>
Washing blue motorcycle.
Washing silver semi.
No more vehicles.</code></pre>
<h3 id="h2-500920c10-0004">Throwing Exceptions</h3>
<p class="BodyFirst">One seldom-used feature of generators is the <code>throw()</code> method, which can be used to put the generator into some sort of exceptional state, especially when that requires some special behavior beyond the run-of-the-mill <code>close()</code>.</p>
<p>For example, if you’re using a generator to retrieve values from a thermometer device over a network connection, and if the connection is lost, a default value (say, <code>0</code>) is returned from the query instead. You don’t want to log that default value, since it’s wrong! Instead, you’ll want the generator to return the constant <code>NaN</code> for that iteration.</p>
<p>You could write a different function that detects that the network connection is lost, which would retrieve from trying to query the disconnected device. Then, you can cause the generator to raise an exception at the <code>yield</code> statement it’s idling at by using the <code>throw()</code> method. Your generator can catch that exception and yield <code>NaN</code>.</p>
<p>This is similar to how <code>close()</code> will raise <code>GeneratorExit</code>; in fact, <code>close()</code> is functionally identical to <code>throw(GeneratorExit)</code>.</p>
<p>As amazingly useful as that sounds, there aren’t as many real-world use cases for <code>throw()</code>. The thermometer example is one of the few valid such scenarios, but even that would likely be solved better by having the generator call the function for checking the network connection.</p>
<p>I’ve had to write a fairly contrived example using my <code>traffic()</code> generator to demonstrate this behavior. I’m catching <code>ValueError</code> to allow skipping a vehicle; that is the exception that I will raise at the <code>yield</code> statement with the <code>throw()</code> method in the usage later.</p>
<pre><code>from random import choice
colors = ['red', 'green', 'blue', 'silver', 'white', 'black']
vehicles = ['car', 'truck', 'semi', 'motorcycle', None]

def traffic():
    while True:
        vehicle = choice(vehicles)
        color = choice(colors)
<span epub:type="pagebreak" title="267" id="Page_267"/>        try:
            yield f"{color} {vehicle}"
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> except ValueError:
          <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> print(f"Skipping {color} {vehicle}...")
          <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> continue
        except GeneratorExit:
            print("No more vehicles.")
            raise</code></pre>
<p class="CodeListingCaption"><a id="listing10-21">Listing 10-21</a>: <em>traffic_generator_throw.py:1</em></p>
<p>When the <code>ValueError</code> exception is raised at the <code>yield</code> statement, it will be caught <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the generator will announce that the current vehicle is being skipped <span class="CodeAnnotation" aria-label="annotation2">❷</span>, before moving to the next iteration of its infinite loop <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>
<p>This would really only be conceivably useful if I abstracted out the logic of washing a car into its own function. That function can raise exceptions:</p>
<pre><code>def wash_vehicle(vehicle):
    if 'semi' in vehicle:
        raise ValueError("Cannot wash vehicle.")
    print(f"Washing {vehicle}.")</code></pre>
<p class="CodeListingCaption"><a id="listing10-22">Listing 10-22</a>: <em>traffic_generator_throw.py:2</em></p>
<p>The <code>wash_vehicle()</code> function checks that it’s not being asked to wash a semi. If it is, a <code>ValueError</code> is raised.</p>
<p>I’ll write a function, <code>car_wash()</code>, which will handle passing each vehicle from <code>traffic()</code> to <code>wash_vehicle()</code>:</p>
<pre><code>def car_wash(traffic, limit):
    count = 0
    for vehicle in traffic:
        try:
            wash_vehicle(vehicle)
        except Exception as e:
          <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> traffic.throw(e)
        else:
            count += 1
        if count &gt;= limit:
            traffic.close()</code></pre>
<p class="CodeListingCaption"><a id="listing10-23">Listing 10-23</a>: <em>traffic_generator_throw.py:3</em></p>
<p>In the context of the <code>car_wash()</code> function, I catch all exceptions thrown from my call to <code>wash_vehicle()</code>. This catch-all is completely acceptable because I’m re-raising the caught exception within the generator, using <code>traffic.throw()</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. That way, the logic of which exceptions can be raised and how they are handled is handled solely by the <code>wash_vehicle()</code> function and the <code>traffic</code> generator. If any exception is passed to <code>traffic.throw()</code> that is not explicitly handled by the generator, that exception will be raised and left uncaught at the <code>yield</code> statement, so there is no implicit error silencing.</p>
<p>If there’s no exception from calling <code>car_wash()</code>, I increment my count of vehicles washed. If an exception was caught, I don’t want to increment, <span epub:type="pagebreak" title="268" id="Page_268"/>since I don’t want to count the skipped semis in the number of vehicles washed.</p>
<p>Finally, I create a <code>traffic()</code> generator and pass it to the <code>car_wash()</code> function:</p>
<pre><code>queue = traffic()
car_wash(queue, 10)</code></pre>
<p class="CodeListingCaption"><a id="listing10-24">Listing 10-24</a>: <em>traffic_generator_throw.py:4</em></p>
<p>Running that code produces something like the following:</p>
<pre><code>Washing white car.
Washing red motorcycle.
Skipping green semi...
Washing red truck.
Washing green car.
Washing blue truck.
Washing blue truck.
Skipping white semi...
Washing green truck.
Washing green motorcycle.
Washing black motorcycle.
Washing red truck.
No more vehicles.</code></pre>
<p>You can see that 10 vehicles are washed and all the semis are skipped. It works exactly as designed.</p>
<p>As I said, this was a contrived example. There’s probably little reason to have the <em>generator</em> handle the <code>ValueError</code> exception, when I could have handled it in the <code>car_wash()</code> function instead. While I cannot guarantee that there is never a use for <code>throw()</code>, if you think you need it, you’re often overlooking a simpler way of handling the problem.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2>	<p class="BoxBodyFirst">There is no <code>__throw__()</code> special method. To implement this behavior in a custom class, you would define <code>throw()</code> as an ordinary member function.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c10-0004">yield from</h2>
<p class="BodyFirst">When using a generator, you are not limited to yielding data from the current generator iterator. You can temporarily hand off control to other iterables, generators, or coroutines, by using <code>yield from</code>.</p>
<p>In my traffic generator, I want to add a small chance of a biker gang being generated. I start by writing a generator specifically for a biker gang. As with prior examples, I’m reusing those same lists:</p>
<pre><code>from random import choice, randint

colors = ['red', 'green', 'blue', 'silver', 'white', 'black']
vehicles = ['car', 'truck', 'semi', 'motorcycle', None]</code></pre>
<p class="CodeListingCaption"><a id="listing10-25">Listing 10-25</a>: <em>traffic_bikers_generator.py:1</em></p>
<p><span epub:type="pagebreak" title="269" id="Page_269"/>Here’s my new <code>biker_gang()</code> generator function:</p>
<pre><code>def biker_gang():
    for _ in range(randint(2, 10)):
        color = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> choice(colors)
      <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> yield f"{color} motorcycle"</code></pre>
<p class="CodeListingCaption"><a id="listing10-26">Listing 10-26</a>: <em>traffic_bikers_generator.py:2</em></p>
<p>The <code>biker_gang()</code> generator will use the <code>random.randint()</code> function to select a random number between 2 and 10 and generate a biker gang of that size. For each bike in the gang, a random color is selected <span class="CodeAnnotation" aria-label="annotation1">❶</span> and a motorcycle of the selected color is yielded <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p>To use it, I add three lines to my original infinite <code>traffic()</code> generator from <a href="#listing10-16" id="listinganchor10-16">Listing 10-16</a>:</p>
<pre><code>def traffic():
    while True:
        <b>if randint(1, 50) == 50:</b>
<b>          </b><span class="CodeAnnotationCode" aria-label="annotation1">❶</span> <b>yield from biker_gang()</b>
<b>          </b><span class="CodeAnnotationCode" aria-label="annotation2">❷</span> <b>continue</b>
        
        vehicle = choice(vehicles)
        color = choice(colors)
        yield f"{color} {vehicle}"</code></pre>
<p class="CodeListingCaption"><a id="listing10-27">Listing 10-27</a>: <em>traffic_bikers_generator.py:3</em></p>
<p>I use <code>random.randint()</code> to determine whether to generate a biker gang, at a 1-in-50 probability. To generate the biker gang, I use <code>yield from</code> to hand off execution flow to the <code>biker_gang()</code> generator <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The <code>traffic()</code> generator will stay paused at this position until the <code>biker_gang()</code> generator is finished, at which point, control is passed back to this generator and it resumes.</p>
<p>Once <code>biker_gang()</code> is done, I skip to the next iteration of the infinite loop with <code>continue</code> to generate another vehicle <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p>The usage of the <code>traffic()</code> generator is pretty much the same as before:</p>
<pre><code>count = 0
for count, vehicle in enumerate(traffic()):
    print(f"{vehicle}")
    if count == 100:
        break</code></pre>
<p class="CodeListingCaption"><a id="listing10-28">Listing 10-28</a>: <em>traffic_bikers_generator.py:4</em></p>
<p>Running this code will (probably) show the new biker gang–generation logic at work. Here’s an example output (redacted):</p>
<pre><code>black motorcycle
green truck
<var># --snip--</var>
red car
black motorcycle
black motorcycle
<span epub:type="pagebreak" title="270" id="Page_270"/>blue motorcycle
white motorcycle
green motorcycle
blue motorcycle
white motorcycle
silver semi
<var># --snip--</var>
blue truck
silver truck</code></pre>
<p>You are not limited to passing off control to other generators. You can use <code>yield from</code> to iterate over any iterable object, whether it be a collection, an iterator class, or a generator object. Once the iterable is exhausted, control reverts back to the calling generator.</p>
<h2 id="h1-500920c10-0005">Generator Expressions</h2>
<p class="BodyFirst">A <em>generator expression</em> is an iterator that wraps the entire logic of a generator into a single expression. Generator expressions are lazy, so you can use them to work with large amounts of data without locking up your program.</p>
<p>To demonstrate how to create and use generator expressions, I’ll rebuild my earlier license plate generator. I’ll write a generator function containing a single <code>for</code> loop. Later, I’ll transform this into a generator expression.</p>
<p>This loop generates all the possible license plate numbers consisting of the letters <em>ABC</em> and three following digits:</p>
<pre><code>def license_plates():
    for num in range(1000):
        yield f'ABC {num:03}'</code></pre>
<p class="CodeListingCaption"><a id="listing10-29">Listing 10-29</a>: <em>license_plates.py:1a</em></p>
<p>The iterable <code>range(1000)</code> produces all the integers from <code>0</code> to <code>999</code>. The loop iterates through those values, assigning the current value of each iteration to <code>num</code>. Within the loop, I create the license plate number with f-strings, using string formatting to pad <code>num</code> with leading <code>0</code>s as necessary, to ensure there are always three digits.</p>
<p>I want to print the values to test. Since this is also an iterator object, it is best to print the values it produces from its usage, instead of from within the iterator itself. I print from the generator like this:</p>
<pre><code>for plate in license_plates():
    print(plate)</code></pre>
<p class="CodeListingCaption"><a id="listing10-30">Listing 10-30</a>: <em>license_plates.py:2a</em></p>
<p>Running this code prints the following (redacted):</p>
<pre><code>ABC 000
ABC 001
<span epub:type="pagebreak" title="271" id="Page_271"/>ABC 002
<var># --snip--</var>
ABC 997
ABC 998
ABC 999</code></pre>
<p>Because this generator function is so simple, containing only one loop, it is an ideal case for a generator expression. I’ll rewrite as follows:</p>
<pre><code><b>license_plates = (</b>
<b>    </b>f'ABC {number:03}' 
    for number in range(1000)
<b>)</b></code></pre>
<p class="CodeListingCaption"><a id="listing10-31">Listing 10-31</a>: <em>license_plates.py:1b</em></p>
<p>The generator expression is enclosed in the outer parentheses and is bound to the name <code>license_plates</code>. The generator expression itself is essentially an inversion of the loop syntax.</p>
<p>Within the generator expression, the logic from the suite of the loop earlier (<a href="#listing10-30" id="listinganchor10-30">Listing 10-30</a>) is declared first, where I define an expression that will be evaluated on each iteration. I create a string composed of the letters <em>ABC</em> and the number from the current iteration, left-padded with zeroes to three digits. Similar to a <code>return</code> in a lambda, the <code>yield</code> in the generator expression is implied.</p>
<p>Next, I declare the loop itself. As before, I iterate over a <code>range()</code> iterable, using the name <code>number</code> for the value on each iteration.</p>
<p>The revised usage here prints out all the possible license plates:</p>
<pre><code>for plate in license_plates: 
    print(plate)</code></pre>
<p class="CodeListingCaption"><a id="listing10-32">Listing 10-32</a>: <em>license_plates.py:2b</em></p>
<h3 id="h2-500920c10-0005">Generator Objects Are Lazy</h3>
<p class="BodyFirst">Remember, all generator objects are lazy, whether they were produced by generator functions or generator expressions. This means generator objects produce values on demand, and not a moment sooner.</p>
<p>Recall the modified version of Kyle Keen’s eager-evaluation demonstration from <a href="#listing10-1" id="listinganchor10-1">Listing 10-1</a>. I can replicate that same essential logic in a generator expression, and you can see this lazy evaluation at work:</p>
<pre><code>import time
sleepy = <b>(time.sleep(t) for t in range(0, 3))</b></code></pre>
<p class="CodeListingCaption"><a id="listing10-33">Listing 10-33</a>: <em>sleepy.py:1b</em></p>
<p>Unlike the list—whose very <em>definition</em> caused the program to sleep for three seconds before continuing, because every item was being evaluated at definition—this code runs instantly, because it defers evaluation of its <span epub:type="pagebreak" title="272" id="Page_272"/>values until they’re needed. Defining the generator expression itself does not execute <code>time.sleep()</code>.</p>
<p>Even when I manually iterate over the first value in <code>sleepy</code>, there is no delay:</p>
<pre><code>print("Calling...")
next(sleepy)
print("Done!")</code></pre>
<p class="CodeListingCaption"><a id="listing10-34">Listing 10-34</a>: <em>sleepy.py:2</em></p>
<p>Because <code>time.sleep(0)</code> is called on the first iteration of the generator expression, <code>next(sleepy)</code> returns instantly. Subsequent calls to <code>next(sleepy)</code> would cause the program to sleep, but that won’t happen until I request it.</p>
<p>There’s one critical exception to the lazy evaluation of generator expressions: the expression in the leftmost <code>for</code> statement is evaluated immediately. For example, consider what would happen if you were to write this:</p>
<pre><code>import time
sleepy = <b>(time.sleep(t) for t in [1, 2, 3, 4, 5])</b></code></pre>
<p class="CodeListingCaption"><a id="listing10-35">Listing 10-35</a>: <em>sleepy.py:1c</em></p>
<p>That version of the generator expression has none of the desired lazy evaluation behavior, as the list <code>[1, 2, 3, 4, 5] </code>in the <code>for</code> loop is evaluated immediately when the generator expression is first encountered. This is by design, so any errors in the loop’s expression will be raised with a traceback to the generator expression’s declaration, rather than the first <em>usage</em> of the generator expression. However, because the list here evaluates instantly, we don’t actually see a delay.</p>
<h3 id="h2-500920c10-0006">Generator Expressions with Multiple Loops</h3>
<p class="BodyFirst">Generator expressions can support more than one loop at a time, replicating the logic of a nested loop. You list the loops in order, from outermost to innermost.</p>
<p>I’ll rewrite my license plate generator expression to generate all possible combinations of letters and numbers, starting with <code>AAA 000</code> and ending with <code>ZZZ 999</code>. There are 17,576,000 possible results for this, so this is fast only because generator expressions are lazy; the values are not created until they’re requested.</p>
<pre><code><b>from itertools import product</b>
<b>from string import ascii_uppercase as alphabet</b>

license_plates = (
    f'<b>{ </b><span class="CodeAnnotationCode" aria-label="annotation1">❶</span> <b>"".join(letters)}</b> {number:03}'
    <b>for letters in </b><span class="CodeAnnotationCode" aria-label="annotation2">❷</span> <b>product(alphabet, repeat=3)</b>
  <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> for number in range(1000)
)</code></pre>
<p class="CodeListingCaption"><a id="listing10-36">Listing 10-36</a>: <em>license_plates.py:1c</em></p>
<p><span epub:type="pagebreak" title="273" id="Page_273"/>The generator expression, which is wrapped in parentheses and bound to <code>license_plates</code>, spans three lines here for readability. I could have written it as a single line, but once a generator expression starts involving multiple loops, it’s usually best to split it over multiple lines.</p>
<p>In my generator expression, I’m employing two loops. For the first (and outermost) loop, I iterate over all the possible combinations of three letters via <code>itertools.product</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, as I did in <a href="#listing10-2" id="listinganchor10-2">Listing 10-2</a>. The product <code>iterator</code> produces a tuple of values on each iteration, which I must concatenate together into a string using <code>"".join()</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span> when creating the formatted string.</p>
<p>For the second (or inner) loop, I iterate over all possible numbers between <code>000</code> and <code>999</code>, as before <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>
<p>On each iteration, I use an f-string to generate the license plate.</p>
<p>The result is an iterator bound to <code>license_plates</code> that can lazily generate all the possible license plate numbers. The next license plate is not created until it’s requested.</p>
<p>I can use the <code>license_plates</code> generator expression the same as I would a generator object. Its usage is no different from what you saw in <a href="#listing10-5" id="listinganchor10-5">Listing 10-5</a> through <a href="#listing10-7" id="listinganchor10-7">Listing 10-7</a>:</p>
<pre><code>registrations = {}


def new_registration(owner):
    if owner not in registrations:
        plate = next(license_plates)
        registrations[owner] = plate
        return True
    return False


# Fast-forward through several results for testing purposes.
for _ in range(4441888):
    next(license_plates)

name = "Jason C. McDonald"
my_plate = new_registration(name)
print(registrations[name])</code></pre>
<p class="CodeListingCaption"><a id="listing10-37">Listing 10-37</a>: <em>license_plates.py:2c</em></p>
<p>The output of this program is as follows:</p>
<pre><code>GOV 888</code></pre>
<h3 id="h2-500920c10-0007">Conditionals in Generator Expressions</h3>
<p class="BodyFirst">As you may notice, this produced license plates starting with the letters <em>GOV</em>. I need to integrate that conditional from <a href="#listing10-2">Listing 10-2</a> to check for that reserved combination of letters, which I’ll do next.</p>
<p><span epub:type="pagebreak" title="274" id="Page_274"/>I can add a conditional to my generator expression from <a href="#listing10-36" id="listinganchor10-36">Listing 10-36</a>, to incorporate this limitation:</p>
<pre><code>from itertools import product
from string import ascii_uppercase as alphabet

license_plates = (
    f'{"".join(letters)} {numbers:03}'
    for letters in product(alphabet, repeat=3)
    <b>if letters != ('G', 'O', 'V')</b>
    for numbers in range(1000)
)</code></pre>
<p class="CodeListingCaption"><a id="listing10-38">Listing 10-38</a>: <em>license_plates.py:1d</em></p>
<p>I’ve added the conditional: if the value of the tuple <code>letters</code> is <em>not</em> <code>('G', 'O', 'V')</code>, the value will be used. Otherwise, the iteration will be skipped (an implicit <code>continue</code>).</p>
<p>Order matters here! The loops and conditionals are evaluated from top to bottom, as if they were nested. If I’d checked for <code>('G', 'O', 'V')</code> further down, <code>continue</code> would be implicitly called on a thousand separate iterations, but since it <em>precedes</em> the second loop, the numbers are never iterated over on <code>('G', 'O', 'V') </code>at all; the generator expression continues on the first loop.</p>
<p>This syntax can be a bit pesky to keep straight at first. I like to think of it as a nested loop, where the <code>yield</code> line at the end has been yanked out and stuck on the front. The equivalent generator function, written with a single nested loop, would look like this:</p>
<pre><code>def license_plate_generator():
    for letters in product(alphabet, repeat=3):
        if letters != ('G', 'O', 'V'):
            for numbers in range(1000):
                yield f'{"".join(letters)} {numbers:03}'</code></pre>
<p>The last line moves to the front, and you drop the <code>yield</code> keyword, since that’s implied in generator expressions. You also drop the colons from the end of each of the other lines. This way of writing generator expressions is helpful for making sure your logic is sound.</p>
<p>Running the code again produces the following:</p>
<pre><code>GOW 888</code></pre>
<p>As you can see, the conditional is working. Instead of <code>GOV 888</code>, the result is now <code>GOW 888</code>.</p>
<p>You can also use <code>if-else</code> in the context of a generator expression, but there is one catch: the placement is different from with just an <code>if</code>! This subtlety catches a lot of Python developers unawares, even the experienced ones.</p>
<p>Let me show you what I mean. Here’s a generator expression with an <code>if</code>, which produces all the integers less than 100 that are divisible by 3:</p>
<pre><code><span epub:type="pagebreak" title="275" id="Page_275"/>divis_by_three = (n for n in range(100) if n % 3 == 0)</code></pre>
<p class="CodeListingCaption"><a id="listing10-39">Listing 10-39</a>: <em>divis_by_three.py:1a</em></p>
<p>That works, but now, I want to print out <code>"redacted"</code> for every number that <em>isn’t</em> divisible by 3. You might logically try the following (as I did while writing this chapter, and it failed):</p>
<pre><code>divis_by_three = (n for n in range(100) if n % 3 == 0 <b>else "redacted"</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing10-40">Listing 10-40</a>: <em>divis_by_three.py:1b</em></p>
<p>Running that produces this:</p>
<pre><code>SyntaxError: invalid syntax</code></pre>
<p>Eep! The reason for this error becomes clear if you convert the generator expression to a generator function, using the technique I described earlier in this chapter:</p>
<pre><code>def divis_by_three():
    for n in range(100):
        if n % 3 == 0:
        else:  # SyntaxError!
            "redacted"
            yield n</code></pre>
<p>That syntax is outright nonsense. The generator expression itself does not support the <code>else</code> clause—in fact, every compound statement may only have one clause in a generator expression. However, the generator expression does support a <em>ternary expression</em>, which is a compact conditional expression:</p>
<pre><code>def divis_by_three():
    for n in range(100):
        yield n if n % 3 == 0 else "redacted"</code></pre>
<p>Ternary expressions follow the form <var>a</var><code> if </code><var>expression</var><code> else </code><var>b</var>. The ternary expression evaluates to value <var>a</var> if <var>expression</var> evaluates to <code>True</code>—or to <var>b</var>, otherwise. These sorts of expressions can show up anywhere, from assignment to return statements. However, their use is discouraged in most situations, as they are hard to read. Ternary expressions are mainly only used in lambdas and generator expressions, where full-size conditional statements are out of the question.</p>
<p>I can convert that generator function logic back into a generator expression:</p>
<pre><code>divis_by_three = (n <b>if n % 3 == 0 else "redacted"</b> for n in range(100))</code></pre>
<p class="CodeListingCaption"><a id="listing10-41">Listing 10-41</a>: <em>divis_by_three.py:1c</em></p>
<p><span epub:type="pagebreak" title="276" id="Page_276"/>That version evaluates correctly. Hooray! However, if I were to revert to using an <code>if</code> and dropping the <code>else</code> statement, I’d be back to having problems:</p>
<pre><code>divis_by_three = (n if n % 3 == 0 for n in range(100))</code></pre>
<p class="CodeListingCaption"><a id="listing10-42">Listing 10-42</a>: <em>divis_by_three.py:1d</em></p>
<p>Running that gives me this:</p>
<pre><code>SyntaxError: invalid syntax</code></pre>
<p>If I convert that back to generator function logic, the problem becomes evident again:</p>
<pre><code>def divis_by_three():
    for n in range(100):
        yield n if n % 3 == 0  # syntax error</code></pre>
<p>Without an <code>else</code>, that’s not a ternary expression, so I have to go back to the normal <code>if</code> statement:</p>
<pre><code>def divis_by_three():
    for n in range(100):
        if n % 3 == 0:
            yield n</code></pre>
<p>That can be converted back to a generator expression that works:</p>
<pre><code>divis_by_three = (n for n in range(100) if n % 3 == 0)</code></pre>
<p class="CodeListingCaption"><a id="listing10-43">Listing 10-43</a>: <em>divis_by_three.py:1e (same as 1a)</em></p>
<p>This can be a bit infuriating to remember offhand. I recommend you write your logic as a generator function first and then convert it to a generator expression.</p>
<h3 id="h2-500920c10-0008">Nested Generator Expressions</h3>
<p class="BodyFirst">One inefficiency in my use of the current version of the license plate generator expression is that I’m joining the string together on every iteration. My generator expression in <a href="#listing10-38" id="listinganchor10-38">Listing 10-38</a> joined each combination of letters once, instead of once for every combination of letters <em>and</em> numbers. What’s more, in my conditional, the code would look cleaner and be more maintainable if I had a nice, clean string to work with, instead of the tuple being produced by <code>product()</code>.</p>
<p>Unlike generator functions, generator expressions are limited to nested single-clause compound statements, and thus, a single top-level loop. I can overcome this by <em>nesting</em> one generator expression inside the other. This is effectively the same as writing two separate generator expressions and having one use the other.</p>
<p><span epub:type="pagebreak" title="277" id="Page_277"/>Here’s how I’d use this technique in my license plate generator code:</p>
<pre><code>from itertools import product
from string import ascii_uppercase as alphabet

license_plates = (
    <b>f'</b><span class="CodeAnnotationCode" aria-label="annotation1">❶</span> <b>{</b>letters<b>}</b> {numbers:03}'
    for letters in <b>(</b>
        <b>"".join(chars)</b>
        <b>for chars in </b>product(alphabet, repeat=3)
    <b>)</b>
    if letters != 'GOV'
    for numbers in range(1000)
)</code></pre>
<p class="CodeListingCaption"><a id="listing10-44">Listing 10-44</a>: <em>license_plates.py:1e</em></p>
<p>The inner nested generator expression handles iterating over the results of <code>product()</code>, joining the three letters into a single string. In the outer generator expression, I iterate over the inner expression to get the string containing the next combination of letters. Then, before I iterate over the numbers, I ensure that <code>letters</code> is not equal to the string <code>'GOV'</code>. If it is, the generator expression will skip that iteration of letter combinations.</p>
<p>This approach improves the readability of my code. Instead of having to add cruft to the f-string by calling <code>join()</code> inside of it, I can directly include <code>{letters}</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<p>While this is the cleanest approach to license plate generation I’ve used <em>so far</em>, I wouldn’t use the above code in production, because I’ve arguably reached the practical limit of readability for generator expressions. When things get this complicated, you should just reach for ordinary generator functions. The generator function in <a href="#listing10-2">Listing 10-2</a> is much more readable and maintainable than the equivalent generator expression in <a href="#listing10-44" id="listinganchor10-44">Listing 10-44</a>.</p>
<h2 id="h1-500920c10-0006">List Comprehensions</h2>
<p class="BodyFirst">If you wrap a generator expression in square brackets (<code>[ ])</code> instead of parentheses, you create a <em>list comprehension</em>, which uses the enclosed generator expression to populate the list. This is the most common and perhaps the most popular usage of generator expressions.</p>
<p>However, since I’m declaring an <em>iterable</em>, I’m losing the lazy evaluation inherent in the generator expression. List comprehensions are eager because list definitions are eager. For that reason, I’d likely never write the license plate generator expression as a list comprehension; it would take several seconds to finish, and that doesn’t make for a pleasant user experience. Make sure you only use a list comprehension when you actually need a list object: that is, when you need to store the values in a collection for later processing or use. Otherwise, use a generator expression.</p>
<p>List comprehensions are preferable to <code>filter()</code> for purposes of readability, as they’re easier to write and debug, and they look cleaner. I can <span epub:type="pagebreak" title="278" id="Page_278"/>rewrite the coffee <code>filter()</code> example from <span class="xref" itemid="xref_target_Chapter 9 ">Chapter 9 </span>(Listing 9-96) as a list comprehension:</p>
<pre><code>orders = ['cold brew', 'lemongrass tea', 'chai latte', 'medium drip',
          'french press', 'mocha cappuccino', 'pumpkin spice latte',
          'double-shot espresso', 'dark roast drip', 'americano']

drip_orders = [ <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> order <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> for order in orders <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> if 'drip' in order]

print(f'There are {len(drip_orders)} orders for drip coffee.')</code></pre>
<p class="CodeListingCaption"><a id="listing10-45">Listing 10-45</a>: <em>orders_comprehension.py</em></p>
<p>Remember, a list comprehension is just a type of generator expression. I iterate over every item <code>order</code> in the iterable <code>orders</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If the string <code>'drip'</code> can be found in the current <code>order</code>, then I’ll add that item to <code>drip_orders</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. I don’t need to do anything with <code>order</code> besides adding it to the list, so I lead the generator expression with a bare <code>order</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<p>Functionally, this code is the same as before, but this version with the list comprehension is <em>much</em> cleaner! <code>filter()</code> has its uses, but most of the time, you’ll find that generator expressions or list comprehensions will serve your purposes better.</p>
<h2 id="h1-500920c10-0007">Set Comprehensions</h2>
<p class="BodyFirst">Just as you can create a list comprehension by enclosing a generator expression in square brackets, so also can you create a <em>set comprehension</em> by enclosing in curly braces (<code>{ }</code>). This will use the generator expression to populate a <em>set</em>.</p>
<p>There aren’t any surprises here, so I’ll keep the example very basic. This set comprehension will find all the possible remainders from dividing 100 by an odd number less than 100. Sets will exclude any duplicates, making the results easier to comprehend:</p>
<pre><code>odd_remainders = {100 % divisor for divisor in range(1, 100, 2)}
print(odd_remainders)</code></pre>
<p class="CodeListingCaption"><a id="listing10-46">Listing 10-46</a>: <em>odd_remainders.py</em></p>
<p>For every other integer <code>divisor</code> between <code>1</code> and <code>99</code> inclusive, I find the remainder of dividing <code>100</code> by the <code>divisor</code>, using the modulo operator. The result is added to the set.</p>
<p>Running that code gives me this:</p>
<pre><code>{0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 21,
22, 23, 25, 26, 27, 29, 30, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49}</code></pre>
<p>Set comprehensions really do work the same as list comprehensions, except for which collection is created. Sets are unordered and contain no duplicates.</p>
<h2 id="h1-500920c10-0008"><span epub:type="pagebreak" title="279" id="Page_279"/>Dictionary Comprehensions</h2>
<p class="BodyFirst">A dictionary comprehension follows almost the same structure as a set comprehension, but it requires colons. Both a set comprehension and a dictionary comprehension are enclosed in curly braces (<code>{ }</code>), like their respective collection literals. A dictionary comprehension additionally uses a colon (<code>:</code>) to separate key-value pairs, and this is what distinguishes it from a set comprehension.</p>
<p>For example, if I wanted a dictionary comprehension that uses an integer between 1 and 100 as the key and the square of that number as the value, I would write this:</p>
<pre><code>squares = {n : n ** 2 for n in range(1,101)}
print(squares[2])
print(squares[7])
print(squares[11])</code></pre>
<p class="CodeListingCaption"><a id="listing10-47">Listing 10-47</a>: <em>squares_dictionary_comprehension.py</em></p>
<p>The key expression, on the left side of the colon, is evaluated before the value expression, on the right. I use the same loop for creating both key and value.</p>
<p>Be aware, like with list and set comprehensions, dictionary comprehensions are eager. The program will evaluate the dictionary comprehension until the <code>range()</code> iterable I’m using is exhausted.</p>
<p>Here’s the output:</p>
<pre><code>4
49
121</code></pre>
<p>That’s all there is to it! Again, besides the colon, everything is the same as in any other generator expression.</p>
<h2 id="h1-500920c10-0009">Hazards of Generator Expressions</h2>
<p class="BodyFirst">Generator expressions, along with the different types of comprehension, can be addictive, partly because one feels really smart when crafting them. There’s something about powerful one-liners that gets programmers very excited. We really like being clever with our code.</p>
<p>However, I must caution against going too crazy with generator expressions. As The Zen of Python reminds us:</p>
<blockquote class="blockquote">
<p class="Blockquote">Beautiful is better than ugly.</p>

<p class="Blockquote">… </p>
<p class="Blockquote">Simple is better than complex.</p>
<p class="Blockquote">Complex is better than complicated.</p>
<p class="Blockquote">…</p>
<p class="Blockquote"><span epub:type="pagebreak" title="280" id="Page_280"/>Sparse is better than dense.</p>
<p class="Blockquote">Readability counts.</p></blockquote>
<p>Generator expressions can be beautiful—but they can also become dense, unreadable messes when used unwisely. List comprehensions are especially vulnerable to abuse. I’ll lay out some examples of where list comprehensions and generator expressions aren’t suitable.</p>
<h3 id="h2-500920c10-0009">They Quickly Become Unreadable</h3>
<p class="BodyFirst">The following example appeared in a survey by Open edX. In the original, each list comprehension was on a single line. For the sake of reproducing it legibly, without giving my typesetter fits, I’ve taken the liberty of splitting each of the three list comprehensions across multiple lines. Unfortunately, it really doesn’t do much to improve things:</p>
<pre><code>primary = [
    c
    for m in status['members']
    if m['stateStr'] == 'PRIMARY'
    for c in rs_config['members']
    if m['name'] == c['host']
    ]

secondary = [
    c
    for m in status['members']
    if m['stateStr'] == 'SECONDARY'
    for c in rs_config['members']
    if m['name'] == c['host']
    ]

hidden = [
    m
    for m in rs_config['members']
    if m['hidden']
    ]</code></pre>
<p>Can you tell what’s going on? You probably could if you read it for a while, but why would you want to? The code is as clear as mud, and sure enough, it was rated as the most unreadable example in the survey.</p>
<p>List comprehensions and generator expressions are powerful, but it doesn’t take much for them to become unreadable like this. Since generator expressions essentially “flip” the order of statements, so the loop comes after the statement that relates to it, it is harder to comprehend the logic in this format. The above would be better written in the context of a traditional loop.</p>
<p>My colleague “grym” from Libera.Chat IRC shared an even more abhorrent example of how easily abused list comprehensions are:</p>
<pre><code>cropids = [self.roidb[inds[i]]['chip_order'][
    self.crop_idx[inds[i]] % len(self.roidb[inds[i]]['chip_order'])]
<span epub:type="pagebreak" title="281" id="Page_281"/>    for i in range(cur_from, cur_to)
]</code></pre>
<p>Don’t ask me what it does. None of us wanted to figure it out. My soul burns just reading it.</p>
<h3 id="h2-500920c10-0010">They Don’t Replace Loops</h3>
<p class="BodyFirst">Since generator expressions and comprehensions are so neat and compact, it might be tempting to write clever one-liners in place of garden variety <code>for</code> loops. Resist this temptation! Generator expressions are suited for creating lazy iterators, while list comprehensions should only be employed when you actually need to create a list.</p>
<p>The reason for this is best understood by studying an example. Imagine you were reading through someone else’s code and you encountered this:</p>
<pre><code>some_list = getTheDataFromWhereever()
[API.download().process(foo) for foo in some_list]</code></pre>
<p>The first thing that stands out is that, although a list comprehension is meant to create a list value, that value is not being stored anywhere. Anytime a value is implicitly discarded like this, it should be a warning that the pattern is being abused.</p>
<p>Second, you can’t tell at a glance whether the data in <code>some_list</code> is being mutated directly. This is a case of a list comprehension being used inappropriately, in place of a loop. It’s somewhat unreadable, as it obfuscates the behavior of the code, and it also makes debugging difficult.</p>
<p>This is one case where the author should have stuck with loops, which would have looked like this:</p>
<pre><code>some_list = getTheDataFromWhereever()
for foo in some_list:
    API.download().process(foo)</code></pre>
<p>In this form, it’s not so unexpected that the values in <code>some_list</code> are being mutated, although it’s still bad practice for a function to have side effects like this. Most importantly, debugging is easier.</p>
<h3 id="h2-500920c10-0011">They Can Be Hard to Debug</h3>
<p class="BodyFirst">The nature of a generator expression or comprehension is that you’re packing everything into one gigantic statement. The benefit of this is that you eliminate a bunch of intermediate steps. The drawback is . . . you eliminate a bunch of intermediate steps.</p>
<p>Think about debugging in a typical loop. You can step through it, one iteration at a time, using your debugger to observe the state of each variable as you go. You can also use error handling to deal with unusual edge cases.</p>
<p>None of that can help you in a generator expression, where either everything works or nothing works. You can try to parse through the errors <span epub:type="pagebreak" title="282" id="Page_282"/>and output to figure out what you did wrong, but I assure you, it’s a confusing experience.</p>
<p>You can avoid some of this madness by avoiding generator expressions or list comprehensions on your first version of the code. Write the logic the obvious way, using traditional loops, iterator tools, or normal generators (coming up). Once you know it’s working, <em>then and only then</em> should you collapse the logic into a generator expression, and <em>only</em> if you can do so without eschewing all your error handling (<code>try</code> statements).</p>
<p>This may sound like a lot of extra work, but I follow this exact pattern in competitive code golfing, especially when I’m up against the clock. My understanding of generator expressions is usually my main advantage against less-experienced competitors, but I <em>always</em> write the standard loop or generator first; I cannot afford to waste time debugging bad logic in a generator expression.</p>
<h3 id="h2-500920c10-0012">When to Use Generator Expressions</h3>
<p class="BodyFirst">It’s difficult to set a hard-and-fast rule on when generator expressions should be used. As always, the important factor is readability. Most of my preceding examples split the generator expression across multiple lines, but they’re primarily intended to be written on one line. If doing so results in code that is difficult to visually parse, think twice about using generator expressions at all.</p>
<p>In a way, a generator expression is to an iterator as a lambda is to a function, in that it’s particularly useful for defining a one-off iterator right where you’ll use it. You can even omit the extra parentheses around a generator expression when it’s the sole argument. A generator expression, like a lambda, is best suited for simple, one-off logic that would benefit from being declared right where it’s used.</p>
<p>When the purpose of this one-off iterator is to populate a list, a list comprehension would be used. The same is true of set comprehensions and dictionary comprehensions for their respective collections.</p>
<p>Generators are preferred over generator expressions whenever you’re working with more complicated logic. Because a generator expression follows the same syntactic structure as an ordinary function, it isn’t prone to becoming unreadable in the same way generator expressions are.</p>
<h2 id="h1-500920c10-0010">Simple Coroutines</h2>
<p class="BodyFirst">The <em>coroutine</em> is a type of generator that <em>consumes</em> data on demand, instead of producing data, and it waits patiently until it receives it. For example, you could write a coroutine to maintain a running average temperature; you can periodically send a new temperature to the coroutine, and it will immediately recalculate the average with each new value.</p>
<p>There are two kinds of coroutines. What I’m covering here is the <em>simple coroutine</em>. Later, when I cover concurrency, I’ll introduce the <em>native coroutine</em> <span epub:type="pagebreak" title="283" id="Page_283"/>(also known as the <em>asynchronous coroutine</em>), which employs and further builds on these concepts.</p>
<p>For the rest of this chapter, when I refer to <em>coroutines</em>, assume I’m talking about simple coroutines.</p>
<p>Because coroutines are generators, you can use <code>close()</code> and <code>throw() </code>with them. Control can be handed off to another coroutine, using <code>yield from</code>. Only <code>next()</code> will not work here, since you are sending values, rather than retrieving them; instead, you use <code>send()</code>.</p>
<p>For example, I want to count the number of vehicles (from the earlier <code>traffic()</code> generator) of a particular color in an iterative fashion. Here’s a coroutine that does that:</p>
<pre><code>from random import choice


def color_counter(color):
    matches = 0
    while True:
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> vehicle = yield
        if color in vehicle:
            matches += 1
        print(f"{matches} so far.")</code></pre>
<p class="CodeListingCaption"><a id="listing10-48">Listing 10-48</a>: <em>traffic_colors_coroutine.py:1a</em></p>
<p>The <code>color_counter()</code> coroutine function accepts a single argument: a string for the color of the vehicle being counted. This argument will be passed when the generator iterator is created.</p>
<p>I want this coroutine to receive data until I explicitly close it, so I use an infinite loop. The key difference between a generator and a coroutine is the location where the yield statement appears. Here, the <code>yield</code> expression is being <em>assigned</em> to something—specifically, to the name <code>vehicle</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The data sent to the coroutine is assigned to <code>vehicle</code>, which I can then process by checking whether the color matches and incrementing the count of vehicles that match. Finally, I print out the current count.</p>
<p>As I mentioned, I’ll reuse the infinite traffic generator from earlier to create the data:</p>
<pre><code>colors = ['red', 'green', 'blue', 'silver', 'white', 'black']
vehicles = ['car', 'truck', 'semi', 'motorcycle']


def traffic():
    while True:
        vehicle = choice(vehicles)
        color = choice(colors)
        yield f"{color} {vehicle}"</code></pre>
<p class="CodeListingCaption"><a id="listing10-49">Listing 10-49</a>: <em>traffic_colors_coroutine.py:2</em></p>
<p><span epub:type="pagebreak" title="284" id="Page_284"/>The usage of my <code>color_counter()</code> coroutine is not too different from that of a generator, but there are a few key differences:</p>
<pre><code>counter = color_counter('red')</code></pre>
<p class="CodeListingCaption"><a id="listing10-50">Listing 10-50</a>: <em>traffic_colors_coroutine.py:3</em></p>
<p>Before I can use the coroutine, I have to create a coroutine object (actually, a generator iterator) from the coroutine function. I bind this object to <code>counter</code>.</p>
<p>I send data to a coroutine by using its <code>send()</code> method. However, before a coroutine can receive data, it must be <em>primed</em> by passing <code>None</code> to <code>send()</code>:</p>
<pre><code>counter.send(None)  # prime the coroutine</code></pre>
<p class="CodeListingCaption"><a id="listing10-51">Listing 10-51</a>: <em>traffic_colors_coroutine.py:4a</em></p>
<p>Priming causes the coroutine to run up to its first <code>yield</code> statement. Without priming, whatever value is first sent is lost, as it’s the <code>yield</code> statement that receives the value sent in.</p>
<p>Alternatively, I could prime like this:</p>
<pre><code>next(counter)  # prime the coroutine</code></pre>
<p class="CodeListingCaption"><a id="listing10-52">Listing 10-52</a>: <em>traffic_colors_coroutine.py:4b</em></p>
<p>It doesn’t matter which you use. I prefer the technique in <a href="#listing10-51" id="listinganchor10-51">Listing 10-51</a>, because it makes it clear I’m priming a coroutine, rather than working with any old generator.</p>
<p>After priming, I can use the coroutine:</p>
<pre><code>for count, vehicle in enumerate(traffic(), start=1):
    if count &lt; 100:
        counter.send(vehicle)
    else:
        counter.close()
        break</code></pre>
<p class="CodeListingCaption"><a id="listing10-53">Listing 10-53</a>: <em>traffic_colors_coroutine.py:5a</em></p>
<p>I iterate over the <code>traffic()</code> generator, sending each value to the coroutine <code>counter</code> by using the <code>send()</code> method. The coroutine processes the data and prints out the current count of red vehicles.</p>
<p>In the context of my loop, once I’ve iterated through a hundred vehicles, I manually close the coroutine and break out of the loop.</p>
<p>Running this code produces the following redacted output:</p>
<pre><code>0 so far.
0 so far.
1 so far.
<var># --snip--</var>
19 so far.
<span epub:type="pagebreak" title="285" id="Page_285"/>19 so far.
19 so far.</code></pre>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2>	<p class="BoxBodyFirst">There is no <code>__send__()</code> special method. To implement coroutine-like behavior in a custom class, you would define <code>send()</code> as an ordinary member function.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c10-0013">Returning Values from a Coroutine</h3>
<p class="BodyFirst">In real projects, one very rarely wants to print the results and be done. For most coroutines to be useful, you need some way to retrieve the data being produced.</p>
<p>To do this with my color counter, I’ll change one line in my coroutine and drop the <code>print()</code> statement I no longer want, like this:</p>
<pre><code>def color_counter(color):
    matches = 0
    while True:
        vehicle = yield <b>matches</b>
        if color in vehicle:
            matches += 1</code></pre>
<p class="CodeListingCaption"><a id="listing10-54">Listing 10-54</a>: <em>traffic_colors_coroutine.py:1b</em></p>
<p>I place the name <code>matches</code> after the <code>yield</code> keyword to indicate that I want to yield the value bound to that variable. Because a coroutine instance is really a special kind of generator iterator, it can both accept and return values with the <code>yield</code> statement. In this case, on each iteration, a new value is accepted and assigned to <code>vehicle</code>, and then the current value of <code>matches</code> is yielded.</p>
<p>The usage is very similar; it requires just a simple change:</p>
<pre><code><b>matches = 0</b>
for count, vehicle in enumerate(traffic(), start=1):
    if count &lt; 100:
        <b>matches = </b>counter.send(vehicle)
    else:
        counter.close()
        break

<b>print(f"There were {matches} matches.")</b></code></pre>
<p class="CodeListingCaption"><a id="listing10-55">Listing 10-55</a>: <em>traffic_colors_coroutine.py:5b</em></p>
<p>Every time a value is sent via <code>counter.send()</code>, a value is also returned and assigned to <code>matches</code>. I print out this value after the loop is done, instead of seeing a running count.</p>
<p>The new output is now one line, such as this:</p>
<pre><code>There were 18 matches.</code></pre>
<h3 id="h2-500920c10-0014"><span epub:type="pagebreak" title="286" id="Page_286"/>Sequence of Behavior</h3>
<p class="BodyFirst">The order in which things happen in coroutines can be a little difficult to anticipate. To understand this, here is an oversimplified coroutine that only outputs its input:</p>
<pre><code>def coroutine():
    ret = None
    while True:
        print("...")
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> recv = <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> yield ret
      <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> print(f"recv: {recv}")
      <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> ret = recv


co = coroutine()
current = <span class="CodeAnnotationCode" aria-label="annotation5">❺</span> co.send(None)
<span class="CodeAnnotationHang" aria-label="annotation6">❻</span> print(f"current (ret): {current}")

for i in range(10):
  <span class="CodeAnnotationCode" aria-label="annotation7">❼</span> current = <span class="CodeAnnotationCode" aria-label="annotation8">❽</span> co.send(i)
  <span class="CodeAnnotationCode" aria-label="annotation9">❾</span> print(f"current (ret): {current}")

co.close()</code></pre>
<p class="CodeListingCaption"><a id="listing10-56">Listing 10-56</a>: <em>coroutine_sequence.py</em></p>
<p> Here’s the sequence of behavior when using a generator as both a generator and a coroutine like this:</p>
<ol class="decimal">
<li value="1">The coroutine is primed with <code>co.send(None)</code> <span class="CodeAnnotation" aria-label="annotation5">❺</span>, advancing it to the first <code>yield</code> statement <span class="CodeAnnotation" aria-label="annotation2">❷</span> and yielding the initial value of <code>ret</code> (<code>None</code>). This value is printed out external to the coroutine <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</li>
<li value="2">The first input to the coroutine (<code>0</code>) is accepted from <code>co.send()</code> <span class="CodeAnnotation" aria-label="annotation8">❽</span> and stored in <code>recv</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</li>
<li value="3">The value of <code>recv</code> (<code>0</code>) is printed out <span class="CodeAnnotation" aria-label="annotation3">❸</span> and then stored in <code>ret </code><span class="CodeAnnotation" aria-label="annotation4">❹</span>.</li>
<li value="4">The coroutine advances to the next <code>yield</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</li>
<li value="5">The current value of <code>ret</code> (<code>0</code>) is yielded <span class="CodeAnnotation" aria-label="annotation2">❷</span>, stored in <code>current</code> <span class="CodeAnnotation" aria-label="annotation7">❼</span>, and printed in the <code>for</code> loop <span class="CodeAnnotation" aria-label="annotation9">❾</span>. The <code>for</code> loop advances.</li>
<li value="6">The next input (<code>1</code>) is accepted from <code>co.send()</code> <span class="CodeAnnotation" aria-label="annotation8">❽</span> and stored in <code>recv</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</li>
<li value="7">The new value of <code>recv</code> (<code>1</code>) is printed out <span class="CodeAnnotation" aria-label="annotation2">❷</span> and then stored in <code>ret</code>.</li>
<li value="8">The coroutine advances to the next <code>yield</code>.</li>
<li value="9">The current value of <code>ret</code> (<code>1</code>) is yielded <span class="CodeAnnotation" aria-label="annotation2">❷</span>, stored in <code>current</code> <span class="CodeAnnotation" aria-label="annotation7">❼</span>, and printed in the <code>for</code> loop <span class="CodeAnnotation" aria-label="annotation9">❾</span>. The <code>for</code> loop advances.</li>
<li value="10">And so on and so forth.</li>
</ol>
<p>In simpler terms, the coroutine will always <code>yield</code> a value before it accepts a new value from <code>send()</code>. This is because the right side of the assignment expression is evaluated before the left side. The behavior is consistent <span epub:type="pagebreak" title="287" id="Page_287"/>with the rest of Python, even though it may feel a bit surprising in this context before you’re used to it.</p>
<h2 id="h1-500920c10-0011">What About Async?</h2>
<p class="BodyFirst">Some Python developers insist that simple coroutines have no place in modern Python code, that they’ve been entirely replaced by <em>native coroutines</em>—also known as <em>async coroutines</em>. This may be the case, but the difference in usage is nontrivial. Native coroutines have a number of advantages, but they have to be called differently. (I’ll cover <code>asyncio</code> and native coroutines in <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>.)</p>
<h2 id="h1-500920c10-0012">Wrapping Up</h2>
<p class="BodyFirst">In this chapter, I’ve covered the various forms of generator objects—generator expressions, comprehensions, and simple coroutines—and introduced infinite iterators.</p>
<p>Generators and coroutines make it possible to utilize lazy evaluation in your iterative code, wherein values are only evaluated on demand. When these features are utilized correctly, your code can process large amounts of data without hanging or crashing.</p>
<p>I’ll build on many of these features in <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>, when I introduce asynchrony.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="289" id="Page_289"/>11</span><br/>
<span class="ChapterTitle">Text IO and Context Managers</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">I find that a project doesn’t feel <em>real</em> until I start working with files. Text-based files, the most common way to store data, are the key to retaining state between program runs.</p>
<p>While it’s perfectly simple to open a text file in Python, there are many silent subtleties that are often overlooked until they bite you in the rear. Many developers make do with some idiosyncratic combination of techniques that appear to work but are far removed from the beauty and simplicity of idiomatic Python.</p>
<p>In this chapter, I’ll break down the two central components involved in working with text files: <em>streams</em> and <em>path-like objects</em>. I’ll cover the myriad ways of opening, reading from, and writing to files, discuss how to work with the filesystem, and wrap up with a whirlwind tour of some common file formats.</p>
<h2 id="h1-500920c11-0001"><span epub:type="pagebreak" title="290" id="Page_290"/>Standard Input and Output</h2>
<p class="BodyFirst">So far, we’ve taken functions like <code>print()</code> and <code>input()</code> for granted. They’re practically always the first functions a developer learns in a language, but they’re also an essential starting point for a true understanding of text input and output. Let’s take a deeper look.</p>
<h3 id="h2-500920c11-0001">Revisiting print()</h3>
<p class="BodyFirst">As you’ve seen throughout this book, the <code>print()</code> function takes a string argument and prints it on the screen. That is simple enough, but the functionality of <code>print()</code> does not end there. You can use <code>print()</code> to quickly and flexibly output multiple values in a number of ways, and as you’ll see in a later section, you can even use it to write to files.</p>
<h4 id="h3-500920c11-0001">Standard Streams</h4>
<p class="BodyFirst">To fully understand the potential of <code>print()</code>, you must understand streams. When you use <code>print()</code>, you send the string to the <em>standard output stream</em>, a special communication channel provided by your operating system. The standard output stream behaves like a queue: you push data, usually strings, to the stream, and these strings can be picked up in order by other programs or processes, notably the terminal. Your system sends all strings provided to <code>print()</code> to the standard output stream, by default.</p>
<p>Your system also has a <em>standard error stream</em> to display error messages. Normal output is sent to the standard output stream, and error-related output is sent to the standard error stream.</p>
<p>So far in this book, when I’ve wanted to print an error message, I’ve used an ordinary <code>print()</code> call, the same as for a normal message:</p>
<pre><code>print("Normal message")
print("Scary error occurred")</code></pre>
<p class="CodeListingCaption"><a id="listing11-1">Listing 11-1</a>: <em>print_error.py:1a</em></p>
<p>This is fine as long as the user only needs the error output to appear in the terminal. However, say the user wants to use the terminal to pipe all program output into files, so that normal output goes into one file and error output goes into the other. Here’s an example in bash:</p>
<pre><code>$ <b>python3 print_error.py &gt; output.txt 2&gt; error.txt</b>
$ <b>cat output.txt</b>
A normal message.
A scary error occurred.
$ <b>cat error.txt</b>
$</code></pre>
<p>The user would expect <em>output.txt</em> to contain <code>Normal message</code> and <em>error.txt</em> to contain <code>Scary error occurred</code>. However, because <code>print()</code> sends messages to the standard output stream by default, both messages got exported to <em>output.txt</em>. Meanwhile, <em>error.txt</em> is completely empty.</p>
<p><span epub:type="pagebreak" title="291" id="Page_291"/>To send the error text to the standard error stream instead, I have to specify it by using the <code>file=</code> keyword argument on <code>print()</code>:</p>
<pre><code><b>import sys</b>
print("Normal message")
print("Scary error occurred"<b>, file=sys.stderr</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing11-2">Listing 11-2</a>: <em>print_error.py:1b</em></p>
<p>I first import the <code>sys</code> module, which gives me access to <code>sys.stderr</code>, a handle to the standard error stream. I send the error message to the standard error stream by specifying the argument <code>file=sys.stderr</code> in my second <code>print()</code> call. The normal message still goes to standard output, as the default argument is <code>file=sys.stdout</code>.</p>
<p>Revising the shell session from before, the usage is the same, but you can see the outputs are now sent where they’re expected to be:</p>
<pre><code>$ <b>python3 print_error.py &gt; output.txt 2&gt; error.txt</b>
$ <b>cat output.txt</b>
A normal message.
$ <b>cat error.txt</b>
A scary error occurred.</code></pre>
<p>The ordinary message has been piped to the file <em>output.txt</em>, and the error message has been piped to the file <em>error.txt</em>. This is the standard expected behavior for output from command-line programs being used in this manner.</p>
<p>As the parameter name <code>file=</code> suggests, the <code>print()</code> function is not limited to the standard streams. In fact, as you’ll see in a moment, it is quite well suited to writing text to files.</p>
<h4 id="h3-500920c11-0002">Flush</h4>
<p class="BodyFirst">One important fact to know is that standard streams are implemented as <em>buffers</em>: data can be pushed to a buffer, which behaves like a queue. That data will wait there until it is picked up by the terminal, or whatever process or program is intended to display it. In the case of standard output and standard error, text is pushed to the stream buffer, and then the buffer is <em>flushed</em> when its contents are all printed to the terminal. Flushing doesn’t always happen when you expect, for a plethora of reasons (all beyond the scope of this book). On occasion, you will send a message with <code>print()</code> and then wonder why it hasn’t printed to the terminal yet.</p>
<p>Usually, it’s best to let the system decide when to flush the standard streams, instead of forcing it yourself. However, in some cases, you may want to force it. For example, you may want to add something to the end of a line already displayed on the terminal.</p>
<p>Here’s a simple progress indicator that does exactly that. I’ll use <code>time.sleep()</code> to indicate that some time-consuming process is happening, like a download. I want to ensure the user knows the program hasn’t crashed, so <span epub:type="pagebreak" title="292" id="Page_292"/>I display a “Downloading . . . ” message, adding another dot every tenth of a second:</p>
<pre><code>import time

print("Downloading", end='')
for n in range(20):
    print('.', end='', flush=True)
    time.sleep(0.1)
print("\nDownload completed!")</code></pre>
<p class="CodeListingCaption"><a id="listing11-3">Listing 11-3</a>: <em>progress_indicator.py</em></p>
<p>The <code>end=</code> keyword argument on <code>print()</code> prevents a new line from being printed. I’ll come back to this later. The important piece for the example is the <code>flush=</code> keyword argument. If I’d omitted that, the user wouldn’t have seen anything until the loop had finished, because the buffer would have waited for the newline character before writing out to the terminal. However, by forcing the buffer to flush, the line on the terminal updates on each loop iteration.</p>
<p>If you need all your <code>print()</code> calls to flush every time by default, you can run Python in <em>unbuffered mode</em>, by passing the <code>-u</code> flag to the Python interpreter when you invoke your program, as in <code>python3 -u -m mypackage</code>.</p>
<h4 id="h3-500920c11-0003">Printing Multiple Values</h4>
<p class="BodyFirst">The <code>print()</code> function can accept any number of ordered arguments, and each will be converted into strings using each value’s <code>__str__()</code> special method. This is a sort of quick and dirty alternative to formatting with f-strings.</p>
<p>For example, I might want to store an address in multiple pieces and then be able to print out the whole thing. I’ll initialize the individual values:</p>
<pre><code>number = 245
street = "8th Street"
city = "San Francisco"
state = "CA"
zip_code = 94103</code></pre>
<p class="CodeListingCaption"><a id="listing11-4">Listing 11-4</a>: <em>address_print.py:1</em></p>
<p>I could use formatted strings to put the address together:</p>
<pre><code>print(f"{number} {street} {city} {state} {zip_code}")</code></pre>
<p class="CodeListingCaption"><a id="listing11-5">Listing 11-5</a>: <em>address_print.py:2a</em></p>
<p>While this works, I can do the same thing without the f-string, resulting in a simpler <code>print()</code> statement:</p>
<pre><code>print(number, street, city, state, zip_code)</code></pre>
<p class="CodeListingCaption"><a id="listing11-6">Listing 11-6</a>: <em>address_print.py:2b</em></p>
<p><span epub:type="pagebreak" title="293" id="Page_293"/>The <code>print()</code> statement converts each argument to a string and then concatenates the pieces together, with a space between each piece (by default). In either case, the output is the same:</p>
<pre><code>245 8th Street San Francisco CA 94103</code></pre>
<p>The benefits of this <code>print()</code> statement without f-strings are readability and efficiency. Since the final output is nothing more than all the pieces concatenated together with spaces, and since I have no need to store the whole string in a single value in memory, the f-string is overkill.</p>
<p>Here’s another example of the <code>print()</code> function’s innate concatenating abilities. I can quickly generate a table of property values from a dictionary. First, here’s that dictionary:</p>
<pre><code>nearby_properties = {
    "N. Anywhere Ave.":
    {
        123: 156_852,
        124: 157_923,
        126: 163_812,
        127: 144_121,
        128: 166_356,
    },
    "N. Everywhere St.":
    {
        4567: 175_753,
        4568: 166_212,
        4569: 185_123,
    }
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-7">Listing 11-7</a>: <em>market_table_print.py:1</em></p>
<p>I want to print out a table, with the street, number, and formatted property value, separating each column with a tab character (<code>\t</code>). I’ll use an f-string first, just so you can see why I wouldn’t use that approach:</p>
<pre><code>for street, properties in nearby_properties.items():
    for address, value in properties.items():
        print(f"{street}\t{address}\t${value:,}")</code></pre>
<p class="CodeListingCaption"><a id="listing11-8">Listing 11-8</a>: <em>market_table_print.py:2a</em></p>
<p>While this produces the desired output (which I’ll show in a moment), the f-string adds an unnecessary layer of complexity. Since I’m separating each column with a tab character, I can once again make better use of <code>print()</code> instead:</p>
<pre><code>for street, properties in nearby_properties.items():
    for address, value in properties.items():
        print(<b>street, address, f"${value:,}", sep='\t'</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing11-9">Listing 11-9</a>: <em>market_table_print.py:2b</em></p>
<p><span epub:type="pagebreak" title="294" id="Page_294"/>The <code>sep=</code> argument allows me to define what string should be used between each of the values. This <code>sep</code> string is a space by default, as in <a href="#listing11-6" id="listinganchor11-6">Listing 11-6</a>, but here, I’m using a tab character (<code>\t</code>) as a separator instead.</p>
<p>I prefer this solution because it’s much more readable. I still use an f-string to format <code>value</code> to display the desired comma separator, lest I get uglier output like <code>$144121</code>. The values bound to <code>street</code> and <code>address</code> do not need any special treatment.</p>
<p>Here’s the output, which is the same for either version of the code:</p>
<pre><code><var># --snip--</var>
N. Anywhere Ave.        127     $144,121
N. Anywhere Ave.        128     $166,356
N. Everywhere St.       4567    $175,753
<var># --snip--</var></code></pre>
<p>Another advantage of this approach is that if I decide I want to separate columns with spaces and a vertical bar character, I only need to change the <code>sep=</code> argument:</p>
<pre><code>for street, properties in nearby_properties.items():
    for address, value in properties.items():
        print(street, address, f"${value:,}", <b>sep='  |  '</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing11-10">Listing 11-10</a>: <em>market_table_print.py:2c</em></p>
<p>If I had used f-strings, I would have needed to change the character I was using for each separation.</p>
<p>Here’s the new output:</p>
<pre><code><var># --snip--</var>
N. Anywhere Ave.  |  127  |  $144,121
N. Anywhere Ave.  |  128  |  $166,356
N. Everywhere St.  |  4567  |  $175,753
<var># --snip--</var></code></pre>
<p>The <code>print()</code> function also has an <code>end=</code> parameter, to determine what to append to the end of the output. By default, this is a newline character (<code>\n</code>), but you can change this in the same manner as <code>sep=</code>.</p>
<p>One common use is to set <code>end=\r</code>, which will cause the next printed line to overwrite the previous line. This is especially useful in status updates, such as progress messages.</p>
<h3 id="h2-500920c11-0002">Revisiting input()</h3>
<p class="BodyFirst">The <code>input()</code> function allows you to receive user input from the terminal, that is, from the <em>standard input stream</em>. Unlike with <code>print()</code>, the <code>input()</code> function has no extra features here, but it is useful to have a formal familiarity with <code>input()</code> moving forward.</p>
<p>The sole argument accepted by <code>input()</code> is <code>prompt</code>, an optional string that is printed to standard output without adding a trailing newline character. The value passed to <code>prompt=</code> is usually a message that informs the user what <span epub:type="pagebreak" title="295" id="Page_295"/>they’re supposed to input. This argument can be any value that can be converted to a string via its <code>__str__()</code> method, the same as in the ordered arguments passed to <code>print()</code>.</p>
<p>Here’s a basic prompt for an MLS number, perhaps intended as part of a property search program:</p>
<pre><code>mls = input("Search: MLS#")
print(f"Searching for property with MLS#{mls}...")</code></pre>
<p class="CodeListingCaption"><a id="listing11-11">Listing 11-11</a>: <em>search_input.py</em></p>
<p>Running this prompts the user for an <code>MLS</code> number and then reports that it’s searching for a property with that number:</p>
<pre><code>Search: MLS#<var>2092412</var>
Searching for property with MLS#2092412...</code></pre>
<p>There is absolutely nothing more to using <code>input()</code>.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2><p class="BoxBodyFirst">When reading code or tutorials written in Python 2, you’ll probably encounter the use of a <code>raw_input()</code> function. This was needed in Python 2 because the <code>input()</code> function at the time was generally impractical and terribly unsafe—it implicitly evaluated user input as an expression—and thus, Pythonistas avoided it like the plague. In Python 3, the old, dangerous <code>input()</code> was removed, and <code>raw_input() </code>was renamed to <code>input()</code>, so there’s no longer cause for concern.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c11-0002">Streams</h2>
<p class="BodyFirst">To work with any data file, you need to obtain a <em>stream</em>, also called a <em>file object</em> or <em>file-like object</em>, which offers methods for reading from and writing to that particular file in memory. There are two kinds of streams. <em>Binary streams</em>, which form the foundation of all streams, work with data in binary (1s and 0s). <em>Text streams</em> handle the encoding and decoding of text from binary.</p>
<p>Streams can work with more than just traditional files, such as your run-of-the-mill <em>.txt</em> files, Word documents, or what have you. The objects for the standard output (<code>sys.stdout</code>), standard error (<code>sys.stderr</code>), and standard input (<code>sys.stdin</code>) that you’ve already been using are, in fact, streams. Everything you know about the standard streams is the same on any stream.</p>
<p>For this chapter, I’ll focus exclusively on text streams. I’ll dig into binary data and binary streams in <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>.</p>
<p>You can create a stream that works with a file by using the built-in <code>open()</code> function. There is a <em>lot</em> to using this function, but I’ll start with the most simplistic usage.</p>
<p>The code in this entire section will assume every file is in the same directory as the Python module opening it. If the file is somewhere else on the machine, you’ll need a path, which is a separate topic I’ll explore later in this chapter.</p>
<p><span epub:type="pagebreak" title="296" id="Page_296"/>To read a file named <em>213AnywhereAve.txt</em> (the contents of which are identical to the output coming up), I’ll create a stream to work with it. Python beautifully handles creating the stream to the file in the background, so I only need to use the <code>open()</code> function:</p>
<pre><code>house = open("213AnywhereAve.txt")
print(house.read())
house.close()</code></pre>
<p class="CodeListingCaption"><a id="listing11-12">Listing 11-12</a>: <em>read_house_open.py:1a</em></p>
<p>The <code>open()</code> function returns a stream object—specifically, a <code>TextIOWrapper</code> object—that works with the contents of the <em>213AnywhereAve.txt</em> file. I bind this stream object to <code>house</code>.</p>
<p>Next, I read the entire contents of the file by calling the <code>read()</code> method on <code>house</code> and passing the string it returns directly to <code>print()</code>.</p>
<p>Once I’m done working with the file, I <em>must</em> close it, and I do that on the last line. It’s important not to leave file closing to the garbage collector, as that is neither guaranteed to work nor portable across all Python implementations. What’s more, when writing to a file, Python is not guaranteed to finish making changes to the file until <code>close()</code> is called. This means that if you forget to close before your program ends, your changes may be lost in part or in whole.</p>
<p>Assuming the <em>213AnywhereAve.txt</em> file exists in the same directory as this Python module, this code will output the entire contents of the file to the screen:</p>
<pre><code>Beautiful 3 bed, 2.5 bath on 2 acres.
Finished basement, covered porch.
Kitchen features granite countertops and new appliances.
Large fenced yard with mature trees and garden space.
$856,752<br/>
</code></pre>
<p>You can only read from this particular stream. Writing to a file requires me to open it differently, which I’ll return to shortly.</p>
<h2 id="h1-500920c11-0003">Context Manager Basics</h2>
<p class="BodyFirst">A <em>context manager</em> is a type of object that automatically handles its own cleanup tasks when program execution leaves a certain section of code, or <em>context</em>. This context is provided by a Python <code>with</code> statement. (This is the last of Python’s compound statements, alongside familiar friends such as <code>if</code>, <code>try</code>, and <code>def</code>,<code> </code>to name a few.) To really understand how this works, I’ll unpack the underlying logic and build up to the use of context managers.</p>
<p>There’s one remaining problem in <a href="#listing11-12" id="listinganchor11-12">Listing 11-12</a>. As it stands, the example is pretty safe, as <code>house.read()</code> isn’t going to fail unless I’m unable to open the file. In reality, though, I’d do more after opening than just printing out the contents of the file. I may process the data in any number of ways, store it in a collection, or search it for something in particular. There’s lots of <span epub:type="pagebreak" title="297" id="Page_297"/>room for errors and exceptions. With this approach, if I successfully open the file but experience any sort of exception while reading from or working with that file—say, a <code>KeyError</code> if I tried to read it into a dictionary—the <code>close()</code> method would never get called.</p>
<p>To get around this, I can wrap the <code>close()</code> call in the <code>finally</code> clause of a <code>try</code> statement:</p>
<pre><code>house = open("213AnywhereAve.txt")
<b>try:</b>
    print(house.read())
<b>finally:</b>
    house.close()</code></pre>
<p class="CodeListingCaption"><a id="listing11-13">Listing 11-13</a>: <em>read_house_open.py:1b</em></p>
<p>If the file <em>213AnywhereAve.txt</em> does not exist, it will raise a <code>FileNotFoundError</code> exception. If I’m able to open it successfully, I can try to <code>read()</code> from the <code>house</code> stream. I’m not catching any exceptions, so they’ll automatically bubble up from this <code>try</code> statement. Because the <code>close()</code> call is in the <code>finally</code> clause, it will be called whether there’s an error or not.</p>
<p>In practice, though, always remembering to call <code>close()</code> is utterly impractical, not to mention a royal pain. If you forget, or if the program terminates before you can call <code>close()</code>, all sorts of pesky bugs can result.</p>
<p>Thankfully, all stream objects are context managers, so they can clean up after themselves with a <code>with</code> statement, encapsulating that entire <code>try</code>-<code>finally</code> logic (<a href="#listing11-13" id="listinganchor11-13">Listing 11-13</a>) into a single statement:</p>
<pre><code><b>with </b>open("213AnywhereAve.txt")<b> as house:</b>
    print(house.read())</code></pre>
<p class="CodeListingCaption"><a id="listing11-14">Listing 11-14</a>: <em>read_house_open.py:1c</em></p>
<p>This opens the <em>213AnywhereAve.txt</em> file, binds the stream to <code>house</code>, and then runs the line of code for reading and printing from that file. There’s no need for a manual call to <code>house.close()</code>, because the <code>with</code> statement handles that automatically in the background.</p>
<p>I’ll dig into the mechanics of <code>with</code> more later on, but as it is the canonical way of working with (most) streams, I’ll use it exclusively from here on out.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2><p class="BoxBodyFirst">Don’t ever use <code>with</code> on the standard streams (<code>sys.stdout</code>, <code>sys.stderr</code>, and <code>sys.stdin</code>). Using <code>with</code> on standard streams will call <code>close()</code> on them, at which point, <em>you can’t use them</em> without restarting your Python instance! There are (convoluted) ways of reopening the standard streams, but honestly, it’s best not to close them to begin with.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c11-0004">File Modes</h2>
<p class="BodyFirst">The <code>open()</code> function optionally accepts a second argument: <em>mode=</em>, which should be a string dictating how the file should be opened, which in turn <span epub:type="pagebreak" title="298" id="Page_298"/>defines what operations may be performed on the stream object—reading, writing, and so on. If you don’t pass a <code>mode=</code> argument, Python uses <code>mode='r'</code>, which opens the file for reading only.</p>
<p>There are eight different file modes for text-based files (see <a href="#table11-1" id="tableanchor11-1">Table 11-1</a>), and the behavior of each is a little different. The base modes are as follows:</p>
<ul>
<li><code>r</code> opens the file for <em>reading</em>.</li>
<li><code>w</code> opens the file for <em>writing</em>; it truncates (erases) the file contents first.</li>
<li><code>a</code> opens the file for <em>append</em> writing (that is, writing to the end of the existing file).</li>
<li><code>x</code> <em>creates</em> a new file and opens it for writing; the file must not already exist.</li>
</ul>
<p>Adding the addition (<code>+</code>) flag adds either reading or writing, whichever is missing from the mode. The most important usage is the mode <code>r+</code>, which allows you to both read from and write to the file <em>without</em> the contents being erased first.</p>
<p>The behavior of each mode can feel a bit unexpected at times. <a href="#table11-1">Table 11-1</a>, which is based in part on a Stack Overflow answer by industryworker3595112 (see <a href="https://stackoverflow.com/a/30931305/472647/" class="LinkURL">https://stackoverflow.com/a/30931305/472647/</a>), breaks down the functionalities of the modes.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table11-1">Table 11-1:</a> File Modes</p></figcaption>
<table id="table-500920c11-0001" border="1">
<thead>
<tr>
<td><b>Functionalities</b></td>
<td colspan="8"><b>Modes</b></td>
</tr>
</thead>
<tbody>
<tr>
<td/>
<td><b><code>r</code></b></td>
<td><b><code>r+</code></b></td>
<td><b><code>w</code></b></td>
<td><b><code>w+</code></b></td>
<td><b><code>a</code></b></td>
<td><b><code>a+</code></b></td>
<td><b><code>x</code></b></td>
<td><b><code>x+</code></b></td>
</tr>
<tr>
<td>Allow read</td>
<td>✓</td>
<td>✓</td>
<td/>
<td>✓</td>
<td/>
<td>✓</td>
<td/>
<td>✓</td>
</tr>
<tr>
<td>Allow write</td>
<td/>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Can create new file</td>
<td/>
<td/>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Can open existing file</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td/>
<td/>
</tr>
<tr>
<td>Erase file contents first</td>
<td/>
<td/>
<td>✓</td>
<td>✓</td>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td>Allow seek</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td/>
<td>✓*</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Initial position at start</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td/>
<td/>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Initial position at end</td>
<td/>
<td/>
<td/>
<td/>
<td>✓</td>
<td>✓</td>
<td/>
<td/>
</tr>
</tbody>
</table>
</figure>
*Only allows seek on read
<p>In a stream, the <em>position</em> dictates where you read to and write from within the file. The <code>seek()</code> method allows you to change this position, if the mode supports it. By default, the position will be at either the start or the end of the file. I’ll cover this in depth in a later section.</p>
<p>You can also use the <code>mode=</code> parameter to switch between <em>text mode</em> (<code>t</code>), which is the default, and <em>binary mode</em> (<code>b</code>). In <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>, I’ll work exclusively in binary mode. For now, at least be aware of which mode you’re opening a file in. For example, the argument <code>mode='r+t'</code> opens the file in read-write text mode, and it is the same as <code>mode='r+'</code>. By contrast, <code>mode='r+b'</code> opens <span epub:type="pagebreak" title="299" id="Page_299"/>the file in read-write binary mode. For this entire chapter, I’ll only use the default text mode.</p>
<p>When you’re opening a file in read mode (<code>r</code> or <code>r+</code>), the file <em>must</em> already exist. If it doesn’t, the <code>open()</code> function will raise <code>FileNotFoundError</code>.</p>
<p>Create mode (<code>x</code> or <code>x+</code>) expects precisely the opposite: the file <em>must not</em> already exist. If it does, the <code>open()</code> function will raise <code>FileExistsError</code>.</p>
<p>Write mode (<code>w</code> or <code>w+</code>) and append mode (<code>a</code> or <code>a+</code>) have neither of these problems. If the file exists, it will be opened; if it doesn’t, it will be created.</p>
<p>If you attempt to write to a stream opened only for reading (<code>r</code>) or read from a stream opened only for writing (<code>w</code>, <code>a</code>, or <code>x</code>), that read or write operation will raise the <code>io.UnsupportedOperation</code> error.</p>
<p>If you want to check in advance which operations a stream supports, use the <code>readable()</code>, <code>writable()</code>, or <code>seekable()</code> methods on the stream. For example:</p>
<pre><code>with open("213AnywhereAve.txt", 'r') as file:
    print(file.readable())  # prints 'True'
    print(file.writable())  # prints 'False'
    print(file.seekable())  # prints 'True'</code></pre>
<p class="CodeListingCaption"><a id="listing11-15">Listing 11-15</a>: <em>check_stream_capabilities.py</em></p>
<h2 id="h1-500920c11-0005">Reading Files</h2>
<p class="BodyFirst">To read from a file, you first acquire a stream, opening it in one of the readable modes (<code>'r'</code>, <code>'r+'</code>, <code>'w+'</code>, <code>'a+'</code>, or <code>'x+'</code>). From there, you can read in one of four ways: <code>read()</code>, <code>readline()</code>, <code>readlines()</code>, or iteration.</p>
<p>For all of the examples in this section, I’ll read from the following text file:</p>
<pre><code>78 Somewhere Road, Anytown PA<br/>
Tiny 2-bed, 1-bath bungalow. Needs repairs.
Built in 1981; original kitchen and appliances.
Small backyard with old storage shed.
Built on ancient burial ground.
$431,998<br/>
</code></pre>
<p class="CodeListingCaption"><a id="listing11-16">Listing 11-16</a>: <em>78SomewhereRd.txt</em></p>
<h3 id="h2-500920c11-0003">The read() Method</h3>
<p class="BodyFirst">I can use the <code>read()</code> method to read the complete contents of the <code>78SomewhereRd.txt</code> file like this:</p>
<pre><code>with open('78SomewhereRd.txt', 'r') as house:
    contents = house.read()
    print(type(contents))  # prints &lt;class 'str'&gt;
    print(contents)</code></pre>
<p class="CodeListingCaption"><a id="listing11-17">Listing 11-17</a>: <em>read_house.py:1a</em></p>
<p><span epub:type="pagebreak" title="300" id="Page_300"/>After acquiring the stream <code>house</code>, which I opened in read mode, I call the <code>read()</code> method to read the entire file in as a single string, which I bind to <code>contents</code>. Each of the lines in the <em>78SomewhereRd.txt</em> file ends with a newline character (<code>\n</code>), and those are retained in the string. If I print <code>contents</code> as a raw string via <code>repr()</code>, you can see the literal newline characters:</p>
<pre><code>    print(repr(contents))</code></pre>
<p>This line of code outputs the following (redacted for brevity):</p>
<pre><code>'78 Somewhere Road, Anytown PA\nTiny 2 bed, 1 bath <var>#</var> <var>--snip--</var>'</code></pre>
<p>(Remember, those literal <code>\n</code> characters are only there because I printed the raw string. A normal print of contents would recognize the newline characters and create new lines accordingly.)</p>
<p>By default, <code>read()</code> will read characters until the end of the file is encountered. You can alter this behavior with the <code>size=</code> argument, which takes a maximum number of characters to read. For example, to read a maximum of 20 characters from the file (and less if the end of the file is encountered first), I would do the following:</p>
<pre><code>with open('78SomewhereRd.txt', 'r') as house:
    <b>print(house.read(20))</b></code></pre>
<p class="CodeListingCaption"><a id="listing11-18">Listing 11-18</a>: <em>read_house.py:1b</em></p>
<p>This would output the following:</p>
<pre><code>78 Somewhere Road, A</code></pre>
<h3 id="h2-500920c11-0004">The readline() Method</h3>
<p class="BodyFirst">The <code>readline()</code> method behaves exactly like <code>read()</code>, except that it reads only up to and including a newline (<code>\n</code>), instead of just the end of the file. I can use this to read the first two lines of the file. As before, I’m using <code>repr()</code> to show the raw strings, as I want to actually <em>see</em> the newline characters for the sake of the example:</p>
<pre><code>with open('78SomewhereRd.txt', 'r') as house:
    line1 = house.readline()
    line2 = house.readline()
    print(repr(line1))
    print(repr(line2))</code></pre>
<p class="CodeListingCaption"><a id="listing11-19">Listing 11-19</a>: <em>readline_house.py</em></p>
<p>The <code>house</code> stream remembers my position in the file, so after each call to <code>readline()</code>, the stream position is set to the beginning of the next line. <span epub:type="pagebreak" title="301" id="Page_301"/>Running this code outputs the first two lines, which I print as raw strings so I can see the literal newline characters:</p>
<pre><code>'78 Somewhere Road, Anytown PA\n'
'Tiny 2 bed, 1 bath bungalow.\n'</code></pre>
<p>The <code>readline()</code> method also has a <code>size=</code> positional argument, which works like <code>read(size=)</code>, except that it will stop at the first newline it encounters if the size is greater than the line’s length.</p>
<h3 id="h2-500920c11-0005">The readlines() Method</h3>
<p class="BodyFirst">I can read all the lines in the file at once as a list of strings, using <code>readlines()</code>:</p>
<pre><code>with open('78SomewhereRd.txt', 'r') as house:
    lines = house.readlines()
    for line in lines:
        print(line.strip())</code></pre>
<p class="CodeListingCaption"><a id="listing11-20">Listing 11-20</a>: <em>readlines_house.py</em></p>
<p>Each individual line is stored in a string, and all the strings are stored in the list <code>lines</code>. Once I’ve read all of the lines, I’ll print each one out, removing the trailing newline character from each string by using the <code>strip()</code> method on the string object. This removes any leading and trailing whitespace characters, including newlines.</p>
<p>Running that code outputs this:</p>
<pre><code>78 Somewhere Road, Anytown PA
Tiny 2-bed, 1-bath bungalow. Needs repairs.
Built in 1981; original kitchen and appliances.
Small backyard with old storage shed.
Built on ancient burial ground.
$431,998</code></pre>
<p>The <code>readlines()</code> method has a <code>hint=</code> parameter, which is similar to the <code>size=</code> parameter on <code>read()</code>. The critical difference is that <code>readlines()</code> <em>always</em> reads entire lines. If the number of characters specified in <code>hint=</code> is short of the next newline, <code>readlines()</code> will still read up to (and including) that next newline.</p>
<h3 id="h2-500920c11-0006">Reading with Iteration</h3>
<p class="BodyFirst">Streams themselves are iterators—they implement the <code>__iter__()</code> and <code>__next__()</code> special methods. This means I can iterate over a stream directly!</p>
<pre><code>with open('78SomewhereRd.txt', 'r') as house:
    for line in house:
        print(line.strip())</code></pre>
<p class="CodeListingCaption"><a id="listing11-21">Listing 11-21</a>: <em>iterate_house.py</em></p>
<p><span epub:type="pagebreak" title="302" id="Page_302"/>The output is the same as in the last example, but this iterative approach doesn’t have the overhead of creating a list I’ll only throw away after printing.</p>
<p>If you’re only reading a file once, direct iteration over the stream is usually going to be the cleaner and (probably) more efficient solution.</p>
<p>On the other hand, if you need to access the contents of a file more than once in your program’s execution, you’ll almost always want to read the data into memory—that is, to read it from the stream and store it in a typical Python collection or other value. It’s always faster to read from a value in memory than from a file!</p>
<h2 id="h1-500920c11-0006">Stream Position</h2>
<p class="BodyFirst">After every read and write operation, your position in the stream will change. You can use the <code>tell()</code> and <code>seek()</code> methods to work with the stream position.</p>
<p>The <code>tell()</code> method returns your current stream position as a positive integer, representing the number of characters from the start of the file.</p>
<p>The <code>seek()</code> method allows you to move back and forth within a stream, character by character. When working with text streams, it accepts one argument: a positive integer representing a new position to move to, represented by the number of characters from the beginning. This method works on any stream, as long as it isn’t opened in append mode (<code>'a'</code> or <code>'a+'</code>).</p>
<p>The most common use is to jump to the beginning of the file with <code>seek(0)</code>. To demonstrate that, I’ll print out the first line of the <em>78SomewhereRd.txt</em> file three times:</p>
<pre><code>with open('78SomewhereRd.txt', 'r') as house:
    for _ in range(3):
        print(house.readline().strip())
        house.seek(0)</code></pre>
<p class="CodeListingCaption"><a id="listing11-22">Listing 11-22</a>: <em>iterate_house.py</em></p>
<p>After opening the file, I loop three times. On each iteration of the loop, I print out the current line, with the newline removed with <code>strip()</code>. Then, I reposition the stream at the beginning of the file, before the next loop iteration.</p>
<p>The output is as follows:</p>
<pre><code>78 Somewhere Road, Anytown PA
78 Somewhere Road, Anytown PA
78 Somewhere Road, Anytown PA</code></pre>
<p>Additionally, you can skip to the end of the stream with <code>seek(0, 2)</code>, meaning you’re moving <code>0</code> positions away from the end of the file (a <code>whence</code> of <code>2</code>). When doing this, you must provide <code>0</code> as the first argument and <code>2</code> as the second argument; nothing else works for this.</p>
<p><span epub:type="pagebreak" title="303" id="Page_303"/>The <code>seek()</code> method can also be used to skip to other stream positions, not just the start or the end. A trivial demonstration of this would be to skip one character each time I read the opening line:</p>
<pre><code>with open('78SomewhereRd.txt', 'r') as house:
    for <b>n</b> in range(<b>10</b>):
        <b>house.seek(n)</b>
        print(house.readline().strip())</code></pre>
<p class="CodeListingCaption"><a id="listing11-23">Listing 11-23</a>: <em>iterate_house_mangle.py</em></p>
<p>Instead of passing <code>0</code> to <code>seek()</code>, I’m passing <code>n</code>, the iteration count from the loop, before reading the line. On each iteration, the first line is printed again, but with one less character at the beginning:</p>
<pre><code>78 Somewhere Road, Anytown PA
8 Somewhere Road, Anytown PA
Somewhere Road, Anytown PA
Somewhere Road, Anytown PA
omewhere Road, Anytown PA
mewhere Road, Anytown PA
ewhere Road, Anytown PA
where Road, Anytown PA
here Road, Anytown PA
ere Road, Anytown PA</code></pre>
<p>That’s an interesting example, though it’s not very useful. Don’t worry—I’ll employ <code>seek()</code> in a more practical fashion in some upcoming examples.</p>
<h2 id="h1-500920c11-0007">Writing Files</h2>
<p class="BodyFirst">The first thing to remember about writing to a stream is that you’re always <em>overwriting</em>, never <em>inserting</em>! This doesn’t matter when you’re appending to the end of a file, but in all other cases, it can cause confusion and undesired results.</p>
<p>When modifying a file, read the contents into memory, modify the file there, and then write it out again, to reduce the chances of obliterating data because of a bug. You can write out the new data either in place or to a temporary file that you move into place. I’ll introduce the latter technique later on in this chapter, when I discuss the <code>pathlib</code> module. For now, I’ll just overwrite files in place. Either technique will prevent a lot of annoying and destructive bugs.</p>
<p>There are three ways to write to a stream: the <code>write()</code> method, the <code>writelines()</code> method, and the <code>print()</code> function. Before using any of these, you must be certain your stream is open in a writable file mode (anything except <code>'r'</code>) and know your current stream position! All file modes but one have an initial stream position at the beginning of the file. The exception is the append mode (<code>'a'</code> and <code>'a+'</code>), which has an initial position at the end of the file. As you read from and write to the stream, that position will change.</p>
<h3 id="h2-500920c11-0007"><span epub:type="pagebreak" title="304" id="Page_304"/>The write() Method</h3>
<p class="BodyFirst">The <code>write()</code> method writes the given string to the file, starting at the current stream position, and it returns an integer representing how many characters it wrote to the file. Remember, though, it overwrites any data that’s in the way, from the stream position until the end of the new data. To prevent accidental data loss, read the file into memory, modify the data there, and then write it back out to the same file.</p>
<p>That property description in <em>78SomewhereRd.txt</em> isn’t very appealing. I’ll write a program to improve the description and write the updated real estate listing to the file:</p>
<pre><code>with open('78SomewhereRd.txt', 'r+') as real_estate_listing:
    contents = real_estate_listing.read()</code></pre>
<p class="CodeListingCaption"><a id="listing11-24">Listing 11-24</a>: <em>improve_real_estate_listing.py:1a</em></p>
<p>First, I open the file in read-write mode. Instead of directly modifying the file contents via the stream, I’ll read the file’s data into memory as a string, binding it to <code>contents</code>. I’ll revise the description by working on this string, rather than with the stream itself:</p>
<pre><code>    contents = contents.replace('Tiny', 'Cozy')
    contents = contents.replace('Needs repairs', 'Full of potential')
    contents = contents.replace('Small', 'Compact')
    contents = contents.replace('old storage shed', 'detached workshop')
    contents = contents.replace('Built on ancient burial ground.',
                                'Unique atmosphere.')</code></pre>
<p class="CodeListingCaption"><a id="listing11-25">Listing 11-25</a>: <em>improve_real_estate_listing.py:2a</em></p>
<p>I use the <code>replace()</code> string method to replace the unappealing words and phrases with more attractive ones.</p>
<p>Once I’m happy with the new version of my string, I can write it out to the file:</p>
<pre><code>    real_estate_listing.seek(0)
    real_estate_listing.write(contents)</code></pre>
<p class="CodeListingCaption"><a id="listing11-26">Listing 11-26</a>: <em>improve_real_estate_listing.py:3a</em></p>
<p>I position myself at the start of the file, since I want to overwrite everything there, using <code>real_estate_listing.seek(0)</code>. Then, I write the new contents of the file. Any of the old contents that are in the way are overwritten.</p>
<p>The last remaining trouble is that the new contents are shorter than the old contents, so some old data will be left hanging out at the end of the file. After <code>write()</code>, the stream position is at the end of the new data I just wrote, so I can clean up the leftovers from the old data with this:</p>
<pre><code>    real_estate_listing.truncate()</code></pre>
<p class="CodeListingCaption"><a id="listing11-27">Listing 11-27</a>: <em>improve_real_estate_listing.py:4</em></p>
<p><span epub:type="pagebreak" title="305" id="Page_305"/>By default, the <code>truncate()</code> method erases everything from the current stream position through to the end of the file. It does this by truncating (or shortening) the file to a given number of bytes, which can be passed as an argument. If no explicit size is passed in, <code>truncate()</code> uses the value provided by the <code>tell()</code> method, which corresponds to the current stream position.</p>
<p>Once the flow leaves the <code>with</code> statement, the stream is flushed and closed, ensuring the changes to the file are written.</p>
<p>That program doesn’t output anything on the command line. If I open the <em>78SomewhereRd.txt</em> file, I can see the new description:</p>
<pre><code>78 Somewhere Road, Anytown PA
Cozy 2-bed, 1-bath bungalow. Full of potential.
Built in 1981; original kitchen and appliances.
Compact backyard with detached workshop.
Unique atmosphere.
$431,998<br/>
</code></pre>
<h3 id="h2-500920c11-0008">The writelines() Method</h3>
<p class="BodyFirst">Just as <code>readlines()</code> stores the contents of the file as a list of strings, <code>writelines()</code> writes out a list of strings to a file. That is all it does. The <code>writelines()</code> method doesn’t insert newline characters at the end of each string in the list provided to it. The sole difference between <code>write()</code> and <code>writelines()</code> is that the latter accepts a list of strings, instead of just a single string, and returns nothing.</p>
<p>I can modify the file using <code>writelines()</code>. For this example, I restored the <em>78SomewhereRd.txt</em> file to what it was in <a href="#listing11-16" id="listinganchor11-16">Listing 11-16</a>.</p>
<pre><code>with open('78SomewhereRd.txt', 'r+') as real_estate_listing:
    contents = real_estate_listing.<b>readlines()</b></code></pre>
<p class="CodeListingCaption"><a id="listing11-28">Listing 11-28</a>: <em>improve_real_estate_listing.py:1b</em></p>
<p>I open the file <em>78SomewhereRd.txt</em> as before, but this time, I read the contents in with <code>real_estate_listing.readlines()</code>, which returns a list of strings I bind to the name <code>contents</code>.</p>
<p>Next, I make my changes to the description by modifying that list of strings. Once again, I’m not working with the stream here at all, but rather with the list of strings containing the data I read from the stream.</p>
<pre><code><b>    new_contents = []</b>
<b>    for line in contents:</b>
<b>        line = line.</b>replace('Tiny', 'Cozy')
<b>        line = line.</b>replace('Needs repairs', 'Full of potential')
<b>        line = line.</b>replace('Small', 'Compact')
<b>        line = line.</b>replace('old storage shed', 'detached workshop')
<b>        line = line.</b>replace('Built on ancient burial ground',
                            'Unique atmosphere')
        <b>new_contents.append(line)</b></code></pre>
<p class="CodeListingCaption"><a id="listing11-29">Listing 11-29</a>: <em>improve_real_estate_listing.py:2b</em></p>
<p><span epub:type="pagebreak" title="306" id="Page_306"/>I iterate over each line in <code>contents</code>, make the necessary substitutions, and store the modified lines in a new list, <code>new_contents</code>. I’ll be the first to admit that this implementation is much less efficient than the version using <code>write()</code>, but this technique becomes useful when you’re working with many lines that need to be individually processed.</p>
<p>Finally, I can write out the new file contents using <code>writelines()</code>:</p>
<pre><code>    real_estate_listing.seek(0)
    real_estate_listing.<b>writelines(new_contents)</b>
    real_estate_listing.truncate()</code></pre>
<p class="CodeListingCaption"><a id="listing11-30">Listing 11-30</a>: <em>improve_real_estate_listing.py:3b-4</em></p>
<p>I pass the list of strings to <code>writelines()</code>. Because the newline character was retained at the end of each line as it was read in by <code>readlines()</code>, those same newline characters are being written out. If I had removed them, however, I would have had to add them back in manually before calling <code>writelines()</code>.</p>
<p>The output is the same for the example in the previous section.</p>
<h3 id="h2-500920c11-0009">Writing Files with print()</h3>
<p class="BodyFirst">You know that <code>print()</code> outputs data using the <code>sys.stdout</code> stream by default, but you can override this by passing a stream to the <code>file=</code> argument. One particular use for this is to conditionally output either to the terminal or to a file. The simple formatting features on <code>print()</code> make it an excellent alternative to <code>write()</code>, in some cases.</p>
<p>The rules of usage are identical to <code>write()</code> and <code>writelines()</code>: you must have a stream that is writable, and you must be mindful of the stream position.</p>
<p>To demonstrate this, I’ll rewrite the real estate listings table produced by <a href="#listing11-14" id="listinganchor11-14">Listing 11-14</a> to output to a file, instead of the standard output. I’ll reuse the <code>nearby_properties</code> dictionary from <a href="#listing11-7" id="listinganchor11-7">Listing 11-7</a>:</p>
<pre><code>nearby_properties = {
    "N. Anywhere Ave.":
    {
        123: 156_852,
        124: 157_923,
        126: 163_812,
        127: 144_121,
        128: 166_356
    },
    "N. Everywhere St.":
    {
        4567: 175_753,
        4568: 166_212,
        4569: 185_123
    }
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-31">Listing 11-31</a>: <em>print_file_real_estate_listing.py:1</em></p>
<p><span epub:type="pagebreak" title="307" id="Page_307"/>Here’s my revised code for generating the real estate listings table:</p>
<pre><code><b>with open('listings.txt', 'w') as real_estate_listings:</b>
    for street, properties in nearby_properties.items():
        for address, value in properties.items():
            print(street, address, f"${value:,}",
                  sep='  |  ',
                  <b>file=real_estate_listings</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing11-32">Listing 11-32</a>: <em>print_file_real_estate_listings.py:2</em></p>
<p>I open the file <em>listings.txt</em> in write mode, since I want to either create or completely replace that file when this code runs. The loop iterating over <code>nearby_properties</code> and the call to <code>print()</code> are both essentially unchanged from before. The difference here is that I pass the <code>real_estate_listings</code> stream to the <code>file=</code> parameter of <code>print()</code>.</p>
<p>The output is the same as before, but it is written to the <em>listings.txt</em> file instead of being printed to the terminal:</p>
<pre><code><var># --snip--</var>
N. Anywhere Ave.  |  127  |  $144,121
N. Anywhere Ave.  |  128  |  $166,356
N. Everywhere St. |  4567 |  $175,753
<var># --snip--</var></code></pre>
<h3 id="h2-500920c11-0010">Line Separators</h3>
<p class="BodyFirst">If you have any experience with writing portable code, you may remember that in Windows operating systems, lines are separated with both the carriage return and the newline (<code>\r\n</code>), while only the newline (<code>\n</code>) is used in UNIX systems. This difference can be a royal pain when working with files in many languages.</p>
<p>On the other hand, Python streams abstract this difference out behind the scenes. When writing to a stream in text mode using <code>print()</code>, <code>write()</code>, or <code>writelines()</code>, you only ever use the <em>universal newline</em>—which is the newline character (<code>\n</code>)—as your line separator. Python will always substitute the system-appropriate line separator.</p>
<p>In the same way, when reading from files using <code>read()</code>, <code>readline()</code>, or <code>readlines()</code>, you only need to work with the newline character as the line separator.</p>
<h2 id="h1-500920c11-0008">Context Manager Details</h2>
<p class="BodyFirst">So far in this chapter, I’ve used a context manager via the <code>with</code> statement every time I’ve opened a file, to idiomatically ensure streams are closed as soon as they’re no longer needed.</p>
<p>Like many of Python’s compound statements, <code>with</code> statements utilize certain special methods to work with objects. This means <code>with</code> is not limited to streams: it can be made to handle virtually any situation that calls for <code/><span epub:type="pagebreak" title="308" id="Page_308"/>try-finally logic. To demonstrate this, I’ll unpack precisely how the <code>with</code> statement interfaces with streams, and then I’ll apply that knowledge to a custom class.</p>
<h3 id="h2-500920c11-0011">How Context Managers Work</h3>
<p class="BodyFirst">For an object to be a context manager, it must implement two special methods: <code>__enter__()</code> and <code>__exit__()</code>.</p>
<p>Streams implement both of these methods. The <code>__exit__()</code> method closes the stream, eliminating the need to remember to manually close the stream. </p>
<p>The <code>__enter__()</code> method is responsible for any setup before the context manager is used. This method doesn’t do anything interesting in the case of a stream, although some context manager classes make more use of <code>__enter__()</code>, as you’ll see in the custom context manager example later.</p>
<p>According to PEP 343, which defined context managers, the <code>with</code> compound statement is roughly equivalent to this:</p>
<pre><code>VAR = EXPR
VAR.__enter__()
try:
    BLOCK
finally:
    VAR.__exit__()</code></pre>
<p>The expression passed to the <code>with</code> statement is used to initialize an object. The <code>__enter__()</code> method is called on that object to perform whatever tasks should be completed before the object is used. (Again, in the case of streams, this method does nothing.) Next, the suite of the <code>with</code> statement is called within the context of a <code>try</code> clause. Whether it succeeds or fails, the <code>__exit__()</code> method will be called, usually to perform any necessary cleanup tasks on the object.</p>
<p>Recalling the example from <a href="#listing11-17" id="listinganchor11-17">Listing 11-17</a>, if Python didn’t have <code>with</code> statements, I’d need to use the following code to ensure a file was closed, whether there was an error or not:</p>
<pre><code>real_estate_listing = open("213AnywhereAve.txt")
try:
    print(real_estate_listing.read())
finally:
    real_estate_listing.close()</code></pre>
<p class="CodeListingCaption"><a id="listing11-33">Listing 11-33</a>: <em>read_real_estate_listing_file.py:1a</em></p>
<p>Because streams like <code>real_estate_listing</code> are context managers, I can instead represent that same logic as follows:</p>
<pre><code>real_estate_listing = open("213AnywhereAve.txt")
<b>real_estate_listing.__enter__()</b>
try:
    print(real_estate_listing.read())
<span epub:type="pagebreak" title="309" id="Page_309"/>finally:
    <b>real_estate_listing.__exit__()</b></code></pre>
<p class="CodeListingCaption"><a id="listing11-34">Listing 11-34</a>: <em>read_real_estate_listing_file.py:1b</em></p>
<p>Once again, <code>__enter__()</code> does nothing, but it is called as a matter of convention on context managers. The <code>__exit__()</code> method closes the stream when I’m done. This version feels more verbose, but as it uses the special methods of the context manager, the logic can be handled entirely in a single <code>with</code> statement:</p>
<pre><code><b>with</b> open("213AnywhereAve.txt") <b>as real_estate_listing:</b>
    print(real_estate_listing.read())</code></pre>
<p class="CodeListingCaption"><a id="listing11-35">Listing 11-35</a>: <em>read_real_estate_listing_file.py:1c</em></p>
<p>This is much easier to remember and type. It’s all made possible by context managers.</p>
<h3 id="h2-500920c11-0012">Using Multiple Context Managers</h3>
<p class="BodyFirst">You can use multiple context managers in a <code>with</code> statement, which can open up all sorts of possibilities. For example, say I want to be able to read from two files at once, perhaps to combine them into one or to look for differences between them. (In the interest of expediency, I won’t actually do anything with these files in this example; I’ll just open them.)</p>
<p>To open multiple streams in a single <code>with</code> statement, I separate the <code>open()</code> expressions in the header with a comma, like this:</p>
<pre><code>with open('213AnywhereAve.txt', 'r') as left, open('18SomewhereLn.txt', 'r') as right:
    # work with the streams left and right however you want</code></pre>
<p class="CodeListingCaption"><a id="listing11-36">Listing 11-36</a>: <em>multiple_streams.py</em></p>
<p>I can use the streams <code>left</code> and <code>right</code> in the usual manner. When the <code>with</code> statement ends, both streams are closed automatically.</p>
<h3 id="h2-500920c11-0013">Implementing the Context Management Protocol</h3>
<p class="BodyFirst">The <em>context management protocol</em> is the fancy, official term for the <code>__enter__()</code> and <code>__exit__()</code> special methods. Any object that implements these two special methods can be managed by the <code>with</code> statement. They’re not limited to working with streams; you can use them to automate doing anything that needs to be done before or after usage of an object.</p>
<p>Remember that these methods need only be implemented. If you don’t need one or the other to actually do anything, don’t write any functionality into the unneeded method.</p>
<p>To demonstrate this, I’ll work with the example of a house showing. Before you can show a prospective buyer a home, you have to unlock the front door. When you leave, you lock the door again. This sort of pattern is precisely what a context manager is for.</p>
<p><span epub:type="pagebreak" title="310" id="Page_310"/>First, I define the entire <code>House</code> class:</p>
<pre><code>class House:
    def __init__(self, address, house_key, **rooms):
        self.address = address
        self.__house_key = house_key
        self.__locked = True
        self._rooms = dict()
        for room, desc in rooms.items():
            self._rooms[room.replace("_", " ").lower()] = desc

    def unlock_house(self, house_key):
        if self.__house_key == house_key:
            self.__locked = False
            print("House unlocked.")
        else:
            raise RuntimeError("Wrong key! Could not unlock house.")

    def explore(self, room):
        if self.__locked:
            raise RuntimeError("Cannot explore a locked house.")

        try:
            return f"The {room.lower()} is {self._rooms[room.lower()]}."
        except KeyError as e:
            raise KeyError(f"No room {room}") from e

    def lock_house(self):
        self.__locked = True
        print("House locked!")</code></pre>
<p class="CodeListingCaption"><a id="listing11-37">Listing 11-37</a>: <em>house_showing.py:1</em></p>
<p>This class relies entirely on concepts from prior chapters, so I won’t detail implementation here. In short, a <code>House</code> object is initialized with an address, a value to use as the house key, and a keyword argument describing each room. You’ll notice that my initializer converts underscores in the keyword argument names to spaces before storing the room name in the <code>self._rooms</code> dictionary. It changes both the room name and the description to lowercase. This will make the usage of the class feel more obvious and less error-prone.</p>
<p>The important part of this example is the <code>HouseShowing</code> class, which I’ll ultimately write as a context manager by defining the <code>__enter__()</code> and <code>__exit__()</code> special methods in the upcoming <a href="#listing11-39" id="listinganchor11-39">Listing 11-39</a> and <a href="#listing11-41" id="listinganchor11-41">Listing 11-41</a>, respectively. First, I’ll define the class and its initializer:</p>
<pre><code>class HouseShowing:

    def __init__(self, house, house_key):
        self.house = house
        self.house_key = house_key</code></pre>
<p class="CodeListingCaption"><a id="listing11-38">Listing 11-38</a>: <em>house_showing.py:2</em></p>
<p><span epub:type="pagebreak" title="311" id="Page_311"/>In the initializer, I accept two arguments: a <code>House</code> instance and the key value with which to unlock the house. In the next two sections, I’ll add the <code>__enter__()</code> and <code>__exit__()</code> special instance methods, to make <code>HouseShowing</code> a context manager.</p>
<h3 id="h2-500920c11-0014">The __enter__() Method</h3>
<p class="BodyFirst">Before I can show any room in the <code>House</code>, I must always unlock the house first. If the key is wrong, I can’t get in, so there’s no point in continuing with the showing. Since this behavior should always occur before any other use of a <code>House</code> instance, it is handled by the <code>__enter__()</code> special instance method:</p>
<pre><code>    def __enter__(self):
        self.house.unlock_house(self.house_key)
        return self</code></pre>
<p class="CodeListingCaption"><a id="listing11-39">Listing 11-39</a>: <em>house_showing.py:3</em></p>
<p>I attempt to unlock the house using the key with which I initialized <code>HouseShowing</code>. Notice that I don’t perform any error handling here. Always allow errors originating from the usage of your class to bubble up through this method, so the developer using your class can fix their code.</p>
<p>Importantly, I <em>must</em> return the instance from <code>__enter__()</code> for the <code>with</code> statement to be able to work with it!</p>
<p>The user should be able to work with this object directly, instead of having to drill down into an attribute. The main purpose of a house showing is to see the different rooms, so I write a method for that:</p>
<pre><code>    def show(self, room):
        print(self.house.explore(room))</code></pre>
<p class="CodeListingCaption"><a id="listing11-40">Listing 11-40</a>: <em>house_showing.py:4</em></p>
<p>Once again, you’ll notice that I don’t handle any of the possible exceptions from <code>house.explore()</code> here, as they all relate to the usage of the class. If the error stems from how the class is used, the exception should be handled in the usage as well.</p>
<h3 id="h2-500920c11-0015">The __exit__() Method</h3>
<p class="BodyFirst">When I leave the house, either because the tour is over or I couldn’t find a sunroom, I always want to lock up. That behavior is handled by the special instance method <code>__exit__()</code>:</p>
<pre><code>    def __exit__(self, exc_type, exc_val, exc_tb):
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> if exc_type:
            print("Sorry about that.")
      <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> self.house.lock_house()</code></pre>
<p class="CodeListingCaption"><a id="listing11-41">Listing 11-41</a>: <em>house_showing.py:5</em></p>
<p><span epub:type="pagebreak" title="312" id="Page_312"/>This method must accept three arguments besides <code>self</code>. If an exception is raised anywhere in the suite of the <code>with</code> statement, these three parameters will describe the exception’s type (<code>exc_type</code>), message (<code>exc_val</code>), and traceback (<code>exc_tb</code>). If there is no exception, all three of these parameters will have the value <code>None</code>. The parameter names I’m using here are conventional. You can call them whatever you like, but I recommend sticking with these names unless you have a good reason to change them.</p>
<p>Although <code>__exit__()</code> must accept these arguments, you’re not required to do anything with them. They’re useful if you need to take different close or cleanup actions when certain exceptions occur. In my case, if there was any exception <span class="CodeAnnotation" aria-label="annotation1">❶</span>, I apologize to the client while locking up the house <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In my particular code, I make no use of the message (<code>exc_val</code>) and traceback (<code>exc_tb</code>) arguments. If there was no exception, I only lock the house.</p>
<p>Importantly, <code>__exit__()</code> <em>does not have any role in raising or handling the error</em>! It acts as a listener, eavesdropping on any exceptions that occur in the <code>with</code> suite. Within <code>__exit__()</code>, I use conditional statements to work with the exceptions passed as arguments. I cannot use <code>try</code> for this, because any exceptions never bubble up through <code>__exit__()</code> directly, as you’ll notice in <a href="#listing11-34" id="listinganchor11-34">Listing 11-34</a>. I should never re-raise the exceptions passed in either, because any exception that occurs in the suite of the <code>with</code> will be raised by the responsible statement and should be handled by the caller. Once again: <code>__exit__()</code> has no role in handling these exceptions. The only exceptions that an <code>__exit__()</code> method should ever handle are those its own suite directly caused.</p>
<h3 id="h2-500920c11-0016">Using the Custom Class</h3>
<p class="BodyFirst">Now that my class is a context manager, I can write my usage. I start by creating a <code>House</code> object:</p>
<pre><code>house = House("123 Anywhere Street", house_key=1803,
              living_room="spacious",
              office="bright",
              bedroom="cozy",
              bathroom="small",
              kitchen="modern")</code></pre>
<p class="CodeListingCaption"><a id="listing11-42">Listing 11-42</a>: <em>house_showing.py:6</em></p>
<p>In creating the <code>House</code> instance, I’m defining a <code>house_key</code> value of <code>1803</code>, which is the value I’ll have to provide later when defining the <code>HouseShowing</code>.</p>
<p>I create a new <code>HouseShowing</code> in the context of a <code>with</code> statement, passing the <code>House</code> instance I created (<code>house</code>) to it. For the sake of example, I’m using the wrong <code>house_key</code> value (<code>9999</code>), so I should get an exception:</p>
<pre><code>with HouseShowing(house, house_key=9999) as showing:
    showing.show("Living Room")
    showing.show("bedroom")
    showing.show("porch")</code></pre>
<p class="CodeListingCaption"><a id="listing11-43">Listing 11-43</a>: <em>house_showing.py:7a</em></p>
<p><span epub:type="pagebreak" title="313" id="Page_313"/>In the header, I create a new instance of <code>HouseShowing</code>. Its <code>__enter__()</code> method is called by the <code>with</code> statement. The value returned from <code>__enter__()</code> is bound to <code>showing</code>. If I had forgotten to return anything from <code>__enter__()</code> in <a href="#listing11-39">Listing 11-39</a>, <code>showing</code> would have been bound to <code>None</code>, and this code wouldn’t have worked.</p>
<p>Since <code>house_key</code> is wrong and I cannot unlock the house, here’s the output from running the program as it is right now:</p>
<pre><code>Traceback (most recent call last):
  File "context_class.py", line 57, in &lt;module&gt;
    with HouseShowing(house, 9999) as showing:
  File "context_class.py", line 38, in __enter__
    self.house.unlock_house(self.house_key)
  File "context_class.py", line 15, in unlock_house
    raise RuntimeError("Wrong key! Could not unlock house.")
RuntimeError: Wrong key! Could not unlock house.</code></pre>
<p>Because the <code>house_key</code> value was wrong, <code>showing.__enter__()</code> encountered an exception, which I allowed to remain unhandled. This is important, because my code in <a href="#listing11-43" id="listinganchor11-43">Listing 11-43</a> is wrong. I need to pass the correct value for <code>house_key</code>. The <code>with</code> statement didn’t even try to run its suite. It encountered an exception and gave up.</p>
<p>I’ll correct the value I’m passing to <code>house_key</code>:</p>
<pre><code>with HouseShowing(house, house_key=<b>1803</b>) as showing:
    showing.show("Living Room")
    showing.show("bedroom")
    showing.show("porch")</code></pre>
<p class="CodeListingCaption"><a id="listing11-44">Listing 11-44</a>: <em>house_showing.py:7b</em></p>
<p>Now, I’ll be able to unlock the house. In the suite of the <code>with</code> statement, I make three calls to the <code>show()</code> method. The first two will work, because the <code>House</code> instance bound to <code>house</code> has those rooms defined (see <a href="#listing11-42" id="listinganchor11-42">Listing 11-42</a>), but the third will fail with an exception. Take a look at the output:</p>
<pre><code>House unlocked.
The living room is spacious.
The bedroom is cozy.
Sorry about that.
House locked!
Traceback (most recent call last):
  File "context_class.py", line 22, in explore
    return f"The {room.lower()} is {self._rooms[room.lower()]}."
KeyError: 'porch'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "context_class.py", line 60, in &lt;module&gt;
    showing.show("porch")
  File "context_class.py", line 42, in show
    print(self.house.explore(room))
<span epub:type="pagebreak" title="314" id="Page_314"/>  File "context_class.py", line 24, in explore
    raise KeyError(f"No room {room}") from e
KeyError: 'No room porch'</code></pre>
<p>The <code>with</code> statement calls <code>showing.__enter__()</code> on <code>HouseShowing</code>, which in turn calls <code>house.unlock_house()</code>, as indicated by the message <code>House unlocked</code>. Then, with each call to <code>showing.show()</code> in the suite of the <code>with</code> statement, a description of the requested room is printed out.</p>
<p>The third call to <code>showing.show()</code> in <a href="#listing11-44" id="listinganchor11-44">Listing 11-44</a>, requesting to see the porch, fails with an exception because the house doesn’t have a porch. Instead, <code>showing.__exit__()</code> is called, and the exception is passed to it. The apology is printed, and then <code>house.lock_house()</code> is called.</p>
<p>After all this, the traceback of the exception is printed.</p>
<p>To fix the problem with the code, I’d need to drop the request to see the porch and replace it with a room that does exist. Perhaps I’ll look at the kitchen instead.</p>
<pre><code>with HouseShowing(house, 1803) as showing:
    showing.show("Living Room")
    showing.show("bedroom")
    showing.show(<b>"kitchen"</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing11-45">Listing 11-45</a>: <em>house_showing.py:7c</em></p>
<p>Running this version outputs the following:</p>
<pre><code>House unlocked.
The living room is spacious.
The bedroom is cozy.
The kitchen is modern.
House locked!</code></pre>
<p>No errors here. The house is unlocked, the requested rooms are shown, and then the house is locked again. Because there were no exceptions raised in the suite, <code>house.__exit__()</code> does not print the apology from before.</p>
<h2 id="h1-500920c11-0009">Paths</h2>
<p class="BodyFirst">So far, I’ve used files located in the same directory as the module opening them. In real programs, a file may be anywhere on the system. This is far from trivial, which is probably why most tutorials skim over this topic. I’ll dive deep into file paths here.</p>
<p>First, file paths are not the same on all operating systems. UNIX-style systems, such as macOS and Linux, use the POSIX file path conventions, while Windows uses an entirely different scheme. Second, you can’t always be sure what directory your code is being run in, so relative paths only get you so far. Third, you can’t make assumptions about the name or location of important directories, such as the user’s home directory. In short, file paths are tricky to generalize.</p>
<p><span epub:type="pagebreak" title="315" id="Page_315"/>To get around all of these issues, Python offers two modules: <code>os</code> and <code>pathlib</code>. Up until Python 3.6, using the <code>os</code> package and its submodule (<code>os.path</code>) was the standard way of working with file paths. Even now, this remains a common approach. The <code>os</code> package allows you to work portably with whatever operating system your code is running on, yet the package as a whole is plagued with complexity, verbosity, and some pretty snarly legacy code. It’s also considered something of a “junk drawer,” since it contains all the functions and classes designed for working with the operating system. Thus, it can be hard to know what to use from the <code>os</code> module or even how to use it.</p>
<p>The <code>pathlib</code> module was introduced in Python 3.4 and became fully supported by <code>open()</code> in Python 3.6. It offers a cleaner, better organized, and more predictable way of handling paths. More importantly, it replaces most of <code>os.path</code> and cleanly incorporates much of the filesystem functionality offered by <code>os</code> and another useful module: <code>glob</code>, which allows you to find multiple paths fitting a particular pattern, following UNIX rules.</p>
<p>I recommend preferring <code>pathlib</code> for the sake of maintainability, readability, and performance, so that’s what I’ll focus on here. If you find yourself working with legacy code, or if you need a few of the advanced functions in <code>os.path</code>, refer to the official documentation for the <code>os.path</code> module: <a href="https://docs.python.org/3/library/os.path.html" class="LinkURL">https://docs.python.org/3/library/os.path.html</a>.</p>
<h3 id="h2-500920c11-0017">Path Objects</h3>
<p class="BodyFirst">The <code>pathlib</code> module provides several related classes that represent filesystem paths. These are called <em>path-like</em> classes—as of Python 3.6, they all inherit from the <code>os.Pathlike</code> abstract class—and they are immutable representations of a filesystem path. Importantly, path-like objects are <em>not</em> based on strings; they’re unique objects with their own behaviors, based on the parts of a path and how those parts fit together, so they abstract out a lot of the logic.</p>
<p>One of the nice things about <code>pathlib</code> path objects is that they handle all the different filesystem conventions quietly, behind the scenes, as appropriate to the system: current directory (<code>.</code>), parent directory (<code>..</code>), slashes (<code>/</code> or <code>\</code>), and so forth.</p>
<p>There are two types of path-like objects: <em>pure paths</em> and <em>concrete paths</em>.</p>
<h4 id="h3-500920c11-0004">Pure Paths</h4>
<p class="BodyFirst">A <em>pure path</em> represents a path and allows you to work with it, without accessing the underlying filesystem. Instantiating an object from the <code>PurePath</code> class will automatically create a <code>PurePosixPath</code> or <code>PureWindowsPath</code> object behind the scenes, depending on the operating system. You can usually entrust this to Python to figure out, although you can instantiate the specific type of path if you need it for your code.</p>
<pre><code>from pathlib import PurePath
path = PurePath('../some_file.txt')

<span epub:type="pagebreak" title="316" id="Page_316"/>with open(path, 'r') as file:
    print(file.read())  # this is okay (assuming file exists)

# create empty file if none exists
path.touch()            # fails on Pure paths!</code></pre>
<p class="CodeListingCaption"><a id="listing11-46">Listing 11-46</a>: <em>relative_path.py:1a</em></p>
<p>I can pass the <code>PurePath</code> object to the <code>open()</code> function to open <em>../some_file.txt</em>. However, I cannot interact with the filesystem through the <code>path</code> object itself, as I attempt to do with <code>path.touch()</code>, which fails.</p>
<p>If you only intend to use the path in a call to <code>open()</code>, or if you otherwise don’t plan to interact with the system directly through the path object’s methods, then you should use a pure path, which will help prevent you from accidentally modifying the filesystem.</p>
<h4 id="h3-500920c11-0005">Concrete Paths</h4>
<p class="BodyFirst">A <em>concrete path</em> provides methods for interacting with the filesystem. Instantiating an object from the <code>Path</code> class will create either a <code>PosixPath</code> or a <code>WindowsPath</code> object:</p>
<pre><code>from pathlib import <b>Path</b>
path = <b>Path</b>('../some_file.txt')

with open(path, 'r') as file:
    print(file.read())  # this is okay (assuming file exists)

# create empty file if none exists
path.touch()            <b># okay on Path!</b></code></pre>
<p class="CodeListingCaption"><a id="listing11-47">Listing 11-47</a>: <em>relative_path.py:1b</em></p>
<p>This code is exactly the same as in <a href="#listing11-46" id="listinganchor11-46">Listing 11-46</a>, except that I’m defining a <code>Path</code> object instead of a <code>PurePath</code>. As a result, I can still open the path, but I can also use methods on the <code>path</code> object to interact directly with the filesystem. For example, I can use <code>path.touch()</code> to create an empty file at <em>../some_file.txt</em>, if that file doesn’t already exist.</p>
<p>If you are explicitly coupling your implementation to a particular operating system, use either the <code>Windows</code> or the <code>Posix</code> form of the class; otherwise, use the <code>PurePath</code> or <code>Path</code> class.</p>
<h3 id="h2-500920c11-0018">Parts of a Path</h3>
<p class="BodyFirst">A path-like object is made up of parts that the path class joins together behind the scenes, based on the operating system. There are two ways of writing a path: <em>absolute</em> and <em>relative</em>. Both ways of writing paths work in all the <code>PurePath</code> and <code>Path</code> objects.</p>
<p>An <em>absolute</em> path is one that starts from the root of the filesystem. The absolute path to a file always starts with an <em>anchor</em> and ends with the <em/><span epub:type="pagebreak" title="317" id="Page_317"/>name—the full filename. The name consists of a <em>stem</em> (that is, the filename) before the first nonleading dot and, typically, one or more <em>suffixes</em> after the dot. For example, consider the following fictional path:</p>
<pre><code>/path/to/file.txt</code></pre>
<p>The anchor here is the leading forward slash (<code>/</code>). The name is <code>file.txt</code>, with a stem of <code>file</code> and a suffix of <code>.txt</code>. I’ll break down a couple of more complex examples shortly.</p>
<p>These parts can be retrieved from the path-like object. You can use the <code>PurePath.parts()</code> method, which returns a tuple of parts. Otherwise, you can access specific components as properties.</p>
<p>Here’s a function that prints out each part of a path passed to it. I’ll discuss the function, then employ it in the next couple of sections to dissect a Windows path and a POSIX path, respectively.</p>
<pre><code>import pathlib


def path_parts(path):
    print(f"{path}\n")

    print(f"Drive: {path.drive}")
    print(f"Root: {path.root}")
    print(f"Anchor: {path.anchor}\n")

    print(f"Parent: {path.parent}\n")
    for i, parent in enumerate(path.parents):
        print(f"Parents [{i}]: {parent}")

    print(f"Name: {path.name}")
    print(f"Suffix: {path.suffix}")
    for i, suffix in enumerate(path.suffixes):
        print(f"Suffixes [{i}]: {suffix}")
    print(f"Stem: {path.stem}\n")

    print("-------------------\n")</code></pre>
<p class="CodeListingCaption"><a id="listing11-48">Listing 11-48</a>: <em>path_parts.py:1</em></p>
<p>The <code>path.parents</code> property is an iterable collection. The first item, <code>parents[0]</code>, is the immediate parent and is the same as <code>path.parent</code>. The next item, <code>parents[1]</code>, is the parent of <code>parents[0]</code>, and so on.</p>
<p>The <code>path.suffixes</code> property is a list of the suffixes, as some files can have more than one, especially on POSIX. These will be listed left to right, so <code>path.suffixes[-1]</code> is always the last suffix.</p>
<p>Now that I have this function, I can run a couple of paths through it to see the parts, which I’ll do in Listings 11-49 and 11-50.</p>
<h4 id="h3-500920c11-0006"><span epub:type="pagebreak" title="318" id="Page_318"/>Parts of a Windows Path</h4>
<p class="BodyFirst">I’ll start by breaking down an absolute path on Windows. (It doesn’t matter here whether you’re working with a pure path or a concrete path; the paths <em>themselves</em> are structured the same in both.)</p>
<p>I break down the parts of an example path on Windows in <a href="#figure11-1" id="figureanchor11-1">Figure 11-1</a>.</p>
<figure>
<img src="Images/f11001.png" class="" alt="" width="469" height="169"/>
<figcaption><p><a id="figure11-1">Figure 11-1</a>: Parts of a Windows absolute path</p></figcaption>
</figure>
<p>In a Windows path, the anchor consists of the <em>drive</em>, which is <code>C:</code> in <a href="#figure11-1">Figure 11-1</a>, and a <em>root</em>, which is <code>\</code>. The <em>parent</em> is the path to the containing directory—in this case, <code>C:\Windows\System\</code>. That can be further broken down into three subparents: <code>C:\</code> (also the anchor), <code>Windows\</code>, and <code>System\</code>.</p>
<p>The <em>name</em> consists of the <em>stem</em>, which is usually the filename (<code>python37</code>) before the first nonleading dot; and the <em>suffix</em> or <em>suffixes</em>, which is the file extension (<code>.dll</code>) after the dot.</p>
<p>I’ll break that down again, using my function from <a href="#listing11-48" id="listinganchor11-48">Listing 11-48</a>:</p>
<pre><code>path_parts(pathlib.PureWindowsPath('C:/Windows/System/python37.dll'))</code></pre>
<p class="CodeListingCaption"><a id="listing11-49">Listing 11-49</a>: <em>path_parts.py:2a</em></p>
<p>You’ll notice that I used forward slashes as the directory separator, which are not typically employed in Windows paths. The <code>pathlib</code> module allows me to use either forward slashes (<code>/</code>) or escaped backslashes (<code>\\</code>) for paths on any system, and it handles the switch behind the scenes. (Remember that single backslashes are escape characters in Python.) Forward slashes are less prone to typos, and using them eliminates the risk of accidentally omitting one of the pair of backslashes. I therefore recommend sticking with forward slashes when you can.</p>
<p>Running that code outputs all the parts of the path:</p>
<pre><code>C:\Windows\System\python37.dll

Drive: C:
Root: \
Anchor: C:\

Parent: C:\Windows\System

Parents [0]: C:\Windows\System
Parents [1]: C:\Windows
Parents [2]: C:\
Name: python37.dll
<span epub:type="pagebreak" title="319" id="Page_319"/>Suffix: .dll
Suffixes [0]: .dll
Stem: python37</code></pre>
<p>This is consistent with the parts I outlined in <a href="#figure11-1">Figure 11-1</a>. I have the absolute path to each parent in ascending order, starting from the immediate parent of the file, <code>C:\Windows\System</code>.</p>
<p>The name is <code>python37.dll</code>, which is broken into the stem (<code>python37</code>) and one suffix (<code>.dll</code>).</p>
<h4 id="h3-500920c11-0007">Parts of a POSIX Path</h4>
<p class="BodyFirst">Filesystem paths on UNIX-like systems, like Linux or macOS, are a little different. They follow the path conventions laid out by the POSIX standard.</p>
<figure>
<img src="Images/f11002.png" class="" alt="" width="631" height="208"/>
<figcaption><p><a id="figure11-2">Figure 11-2</a>: Parts of a POSIX absolute path</p></figcaption>
</figure>
<p>In a POSIX absolute path, the <em>root</em> only contains the <em>anchor</em> (<code>/</code>). The <em>drive</em> part is always empty on POSIX paths, but the property itself exists for compatibility. The <em>name</em> part at the end consists of a <em>stem</em> (which again is generally the filename) before the first nonleading dot, plus one or more <em>suffixes</em> (which usually make up the file extension).</p>
<p>Passing that path to my <code>path_parts()</code> function from <a href="#listing11-48">Listing 11-48</a> shows all these parts:</p>
<pre><code>path_parts(pathlib.PurePosixPath('/usr/lib/x86_64-linux-gnu/libpython3.7m.so.1'))</code></pre>
<p class="CodeListingCaption"><a id="listing11-50">Listing 11-50</a>: <em>path_parts.py:2b</em></p>
<p>The output is as follows:</p>
<pre><code>/usr/lib/x86_64-linux-gnu/libpython3.7m.so.1

Drive: 
Root: /
Anchor: /

Parent: /usr/lib/x86_64-linux-gnu

Parents [0]: /usr/lib/x86_64-linux-gnu
Parents [1]: /usr/lib
Parents [2]: /usr
Parents [3]: /
<span epub:type="pagebreak" title="320" id="Page_320"/>Name: libpython3.7m.so.1
Suffix: .1
Suffixes [0]: .7m
Suffixes [1]: .so
Suffixes [2]: .1
Stem: libpython3.7m.so</code></pre>
<p>This example demonstrates a unique issue you may encounter with file extensions. While there are valid file extensions that consist of multiple suffixes, such as <em>.tar.gz</em> (for a GZ-compressed tarball), not every suffix is part of the file extension. This is a perfect example: the intended filename is <code>libpython3.7m</code>, but <code>pathlib</code> incorrectly interprets the <code>.7m</code> as one of the suffixes because of its leading dot. Meanwhile, because the intended file extension (<code>.so.1</code>) is actually composed of two suffixes, the stem is incorrectly detected as <code>libpython3.7m.so</code> and the suffix as just <code>.1</code>. You’ll need to keep this in mind when looking for the file extension on a path. There’s no simple or obvious way to resolve this; you have to take it case by case, as needed for your code. In short, don’t rely too much on <code>pathlib</code>’s ability to discern the stem and suffix; it can fail you in quite annoying ways.</p>
<h3 id="h2-500920c11-0019">Creating a Path</h3>
<p class="BodyFirst">You can define a path using the desired class initializer, such as <code>PureWindowsPath</code> or <code>PosixPath</code>, by passing the path as a string. From there, you can use the path with <code>open()</code> or any other file operation. For example, on my own UNIX system, I can access my bash history like this:</p>
<pre><code>from pathlib import PosixPath

path = PosixPath('/home/jason/.bash_history')</code></pre>
<p class="CodeListingCaption"><a id="listing11-51">Listing 11-51</a>: <em>read_from_path.py:1a</em></p>
<p>Because I’m specifying a POSIX-format path and I plan to access the underlying filesystem using the methods on my <code>path</code> object, I use <code>PosixPath</code> class. If I wanted this to work on Windows as well, I’d use <code>Path</code>, but since <code>.bash_history</code> isn’t necessarily a file that appears on Windows, I’ll stick with <code>PosixPath</code> here.</p>
<p>After initializing the path-like object and binding it to <code>path</code>, I can open it. There are two ways to do this; either pass it to <code>open()</code> or use the functionally identical<code> open() </code>method on the<code> Path </code>object<code> </code>(not available on<code> PurePath</code>). I’ll use the latter:</p>
<pre><code>with path.open('r') as file:
    for line in file:
        continue
    print(line.strip())</code></pre>
<p class="CodeListingCaption"><a id="listing11-52">Listing 11-52</a>: <em>read_from_path.py:2</em></p>
<p>In this example, I only want the last line of the file, so I have to iterate over the whole thing. By time the loop finishes, the name <code>line</code> will have <span epub:type="pagebreak" title="321" id="Page_321"/>been bound to the string of the last line read. There’s no easier way to seek the end of a text file for reading.</p>
<p>Finally, I print out this line, stripping off the trailing line break by using the <code>strip() </code>method.</p>
<p>Running that code shows me the last line I ran in my shell:</p>
<pre><code>w3m nostarch.com</code></pre>
<p>This works well on my machine, but it certainly won’t work on yours, unless your username is <em>also</em> <code>jason</code>. It also won’t work if your system structures home directories differently than mine. I need a more portable approach, and this is where <code>pathlib</code> really shines.</p>
<pre><code>from pathlib import PosixPath

path = <b>PosixPath.joinpath(PosixPath.home(), '.bash_history')</b></code></pre>
<p class="CodeListingCaption"><a id="listing11-53">Listing 11-53</a>: <em>read_from_path.py:1b</em></p>
<p>The <code>joinpath()</code> method combines two or more paths together and is available on all six <code>pathlib</code> classes. <code>PosixPath.home()</code> returns the absolute path to the current user’s home directory. (The same method exists on <code>WindowsPath</code> and refers to the user directory.)</p>
<p>I join <code>.bash_history</code> to this home directory path.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2><p class="BoxBodyFirst">It’s important not to include the anchor (the leading slash <code>/</code>) on any but the first argument passed to <code>joinpath()</code>. Such a path is considered absolute, and it will cause all the preceding arguments to be thrown away. (However, if you need to define an absolute path, you <em>will</em> need it on the first argument.)</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>I can use this new path in the exact same way as in <a href="#listing11-51" id="listinganchor11-51">Listing 11-51</a>. Running the revised code produces the same output:</p>
<pre><code>w3m nostarch.com</code></pre>
<p>Yet, there’s an even shorter way: <code>pathlib</code> classes implement the forward-slash operator (<code>/</code>) to make it easier to join path-like objects to each other, or even to strings:</p>
<pre><code>from pathlib import PosixPath

path = PosixPath.home() <b>/</b> '.bash_history'</code></pre>
<p class="CodeListingCaption"><a id="listing11-54">Listing 11-54</a>: <em>read_from_path.py:1c</em></p>
<p>I’ll leave it to you to decide whether that reads cleaner than <code>PosixPath.joinpath()</code>, but I certainly prefer it. They’re functionally identical, so use whichever one feels more readable in your particular situation.</p>
<p>There’s one other shortcut I can use in this code. On UNIX-like systems, the tilde character (<code>~</code>) refers to the user’s home folder, so I could just <span epub:type="pagebreak" title="322" id="Page_322"/>write my entire path using this convention and then have <code>pathlib</code> expand to the full absolute path:</p>
<pre><code>from pathlib import PosixPath

path = <b>PosixPath('~/.bash_history').expanduser()</b></code></pre>
<p class="CodeListingCaption"><a id="listing11-55">Listing 11-55</a>: <em>read_from_path.py:1d</em></p>
<p>This is the most readable approach by far, and it behaves the same as before.</p>
<h3 id="h2-500920c11-0020">Relative Paths</h3>
<p class="BodyFirst">A <em>relative</em> path is one that starts from the current position, instead of the root of the filesystem. Path-like objects can handle relative paths just as easily as absolute ones. Relative paths are based on the <em>current working directory</em>, which is the directory the user (or system) is currently running commands from.</p>
<p>This is useful, for example, if I have a Python program, <code>magic_program</code>, that I invoke from the command line and to which I can pass a path. The path will be received by the program as a string and will be interpreted as a <code>Path</code> object. If my current working directory were something long or difficult to type, it would be quite inconvenient to have to type an absolute path to a file contained in (or below) that directory, like this:</p>
<pre><code>$ magic_program /home/jason/My_Nextcloud/DeadSimplePython/Status.txt</code></pre>
<p>This invocation is painful! If I’m already in that <em>DeadSimplePython/</em> directory, I should be able to pass a relative path:</p>
<pre><code>$ magic_program DeadSimplePython/Status.txt</code></pre>
<p>Whew! That’s much easier to use. Because of relative paths, it would be possible to write this program.</p>
<p>You can get the current working directory with the <code>Path.cwd()</code> command, like this:</p>
<pre><code>from pathlib import Path
print(Path.cwd())</code></pre>
<p>That code would print out the absolute path to the current working directory, in the appropriate path format for your system.</p>
<p>Any path that does not lead with an anchor (typically <code>/</code>) is considered a relative path. Additionally, a single dot (<code>.</code>) represents the current directory, and a double dot (<code>..</code>) represents the previous, or parent, directory. In this way, you can construct a relative path in the same manner as an absolute path. For example, if I wanted to look for a <code>settings.ini</code> file in the parent of the current working directory, I could do so with the following:</p>
<pre><code>from pathlib import Path
path = Path('../settings.ini')</code></pre>
<p><span epub:type="pagebreak" title="323" id="Page_323"/>This path can be converted to an absolute path using the <code>Path.resolve()</code> method. It resolves the dot operators (<code>.</code> and <code>..</code>) in paths and any symbolic links. Other redundant path elements, such as extra slashes or unnecessary dot operators (such as <code>.//dir1/../dir1///dir2</code>), are cleaned up.</p>
<p>Although I could resolve the path in a subsequent line of code, I prefer to modify that line to resolve the path right on the spot.</p>
<pre><code>from pathlib import Path
path = Path('../settings.ini').resolve()</code></pre>
<p><code>path</code> is now an absolute path to <em>settings.ini</em>.</p>
<h3 id="h2-500920c11-0021">Paths Relative to Package</h3>
<p class="BodyFirst">Sooner or later, you’ll want to package noncode resources (like images or sounds) alongside your Python project and then access them from your code. You won’t know for certain where the user has placed your Python project directory on his or her filesystem; even if you knew where it <em>should</em> be, the user or system might have moved it. You need a way to create the absolute path to the noncode resources you shipped with your package. “Aha!” you may think. “This is a perfect situation for a relative path!” You would be wrong.</p>
<p>A common trap to fall into is to assume that the current working directory is the location of the current or main Python module. <em>That is not necessarily the case!</em> When you set up your project correctly, as I described in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, you can run a Python module from anywhere on the system. Your current location is the current working directory, and all paths will be relative to that location. You need a way to find the resources that does <em>not</em> depend on the current working directory; in other words, relative paths are out.</p>
<p>I’ll use my <em>omission</em> project from <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> as an example. Here’s the project structure:</p>
<pre><code>omission-git/
├── LICENSE.md
├── omission/
│   ├── __init__.py
│   ├── __main__.py
│   ├── app.py
│   ├── common/
│   ├── data/
│   ├── interface/
│   ├── game/
│   │   ├── __init__.py
│   │   └── content_loader.py
│   ├── resources/
│   │   ├── audio/
│   │   ├── content/
│   │       └── content.txt
│   │   ├── font/
│   │   └── icons/
│   └── tests/
├── omission.py
<span epub:type="pagebreak" title="324" id="Page_324"/>├── pylintrc
├── README.md
└── .gitignore</code></pre>
<p class="CodeListingCaption"><a id="listing11-56">Listing 11-56</a>: File structure for <em>omission</em> project</p>
<p>With my module <em>omission/game/contentloader.py</em>, I want to load the text file containing the game content, which is stored at <em>omission/resources/content/content.txt</em>.</p>
<p>In my initial attempt, I incorrectly assumed the current working directory would be the location of <em>content_loader.py</em>. Thus, I tried to open the <em>content.txt</em> file with a relative path something like this:</p>
<pre><code>from pathlib import Path

path = Path('../resources/content/content.txt')

with path.open() as file:
    data = file.read()</code></pre>
<p class="CodeListingCaption"><a id="listing11-57">Listing 11-57</a>: <em>content_loader.py:1a</em></p>
<p>Because I was starting my <em>omission</em> program by running <em>omission.py</em> from the root of my repository, <em>omission-git</em> was incidentally my working directory, so this code appeared to work.</p>
<p>Temporarily sticking the following line of code into my <em>content_loader.py</em> module confirmed that, by printing out the absolute path to that directory:</p>
<pre><code>print(Path.cwd())  # prints '/home/jason/Code/omission-git'</code></pre>
<p>“That’s easy,” I thought to myself. “I just write all my paths relative to <code>omission-git</code>.” (This is where things went really wrong!) I changed my code to use paths relative to that <em>omission-git/</em> directory like this:</p>
<pre><code>from pathlib import Path

path = Path('<b>omission/</b>resources/content/content.txt')

with path.open() as file:
    data = file.read()</code></pre>
<p class="CodeListingCaption"><a id="listing11-58">Listing 11-58</a>: <em>content_loader.py:1b</em></p>
<p>The program appeared to work now—I could pass <code>path</code> to <code>open()</code> and read the contents without any problems. All my tests passed, and I happily moved on. It wasn’t until I started packaging that I discovered something was still wrong. If I executed the <em>omission.py</em> module from any directory other than the one it was stored in, the program would crash with a <code>FileNotFoundError</code>.</p>
<p>After checking the current working directory again, as before, I realized what I mentioned earlier: the current working directory is wherever the module is invoked <em>from</em>, not where it lives, and all paths are relative to that current working directory.</p>
<p><span epub:type="pagebreak" title="325" id="Page_325"/>The solution was to base my relative paths off of the special <code>__file__</code> attribute of modules, which contains the absolute path to the module on the current system. I utilize that special attribute like this:</p>
<pre><code>from pathlib import Path

path = Path(<b>__file__</b>)<b>.resolve()</b>
<b>path = path.parents[1] / Path('</b>resources/content/content.txt<b>')</b>

with path.open() as file:
    data = file.read()</code></pre>
<p class="CodeListingCaption"><a id="listing11-59">Listing 11-59</a>: <em>content_loader.py:1c</em></p>
<p>I convert the <code>__file__</code> attribute to a <code>Path</code> object. Since this attribute may return a relative path, I use <code>resolve()</code> to convert it to an absolute path, so I don’t have to bother with the current working directory. <code>path</code> is now an absolute path to the current module. I need to work with an absolute path for the rest of this code to work.</p>
<p>Next, now that I have an absolute path to this <em>content_loader.py</em> module, I can craft a path to the file I want <em>relative to this module</em>. Knowing my project’s directory structure, I need to start from the top-level package, <code>omission</code>, instead of in the <code>game</code> subpackage this module is in. I get this part of the path with <code>path.parents[1]</code>, for the parent path, one level removed.</p>
<p>Finally, I combine the absolute path of the <code>omission</code> package with the relative path to the file I want. The result is an absolute path to my <em>content.txt</em> file that will work, no matter where the <code>omission</code> package lives on the filesystem or where it’s executed from.</p>
<p>This approach works for most practical cases, but beware that <code>__file__</code> is an <em>optional</em> attribute. It’s not defined for built-in modules, C modules that are statically linked to the interpreter, and anything run in the REPL. To get around these problems, you can use the rather robust <code>pkg_resources</code> module to achieve the same end as you would with <code>__file__</code>. You can learn more about this from<a href="http://setuptools.readthedocs.io/en/latest/pkg_resources.html" class="LinkURL"> https://setuptools.readthedocs.io/en/latest/pkg_resources.html</a>.</p>
<p>Unfortunately, both <code>__file__</code> and libraries like <code>pkg_resources</code> are incompatible with some packaging tools. This is really more of problem with the tools than with the pattern, since no one has any alternatives! There’s no more elegant solution here. Just be aware of this limitation when selecting packaging tools.</p>
<h3 id="h2-500920c11-0022">Path Operations</h3>
<p class="BodyFirst">The <code>pathlib</code> concrete path objects provide methods of performing many common file operations in a platform-agnostic fashion. Two of the most convenient of these methods are <code>Path.read_text()</code> and <code>Path.write_text()</code>, which provide a quick way to read and write entire text files without having to define a separate stream object or <code>with</code> statement. In this usage, the stream object is created and managed internally, within the <code>Path</code> object. The former reads in and returns the entire contents of the file as a string; the latter writes a string out as a file, overwriting the existing file if there is one.</p>
<p><span epub:type="pagebreak" title="326" id="Page_326"/><a href="#table11-2" id="tableanchor11-2">Table 11-2</a> outlines several more of the file operation methods on <code>Path</code>. Each of these would be run directly on a <code>Path</code>, <code>WindowsPath</code>, or <code>PosixPath</code> object, referred to as <code>path</code> below.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table11-2">Table 11-2</a>: Filesystem Operations on Path</p></figcaption>
<table id="table-500920c11-0002" border="1">
<thead>
<tr>
<td><b>File operation methods</b></td>
<td><b>Functionalities</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>path.mkdir()</code></td>
<td>Creates a directory at <code>path</code>. If the optional <code>parents=</code> argument is <code>True</code>, it will create any missing parent directories.</td>
</tr>
<tr>
<td><code>path.rename(</code><var>name</var><code>)</code></td>
<td>Renames the item (file or directory) at <code>path</code> to <var>name</var>. On Unix, if the file <var>name</var> exists at the path and the user has the correct permissions, it will be replaced.</td>
</tr>
<tr>
<td><code>path.replace(</code><var>name</var><code>)</code></td>
<td>Renames the item (file or directory) at <code>path</code> to <var>name</var>, replacing any existing file by that name. Unlike <code>rename</code>, this will <em>always</em> replace any existing file by the same name, assuming the correct file permissions.</td>
</tr>
<tr>
<td><code>path.rmdir()</code></td>
<td>Removes the directory at <code>path</code>. It must be empty; otherwise, an <code>OSError</code> will be raised.</td>
</tr>
<tr>
<td><code>path.unlink()</code></td>
<td>Removes the file or symbolic link (filesystem shortcut) at <code>path</code>. Cannot be used to remove directories. In Python 3.8 and later, if the optional <code>missing_ok=</code> argument is <code>True</code>, attempting to remove a file that does not exist will <em>not</em> raise <code>FileNotFoundError</code>.</td>
</tr>
<tr>
<td><code>path.glob()</code></td>
<td>Returns a generator of path-like objects for all items at <code>path</code> that match the specified <var>pattern</var>, according to the syntax of a Unix-style <code>glob</code> search.</td>
</tr>
<tr>
<td><code>path.iterdir()</code></td>
<td>Returns a generator of path-like objects for all items at <code>path</code>.</td>
</tr>
<tr>
<td><code>path.touch()</code></td>
<td>Creates an empty file at <code>path</code>. Normally, nothing happens if it already exists. If the optional <code>exist_ok=</code> argument is <code>False</code> and the file exists, a <code>FileExistsError</code> is raised.</td>
</tr>
<tr>
<td><code>path.symlink_to(</code><var>target</var><code>)</code></td>
<td>Creates a symbolic link at <code>path</code> to <var>target</var>.</td>
</tr>
<tr>
<td><code>path.link_to(</code><var>target</var><code>)</code></td>
<td>Creates a hard link at <code>path</code> to <var>target</var> (Python 3.8 and later only).</td>
</tr>
</tbody>
</table>
</figure>
<p>In addition, you get information about the file or directory a <code>Path</code> object points to, as shown in <a href="#table11-3" id="tableanchor11-3">Table 11-3</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table11-3">Table 11-3</a>: File Information Methods on Path</p></figcaption>
<table id="table-500920c11-0003" border="1">
<thead>
<tr>
<td><b>File information methods</b></td>
<td><b>Functionalities</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>path.exists()</code></td>
<td>Returns <code>True</code> if <code>path</code> points to an existing file or symbolic link.</td>
</tr>
<tr>
<td><code>path.is_file()</code></td>
<td>Returns <code>True</code> if <code>path</code> points to a file or symbolic link to a file.</td>
</tr>
<tr>
<td><code>path.is_dir()</code><code/></td>
<td>Returns <code>True</code> if <code>path</code> points to a directory or symbolic link to a directory.</td>
</tr>
<tr>
<td><code>path.is_symlink()</code></td>
<td>Returns <code>True</code> if <code>path</code> points to a symbolic link.</td>
</tr>
<tr>
<td><code>path.is_absolute()</code></td>
<td>Returns <code>True</code> if <code>path</code> is absolute.</td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="327" id="Page_327"/>I’ve only covered a portion of <code>pathlib</code>’s functionality. I strongly recommend you browse through the official module documentation, which has a complete list of methods and their usages: <a href="https://docs.python.org/3/library/pathlib.html" class="LinkURL">https://docs.python.org/3/library/pathlib.html</a>. </p>
<h3 id="h2-500920c11-0023">Out-of-Place File Writes</h3>
<p class="BodyFirst">As I mentioned earlier in the chapter, <code>path.replace()</code> is particularly useful as part of a technique for preventing file corruption if there’s a computer or program crash during writing. Instead of directly modifying a file in place, you can write to a new file and then replace the old file with the new version.</p>
<p>To demonstrate this, I’ll rewrite one of my earlier examples (Listings 11-37 through 11-39) to employ <code>pathlib</code> and use this technique:</p>
<pre><code>from pathlib import Path

path = Path('78SomewhereRd.txt')

with path.open('r') as real_estate_listing:
    contents = real_estate_listing.read()
    contents = contents.replace('Tiny', 'Cozy')
    contents = contents.replace('Needs repairs', 'Full of potential')
    contents = contents.replace('Small', 'Compact')
    contents = contents.replace('old storage shed', 'detached workshop')
    contents = contents.replace('Built on ancient burial ground.',
                                'Unique atmosphere.')</code></pre>
<p class="CodeListingCaption"><a id="listing11-60">Listing 11-60</a>: <em>rewrite_using_tmp.py:1</em></p>
<p>I read in the file from <em>78SomewhereRd.txt</em> as before, except that this time, I only open the file in read mode, instead of read-write. Once I’ve finished with it, I can safely close the file. My revised data is waiting in the string <code>contents</code>.</p>
<p>Now, I create a new temporary file path and write my data out to that new file:</p>
<pre><code>tmp_path = path.with_name(path.name + '.tmp')

with tmp_path.open('w') as file:
    file.write(contents)</code></pre>
<p class="CodeListingCaption"><a id="listing11-61">Listing 11-61</a>: <em>rewrite_using_tmp.py:2</em></p>
<p>I use <code>path.with_name()</code> to create a new <code>Path</code>, with the name provided as an argument. In this case, the new name is the same as the old name, but with <code>.tmp</code> appended to the end. I open that new path in write mode and write the string <code>contents</code> out to it.</p>
<p>At this point, my original <em>78SomewhereRd.txt</em> and my new <em>78SomewhereRd.txt.tmp</em> files exist side by side. I conclude by moving the temporary file into the place of the original, overwriting it.</p>
<pre><code>tmp_path.replace(path)  # move the new file into place of the old one</code></pre>
<p class="CodeListingCaption"><a id="listing11-62">Listing 11-62</a>: <em>rewrite_using_tmp.py:3</em></p>
<p><span epub:type="pagebreak" title="328" id="Page_328"/>That <code>replace()</code> method has the operating system perform the replacement, instead of doing it itself. This is a virtually instantaneous operation, in contrast to writing to the file, which may take a bit of time, depending on the size. Now, I only have the revised <em>78SomewhereRd.txt</em>, and the temporary file is gone.</p>
<p>The benefit of this technique is that, had my computer crashed while I was writing to the file, the worst outcome would be that I’d have a corrupt <em>78SomewhereRd.txt.tmp</em> file. My original <em>78SomewhereRd.txt</em> would be unchanged and unharmed.</p>
<h3 id="h2-500920c11-0024">The os Module</h3>
<p class="BodyFirst">Python’s <code>os</code> module allows you to interface with the operating system in a relatively platform-agnostic fashion. Most code written before Python 3.6, and even a lot of modern code, still uses the <code>os.path</code> and <code>os</code> modules for handling paths. As I’ve mentioned, <code>pathlib</code> is going to be the better tool for working with the filesystem in most cases, but <code>os</code> still has many uses. For some longtime Python developers, using <code>os</code> is also just a habit.</p>
<p>As of Python 3.8, <code>os.path</code> has 12 functions, with no existing equivalent in <code>pathlib</code>. One example is <code>os.path.getsize(</code><var>pathlike</var><code>)</code>, which returns the size of the item at <var>pathlike</var> in bytes. Meanwhile, <code>os</code> itself has dozens of functions for interacting with the filesystem in a much more low-level, technical fashion than <code>pathlib</code>.</p>
<p>Thankfully, since Python 3.6, <code>pathlib</code> and <code>os</code> play well together. I recommend using <code>pathlib</code> as much as you can—it will fully satisfy the majority of use cases—and bring in the <code>os</code> or <code>os.path</code> modules anytime you need one of their unique functionalities. The documentation will be helpful if you want to learn more about these modules: <a href="https://docs.python.org/3/library/os.html" class="LinkURL">https://docs.python.org/3/library/os.html</a>.</p>
<p>The <code>os</code> module is not limited to working with the filesystem, so it will come up again in later chapters.</p>
<h2 id="h1-500920c11-0010">File Formats</h2>
<p class="BodyFirst">Up to this point, I’ve worked entirely with plaintext files. This works for storing plain strings, but it’s not usually sufficient for more structured data. Here, I’ll discuss working with other file formats.</p>
<p>In many cases, you’ll get more reliable results by using an existing standard file format. However, it’s always possible to design your own format and write custom parser logic for it, so long as you’re willing to put the effort into designing, testing, and maintaining it.</p>
<p>Python offers tools for a few of the most common formats in the standard library, and many other formats are supported through third-party libraries. Here, I’ll cover usage of the popular JSON format and then give an overview of a few other common formats.</p>
<p>The process of converting Python data to a format for storage is called <em>serialization</em>, and the reverse is <em>deserialization</em>.</p>
<h3 id="h2-500920c11-0025"><span epub:type="pagebreak" title="329" id="Page_329"/>JSON</h3>
<p class="BodyFirst"><em>JSON</em>, or <em>JavaScript Object Notation</em>, is one of the most popular text-based file formats among Python developers. JSON data can be structured in a variety of ways, the most common being storing the contents of a Python dictionary in a file.</p>
<p>The built-in <code>json</code> module allows you to easily convert data between JSON data and many built-in Python data types and collections. In the case of JSON, serialization and deserialization are not perfect inverses of one another, as seen in <a href="#table11-4" id="tableanchor11-4">Table 11-4</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table11-4">Table 11-4:</a> JSON Serialization and Deserialization Types</p></figcaption>
<table id="table-500920c11-0004" border="1">
<thead>
<tr>
<td><b>Python (to serialize)</b></td>
<td><b>JSON (serialized)</b></td>
<td><b>Python (deserialized)</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>dict</code></td>
<td>object (All keys are strings!)</td>
<td><code>dict</code></td>
</tr>
<tr>
<td>
<code>list</code><br/>
<code>tuple</code>
</td>
<td>
array
<br/>
</td>
<td>
<code>list</code>
<br/>
</td>
</tr>
<tr>
<td><code>bool</code></td>
<td>boolean</td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>str</code></td>
<td>string</td>
<td><code>str</code></td>
</tr>
<tr>
<td><code>int</code><br/>
<code>int-derived enums</code></td>
<td>number (int)
<br/></td>
<td><code>int</code>
<br/></td>
</tr>
<tr>
<td><code>float</code><br/>
<code>float-derived enums</code></td>
<td>number (real)
<br/></td>
<td><code>float</code>
<br/></td>
</tr>
<tr>
<td><code>None</code></td>
<td>null</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
</figure>
<p>Anything directly derived from these Python types can also be JSON-serialized, but all other objects <em>cannot</em> be serialized to JSON on their own and must be converted to a type that can be.</p>
<p>To make a custom class JSON-serializable, you would need to define a new object that subclasses <code>json.JSONEncoder</code> and overrides its <code>default()</code> method. See the documentation for more information about this: <a href="https://docs.python.org/3/library/json.html#json.JSONEncoder" class="LinkURL">https://docs.python.org/3/library/json.html#json.JSONEncoder</a>.</p>
<h4 id="h3-500920c11-0008">Writing to JSON</h4>
<p class="BodyFirst">Writing to JSON is refreshingly simple, in comparison to working with many other file formats. You use the <code>json.dump()</code> function to convert data to JSON format and write it to a file. Alternatively, you use <code>json.dumps()</code> to create and write JSON code to a string if you want to wait and write it to a stream later. I’ll demonstrate the former technique in this example.</p>
<p>I’ll work with my <code>nearby_properties</code> nested dictionary from <a href="#listing11-7">Listing 11-7</a>, which I want to write out to a file I’ll call <em>nearby.json</em>:</p>
<pre><code><b>import json</b>

nearby_properties = {
    "N. Anywhere Ave.":
<span epub:type="pagebreak" title="330" id="Page_330"/>    {
        123: 156_852,
        124: 157_923,
        126: 163_812,
        127: 144_121,
        128: 166_356
    },
    "N. Everywhere St.":
    {
        4567: 175_753,
        4568: 166_212,
        4569: 185_123
    }
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-63">Listing 11-63</a>: <em>write_house_json.py:1</em></p>
<p>The only change from the prior example (<a href="#listing11-7">Listing 11-7</a>) is that I’m now importing the <code>json</code> module.</p>
<p>I’m converting a dictionary containing only serializable types (see <a href="#table11-4">Table 11-4</a>) directly to a stream using <code>json.dump()</code>:</p>
<pre><code>with open('nearby.json', 'w') as jsonfile:
    json.dump(nearby_properties, jsonfile)</code></pre>
<p class="CodeListingCaption"><a id="listing11-64">Listing 11-64</a>: <em>write_house_json.py:2</em></p>
<p>First, I use <code>open()</code> to create a writable stream for the <em>nearby.json</em> file. The <code>json.dump()</code> function requires two arguments. The first is the object being written out, which can be <em>any</em> serializable object. In this case, I’m writing out the dictionary <code>nearby_properties</code>.</p>
<p>The second argument is the stream I want to write to, which must be a writable text-based stream. Here, I pass <code>jsonfile</code>, which is the text-based stream opened in write mode in the <code>with</code> statement.</p>
<p>That’s all it takes to write a Python dictionary to a JSON file!</p>
<p>The <code>json.dumps()</code> function works in exactly the same manner, except that it returns a Python string containing the JSON code, rather than requiring you to pass a stream to it.</p>
<p>After running my code, I can open up the newly created <em>nearby.json</em> and see the contents, which are in JSON format:</p>
<pre><code>{
    "N. Anywhere Ave.": {
        "123": 156852,
        "124": 157923,
        "126": 163812,
        "127": 144121,
        "128": 166356
    },
    "N. Everywhere St.": {
        "4567": 175753,
        "4568": 166212,
<span epub:type="pagebreak" title="331" id="Page_331"/>        "4569": 185123
    }
}</code></pre>
<p class="CodeListingCaption"><a id="listing11-65">Listing 11-65</a>: <em>nearby.json</em></p>
<h4 id="h3-500920c11-0009">Reading from JSON</h4>
<p class="BodyFirst">You can directly deserialize a JSON file into the corresponding Python object using the <code>json.load()</code> function, which accepts the source stream object as an argument. If I have JSON code in a Python string, I can also deserialize it directly with <code>json.loads()</code>, passing the string as an argument.</p>
<p>I’ll use <code>json.load()</code> to deserialize my nested dictionary from my <em>nearby.json</em> file:</p>
<pre><code>import json

with open('nearby.json', 'r') as jsonfile:
    nearby_from_file = json.load(jsonfile)</code></pre>
<p class="CodeListingCaption"><a id="listing11-66">Listing 11-66</a>: <em>read_house_json.py:1</em></p>
<p>I open the JSON file in read mode, and then I pass the stream to <code>json.load()</code>. That will return the deserialized object, which in this case is a dictionary I bind to <code>nearby_from_file</code>.</p>
<p>There is one important difference between this dictionary and the one I started with in <a href="#listing11-65" id="listinganchor11-65">Listing 11-65</a>. I’ll demonstrate this difference by printing out the literal representation of each key and value:</p>
<pre><code>for k1, v1 in nearby_from_file.items():
    print(repr(k1))
    for k2, v2 in v1.items():
        print(f'{k2!r}: {v2!r}')</code></pre>
<p class="CodeListingCaption"><a id="listing11-67">Listing 11-67</a>: <em>read_house_json.py:2</em></p>
<p>The f-string here embeds the values of <code>k2</code> and <code>v2</code> in the string, and the <code>!r</code> formats them as if they had been run through <code>repr()</code>.</p>
<p>Can you spot the difference with this dictionary in the output?</p>
<pre><code>'N. Anywhere Ave.'
'123': 156852
'124': 157923
'126': 163812
'127': 144121
'128': 166356
'N. Everywhere St.'
'4567': 175753
'4568': 166212
'4569': 185123</code></pre>
<p><span epub:type="pagebreak" title="332" id="Page_332"/>The key values for the inner dictionaries are strings now—instead of integers, as in the original dictionary (<a href="#listing11-63" id="listinganchor11-63">Listing 11-63</a>)—because the key in a JSON object is always a string. This is a perfect example of serialization and deseralization not being inverse operations. If I wanted to get back to using integers for my keys, I’d need to rewrite this code to handle that conversion iteratively. That’s beyond the scope of this chapter, so I’ll leave this example as is.</p>
<h3 id="h2-500920c11-0026">Other Formats</h3>
<p class="BodyFirst">I could devote an entire book just to working with file formats in Python (although I don’t think my editor would go for it). Instead, I’ll breeze through several of the most common formats. For each of these, you can pair the concepts from this chapter with the documentation for the particular modules or libraries you’re using.</p>
<h4 id="h3-500920c11-0010">CSV</h4>
<p class="BodyFirst">One of the most common structured text formats is <em>CSV</em>, which stands for <em>comma-separated values</em>. As its name suggests, it separates individual values with commas. Sets of values are separated by newline characters (<code>\n</code>).</p>
<p>CSV format is used by nearly all spreadsheets and databases, although seldom in a standardized manner. A CSV file exported by Excel may not be the same as one exported by a UNIX program. These subtle differences, known as <em>dialects</em>, ordinarily make working with CSV a bit tricky.</p>
<p>Python’s standard library includes a <code>csv</code> module that not only handles serializing to and deserializing from CSV files, but also abstracts out the differences between CSV dialects.</p>
<p>To learn more about the <code>csv</code> module, see the Python documentation: <a href="https://docs.python.org/3/library/csv.html#module-csv" class="LinkURL">https://docs.python.org/3/library/csv.html#module-csv</a>.</p>
<h4 id="h3-500920c11-0011">INI</h4>
<p class="BodyFirst">The <em>INI</em> format is excellent for storing configuration files, especially settings. It’s an informal standard that is designed to be human-readable and easy to parse. You’ll find INI files on Windows and Unix systems alike. You’ve almost certainly encountered files like <em>php.ini</em> and <em>Desktop.ini</em>—and perhaps, you’ve even encountered <em>tox.ini</em>, which is used by many Python tools, including <code>flake8</code> and <code>pytest</code>. It’s also common to find <em>.conf</em>, <em>.cfg,</em> and even <em>.txt</em> files that use this INI format.</p>
<p>Python’s standard library includes the <code>configparser</code> module for working with INI-style files, although this module invented its own format for multiline strings. This makes the module’s output potentially incompatible with anything other than Python’s <code>configparser</code>, and it has no support for nested sections. It also can’t work with the value-type prefixes used by Windows Registry-style INI files.</p>
<p>See the official documentation for <code>configparser</code> to learn how to use it: <a href="https://docs.python.org/3/library/configparser.html#module-configparser" class="LinkURL">https://docs.python.org/3/library/configparser.html#module-configparser</a>.</p>
<p><span epub:type="pagebreak" title="333" id="Page_333"/>Alternatively, the third-party library <em>configobj</em> supports nested sections and the standard multiline strings, along with many other features lacking in <code>configparser</code>. Files created by this module are compatible with other INI parsers, especially those in other languages. The official documentation for this library is available at <a href="https://configobj.readthedocs.io/en/latest/" class="LinkURL">https://configobj.readthedocs.io/en/latest/</a>.</p>
<h4 id="h3-500920c11-0012">XML</h4>
<p class="BodyFirst"><em>XML</em> is a structured markup language based upon the idea of tags, elements, and attributes. Many other file formats use the XML syntax, including <em>XHTML</em>, <em>SVG</em>, <em>RSS</em>, and most office document formats (<em>DOCX</em> and <em>ODT</em>). You can use XML to devise your own text-based file formats.</p>
<p>Python developers often shun XML in favor of JSON, for two reasons: <em>simplicity of usage</em> and <em>security</em>. The same structures can be represented in both JSON and XML, but working with XML in Python involves eight different modules. These are all covered in detail at <a href="https://docs.python.org/3/library/xml.html" class="LinkURL">https://docs.python.org/3/library/xml.html</a>. Given a choice between XML and JSON, you’ll always find it easier to work with the latter.</p>
<p>XML also has a number of security vulnerabilities, which must be taken into account whenever you’re deserializing untrusted or unauthenticated data. The built-in Python modules specifically are vulnerable to some of these attacks, so when security is a factor, the documentation advises use of the <em>defusedxml</em> and <em>defusedexpat</em> third-party libraries.</p>
<p>Alternatively, you can use the third-party library <em>lxml</em>, which addresses many of these issues. More information about this library is available at <a href="https://lxml.de/" class="LinkURL">https://lxml.de/</a>.</p>
<h4 id="h3-500920c11-0013">HTML</h4>
<p class="BodyFirst">I doubt I need to tell you what <em>HTML</em> is, since it is ubiquitous on the internet. Python allows you to work with HTML files via the built-in <code>html</code> module and its two submodules: <code>html.parser</code> and <code>html.entities</code>. This is a very deep rabbit hole (unsurprisingly), so I’ll leave you to explore it on your own if you’re interested. The documentation is a good place to start: <a href="https://docs.python.org/3/library/html.html" class="LinkURL">https://docs.python.org/3/library/html.html</a>.</p>
<p>There are also some excellent third-party libraries for working with HTML, including <em>lxml.html</em> (part of <em>lxml</em>) and <em>beautifulsoup4</em>. You can learn more about the latter at <a href="https://www.crummy.com/software/BeautifulSoup/" class="LinkURL">https://www.crummy.com/software/BeautifulSoup/</a>.</p>
<h4 id="h3-500920c11-0014">YAML</h4>
<p class="BodyFirst"><em>YAML</em> is a popular alternative to markup languages like XML; its name is a recursive acronym for <em>YAML Ain’t Markup Language</em>. YAML covers many of the same use cases as XML, but with a simpler syntax.</p>
<p>The latest version of this language—YAML 1.2—implements all the features of JSON, in addition to its own syntax. This means all JSON is also valid YAML 1.2. Besides this, all JSON output by Python using default settings is compatible with YAML 1.0 and 1.1. Thus, at least in Python, YAML <span epub:type="pagebreak" title="334" id="Page_334"/>is always a superset of JSON. One particular advantage of YAML over JSON is its support for comments.</p>
<p>The third-party <em>PyYAML</em> library is listed on the Python wiki as being the only YAML parser that has attempted compliance with the YAML standard. More information about this library can be found at <a href="https://pyyaml.org/" class="LinkURL">https://pyyaml.org/</a>.</p>
<p>YAML does have potential security concerns—namely, it can be used to execute arbitrary Python code. The PyYAML library has a <code>yaml.safe_load()</code> function that mitigates this risk, so that should be used instead of <code>yaml.load()</code>.</p>
<h4 id="h3-500920c11-0015">TOML</h4>
<p class="BodyFirst">Another option for configuration files is <em>TOML</em>, an acronym for <em>Tom’s Obvious, Minimal Language</em>. It’s an open format created by Tom Preston-Werner. It draws inspiration from INI, but it implements a formal specification.</p>
<p>The most popular third-party library for working with TOML is appropriately called <em>toml</em>. You can learn more about it at <a href="https://github.com/uiri/toml/" class="LinkURL">https://github.com/uiri/toml/</a>.</p>
<h4 id="h3-500920c11-0016">ODF</h4>
<p class="BodyFirst">The <em>Open Document Format</em> (ODF) is an XML-based document format developed and maintained by the Organization for the Advancement of Structured Information Standards (OASIS). It is being widely adopted and is increasingly becoming a ubiquitous document standard. It is used by nearly all modern word processors, including LibreOffice, Microsoft Word, and Google Docs.</p>
<p>The primary use for ODF is when working with data ordinarily handled by an office suite. Perhaps you’re writing a grammar checker, a spreadsheet validator, a word processor, or a slide deck organizer.</p>
<p>One of the most popular Python libraries for working with the Open Document Format is <em>odfpy</em>, which is developed and maintained by the European Environmental Agency. More information and documentation for this library is available at <a href="https://github.com/eea/odfpy/wiki/" class="LinkURL">https://github.com/eea/odfpy/wiki/</a>.</p>
<h4 id="h3-500920c11-0017">RTF</h4>
<p class="BodyFirst">The <em>Rich Text Format</em> (RTF) is a popular document format that supports basic text formatting. Although it’s a proprietary format originally developed by Microsoft for Word, it’s relatively common for basic documents because of its simplicity and portability. Although the format is no longer in active development and has lost ground to the Open Document Format, it is still just as usable as ever.</p>
<p>There are a few third-party packages for working with Rich Text Format. The most popular library for Python 2 was <em>PyRTF</em>. Two forks of that library exist for Python 3: <em>PyRTF3</em> and <em>rtfx</em>. (As of this writing, the <em>PyRTF3</em> library is unmaintained, although it is still available in pip.) <em>RTFMaker</em> is a newer alternative, presently under active development. Unfortunately, documentation for all four libraries is sparse, so plan on sailing into uncharted waters if you use any of these libraries.</p>
<p><span epub:type="pagebreak" title="335" id="Page_335"/>Alternatively, if none of these libraries do what you need or you don’t want to work without documentation, the Rich Text Format is simple enough that you can write your own basic parser with a little research. It’s a closed specification, so it can be hard to find the official documents, but version 1.5 of the Rich Text Format Specification is archived here: <a href="http://www.biblioscape.com/rtf15_spec.htm" class="LinkURL">http://www.biblioscape.com/rtf15_spec.htm</a>.</p>
<h2 id="h1-500920c11-0011">Wrapping Up</h2>
<p class="BodyFirst">Who would have guessed how much was involved in working with text files in Python? I’ve only scratched the surface of this topic, the complexity of which is belied by the existence of so many five-minute beginner’s tutorials.</p>
<p>Opening a file is easy enough, using a <code>with</code> statement and the <code>open()</code> function. The <code>pathlib</code> module handles paths in a platform-agnostic fashion, so you can stop worrying about which way your slash is supposed to lean. Dozens of modules (from the standard library and third-party developers) exist for handling the countless text-based file formats out there, often via a few method calls. When you put all these pieces together, you ultimately get delightfully simple, yet robust, patterns for handling text files.</p>
<p>In the next chapter, I’ll introduce the techniques necessary to work with binary data in Python, especially in the context of reading and writing binary files.</p>
<p>It feels good to move beyond the boundaries of the program execution and create real files on the user’s computer, doesn’t it?</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="337" id="Page_337"/>12</span><br/>
<span class="ChapterTitle">Binary and Serialization</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">01100010 01101001 01101110 01100001 01110010 01111001. This is the language of computers, the delight of hackers, and the subject of that one computer science joke you have memorized. If a programming language wants a chance to gain the admiration of elite developers, it must allow working with <em>binary</em>.</p>
<p>For the programmers who haven’t encountered binary yet, I’ll start by breaking down the fundamentals, particularly as Python sees them, and the different ways of expressing binary data and performing bitwise operations. With that foundation in place, I’ll cover how to read and write files in binary, and I’ll wrap up with a whirlwind tour of some of the most common binary file formats.</p>
<h2 id="h1-500920c12-0001"><span epub:type="pagebreak" title="338" id="Page_338"/>Binary Notation and Bitwise</h2>
<p class="BodyFirst">For those who are new to the fine art of bit twiddling, I’ll breeze through it now. Even if you already know how to do bitwise manipulation, I recommend hanging in there for the next few pages for a review—and perhaps some little surprises.</p>
<h3 id="h2-500920c12-0001">Number Systems Refresher</h3>
<p class="BodyFirst"><em>Binary</em> is a number system with only two digits—<code>0</code> and <code>1</code>—which correspond to the open and closed position (respectively) of gates on circuit boards. This is the foundation of all computer programming. Typically, this binary is abstracted out for better human comprehension through CPU instructions and data types, and then further toward human language through various programming constructs. Although you won’t usually need to think much about binary, there are times when manipulating it directly is the most effective way to solve a problem.</p>
<p>In Python, when writing a numeric literal in binary, you prefix it with <code>0b</code> to differentiate it from run-of-the-mill decimal (base-10) numbers. For example, while <code>11</code> is the decimal value “eleven,” <code>0b11</code> is the binary value for “three.”</p>
<p>A binary <em>bit</em> is a single digit. A <em>byte</em> is usually made up of eight bits, although uncommonly, this can vary. Within a byte, place values typically ascend from right to left, as with decimal numbers. You can compose any number by switching on (<code>1</code>) or off (<code>0</code>) the bits at different positions. In a byte, the rightmost place has a value of <code>1</code>, and each subsequent place has double the preceding value. The value of each place is demonstrated in <a href="#table12-1" id="tableanchor12-1">Table 12-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table12-1">Table 12-1</a>: Place Values of Bits</p></figcaption>
<table id="table-500920c12-0001" border="1"><tbody>
<tr>
<td>128</td>
<td>64</td>
<td>32</td>
<td>16</td>
<td>8</td>
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
</figure>
<p>So, the byte <code>0b01011010</code> would be equivalent to <code>64 + 16 + 8 + 2</code>, or <code>90</code>. The computer interprets particular bytes differently, depending on the data type—something determined by the code, rather than stored in the binary data. From a low-level perspective, the same sequence of bits could represent the integer <code>90</code>, the ASCII character <code>'Z'</code>, a part of a floating-point number, a bytecode instruction . . . the possibilities are endless. Thankfully, you don’t need to worry about how the computer handles this interpretation. Trust the language for that.</p>
<h4 id="h3-500920c12-0001">Hexadecimal</h4>
<p class="BodyFirst">You can also represent numeric literals in the <em>hexadecimal</em>, or base-16 number system, which is so named because there are 16 unique digits for the decimal values <code>0</code> through <code>15</code>. The first 10 use the ordinary digits <code>0</code> through <code>9</code> and the letters <code>A</code> through <code>F</code> as digits for values <code>10</code> through <code>15</code>, respectively. The decimal value <code>16</code> cannot be represented with a single digit in hexadecimal; it is instead represented by <code>10</code> in this system. In Python, as <span epub:type="pagebreak" title="339" id="Page_339"/>in most programming languages, you prefix hexadecimal literals with <code>0x</code> to differentiate them from decimal numbers. <code>0x15</code> would represent decimal value <code>21</code>, because <code>0x10</code> (<code>16</code>) + <code>0x05</code> (<code>5</code>) = <code>0x15</code> (<code>21</code>).</p>
<p class="BodyFirst">When manually composing larger numbers in any number system, mentally or on paper, it’s useful to think of each <em>place value</em> as the base value raised to the place number (starting from zero). For example, the decimal number <code>4972</code> could be thought of as <code>2 + 70 + 900 + 4000</code>, which can further be broken down as <code>(2 * 10</code><sup>0</sup><code>) + (7 * 10</code><sup>1</sup><code>) + (9 * 10</code><sup>2</sup><code>) + (4 * 10</code><sup>3</sup><code>).</code></p>
<p><a href="#table12-2" id="tableanchor12-2">Table 12-2</a> demonstrates this with base 10 (decimal), base 2 (binary), and base 16 (hexadecimal).</p>
<figure>
<figcaption class="TableTitle"><p><a id="table12-2">Table 12-2</a>: Place Values in Various Number Systems</p></figcaption>
<table id="table-500920c12-0002" border="1">
<thead>
<tr>
<td><b>Number system</b></td>
<td colspan="5"><b>Place values</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><b/></td>
<td><code>10000 (n</code><sup>4</sup><code>)</code></td>
<td><code>1000 (n</code><sup>3</sup><code>)</code></td>
<td><code>100 (n</code><sup>2</sup><code>)</code></td>
<td><code>10 (n</code><sup>1</sup><code>)</code></td>
<td><code>1 (n</code><sup>0</sup><code>)</code></td>
</tr>
<tr>
<td><b>Decimal</b></td>
<td><code>10</code><sup>4</sup><code> (10000)</code></td>
<td><code>10</code><sup>3</sup><code> (1000)</code></td>
<td><code>10</code><sup>2</sup><code> (100)</code></td>
<td><code>10</code><sup>1</sup><code> (10)</code></td>
<td><code>10</code><sup>0</sup><code> (1)</code></td>
</tr>
<tr>
<td><b>Binary</b></td>
<td><code>2</code><sup>4</sup><code> (16)</code></td>
<td><code>2</code><sup>3</sup><code> (8)</code></td>
<td><code>2</code><sup>2</sup><code> (4)</code></td>
<td><code>2</code><sup>1</sup><code> (2)</code></td>
<td><code>2</code><sup>0</sup><code> (1)</code></td>
</tr>
<tr>
<td><b>Hexadecimal</b></td>
<td><code>16</code><sup>4</sup><code> (65536)</code></td>
<td><code>16</code><sup>3</sup><code> (4096)</code></td>
<td><code>16</code><sup>2</sup><code> (256)</code></td>
<td><code>16</code><sup>1</sup><code> (16)</code></td>
<td><code>16</code><sup>0</sup><code> (1)</code></td>
</tr>
</tbody>
</table>
</figure>
<p>You can use this principle to convert a decimal value to another system, such as hexadecimal. For example, if I wanted to convert the decimal value 2630, I’d first determine the highest place value needed with the formula <code>⌊log</code><sub>16</sub><code>2630⌋</code>, which gives me <code>2</code>. Then, I’d perform the conversion as shown in <a href="#table12-3" id="tableanchor12-3">Table 12-3</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table12-3">Table 12-3</a>: Converting Decimal to Hexadecimal</p></figcaption>
<table id="table-500920c12-0003" border="1"><tbody>
<tr>
<td><b>Value to convert</b></td>
<td><code class="bold">2630</code></td>
<td><code class="bold">70</code></td>
<td><code class="bold">6</code></td>
</tr>
<tr>
<td><b>Place value</b></td>
<td><code>⌊</code><code class="bold">2630</code><code>/16</code><sup>2</sup><code>⌋ = 0xA (10)</code></td>
<td><code>⌊</code><code class="bold">70</code><code>/16</code><sup>1</sup><code>⌋ = 0x4</code></td>
<td><code>⌊</code><code class="bold">6</code><code>/16</code><sup>0</sup><code>⌋ = 0x6</code></td>
</tr>
<tr>
<td><b>Current hexadecimal value</b></td>
<td><code>0x</code><code class="bold">A</code><code>00</code></td>
<td><code>0xA</code><code class="bold">4</code><code>0</code></td>
<td><code>0xA4</code><code class="bold">6</code></td>
</tr>
<tr>
<td><b>Calculate remaining value</b></td>
<td><code>2630 % 16</code><sup>2</sup><code> = </code><code class="bold">70</code></td>
<td><code>70 % 16</code><sup>1</sup><code> = </code><code class="bold">6</code></td>
<td><code>6 % 16</code><sup>0</sup><code> = 0</code></td>
</tr>
</tbody>
</table>
</figure>
<p>The decimal value <code>2630</code> has the hexadecimal value <code>0xA46</code>.</p>
<p>Hexadecimal is useful in the context of binary because you can exactly express each possible value of a byte (eight bits) in two digits, from <code>0x00</code> (<code>0</code>) to <code>0xFF</code> (<code>255</code>). Hexadecimal is a more succinct way of representing binary: <code>0b10101010</code> can be written as <code>0xAA</code>.</p>
<h4 id="h3-500920c12-0002">Hexadecimal Humor</h4>
<p class="BodyFirst">Hexadecimal employs the first six letters of the Latin alphabet as digits, and among developers, this has led to a traditional brand of puns known as <em>hexspeak</em>. Hexadecimal numbers such as 0xDEADBEEF and 0xC0FFEE have valid numeric values and are visually recognizable; the former has traditionally been used on some ancient IBM systems for uninitialized memory, because it was easy to spot amidst the wall of hexadecimal that was a core dump.</p>
<p><span epub:type="pagebreak" title="340" id="Page_340"/>In the same way, you can sometimes mark special data in your binary. This can make your binary files a little easier to read and debug manually, and besides, it’s fun! Just be mindful that normal data may coincidentally show up in hexspeak, too—for example, a normal integer value that happens to read as 0xDEADBEEF—so use it with caution.</p>
<h4 id="h3-500920c12-0003">Octal</h4>
<p class="BodyFirst">The third most common number system for representing binary data is <em>octal</em>, or base-8. Octal literals are prefixed with <code>0o</code> (zero, followed by a lowercase letter <em>o</em>). Octal uses digits for decimal values <code>0</code> through <code>7</code>, but it writes <code>8</code> as <code>0o10</code>. Thus, decimal values <code>9</code> and <code>10</code> would be <code>0o11</code> and <code>0o12</code>, respectively.</p>
<p><a href="#table12-4" id="tableanchor12-4">Table 12-4</a> shows that place value table again, this time including octal.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table12-4">Table 12-4</a>: Place Values in Various Number Systems</p></figcaption>
<table id="table-500920c12-0004" border="1">
<thead>
<tr>
<td><b>Number systems</b></td>
<td colspan="5"><b>Place values</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><b/></td>
<td><code>10000 (n</code><sup>4</sup><code>)</code></td>
<td><code>1000 (n</code><sup>3</sup><code>)</code></td>
<td><code>100 (n</code><sup>2</sup><code>)</code></td>
<td><code>10 (n</code><sup>1</sup><code>)</code></td>
<td><code>1 (n</code><sup>0</sup><code>)</code></td>
</tr>
<tr>
<td><b>Decimal</b></td>
<td><code>10</code><sup>4</sup><code> (10000)</code></td>
<td><code>10</code><sup>3</sup><code> (1000)</code></td>
<td><code>10</code><sup>2</sup><code> (100)</code></td>
<td><code>10</code><sup>1</sup><code> (10)</code></td>
<td><code>10</code><sup>0</sup><code> (1)</code></td>
</tr>
<tr>
<td><b>Binary</b></td>
<td><code>2</code><sup>4</sup><code> (16)</code></td>
<td><code>2</code><sup>3</sup><code> (8)</code></td>
<td><code>2</code><sup>2</sup><code> (4)</code></td>
<td>
<code>2</code><sup>1</sup><code> (2)</code></td>
<td>

<code>2</code><sup>0</sup><code> (1)</code></td>
</tr>
<tr>
<td>
<b>Octal</b></td>
<td>

<code class="bold">8</code><sup>4</sup><code class="bold"> (4096)</code>
</td>
<td>
<code class="bold">8</code><sup>3</sup><code class="bold"> (512)</code></td>
<td>

<code class="bold">8</code><sup>2</sup><code class="bold"> (64)</code></td>
<td>

<code class="bold">8</code><sup>1</sup><code class="bold"> (8)</code></td>
<td>

<code class="bold">8</code><sup>0</sup><code class="bold"> (1)</code></td>
</tr>
<tr>
<td><b>Hexadecimal</b></td>
<td><code>16</code><sup>4</sup><code> (65536)</code></td>
<td><code>16</code><sup>3</sup><code> (4096)</code></td>
<td><code>16</code><sup>2</sup><code> (256)</code></td>
<td><code>16</code><sup>1</sup><code> (16)</code></td>
<td><code>16</code><sup>0</sup><code> (1)</code></td>
</tr>
</tbody>
</table>
</figure>
<p>Every 8-bit byte can be represented by three octal digits, with the highest value (<code>0xFF</code>) being <code>0o377</code>. Although octal doesn’t map to bytes as cleanly or obviously as hexadecimal, it is still useful in some scenarios because it’s more compact than binary but doesn’t require six extra digits like hexadecimal. Octal is used for UNIX file permissions, and it simplifies specifying individual parts of some UTF-8 characters and some assembly op codes. If you have trouble picturing these use cases, you probably don’t need octal. You could go through your entire career without needing it! Regardless, it is helpful to know about it for the rare cases when you might need it.</p>
<h4 id="h3-500920c12-0004">Number Systems on Integers</h4>
<p class="BodyFirst">It’s important to remember that binary, octal, decimal, and hexadecimal are all <em>number systems</em>; that is, they’re different ways of representing the same <em>whole number</em>, or <em>integer</em>. The decimal number <code>12</code> can be represented as <code>0b1100</code>, <code>0xc</code>, or <code>0o14</code>, but binding any of these literals to a name in Python will still store an integer with the decimal value <code>12</code>.</p>
<p>Consider the following:</p>
<pre><code>chapter = 0xc
print(chapter)  # prints '12'</code></pre>
<p class="CodeListingCaption"><a id="listing12-1">Listing 12-1</a>: print_integer.py:1a</p>
<p><span epub:type="pagebreak" title="341" id="Page_341"/>By default, printing an integer always shows the value in decimal. I can instead show the value in another number system by using one of the built-in functions for that purpose: <code>bin()</code>, <code>oct()</code>, or <code>hex()</code>:</p>
<pre><code>chapter = 0xc
print(bin(chapter))  # prints '0b1100'
print(hex(chapter))  # prints '0xc'
print(oct(chapter))  # prints '0o14'</code></pre>
<p class="CodeListingCaption"><a id="listing12-2">Listing 12-2</a>: print_integer.py:1b</p>
<p>Regardless of how you display it, the actual value bound to <code>chapter</code> is unchanged.</p>
<h4 id="h3-500920c12-0005">Two’s Complement</h4>
<p class="BodyFirst">In binary on most computers, negative numbers are represented as the <em>two’s complement</em> of the positive number. This technique is preferred over simply using a single bit to indicate positive or negative, as it allows you to store one additional value in the byte.</p>
<p>For example, the positive number <code>42</code> would be <code>0b00101010</code> in binary. To get <code>-42</code>, I’d find the two’s complement by inverting each of the bits (giving me <code>0b11010101</code>) and then adding <code>0b1</code>, ultimately producing <code>0b11010110</code> (you carry the <code>1</code>: <code>0b01</code> + <code>0b01</code> = <code>0b10</code>).</p>
<p>To convert a negative number back to a positive, you only need to repeat the process. Starting with <code>-42</code>, or <code>0b11010110</code>, I invert each of the bits, giving me <code>0b00101001</code>. Then, I add <code>0b1</code>, producing <code>0b00101010</code>, which is positive <code>42</code>.</p>
<p>Python <em>almost</em> uses two’s complement—it actually does something more complex, as you’ll see in a later section—so it instead shows negative binary numbers by placing a negative sign on the binary representation of the positive form of the number, as seen below:</p>
<pre><code>print(bin(42))   # prints  '0b101010'
print(bin(-42))  # prints '-0b101010'</code></pre>
<p class="CodeListingCaption"><a id="listing12-3">Listing 12-3</a>: negative_binary.py:1</p>
<p>As a bit wrangler myself, this may be the only thing I dislike about Python, although I understand its purpose.</p>
<p>Thankfully, it is possible to see the (approximate) two’s complement notation by using a <em>bitmask</em>, a binary value that uses strategically placed <code>1</code>s to keep certain bits in a value and throw away the rest. In this case, I want the first eight bits of the value (one byte), so I take the bitwise <code>AND</code> the value with a bitmask of eight <code>1</code>s:</p>
<pre><code>print(bin(-42 &amp; 0b11111111))  # prints '0b11010110'</code></pre>
<p class="CodeListingCaption"><a id="listing12-4">Listing 12-4</a>: negative_binary.py:2</p>
<p>That shows exactly what I’d expect: the eight-bit-long two’s complement representation of <code>-42</code>.</p>
<h4 id="h3-500920c12-0006"><span epub:type="pagebreak" title="342" id="Page_342"/>Byte Order</h4>
<p class="BodyFirst">In this section, I’m not referring to Python at all, but rather to the computer memory <em>underneath</em> everything. We’re all the way down to silicon right now.</p>
<p>Most data is made up of multiple bytes, but the sequence the bytes appear in depends on the <em>byte order</em> used by your platform: either <em>big-endian</em> or <em>little-endian</em>.</p>
<p>Byte order has everything to do with how the computer stores data in memory. Each one-byte-wide slot in memory has a numeric address, typically represented in hexadecimal. Memory addresses are consecutive. Let’s consider a value, say <code>0xAABBCCDD</code> (<code>2,864,434,397</code> in decimal), that is composed of four bytes: <code>0xAA</code>, <code>0xBB</code>, <code>0xCC</code>, and <code>0xDD</code>. This value can be stored in a four-byte-wide chunk of memory, with each byte having an address. For example, the computer might decide to store that data in the memory at addresses <code>0xABCDEF01</code>, <code>0xABCDEF02</code>, <code>0xABCDEF03</code>, and <code>0xABCDEF04</code>, as shown in <a href="#table12-5" id="tableanchor12-5">Table 12-5</a>. </p>
<figure>
<figcaption class="TableTitle"><p><a id="table12-5">Table 12-5</a>: An Empty Four-Byte Chunk of Memory with Addresses</p></figcaption>
<table id="table-500920c12-0005" border="1">
<thead>
<tr>
<td><b>Address</b></td>
<td><span class="Regular"><code>0xABCDEF01</code></span></td>
<td><span class="Regular"><code>0xABCDEF02</code></span></td>
<td><span class="Regular"><code>0xABCDEF03</code></span></td>
<td><span class="Regular"><code>0xABCDEF04</code></span></td>
</tr>
</thead>
<tbody>
<tr>
<td><b>Value</b></td>
<td/>
<td/>
<td/>
<td/>
</tr>
</tbody>
</table>
</figure>
<p>Now here’s the challenge: in what order do we store those bytes? Your first instinct might be to store them as you’d write them on paper, like in <a href="#table12-6" id="tableanchor12-6">Table 12-6</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table12-6">Table 12-6</a>: Data Stored in Memory in Big-Endian Byte Order</p></figcaption>
<table id="table-500920c12-0006" border="1">
<thead>
<tr>
<td><b>Address</b></td>
<td><span class="Regular"><code>0xABCDEF01</code></span></td>
<td><span class="Regular"><code>0xABCDEF02</code></span></td>
<td><span class="Regular"><code>0xABCDEF03</code></span></td>
<td><span class="Regular"><code>0xABCDEF04</code></span></td>
<td><span class="Regular">Whole value</span></td>
</tr>
</thead>
<tbody>
<tr>
<td><b>Hex value</b></td>
<td><code>0xAA</code></td>
<td><code>0xBB</code></td>
<td><code>0xCC</code></td>
<td><code>0xDD</code></td>
<td><code>= 0xAABBCCDD</code></td>
</tr>
<tr>
<td><b>Equivalent</b></td>
<td><code>2852126720</code></td>
<td><code>+ 12255232</code></td>
<td><code>+ 52224</code></td>
<td><code>+ 221</code></td>
<td><code>= 2864434397</code></td>
</tr>
</tbody>
</table>
</figure>
<p>We call this byte order <em>big-endian</em>, because the value representing the largest part of the value is stored in the lowest, or leftmost, address. The big-endian byte order is often the easiest to reason about, because it orders bytes from left to right, just like how you’d write it on paper.</p>
<p>In contrast, on little-endian systems, the bytes are reversed, as shown in <a href="#table12-7" id="tableanchor12-7">Table 12-7</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table12-7">Table 12-7</a>: Data Stored in Memory in Little-Endian Byte Order</p></figcaption>
<table id="table-500920c12-0007" border="1">
<thead>
<tr>
<td><b>Address</b></td>
<td><span class="Regular"><code>0xABCDEF01</code></span></td>
<td><span class="Regular"><code>0xABCDEF02</code></span></td>
<td><span class="Regular"><code>0xABCDEF03</code></span></td>
<td><span class="Regular"><code>0xABCDEF04</code></span></td>
<td><span class="Regular">Whole value</span></td>
</tr>
</thead>
<tbody>
<tr>
<td><b>Hex value</b></td>
<td><code>0xDD</code></td>
<td><code>0xCC</code></td>
<td><code>0xBB</code></td>
<td><code>0xAA</code></td>
<td><code>= 0xDDCCBBAA</code></td>
</tr>
<tr>
<td><b>Equivalent</b></td>
<td><code>221</code></td>
<td><code>+ 52224</code></td>
<td><code>+ 12255232</code></td>
<td><code>+ 2852126720</code></td>
<td><code>= 2864434397</code></td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="343" id="Page_343"/>As the name <em>little-endian</em> suggests, the byte representing the smallest part of the number is stored in the lowest memory address.</p>
<p>Endianness only affects primitive data types, like integers and floating-point numbers. It will not affect collections, such as strings, which are just arrays of individual characters.</p>
<p>Although little-endian byte order sounds confusing, it makes a few little technical optimizations possible on the hardware. Most modern computers, including all Intel and AMD processors, use little-endian.</p>
<p>In most programming languages, we conventionally write binary numbers in big-endian. It’s the byte order used when you display an integer in binary in Python with <code>bin()</code>.</p>
<p>Often, the only time you need to be concerned about byte order is when your binary data is going to leave your program, such as when writing it to a file or sending it over a network.</p>
<h3 id="h2-500920c12-0002">Python Integers and Binary</h3>
<p class="BodyFirst">Like in most programming languages, binary and hexadecimal literals are integers in Python. However, one implementation detail behind Python integers bleeds into the binary logic of the language: <em>integers are effectively infinite</em>.</p>
<p>In Python 2, the <code>int</code> type had a fixed size of 32 bits, or four bytes. Python 2 also had the <code>long</code> type, which had an unlimited size. In Python 3, the <code>long</code> type was adopted as the new <code>int</code>, so all integers now have a theoretically infinite size.</p>
<p>This behavior has one critical consequence for binary: two’s complement notation must effectively lead with an infinite number of <code>1</code> bits. This is why Python uses the rather unconventional negative binary notation. There’s no rational way to express an infinite number of <code>1</code>s! It also means you can’t directly type a binary literal for a negative integer. Instead, you have to use the negation operator (<code>-</code>) before the binary literal of the <em>positive</em> integer and trust Python to figure things out.</p>
<p>Since Python uses that negative binary notation, the negative binary form of a number reads the same as the positive binary form. The two’s complement notation would only be accurate if you could see the infinite leading <code>1</code> bits. This has a weird consequence elsewhere, as you’ll see shortly.</p>
<h3 id="h2-500920c12-0003">Bitwise Operations</h3>
<p class="BodyFirst">You can work directly with binary data using the <em>bitwise operators</em>, which perform operations on individual bits. There are six bitwise operators, and Python offers all of them, although a couple behave a bit differently than you’d ordinarily expect.</p>
<p>The <em>Bitwise And</em> operator (<code>&amp;</code>) produces a new binary value, where each bit is <code>1</code> if the corresponding bits in the left and right operands are both <code>1</code>. <span epub:type="pagebreak" title="344" id="Page_344"/>For example, <code>0b1101 &amp; 0b1010</code> produces <code>0b1000</code>, because only the leftmost bit is <code>1</code> in both operands:</p>
<pre><code>  0b<b>1</b>101
&amp; 0b<b>1</b>010
= 0b<b>1</b>000</code></pre>
<p>The <em>Bitwise Or</em> operator (<code>|</code>) produces a value where each bit is <code>1</code> if either the left or the right operand is <code>1</code> (or if both are). For example, <code>0b1101 | 0b1010</code> produces <code>0b1111</code>, because each of the four bits is on in at least one of the operands.</p>
<pre><code>  0b<b>11</b>0<b>1</b>
| 0b<b>1</b>0<b>1</b>0
= 0b<b>1111</b></code></pre>
<p>The <em>Bitwise Exclusive Or</em> operator (<code>^</code>), also known as a <em>Bitwise XOR</em>, sets a bit to <code>1</code> if it is on in either operand, but not in both. For example, <code>0b1101 ^ 0b1010</code> produces <code>0b0111</code>; the first bit is on in both operands, so it is off here, but the other three bits are on in only one operand, so they’re included.</p>
<pre><code>  0b1<b>101</b>
^ 0b1<b>010</b>
= 0b0<b>111</b></code></pre>
<p>The <em>Bitwise Inversion</em> operator (<code>~</code>), also known as the <em>Bitwise Not</em>, flips each bit in the operand given, such that <code>0b0101</code> would become (approximately) <code>0b1010</code>.</p>
<pre><code>~ 0b0101
= 0b1010</code></pre>
<p>However, since in Python, integers are infinite, the new value would have infinite leading <code>1</code> bits. Therefore, the real result of <code>~0b0101</code> is actually <code>0b111...1010</code>.</p>
<pre><code>~ 0b000...0101
= 0b111...1010</code></pre>
<p>Since infinite <code>1</code>s are hard to print, Python shows the result in negative binary notation—placing a negative sign at the front and subtracting <code>1</code> to get around the two’s complement. Remember, this convention is what allows Python to display a negative number as the negative binary form of the positive number. Unfortunately, it makes it a bit harder to read the results of normal bit twiddling.</p>
<p>Whenever this gets in your way, you can print the bitmasked form:</p>
<pre><code>print(bin(~0b0101))           # prints '-0b110' (that is, -0b0101 - 0b1)
print(bin(~0b0101 &amp; 0b1111))  # prints '0b1010' (much better)</code></pre>
<p class="CodeListingCaption"><a id="listing12-5">Listing 12-5</a>: bitwise_inversion.py</p>
<p><span epub:type="pagebreak" title="345" id="Page_345"/>Remember that the first value is <em>internally</em> correct, as it has the infinite leading <code>1</code>s that make it a negative Python integer. The second only <em>looks</em> correct, but it lacks those leading <code>1</code>s, so it’s actually wrong.</p>
<p>The last two bitwise operators are the <em>Left Shift</em> (<code/><code>&lt;&lt;</code>) and <em>Right Shift</em> (<code/><code>&gt;&gt;</code>) operators. In binary arithmetic, there are two types of shifts, of which a programming language can only use one on its shift operators. The <em>logical shift</em> allows bits to “drop off” the end of the number, shifting in zeros at the other end to replace discarded bits. The <em>arithmetic shift</em> does the same as the logical shift, but it will also shift in the <em>sign bit</em> (<code>1</code> in negative numbers) where necessary to preserve the sign.</p>
<p>Every language must decide which form of bitwise shift its operators should use, and Python uses the <em>arithmetic shift</em>. In addition, because of the infinite nature of integers, you cannot discard bits with a left shift; the integer will keep growing to accommodate them, as you can see here:</p>
<pre><code>print(bin(0b1100 &lt;&lt; 4))   # prints '0b11000000'</code></pre>
<p class="CodeListingCaption"><a id="listing12-6">Listing 12-6</a>: bitwise_shift.py:1</p>
<p>That probably won’t have any profound effect on your code, but it may change how you implement some binary algorithms that rely on discarding bits with a left shift.</p>
<p>A right shift will preserve the sign, so it will shift in <code>0</code>s on the left for positive integers and <code>1</code>s for negative integers:</p>
<pre><code>print(bin(0b1100 &gt;&gt; 4))   # prints  '0b0' (0b0...0000)
print(bin(-0b1100 &gt;&gt; 4))  # prints '-0b1' (0b1...1111)</code></pre>
<p class="CodeListingCaption"><a id="listing12-7">Listing 12-7</a>: bitwise_shift.py:2</p>
<p>In summary, <a href="#table12-8" id="tableanchor12-8">Table 12-8</a> shows those bitwise operators again, as well as their corresponding special methods.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table12-8">Table 12-8</a>: Bitwise Operators</p></figcaption>
<table id="table-500920c12-0008" border="1">
<thead>
<tr>
<td><b>Operator</b></td>
<td><b>Use</b></td>
<td><b>Binary (not Python) example</b></td>
<td><b>Special method</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>Bitwise And</td>
<td><code>1100 &amp; 1011 ⇒ 1000</code></td>
<td><code>__and__(</code><var>a</var><code>, </code><var>b</var><code>)</code></td>
</tr>
<tr>
<td><code>|</code></td>
<td>Bitwise Or</td>
<td><code>1100 | 1011 ⇒ 1111</code></td>
<td><code>__or__(</code><var>a</var><code>, </code><var>b</var><code>)</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>Bitwise Exclusive Or<br/>
(Bitwise XOR)</td>
<td><code>1100 ^ 1011 ⇒ 0111</code></td>
<td><code>__xor__(</code><var>a</var><code>, </code><var>b</var><code>)</code></td>
</tr>
<tr>
<td><code>~</code></td>
<td>Bitwise Inversion<br/>
(Bitwise Not)</td>
<td><code>~1100 ⇒ 0011</code></td>
<td><code>__inv__(</code><var>a</var><code>)</code><br/>
<code>__invert__(</code><var>a</var><code>)</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>Left (arithmetic) Shift</td>
<td><code>0111 &lt;&lt; 2 ⇒ 11100</code></td>
<td><code>__lshift__(</code><var>a</var><code>, </code><var>b</var><code>)</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>Right (arithmetic) Shift</td>
<td><code>0111 &gt;&gt; 2 ⇒ 0001</code><br/>
<code>1..1010  2 ⇒ 1..1110</code></td>
<td><code>__rshift__(</code><var>a</var><code>, </code><var>b</var><code>)</code></td>
</tr>
</tbody>
</table>
</figure>
<p>These operators also work on boolean values, which are internally based on integers (much to the consistent annoyance of one of my colleagues!). They won’t work like this on other types—only on booleans and integers.</p>
<p><span epub:type="pagebreak" title="346" id="Page_346"/>Be cautious when using bitwise with existing custom classes! Because they’re uncommonly used compared to many other operators, some classes choose to repurpose the bitwise operators for altogether unrelated purposes. Thus, performing bitwise operations on anything except an integer or boolean can result in wildly unpredictable behavior. Be sure to read the documentation on any class you want to use before you rely on the bitwise operators with it!</p>
<p>You can make your own objects work with the bitwise operators themselves by implementing the corresponding special methods from <a href="#table12-8">Table 12-8</a>.</p>
<h2 id="h1-500920c12-0002">Bytes Literals</h2>
<p class="BodyFirst">Another way to represent binary in Python is with a <em>bytes literal</em>, which looks like a string literal prepended with <code>b</code>, such as <code>b"HELLO" </code>or<code> b"\xAB\x42"</code>. These are not strings, but rather sequences of bytes, with each byte represented by either an ASCII character (such as <code>"H"</code> for <code>0x48</code>) or a hexadecimal escape sequence (such as <code>"\x42"</code> for <code>0x42</code>). Unlike integer objects, bytes literals have the explicit size and implied byte order you give them.</p>
<p>Here’s that example bytes literal, which contains the binary equivalent of the string “HELLO”:</p>
<pre><code>bits = b"HELLO"</code></pre>
<p class="CodeListingCaption"><a id="listing12-8">Listing 12-8</a>: bytes_literal.py:1a</p>
<p>Although a bytes literal isn’t exactly a string, most of the rules of string literals still apply here, with two major exceptions. First, a bytes literal can only contain ASCII characters (values <code>0x00</code> to <code>0xFF</code>), partly because each item in a bytes literal must be exactly one byte in size, and partly for backward compatibility with Python 2 and other languages that use ASCII text encoding. Second, unlike strings, bytes literals cannot be formatted via f-strings.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2><p class="BoxBodyFirst">As of Python 3.5, you can format bytes literals with old-fashioned string formatting, known as <em>%-interpolation</em>. If you find yourself needing string formatting or substitution on bytes literals, see PEP 461.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>In all Python strings, you can use the escape sequence <code>'\x</code><var>hh' </var>to represent a character with the hexadecimal value <var>hh</var>. Unlike in some languages, the escape sequence must always contain a two-digit hexadecimal number. It does not matter whether the digits <code>A</code> through <code>F</code> are uppercase or lowercase: <code>'\xAB'</code> and <code>'\xab'</code> are treated the same, although Python always outputs the latter.</p>
<p>For example, if I knew the hexadecimal codes I needed for <code>"HELLO"</code>, I could use them in place of some (or all) the ASCII character literals:</p>
<pre><code>bits = b"<b>\x48\x45\x4C\x4C\x4F</b>"</code></pre>
<p class="CodeListingCaption"><a id="listing12-9">Listing 12-9</a>: bytes_literal.py:1b</p>
<p><span epub:type="pagebreak" title="347" id="Page_347"/>These hexadecimal literals are also needed when the desired value cannot be represented by a visible character, such as <code>'\x07'</code>, which in ASCII is the nonprinting control code <code>BEL</code>, which sounds the system bell. (And yes, <code>print('\x07')</code> will indeed play a sound, assuming you haven’t turned off your system bell in your terminal or system settings.)</p>
<p>You can also create raw bytes literals, wherein the backslash character (<code>\</code>) is always treated as a literal character. Because of this, raw bytes literals cannot interpret escape sequences, which limits their usefulness. However, if you don’t need escape sequences and do want literal backslashes, then raw bytes literals can occasionally come in handy. To define a raw bytes literal, precede the string with either <code>rb</code> or <code>br</code>. I demonstrate this below:</p>
<pre><code>bits_escaped = b"\\A\\B\\C\\D\\E"
bits_raw = br"\A\B\C\D\E"
print(bits_raw)                  # prints b'\\A\\B\\C\\D\\E'
print(bits_escaped == bits_raw)  # prints 'True'</code></pre>
<p class="CodeListingCaption"><a id="listing12-10">Listing 12-10</a>: bytes_literal.py:2</p>
<p>Both <code>bits_escaped</code> and <code>bits_raw</code> have exactly the same value, as demonstrated by the comparison in the <code>print()</code> statement, but the value assigned to <code>bits_raw</code> was easier to type.</p>
<h2 id="h1-500920c12-0003">Bytes-Like Objects</h2>
<p class="BodyFirst">If you need to store binary data, Python offers <em>bytes-like objects</em>. Unlike integers, these objects have a fixed size and an <em>implied</em> byte order. This means they have the byte order you followed when you provided the bytes to the bytes-like object; it also means you are responsible for explicitly defining the byte order of the data you provide. This can be helpful when the infinite nature of integers gets underfoot. Bytes-like objects also provide a number of utility functions, unlike bytes literals.</p>
<p>There’s one drawback: the bitwise operators don’t work with bytes-like objects. That may sound strange, and even annoying, and the exact reasons for this are largely unknown. There are two very plausible reasons, however.</p>
<p>First, it’s essential to avoid unexpected behavior relating to byte order. If you tried to perform a bitwise operation on a big-endian and a little-endian object greater than one byte, the result’s byte order would be unclear. You’d run the risk of getting garbage output, which would be quite difficult to debug.</p>
<p>Second, it’s difficult to predict how to handle bitwise operations on bytes-like objects of different lengths. You could pad them to be the same length, but you’d again need to know the byte order to do that correctly.</p>
<p>Instead of making the language guess how to implicitly resolve these difficult patches of logic, bytes-like objects just don’t support bitwise operators. There are a couple of ways to perform bitwise manipulations on bytes-like objects, but they’re a little more involved. I’ll come back to that shortly.</p>
<p><span epub:type="pagebreak" title="348" id="Page_348"/>There are two primary bytes-like objects: <code>bytes</code>, which is immutable, and <code>bytearray</code>, which is mutable. Both objects are identical in all other regards: they provide the same functionality as any other Python sequence and offer the same methods and behaviors. The two objects are even interoperable.</p>
<p>The decision of whether to use <code>bytes</code> or <code>bytearray</code> comes down solely to whether you want a mutable or an immutable object. For simplicity, I’ll mainly use the <code>bytes</code> object in this section; the code would be the same for <code>bytearray</code>.</p>
<h3 id="h2-500920c12-0004">Creating a bytes Object</h3>
<p class="BodyFirst">There are six ways to create a bytes-like object—not counting the default and copy initializers, which create an empty object or copy the value of another bytes-like object, respectively.</p>
<p>The trouble is, passing a binary literal to the initializer unexpectedly results in an empty bytes object. This occurs because a binary literal is really an integer, and passing an integer <var>n</var> to the <code>bytes()</code> constructor creates an empty bytes object with a size of <var>n</var> bytes:</p>
<pre><code>bits = bytes(0b110)
print(bits)  # prints '\x00\x00\x00\x00\x00\x00'</code></pre>
<p class="CodeListingCaption"><a id="listing12-11">Listing 12-11</a>: init_bytes.py:1a</p>
<p>The <code>bits</code> object is exactly six (<code>0b110</code>) bytes long, and each of those bits is set to zero. Although this may feel like surprising behavior, remember that any binary data passed to <code>bytes</code> must have an explicit byte order, something that isn’t inherent to Python integers.</p>
<p>You can create a bytes object from binary literals in a couple of ways. One way is to pass an iterable of integers to the bytes initializer. However, each of the integers provided by the iterable must be positive and representable in a single byte—that is, it must be between the values of <code>0</code> and <code>255</code>, inclusive—or a <code>ValueError</code> will be raised.</p>
<p>The fastest way to do that here is to pack my binary literal into a tuple by itself:</p>
<pre><code>bits = bytes(<b>(</b>0b110<b>,)</b>)
print(bits)  # prints "b'\x06'"</code></pre>
<p class="CodeListingCaption"><a id="listing12-12">Listing 12-12</a>: init_bytes.py:1b</p>
<p>Recall that I must provide a trailing comma (<code class="bold">,</code>) in a single-element tuple, or else it will be interpreted as a literal integer instead.</p>
<p>Another way to accomplish this same goal would be to wrap the binary literal in square brackets (<code>[ ]</code>) to define a list. Because each integer in the iterable fits in a single byte, the order in which the items are provided by the iterable effectively defines the byte order.</p>
<p>Yet another way to initialize a bytes object is to assign a bytes literal:</p>
<pre><code><span epub:type="pagebreak" title="349" id="Page_349"/>bits = b'\x06'
print(bits)  # prints "b'\x06'"</code></pre>
<p class="CodeListingCaption"><a id="listing12-13">Listing 12-13</a>: init_bytes.py:2a</p>
<p>In the case of <code>bytearray</code>, you’d pass that literal to the initializer:</p>
<pre><code>bits = <b>bytearray(</b>b'\x06'<b>)</b>
print(bits)  # prints "b'\x06'"</code></pre>
<p class="CodeListingCaption"><a id="listing12-14">Listing 12-14</a>: init_bytes.py:2b</p>
<p>No surprises there.</p>
<p>Finally, I can create a bytes object from any string, although I must explicitly state the text encoding being used:</p>
<pre><code>bits = bytes('☺', encoding='utf-8')
print(bits)  # prints "b'\xe2\x98\xba'"</code></pre>
<p class="CodeListingCaption"><a id="listing12-15">Listing 12-15</a>: init_bytes.py:3</p>
<p>The smiley face emoji (<code>☺</code>) is a Unicode character with a UTF-8 encoding that spans three bytes: <code>0xE298BA</code>. If you’re familiar with Unicode, you’ll notice what is not happening here: bytes is <em>not</em> using the formal Unicode code point for the smiley face emoji (<code>U+263A</code>), but rather, it is using the internal binary representation that UTF-8 uses.</p>
<p>I could have left the keyword off the <code>encoding=</code> argument, and many Python programmers will, but I prefer to spell it out explicitly. Just know that <code>bytes('☺', 'utf-8')</code> is equivalent.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2><p class="BoxBodyFirst">UTF-8 string literals don’t actually have a byte order; they read as if they were big-endian, but that’s only coincidental. Some other systems, like UTF-16 and UTF-32, offer variants for the different byte orders.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c12-0005">Using int.to_bytes()</h3>
<p class="BodyFirst">Perhaps the easiest way to convert between an integer and a bytes-like object is with the <code>int.to_bytes()</code> method.</p>
<p>As mentioned, when working with bytes, you must specify the byte order. The byte order required is often determined by your situation, such as what particular file format you’re working with. Networks always use big-endian byte order.</p>
<p>Beyond that, the choice is somewhat arbitrary. If the data is only being used by my application, I’ll usually stick to big-endian, which is my preference; if the data will be handled by system processes, I’ll employ the system’s byte order, which I determine with the following:</p>
<pre><code>import sys

print(sys.byteorder)  # prints 'little'</code></pre>
<p class="CodeListingCaption"><a id="listing12-16">Listing 12-16</a>: int_to_bytes.py:1</p>
<p><span epub:type="pagebreak" title="350" id="Page_350"/>The <code>sys.byteorder</code> attribute provides the byte order of the current system as a string. On my machine, as on most modern computers, the value is the string <code>'little'</code>, for little-endian.</p>
<p>Now, I can create my <code>bytes</code> object:</p>
<pre><code>answer = 42
bits = answer.to_bytes( <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> 4, byteorder=sys.byteorder)
print(bits.hex( <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> sep=' '))  # prints '2a 00 00 00'</code></pre>
<p class="CodeListingCaption"><a id="listing12-17">Listing 12-17</a>: int_to_bytes.py:2a</p>
<p>I start by binding an integer value to the name <code>answer</code>. All <code>int</code> objects have a <code>to_bytes()</code> method for converting the value to a bytes-like object. I call that method on <code>answer</code>, passing the desired size in bytes (arbitrary for this example) of the resulting bytes-like object <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the byte order to use. I bind the <code>bytes</code> object to the name <code>bits</code>.</p>
<p>Finally, to make the output more readable, I print out the value of <code>bits</code> in hexadecimal, instead of the default bytestring, separating the individual byte values with spaces <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The value <code>42</code> is representable with only one byte, and this byte (<code>2a</code>) appears on the left, since I’m using little-endian byte order.</p>
<p>When I try this with negative numbers, things get a little trickier. The same method as above would not work for the value <code>-42</code>:</p>
<pre><code>answer = -42
bits = answer.to_bytes(4, byteorder=sys.byteorder)
print(bits.hex(sep=' '))</code></pre>
<p class="CodeListingCaption"><a id="listing12-18">Listing 12-18</a>: int_to_bytes.py:3a</p>
<p>This code fails on the <code>answer.to_bytes()</code> method call with the following:</p>
<pre><code>Traceback (most recent call last):
  File "tofrombytes.py", line 10, in &lt;module&gt;
    bits = answer.to_bytes(4, byteorder=sys.byteorder)
OverflowError: can't convert negative int to unsigned</code></pre>
<p>To get around this, I must explicitly specify that the integer is <em>signed</em>, meaning two’s complement is being used to represent negative numbers:</p>
<pre><code>answer = -42
bits = answer.to_bytes(4, byteorder=sys.byteorder<b>, signed=True</b>)
print(bits.hex(sep=' '))  # prints 'd6 ff ff ff'</code></pre>
<p class="CodeListingCaption"><a id="listing12-19">Listing 12-19</a>: int_to_bytes.py:3b</p>
<p>This version works as expected, as you can see from the output of the <code>print</code> statement.</p>
<p>By default, the <code>signed</code> parameter is <code>False</code> to avoid surprises, many originating from the fact that Python only <em>pretends</em> to use two’s complement but is really doing its own thing. In any case, you should get into the habit of setting it to <code>True</code> when converting anything that <em>might</em> be a negative number to an integer. If the integer value is positive, setting <code>signed</code> to <code>True</code> won’t have any effect:</p>
<pre><code><span epub:type="pagebreak" title="351" id="Page_351"/>answer = 42
bits = answer.to_bytes(4, byteorder=sys.byteorder, <b>signed=True</b>)
print(bits.hex(sep=' '))  # prints '2a 00 00 00'</code></pre>
<p class="CodeListingCaption"><a id="listing12-20">Listing 12-20</a>: int_to_bytes.py:2b</p>
<h3 id="h2-500920c12-0006">Sequence Operations</h3>
<p class="BodyFirst">Nearly all operations you can perform on a sequence like a tuple or a list, you can do with bytes-like objects. For example, to see if there’s a particular sequence of bytes in a larger bytes object, you can use the <code>in</code> operator:</p>
<pre><code>bits = b'\xaa\xbb\xcc\xdd\xee\xff'
print(b'\xcc\xdd' in bits)  # prints 'True'</code></pre>
<p class="CodeListingCaption"><a id="listing12-21">Listing 12-21</a>: bytes_in.py</p>
<p>The <code>in</code> operator here is acting like it would with a string.</p>
<p>I won’t go into any more depth on these operations here, as they behave precisely like they would in <code>tuple</code> (for <code>bytes</code>) or <code>list</code> (for <code>bytearray</code>).</p>
<h3 id="h2-500920c12-0007">Converting bytes to int</h3>
<p class="BodyFirst">You can create an integer from a <code>bytes</code> object using <code>int.from_bytes()</code>. I’ll start by defining a <code>bytes</code> object to convert from:</p>
<pre><code>import sys

bits = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> (-42).to_bytes(4, byteorder=sys.byteorder, signed=True)</code></pre>
<p class="CodeListingCaption"><a id="listing12-22">Listing 12-22</a>: bytes_to_int.py:1</p>
<p>In the same way I called <code>to_bytes()</code> on a name bound to an integer value, I call the same method on an integer literal wrapped in parentheses here <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This code defines a new <code>bytes</code> object, bound to the name <code>bits</code>, with the same value as in <a href="#listing12-19" id="listinganchor12-19">Listing 12-19</a>.</p>
<p>To convert the value from <code>bits</code> into an integer value, I use the <code>int.from_bytes()</code> method, which I’m calling on the <code>int</code> class:</p>
<pre><code>answer = int.from_bytes(bits, byteorder=sys.byteorder, signed=True)
print(answer)  # prints '-42'</code></pre>
<p class="CodeListingCaption"><a id="listing12-23">Listing 12-23</a>: bytes_to_int.py:2</p>
<p>I pass <code>bits</code> to the method and indicate the <code>byteorder</code> and the <code>bytes</code> object used. I also indicate via <code>signed=True</code> that the bytes object is using two’s complement to represent negative values. The byte order and signed values are not remembered by the bytes object; you’ll need to know these whenever converting from <code>bytes</code> objects to integers.</p>
<p>The value of <code>answer</code> is <code>-42</code>, which was obtained from the bytes object.</p>
<h2 id="h1-500920c12-0004"><span epub:type="pagebreak" title="352" id="Page_352"/>struct</h2>
<p class="BodyFirst">The deeper you get into Python’s inner workings, the more you discover the C language peeking through. This is largely owing to the fact that CPython, the primary implementation of Python, is written in C. Interoperability with C remains a factor in how the language is implemented. One example of this is the <code>struct</code> module. It was originally created to allow data to be moved between Python values and C structs. It soon proved to be a handy way to convert values to packed binary data, specifically <em>contiguous</em> binary data, which is stored one item after the next in memory.</p>
<p>The modern <code>struct</code> module uses <code>bytes</code> for storing this binary data, providing the sixth way of creating bytes-like objects. Unlike <code>int.to_bytes()</code>, which is limited to integers, the <code>struct.pack()</code> method can also convert floating-point numbers and strings (character arrays) to binary, using whichever byte order you request. However, remember that strings themselves are unaffected by byte order. You can also use <code>struct.pack()</code> to pack multiple values into the same <code>bytes</code> object and later unpack those individual values into separate variables.</p>
<p>By default, <code>struct</code> will align all values to the exact sizes expected by the C compiler on your system, padding (or truncating padding) where necessary, although you can change this alignment behavior to use standard sizes instead.</p>
<h3 id="h2-500920c12-0008">struct Format String and Packing</h3>
<p class="BodyFirst">The byte order, alignment behavior, and data types for <code>struct</code> are determined by the <em>format string</em>, which must be passed to any of the module’s functions, or else to the initializer of the <code>struct.Struct</code> object, which lets you reuse the format string more efficiently.</p>
<p>Often, the first character of the format string defines the byte order and alignment behavior, as in <a href="#table12-9" id="tableanchor12-9">Table 12-9</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table12-9">Table 12-9</a>: struct Format String Byte Order Flags</p></figcaption>
<table id="table-500920c12-0009" border="1">
<thead>
<tr>
<td><b>Character</b></td>
<td><b>Behavior</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>@</code></td>
<td>Use native byte order and alignment (default).</td>
</tr>
<tr>
<td><code>=</code></td>
<td>Use native byte order, but no alignment.</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Little-endian, no alignment.</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Big-endian, no alignment.</td>
</tr>
<tr>
<td><code>!</code></td>
<td>Network standard: big-endian, no alignment (same as <code>&gt;</code>).</td>
</tr>
</tbody>
</table>
</figure>
<p>If you omit this initial character, <code>struct</code> will use the native byte order and alignment (same as if you start with <code>@</code>), padding the data as necessary to make sense to the C compiler. The rest of the string indicates the data <span epub:type="pagebreak" title="353" id="Page_353"/>types and order of the values being packed into the struct. Each of the basic C data types is represented by a character, as shown in <a href="#table12-10" id="tableanchor12-10">Table 12-10</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table12-10">Table 12-10</a>: struct Format Characters</p></figcaption>
<table id="table-500920c12-0010" border="1">
<thead>
<tr>
<td><b>Character</b></td>
<td><b>C type</b></td>
<td><b>Python type</b></td>
<td><b>Standard size</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>?</code></td>
<td><code>_Bool</code> (C99)</td>
<td><code>bool</code></td>
<td>1</td>
</tr>
<tr>
<td><code>c</code></td>
<td><code>char</code></td>
<td><code>bytes(1)</code></td>
<td>1</td>
</tr>
<tr>
<td><code>b</code></td>
<td><code>signed char</code></td>
<td><code>int</code></td>
<td>1</td>
</tr>
<tr>
<td><code>B</code></td>
<td><code>unsigned char</code></td>
<td><code>int</code></td>
<td>1</td>
</tr>
<tr>
<td><code>h</code></td>
<td><code>short</code></td>
<td><code>int</code></td>
<td>2</td>
</tr>
<tr>
<td><code>H</code></td>
<td><code>unsigned short</code></td>
<td><code>int</code></td>
<td>2</td>
</tr>
<tr>
<td><code>i</code></td>
<td><code>int</code></td>
<td><code>int</code></td>
<td>4</td>
</tr>
<tr>
<td><code>I</code></td>
<td><code>unsigned int</code></td>
<td><code>int</code></td>
<td>4</td>
</tr>
<tr>
<td><code>l</code></td>
<td><code>long</code></td>
<td><code>int</code></td>
<td>4</td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>unsigned long</code></td>
<td><code>int</code></td>
<td>4</td>
</tr>
<tr>
<td><code>q</code></td>
<td><code>long long</code></td>
<td><code>int</code></td>
<td>8</td>
</tr>
<tr>
<td><code>Q</code></td>
<td><code>unsigned long long</code></td>
<td><code>int</code></td>
<td>8</td>
</tr>
<tr>
<td><code>e</code></td>
<td>(IEEE 754 binary16 “half precision”)</td>
<td><code>float</code></td>
<td>2</td>
</tr>
<tr>
<td><code>f</code></td>
<td><code>float</code></td>
<td><code>float</code></td>
<td>4</td>
</tr>
<tr>
<td><code>d</code></td>
<td><code>double</code></td>
<td><code>float</code></td>
<td>8</td>
</tr>
<tr>
<td><code>s</code></td>
<td><code>char[]</code></td>
<td><code>bytes</code></td>
<td/>
</tr>
<tr>
<td><code>p</code></td>
<td><code>char[]</code> (Pascal string)</td>
<td><code>bytes</code></td>
<td/>
</tr>
<tr>
<td><code>x</code></td>
<td>(pad byte)</td>
<td>effectively <code>bytes(1)</code></td>
<td/>
</tr>
</tbody>
</table>
</figure>
<p>Most of these types are self-explanatory, especially if you know C (or C++, for that matter). When using native alignment, the size of each type will depend on the system; otherwise, <code>struct</code> uses the standard size.</p>
<p>If I wanted to pack two integers and a boolean, in that order, using big-endian notation (and standard sizes), I’d use the following format string:</p>
<pre><code>import struct

bits = struct.pack('&gt;ii?', 4, 2, True)
print(bits)  # prints '\x00\x00\x00\x04\x00\x00\x00\x02\x01'</code></pre>
<p class="CodeListingCaption"><a id="listing12-24">Listing 12-24</a>: struct_multiple_values.py:1a</p>
<p>Here, I use the <code>struct.pack()</code> function, to which I pass the format string and all the values I want to pack, in order. This creates a bytes object.</p>
<p><span epub:type="pagebreak" title="354" id="Page_354"/>Alternatively, I can precede the type character with the desired number of values of that type. Here, I specify two adjacent integer values with <code>2i</code>, instead of <code>ii</code>. The outcome is the same as before:</p>
<pre><code>import struct

bits = struct.pack(<b>'&gt;2i?'</b>, 4, 2, True)
print(bits)  # prints '\x00\x00\x00\x04\x00\x00\x00\x02\x01'</code></pre>
<p class="CodeListingCaption"><a id="listing12-25">Listing 12-25</a>: struct_multiple_values.py:1b</p>
<p>The format character <code>'e'</code> refers to the <em>half-precision</em> floating-point number introduced in the 2008 revision of the IEEE 754, which is the document that defines the floating-point standard used by all modern computers.</p>
<p>The pad byte, <code>'x'</code>, is exactly one empty byte (<code>\x00</code>). Use <code>'x'</code> to manually pad your data. For example, to pack two integers with exactly three empty bytes between them, I’d use the following:</p>
<pre><code>import struct

bits = struct.pack('&gt;i3xi', -4, -2)
print(bits)  # prints '\xff\xff\xff\xfc\x00\x00\x00\xff\xff\xff\xfe'</code></pre>
<p class="CodeListingCaption"><a id="listing12-26">Listing 12-26</a>: struct_ints_padded.py:1</p>
<p>There are two ways to represent strings in <code>struct</code>. Typically, you must <em>null-terminate</em> traditional strings (<code>'s'</code>), meaning the last character is always <code>\x00</code>, to mark the end. The number preceding the format character is the length of the string in characters; <code>'10s'</code> would be a 10-character string (that is, 9 characters and the null terminator byte). I can pack the string <code>"Hi!"</code> like this:</p>
<pre><code>import struct

bits = struct.pack('&gt;4s', b"Hi!")
print(bits)  # prints 'Hi!\x00'</code></pre>
<p class="CodeListingCaption"><a id="listing12-27">Listing 12-27</a>: struct_string.py:1</p>
<p>You’ll notice that I wrote my string as a bytes literal by prepending it with <code>b</code>. The <code>struct.pack()</code> method cannot work directly with strings, but rather must have a bytes literal where the format calls for a string. (A little later, I have an example where I convert a typical UTF-8 string to a bytes literal.)</p>
<p>As long as you know the size of your string and the data will only ever be read by your code, you don’t have to include the null terminator byte here. However, it’s good to be in the habit if you’ll be sending your data out of Python. If a C program tried to work with a string that lacked a null terminator, some pretty strange behavior could result.</p>
<p>Alternatively, you can use a Pascal string (<code>'p'</code>), which begins with a single byte representing the size as an integer. This string format doesn’t require a null termination character, because its size is explicitly stored in the first byte. However, it also effectively limits the maximum size of the string to 255 bytes.</p>
<pre><code><span epub:type="pagebreak" title="355" id="Page_355"/>bits = struct.pack('&gt;4p', b"Hi!")
print(bits)  # prints '\x03Hi!'</code></pre>
<p class="CodeListingCaption"><a id="listing12-28">Listing 12-28</a>: struct_string.py:2</p>
<p>Another consideration is that you may need to pad your <code>struct</code> to the <em>word size</em>, which is the smallest addressable chunk of memory, on your system. This is especially relevant when packing data to be handed off to C.</p>
<p>For example, a C <code>struct</code> of two longs and one short has a length of 24 bytes, but the format string <code>'@llh'</code> only produces an 18-byte chunk of binary. To correct this, append the format string with a zero, followed by the largest type in your struct; in this case, that format string would be <code>'@llh0l'</code>:</p>
<pre><code>struct.calcsize('@llh')    # prints '18' (wrong)
struct.calcsize('@llh0l')  # prints '24' (correct, what C expects)</code></pre>
<p>There is never any danger in padding this way. If it’s not needed, the size will be unaffected. This is only applicable when using native byte order and alignment (<code>@</code>), which is necessary for exchanging data with C. If you’re specifying byte order manually or using network standard (no alignment), this won’t matter and will have no effect.</p>
<p>There are also three types I’ve deliberately omitted from <a href="#table12-10">Table 12-10</a>: <code>ssize_t</code> (<code>n</code>), <code>size_t</code> (<code>N</code>), and <code>void*</code> (<code>P</code>). These are only available if you’re using native byte ordering and alignment (<code>@</code>), but you won’t need those unless you’re moving data between C and Python. See the documentation if you need to know about them: <a href="https://docs.python.org/3/library/struct.html#format-characters." class="LinkURL">https://docs.python.org/3/library/struct.html#format-characters.</a></p>
<h3 id="h2-500920c12-0009">Unpacking with struct</h3>
<p class="BodyFirst">To unpack data from a <code>struct</code> back into Python values, I must first determine the appropriate format string for the binary data.</p>
<p>Consider an integer packed into <code>bytes</code> using native byte order and alignment:</p>
<pre><code>import struct

answer = -360
bits = struct.pack('i', answer)</code></pre>
<p class="CodeListingCaption"><a id="listing12-29">Listing 12-29</a>: struct_int.py:1</p>
<p>As long as I know that <code>bits</code> uses native ordering and contains a single integer, I can retrieve that integer with <code>struct.unpack()</code>:</p>
<pre><code>new_answer, = struct.unpack('i', bits)
print(new_answer)  # prints '-360'</code></pre>
<p class="CodeListingCaption"><a id="listing12-30">Listing 12-30</a>: struct_int.py:2</p>
<p><span epub:type="pagebreak" title="356" id="Page_356"/>Notice that I included a trailing comma (<code>,</code>) after <code>new_answer</code> in the assignment statement. The <code>struct.unpack()</code> function always returns a tuple, which I must unpack. Since that tuple contains only one value, the trailing comma forces it to unpack; otherwise, <code>new_answer</code> would be bound to the tuple itself.</p>
<p>As one more example, I’ll unpack the two integers from the bytes-like object from <a href="#listing12-26" id="listinganchor12-26">Listing 12-26</a>:</p>
<pre><code>first, second = struct.unpack('&gt;i3xi', bits)
print(first, second)  # prints '-4 -2'</code></pre>
<p class="CodeListingCaption"><a id="listing12-31">Listing 12-31</a>: struct_ints_padded.py:2</p>
<p>The three pad bytes (<code>'3x'</code>) are discarded, and the two integers are unpacked into the names <code>first</code> and <code>second</code>.</p>
<p>When working with <code>struct</code>, it is absolutely imperative that you know the format string that was used to pack the <code>struct</code> in the first place. Observe what would happen if I changed the format string in a few ways:</p>
<pre><code>wrong = struct.unpack('&lt;i3xi', bits)   # wrong byte order
print(*wrong)                          # prints '-50331649 -16777217'

wrong = struct.unpack('&gt;f3xf', bits)   # wrong types
print(*wrong)                          # prints 'nan nan'

wrong = struct.unpack('&gt;hh3xhh', bits) # wrong integer type
print(*wrong)                          # prints '-1 -4 -1 -2'

wrong = struct.unpack('&gt;q3xq', bits)   # data sizes too large
print(*wrong)                          # throws struct.error</code></pre>
<p class="CodeListingCaption"><a id="listing12-32">Listing 12-32</a>: struct_ints_padded.py:3</p>
<p>All but the last example <em>seem</em> to work, but all the values I’ve unpacked are wrong. The moral is simple: know your layout so you can use the correct format strings.</p>
<h3 id="h2-500920c12-0010">struct objects</h3>
<p class="BodyFirst">If you need to use the same format string repeatedly, the most efficient approach is to initialize a <code>struct.Struct</code> object, which provides methods analogous to the <code>struct</code> functions. For example, here I want to repeatedly pack two integers and a floating-point number into bytes objects, so I’ll create a <code>Struct</code> object.</p>
<pre><code>import struct

packer = struct.Struct('iif')</code></pre>
<p class="CodeListingCaption"><a id="listing12-33">Listing 12-33</a>: struct_object.py:1</p>
<p><span epub:type="pagebreak" title="357" id="Page_357"/>I create a <code>Struct</code> object with the format string <code>'iif'</code>, and I bind it to the name <code>packer</code>. The <code>Struct</code> object remembers this format string and uses it for any <code>pack()</code> or <code>unpack()</code> calls on the object.</p>
<p>Next, I’ll write a generator that produces some strange numeric data and packs it into bytes-like objects:</p>
<pre><code>def number_grinder(n):
    for right in range(1, 100):
        left = right % n
        result = left / right
        yield packer.pack(left, right, result)</code></pre>
<p class="CodeListingCaption"><a id="listing12-34">Listing 12-34</a>: struct_object.py:2</p>
<p>In this example, I’m iterating over integers 1 through 99 as the <code>right</code> operand of division, and then I’m taking as the <code>left</code> operand the modulo of the <code>right</code> value and whatever number was passed to the function as <code>n</code>. Then, I perform the division with left and right, binding the result to <code>result</code>. (There’s no particular reason for this math; it’s just for fun.)</p>
<p>Next, I use <code>packer.pack()</code> and pass it the operands and the result of the division. The <code>packer</code> object uses the format string I passed to its initializer earlier.</p>
<p>In the next part of my code, I retrieve the packed <code>struct</code> data from the generator and, for the sake of the example, unpack the data again, using the <code>packer</code> object:</p>
<pre><code>for bits in number_grinder(5):
    print(*packer.unpack(bits))</code></pre>
<p class="CodeListingCaption"><a id="listing12-35">Listing 12-35</a>: struct_object.py:3</p>
<p>If you run that code, you’ll see the <code>left</code>, <code>right</code>, and <code>result</code> values that had been packed into the bytes objects yielded by the generator. This is a silly example, of course; in the real world, I would have done something useful with this binary data, such as storing it in a file, instead of merely unpacking it again.</p>
<h2 id="h1-500920c12-0005">Bitwise on Bytes-Like Objects</h2>
<p class="BodyFirst">As I mentioned earlier, bytes-like objects, including <code>bytes</code> and <code>bytearray</code>, do not directly support bitwise operators. Annoying as this may seem, it makes sense when you consider that bytes-like objects don’t know their own byte order. If you performed a bitwise operation between a big-endian and a little-endian value, it would be impossible to determine the byte order of the result. If there’s one thing that Python developers hate, it’s unclear behavior.</p>
<p>It is possible to perform bitwise operations on bytes-like objects, but you must use one of two workarounds.</p>
<h3 id="h2-500920c12-0011"><span epub:type="pagebreak" title="358" id="Page_358"/>Bitwise Operations via Integers</h3>
<p class="BodyFirst">The first option is to convert the bytes-like objects to integers first, which resolves the byte order. Integers in Python are technically infinite, so this approach can be leveraged for handling binary data of differing lengths.</p>
<p>Here, I write a function to handle a bitwise operation between two bytes-like objects:</p>
<pre><code>def bitwise_and(left, right, *, byteorder):
    size = max(len(left), len(right))</code></pre>
<p class="CodeListingCaption"><a id="listing12-36">Listing 12-36</a>: bitwise_via_int.py:1</p>
<p>My <code>bitwise_and()</code> function accepts three arguments: the two bytes-like objects (<code>left</code> and <code>right</code>) as operands for the bitwise operation, plus the byteorder. You will recall that the <code>*</code> in the parameter list forces all parameters after it, namely <code>byteorder</code>, to be keyword-only arguments. I don’t offer a default argument for <code>byteorder</code>, for the same reason <code>bytes</code> objects don’t have bitwise operators. If the user is unable to provide this argument explicitly, the function should fail, rather than potentially producing garbage output.</p>
<p>To convert the result back to <code>bytes</code> in the last step, I must know the size of the result (which should be size of the largest <code>bytes</code> object passed to it) so I don’t chop off leading or trailing zeros—or actual data, if this were for another bitwise operation!</p>
<p>Because <code>bytes</code> is a sequence, it implements the <code>__len__()</code> special method. In my function, I take the <code>max()</code> of the lengths of the two <code>bytes</code> arguments, and I use that value as the size of the output. Here’s the next piece of the function I started in <a href="#listing12-36" id="listinganchor12-36">Listing 12-36</a>:</p>
<pre><code>    left = int.from_bytes(left, byteorder=byteorder)
    right = int.from_bytes(right, byteorder=byteorder)</code></pre>
<p class="CodeListingCaption"><a id="listing12-37">Listing 12-37</a>: bitwise_via_int.py:2</p>
<p>I convert the <code>left</code> and <code>right</code> bytes-like objects to integers by using the <code>int.from_bytes()</code> method, employing the byte order passed to my function. Meanwhile, in writing my code, I must assume the arguments from <a href="#listing12-36">Listing 12-36</a> are mutable, lest <code>bitwise_and()</code> have a risk of side effects.</p>
<p>Please note, <em>I am not using</em> <code>signed=True</code> <em>here</em>! This is utterly vital for the bitwise operation to turn out right. Otherwise, my function will interpret any bytes-like object with a <code>1</code> in the most significant bit as indicative of a negative integer. This would thereby pad the significant end of the integer with infinite <code>1</code>s. The effective result of <code>0xCCCCCC &amp; 0xAAAA</code> according to this function would then be <code>0xCC8888</code>, rather than the correct value of <code>0x008888</code>.</p>
<p>Now that I have integer forms of these arguments, I can use the normal bitwise operator on them. Here’s the last piece of the function, continued from <a href="#listing12-37" id="listinganchor12-37">Listing 12-37</a>:</p>
<pre><code><span epub:type="pagebreak" title="359" id="Page_359"/>    result = left &amp; right
    return result.to_bytes(size, byteorder, signed=True)</code></pre>
<p class="CodeListingCaption"><a id="listing12-38">Listing 12-38</a>: bitwise_via_int.py:3</p>
<p>I bind the result of the bitwise operation to <code>result</code>. Finally, I convert <code>result</code> back to a <code>bytes</code> object, using the <code>size</code> I determined earlier, the <code>byteorder</code> passed to my function, and <code>signed=True</code> to handle conversion of any possible negative integer values. I return the resulting bytes-like object.</p>
<p>I’ll use my <code>bitwise_and()</code> function to perform a bitwise operation with any two bytes-like objects:</p>
<pre><code>bits = b'\xcc\xcc\xcc'   # 0b110011001100110011001100
bitfilter = b'\xaa\xaa'  # 0b1010101010101010

result = bitwise_and(bits, bitfilter, byteorder='big')
print(result)            # prints "b'\x00\x88\x88'"</code></pre>
<p class="CodeListingCaption"><a id="listing12-39">Listing 12-39</a>: bitwise_via_int.py:4</p>
<p>The result is exactly right! It doesn’t matter what bytes-like objects I pass to this function; it will work as expected.</p>
<h3 id="h2-500920c12-0012">Bitwise Operations via Iteration</h3>
<p class="BodyFirst">The bitwise-via-integers approach is the most flexible, but it can be impractical when you’re working with a lot of data, since you’re duplicating the contents of the two <code>bytes</code> objects in <code>int</code>. For the algorithmic efficiency crowd, the integer approach has a space complexity of <code>Θ(n)</code>. Another option is to use iteration, instead of using integers as intermediary objects. Interestingly, both options have roughly the same time complexity. In fact, the iterative approach is slightly <em>slower</em>! Its strength is a lower space complexity, which lets it avoid excessive memory consumption when processing a large amount of data.</p>
<p>When you have a lot of binary data on which to perform bitwise operations, it’s sometimes better to leverage the iterable nature of bytes-like objects. Here, I’ll write another function for performing a bitwise operation on two bytes-like objects, this time with iteration:</p>
<pre><code>def bitwise_and(left, right):
    return bytes(l &amp; r for l, r in zip(left, right))</code></pre>
<p class="CodeListingCaption"><a id="listing12-40">Listing 12-40</a>: bitwise_via_iter.py:1a</p>
<p>Within my <code>bitwise_and()</code> function, I employ a generator expression to create a new <code>bytes</code> object, which I ultimately return. Iterating over bytes-like objects yields positive integer values equivalent to each byte. The <code>zip()</code> function allows me to iterate over both the <code>left</code> and <code>right</code> bytes objects at the same time, and then I take the bitwise and (<code>&amp;</code>) of the pair of integers produced on each iteration.</p>
<p><span epub:type="pagebreak" title="360" id="Page_360"/>I use this function in much the same manner as with the integer version, except that I don’t need to bother with the byte order. The implicit byte order of the operands is used. (As mentioned earlier, it’s your responsibility to ensure the byte orders are the same!)</p>
<p>Here’s the usage of my function from <a href="#listing12-40" id="listinganchor12-40">Listing 12-40</a>:</p>
<pre><code>bits = b'\xcc\xcc\xcc'   # 0b110011001100110011001100
bitfilter = b'\xaa\xaa'  # 0b1010101010101010

result = bitwise_and(bits, bitfilter)
print(result)            # prints "b'\x88\x88'"</code></pre>
<p class="CodeListingCaption"><a id="listing12-41">Listing 12-41</a>: bitwise_via_iter.py:2</p>
<p>This present approach has one significant limitation: I can only reliably perform bitwise operations if the operands are the same length. Otherwise, the result will only be as long as the shortest operand object.</p>
<p>It is possible to work with operands of different sizes, but for that, I must know the byte order again, so I know which side to pad. It took me and my colleague Daniel Foerster a fair bit of back-and-forth to work out a reliable and Pythonic solution to this particular problem.</p>
<p>Here’s an expanded form of the iterative <code>bitwise_and()</code> function from <a href="#listing12-40">Listing 12-40</a>, which now handles bytes-like objects of different sizes:</p>
<pre><code>import itertools


def bitwise_and(left, right, <b>*, byteorder</b>):
<b>    pad_left = itertools.repeat(0, max(len(right) - len(left), 0))</b>
<b>    pad_right = itertools.repeat(0, max(len(left) - len(right), 0))</b>
<b/>
<b>    if byteorder == 'big':</b>
<b>        left_iter = itertools.chain(pad_left, left)</b>
<b>        right_iter = itertools.chain(pad_right, right)</b>
<b>    elif byteorder == 'little':</b>
<b>        left_iter = itertools.chain(left, pad_left)</b>
<b>        right_iter = itertools.chain(right, pad_right)</b>
<b>    else:</b>
<b>        raise ValueError("byteorder must be either 'little' or 'big'")</b>
    
    return bytes(l &amp; r for l, r in zip(<b>left_iter, right_iter</b>))</code></pre>
<p class="CodeListingCaption"><a id="listing12-42">Listing 12-42</a>: bitwise_via_iter.py:1b</p>
<p>I create <code>pad_left</code> and <code>pad_right</code>, which are iterables for the padding on the <code>left</code> or <code>right</code> operands, respectively. Each of these uses <code>itertools.repeat()</code> to produce the value <code>0</code> on each iteration, up to a particular number of iterations. That limit is calculated as how many more bytes the other operand has than one I’m padding, or zero if this operand is the larger of the two.</p>
<p>Next, I create two more iterables that combine the padding and the operand for each side of the bitwise operation. The byte order determines <span epub:type="pagebreak" title="361" id="Page_361"/>the order in which I combine the padding and operand iterables, as the padding must be applied to the higher-value end.</p>
<p>If anything other than <code>'big'</code> or <code>'little'</code> is passed to the <code>byteorder</code> parameter, I raise a <code>ValueError</code>. (The exception and its message I raise there are the same as what <code>int.from_bytes()</code> would raise with a nonsense <code>byteorder</code> argument.)</p>
<p>Finally, with the <code>left_iter</code> and <code>right_iter</code> iterables, which will produce the same number of bytes, I perform the iterative bitwise in a generator expression, as before.</p>
<p>The usage and return of this version of my <code>bitwise_and()</code> function is identical to that of the integer-based version:</p>
<pre><code>bits = b'\xcc\xcc\xcc'   # 0b110011001100110011001100
bitfilter = b'\xaa\xaa'  # 0b1010101010101010

result = bitwise_and(bits, bitfilter<b>, byteorder='big'</b>)
print(result)            # prints "b'\x00\x88\x88'"</code></pre>
<p class="CodeListingCaption"><a id="listing12-43">Listing 12-43</a>: bitwise_via_iter.py:2b</p>
<p>Again, the advantage of the iterative approach is that it is optimized for space complexity. In terms of time complexity, it is slower than the integer-based approach from earlier, so it should be reserved for working with particularly large bytes-like objects. Otherwise, stick with <code>int.from_bytes()</code> and <code>int.to_bytes()</code> for bitwise operations on bytes-like objects.</p>
<h2 id="h1-500920c12-0006">memoryview</h2>
<p class="BodyFirst">When you’re slicing a bytes object, a copy of the data being sliced is created. Ordinarily, this has no negative effects, especially when you’re going to assign the data anyway. However, when you’re working with particularly large slices, especially repeatedly, all that copying can create some serious performance slowdowns.</p>
<p>The <code>memoryview</code> class helps alleviate that, by accessing the raw memory data of any object that implements the <em>buffer protocol</em>, a set of methods that provide and govern access to an underlying memory array. Bytes-like objects fit this qualification, and you’ll most often use <code>memoryview</code> with <code>bytes</code> and <code>bytearray</code>. You won’t often encounter the buffer protocol in any types other than binary-oriented objects, although <code>array.array</code> is a notable exception. (In fact, the buffer protocol is defined and implemented at the C level, rather than in Python itself, so implementing it in your own classes is decidedly nontrivial.)</p>
<p>Since <code>memoryview</code> is designed to provide very low-level access to memory, it has a lot of particularly advanced methods and concepts, which I won’t get into here. I will show you its most basic usage: slicing, or accessing a part of, a bytes-like object by reading in place, rather than by making a copy of the sliced data. Although this is only called for when dealing with particularly large buffers, I’ll demonstrate with a small <code>bytes</code> object for brevity.</p>
<p>In this example, I want to employ slicing to confirm that a bit of binary data fits a particular format—perhaps that two <code>0xFF</code> bytes appear after every three bytes. (Why I’d do this in the real world is beyond me; I just needed <span epub:type="pagebreak" title="362" id="Page_362"/>an example.) Effectively, I want to slice the fourth and fifth bytes from every five bytes, as the first three of each set of five can be anything.</p>
<p>I’ll start with the version without <code>memoryview</code> first, for reference:</p>
<pre><code>def verify(bits):
    for i in range(3, len(bits), 5):
        if bits[i:i+2] != b'\xff\xff':
            return False
    return True</code></pre>
<p class="CodeListingCaption"><a id="listing12-44">Listing 12-44</a>: slicing_with_memoryview.py:1a</p>
<p>With this function, I iterate based on the fourth byte (the first in the pair), via the <code>for</code> loop. As soon as I reach the end of <code>bits</code>, I know I’ve processed everything. (If this ever slices out only the last byte, the code runs just fine and returns <code>False</code>, as it should.)</p>
<p>Within each iteration of my loop, I slice out the two bytes I care about with <code>bits[i:i+2]</code> and compare that to the <code>b'\xff\xff'</code> I’m checking for. If it doesn’t match, I immediately return <code>False</code>. However, if the code makes it through the loop without that condition failing, then the function returns <code>True</code>.</p>
<p>Here’s the usage:</p>
<pre><code>good = b'\x11\x22\x33\xff\xff\x44\x55\x66\xff\xff\x77\x88'
print(verify(good))  # prints 'True'

nope = b'\x11\x22\x33\xff\x44\x55\x66\x77\xff\x88\x99\xAA'
print(verify(nope))  # prints 'False'</code></pre>
<p class="CodeListingCaption"><a id="listing12-45">Listing 12-45</a>: slicing_with_memoryview.py:2</p>
<p>As I mentioned, this code is perfectly fine in most cases. When I slice, I make a copy of those two bytes. But if that slice is something on the order of two <em>kilobytes</em> in length, with hundreds of slices being made, I may run into some serious performance issues with all that copying.</p>
<p>This is where <code>memoryview</code> comes in handy. I’ll update my example to use that instead.</p>
<pre><code>def verify(bits):
    <b>is_good = True</b>
<b>    view = memoryview(bits)</b>
    for i in range(3, len(<b>view</b>), 5):
        if <b>view</b>[i:i+2] != b'\xff\xff':
            <b>is_good = False</b>
            <b>break</b>
    <b>view.release()</b>
    return <b>is_good</b></code></pre>
<p class="CodeListingCaption"><a id="listing12-46">Listing 12-46</a>: slicing_with_memoryview.py:1b</p>
<p>The code is functionally the same as before, except that this time, I create a <code>memoryview</code> object, which I bind to the name <code>view</code>, to give me direct access to the underlying memory of <code>bits</code>.</p>
<p><span epub:type="pagebreak" title="363" id="Page_363"/>I can use <code>memoryview</code> in essentially the same way as I would <code>bytes</code>, except that slicing on a <code>memoryview</code> only views the data in place, rather than creating a copy of the data.</p>
<p>It is <em>vital</em> that I release the <code>memoryview</code> as soon as I’m done with it, by calling the <code>release()</code> method on my <code>memoryview</code> object. Objects that support the buffer protocol know when they’re being watched by a <code>memoryview</code>, and they will change their behavior in various ways to prevent memory errors. For example, a <code>bytearray</code> object will not resize as long as there’s a <code>memoryview</code> of it. It is always safe to call the <code>release()</code> method; at worst, it will do nothing at all. Once I release a <code>memoryview</code>, I cannot use it further. Attempting to do so would raise a <code>ValueError</code>.</p>
<p>Unfortunately, my code is still rather un-Pythonic, what with having to assign a value to <code>is_good</code> and return with that name at the function end. I’d like to polish that up.</p>
<p>Hmm . . . I have to remember to close something when I’m finished with it. Surely, that means <code>memoryview</code> is also a context manager that I can use in a <code>with</code> statement. Sure enough, that works! I can incorporate that technique to make my function more concise and Pythonic:</p>
<pre><code>def verify(bits):
    <b>with memoryview(bits) as view:</b>
        for i in range(3, len(view), 5):
            if view[i:i+2] != b'\xff\xff':
                <b>return False</b>
<b>    return True</b></code></pre>
<p class="CodeListingCaption"><a id="listing12-47">Listing 12-47</a>: slicing_with_memoryview.py:1c</p>
<p>That’s more like it. This code still behaves the same as the preceding two versions, but it reads cleaner and doesn’t make copies of the data it’s slicing out. The usage and outcome are the same as in <a href="#listing12-45" id="listinganchor12-45">Listing 12-45</a>.</p>
<h2 id="h1-500920c12-0007">Reading and Writing Binary Files</h2>
<p class="BodyFirst">Just as you can write strings out to a file using a stream, you can use a stream to write binary data to a file. Binary file formats, as you’ll see later, have a few advantages over text-based file formats, especially in terms of compact file sizes and faster processing. The techniques are almost identical to those in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>, with one critical difference: the stream must be opened in <em>binary mode</em>, instead of the default text mode. This returns a <code>BufferedReader</code>, <code>BufferedWriter</code>, or <code>BufferedRandom</code> object, depending on the mode you open with (see Table 11-1 from <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>).</p>
<p>There are a number of existing file formats for storing data in binary, which I’ll discuss later, but for this example, I’ll create my own format using <code>struct</code>. This may be called for sometimes in your own projects, when you need to store very specific data in a particular manner. Designing your own binary file format can require considerable thought and planning, but when done right, a custom file format can be made to fit your data like a glove. As you’ll see, <code>struct</code> is particularly suitable for this, because of its format strings.</p>
<h3 id="h2-500920c12-0013"><span epub:type="pagebreak" title="364" id="Page_364"/>Organizing the Data</h3>
<p class="BodyFirst">In this section, I’ll create a basic class structure for keeping track of a personal bookshelf. Ultimately, I’ll be able to write this bookshelf data to a binary stream (including a binary file) and create a bookshelf from a binary stream.</p>
<p>I’ll break my code down into three files: <em>book.py</em>, <em>bookshelf.py</em>, and <em>__main__.py</em>, all in the same package. That package will also need to contain an <em>__init__.py</em> file, which will be empty in this case. All of these files will go into a directory, <em>rw_binary_example/</em>, which will become the package. Here’s my file structure for the example:</p>
<pre><code>rw_binary_example/
├── book.py
├── bookshelf.py
├── __init__.py
├── __main__.py</code></pre>
<p class="CodeListingCaption"><a id="listing12-48">Listing 12-48</a>: File structure of rw_binary_example/ package</p>
<h4 id="h3-500920c12-0007">The Book class</h4>
<p class="BodyFirst">The basic unit of data in my code is a <code>Book</code>, which I’ll write as its own class:</p>
<pre><code>import struct


class Book:

    packer = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> struct.Struct("&gt;64sx64sx2h")

    def __init__(self, title="", author="", pages=0, pages_read=0):
        self.title = title
        self.author = author
        self.pages = pages
        self.pages_read = pages_read
        
    def update_progress(self, pages_read):
        self.pages_read = min(pages_read, self.pages)</code></pre>
<p class="CodeListingCaption"><a id="listing12-49">Listing 12-49</a>: book.py:1</p>
<p>Most of this will look familiar by now. A book has a <code>title</code>, an <code>author</code>, a page count (<code>pages</code>), and an instance attribute for tracking how many pages have been read (<code>pages_read</code>). I also provide an <code>update_progress()</code> method to update the number of pages the user has read so far.</p>
<p>The line of particular interest here is the one where I define the class attribute <code>packer</code>. I bind this name to a <code>Struct</code> object, wherein I define the binary format for my object in a format string <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Here, I use the <code>Struct</code> object instead of the <code>pack()</code> function directly from the <code>struct</code> module. I do this for two reasons: (1) so there’s a single canonical source for the binary <span epub:type="pagebreak" title="365" id="Page_365"/>format I’m using and (2) because it means the format string is <em>precompiled</em> into a Python bytecode object, making for more efficient reuse.</p>
<p>I’m using big-endian byte order, not only because it’s familiar, but also because it’s what I’d use if I wanted to send this data over the internet (although I’m not doing so here). If I have to make a somewhat arbitrary decision, like choosing a byte order, I might as well maximize the possibilities of what I can do with the data!</p>
<p>I’ll also set a limit on the size of my string. I need a predictable format so I can read from the binary data later, and working with data that varies in size can be forbiddingly difficult. For my program, I set a size limit of 64 bytes, which should be sufficient for encoding most book titles and authors. I use <code>64s</code> in my format string to denote the <code>struct</code> fields for title and author. I also follow each of these fields with a padding byte (<code>x</code>), which will guarantee that these fields can always be interpreted as C-style null-terminated strings, even if all 64 characters are used. That makes for one less potential bug if my data needs to be interpreted by code in another programming language.</p>
<p>I also specify two 2-byte (short) integers (<code>2h</code>) for storing the page count and pages read. This should be sufficient space for both, since a book with more than 32,767 pages is rather an absurd idea. (I could also make this number unsigned, but I don’t really need the slightly higher maximum value. Perhaps I’ll find a clever use for negative values in a later version of my code.) If I try to pack too large a value into a struct field, a <code>struct.error</code> exception will be raised.</p>
<p>Now that I have my class and its format string, I can write an instance method for converting to binary the book data from the <code>Book</code> class I started in <a href="#listing12-49" id="listinganchor12-49">Listing 12-49</a>:</p>
<pre><code>    def serialize(self):
        return self.packer.pack(
            self.title.encode(),
            self.author.encode(),
            self.pages,
            self.pages_read
        )</code></pre>
<p class="CodeListingCaption"><a id="listing12-50">Listing 12-50</a>: book.py:2</p>
<p>To use the precompiled format string from earlier, I call the <code>pack()</code> method on the <code>self.packer</code> instance attribute, instead of using <code>struct.pack()</code>. I only need to pass the data I’m packing into binary.</p>
<p>I must call the <code>encode()</code> method on each of my strings to convert them from UTF-8 to bytes literal strings. I could also have used <code>self.title.encode(encoding='utf-8')</code> to explicitly specify the encoding. I might specify the encoding if I were using some string encoding other than the default UTF-8.</p>
<p>The integer values, <code>self.pages</code> and <code>self.pages_read</code>, can be passed as is.</p>
<p>The <code>self.packer.pack()</code> method returns a bytes object, which I then return from the <code>serialize</code> method.</p>
<h4 id="h3-500920c12-0008"><span epub:type="pagebreak" title="366" id="Page_366"/>The Bookshelf class</h4>
<p class="BodyFirst">My program will store a collection of <code>Book</code> objects in a <code>Bookshelf</code>, which will be little more than a thin wrapper around a list:</p>
<pre><code>import struct
from .book import Book

class Bookshelf:
    fileinfo = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> struct.Struct('&gt;h')
    version = 1

    def __init__(self, *books):
        self.shelf = [*books]
        
    def __iter__(self):
        return iter(self.shelf)
        
    def add_books(self, *books):
        self.shelf.extend(books)</code></pre>
<p class="CodeListingCaption"><a id="listing12-51">Listing 12-51</a>: bookshelf.py:1</p>
<p>I’m importing the <code>Book</code> class from the <code>book</code> module that lives in the same package as this module, so I use a relative import, as seen on the first line.</p>
<p>The <code>Bookshelf</code> class initializes the list, <code>self.shelf</code>, which will store any book objects passed as arguments to the initializer. Users can also add more books to the shelf with the <code>add_books()</code> method.</p>
<p>I allow iterating over the books directly by returning the iterator for the list from <code>__iter__()</code>, as there’s no need to reinvent the wheel here.</p>
<p>I could add some other features, such as removing or looking up specific books, but I want to keep this simple, to focus on converting this data to binary.</p>
<p>Most important to this example is the additional <code>Struct</code> that I’ve created and bound to <code>fileinfo</code>. I’ll use it to store the file format <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Along with that, I have a <code>version</code> class attribute for tracking the file format version number. This way, if I later change my <em>.shlf</em> file format, I can tell my future code how to read both the old and the new files.</p>
<p>I define a method for writing this data to a binary stream. You’ll recall from <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span> that files are opened as streams. I can also apply these same techniques to send the data to another process or over a network to another machine.</p>
<pre><code>    def write_to_stream(self, stream):
        stream.write(self.fileinfo.pack(self.version))
        for book in self.shelf:
            stream.write(book.serialize())</code></pre>
<p class="CodeListingCaption"><a id="listing12-52">Listing 12-52</a>: bookshelf.py:2</p>
<p>The <code>write_to_stream()</code> method accepts a stream object as an argument. I write the <em>.shlf</em> file format version, <code>version</code>, to the binary stream first. My code <span epub:type="pagebreak" title="367" id="Page_367"/>can later check this first value and ensure the <em>.shlf</em> file being read follows the expected format.</p>
<p>Next, I iterate over the <code>Book</code> objects in the <code>self.shelf</code> list, call the <code>serialize()</code> method on each book, and write the returned bytes object to the stream using <code>stream.write()</code>. Since the stream automatically moves its position to the end of the last data I wrote to the binary file, I don’t need to call <code>stream.seek()</code> at any point.</p>
<h3 id="h2-500920c12-0014">Writing to a File</h3>
<p class="BodyFirst">Now, I can put my <code>Book</code> and <code>Bookshelf</code> classes to work to store some data:</p>
<pre><code>from .bookshelf import Bookshelf
from .book import Book


def write_demo_file():
    # Write to file

    cheuk_ting_bookshelf = Bookshelf(
        Book("Automate the Boring Stuff with Python", "Al Sweigart", 592, 592),
        Book("Doing Math with Python", "Amit Saha", 264, 100),
        Book("Black Hat Python", "Justin Seitz", 192, 0),
        Book("Serious Python", "Julien Danjou", 240, 200),
        Book("Real-World Python", "Lee Vaughan", 370, 370),
    )</code></pre>
<p class="CodeListingCaption"><a id="listing12-53">Listing 12-53</a>: __main__.py:1</p>
<p>I import my <code>Book</code> and <code>Bookshelf</code> classes at the top of the module. In my <code>write_demo_file()</code> function, I create the new <code>Bookshelf</code> object <code>cheuk_ting_bookshelf</code> and fill it with some data. Cheuk Ting sure has good taste in books!</p>
<p>Next, within that same <code>write_file()</code> method, I add the following to open a file in binary write mode:</p>
<pre><code>    with open('mybookshelf.shlf', 'bw') as file:
        cheuk_ting_bookshelf.write_to_stream(file)</code></pre>
<p class="CodeListingCaption"><a id="listing12-54">Listing 12-54</a>: __main__.py:2</p>
<p>You’ll recall from <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span> that including <code>b</code> in the mode string on <code>open()</code> will open the stream in <em>binary mode</em>, instead of the default text mode. I want to write out the file, overwriting its contents if the file already exists, so I use <code>w</code> mode.</p>
<p>To aid you in following this example, I’ll create a stub function for my <code>read_demo_file()</code> function now and fill it in later:</p>
<pre><code>def read_demo_file():
    """TODO: Write me."""</code></pre>
<p class="CodeListingCaption"><a id="listing12-55">Listing 12-55</a>: __main__.py:3a</p>
<p><span epub:type="pagebreak" title="368" id="Page_368"/>After opening my file, I pass it to the <code>write_to_stream()</code> method of my <code>cheuk_ting_bookshelf</code> object.</p>
<p>At the bottom of <em>__main__.py</em>, I must include the usual boilerplate for executing my <code>main()</code> function:</p>
<pre><code>if __name__ == "__main__":
    write_demo_file()</code></pre>
<p class="CodeListingCaption"><a id="listing12-56">Listing 12-56</a>: <em>__main__.py:4a</em></p>
<p>That’s it! Running the package (via <code>python3 -m rw_binary_example</code>) creates a new file in my current working directory entitled <em>mybookshelf.shlf</em>. If you open that file in a text editor capable of displaying binary files, such as Visual Studio Code, you’ll likely see the titles and authors of the books displayed amidst a bunch of strange symbols.</p>
<p>I’ve created a binary file containing my data! (I’ll admit, I did some serious chuckling to myself after I got this example working.)</p>
<h3 id="h2-500920c12-0015">Reading from a Binary File</h3>
<p class="BodyFirst">The <em>.shlf</em> file I created is merely a blob of binary data, with no information on how to read it. For my <em>.shlf</em> format to be of any use, I need to expand my program to be able to read in the data from <em>.shlf</em> files, converting that binary data back into strings and integers.</p>
<p>In the <code>Book</code> class again, I add a method for creating a new object from the binary data I would read from a <em>.shlf</em> file:</p>
<pre><code>    @classmethod
    def deserialize(cls, bits):
        title, author, pages, pages_read = cls.packer.unpack(bits)
        title = title.decode()
        author = author.decode()</code></pre>
<p class="CodeListingCaption"><a id="listing12-57">Listing 12-57</a>: <em>book.py:3</em></p>
<p>I’ve chosen to make this a class method, rather than an instance method, to prevent the undesired side effect of overwriting another book. The method accepts a bytes object, and I use the <code>Book.packer</code> class attribute (see <a href="#listing12-49">Listing 12-49</a>) to unpack the binary data into four names.</p>
<p>I use <code>decode()</code> to convert the strings from bytes to UTF-8. As before, if I were decoding into anything other than UTF-8, I’d need to specify the encoding via the <code>encoding=</code> parameter of <code>decode()</code>.</p>
<p>The <code>unpack()</code> method automatically converts the integer values to <code>int</code>.</p>
<p>Finally, within this same <code>deserialize()</code> class method, I create and return a new <code>Book</code> object from the values I unpacked:</p>
<pre><code>        return cls(title, author, pages, pages_read)</code></pre>
<p class="CodeListingCaption"><a id="listing12-58">Listing 12-58</a>: <em>book.py:4</em></p>
<p>I’ll put this new class method to work in my <code>Bookshelf</code> class.</p>
<p><span epub:type="pagebreak" title="369" id="Page_369"/>Next, I’ll add a <code>from_stream()</code> class method for creating a new Bookshelf from a binary stream:</p>
<pre><code>    @classmethod
    def from_stream(cls, stream):
        size = cls.fileinfo.size
        version, = cls.fileinfo.unpack(stream.read(size))
        if version != 1:
            raise ValueError(f"Cannot open .shlf v{version}; expect v1.")</code></pre>
<p class="CodeListingCaption"><a id="listing12-59">Listing 12-59</a>: <em>bookshelf.py:3</em></p>
<p>My <code>from_stream()</code> class method receives a stream object as an argument, <code>stream</code>.</p>
<p>Before I do any processing, I need to check the format version of a <em>.shlf</em> file, in case some user in the future tries to open a (theoretical, for now) version-2 file with this package. To do that, I first determine how many bytes to read off the beginning of my file, where I stored the version data. <code>Struct</code> objects like <code>cls.fileinfo</code> (see <a href="#listing12-51" id="listinganchor12-51">Listing 12-51</a>) have a <code>size</code> attribute, which returns an integer representing the exact number of bytes needed to represent data packed into that <code>Struct</code>.</p>
<p>I read the number of bytes indicated by <code>size</code> from the binary stream using <code>stream.read(size)</code>, and I pass the returned bytes literal to <code>cls.fileinfo.unpack()</code>. That returns a tuple of values, but as the tuple has only one value in this case, I must be careful to unpack that value into <code>version</code>, rather than binding the tuple itself to that name.</p>
<p>I check the returned file format version before proceeding, raising a <code>ValueError</code> if the format version is wrong for this code. A future expanded version of this code might allow me to switch which <code>Struct</code> object I use in the <code>Book</code> module, based on the format version of the file being read.</p>
<p>Now, I prepare to read the data for the individual books:</p>
<pre><code>        size = Book.packer.size
        shelf = Bookshelf()</code></pre>
<p class="CodeListingCaption"><a id="listing12-60">Listing 12-60</a>: <em>bookshelf.py:4</em></p>
<p>I get the size in bytes of the <code>Struct</code> object the <code>Book</code> class uses, and I store that in <code>size</code>. I instantiate a new <code>Bookshelf</code> object, which I bind to <code>shelf</code>. I’m now ready to read the rest of the data in the binary stream:</p>
<pre><code>        while bits := stream.read(size):
            shelf.add_books(Book.deserialize(bits))
            
        return shelf</code></pre>
<p class="CodeListingCaption"><a id="listing12-61">Listing 12-61</a>: <em>bookshelf.py:5</em></p>
<p>Within the header of a loop, I use <code>stream.read(size)</code> to read the next segment of data from the binary stream, which I bind to <code>bits</code>. I’m using an <em>assignment expression</em>, via the <em>walrus operator</em>, in this context, so I can also <span epub:type="pagebreak" title="370" id="Page_370"/>check the value of <code>bits</code> right here in the loop header. Then, I implicitly check that <em>bits</em> is not an empty bytes literal (<code>bytes()</code>)—the value of <code>bits</code> will be “falsey,” or implicitly evaluate to <code>False</code> in the conditional, only if it is actually empty—which would indicate that I’ve reached the end of the stream. Any other value of <code>bits</code>, even <code>b'\x00'</code>, would cause this expression to evaluate to <code>True</code>.</p>
<p>Within the suite of this loop, I create a new <code>Book</code> from the binary data in <code>bits</code>, using the <code>Book.deserialize()</code> class method. Then, I add that <code>Book</code> object to the <code>Bookshelf</code> object bound to <code>shelf</code>, which I build here.</p>
<p>Finally, after the loop completes, I return <code>shelf</code>.</p>
<p>Because of how I’ve structured the <code>Bookshelf</code> and <code>Book</code> classes, the code for reading a <em>.shlf</em> file is quite elegant. I’ll fill in my <code>read_demo_file()</code> function in the <em>__main__.py</em> module now.</p>
<p>Laís received some book recommendations from her friend Cheuk Ting in a <em>.shlf</em> file, so she needs to open that file. Here is the code that allows her to do so with the <code>Bookshelf</code> class:</p>
<pre><code>def read_demo_file():
    with open('mybookshelf.shlf', 'br') as file:
        lais_bookshelf = Bookshelf.from_stream(file)
        
    for book in lais_bookshelf:
        print(book.title)</code></pre>
<p class="CodeListingCaption"><a id="listing12-62">Listing 12-62</a>: <em>__main__.py:3b</em></p>
<p>I open the <em>mybookshelf.shlf</em> file in <em>binary read</em> mode (<code>br</code>). I pass the <code>file</code> stream object to <code>Bookshelf.from_stream()</code>, and then I bind the resulting <code>Bookshelf</code> object to <code>lais_bookshelf</code>.</p>
<p>Finally, to verify everything has worked, I iterate over each book in <code>lais_bookshelf</code> and print the titles.</p>
<p>I must be certain to call <code>read_demo_file()</code>:</p>
<pre><code>if __name__ == "__main__":
    write_demo_file()
    read_demo_file()</code></pre>
<p class="CodeListingCaption"><a id="listing12-63">Listing 12-63</a>: <em>__main__.py:4b</em></p>
<p>Running that code outputs the following:</p>
<pre><code>Automate the Boring Stuff with Python
Doing Math with Python
Black Hat Python
Serious Python
Real-World Python</code></pre>
<p>Laís’s bookshelf is now identical to Cheuk Ting’s!</p>
<p>I hope Cheuk Ting remembers to recommend <em>Dead Simple Python</em> to Laís, too, after she gets done with it.</p>
<h3 id="h2-500920c12-0016"><span epub:type="pagebreak" title="371" id="Page_371"/>Seek with Binary Stream</h3>
<p class="BodyFirst">When working with streams, you can change stream position if you only want to read or modify part of a stream, rather than traversing or processing the whole thing. Recall from <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span> that you can work with the stream position on a text stream using the <code>tell()</code> and <code>seek()</code> methods. You can use these same methods with binary stream objects, namely <code>BufferedReader</code>, <code>BufferedWriter</code>, and <code>BufferedRandom</code>, but with some additional functionality on <code>seek()</code>.</p>
<p>The <code>seek()</code> method accepts two arguments. The first is <code>offset</code>, which is the number of bytes to move in the stream. Positive offset values move forward, and negative offset values move backward.</p>
<p>The second argument is <code>whence</code>, which provides the starting position that <code>offset</code> moves from. With text streams, the offset must be zero. That limitation doesn’t exist on binary streams!</p>
<p>With binary streams, there are three possible values for whence: <code>0</code> for start, <code>1</code> for current position, and <code>2</code> for end. If I wanted to seek to six bytes from the end of a stream, I’d do something like this:</p>
<pre><code>from pathlib import Path
Path('binarybits.dat').write_bytes(b'ABCDEFGHIJKLMNOPQRSTUVWXYZ')


with open('binarybits.dat', 'br') as file:
    file.seek(-6, 2)</code></pre>
<p class="CodeListingCaption"><a id="listing12-64">Listing 12-64</a>: <em>seek_binary_stream.py:1</em></p>
<p>Providing a whence of <code>2</code> means I start seeking from the end of the stream, and the offset argument of <code>-6</code> moves back six bytes from there.</p>
<p>Similarly, if I then wanted to move forward two bytes from the current stream position, I’d use the following:</p>
<pre><code>    file.seek(2, 1)</code></pre>
<p class="CodeListingCaption"><a id="listing12-65">Listing 12-65</a>: <em>seek_binary_stream.py:2</em></p>
<p>The whence argument of <code>1</code> starts the seek from the current position, and the offset argument of <code>2</code> moves forward two bytes from there.</p>
<p>One word of caution when using <code>seek()</code>: only use positive offsets when starting at the beginning of your file (a whence of <code>0</code>, the default), or the statement will raise an <code>OSError</code>. Similarly, be careful not to rewind past the start of the stream when using a negative offset and a whence of <code>1</code>.</p>
<p>Always use negative offsets when starting at the end of your file (a whence of <code>2</code>). Positive offsets won’t raise an error, but seeking past the end of the buffer is rather pointless, if benign. Seeking past the end and then writing data to the buffer from that position will actually drop said data into a black hole; it won’t be written to the stream. If you want to append to a stream, position yourself at the end with <code>file.seek(0, 2)</code>.</p>
<h3 id="h2-500920c12-0017"><span epub:type="pagebreak" title="372" id="Page_372"/>BufferedRWPair</h3>
<p class="BodyFirst">One of the fun things about writing a book like <em>Dead Simple Python</em> is discovering unfamiliar techniques. While perusing the Python documentation for this section, I learned about another type of binary stream called a <code>BufferedRWPair</code>, which accepts two stream objects: one to read from and another to write from. (These <em>must</em> be different stream objects!)</p>
<p>The primary use of <code>BufferedRWPair</code> is in working with a socket or a two-way pipe, wherein your code communicates with another process on the system through two separate buffers: one for receiving data from the other process and another for sending data.</p>
<p>Another use would be to simplify the process of reading data from one source, possibly process it, and then send it somewhere else. For example, I could use this to read data from a device’s serial port and write it directly out to a file.</p>
<p>I won’t write a full example for this here, as it would be fairly involved and likely use topics I haven’t covered. (I prefer to stay reasonably relevant.) The usage of <code>BufferedRWPair</code> is about the same as any other byte stream, except that you’d explicitly initialize it by passing two streams: one to read and one to write.</p>
<p>For a simple example, I’ll first create a binary file containing some data using the normal means:</p>
<pre><code>from pathlib import Path
Path('readfrom.dat').write_bytes(b'\xaa\xbb\xcc')</code></pre>
<p class="CodeListingCaption"><a id="listing12-66">Listing 12-66</a>: <em>creating_bufferedrwpair.py:1</em></p>
<p>This code only creates the file <em>readfrom.dat</em>, so I have something to read from in the important part of the example.</p>
<p>I create a <code>BufferedRWPair</code> by passing it a stream to read and a stream to write. I’ll use the <code>open()</code> method on <code>Path</code> to create the streams:</p>
<pre><code>from io import BufferedRWPair
with BufferedRWPair(Path('readfrom.dat').open('rb'), Path('writeto.dat').open('wb')) as buffer:
    data = buffer.read()
    print(data)  # prints "b'\xaa\xbb\xcc'"
    buffer.write(data)</code></pre>
<p class="CodeListingCaption"><a id="listing12-67">Listing 12-67</a>: <em>creating_bufferedrwpair.py:2</em></p>
<p>To verify this works, I’ll open <em>writeto.dat</em> directly in read mode to see its contents:</p>
<pre><code>Path('writeto.dat').read_bytes()  # prints "b'\xaa\xbb\xcc'"</code></pre>
<p class="CodeListingCaption"><a id="listing12-68">Listing 12-68</a>: <em>creating_bufferedrwpair.py:3</em></p>
<p>That’s clearly an oversimplified example, but you get the essential idea. There are many uses for <code>BufferedRWPair</code> in advanced situations. Chances are, you’ll know when you need it.</p>
<h2 id="h1-500920c12-0008"><span epub:type="pagebreak" title="373" id="Page_373"/>Serialization Techniques</h2>
<p class="BodyFirst">As mentioned in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>, <em>serialization</em> is the process of converting data to a format that can be stored. This data can be written to a file, transmitted over a network, or even shared between processes. The inverse operation is <em>deserialization</em>, which converts the serialized data back into its original form, or at least a close equivalent.</p>
<p>I also touched on a number of formats used for serialization, especially JSON and CSV. All of these formats were text based and intended to be human readable, which makes them excellent candidates for files that the user should be able to modify by hand. Human-readable formats are also <em>futureproof</em>, meaning in this case that the deserialization process can be reverse engineered if the presently used technology or format specification ever ceases to exist. (And that happens more often than you might think!)</p>
<p>There are a few disadvantages of using human-readable, text-based serialization formats, rather than <em>binary</em> serialization formats. The first is size: it will virtually always take more memory to represent non-string data as a string than to use its original, binary form. Text-based formats are also often slower to deserialize, in contrast to binary formats. This is one reason why binary formats are better suited to the <em>virtual machine</em> design pattern, wherein different bytes correspond to different behaviors. Most interpreted languages, including Python itself, use some form of this design pattern internally.</p>
<p>The third disadvantage of text-based serialization formats is the same as one of its advantages: the file can be easily modified. You may want to discourage users from directly editing particularly complex or fragile data, as minor errors can corrupt the file. Using binary serialization formats is an effective way of discouraging file tampering.</p>
<p>A good example of this is <em>Minecraft’s .dat</em> file format, which contains serialized game world data in a binary format. (The fact that <em>Minecraft</em> is written in Java is beside the point; principles of serialization are language agnostic.) It’s important to note that obfuscation is not an effective security technique. <em>Minecraft</em> <em>.dat</em> files are still editable by the end user, as evidenced by third-party programs like MCEdit.</p>
<p>If you want to protect your serialized data, <em>encryption</em> is your only answer. How you apply encryption depends on your situation.</p>
<p>For example, the space simulator game <em>Oolite</em> uses XML to serialize player data so the file can still be read and edited by the user, but it includes a hash string of the data in the file so the game can detect cheating and make minor adjustments to gameplay.</p>
<p>In an application where security really matters, the serialized data will often be fully encrypted. Many applications will store saved passwords in this manner, encrypted behind a master password or key, to prevent the data from being intercepted. The passwords must be serialized and stored to disk for the program to retain them, but the encryption ensures that no one else can deserialize the data.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2><span epub:type="pagebreak" title="374" id="Page_374"/>GOTCHA ALert</h2><p class="BoxBodyFirst">Obscuring a user’s own data with nonstandard binary serialization formats and encrypting it when security is not a factor are widespread anti-patterns. Locking in your users by limiting their access to their data in this manner is generally considered unethical. Use these tools wisely and strongly consider making your serialization format specifications public.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>In short, your decision on whether to use text-based or binary serialization depends entirely on your situation. Binary serialization can offer smaller file sizes, faster deserialization, and the added benefit of discouraging tampering by end users. However, binary-based formats are not as futureproof as text-based formats, and they can also give users an uneasy feeling of opacity about the data. These are the reasons why they’re seldom used for serializing settings.</p>
<h3 id="h2-500920c12-0018">Forbidden Tools: pickle, marshal, and shelve</h3>
<p class="BodyFirst"><em>Pickle</em> is a common built-in serialization tool. It stores Python objects in a binary format that can be saved to a file and then later deserialized, or <em>unpickled</em>, into a Python object again. Sounds perfect, right?</p>
<p>There’s a big red box at the top of the documentation that screams about security concerns with <code>pickle</code>, and it may be tempting to overlook that. “This is merely a calculator app,” a developer might say. “Security doesn’t matter here.”</p>
<p>Except the security here has nothing to do with the data itself. Pickled data can be tampered with to execute arbitrary code, meaning if you use <code>pickle</code> for serialization, your Python program can be made to do <em>literally anything</em>. If someone modifies pickled data on a user’s machine, which isn’t difficult to do, your harmless Python program will become malware as soon as it unpickles that file.</p>
<p>It’s possible to guard against file tampering by signing data with a message authentication module called <code>hmac</code>, but at that point, it would be more straightforward to use the other techniques from this chapter to serialize data in a secure fashion. Pickled data isn’t intended to make sense outside of Python anyway, whereas a custom serialization approach <em>could</em> be made portable.</p>
<p>What’s more, <code>pickle</code> is painfully slow and produces some pretty bloated files. It’s practically the most inefficient way to serialize anything to a file, even before I consider security.</p>
<p>There are two related built-in tools in Python: <code>marshal</code> and <code>shelve</code>. The former, <code>marshal</code>, is really only intended to be used internally by Python, as its deliberately undocumented specification can change between Python versions. It also has the same issues related to security and performance as does <code>pickle</code>, so it shouldn’t be considered an alternative. Even if it were perfect, it would still not be intended for your use.</p>
<p>The <code>shelve</code> module is built on <code>pickle</code>, and it should be dismissed for the same reasons as <code>pickle</code>.</p>
<p>Frankly, <code>pickle</code>, <code>marshal</code>, and <code>shelve</code> offer no advantages over other serialization-to-file techniques. They’re like <code>sudo pip</code>: they <em>appear</em> to work <span epub:type="pagebreak" title="375" id="Page_375"/>until they completely kick the pooch, at which point, you discover in the most painful way possible how much evil they conceal.</p>
<p>Ignore the myriad tutorials and misguided Stack Overflow answers on this one. Unless you’re transferring data directly between processes, please forget that these modules exist at all, except to warn other Python developers away from them. Leave the <code>pickle</code> in the fridge.</p>
<p>You may wonder why these modules are even included in the standard library in the first place. There are a few factors.</p>
<p>First, <code>pickle</code> does have one valid use: transferring data between running processes. This is safe because the data is never written to a file. Speed and size are still problems here, but there are efforts to mitigate these issues, as it’s believed to be easier to redeem <code>pickle</code> than to invent a whole new protocol. Python 3.8 saw a new version of the <code>pickle</code> protocol, which is meant to improve handling of large data (see PEP 574). I’ll revisit <code>pickle</code> in <span class="xref" itemid="xref_target_Chapter 17">Chapter 17</span>, when I cover multiprocessing.</p>
<p>Second, plenty of Python code exists that relies on these modules. At one time, <code>pickle</code> was considered the “one obvious way” of serializing data, although it has long since fallen out of favor as its flaws have become apparent. There’s already a move to deprecate and remove many so-called “dead batteries” (a reference to Python’s “batteries included” nature) from the standard library, but <code>pickle</code> isn’t on that list because of its use in multiprocessing.</p>
<p>That leaves only one solution: accept that <code>pickle</code>, <code>marshal</code>, and <code>shelve</code> have their uses, but that serialization-to-file is not among them.</p>
<h3 id="h2-500920c12-0019">Serialization Formats</h3>
<p class="BodyFirst">So if <code>pickle</code> and friends are out, what options remain? Thankfully, quite a few! I’ve compiled a short list of some of the most common and popular binary serialization formats, but it is far from exhaustive. If you are interested in any of these file formats, peruse the official documentation for the associated module or library.</p>
<h4 id="h3-500920c12-0009">Property List</h4>
<p class="BodyFirst">The <em>property list</em>, or <em>.plist</em> file, is a serialization format that was created for the NeXTSTEP operating system in the 1980s and was further developed for its descendants: macOS and GNUstep. Although it is primarily used with these platforms, you can certainly employ property lists in your own project. This is one of the best ways to perform binary serialization without <code>pickle</code>.</p>
<p>There are two major flavors of property list: binary and the human-readable, XML-based form. Both can be serialized and deserialized with the built-in <code>plistlib</code> module.</p>
<p>One of the advantages of property lists in Python is that they can directly serialize most basic types, including dictionaries, which are frequently used as the top-level objects (like with JSON).</p>
<p>To learn more, read the official documentation at <a href="https://docs.python.org/3/library/plistlib.html" class="LinkURL">https://docs.python.org/3/library/plistlib.html</a>.</p>
<h4 id="h3-500920c12-0010"><span epub:type="pagebreak" title="376" id="Page_376"/>MessagePack</h4>
<p class="BodyFirst">One of the leading formats for binary serialization is <em>MessagePack</em>, which is designed to produce simple, compact serialized output. It is based on JSON, and for the most part, it can represent the same sort of data.</p>
<p>The official third-party package, <em>msgpack</em>, can be installed via pip. More information and official documentation can be found on the MessagePack website: <a href="https://msgpack.org/" class="LinkURL">https://msgpack.org/</a>.</p>
<h4 id="h3-500920c12-0011">BSON</h4>
<p class="BodyFirst">Another binary serialization format based on JSON is called <em>BSON</em> (for “binary JSON”). Being a binary format, BSON is much faster to deserialize than JSON. It also usually produces files that are smaller, though still larger than those produced by MessagePack. In certain situations, BSON files can even be larger than the equivalent JSON file. BSON also provides some additional types over MessagePack.</p>
<p>As MongoDB makes significant use of the BSON format, the MongoDB package for Python, <em>pymongo</em>, provides a <em>bson</em> package. A fork of this package is also available simply as <em>bson</em>, if you don’t want the whole <em>pymongo</em> package. You can also learn more about BSON from the specification’s official website: <a href="http://bsonspec.org/" class="LinkURL">http://bsonspec.org/</a>.</p>
<h4 id="h3-500920c12-0012">CBOR</h4>
<p class="BodyFirst">The <em>Concise Binary Object Representation</em>, or <em>CBOR</em>, is a binary serialization format that focuses on concise encoding. Like BSON and MessagePack, it is also based on the JSON data model. Unlike its cousins, CBOR is officially defined as an internet standard by the Internet Engineering Task Force in RFC 8949, and it is employed in the Internet of Things.</p>
<p>There are a few packages available through pip for working with CBOR, the most up-to-date of which is <em>cbor2</em>. More information about the format is available from the official website: <a href="https://cbor.io/" class="LinkURL">https://cbor.io/</a>.</p>
<h4 id="h3-500920c12-0013">NetCDF</h4>
<p class="BodyFirst">The <em>Network Common Data Form</em>, or <em>NetCDF</em>, is a binary serialization format designed primarily for working with array-oriented scientific data. It was created in 1989, based on NASA’s Common Data Format, although the two formats are no longer compatible. NetCDF is still maintained by the <em>University Corporation for Atmospheric Research</em> (<em>UCAR</em>).</p>
<p>The <em>netCDF4</em> package from pip provides modules for working with the NetCDF format. You can also learn more about the format at <a href="https://www.unidata.ucar.edu/software/netcdf/" class="LinkURL">https://www.unidata.ucar.edu/software/netcdf/</a>.</p>
<h4 id="h3-500920c12-0014">Hierarchial Data Format</h4>
<p class="BodyFirst">The <em>Hierarchial Data Format</em>, or <em>HDF</em>, is a binary serialization format designed for storing large amounts of data. It is developed and maintained by the not-for-profit HDF Group, and it is used heavily in science, <span epub:type="pagebreak" title="377" id="Page_377"/>engineering, finance, data analysis, and even creative projects. It has had a central role in some major NASA projects, and it was employed in producing movies such as <em>The Lord of the Rings</em> and <em>Spider-Man 3</em>.</p>
<p>HDF5 is the latest version of the format and is the current recommended standard. The HDF Group still supports and maintains HDF4.</p>
<p>A number of third-party modules exist for working with HDF. Two of the leading options are <em>h5py</em> and <em>tables</em>. More information about the format is available from The HDF Group’s website: <a href="https://www.hdfgroup.org/" class="LinkURL">https://www.hdfgroup.org/</a>.</p>
<h4 id="h3-500920c12-0015">Protocol Buffers</h4>
<p class="BodyFirst">Google’s <em>Protocol Buffers</em> is an increasingly popular binary serialization format, but I’m addressing it last because it operates in a very different manner from the others.</p>
<p>Unlike in most formats, which have existing standard specifications, you define a tailor-made specification for your file in a special <em>.proto</em> schema file. This schema is then compiled into your favorite language, using Google’s proto compiler; in the case of Python, it produces a Python module. You would then use this generated module for serialization and deserialization, according to the specification you created.</p>
<p>If you’re interested in this, refer to Google’s official documentation: <a href="https://developers.google.com/protocol-buffers/docs/pythontutorial" class="LinkURL">https://developers.google.com/protocol-buffers/docs/pythontutorial</a>.</p>
<h4 id="h3-500920c12-0016">A Few More</h4>
<p class="BodyFirst">There are also a number of binary serialization formats designed for specific purposes, such as <em>GRIB</em> in meteorology and <em>FITS</em> in astronomy. Often, the best way to find a serialization format that fits your purpose is to think about your data first, how it should be stored, and in what situations it needs to be deserialized. Once you find a format that fits your particular need, find (or write) a module to work with it in Python.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2><p class="BoxBodyFirst">You may notice that I’ve omitted the built-in <em>xdrlib</em> module for working with the older XDR serialization format. It’s deprecated as of Python 3.8, and PEP 594 has it slated for removal in Python 3.10, so it’s best to not start using it.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c12-0009">Wrapping Up</h2>
<p class="BodyFirst">Binary is the language of computers. It is one of the most reliable ways for your program to share data outside of itself, whether through files (as you’ve seen here) or across processes or networks. Binary serialization formats generally offer smaller file sizes and faster deserialization than text-based formats, at the cost of less human readability. Whether you should use text or binary for any particular task partly depends on your audience: <em>text is for humans, binary is for computers</em>. Besides this, consider the available tooling for any given format and its suitability for the data you want to encode. For example, even if a user will never need to interact with a settings file, <em>.json</em> remains a popular format, if for no other reason than the ease of debugging it!</p>
<p><span epub:type="pagebreak" title="378" id="Page_378"/>The goal of a programmer is ultimately to serve as the translator between humans and computers. It takes time to master thinking in bits and bytes, binary and hexadecimal, but it’s a skill well worth cultivating. No matter how high up the tower of abstractions a programmer climbs, they can never really escape the fundamental computer language upon which everything is built. An expert programmer is one who is fluent in both human language and computer logic; the more you know of both, the better you can utilize the tools Python or any other language offers you.</p>
</section>
</div></body></html>