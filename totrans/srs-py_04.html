<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_49"/><strong><span class="big">4</span></strong><br/><strong>HANDLING TIMESTAMPS AND TIME ZONES</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">Time zones are complicated. Most people expect dealing with time zones to involve merely adding or subtracting a few hours from the universal time reference, UTC (Coordinated Universal Time), from −12 hours to +12 hours.</p>&#13;
<p class="indent">However, reality shows otherwise: time zones are not logical or predictable. There are time zones with 15-minute granularity; countries that change time zones twice a year; countries that use a custom time zone during summer, known as daylight saving time, that starts on different dates; plus tons of special and corner cases. These make the history of time zones interesting but also complicate how to handle them. All of those particularities should make you stop and think when dealing with time zones.</p>&#13;
<p class="indent">This chapter will outline why dealing with time zones is tricky and how to best handle them in your programs. We’ll look at how to build timestamp objects, how and why to make them time zone aware, and how to deal with corner cases you might come across.</p>&#13;
<h3 class="h3" id="lev1sec17"><span epub:type="pagebreak" id="page_50"/><strong>The Problem of Missing Time Zones</strong></h3>&#13;
<p class="noindent">A timestamp without a time zone attached gives no useful information, because without the time zone, you cannot infer what point in time your application is really referring to. Without their respective time zones, therefore, you can’t compare two timestamps; that would be like comparing days of the week without accompanying dates—whether Monday is before or after Tuesday depends on what weeks they’re in. Timestamps without time zones attached should be considered irrelevant.</p>&#13;
<p class="indent">For that reason, your application should never have to handle timestamps with no time zone. Instead, it must raise an error if no time zone is provided, or it should make clear what default time zone is assumed—for example, it’s common practice to choose UTC as the default time zone.</p>&#13;
<p class="indent">You also must be careful of making any kind of time zone conversion before <em>storing</em> your timestamps. Imagine a user creates a recurring event every Wednesday at 10:00 <small>AM</small> in their local time zone, say Central European Time (CET). CET is an hour ahead of UTC, so if you convert that timestamp to UTC to store it, the event will be stored as every Wednesday at 09:00 <small>AM</small>. The CET time zone switches from UTC+01:00 to UTC+02:00 in the summer, so on top of that, in the summer months, your application will compute that the event starts at 11:00 <small>AM</small> CET every Wednesday. You can see how this program quickly becomes redundant!</p>&#13;
<p class="indent">Now that you understand the general problem of handling time zones, let’s dig into our favorite language. Python comes with a timestamp object named <code>datetime.datetime</code> that can store date and time precise to the microsecond. The <code>datetime.datetime</code> object can be either time zone <em>aware</em>, in which case it embeds time zone information, or time zone <em>unaware</em>, in which case it does not. Unfortunately, the <code>datetime</code> API returns a time zone–unaware object by default, as you’ll soon see in <a href="ch04.xhtml#ch4list1">Listing 4-1</a>. Let’s look at how to build a default timestamp object and then how to rectify it so that it uses time zones.</p>&#13;
<h3 class="h3" id="lev1sec18"><strong>Building Default datetime Objects</strong></h3>&#13;
<p class="noindent">To build a <code>datetime</code> object with the current date and time as values, you can use the <code>datetime.datetime.utcnow()</code> function. This function retrieves the date and time for the UTC time zone right now, as shown in <a href="ch04.xhtml#ch4list1">Listing 4-1</a>. To build this same object using the date and time for the time zone of the region the machine is in, you can use the <code>datetime.datetime.now()</code> method. <a href="ch04.xhtml#ch4list1">Listing 4-1</a> retrieves the time and date for both UTC and my region’s time zone.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import datetime</span><br/>&gt;&gt;&gt; <span class="codestrong1">datetime.datetime.utcnow()</span><br/>  <span class="ent">➊</span> datetime.datetime(2018, 6, 15, 13, 24, 48, 27631)<span epub:type="pagebreak" id="page_51"/><br/>&gt;&gt;&gt; <span class="codestrong1">datetime.datetime.utcnow().tzinfo is None</span><br/>  <span class="ent">➋</span> True</pre>&#13;
<p class="listing1"><a id="ch4list1"/><em>Listing 4-1: Getting the time of the day with <span class="codeitalic">datetime</span></em></p>&#13;
<p class="indent">We import the <code>datetime</code> library and define the <code>datetime</code> object as using the UTC time zone. This returns a UTC timestamp whose values are year, month, date, hours, minutes, seconds, and microseconds <span class="ent">➊</span>, respectively, in the listing. We can check whether this object has time zone information by checking the <code>tzinfo</code> object, and here we’re told that it doesn’t <span class="ent">➋</span>.</p>&#13;
<p class="indent">We then create the <code>datetime</code> object using the <code>datetime.datetime.now()</code> method to retrieve the current date and time in the default time zone for the region of the machine:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">datetime.datetime.now()</span><br/>  <span class="ent">➌</span> datetime.datetime(2018, 6, 15, 15, 24, 52, 276161)</pre>&#13;
<p class="indent">This timestamp, too, is returned without any time zone, as we can tell from the absence of the <code>tzinfo</code> field <span class="ent">➌</span>—if the time zone information had been present, it would have appeared at the end of the output as something like <code>tzinfo=&lt;UTC&gt;</code>.</p>&#13;
<p class="indent">The <code>datetime</code> API always returns unaware <code>datetime</code> objects by default, and since there is no way for you to tell what the time zone is from the output, these objects are pretty useless.</p>&#13;
<p class="indent">Armin Ronacher, creator of the Flask framework, suggests that an application should always assume the unaware <code>datetime</code> objects in Python are UTC. However, as we just saw, this doesn’t work for objects returned by <code>datetime.datetime.now()</code>. When you are building datetime objects, I strongly recommend that you always make sure they are time zone aware. That ensures you can always compare your objects directly and check whether they are returned correctly with the information you need. Let’s see how to create time zone–aware timestamps using <code>tzinfo</code> objects.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>BONUS: CONSTRUCT ING A DATETIME OB JECT FROM A DATE</strong></p>&#13;
<p class="noindent">You can also build your own <code>datetime</code> object with a particular date by passing the values you want for the different components of the day, as shown in <a href="ch04.xhtml#ch4list2">Listing 4-2</a>.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import datetime</span><br/>&gt;&gt;&gt; <span class="codestrong1">datetime.datetime(2018, 6, 19, 19, 54, 49)</span><br/>datetime.datetime(2018, 6, 19, 19, 54, 49)</pre>&#13;
<p class="listing1"><a id="ch4list2"/><em>Listing 4-2: Building your own <code>timestamp</code> object</em></p>&#13;
</div>&#13;
<h3 class="h3" id="lev1sec19"><span epub:type="pagebreak" id="page_52"/><strong>Time Zone–Aware Timestamps with dateutil</strong></h3>&#13;
<p class="noindent">There are already many databases of existing time zones, maintained by central authorities such as IANA (Internet Assigned Numbers Authority), which are shipped with all major operating systems. For this reason, rather than creating our own time zone classes and manually duplicating those in each Python project, Python developers rely on the <code>dateutil</code> project to obtain <code>tzinfo</code> classes. The <code>dateutil</code> project provides the Python module <code>tz</code>, which makes time zone information available directly, without much effort: the <code>tz</code> module can access the operating system’s time zone information, as well as ship and embed the time zone database so it is directly accessible from Python.</p>&#13;
<p class="indent">You can install <code>dateutil</code> using <code>pip</code> with the command <code>pip install python-dateutil</code>. The <code>dateutil</code> API allows you to obtain a <code>tzinfo</code> object based on a time zone name, like so:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from dateutil import tz</span><br/>&gt;&gt;&gt; <span class="codestrong1">tz.gettz("Europe/Paris")</span><br/>tzfile('/usr/share/zoneinfo/Europe/Paris')<br/>&gt;&gt;&gt; <span class="codestrong1">tz.gettz("GMT+1")</span><br/>tzstr('GMT+1')</pre>&#13;
<p class="indent">The <code>dateutil.tz.gettz()</code> method returns an object implementing the <code>tzinfo</code> interface. This method accepts various string formats as argument, such as the time zone based on a location (for example, “Europe/Paris”) or a time zone relative to GMT. The <code>dateutil</code> time zone objects can be used as <code>tzinfo</code> classes directly, as demonstrated in <a href="ch04.xhtml#ch4list3">Listing 4-3</a>.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import datetime</span><br/>&gt;&gt;&gt; <span class="codestrong1">from dateutil import tz</span><br/>&gt;&gt;&gt; <span class="codestrong1">now = datetime.datetime.now()</span><br/>&gt;&gt;&gt; <span class="codestrong1">now</span><br/>datetime.datetime(2018, 10, 16, 19, 40, 18, 279100)<br/>&gt;&gt;&gt; <span class="codestrong1">tz = tz.gettz("Europe/Paris")</span><br/>&gt;&gt;&gt; <span class="codestrong1">now.replace(tzinfo=tz)</span><br/>datetime.datetime(2018, 10, 16, 19, 40, 18, 279100, tzinfo=tzfile('/usr/share/zoneinfo/Europe/<br/>Paris'))</pre>&#13;
<p class="listing1"><a id="ch4list3"/><em>Listing 4-3: Using <span class="codeitalic">dateutil</span> objects as <span class="codeitalic">tzinfo</span> classes</em></p>&#13;
<p class="indent">As long as you know the name of the desired time zone, you can obtain a <code>tzinfo</code> object that matches the time zone you target. The <code>dateutil</code> module can access the time zone managed by the operating system, and if that information is for some reason unavailable, will fall back on its own list of embedded time zones. If you ever need to access this embedded list, you can do so via the <code>datetutil.zoneinfo</code> module:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from dateutil.zoneinfo import get_zonefile_instance</span><br/>&gt;&gt;&gt; <span class="codestrong1">zones = list(get_zonefile_instance().zones)</span><br/>&gt;&gt;&gt; <span class="codestrong1">sorted(zones)[:5]</span><span epub:type="pagebreak" id="page_53"/><br/>['Africa/Abidjan', 'Africa/Accra', 'Africa/Addis_Ababa', 'Africa/Algiers', 'Africa/Asmara']<br/>&gt;&gt;&gt; <span class="codestrong1">len(zones)</span><br/>592</pre>&#13;
<p class="indent">In some cases, your program does not know which time zone it’s running in, so you’ll need to determine it yourself. The <code>datetutil.tz.gettz()</code> function will return the local time zone of your computer if you pass no argument to it, as shown in <a href="ch04.xhtml#ch4list4">Listing 4-4</a>.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from dateutil import tz</span><br/>&gt;&gt;&gt; <span class="codestrong1">import datetime</span><br/>&gt;&gt;&gt; <span class="codestrong1">now = datetime.datetime.now()</span><br/>&gt;&gt;&gt; <span class="codestrong1">localzone = tz.gettz()</span><br/>&gt;&gt;&gt; <span class="codestrong1">localzone</span><br/>tzfile('/etc/localtime')<br/>&gt;&gt;&gt; <span class="codestrong1">localzone.tzname(datetime.datetime(2018, 10, 19))</span><br/>'CEST'<br/>&gt;&gt;&gt; <span class="codestrong1">localzone.tzname(datetime.datetime(2018, 11, 19))</span><br/>'CET'</pre>&#13;
<p class="listing1"><a id="ch4list4"/><em>Listing 4-4: Obtaining your local time zone</em></p>&#13;
<p class="indent">As you can see, we pass two dates to <code>localzone.tzname(datetime.datetime())</code> separately, and <code>dateutil</code> is able to tell us that one is in Central European Summer Time (CEST) and the other is in Central European Time (no summer). If you pass in your current date, you’ll get your own current time zone.</p>&#13;
<p class="indent">You can use objects from the <code>dateutil</code> library in <code>tzinfo</code> classes without having to bother implementing those yourself in your application. This makes it easy to convert unaware <code>datetime</code> objects to aware <code>datetime</code> objects.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>IMPLEMENTING YOUR OWN TIME ZONE CLASSES</strong></p>&#13;
<p class="noindent">A class exists in Python that allows you to implement time zone classes yourself: the <code>datetime.tzinfo</code> class is an abstract class that provides a base for implementing classes representing time zones. If you ever want to implement a class to represent a time zone, you need to use this as the parent class and implement three different methods:</p>&#13;
<ul>&#13;
<li><p class="noindent"><code>utcoffset(dt)</code>, which must return an offset from UTC in minutes east of UTC for the time zone</p></li>&#13;
<li><p class="noindent"><code>dst(dt)</code>, which must return the daylight saving time adjustment in minutes east of UTC for the time zone</p></li>&#13;
<li><p class="noindent"><code>tzname(dt)</code>, which must return the name of the time zone as a string</p></li>&#13;
</ul>&#13;
<p class="indent">These three methods will embed a <code>tzinfo object</code>, allowing you to translate any time zone–aware <code>datetime</code> to another time zone.</p>&#13;
<p class="indent">However, as mentioned, since time zone databases exist, it’s impractical to implement those time zone classes oneself.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1sec20"><span epub:type="pagebreak" id="page_54"/><strong>Serializing Time Zone–Aware datetime Objects</strong></h3>&#13;
<p class="noindent">You’ll often need to transport a <code>datetime</code> object from one point to another, where those different points might not be Python native. The typical case nowadays would be with an HTTP REST API, which must return <code>datetime</code> objects serialized to a client. The native Python method named <code>isoformat</code> can be used to serialize <code>datetime</code> objects for non-Python native points, as shown in <a href="ch04.xhtml#ch4list5">Listing 4-5</a>.</p>&#13;
<pre>   &gt;&gt;&gt; <span class="codestrong1">import datetime</span><br/>   &gt;&gt;&gt; <span class="codestrong1">from dateutil import tz</span><br/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">def utcnow():</span><br/>       <span class="codestrong1">return datetime.datetime.now(tz=tz.tzutc())</span><br/>   &gt;&gt;&gt; <span class="codestrong1">utcnow()</span><br/><span class="ent">➋</span> datetime.datetime(2018, 6, 15, 14, 45, 19, 182703, tzinfo=tzutc())<br/><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong1">utcnow().isoformat()</span><br/>   '2018-06-15T14:45:21.982600+00:00'</pre>&#13;
<p class="listing1"><a id="ch4list5"/><em>Listing 4-5: Serializing a time zone–aware <span class="codeitalic">datetime</span> object</em></p>&#13;
<p class="indent">We define a new function called <code>utcnow</code> and tell it explicitly to return an object with the UTC time zone <span class="ent">➊</span>. As you can see, the object returned now contains time zone information <span class="ent">➋</span>. We then format the string using the ISO format <span class="ent">➌</span>, ensuring the timestamp also contains some time zone information (the <code>+00:00</code> part).</p>&#13;
<p class="indent">You can see I’ve used the method <code>isoformat()</code> to format the output. I recommend that you always format your <code>datetime</code> input and output strings using ISO 8601, with the method <code>datetime.datetime.isoformat()</code>, to return timestamps formatted in a readable way that includes the time zone information.</p>&#13;
<p class="indent">Your ISO 8601–formatted strings can then be converted to native <code>datetime.datetime</code> objects. The <code>iso8601</code> module offers only one function, <code>parse_date</code>, which does all the hard work of parsing the string and determining the timestamp and time zone values. The <code>iso8601</code> module is not provided as a built-in module in Python, so you need to install it using <code>pip install iso8601</code>. <a href="ch04.xhtml#ch4list6">Listing 4-6</a> shows how to parse a timestamp using ISO 8601.</p>&#13;
<pre>   &gt;&gt;&gt; <span class="codestrong1">import iso8601</span><br/>   &gt;&gt;&gt; <span class="codestrong1">import datetime</span><br/>   &gt;&gt;&gt; <span class="codestrong1">from dateutil import tz</span><br/>   &gt;&gt;&gt; <span class="codestrong1">now = datetime.datetime.utcnow()</span><br/>   &gt;&gt;&gt; <span class="codestrong1">now.isoformat()</span><br/>   '2018-06-19T09:42:00.764337'<br/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">parsed = iso8601.parse_date(now.isoformat())</span><br/>   &gt;&gt;&gt; <span class="codestrong1">parsed</span><br/>   datetime.datetime(2018, 6, 19, 9, 42, 0, 764337, tzinfo=&lt;iso8601.Utc&gt;)<br/>   &gt;&gt;&gt; <span class="codestrong1">parsed == now.replace(tzinfo=tz.tzutc())</span><br/>   True</pre>&#13;
<p class="listing1"><a id="ch4list6"/><em>Listing 4-6: Using the <span class="codeitalic">iso8601</span> module to parse an ISO 8601–formatted timestamp</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_55"/>In <a href="ch04.xhtml#ch4list6">Listing 4-6</a>, the <code>iso8601</code> module is used to construct a <code>datetime</code> object from a string. By calling <code>iso8601.parse_date</code> on a string containing an ISO 8601–formatted timestamp <span class="ent">➊</span>, the library is able to return a <code>datetime</code> object. Since that string does not contain any time zone information, the <code>iso8601</code> module assumes that the time zone is UTC. If a time zone contains correct time zone information, the <code>iso8601</code> module returns correctly.</p>&#13;
<p class="indent">Using time zone–aware <code>datetime</code> objects and using ISO 8601 as the format for their string representation is a perfect solution for most problems around time zone, making sure no mistakes are made and building great interoperability between your application and the outside world.</p>&#13;
<h3 class="h3" id="lev1sec21"><strong>Solving Ambiguous Times</strong></h3>&#13;
<p class="noindent">There are certain cases where the time of the day can be ambiguous; for example during the daylight saving time transition when the same “wall clock” time occurs twice a day. The <code>dateutil</code> library provides us with the <code>is_ambiguous</code> method to distinguish such timestamps. To show this in action, we’ll create an ambiguous timestamp in <a href="ch04.xhtml#ch4list7">Listing 4-7</a>.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import dateutil.tz</span><br/>&gt;&gt;&gt; <span class="codestrong1">localtz = dateutil.tz.gettz("Europe/Paris")</span><br/>&gt;&gt;&gt; <span class="codestrong1">confusing = datetime.datetime(2017, 10, 29, 2, 30)</span><br/>&gt;&gt;&gt; <span class="codestrong1">localtz.is_ambiguous(confusing)</span><br/>True</pre>&#13;
<p class="listing1"><a id="ch4list7"/><em>Listing 4-7: A confusing timestamp, occurring during the daylight saving time crossover</em></p>&#13;
<p class="indent">On the night of October 30, 2017, Paris switched from summer to winter time. The city switched at 3:00 <small>AM</small>, when the time goes back to 2:00 <small>AM</small>. If we try to use a timestamp at 2:30 on that date, there is no way for this object to be sure whether it is after or before the daylight saving time change.</p>&#13;
<p class="indent">However, it is possible to specify which side of the fold a timestamp is on by using the <code>fold</code> attribute, added to <code>datetime</code> objects from Python 3.6 by PEP 495 (Local Time Disambiguation—<em><a href="https://www.python.org/dev/peps/pep-0495/">https://www.python.org/dev/peps/pep-0495/</a></em>). This attribute indicates which side of the fold the datetime is on, as demonstrated in <a href="ch04.xhtml#ch4list8">Listing 4-8</a>.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import dateutil.tz</span><br/>&gt;&gt;&gt; <span class="codestrong1">import datetime</span><br/>&gt;&gt;&gt; <span class="codestrong1">localtz = dateutil.tz.gettz("Europe/Paris")</span><br/>&gt;&gt;&gt; <span class="codestrong1">utc = dateutil.tz.tzutc()</span><br/>&gt;&gt;&gt; <span class="codestrong1">confusing = datetime.datetime(2017, 10, 29, 2, 30, tzinfo=localtz)</span><br/>&gt;&gt;&gt; <span class="codestrong1">confusing.replace(fold=0).astime zone(utc)</span><br/>datetime.datetime(2017, 10, 29, 0, 30, tzinfo=tzutc())<br/>&gt;&gt;&gt; <span class="codestrong1">confusing.replace(fold=1).astime zone(utc)</span><br/>datetime.datetime(2017, 10, 29, 1, 30, tzinfo=tzutc())</pre>&#13;
<p class="listing1"><a id="ch4list8"/><em>Listing 4-8: Disambiguating the ambiguous timestamp</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_56"/>You’ll need to use this in only very rare cases, since ambiguous timestamps occur only in a small window. Sticking to UTC is a great workaround to keep life simple and avoid running into time zone issues. However, it is good to know that the <code>fold</code> attribute exists and that <code>dateutil</code> is able to help in such cases.</p>&#13;
<h3 class="h3" id="lev1sec22"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we have seen how crucial it is to carry time zone information in time stamps. The built-in <code>datetime</code> module is not complete in this regard, but the <code>dateutil</code> module is a great complement: it allows us to get <code>tzinfo</code>-compatible objects that are ready to be used. The <code>dateutil</code> module also helps us solve subtle issues such as daylight saving time ambiguity.</p>&#13;
<p class="indent">The ISO 8601 standard format is an excellent choice for serializing and unserializing timestamps because it is readily available in Python and compatible with any other programming language.</p>&#13;
</body></html>