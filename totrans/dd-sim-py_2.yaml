- en: Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分
- en: ESSENTIAL STRUCTURES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基本结构
- en: '5'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Variables and Types
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 变量与类型
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Some of the most pernicious misconceptions about Python revolve around its nuances
    regarding variables and data types. Misunderstandings related to this *one* topic
    cause countless frustrating bugs, and this is unfortunate. Python’s way of handling
    variables is at the core of its power and versatility. If you understand this,
    everything else falls into place.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 的一些最有害的误解，围绕着它在变量和数据类型上的细微差别。这些关于 *一个* 主题的误解引发了无数令人沮丧的错误，实在令人遗憾。Python
    处理变量的方式是它强大与多功能性的核心。如果你理解了这一点，其他的都能迎刃而解。
- en: My own understanding of this topic was cemented by “Facts and Myths About Python
    Names and Values,” Ned Batchelder’s now-legendary talk at PyCon 2015\. I recommend
    you watch the video of the presentation at [https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns),
    either now or after reading this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个主题的理解是在 Ned Batchelder 在 PyCon 2015 上的那场如今传奇的讲座“关于 Python 名称和值的事实与误区”中得以巩固的。我建议你在阅读本章后，观看这场讲座的视频，视频链接是
    [https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns)。
- en: 'Variables According to Python: Names and Values'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 中的变量：名称和值
- en: Many myths about Python variables stem from people’s attempts to describe the
    language in terms of *other languages*. Perhaps most annoying to Python experts
    is the misleading aphorism, “Python has no variables,” which is really just the
    product of someone being overly clever about the fact that the Python language
    uses the terms *name* and *value*, instead of *variable*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 变量的许多误解源于人们试图用 *其他语言* 的术语来描述这门语言。也许最让 Python 专家烦恼的是那个误导性的格言：“Python
    没有变量”，这其实只是因为有人过于聪明地将 Python 语言使用 *名称* 和 *值* 术语，而非 *变量*。
- en: Python developers still use the term *variable* on a regular basis, and it even
    appears in the documentation, as it is part of understanding the overall system.
    However, for the sake of clarity, I’ll use the official Python terms exclusively
    throughout the rest of the book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 开发者仍然经常使用 *变量* 这个术语，它甚至出现在文档中，因为它是理解整个系统的一部分。不过，为了清晰起见，接下来我将在本书中仅使用官方的
    Python 术语。
- en: 'Python uses the term *name* to refer to what would conventionally be called
    a variable. A name refers to a value or an object, in the same way that your name
    refers to you but does not contain you. There may even be multiple names for the
    same thing, just as you may have a given name and a nickname. A *value* is a particular
    instance of data in memory. The term *variable* refers to the combination of the
    two: a name that refers to a value. From now on, I’ll only use the term *variable*
    in relation to this precise definition.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用 *名称* 这个术语来指代传统意义上的变量。名称指向一个值或对象，就像你的名字代表你，但不包含你一样。对于同一个事物，甚至可能有多个名称，就像你可能有一个本名和一个昵称。*值*
    是内存中某个数据的特定实例。术语 *变量* 指的是两者的结合：一个指向值的名称。从现在起，我只会根据这个精确定义使用 *变量* 这个术语。
- en: Assignment
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值
- en: 'Let’s look at what happens under the hood when I define a variable per the
    above definitions like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下当我按照上面的定义来定义一个变量时，幕后发生了什么：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5-1: *simple_assignment.py:1*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-1：*simple_assignment.py:1*
- en: The name `answer` is *bound* to the value `42`, meaning the name can now be
    used to refer to the value in memory. This operation of binding is referred to
    as an *assignment*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 `answer` 被 *绑定* 到值 `42`，这意味着该名称现在可以用来引用内存中的值。这个绑定操作被称为 *赋值*。
- en: 'Look at what happens behind the scenes when I assign the variable `answer`
    to a new variable, `insight`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当我将变量 `answer` 赋值给新变量 `insight` 时，幕后发生了什么：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5-2: *simple_assignment.py:2*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-2：*simple_assignment.py:2*
- en: The name `insight` doesn’t refer to a copy of the value `42`, but rather to
    the same, original value. This is illustrated in [Figure 5-1](#figure5-1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 `insight` 并不指向值 `42` 的副本，而是指向相同的原始值。这一点在 [图 5-1](#figure5-1) 中得到了说明。
- en: '![](Images/f05001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f05001.png)'
- en: 'Figure 5-1: Multiple names can be bound to the same value in memory.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：多个名称可以绑定到内存中的同一个值。
- en: 'In memory, the name `insight` is bound to the value `42`, which was already
    bound to another name: `answer`. Both names are still usable as variables. More
    importantly, `insight` is not bound to `answer`, but rather to the same value
    that `answer` was already bound to when I assigned `insight`. A name always points
    to a value.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，`insight` 这个名字绑定到了值 `42`，而这个值之前已经绑定到了另一个名字：`answer`。这两个名字仍然可以作为变量使用。更重要的是，`insight`
    不是绑定到 `answer`，而是绑定到了 `answer` 在我为 `insight` 赋值时已经绑定的那个相同的值。一个名字始终指向一个值。
- en: Back in Chapter 3, I introduced the `is` operator, which compares *identity*—the
    specific location in memory that a name is bound to. This means `is` doesn’t check
    whether a name points to equivalent values, but rather whether it points to the
    *same* value in memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章中，我介绍了 `is` 运算符，它比较的是 *身份*——一个名字所绑定的内存中特定的位置。这意味着 `is` 并不是检查一个名字是否指向等价的值，而是检查它是否指向内存中的
    *同一个* 值。
- en: When you make an assignment, Python makes its own decisions behind the scenes
    about whether to create a new value in memory or bind to an existing value. The
    programmer often has very little control over this decision.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行赋值时，Python 会在幕后自行决定是创建一个新的值还是绑定到一个现有的值。程序员通常对这个决定几乎没有控制权。
- en: 'To see this, run this example in an interactive session instead of a file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这一点，请在交互式会话中运行此示例，而不是在文件中运行：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 5-3: (Interactive session):1'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-3：（交互式会话）：1
- en: I assign identical values to `spam` and `eggs`. I also bind `maps` to the same
    value as `spam`. (In case you didn’t catch it, “maps” is “spam” backward. No wonder
    GPS gets annoying.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我为 `spam` 和 `eggs` 赋予相同的值。 我还将 `maps` 绑定到与 `spam` 相同的值。（如果你没注意到的话，“maps” 是 “spam”
    的倒写。难怪 GPS 让人烦恼。）
- en: 'When I compare the names with the comparison operator (`==`) to check whether
    the values are equivalent, both expressions return `True`, as one would expect:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我用比较运算符（`==`）比较这两个名字，检查它们的值是否相等时，两种表达式都返回 `True`，正如预期的那样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-4: (Interactive session):2'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-4：（交互式会话）：2
- en: 'However, when I compare the identities of the names with `is`, something surprising
    happens:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我使用 `is` 比较这些名字的身份时，出现了一个令人惊讶的情况：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 5-5: (Interactive session):3'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-5：（交互式会话）：3
- en: The names `spam` and `maps` are both bound to the same value in memory, but
    `eggs` is probably bound to a different but equivalent value. Thus, `spam` and
    `eggs` don’t share an identity. This is illustrated in [Figure 5-2](#figure5-2).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam` 和 `maps` 这两个名字都绑定到了内存中的同一个值，但 `eggs` 可能绑定到不同但等价的值。因此，`spam` 和 `eggs`
    并不共享同一身份。这一点在[图 5-2](#figure5-2)中得到了说明。'
- en: '![](Images/f05002.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f05002.png)'
- en: 'Figure 5-2: `spam` and `maps` share an identity; `eggs` is bound to an equivalent
    value, but it does not share identity.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：`spam` 和 `maps` 共享身份；`eggs` 绑定到一个等价的值，但它不共享身份。
- en: It just goes to show, spam by any other name is still spam.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这也说明了，无论什么名字，spam 依旧是 spam。
- en: 'Python isn’t guaranteed to behave exactly like this, and it may well decide
    to reuse an existing value. For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并不保证像这样精确地工作，它可能会决定重用一个现有的值。例如：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-6: (Interactive session)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-6：（交互式会话）
- en: When I assign the value `42` to `insight`, Python decides to bind that name
    to the existing value. Now, `answer` and `insight` happen to be bound to the same
    value in memory, and thus, they share an identity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将值 `42` 赋给 `insight` 时，Python 决定将这个名字绑定到现有的值上。现在，`answer` 和 `insight` 恰好都绑定到了内存中的同一个值，因此，它们共享同一身份。
- en: This is why the identity operator (`is`) can be sneaky. There are many situations
    in which `is` appears to work like the comparison operator (`==`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么身份运算符（`is`）可能会让人感到困惑的原因。有很多情况下，`is` 看起来像是比较运算符（`==`）。
- en: As a final note, the built-in function `id()` returns an integer representing
    the identity of whatever is passed to it. These integers are the values that the
    `is` operator compares. If you’re curious about how Python handles names and values,
    try playing with `id()`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要提到的是，内置函数 `id()` 返回一个整数，表示传递给它的对象的身份。这些整数是 `is` 运算符进行比较的值。如果你对 Python 如何处理名字和值感兴趣，可以尝试使用
    `id()` 进行实验。
- en: Data Types
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: As you’ve likely noticed, Python does not require you, the programmer, to declare
    a type for your variables. Back when I first picked up Python, I joined the `#python`
    channel on IRC and jumped right in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的那样，Python 并不要求你，作为程序员，声明变量的类型。早在我第一次接触 Python 时，我加入了 IRC 上的 `#python`
    频道，并直接开始了编程。
- en: “How do you declare the data type of a variable in Python?” I asked, in all
    the naivete of a first-year coder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “如何在 Python 中声明变量的数据类型？”我问道，带着一个一年级编程新手的天真。
- en: 'Within moments, I received a response that I consider to be my first true induction
    into the bizarre world of programming: “You’re a data type.”'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不久之后，我收到了我认为是我第一次真正进入编程世界的回应：“你是一个数据类型。”
- en: 'The room regulars went on to explain that Python is a dynamically typed language,
    meaning I didn’t have to tell the language what sort of information to put in
    a variable. Instead, Python would decide the type for me. I didn’t even have to
    use a special “variable declaration” keyword. I just had to assign like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这群常客接着解释说，Python 是一种动态类型语言，这意味着我不需要告诉语言变量应该存储什么类型的信息。相反，Python 会为我决定类型。我甚至不需要使用特殊的“变量声明”关键字。我只需要像这样赋值：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 5-7: *types.py:1*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-7: *types.py:1*'
- en: At that precise moment, Python became my all-time favorite language.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个准确的时刻，Python 成为了我最喜欢的编程语言。
- en: 'It’s important to remember that Python is still a strongly typed language.
    I touched on this concept, along with dynamic typing, in Chapter 3. Ned Batchelder
    sums up Python’s type system quite brilliantly in his aforementioned PyCon 2015
    talk about names and values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，Python 仍然是一种强类型语言。我在第 3 章中讲解了这个概念，以及动态类型。Ned Batchelder 在他前面提到的 2015
    年 PyCon 演讲中，巧妙地总结了 Python 的类型系统。
- en: Names have a scope—they come and go with functions—but they have no type. Values
    have a type . . . but they have no scope.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 名字有作用域——它们随函数的调用而消失——但它们没有类型。值有类型……但是它们没有作用域。
- en: Although I haven’t touched on scope yet, this should already make sense. Names
    are bound to values, and those values exist in memory, as long as there is some
    *reference* to them. You can bind a name to literally any value you want, but
    you are limited as to what you can do with any particular value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我还没有涉及作用域的内容，但这已经是有意义的了。名字绑定到值，而这些值存在于内存中，只要有某种*引用*指向它们。你可以将一个名字绑定到你想要的任何值，但你在对特定值进行操作时是有限制的。
- en: The type() Function
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: type() 函数
- en: 'If you ever need to know a value’s data type, you can use the built-in `type()`
    function. Recall that everything in Python is an object, so this function will
    really just return what class the value is an instance of:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要知道某个值的数据类型，可以使用内置的 `type()` 函数。记住，在 Python 中，一切都是对象，因此这个函数实际上只是返回该值所属的类：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 5-8: *types.py:2*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-8: *types.py:2*'
- en: 'Here, you can see that the value assigned to `answer` is an integer (`int`).
    On rare occasions, you may want to check the data type before you do something
    with a value. For that, you can pair the `type()` function with the `is` operator,
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到赋值给 `answer` 的值是一个整数（`int`）。在一些罕见的情况下，你可能想在操作某个值之前检查它的数据类型。为此，你可以将
    `type()` 函数与 `is` 操作符配合使用，如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 5-9: *types.py:3a*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-9: *types.py:3a*'
- en: 'In many cases where this sort of introspection is necessary, it may be better
    to use `isinstance()` instead of `type()`, as it accounts for subclasses and inheritance
    (see Chapter 13). The function itself returns `True` or `False`, so I can use
    it as the condition in an `if` statement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多需要进行这种自省的情况下，使用 `isinstance()` 而非 `type()` 可能会更好，因为 `isinstance()` 会考虑到子类和继承（参见第
    13 章）。这个函数本身会返回 `True` 或 `False`，因此我可以将它作为 `if` 语句的条件：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 5-10: *types.py:3b*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-10: *types.py:3b*'
- en: Truth be told, there is rarely a need for either. Instead, Python developers
    prefer a more dynamic approach.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，通常没有必要这么做。Python 开发者更倾向于使用一种更动态的方法。
- en: Duck Typing
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: 'Python uses what is known (unofficially) as *duck typing*. This isn’t a technical
    term at all; it comes from the old saying:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用一种被称为（非正式的）*鸭子类型*的机制。这并不是一个技术术语，它来自于一句古老的说法：
- en: If it looks like a duck, walks like a duck, and quacks like a duck, then it
    probably *is* a duck.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果它看起来像一只鸭子，走路像鸭子，叫声像鸭子，那么它可能*就是*一只鸭子。
- en: Python doesn’t care much about what a value’s data type is, but rather it cares
    about the *functionality* of the value’s data type. For example, if an object
    supports all the math operators and functions, and if it accepts floats and integers
    as operands on the binary operators, then Python considers the object to be a
    numeric type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并不关心某个值的数据类型是什么，它更关心的是该数据类型的*功能*。例如，如果一个对象支持所有的数学运算符和函数，并且能够接受浮动数和整数作为二元运算符的操作数，那么
    Python 会将该对象视为数字类型。
- en: In other words, Python doesn’t care if it’s actually a robotic duck or a moose
    in a duck costume. If it has the traits needed, the rest of the details are usually
    moot.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Python 并不在乎它到底是一个机器人鸭子，还是穿着鸭子服装的麋鹿。如果它具备所需的特征，其他的细节通常无关紧要。
- en: If you’re familiar with object-oriented programming, particularly how quickly
    inheritance can get out of hand, then this whole concept of duck typing will probably
    be a breath of fresh air. If your class behaves as it should, it usually won’t
    matter what it inherits from.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉面向对象编程，尤其是继承如何迅速变得复杂，那么鸭子类型的概念可能会让你感到耳目一新。如果你的类按预期行为运行，通常不在乎它继承自什么。
- en: Scope and Garbage Collection
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域和垃圾回收
- en: '*Scope* is what defines where a variable can be accessed from. It might be
    available to an entire module or limited to the suite (body) of a function.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*作用域*定义了一个变量可以从哪里访问。它可能对整个模块可用，或者仅限于函数的语句块（主体）。'
- en: As I mentioned already, names have *scope*, whereas values do not. A name can
    be *global*, meaning it is defined by itself in a module, or it can be *local*,
    meaning it only exists within a particular function or comprehension.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，名称有*作用域*，而值没有。一个名称可以是*全局的*，意味着它在一个模块中独立定义，或者它可以是*局部的*，意味着它只存在于特定的函数或推导式内部。
- en: Local Scope and the Reference-Counting Garbage Collector
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地作用域和引用计数垃圾回收器
- en: Functions (including lambdas) and comprehensions define their own scope; they
    are the only structures in the language to do so. Modules and classes don’t have
    their own scope in the strictest sense; they only have their own namespace. When
    a scope reaches its end, all the names defined within it are automatically deleted.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数（包括lambda表达式）和推导式定义了它们自己的作用域；它们是语言中唯一做这种定义的结构。模块和类在严格意义上没有自己的作用域；它们只有自己的命名空间。当一个作用域结束时，作用域内定义的所有名称都会被自动删除。
- en: For any particular value, Python keeps a *reference count*, which is simply
    a count of how many references exist for that value. Every time a value is bound
    to a name, a reference is created (although there are other ways the language
    may create references). When there are no more references, the value is deleted.
    This is the *reference-counting garbage collector*, and it efficiently handles
    most garbage collection scenarios.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何特定的值，Python会保持一个*引用计数*，即计算该值有多少个引用。每当一个值绑定到一个名称时，就会创建一个引用（尽管语言中还有其他方式可以创建引用）。当没有更多的引用时，值就会被删除。这就是*引用计数垃圾回收器*，它高效地处理大多数垃圾回收场景。
- en: 'You can see how this works with a typical function, like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个典型的函数来看到这个是如何工作的，比如这样：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 5-11: *local_scope.py:1*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-11: *local_scope.py:1*'
- en: I create a `spam()` function, inside of which I define the names `message`,
    `word`, and `separator`. I can access any of these names inside the function;
    that is their local scope. It doesn’t matter that `separator` is defined within
    a `for` loop, as loops don’t have their own scope. I can still access it outside
    of the loop.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个`spam()`函数，在其中定义了名称`message`、`word`和`separator`。我可以在函数内部访问这些名称；这就是它们的局部作用域。即使`separator`是在`for`循环内定义的，也没关系，因为循环没有自己的作用域。我仍然可以在循环外访问它。
- en: 'However, I cannot access any of these names outside of the function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我不能在函数外部访问这些名称：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 5-12: *local_scope.py:2*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-12: *local_scope.py:2*'
- en: Trying to access `message` outside the context of the `spam()` function where
    it was defined will raise a `NameError`. In this example, `message` doesn’t exist
    in the outer scope. What’s more, as soon as the function `spam()` exits, the names
    `message`, `word`, and `separator` are deleted. Because `word` and `separator`
    each referred to values with a reference count of one (meaning only one name was
    bound to each), the values are also deleted.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在定义`spam()`函数的上下文之外访问`message`将引发`NameError`。在这个例子中，`message`在外部作用域中不存在。而且，一旦`spam()`函数退出，`message`、`word`和`separator`这些名称就会被删除。因为`word`和`separator`各自引用了一个引用计数为1的值（意味着每个值只绑定了一个名称），这些值也会被删除。
- en: 'The value of `message` is not deleted when the function exits, however, because
    of the return statement at the end of the function (see [Listing 5-11](#listing5-11))
    and what I do with that value here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`message`的值在函数退出时并没有被删除，但由于函数末尾的`return`语句（见[Listing 5-11](#listing5-11)）以及我在这里对该值的操作：'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 5-13: *local_scope.py:3*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-13: *local_scope.py:3*'
- en: I bind the value returned by `spam()` to `output` in the outer scope, meaning
    that value still exists in memory and can be accessed outside of the function.
    Assigning the value to `output` increases the reference count for that value,
    so even though the name `message` is deleted when `spam()` exits, the value is
    not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`spam()`返回的值绑定到外部作用域中的`output`，这意味着该值仍然存在于内存中，并且可以在函数外访问。将该值赋给`output`增加了该值的引用计数，因此即使当`spam()`退出时删除了`message`名称，该值依然存在。
- en: Interpreter Shutdown
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释器关闭
- en: When the Python interpreter is asked to shut down, such as when a Python program
    terminates, it enters *interpreter shutdown*. During this phase, the interpreter
    goes through the process of releasing all allocated resources, calling the garbage
    collector multiple times, and triggering destructors in objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python解释器被要求关闭时，比如当Python程序终止时，它会进入*解释器关闭*阶段。在此阶段，解释器会释放所有分配的资源，执行多次垃圾回收，并触发对象的析构函数。
- en: 'You can use the `atexit` module from the standard library to add functions
    to this interpreter shutdown process. This may be necessary in some highly technical
    projects, although in general, you shouldn’t need to do this. Functions added
    via `atexit.register()` will be called in a last-in, first-out manner. However,
    be aware that it becomes difficult to work with modules, including the standard
    library, during interpreter shutdown. It’s like trying to work in a building as
    it’s being demolished: the janitor’s closet may disappear at any time, without
    warning.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准库中的`atexit`模块将函数添加到解释器的关闭过程。这在某些高度技术化的项目中可能是必要的，尽管通常情况下你不需要这么做。通过`atexit.register()`添加的函数将按照后进先出的顺序被调用。然而，请注意，在解释器关闭过程中，操作模块（包括标准库）变得非常困难。这就像在一座大楼拆除时工作：清洁工的储藏室可能随时消失，毫无预警。
- en: Global Scope
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域
- en: When a name is defined within a module but outside of any function, class, or
    comprehension, it is considered to be in *global* *scope*. Although it’s okay
    to have some global scope names, having too many usually leads to the creation
    of code that is difficult to debug and maintain. Therefore, you should use global
    scope names sparingly for variables. There is often a cleaner solution, such as
    a class (see Chapter 7).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个名称在模块中定义，但不在任何函数、类或推导式内部时，它被认为是在*全局* *作用域*中。虽然有一些全局作用域名称是可以的，但如果有太多，通常会导致难以调试和维护的代码。因此，你应该谨慎使用全局作用域名称来定义变量。通常会有更简洁的解决方案，例如使用类（见第7章）。
- en: 'Properly using global scope names in the context of a more local scope, such
    as a function, requires you to think ahead a little. Consider what I do if I want
    a function that can modify a global variable storing a high score. First, I define
    the global variable:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在更局部作用域（例如函数）中正确使用全局作用域名称，需要你稍微思考一下。如果我想要一个能够修改存储高分的全局变量的函数，应该怎么做呢？首先，我定义这个全局变量：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-14: *global**_scope.py:1*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-14: *global**_scope.py:1*'
- en: 'I’ll write this function the wrong way first:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我先写一个错误的函数：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 5-15: *global**_scope.py:2*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-15: *global**_scope.py:2*'
- en: When I run this code, Python complains that I’m using a local variable before
    I’ve assigned a value to it ❶. The problem is, I’m assigning to the name `high_score`
    within the scope of the function `score()` ❷, and that *shadows*, or hides, the
    global `high_score` name behind the new, local `high_score` name. The fact that
    I’ve created a local `high_score` name *anywhere in the function* makes it impossible
    for the function to ever “see” the global `high_score` name.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这段代码时，Python会抱怨我在为局部变量赋值之前就使用了它 ❶。问题是，我在函数`score()`的作用域内对`high_score`进行了赋值
    ❷，这*遮蔽*了全局的`high_score`名称，将其隐藏在新的局部`high_score`名称后面。我在函数中的任何地方创建了一个局部的`high_score`名称，这使得该函数永远无法“看到”全局的`high_score`名称。
- en: 'To make this work, I need to declare that I’m going to use the global name
    in the local scope, instead of defining a new local name. I can do this with the
    `global` keyword:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个过程有效，我需要声明我将在局部作用域中使用全局名称，而不是定义一个新的局部名称。我可以通过`global`关键字来做到这一点：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 5-16: *global**_scope.py:3*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-16: *global**_scope.py:3*'
- en: Before I do anything else in my function, I must specify that I’m using the
    global `high_score` name. This means that anywhere I assign a value to the name
    `high_score` in `score()`, the function will use the global name, instead of trying
    to create a new local name. The code now works as expected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我做任何操作之前，我必须指定我使用的是全局变量`high_score`。这意味着在`score()`函数中，只要我给`high_score`赋值，函数就会使用全局变量，而不是尝试创建一个新的局部变量。现在代码按预期工作。
- en: 'Every time you wish to rebind a global name from within a local scope, you
    must use the `global` keyword first. If you’re only accessing the current value
    bound to a global name, you don’t need to use the `global` keyword. It is vital
    for you to cultivate this habit, because Python won’t always raise an error if
    you handle scope incorrectly. Consider this example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想要在局部作用域内重新绑定一个全局变量时，你必须先使用`global`关键字。如果你只是访问全局变量当前绑定的值，那么就不需要使用`global`关键字。培养这个习惯非常重要，因为Python并不会在你错误地处理作用域时总是抛出错误。请看这个例子：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-17: *global**_scope_gotcha.py:1a*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5-17：*global**_scope_gotcha.py:1a*
- en: This code runs without raising any errors, but the output is wrong. A new name,
    `current_score`, is being created in the local scope of the function `score()`,
    and it is bound to the value `465`. This shadows the global name `current_score`.
    When the function terminates, both the `new_score` and the local `current_score`
    are deleted. In all of this, the global `current_score` has remained untouched.
    It is still bound to `0`, and that is what is printed out.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行时没有抛出错误，但输出结果是错误的。在`score()`函数的局部作用域中，创建了一个新的名字`current_score`，并将其绑定到值`465`。这覆盖了全局变量`current_score`。当函数结束时，`new_score`和局部的`current_score`都会被删除。在这一过程中，全局的`current_score`保持不变，仍然绑定着`0`，这就是最终被打印出来的值。
- en: 'Once again, to resolve this problem, I need only use the `global` keyword:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，为了解决这个问题，我只需要使用`global`关键字：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 5-18: *global**_scope_gotcha.py:1b*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5-18：*global**_scope_gotcha.py:1b*
- en: Because I specified that the global `current_name` is to be used in this function,
    the code now behaves precisely as expected, printing out the value `465`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我指定在这个函数中使用全局的`current_name`，所以代码现在按预期执行，打印出值`465`。
- en: The Dangers of Global Scope
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域的危险
- en: There is one more major gotcha to account for with global scope. Modifying any
    variable at a global level, as in rebinding or mutating on a name outside the
    context of a function, can lead to confusing behavior and surprising bugs—especially
    once you start dealing with multiple modules. It’s acceptable for you to initially
    “declare” a name at a global scope, but you should do all further rebinding and
    mutation of that global name at the local scope level.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个关于全局作用域的重大陷阱。修改全局变量（比如重新绑定或在函数外部变更某个变量名）可能会导致混乱的行为和意外的错误，特别是当你开始处理多个模块时。你可以在全局作用域中“声明”一个名字，但所有进一步的绑定和修改应该在局部作用域中进行。
- en: By the way, this does *not* apply to classes, which do not actually define their
    own scope. I’ll return to this later in this chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这个规则*不适用于*类，因为类实际上并不定义自己的作用域。我会在本章稍后讨论这个问题。
- en: The nonlocal Keyword
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: nonlocal关键字
- en: 'Python allows you to write functions within functions. I’ll defer discussing
    the practicality of this until Chapter 6. Here, I mainly want to explore this
    functionality’s impact on scope. Consider the following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许你在函数内部写函数。我会在第6章中再讨论这一功能的实际应用。在这里，我主要想探讨这种功能对作用域的影响。请看以下示例：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 5-19: *nonlocal**.py*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5-19：*nonlocal**.py*
- en: 'The function `order()` contains another function: `cook()`. Each function has
    its own scope.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`order()`包含了另一个函数：`cook()`。每个函数都有自己的作用域。
- en: Remember, as long as a function only accesses a global name like `spam`, you
    don’t need to do anything special. However, trying to *assign* to a global name
    will actually define a new local name that shadows the global one. The same behavior
    is true of the inner function using names defined in the outer function, which
    is known as the *nested scope* or *enclosing scope*. To get around this, I specify
    that `eggs` is `nonlocal`, meaning it can be found in the enclosing scope, rather
    than in the local scope ❶. The inner function `cook()` has no trouble accessing
    the global name `spam`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只要一个函数仅访问像`spam`这样的全局名称，你就不需要做任何特殊处理。然而，尝试对一个全局名称进行*赋值*，实际上会定义一个新的局部名称，覆盖全局名称。内层函数使用外层函数定义的名称时，表现也是一样的，这被称为*嵌套作用域*或*包含作用域*。为了解决这个问题，我指定`eggs`是`nonlocal`，意味着它可以在包含作用域中找到，而不是在局部作用域中❶。内层函数`cook()`可以毫不费力地访问全局名称`spam`。
- en: The `nonlocal` keyword starts looking for the indicated name in the innermost
    nested scope, and if it doesn’t find it, it moves to the next enclosing scope
    above that. It repeats this until it either finds the name or determines that
    the name does not exist in a nonglobal enclosing scope.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonlocal`关键字从最内层的嵌套作用域开始查找指定的名称，如果找不到，它会移动到上方的下一个包含作用域。它会一直重复这一过程，直到找到名称或确定该名称在非全局的包含作用域中不存在。'
- en: Scope Resolution
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域解析
- en: 'Python’s rule about which scopes it searches for a name, and in what order,
    is called the *scope resolution order*. The easiest way to remember the scope
    resolution order is with the acronym *LEGB—*for which my colleague Ryan gave me
    the handy mnemonic “Lincoln Eats Grant’s Breakfast”:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Python关于它搜索名称的作用域及其顺序的规则称为*作用域解析顺序*。记住作用域解析顺序最简单的方法是使用首字母缩写*LEGB*—我的同事Ryan给了我一个方便的记忆法“Lincoln
    Eats Grant’s Breakfast”：
- en: Local
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部
- en: Enclosing-function locals (that is, anything found via `nonlocal`)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含函数的局部（即，通过`nonlocal`找到的任何内容）
- en: Global
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局
- en: Built-in
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内建
- en: Python will look in these scopes, in order, until it finds a match or reaches
    the end. The `nonlocal` and `global` keywords adjust the behavior of this scope
    resolution order.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python会按这些作用域的顺序查找，直到找到匹配项或到达结尾。`nonlocal`和`global`关键字会调整此作用域解析顺序的行为。
- en: The Curious Case of the Class
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类的奇怪案例
- en: Classes have their own way of dealing with scope. Technically speaking, classes
    don’t directly factor into the scope resolution order. Every name declared directly
    within a class is known as an *attribute*, and it is accessed through the dot
    (`.`) operator on the class (or object) name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类有自己处理作用域的方式。严格来说，类并不会直接影响作用域解析顺序。每个在类内部声明的名称都被称为*属性*，并且通过类（或对象）名称上的点（`.`）操作符进行访问。
- en: 'To demonstrate this, I’ll define a class with a single attribute:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将定义一个具有单一属性的类：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 5-20: *class_attributes**.py*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-20：*class_attributes**.py*
- en: 'Those three print statements all output the same thing. Running that code gives
    me this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那三条打印语句的输出都是相同的。运行该代码会得到以下结果：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The name `output` is a *class attribute* ❶, belonging to the `Nutrimatic` class.
    Even within that class, I would not be able to refer to it merely as `output`.
    I must access it through `self.output` ❷, as `self` refers to the class instance
    the function (instance method) `request()` is being called on. I can also access
    it via `machine.output` ❸ or `Nutrimatic.output` ❹ anywhere the object `machine`
    or the class `Nutrimatic` is, respectively, in scope. All of those names point
    to the exact same attribute: `output`. Especially in this case, there’s no real
    difference between them.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`output`是一个*类属性*❶，属于`Nutrimatic`类。即使在该类内部，我也不能仅仅通过`output`来引用它。必须通过`self.output`❷来访问它，因为`self`指代的是调用函数（实例方法）`request()`的类实例。我也可以通过`machine.output`❸或`Nutrimatic.output`❹在`machine`对象或`Nutrimatic`类的作用域中访问它。这些名称都指向完全相同的属性：`output`。特别是在这个例子中，它们之间没有实质性的区别。
- en: Generational Garbage Collector
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代际垃圾回收器
- en: Behind the scenes, Python also has a more robust *generational garbage collector*
    that handles all of the odd situations a reference-counting garbage collector
    cannot, such as reference cycles (when two values reference one another). All
    of these situations, and the ways they’re handled by the garbage collector, are
    far beyond the scope of this book.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Python 还有一个更强大的*代际垃圾回收器*，它处理引用计数垃圾回收器无法处理的各种奇怪情况，例如引用循环（当两个值相互引用时）。所有这些情况，以及它们是如何被垃圾回收器处理的，远远超出了本书的范围。
- en: Moving forward, the most important takeaway to remember is that the generational
    garbage collector incurs some performance costs. Thus, it’s sometimes worthwhile
    to avoid reference cycles. One way to do this is with `weakref`, which creates
    a reference to a value without increasing that value’s reference count. This feature
    was defined in PEP 205, and the documentation exists at [https://docs.python.org/library/weakref.html](https://docs.python.org/library/weakref.html).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，最重要的理解是，代代垃圾回收器会带来一定的性能开销。因此，有时避免引用循环是值得的。做到这一点的一种方法是使用 `weakref`，它创建一个对值的引用，但不会增加该值的引用计数。此功能在
    PEP 205 中有所定义，相关文档可以在 [https://docs.python.org/library/weakref.html](https://docs.python.org/library/weakref.html)
    找到。
- en: The Immutable Truth
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变的真相
- en: Values in Python can be either *immutable* or *mutable*. The difference hinges
    on whether the values can be *modified in place*, meaning they can be changed
    right where they are in memory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的值可以是*不可变*的或*可变*的。它们的区别在于，是否可以*就地修改*，即是否可以直接在内存中修改它们的值。
- en: '*Immutable* types cannot be modified in place. For example, integers (`int`),
    floating-point numbers (`float`), strings (`str`), and tuples (`tuple`) are all
    immutable. If you attempt to mutate an immutable value, you’ll wind up with a
    completely different value being created:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可变*类型无法就地修改。例如，整数（`int`）、浮点数（`float`）、字符串（`str`）和元组（`tuple`）都是不可变的。如果你尝试修改一个不可变值，最终会创建一个完全不同的值：'
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 5-21: *immutable_types.py*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-21：*immutable_types.py*
- en: Initially, `eggs` and `carton` are both bound to the same value, and thus, they
    share an identity. When I modify `eggs`, it is rebound to a new value, so it no
    longer shares an identity with `carton`. You can see that the two names now point
    to different values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，`eggs` 和 `carton` 都绑定到相同的值，因此它们共享相同的身份。当我修改 `eggs` 时，它被重新绑定到一个新值，因此不再与 `carton`
    共享身份。你可以看到这两个名称现在指向不同的值。
- en: '*Mutable* types, on the other hand, can be modified in place. Lists constitute
    one example of a mutable type:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*可变*类型则可以就地修改。列表就是一种可变类型的例子：'
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 5-22: *mutable_types.py*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-22：*mutable_types.py*
- en: Because the list is aliased to both `temps` and `highs`, any modifications made
    to the list value ❶ are visible through either name. Both names are bound to the
    original value, as demonstrated by the `is` comparisons. This remains the case,
    even after that value is mutated.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该列表在 `temps` 和 `highs` 之间是别名关系，所以对列表值 ❶ 进行的任何修改都可以通过这两个名称看到。正如 `is` 比较所示，两个名称都绑定到原始值，即使该值被修改后，依然如此。
- en: Passing by Assignment
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过赋值传递
- en: Another frequent question from programmers new to the language is, “Does Python
    pass by value or by reference?”
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者经常问的另一个问题是，“Python 是通过值传递还是引用传递？”
- en: The answer is, “Effectively, neither.” More accurately, as Ned Batchelder describes
    it, Python *passes by assignment*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，“实际上，两者都不是。”更准确地说，正如 Ned Batchelder 所描述的，Python 是*通过赋值传递*的。
- en: 'Neither the values nor the names bound to them are moved. Instead, each value
    is bound to the parameter via assignment. Consider a simple function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 既不是值，也不是绑定到它们的名称会被移动。相反，每个值是通过赋值与参数绑定的。考虑一个简单的函数：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, there is one copy of the string value `"Jason"` in memory, and that is
    bound to the name `my_name`. When I pass `my_name` to the `greet()` function—specifically,
    to the `person` parameter—it’s the same as if I had said (`person = my_name`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，内存中有一个字符串值 `"Jason"`，它绑定到名称 `my_name`。当我将 `my_name` 传递给 `greet()` 函数时——具体来说，传递给
    `person` 参数——就相当于我说了（`person = my_name`）。
- en: Again, assignment never makes a copy of a value. The name `person` is now bound
    to the value `"Jason"`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，赋值从不创建值的副本。现在，`person` 绑定到值 `"Jason"`。
- en: 'This concept of passing by assignment gets tricky when you start working with
    mutable values, such as lists. To demonstrate this often-unexpected behavior,
    I’ve written a function that finds the lowest temperature in a list passed to
    it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始处理可变值（例如列表）时，*通过赋值传递*的概念会变得棘手。为了演示这种常常出乎意料的行为，我写了一个函数，它会找到传递给它的列表中的最低温度：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 5-23: *lowest_temp.py:1a*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-23：*lowest_temp.py:1a*
- en: 'At first glance, you may assume that passing a list to the `temperatures` parameter
    will make a copy, so it shouldn’t matter if you modify the value bound to the
    parameter. However, lists are mutable, meaning *the value itself* can be modified:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，你可能会认为将一个列表传递给`temperatures`参数会创建一个副本，因此如果修改与该参数绑定的值，应该不会有问题。然而，列表是可变的，这意味着*值本身*是可以被修改的：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 5-24: *lowest_temp.py:2*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-24：*lowest_temp.py:2*
- en: When I passed `temps` to the function’s `temperatures` parameter, I only *aliased*
    the list, so any changes made on `temperatures` are visible from all the other
    names bound to that same list value—namely, from `temps`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将`temps`传递给函数的`temperatures`参数时，我只是*创建了一个别名*，因此在`temperatures`上所做的任何更改都可以从绑定到同一个列表值的其他名字（即`temps`）中看到。
- en: 'You can see this in action when I run this code and get the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在运行这段代码并得到以下输出时看到这一点：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When `find_lowest()` sorted the list passed to `temperatures`, it actually sorted
    the one mutable list that both `temps` and `temperatures` aliased. This is a clear
    case of a function having *side effects*, which are changes to values that existed
    before the function call.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当`find_lowest()`对传递给`temperatures`的列表进行排序时，它实际上是对`temps`和`temperatures`都指向的那个可变列表进行了排序。这是一个典型的函数有*副作用*的例子，副作用指的是函数调用前已经存在的值的变化。
- en: 'An awe-inspiring number of bugs originate from this one type of misunderstanding.
    In general, functions should not have side effects, meaning that any values passed
    to the function as arguments should *not* be directly mutated. To avoid mutating
    the original value, I have to explicitly make a copy of it. Here’s how I’d do
    that in the `find_lowest()` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由这种类型的误解引发的错误数量令人叹为观止。通常，函数不应该有副作用，意味着传递给函数的任何参数值*不应*直接被修改。为了避免修改原始值，我必须显式地复制它。以下是在`find_lowest()`函数中的做法：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 5-25: *lowest_temp.py:1b*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-25: *lowest_temp.py:1b*'
- en: The `sorted()` function has no side effects; it creates a new list using the
    items in the list passed to it ❶. It then sorts this new list and returns it.
    I bind this new list to `sorted_temps`. Thus, the original list (bound to `temps`
    and `temperatures`) is untouched.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`函数没有副作用；它使用传递给它的列表中的项目创建一个新列表❶。然后它对这个新列表进行排序并返回。我将这个新列表绑定到`sorted_temps`。因此，原始列表（绑定到`temps`和`temperatures`）保持不变。'
- en: If you’re coming from C and C++, it may be helpful to remember the potential
    hang-ups related to pass-by-pointer or pass-by-reference. Although Python’s assignment
    is scarcely similar from a technical standpoint, the risks of side effects and
    unintended mutations are the same.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从 C 和 C++ 背景来的，可能有助于记住与指针传递或引用传递相关的潜在问题。尽管从技术角度看，Python 的赋值方式与它们几乎没有相似之处，但副作用和意外变异的风险是一样的。
- en: Collections and References
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合和引用
- en: 'All collections, including lists, employ a clever little semantic detail that
    can become a royal pain if you don’t know to expect it: ***Individual items are
    references.*** Just as a name is bound to a value, so also are items in collections
    bound to values, in the same manner. This binding is called a *reference*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合，包括列表，都使用了一个巧妙的小语义细节，如果你没有预料到，它可能会成为一个麻烦：***单个项目是引用。*** 就像一个名称绑定到一个值一样，集合中的项目也以相同的方式绑定到值。这种绑定被称为*引用*。
- en: A simple example involves trying to create a tic-tac-toe board. This first version
    won’t work quite how you’d expect.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是尝试创建一个井字游戏棋盘。这个第一个版本不会像你预期的那样工作。
- en: 'I’ll start by creating the game board:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从创建游戏棋盘开始：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 5-26: *tic_tac_toe**.py:1a*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-26: *tic_tac_toe**.py:1a*'
- en: I’m trying to create a two-dimensional board. You can fill a collection, like
    a list, with several items, all with the same repeating value, using the multiplication
    operator ❶, as I’ve done here. I enclose the repeating value in square brackets
    and multiply it by the number of repetitions I want. A single row of my board
    is defined with `["-"] * 3`, which makes a list of three `"-"` strings.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我正试图创建一个二维的棋盘。你可以使用乘法运算符❶填充一个集合（比如列表），使其包含多个相同的重复值，就像我在这里做的那样。我将重复值用方括号括起来，并用所需的重复次数进行乘法运算。我定义棋盘的一行为`["-"]
    * 3`，这会创建一个包含三个`"-"`字符串的列表。
- en: 'Unfortunately, this won’t work the way you’d expect. The problem begins when
    I attempt to define the second dimension of the array—three copies of the `[["-"]
    * 3]` list—using multiplication. You can see the problem manifest when I try to
    make a move:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不会像你预期的那样工作。问题出现在我尝试定义数组的第二个维度——通过乘法创建三份`[["-"] * 3]`列表时。当我尝试下棋时，你可以看到问题的表现：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 5-27: *tic_tac_toe**.py:2*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-27: *tic_tac_toe**.py:2*'
- en: 'When I mark a move on the board ❷, I want to see that change in only one spot
    on the board, like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在棋盘上标记一个移动❷时，我希望只在棋盘的一个位置看到该变化，就像这样：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Instead, I get this nasty surprise:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我得到了这个讨厌的意外：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Cue the weeping and gnashing of teeth. Somehow, that one change has propagated
    to *all three* *rows*. Why?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 哭泣与咬牙切齿的时刻来了。不知怎么，那一个改变已经传播到*所有三* *行*。为什么呢？
- en: Initially, I created a list with three `"-"` values as items ❶. Since strings
    are immutable and thus cannot be modified in place, this works as expected. Rebinding
    the first item in the list to `"X"` does not affect the other two items.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我创建了一个包含三个`"-"`值的列表作为项❶。由于字符串是不可变的，因此不能原地修改，所以这按预期工作。将列表中的第一个项重新绑定为`"X"`不会影响其他两个项。
- en: The outer dimension of the list is composed of three list items. Because I defined
    *one* list and used it *three* times, I now have three *aliases* for one mutable
    value! By changing that list through one reference (the second row), I’m mutating
    that one shared value ❷, so all three references see the change.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的外部维度由三个列表项组成。因为我定义了*一个*列表并使用了*三*次，现在我为一个可变值拥有了三个*别名*! 通过在一个引用（第二行）中更改该列表，我在变更那个共享值❷，所以所有三个引用都会看到变化。
- en: 'There are a few ways to fix this, but all of them work by ensuring each row
    references a separate value, like so:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有几种方式，但所有这些方式都是通过确保每一行引用一个独立的值来工作的，像这样：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 5-28: *tic_tac_toe**.py:1b*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-28: *tic_tac_toe**.py:1b*'
- en: 'I only needed to change how I defined the game board initially. I now use a
    *list comprehension* to create the rows. In short, this list comprehension will
    define a separate list value from `["-"] * 3` three different times. (List comprehensions
    get complicated; they’ll be explained in depth in Chapter 10.) Running the code
    now results in the expected behavior:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我只需要改变最初定义游戏板的方式。现在我使用*列表推导式*来创建行。简而言之，这个列表推导式将三次分别定义一个与`["-"] * 3`不同的列表值。（列表推导式比较复杂，后续会在第10章深入讲解。）现在运行代码，得到了预期的行为：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Long story short, whenever you’re working with a collection, remember that
    an item is no different from any other name. Here is one more example to drive
    this point home:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，每当你操作一个集合时，要记住，一个项和其他名称没有什么不同。再举一个例子来说明这一点：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 5-29: *team_scores**.py:1*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-29: *team_scores**.py:1*'
- en: 'I create three lists, assigning each to a name. Then, I pack all three into
    the tuple `scores`. You may remember from earlier that tuples cannot be modified
    directly, because they’re immutable. That same rule does not necessarily apply
    to a tuple’s items. You can’t change the tuple itself, but you can (indirectly)
    modify the values its items refer to:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了三个列表，将每个列表赋予一个名称。然后，我将这三者打包成元组`scores`。你可能记得，元组不能被直接修改，因为它们是不可变的。但这个规则并不一定适用于元组的项。你不能改变元组本身，但你可以（间接地）修改它的项所引用的值：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 5-30: *team_scores**.py:2*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-30: *team_scores**.py:2*'
- en: When I mutate the list `scores_team_1`, that change appears in the first item
    of the tuple, because that item only aliased a mutable value.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我修改列表`scores_team_1`时，这个变化出现在元组的第一个项中，因为这个项只是别名指向了一个可变值。
- en: 'I could also directly mutate a mutable list in the `scores` tuple through two-dimensional
    subscription, like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以通过二维订阅直接修改`scores`元组中的可变列表，像这样：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 5-31: *team_scores**.py:3*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-31: *team_scores**.py:3*'
- en: Tuples don’t give you any sort of security about things being modified. Immutability
    exists mainly for efficiency, not for protecting data. Mutable values are *always*
    going to be mutable, no matter where they live or how they’re referred to.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 元组并不会为你提供任何关于数据是否会被修改的安全性。不可变性主要是为了效率，而不是保护数据。可变值*总是*可变的，无论它们存在于哪里或是如何被引用。
- en: The problems in the two examples above may seem relatively easy to spot, but
    things start getting troublesome when the related code is spread out across a
    large file or multiple files. Mutating on a name in one module may unexpectedly
    modify an item of a collection in a completely different module, and you might
    never have expected it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上面两个例子中的问题看起来可能比较容易发现，但当相关代码分布在一个大文件或多个文件中时，问题就变得复杂了。在一个模块中对一个名称的变更可能会意外地修改另一个完全不同模块中集合的项，而你可能从未预料到这种情况。
- en: Shallow Copy
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浅拷贝
- en: There are many ways to ensure you are binding a name to a *copy* of a mutable
    value, instead of aliasing the original; the most explicit of these ways is with
    the `copy()` function. This is sometimes also known as a *shallow copy*, in contrast
    to the *deep copy* I’ll cover later.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以确保你将名称绑定到*可变值的副本*，而不是给原始值起别名；其中最明确的一种方法是使用`copy()`函数。这也被称为*浅拷贝*，与稍后我会讲解的*深拷贝*相对。
- en: 'To demonstrate this, I’ll create a `Taco` class (see Chapter 7 for more on
    classes) that allows you to define the class with various toppings and then add
    a sauce afterward. This first version has a bug:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个问题，我将创建一个 `Taco` 类（更多内容请参见第 7 章），它允许你为每个 taco 定义各种配料，然后在后面添加酱料。这个版本有一个
    bug：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 5-32: *mutable_**tacos.py:1a*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-32：*mutable_**tacos.py:1a*
- en: In the `Taco` class, the initializer `__init__()` accepts a list of toppings,
    which it stores as the `ingredients` list. The `add_sauce()` method will add the
    specified `sauce` string to the `ingredients` list.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Taco` 类中，初始化函数 `__init__()` 接受一个配料列表，并将其存储为 `ingredients` 列表。`add_sauce()`
    方法将把指定的 `sauce` 字符串添加到 `ingredients` 列表中。
- en: (Can you anticipate the problem?)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: （你能预见到问题吗？）
- en: 'I use the class as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我按如下方式使用这个类：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 5-33: *mutable_**tacos.py:2a*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-33：*mutable_**tacos.py:2a*
- en: 'I define a list of toppings I want on all my tacos, and then I define two tacos:
    `hot_taco` and `mild_taco`. I pass the `default_toppings` list to the initializer
    for each taco. Then I add `"Salsa"` to the list of toppings to `hot_taco`, but
    I don’t want any `"Salsa"` on `mild_taco`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个我希望所有 tacos 上都能加的配料列表，然后我定义了两个 tacos：`hot_taco` 和 `mild_taco`。我将 `default_toppings`
    列表传递给每个 taco 的初始化函数。然后，我给 `hot_taco` 的配料列表添加了 `"Salsa"`，但我不希望在 `mild_taco` 上加
    `"Salsa"`。
- en: 'To make sure this is working, I print out the list of `ingredients` for the
    two tacos, as well as the `default_toppings` list I started with:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这能正常工作，我打印出了两个 taco 的`ingredients`列表，以及我开始时的`default_toppings`列表：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 5-34: *mutable_**tacos.py:3*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-34：*mutable_**tacos.py:3*
- en: 'That outputs the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Waiter, there’s a bug in my taco!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 服务员，我的 taco 有个 bug！
- en: The trouble is, when I created my `hot_taco` and `mild_taco` object by passing
    `default_toppings` to the `Taco` initializer, I bound both `hot_taco.ingredients`
    and `mild_taco.ingredients` to the same list value as `default_toppings`. These
    are now all aliases of the same value in memory. Then, when I call the function
    `hot_taco.add_sauce()`, I mutate that list value. The addition of `"Salsa"` is
    visible not only in `hot_taco.ingredients`, but also (unexpectedly) in `mild_taco.ingredients`
    and in the `default_toppings` list. This is definitely not the desired behavior;
    adding `"Salsa"` to one taco should only affect that one taco.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当我通过将 `default_toppings` 传递给 `Taco` 的初始化函数来创建 `hot_taco` 和 `mild_taco`
    对象时，我把 `hot_taco.ingredients` 和 `mild_taco.ingredients` 都绑定到了与 `default_toppings`
    相同的列表值。这些现在都是内存中同一个值的别名。然后，当我调用函数 `hot_taco.add_sauce()` 时，我修改了那个列表值。`"Salsa"`
    的添加不仅在 `hot_taco.ingredients` 中可见，而且（意外地）也出现在了 `mild_taco.ingredients` 和 `default_toppings`
    列表中。这绝对不是预期的行为；给一个 taco 添加 `"Salsa"` 应该只影响那个 taco。
- en: 'One way to resolve this is to ensure I’m assigning a copy of the mutable value.
    In the case of my `Taco` class, I will rewrite the initializer so it assigns a
    copy of the specified list to `self.ingredients`, instead of aliasing:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是确保我分配的是可变值的副本。在我的 `Taco` 类中，我将重写初始化函数，使其将指定列表的副本分配给 `self.ingredients`，而不是使用别名：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 5-35: *mutable_**tacos.py:1b*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-35：*mutable_**tacos.py:1b*
- en: I make a copy with the `copy.copy()` function ❶, which is imported from `copy`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `copy.copy()` 函数 ❶ 进行拷贝，该函数是从 `copy` 模块导入的。
- en: 'I make a copy of the list passed to `toppings` within `Taco.__init__()`, assigning
    that copy to `self.ingredients`. Any changes made to `self.ingredients` don’t
    affect the others; adding `"Salsa"` to `hot_taco` does not change `mild_taco.ingredients`,
    nor does it change `default_toppings`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 `Taco.__init__()` 中对传递的 `toppings` 列表进行拷贝，将副本分配给 `self.ingredients`。对 `self.ingredients`
    的任何更改都不会影响其他列表；给 `hot_taco` 添加 `"Salsa"` 不会改变 `mild_taco.ingredients`，也不会改变 `default_toppings`：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Deep Copy
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深拷贝
- en: A shallow copy is all well and good for lists of immutable values, but as previously
    mentioned, when a mutable value contains other mutable values, changes to those
    values can appear to replicate in weird ways.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 浅拷贝对于不可变值的列表来说完全没问题，但如前所述，当一个可变值包含其他可变值时，对这些值的更改可能会以奇怪的方式复制。
- en: 'For example, consider what happens when I try to make a copy of a `Taco` object
    before changing one of the two tacos. My first attempt results in some undesired
    behavior. Building on the same `Taco` class as before (see [Listing 5-35](#listing5-35)),
    I’ll use the copy of one taco to define another:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑当我尝试在改变两个 taco 之一之前复制一个 `Taco` 对象时会发生什么。我的第一次尝试导致了一些不想要的行为。在之前的 `Taco`
    类基础上（参见[列表 5-35](#listing5-35)），我会用一个 taco 的副本来定义另一个：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 5-36: *mutable_**tacos.py:2b*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-36：*mutable_**tacos.py:2b*
- en: I want to create a new taco (`hot_taco`) that is initially identical to `mild_taco`,
    but with added `"Salsa"`. I’m attempting this by binding a copy of `mild_taco`
    ❶ to `hot_taco`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我想创建一个新的 `Taco`（`hot_taco`），它最初与 `mild_taco` 相同，但添加了 `"Salsa"`。我正试图通过将 `mild_taco`
    的副本 ❶ 绑定到 `hot_taco` 来实现。
- en: 'Running the revised code (including [Listing 5-34](#listing5-34)) produces
    the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修订后的代码（包括 [列表 5-34](#listing5-34)）会产生以下结果：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: I might not expect any changes made to `hot_taco` to reflect in `mild_taco`,
    but unexpected changes have clearly happened.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能不期望对 `hot_taco` 所做的更改会反映到 `mild_taco` 上，但显然发生了意外更改。
- en: The issue is that, when I make a copy of the `Taco` object value itself, I am
    not making a copy of the `self.ingredients` list *within* the object. Both `Taco`
    objects contain references to the same list value.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当我拷贝 `Taco` 对象的值本身时，并没有拷贝对象内部的 `self.ingredients` 列表。两个 `Taco` 对象都包含对同一列表值的引用。
- en: 'To fix this problem, I can use *deep copy* to ensure that any mutable values
    inside the object are copied as well. In this case, a deep copy of a `Taco` object
    will create a copy of the `Taco` value, as well as a copy of any mutable values
    that `Taco` contains references to—namely, the list `self.ingredients`. [Listing
    5-37](#listing5-37) shows that same program, using deep copy:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我可以使用 *深拷贝* 来确保对象内部的可变值也被拷贝。在这种情况下，`Taco` 对象的深拷贝会创建一个 `Taco` 值的副本，同时拷贝
    `Taco` 引用的所有可变值——即列表 `self.ingredients`。[列表 5-37](#listing5-37) 显示了相同的程序，使用深拷贝：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 5-37: *mutable_**tacos.py:2c*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-37：*mutable_**tacos.py:2c*
- en: 'The only change is that I’m using `copy.deepcopy()`, instead of `copy.copy()`
    ❶. Now when I mutate the list inside `hot_taco`, it doesn’t affect `mild_taco`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是，我使用了 `copy.deepcopy()`，而不是 `copy.copy()` ❶。现在，当我改变 `hot_taco` 内部的列表时，它不会影响到
    `mild_taco`：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I don’t know about you, but I’m getting hungry for tacos.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你怎么样，但我开始对塔可（taco）感到饥饿了。
- en: Copying is the most generic way to solve the problem of passing around mutable
    objects. However, depending on what you’re doing, there may be an approach better
    suited to the particular collection you’re using. For example, many collections,
    like lists, have functions that return a copy of the collection with some specific
    modification. When you’re solving these sorts of issues with mutability, you can
    start by employing copy and deep copy. Then, you can exchange that for a more
    domain-specific solution later.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 拷贝是解决传递可变对象问题的最通用方法。然而，取决于你所做的事情，可能有一种方法更适合你正在使用的特定集合。例如，许多集合，如列表，具有返回某些特定修改副本的函数。在处理可变性问题时，你可以先使用拷贝和深拷贝，然后再根据需要换成更具体的解决方案。
- en: Coercion and Conversion
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制转换与类型转换
- en: Names do not have types. Therefore, Python has no need of type casting, at least
    in the typical sense of the term.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 名称没有类型。因此，Python 不需要类型转换，至少在该术语的典型意义上不需要。
- en: 'Allowing Python to figure out the conversions by itself, such as when adding
    together an integer (`int`) and a `float`, is called *coercion*. Here are a few
    examples:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 Python 自动进行类型转换，比如将一个整数（`int`）和一个 `float` 相加，称为 *强制转换*。以下是一些示例：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 5-38: *coercion.py*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-38：*coercion.py*
- en: Even so, there are potential situations in which you may need to use one value
    to create a value of a different type, such as when you are creating a string
    from an integer. *Conversion* is the process of explicitly casting a value of
    one type to another type.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，还是有一些潜在情况，你可能需要使用一个值来创建一个不同类型的值，比如从整数创建字符串。*转换* 是将一个类型的值显式地转换为另一个类型的过程。
- en: Every type in Python is an instance of a class. Therefore, the class of the
    type you want to create only needs to have an initializer that can handle the
    data type of the value you’re converting from. (This is usually done through duck
    typing.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的每个类型都是一个类的实例。因此，你要创建的类型的类只需要有一个初始化器，能够处理你正在转换的值的数据类型。（这通常是通过鸭子类型实现的。）
- en: 'One of the more common scenarios is to convert a string containing a number
    into a numeric type, such as a `float`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的场景之一是将包含数字的字符串转换为数字类型，例如 `float`：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Listing 5-39: *conversion.py:1*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-39：*conversion.py:1*
- en: Here, I start with a piece of information as a string value, which is bound
    to the name `life_universe_everything`. Imagine I want to do some complex mathematical
    analysis on this data; to do this, I must first convert the data into a floating-point
    number. The desired type would be an instance of the class `float`. That particular
    class has an initializer (`__init__()`) that accepts a string as an argument,
    which is something I know from the documentation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我从一个作为字符串的值开始，它绑定到名称 `life_universe_everything`。假设我想对这些数据进行一些复杂的数学分析；为此，我必须先将数据转换为浮点数。所需的类型是
    `float` 类的一个实例。这个类有一个初始化器（`__init__()`），它接受一个字符串作为参数，这一点我从文档中知道。
- en: I initialize a `float()` object, pass `life_universe_everything` to the initializer,
    and bind the resulting object to the name `answer`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我初始化了一个 `float()` 对象，将 `life_universe_everything` 传递给初始化函数，并将结果对象绑定到名称 `answer`。
- en: 'I’ll print out the `type` and value of `answer`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我将打印 `answer` 的 `type` 和其值：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 5-40: *conversion.py:2*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-40: *conversion.py:2*'
- en: 'That outputs the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Since there were no errors, you can see that the result is a `float` with value
    `42.0`, bound to `answer`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有错误，你可以看到结果是一个值为 `42.0` 的 `float`，绑定到 `answer` 上。
- en: Every class defines its own initializers. In the case of `float()`, if the string
    passed to it cannot be interpreted as a floating-point number, a `ValueError`
    will be raised. Always consult the documentation for the object you’re initializing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都有自己的初始化器。在 `float()` 的情况下，如果传递给它的字符串无法被解释为浮点数，则会引发 `ValueError`。初始化对象时请始终查阅文档。
- en: A Note About Systems Hungarian Notation
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于系统匈牙利命名法的说明
- en: If you’re coming from a statically typed language like C++ or Java, you’re probably
    used to working with data types. Thus, when picking up a dynamically typed language
    such as Python, it might be tempting to employ some means of “remembering” what
    type of value every name is bound to. ***Don’t do this!*** You will find the most
    success using Python if you learn to take full advantage of dynamic typing, weak
    binding, and duck typing.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自像 C++ 或 Java 这样的静态类型语言，你可能已经习惯了处理数据类型。因此，当学习 Python 这种动态类型语言时，你可能会很想采用某种方式来“记住”每个名称绑定的值的类型。***不要这样做！***
    如果你学会充分利用动态类型、弱绑定和鸭子类型，你会在使用 Python 时获得最大的成功。
- en: 'I will confess: the first year I used Python, I used *Systems Hungarian notation*—the
    convention of appending a prefix denoting data type to every variable name—to
    try to “defeat” the language’s dynamic typing system. My code was littered with
    such debris as `intScore`, `floatAverage`, and `boolGameOver`. I picked up the
    habit from my time using Visual Basic .NET, and I thought I was brilliant. In
    fact, I was depriving myself of many opportunities to refactor.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认：我使用 Python 的第一年，我使用了 *系统匈牙利命名法*——即在每个变量名后加上表示数据类型的前缀——来试图“战胜”语言的动态类型系统。我的代码里到处都是像
    `intScore`、`floatAverage` 和 `boolGameOver` 这样的垃圾代码。我是从使用 Visual Basic .NET 时养成这个习惯的，当时我觉得自己非常聪明。事实上，我剥夺了自己许多重构的机会。
- en: 'Systems Hungarian notation will quickly render code obtuse. For example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 系统匈牙利命名法会迅速使代码变得晦涩。例如：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 5-41: *evils_of_systems_hungarian.py*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-41: *evils_of_systems_hungarian.py*'
- en: 'Needless to say, this code is quite painful to read. On the other hand, if
    you make full use of Python’s typing system (and resist the urge to store every
    intermediate step), the code will be decidedly more compact:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 不用多说，这段代码相当难以阅读。另一方面，如果你充分利用 Python 的类型系统（并且抵制将每个中间步骤都存储的冲动），代码将会更加紧凑：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 5-42: *duck_typing_feels_better.py*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-42: *duck_typing_feels_better.py*'
- en: My code became far cleaner once I stopped treating Python like a statically
    typed language. Python’s typing system is a big part of what makes it such a readable
    and compact language.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我不再将 Python 当作静态类型语言来看待，我的代码变得干净多了。Python 的类型系统是使其成为一种可读且紧凑的语言的重要因素之一。
- en: Terminology Review
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语复习
- en: I’ve introduced a lot of important new words in this section. Since I’ll be
    using this vocabulary frequently throughout the rest of the book, doing a quick
    recap here is prudent.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我介绍了许多重要的新词汇。由于我将在本书的其余部分频繁使用这些词汇，在这里进行快速回顾是明智的。
- en: alias (v.) To bind a mutable value to more than one name. Mutations performed
    on a value bound to one name will be visible on all names bound to that mutable
    value.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 别名（v.）将一个可变值绑定到多个名称。对绑定到某个名称的值进行的变更将对所有绑定到该可变值的名称可见。
- en: assignment (n.) The act of binding a value to a name. Assignment never copies
    data.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: assignment (名词) 将一个值绑定到一个名称的行为。赋值从不复制数据。
- en: bind (v.) To create a reference between a name and a value.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: bind (动词) 在名称和值之间创建引用。
- en: coercion (n.) The act of implicitly casting a value from one type to another.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: coercion (名词) 隐式地将一个值从一种类型转换到另一种类型的行为。
- en: conversion (n.) The act of explicitly casting a value from one type to another.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: conversion (名词) 将一个值显式地从一种类型转换到另一种类型的行为。
- en: copy (v.) To create a new value in memory from the same data as another value.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: copy (动词) 从另一个值的相同数据中创建一个新的内存值。
- en: data (n.) Information stored in a value. You may have copies of any given data
    stored in other values.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: data (名词) 存储在值中的信息。你可以在其他值中拥有给定数据的副本。
- en: deep copy (v.) To both copy an object to a new value *and* copy all the data
    from values referenced within that object to new values.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: deep copy (动词) 将一个对象复制到一个新值，并且*还*将对象内引用的所有值的数据复制到新值。
- en: identity (n.) The specific location in memory that a name is bound to. When
    two names share an identity, they are bound to the same value in memory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: identity (名词) 一个名称所绑定的内存位置。当两个名称共享相同的身份时，它们绑定到内存中的同一个值。
- en: immutable (adj.) Of or relating to a value that *cannot* be modified in place.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: immutable (形容词) 表示*不能*在原地修改的值。
- en: mutable (adj.) Of or relating to a value that *can* be modified in place.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: mutable (形容词) 表示*可以*在原地修改的值。
- en: mutate (v.) To change a value in place.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: mutate (动词) 在原地修改一个值。
- en: name (n.) A reference to a value in memory, commonly thought of as a “variable”
    in Python. A name must always be bound to a value. ***Names have scope, but not
    type.***
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: name (名词) 在内存中指向一个值的引用，通常被视为 Python 中的“变量”。一个名称必须始终绑定到一个值。***名称有作用域，但没有类型。***
- en: rebind (v.) To bind an existing name to a different value.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: rebind (动词) 将一个已有的名称绑定到一个不同的值上。
- en: reference (n.) The association between a name and a value.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: reference (名词) 名称和值之间的关联。
- en: scope (n.) A property that defines what section of the code a name is accessible
    from, such as from within a function or within a module.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: scope (名词) 一种属性，定义了一个名称在代码中可访问的区域，比如在一个函数内或模块内。
- en: shallow copy (v.) To copy an object to a new value but *not* copy the data from
    values referenced within that object to new values.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: shallow copy (动词) 将一个对象复制到一个新值，但*不会*复制该对象内引用的所有值的数据到新值。
- en: type (n.) A property that defines how a raw value is interpreted, for example,
    as an integer or a boolean.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: type (名词) 一种属性，定义了如何解释原始值，例如作为整数或布尔值。
- en: value (n.) A unique copy of data in memory. There must be a reference to a value,
    or else the value is deleted. ***Values have type, but not scope.***
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: value (名词) 内存中数据的唯一副本。必须有一个引用指向值，否则该值会被删除。***值有类型，但没有作用域。***
- en: variable (n.) A combination of a name and the value the name refers to.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: variable (名词) 一个名称和该名称所指向的值的组合。
- en: weakref (n.) A reference that does not increase the reference count on the value.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: weakref (名词) 一种不会增加值的引用计数的引用。
- en: To help keep us grounded in these concepts, we usually use the term *name* instead
    of *variable*. Instead of *changing* something, we *(re)bind a name* or *mutate
    a value*. Assignment never copies—it literally always binds a name to a value.
    Passing to a function is just assignment.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们更好地理解这些概念，我们通常使用术语*name*（名称）而不是*variable*（变量）。与其说是*改变*某些东西，不如说我们*重新绑定一个名称*或*改变一个值*。赋值从不复制——它实际上总是将名称绑定到一个值。传递给一个函数只是赋值操作。
- en: By the way, if you ever have trouble wrapping your head around these concepts
    and how they play out in your code, try the visualizer at [http://pythontutor.com/](http://pythontutor.com/).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，如果你在理解这些概念以及它们在代码中的应用时遇到困难，可以尝试使用可视化工具 [http://pythontutor.com/](http://pythontutor.com/)。
- en: Wrapping Up
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: It’s easy to take something like variables for granted, but by understanding
    Python’s unique approach, you can better avail yourself of the power that is available
    through dynamic typing. I must admit, Python has somewhat spoiled me. When I work
    in statically typed languages, I find myself pining for the expressiveness of
    duck typing.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 像变量这样的概念容易被人忽视，但通过理解 Python 独特的方式，你可以更好地利用动态类型带来的强大功能。我必须承认，Python 有些宠坏了我。当我在静态类型语言中工作时，我发现自己渴望鸭子类型的表达能力。
- en: 'Still, working with Python-style dynamic typing can take getting used to if
    you have a background in other languages. It’s like learning how to speak a new
    human language: only with time and practice will you begin to think in the new
    tongue.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果你有其他语言的背景，习惯 Python 风格的动态类型系统可能需要一些时间。这就像学习一门新的语言：只有随着时间的推移和实践，你才会开始用这门新语言思考。
- en: If all this is making your head swim, let me reiterate the single most important
    principles. Names have scope, but no type. Values have type, but no scope. A name
    can be bound to any value, and a value can be bound to any number of names. It
    really is that dead simple! If you remember that much, you’ll go a long way.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切让你感到困惑，我再强调一下最重要的原则。名字有作用域，但没有类型。值有类型，但没有作用域。一个名字可以绑定任何值，而一个值可以绑定任意数量的名字。真的是这么简单！如果你记住这一点，你就能走得很远。
- en: '6'
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Functions and Lambdas
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 函数与 Lambda
- en: '![](Images/chapterart.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Functions are one of the most elementary concepts in programming, yet Python
    packs a surprising amount of versatility into them. You’ll recall from Chapter
    3 that functions are first-class objects, so they are treated no differently from
    any other object. This fact, combined with the power of dynamic typing, opens
    up so many possibilities.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是编程中最基本的概念之一，但 Python 赋予了它们惊人的多功能性。你还记得第三章中提到的，函数是第一类对象，因此它们和其他任何对象一样对待。这一事实，加上动态类型的强大功能，开启了许多可能性。
- en: Python has full support for *functional programming*, a distinct paradigm from
    which we get those “lambdas,” or anonymous functions, you keep reading about online.
    If you’re used to languages like Haskell or Scala, a lot of the concepts in this
    chapter are going to seem familiar to you. However, if you’re more used to object-oriented
    programming, such as in Java or C++, this may be the first time you’ve encountered
    many of these concepts.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Python 完全支持 *函数式编程*，这是一个与众不同的编程范式，从中我们得到了那些你在网上经常看到的“lambda”或匿名函数。如果你习惯了像 Haskell
    或 Scala 这样的语言，本章中的许多概念对你来说应该很熟悉。然而，如果你更习惯面向对象编程，例如 Java 或 C++，那么这些概念可能是你第一次接触。
- en: When learning Python, it makes sense to dive into functional programming early
    on. It is perfectly possible to write idiomatic Python code without ever creating
    a single class (see Chapter 7). By contrast, functions and functional programming
    concepts underpin much of the language’s most powerful features.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 Python 时，尽早深入函数式编程是有意义的。完全可以编写符合 Python 风格的代码，而不需要创建任何类（参见第七章）。相比之下，函数和函数式编程的概念支撑着
    Python 语言许多最强大的特性。
- en: Python Function Essentials
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 函数基础
- en: I briefly touched on functions in Chapter 3. Building on that knowledge, I’ll
    gradually construct a more complex example in this chapter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第三章简要介绍了函数。基于那部分知识，本章将逐步构建一个更复杂的示例。
- en: 'I’ll start by creating a function that rolls a single die with a specified
    number of sides:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从创建一个掷单个骰子的函数开始，骰子的面数是指定的：
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 6-1: *dice_roll.py:1a*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-1: *dice_roll.py:1a*'
- en: I define a function named `roll_dice()`, which accepts a single parameter, `sides`.
    This function is considered pure, because it has no side effects; it accepts a
    value as an input and returns a new value as an output. I return a value from
    the function using the `return` keyword.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个名为 `roll_dice()` 的函数，它接受一个参数 `sides`。这个函数被认为是纯函数，因为它没有副作用；它接受一个输入值并返回一个新的输出值。我使用
    `return` 关键字从函数中返回一个值。
- en: The `random` module has a number of functions for producing random values. Here,
    I use its `random.randint()` function to generate a pseudorandom number in Python.
    I generate a random number between `1` and `20` (the value of `sides` in this
    example) inclusively, with `random.randint(1, 20)`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`random` 模块提供了多个生成随机值的函数。在这里，我使用它的 `random.randint()` 函数来生成一个伪随机数。我生成一个介于 `1`
    和 `20` 之间的随机数（在这个例子中是 `sides` 的值），使用 `random.randint(1, 20)`。'
- en: 'Here’s my usage for the function:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我对函数的使用：
- en: '[PRE54]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listing 6-2: *dice_roll.py:2a*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-2: *dice_roll.py:2a*'
- en: Later, I call the function and pass the value `20` as an argument ❶, so the
    function call is effectively the same as rolling a 20-sided die. The value that
    the first function call returns is bound to `player1`; the second call’s return
    is bound to `player2`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，我调用了这个函数，并将值 `20` 作为参数传入 ❶，因此这个函数调用实际上和掷一个 20 面骰子是一样的。第一次函数调用返回的值绑定到 `player1`；第二次函数调用的返回值绑定到
    `player2`。
- en: Because I defined `roll_dice()` as a function, I can use it as many times as
    I want. If I want to change its behavior, I only need to modify the function in
    the one place where it is defined, and every usage of that function will be affected.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我将 `roll_dice()` 定义为一个函数，所以可以根据需要多次使用它。如果我想改变它的行为，只需要在定义函数的地方修改一次，所有使用该函数的地方都会受到影响。
- en: 'Say I wanted to roll multiple dice at once and return the results in a tuple.
    I can rewrite the `roll_dice()` function to do that:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想一次掷多个骰子，并将结果以元组的形式返回。我可以重写`roll_dice()`函数来实现这一点：
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Listing 6-3: *dice_roll.py:1b*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 6-3: *dice_roll.py:1b*'
- en: To allow rolling multiple dice, the function accepts a second parameter, `dice`,
    which represents the number of dice being rolled. The first parameter, `sides`,
    still represents the number of sides on any one of the dice.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持掷多个骰子，函数接受第二个参数`dice`，表示掷骰子的数量。第一个参数`sides`仍然表示每个骰子的面数。
- en: The scary-looking line of code at the top of the function is a *generator expression*,
    which I’ll cover in Chapter 10. For now, you can take it for granted that I’m
    generating one random number for each die being rolled and packing the results
    in a tuple.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 函数顶部看起来有些吓人的代码行是一个*生成器表达式*，我将在第10章中详细讲解。现在，你可以理所当然地认为我正在为每个掷出的骰子生成一个随机数，并将结果打包成一个元组。
- en: 'Since my function now has a second parameter in the function call, I pass two
    arguments:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我的函数现在在函数调用中有第二个参数，我传递两个参数：
- en: '[PRE56]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 6-4: *dice_roll.py:2b*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 6-4: *dice_roll.py:2b*'
- en: The returned tuple can be *unpacked*, meaning each item in the tuple is bound
    to a name I can use to access the value. The number of names listed on the left
    (separated by commas) and the number of values in the tuple *must* match for this
    to work, or else Python will raise an error. (See Chapter 9 for more on unpacking
    and tuples.)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的元组可以被*解包*，意味着元组中的每个项目都可以绑定一个名称，我可以使用这个名称来访问该值。左侧列出的名称数量（用逗号分隔）和元组中的值数量*必须*匹配，否则
    Python 会抛出错误。（关于解包和元组的更多内容，请参见第9章。）
- en: Recursion
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: '*Recursion* occurs when a function calls itself. This can be helpful when you
    need to repeat the entire logic of a function but a loop is unsuitable or feels
    too cluttered, as in the upcoming example.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归*是指一个函数调用自己。当你需要重复执行整个函数逻辑，但循环不适合或显得过于冗杂时，递归就很有用，正如下面的例子所示。'
- en: For example, returning to my dice-rolling function, I can accomplish the exact
    same result using recursion, instead of that generator expression I was using
    earlier (although in practice, the generator expression is usually considered
    more Pythonic).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回到我的掷骰子函数，我可以通过递归实现与之前相同的结果，而不是使用之前的生成器表达式（尽管在实践中，生成器表达式通常被认为是更符合 Python
    风格的）。
- en: '[PRE57]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 6-5: *dice_roll_recursive.py:1a*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 6-5: *dice_roll_recursive.py:1a*'
- en: I store the resulting roll for this function call in `roll`. Then, in the recursive
    call, I pass my `sides` parameter as is, while reducing the number of `dice` to
    roll by one, to account for the die I just rolled. Finally, I combine the tuple
    that is returned from that recursive function call with the result of the roll
    on this function call, and I return the resulting longer tuple.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我将此次函数调用的掷骰结果存储在`roll`中。然后，在递归调用中，我将`sides`参数原样传递，同时将`dice`的数量减少一，以考虑我刚才掷的那个骰子。最后，我将从递归函数调用中返回的元组与当前函数调用的掷骰结果合并，返回结果是一个更长的元组。
- en: 'The usage is essentially the same as before:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法基本上和之前一样：
- en: '[PRE58]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 6-6: *dice_roll_recursive.py:2a*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 6-6: *dice_roll_recursive.py:2a*'
- en: 'If you were to print out each value being returned, in order from deepest recursive
    call to outermost, here’s what you would see:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印出每个返回的值，从最深的递归调用到最外层的递归调用，你会看到如下内容：
- en: '[PRE59]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 6-7: Returns from recursive calls to `roll_dice(6, 5)`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 6-7: 从递归调用中返回的`roll_dice(6, 5)`结果'
- en: When the number of dice left is zero or negative, I return an empty tuple instead
    of recursively calling it again. If I don’t do that, the recursion will try to
    run forever. Thankfully, Python will pull the plug at some point and just crash
    the program, instead of letting it consume all your computer’s memory (as some
    other programming languages are apt to do). The *recursion depth* is how many
    recursive function calls have not returned yet, and Python caps it at approximately
    one thousand.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当剩余的骰子数量为零或负数时，我会返回一个空元组，而不是再次递归调用。如果不这么做，递归将会无限运行。幸运的是，Python 会在某个时刻中止程序，而不会让它消耗掉你计算机的所有内存（就像一些其他编程语言可能会做的那样）。*递归深度*指的是那些尚未返回的递归函数调用的数量，Python
    会将其限制在大约一千次。
- en: 'If the recursion depth goes any deeper than the limit, the entire program stops
    and raises an error:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递归深度超过了限制，整个程序会停止并抛出错误：
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is why it’s so important that you build some means of stopping when you
    use recursion. In the `roll_dice` function, this stopping mechanism is at the
    very top of the function:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在使用递归时，构建某种停止机制如此重要的原因。在 `roll_dice` 函数中，这个停止机制位于函数的最上面：
- en: '[PRE61]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Since `dice` is getting decremented every time the function calls itself, sooner
    or later, it will reach zero. When it does, it returns an empty tuple, instead
    of producing another recursive call. Then, the rest of the recursive calls can
    finish running and return.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `dice` 每次函数调用时都会递减，迟早它会变为零。到那时，它会返回一个空元组，而不是产生另一个递归调用。然后，其他递归调用可以完成并返回。
- en: 'There may be cases in which a recursion depth of a thousand is not enough.
    If you need more, you can override the maximum:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有递归深度为一千次也不够的情况。如果需要更多，你可以覆盖最大递归深度：
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `sys.setrecursionlimit()` function allows you to set a new maximum recursion
    depth. In this case, my new limit is `2000`. The benefit of this approach is that
    once you no longer need your limit, you can set it back to the default so it can
    keep *other* recursive calls from getting out of hand.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.setrecursionlimit()` 函数允许你设置新的最大递归深度。在这种情况下，我的新限制是 `2000`。这种方法的好处是，一旦你不再需要这个限制，你可以将其恢复为默认值，以防止
    *其他* 递归调用失控。'
- en: Default Argument Values
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数值
- en: 'You might imagine that I would need to roll a single die far more often than
    any other option. As it stands right now, I would have to manually specify that
    I only want to roll one 20-sided die:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为我需要比其他选项更频繁地掷一个骰子。照目前的情况来看，我必须手动指定我只想掷一个20面骰：
- en: '[PRE63]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: I have to manually pass a `1` as the second argument of `roll_dice` to specify
    that I’m rolling a single die.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须手动传递一个 `1` 作为 `roll_dice` 的第二个参数，以指定我只掷一个骰子。
- en: By the way, that trailing comma after `result` is how I unpack a single value
    from a single-item tuple, meaning the actual value of the only item in the tuple
    is now bound to `result`. (See Chapter 9 for more on unpacking.)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，`result` 后面的那个尾随逗号是我如何从一个单项元组中解包一个单一值的方法，这意味着元组中唯一项的实际值现在被绑定到 `result`。
    （有关解包的更多内容，请参见第9章。）
- en: 'Since rolling a single die is likely the most common action I want to take
    with this function, I want to make it more convenient to use. I can use *default
    argument values* to accomplish this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于掷一个骰子可能是我最常用的操作，我希望让它变得更加方便。我可以使用 *默认参数值* 来实现这一点：
- en: '[PRE64]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 6-8: *dice_roll.py:1c*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-8：*dice_roll.py:1c*
- en: 'The `dice` parameter now has a default argument value of `1`. Thus, anytime
    I don’t specify the second argument, `dice` will use its default argument value.
    This makes it possible to use a simplified function call to roll a single six-sided
    die:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`dice` 参数现在的默认值为 `1`。因此，每当我没有指定第二个参数时，`dice` 就会使用其默认值。这使得可以使用简化的函数调用来掷一个六面骰子：'
- en: '[PRE65]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If I do want to roll multiple dice, I can still pass that second argument:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我确实想要掷多个骰子，我仍然可以传递第二个参数：
- en: '[PRE66]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: When you specify a default argument value for a parameter, you are defining
    an *optional parameter*. Conversely, a parameter with no default argument value
    is a *required parameter*. You can have as many of each as you like, but you must
    list all required parameters *before* your optional parameters. Otherwise, the
    code won’t run.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为参数指定一个默认值时，你正在定义一个 *可选参数*。相反，一个没有默认值的参数是 *必需参数*。你可以根据需要有任意多个可选或必需参数，但你必须在可选参数之前列出所有必需参数，否则代码将无法运行。
- en: 'When using optional parameters, there is one significant trap lurking in the
    dark: default argument values are only evaluated once, when the function is defined.
    One place where this gets treacherous is when you’re using any mutable data type,
    such as a list. Consider this code for generating values in a Fibonacci sequence,
    which doesn’t quite work as expected:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用可选参数时，有一个重要的陷阱潜伏在黑暗中：默认参数值只会在函数定义时求值一次。一个潜在的问题是，当你使用任何可变数据类型时，比如列表。考虑这个生成斐波那契数列值的代码，它并不像预期的那样工作：
- en: '[PRE67]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 6-9: *fibonacci.py:1a*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-9：*fibonacci.py:1a*
- en: This is going to have a problem because the default argument value `[1, 1]`
    ❶ is evaluated when Python first processes the function definition, creating a
    single mutable list with the value `[1, 1]` in memory. That gets mutated on the
    first function call ❷ and then returned.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会有一个问题，因为默认参数值 `[1, 1]` ❶ 在 Python 首次处理函数定义时被求值，创建了一个内存中值为 `[1, 1]` 的单一可变列表。这个列表在第一次函数调用时被修改
    ❷，然后被返回。
- en: 'This usage of the function shows the problem:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的用法展示了问题所在：
- en: '[PRE68]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 6-10: *fibonacci.py:2*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-10: *fibonacci.py:2*'
- en: Everything looks okay in the code, but it isn’t. `fib1` is now bound to the
    same mutable value as `series`, so any changes to `fib1` are reflected in the
    default argument value *for every function call*. The second function call mutates
    this list further.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来没问题，但实际上并非如此。`fib1`现在绑定到了与`series`相同的可变值上，因此对`fib1`的任何更改都会反映在每个函数调用的默认参数值中。第二次函数调用进一步改变了这个列表。
- en: 'When I call `fibonacci_next()` a third time, I’m probably expecting to start
    with a clean slate, `[1, 1, 2]`, which would be the result of a single mutation
    on the original default argument value. Instead, I’m getting the value of that
    single mutable value I’ve been messing with this whole time: `fib2` is now a third
    alias to the list. Oops!'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第三次调用`fibonacci_next()`时，我可能期待从一个干净的状态开始，即`[1, 1, 2]`，这是对原始默认参数值进行单次变异后的结果。相反，我得到了那个我一直在操作的单一可变值：`fib2`现在是这个列表的第三个别名。哎呀！
- en: 'This becomes apparent when I examine the output. This is what I’d be expecting:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当我检查输出时，这一点变得明显。这是我期待的结果：
- en: '[PRE69]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'But this is what I actually get:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 但这才是我实际上得到的：
- en: '[PRE70]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In short, *never use mutable values for default argument values*. Instead,
    use `None` as a default value, as shown in the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*永远不要使用可变值作为默认参数值*。相反，使用`None`作为默认值，如下所示：
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 6-11: *fibonacci.py:1b*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-11: *fibonacci.py:1b*'
- en: The proper way is to use `None` as the default argument value, and then to create
    a new mutable value if that default is being used.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法是使用`None`作为默认参数值，然后在使用该默认值时创建一个新的可变值。
- en: 'Running that same usage code as before ([Listing 6-9](#listing6-9)) now produces
    the expected output:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 运行之前的相同使用代码（[列表 6-9](#listing6-9)）现在会产生预期的输出：
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Keyword Arguments
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键字参数
- en: Readability matters. Unfortunately, function calls with multiple parameters
    aren’t always the most readable bits of code. *Keyword arguments* help resolve
    this by attaching labels to arguments in function calls.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性很重要。不幸的是，带有多个参数的函数调用并不总是最具可读性的代码片段。*关键字参数*通过在函数调用中为参数附加标签来帮助解决这个问题。
- en: Arguments that are mapped to their parameters by the order you pass them in,
    like in all the prior examples, are called *positional arguments*.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 通过你传递参数的顺序与参数名称进行映射的参数，如同之前所有的示例中一样，被称为*位置参数*。
- en: If you knew nothing about the `roll_dice()` function from earlier and you encountered
    this line of code, what would you think it did?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对之前的`roll_dice()`函数一无所知，而你遇到了这一行代码，你会认为它做了什么？
- en: '[PRE73]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Listing 6-12: *dice_roll.py:3a*'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-12: *dice_roll.py:3a*'
- en: You would probably guess that this is rolling multiple dice, and perhaps that
    it is specifying how many sides those dice have—but which is which? Is it rolling
    six five-sided dice or five six-sided dice? You can imagine how confusing this
    would be with even more arguments. This is the shortcoming of positional arguments.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会猜测这是在掷多个骰子，或许是指定骰子的面数——但哪个是哪个呢？是掷六个五面骰子，还是五个六面骰子？你可以想象，如果有更多的参数，这会变得多么令人困惑。这就是位置参数的缺点。
- en: 'As The Zen of Python says:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 正如《Python禅》所说：
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面对模糊性时，拒绝猜测的诱惑。
- en: 'It can’t be good, then, to force the reader to guess. I can eliminate the ambiguity
    by using *keyword arguments*. I don’t need to change the function definition at
    all to be able to use keyword arguments. I only need to change my function call:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，强迫读者猜测肯定不好。我可以通过使用*关键字参数*来消除模糊性。我不需要改变函数定义，就可以使用关键字参数。我只需要更改我的函数调用：
- en: '[PRE74]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Listing 6-13: *dice_roll.py:3b*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-13: *dice_roll.py:3b*'
- en: 'Each of those names comes from the earlier function definition of `roll_dice`,
    where I specified it had two parameters: `sides` and `dice`. In my function call,
    I can assign values directly to those parameters by name. Now, there is no question
    about what each argument does. Specify the name of the parameter, matching what
    is in the function definition, and then assign the desired value directly to it.
    That’s all.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称都来自早先`roll_dice`函数的定义，在定义中我指定了它有两个参数：`sides`和`dice`。在我的函数调用中，我可以通过名称直接为这些参数赋值。现在，不会再有任何疑问关于每个参数的作用了。只需指定参数的名称，与函数定义中的名称匹配，然后直接为其赋值。这就是全部。
- en: 'When using keyword arguments, you don’t even have to list them in order, just
    as long as all the required parameters receive values:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字参数时，你甚至不需要按顺序列出它们，只要所有必需的参数都收到值即可：
- en: '[PRE75]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 6-14: *dice_roll.py:3c*'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-14: *dice_roll.py:3c*'
- en: 'This can be even more helpful when you have multiple optional parameters on
    the function. Consider if I rewrote `roll_dice()` so that the dice being rolled
    were six sided, by default:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数有多个可选参数时，这会更加有帮助。想象一下，如果我将`roll_dice()`重写，使得掷骰子的默认骰子是六面体的：
- en: '[PRE76]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Listing 6-15: *dice_roll.py:1d*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-15: *dice_roll.py:1d*'
- en: 'Keyword arguments allow you to simplify your function calls even further:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数可以进一步简化你的函数调用：
- en: '[PRE77]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Listing 6-16: *dice_roll.py:3d*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-16: *dice_roll.py:3d*'
- en: You’re only passing a value to one of the optional arguments, `dice`. For the
    other one, `sides`, the default value is used. It no longer needs to matter whether
    `sides` or `dice` appears first in the function’s parameter list; you can just
    use the ones you want and leave the rest alone.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你只向其中一个可选参数`dice`传递了一个值。对于另一个参数`sides`，使用的是默认值。现在无论`sides`还是`dice`在函数参数列表中出现的顺序如何都不再重要；你可以根据需要使用你想要的参数，其他的可以保持不变。
- en: 'It is even possible to mix and match positional arguments and keyword arguments:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以混合使用位置参数和关键字参数：
- en: '[PRE78]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Listing 6-17: *dice_roll.py:3e*'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-17: *dice_roll.py:3e*'
- en: Here, `6` is passed as a positional argument to the first parameter in the function
    definition, `sides`. Then, I pass `5` as a keyword argument to the parameter `dice`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`6`作为位置参数传递给函数定义中的第一个参数`sides`。然后，我将`5`作为关键字参数传递给参数`dice`。
- en: This can come in handy, particularly when you don’t want to bother with naming
    the positional arguments but you still want to use one of many possible optional
    parameters. The only rule here is that your keyword arguments must come after
    your positional arguments in the function call. (See also the section “Keyword-Only
    Parameters” later in the chapter.)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，尤其是在你不想费心命名位置参数时，但仍然希望使用多个可选参数中的一个。这里的唯一规则是，关键字参数必须在位置参数之后出现在函数调用中。（参见本章后面的“仅限关键字参数”部分。）
- en: On Overloaded Functions
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于重载函数
- en: If you’re coming from a strictly typed language such as Java or C++, you’re
    probably used to writing *overloaded functions*, wherein you can write multiple
    functions with the same name but different parameters. Typically, overloaded functions
    in languages that support them provide a consistent interface (function name),
    while supporting arguments of different types.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自于像Java或C++这样严格类型的语言，你可能习惯于编写*重载函数*，即你可以写多个同名但参数不同的函数。通常，支持重载函数的语言会提供一致的接口（函数名），同时支持不同类型的参数。
- en: Python usually doesn’t need overloaded functions. Using dynamic typing, duck
    typing, and optional parameters, you can write single functions that handle all
    the input scenarios you need to throw at Python.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通常不需要重载函数。通过使用动态类型、鸭子类型和可选参数，你可以编写单个函数来处理你需要提供给Python的所有输入场景。
- en: If you really, really need overloaded functions—and you probably don’t—you actually
    can create them with *single-dispatch functions*. I’ll cover this in Chapter 15.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的非常需要重载函数——而你可能并不需要——你其实可以通过*单一分发函数*来创建它们。我将在第15章讲解这一点。
- en: Variadic Arguments
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数
- en: With the skills discussed so far, even while using optional parameters, you
    still have to anticipate how many arguments can potentially get passed to your
    function. This is fine in most cases, but sometimes, you’ll have no idea how many
    to expect.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，使用所讨论的技能，即使使用了可选参数，你仍然需要预见到可能会传递多少个参数到你的函数中。在大多数情况下这是没问题的，但有时你根本无法知道会有多少个参数。
- en: To solve this, your first instinct might be to pack all the arguments into a
    single tuple or a list. That works in some situations, but other times, it can
    become an extra inconvenience when calling the function.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你的第一反应可能是将所有参数打包成一个元组或列表。在某些情况下，这样做有效，但有时在调用函数时它会变成一种额外的不便。
- en: 'A better solution is to use *arbitrary arguments lists*, also called *variadic
    arguments*, which automatically pack multiple arguments into a single *variadic
    parameter* or *variadic positional parameter*. In the dice-rolling function, I
    want to allow the rolling of multiple dice, where each die may have a different
    number of sides:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是使用*任意参数列表*，也称为*可变参数*，它会自动将多个参数打包成一个*可变参数*或*可变位置参数*。在掷骰子函数中，我希望允许掷多个骰子，其中每个骰子可能有不同的面数：
- en: '[PRE79]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Listing 6-18: *dice_roll_variadic.py:1a*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-18: *dice_roll_variadic.py:1a*'
- en: I turn the parameter `dice` into a variadic parameter by preceding it with a
    single asterisk (`*`). All the arguments passed to `roll_dice` will now be packed
    into a tuple, bound to the name `dice`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过在参数`dice`前加上单个星号（`*`）将其转变为可变参数。现在，传递给`roll_dice`的所有参数都将被打包成一个元组，并绑定到`dice`这个名称上。
- en: Within the function, I can use this tuple in the usual manner. In this case,
    I’m using a generator expression (see Chapter 10) to roll each die specified in
    `dice`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我可以像通常那样使用这个元组。在这种情况下，我使用了一个生成器表达式（见第10章）来掷`dice`中指定的每个骰子。
- en: 'The placement of the variadic parameter is important: it must come *after*
    any positional parameters in the function definition. Any parameters I list after
    it will only be usable as keyword arguments, because the variadic parameter consumes
    all the remaining positional arguments.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数的位置非常重要：它必须在函数定义中的任何位置参数之后。任何我在它后面列出的参数将只能作为关键字参数使用，因为可变参数会消耗所有剩余的位置参数。
- en: 'Here’s my usage:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的用法：
- en: '[PRE80]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Listing 6-19: *dice_roll_variadic.py:2*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-19：*dice_roll_variadic.py:2*
- en: 'In both function calls, I’m listing the dice I want to roll, with the number
    representing the number of sides of each die. In the first call, I’m rolling five
    six-sided dice. In the second call, I’m rolling four dice: a 20-sided die, a 6-sided
    die, an 8-sided die, and a 4-sided die.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个函数调用中，我都列出了我想掷的骰子，数字表示每个骰子的面数。在第一个调用中，我掷的是五个六面骰子。在第二个调用中，我掷的是四个骰子：一个20面骰子，一个6面骰子，一个8面骰子和一个4面骰子。
- en: 'If I wanted to use the recursive approach, I’d populate the argument list by
    automatically unpacking that tuple into the function call:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想使用递归方法，我会通过自动解包元组并将其传递给函数调用来填充参数列表：
- en: '[PRE81]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Listing 6-20: *dice_roll_variadic.py:1b*'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-20：*dice_roll_variadic.py:1b*
- en: Most of this code is going to look similar to the earlier recursive version.
    The most significant change is in what I’m passing to the recursive function call.
    The asterisk (`*`) in front of the name unpacks the tuple `dice` into the argument
    list ❶. I already processed the first item in the list, so I use the slice notation
    `[1:]` to remove that first item ❷ (see Chapter 9), to ensure it isn’t processed
    again.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码大部分与之前的递归版本相似。最显著的变化是在递归函数调用中传递的内容。`*`符号在名称前解包了元组`dice`到参数列表中 ❶。我已经处理了列表中的第一个项，所以我使用切片符号`[1:]`来去除第一个项
    ❷（见第9章），确保它不会再次被处理。
- en: Keyword Variadic Arguments
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键字可变参数
- en: To capture an unknown number of *keyword arguments*, precede the parameter name
    with *two* asterisks (`**`), making the parameter a *keyword variadic parameter*.
    The keyword arguments passed to the function are packed into a single dictionary
    object, so as to preserve the association between keyword and value. They are
    similarly unpacked by being preceded with two asterisks.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获不确定数量的*关键字参数*，可以在参数名称前加上*两个*星号（`**`），将该参数变成*关键字可变参数*。传递给函数的关键字参数会被打包成一个单一的字典对象，从而保留关键字与值之间的关联。它们也可以通过在参数前加上两个星号来解包。
- en: This doesn’t show up very often in the wild. After all, if you didn’t know what
    the arguments were named, it would be hard to use them.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在实际中并不常见。毕竟，如果你不知道参数是如何命名的，就很难使用它们。
- en: 'One case where keyword variadic arguments are commonly useful is in blindly
    relaying arguments to another function call:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的使用关键字可变参数的场景是将参数盲目地传递给另一个函数调用：
- en: '[PRE82]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 6-21: *variadic_relay.py:1*'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-21：*variadic_relay.py:1*
- en: The `call_something_else()` function has one positional argument, `func`, where
    I’ll pass a *callable* object, such as another function. The second parameter,
    `args`, is a variadic parameter for capturing all the remaining positional arguments.
    Last is the keyword variadic parameter, `kwargs`, for capturing any keyword arguments;
    sometimes, the name `kw` is used instead. Remember, either of these can be empty
    and this code will still work.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_something_else()`函数有一个位置参数`func`，我将在其中传递一个*可调用*对象，例如另一个函数。第二个参数`args`是一个可变参数，用于捕获所有剩余的位置参数。最后是关键字可变参数`kwargs`，用于捕获任何关键字参数；有时也会使用`kw`来命名。记住，这些参数中的任何一个都可以为空，代码仍然可以正常工作。'
- en: You can check whether an object is callable by passing it to the `callable()`
    function.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将对象传递给`callable()`函数来检查它是否是可调用的。
- en: The names `args` and `kwargs` are conventionally used for positional variadic
    and keyword variadic parameters, respectively. However, if you can think of names
    that better fit your particular situation, that’s certainly acceptable!
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`args` 和 `kwargs` 这两个名称是惯例上分别用于位置可变参数和关键字可变参数的名称。然而，如果你能想到更适合你具体情况的名称，那当然也是可以接受的！'
- en: When the function calls the callable object `func`, it first unpacks all the
    positional arguments that were captured, and then it unpacks all the keyword arguments.
    The function code doesn’t need any knowledge of the callable object’s parameter
    list; instead, any and every argument passed to `call_something_else()` after
    that first positional argument will get blindly passed on.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数调用可调用对象 `func` 时，它首先解包所有被捕获的定位参数，然后解包所有的关键字参数。函数代码不需要知道可调用对象的参数列表；相反，任何传递给
    `call_something_else()` 的参数（在第一个位置参数之后）都将被盲目地传递下去。
- en: 'You can see this in action here:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到这一点的实际演示：
- en: '[PRE83]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Listing 6-22: *variadic_relay.py:2*'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-22: *variadic_relay.py:2*'
- en: 'When I run that code, the `call_something_else()` function will call `say_hi()`,
    passing the argument `name="Bob"` to it. That produces the following output:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这段代码时，`call_something_else()` 函数将调用 `say_hi()`，并传递参数 `name="Bob"`。这会产生以下输出：
- en: '[PRE84]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This bit of magic will come back into play shortly in writing *decorators* (see
    the section “Decorators” later in this chapter).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这段神奇的代码将在写 *装饰器* 时再次派上用场（请参阅本章后面的“装饰器”部分）。
- en: Keyword-Only Parameters
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅限关键字参数
- en: You can use variadic parameters to turn some of your keyword parameters into
    *keyword-only parameters*, which were introduced in PEP 3102\. These parameters
    cannot have values passed in as positional arguments, but rather only as keyword
    arguments. This can be especially useful in ensuring that particularly long or
    perilous parameter lists are used in the proper manner, instead of as nigh-on
    unreadable chains of positional arguments.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用可变参数将一些关键字参数转换为 *仅限关键字参数*，这些参数是在 PEP 3102 中引入的。这些参数不能通过位置参数传递值，而只能作为关键字参数传递。这在确保特别长或危险的参数列表以正确的方式使用，而不是作为几乎无法阅读的定位参数链时尤其有用。
- en: 'To demonstrate this, I’ll rewrite my `roll_dice()` function to have two keyword-only
    parameters:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将重写我的`roll_dice()`函数，使其具有两个仅限关键字参数：
- en: '[PRE85]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Listing 6-23: *dice_roll_keyword_only.py:1*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-23: *dice_roll_keyword_only.py:1*'
- en: I use the unnamed variadic parameter `*`, which ensures every parameter that
    follows it in the list can only be accessed by name. If the caller passes in too
    many positional arguments (or in this case, *any* positional arguments), a `TypeError`
    is raised.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了未命名的可变参数 `*`，这确保了列表中其后的每个参数只能通过名称来访问。如果调用者传入了过多的位置参数（或者在这种情况下，*任何*位置参数），将引发
    `TypeError` 错误。
- en: 'This affects the usage, such that I can only use keyword arguments now:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这会影响用法，因此我现在只能使用关键字参数：
- en: '[PRE86]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Listing 6-24: *dice_roll_keyword_only.py:2*'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-24: *dice_roll_keyword_only.py:2*'
- en: 'Attempting to use positional arguments raises an error:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用位置参数会引发错误：
- en: '[PRE87]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Listing 6-25: *dice_roll_keyword_only.py:3*'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-25: *dice_roll_keyword_only.py:3*'
- en: Positional-Only Parameters
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅限位置参数
- en: As of Python 3.8 (via PEP 570), it is also possible to define *positional-only
    parameters*. This is useful when the parameter name is either unhelpful or likely
    to be changed down the road, meaning any code using it as a keyword parameter
    would be likely to break in the future.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.8（通过 PEP 570）开始，*仅限位置参数*的定义也成为可能。这在参数名称不太有用或未来可能会更改的情况下很有用，这意味着任何将其作为关键字参数使用的代码可能会在未来出现问题。
- en: 'You’ll recall that positional parameters must always come first in the parameter
    list. Placing a forward slash (`/`) in the list designates all preceding parameters
    as positional-only:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，位置参数必须始终位于参数列表的最前面。在列表中放置一个正斜杠（`/`）会将所有前面的参数指定为仅限位置参数：
- en: '[PRE88]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Listing 6-26: *dice_roll_positional_only.py:1*'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-26: *dice_roll_positional_only.py:1*'
- en: 'In this example, the parameter `dice` still has a default value of `1`, but
    it is now positional-only. On the other hand, `sides` can be used as either a
    positional or a keyword parameter. Here’s that behavior in action:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，参数 `dice` 仍然有一个默认值 `1`，但它现在是仅限位置的。另一方面，`sides` 可以作为位置参数或关键字参数使用。以下是该行为的实际演示：
- en: '[PRE89]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Listing 6-27: *dice_roll_positional_only.py:2*'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-27: *dice_roll_positional_only.py:2*'
- en: The first four examples all work, because the positional-only argument `dice`
    is either included as the first argument or omitted altogether. Any attempt to
    access `dice` by keyword fails with a `TypeError`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个示例都能正常工作，因为位置仅参数 `dice` 要么作为第一个参数传递，要么完全省略。任何尝试通过关键字访问 `dice` 的操作都会失败并引发
    `TypeError`。
- en: 'Argument Types: All Together Now!'
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数类型：大家一起看！
- en: 'To ensure everything is clear regarding positional parameters and keyword parameters,
    I’ll take a moment to review with this (admittedly contrived) example:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保有关位置参数和关键字参数的内容清晰明了，我会用这个（承认是人为的）示例做一下回顾：
- en: '[PRE90]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The parameter `pos_only` is positional-only, as it comes before the forward-slash
    (`/`) marker. If I have any positional-only parameters, they must appear first
    in the list. Because this parameter has a default value, it is optional. However,
    if I wanted to pass an argument to it, it would need to be the first positional
    argument passed to the function; otherwise, a `TypeError` would be raised.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `pos_only` 是位置仅参数，因为它位于斜杠符号（`/`）标记之前。如果我有任何位置仅参数，它们必须首先出现在列表中。由于该参数有默认值，它是可选的。然而，如果我想为它传递一个参数，它必须是传递给函数的第一个位置参数；否则会引发
    `TypeError`。
- en: Next is the `pos_kw` parameter, which can be either positional or keyword. It
    comes after any positional-only parameters and after the forward-slash (`/`) marker,
    if there is one.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `pos_kw` 参数，它可以是位置参数或关键字参数。它位于所有位置仅参数之后，并且位于斜杠符号（`/`）标记之后（如果有的话）。
- en: Finally, after the asterisk (`*`) marker, I have `kw_only`, which is a keyword-only
    parameter. In this example, if my function receives more than two positional arguments,
    a `TypeError` will be raised.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在星号符号（`*`）之后，我有 `kw_only`，它是一个仅限关键字的参数。在这个例子中，如果我的函数接收到两个以上的位置参数，会引发 `TypeError`。
- en: Nested Functions
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套函数
- en: From time to time, you may want to reuse a piece of logic *within* a function
    but not clutter up your code by making yet another function. In this situation,
    you can nest functions within other functions.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想在函数内部重复使用某些逻辑，但又不想通过创建另一个函数来让代码显得杂乱。在这种情况下，你可以在函数内部嵌套函数。
- en: 'I can use this to improve the recursive version of `roll_dice()`, making the
    logic for rolling a single die into something more reusable in the function:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以利用这一点来改进递归版的 `roll_dice()`，将单个骰子的投掷逻辑转化为更具可重用性的功能。
- en: '[PRE91]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Listing 6-28: *dice_roll_recursive.py:1b*'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-28：*dice_roll_recursive.py:1b*
- en: In this example, I moved the logic for rolling a single die into a nested function
    `roll()`, which I can call from anywhere in the function `roll_dice()`. The direct
    benefit of abstracting out this logic is that it can be maintained more easily,
    without disrupting the rest of the code.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将投掷单个骰子的逻辑移动到一个嵌套函数 `roll()` 中，我可以在 `roll_dice()` 函数中的任何位置调用它。将此逻辑抽象出来的直接好处是，它可以更容易地进行维护，而不干扰其余的代码。
- en: 'Here’s the usage:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用法：
- en: '[PRE92]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Listing 6-29: *dice_roll_recursive.py:2b*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-29：*dice_roll_recursive.py:2b*
- en: That produces the usual random output.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生通常的随机输出。
- en: In production, I’d rarely use a nested function for something that trivial.
    Normally, I’d employ a nested function for more complex logic that sees frequent
    reuse, especially if it is used in multiple places in the outer function.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，我很少会使用嵌套函数来处理如此简单的事情。通常，我会使用嵌套函数来处理更复杂的逻辑，尤其是当该逻辑在外部函数中被多次使用时。
- en: You’ll recall from Chapter 5 that the nested function can access the names of
    its enclosing scope. However, if I wanted to rebind or mutate any of those names
    from within the nested function, I’d need to use the `nonlocal` keyword.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得第 5 章中提到的，嵌套函数可以访问其封闭作用域中的名称。然而，如果我想在嵌套函数内部重新绑定或改变这些名称，我需要使用 `nonlocal`
    关键字。
- en: Closures
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: You can create a function that builds and returns a kind of function called
    a *closure*, which encloses one or more nonlocal names. This pattern acts as a
    sort of “function factory.”
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个构建并返回一种名为*闭包*的函数，它封闭了一个或多个非局部变量。这种模式充当一种“函数工厂”。
- en: 'Building on the dice example, I’ll write a function that returns a *closure*
    for rolling a particular set of dice:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 以骰子示例为基础，我将编写一个函数，返回一个用于投掷特定骰子的*闭包*：
- en: '[PRE93]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Listing 6-30: *dice_cup_closure.py:1*'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-30：*dice_cup_closure.py:1*
- en: I create the function `make_dice_cup()`, which accepts the arguments for `sides`
    and `dice`. Inside `make_dice_cup()`, I define a nested function `roll()`, which
    uses `sides` and `dice`. When that nested function is returned by the outer function
    (no parentheses!) ❶, it becomes a closure, because it encloses `sides` and `dice`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了函数`make_dice_cup()`，它接受`sides`和`dice`作为参数。在`make_dice_cup()`内部，我定义了一个嵌套函数`roll()`，它使用`sides`和`dice`。当这个嵌套函数被外部函数返回时（没有括号！）❶，它变成了一个闭包，因为它封闭了`sides`和`dice`。
- en: '[PRE94]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Listing 6-31: *dice_cup_closure.py:2*'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-31: *dice_cup_closure.py:2*'
- en: I bind the closure returned by `make_dice_cup()` to the name `roll_for_damage`,
    which I can now call as a function without any arguments. The closure continues
    to use `sides` and `dice` with the values I specified earlier to roll dice and
    return values; it is now a function in its own right.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`make_dice_cup()`返回的闭包绑定到名称`roll_for_damage`，现在我可以像调用函数一样调用它而无需任何参数。闭包继续使用我之前指定的`sides`和`dice`来投掷骰子并返回值；它现在本身就是一个函数。
- en: Caution is necessary when using closures, as you can easily violate the rules
    of functional programming with them. If a closure has the ability to mutate the
    values it encloses, it becomes a sort of de facto object, and a difficult one
    to debug at that!
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包时需要小心，因为你很容易违反函数式编程的规则。如果闭包能够改变它所封闭的值，它就变成了一种事实上的对象，而且还是一个很难调试的对象！
- en: Recursion with Closures
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包中的递归
- en: The previous closure example didn’t use the recursive form of the dice-rolling
    code because, while it’s possible to implement such closure correctly, it’s even
    easier to do it wrong.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个闭包示例没有使用递归形式的投骰子代码，因为，虽然可以正确实现这种闭包，但实际上更容易出错。
- en: 'Here’s the most apparently obvious, yet wrong, way to make that closure recursive:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现闭包递归的最显而易见但错误的方法：
- en: '[PRE95]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Listing 6-32: *dice_cup_closure_recursive.py:1a*'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-32: *dice_cup_closure_recursive.py:1a*'
- en: Using what you know about names and scope so far, can you anticipate what’s
    wrong with the above?
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你目前对名称和作用域的了解，你能预见到上面代码的问题吗？
- en: 'The giveaway that something is wrong with the closure is the keyword `nonlocal`,
    as it indicates I’m mutating or rebinding a nonlocal name: `dice`.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 判断闭包是否有问题的标志是关键字`nonlocal`，因为它表示我正在修改或重新绑定一个非本地名称：`dice`。
- en: 'Attempting to use this closure will reveal the problem:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这个闭包会揭示出问题：
- en: '[PRE96]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Listing 6-33: *dice_cup_closure_recursive.py:2*'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-33: *dice_cup_closure_recursive.py:2*'
- en: 'That code produces the following output (for example):'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会产生以下输出（例如）：
- en: '[PRE97]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The first time the closure `roll_for_damage()` is used, everything is fine.
    However, `dice` isn’t reset when the function exits, so all subsequent calls to
    the closure find that `dice == 0`. Thus, they only return `()`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包`roll_for_damage()`第一次被使用时，一切正常。然而，`dice`在函数退出时并没有被重置，因此所有后续对该闭包的调用都会发现`dice
    == 0`。因此，它们只会返回`()`
- en: 'To write a recursive closure, you need to use an optional parameter on the
    closure:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写递归闭包，你需要在闭包中使用一个可选参数：
- en: '[PRE98]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Listing 6-34: *dice_cup_closure_recursive.py:1b*'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-34: *dice_cup_closure_recursive.py:1b*'
- en: In this version, I use the nonlocal name `dice` as the default value of the
    new, local parameter `dice`. (Recall, this will only work with immutable types.)
    This behaves precisely as expected, as it still closes over `sides` and the nonlocal
    `dice`, but it rebinds neither.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我将非本地名称`dice`作为新本地参数`dice`的默认值。（回想一下，这只适用于不可变类型。）它的行为完全符合预期，因为它仍然封闭`sides`和非本地`dice`，但它没有重新绑定这两个值。
- en: Stateful Closures
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有状态的闭包
- en: While it is generally best to write closures as pure functions, it is occasionally
    useful to create a *stateful closure*—that is, a closure that retains a little
    bit of state between calls that it can use. In general, you should avoid using
    stateful closures unless no other solution presents itself.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常最好将闭包写成纯函数，但偶尔也有必要创建一个*有状态的闭包*——即一个在调用之间保留一些状态以供使用的闭包。一般来说，除非没有其他解决方案，否则应避免使用有状态的闭包。
- en: 'Just to demonstrate this, I’ll create a stateful closure that limits how many
    times a player can reroll a group of dice:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将创建一个有状态的闭包，限制玩家重新投掷一组骰子的次数：
- en: '[PRE99]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Listing 6-35: *dice_roll_turns.py:1*'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-35: *dice_roll_turns.py:1*'
- en: I write the closure `roll()` so that it only allows the caller to reroll the
    dice a maximum number of times, specified by `limit`, before the function starts
    returning `None`. By this design, after the limit is reached, a new closure must
    be created. The logic of tracking how many times a player can roll the dice has
    been abstracted out into the closure.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了闭包 `roll()`，使其仅允许调用者重新掷骰子的次数最多为 `limit` 次，超过次数后函数会返回 `None`。通过这种设计，在达到限制后，必须创建一个新的闭包。跟踪玩家掷骰子次数的逻辑已经被抽象到闭包中。
- en: This closure is very limited and predictable in how it mutates and uses its
    state. It’s important to limit your closures in this way, since debugging a stateful
    closure can be difficult. There is no way to see the current value of `limit`
    from outside the closure; it’s simply not possible.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这个闭包在如何变更和使用其状态方面非常有限和可预测。限制你的闭包至此是很重要的，因为调试带状态的闭包可能非常困难。无法从闭包外部看到 `limit` 的当前值；这几乎是不可能的。
- en: 'You can see this predictable behavior at work in the usage:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在使用中看到这种可预测的行为：
- en: '[PRE100]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Listing 6-36: *dice_roll_turns.py:2*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-36: *dice_roll_turns.py:2*'
- en: 'Running that code produces the following randomized output, wherein each turn
    gets three tosses of the dice; each toss is represented by a tuple:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会生成以下随机化输出，其中每轮有三次掷骰子；每次掷骰子由一个元组表示：
- en: '[PRE101]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: A stateful closure can be useful in situations where writing an entire class
    (see Chapter 7) brings in too much boilerplate. Since I only have one piece of
    state, `limit`, and I am using it predictably, this approach is acceptable. Anything
    more complicated, and debugging becomes impractically difficult.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 带有状态的闭包在某些情况下非常有用，尤其是当写一个完整的类（参见第 7 章）会带来太多冗余代码时。由于我只有一个状态，`limit`，并且我使用它是可预测的，因此这种方法是可以接受的。如果情况更复杂，调试将变得非常困难。
- en: As I pointed out earlier, anytime you see `nonlocal` in a closure, you should
    be extra cautious, as it indicates the presence of state. This can be acceptable
    on occasion, but there is usually a better approach. Stateful closures are not
    pure functional programming!
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前指出的，任何时候你在闭包中看到 `nonlocal`，你应该特别小心，因为它表示存在状态。偶尔可以接受这种情况，但通常有更好的方法。带状态的闭包不是纯粹的函数式编程！
- en: Lambdas
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambdas
- en: 'A *lambda* is an anonymous (nameless) function made up of a single expression.
    The structure is as follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '*lambda* 是一个匿名（无名）函数，由单个表达式构成。其结构如下：'
- en: '[PRE102]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: On the left side of the colon is the parameter list, which may be omitted if
    you don’t want to accept any arguments. On the right is the return expression,
    which is evaluated when the lambda is called and the result is implicitly returned.
    To use a lambda, you must bind it to a name, whether by assignment or by passing
    it as an argument to another function.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号左侧是参数列表，如果你不想接受任何参数，可以省略它。右侧是返回表达式，它在调用 lambda 时被计算，并隐式返回结果。要使用 lambda，你必须将其绑定到一个名称上，无论是通过赋值，还是将其作为参数传递给另一个函数。
- en: 'For example, here’s a lambda that adds two numbers:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是一个将两个数字相加的 lambda：
- en: '[PRE103]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Listing 6-37: *addition_lambda.py*'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-37: *addition_lambda.py*'
- en: I bind the `lambda` to the name `add` and then call it as a function. This particular
    lambda accepts two arguments and then returns their sum.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 `lambda` 绑定到名称 `add`，然后像调用函数一样调用它。这个特定的 lambda 接受两个参数，并返回它们的和。
- en: Why Lambdas Are Useful
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么 Lambda 很有用
- en: Many programmers can’t imagine ever needing nameless functions. It would seem
    to make reuse completely impractical. After all, if you’re just going to bind
    a lambda to a name, shouldn’t you have just written a function?
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员无法想象什么时候需要无名函数。这似乎会使重用变得完全不切实际。毕竟，如果你最终只是将 lambda 绑定到一个名称上，难道你不应该直接写一个函数吗？
- en: 'To understand how lambdas can be useful, let’s take a look at an example *without*
    lambdas first. This code represents a player character in a basic text adventure
    game:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 lambda 如何有用，让我们先看一个*没有*使用 lambda 的例子。以下代码表示一个基础文字冒险游戏中的玩家角色：
- en: '[PRE104]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Listing 6-38: *text_adventure_v1.py:1*'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-38: *text_adventure_v1.py:1*'
- en: 'I’m keeping track of my character’s stats in a couple of global names at the
    top, `health` and `xp`, which I’ll use throughout my program:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我在程序的顶部通过 `health` 和 `xp` 两个全局变量跟踪我的角色状态，我将在程序中使用它们：
- en: '[PRE105]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Listing 6-39: *text_adventure_v1.py:2*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-39: *text_adventure_v1.py:2*'
- en: My `attempt()` function handles rolling the dice, using the outcome to decide
    whether the player’s action succeeded or failed, and then modifying the values
    of the global `health` and `xp` variables accordingly. It determines how those
    values should be changed, based on the value returned from calling the function
    passed to `outcome`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 `attempt()` 函数负责掷骰子，使用结果来决定玩家的动作是成功还是失败，然后相应地修改全局 `health` 和 `xp` 变量的值。它根据调用传递给
    `outcome` 函数的返回值来决定这些值应该如何变化。
- en: The part to focus on is the parameter `outcome` ❶—which, by its usage in `attempt()`
    ❷, should be a function that accepts a boolean value and returns a tuple of two
    integers representing the desired changes to `health` and `xp`, respectively.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 需要关注的部分是参数 `outcome` ❶——根据它在 `attempt()` ❷ 中的用法，它应该是一个接受布尔值并返回一个包含两个整数的元组的函数，这两个整数分别表示对
    `health` 和 `xp` 的期望变化。
- en: 'Expanding on that example, I’ll use what I’ve built so far:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展这个例子，我将使用到目前为止构建的内容：
- en: '[PRE106]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Listing 6-40: *text_adventure_v1.py:3a*'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-40：*text_adventure_v1.py:3a*
- en: 'There’s no real pattern to the outcomes of each possible action, so I have
    to write functions for each one: in this example, `eat_bread()` and `fight_ice_weasel()`.
    Even this example is a bit oversimplified, as the code determining the outcome
    might involve a bunch of mathematics and randomization. Regardless, since I need
    a separate outcome function for each action, this code is going to grow rapidly,
    leading to a maintainability nightmare.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可能的动作结果没有固定的模式，因此我必须为每个动作编写函数：在这个例子中，`eat_bread()`和`fight_ice_weasel()`。即使这个例子有些过于简化，因为决定结果的代码可能涉及一堆数学运算和随机化。不过，由于我需要为每个动作编写单独的结果函数，这段代码将迅速膨胀，导致可维护性变成一场噩梦。
- en: (Be advised, the `if` statement above is not the most Pythonic way to write
    that code; I deliberately chose that structure to illustrate the logic.)
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，上面的 `if` 语句并不是最 Pythonic 的写法；我故意选择了这种结构来说明逻辑。）
- en: When I attempt an action ❶, I pass the string representing the action, the minimum
    dice roll necessary to succeed, and the function determining the outcome. When
    passing a function, remember not to include the trailing parentheses. Here, I
    want to pass the function itself, not the value it returns.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当我尝试某个动作❶时，我传递表示该动作的字符串、成功所需的最小骰子掷值，以及决定结果的函数。传递函数时，记住不要加上尾随的圆括号。这里，我希望传递的是函数本身，而不是它返回的值。
- en: 'This sort of usage is where lambdas come in. I can replace the `eat_bread()`
    and `fight_ice_weasel()` functions, plus the two calls to `attempt()`, with just
    the following:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法正是 lambda 的作用所在。我可以用下面的代码替换 `eat_bread()` 和 `fight_ice_weasel()` 函数，以及两次调用
    `attempt()`：
- en: '[PRE107]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Listing 6-41: *text_adventure_v1.py:3b*'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-41：*text_adventure_v1.py:3b*
- en: 'The third argument of each is a lambda, which accepts a single parameter named
    `success` and returns a value depending on the value of `success`. Let’s isolate
    just that first lambda:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数的第三个参数是一个 lambda，它接受一个名为`success`的单一参数，并根据`success`的值返回一个结果。让我们单独看看第一个 lambda：
- en: '[PRE108]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: When the lambda is called, if the value of `success` is `True`, then `(1, 0)`
    will be returned. Otherwise, `(-1, 0)` is returned.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 当 lambda 被调用时，如果 `success` 的值为 `True`，则返回 `(1, 0)`；否则，返回 `(-1, 0)`。
- en: That lambda is being passed to (and thus bound to) the `outcome` parameter of
    the `attempt()` function, and it is subsequently called with a single boolean
    argument.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 该 lambda 被传递给（并因此绑定到）`attempt()`函数的`outcome`参数，并随后使用一个布尔值作为参数进行调用。
- en: By using lambdas in this manner, I can create many different possible outcomes
    in my code with only one line of code.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式使用 lambda，我可以在代码中用一行代码创建多种不同的可能结果。
- en: Remember that *a lambda may only consist of a single return expression*! This
    makes lambdas suitable for short, clear fragments of logic, especially when the
    code is made more readable by keeping that logic close to its usage within another
    function call. If you want anything more complex, you’ll need to write a proper
    function.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*lambda 只能包含单一的返回表达式*! 这使得 lambda 适合用于短小、清晰的逻辑片段，尤其是当通过将该逻辑保持在与其在另一个函数调用中的使用接近时，代码可读性会得到提高。如果你需要更复杂的逻辑，必须编写一个正式的函数。
- en: Lambdas as Sorting Keys
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为排序键的 Lambda 表达式
- en: One of the most common situations where a lambda comes in handy is when specifying
    a *key function*, which is a callable that returns the part of a collection or
    object that should be used for sorting. A key function is typically passed to
    another function that is responsible for sorting data in some manner.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: lambda最常用的场景之一是当需要指定一个*键函数*时，键函数是一个可调用对象，返回集合或对象中的部分内容，用于排序。键函数通常会传递给另一个负责以某种方式对数据进行排序的函数。
- en: 'For example, here I have a list of tuples containing first and last names,
    and I want to sort the list by last name:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个包含名字和姓氏的元组列表，我想按照姓氏对列表进行排序：
- en: '[PRE109]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Listing 6-42: *sort_names.py*'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-42: *sort_names.py*'
- en: The `sorted()` function uses the `key` argument ❶, which is always a function
    or other callable, by passing each item to it and then using the value returned
    from that callable to determine the sorting order. Since I want the tuples sorted
    by last name, which is the second item of each tuple, I have the lambda return
    that item, which is `x[1]`.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`函数使用`key`参数 ❶，它始终是一个函数或其他可调用对象，传递每个项给它，然后使用从该可调用对象返回的值来确定排序顺序。由于我希望按照姓氏排序元组，而姓氏是每个元组的第二项，所以我让lambda返回该项，也就是`x[1]`。'
- en: The end result is that `by_last_name` contains the list, sorted by last name.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，`by_last_name`包含按姓氏排序的列表。
- en: Decorators
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: '*Decorators* allow you to modify the behavior of a function (or even multiple
    functions) by wrapping it in an additional layer of logic. This changes the function’s
    behavior without you having to rewrite the function itself.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器*允许你通过将函数（或多个函数）包装在额外的逻辑层中，来修改函数的行为。这改变了函数的行为，而无需你重写函数本身。'
- en: To demonstrate this, here’s another example with my text adventure game hero.
    I want to define multiple game events that affect the player character’s statistics
    in different ways, and I want those changes displayed as they happen. I’ll start
    with an implementation that doesn’t use decorators. This code only uses concepts
    I’ve already covered so far in this book, so I’ll mainly draw your attention to
    some inefficiencies.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，这里有一个我在文字冒险游戏中的英雄的例子。我想定义多个游戏事件，这些事件以不同的方式影响玩家角色的统计数据，并且我希望这些变化能够实时显示。我将从一个不使用装饰器的实现开始。这个代码只使用了我在本书中已经讲解过的概念，所以我会主要提醒你注意一些效率上的不足。
- en: 'I’ll start by defining my global variables:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从定义我的全局变量开始：
- en: '[PRE110]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Listing 6-43: *text_adventure_v2.py:1a*'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-43: *text_adventure_v2.py:1a*'
- en: 'Next, I’ll define functions for each action the player can take:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将为玩家可以执行的每个动作定义函数：
- en: '[PRE111]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Listing 6-44: *text_adventure_v2.py:2a*'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-44: *text_adventure_v2.py:2a*'
- en: Each function represents an action the player can take, and some common code
    is shared between these functions. First, each function checks the character’s
    health to determine if the character is even able to perform the action ❶ ❸. If
    the character’s health is sufficient, the player performs the action, which alters
    the character’s statistics. When the action is completed (or if the character’s
    health is too low to take an action), the current stats are displayed ❷ ❹.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数代表玩家可以执行的一个动作，且这些函数之间共享一些常见的代码。首先，每个函数会检查角色的生命值，以确定角色是否能够执行该动作 ❶ ❸。如果角色的生命值足够，玩家便会执行该动作，从而改变角色的统计数据。当动作完成后（或者如果角色的生命值过低无法执行动作），当前的统计数据会显示出来
    ❷ ❹。
- en: 'And then, of course, I have the usage:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当然，我有了用法：
- en: '[PRE112]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Listing 6-45: *text_adventure_v2.py:3*'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-45: *text_adventure_v2.py:3*'
- en: That works, but as I said, the repeated code in [Listing 6-44](#listing6-44)
    is not very Pythonic. Your first instinct might be to move the common code—the
    code that checks the health and displays the statistics—out into their own functions.
    However, you would still need to remember to call each one within *every character
    action function*, and they’re easy to overlook. Furthermore, each function would
    still need that conditional statement at the top to ensure the code isn’t run
    when health is too low.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以正常工作，但正如我所说，[列表 6-44](#listing6-44)中的重复代码不是很符合Python的优雅风格。你的第一反应可能是将共同的代码——即检查生命值和显示统计信息的代码——提取到自己的函数中。然而，你仍然需要记得在*每个角色动作函数*中调用它们，而且这些函数很容易被忽视。此外，每个函数顶部仍然需要那个条件语句，以确保当生命值过低时不会执行代码。
- en: This situation, where I want to run the same code before and after every function,
    can be perfectly solved with decorators.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况，即我希望在每个函数之前和之后都运行相同的代码，使用装饰器可以完美解决。
- en: 'Here, I’ll create a decorator toward the top of the text adventure game code:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将在文字冒险游戏代码的顶部创建一个装饰器：
- en: '[PRE113]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Listing 6-46: *text_adventure_v2.py:1b*'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-46: *text_adventure_v2.py:1b*'
- en: A decorator is most often implemented as a closure, which closes over a function
    (or any other callable object) being modified. The decorator itself, `character_action()`,
    accepts a `func` parameter, which is the callable being modified.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器通常实现为闭包，它封闭了正在修改的函数（或任何其他可调用对象）。装饰器本身，`character_action()`，接受一个 `func` 参数，这就是被修改的可调用对象。
- en: Within the decorator definition is the *wrapper*, which is the callable where
    the decorator’s logic lives ❸. As I said, most commonly, the closure pattern is
    used for this. However, the wrapper can be implemented with any callable, including
    a class. (Technically, I could even implement the wrapper as a noncallable, but
    this is seldom, if ever, useful.)
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在装饰器定义内部是 *包装器*，它是装饰器逻辑所在的可调用对象 ❸。如我所说，最常见的是使用闭包模式来实现这一点。然而，包装器可以用任何可调用对象实现，包括类。（从技术上讲，我甚至可以实现一个非可调用的包装器，但这种做法很少，几乎没有用处。）
- en: Because I don’t know how many arguments will be passed to any function I’ll
    apply the decorator to, I set up the wrapper to accept variadic arguments.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我不知道将传递给我装饰器的任何函数的参数数量，我设置包装器以接受可变数量的参数。
- en: The `@functools.wraps(func)` line ❷ prevents the callable being wrapped from
    having its identity concealed from the rest of the program. Without that line,
    wrapping the callable would mess up external access of such important function
    attributes as `__doc__` (the docstring) and `__name__`. This line is itself a
    decorator that ensures all the important attributes of the callable are retained
    by the now-wrapped function, thus making them accessible outside the function
    in all the usual ways. (To use that special decorator, I must import `functools`
    first ❶.)
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`@functools.wraps(func)` 这一行 ❷ 防止被包装的可调用对象在程序中暴露出身份。如果没有这一行，包装可调用对象会导致一些重要函数属性（如
    `__doc__`（文档字符串）和 `__name__`）在外部无法访问。该行本身就是一个装饰器，确保所有可调用对象的重要属性被现在的包装函数保留，从而在外部以通常的方式访问。（要使用这个特殊的装饰器，我必须先导入
    `functools` ❶。）'
- en: Inside the wrapper, I put all that logic I want to run before and after each
    function. After checking `health`, I call the function that is bound to `func`,
    unpacking all the variadic arguments into the call. I also bind the return value
    to `result`, so I can ensure that gets returned from the decorator after I print
    the stats.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在包装器内部，我放入了所有想要在每个函数执行前后运行的逻辑。在检查 `health` 后，我调用与 `func` 绑定的函数，将所有可变参数解包传递给该函数。我还将返回值绑定到
    `result`，这样我可以确保在打印统计信息后将其从装饰器返回。
- en: As with any closure, it is supremely important that the outer function return
    the inner function ❹.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何闭包一样，外部函数返回内部函数 ❹ 这一点至关重要。
- en: 'Now, I can use the decorator I wrote and refactor my other functions:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以使用我编写的装饰器，并重构我的其他函数：
- en: '[PRE114]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Listing 6-47: *text_adventure_v2.py:2b*'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-47: *text_adventure_v2.py:2b*'
- en: To apply decorators to a function, I list each decorator I want to apply directly
    above the function definition, one decorator per line. I precede each decorator
    name with an `@` symbol. In my example, I only apply a single decorator to each
    function, but you can use as many as you like. They will be applied in order,
    with each decorator wrapping whatever is immediately below it.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 要将装饰器应用于函数，我将每个装饰器列在函数定义上方，每行一个装饰器。我在每个装饰器名称前加上 `@` 符号。在我的示例中，我每个函数只应用了一个装饰器，但你可以使用任意多个装饰器。它们将按顺序应用，每个装饰器包装其下方紧跟着的内容。
- en: Since I moved all the repetitive logic about checking health and displaying
    stats out of the individual functions and into the decorator, my code is cleaner
    and easier to maintain. If you run the code, it works the same as before.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我将所有关于检查健康和显示统计信息的重复逻辑从各个函数中移到装饰器中，我的代码更加简洁，且更易于维护。如果你运行代码，它的行为与之前相同。
- en: Type Hints and Function Annotations
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提示和函数注解
- en: 'Python 3.5 onward allows you to specify *type hints*, which are exactly that:
    *hints* about what data type should be passed in or returned. These are not strictly
    necessary, given Python’s robust dynamic type system, but they may have a few
    benefits.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.5 开始，允许你指定 *类型提示*，它们就是：关于应该传入或返回什么数据类型的 *提示*。考虑到 Python 强大的动态类型系统，这些并不是严格必要的，但它们可能会带来一些好处。
- en: First, type hinting aids in documentation. The function definition now shows
    what type of information it wants, which is especially helpful when your IDE auto-magically
    shows hints as you type arguments in.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，类型提示有助于文档化。函数定义现在展示了它想要什么类型的信息，这在你输入参数时，IDE 自动显示提示时尤其有用。
- en: Second, type hints help you catch potential bugs sooner. Static type checkers
    like *Mypy* are the primary tools for this (see Chapter 2). Some IDEs, like PyCharm,
    may warn you if you’re doing something weird, like passing a string to something
    type-hinted as an integer.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，类型提示有助于你更早地捕捉潜在的错误。像 *Mypy* 这样的静态类型检查工具是主要的工具（参见第 2 章）。一些 IDE，例如 PyCharm，如果你做了些奇怪的事情，比如将一个字符串传给了被类型提示为整数的变量，可能会提醒你。
- en: If you’re familiar with statically typed languages like Java and C++, this might
    make you a little excited.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉像 Java 和 C++ 这样的静态类型语言，这可能会让你感到兴奋。
- en: However, understand that using type hints does not trade Python’s dynamic typing
    for static typing!
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，理解一个重要的概念：使用类型提示并不会将 Python 的动态类型变为静态类型！
- en: Python will not raise an error if you pass the wrong type.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你传入错误的类型，Python 不会抛出错误。
- en: Python will not try to convert data to the specified type.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 不会尝试将数据转换为指定的类型。
- en: Python will actually ignore these hints altogether!
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 实际上会完全忽略这些提示！
- en: Type hints are specified with *annotations*, which are extra pieces of information
    that are permitted by the Python language but are not actually processed by the
    interpreter itself. There are two kinds of annotations.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示是通过*注解*指定的，注解是 Python 语言允许的额外信息，但解释器本身并不会处理这些信息。注解有两种类型。
- en: '*Variable annotations* specify the expected type on a name, like this:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量注解*指定了一个名称的期望类型，例如这样：'
- en: '[PRE115]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '*Function annotations* specify type hints on parameters and function returns.
    Here, I apply function annotations to the `roll_dice()` function from earlier:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数注解*用于指定参数和函数返回值的类型提示。在这里，我将函数注解应用于之前的`roll_dice()`函数：'
- en: '[PRE116]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Listing 6-48: *dice_roll.py:1e*'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-48: *dice_roll.py:1e*'
- en: This notation allows me to denote what types I expect for the parameters and
    return. In this case, both parameters should receive an integer, so I follow each
    name with a colon and then `int` as the expected data type. If there’s a default
    value of the expected type, it is included after the type hint.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这种符号允许我标明我期望的参数和返回值类型。在这种情况下，两个参数都应该接收一个整数，因此我在每个参数名后面加上冒号，然后写上`int`作为期望的数据类型。如果有期望类型的默认值，它会在类型提示后面进行说明。
- en: I denote the return type with an arrow (`->`) and the expected type. Collections
    like tuples and lists are a little trickier to specify with type hints. From the
    `typing` module, I can use the notation `Tuple[ ]`, which is a *generic type*.
    Every value of this particular tuple should be an `int`, but since I don’t really
    know how many will be returned, I specify a `...` to say, “There may be more.”
    Now, the function will be expected to return one or more integers, but no other
    types.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过箭头（`->`）和期望的类型来表示返回类型。像元组和列表这样的集合类型在使用类型提示时会稍微复杂一点。通过 `typing` 模块，我可以使用 `Tuple[
    ]` 符号，它是一个*泛型类型*。这个特定元组的每个值都应该是一个 `int`，但由于我不清楚将返回多少个元素，因此我用 `...` 来表示“可能有更多”。现在，函数预计将返回一个或多个整数，但不会返回其他类型。
- en: By the way, if you don’t know what or how many types will be returned in a tuple,
    you can use the notation `typing.Tuple[typing.Any, ...]`
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你不知道元组中将返回什么类型或有多少种类型，你可以使用符号 `typing.Tuple[typing.Any, ...]`
- en: 'That return type hint in the preceding code example is pretty long. I could
    shorten it by defining a *type alias*, like this:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例中的返回类型提示比较长。我可以通过定义一个*类型别名*来缩短它，例如这样：
- en: '[PRE117]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Listing 6-49: *dice_roll.py:1f*'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-49: *dice_roll.py:1f*'
- en: I define `TupleInts` as a type alias for `Tuple[int, ...]`, and I can use it
    the same way throughout my code.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 `TupleInts` 定义为 `Tuple[int, ...]` 的类型别名，并且可以在整个代码中以相同的方式使用它。
- en: Again, Python itself won’t act on these type hints; it will only recognize the
    notation system as valid and store it in the `__annotations__` attribute of the
    function, nothing more.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Python 本身并不会处理这些类型提示，它只会将这种符号系统识别为有效，并将其存储在函数的`__annotations__`属性中，仅此而已。
- en: 'I can now run this code through Mypy:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以通过 Mypy 来运行这段代码：
- en: '[PRE118]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: If there are any mismatches between the type hints and the actual usage, Mypy
    will list these in detail, so they can be fixed.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型提示和实际使用之间有任何不匹配，Mypy 会详细列出这些问题，方便进行修正。
- en: Duck Typing and Type Hints
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型和类型提示
- en: You might think that type hinting is incompatible with duck typing, but thanks
    to the `typing` module, the two generally play very well with one another.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为类型提示与鸭子类型不兼容，但得益于 `typing` 模块，两者通常能很好地配合使用。
- en: For example, if you wanted a function that could accept a single parameter of
    any type that could be iterated over (see Chapter 9), such as a tuple or a list,
    you could use `typing.Iterable[]`, with the contained type in the brackets. For
    this example, I’ll presume that the iterable may contain any type.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想要一个能够接受任何类型的单一参数，并且该类型是可迭代的（见第9章），比如元组或列表，你可以使用`typing.Iterable[]`，括号内填入包含的类型。对于这个例子，我假设该可迭代对象可能包含任何类型的元素。
- en: '[PRE119]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The parameter `within` is type-hinted to be an iterable with `typing.Iterable[
    ]`. The hint `typing.Any` within the square brackets indicates that the `Iterable`
    can contain items of any data type.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`within`被类型提示为一个可迭代对象，使用了`typing.Iterable[]`。方括号内的提示`typing.Any`表示`Iterable`可以包含任何数据类型的元素。
- en: 'The typing module contains many different such types, enough to fill up a separate
    chapter altogether. The best way to learn more about type hinting is to read the
    documentation: [https://docs.python.org/library/typing.html](https://docs.python.org/library/typing.html).
    I also recommend taking a look at PEP 484, which defined type hinting, and PEP
    3107, which defined function annotations.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing`模块包含了许多不同的类型，足以填满一个单独的章节。学习类型提示的最佳方式是阅读文档：[https://docs.python.org/library/typing.html](https://docs.python.org/library/typing.html)。我还推荐你阅读PEP
    484，它定义了类型提示，以及PEP 3107，它定义了函数注解。'
- en: Should You Use Type Hinting?
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 是否应该使用类型提示？
- en: Type hinting is entirely optional, and there are cases for it and against it.
    Some argue that it clutters up the code, impairing the natural readability that
    Python attained through dynamic typing. Others see it as a much-needed tool for
    mitigating the bugs made possible through the lack of static typing.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示是完全可选的，既有支持的理由，也有反对的声音。有些人认为它会使代码变得杂乱，破坏了Python通过动态类型实现的自然可读性。另一些人则认为它是一个非常需要的工具，有助于减少由于缺乏静态类型检查而可能出现的错误。
- en: In practice, you don’t need to make a wholesale “use or don’t use” decision.
    Because type hinting is optional, you can use it in cases where it improves the
    readability and stability of the code and skip it in cases where it doesn’t. Even
    within a function, you can define a type hint for one parameter and omit it for
    the next.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你不需要做出“要么使用，要么不使用”的彻底决定。由于类型提示是可选的，你可以在它提高代码可读性和稳定性的地方使用它，在它不适用的地方跳过它。即便是在同一个函数中，你也可以为一个参数定义类型提示，而为下一个参数省略它。
- en: Ultimately, the decision is up to you and your team alone. Only you know if
    and when type hints will be helpful. In short, *know thine own project*.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，决定权在你和你的团队手中。只有你知道何时何地使用类型提示最为有用。简而言之，*了解你自己的项目*。
- en: Since this book focuses on idiomatic Python above all else, and since type hinting
    is entirely optional, I won’t use it in any future examples.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书重点讲解符合Python习惯用法的内容，并且类型提示完全是可选的，因此在以后的例子中，我不会使用类型提示。
- en: Wrapping Up
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: I hope you come away from this chapter with a newfound appreciation for functional
    programming in the Python language. Even when the paradigm is not embraced wholesale,
    its concepts and guidelines inform Pythonic code.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能在本章结束后对Python中的函数式编程有一个全新的认识。即使这个范式没有被全面采用，其概念和指导原则也为Pythonic代码提供了重要的启发。
- en: I’ll still apply functional concepts as I move into object-oriented programming
    in the next chapter. I’ve found that, when combined correctly, these paradigms
    interact in surprisingly positive ways.**  **# 7
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当我进入面向对象编程时，我仍然会应用函数式的概念。我发现，当这两种范式正确结合时，它们的互动方式令人惊讶地积极。**  **# 7
- en: Objects and Classes
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 对象和类
- en: '![](Images/chapterart.png)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Objects are the bread and butter of many a programmer. Python makes full use
    of objects, even to the point of inspiring the mantra, “Everything is an object.”
    However, if you’ve worked with classes and objects in any other language, Python’s
    take may surprise you.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多程序员来说，对象是必不可少的。Python充分利用对象，甚至有“万物皆对象”的口号。然而，如果你在其他语言中使用过类和对象，Python的处理方式可能会让你感到惊讶。
- en: '*Object-oriented programming* (or *OOP*) is a paradigm in which data and its
    corresponding logic is organized into objects. If you’re familiar with such languages
    as Java, C++, Ruby, and C#, you’re well acquainted with these concepts.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象编程*（或 *OOP*）是一种将数据及其对应的逻辑组织为对象的范式。如果你熟悉Java、C++、Ruby和C#等语言，你应该对这些概念非常了解。'
- en: Yet, object-oriented programming in Python is not mutually exclusive with functional
    programming; in fact, the two paradigms work very well together.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python中的面向对象编程与函数式编程并不相互排斥；实际上，这两种范式结合得非常好。
- en: 'In this chapter, I’ll cover the essentials of object-oriented programming in
    Python: creating classes with attributes, modules, and properties. I’ll demonstrate
    adding various behaviors via special methods, and I’ll wrap up with a summary
    of the situations in which classes are the most useful.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我将讲解 Python 中面向对象编程的基础：创建带有属性、模块和属性的类。我将演示如何通过特殊方法添加各种行为，并且最后总结类在什么情况下最为有用。
- en: Declaring a Class
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明一个类
- en: 'Creating a new class is simple. I’ll create a class named `SecretAgent`:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新类很简单。我将创建一个名为`SecretAgent`的类：
- en: '[PRE120]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Listing 7-1: Initializing a class'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-1: 类初始化'
- en: Below this, in the accompanying suite of the class declaration, I’d add any
    methods I want to include in the object. An object is known as an *instance* of
    a class in Python. I’ll cover this in detail shortly.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明的附加部分，我会添加我希望包括在对象中的任何方法。在 Python 中，对象被称为类的*实例*。我稍后会详细讲解这一点。
- en: In Python, everything is an object, in that everything inherits from the `object`
    class. In Python 3, this inheritance from `object` is implicit, as seen in [Listing
    7-1](#listing7-1). In Python 2, you had to explicitly inherit from `object`, or
    from another class that inherits from `object`. (I cover inheritance in Chapter
    13. You can take it for granted here.)
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，一切都是对象，因为一切都继承自`object`类。在 Python 3 中，这种从`object`的继承是隐式的，如[列表 7-1](#listing7-1)所示。而在
    Python 2 中，你必须显式继承自`object`，或者从继承自`object`的其他类继承。（我会在第 13 章讲解继承，你可以在这里视其为理所当然。）
- en: 'Here’s the `SecretAgent` class declaration again, this time explicitly inheriting
    from `object`, as Python 2 would have required:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`SecretAgent`类的声明，再次显式继承自`object`，正如 Python 2 所要求的：
- en: '[PRE121]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Listing 7-2: Initializing a class with explicit inheritance'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-2: 显式继承的类初始化'
- en: Listings 7-1 and 7-2 are functionally identical. Python developers really hate
    *boilerplate code*, which is code that is widely reused, with little or no modification.
    That is why Python 3 added the shorter technique seen in [Listing 7-1](#listing7-1).
    Unless you need to support Python 2, the shorter technique is preferred. You’ll
    encounter both ways often enough, so it’s important to know that they do the exact
    same thing in Python 3.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-1 和 7-2 在功能上是相同的。Python 开发者非常讨厌*样板代码*，即广泛重用、修改较少或不修改的代码。这也是为什么 Python 3
    增加了[列表 7-1](#listing7-1)中看到的简短技巧。除非你需要支持 Python 2，否则推荐使用这种简短技巧。你将经常遇到这两种方式，因此了解它们在
    Python 3 中做的完全相同非常重要。
- en: The Initializer
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化方法
- en: A class often has an *initializer* method for defining the initial values of
    *instance attributes*, which are the member variables that exist in each instance.
    If your instance will have no instance attributes, you don’t need to define `__init__()`.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类通常有一个*初始化方法*，用来定义*实例属性*的初始值，实例属性是每个实例中存在的成员变量。如果你的实例没有任何实例属性，就不需要定义`__init__()`。
- en: 'I want each instance of `SecretAgent` to have a code name and a list of secrets.
    Here’s the initializer for my `SecretAgent` class, which has two instance attributes:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望每个`SecretAgent`实例都有一个代号和一个秘密列表。这里是我为`SecretAgent`类定义的初始化方法，它有两个实例属性：
- en: '[PRE122]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Listing 7-3: *secret_agent.py:1a*'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-3: *secret_agent.py:1a*'
- en: The initializer must have the name `__init__` to be recognized as an initializer,
    and it must accept at least one argument, conventionally called `self`. This `self`
    argument references the instance the method is acting on.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化方法必须命名为`__init__`，才能被识别为初始化方法，并且必须至少接受一个参数，通常称为`self`。这个`self`参数引用正在操作的实例。
- en: In this case, I also accept a second argument, `codename`, which I use as the
    initial value of one of my instance attributes. This `self.codename` attribute
    will be the code name of the secret agent.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我还接受第二个参数`codename`，它被用作我的一个实例属性的初始值。这个`self.codename`属性将是特工的代号。
- en: Instance attributes are part of the class instance itself, so I must access
    them through the dot (`.`) operator on `self`. All instance attributes should
    be declared in the initializer method, rather than on the fly in other instance
    methods. Therefore, I’m also defining `self._secrets` as an empty list. This will
    be a list of secrets the particular secret agent (instance) is keeping.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 实例属性是类实例的一部分，因此我必须通过`self`上的点（`.`）运算符访问它们。所有实例属性应该在初始化方法中声明，而不是在其他实例方法中动态声明。因此，我还将`self._secrets`定义为空列表。这个列表将是特定特工（实例）所保守的秘密。
- en: Lastly, an initializer must never return a value via the `return` keyword; if
    it does, calling the initializer will raise a `TypeError`. However, you may use
    `return` by itself to explicitly exit the method, if you ever need to.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，初始化函数绝对不能通过`return`关键字返回一个值；如果返回了，调用初始化函数会抛出`TypeError`。不过，如果需要，你可以单独使用`return`来显式退出方法。
- en: 'Whenever I create a new class instance, the initializer is automatically called.
    Here, I create three `SecretAgent` instances and provide arguments for the `codename`
    parameter of the initializer:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我创建一个新的类实例时，初始化函数会自动被调用。在这里，我创建了三个`SecretAgent`实例，并为初始化函数的`codename`参数提供了参数：
- en: '[PRE123]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Listing 7-4: *secret_agent_usage.py:1*'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-4: *secret_agent_usage.py:1*'
- en: In this module, I import my `SecretAgent` class and create three new instances.
    You’ll notice that I didn’t need to pass anything to the first parameter, `self`.
    That’s taken care of behind the scenes. Instead, my first argument, `"Mouse"`,
    is passed to the second parameter of the initializer, `codename`. Each instance
    also has its own empty `_secrets` list.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中，我导入了我的`SecretAgent`类并创建了三个新的实例。你会注意到，我并没有向第一个参数`self`传递任何东西。这是由幕后自动处理的。相反，我的第一个参数`"Mouse"`被传递给了初始化函数的第二个参数`codename`。每个实例也都有它自己空的`_secrets`列表。
- en: The Constructor
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: If you’re coming from C++, Java, or some similar language, you may expect to
    write a *constructor*—a function that constructs an instance of a class—or you
    may think that the initializer does the same thing as a constructor. In fact,
    Python 3 splits the duties of a typical constructor between the initializer `__init__()`
    and the constructor `__new__()`.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自 C++、Java 或类似的语言，你可能会期望写一个*构造函数*—一个构造类实例的函数—或者你可能认为初始化函数和构造函数做的是一样的事。实际上，Python
    3 将典型构造函数的职责分配给了初始化函数`__init__()`和构造函数`__new__()`。
- en: In Python, the constructor `__new__()` takes care of actually creating the instance
    in memory. When you create a new instance, the constructor is automatically called
    first, followed by a call to the initializer. The constructor is the only method
    in the class to be called automatically before the object is created!
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，构造函数`__new__()`负责实际在内存中创建实例。当你创建一个新的实例时，构造函数会自动首先被调用，然后才是初始化函数的调用。构造函数是类中唯一在对象创建之前自动调用的方法！
- en: 'You don’t normally need to define a constructor; one is provided automatically.
    The only time you would create a constructor would be if you needed additional
    control over the process. However, to familiarize you with the syntax, I’ll write
    a very basic (and effectively pointless) constructor, which could go in a class
    definition:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你不需要定义构造函数；它会自动提供。唯一需要创建构造函数的情况是当你需要更多的控制权时。然而，为了让你熟悉语法，我将编写一个非常基础（而且实际上没有意义）的构造函数，它可以放在类定义中：
- en: '[PRE124]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The constructor always has the name `__new__`, and it implicitly accepts a class
    as its first parameter, `cls` (in contrast to the initializer, which accepts a
    class instance on `self`). Since the initializer accepts parameters, I also need
    to prepare the constructor to accept these on the constructor, so I use variadic
    arguments to capture these arguments and pass them on to the initializer parameters.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数总是叫做`__new__`，并且它隐式地接受一个类作为它的第一个参数`cls`（与初始化函数不同，初始化函数接受一个类实例作为`self`）。由于初始化函数需要接受参数，我还需要准备构造函数来接收这些参数，所以我使用变长参数来捕获这些参数并将它们传递给初始化函数的参数。
- en: The constructor must return the class instance that gets created. Technically,
    I could return whatever I wanted here, but the expected behavior would almost
    certainly be to return an instance that has been instantiated from the `SecretAgent`
    class. To do that, I call the `__new__` function on the parent class, which you
    may recall (from [Listing 7-2](#listing7-2)) is `object`. (I’ll return to `super()`
    in Chapter 13. Don’t worry about understanding it now.)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数必须返回被创建的类实例。从技术上讲，我可以在这里返回任何我想要的东西，但预期的行为几乎肯定是返回一个由`SecretAgent`类实例化的对象。为了做到这一点，我在父类上调用`__new__`函数，你可能还记得（从[列表
    7-2](#listing7-2)）它是`object`。（我会在第13章回到`super()`，现在不需要理解它。）
- en: In practice, if this is all your constructor needs to do, just omit it! Python
    automatically handles the constructor behavior if you don’t write any code for
    it. Only write a constructor when you need to control the behavior around instantiating
    the class instance itself. In any event, that scenario is rare; it is perfectly
    plausible that you will never write a constructor in your entire Python programming
    career.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，如果构造函数只需要做这些工作，那么直接省略它！如果你没有为构造函数编写任何代码，Python 会自动处理构造函数的行为。只有当你需要控制类实例化过程中的行为时，才编写构造函数。无论如何，这种情况是很少见的；你完全可以在整个
    Python 编程生涯中从未编写过构造函数。
- en: The Finalizer
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 析构器
- en: 'The *finalizer* is called when a class instance finally reaches the end of
    its lifespan and is cleaned up by the garbage collector. It exists solely to handle
    any technically complex cleanup that your particular class may require. As with
    the constructor, you will seldom, if ever, need to write this function yourself.
    If you do, it’s important to understand: the finalizer is only called if the class
    instance (value) itself is cleaned up by the garbage collector!'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '*析构器* 在类实例的生命周期结束时被调用，并由垃圾回收器清理。它仅用于处理你的特定类可能需要的任何技术性复杂的清理工作。与构造函数类似，你很少需要，甚至从不需要自己编写这个函数。如果你确实编写了它，需要理解的是：只有在类实例（值）本身被垃圾回收器清理时，析构器才会被调用！'
- en: If any references to the class instance still exist, the finalizer won’t be
    called; furthermore, depending on the implementation of Python you’re using, the
    garbage collector might not always clean up the class instance when you’d expect,
    if at all.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仍然存在对类实例的引用，析构器将不会被调用；此外，具体取决于你使用的 Python 实现，垃圾回收器可能不会按照你预期的那样，或者根本不会清理类实例。
- en: Therefore, only use the finalizer for code directly relating to garbage-collecting
    the class instance. It should never contain code that needs to be run as part
    of any other circumstance.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只应将析构器用于与垃圾回收类实例直接相关的代码。它绝不应包含任何需要在其他情况下运行的代码。
- en: 'Here’s a rather useless finalizer that prints a message when the garbage collector
    cleans up a `SecretAgent` class instance:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当无用的析构器，当垃圾回收器清理 `SecretAgent` 类实例时，会打印一条消息：
- en: '[PRE125]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Listing 7-5: *secret_agent.py:2*'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 7-5: *secret_agent.py:2*'
- en: A finalizer always has the name `__del__` and accepts a single parameter, `self`.
    It must not return anything.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 析构器的名称总是 `__del__`，并接受一个参数 `self`。它不能返回任何内容。
- en: 'To demonstrate this finalizer, I’ll create and manually delete an instance.
    It is possible to delete a name, thereby unbinding it from its value, by using
    the `del` keyword. Given the `SecretAgent` class with that finalizer method, I
    can create and then delete a name referring to a class instance:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个析构器，我将创建并手动删除一个实例。可以通过使用 `del` 关键字删除一个名称，从而解除它与其值的绑定。给定带有该析构器方法的 `SecretAgent`
    类，我可以创建并删除一个指向类实例的名称：
- en: '[PRE126]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Listing 7-6: *secret_agent_disavow.py*'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 7-6: *secret_agent_disavow.py*'
- en: I create a new instance from the `SecretAgent` class and bind it to the name
    `weasel`. Then, I immediately delete the name by using the `del` operator. The
    name `weasel` is now undefined again. Coincidentally, because no references remain
    to the `SecretAgent` instance the name was bound to, that instance is cleaned
    up by the garbage collector, which first calls the finalizer.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 `SecretAgent` 类创建一个新实例并将其绑定到名称 `weasel`。然后，我通过使用 `del` 运算符立即删除这个名称。现在，名称
    `weasel` 已经变得未定义。巧合的是，因为不再有引用指向绑定到该名称的 `SecretAgent` 实例，该实例被垃圾回收器清理，同时首先调用析构器。
- en: 'Thus, running that code displays this output:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，运行该代码将显示以下输出：
- en: '[PRE127]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Note that `del` only deletes the name, not the value! If you have multiple names
    bound to the same value, and if you `del` one of those names, then the other names
    and their values will be unaffected. In other words, `del` will not force the
    garbage collector to delete the objects.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`del` 只删除名称，而不是值！如果你有多个名称绑定到同一个值，并且你对其中一个名称使用 `del`，那么其他名称及其值将不受影响。换句话说，`del`
    不会强制垃圾回收器删除对象。
- en: Attributes
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: All variables belonging to a class or instance are called *attributes*. Attributes
    belonging to the instance itself are called *instance attributes*, which are also
    sometimes referred to as *member variables*. Attributes belonging to the class
    itself are *class attributes*, which are also sometimes called *class variables*.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属于类或实例的变量都称为 *属性*。属于实例本身的属性称为 *实例属性*，有时也称为 *成员变量*。属于类本身的属性是 *类属性*，也有时称为 *类变量*。
- en: Many intermediate-level Python programmers don’t realize there is a significant
    difference between the two. I must admit, I spent the first few years of my Python
    development career using them utterly incorrectly!
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 许多中级 Python 程序员并没有意识到它们之间存在显著的差异。我必须承认，我在 Python 开发生涯的最初几年，曾完全错误地使用了它们！
- en: Instance Attributes
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例属性
- en: An *instance attribute* exists on the instance itself; its value is unique to
    the instance and is not available to other instances. All instance attributes
    should be declared in the class’s initializer.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例属性*存在于实例本身；它的值对于每个实例都是唯一的，且不能被其他实例访问。所有实例属性应该在类的初始化方法中声明。'
- en: 'Revisiting the `__init__()` method from [Listing 7-3](#listing7-3), you’ll
    see I have two instance attributes:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[示例 7-3](#listing7-3)中的`__init__()`方法，你会看到我有两个实例属性：
- en: '[PRE128]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Class Attributes
  id: totrans-701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类属性
- en: A *class attribute* exists on the class, instead of on an individual instance.
    In practice, this means that all related class instances effectively “share” a
    class attribute, although it would exist even without any instances.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '*类属性*存在于类中，而不是在单个实例中。实际上，这意味着所有相关的类实例都会“共享”一个类属性，尽管即使没有任何实例，它也会存在。'
- en: 'Class attributes are declared at the top of the class, outside of any methods.
    Here, I add one class attribute directly into the suite of the class:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性在类的顶部声明，位于任何方法之外。在这里，我直接将一个类属性添加到类的代码块中：
- en: '[PRE129]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Listing 7-7: *secret_agent.py:1b*'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-7: *secret_agent.py:1b*'
- en: The attribute `_codeword` belongs to the `SecretAgent` class. Typically, all
    class attributes are declared before any methods to make them easier to find,
    although this is just convention. The important part is that they are defined
    outside of any methods.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`_codeword`属于`SecretAgent`类。通常，所有类属性都会在任何方法之前声明，以便更容易找到，尽管这只是约定。重要的是，它们被定义在任何方法之外。
- en: 'The class attribute can be accessed like this:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性可以这样访问：
- en: '[PRE130]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Listing 7-8: *secret_agent_usage.py:2a*'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-8: *secret_agent_usage.py:2a*'
- en: I can access the class attribute `_codeword` directly through the class, or
    through any instances instantiated from the class. If the class attribute is rebound
    or mutated on the class itself ❶, the changes will appear in all cases. However,
    if a value is assigned to the name on an instance, it will create an instance
    attribute with the same name ❷, which shadows the class attribute on that instance,
    without affecting other instances.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过类本身访问类属性`_codeword`，或者通过任何从该类实例化的实例。如果类属性在类本身被重新绑定或修改 ❶，这些更改将在所有实例中反映。然而，如果给实例的同名属性赋值，它会创建一个实例属性
    ❷，该属性会在该实例上遮蔽类属性，但不会影响其他实例。
- en: Class attributes are particularly useful for constant values that the class’s
    methods use. I also find them more practical and maintainable than global variables
    in many cases, especially in GUI programming. For example, I often employ class
    attributes when I need to maintain a shared instance of a widget, like a window.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性特别适用于类方法使用的常量值。在许多情况下，我发现它们比全局变量更实用、更易维护，特别是在 GUI 编程中。例如，当我需要维护一个共享的小部件实例（如窗口）时，我经常使用类属性。
- en: Scope-Naming Conventions
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域命名约定
- en: If you’re coming from a language that has class scope, you may wonder why I
    haven’t mentioned it yet. Isn’t data hiding an important part of encapsulation?
    In fact, Python has no formal concept of data hiding. Instead, PEP 8 outlines
    a naming convention that indicates whether an attribute is safe to modify externally
    (public) or not (nonpublic).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自于具有类作用域的语言，你可能会想，为什么我到现在还没有提到这个问题。数据隐藏不是封装的重要部分吗？事实上，Python 并没有数据隐藏的正式概念。相反，PEP
    8 概述了一种命名约定，用来指示某个属性是否可以在外部修改（公共）或不可以（非公共）。
- en: While I talk a lot about attributes in this section, these naming conventions
    apply to methods as well.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我谈了很多关于属性的内容，但这些命名约定同样适用于方法。
- en: Nonpublic
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非公共
- en: By preceding a name with an underscore, I declare that the attribute `_secrets`
    is intended to be *nonpublic*, meaning it shouldn’t be modified (or, ideally,
    accessed) outside of the class. This is more of a social contract via style convention;
    I’m not actually hiding anything.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在名称前加上一个下划线，我声明属性`_secrets`是*非公共*的，意味着它不应在类外部被修改（或者，理想情况下，不应被访问）。这更多的是一种通过风格约定的社会契约；我实际上并没有隐藏任何东西。
- en: This may seem dangerous to many developers coming from languages with explicit
    scope, like Java, but it works out pretty well. As my pal “grym” likes to put
    it, “If you know why you shouldn’t stick a fork in a toaster, you are therefore
    qualified to stick a fork in a toaster.” In other words, if the client is going
    to disregard the underscore warning label, they probably know what they’re doing.
    (On the off-chance they don’t, they’re fully responsible for the consequences.)
    That little underscore hanging out after the dot operator is advertising “You
    really shouldn’t mess with me!”
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于许多来自具有显式作用域的语言（如Java）的开发者来说，可能看起来很危险，但实际上效果很好。正如我的朋友“grym”喜欢说的：“如果你知道为什么不应该把叉子插进烤面包机，那么你就有资格把叉子插进烤面包机。”换句话说，如果客户端打算忽视下划线警告标签，他们可能知道自己在做什么。（如果他们万一不知道，他们将为后果负责。）在点操作符后面悬挂的那个小下划线是在提醒你：“你真的不应该碰我！”
- en: Public
  id: totrans-718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公有
- en: The attribute `codename`, which does not start with an underscore, is intended
    to be *public*. It is okay for this attribute to be accessed or modified externally,
    as it won’t really affect the behavior of the class. Public attributes are preferable
    to writing a plain getter/setter pair of methods; the behavior is the same, but
    the result is cleaner, with less boilerplate.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`codename`没有以下划线开头，意味着它是*公有*的。可以从外部访问或修改此属性，因为它不会真正影响类的行为。公有属性比写简单的获取器/设置器方法对代码更友好；行为是一样的，但结果更简洁，减少了冗余代码。
- en: If an attribute needs a custom getter or setter, one approach is to define the
    attribute as nonpublic and create a public *property*, which I’ll come back to
    shortly.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个属性需要自定义的获取器或设置器，一种方法是将属性定义为非公有，并创建一个公共的*属性*，稍后我会再详细说明。
- en: Name Mangling
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称改编
- en: 'Python does offer *name mangling*, which rewrites an attribute or method name
    to prevent it from being shadowed by derived (inheriting) classes. This provides
    a sort of weak form of data hiding. It can also be useful for an added level of
    forewarning: “No, *really*, if you mess with this attribute, terrible things will
    happen!”'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: Python确实提供了*名称改编*功能，能够重写属性或方法的名称，以防止它被派生（继承）类覆盖。这提供了一种弱形式的数据隐藏。它也可以作为一种额外的预警：“不，*真的*，如果你乱改这个属性，会发生可怕的事情！”
- en: 'To mark an attribute (or method) for name mangling, precede the name with two
    underscores (`__`), like this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 要标记一个属性（或方法）进行名称改编，在名称前加上两个下划线（`__`），如：
- en: '[PRE131]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Listing 7-9: *message.py:1*'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-9: *message.py:1*'
- en: 'The `__format` attribute will be name mangled, so accessing it externally in
    the ordinary manner will not work:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`__format`属性将被名称改编，因此以普通方式从外部访问它将无法正常工作：'
- en: '[PRE132]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Listing 7-10: *message.py:2*'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-10: *message.py:2*'
- en: 'This will raise an `AttributeError` because the `msg` instance does not have
    an attribute named `__format`; the name of that attribute was mangled. Be aware
    that name mangling is *not* a true form of data hiding! It is still perfectly
    possible to access a name-mangled attribute:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引发一个`AttributeError`，因为`msg`实例没有名为`__format`的属性；该属性的名称已被改编。需要注意的是，名称改编*不是*一种真正的数据隐藏形式！仍然可以访问名称改编后的属性：
- en: '[PRE133]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Listing 7-11: *message.py:3*'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-11: *message.py:3*'
- en: 'The name-mangling pattern is predictable: an underscore, the name of the class,
    and then the name of the attribute, with its two leading underscores.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 名称改编模式是可以预测的：一个下划线，类的名称，然后是属性的名称，并带有两个前导下划线。
- en: Public, Nonpublic, or Name Mangled?
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公有、非公有或名称改编？
- en: 'When deciding whether to make an attribute public or nonpublic, I ask myself
    one question: could changing this attribute externally cause unexpected or negative
    behavior in the class? If the answer is yes, I make the attribute nonpublic by
    preceding it with an underscore. If the answer is no, I leave the attribute public.
    It is up to the coder using the class to respect the rules or suffer the consequences.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否将属性设为公有或非公有时，我会问自己一个问题：外部更改此属性是否会导致类出现意外或负面行为？如果答案是肯定的，我会通过在属性名前加下划线使其变为非公有。如果答案是否定的，我会保持属性为公有。是否遵守规则取决于使用该类的程序员，若违反规则，将自负后果。
- en: As to name mangling, in practice, I very rarely employ this pattern. I reserve
    it only for those cases where (a) I need to avoid a naming conflict in the context
    of inheritance or (b) external access of the attribute will have exceptionally
    horrific effects on the behavior of the class, and thus, an extra degree of warning
    is justified.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 关于名称改编，实际上，我很少使用这种模式。我只在以下情况保留它：（a）我需要避免继承上下文中的命名冲突，或者（b）外部访问属性会对类的行为产生异常可怕的影响，因此，额外的警告是合理的。
- en: Always remember that Python does not have private class scope. Truly secret
    data should be properly encrypted, not just concealed from your API. There are
    also no optimization benefits to private class scope, unlike in languages like
    Java, since all attribute lookups occur at runtime.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 永远记住，Python 没有私有类作用域。真正的秘密数据应该经过适当加密，而不仅仅是从你的 API 隐藏。与 Java 等语言不同，私有类作用域没有优化优势，因为所有属性查找都发生在运行时。
- en: Methods
  id: totrans-737
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'A class is nothing without its methods, which make encapsulation possible.
    There are three distinct types of methods: instance methods, class methods, and
    static methods.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类如果没有它的方法，就什么也不是，这些方法使得封装成为可能。方法有三种不同类型：实例方法、类方法和静态方法。
- en: Instance Methods
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例方法
- en: '*Instance methods* are your run-of-the-mill methods, which exist on the instance
    itself. The first parameter, conventionally named `self`, provides access to the
    instance attributes of the instance.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例方法*是常规方法，存在于实例本身上。第一个参数，通常命名为`self`，提供对实例属性的访问。'
- en: 'Here, I add an instance method to my `SecretAgent` class:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我向`SecretAgent`类添加了一个实例方法：
- en: '[PRE134]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Listing 7-12: *secret_agent.py:3*'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-12: *secret_agent.py:3*'
- en: Besides the required first parameter, the instance method accepts a second parameter,
    `secret`, which is appended to the list bound to the instance attribute `_secrets`.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 除了必需的第一个参数外，实例方法还接受第二个参数`secret`，它会附加到绑定到实例属性`_secrets`的列表中。
- en: 'I call this method on the instance, using the dot operator:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 我在实例上调用此方法，使用点运算符：
- en: '[PRE135]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Listing 7-13: *secret_agent_usage.py:2b*'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-13: *secret_agent_usage.py:2b*'
- en: The dot operator implicitly passes `mouse` to the `self` parameter, so my first
    argument, the tuple of coordinates (notice the extra set of parentheses), is passed
    to the second parameter, `secret`, on the `remember()` method.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 点运算符隐式地将`mouse`传递给`self`参数，因此我的第一个参数，即坐标元组（请注意额外的一对括号），会传递给`remember()`方法中的第二个参数`secret`。
- en: Class Methods
  id: totrans-749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类方法
- en: Like class attributes, *class methods* belong to the class, instead of to the
    instances instantiated from the class. These are useful for working with class
    attributes.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 像类属性一样，*类方法*属于类，而不是属于从类实例化的实例。这些对于处理类属性非常有用。
- en: 'Back in [Listing 7-7](#listing7-7), I defined `_codeword` as a class attribute
    so all `SecretAgent` instances would be aware of the code word; it’s something
    all agents should have in common. I need a way to inform all the agents at once
    of the new code word, so I’ll add a class method, `inform()`, which will modify
    the `_codeword` class attribute:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 7-7](#listing7-7)中，我将`_codeword`定义为类属性，以便所有`SecretAgent`实例都能了解密码；这是所有特工应有的共同点。我需要一种方法一次性通知所有特工新的密码，因此我将添加一个类方法`inform()`，它将修改`_codeword`类属性：
- en: '[PRE136]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Listing 7-14: *secret_agent.py:4*'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-14: *secret_agent.py:4*'
- en: I precede a class method with the built-in `@classmethod` decorator. A class
    method receives the class as its first argument, so the first parameter is named
    `cls`. Class attributes like `_codeword` are accessed on the class passed to `cls`.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 我在类方法前加上内置的`@classmethod`装饰器。类方法将类作为它的第一个参数，因此第一个参数命名为`cls`。像`_codeword`这样的类属性是通过传递给`cls`的类来访问的。
- en: One of the benefits of this approach is that I don’t have to worry about whether
    I’m calling `inform()` on the class or on an instance. Because the method is a
    class instance, it will always access the class attribute on the class (`cls`),
    instead of the instance (`self`), and thus avoid accidentally shadowing `_codeword`
    on a single instance (see [Listing 7-8](#listing7-8)).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个好处是，我不必担心是在类上还是在实例上调用`inform()`。因为该方法是类方法，它将始终访问类上的类属性（`cls`），而不是实例上的属性（`self`），从而避免在单个实例上意外覆盖`_codeword`（见[列表
    7-8](#listing7-8)）。
- en: I don’t plan to include a getter for this attribute. After all, secret agents
    have to keep secrets!
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 我不打算为这个属性包含一个getter。毕竟，秘密特工必须保持机密！
- en: 'To use this method, I would call something like this:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此方法，我会像这样调用：
- en: '[PRE137]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Listing 7-15: *secret_agent_usage.py:3*'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-15: *secret_agent_usage.py:3*'
- en: I can call the `inform()` class method directly on the `SecretAgent` class,
    or on any `SecretAgent` instance, such as `fox`. The changes that `inform()` makes
    to the class attribute `_codeword` appear on the class itself and all its instances.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以直接在 `SecretAgent` 类上，或者在任何 `SecretAgent` 实例（比如 `fox`）上调用 `inform()` 类方法。`inform()`
    对类属性 `_codeword` 所做的更改会出现在类本身和所有实例上。
- en: When calling the class method with the dot operator, the class is implicitly
    passed to the `cls` parameter. That parameter name is still just a convention;
    the `@classmethod` decorator is what ensures that the first argument is always
    the class, never the instance.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用点操作符调用类方法时，类会隐式地传递给 `cls` 参数。这个参数名仍然只是一个约定；`@classmethod` 装饰器确保第一个参数始终是类，而不是实例。
- en: One awesome use of class methods is to provide alternative means of initializing
    instances. For example, the built-in integer class offers `int.from_bytes()`,
    which initializes a new `int` class instance, using a `bytes` value.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法的一个很棒的用途是提供初始化实例的替代方式。例如，内建的整数类提供 `int.from_bytes()`，它使用 `bytes` 值初始化一个新的
    `int` 类实例。
- en: Static Methods
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态方法
- en: A *static method* is a regular function defined within a class, which accesses
    neither the instance attributes nor the class attributes. The only difference
    between a static method and a function is that a static method belongs to the
    class for namespace reasons.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态方法* 是一个定义在类中的普通函数，它既不访问实例属性，也不访问类属性。静态方法和普通函数的唯一区别是，静态方法属于类，这出于命名空间的考虑。'
- en: The main reason to write a static method comes up when your class offers some
    functionality that doesn’t need to access any of the class or instance attributes
    or methods. For example, you may write a static method for handling some particularly
    complicated algorithm that is critical to your class’s implementation. By including
    the static method in the class, you are indicating that the algorithm is part
    of the class’s self-contained implementation logic, even though it does not access
    any attributes or methods.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 编写静态方法的主要原因出现在你的类提供了一些功能，而这些功能不需要访问任何类或实例的属性或方法。例如，你可能会为处理某些特别复杂且对类实现至关重要的算法编写静态方法。通过将静态方法包括在类中，你表明该算法是类自包含实现逻辑的一部分，即使它不访问任何属性或方法。
- en: 'I’ll add a static method to the `SecretAgent` class, which handles one thing
    all the agents would do the same, regardless of their data—answer questions:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 我将为 `SecretAgent` 类添加一个静态方法，这个方法处理所有特工都会做的相同的事情——回答问题：
- en: '[PRE138]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Listing 7-16: *secret_agent.py:5*'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-16：*secret_agent.py:5*
- en: I precede the static method with the `@staticmethod` decorator. You’ll notice
    that I don’t need to worry about a special first parameter, since the method doesn’t
    need access to any attributes. When this method is called on a class or on an
    instance, it only prints out the message, “I know nothing.”
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 我在静态方法前加上 `@staticmethod` 装饰器。你会注意到，我不需要担心特殊的第一个参数，因为该方法不需要访问任何属性。当这个方法在类或实例上被调用时，它只会输出消息：“我什么都不知道。”
- en: Properties
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: '*Properties* constitute a special variety of instance method that allows you
    to write getters and setters that behave so it appears that you were directly
    accessing an instance attribute. Properties allow you to write a consistent interface,
    where you use the object directly through what appear to be its attributes.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性* 是一种特殊的实例方法，它允许你编写 getter 和 setter，使它们的行为看起来像是直接访问实例属性。属性让你可以编写一致的接口，通过看似是属性的方式直接使用对象。'
- en: It is preferable to use properties, instead of making the user remember whether
    to call a method or use an attribute. Using properties is also much more Pythonic
    than cluttering your class with bare getters and setters that don’t augment attribute
    access or modification.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用属性，而不是让用户记住是调用方法还是使用属性。使用属性比在类中堆砌没有增强属性访问或修改功能的纯粹 getter 和 setter 要更具 Python
    风格。
- en: Setting Up the Scenario
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置场景
- en: 'To demonstrate properties in action, I’ll expand on my `SecretAgent` class.
    Here’s the class so far. First, to set up, I’ll move it to a new file:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示属性的实际应用，我将扩展我的 `SecretAgent` 类。到目前为止，这是该类的代码。首先，为了设置，我将它移动到一个新的文件中：
- en: '[PRE139]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Listing 7-17: *secret_agent_property.py:1*'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-17：*secret_agent_property.py:1*
- en: 'Next, I will add one more class method to encrypt whatever message is passed
    to it, using an encryption system of my own devising. This method has nothing
    to do with properties per se, but I include it to make the example complete:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将添加另一个类方法来加密传入的任何消息，使用我自己设计的加密系统。这个方法与属性本身没有关系，但我把它包括进来是为了让这个例子更完整：
- en: '[PRE140]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Listing 7-18: *Using a property with no getter*'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-18: *使用没有 getter 的属性*'
- en: The `_encrypt()` class method uses the `_codeword` class attribute to perform
    a basic substitution cipher encoding on a string `message`. I use `sum()` to find
    the sum of the Unicode code points (as integers) for each character in `_codeword`.
    I pass a character (string) to the `ord()` function, which returns the Unicode
    code point as an integer. This sum of code points is bound to `code`. (The odd-looking
    loop here is actually a generator expression, which I’ll cover in Chapter 10.
    You can take it for granted here that it calls `ord()` on each character in the
    string bound to `cls._codeword`.)
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '`_encrypt()` 类方法使用 `_codeword` 类属性对字符串 `message` 执行基本的替换密码编码。我使用 `sum()` 来计算
    `_codeword` 中每个字符的 Unicode 代码点（作为整数）的总和。我将一个字符（字符串）传递给 `ord()` 函数，它返回该字符的 Unicode
    代码点作为整数。这个代码点总和被绑定到 `code` 变量上。（这里看起来有点奇怪的循环实际上是一个生成器表达式，我将在第 10 章中详细介绍。你可以理解为它会对绑定到
    `cls._codeword` 的字符串中的每个字符调用 `ord()`。）'
- en: I use `code` to offset the Unicode code point of each character in the message.
    The `chr()` function returns the character associated with the given code point.
    I pass to it the sum of the current code point and `code`, for each character
    in the message. (Once again, I’m employing a generator expression here.)
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `code` 来调整消息中每个字符的 Unicode 代码点。`chr()` 函数返回与给定代码点关联的字符。我将当前代码点与 `code` 的总和传递给它，针对消息中的每个字符。（再次强调，我在这里使用了生成器表达式。）
- en: Defining a Property
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义属性
- en: 'A *property* behaves like an attribute, but it is made up of three instance
    methods: a *getter*, a *setter*, and a *deleter*. Remember that a property appears
    to be an ordinary attribute to the user of the class. Accessing the property calls
    the getter, assigning a value to it calls the setter, and deleting the property
    with the `del` keyword calls the deleter.'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *属性* 行为类似于一个普通的属性，但它由三个实例方法组成：一个 *getter*、一个 *setter* 和一个 *deleter*。记住，对于类的用户而言，属性看起来就像是一个普通的属性。访问属性时调用
    getter，给属性赋值时调用 setter，使用 `del` 关键字删除属性时调用 deleter。
- en: Like an ordinary getter or setter method, a property might access or modify
    a nonpublic attribute, multiple attributes, or even no attributes at all. It all
    depends on what behavior you want.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 和普通的 getter 或 setter 方法一样，属性也可以访问或修改非公共属性、多个属性，甚至根本不修改任何属性。这完全取决于你希望属性具有什么样的行为。
- en: Here, I’ll define a property called `secret` for my `SecretAgent` class, which
    will serve as the getter, setter, and deleter for my `_secrets` instance attribute.
    This approach will allow me to add logic, such as having the setter encrypt the
    assigned data before storing it in the `_secrets` attribute.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将为我的 `SecretAgent` 类定义一个名为 `secret` 的属性，它将作为我的 `_secrets` 实例属性的 getter、setter
    和 deleter。这样做可以让我添加一些逻辑，比如在将数据存储到 `_secrets` 属性之前让 setter 对数据进行加密。
- en: Before defining the property itself, I need to define the three functions that
    will make up the property. Technically, I can call them whatever I like, but the
    convention is to name them `getx`, `setx`, or `delx`, where `x` is the name of
    the property. I’m also making these nonpublic methods, since I want the client
    to use the property directly.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义属性本身之前，我需要定义三个将组成该属性的函数。从技术上讲，我可以随意命名它们，但惯例是将它们命名为 `getx`、`setx` 或 `delx`，其中
    `x` 是属性的名称。我还将这些方法设置为非公共方法，因为我希望客户端直接使用该属性。
- en: 'First, the getter:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，getter：
- en: '[PRE141]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Listing 7-19: *secret_agent_property.py:3*'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-19: *secret_agent_property.py:3*'
- en: The getter, `_getsecret()`, accepts no parameters and should return the value
    of the property. In this example, I want the getter to return the last item stored
    in the list bound to the instance attribute `self._secrets`, or if the list is
    empty, to return `None`.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: getter `_getsecret()` 不接受任何参数，应该返回属性的值。在这个例子中，我希望 getter 返回绑定到实例属性 `self._secrets`
    的列表中的最后一个项目，或者如果列表为空，则返回 `None`。
- en: 'Next, the setter:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，setter：
- en: '[PRE142]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Listing 7-20: *secret_agent_property.py:4*'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-20: *secret_agent_property.py:4*'
- en: The setter, `_setsecret()`, accepts a single parameter, which receives the value
    being assigned to the property in the call (see [Listing 7-23](#listing7-23)).
    In this case, I assume this is some sort of string, which I run through the static
    method `_encode()` I defined earlier and then store in the list `self._secrets`.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器`_setsecret()`接受一个参数，该参数接收在调用中赋给属性的值（见[列表 7-23](#listing7-23)）。在这种情况下，我假设它是某种字符串，我将其通过我之前定义的静态方法`_encode()`处理，然后存储在列表`self._secrets`中。
- en: 'Finally, here’s the deleter:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这就是deleter：
- en: '[PRE143]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Listing 7-21: *secret_agent_property.py:5*'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-21: *secret_agent_property.py:5*'
- en: The *deleter*, `_delsecret()`, accepts no parameters and returns no value. This
    method is called when the property is deleted, either in the background, by the
    garbage collector, or explicitly, with `del secret`. In this example, when the
    property is deleted, I want the entire list of secrets to be cleared.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '*deleter*`_delsecret()`不接受任何参数，也不返回任何值。当属性被删除时，无论是后台删除还是通过垃圾回收器，或是通过`del secret`显式删除时，这个方法会被调用。在这个例子中，当属性被删除时，我希望清空所有秘密列表。'
- en: You actually don’t need to define a deleter if you have no need for special
    behavior when the decorator is deleted. Consider what you want to happen if `del`
    is called on your decorator, such as when you are deleting an associated attribute
    that the property controls; if you can’t think of anything, skip writing the deleter.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要在装饰器被删除时进行特殊行为，你实际上不需要定义deleter。考虑一下当`del`在你的装饰器上被调用时会发生什么，比如当你删除属性时；如果你想不出任何事情，就跳过编写deleter。
- en: 'Finally, I define the property itself:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我定义了属性本身：
- en: '[PRE144]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Listing 7-22: *secret_agent_property.py:6a*'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-22: *secret_agent_property.py:6a*'
- en: This is defined on the class itself, outside of the `__init__()` method and
    after the functions that make it up. I pass the three methods to the `fget`, `fset`,
    and `fdel` keyword arguments, respectively (although you can also pass them as
    positional arguments, in that same order). I bind the property to the name `secret`,
    which becomes the property name.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义在类本身上，位于`__init__()`方法之外，并且在构成该类的函数之后。我将三个方法分别传递给`fget`、`fset`和`fdel`关键字参数（尽管你也可以按位置参数传递它们，顺序相同）。我将属性绑定到`secret`这个名称上，它就成了属性名。
- en: 'The property can now be used as if it were an instance attribute:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以像使用实例属性一样使用这个属性：
- en: '[PRE145]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Listing 7-23: *secret_agent_property.py:7a*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-23: *secret_agent_property.py:7a*'
- en: Every time I try to retrieve the value of the property, the getter is called.
    Meanwhile, assigning a value to the property calls the setter. There’s no need
    to remember and explicitly call dedicated getter or setter methods; I treat the
    property like an attribute.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我尝试获取属性的值时，getter会被调用。与此同时，赋值给属性时会调用setter。无需记住并显式调用专用的getter或setter方法；我像对待属性一样对待该属性。
- en: You’ll recall that the deleter for `secrets` clears the contents of the `_secrets`
    list. Just before deleting the property, the list contains two secrets. After
    deleting, the list is empty.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，`secrets`的deleter清空了`_secrets`列表的内容。在删除属性之前，列表包含两个秘密。删除后，列表为空。
- en: It is not necessary to define all three parts of the property. For example,
    I don’t want the `secret` property to even have a getter, so I can remove `_getsecret()`
    from my class code. Secret agents shouldn’t share their secrets, after all.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 并不需要定义属性的全部三个部分。例如，我不希望`secret`属性甚至有getter，因此可以将`_getsecret()`从我的类代码中移除。毕竟，特工们不应该分享他们的秘密。
- en: '[PRE146]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Listing 7-24: A secret property with no getter'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-24: 没有getter的秘密属性'
- en: Because I don’t pass an argument to `fget`, the default value of `None` is used
    instead ❶. This property has a setter and a deleter, but no getter.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我没有传递参数给`fget`，所以会使用默认值`None` ❶。这个属性有setter和deleter，但没有getter。
- en: 'As a result, I can assign to `secret`, but I can’t access the value:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我可以赋值给`secret`，但不能访问它的值：
- en: '[PRE147]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Listing 7-25: *Using a property with no getter*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-25: *使用没有getter的属性*'
- en: Assigning values to `mouse.secret` works as before, since that calls the setter.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 向`mouse.secret`赋值的方式和之前一样，因为那样会调用setter。
- en: 'However, attempting to access the value throws an `AttributeError`. I could
    instead have written a getter for secrets that always returned `None`, but the
    client would have to remember that it returned this useless value. Recall The
    Zen of Python:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试访问值时会抛出`AttributeError`。我本可以为`secrets`写一个始终返回`None`的getter，但客户端就必须记住它返回的是这个无用的值。回想一下《Python之禅》：
- en: Errors should never pass silently.
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误不应该悄无声息地通过。
- en: ''
  id: totrans-819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  id: totrans-820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非被明确地静默处理。
- en: If a particular usage is not desired, especially when it comes to designing
    a class or interface, the usage should *explicitly fail*.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某种用法不需要，尤其是在设计类或接口时，应该*显式失败*。
- en: Property with Decorators
  id: totrans-822
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用装饰器定义属性
- en: Creating a property is easy enough, but the approach to implementing it that
    I’ve shown thus far doesn’t really feel very Pythonic, because I have to rely
    on my method names to remind me that they’re part of a property. Thankfully, there’s
    another way.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个属性足够简单，但到目前为止，我展示的实现方法并不算非常符合Python的风格，因为我必须依赖方法名来提醒自己它们是属性的一部分。幸运的是，还有另一种方法。
- en: 'Python offers a cleaner approach to defining properties: with decorators. There
    are two approaches to this technique.'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一种更简洁的定义属性的方法：使用装饰器。这个技术有两种方法。
- en: 'Approach 1: property() and Decorators'
  id: totrans-825
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法1：property()和装饰器
- en: The first approach is to still employ the `property()` function but use decorators
    to denote the associated methods. The chief benefit of this approach is the added
    readability, and it is mainly used when the getter will be omitted. I can use
    the name of the property as the method name and rely on the decorator to clarify
    its role.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是仍然使用`property()`函数，但通过装饰器来标注相关的方法。这种方法的主要优点是提高了可读性，通常在省略getter时使用。我可以使用属性的名称作为方法名，并依赖装饰器来明确其作用。
- en: 'Here’s my rewritten code for the `secret` property, using this approach:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我使用这种方法重写的`secret`属性代码：
- en: '[PRE148]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Listing 7-26: *secret_agent_property.py:3b*'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7-26：*secret_agent_property.py:3b*
- en: 'In this approach, I define `secret` as a property before writing its methods.
    I pass no arguments to `property()`, so all three functions default to `None`.
    Next, I add the getter:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我在编写方法之前先定义`secret`为一个属性。我没有向`property()`传递任何参数，因此三个函数默认都为`None`。接下来，我添加getter：
- en: '[PRE149]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Listing 7-27: *secret_agent_property.py:4b*'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7-27：*secret_agent_property.py:4b*
- en: My getter method now must have the same name as the property, `secret`. If it
    doesn’t, it will fail with an `AttributeError` when the getter is first called,
    rather than when the class is created. The method is preceded by the decorator
    `@secret.getter`. This designates it as the getter for the property, just as if
    I had passed it to `property(fget=)`.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我的getter方法必须与属性名相同，`secret`。如果不相同，当getter第一次被调用时，它会抛出`AttributeError`，而不是在类创建时。方法前面加上了装饰器`@secret.getter`，这将它指定为属性的getter，就像我将它传递给`property(fget=)`一样。
- en: 'Here’s the setter:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 这是setter：
- en: '[PRE150]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Listing 7-28: *secret_agent_property.py:5b*'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7-28：*secret_agent_property.py:5b*
- en: Similarly, the setter method must share its name with the property it relates
    to, and it is preceded by the decorator `@secret.setter`.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，setter方法必须与它关联的属性同名，并且前面加上装饰器`@secret.setter`。
- en: 'Finally, the deleter:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是deleter：
- en: '[PRE151]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Listing 7-29: *secret_agent_property.py:6b*'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7-29：*secret_agent_property.py:6b*
- en: Similar to the getter and setter, the deleter is preceded by the decorator `@secret.deleter`.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 与getter和setter类似，deleter前面加上了装饰器`@secret.deleter`。
- en: This version works as is, but there is an even better technique.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本可以直接使用，但还有一种更好的技术。
- en: 'Approach 2: Decorators Without property()'
  id: totrans-843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法2：没有property()的装饰器
- en: The second approach to declaring a property with decorators is even shorter,
    and it is the most commonly used. This approach is preferred when defining a property
    that has a getter.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器声明属性的第二种方法更简洁，而且是最常用的。定义有getter的属性时，通常选择这种方法。
- en: 'If you have defined a getter, you don’t have to explicitly create and assign
    a `property()`. Instead, the decorator `@property` can be applied to the getter:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经定义了getter，就不需要显式创建并赋值`property()`。相反，可以将装饰器`@property`应用于getter：
- en: '[PRE152]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: I precede the getter function with the decorator `@property`, instead of `@secret.getter`,
    which creates a property with the same name as the method. Since this defines
    the property `secret`, I don’t need `secret = property()` anywhere in my code.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 我在getter函数前面加上了装饰器`@property`，而不是`@secret.getter`，这会创建一个与方法同名的属性。由于这定义了属性`secret`，所以在代码中不需要再写`secret
    = property()`。
- en: Bear in mind, this shortcut only works with the getter method. The setter and
    deleter must be defined in the same manner as before.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个快捷方式只适用于getter方法。setter和deleter必须像之前一样定义。
- en: 'As before, I can omit any of the three methods if their behavior is not desired.
    For example, if I don’t want `secret` to be readable, I omit the getter, so my
    full property code looks like this:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，如果某些方法的行为不需要，可以省略它们。例如，如果我不希望`secret`是可读的，我就省略getter，那么我的完整属性代码如下：
- en: '[PRE153]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Because I don’t have a getter, I must explicitly declare my property up front
    ❶. In this version, assignment and deletion of `secret` works as before, but accessing
    the value raises an `AttributeError`.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我没有 getter，所以必须明确声明我的属性❶。在这个版本中，`secret` 的赋值和删除像以前一样正常工作，但访问该值时会引发 `AttributeError`。
- en: When Not to Use Properties
  id: totrans-852
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时不使用属性
- en: There’s some debate about when to use properties, versus traditional getter
    and setter methods. One of the chief drawbacks of properties is that they conceal
    that some calculation or processing is being performed upon assignment, which
    the client might not expect. This especially becomes a problem if this processing
    is particularly long or complicated, such that a client may need to run it concurrently
    with `async` or threads (see Chapters 16 and 17); you cannot run an assignment
    concurrently with the same ease as running a method concurrently.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 关于何时使用属性与传统的 getter 和 setter 方法之间，存在一些争论。属性的主要缺点之一是它们隐藏了在赋值时可能会进行某些计算或处理，而客户端可能没有预料到。如果这种处理特别长或者复杂，成为一个问题，尤其是当客户端需要将其与
    `async` 或线程并行运行时（见第 16 章和第 17 章）；你无法像并行运行方法一样轻松地并行运行赋值。
- en: You must also consider the expected behavior of an assignment. When a value
    is directly assigned to an attribute, you would typically expect the same value
    to be retrievable *from* that attribute. In reality, depending on how you wrote
    your properties, the value might be transformed when assigned or accessed. You’ll
    need to take this client expectation into consideration when designing your class.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须考虑赋值的预期行为。当一个值被直接赋给一个属性时，通常期望可以从该属性中检索到相同的值。然而，实际上，根据你编写属性的方式，赋值或访问时该值可能会发生变化。在设计你的类时，你需要考虑到这种客户端的预期。
- en: Some camps believe properties should only be used as a way of deprecating attributes
    that used to be public or that have been removed entirely. Others, like myself,
    find properties useful as replacements for otherwise relatively simplistic getters
    and setters that still involve more logic than plain assignment and access.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为属性应该只作为淘汰曾经是公共属性或者已完全移除的属性的一种方式。而像我这样的人，认为属性作为替代那些尽管涉及更多逻辑但依然相对简单的 getter
    和 setter 来处理平凡的赋值和访问时，仍然是有用的。
- en: In any case, properties are some of those cool features of Python that are all
    too easy to misuse or misapply. Carefully consider the implications of properties,
    public attributes, or methods in your specific case. Take the occasion to consult
    the advice of other experienced Python developers, such as in the Libera.Chat
    IRC `#python` channel. (If you want to debate the most Pythonic general position
    on properties, though, bring a helmet.)
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，属性是 Python 中一些非常酷的功能，它们非常容易被误用或滥用。在你的具体案例中，仔细考虑属性、公共属性或方法的含义。利用这个机会参考其他经验丰富的
    Python 开发者的建议，例如在 Libera.Chat IRC `#python` 频道。（不过，如果你想辩论关于属性的最 Pythonic 的通用立场，记得带上头盔。）
- en: Special Methods
  id: totrans-857
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊方法
- en: Special methods are my favorite part of Python object-oriented programming.
    I’m trembling a little with excitement right now (or maybe I had too much coffee).
    *Special methods*, sometimes called *magic methods*, allow you to add support
    to your classes for virtually any Python operator or built-in command!
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法是我最喜欢的 Python 面向对象编程部分。我现在有点激动（或者是我喝了太多咖啡）。*特殊方法*，有时称为*魔法方法*，允许你为几乎所有的 Python
    操作符或内置命令为你的类添加支持！
- en: 'Special methods are also colloquially known as *dunder methods*—which is short
    for “***d***ouble ***under***score”—because they begin and end with two underscore
    characters (`__`). You’ve already seen three examples of special methods: `__init__()`,
    `__new__()`, and `__del__()`. The Python language defines about a hundred special
    methods, most of which are documented at [https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html).
    I’ll cover a number of the most common ones here. In future chapters, I’ll discuss
    other special methods as they become relevant. I also list all the special methods
    in Python in Appendix A.'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法也通常被称为 *dunder 方法*，即“***d***ouble ***under***score”的缩写——因为它们以两个下划线字符（`__`）开始和结束。你已经看到了三个特殊方法的例子：`__init__()`、`__new__()`
    和 `__del__()`。Python 语言定义了大约一百个特殊方法，其中大多数在 [https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html)
    上有文档。我将在这里介绍一些最常见的特殊方法。在未来的章节中，我会在它们变得相关时讨论其他特殊方法。我还在附录 A 中列出了 Python 中的所有特殊方法。
- en: Scenario Setup
  id: totrans-860
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景设置
- en: 'For the examples in this section, I’ll use a new class, `GlobalCoordinates`,
    which will store a global coordinate as latitude and longitude. This class is
    defined as follows:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的示例中，我将使用一个新的类`GlobalCoordinates`，该类将存储作为纬度和经度的全球坐标。这个类定义如下：
- en: '[PRE154]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Listing 7-30: *global_coordinates.py:1*'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-30：*global_coordinates.py:1*
- en: You can probably work out what’s going on here, based on the knowledge you have
    so far. The class `GlobalCoordinates` converts and stores a latitude and longitude
    as tuples of degrees, minutes, seconds, and a string literal representing a cardinal
    direction.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你目前的知识，你大概可以理解这里发生了什么。`GlobalCoordinates`类将纬度和经度转换并存储为度、分、秒的元组，以及一个表示方位的字符串文字。
- en: I chose to create this particular class because its data lends itself well to
    a healthy subset of the special methods I’ll cover.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择创建这个特定的类，因为它的数据非常适合我将要介绍的特殊方法的一个健康子集。
- en: Conversion Methods
  id: totrans-866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换方法
- en: There are many ways to represent the same data, and most clients will expect
    to be able to convert an object containing data to any Python primitive type that
    makes sense. For example, global coordinates could be expressed as strings or
    hashes. You should carefully consider what data types your class should support
    conversion to. Here, I cover some special methods for data conversions.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方式可以表示相同的数据，大多数客户端将期望能够将包含数据的对象转换为任何合适的Python原生类型。例如，全球坐标可以表示为字符串或哈希值。你应该仔细考虑你的类应该支持哪些数据类型的转换。在这里，我介绍了一些数据转换的特殊方法。
- en: 'Canonical String Representation: __repr__()'
  id: totrans-868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规范字符串表示：__repr__()
- en: When writing a class, it is considered good practice to define, at minimum,
    the `__repr__()` instance method, which returns the *canonical string representation*
    of the object. This string representation should ideally contain all the data
    necessary to create another class instance with the same contents.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写类时，通常的好做法是至少定义`__repr__()`实例方法，该方法返回对象的*规范字符串表示*。理想情况下，这个字符串表示应该包含所有必要的数据，以便使用相同的内容创建另一个类实例。
- en: 'If I don’t define a `__repr__()` instance method for `GlobalCoordinates`, Python
    falls back on its default version for objects, which is pretty uselessly underwhelming.
    I’ll create an instance of `GlobalCoordinates` and print this default representation
    via `repr()`:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我没有为`GlobalCoordinates`定义`__repr__()`实例方法，Python将使用其默认的对象版本，这个版本是相当无用的。我要创建一个`GlobalCoordinates`实例，并通过`repr()`打印出这个默认表示：
- en: '[PRE155]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Listing 7-31: *global_coordinates_usage.py:1*'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-31：*global_coordinates_usage.py:1*
- en: 'Running that prints out the following canonical string representation:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该代码将打印出以下规范字符串表示：
- en: '[PRE156]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Not good for much, is it? Instead, I’ll define my own `__repr__()` instance
    method for the class:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太有用，对吧？于是，我将为这个类定义我自己的`__repr__()`实例方法：
- en: '[PRE157]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Listing 7-32: *global_coordinates.py:2*'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-32：*global_coordinates.py:2*
- en: 'I return a string containing all the information needed to recreate the instance:
    the class name, the latitude, and the longitude.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 我返回一个包含所有必要信息的字符串，以便重新创建该实例：类名、纬度和经度。
- en: 'Rerunning the code in [Listing 7-31](#listing7-31) now produces more useful
    information:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行[列表 7-31](#listing7-31)中的代码，现在产生了更有用的信息：
- en: '[PRE158]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Human-Readable String Representation: __str__()'
  id: totrans-881
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 人类可读的字符串表示：__str__()
- en: The `__str__()` special method has a similar purpose to `__repr__()`, except
    that it’s meant to be human-readable, as opposed to the more technically inclined
    canonical representation, which is more useful for debugging.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '`__str__()`特殊方法的目的与`__repr__()`类似，唯一的区别是它是为了人类可读的，而`__repr__()`则是更具技术性、适合调试的规范表示。'
- en: If you don’t define `__str__()`, the `__repr__()` function will be used instead,
    but that wouldn’t be desirable in this example. The user should only see the pretty
    coordinates!
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有定义`__str__()`，那么会使用`__repr__()`函数，但在这个示例中那并不理想。用户应该只看到漂亮的坐标！
- en: 'Here’s my `__str__()` instance method for `GlobalCoordinates`:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的`__str__()`实例方法，适用于`GlobalCoordinates`：
- en: '[PRE159]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Listing 7-33: *global_coordinates.py:3*'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-33：*global_coordinates.py:3*
- en: Unlike with `__repr__()`, I omit all that boring technical information and focus
    on composing and returning a string representation a user might want to see.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 与`__repr__()`不同，我省略了所有那些无聊的技术信息，专注于编写并返回一个用户可能想要看到的字符串表示。
- en: 'This method is called when an instance of the class is passed to `str()`, although
    passing the instance directly to `print()` or as an expression in a formatted
    string will also invoke `__str__()`. For example:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Listing 7-34: *global_coordinates_usage.py:2*'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Lovely and readable!
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: 'Unique Identifier (Hash): __hash__()'
  id: totrans-894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__hash__()` method typically returns a *hash value*, which is an integer
    that is unique to the data within the class instance. This allows you to use instances
    of the class in certain collections, such as keys in a dictionary or values in
    a set (see Chapter 9). It’s often helpful to write this method yourself, as the
    default behavior results in every class instance having a unique hash value, even
    if two instances contain the exact same data.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: The `__hash__()` method should only depend on values that won’t change for the
    life of the instance! Several collections rely on these hash values *never changing*,
    but the value of a mutable object might change.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my `__hash__()` function for `GlobalCoordinates`:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Listing 7-35: *global_coordinates.py:4*'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: I’ve taken the most common approach, which is to create a tuple containing all
    the important instance attributes and then to call `hash()` on the tuple, which
    returns the hash value of whatever is passed to it. I then return that hash value.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: Additional Conversion Special Methods
  id: totrans-901
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python has special methods for converting the data in the instance to other
    forms. It is up to you to decide which of these you will define on your class:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '`__bool__()` should return `True` or `False`. If this isn’t defined, the automatic
    conversion to a boolean value will check whether `__len__()` returns a nonzero
    value (see Chapter 9); otherwise, `True` will always be used.'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__bytes__()` should return a `bytes` object (see Chapter 12).'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ceil__()` should return an `int` numeric value, usually resulting from rounding
    up a `float` value to the nearest integer.'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__complex__()` should return a `complex` numeric value.'
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__float__()` should return a `float` numeric value.'
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__floor__()` should return an `int` numeric value, usually resulting from
    rounding down a `float` numeric value to the nearest integer.'
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__format__()` should accept a string representing the format specification
    (see Chapter 3) and return a string representation of the instance, with the specification
    applied. How exactly you apply the specification is up to you.'
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__index__()` should return the same value as `__int__()`, which must also
    be defined if you write this method. The presence of this method indicates that
    the class should be considered a type of integer; you don’t have to throw away
    any data to get the integer value (lossless conversion).'
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__int__()` should return an `int` numeric value. You may simply have this
    function call `__ceil__()`, `__floor__()`, `__round__()`, or `__trunc__()`.'
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__round__()` should return an `int` numeric value, usually resulting from
    rounding a `float` numeric value up or down.'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__trunc__()` should return an `int` numeric value, usually resulting from
    dropping the non-whole (decimal) part of a `float` numeric value.'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You only need to define the special methods that make sense for your class.
    In my case, *none* of these additional conversion methods are particularly suitable
    for a pair of global coordinates.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Methods
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python has six comparison special methods that correspond to the six comparison
    operators in Python: `==`, `!=`, `<`, `>`, `<=`, and `>=`. Each one conventionally
    returns a boolean value.'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: If one of these special methods is called, but the method isn’t defined, the
    class instance will return the special value `NotImplemented` to alert Python
    that the comparison didn’t happen. This allows the language to decide the best
    response. In the case of comparisons with built-in types, `NotImplemented` will
    be coerced to the boolean value `False`, so as to not break algorithms that rely
    on those functions. In most other situations, a `TypeError` will be raised.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: 'Equals: __eq__()'
  id: totrans-918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `__eq__()` special method is called by the equals (`==`) operator. I’ll
    define this method for my `GlobalCoordinates` class:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Listing 7-36: *global_coordinates.py:5*'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: 'All comparison special methods accept two parameters: `self` and `other`. These
    represent the operands on the left and right of the operator, so `a == b` would
    call `a.__eq__(b)`.'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: In the ongoing example, it would only make sense to compare two `GlobalCoordinates`
    class instances to one another. Comparing a `GlobalCoordinates` instance directly
    to an integer or a float wouldn’t be logical. Thus, this is one of those rare
    scenarios where type matters. I use `isinstance()` to ensure `other` is an instance
    of the `GlobalCoordinates` class (or a subclass thereof) ❶. If it is, I compare
    the instance attributes that constitute the latitude and longitude of one `GlobalCoordinates`
    instance to the same attributes of the other instance. I return `True` if they
    all match.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: However, if `other` is of a different type, the comparison doesn’t happen, so
    I return the special value `NotImplemented` ❶.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: 'Not Equals: __ne__()'
  id: totrans-925
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__ne__()` special method corresponds to the not-equals (`!=`) operator.
    If undefined, a call to `__ne__()` *delegates* to `__eq__()`, just returning the
    opposite value that `__eq__()` does. If this is what you’re expecting, there’s
    no need to define `__ne__()`.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: However, if there’s more complex logic to your not-equals comparison, it might
    make sense to define it.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: 'Less Than and Greater Than: __lt__() and __gt__()'
  id: totrans-928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The special methods `__lt__()` and `__gt__()` correspond to the less-than (`<`)
    and greater-than (`>`) operators, respectively. These two special methods are
    *reflections* of one another, meaning one operator in the pair can be substituted
    for the other. The expression `a < b` calls `a.__lt__(b)`, but if that returns
    ``NotImplemented, Python automatically flips the logic and calls `b.__gt__(a)`.
    Thus, if you’re only comparing instances of the same class, you can often get
    away with defining just one of the two special methods: usually, `__lt__()`. The
    same is true of `__le__()` and `__ge__()`, which correspond to less-than-or-equal-to
    (`<=`) and greater-than-or-equal-to (`>=`).``'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法`__lt__()`和`__gt__()`分别对应小于（`<`）和大于（`>`）运算符。这两个特殊方法是彼此的*反射*，意味着一对运算符中的一个可以替换为另一个。表达式`a
    < b`调用`a.__lt__(b)`，但是如果返回`NotImplemented`，Python会自动翻转逻辑并调用`b.__gt__(a)`。因此，如果你只比较同一类的实例，通常只需要定义其中一个特殊方法：通常是`__lt__()`。`__le__()`和`__ge__()`的情况也是如此，它们分别对应小于或等于（`<=`）和大于或等于（`>=`）。
- en: '[PRE164]  def __sub__(self, other):         if not isinstance(other, GlobalCoordinates):             return
    NotImplemented          lat_diff = self.latitude - other.latitude         lon_diff
    = self.longitude - other.longitude         return (lat_diff, lon_diff) [PRE165]  def
    __invert__(self):         return GlobalCoordinates(             latitude=self.degrees_from_decimal(-self.latitude,
    lat=True),             longitude=self.degrees_from_decimal(-self.longitude, lat=False)         )
    [PRE166]  def __call__(self, ❶ other):         EARTH_RADIUS_KM = 6371          distance_lat
    = math.radians(other.latitude - self.latitude)         distance_lon = math.radians(other.longitude
    - self.longitude)         lat = math.radians(self.latitude)         lon = math.radians(self.longitude)         a
    = (             math.sin(distance_lat / 2)             * math.sin(distance_lat
    / 2)             + math.sin(distance_lon)             * math.sin(distance_lon
    / 2)             * math.cos(lat)             * math.cos(lon)         )         c
    = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))        ❷ return c * EARTH_RADIUS_KM
    [PRE167] nostarch = GlobalCoordinates(latitude=(37, 46, 32.6, "N"),                              longitude=(122,
    24, 39.4, "W"))  psf = GlobalCoordinates(latitude=(45, 27, 7.7, "N"),                         longitude=(122,
    47, 30.2 "W"))  distance = nostarch(psf) print(distance)  # 852.6857266443297
    [PRE168] class CoffeeOrder:      def __init__(self, recipe, to_go=False):         self.recipe
    = recipe         self.to_go = to_go      def brew(self):         vessel = "in
    a paper cup" if self.to_go else "in a mug"         print("Brewing", *self.recipe.parts,
    vessel)   class CoffeeRecipe:      def __init__(self, parts):         self.parts
    = parts   special = CoffeeRecipe(["double-shot", "grande", "no-whip", "mocha"])
    order = CoffeeOrder(special, to_go=False) order.brew()  # prints "Brewing double-shot
    grande no-whip mocha in a mug" [PRE169] import functools ❶ def auto_order(to_go):     def
    decorator(cls):         @functools.wraps(cls)         def wrapper(*args, **kwargs):          ❷
    recipe = cls(*args, **kwargs)          ❸ return (CoffeeOrder(recipe, to_go), recipe)         return
    wrapper   ❹ return decorator [PRE170] @auto_order(to_go=True) class CoffeeShackRecipe(CoffeeRecipe):     pass   order,
    recipe = CoffeeShackRecipe(["tall", "decaf", "cappuccino"]) order.brew()  # prints
    "Brewing tall decaf cappuccino in a paper cup" [PRE171] class Pizza:      def
    __init__(self, topping, second_topping=None):         self.first = topping         self.second
    = second_topping  order = Pizza("pepperoni", "mushrooms")  match order:     case
    Pizza(first=''pepperoni'', second=''mushroom''):         print("ANSI standard
    pizza")     case Pizza(first=''pineapple''):         print("Is this even pizza?")
    [PRE172] # `--snip--`  match order:   # `--snip--`     case Pizza(first=''pineapple''):         print("Is
    this even pizza?")  **case Pizza(first=first, second=''cheese''):**  **print(f"Very
    cheesy pizza with {first}.")** [PRE173] # `--snip--`  match order:   # `--snip--`  `case
    Pizza(first=first, second=''cheese''):`  `print(f"Very cheesy pizza with {first}.")`  **case
    Pizza(first=first, second=second):**  **print(f"Pizza with {first} and {second}.")**
    [PRE174] class Point:     def __init__(self, x, y, z):         self.x_pos = x         self.y_pos
    = y         self.z_pos = z   point = Point(0, 100, 0)  match point:     case Point(x_pos=0,
    y_pos=0, z_pos=0):         print("You are here.")     case Point(x_pos=0, y_pos=_,
    z_pos=0):         print("Look up!") [PRE175] class Point:  **__match_args__ =
    (''x_pos'', ''y_pos'', ''z_pos'')**      def __init__(self, x, y, z):         self.x_pos
    = x         self.y_pos = y         self.z_pos = z   point = Point(0, 123, 0)  match
    point:     case Point(**0, 0, 0**):         print("You are here.")     case Point(**0,
    _, 0**):         print("Look up!") [PRE176] thing.action()  # this can mutate
    attributes in thing [PRE177] action(thing)  # should not modify thing; returns
    new value or object [PRE178]`  [PRE179] import random   def generate_puzzle(low=1,
    high=100):     print(f"I''m thinking of a number between {low} and {high}...")     return
    random.randint(low, high) [PRE180] def make_guess(target):     guess = int(input("Guess:
    "))      if guess == target:         return True      if guess < target:         print("Too
    low.")     elif guess > target:         print("Too high.")     return False [PRE181]
    def play(tries=8):     target = generate_puzzle()     while tries > 0:         if
    make_guess(target):             print("You win!")             return   tries -=
    1         print(f"{tries} tries left.")      print(f"Game over! The answer was
    {target}.") [PRE182] if __name__ == ''__main__'':     play() [PRE183] I''m thinking
    of a number between 1 and 100... Guess: 50 Too low. 7 tries left. Guess: 75 Too
    low. 6 tries left. Guess: 90 Too high. 5 tries left. Guess: 87 You win! [PRE184]
    I''m thinking of a number between 1 and 100... Guess: Fifty Traceback (most recent
    call last):   File "./number_guess.py", line 35, in <module>     play()   File
    "./number_guess.py", line 25, in play     if make_guess(target):  File "./number_guess.py",
    line 10, in make_guess     guess = int(input("Guess: ")) ValueError: invalid literal
    for int() with base 10: ''Fifty'' [PRE185] ValueError: invalid literal for int()
    with base 10: ''Fifty'' [PRE186]  File "./number_guess.py", line 10, in make_guess     guess
    = int(input("Guess: ")) [PRE187]  File "./number_guess.py", line 25, in play     if
    make_guess(target): [PRE188]  File "./number_guess.py", line 35, in <module>     play()
    [PRE189] Traceback (most recent call last): [PRE190] def make_guess(target):     **guess
    = None**     **while guess is None:**         **try:**             guess = int(input("Guess:
    "))         **except ValueError:**             **print("Enter an integer.")**      if
    guess == target:         return True      if guess < target:         print("Too
    low.")     elif guess > target:         print("Too high.")     return False [PRE191]
    def make_guess(target):     guess = None     while guess is None:         guess
    = input()         **if guess.isdigit():**             guess = int(guess)         **else:**             print("Enter
    an integer.")             guess = None      if guess == target:         return
    True      if guess < target:         print("Too low.")     elif guess > target:         print("Too
    high.")     return False [PRE192] class AverageCalculator:      def __init__(self):         self.total
    = 0         self.count = 0      def __call__(self, *values):         if values:             for
    value in values:                 self.total += float(value)                 self.count
    += 1         return self.total / self.count [PRE193] average = AverageCalculator()
    values = input("Enter scores, separated by spaces:\n    ").split() try:     print(f"Average
    is {average(*values)}") except ❶ ZeroDivisionError:     print("ERROR: No values
    provided.") except ( ❷ ValueError, ❸ UnicodeError):     print(f"ERROR: All inputs
    should be numeric.") [PRE194] try:     some_scary_function() except:     print("An
    error occurred. Moving on!") [PRE195] def greet():     name = input("What''s your
    name? ")     print(f"Hello, {name}.")   while True:     try:         greet()         break     except:         print("Error
    caught") [PRE196] What''s your name? ^CError caught What''s your name? ^CError
    caught What''s your name? ^CError caught What''s your name?  [PRE197] def greet():     name
    = input("What''s your name? ")     print(f"Hello, {name}.")   while True:     try:         greet()         break  **except
    Exception:**         print("Error caught") [PRE198] def average(number_string):     total
    = 0     skip = 0     values = 0     for n in number_string.split():         values
    += 1       ❶ try:             total += float(n)       ❷ except ValueError:             skip
    += 1 [PRE199]  ❸ if skip == values:         raise ValueError("No valid numbers
    provided.")     elif skip:         print(f"<!> Skipped {skip} invalid values.")      return
    total / values [PRE200] while True:     line = input("Enter numbers (space delimited):\n    ")     avg
    = average(line)     print(avg) [PRE201] Enter numbers (space delimited):     4
    5 6 7  5.5 [PRE202] Enter numbers (space delimited):     four five 6 7 <!> Skipped
    2 invalid values. 3.25 [PRE203] Enter numbers (space delimited):     four five
    six seven Traceback (most recent call last):   File "./raiseexception.py", line
    25, in <module>     avg = average(line)   File "./raiseexception.py", line 16,
    in average     raise ValueError("No valid numbers provided.") ValueError: No valid
    numbers provided. [PRE204] while True:     **try:**         line = input("Enter
    numbers (space delimited):\n    ")         avg = average(line)  print(avg)     **except
    ValueError:**         **print("No valid numbers provided.")** [PRE205] Enter numbers
    (space delimited):     four five six No valid numbers provided. Enter numbers
    (space delimited):     4 5 6 5.0 [PRE206] friend_emails = {     "Anne": "anne@example.com",     "Brent":
    "brent@example.com",     "Dan": "dan@example.com",     "David": "david@example.com",     "Fox":
    "fox@example.com",     "Jane": "jane@example.com",     "Kevin": "kevin@example.com",     "Robert":
    "robert@example.com" } [PRE207] def lookup_email(name):     try:         return
    friend_emails[name]  except KeyError ❶ as e:         print(f"<No entry for friend
    {e}>") [PRE208] name = input("Enter name to look up: ") email = lookup_email(name)
    print(f"Email: {email}") [PRE209] Enter name to look up: Jason <No entry for friend
    ''Jason''> Email: None [PRE210] import logging from operator import add, sub,
    mul, truediv import sys [PRE211] logging.basicConfig(filename=''log.txt'', level=logging.INFO)
    [PRE212] def calculator(a, b, op):     a = float(a)     b = float(b)     if op
    == ''+'':         return ❶ add(a, b)     elif op == ''-'':         return sub(a,
    b)     elif op == ''*'':         return mul(a, b)     elif op == ''/'':         return
    truediv(a, b)     else:       ❷ raise NotImplementedError(f"No operator {op}")
    [PRE213] print("""CALCULATOR Use postfix notation. Ctrl+C or Ctrl+D to quit. """)  ❶
    while True:   ❷ try:         equation = input(" ").split()         result = calculator(*equation)         print(result)
    [PRE214]  except NotImplementedError as e:         print("<!> Invalid operator.")         logging.info(e)
    [PRE215]  except ValueError as e:         print("<!> Expected format: <A> <B>
    <OP>")         logging.info(e) [PRE216]  except TypeError as e:         print("<!>
    Wrong number of arguments. Use: <A> <B> <OP>")         logging.info(e) [PRE217]  except
    ZeroDivisionError as e:         print("<!> Cannot divide by zero.")         logging.info(e)
    [PRE218]  except (KeyboardInterrupt, EOFError):         print("\nGoodbye.")         sys.exit(0)
    [PRE219] CALCULATOR Use postfix notation. Ctrl+C or Ctrl+D to quit.   11 31 +
    42.0  11 + 31 <!> Expected format: <A> <B> <OP>  11 + 31 + 10 <!> Wrong number
    of arguments. Use: <A> <B> <OP>  11 + <!> Wrong number of arguments. Use: <A>
    <B> <OP>  10 0 / <!> Cannot divide by zero.  10 40 @ <!> Invalid operator.  ^C
    Goodbye. [PRE220] INFO:root:could not convert string to float: ''+'' INFO:root:calculator()
    takes 3 positional arguments but 5 were given INFO:root:calculator() missing 1
    required positional argument: ''op'' INFO:root:float division by zero INFO:root:No
    operator @ [PRE221]  except Exception as e:         logging.exception(e)       ❶
    raise [PRE222] cities = {     "SEATTLE": "WASHINGTON, USA",     "PORTLAND": "OREGON,
    USA",     "BOSTON": "MASSACHUSETTS, USA", }  landmarks = {     "SPACE NEEDLE":
    "SEATTLE",     "LIBERTY SHIP MEMORIAL": "PORTLAND",     "ALAMO": "SAN ANTONIO",
    } [PRE223] def lookup_landmark(landmark):     landmark = landmark.upper()     try:         city
    = landmarks[landmark]         state = cities[city]   ❶ except KeyError as e:       ❷
    raise KeyError("Landmark not found.") from e     print(f"{landmark} is in {city},
    {state}") [PRE224] lookup_landmark("space needle") lookup_landmark("alamo") lookup_landmark("golden
    gate bridge") [PRE225] SPACE NEEDLE is in SEATTLE, WASHINGTON, USA Traceback (most
    recent call last):   File "./chaining.py", line 18, in lookup_landmark     state
    = cities[city] ❶ KeyError: ''SAN ANTONIO''  ❷ The above exception was the direct
    cause of the following exception:  Traceback (most recent call last):  File "./chaining.py",
    line 25, in <module>     lookup_landmark("alamo")   File "./chaining.py", line
    20, in lookup_landmark     raise KeyError("Landmark not found.") from e ❸ KeyError:
    ''Landmark not found.'' [PRE226] During handling of the above exception, another
    exception occurred: [PRE227] import math   def average_string(number_string):     try:         numbers
    = [float(n) for n in number_string.split()]  except ValueError:         total
    = math.nan         values = 1 [PRE228]  else:         total = sum(numbers)         values
    = len(numbers) [PRE229]  try:         average = total / values     except ZeroDivisionError:         average
    = math.inf      return average   while True:     number_string = input("Enter
    space-delimited list of numbers:\n    ")     print(average_string(number_string))
    [PRE230]  4 5 6 7 5.5      inf     four five six nan [PRE231] def average_file(path):     file
    = open(path, ''r'')      try:       ❶ numbers = [float(n) for n in file.readlines()]
    [PRE232]  except ValueError as e:         raise ValueError("File contains non-numeric
    values.") from e [PRE233]  else:         try:             return sum(numbers)
    / len(numbers)         except ZeroDivisionError as e:             raise ValueError("Empty
    file.") from e [PRE234]  finally:         print("Closing file.")         file.close()
    [PRE235] print(average_file(''numbers_good.txt'')) [PRE236] Closing file. 42.0
    [PRE237] print(average_file(''numbers_bad.txt'')) [PRE238] ❶ Closing file. Traceback
    (most recent call last):   File "tryfinally.py", line 5, in average_file     numbers
    = [float(n) for n in file.readlines()]   File "tryfinally.py", line 5, in <listcomp>     numbers
    = [float(n) for n in file.readlines()] ValueError: could not convert string to
    float: ''thirty-three\n''  The above exception was the direct cause of the following
    exception:  Traceback (most recent call last):   File "tryfinally.py", line 20,
    in <module>     print(average_file(''numbers_bad.txt''))  # ValueError   File
    "tryfinally.py", line 7, in average_file     raise ValueError("File contains non-numeric
    values.") from e ValueError: File contains non-numeric values. [PRE239] print(average_file(''numbers_empty.txt''))
    [PRE240] ❶ Closing file. Traceback (most recent call last):   File "tryfinally.py",
    line 10, in average_file     return sum(numbers) / len(numbers) ZeroDivisionError:
    division by zero  The above exception was the direct cause of the following exception:  Traceback
    (most recent call last):   File "tryfinally.py", line 21, in <module>     print(average_file(''numbers_empty.txt''))  #
    ValueError   File "tryfinally.py", line 12, in average_file     raise ValueError("Empty
    file.") from e ❷ ValueError: Empty file. [PRE241] print(average_file(''nonexistent.txt''))
    [PRE242] Traceback (most recent call last):   File "tryfinally.py", line 22, in
    <module>     print(average_file(''nonexistent.txt''))  # FileNotFoundError   File
    "tryfinally.py", line 2, in average_file     file = open(path, ''r'') FileNotFoundError:
    [Errno 2] No such file or directory: ''nonexistent.txt'' [PRE243] class ❶ SillyWalkException(
    ❷ RuntimeError):     def __init__(self, ❸ message="Someone walked silly."):         super().__init__(message)   def
    walking():   ❹ raise SillyWalkException("My walk has gotten rather silly.")   try:     walking()
    ❺ except SillyWalkException as e:     print(e) [PRE244] class SillyWalkException(RuntimeError):     """Exception
    for walking silly.""" [PRE245]`**'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
