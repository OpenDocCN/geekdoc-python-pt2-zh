- en: Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分
- en: ESSENTIAL STRUCTURES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基本结构
- en: '5'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Variables and Types
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和类型
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Some of the most pernicious misconceptions about Python revolve around its nuances
    regarding variables and data types. Misunderstandings related to this *one* topic
    cause countless frustrating bugs, and this is unfortunate. Python’s way of handling
    variables is at the core of its power and versatility. If you understand this,
    everything else falls into place.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Python的误解中，一些最具误导性的是围绕变量和数据类型的细微差别。与这个*单一*主题相关的误解导致了无数令人沮丧的错误，真是遗憾。Python处理变量的方式是其强大和多功能的核心。如果你理解了这一点，其他一切都会迎刃而解。
- en: My own understanding of this topic was cemented by “Facts and Myths About Python
    Names and Values,” Ned Batchelder’s now-legendary talk at PyCon 2015\. I recommend
    you watch the video of the presentation at [https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns),
    either now or after reading this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个主题的理解是通过Ned Batchelder在2015年PyCon大会上的经典演讲《Python名称和值的事实与误区》得以巩固的。我建议你观看这场演讲的视频，链接是[https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns)，可以在阅读完本章后再观看。
- en: 'Variables According to Python: Names and Values'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的变量：名称和值
- en: Many myths about Python variables stem from people’s attempts to describe the
    language in terms of *other languages*. Perhaps most annoying to Python experts
    is the misleading aphorism, “Python has no variables,” which is really just the
    product of someone being overly clever about the fact that the Python language
    uses the terms *name* and *value*, instead of *variable*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多关于Python变量的误区源于人们试图用*其他语言*的术语来描述Python。也许最让Python专家烦恼的是那句误导性的格言：“Python没有变量”，这实际上只是某些人过于聪明地强调了Python语言使用*名称*和*值*的术语，而不是*变量*。
- en: Python developers still use the term *variable* on a regular basis, and it even
    appears in the documentation, as it is part of understanding the overall system.
    However, for the sake of clarity, I’ll use the official Python terms exclusively
    throughout the rest of the book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python开发者仍然常常使用*变量*这个术语，它甚至出现在文档中，因为它是理解整体系统的一部分。然而，为了清晰起见，我将在本书的其余部分中只使用官方的Python术语。
- en: 'Python uses the term *name* to refer to what would conventionally be called
    a variable. A name refers to a value or an object, in the same way that your name
    refers to you but does not contain you. There may even be multiple names for the
    same thing, just as you may have a given name and a nickname. A *value* is a particular
    instance of data in memory. The term *variable* refers to the combination of the
    two: a name that refers to a value. From now on, I’ll only use the term *variable*
    in relation to this precise definition.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用*名称*这个术语来表示传统意义上的变量。一个名称指向一个值或一个对象，就像你的名字指向你，但并不包含你一样。一个东西可能有多个名称，就像你可能有本名和昵称一样。*值*是内存中数据的具体实例。术语*变量*指的是这两者的结合：一个指向值的名称。从现在开始，我只会在这个精确定义的语境中使用*变量*这个术语。
- en: Assignment
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值
- en: 'Let’s look at what happens under the hood when I define a variable per the
    above definitions like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我按照上述定义这样定义一个变量时，幕后发生了什么：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5-1: *simple_assignment.py:1*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-1：*simple_assignment.py:1*
- en: The name `answer` is *bound* to the value `42`, meaning the name can now be
    used to refer to the value in memory. This operation of binding is referred to
    as an *assignment*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`answer`被*绑定*到值`42`，这意味着现在可以使用该名称来引用内存中的值。这个绑定操作称为*赋值*。
- en: 'Look at what happens behind the scenes when I assign the variable `answer`
    to a new variable, `insight`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当我将变量`answer`赋值给新变量`insight`时，幕后发生了什么：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5-2: *simple_assignment.py:2*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-2：*simple_assignment.py:2*
- en: The name `insight` doesn’t refer to a copy of the value `42`, but rather to
    the same, original value. This is illustrated in [Figure 5-1](#figure5-1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`insight`并不是指值`42`的副本，而是指同一个原始值。这个过程在[图 5-1](#figure5-1)中得到了说明。
- en: '![](Images/f05001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f05001.png)'
- en: 'Figure 5-1: Multiple names can be bound to the same value in memory.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1：多个名称可以绑定到内存中相同的值。
- en: 'In memory, the name `insight` is bound to the value `42`, which was already
    bound to another name: `answer`. Both names are still usable as variables. More
    importantly, `insight` is not bound to `answer`, but rather to the same value
    that `answer` was already bound to when I assigned `insight`. A name always points
    to a value.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，名称 `insight` 被绑定到值 `42`，而这个值已经绑定到另一个名称：`answer`。两个名称仍然可以作为变量使用。更重要的是，`insight`
    并不是绑定到 `answer`，而是绑定到 `answer` 原先绑定的那个值。当我给 `insight` 赋值时，`insight` 总是指向一个值。
- en: Back in Chapter 3, I introduced the `is` operator, which compares *identity*—the
    specific location in memory that a name is bound to. This means `is` doesn’t check
    whether a name points to equivalent values, but rather whether it points to the
    *same* value in memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章，我介绍了 `is` 运算符，它比较的是 *身份* —— 即名称所绑定的内存位置。这意味着 `is` 并不会检查名称是否指向相等的值，而是检查它是否指向内存中的
    *同一个* 值。
- en: When you make an assignment, Python makes its own decisions behind the scenes
    about whether to create a new value in memory or bind to an existing value. The
    programmer often has very little control over this decision.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行赋值操作时，Python 会在幕后做出决定，决定是创建一个新的内存值，还是绑定到现有的值上。程序员通常无法控制这个决策。
- en: 'To see this, run this example in an interactive session instead of a file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这个，你可以在交互式会话中运行这个示例，而不是在文件中运行：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 5-3: (Interactive session):1'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-3: （交互式会话）：1'
- en: I assign identical values to `spam` and `eggs`. I also bind `maps` to the same
    value as `spam`. (In case you didn’t catch it, “maps” is “spam” backward. No wonder
    GPS gets annoying.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我将相同的值赋给 `spam` 和 `eggs`，并将 `maps` 绑定到与 `spam` 相同的值。（如果你没有注意到，“maps” 是 “spam”
    反过来拼写的，怪不得 GPS 会让人抓狂。）
- en: 'When I compare the names with the comparison operator (`==`) to check whether
    the values are equivalent, both expressions return `True`, as one would expect:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用比较运算符（`==`）比较名称，检查值是否相等时，两个表达式都会返回 `True`，正如预期的那样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-4: (Interactive session):2'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-4: （交互式会话）：2'
- en: 'However, when I compare the identities of the names with `is`, something surprising
    happens:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我使用 `is` 比较名称的身份时，发生了一些令人惊讶的事情：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 5-5: (Interactive session):3'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-5: （交互式会话）：3'
- en: The names `spam` and `maps` are both bound to the same value in memory, but
    `eggs` is probably bound to a different but equivalent value. Thus, `spam` and
    `eggs` don’t share an identity. This is illustrated in [Figure 5-2](#figure5-2).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam` 和 `maps` 两个名称都绑定到了内存中的同一个值，但 `eggs` 可能绑定到了一个不同但等效的值。因此，`spam` 和 `eggs`
    并不共享身份。这个情况如图 [图 5-2](#figure5-2) 所示。'
- en: '![](Images/f05002.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f05002.png)'
- en: 'Figure 5-2: `spam` and `maps` share an identity; `eggs` is bound to an equivalent
    value, but it does not share identity.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：`spam` 和 `maps` 共享相同的身份；`eggs` 被绑定到一个等效的值，但它并不共享身份。
- en: It just goes to show, spam by any other name is still spam.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这正好说明了，不管叫啥，spam 还是 spam。
- en: 'Python isn’t guaranteed to behave exactly like this, and it may well decide
    to reuse an existing value. For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并不保证总是以这种方式表现，它可能会决定重用一个现有的值。例如：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-6: (Interactive session)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-6: （交互式会话）'
- en: When I assign the value `42` to `insight`, Python decides to bind that name
    to the existing value. Now, `answer` and `insight` happen to be bound to the same
    value in memory, and thus, they share an identity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将值 `42` 赋给 `insight` 时，Python 会决定将这个名称绑定到现有的值上。现在，`answer` 和 `insight` 恰好都被绑定到内存中的同一个值，因此它们共享相同的身份。
- en: This is why the identity operator (`is`) can be sneaky. There are many situations
    in which `is` appears to work like the comparison operator (`==`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么身份运算符（`is`）可能会让人产生误解的原因。实际上有很多情况下，`is` 看起来像是比较运算符（`==`）一样工作。
- en: As a final note, the built-in function `id()` returns an integer representing
    the identity of whatever is passed to it. These integers are the values that the
    `is` operator compares. If you’re curious about how Python handles names and values,
    try playing with `id()`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后提醒，内建函数 `id()` 会返回一个整数，表示传递给它的对象的身份。这些整数是 `is` 运算符进行比较的值。如果你对 Python 如何处理名称和值感到好奇，可以试着玩玩
    `id()`。
- en: Data Types
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: As you’ve likely noticed, Python does not require you, the programmer, to declare
    a type for your variables. Back when I first picked up Python, I joined the `#python`
    channel on IRC and jumped right in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，Python 并不要求你作为程序员为变量声明类型。刚开始学习 Python 时，我加入了 IRC 上的 `#python` 频道，直接跳了进去。
- en: “How do you declare the data type of a variable in Python?” I asked, in all
    the naivete of a first-year coder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “如何在 Python 中声明变量的数据类型？”我问道，带着作为一年级编程新手的天真。
- en: 'Within moments, I received a response that I consider to be my first true induction
    into the bizarre world of programming: “You’re a data type.”'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我收到了一个回复，我认为这是我第一次真正进入编程这一奇异世界的引导：“你是一个数据类型。”
- en: 'The room regulars went on to explain that Python is a dynamically typed language,
    meaning I didn’t have to tell the language what sort of information to put in
    a variable. Instead, Python would decide the type for me. I didn’t even have to
    use a special “variable declaration” keyword. I just had to assign like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 常客们接着解释道，Python 是一种动态类型语言，这意味着我不需要告诉语言在变量中放入什么类型的信息。相反，Python 会为我决定类型。我甚至不需要使用特殊的“变量声明”关键字。我只需像这样进行赋值：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 5-7: *types.py:1*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-7: *types.py:1*'
- en: At that precise moment, Python became my all-time favorite language.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就在那一刻，Python 成为我最喜欢的编程语言。
- en: 'It’s important to remember that Python is still a strongly typed language.
    I touched on this concept, along with dynamic typing, in Chapter 3. Ned Batchelder
    sums up Python’s type system quite brilliantly in his aforementioned PyCon 2015
    talk about names and values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，Python 仍然是一种强类型语言。我在第三章中提到过这个概念，并与动态类型一起讨论。Ned Batchelder 在他前述的 2015
    年 PyCon 演讲中，关于名字和值的讨论中精彩地总结了 Python 的类型系统：
- en: Names have a scope—they come and go with functions—but they have no type. Values
    have a type . . . but they have no scope.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 名字有作用域——它们随着函数的来去而存在——但它们没有类型。值有类型……但它们没有作用域。
- en: Although I haven’t touched on scope yet, this should already make sense. Names
    are bound to values, and those values exist in memory, as long as there is some
    *reference* to them. You can bind a name to literally any value you want, but
    you are limited as to what you can do with any particular value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我还没有讲解作用域，但这应该已经能让你理解。名字绑定到值，而这些值存在于内存中，只要有某种*引用*指向它们。你可以将名字绑定到任何你想要的值，但你在使用特定值时会有所限制。
- en: The type() Function
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`type()` 函数'
- en: 'If you ever need to know a value’s data type, you can use the built-in `type()`
    function. Recall that everything in Python is an object, so this function will
    really just return what class the value is an instance of:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要知道一个值的数据类型，可以使用内置的 `type()` 函数。回想一下，Python 中的每一切都是对象，因此该函数实际上会返回值所属的类：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 5-8: *types.py:2*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-8: *types.py:2*'
- en: 'Here, you can see that the value assigned to `answer` is an integer (`int`).
    On rare occasions, you may want to check the data type before you do something
    with a value. For that, you can pair the `type()` function with the `is` operator,
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到赋给 `answer` 的值是一个整数（`int`）。在某些少见的情况下，你可能需要在对值进行操作之前检查数据类型。为此，你可以将 `type()`
    函数与 `is` 操作符结合使用，如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 5-9: *types.py:3a*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-9: *types.py:3a*'
- en: 'In many cases where this sort of introspection is necessary, it may be better
    to use `isinstance()` instead of `type()`, as it accounts for subclasses and inheritance
    (see Chapter 13). The function itself returns `True` or `False`, so I can use
    it as the condition in an `if` statement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多需要这种自省的情况下，使用 `isinstance()` 而不是 `type()` 可能会更好，因为 `isinstance()` 会考虑子类和继承关系（见第13章）。该函数本身返回
    `True` 或 `False`，所以我可以将它用作 `if` 语句中的条件：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 5-10: *types.py:3b*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-10: *types.py:3b*'
- en: Truth be told, there is rarely a need for either. Instead, Python developers
    prefer a more dynamic approach.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，几乎没有必要使用声明。相反，Python 开发者更倾向于采用更动态的方法。
- en: Duck Typing
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: 'Python uses what is known (unofficially) as *duck typing*. This isn’t a technical
    term at all; it comes from the old saying:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用被称为（非正式地）*鸭子类型*的方式。这根本不是一个技术术语，它来源于一句古老的谚语：
- en: If it looks like a duck, walks like a duck, and quacks like a duck, then it
    probably *is* a duck.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果它看起来像鸭子，走起来像鸭子，叫声也像鸭子，那么它很可能*就是*鸭子。
- en: Python doesn’t care much about what a value’s data type is, but rather it cares
    about the *functionality* of the value’s data type. For example, if an object
    supports all the math operators and functions, and if it accepts floats and integers
    as operands on the binary operators, then Python considers the object to be a
    numeric type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对一个值的数据类型并不那么关心，而更关心该值数据类型的*功能性*。例如，如果一个对象支持所有的数学运算符和函数，并且能够接受浮点数和整数作为二元运算符的操作数，那么
    Python 就会将该对象视为数值类型。
- en: In other words, Python doesn’t care if it’s actually a robotic duck or a moose
    in a duck costume. If it has the traits needed, the rest of the details are usually
    moot.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Python 并不关心它是否真的是一只机器人鸭子或穿着鸭子服装的驼鹿。如果它具有所需的特征，其他细节通常就不那么重要了。
- en: If you’re familiar with object-oriented programming, particularly how quickly
    inheritance can get out of hand, then this whole concept of duck typing will probably
    be a breath of fresh air. If your class behaves as it should, it usually won’t
    matter what it inherits from.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉面向对象编程，尤其是继承如何迅速变得难以管理，那么鸭子类型（duck typing）这一概念可能会让你如沐春风。如果你的类表现得符合预期，通常就不需要关心它继承了什么。
- en: Scope and Garbage Collection
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围和垃圾回收
- en: '*Scope* is what defines where a variable can be accessed from. It might be
    available to an entire module or limited to the suite (body) of a function.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围*定义了一个变量可以从哪里访问。它可能对整个模块可用，也可能仅限于某个函数的代码块（主体）。'
- en: As I mentioned already, names have *scope*, whereas values do not. A name can
    be *global*, meaning it is defined by itself in a module, or it can be *local*,
    meaning it only exists within a particular function or comprehension.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所提到的，名称有*作用域*，而值则没有。一个名称可以是*全局的*，意味着它是在模块中独立定义的，或者它可以是*局部的*，意味着它仅在特定的函数或推导式内存在。
- en: Local Scope and the Reference-Counting Garbage Collector
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地作用域与引用计数垃圾回收器
- en: Functions (including lambdas) and comprehensions define their own scope; they
    are the only structures in the language to do so. Modules and classes don’t have
    their own scope in the strictest sense; they only have their own namespace. When
    a scope reaches its end, all the names defined within it are automatically deleted.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数（包括 lambda）和推导式定义了它们自己的作用域；它们是语言中唯一具备这种特性的结构。模块和类在严格意义上没有自己的作用域；它们只有自己的命名空间。当一个作用域结束时，定义在其中的所有名称会被自动删除。
- en: For any particular value, Python keeps a *reference count*, which is simply
    a count of how many references exist for that value. Every time a value is bound
    to a name, a reference is created (although there are other ways the language
    may create references). When there are no more references, the value is deleted.
    This is the *reference-counting garbage collector*, and it efficiently handles
    most garbage collection scenarios.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何特定的值，Python 会保持一个*引用计数*，它简单地记录了该值有多少个引用。每次将一个值绑定到一个名称时，就会创建一个引用（虽然语言可能通过其他方式创建引用）。当没有更多引用时，该值会被删除。这就是*引用计数垃圾回收器*，它能够高效地处理大多数垃圾回收场景。
- en: 'You can see how this works with a typical function, like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个典型的函数看到这个工作原理，比如这样：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 5-11: *local_scope.py:1*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-11: *local_scope.py:1*'
- en: I create a `spam()` function, inside of which I define the names `message`,
    `word`, and `separator`. I can access any of these names inside the function;
    that is their local scope. It doesn’t matter that `separator` is defined within
    a `for` loop, as loops don’t have their own scope. I can still access it outside
    of the loop.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个`spam()`函数，在其中定义了`message`、`word`和`separator`这三个名称。我可以在函数内部访问这些名称；那就是它们的局部作用域。即使`separator`是在`for`循环中定义的，也不影响访问，因为循环没有自己的作用域。我仍然可以在循环外部访问它。
- en: 'However, I cannot access any of these names outside of the function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我不能在函数外部访问这些名称：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 5-12: *local_scope.py:2*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-12: *local_scope.py:2*'
- en: Trying to access `message` outside the context of the `spam()` function where
    it was defined will raise a `NameError`. In this example, `message` doesn’t exist
    in the outer scope. What’s more, as soon as the function `spam()` exits, the names
    `message`, `word`, and `separator` are deleted. Because `word` and `separator`
    each referred to values with a reference count of one (meaning only one name was
    bound to each), the values are also deleted.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在`spam()`函数外部访问`message`，会引发`NameError`。在这个例子中，`message`在外部作用域中不存在。而且，一旦`spam()`函数退出，`message`、`word`和`separator`这些名称会被删除。因为`word`和`separator`各自引用的值的引用计数为一（意味着每个值只绑定了一个名称），这些值也会被删除。
- en: 'The value of `message` is not deleted when the function exits, however, because
    of the return statement at the end of the function (see [Listing 5-11](#listing5-11))
    and what I do with that value here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于函数末尾的返回语句（见[示例 5-11](#listing5-11)）以及我对该值的处理，`message`的值在函数退出时并不会被删除：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 5-13: *local_scope.py:3*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-13: *local_scope.py:3*'
- en: I bind the value returned by `spam()` to `output` in the outer scope, meaning
    that value still exists in memory and can be accessed outside of the function.
    Assigning the value to `output` increases the reference count for that value,
    so even though the name `message` is deleted when `spam()` exits, the value is
    not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 `spam()` 返回的值绑定到外部作用域中的 `output`，意味着该值仍然存在于内存中，并且可以在函数外部访问。将该值赋给 `output`
    增加了该值的引用计数，因此即使在 `spam()` 退出时删除了 `message` 名称，该值仍然存在。
- en: Interpreter Shutdown
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释器关闭
- en: When the Python interpreter is asked to shut down, such as when a Python program
    terminates, it enters *interpreter shutdown*. During this phase, the interpreter
    goes through the process of releasing all allocated resources, calling the garbage
    collector multiple times, and triggering destructors in objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 解释器被请求关闭时，例如当 Python 程序终止时，它进入*解释器关闭*阶段。在这个阶段，解释器会释放所有分配的资源，调用垃圾回收器多次，并触发对象的析构函数。
- en: 'You can use the `atexit` module from the standard library to add functions
    to this interpreter shutdown process. This may be necessary in some highly technical
    projects, although in general, you shouldn’t need to do this. Functions added
    via `atexit.register()` will be called in a last-in, first-out manner. However,
    be aware that it becomes difficult to work with modules, including the standard
    library, during interpreter shutdown. It’s like trying to work in a building as
    it’s being demolished: the janitor’s closet may disappear at any time, without
    warning.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准库中的 `atexit` 模块，将函数添加到这个解释器关闭的过程中。虽然通常情况下你不需要这么做，但在某些技术性较强的项目中，这可能是必要的。通过
    `atexit.register()` 注册的函数将按后进先出（LIFO）的顺序被调用。然而，要注意的是，在解释器关闭时，处理模块（包括标准库）会变得非常困难。就像在一栋大楼被拆除时尝试工作一样：清洁工的储藏室随时可能消失，且没有任何警告。
- en: Global Scope
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域
- en: When a name is defined within a module but outside of any function, class, or
    comprehension, it is considered to be in *global* *scope*. Although it’s okay
    to have some global scope names, having too many usually leads to the creation
    of code that is difficult to debug and maintain. Therefore, you should use global
    scope names sparingly for variables. There is often a cleaner solution, such as
    a class (see Chapter 7).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个名称在模块中定义，但不在任何函数、类或推导式内时，它被认为处于*全局作用域*中。虽然拥有一些全局作用域名称是可以的，但过多的全局名称通常会导致难以调试和维护的代码。因此，你应该谨慎使用全局作用域中的名称，特别是对于变量。通常会有更简洁的解决方案，比如使用类（参见第7章）。
- en: 'Properly using global scope names in the context of a more local scope, such
    as a function, requires you to think ahead a little. Consider what I do if I want
    a function that can modify a global variable storing a high score. First, I define
    the global variable:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在更局部的作用域（例如函数）中正确使用全局作用域的名称，要求你提前思考一下。如果我想要一个可以修改存储高分的全局变量的函数，我会怎么做呢？首先，我定义这个全局变量：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-14: *global**_scope.py:1*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-14: *global**_scope.py:1*'
- en: 'I’ll write this function the wrong way first:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先会以错误的方式编写这个函数：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 5-15: *global**_scope.py:2*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-15: *global**_scope.py:2*'
- en: When I run this code, Python complains that I’m using a local variable before
    I’ve assigned a value to it ❶. The problem is, I’m assigning to the name `high_score`
    within the scope of the function `score()` ❷, and that *shadows*, or hides, the
    global `high_score` name behind the new, local `high_score` name. The fact that
    I’ve created a local `high_score` name *anywhere in the function* makes it impossible
    for the function to ever “see” the global `high_score` name.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这段代码时，Python 会抱怨我在赋值之前就使用了一个局部变量 ❶。问题是，我在函数 `score()` 的作用域内给 `high_score`
    赋值 ❷，这样就*遮蔽*了全局的 `high_score` 名称，或者说隐藏了全局 `high_score` 名称，转而使用了新的局部 `high_score`
    名称。事实上，我在函数的*任何地方*创建了一个局部 `high_score` 名称，使得这个函数永远无法“看到”全局的 `high_score` 名称。
- en: 'To make this work, I need to declare that I’m going to use the global name
    in the local scope, instead of defining a new local name. I can do this with the
    `global` keyword:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个代码正常工作，我需要声明我要在局部作用域中使用全局名称，而不是定义一个新的局部名称。我可以通过 `global` 关键字来实现：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 5-16: *global**_scope.py:3*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-16: *global**_scope.py:3*'
- en: Before I do anything else in my function, I must specify that I’m using the
    global `high_score` name. This means that anywhere I assign a value to the name
    `high_score` in `score()`, the function will use the global name, instead of trying
    to create a new local name. The code now works as expected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我函数中的任何操作之前，我必须指定我正在使用全局变量`high_score`。这意味着在`score()`函数中无论我在哪里给`high_score`赋值，函数都会使用全局变量，而不是尝试创建一个新的局部变量。代码现在按预期工作。
- en: 'Every time you wish to rebind a global name from within a local scope, you
    must use the `global` keyword first. If you’re only accessing the current value
    bound to a global name, you don’t need to use the `global` keyword. It is vital
    for you to cultivate this habit, because Python won’t always raise an error if
    you handle scope incorrectly. Consider this example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你希望在局部作用域中重新绑定一个全局变量时，你必须首先使用`global`关键字。如果你只是访问全局变量当前绑定的值，你不需要使用`global`关键字。养成这个习惯非常重要，因为Python并不会总是抛出错误，如果你错误地处理了作用域。请看这个例子：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-17: *global**_scope_gotcha.py:1a*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-17: *global**_scope_gotcha.py:1a*'
- en: This code runs without raising any errors, but the output is wrong. A new name,
    `current_score`, is being created in the local scope of the function `score()`,
    and it is bound to the value `465`. This shadows the global name `current_score`.
    When the function terminates, both the `new_score` and the local `current_score`
    are deleted. In all of this, the global `current_score` has remained untouched.
    It is still bound to `0`, and that is what is printed out.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行没有抛出任何错误，但输出是错误的。一个新的变量`current_score`在函数`score()`的局部作用域中被创建，并绑定了值`465`。这遮蔽了全局变量`current_score`。当函数结束时，`new_score`和局部变量`current_score`都会被删除。在这一过程中，全局的`current_score`保持不变。它仍然绑定着`0`，并打印出来的正是这个值。
- en: 'Once again, to resolve this problem, I need only use the `global` keyword:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为了解决这个问题，我只需要使用`global`关键字：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 5-18: *global**_scope_gotcha.py:1b*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-18: *global**_scope_gotcha.py:1b*'
- en: Because I specified that the global `current_name` is to be used in this function,
    the code now behaves precisely as expected, printing out the value `465`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我指定了这个函数要使用全局的`current_name`，所以代码现在行为正如预期一样，打印出值`465`。
- en: The Dangers of Global Scope
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域的危险
- en: There is one more major gotcha to account for with global scope. Modifying any
    variable at a global level, as in rebinding or mutating on a name outside the
    context of a function, can lead to confusing behavior and surprising bugs—especially
    once you start dealing with multiple modules. It’s acceptable for you to initially
    “declare” a name at a global scope, but you should do all further rebinding and
    mutation of that global name at the local scope level.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个需要注意的全局作用域的陷阱。修改全局作用域中的任何变量，比如重新绑定或者在函数外部修改某个变量的值，可能会导致令人困惑的行为和意外的错误，尤其是当你开始处理多个模块时。虽然你可以在全局作用域中初步“声明”一个变量，但应该在局部作用域中进行所有进一步的重新绑定和修改。
- en: By the way, this does *not* apply to classes, which do not actually define their
    own scope. I’ll return to this later in this chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，这一点*不适用于*类，因为类本身并不定义自己的作用域。稍后我会在本章中回到这个话题。
- en: The nonlocal Keyword
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: nonlocal关键字
- en: 'Python allows you to write functions within functions. I’ll defer discussing
    the practicality of this until Chapter 6. Here, I mainly want to explore this
    functionality’s impact on scope. Consider the following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许在函数内部定义函数。我将在第六章中再讨论这一点的实用性。在这里，我主要想探索这种功能对作用域的影响。请看以下示例：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 5-19: *nonlocal**.py*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-19: *nonlocal**.py*'
- en: 'The function `order()` contains another function: `cook()`. Each function has
    its own scope.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`order()`包含了另一个函数：`cook()`。每个函数都有自己的作用域。
- en: Remember, as long as a function only accesses a global name like `spam`, you
    don’t need to do anything special. However, trying to *assign* to a global name
    will actually define a new local name that shadows the global one. The same behavior
    is true of the inner function using names defined in the outer function, which
    is known as the *nested scope* or *enclosing scope*. To get around this, I specify
    that `eggs` is `nonlocal`, meaning it can be found in the enclosing scope, rather
    than in the local scope ❶. The inner function `cook()` has no trouble accessing
    the global name `spam`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只要一个函数仅访问像 `spam` 这样的全局名称，你不需要做任何特别的操作。然而，试图*赋值*给一个全局名称实际上会定义一个新的本地名称，并遮蔽全局名称。对于使用外部函数中定义的名称的内部函数，这也有相同的行为，这种情况被称为*嵌套作用域*或*封闭作用域*。为了避免这种情况，我指定
    `eggs` 为 `nonlocal`，意味着它可以在封闭作用域中找到，而不是在本地作用域 ❶ 中找到。内部函数 `cook()` 没有问题访问全局名称 `spam`。
- en: The `nonlocal` keyword starts looking for the indicated name in the innermost
    nested scope, and if it doesn’t find it, it moves to the next enclosing scope
    above that. It repeats this until it either finds the name or determines that
    the name does not exist in a nonglobal enclosing scope.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonlocal` 关键字会在最内层的嵌套作用域中查找指定的名称，如果没找到，它会继续查找上层的封闭作用域。它会一直重复这个过程，直到找到名称或确定该名称在非全局的封闭作用域中不存在为止。'
- en: Scope Resolution
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域解析
- en: 'Python’s rule about which scopes it searches for a name, and in what order,
    is called the *scope resolution order*. The easiest way to remember the scope
    resolution order is with the acronym *LEGB—*for which my colleague Ryan gave me
    the handy mnemonic “Lincoln Eats Grant’s Breakfast”:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Python 关于它搜索名称的规则，以及搜索顺序，被称为*作用域解析顺序*。记住作用域解析顺序最简单的方法是通过首字母缩略词*LEGB*——我的同事 Ryan
    给我提供了一个便于记忆的助记符：“Lincoln Eats Grant’s Breakfast”：
- en: Local
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地
- en: Enclosing-function locals (that is, anything found via `nonlocal`)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封闭函数的局部变量（也就是通过 `nonlocal` 找到的任何东西）
- en: Global
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局
- en: Built-in
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置
- en: Python will look in these scopes, in order, until it finds a match or reaches
    the end. The `nonlocal` and `global` keywords adjust the behavior of this scope
    resolution order.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会按照顺序在这些作用域中查找，直到找到匹配项或到达末尾。`nonlocal`和`global`关键字调整了这种作用域解析顺序的行为。
- en: The Curious Case of the Class
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类的奇异案例
- en: Classes have their own way of dealing with scope. Technically speaking, classes
    don’t directly factor into the scope resolution order. Every name declared directly
    within a class is known as an *attribute*, and it is accessed through the dot
    (`.`) operator on the class (or object) name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类有自己处理作用域的方式。从技术上讲，类不会直接影响作用域解析顺序。每个在类中直接声明的名称都被称为*属性*，并且它是通过类（或对象）名称上的点（`.`）操作符进行访问的。
- en: 'To demonstrate this, I’ll define a class with a single attribute:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将定义一个只有一个属性的类：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 5-20: *class_attributes**.py*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-20: *class_attributes**.py*'
- en: 'Those three print statements all output the same thing. Running that code gives
    me this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那三条打印语句输出的内容是一样的。运行这段代码给我带来的结果是：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The name `output` is a *class attribute* ❶, belonging to the `Nutrimatic` class.
    Even within that class, I would not be able to refer to it merely as `output`.
    I must access it through `self.output` ❷, as `self` refers to the class instance
    the function (instance method) `request()` is being called on. I can also access
    it via `machine.output` ❸ or `Nutrimatic.output` ❹ anywhere the object `machine`
    or the class `Nutrimatic` is, respectively, in scope. All of those names point
    to the exact same attribute: `output`. Especially in this case, there’s no real
    difference between them.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 `output` 是一个*类属性* ❶，属于 `Nutrimatic` 类。即使在该类内部，我也不能仅仅称之为 `output`。我必须通过 `self.output`
    ❷ 来访问它，因为 `self` 是指函数（实例方法）`request()` 被调用时所关联的类实例。我也可以通过 `machine.output` ❸ 或
    `Nutrimatic.output` ❹ 在 `machine` 对象或 `Nutrimatic` 类的作用域内访问它。这些名称指向的是完全相同的属性：`output`。尤其是在这个案例中，它们之间没有什么实质性的区别。
- en: Generational Garbage Collector
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代际垃圾回收器
- en: Behind the scenes, Python also has a more robust *generational garbage collector*
    that handles all of the odd situations a reference-counting garbage collector
    cannot, such as reference cycles (when two values reference one another). All
    of these situations, and the ways they’re handled by the garbage collector, are
    far beyond the scope of this book.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Python 还拥有一个更强大的*代际垃圾回收器*，它处理引用计数垃圾回收器无法处理的所有特殊情况，例如引用循环（当两个值互相引用时）。所有这些情况，以及垃圾回收器处理它们的方式，远远超出了本书的范围。
- en: Moving forward, the most important takeaway to remember is that the generational
    garbage collector incurs some performance costs. Thus, it’s sometimes worthwhile
    to avoid reference cycles. One way to do this is with `weakref`, which creates
    a reference to a value without increasing that value’s reference count. This feature
    was defined in PEP 205, and the documentation exists at [https://docs.python.org/library/weakref.html](https://docs.python.org/library/weakref.html).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 继续往下，最重要的要点是，代际垃圾回收器会带来一些性能开销。因此，有时避免引用循环是值得的。实现这一点的一种方式是使用 `weakref`，它创建一个对值的引用，而不增加该值的引用计数。此功能在
    PEP 205 中进行了定义，相关文档可以在 [https://docs.python.org/library/weakref.html](https://docs.python.org/library/weakref.html)
    找到。
- en: The Immutable Truth
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变的真相
- en: Values in Python can be either *immutable* or *mutable*. The difference hinges
    on whether the values can be *modified in place*, meaning they can be changed
    right where they are in memory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，值可以是*不可变*的或者*可变*的。它们之间的区别在于值是否可以*原地修改*，也就是说，它们能否在内存中的当前位置被更改。
- en: '*Immutable* types cannot be modified in place. For example, integers (`int`),
    floating-point numbers (`float`), strings (`str`), and tuples (`tuple`) are all
    immutable. If you attempt to mutate an immutable value, you’ll wind up with a
    completely different value being created:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可变*类型不能原地修改。例如，整数（`int`）、浮点数（`float`）、字符串（`str`）和元组（`tuple`）都是不可变的。如果你尝试修改一个不可变的值，你将会得到一个完全不同的新值：'
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 5-21: *immutable_types.py*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-21: *immutable_types.py*'
- en: Initially, `eggs` and `carton` are both bound to the same value, and thus, they
    share an identity. When I modify `eggs`, it is rebound to a new value, so it no
    longer shares an identity with `carton`. You can see that the two names now point
    to different values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`eggs` 和 `carton` 都绑定到相同的值，因此它们共享同一个身份。当我修改 `eggs` 时，它被重新绑定到一个新值，因此它不再与 `carton`
    共享身份。你可以看到，现在这两个名字指向了不同的值。
- en: '*Mutable* types, on the other hand, can be modified in place. Lists constitute
    one example of a mutable type:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*可变*类型可以原地修改。列表就是一个可变类型的例子：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 5-22: *mutable_types.py*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-22: *mutable_types.py*'
- en: Because the list is aliased to both `temps` and `highs`, any modifications made
    to the list value ❶ are visible through either name. Both names are bound to the
    original value, as demonstrated by the `is` comparisons. This remains the case,
    even after that value is mutated.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为列表同时别名化为 `temps` 和 `highs`，所以对列表值 ❶ 所做的任何修改都可以通过任意名字看到。正如 `is` 比较所演示的，两个名字都绑定到原始值，即使该值被修改后，依然如此。
- en: Passing by Assignment
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过赋值传递
- en: Another frequent question from programmers new to the language is, “Does Python
    pass by value or by reference?”
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学该语言的程序员，另一个常见的问题是，“Python 是通过值传递还是引用传递？”
- en: The answer is, “Effectively, neither.” More accurately, as Ned Batchelder describes
    it, Python *passes by assignment*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：“实际上，既不是。” 更准确地说，正如 Ned Batchelder 所描述的，Python 是*通过赋值传递*的。
- en: 'Neither the values nor the names bound to them are moved. Instead, each value
    is bound to the parameter via assignment. Consider a simple function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是值还是绑定到这些值的名字，都没有被移动。相反，每个值都通过赋值绑定到参数。考虑一个简单的函数：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, there is one copy of the string value `"Jason"` in memory, and that is
    bound to the name `my_name`. When I pass `my_name` to the `greet()` function—specifically,
    to the `person` parameter—it’s the same as if I had said (`person = my_name`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内存中有一个字符串值 `"Jason"` 的副本，它被绑定到名字 `my_name`。当我将 `my_name` 传递给 `greet()` 函数——具体来说，传递给
    `person` 参数时——这就相当于我说了（`person = my_name`）。
- en: Again, assignment never makes a copy of a value. The name `person` is now bound
    to the value `"Jason"`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，赋值从不会复制一个值。名字 `person` 现在被绑定到值 `"Jason"`。
- en: 'This concept of passing by assignment gets tricky when you start working with
    mutable values, such as lists. To demonstrate this often-unexpected behavior,
    I’ve written a function that finds the lowest temperature in a list passed to
    it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过赋值传递的概念在处理可变值（如列表）时变得棘手。为了演示这种常常令人意外的行为，我写了一个函数来查找传入列表中的最低温度：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 5-23: *lowest_temp.py:1a*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-23: *lowest_temp.py:1a*'
- en: 'At first glance, you may assume that passing a list to the `temperatures` parameter
    will make a copy, so it shouldn’t matter if you modify the value bound to the
    parameter. However, lists are mutable, meaning *the value itself* can be modified:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，你可能认为将列表传递给 `temperatures` 参数会创建一个副本，因此修改绑定到参数的值应该不影响原值。然而，列表是可变的，意味着*值本身*可以被修改：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 5-24: *lowest_temp.py:2*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-24: *lowest_temp.py:2*'
- en: When I passed `temps` to the function’s `temperatures` parameter, I only *aliased*
    the list, so any changes made on `temperatures` are visible from all the other
    names bound to that same list value—namely, from `temps`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将`temps`传递给函数的`temperatures`参数时，我只是*引用*了这个列表，因此在`temperatures`上的任何更改都会在绑定到同一个列表值的所有其他名称中可见——即，`temps`。
- en: 'You can see this in action when I run this code and get the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这段代码并得到以下输出时，你可以看到它的效果：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When `find_lowest()` sorted the list passed to `temperatures`, it actually sorted
    the one mutable list that both `temps` and `temperatures` aliased. This is a clear
    case of a function having *side effects*, which are changes to values that existed
    before the function call.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当`find_lowest()`对传递给`temperatures`的列表进行排序时，它实际上排序了一个可变列表，而该列表同时被`temps`和`temperatures`引用了。这是一个典型的*副作用*案例——即对函数调用前已存在值的更改。
- en: 'An awe-inspiring number of bugs originate from this one type of misunderstanding.
    In general, functions should not have side effects, meaning that any values passed
    to the function as arguments should *not* be directly mutated. To avoid mutating
    the original value, I have to explicitly make a copy of it. Here’s how I’d do
    that in the `find_lowest()` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一种惊人的错误数量源于这种误解。通常，函数不应有副作用，这意味着传递给函数的任何值作为参数不应直接发生变化。为了避免改变原始值，我必须显式地复制它。这就是我在`find_lowest()`函数中要做到的：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 5-25: *lowest_temp.py:1b*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-25: *lowest_temp.py:1b*'
- en: The `sorted()` function has no side effects; it creates a new list using the
    items in the list passed to it ❶. It then sorts this new list and returns it.
    I bind this new list to `sorted_temps`. Thus, the original list (bound to `temps`
    and `temperatures`) is untouched.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`函数没有副作用；它会创建一个新列表，使用传递给它的列表中的项目❶。然后，它对这个新列表进行排序并返回。这个新列表被绑定到`sorted_temps`。因此，原始列表（绑定到`temps`和`temperatures`）保持不变。'
- en: If you’re coming from C and C++, it may be helpful to remember the potential
    hang-ups related to pass-by-pointer or pass-by-reference. Although Python’s assignment
    is scarcely similar from a technical standpoint, the risks of side effects and
    unintended mutations are the same.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自C和C++，记住与指针传递或引用传递相关的潜在问题可能会很有帮助。尽管从技术角度来看，Python的赋值操作几乎没有相似之处，但副作用和意外变异的风险是相同的。
- en: Collections and References
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合和引用
- en: 'All collections, including lists, employ a clever little semantic detail that
    can become a royal pain if you don’t know to expect it: ***Individual items are
    references.*** Just as a name is bound to a value, so also are items in collections
    bound to values, in the same manner. This binding is called a *reference*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合，包括列表，都包含一个巧妙的小语义细节，如果你不知道会预期它，它可能会成为一个麻烦：***单个项目是引用。*** 就像一个名字绑定到一个值一样，集合中的项目也以相同的方式绑定到值。这个绑定称为*引用*。
- en: A simple example involves trying to create a tic-tac-toe board. This first version
    won’t work quite how you’d expect.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是尝试创建一个井字棋棋盘。这个版本的实现不会像你预期的那样工作。
- en: 'I’ll start by creating the game board:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从创建游戏棋盘开始：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 5-26: *tic_tac_toe**.py:1a*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-26: *tic_tac_toe.py:1a*'
- en: I’m trying to create a two-dimensional board. You can fill a collection, like
    a list, with several items, all with the same repeating value, using the multiplication
    operator ❶, as I’ve done here. I enclose the repeating value in square brackets
    and multiply it by the number of repetitions I want. A single row of my board
    is defined with `["-"] * 3`, which makes a list of three `"-"` strings.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在尝试创建一个二维棋盘。你可以使用乘法运算符❶填充一个集合，比如列表，用多个具有相同重复值的项目，就像我在这里所做的那样。我将重复的值放在方括号中，并将其乘以我想要的重复次数。我通过`["-"]
    * 3`定义了棋盘的单行，它生成一个包含三个`"-"`字符串的列表。
- en: 'Unfortunately, this won’t work the way you’d expect. The problem begins when
    I attempt to define the second dimension of the array—three copies of the `[["-"]
    * 3]` list—using multiplication. You can see the problem manifest when I try to
    make a move:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不会按照你预期的方式工作。问题出现在我尝试使用乘法定义数组的第二维时——即三个`[["-"] * 3]`列表的副本。当我尝试进行一步时，你可以看到问题的出现：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 5-27: *tic_tac_toe**.py:2*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-27: *tic_tac_toe.py:2*'
- en: 'When I mark a move on the board ❷, I want to see that change in only one spot
    on the board, like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在棋盘上标记一个位置❷时，我希望只在棋盘上的一个位置看到变化，像这样：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Instead, I get this nasty surprise:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我得到的是这个令人讨厌的惊喜：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Cue the weeping and gnashing of teeth. Somehow, that one change has propagated
    to *all three* *rows*. Why?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好哭泣和咬牙切齿吧。不知道为什么，这个变化已经传播到*所有三个* *行*。为什么？
- en: Initially, I created a list with three `"-"` values as items ❶. Since strings
    are immutable and thus cannot be modified in place, this works as expected. Rebinding
    the first item in the list to `"X"` does not affect the other two items.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我创建了一个包含三个`"-"`值的列表作为元素❶。由于字符串是不可变的，不能就地修改，所以这按预期工作。将列表中的第一个元素重新绑定为`"X"`不会影响另外两个元素。
- en: The outer dimension of the list is composed of three list items. Because I defined
    *one* list and used it *three* times, I now have three *aliases* for one mutable
    value! By changing that list through one reference (the second row), I’m mutating
    that one shared value ❷, so all three references see the change.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的外部维度由三个列表元素组成。因为我定义了*一个*列表并使用它*三*次，所以我现在有了三个*别名*指向同一个可变值！通过一个引用（第二行）修改该列表时，我实际上是在改变那个共享的值❷，因此所有三个引用都看到了这个变化。
- en: 'There are a few ways to fix this, but all of them work by ensuring each row
    references a separate value, like so:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以修复这个问题，但它们的共同点是确保每一行引用一个单独的值，如下所示：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 5-28: *tic_tac_toe**.py:1b*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-28: *tic_tac_toe**.py:1b*'
- en: 'I only needed to change how I defined the game board initially. I now use a
    *list comprehension* to create the rows. In short, this list comprehension will
    define a separate list value from `["-"] * 3` three different times. (List comprehensions
    get complicated; they’ll be explained in depth in Chapter 10.) Running the code
    now results in the expected behavior:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我只需要改变最初定义游戏板的方式。我现在使用*列表推导式*来创建行。简而言之，这个列表推导式会三次分别定义一个与`["-"] * 3`不同的列表值。（列表推导式很复杂；它们将在第10章中详细讲解。）现在运行代码会得到预期的行为：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Long story short, whenever you’re working with a collection, remember that
    an item is no different from any other name. Here is one more example to drive
    this point home:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，任何时候你在处理一个集合时，记住一个元素与任何其他名称没有什么不同。这里有一个例子来进一步说明这一点：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 5-29: *team_scores**.py:1*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-29: *team_scores**.py:1*'
- en: 'I create three lists, assigning each to a name. Then, I pack all three into
    the tuple `scores`. You may remember from earlier that tuples cannot be modified
    directly, because they’re immutable. That same rule does not necessarily apply
    to a tuple’s items. You can’t change the tuple itself, but you can (indirectly)
    modify the values its items refer to:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了三个列表，并将每个列表分配给一个名称。然后，我将这三个列表打包成元组`score`。你可能记得，元组不能直接修改，因为它们是不可变的。但这个规则并不一定适用于元组的元素。你不能改变元组本身，但你可以（间接地）修改它的元素所指向的值：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 5-30: *team_scores**.py:2*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-30: *team_scores**.py:2*'
- en: When I mutate the list `scores_team_1`, that change appears in the first item
    of the tuple, because that item only aliased a mutable value.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我修改列表`score_team_1`时，这个变化会出现在元组的第一个元素中，因为该元素仅仅是一个指向可变值的别名。
- en: 'I could also directly mutate a mutable list in the `scores` tuple through two-dimensional
    subscription, like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以通过二维订阅直接修改`score`元组中的一个可变列表，如下所示：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 5-31: *team_scores**.py:3*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-31: *team_scores**.py:3*'
- en: Tuples don’t give you any sort of security about things being modified. Immutability
    exists mainly for efficiency, not for protecting data. Mutable values are *always*
    going to be mutable, no matter where they live or how they’re referred to.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 元组并不能为你提供任何关于事物被修改的安全性。不可变性主要是为了效率，而不是为了保护数据。可变值*始终*是可变的，无论它们存在于何处，或如何被引用。
- en: The problems in the two examples above may seem relatively easy to spot, but
    things start getting troublesome when the related code is spread out across a
    large file or multiple files. Mutating on a name in one module may unexpectedly
    modify an item of a collection in a completely different module, and you might
    never have expected it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上面两个例子中的问题看起来可能相对容易发现，但当相关的代码分散在一个大文件或多个文件中时，问题就变得棘手了。在一个模块中修改一个名称，可能会意外地修改一个完全不同模块中的集合元素，而你可能从未预料到这种情况。
- en: Shallow Copy
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浅拷贝
- en: There are many ways to ensure you are binding a name to a *copy* of a mutable
    value, instead of aliasing the original; the most explicit of these ways is with
    the `copy()` function. This is sometimes also known as a *shallow copy*, in contrast
    to the *deep copy* I’ll cover later.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以确保你绑定一个名称到一个可变值的*副本*，而不是别名化原始值；其中最明确的方法是使用`copy()`函数。这有时也被称为*浅拷贝*，与我稍后会讲到的*深拷贝*相对。
- en: 'To demonstrate this, I’ll create a `Taco` class (see Chapter 7 for more on
    classes) that allows you to define the class with various toppings and then add
    a sauce afterward. This first version has a bug:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将创建一个 `Taco` 类（有关类的更多内容请参见第 7 章），该类允许你定义具有各种配料的塔可，然后再添加酱料。这个版本有一个 bug：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 5-32: *mutable_**tacos.py:1a*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-32: *mutable_**tacos.py:1a*'
- en: In the `Taco` class, the initializer `__init__()` accepts a list of toppings,
    which it stores as the `ingredients` list. The `add_sauce()` method will add the
    specified `sauce` string to the `ingredients` list.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Taco` 类中，初始化函数 `__init__()` 接受一个配料列表，并将其存储为 `ingredients` 列表。`add_sauce()`
    方法将指定的 `sauce` 字符串添加到 `ingredients` 列表中。
- en: (Can you anticipate the problem?)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: （你能预见到这个问题吗？）
- en: 'I use the class as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我按如下方式使用该类：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 5-33: *mutable_**tacos.py:2a*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-33: *mutable_**tacos.py:2a*'
- en: 'I define a list of toppings I want on all my tacos, and then I define two tacos:
    `hot_taco` and `mild_taco`. I pass the `default_toppings` list to the initializer
    for each taco. Then I add `"Salsa"` to the list of toppings to `hot_taco`, but
    I don’t want any `"Salsa"` on `mild_taco`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个所有塔可（taco）都要用的配料列表，然后我定义了两个塔可：`hot_taco` 和 `mild_taco`。我将 `default_toppings`
    列表传递给每个塔可的初始化函数。然后，我将 `"Salsa"` 添加到 `hot_taco` 的配料列表中，但不希望在 `mild_taco` 上添加任何
    `"Salsa"`。
- en: 'To make sure this is working, I print out the list of `ingredients` for the
    two tacos, as well as the `default_toppings` list I started with:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这个功能正常，我打印了两个塔可的 `ingredients` 列表，以及我最初创建的 `default_toppings` 列表：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 5-34: *mutable_**tacos.py:3*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-34: *mutable_**tacos.py:3*'
- en: 'That outputs the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Waiter, there’s a bug in my taco!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 服务员，我的塔可有个 bug！
- en: The trouble is, when I created my `hot_taco` and `mild_taco` object by passing
    `default_toppings` to the `Taco` initializer, I bound both `hot_taco.ingredients`
    and `mild_taco.ingredients` to the same list value as `default_toppings`. These
    are now all aliases of the same value in memory. Then, when I call the function
    `hot_taco.add_sauce()`, I mutate that list value. The addition of `"Salsa"` is
    visible not only in `hot_taco.ingredients`, but also (unexpectedly) in `mild_taco.ingredients`
    and in the `default_toppings` list. This is definitely not the desired behavior;
    adding `"Salsa"` to one taco should only affect that one taco.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在，我通过将 `default_toppings` 传递给 `Taco` 初始化函数来创建 `hot_taco` 和 `mild_taco` 对象时，我将
    `hot_taco.ingredients` 和 `mild_taco.ingredients` 都绑定到了与 `default_toppings` 相同的列表值上。这些现在都成了内存中同一个值的别名。然后，当我调用
    `hot_taco.add_sauce()` 函数时，我修改了那个列表值。添加 `"Salsa"` 不仅在 `hot_taco.ingredients` 中可见，而且（意外地）也出现在
    `mild_taco.ingredients` 和 `default_toppings` 列表中。这显然不是我们想要的行为；向一个塔可添加 `"Salsa"`
    应该只影响那个塔可。
- en: 'One way to resolve this is to ensure I’m assigning a copy of the mutable value.
    In the case of my `Taco` class, I will rewrite the initializer so it assigns a
    copy of the specified list to `self.ingredients`, instead of aliasing:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是确保我分配的是可变值的副本。在我的 `Taco` 类中，我将重写初始化函数，使其将指定列表的副本赋给 `self.ingredients`，而不是直接引用：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 5-35: *mutable_**tacos.py:1b*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-35: *mutable_**tacos.py:1b*'
- en: I make a copy with the `copy.copy()` function ❶, which is imported from `copy`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `copy.copy()` 函数 ❶ 创建了一个副本，该函数从 `copy` 模块导入。
- en: 'I make a copy of the list passed to `toppings` within `Taco.__init__()`, assigning
    that copy to `self.ingredients`. Any changes made to `self.ingredients` don’t
    affect the others; adding `"Salsa"` to `hot_taco` does not change `mild_taco.ingredients`,
    nor does it change `default_toppings`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 `Taco.__init__()` 内部创建了传递给 `toppings` 的列表的副本，将该副本赋给 `self.ingredients`。对
    `self.ingredients` 所做的任何更改都不会影响其他的；向 `hot_taco` 添加 `"Salsa"` 不会改变 `mild_taco.ingredients`，也不会改变
    `default_toppings`：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Deep Copy
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深拷贝
- en: A shallow copy is all well and good for lists of immutable values, but as previously
    mentioned, when a mutable value contains other mutable values, changes to those
    values can appear to replicate in weird ways.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 浅拷贝对于不可变值的列表来说是完全没问题的，但如前所述，当一个可变值包含其他可变值时，对这些值的更改可能会以奇怪的方式复制。
- en: 'For example, consider what happens when I try to make a copy of a `Taco` object
    before changing one of the two tacos. My first attempt results in some undesired
    behavior. Building on the same `Taco` class as before (see [Listing 5-35](#listing5-35)),
    I’ll use the copy of one taco to define another:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑当我在更改两个塔可中的一个之前，尝试复制一个 `Taco` 对象时会发生什么。我的第一次尝试导致了一些不期望的行为。基于之前相同的 `Taco`
    类（参见 [列表 5-35](#listing5-35)），我将使用一个塔可的副本来定义另一个：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 5-36: *mutable_**tacos.py:2b*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-36: *mutable_**tacos.py:2b*'
- en: I want to create a new taco (`hot_taco`) that is initially identical to `mild_taco`,
    but with added `"Salsa"`. I’m attempting this by binding a copy of `mild_taco`
    ❶ to `hot_taco`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我想创建一个新的塔可（`hot_taco`），它最初和`mild_taco`完全相同，但多了一个“萨尔萨”。我尝试通过将`mild_taco` ❶的副本绑定到`hot_taco`来实现。
- en: 'Running the revised code (including [Listing 5-34](#listing5-34)) produces
    the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改后的代码（包括[列表 5-34](#listing5-34)）会生成以下内容：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: I might not expect any changes made to `hot_taco` to reflect in `mild_taco`,
    but unexpected changes have clearly happened.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能不期望对`hot_taco`所做的任何更改会反映到`mild_taco`上，但显然，意外的更改确实发生了。
- en: The issue is that, when I make a copy of the `Taco` object value itself, I am
    not making a copy of the `self.ingredients` list *within* the object. Both `Taco`
    objects contain references to the same list value.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当我复制`Taco`对象的值本身时，我并没有复制对象内部的`self.ingredients`列表。两个`Taco`对象都包含指向同一个列表值的引用。
- en: 'To fix this problem, I can use *deep copy* to ensure that any mutable values
    inside the object are copied as well. In this case, a deep copy of a `Taco` object
    will create a copy of the `Taco` value, as well as a copy of any mutable values
    that `Taco` contains references to—namely, the list `self.ingredients`. [Listing
    5-37](#listing5-37) shows that same program, using deep copy:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我可以使用*深拷贝*来确保对象内部的任何可变值也被复制。在这种情况下，`Taco`对象的深拷贝将创建`Taco`值的副本，并复制`Taco`包含引用的任何可变值——也就是列表`self.ingredients`。[列表
    5-37](#listing5-37)展示了使用深拷贝的相同程序：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 5-37: *mutable_**tacos.py:2c*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-37: *mutable_**tacos.py:2c*'
- en: 'The only change is that I’m using `copy.deepcopy()`, instead of `copy.copy()`
    ❶. Now when I mutate the list inside `hot_taco`, it doesn’t affect `mild_taco`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是我使用了`copy.deepcopy()`，而不是`copy.copy()` ❶。现在当我修改`hot_taco`中的列表时，它不会影响`mild_taco`：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I don’t know about you, but I’m getting hungry for tacos.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你怎么样，但我现在好像有点饿了，想吃塔可。
- en: Copying is the most generic way to solve the problem of passing around mutable
    objects. However, depending on what you’re doing, there may be an approach better
    suited to the particular collection you’re using. For example, many collections,
    like lists, have functions that return a copy of the collection with some specific
    modification. When you’re solving these sorts of issues with mutability, you can
    start by employing copy and deep copy. Then, you can exchange that for a more
    domain-specific solution later.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 复制是解决传递可变对象问题的最通用方法。然而，根据你所做的事情，可能有更适合你使用的特定集合的方法。例如，许多集合（如列表）有返回经过特定修改的集合副本的函数。当你在处理可变性时，可以从使用复制和深拷贝开始。然后，稍后可以根据更具体的领域需求将其替换为更符合业务需求的解决方案。
- en: Coercion and Conversion
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制转换和转换
- en: Names do not have types. Therefore, Python has no need of type casting, at least
    in the typical sense of the term.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 名称没有类型。因此，Python不需要类型转换，至少在通常意义上是这样的。
- en: 'Allowing Python to figure out the conversions by itself, such as when adding
    together an integer (`int`) and a `float`, is called *coercion*. Here are a few
    examples:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让 Python 自动处理转换，比如将一个整数（`int`）和一个`float`相加，这称为*强制转换*。以下是一些示例：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 5-38: *coercion.py*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-38: *coercion.py*'
- en: Even so, there are potential situations in which you may need to use one value
    to create a value of a different type, such as when you are creating a string
    from an integer. *Conversion* is the process of explicitly casting a value of
    one type to another type.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，还是存在一些潜在的情况，可能需要用一个值创建不同类型的值，比如当你从一个整数创建一个字符串时。*转换*是将一种类型的值显式地转换为另一种类型的过程。
- en: Every type in Python is an instance of a class. Therefore, the class of the
    type you want to create only needs to have an initializer that can handle the
    data type of the value you’re converting from. (This is usually done through duck
    typing.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的每个类型都是一个类的实例。因此，你想要创建的类型的类只需要有一个可以处理你正在转换的值的数据类型的初始化器。（这通常是通过鸭子类型来实现的。）
- en: 'One of the more common scenarios is to convert a string containing a number
    into a numeric type, such as a `float`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更常见的场景是将包含数字的字符串转换为数字类型，如`float`：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Listing 5-39: *conversion.py:1*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-39: *conversion.py:1*'
- en: Here, I start with a piece of information as a string value, which is bound
    to the name `life_universe_everything`. Imagine I want to do some complex mathematical
    analysis on this data; to do this, I must first convert the data into a floating-point
    number. The desired type would be an instance of the class `float`. That particular
    class has an initializer (`__init__()`) that accepts a string as an argument,
    which is something I know from the documentation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我从一个字符串值开始，并将其绑定到名称 `life_universe_everything`。假设我想对这些数据进行一些复杂的数学分析；为此，我必须首先将数据转换为浮点数。所需的类型将是
    `float` 类的一个实例。该类有一个初始化函数（`__init__()`），接受一个字符串作为参数，这是我从文档中了解到的。
- en: I initialize a `float()` object, pass `life_universe_everything` to the initializer,
    and bind the resulting object to the name `answer`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我初始化了一个 `float()` 对象，将 `life_universe_everything` 传递给初始化函数，并将结果对象绑定到名称 `answer`。
- en: 'I’ll print out the `type` and value of `answer`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我将打印出 `answer` 的 `type` 和其值：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 5-40: *conversion.py:2*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-40: *conversion.py:2*'
- en: 'That outputs the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Since there were no errors, you can see that the result is a `float` with value
    `42.0`, bound to `answer`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有错误，你可以看到结果是一个值为`42.0`的`float`类型，绑定到`answer`。
- en: Every class defines its own initializers. In the case of `float()`, if the string
    passed to it cannot be interpreted as a floating-point number, a `ValueError`
    will be raised. Always consult the documentation for the object you’re initializing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都定义了自己的初始化函数。以 `float()` 为例，如果传递给它的字符串无法被解释为浮点数，将会引发 `ValueError`。始终查阅你正在初始化的对象的文档。
- en: A Note About Systems Hungarian Notation
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于系统匈牙利命名法的说明
- en: If you’re coming from a statically typed language like C++ or Java, you’re probably
    used to working with data types. Thus, when picking up a dynamically typed language
    such as Python, it might be tempting to employ some means of “remembering” what
    type of value every name is bound to. ***Don’t do this!*** You will find the most
    success using Python if you learn to take full advantage of dynamic typing, weak
    binding, and duck typing.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自像 C++ 或 Java 这样的静态类型语言，你可能习惯于处理数据类型。因此，在学习 Python 这样的动态类型语言时，你可能会想通过某种方式“记住”每个名称绑定的值的类型。***不要这样做！***
    如果你学会充分利用动态类型、弱绑定和鸭子类型，你会在使用 Python 时取得最大的成功。
- en: 'I will confess: the first year I used Python, I used *Systems Hungarian notation*—the
    convention of appending a prefix denoting data type to every variable name—to
    try to “defeat” the language’s dynamic typing system. My code was littered with
    such debris as `intScore`, `floatAverage`, and `boolGameOver`. I picked up the
    habit from my time using Visual Basic .NET, and I thought I was brilliant. In
    fact, I was depriving myself of many opportunities to refactor.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认：我使用 Python 的第一年，我采用了 *系统匈牙利命名法*——将表示数据类型的前缀附加到每个变量名上——试图“战胜”语言的动态类型系统。我的代码中充满了
    `intScore`、`floatAverage` 和 `boolGameOver` 等垃圾代码。我从使用 Visual Basic .NET 时养成了这个习惯，并且以为自己很聪明。事实上，我剥夺了自己很多重构的机会。
- en: 'Systems Hungarian notation will quickly render code obtuse. For example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 系统匈牙利命名法会使代码变得晦涩。例如：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 5-41: *evils_of_systems_hungarian.py*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-41: *evils_of_systems_hungarian.py*'
- en: 'Needless to say, this code is quite painful to read. On the other hand, if
    you make full use of Python’s typing system (and resist the urge to store every
    intermediate step), the code will be decidedly more compact:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，这段代码相当难以阅读。另一方面，如果你充分利用 Python 的类型系统（并抵制将每个中间步骤都存储的冲动），代码将会简洁得多：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 5-42: *duck_typing_feels_better.py*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-42: *duck_typing_feels_better.py*'
- en: My code became far cleaner once I stopped treating Python like a statically
    typed language. Python’s typing system is a big part of what makes it such a readable
    and compact language.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当我不再把 Python 当作静态类型语言时，我的代码变得更简洁了。Python 的类型系统是使其成为一种可读且简洁语言的关键部分。
- en: Terminology Review
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语复习
- en: I’ve introduced a lot of important new words in this section. Since I’ll be
    using this vocabulary frequently throughout the rest of the book, doing a quick
    recap here is prudent.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这一节引入了许多重要的新词。由于在本书的其余部分我将频繁使用这些词汇，所以在这里快速回顾一遍是明智的做法。
- en: alias (v.) To bind a mutable value to more than one name. Mutations performed
    on a value bound to one name will be visible on all names bound to that mutable
    value.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: alias (v.) 将一个可变值绑定到多个名称。对绑定到一个名称的值进行的变更将在所有绑定到该可变值的名称上可见。
- en: assignment (n.) The act of binding a value to a name. Assignment never copies
    data.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: assignment (n.) 将一个值绑定到一个名称的操作。赋值从不复制数据。
- en: bind (v.) To create a reference between a name and a value.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: bind (v.) 在名称和值之间创建一个引用。
- en: coercion (n.) The act of implicitly casting a value from one type to another.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: coercion (n.) 隐式地将一个值从一种类型转换为另一种类型的操作。
- en: conversion (n.) The act of explicitly casting a value from one type to another.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: conversion (n.) 显式地将一个值从一种类型转换为另一种类型的操作。
- en: copy (v.) To create a new value in memory from the same data as another value.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: copy (v.) 从另一个值的相同数据创建一个新值。
- en: data (n.) Information stored in a value. You may have copies of any given data
    stored in other values.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: data (n.) 存储在值中的信息。你可以在其他值中拥有给定数据的副本。
- en: deep copy (v.) To both copy an object to a new value *and* copy all the data
    from values referenced within that object to new values.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: deep copy (v.) 同时将一个对象复制到一个新值，并将该对象内所有被引用值的数据复制到新值。
- en: identity (n.) The specific location in memory that a name is bound to. When
    two names share an identity, they are bound to the same value in memory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: identity (n.) 名称绑定到的内存中特定的位置。当两个名称共享相同的身份时，它们绑定到内存中的同一个值。
- en: immutable (adj.) Of or relating to a value that *cannot* be modified in place.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: immutable (adj.) 与*不能*在原地修改的值相关的。
- en: mutable (adj.) Of or relating to a value that *can* be modified in place.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: mutable (adj.) 与*可*在原地修改的值相关的。
- en: mutate (v.) To change a value in place.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: mutate (v.) 在原地改变一个值。
- en: name (n.) A reference to a value in memory, commonly thought of as a “variable”
    in Python. A name must always be bound to a value. ***Names have scope, but not
    type.***
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: name (n.) 对内存中某个值的引用，在 Python 中通常被称为“变量”。一个名称必须始终绑定到一个值。***名称有作用域，但没有类型。***
- en: rebind (v.) To bind an existing name to a different value.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: rebind (v.) 将现有名称绑定到另一个值。
- en: reference (n.) The association between a name and a value.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: reference (n.) 名称与值之间的关联。
- en: scope (n.) A property that defines what section of the code a name is accessible
    from, such as from within a function or within a module.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: scope (n.) 定义名称在代码中可访问区域的属性，比如在函数内或模块内。
- en: shallow copy (v.) To copy an object to a new value but *not* copy the data from
    values referenced within that object to new values.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: shallow copy (v.) 将一个对象复制到一个新值，但*不*复制该对象内所引用的值的数据到新值。
- en: type (n.) A property that defines how a raw value is interpreted, for example,
    as an integer or a boolean.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: type (n.) 定义原始值如何被解释的属性，例如，作为整数或布尔值。
- en: value (n.) A unique copy of data in memory. There must be a reference to a value,
    or else the value is deleted. ***Values have type, but not scope.***
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: value (n.) 内存中数据的唯一副本。必须有对一个值的引用，否则该值会被删除。***值有类型，但没有作用域。***
- en: variable (n.) A combination of a name and the value the name refers to.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: variable (n.) 名称与名称所指向的值的组合。
- en: weakref (n.) A reference that does not increase the reference count on the value.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: weakref (n.) 一种不会增加值引用计数的引用。
- en: To help keep us grounded in these concepts, we usually use the term *name* instead
    of *variable*. Instead of *changing* something, we *(re)bind a name* or *mutate
    a value*. Assignment never copies—it literally always binds a name to a value.
    Passing to a function is just assignment.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解这些概念，我们通常使用*名称*而非*变量*这个术语。我们不是在*改变*某些东西，而是*(重新)绑定一个名称*或*修改一个值*。赋值操作从不复制——它实际上总是将一个名称绑定到一个值。将值传递给函数本质上就是赋值。
- en: By the way, if you ever have trouble wrapping your head around these concepts
    and how they play out in your code, try the visualizer at [http://pythontutor.com/](http://pythontutor.com/).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你在理解这些概念及其如何在代码中发挥作用时遇到困难，可以试试[http://pythontutor.com/](http://pythontutor.com/)上的可视化工具。
- en: Wrapping Up
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: It’s easy to take something like variables for granted, but by understanding
    Python’s unique approach, you can better avail yourself of the power that is available
    through dynamic typing. I must admit, Python has somewhat spoiled me. When I work
    in statically typed languages, I find myself pining for the expressiveness of
    duck typing.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易对像变量这样的概念掉以轻心，但通过理解 Python 的独特方式，你可以更好地利用动态类型所提供的强大功能。不得不承认，Python 让我有些“娇惯”了。当我使用静态类型语言时，我常常渴望鸭子类型的表达能力。
- en: 'Still, working with Python-style dynamic typing can take getting used to if
    you have a background in other languages. It’s like learning how to speak a new
    human language: only with time and practice will you begin to think in the new
    tongue.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果你有其他语言的背景，使用 Python 风格的动态类型仍然需要一定的适应过程。这就像学习如何讲一种新的人类语言：只有随着时间的推移和练习，你才会开始用新语言思考。
- en: If all this is making your head swim, let me reiterate the single most important
    principles. Names have scope, but no type. Values have type, but no scope. A name
    can be bound to any value, and a value can be bound to any number of names. It
    really is that dead simple! If you remember that much, you’ll go a long way.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切让你感到困惑，我再重复一遍最重要的原则。名称有作用域，但没有类型。值有类型，但没有作用域。一个名称可以绑定到任何值，一个值可以绑定到任意数量的名称。真的是那么简单！只要记住这一点，你就会走得很远。
- en: '6'
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Functions and Lambdas
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和Lambda表达式
- en: '![](Images/chapterart.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Functions are one of the most elementary concepts in programming, yet Python
    packs a surprising amount of versatility into them. You’ll recall from Chapter
    3 that functions are first-class objects, so they are treated no differently from
    any other object. This fact, combined with the power of dynamic typing, opens
    up so many possibilities.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是编程中最基础的概念之一，但Python在其中融入了令人惊讶的多功能性。你会从第3章记得，函数是头等公民对象，因此它们与其他任何对象一样对待。这一事实，结合动态类型的强大功能，开辟了许多可能性。
- en: Python has full support for *functional programming*, a distinct paradigm from
    which we get those “lambdas,” or anonymous functions, you keep reading about online.
    If you’re used to languages like Haskell or Scala, a lot of the concepts in this
    chapter are going to seem familiar to you. However, if you’re more used to object-oriented
    programming, such as in Java or C++, this may be the first time you’ve encountered
    many of these concepts.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Python完全支持*函数式编程*，这是一个独特的编程范式，从中我们得到了那些你在网上经常看到的“lambda”或匿名函数。如果你习惯了Haskell或Scala这类语言，本章中的很多概念对你来说可能会很熟悉。然而，如果你更习惯于面向对象编程，如Java或C++，这可能是你第一次接触到这些概念。
- en: When learning Python, it makes sense to dive into functional programming early
    on. It is perfectly possible to write idiomatic Python code without ever creating
    a single class (see Chapter 7). By contrast, functions and functional programming
    concepts underpin much of the language’s most powerful features.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习Python时，尽早深入了解函数式编程是很有意义的。完全可以编写符合惯用法的Python代码而不创建任何类（见第7章）。相比之下，函数和函数式编程概念支撑了语言许多最强大的特性。
- en: Python Function Essentials
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python函数要点
- en: I briefly touched on functions in Chapter 3. Building on that knowledge, I’ll
    gradually construct a more complex example in this chapter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中我简要提到了函数。基于那部分知识，我将在本章中逐步构建一个更复杂的示例。
- en: 'I’ll start by creating a function that rolls a single die with a specified
    number of sides:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先创建一个函数，用于掷一个具有指定面数的骰子：
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 6-1: *dice_roll.py:1a*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-1: *dice_roll.py:1a*'
- en: I define a function named `roll_dice()`, which accepts a single parameter, `sides`.
    This function is considered pure, because it has no side effects; it accepts a
    value as an input and returns a new value as an output. I return a value from
    the function using the `return` keyword.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个名为`roll_dice()`的函数，它接受一个参数`sides`。这个函数被认为是纯函数，因为它没有副作用；它接受一个值作为输入，并返回一个新值作为输出。我使用`return`关键字从函数返回一个值。
- en: The `random` module has a number of functions for producing random values. Here,
    I use its `random.randint()` function to generate a pseudorandom number in Python.
    I generate a random number between `1` and `20` (the value of `sides` in this
    example) inclusively, with `random.randint(1, 20)`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`random`模块有许多用于生成随机值的函数。在这里，我使用它的`random.randint()`函数在Python中生成一个伪随机数。我生成一个在`1`和`20`之间（此示例中的`sides`值）包含的随机数，使用`random.randint(1,
    20)`。'
- en: 'Here’s my usage for the function:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我使用该函数的方式：
- en: '[PRE54]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listing 6-2: *dice_roll.py:2a*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-2: *dice_roll.py:2a*'
- en: Later, I call the function and pass the value `20` as an argument ❶, so the
    function call is effectively the same as rolling a 20-sided die. The value that
    the first function call returns is bound to `player1`; the second call’s return
    is bound to `player2`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我调用该函数并传递值`20`作为参数❶，因此函数调用实际上就像是掷一个20面骰子。第一次函数调用返回的值绑定到`player1`；第二次调用的返回值绑定到`player2`。
- en: Because I defined `roll_dice()` as a function, I can use it as many times as
    I want. If I want to change its behavior, I only need to modify the function in
    the one place where it is defined, and every usage of that function will be affected.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我将`roll_dice()`定义为一个函数，所以可以根据需要多次使用它。如果我想改变它的行为，只需要修改定义它的地方，所有使用该函数的地方都会受到影响。
- en: 'Say I wanted to roll multiple dice at once and return the results in a tuple.
    I can rewrite the `roll_dice()` function to do that:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想一次性投掷多个骰子，并将结果返回为一个元组。我可以重写`roll_dice()`函数来实现这一点：
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Listing 6-3: *dice_roll.py:1b*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6-3: *dice_roll.py:1b*'
- en: To allow rolling multiple dice, the function accepts a second parameter, `dice`,
    which represents the number of dice being rolled. The first parameter, `sides`,
    still represents the number of sides on any one of the dice.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许投掷多个骰子，函数接受第二个参数`dice`，表示投掷的骰子数量。第一个参数`sides`仍然表示任何一个骰子的面数。
- en: The scary-looking line of code at the top of the function is a *generator expression*,
    which I’ll cover in Chapter 10. For now, you can take it for granted that I’m
    generating one random number for each die being rolled and packing the results
    in a tuple.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 函数顶部那行看起来可怕的代码是一个*生成器表达式*，我将在第10章讲解。现在你可以理所当然地认为，我为每个正在投掷的骰子生成一个随机数，并将结果打包到一个元组中。
- en: 'Since my function now has a second parameter in the function call, I pass two
    arguments:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我的函数现在在函数调用中有第二个参数，我传递了两个参数：
- en: '[PRE56]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 6-4: *dice_roll.py:2b*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-4: *dice_roll.py:2b*'
- en: The returned tuple can be *unpacked*, meaning each item in the tuple is bound
    to a name I can use to access the value. The number of names listed on the left
    (separated by commas) and the number of values in the tuple *must* match for this
    to work, or else Python will raise an error. (See Chapter 9 for more on unpacking
    and tuples.)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的元组可以*解包*，这意味着元组中的每一项都绑定到一个名称，我可以使用这个名称来访问对应的值。左侧列出的名称（以逗号分隔）和元组中的值的数量*必须*匹配，否则
    Python 会引发错误。（有关解包和元组的更多信息，请参见第9章。）
- en: Recursion
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: '*Recursion* occurs when a function calls itself. This can be helpful when you
    need to repeat the entire logic of a function but a loop is unsuitable or feels
    too cluttered, as in the upcoming example.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归*是指一个函数调用它自己。当你需要重复函数的整个逻辑，而循环不合适或者感觉太乱时，这种方法很有用，正如接下来的例子所示。'
- en: For example, returning to my dice-rolling function, I can accomplish the exact
    same result using recursion, instead of that generator expression I was using
    earlier (although in practice, the generator expression is usually considered
    more Pythonic).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回到我的掷骰子函数，我可以使用递归实现完全相同的结果，而不是之前使用的生成器表达式（尽管在实践中，生成器表达式通常被认为是更符合 Python 风格的做法）。
- en: '[PRE57]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 6-5: *dice_roll_recursive.py:1a*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-5: *dice_roll_recursive.py:1a*'
- en: I store the resulting roll for this function call in `roll`. Then, in the recursive
    call, I pass my `sides` parameter as is, while reducing the number of `dice` to
    roll by one, to account for the die I just rolled. Finally, I combine the tuple
    that is returned from that recursive function call with the result of the roll
    on this function call, and I return the resulting longer tuple.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个函数调用的结果存储在`roll`中。然后，在递归调用中，我直接传递`side`参数，同时将要投掷的`dice`数量减去1，以便考虑到我刚刚投掷的骰子。最后，我将从递归函数调用返回的元组与当前函数调用的投掷结果合并，返回得到的更长元组。
- en: 'The usage is essentially the same as before:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法与之前基本相同：
- en: '[PRE58]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 6-6: *dice_roll_recursive.py:2a*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-6: *dice_roll_recursive.py:2a*'
- en: 'If you were to print out each value being returned, in order from deepest recursive
    call to outermost, here’s what you would see:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按顺序打印出每个返回的值，从最深的递归调用到最外层调用，你将看到以下内容：
- en: '[PRE59]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 6-7: Returns from recursive calls to `roll_dice(6, 5)`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-7: 从递归调用返回的`roll_dice(6, 5)`结果'
- en: When the number of dice left is zero or negative, I return an empty tuple instead
    of recursively calling it again. If I don’t do that, the recursion will try to
    run forever. Thankfully, Python will pull the plug at some point and just crash
    the program, instead of letting it consume all your computer’s memory (as some
    other programming languages are apt to do). The *recursion depth* is how many
    recursive function calls have not returned yet, and Python caps it at approximately
    one thousand.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当剩下的骰子数量为零或负数时，我返回一个空元组，而不是再次递归调用它。如果我不这样做，递归会永远执行下去。幸运的是，Python 会在某个时候强制停止并崩溃程序，而不是让它占用你所有计算机的内存（正如一些其他编程语言可能会发生的情况）。*递归深度*是指尚未返回的递归函数调用的数量，Python
    将其限制为大约一千次。
- en: 'If the recursion depth goes any deeper than the limit, the entire program stops
    and raises an error:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递归深度超过限制，整个程序会停止并引发错误：
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is why it’s so important that you build some means of stopping when you
    use recursion. In the `roll_dice` function, this stopping mechanism is at the
    very top of the function:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在使用递归时，建立停止机制如此重要。在 `roll_dice` 函数中，这个停止机制位于函数的最顶部：
- en: '[PRE61]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Since `dice` is getting decremented every time the function calls itself, sooner
    or later, it will reach zero. When it does, it returns an empty tuple, instead
    of producing another recursive call. Then, the rest of the recursive calls can
    finish running and return.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次函数调用时 `dice` 都会递减，迟早它会达到零。当它达到零时，函数返回一个空元组，而不是再进行一次递归调用。然后，其余的递归调用可以完成并返回。
- en: 'There may be cases in which a recursion depth of a thousand is not enough.
    If you need more, you can override the maximum:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一些情况，递归深度达到一千仍然不够。如果你需要更多，可以覆盖最大递归深度：
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `sys.setrecursionlimit()` function allows you to set a new maximum recursion
    depth. In this case, my new limit is `2000`. The benefit of this approach is that
    once you no longer need your limit, you can set it back to the default so it can
    keep *other* recursive calls from getting out of hand.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.setrecursionlimit()` 函数允许你设置新的最大递归深度。在这个例子中，我的新限制是 `2000`。这种方法的好处是，一旦你不再需要这个限制，你可以将其恢复为默认值，从而避免
    *其他* 递归调用失控。'
- en: Default Argument Values
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数值
- en: 'You might imagine that I would need to roll a single die far more often than
    any other option. As it stands right now, I would have to manually specify that
    I only want to roll one 20-sided die:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，我会比任何其他选项更频繁地掷单个骰子。目前的做法是，我必须手动指定我只想掷一个 20 面骰：
- en: '[PRE63]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: I have to manually pass a `1` as the second argument of `roll_dice` to specify
    that I’m rolling a single die.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须手动传递 `1` 作为 `roll_dice` 的第二个参数，来指定我正在掷一个骰子。
- en: By the way, that trailing comma after `result` is how I unpack a single value
    from a single-item tuple, meaning the actual value of the only item in the tuple
    is now bound to `result`. (See Chapter 9 for more on unpacking.)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，`result` 后面的那个逗号是我从单元素元组中解包单个值的方式，这意味着元组中唯一元素的实际值现在被绑定到 `result`。 （有关解包的更多内容，请参见第
    9 章。）
- en: 'Since rolling a single die is likely the most common action I want to take
    with this function, I want to make it more convenient to use. I can use *default
    argument values* to accomplish this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于掷单个骰子可能是我最常执行的操作，我希望让它变得更加方便使用。我可以使用 *默认参数值* 来实现这一点：
- en: '[PRE64]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 6-8: *dice_roll.py:1c*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-8: *dice_roll.py:1c*'
- en: 'The `dice` parameter now has a default argument value of `1`. Thus, anytime
    I don’t specify the second argument, `dice` will use its default argument value.
    This makes it possible to use a simplified function call to roll a single six-sided
    die:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`dice` 参数现在有一个默认值 `1`。因此，每当我没有指定第二个参数时，`dice` 将使用其默认值。这使得可以使用简化的函数调用来掷一个六面骰：'
- en: '[PRE65]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If I do want to roll multiple dice, I can still pass that second argument:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我确实想要掷多个骰子，我仍然可以传递第二个参数：
- en: '[PRE66]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: When you specify a default argument value for a parameter, you are defining
    an *optional parameter*. Conversely, a parameter with no default argument value
    is a *required parameter*. You can have as many of each as you like, but you must
    list all required parameters *before* your optional parameters. Otherwise, the
    code won’t run.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为参数指定默认值时，你正在定义一个 *可选参数*。相反，没有默认值的参数是 *必需参数*。你可以根据需要列出任意数量的每种参数，但必须将所有必需参数列在
    *可选参数* 之前。否则，代码将无法运行。
- en: 'When using optional parameters, there is one significant trap lurking in the
    dark: default argument values are only evaluated once, when the function is defined.
    One place where this gets treacherous is when you’re using any mutable data type,
    such as a list. Consider this code for generating values in a Fibonacci sequence,
    which doesn’t quite work as expected:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选参数时，有一个重大陷阱需要注意：默认参数值只会在函数定义时评估一次。一个可能让人困惑的地方是，当你使用可变数据类型（例如列表）时。考虑一下这个生成斐波那契数列的代码，它并没有按预期工作：
- en: '[PRE67]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 6-9: *fibonacci.py:1a*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-9: *fibonacci.py:1a*'
- en: This is going to have a problem because the default argument value `[1, 1]`
    ❶ is evaluated when Python first processes the function definition, creating a
    single mutable list with the value `[1, 1]` in memory. That gets mutated on the
    first function call ❷ and then returned.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这里会出现一个问题，因为默认参数值 `[1, 1]` ❶ 会在 Python 首次处理函数定义时被评估，创建一个内存中值为 `[1, 1]` 的单一可变列表。这个列表在第一次函数调用时会被改变
    ❷ ，然后返回。
- en: 'This usage of the function shows the problem:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的用法展示了问题：
- en: '[PRE68]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 6-10: *fibonacci.py:2*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-10: *fibonacci.py:2*'
- en: Everything looks okay in the code, but it isn’t. `fib1` is now bound to the
    same mutable value as `series`, so any changes to `fib1` are reflected in the
    default argument value *for every function call*. The second function call mutates
    this list further.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来没问题，但实际上并不是。`fib1` 现在与 `series` 绑定到了相同的可变值，因此对 `fib1` 的任何更改都会反映到每次函数调用的默认参数值中。第二次函数调用进一步改变了这个列表。
- en: 'When I call `fibonacci_next()` a third time, I’m probably expecting to start
    with a clean slate, `[1, 1, 2]`, which would be the result of a single mutation
    on the original default argument value. Instead, I’m getting the value of that
    single mutable value I’ve been messing with this whole time: `fib2` is now a third
    alias to the list. Oops!'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第三次调用 `fibonacci_next()` 时，我可能期望从一个干净的状态开始，即 `[1, 1, 2]`，这是对原始默认参数值进行一次变异后的结果。然而，实际上，我得到的是我一直在弄乱的那个可变值：`fib2`
    现在是该列表的第三个别名。哎呀！
- en: 'This becomes apparent when I examine the output. This is what I’d be expecting:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当我检查输出时，这一点变得显而易见。这是我期望的结果：
- en: '[PRE69]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'But this is what I actually get:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是我实际得到的结果：
- en: '[PRE70]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In short, *never use mutable values for default argument values*. Instead,
    use `None` as a default value, as shown in the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，*绝不使用可变值作为默认参数值*。相反，使用 `None` 作为默认值，如下所示：
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 6-11: *fibonacci.py:1b*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-11: *fibonacci.py:1b*'
- en: The proper way is to use `None` as the default argument value, and then to create
    a new mutable value if that default is being used.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的做法是使用 `None` 作为默认参数值，然后如果使用了这个默认值，就创建一个新的可变值。
- en: 'Running that same usage code as before ([Listing 6-9](#listing6-9)) now produces
    the expected output:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述运行相同的代码（[列表 6-9](#listing6-9)）现在会生成预期的输出：
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Keyword Arguments
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键字参数
- en: Readability matters. Unfortunately, function calls with multiple parameters
    aren’t always the most readable bits of code. *Keyword arguments* help resolve
    this by attaching labels to arguments in function calls.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性很重要。不幸的是，带有多个参数的函数调用并不总是最易读的代码片段。*关键字参数*通过为函数调用中的参数附加标签来帮助解决这个问题。
- en: Arguments that are mapped to their parameters by the order you pass them in,
    like in all the prior examples, are called *positional arguments*.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 按传递顺序映射到其参数的参数，像之前所有的示例一样，被称为*位置参数*。
- en: If you knew nothing about the `roll_dice()` function from earlier and you encountered
    this line of code, what would you think it did?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对之前的 `roll_dice()` 函数一无所知，而你遇到了这一行代码，你会认为它做了什么？
- en: '[PRE73]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Listing 6-12: *dice_roll.py:3a*'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-12: *dice_roll.py:3a*'
- en: You would probably guess that this is rolling multiple dice, and perhaps that
    it is specifying how many sides those dice have—but which is which? Is it rolling
    six five-sided dice or five six-sided dice? You can imagine how confusing this
    would be with even more arguments. This is the shortcoming of positional arguments.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会猜测这是在掷多个骰子，也许它在指定骰子的面数——但哪一个是哪个呢？是掷六个五面骰子，还是五个六面骰子？你可以想象，如果有更多的参数，这将会有多么困惑。这就是位置参数的短处。
- en: 'As The Zen of Python says:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 正如《Python之禅》中所说：
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面对模糊性时，拒绝猜测的诱惑。
- en: 'It can’t be good, then, to force the reader to guess. I can eliminate the ambiguity
    by using *keyword arguments*. I don’t need to change the function definition at
    all to be able to use keyword arguments. I only need to change my function call:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，强迫读者猜测肯定不好。我可以通过使用*关键字参数*来消除这种模糊性。我不需要修改函数定义就能使用关键字参数。我只需要修改我的函数调用：
- en: '[PRE74]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Listing 6-13: *dice_roll.py:3b*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-13: *dice_roll.py:3b*'
- en: 'Each of those names comes from the earlier function definition of `roll_dice`,
    where I specified it had two parameters: `sides` and `dice`. In my function call,
    I can assign values directly to those parameters by name. Now, there is no question
    about what each argument does. Specify the name of the parameter, matching what
    is in the function definition, and then assign the desired value directly to it.
    That’s all.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称来自于之前 `roll_dice` 函数的定义，我在定义时指定了它有两个参数：`sides` 和 `dice`。在我的函数调用中，我可以通过名称直接为这些参数赋值。现在，关于每个参数的作用就没有疑问了。指定参数的名称，与函数定义中的名称匹配，然后将所需的值直接赋给它。这就完成了。
- en: 'When using keyword arguments, you don’t even have to list them in order, just
    as long as all the required parameters receive values:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字参数时，你甚至不需要按顺序列出它们，只要所有必需的参数都获得了值：
- en: '[PRE75]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 6-14: *dice_roll.py:3c*'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-14: *dice_roll.py:3c*'
- en: 'This can be even more helpful when you have multiple optional parameters on
    the function. Consider if I rewrote `roll_dice()` so that the dice being rolled
    were six sided, by default:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数有多个可选参数时，这种方法会更加有用。假设我重写了`roll_dice()`函数，使得掷出的骰子默认是六面：
- en: '[PRE76]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Listing 6-15: *dice_roll.py:1d*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-15：*dice_roll.py:1d*
- en: 'Keyword arguments allow you to simplify your function calls even further:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数让你进一步简化函数调用：
- en: '[PRE77]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Listing 6-16: *dice_roll.py:3d*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-16：*dice_roll.py:3d*
- en: You’re only passing a value to one of the optional arguments, `dice`. For the
    other one, `sides`, the default value is used. It no longer needs to matter whether
    `sides` or `dice` appears first in the function’s parameter list; you can just
    use the ones you want and leave the rest alone.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你只向其中一个可选参数`dice`传递了一个值。对于另一个参数`sides`，则使用默认值。这样，`sides`或`dice`在函数参数列表中出现的顺序就不再重要；你只需要使用你想要的那个，其它的可以忽略。
- en: 'It is even possible to mix and match positional arguments and keyword arguments:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以将位置参数和关键字参数混合使用：
- en: '[PRE78]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Listing 6-17: *dice_roll.py:3e*'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-17：*dice_roll.py:3e*
- en: Here, `6` is passed as a positional argument to the first parameter in the function
    definition, `sides`. Then, I pass `5` as a keyword argument to the parameter `dice`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`6`作为位置参数传递给函数定义中的第一个参数`sides`。然后，我将`5`作为关键字参数传递给参数`dice`。
- en: This can come in handy, particularly when you don’t want to bother with naming
    the positional arguments but you still want to use one of many possible optional
    parameters. The only rule here is that your keyword arguments must come after
    your positional arguments in the function call. (See also the section “Keyword-Only
    Parameters” later in the chapter.)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某些情况下特别有用，尤其是当你不想麻烦地命名位置参数，但又想使用多个可选参数中的某一个时。唯一的规则是，关键字参数必须在函数调用中的位置参数后面传递。（也请参阅本章稍后的“仅限关键字参数”部分。）
- en: On Overloaded Functions
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于重载函数
- en: If you’re coming from a strictly typed language such as Java or C++, you’re
    probably used to writing *overloaded functions*, wherein you can write multiple
    functions with the same name but different parameters. Typically, overloaded functions
    in languages that support them provide a consistent interface (function name),
    while supporting arguments of different types.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自像 Java 或 C++ 这样严格类型的语言，你可能已经习惯了编写*重载函数*，在这些语言中你可以编写多个具有相同名称但不同参数的函数。通常，支持重载的语言中的重载函数提供一致的接口（函数名称），同时支持不同类型的参数。
- en: Python usually doesn’t need overloaded functions. Using dynamic typing, duck
    typing, and optional parameters, you can write single functions that handle all
    the input scenarios you need to throw at Python.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通常不需要重载函数。通过动态类型、鸭子类型和可选参数，你可以编写单一函数来处理所有你需要传递给 Python 的输入场景。
- en: If you really, really need overloaded functions—and you probably don’t—you actually
    can create them with *single-dispatch functions*. I’ll cover this in Chapter 15.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的、真的需要重载函数——不过你可能并不需要——你实际上可以通过*单 dispatch 函数*来创建它们。我将在第 15 章介绍这个话题。
- en: Variadic Arguments
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变长参数
- en: With the skills discussed so far, even while using optional parameters, you
    still have to anticipate how many arguments can potentially get passed to your
    function. This is fine in most cases, but sometimes, you’ll have no idea how many
    to expect.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 使用到目前为止讨论的技巧，即使是使用可选参数，你仍然需要预估可能会传递给函数的参数数量。这在大多数情况下没问题，但有时你根本无法知道会传递多少参数。
- en: To solve this, your first instinct might be to pack all the arguments into a
    single tuple or a list. That works in some situations, but other times, it can
    become an extra inconvenience when calling the function.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你的第一反应可能是将所有参数打包成一个元组或列表。在某些情况下这是可行的，但在其他时候，这可能在调用函数时变得更加麻烦。
- en: 'A better solution is to use *arbitrary arguments lists*, also called *variadic
    arguments*, which automatically pack multiple arguments into a single *variadic
    parameter* or *variadic positional parameter*. In the dice-rolling function, I
    want to allow the rolling of multiple dice, where each die may have a different
    number of sides:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是使用*任意参数列表*，也叫*变长参数*，它可以自动将多个参数打包到一个*变长参数*或*变长位置参数*中。在掷骰子函数中，我希望能够让用户掷多个骰子，每个骰子可能有不同数量的面：
- en: '[PRE79]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Listing 6-18: *dice_roll_variadic.py:1a*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-18：*dice_roll_variadic.py:1a*
- en: I turn the parameter `dice` into a variadic parameter by preceding it with a
    single asterisk (`*`). All the arguments passed to `roll_dice` will now be packed
    into a tuple, bound to the name `dice`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过在参数`dice`前加一个星号（`*`）将其转换为变参。所有传递给`roll_dice`的参数现在都将被打包成一个元组，并绑定到`dice`这个名字上。
- en: Within the function, I can use this tuple in the usual manner. In this case,
    I’m using a generator expression (see Chapter 10) to roll each die specified in
    `dice`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我可以像往常一样使用这个元组。在这个例子中，我使用一个生成器表达式（见第10章）来掷出`dice`中指定的每个骰子。
- en: 'The placement of the variadic parameter is important: it must come *after*
    any positional parameters in the function definition. Any parameters I list after
    it will only be usable as keyword arguments, because the variadic parameter consumes
    all the remaining positional arguments.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 变参的位置很重要：它必须出现在任何位置参数之后。任何我列出的参数都只能作为关键字参数使用，因为变参会消耗掉所有剩余的位置参数。
- en: 'Here’s my usage:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的使用方式：
- en: '[PRE80]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Listing 6-19: *dice_roll_variadic.py:2*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-19: *dice_roll_variadic.py:2*'
- en: 'In both function calls, I’m listing the dice I want to roll, with the number
    representing the number of sides of each die. In the first call, I’m rolling five
    six-sided dice. In the second call, I’m rolling four dice: a 20-sided die, a 6-sided
    die, an 8-sided die, and a 4-sided die.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个函数调用中，我列出了我要掷出的骰子，每个骰子的数字表示该骰子的面数。在第一次调用中，我掷出了五个六面骰。在第二次调用中，我掷出了四个骰子：一个20面骰，一个6面骰，一个8面骰，和一个4面骰。
- en: 'If I wanted to use the recursive approach, I’d populate the argument list by
    automatically unpacking that tuple into the function call:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想使用递归方法，我会通过自动解包元组来填充参数列表：
- en: '[PRE81]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Listing 6-20: *dice_roll_variadic.py:1b*'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-20: *dice_roll_variadic.py:1b*'
- en: Most of this code is going to look similar to the earlier recursive version.
    The most significant change is in what I’m passing to the recursive function call.
    The asterisk (`*`) in front of the name unpacks the tuple `dice` into the argument
    list ❶. I already processed the first item in the list, so I use the slice notation
    `[1:]` to remove that first item ❷ (see Chapter 9), to ensure it isn’t processed
    again.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码大部分与之前的递归版本相似。最显著的变化是我传递给递归函数调用的内容。在名字前加上的星号（`*`）会将元组`dice`解包成参数列表 ❶。我已经处理了列表中的第一个项，因此使用切片表示法`[1:]`移除第一个项
    ❷（见第9章），以确保它不会再次被处理。
- en: Keyword Variadic Arguments
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键字变参
- en: To capture an unknown number of *keyword arguments*, precede the parameter name
    with *two* asterisks (`**`), making the parameter a *keyword variadic parameter*.
    The keyword arguments passed to the function are packed into a single dictionary
    object, so as to preserve the association between keyword and value. They are
    similarly unpacked by being preceded with two asterisks.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获一个未知数量的*关键字参数*，在参数名之前加上*两个*星号（`**`），将参数变为*关键字变参*。传递给函数的关键字参数将被打包成一个字典对象，以便保持关键字和对应值之间的关联。它们也可以通过在前面加上两个星号来解包。
- en: This doesn’t show up very often in the wild. After all, if you didn’t know what
    the arguments were named, it would be hard to use them.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在实际应用中并不常见。毕竟，如果你不知道参数的名称，使用它们会比较困难。
- en: 'One case where keyword variadic arguments are commonly useful is in blindly
    relaying arguments to another function call:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字变参常见的一个使用场景是在盲目地将参数传递给另一个函数调用时：
- en: '[PRE82]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 6-21: *variadic_relay.py:1*'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-21: *variadic_relay.py:1*'
- en: The `call_something_else()` function has one positional argument, `func`, where
    I’ll pass a *callable* object, such as another function. The second parameter,
    `args`, is a variadic parameter for capturing all the remaining positional arguments.
    Last is the keyword variadic parameter, `kwargs`, for capturing any keyword arguments;
    sometimes, the name `kw` is used instead. Remember, either of these can be empty
    and this code will still work.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_something_else()`函数有一个位置参数`func`，我会传递一个*可调用的*对象，例如另一个函数。第二个参数`args`是一个变参，用于捕获所有剩余的位置参数。最后是关键字变参`kwargs`，用于捕获任何关键字参数；有时也使用`kw`作为名称。记住，这些参数可以为空，代码仍然可以正常运行。'
- en: You can check whether an object is callable by passing it to the `callable()`
    function.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将对象传递给`callable()`函数来检查它是否是可调用的。
- en: The names `args` and `kwargs` are conventionally used for positional variadic
    and keyword variadic parameters, respectively. However, if you can think of names
    that better fit your particular situation, that’s certainly acceptable!
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`args`和`kwargs`这两个名称通常用于位置可变参数和关键字可变参数。然而，如果你能想到更适合特定情况的名称，当然是可以的！'
- en: When the function calls the callable object `func`, it first unpacks all the
    positional arguments that were captured, and then it unpacks all the keyword arguments.
    The function code doesn’t need any knowledge of the callable object’s parameter
    list; instead, any and every argument passed to `call_something_else()` after
    that first positional argument will get blindly passed on.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数调用可调用对象`func`时，它首先解包所有捕获的位置信息参数，然后解包所有关键字参数。函数代码不需要知道可调用对象的参数列表；相反，在第一个位置参数之后传递给`call_something_else()`的每一个参数都会被盲目传递下去。
- en: 'You can see this in action here:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到它的实际效果：
- en: '[PRE83]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Listing 6-22: *variadic_relay.py:2*'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-22: *variadic_relay.py:2*'
- en: 'When I run that code, the `call_something_else()` function will call `say_hi()`,
    passing the argument `name="Bob"` to it. That produces the following output:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这段代码时，`call_something_else()`函数将调用`say_hi()`，并将参数`name="Bob"`传递给它。结果会输出如下：
- en: '[PRE84]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This bit of magic will come back into play shortly in writing *decorators* (see
    the section “Decorators” later in this chapter).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这一段魔法将在编写*装饰器*时再次派上用场（参见本章稍后的“装饰器”部分）。
- en: Keyword-Only Parameters
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅限关键字参数
- en: You can use variadic parameters to turn some of your keyword parameters into
    *keyword-only parameters*, which were introduced in PEP 3102\. These parameters
    cannot have values passed in as positional arguments, but rather only as keyword
    arguments. This can be especially useful in ensuring that particularly long or
    perilous parameter lists are used in the proper manner, instead of as nigh-on
    unreadable chains of positional arguments.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用可变参数将某些关键字参数变成*仅限关键字参数*，这一特性在PEP 3102中引入。这些参数不能作为位置参数传入值，只能作为关键字参数传递。这对于确保特别长或者容易出错的参数列表被正确使用非常有用，而不是变成几乎无法阅读的位置参数链。
- en: 'To demonstrate this, I’ll rewrite my `roll_dice()` function to have two keyword-only
    parameters:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将重写我的`roll_dice()`函数，使其具有两个仅限关键字的参数：
- en: '[PRE85]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Listing 6-23: *dice_roll_keyword_only.py:1*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-23: *dice_roll_keyword_only.py:1*'
- en: I use the unnamed variadic parameter `*`, which ensures every parameter that
    follows it in the list can only be accessed by name. If the caller passes in too
    many positional arguments (or in this case, *any* positional arguments), a `TypeError`
    is raised.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了未命名的可变参数`*`，它确保列表中随后的每个参数只能通过名称访问。如果调用者传入太多位置参数（或者在这种情况下，*任何*位置参数），将引发`TypeError`。
- en: 'This affects the usage, such that I can only use keyword arguments now:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这会影响用法，因此我现在只能使用关键字参数：
- en: '[PRE86]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Listing 6-24: *dice_roll_keyword_only.py:2*'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-24: *dice_roll_keyword_only.py:2*'
- en: 'Attempting to use positional arguments raises an error:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用位置参数会引发错误：
- en: '[PRE87]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Listing 6-25: *dice_roll_keyword_only.py:3*'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-25: *dice_roll_keyword_only.py:3*'
- en: Positional-Only Parameters
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置参数专用
- en: As of Python 3.8 (via PEP 570), it is also possible to define *positional-only
    parameters*. This is useful when the parameter name is either unhelpful or likely
    to be changed down the road, meaning any code using it as a keyword parameter
    would be likely to break in the future.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.8（通过 PEP 570）开始，也可以定义*仅限位置参数*。当参数名称不具备帮助性或可能会在未来改变时，这非常有用，因为任何将其用作关键字参数的代码可能会在未来出现故障。
- en: 'You’ll recall that positional parameters must always come first in the parameter
    list. Placing a forward slash (`/`) in the list designates all preceding parameters
    as positional-only:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记得，位置参数必须始终出现在参数列表的最前面。在列表中放置一个斜杠（`/`）可以将所有之前的参数指定为仅限位置参数：
- en: '[PRE88]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Listing 6-26: *dice_roll_positional_only.py:1*'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-26: *dice_roll_positional_only.py:1*'
- en: 'In this example, the parameter `dice` still has a default value of `1`, but
    it is now positional-only. On the other hand, `sides` can be used as either a
    positional or a keyword parameter. Here’s that behavior in action:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，参数`dice`仍然有默认值`1`，但现在它是仅限位置参数。另一方面，`sides`可以作为位置参数或关键字参数来使用。以下是该行为的实际效果：
- en: '[PRE89]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Listing 6-27: *dice_roll_positional_only.py:2*'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-27: *dice_roll_positional_only.py:2*'
- en: The first four examples all work, because the positional-only argument `dice`
    is either included as the first argument or omitted altogether. Any attempt to
    access `dice` by keyword fails with a `TypeError`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个示例都有效，因为位置参数`dice`要么作为第一个参数传入，要么完全省略。任何尝试通过关键字访问`dice`的操作都会因为`TypeError`而失败。
- en: 'Argument Types: All Together Now!'
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数类型：一起看！
- en: 'To ensure everything is clear regarding positional parameters and keyword parameters,
    I’ll take a moment to review with this (admittedly contrived) example:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保关于位置参数和关键字参数的一切都清晰，我将通过这个（虽然有些做作的）示例来回顾一下：
- en: '[PRE90]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The parameter `pos_only` is positional-only, as it comes before the forward-slash
    (`/`) marker. If I have any positional-only parameters, they must appear first
    in the list. Because this parameter has a default value, it is optional. However,
    if I wanted to pass an argument to it, it would need to be the first positional
    argument passed to the function; otherwise, a `TypeError` would be raised.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`pos_only`是仅限位置的，因为它位于前斜线（`/`）标记之前。如果我有任何位置参数，它们必须首先出现在列表中。由于这个参数有默认值，它是可选的。然而，如果我想传递一个参数给它，那么它必须是传递给函数的第一个位置参数；否则，程序会引发`TypeError`。
- en: Next is the `pos_kw` parameter, which can be either positional or keyword. It
    comes after any positional-only parameters and after the forward-slash (`/`) marker,
    if there is one.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`pos_kw`参数，它可以是位置参数也可以是关键字参数。如果有位置参数，仅限位置的参数和前斜线（`/`）标记之后，它会在任何位置参数之后出现。
- en: Finally, after the asterisk (`*`) marker, I have `kw_only`, which is a keyword-only
    parameter. In this example, if my function receives more than two positional arguments,
    a `TypeError` will be raised.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在星号（`*`）标记之后，我有`kw_only`，这是一个仅限关键字的参数。在这个例子中，如果我的函数接收到两个以上的位置参数，就会引发`TypeError`。
- en: Nested Functions
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套函数
- en: From time to time, you may want to reuse a piece of logic *within* a function
    but not clutter up your code by making yet another function. In this situation,
    you can nest functions within other functions.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想要在一个函数内部重用某段逻辑，但又不想通过再创建一个函数来让代码变得混乱。在这种情况下，你可以将函数嵌套在其他函数内部。
- en: 'I can use this to improve the recursive version of `roll_dice()`, making the
    logic for rolling a single die into something more reusable in the function:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以利用这个来改进递归版本的`roll_dice()`，将掷单个骰子的逻辑做得更加可重用：
- en: '[PRE91]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Listing 6-28: *dice_roll_recursive.py:1b*'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-28: *dice_roll_recursive.py:1b*'
- en: In this example, I moved the logic for rolling a single die into a nested function
    `roll()`, which I can call from anywhere in the function `roll_dice()`. The direct
    benefit of abstracting out this logic is that it can be maintained more easily,
    without disrupting the rest of the code.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我将掷一个骰子的逻辑移动到了一个嵌套函数`roll()`中，我可以从`roll_dice()`函数的任何地方调用它。抽象出这个逻辑的直接好处是，它可以更容易地维护，而不会打乱其余的代码。
- en: 'Here’s the usage:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用示例：
- en: '[PRE92]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Listing 6-29: *dice_roll_recursive.py:2b*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-29: *dice_roll_recursive.py:2b*'
- en: That produces the usual random output.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成常规的随机输出。
- en: In production, I’d rarely use a nested function for something that trivial.
    Normally, I’d employ a nested function for more complex logic that sees frequent
    reuse, especially if it is used in multiple places in the outer function.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，我很少会为如此简单的事情使用嵌套函数。通常，我会为更复杂的逻辑使用嵌套函数，尤其是当逻辑被频繁重用时，尤其是当它在外部函数的多个地方使用时。
- en: You’ll recall from Chapter 5 that the nested function can access the names of
    its enclosing scope. However, if I wanted to rebind or mutate any of those names
    from within the nested function, I’d need to use the `nonlocal` keyword.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该还记得第五章中提到的，嵌套函数可以访问其外部作用域中的变量。然而，如果我想在嵌套函数内部重新绑定或修改这些变量，我需要使用`nonlocal`关键字。
- en: Closures
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: You can create a function that builds and returns a kind of function called
    a *closure*, which encloses one or more nonlocal names. This pattern acts as a
    sort of “function factory.”
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个函数，构建并返回一种名为*闭包*的函数，它封闭一个或多个非局部名称。这个模式就像是一种“工厂函数”。
- en: 'Building on the dice example, I’ll write a function that returns a *closure*
    for rolling a particular set of dice:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在骰子示例的基础上，我将编写一个函数，返回一个*闭包*，用于掷特定的一组骰子：
- en: '[PRE93]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Listing 6-30: *dice_cup_closure.py:1*'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-30: *dice_cup_closure.py:1*'
- en: I create the function `make_dice_cup()`, which accepts the arguments for `sides`
    and `dice`. Inside `make_dice_cup()`, I define a nested function `roll()`, which
    uses `sides` and `dice`. When that nested function is returned by the outer function
    (no parentheses!) ❶, it becomes a closure, because it encloses `sides` and `dice`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了函数`make_dice_cup()`，它接受`骰子面数（sides）`和`骰子数量（dice）`作为参数。在`make_dice_cup()`内部，我定义了一个嵌套函数`roll()`，它使用了`sides`和`dice`。当这个嵌套函数被外部函数返回时（没有括号！）❶，它成为一个闭包，因为它包含了`sides`和`dice`。
- en: '[PRE94]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Listing 6-31: *dice_cup_closure.py:2*'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-31: *dice_cup_closure.py:2*'
- en: I bind the closure returned by `make_dice_cup()` to the name `roll_for_damage`,
    which I can now call as a function without any arguments. The closure continues
    to use `sides` and `dice` with the values I specified earlier to roll dice and
    return values; it is now a function in its own right.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`make_dice_cup()`返回的闭包绑定到名字`roll_for_damage`，现在我可以像调用一个函数一样调用它，而无需任何参数。该闭包继续使用我之前指定的`sides`和`dice`的值来掷骰子并返回结果；它现在已经成为一个独立的函数。
- en: Caution is necessary when using closures, as you can easily violate the rules
    of functional programming with them. If a closure has the ability to mutate the
    values it encloses, it becomes a sort of de facto object, and a difficult one
    to debug at that!
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包时需要小心，因为你很容易违反函数式编程的规则。如果一个闭包能够修改它所包含的值，它就变成了一个事实上的对象，而且还是一个非常难调试的对象！
- en: Recursion with Closures
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归与闭包
- en: The previous closure example didn’t use the recursive form of the dice-rolling
    code because, while it’s possible to implement such closure correctly, it’s even
    easier to do it wrong.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个闭包示例没有使用递归形式的掷骰子代码，因为尽管实现这种闭包是可能的，但错误地实现它更为简单。
- en: 'Here’s the most apparently obvious, yet wrong, way to make that closure recursive:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最明显但错误的方式来实现递归闭包：
- en: '[PRE95]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Listing 6-32: *dice_cup_closure_recursive.py:1a*'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-32: *dice_cup_closure_recursive.py:1a*'
- en: Using what you know about names and scope so far, can you anticipate what’s
    wrong with the above?
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你目前对变量名和作用域的理解，你能预见到上述代码的问题吗？
- en: 'The giveaway that something is wrong with the closure is the keyword `nonlocal`,
    as it indicates I’m mutating or rebinding a nonlocal name: `dice`.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 说明闭包出问题的关键字是`nonlocal`，因为它表明我正在修改或重新绑定一个非局部变量：`dice`。
- en: 'Attempting to use this closure will reveal the problem:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这个闭包时会暴露出问题：
- en: '[PRE96]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Listing 6-33: *dice_cup_closure_recursive.py:2*'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-33: *dice_cup_closure_recursive.py:2*'
- en: 'That code produces the following output (for example):'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码会产生以下输出（例如）：
- en: '[PRE97]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The first time the closure `roll_for_damage()` is used, everything is fine.
    However, `dice` isn’t reset when the function exits, so all subsequent calls to
    the closure find that `dice == 0`. Thus, they only return `()`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包`roll_for_damage()`第一次使用时，一切正常。然而，当函数退出时，`dice`没有被重置，所以随后的所有闭包调用发现`dice ==
    0`。因此，它们只会返回`()`。
- en: 'To write a recursive closure, you need to use an optional parameter on the
    closure:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写递归闭包，你需要在闭包中使用一个可选参数：
- en: '[PRE98]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Listing 6-34: *dice_cup_closure_recursive.py:1b*'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-34: *dice_cup_closure_recursive.py:1b*'
- en: In this version, I use the nonlocal name `dice` as the default value of the
    new, local parameter `dice`. (Recall, this will only work with immutable types.)
    This behaves precisely as expected, as it still closes over `sides` and the nonlocal
    `dice`, but it rebinds neither.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我使用非局部变量`dice`作为新本地参数`dice`的默认值。（请记住，这仅适用于不可变类型。）它的行为完全符合预期，因为它仍然闭包了`sides`和非局部变量`dice`，但并没有重新绑定它们。
- en: Stateful Closures
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有状态的闭包
- en: While it is generally best to write closures as pure functions, it is occasionally
    useful to create a *stateful closure*—that is, a closure that retains a little
    bit of state between calls that it can use. In general, you should avoid using
    stateful closures unless no other solution presents itself.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常最好将闭包写成纯函数，但有时创建一个*有状态的闭包*是有用的——即一个在调用之间保持一些状态的闭包，供后续使用。通常，除非没有其他解决方案，否则你应该避免使用有状态的闭包。
- en: 'Just to demonstrate this, I’ll create a stateful closure that limits how many
    times a player can reroll a group of dice:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将创建一个有状态的闭包，限制玩家可以重新掷骰子的次数：
- en: '[PRE99]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Listing 6-35: *dice_roll_turns.py:1*'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-35: *dice_roll_turns.py:1*'
- en: I write the closure `roll()` so that it only allows the caller to reroll the
    dice a maximum number of times, specified by `limit`, before the function starts
    returning `None`. By this design, after the limit is reached, a new closure must
    be created. The logic of tracking how many times a player can roll the dice has
    been abstracted out into the closure.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了闭包 `roll()`，使得它只允许调用者在指定的 `limit` 次数内重新掷骰子，超过次数后，函数开始返回 `None`。通过这种设计，在达到限制后，必须创建一个新的闭包。追踪玩家能掷骰子多少次的逻辑已经被抽象到闭包中了。
- en: This closure is very limited and predictable in how it mutates and uses its
    state. It’s important to limit your closures in this way, since debugging a stateful
    closure can be difficult. There is no way to see the current value of `limit`
    from outside the closure; it’s simply not possible.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这个闭包在变更和使用其状态时非常有限且可预测。重要的是要以这种方式限制你的闭包，因为调试一个有状态的闭包可能会非常困难。从闭包外部无法查看 `limit`
    的当前值；这根本是不可能的。
- en: 'You can see this predictable behavior at work in the usage:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的用法中看到这种可预测的行为：
- en: '[PRE100]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Listing 6-36: *dice_roll_turns.py:2*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-36: *dice_roll_turns.py:2*'
- en: 'Running that code produces the following randomized output, wherein each turn
    gets three tosses of the dice; each toss is represented by a tuple:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会产生以下随机化的输出，每次回合都会进行三次骰子投掷；每次投掷都由一个元组表示：
- en: '[PRE101]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: A stateful closure can be useful in situations where writing an entire class
    (see Chapter 7) brings in too much boilerplate. Since I only have one piece of
    state, `limit`, and I am using it predictably, this approach is acceptable. Anything
    more complicated, and debugging becomes impractically difficult.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的闭包在编写一个完整类（参见第7章）会引入过多模板代码的情况下非常有用。由于我只有一个状态 `limit`，并且我以可预测的方式使用它，这种方法是可以接受的。任何更复杂的情况，调试起来就变得不切实际了。
- en: As I pointed out earlier, anytime you see `nonlocal` in a closure, you should
    be extra cautious, as it indicates the presence of state. This can be acceptable
    on occasion, but there is usually a better approach. Stateful closures are not
    pure functional programming!
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，每当你在闭包中看到 `nonlocal` 时，你应该格外小心，因为这表示有状态的存在。偶尔这种情况是可以接受的，但通常会有更好的方法。有状态的闭包并不是纯粹的函数式编程！
- en: Lambdas
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: 'A *lambda* is an anonymous (nameless) function made up of a single expression.
    The structure is as follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda* 是一个匿名（无名）函数，由一个单一的表达式构成。其结构如下：'
- en: '[PRE102]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: On the left side of the colon is the parameter list, which may be omitted if
    you don’t want to accept any arguments. On the right is the return expression,
    which is evaluated when the lambda is called and the result is implicitly returned.
    To use a lambda, you must bind it to a name, whether by assignment or by passing
    it as an argument to another function.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号左边是参数列表，如果你不想接受任何参数，可以省略。右边是返回表达式，它在 lambda 被调用时被求值，并且结果会被隐式返回。要使用 lambda，必须将其绑定到一个名字上，无论是通过赋值还是通过将其作为参数传递给另一个函数。
- en: 'For example, here’s a lambda that adds two numbers:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个将两个数字相加的 lambda 表达式：
- en: '[PRE103]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Listing 6-37: *addition_lambda.py*'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-37: *addition_lambda.py*'
- en: I bind the `lambda` to the name `add` and then call it as a function. This particular
    lambda accepts two arguments and then returns their sum.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 `lambda` 绑定到名字 `add` 上，然后像调用函数一样调用它。这个特定的 lambda 接受两个参数，并返回它们的和。
- en: Why Lambdas Are Useful
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么 Lambda 表达式有用
- en: Many programmers can’t imagine ever needing nameless functions. It would seem
    to make reuse completely impractical. After all, if you’re just going to bind
    a lambda to a name, shouldn’t you have just written a function?
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员难以想象自己会需要匿名函数。这似乎会让重用变得完全不切实际。毕竟，如果你只是打算将一个 lambda 绑定到一个名字，难道你应该直接写一个函数吗？
- en: 'To understand how lambdas can be useful, let’s take a look at an example *without*
    lambdas first. This code represents a player character in a basic text adventure
    game:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 lambda 表达式如何有用，我们首先来看一个没有 lambda 的示例。以下代码表示一个基础文字冒险游戏中的玩家角色：
- en: '[PRE104]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Listing 6-38: *text_adventure_v1.py:1*'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-38: *text_adventure_v1.py:1*'
- en: 'I’m keeping track of my character’s stats in a couple of global names at the
    top, `health` and `xp`, which I’ll use throughout my program:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我在程序开头的几个全局变量 `health` 和 `xp` 中跟踪着我角色的状态，我将在整个程序中使用它们：
- en: '[PRE105]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Listing 6-39: *text_adventure_v1.py:2*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-39: *text_adventure_v1.py:2*'
- en: My `attempt()` function handles rolling the dice, using the outcome to decide
    whether the player’s action succeeded or failed, and then modifying the values
    of the global `health` and `xp` variables accordingly. It determines how those
    values should be changed, based on the value returned from calling the function
    passed to `outcome`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 我的`attempt()`函数负责掷骰子，使用结果来决定玩家的行动是否成功，然后根据结果修改全局`health`和`xp`变量的值。它根据调用传递给`outcome`函数的返回值来决定这些值应该如何变化。
- en: The part to focus on is the parameter `outcome` ❶—which, by its usage in `attempt()`
    ❷, should be a function that accepts a boolean value and returns a tuple of two
    integers representing the desired changes to `health` and `xp`, respectively.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 需要关注的部分是参数`outcome` ❶——根据`attempt()`中的使用 ❷，它应该是一个接受布尔值并返回一个包含两个整数的元组的函数，这两个整数分别表示期望的`health`和`xp`变化。
- en: 'Expanding on that example, I’ll use what I’ve built so far:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子的基础上，我将使用到目前为止所构建的内容：
- en: '[PRE106]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Listing 6-40: *text_adventure_v1.py:3a*'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-40: *text_adventure_v1.py:3a*'
- en: 'There’s no real pattern to the outcomes of each possible action, so I have
    to write functions for each one: in this example, `eat_bread()` and `fight_ice_weasel()`.
    Even this example is a bit oversimplified, as the code determining the outcome
    might involve a bunch of mathematics and randomization. Regardless, since I need
    a separate outcome function for each action, this code is going to grow rapidly,
    leading to a maintainability nightmare.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可能动作的结果没有固定的模式，因此我必须为每个动作编写函数：在这个例子中，是`eat_bread()`和`fight_ice_weasel()`。即便如此，这个例子也有些过于简化，因为决定结果的代码可能涉及大量的数学运算和随机化。无论如何，由于每个动作需要一个独立的结果函数，代码量将会迅速增长，导致可维护性问题。
- en: (Be advised, the `if` statement above is not the most Pythonic way to write
    that code; I deliberately chose that structure to illustrate the logic.)
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，上面的`if`语句并不是最 Pythonic 的写法；我故意选择了这种结构来说明逻辑。）
- en: When I attempt an action ❶, I pass the string representing the action, the minimum
    dice roll necessary to succeed, and the function determining the outcome. When
    passing a function, remember not to include the trailing parentheses. Here, I
    want to pass the function itself, not the value it returns.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当我尝试执行一个动作 ❶ 时，我会传递表示该动作的字符串、成功所需的最小骰子点数，以及决定结果的函数。在传递函数时，记得不要包括结尾的括号。在这里，我想传递的是函数本身，而不是它返回的值。
- en: 'This sort of usage is where lambdas come in. I can replace the `eat_bread()`
    and `fight_ice_weasel()` functions, plus the two calls to `attempt()`, with just
    the following:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法就是 lambda 的优势所在。我可以用以下代码替代`eat_bread()`和`fight_ice_weasel()`函数，以及对`attempt()`的两次调用：
- en: '[PRE107]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Listing 6-41: *text_adventure_v1.py:3b*'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-41: *text_adventure_v1.py:3b*'
- en: 'The third argument of each is a lambda, which accepts a single parameter named
    `success` and returns a value depending on the value of `success`. Let’s isolate
    just that first lambda:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数的第三个参数是一个 lambda，它接受一个名为`success`的单一参数，并根据`success`的值返回不同的结果。我们先看一下第一个 lambda：
- en: '[PRE108]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: When the lambda is called, if the value of `success` is `True`, then `(1, 0)`
    will be returned. Otherwise, `(-1, 0)` is returned.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 当 lambda 被调用时，如果`success`的值为`True`，则返回`(1, 0)`。否则，返回`(-1, 0)`。
- en: That lambda is being passed to (and thus bound to) the `outcome` parameter of
    the `attempt()` function, and it is subsequently called with a single boolean
    argument.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 lambda 被传递给（并因此绑定到）`attempt()`函数的`outcome`参数，并随后使用一个布尔值作为参数进行调用。
- en: By using lambdas in this manner, I can create many different possible outcomes
    in my code with only one line of code.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式使用 lambda，我可以在代码中用一行代码创建多种不同的结果。
- en: Remember that *a lambda may only consist of a single return expression*! This
    makes lambdas suitable for short, clear fragments of logic, especially when the
    code is made more readable by keeping that logic close to its usage within another
    function call. If you want anything more complex, you’ll need to write a proper
    function.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*lambda 只能由单个返回表达式组成*！这使得 lambda 非常适合处理简短、清晰的逻辑片段，尤其是在代码通过将逻辑紧密放置在另一个函数调用中来提高可读性的情况下。如果你需要更复杂的逻辑，你就必须写一个正式的函数。
- en: Lambdas as Sorting Keys
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 lambda 作为排序键
- en: One of the most common situations where a lambda comes in handy is when specifying
    a *key function*, which is a callable that returns the part of a collection or
    object that should be used for sorting. A key function is typically passed to
    another function that is responsible for sorting data in some manner.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 函数最常用的情况之一是指定一个*键函数*，它是一个可调用的函数，返回集合或对象中应该用于排序的部分。键函数通常会传递给另一个负责以某种方式排序数据的函数。
- en: 'For example, here I have a list of tuples containing first and last names,
    and I want to sort the list by last name:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里我有一个包含名字和姓氏的元组列表，我想按姓氏对这个列表进行排序：
- en: '[PRE109]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Listing 6-42: *sort_names.py*'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-42: *sort_names.py*'
- en: The `sorted()` function uses the `key` argument ❶, which is always a function
    or other callable, by passing each item to it and then using the value returned
    from that callable to determine the sorting order. Since I want the tuples sorted
    by last name, which is the second item of each tuple, I have the lambda return
    that item, which is `x[1]`.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()` 函数使用 `key` 参数 ❶，它始终是一个函数或其他可调用对象，通过将每个项传递给它，然后使用该可调用对象返回的值来确定排序顺序。由于我希望按姓氏对元组进行排序，而姓氏是每个元组的第二项，因此我让
    lambda 返回该项，即 `x[1]`。'
- en: The end result is that `by_last_name` contains the list, sorted by last name.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，`by_last_name` 包含了按姓氏排序的列表。
- en: Decorators
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: '*Decorators* allow you to modify the behavior of a function (or even multiple
    functions) by wrapping it in an additional layer of logic. This changes the function’s
    behavior without you having to rewrite the function itself.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器* 允许你通过将其包装在额外的逻辑层中来修改函数（甚至多个函数）的行为。这改变了函数的行为，而无需你重新编写函数本身。'
- en: To demonstrate this, here’s another example with my text adventure game hero.
    I want to define multiple game events that affect the player character’s statistics
    in different ways, and I want those changes displayed as they happen. I’ll start
    with an implementation that doesn’t use decorators. This code only uses concepts
    I’ve already covered so far in this book, so I’ll mainly draw your attention to
    some inefficiencies.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，下面是另一个与我的文本冒险游戏英雄相关的示例。我想定义多个游戏事件，以不同的方式影响玩家角色的统计数据，并希望这些变化能够实时显示。我将从一个不使用装饰器的实现开始。此代码只使用了我在本书中已讲解的概念，所以我主要会关注一些低效的地方。
- en: 'I’ll start by defining my global variables:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从定义我的全局变量开始：
- en: '[PRE110]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Listing 6-43: *text_adventure_v2.py:1a*'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-43: *text_adventure_v2.py:1a*'
- en: 'Next, I’ll define functions for each action the player can take:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将定义玩家可以采取的每个动作的函数：
- en: '[PRE111]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Listing 6-44: *text_adventure_v2.py:2a*'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-44: *text_adventure_v2.py:2a*'
- en: Each function represents an action the player can take, and some common code
    is shared between these functions. First, each function checks the character’s
    health to determine if the character is even able to perform the action ❶ ❸. If
    the character’s health is sufficient, the player performs the action, which alters
    the character’s statistics. When the action is completed (or if the character’s
    health is too low to take an action), the current stats are displayed ❷ ❹.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数代表玩家可以采取的一个动作，并且这些函数之间共享一些公共代码。首先，每个函数会检查角色的健康状况，以确定角色是否能够执行该动作 ❶ ❸。如果角色的健康状况足够，玩家就会执行该动作，进而改变角色的统计数据。当动作完成后（或当角色的健康值不足以执行动作时），当前的统计数据会显示出来
    ❷ ❹。
- en: 'And then, of course, I have the usage:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当然，我有了使用方法：
- en: '[PRE112]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Listing 6-45: *text_adventure_v2.py:3*'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-45: *text_adventure_v2.py:3*'
- en: That works, but as I said, the repeated code in [Listing 6-44](#listing6-44)
    is not very Pythonic. Your first instinct might be to move the common code—the
    code that checks the health and displays the statistics—out into their own functions.
    However, you would still need to remember to call each one within *every character
    action function*, and they’re easy to overlook. Furthermore, each function would
    still need that conditional statement at the top to ensure the code isn’t run
    when health is too low.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以工作，但正如我所说，[列表 6-44](#listing6-44) 中重复的代码并不是很 Pythonic。你可能的第一反应是将公共代码——检查健康并显示统计数据的代码——移到它们自己的函数中。然而，你仍然需要记得在*每个角色动作函数*中调用它们，而且很容易忽视。此外，每个函数仍然需要在顶部加上那个条件语句，以确保当健康值过低时不会执行代码。
- en: This situation, where I want to run the same code before and after every function,
    can be perfectly solved with decorators.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况，即在每个函数执行前后都想运行相同的代码，可以通过装饰器完美解决。
- en: 'Here, I’ll create a decorator toward the top of the text adventure game code:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将创建一个装饰器，放在文本冒险游戏代码的顶部：
- en: '[PRE113]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Listing 6-46: *text_adventure_v2.py:1b*'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-46: *text_adventure_v2.py:1b*'
- en: A decorator is most often implemented as a closure, which closes over a function
    (or any other callable object) being modified. The decorator itself, `character_action()`,
    accepts a `func` parameter, which is the callable being modified.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器通常作为一个闭包实现，闭包会捕获被修改的函数（或其他任何可调用对象）。装饰器本身，`character_action()`，接受一个`func`参数，这个`func`就是被修改的可调用对象。
- en: Within the decorator definition is the *wrapper*, which is the callable where
    the decorator’s logic lives ❸. As I said, most commonly, the closure pattern is
    used for this. However, the wrapper can be implemented with any callable, including
    a class. (Technically, I could even implement the wrapper as a noncallable, but
    this is seldom, if ever, useful.)
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器定义内部有一个*包装器*，它是装饰器逻辑所在的可调用对象 ❸。正如我所说，最常见的是使用闭包模式实现。但包装器也可以使用任何可调用对象来实现，包括类。（从技术上讲，我甚至可以将包装器实现为非可调用对象，但这几乎从来没有什么实际用途。）
- en: Because I don’t know how many arguments will be passed to any function I’ll
    apply the decorator to, I set up the wrapper to accept variadic arguments.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我不知道会传递多少个参数给任何应用装饰器的函数，所以我将包装器设置为接受变长参数。
- en: The `@functools.wraps(func)` line ❷ prevents the callable being wrapped from
    having its identity concealed from the rest of the program. Without that line,
    wrapping the callable would mess up external access of such important function
    attributes as `__doc__` (the docstring) and `__name__`. This line is itself a
    decorator that ensures all the important attributes of the callable are retained
    by the now-wrapped function, thus making them accessible outside the function
    in all the usual ways. (To use that special decorator, I must import `functools`
    first ❶.)
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`@functools.wraps(func)` 这一行 ❷ 可以防止被包装的可调用对象在程序其他地方被隐藏其身份。如果没有这一行，包装可调用对象会导致程序无法访问到一些重要的函数属性，比如
    `__doc__`（文档字符串）和 `__name__`。这一行本身就是一个装饰器，确保被包装的函数保留所有重要的属性，从而使这些属性在外部也可以正常访问。（为了使用这个特殊装饰器，我必须先导入
    `functools` ❶。）'
- en: Inside the wrapper, I put all that logic I want to run before and after each
    function. After checking `health`, I call the function that is bound to `func`,
    unpacking all the variadic arguments into the call. I also bind the return value
    to `result`, so I can ensure that gets returned from the decorator after I print
    the stats.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在包装器内部，我把所有希望在每个函数之前和之后执行的逻辑都放在了其中。在检查`health`之后，我调用绑定到`func`的函数，并将所有变长参数解包到调用中。我还将返回值绑定到`result`，这样在打印统计信息之后，确保它会从装饰器中返回。
- en: As with any closure, it is supremely important that the outer function return
    the inner function ❹.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何闭包一样，外部函数返回内部函数是至关重要的 ❹。
- en: 'Now, I can use the decorator I wrote and refactor my other functions:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以使用我编写的装饰器，并重构其他函数：
- en: '[PRE114]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Listing 6-47: *text_adventure_v2.py:2b*'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-47: *text_adventure_v2.py:2b*'
- en: To apply decorators to a function, I list each decorator I want to apply directly
    above the function definition, one decorator per line. I precede each decorator
    name with an `@` symbol. In my example, I only apply a single decorator to each
    function, but you can use as many as you like. They will be applied in order,
    with each decorator wrapping whatever is immediately below it.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 要将装饰器应用于一个函数，我会在函数定义的正上方列出每个装饰器，每个装饰器占一行。我会在每个装饰器名称前加上`@`符号。在我的示例中，我每个函数只应用了一个装饰器，但你可以根据需要应用多个装饰器。它们会按顺序依次应用，每个装饰器包裹着它下面的内容。
- en: Since I moved all the repetitive logic about checking health and displaying
    stats out of the individual functions and into the decorator, my code is cleaner
    and easier to maintain. If you run the code, it works the same as before.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我将所有关于检查健康和显示统计信息的重复逻辑从各个独立函数中移到了装饰器中，我的代码变得更加简洁，易于维护。如果你运行这段代码，它的行为与之前相同。
- en: Type Hints and Function Annotations
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提示和函数注解
- en: 'Python 3.5 onward allows you to specify *type hints*, which are exactly that:
    *hints* about what data type should be passed in or returned. These are not strictly
    necessary, given Python’s robust dynamic type system, but they may have a few
    benefits.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.5 开始，你可以指定*类型提示*，它们正是字面意思：*提示*应该传入或返回什么数据类型。这些并不是绝对必要的，因为 Python
    强大的动态类型系统本身已经足够强大，但它们可能带来一些好处。
- en: First, type hinting aids in documentation. The function definition now shows
    what type of information it wants, which is especially helpful when your IDE auto-magically
    shows hints as you type arguments in.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，类型提示有助于文档编写。函数定义现在显示了它希望接受的数据类型，这在 IDE 自动显示提示时尤为有用，尤其是在你输入参数时。
- en: Second, type hints help you catch potential bugs sooner. Static type checkers
    like *Mypy* are the primary tools for this (see Chapter 2). Some IDEs, like PyCharm,
    may warn you if you’re doing something weird, like passing a string to something
    type-hinted as an integer.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，类型提示有助于你更早地发现潜在的 bug。像 *Mypy* 这样的静态类型检查工具是主要的工具（见第二章）。一些 IDE，比如 PyCharm，如果你做了什么奇怪的事情，比如把字符串传给一个被类型提示为整数的变量，可能会发出警告。
- en: If you’re familiar with statically typed languages like Java and C++, this might
    make you a little excited.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Java 和 C++ 等静态类型语言，这可能会让你感到有些兴奋。
- en: However, understand that using type hints does not trade Python’s dynamic typing
    for static typing!
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要理解的是，使用类型提示并不会将 Python 的动态类型转换为静态类型！
- en: Python will not raise an error if you pass the wrong type.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你传递了错误的类型，Python 并不会引发错误。
- en: Python will not try to convert data to the specified type.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 不会尝试将数据转换为指定的类型。
- en: Python will actually ignore these hints altogether!
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 实际上会完全忽略这些提示！
- en: Type hints are specified with *annotations*, which are extra pieces of information
    that are permitted by the Python language but are not actually processed by the
    interpreter itself. There are two kinds of annotations.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示是通过 *注解* 来指定的，注解是 Python 语言允许的额外信息，但解释器本身并不会实际处理这些信息。注解有两种类型。
- en: '*Variable annotations* specify the expected type on a name, like this:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量注解*指定了一个名称的预期类型，如下所示：'
- en: '[PRE115]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '*Function annotations* specify type hints on parameters and function returns.
    Here, I apply function annotations to the `roll_dice()` function from earlier:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数注解*指定了参数和函数返回值的类型提示。在这里，我将函数注解应用于之前的 `roll_dice()` 函数：'
- en: '[PRE116]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Listing 6-48: *dice_roll.py:1e*'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-48：*dice_roll.py:1e*
- en: This notation allows me to denote what types I expect for the parameters and
    return. In this case, both parameters should receive an integer, so I follow each
    name with a colon and then `int` as the expected data type. If there’s a default
    value of the expected type, it is included after the type hint.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法允许我指定我期望的参数和返回值类型。在这种情况下，两个参数都应该接收一个整数，因此我在每个名称后面跟着一个冒号，然后是 `int` 作为预期的数据类型。如果有一个预期类型的默认值，它会在类型提示之后给出。
- en: I denote the return type with an arrow (`->`) and the expected type. Collections
    like tuples and lists are a little trickier to specify with type hints. From the
    `typing` module, I can use the notation `Tuple[ ]`, which is a *generic type*.
    Every value of this particular tuple should be an `int`, but since I don’t really
    know how many will be returned, I specify a `...` to say, “There may be more.”
    Now, the function will be expected to return one or more integers, but no other
    types.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过箭头（`->`）和预期类型来表示返回类型。像元组和列表这样的集合在使用类型提示时会稍微复杂一点。在 `typing` 模块中，我可以使用 `Tuple[
    ]` 语法，它是一个 *泛型类型*。这个特定元组中的每个值应该是 `int` 类型，但由于我并不确切知道会返回多少个，我用 `...` 来表示“可能会有更多”。现在，函数预计会返回一个或多个整数，但不会返回其他类型。
- en: By the way, if you don’t know what or how many types will be returned in a tuple,
    you can use the notation `typing.Tuple[typing.Any, ...]`
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，如果你不知道元组中会返回什么类型或者有多少个元素，可以使用 `typing.Tuple[typing.Any, ...]` 语法。
- en: 'That return type hint in the preceding code example is pretty long. I could
    shorten it by defining a *type alias*, like this:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码示例中的返回类型提示相当长。我可以通过定义一个 *类型别名* 来简化它，如下所示：
- en: '[PRE117]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Listing 6-49: *dice_roll.py:1f*'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-49：*dice_roll.py:1f*
- en: I define `TupleInts` as a type alias for `Tuple[int, ...]`, and I can use it
    the same way throughout my code.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 `TupleInts` 定义为 `Tuple[int, ...]` 的类型别名，并且可以在我的代码中以相同的方式使用它。
- en: Again, Python itself won’t act on these type hints; it will only recognize the
    notation system as valid and store it in the `__annotations__` attribute of the
    function, nothing more.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Python 本身并不会对这些类型提示做出任何反应；它只会将该语法系统识别为有效，并将其存储在函数的 `__annotations__` 属性中，仅此而已。
- en: 'I can now run this code through Mypy:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在可以通过 Mypy 运行这段代码：
- en: '[PRE118]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: If there are any mismatches between the type hints and the actual usage, Mypy
    will list these in detail, so they can be fixed.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型提示与实际使用之间存在任何不匹配，Mypy 会详细列出这些问题，以便进行修复。
- en: Duck Typing and Type Hints
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型与类型提示
- en: You might think that type hinting is incompatible with duck typing, but thanks
    to the `typing` module, the two generally play very well with one another.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为类型提示与鸭子类型不兼容，但感谢 `typing` 模块，两者通常能够很好地配合使用。
- en: For example, if you wanted a function that could accept a single parameter of
    any type that could be iterated over (see Chapter 9), such as a tuple or a list,
    you could use `typing.Iterable[]`, with the contained type in the brackets. For
    this example, I’ll presume that the iterable may contain any type.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想要一个可以接受任何类型的单个参数的函数，这些类型可以被迭代（参见第9章），比如元组或列表，你可以使用`typing.Iterable[]`，并在方括号中指定其中包含的类型。以此示例来说，我假设这个可迭代的对象可以包含任何类型。
- en: '[PRE119]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The parameter `within` is type-hinted to be an iterable with `typing.Iterable[
    ]`. The hint `typing.Any` within the square brackets indicates that the `Iterable`
    can contain items of any data type.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`within`的类型提示为一个可迭代对象，使用`typing.Iterable[]`。方括号中的`typing.Any`提示表示该`Iterable`可以包含任何数据类型的项目。
- en: 'The typing module contains many different such types, enough to fill up a separate
    chapter altogether. The best way to learn more about type hinting is to read the
    documentation: [https://docs.python.org/library/typing.html](https://docs.python.org/library/typing.html).
    I also recommend taking a look at PEP 484, which defined type hinting, and PEP
    3107, which defined function annotations.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: typing模块包含了许多不同的类型，足够写成单独一章。了解类型提示的最佳方式是阅读文档：[https://docs.python.org/library/typing.html](https://docs.python.org/library/typing.html)。我还建议你查看PEP
    484，它定义了类型提示，以及PEP 3107，它定义了函数注解。
- en: Should You Use Type Hinting?
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该使用类型提示吗？
- en: Type hinting is entirely optional, and there are cases for it and against it.
    Some argue that it clutters up the code, impairing the natural readability that
    Python attained through dynamic typing. Others see it as a much-needed tool for
    mitigating the bugs made possible through the lack of static typing.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示完全是可选的，它有支持的理由，也有反对的意见。有些人认为它会让代码显得杂乱，削弱了Python通过动态类型获得的自然可读性。而另一些人则认为它是一个极为重要的工具，可以减少由于缺乏静态类型带来的错误。
- en: In practice, you don’t need to make a wholesale “use or don’t use” decision.
    Because type hinting is optional, you can use it in cases where it improves the
    readability and stability of the code and skip it in cases where it doesn’t. Even
    within a function, you can define a type hint for one parameter and omit it for
    the next.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你不需要做一个“全用还是完全不使用”的决定。由于类型提示是可选的，你可以在能提高代码可读性和稳定性的情况下使用它，而在没有此需要的情况下跳过它。即使在一个函数内，你也可以为一个参数定义类型提示，而对下一个参数省略它。
- en: Ultimately, the decision is up to you and your team alone. Only you know if
    and when type hints will be helpful. In short, *know thine own project*.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，决定权完全在你和你的团队手中。只有你知道何时以及是否需要类型提示。简而言之，*了解自己的项目*。
- en: Since this book focuses on idiomatic Python above all else, and since type hinting
    is entirely optional, I won’t use it in any future examples.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的重点是符合Python语言风格的编程，并且类型提示是完全可选的，我在未来的示例中将不会使用它。
- en: Wrapping Up
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: I hope you come away from this chapter with a newfound appreciation for functional
    programming in the Python language. Even when the paradigm is not embraced wholesale,
    its concepts and guidelines inform Pythonic code.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你通过本章的学习，能够对Python语言中的函数式编程有全新的理解。即使不能完全采纳这种范式，它的概念和指导思想仍然能影响到Pythonic风格的代码。
- en: I’ll still apply functional concepts as I move into object-oriented programming
    in the next chapter. I’ve found that, when combined correctly, these paradigms
    interact in surprisingly positive ways.**  **# 7
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章的面向对象编程时，我仍然会应用函数式编程的概念。我发现，当这两种范式正确结合时，它们会以出乎意料的积极方式互动。**  **# 7
- en: Objects and Classes
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 对象和类
- en: '![](Images/chapterart.png)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Objects are the bread and butter of many a programmer. Python makes full use
    of objects, even to the point of inspiring the mantra, “Everything is an object.”
    However, if you’ve worked with classes and objects in any other language, Python’s
    take may surprise you.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是许多程序员的核心工具。Python充分利用对象，甚至有了“万物皆对象”的口号。然而，如果你曾在其他语言中使用过类和对象，Python的方式可能会让你感到惊讶。
- en: '*Object-oriented programming* (or *OOP*) is a paradigm in which data and its
    corresponding logic is organized into objects. If you’re familiar with such languages
    as Java, C++, Ruby, and C#, you’re well acquainted with these concepts.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象编程*（或 *OOP*）是一种将数据及其相应逻辑组织为对象的范式。如果你熟悉像 Java、C++、Ruby 和 C# 这样的语言，你一定很了解这些概念。'
- en: Yet, object-oriented programming in Python is not mutually exclusive with functional
    programming; in fact, the two paradigms work very well together.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python中的面向对象编程并不与函数式编程相互排斥；事实上，这两种范式可以很好地协同工作。
- en: 'In this chapter, I’ll cover the essentials of object-oriented programming in
    Python: creating classes with attributes, modules, and properties. I’ll demonstrate
    adding various behaviors via special methods, and I’ll wrap up with a summary
    of the situations in which classes are the most useful.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讲解 Python 中面向对象编程的基本概念：创建具有属性、模块和属性的类。我将演示通过特殊方法添加各种行为，并最后总结类在什么情况下最为有用。
- en: Declaring a Class
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明一个类
- en: 'Creating a new class is simple. I’ll create a class named `SecretAgent`:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新类很简单。我将创建一个名为`SecretAgent`的类：
- en: '[PRE120]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Listing 7-1: Initializing a class'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-1：初始化一个类
- en: Below this, in the accompanying suite of the class declaration, I’d add any
    methods I want to include in the object. An object is known as an *instance* of
    a class in Python. I’ll cover this in detail shortly.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，在类声明的配套部分，我会添加任何希望包含在对象中的方法。在 Python 中，对象被称为类的*实例*。稍后我会详细讲解这一点。
- en: In Python, everything is an object, in that everything inherits from the `object`
    class. In Python 3, this inheritance from `object` is implicit, as seen in [Listing
    7-1](#listing7-1). In Python 2, you had to explicitly inherit from `object`, or
    from another class that inherits from `object`. (I cover inheritance in Chapter
    13. You can take it for granted here.)
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，一切都是对象，也就是说，所有东西都继承自`object`类。在 Python 3 中，这种从`object`的继承是隐式的，如在[示例
    7-1](#listing7-1)中所示。在 Python 2 中，你必须显式地从`object`类继承，或者从继承自`object`的其他类继承。（我将在第13章讲解继承，你可以在这里默认它的存在。）
- en: 'Here’s the `SecretAgent` class declaration again, this time explicitly inheriting
    from `object`, as Python 2 would have required:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`SecretAgent`类的声明，这次显式地从`object`继承，就像 Python 2 中要求的那样：
- en: '[PRE121]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Listing 7-2: Initializing a class with explicit inheritance'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-2：使用显式继承初始化类
- en: Listings 7-1 and 7-2 are functionally identical. Python developers really hate
    *boilerplate code*, which is code that is widely reused, with little or no modification.
    That is why Python 3 added the shorter technique seen in [Listing 7-1](#listing7-1).
    Unless you need to support Python 2, the shorter technique is preferred. You’ll
    encounter both ways often enough, so it’s important to know that they do the exact
    same thing in Python 3.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-1 和 7-2 在功能上是完全相同的。Python 开发者非常讨厌*模板代码*，即那些被广泛重复使用、几乎没有修改的代码。这就是为什么 Python
    3 增加了[示例 7-1](#listing7-1)中看到的简化技术。如果你不需要支持 Python 2，推荐使用更简短的方式。你会经常遇到这两种方式，因此了解它们在
    Python 3 中是做同样的事情非常重要。
- en: The Initializer
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化器
- en: A class often has an *initializer* method for defining the initial values of
    *instance attributes*, which are the member variables that exist in each instance.
    If your instance will have no instance attributes, you don’t need to define `__init__()`.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类通常有一个*初始化器*方法，用于定义*实例属性*的初始值，实例属性是每个实例中存在的成员变量。如果你的实例没有实例属性，就不需要定义`__init__()`。
- en: 'I want each instance of `SecretAgent` to have a code name and a list of secrets.
    Here’s the initializer for my `SecretAgent` class, which has two instance attributes:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望每个`SecretAgent`实例都有一个代号和一份秘密列表。以下是我为`SecretAgent`类定义的初始化方法，它包含两个实例属性：
- en: '[PRE122]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Listing 7-3: *secret_agent.py:1a*'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-3：*secret_agent.py:1a*
- en: The initializer must have the name `__init__` to be recognized as an initializer,
    and it must accept at least one argument, conventionally called `self`. This `self`
    argument references the instance the method is acting on.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器必须命名为`__init__`，才能被识别为初始化器，并且它必须接受至少一个参数，通常叫做`self`。这个`self`参数引用了方法正在作用的实例。
- en: In this case, I also accept a second argument, `codename`, which I use as the
    initial value of one of my instance attributes. This `self.codename` attribute
    will be the code name of the secret agent.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我还接受了第二个参数`codename`，它作为我一个实例属性的初始值。这个`self.codename`属性将是特工的代号。
- en: Instance attributes are part of the class instance itself, so I must access
    them through the dot (`.`) operator on `self`. All instance attributes should
    be declared in the initializer method, rather than on the fly in other instance
    methods. Therefore, I’m also defining `self._secrets` as an empty list. This will
    be a list of secrets the particular secret agent (instance) is keeping.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 实例属性是类实例的一部分，因此我必须通过`self`上的点（`.`）操作符来访问它们。所有实例属性都应该在初始化方法中声明，而不是在其他实例方法中动态创建。因此，我还将`self._secrets`定义为空列表。这将是该特工（实例）所保留的秘密列表。
- en: Lastly, an initializer must never return a value via the `return` keyword; if
    it does, calling the initializer will raise a `TypeError`. However, you may use
    `return` by itself to explicitly exit the method, if you ever need to.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，初始化器绝不能通过 `return` 关键字返回值；如果它这么做，调用初始化器时会抛出 `TypeError`。不过，如果需要，你可以单独使用 `return`
    来显式退出方法。
- en: 'Whenever I create a new class instance, the initializer is automatically called.
    Here, I create three `SecretAgent` instances and provide arguments for the `codename`
    parameter of the initializer:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我创建一个新的类实例时，初始化器会自动被调用。在这里，我创建了三个 `SecretAgent` 实例，并为初始化器的 `codename` 参数提供了参数：
- en: '[PRE123]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Listing 7-4: *secret_agent_usage.py:1*'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-4: *secret_agent_usage.py:1*'
- en: In this module, I import my `SecretAgent` class and create three new instances.
    You’ll notice that I didn’t need to pass anything to the first parameter, `self`.
    That’s taken care of behind the scenes. Instead, my first argument, `"Mouse"`,
    is passed to the second parameter of the initializer, `codename`. Each instance
    also has its own empty `_secrets` list.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中，我导入了我的 `SecretAgent` 类并创建了三个新实例。你会注意到，我不需要为第一个参数 `self` 传递任何东西。那部分在幕后处理了。相反，我的第一个参数
    `"Mouse"` 被传递给了初始化器的第二个参数 `codename`。每个实例也有自己空的 `_secrets` 列表。
- en: The Constructor
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: If you’re coming from C++, Java, or some similar language, you may expect to
    write a *constructor*—a function that constructs an instance of a class—or you
    may think that the initializer does the same thing as a constructor. In fact,
    Python 3 splits the duties of a typical constructor between the initializer `__init__()`
    and the constructor `__new__()`.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自 C++、Java 或类似语言，你可能会期望编写一个 *构造函数* ——一个构建类实例的函数 —— 或者你可能会认为初始化器与构造函数做的是一样的事。事实上，Python
    3 将典型构造函数的职责分配给了初始化器 `__init__()` 和构造函数 `__new__()`。
- en: In Python, the constructor `__new__()` takes care of actually creating the instance
    in memory. When you create a new instance, the constructor is automatically called
    first, followed by a call to the initializer. The constructor is the only method
    in the class to be called automatically before the object is created!
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，构造函数 `__new__()` 负责实际在内存中创建实例。当你创建一个新实例时，构造函数会首先自动调用，接着会调用初始化器。构造函数是类中唯一在对象创建之前自动调用的方法！
- en: 'You don’t normally need to define a constructor; one is provided automatically.
    The only time you would create a constructor would be if you needed additional
    control over the process. However, to familiarize you with the syntax, I’ll write
    a very basic (and effectively pointless) constructor, which could go in a class
    definition:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你不需要定义构造函数；系统会自动提供一个。你只有在需要对过程进行额外控制时才会创建构造函数。然而，为了让你熟悉语法，我会写一个非常基本的（实际上几乎没用的）构造函数，它可以放在类定义中：
- en: '[PRE124]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The constructor always has the name `__new__`, and it implicitly accepts a class
    as its first parameter, `cls` (in contrast to the initializer, which accepts a
    class instance on `self`). Since the initializer accepts parameters, I also need
    to prepare the constructor to accept these on the constructor, so I use variadic
    arguments to capture these arguments and pass them on to the initializer parameters.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的名称总是 `__new__`，并且它隐式接受一个类作为第一个参数 `cls`（与初始化器不同，初始化器接受类实例作为 `self`）。由于初始化器接受参数，我还需要准备构造函数来接受这些参数，因此我使用可变参数来捕获这些参数，并将它们传递给初始化器参数。
- en: The constructor must return the class instance that gets created. Technically,
    I could return whatever I wanted here, but the expected behavior would almost
    certainly be to return an instance that has been instantiated from the `SecretAgent`
    class. To do that, I call the `__new__` function on the parent class, which you
    may recall (from [Listing 7-2](#listing7-2)) is `object`. (I’ll return to `super()`
    in Chapter 13. Don’t worry about understanding it now.)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数必须返回创建的类实例。从技术上讲，我可以在这里返回任何我想要的东西，但预期的行为几乎肯定是返回一个从 `SecretAgent` 类实例化的实例。为此，我在父类上调用
    `__new__` 函数，你可能还记得（来自 [Listing 7-2](#listing7-2)）它是 `object`。 （我将在第13章回到 `super()`，现在不需要理解它。）
- en: In practice, if this is all your constructor needs to do, just omit it! Python
    automatically handles the constructor behavior if you don’t write any code for
    it. Only write a constructor when you need to control the behavior around instantiating
    the class instance itself. In any event, that scenario is rare; it is perfectly
    plausible that you will never write a constructor in your entire Python programming
    career.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果构造函数只需要做这些事情，那就直接省略它吧！如果你没有为构造函数编写任何代码，Python 会自动处理构造函数的行为。只有在需要控制类实例化行为时，才需要编写构造函数。无论如何，这种情况是比较少见的；完全有可能在你整个
    Python 编程生涯中都不会写构造函数。
- en: The Finalizer
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 终结器
- en: 'The *finalizer* is called when a class instance finally reaches the end of
    its lifespan and is cleaned up by the garbage collector. It exists solely to handle
    any technically complex cleanup that your particular class may require. As with
    the constructor, you will seldom, if ever, need to write this function yourself.
    If you do, it’s important to understand: the finalizer is only called if the class
    instance (value) itself is cleaned up by the garbage collector!'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '*终结器*在类实例的生命周期结束并被垃圾回收器清理时被调用。它仅存在于处理类可能需要的任何技术性复杂清理。与构造函数一样，你很少需要自己编写这个函数。如果你确实需要写它，重要的是要理解：只有当类实例（值）本身被垃圾回收器清理时，终结器才会被调用！'
- en: If any references to the class instance still exist, the finalizer won’t be
    called; furthermore, depending on the implementation of Python you’re using, the
    garbage collector might not always clean up the class instance when you’d expect,
    if at all.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仍然有引用指向类实例，那么终结器将不会被调用；此外，取决于你使用的 Python 实现，垃圾回收器可能不会在你预期的时候清理类实例，甚至可能完全不清理。
- en: Therefore, only use the finalizer for code directly relating to garbage-collecting
    the class instance. It should never contain code that needs to be run as part
    of any other circumstance.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，终结器仅用于与垃圾回收类实例相关的代码。它绝不应包含任何需要在其他情况下运行的代码。
- en: 'Here’s a rather useless finalizer that prints a message when the garbage collector
    cleans up a `SecretAgent` class instance:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当无用的终结器，它会在垃圾回收器清理`SecretAgent`类实例时打印一条消息：
- en: '[PRE125]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Listing 7-5: *secret_agent.py:2*'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-5: *secret_agent.py:2*'
- en: A finalizer always has the name `__del__` and accepts a single parameter, `self`.
    It must not return anything.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 终结器的名称总是`__del__`，并接受一个参数`self`。它不应该返回任何内容。
- en: 'To demonstrate this finalizer, I’ll create and manually delete an instance.
    It is possible to delete a name, thereby unbinding it from its value, by using
    the `del` keyword. Given the `SecretAgent` class with that finalizer method, I
    can create and then delete a name referring to a class instance:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个终结器，我将创建并手动删除一个实例。可以使用`del`关键字删除一个名称，从而将其与值解除绑定。给定具有该终结器方法的`SecretAgent`类，我可以创建一个实例，并删除指向类实例的名称：
- en: '[PRE126]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Listing 7-6: *secret_agent_disavow.py*'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-6: *secret_agent_disavow.py*'
- en: I create a new instance from the `SecretAgent` class and bind it to the name
    `weasel`. Then, I immediately delete the name by using the `del` operator. The
    name `weasel` is now undefined again. Coincidentally, because no references remain
    to the `SecretAgent` instance the name was bound to, that instance is cleaned
    up by the garbage collector, which first calls the finalizer.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我从`SecretAgent`类创建一个新实例，并将其绑定到名称`weasel`上。然后，我立即使用`del`运算符删除该名称。此时，名称`weasel`已经不再定义。巧合的是，由于没有引用指向原本与该名称绑定的`SecretAgent`实例，这个实例被垃圾回收器清理掉，首先调用了终结器。
- en: 'Thus, running that code displays this output:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，运行这段代码将显示以下输出：
- en: '[PRE127]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Note that `del` only deletes the name, not the value! If you have multiple names
    bound to the same value, and if you `del` one of those names, then the other names
    and their values will be unaffected. In other words, `del` will not force the
    garbage collector to delete the objects.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`del`只删除名称，而不删除值！如果你有多个名称绑定到相同的值上，而你使用`del`删除其中一个名称，那么其他名称及其值将不受影响。换句话说，`del`并不会强制垃圾回收器删除对象。
- en: Attributes
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: All variables belonging to a class or instance are called *attributes*. Attributes
    belonging to the instance itself are called *instance attributes*, which are also
    sometimes referred to as *member variables*. Attributes belonging to the class
    itself are *class attributes*, which are also sometimes called *class variables*.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 属于类或实例的所有变量都叫做*属性*。属于实例本身的属性叫做*实例属性*，有时也称为*成员变量*。属于类本身的属性叫做*类属性*，有时也叫做*类变量*。
- en: Many intermediate-level Python programmers don’t realize there is a significant
    difference between the two. I must admit, I spent the first few years of my Python
    development career using them utterly incorrectly!
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 许多中级 Python 程序员没有意识到两者之间存在显著的区别。我必须承认，我在 Python 开发生涯的最初几年里完全错误地使用了它们！
- en: Instance Attributes
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例属性
- en: An *instance attribute* exists on the instance itself; its value is unique to
    the instance and is not available to other instances. All instance attributes
    should be declared in the class’s initializer.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例属性*存在于实例本身上；它的值对于每个实例都是唯一的，其他实例无法访问。所有实例属性应在类的初始化器中声明。'
- en: 'Revisiting the `__init__()` method from [Listing 7-3](#listing7-3), you’ll
    see I have two instance attributes:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视来自[示例 7-3](#listing7-3)的`__init__()`方法，你会看到我有两个实例属性：
- en: '[PRE128]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Class Attributes
  id: totrans-701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类属性
- en: A *class attribute* exists on the class, instead of on an individual instance.
    In practice, this means that all related class instances effectively “share” a
    class attribute, although it would exist even without any instances.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '*类属性*存在于类上，而不是某个具体的实例上。实际上，这意味着所有相关的类实例实际上“共享”一个类属性，尽管即使没有任何实例，它依然会存在。'
- en: 'Class attributes are declared at the top of the class, outside of any methods.
    Here, I add one class attribute directly into the suite of the class:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性通常在类的顶部声明，在任何方法外部。在这里，我将一个类属性直接添加到类的成员中：
- en: '[PRE129]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Listing 7-7: *secret_agent.py:1b*'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-7：*secret_agent.py:1b*
- en: The attribute `_codeword` belongs to the `SecretAgent` class. Typically, all
    class attributes are declared before any methods to make them easier to find,
    although this is just convention. The important part is that they are defined
    outside of any methods.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`_codeword`属于`SecretAgent`类。通常，所有类属性都会在任何方法之前声明，以便于查找，尽管这只是一个约定。关键在于它们是在任何方法外部定义的。
- en: 'The class attribute can be accessed like this:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性可以通过以下方式访问：
- en: '[PRE130]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Listing 7-8: *secret_agent_usage.py:2a*'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-8：*secret_agent_usage.py:2a*
- en: I can access the class attribute `_codeword` directly through the class, or
    through any instances instantiated from the class. If the class attribute is rebound
    or mutated on the class itself ❶, the changes will appear in all cases. However,
    if a value is assigned to the name on an instance, it will create an instance
    attribute with the same name ❷, which shadows the class attribute on that instance,
    without affecting other instances.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过类直接访问类属性`_codeword`，也可以通过从类实例化的任何实例访问它。如果类属性在类本身上被重新绑定或修改❶，这些变化将在所有情况下体现。然而，如果在实例上为该名称赋值，它将创建一个具有相同名称的实例属性❷，并在该实例上遮蔽类属性，而不会影响其他实例。
- en: Class attributes are particularly useful for constant values that the class’s
    methods use. I also find them more practical and maintainable than global variables
    in many cases, especially in GUI programming. For example, I often employ class
    attributes when I need to maintain a shared instance of a widget, like a window.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性对于类的方法使用的常量值特别有用。在许多情况下，我发现它们比全局变量更实用和可维护，尤其是在 GUI 编程中。例如，当我需要维护一个共享的部件实例（如窗口）时，我通常会使用类属性。
- en: Scope-Naming Conventions
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围命名约定
- en: If you’re coming from a language that has class scope, you may wonder why I
    haven’t mentioned it yet. Isn’t data hiding an important part of encapsulation?
    In fact, Python has no formal concept of data hiding. Instead, PEP 8 outlines
    a naming convention that indicates whether an attribute is safe to modify externally
    (public) or not (nonpublic).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自于有类作用域的语言，你可能会想，为什么我到现在还没提到它呢？数据隐藏不是封装的重要组成部分吗？事实上，Python 没有正式的数据隐藏概念。相反，PEP
    8 列出了一个命名约定，表明一个属性是否可以在外部修改（公有）或不能修改（非公有）。
- en: While I talk a lot about attributes in this section, these naming conventions
    apply to methods as well.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在本节中我谈论了很多关于属性的内容，但这些命名约定同样适用于方法。
- en: Nonpublic
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非公有
- en: By preceding a name with an underscore, I declare that the attribute `_secrets`
    is intended to be *nonpublic*, meaning it shouldn’t be modified (or, ideally,
    accessed) outside of the class. This is more of a social contract via style convention;
    I’m not actually hiding anything.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在名称前加下划线，我声明属性`_secrets`是*非公有*的，意味着它不应该在类外部被修改（或理想情况下，被访问）。这更多是一种通过风格约定达成的社会契约；我并没有真正隐藏任何东西。
- en: This may seem dangerous to many developers coming from languages with explicit
    scope, like Java, but it works out pretty well. As my pal “grym” likes to put
    it, “If you know why you shouldn’t stick a fork in a toaster, you are therefore
    qualified to stick a fork in a toaster.” In other words, if the client is going
    to disregard the underscore warning label, they probably know what they’re doing.
    (On the off-chance they don’t, they’re fully responsible for the consequences.)
    That little underscore hanging out after the dot operator is advertising “You
    really shouldn’t mess with me!”
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这对许多来自有明确作用域语言（如 Java）的开发者来说可能看起来很危险，但实际上效果很好。正如我的朋友 “grym” 所说，“如果你知道为什么不该把叉子插进烤面包机，你就有资格把叉子插进烤面包机。”换句话说，如果客户端决定忽视下划线警告标签，他们大概知道自己在做什么。（如果他们不知道，他们将完全负责后果。）那个挂在点操作符后面的下划线在提醒你，“你真的不该乱搞我！”
- en: Public
  id: totrans-718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公有
- en: The attribute `codename`, which does not start with an underscore, is intended
    to be *public*. It is okay for this attribute to be accessed or modified externally,
    as it won’t really affect the behavior of the class. Public attributes are preferable
    to writing a plain getter/setter pair of methods; the behavior is the same, but
    the result is cleaner, with less boilerplate.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '`codename` 属性并没有以下划线开头，旨在作为 *公有* 属性。外部访问或修改该属性是可以的，因为它不会真正影响类的行为。公有属性比编写简单的
    getter/setter 方法对更优；行为相同，但结果更简洁，且避免了多余的模板代码。'
- en: If an attribute needs a custom getter or setter, one approach is to define the
    attribute as nonpublic and create a public *property*, which I’ll come back to
    shortly.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个属性需要自定义 getter 或 setter，一种方法是将该属性定义为私有，并创建一个公有的 *property*，稍后我会详细讲解。
- en: Name Mangling
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称重整
- en: 'Python does offer *name mangling*, which rewrites an attribute or method name
    to prevent it from being shadowed by derived (inheriting) classes. This provides
    a sort of weak form of data hiding. It can also be useful for an added level of
    forewarning: “No, *really*, if you mess with this attribute, terrible things will
    happen!”'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: Python 确实提供了 *名称重整*，它会重写属性或方法名，以防止其被派生（继承）类遮蔽。这提供了一种弱形式的数据隐藏。它也可以用于增加警告级别：“不，*真的*，如果你搞乱了这个属性，会发生可怕的事情！”
- en: 'To mark an attribute (or method) for name mangling, precede the name with two
    underscores (`__`), like this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 要标记一个属性（或方法）进行名称重整，可以在属性名之前加上两个下划线（`__`），像这样：
- en: '[PRE131]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Listing 7-9: *message.py:1*'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-9: *message.py:1*'
- en: 'The `__format` attribute will be name mangled, so accessing it externally in
    the ordinary manner will not work:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`__format` 属性会被名称重整，因此用常规方式访问它将无法成功：'
- en: '[PRE132]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Listing 7-10: *message.py:2*'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-10: *message.py:2*'
- en: 'This will raise an `AttributeError` because the `msg` instance does not have
    an attribute named `__format`; the name of that attribute was mangled. Be aware
    that name mangling is *not* a true form of data hiding! It is still perfectly
    possible to access a name-mangled attribute:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 这会引发 `AttributeError`，因为 `msg` 实例没有名为 `__format` 的属性；该属性名已被重整。请注意，名称重整 *并不是*
    数据隐藏的真正形式！仍然可以访问一个经过名称重整的属性：
- en: '[PRE133]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Listing 7-11: *message.py:3*'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-11: *message.py:3*'
- en: 'The name-mangling pattern is predictable: an underscore, the name of the class,
    and then the name of the attribute, with its two leading underscores.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 名称重整的模式是可预测的：一个下划线，类名，然后是属性名，且属性名会有两个前导下划线。
- en: Public, Nonpublic, or Name Mangled?
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公有、私有还是名称重整？
- en: 'When deciding whether to make an attribute public or nonpublic, I ask myself
    one question: could changing this attribute externally cause unexpected or negative
    behavior in the class? If the answer is yes, I make the attribute nonpublic by
    preceding it with an underscore. If the answer is no, I leave the attribute public.
    It is up to the coder using the class to respect the rules or suffer the consequences.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定将属性设为公有还是私有时，我会问自己一个问题：外部修改这个属性会导致类出现意外或负面行为吗？如果答案是肯定的，我会通过在属性名前加下划线使它成为私有。如果答案是否定的，我会保持属性公有。是否遵循这些规则，取决于使用类的程序员，否则就得承担后果。
- en: As to name mangling, in practice, I very rarely employ this pattern. I reserve
    it only for those cases where (a) I need to avoid a naming conflict in the context
    of inheritance or (b) external access of the attribute will have exceptionally
    horrific effects on the behavior of the class, and thus, an extra degree of warning
    is justified.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 至于名称修饰，实际上，我很少使用这种模式。我仅将其保留在（a）我需要避免在继承上下文中发生命名冲突的情况下，或（b）如果属性的外部访问会对类的行为产生异常严重的影响时，因此需要额外的警告。
- en: Always remember that Python does not have private class scope. Truly secret
    data should be properly encrypted, not just concealed from your API. There are
    also no optimization benefits to private class scope, unlike in languages like
    Java, since all attribute lookups occur at runtime.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 永远记住，Python 没有私有类作用域。真正的秘密数据应该被正确加密，而不仅仅是从你的 API 中隐藏起来。与 Java 等语言不同，Python 的私有类作用域没有优化优势，因为所有属性查找发生在运行时。
- en: Methods
  id: totrans-737
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'A class is nothing without its methods, which make encapsulation possible.
    There are three distinct types of methods: instance methods, class methods, and
    static methods.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类没有它的方法就什么都不是，正是方法使得封装成为可能。方法有三种不同的类型：实例方法、类方法和静态方法。
- en: Instance Methods
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例方法
- en: '*Instance methods* are your run-of-the-mill methods, which exist on the instance
    itself. The first parameter, conventionally named `self`, provides access to the
    instance attributes of the instance.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例方法*是你常见的方法，存在于实例本身上。第一个参数通常命名为`self`，它提供对实例属性的访问。'
- en: 'Here, I add an instance method to my `SecretAgent` class:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将一个实例方法添加到我的`SecretAgent`类中：
- en: '[PRE134]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Listing 7-12: *secret_agent.py:3*'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 7-12: *secret_agent.py:3*'
- en: Besides the required first parameter, the instance method accepts a second parameter,
    `secret`, which is appended to the list bound to the instance attribute `_secrets`.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 除了必需的第一个参数，实例方法接受第二个参数`secret`，它会被添加到绑定到实例属性`_secrets`的列表中。
- en: 'I call this method on the instance, using the dot operator:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 我在实例上使用点操作符调用这个方法：
- en: '[PRE135]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Listing 7-13: *secret_agent_usage.py:2b*'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 7-13: *secret_agent_usage.py:2b*'
- en: The dot operator implicitly passes `mouse` to the `self` parameter, so my first
    argument, the tuple of coordinates (notice the extra set of parentheses), is passed
    to the second parameter, `secret`, on the `remember()` method.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 点操作符隐式地将`mouse`传递给`self`参数，因此我的第一个参数，即坐标元组（注意额外的一对括号），会被传递给`remember()`方法的第二个参数`secret`。
- en: Class Methods
  id: totrans-749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类方法
- en: Like class attributes, *class methods* belong to the class, instead of to the
    instances instantiated from the class. These are useful for working with class
    attributes.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 与类属性一样，*类方法*属于类，而不是属于从类实例化的实例。这些方法对于操作类属性非常有用。
- en: 'Back in [Listing 7-7](#listing7-7), I defined `_codeword` as a class attribute
    so all `SecretAgent` instances would be aware of the code word; it’s something
    all agents should have in common. I need a way to inform all the agents at once
    of the new code word, so I’ll add a class method, `inform()`, which will modify
    the `_codeword` class attribute:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 7-7](#listing7-7)中，我将`_codeword`定义为类属性，以便所有`SecretAgent`实例都能知道密码；这是所有特工应该共同拥有的东西。我需要一种方法一次性通知所有特工新的密码，因此我将添加一个类方法`inform()`，它将修改`_codeword`类属性：
- en: '[PRE136]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Listing 7-14: *secret_agent.py:4*'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 7-14: *secret_agent.py:4*'
- en: I precede a class method with the built-in `@classmethod` decorator. A class
    method receives the class as its first argument, so the first parameter is named
    `cls`. Class attributes like `_codeword` are accessed on the class passed to `cls`.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过内建的`@classmethod`装饰器来声明类方法。类方法将类作为第一个参数传入，因此第一个参数命名为`cls`。像`_codeword`这样的类属性是在传递给`cls`的类上访问的。
- en: One of the benefits of this approach is that I don’t have to worry about whether
    I’m calling `inform()` on the class or on an instance. Because the method is a
    class instance, it will always access the class attribute on the class (`cls`),
    instead of the instance (`self`), and thus avoid accidentally shadowing `_codeword`
    on a single instance (see [Listing 7-8](#listing7-8)).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处之一是我不必担心是在类上还是实例上调用`inform()`。因为这个方法是类实例方法，它将始终访问类上的类属性（`cls`），而不是实例（`self`），从而避免在单个实例上意外遮蔽`_codeword`（见[清单
    7-8](#listing7-8)）。
- en: I don’t plan to include a getter for this attribute. After all, secret agents
    have to keep secrets!
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 我不打算为这个属性添加 getter。毕竟，特工必须保守秘密！
- en: 'To use this method, I would call something like this:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此方法，我会像这样调用：
- en: '[PRE137]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Listing 7-15: *secret_agent_usage.py:3*'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 7-15: *secret_agent_usage.py:3*'
- en: I can call the `inform()` class method directly on the `SecretAgent` class,
    or on any `SecretAgent` instance, such as `fox`. The changes that `inform()` makes
    to the class attribute `_codeword` appear on the class itself and all its instances.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以直接在`SecretAgent`类上调用`inform()`类方法，或者在任何`SecretAgent`实例上调用，比如`fox`。`inform()`对类属性`_codeword`所做的更改会出现在类本身以及所有它的实例中。
- en: When calling the class method with the dot operator, the class is implicitly
    passed to the `cls` parameter. That parameter name is still just a convention;
    the `@classmethod` decorator is what ensures that the first argument is always
    the class, never the instance.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用点操作符调用类方法时，类会隐式传递给`cls`参数。这个参数名仍然只是一个约定；`@classmethod`装饰器确保第一个参数始终是类，而不是实例。
- en: One awesome use of class methods is to provide alternative means of initializing
    instances. For example, the built-in integer class offers `int.from_bytes()`,
    which initializes a new `int` class instance, using a `bytes` value.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法的一个超酷用途是提供另一种初始化实例的方式。例如，内置的整数类提供了`int.from_bytes()`，它使用`bytes`值初始化一个新的`int`类实例。
- en: Static Methods
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态方法
- en: A *static method* is a regular function defined within a class, which accesses
    neither the instance attributes nor the class attributes. The only difference
    between a static method and a function is that a static method belongs to the
    class for namespace reasons.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态方法*是一个定义在类中的普通函数，它既不访问实例属性也不访问类属性。静态方法和函数之间的唯一区别是，静态方法属于类，主要是为了命名空间的原因。'
- en: The main reason to write a static method comes up when your class offers some
    functionality that doesn’t need to access any of the class or instance attributes
    or methods. For example, you may write a static method for handling some particularly
    complicated algorithm that is critical to your class’s implementation. By including
    the static method in the class, you are indicating that the algorithm is part
    of the class’s self-contained implementation logic, even though it does not access
    any attributes or methods.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 编写静态方法的主要原因出现在你的类提供了一些不需要访问任何类或实例属性或方法的功能时。例如，你可以为处理一些特别复杂的算法编写一个静态方法，这个算法对类的实现至关重要。通过将静态方法包含在类中，你表明这个算法是类的自包含实现逻辑的一部分，即使它不访问任何属性或方法。
- en: 'I’ll add a static method to the `SecretAgent` class, which handles one thing
    all the agents would do the same, regardless of their data—answer questions:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 我将为`SecretAgent`类添加一个静态方法，用来处理所有特工都会做的事情，不论它们的数据如何——回答问题：
- en: '[PRE138]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Listing 7-16: *secret_agent.py:5*'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-16：*secret_agent.py:5*
- en: I precede the static method with the `@staticmethod` decorator. You’ll notice
    that I don’t need to worry about a special first parameter, since the method doesn’t
    need access to any attributes. When this method is called on a class or on an
    instance, it only prints out the message, “I know nothing.”
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 我在静态方法前加上`@staticmethod`装饰器。你会注意到，我不需要担心特殊的第一个参数，因为该方法不需要访问任何属性。当这个方法在类或实例上调用时，它只会打印出消息：“I
    know nothing.”
- en: Properties
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: '*Properties* constitute a special variety of instance method that allows you
    to write getters and setters that behave so it appears that you were directly
    accessing an instance attribute. Properties allow you to write a consistent interface,
    where you use the object directly through what appear to be its attributes.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性*是实例方法的一个特殊种类，它允许你编写获取器和设置器，表现得好像你直接访问了一个实例属性。属性使你能够编写一个一致的接口，通过看似是属性的方式直接使用对象。'
- en: It is preferable to use properties, instead of making the user remember whether
    to call a method or use an attribute. Using properties is also much more Pythonic
    than cluttering your class with bare getters and setters that don’t augment attribute
    access or modification.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用属性，而不是让用户记得是调用方法还是使用属性。使用属性比在类中堆砌简单的获取器和设置器要更符合 Python 的编码风格，这些获取器和设置器并不会增强属性的访问或修改。
- en: Setting Up the Scenario
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置场景
- en: 'To demonstrate properties in action, I’ll expand on my `SecretAgent` class.
    Here’s the class so far. First, to set up, I’ll move it to a new file:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示属性的实际应用，我将扩展我的`SecretAgent`类。到目前为止，这是类的代码。首先，为了设置环境，我将它移到一个新文件中：
- en: '[PRE139]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Listing 7-17: *secret_agent_property.py:1*'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-17：*secret_agent_property.py:1*
- en: 'Next, I will add one more class method to encrypt whatever message is passed
    to it, using an encryption system of my own devising. This method has nothing
    to do with properties per se, but I include it to make the example complete:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将添加一个类方法，用我自己设计的加密系统对传递给它的任何消息进行加密。这个方法本身与属性没有关系，但我将它包括在内，以使示例完整：
- en: '[PRE140]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Listing 7-18: *Using a property with no getter*'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-18：*使用没有getter的属性*
- en: The `_encrypt()` class method uses the `_codeword` class attribute to perform
    a basic substitution cipher encoding on a string `message`. I use `sum()` to find
    the sum of the Unicode code points (as integers) for each character in `_codeword`.
    I pass a character (string) to the `ord()` function, which returns the Unicode
    code point as an integer. This sum of code points is bound to `code`. (The odd-looking
    loop here is actually a generator expression, which I’ll cover in Chapter 10.
    You can take it for granted here that it calls `ord()` on each character in the
    string bound to `cls._codeword`.)
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '`_encrypt()`类方法使用`_codeword`类属性对字符串`message`执行基本的替换密码编码。我使用`sum()`来计算`_codeword`中每个字符的Unicode码点（作为整数）的总和。我将一个字符（字符串）传递给`ord()`函数，它返回该字符的Unicode码点作为整数。这个码点总和绑定到`code`。（这里看起来奇怪的循环实际上是一个生成器表达式，我将在第10章讲解。你可以放心地认为它在对绑定到`cls._codeword`的字符串中的每个字符调用`ord()`。）'
- en: I use `code` to offset the Unicode code point of each character in the message.
    The `chr()` function returns the character associated with the given code point.
    I pass to it the sum of the current code point and `code`, for each character
    in the message. (Once again, I’m employing a generator expression here.)
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`code`来偏移消息中每个字符的Unicode码点。`chr()`函数返回与给定码点关联的字符。我将当前码点与`code`相加，并传递给`chr()`，用于消息中的每个字符。（再次说明，这里我使用了生成器表达式。）
- en: Defining a Property
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个属性
- en: 'A *property* behaves like an attribute, but it is made up of three instance
    methods: a *getter*, a *setter*, and a *deleter*. Remember that a property appears
    to be an ordinary attribute to the user of the class. Accessing the property calls
    the getter, assigning a value to it calls the setter, and deleting the property
    with the `del` keyword calls the deleter.'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性*表现得像一个普通的属性，但它由三个实例方法组成：*getter*、*setter*和*deleter*。记住，对于类的用户而言，属性看起来像是一个普通的属性。访问该属性会调用getter，给它赋值会调用setter，使用`del`关键字删除属性会调用deleter。'
- en: Like an ordinary getter or setter method, a property might access or modify
    a nonpublic attribute, multiple attributes, or even no attributes at all. It all
    depends on what behavior you want.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 像普通的getter或setter方法一样，属性可能会访问或修改非公共属性、多个属性，甚至根本不访问任何属性。这完全取决于你希望实现的行为。
- en: Here, I’ll define a property called `secret` for my `SecretAgent` class, which
    will serve as the getter, setter, and deleter for my `_secrets` instance attribute.
    This approach will allow me to add logic, such as having the setter encrypt the
    assigned data before storing it in the `_secrets` attribute.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将为`SecretAgent`类定义一个名为`secret`的属性，它将作为`_secrets`实例属性的getter、setter和deleter。这种方法将允许我添加逻辑，例如让setter在将数据存储到`_secrets`属性之前对其进行加密。
- en: Before defining the property itself, I need to define the three functions that
    will make up the property. Technically, I can call them whatever I like, but the
    convention is to name them `getx`, `setx`, or `delx`, where `x` is the name of
    the property. I’m also making these nonpublic methods, since I want the client
    to use the property directly.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义属性本身之前，我需要定义构成该属性的三个函数。从技术上讲，我可以随意命名它们，但约定俗成的是将它们命名为`getx`、`setx`或`delx`，其中`x`是属性的名称。我还将这些方法设置为非公共方法，因为我希望客户端直接使用该属性。
- en: 'First, the getter:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是getter方法：
- en: '[PRE141]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Listing 7-19: *secret_agent_property.py:3*'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-19：*secret_agent_property.py:3*
- en: The getter, `_getsecret()`, accepts no parameters and should return the value
    of the property. In this example, I want the getter to return the last item stored
    in the list bound to the instance attribute `self._secrets`, or if the list is
    empty, to return `None`.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: getter方法`_getsecret()`不接受任何参数，应返回属性的值。在这个例子中，我希望getter返回绑定到实例属性`self._secrets`的列表中的最后一个项，或者如果列表为空，则返回`None`。
- en: 'Next, the setter:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是setter方法：
- en: '[PRE142]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Listing 7-20: *secret_agent_property.py:4*'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-20：*secret_agent_property.py:4*
- en: The setter, `_setsecret()`, accepts a single parameter, which receives the value
    being assigned to the property in the call (see [Listing 7-23](#listing7-23)).
    In this case, I assume this is some sort of string, which I run through the static
    method `_encode()` I defined earlier and then store in the list `self._secrets`.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: setter，`_setsecret()`，接受一个参数，该参数接收在调用中赋给属性的值（见[列表 7-23](#listing7-23)）。在这种情况下，我假设这是某种字符串，我通过我之前定义的静态方法`_encode()`处理它，然后将其存储在`self._secrets`列表中。
- en: 'Finally, here’s the deleter:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是deleter：
- en: '[PRE143]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Listing 7-21: *secret_agent_property.py:5*'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-21: *secret_agent_property.py:5*'
- en: The *deleter*, `_delsecret()`, accepts no parameters and returns no value. This
    method is called when the property is deleted, either in the background, by the
    garbage collector, or explicitly, with `del secret`. In this example, when the
    property is deleted, I want the entire list of secrets to be cleared.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '*deleter*，`_delsecret()`，不接受参数并且不返回值。这个方法在属性被删除时被调用，无论是在后台，由垃圾回收器，还是显式地通过`del
    secret`。在这个例子中，当属性被删除时，我希望整个秘密列表被清空。'
- en: You actually don’t need to define a deleter if you have no need for special
    behavior when the decorator is deleted. Consider what you want to happen if `del`
    is called on your decorator, such as when you are deleting an associated attribute
    that the property controls; if you can’t think of anything, skip writing the deleter.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在删除装饰器时不需要特殊行为，实际上不需要定义deleter。考虑一下如果调用`del`删除你的装饰器时会发生什么，比如在删除装饰器控制的相关属性时；如果你想不出任何行为，可以跳过写deleter。
- en: 'Finally, I define the property itself:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我定义了属性本身：
- en: '[PRE144]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Listing 7-22: *secret_agent_property.py:6a*'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-22: *secret_agent_property.py:6a*'
- en: This is defined on the class itself, outside of the `__init__()` method and
    after the functions that make it up. I pass the three methods to the `fget`, `fset`,
    and `fdel` keyword arguments, respectively (although you can also pass them as
    positional arguments, in that same order). I bind the property to the name `secret`,
    which becomes the property name.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性是在类本身上定义的，位于`__init__()`方法之外，并在构成它的函数之后。我将三个方法分别传递给`fget`、`fset`和`fdel`关键字参数（尽管你也可以按位置参数传递，顺序相同）。我将该属性绑定到名称`secret`，这成为属性的名称。
- en: 'The property can now be used as if it were an instance attribute:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，属性可以像实例属性一样使用：
- en: '[PRE145]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Listing 7-23: *secret_agent_property.py:7a*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-23: *secret_agent_property.py:7a*'
- en: Every time I try to retrieve the value of the property, the getter is called.
    Meanwhile, assigning a value to the property calls the setter. There’s no need
    to remember and explicitly call dedicated getter or setter methods; I treat the
    property like an attribute.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 每次尝试检索属性值时，getter都会被调用。同时，给属性赋值时，会调用setter。无需记住并显式调用专用的getter或setter方法；我像对待属性一样对待这个属性。
- en: You’ll recall that the deleter for `secrets` clears the contents of the `_secrets`
    list. Just before deleting the property, the list contains two secrets. After
    deleting, the list is empty.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，`secrets`的deleter会清空`_secrets`列表的内容。在删除属性之前，列表包含两个秘密。删除后，列表为空。
- en: It is not necessary to define all three parts of the property. For example,
    I don’t want the `secret` property to even have a getter, so I can remove `_getsecret()`
    from my class code. Secret agents shouldn’t share their secrets, after all.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 不必定义属性的三个部分。例如，我不希望`secret`属性甚至有getter，所以我可以从类代码中删除`_getsecret()`。毕竟，特工们不应该分享他们的秘密。
- en: '[PRE146]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Listing 7-24: A secret property with no getter'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-24: 没有getter的秘密属性'
- en: Because I don’t pass an argument to `fget`, the default value of `None` is used
    instead ❶. This property has a setter and a deleter, but no getter.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我没有给`fget`传递参数，所以使用了默认值`None` ❶。这个属性有一个setter和deleter，但没有getter。
- en: 'As a result, I can assign to `secret`, but I can’t access the value:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我可以给`secret`赋值，但无法访问其值：
- en: '[PRE147]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Listing 7-25: *Using a property with no getter*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-25: *使用没有getter的属性*'
- en: Assigning values to `mouse.secret` works as before, since that calls the setter.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 给`mouse.secret`赋值的方式和以前一样，因为这会调用setter。
- en: 'However, attempting to access the value throws an `AttributeError`. I could
    instead have written a getter for secrets that always returned `None`, but the
    client would have to remember that it returned this useless value. Recall The
    Zen of Python:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试访问该值会引发`AttributeError`。我本可以为`secrets`编写一个getter，始终返回`None`，但是客户端必须记住它返回的是这个无用的值。记住《Python之禅》：
- en: Errors should never pass silently.
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误不应默默地通过。
- en: ''
  id: totrans-819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  id: totrans-820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非显式地静默。
- en: If a particular usage is not desired, especially when it comes to designing
    a class or interface, the usage should *explicitly fail*.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不希望某种特定的用法，尤其是在设计类或接口时，这种用法应该*明确失败*。
- en: Property with Decorators
  id: totrans-822
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用装饰器的属性
- en: Creating a property is easy enough, but the approach to implementing it that
    I’ve shown thus far doesn’t really feel very Pythonic, because I have to rely
    on my method names to remind me that they’re part of a property. Thankfully, there’s
    another way.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个属性很容易，但我迄今为止展示的实现方法似乎并不很Pythonic，因为我必须依赖我的方法名来提醒自己它们是属性的一部分。幸运的是，还有另一种方式。
- en: 'Python offers a cleaner approach to defining properties: with decorators. There
    are two approaches to this technique.'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一种更简洁的方式来定义属性：使用装饰器。这个技术有两种方法。
- en: 'Approach 1: property() and Decorators'
  id: totrans-825
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法1：property()和装饰器
- en: The first approach is to still employ the `property()` function but use decorators
    to denote the associated methods. The chief benefit of this approach is the added
    readability, and it is mainly used when the getter will be omitted. I can use
    the name of the property as the method name and rely on the decorator to clarify
    its role.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是仍然使用`property()`函数，但使用装饰器来标记相关方法。这个方法的主要优点是提高了可读性，主要用于省略getter的情况。我可以使用属性的名称作为方法名，并依靠装饰器来明确其作用。
- en: 'Here’s my rewritten code for the `secret` property, using this approach:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我使用这种方法重写的`secret`属性代码：
- en: '[PRE148]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Listing 7-26: *secret_agent_property.py:3b*'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-26：*secret_agent_property.py:3b*
- en: 'In this approach, I define `secret` as a property before writing its methods.
    I pass no arguments to `property()`, so all three functions default to `None`.
    Next, I add the getter:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我在编写方法之前先将`secret`定义为属性。我没有传递任何参数给`property()`，所以所有三个函数默认为`None`。接下来，我添加getter：
- en: '[PRE149]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Listing 7-27: *secret_agent_property.py:4b*'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-27：*secret_agent_property.py:4b*
- en: My getter method now must have the same name as the property, `secret`. If it
    doesn’t, it will fail with an `AttributeError` when the getter is first called,
    rather than when the class is created. The method is preceded by the decorator
    `@secret.getter`. This designates it as the getter for the property, just as if
    I had passed it to `property(fget=)`.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我的getter方法必须与属性同名，即`secret`。如果不相同，在第一次调用getter时将会抛出`AttributeError`，而不是在类创建时。该方法前面加上了装饰器`@secret.getter`。这将其标识为属性的getter，就像我将其传递给`property(fget=)`一样。
- en: 'Here’s the setter:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 这是setter：
- en: '[PRE150]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Listing 7-28: *secret_agent_property.py:5b*'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-28：*secret_agent_property.py:5b*
- en: Similarly, the setter method must share its name with the property it relates
    to, and it is preceded by the decorator `@secret.setter`.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，setter方法必须与它所关联的属性名称相同，并且它前面要加上装饰器`@secret.setter`。
- en: 'Finally, the deleter:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是deleter：
- en: '[PRE151]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Listing 7-29: *secret_agent_property.py:6b*'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-29：*secret_agent_property.py:6b*
- en: Similar to the getter and setter, the deleter is preceded by the decorator `@secret.deleter`.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 与getter和setter类似，deleter前面也加上了装饰器`@secret.deleter`。
- en: This version works as is, but there is an even better technique.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本可以直接使用，但还有一种更好的技术。
- en: 'Approach 2: Decorators Without property()'
  id: totrans-843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法2：没有property()的装饰器
- en: The second approach to declaring a property with decorators is even shorter,
    and it is the most commonly used. This approach is preferred when defining a property
    that has a getter.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器声明属性的第二种方法更简短，也是最常用的方法。当定义一个具有getter的属性时，这种方法是首选。
- en: 'If you have defined a getter, you don’t have to explicitly create and assign
    a `property()`. Instead, the decorator `@property` can be applied to the getter:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经定义了getter，就不需要显式创建和分配`property()`。相反，可以将装饰器`@property`应用到getter上：
- en: '[PRE152]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: I precede the getter function with the decorator `@property`, instead of `@secret.getter`,
    which creates a property with the same name as the method. Since this defines
    the property `secret`, I don’t need `secret = property()` anywhere in my code.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 我用装饰器`@property`来修饰getter函数，而不是`@secret.getter`，这样创建了一个与方法同名的属性。由于这是定义了`secret`属性，因此在我的代码中不需要`secret
    = property()`。
- en: Bear in mind, this shortcut only works with the getter method. The setter and
    deleter must be defined in the same manner as before.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个快捷方式只对getter方法有效。setter和deleter必须像以前一样定义。
- en: 'As before, I can omit any of the three methods if their behavior is not desired.
    For example, if I don’t want `secret` to be readable, I omit the getter, so my
    full property code looks like this:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，如果不需要某种行为，我可以省略三种方法中的任何一种。例如，如果我不希望`secret`是可读的，我可以省略getter，这样我的完整属性代码看起来像这样：
- en: '[PRE153]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Because I don’t have a getter, I must explicitly declare my property up front
    ❶. In this version, assignment and deletion of `secret` works as before, but accessing
    the value raises an `AttributeError`.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我没有 getter 方法，所以我必须在一开始就显式声明我的属性 ❶。在这个版本中，`secret` 的赋值和删除像之前一样工作，但访问该值会抛出
    `AttributeError`。
- en: When Not to Use Properties
  id: totrans-852
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时不使用属性
- en: There’s some debate about when to use properties, versus traditional getter
    and setter methods. One of the chief drawbacks of properties is that they conceal
    that some calculation or processing is being performed upon assignment, which
    the client might not expect. This especially becomes a problem if this processing
    is particularly long or complicated, such that a client may need to run it concurrently
    with `async` or threads (see Chapters 16 and 17); you cannot run an assignment
    concurrently with the same ease as running a method concurrently.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 关于何时使用属性与传统的 getter 和 setter 方法，存在一些争议。属性的一个主要缺点是，它们隐藏了在赋值时可能执行的某些计算或处理，客户端可能没有预料到。如果这些处理特别长或复杂，尤其成为问题，客户端可能需要并发地运行这些处理（参见第16章和第17章）；而你无法像运行方法那样轻松地并发运行赋值。
- en: You must also consider the expected behavior of an assignment. When a value
    is directly assigned to an attribute, you would typically expect the same value
    to be retrievable *from* that attribute. In reality, depending on how you wrote
    your properties, the value might be transformed when assigned or accessed. You’ll
    need to take this client expectation into consideration when designing your class.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须考虑赋值的预期行为。当一个值直接赋给某个属性时，你通常会期望能够从该属性中获取到相同的值。实际上，根据你编写属性的方式，值在赋值或访问时可能会发生变化。在设计类时，你需要考虑到客户端的这种预期。
- en: Some camps believe properties should only be used as a way of deprecating attributes
    that used to be public or that have been removed entirely. Others, like myself,
    find properties useful as replacements for otherwise relatively simplistic getters
    and setters that still involve more logic than plain assignment and access.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人认为，属性应该仅作为一种废弃曾经是公有属性或已完全删除的属性的方式来使用。另一些人，像我一样，认为属性作为替代通常较为简单的 getter 和 setter
    方法是有用的，尤其是在这些方法涉及更多逻辑时，而不仅仅是简单的赋值和访问。
- en: In any case, properties are some of those cool features of Python that are all
    too easy to misuse or misapply. Carefully consider the implications of properties,
    public attributes, or methods in your specific case. Take the occasion to consult
    the advice of other experienced Python developers, such as in the Libera.Chat
    IRC `#python` channel. (If you want to debate the most Pythonic general position
    on properties, though, bring a helmet.)
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，属性是 Python 中一些非常酷的特性，但也非常容易被滥用或错误使用。在具体情况下，要仔细考虑属性、公有属性或方法的影响。利用这个机会，参考其他经验丰富的
    Python 开发者的建议，比如在 Libera.Chat IRC `#python` 频道。（不过，如果你想辩论关于属性的最 Pythonic 的通用观点，带上头盔吧。）
- en: Special Methods
  id: totrans-857
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊方法
- en: Special methods are my favorite part of Python object-oriented programming.
    I’m trembling a little with excitement right now (or maybe I had too much coffee).
    *Special methods*, sometimes called *magic methods*, allow you to add support
    to your classes for virtually any Python operator or built-in command!
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法是我最喜欢的 Python 面向对象编程部分。我现在有点激动（或者可能是咖啡喝多了）。*特殊方法*，有时也叫*魔法方法*，允许你为类添加几乎所有
    Python 运算符或内置命令的支持！
- en: 'Special methods are also colloquially known as *dunder methods*—which is short
    for “***d***ouble ***under***score”—because they begin and end with two underscore
    characters (`__`). You’ve already seen three examples of special methods: `__init__()`,
    `__new__()`, and `__del__()`. The Python language defines about a hundred special
    methods, most of which are documented at [https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html).
    I’ll cover a number of the most common ones here. In future chapters, I’ll discuss
    other special methods as they become relevant. I also list all the special methods
    in Python in Appendix A.'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法也被口语化地称为*dunder 方法*——这是“***d***ouble ***under***score”的缩写——因为它们的名称前后都带有两个下划线字符
    (`__`)。你已经看过三个特殊方法的例子：`__init__()`、`__new__()` 和 `__del__()`。Python 语言定义了大约一百个特殊方法，其中大部分都在[https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html)中有文档说明。我将在这里介绍一些最常见的方法。在未来的章节中，我会在相关时讨论其他特殊方法。我还在附录
    A 中列出了 Python 中所有的特殊方法。
- en: Scenario Setup
  id: totrans-860
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景设置
- en: 'For the examples in this section, I’ll use a new class, `GlobalCoordinates`,
    which will store a global coordinate as latitude and longitude. This class is
    defined as follows:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的示例中，我将使用一个新类`GlobalCoordinates`，该类将存储一个全球坐标的纬度和经度。这个类定义如下：
- en: '[PRE154]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Listing 7-30: *global_coordinates.py:1*'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-30：*global_coordinates.py:1*
- en: You can probably work out what’s going on here, based on the knowledge you have
    so far. The class `GlobalCoordinates` converts and stores a latitude and longitude
    as tuples of degrees, minutes, seconds, and a string literal representing a cardinal
    direction.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你目前掌握的知识，你可能已经能推测这里发生了什么。`GlobalCoordinates`类将纬度和经度转换并存储为度、分、秒的元组，并且有一个字符串字面量表示方位。
- en: I chose to create this particular class because its data lends itself well to
    a healthy subset of the special methods I’ll cover.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择创建这个特定的类，是因为它的数据非常适合我将要介绍的许多特殊方法的子集。
- en: Conversion Methods
  id: totrans-866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换方法
- en: There are many ways to represent the same data, and most clients will expect
    to be able to convert an object containing data to any Python primitive type that
    makes sense. For example, global coordinates could be expressed as strings or
    hashes. You should carefully consider what data types your class should support
    conversion to. Here, I cover some special methods for data conversions.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以表示相同的数据，大多数客户端希望能够将包含数据的对象转换为任何合理的Python基本类型。例如，全球坐标可以作为字符串或哈希表示。你应该仔细考虑你的类应该支持哪些数据类型的转换。这里，我介绍一些数据转换的特殊方法。
- en: 'Canonical String Representation: __repr__()'
  id: totrans-868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标准字符串表示：__repr__()
- en: When writing a class, it is considered good practice to define, at minimum,
    the `__repr__()` instance method, which returns the *canonical string representation*
    of the object. This string representation should ideally contain all the data
    necessary to create another class instance with the same contents.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写类时，通常建议至少定义`__repr__()`实例方法，该方法返回对象的*标准字符串表示*。这个字符串表示应该包含足够的数据，以便创建另一个拥有相同内容的类实例。
- en: 'If I don’t define a `__repr__()` instance method for `GlobalCoordinates`, Python
    falls back on its default version for objects, which is pretty uselessly underwhelming.
    I’ll create an instance of `GlobalCoordinates` and print this default representation
    via `repr()`:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我没有为`GlobalCoordinates`定义`__repr__()`实例方法，Python会回退到它的默认版本，这对于调试几乎没什么用。我将创建一个`GlobalCoordinates`的实例并通过`repr()`打印出这个默认表示：
- en: '[PRE155]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Listing 7-31: *global_coordinates_usage.py:1*'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-31：*global_coordinates_usage.py:1*
- en: 'Running that prints out the following canonical string representation:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后会打印出以下标准字符串表示：
- en: '[PRE156]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Not good for much, is it? Instead, I’ll define my own `__repr__()` instance
    method for the class:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 这没什么用，不是吗？于是，我将为这个类定义我自己的`__repr__()`实例方法：
- en: '[PRE157]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Listing 7-32: *global_coordinates.py:2*'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-32：*global_coordinates.py:2*
- en: 'I return a string containing all the information needed to recreate the instance:
    the class name, the latitude, and the longitude.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 我返回一个包含所有重建实例所需信息的字符串：类名、纬度和经度。
- en: 'Rerunning the code in [Listing 7-31](#listing7-31) now produces more useful
    information:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行[列表 7-31](#listing7-31)的代码，会输出更有用的信息：
- en: '[PRE158]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Human-Readable String Representation: __str__()'
  id: totrans-881
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 人类可读的字符串表示：__str__()
- en: The `__str__()` special method has a similar purpose to `__repr__()`, except
    that it’s meant to be human-readable, as opposed to the more technically inclined
    canonical representation, which is more useful for debugging.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '`__str__()`特殊方法与`__repr__()`有类似的目的，唯一的区别是它旨在以人类可读的方式呈现，而`__repr__()`则更多是技术性较强的标准表示，更有助于调试。'
- en: If you don’t define `__str__()`, the `__repr__()` function will be used instead,
    but that wouldn’t be desirable in this example. The user should only see the pretty
    coordinates!
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有定义`__str__()`，那么`__repr__()`函数将会被使用，但在这个例子中，这样做并不理想。用户应该只看到漂亮的坐标！
- en: 'Here’s my `__str__()` instance method for `GlobalCoordinates`:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我为`GlobalCoordinates`类编写的`__str__()`实例方法：
- en: '[PRE159]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Listing 7-33: *global_coordinates.py:3*'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-33：*global_coordinates.py:3*
- en: Unlike with `__repr__()`, I omit all that boring technical information and focus
    on composing and returning a string representation a user might want to see.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 与`__repr__()`不同，我省略了所有那些乏味的技术信息，专注于组成并返回用户可能希望看到的字符串表示。
- en: 'This method is called when an instance of the class is passed to `str()`, although
    passing the instance directly to `print()` or as an expression in a formatted
    string will also invoke `__str__()`. For example:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 当类的实例被传递给 `str()` 时，会调用此方法，尽管直接将实例传递给 `print()` 或作为格式化字符串中的表达式时也会调用 `__str__()`。例如：
- en: '[PRE160]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Listing 7-34: *global_coordinates_usage.py:2*'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-34: *global_coordinates_usage.py:2*'
- en: 'That outputs the following:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 那将输出以下内容：
- en: '[PRE161]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Lovely and readable!
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 漂亮且易读！
- en: 'Unique Identifier (Hash): __hash__()'
  id: totrans-894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 唯一标识符（哈希值）： __hash__()
- en: The `__hash__()` method typically returns a *hash value*, which is an integer
    that is unique to the data within the class instance. This allows you to use instances
    of the class in certain collections, such as keys in a dictionary or values in
    a set (see Chapter 9). It’s often helpful to write this method yourself, as the
    default behavior results in every class instance having a unique hash value, even
    if two instances contain the exact same data.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '`__hash__()` 方法通常返回一个 *哈希值*，这是一个整数，代表类实例中数据的唯一标识。这使得你可以将类的实例用于某些集合中，例如字典的键或集合中的值（参见第9章）。通常，自己编写此方法会更有帮助，因为默认行为会导致每个类实例具有唯一的哈希值，即使两个实例包含相同的数据。'
- en: The `__hash__()` method should only depend on values that won’t change for the
    life of the instance! Several collections rely on these hash values *never changing*,
    but the value of a mutable object might change.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '`__hash__()` 方法应仅依赖于实例生命周期内不会改变的值！多个集合依赖于这些哈希值 *永远不会改变*，但可变对象的值可能会变化。'
- en: 'Here’s my `__hash__()` function for `GlobalCoordinates`:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我为 `GlobalCoordinates` 编写的 `__hash__()` 方法：
- en: '[PRE162]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Listing 7-35: *global_coordinates.py:4*'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7-35: *global_coordinates.py:4*'
- en: I’ve taken the most common approach, which is to create a tuple containing all
    the important instance attributes and then to call `hash()` on the tuple, which
    returns the hash value of whatever is passed to it. I then return that hash value.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 我采用了最常见的方式，即创建一个包含所有重要实例属性的元组，然后对该元组调用 `hash()`，它会返回传入数据的哈希值。然后，我返回该哈希值。
- en: Additional Conversion Special Methods
  id: totrans-901
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他转换特殊方法
- en: 'Python has special methods for converting the data in the instance to other
    forms. It is up to you to decide which of these you will define on your class:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一些特殊方法用于将实例中的数据转换为其他形式。你可以根据需要决定在类中定义哪些方法：
- en: '`__bool__()` should return `True` or `False`. If this isn’t defined, the automatic
    conversion to a boolean value will check whether `__len__()` returns a nonzero
    value (see Chapter 9); otherwise, `True` will always be used.'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__bool__()` 应返回 `True` 或 `False`。如果未定义此方法，自动转换为布尔值时会检查 `__len__()` 是否返回非零值（参见第9章）；否则，默认会使用
    `True`。'
- en: '`__bytes__()` should return a `bytes` object (see Chapter 12).'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__bytes__()` 应返回一个 `bytes` 对象（参见第12章）。'
- en: '`__ceil__()` should return an `int` numeric value, usually resulting from rounding
    up a `float` value to the nearest integer.'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ceil__()` 应返回一个 `int` 数值，通常是通过将 `float` 值向上舍入到最接近的整数得到的结果。'
- en: '`__complex__()` should return a `complex` numeric value.'
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__complex__()` 应返回一个 `complex` 数值。'
- en: '`__float__()` should return a `float` numeric value.'
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__float__()` 应返回一个 `float` 数值。'
- en: '`__floor__()` should return an `int` numeric value, usually resulting from
    rounding down a `float` numeric value to the nearest integer.'
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__floor__()` 应返回一个 `int` 数值，通常是通过将 `float` 数值向下舍入到最接近的整数得到的结果。'
- en: '`__format__()` should accept a string representing the format specification
    (see Chapter 3) and return a string representation of the instance, with the specification
    applied. How exactly you apply the specification is up to you.'
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__format__()` 应接受一个表示格式说明符的字符串（参见第3章），并返回实例的字符串表示，其中应用了该说明符。如何应用该说明符由你决定。'
- en: '`__index__()` should return the same value as `__int__()`, which must also
    be defined if you write this method. The presence of this method indicates that
    the class should be considered a type of integer; you don’t have to throw away
    any data to get the integer value (lossless conversion).'
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__index__()` 应返回与 `__int__()` 相同的值，若你编写此方法，则必须定义 `__int__()`。该方法的存在表示该类应被视为整数类型；你不需要丢弃任何数据就能获得整数值（无损转换）。'
- en: '`__int__()` should return an `int` numeric value. You may simply have this
    function call `__ceil__()`, `__floor__()`, `__round__()`, or `__trunc__()`.'
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__int__()` 应返回一个 `int` 数值。你可以简单地让此方法调用 `__ceil__()`、`__floor__()`、`__round__()`
    或 `__trunc__()`。'
- en: '`__round__()` should return an `int` numeric value, usually resulting from
    rounding a `float` numeric value up or down.'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__round__()` 应返回一个 `int` 数值，通常是通过将 `float` 数值四舍五入得到的整数值。'
- en: '`__trunc__()` should return an `int` numeric value, usually resulting from
    dropping the non-whole (decimal) part of a `float` numeric value.'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__trunc__()`应该返回一个`int`类型的数值，通常是通过去掉`float`类型数值的小数部分得到的。'
- en: You only need to define the special methods that make sense for your class.
    In my case, *none* of these additional conversion methods are particularly suitable
    for a pair of global coordinates.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要为你的类定义那些合适的特殊方法。以我为例，*这些*额外的转换方法对于一对全球坐标来说并不适用。
- en: Comparison Methods
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较方法
- en: 'Python has six comparison special methods that correspond to the six comparison
    operators in Python: `==`, `!=`, `<`, `>`, `<=`, and `>=`. Each one conventionally
    returns a boolean value.'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: Python有六个比较特殊方法，分别对应Python中的六个比较运算符：`==`、`!=`、`<`、`>`、`<=`和`>=`。每个方法通常返回一个布尔值。
- en: If one of these special methods is called, but the method isn’t defined, the
    class instance will return the special value `NotImplemented` to alert Python
    that the comparison didn’t happen. This allows the language to decide the best
    response. In the case of comparisons with built-in types, `NotImplemented` will
    be coerced to the boolean value `False`, so as to not break algorithms that rely
    on those functions. In most other situations, a `TypeError` will be raised.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用了这些特殊方法，但方法未定义，类实例将返回特殊值`NotImplemented`，以提醒Python比较未发生。这允许语言决定最合适的响应。对于与内建类型的比较，`NotImplemented`将被强制转换为布尔值`False`，以免破坏依赖这些函数的算法。在大多数其他情况下，会抛出`TypeError`错误。
- en: 'Equals: __eq__()'
  id: totrans-918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 等于：__eq__()
- en: 'The `__eq__()` special method is called by the equals (`==`) operator. I’ll
    define this method for my `GlobalCoordinates` class:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '`__eq__()`特殊方法由等号（`==`）运算符调用。我将在我的`GlobalCoordinates`类中定义这个方法：'
- en: '[PRE163]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Listing 7-36: *global_coordinates.py:5*'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-36：*global_coordinates.py:5*
- en: 'All comparison special methods accept two parameters: `self` and `other`. These
    represent the operands on the left and right of the operator, so `a == b` would
    call `a.__eq__(b)`.'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 所有比较特殊方法都接受两个参数：`self`和`other`。这两个参数分别代表运算符左右两边的操作数，因此`a == b`会调用`a.__eq__(b)`。
- en: In the ongoing example, it would only make sense to compare two `GlobalCoordinates`
    class instances to one another. Comparing a `GlobalCoordinates` instance directly
    to an integer or a float wouldn’t be logical. Thus, this is one of those rare
    scenarios where type matters. I use `isinstance()` to ensure `other` is an instance
    of the `GlobalCoordinates` class (or a subclass thereof) ❶. If it is, I compare
    the instance attributes that constitute the latitude and longitude of one `GlobalCoordinates`
    instance to the same attributes of the other instance. I return `True` if they
    all match.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，比较两个`GlobalCoordinates`类的实例才有意义。直接将`GlobalCoordinates`实例与整数或浮点数进行比较是没有逻辑的。因此，这种情况下类型非常重要。我使用`isinstance()`来确保`other`是`GlobalCoordinates`类（或其子类）的实例
    ❶。如果是，我将比较两个`GlobalCoordinates`实例的经纬度属性。如果它们完全匹配，则返回`True`。
- en: However, if `other` is of a different type, the comparison doesn’t happen, so
    I return the special value `NotImplemented` ❶.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`other`是不同类型的对象，比较就不会发生，所以我返回特殊值`NotImplemented` ❶。
- en: 'Not Equals: __ne__()'
  id: totrans-925
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不等于：__ne__()
- en: The `__ne__()` special method corresponds to the not-equals (`!=`) operator.
    If undefined, a call to `__ne__()` *delegates* to `__eq__()`, just returning the
    opposite value that `__eq__()` does. If this is what you’re expecting, there’s
    no need to define `__ne__()`.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '`__ne__()`特殊方法对应不等于（`!=`）运算符。如果未定义，调用`__ne__()`会*委托*给`__eq__()`，仅返回与`__eq__()`相反的值。如果这是你所期望的，就不需要定义`__ne__()`。'
- en: However, if there’s more complex logic to your not-equals comparison, it might
    make sense to define it.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果不等于的比较有更复杂的逻辑，可能会有必要定义它。
- en: 'Less Than and Greater Than: __lt__() and __gt__()'
  id: totrans-928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 小于和大于：__lt__() 和 __gt__()
- en: 'The special methods `__lt__()` and `__gt__()` correspond to the less-than (`<`)
    and greater-than (`>`) operators, respectively. These two special methods are
    *reflections* of one another, meaning one operator in the pair can be substituted
    for the other. The expression `a < b` calls `a.__lt__(b)`, but if that returns
    ``NotImplemented, Python automatically flips the logic and calls `b.__gt__(a)`.
    Thus, if you’re only comparing instances of the same class, you can often get
    away with defining just one of the two special methods: usually, `__lt__()`. The
    same is true of `__le__()` and `__ge__()`, which correspond to less-than-or-equal-to
    (`<=`) and greater-than-or-equal-to (`>=`).``'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法`__lt__()`和`__gt__()`分别对应小于（`<`）和大于（`>`）运算符。这两个特殊方法是*互为镜像*的，这意味着一对运算符中的一个可以替代另一个。表达式`a
    < b`调用`a.__lt__(b)`，但如果返回``NotImplemented``，Python 会自动反转逻辑并调用`b.__gt__(a)`。因此，如果你只比较同一类的实例，通常只需要定义这两个特殊方法中的一个：通常是`__lt__()`。`__le__()`和`__ge__()`也是如此，它们分别对应小于或等于（`<=`）和大于或等于（`>=`）。
- en: '[PRE164]  def __sub__(self, other):         if not isinstance(other, GlobalCoordinates):             return
    NotImplemented          lat_diff = self.latitude - other.latitude         lon_diff
    = self.longitude - other.longitude         return (lat_diff, lon_diff) [PRE165]  def
    __invert__(self):         return GlobalCoordinates(             latitude=self.degrees_from_decimal(-self.latitude,
    lat=True),             longitude=self.degrees_from_decimal(-self.longitude, lat=False)         )
    [PRE166]  def __call__(self, ❶ other):         EARTH_RADIUS_KM = 6371          distance_lat
    = math.radians(other.latitude - self.latitude)         distance_lon = math.radians(other.longitude
    - self.longitude)         lat = math.radians(self.latitude)         lon = math.radians(self.longitude)         a
    = (             math.sin(distance_lat / 2)             * math.sin(distance_lat
    / 2)             + math.sin(distance_lon)             * math.sin(distance_lon
    / 2)             * math.cos(lat)             * math.cos(lon)         )         c
    = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))        ❷ return c * EARTH_RADIUS_KM
    [PRE167] nostarch = GlobalCoordinates(latitude=(37, 46, 32.6, "N"),                              longitude=(122,
    24, 39.4, "W"))  psf = GlobalCoordinates(latitude=(45, 27, 7.7, "N"),                         longitude=(122,
    47, 30.2 "W"))  distance = nostarch(psf) print(distance)  # 852.6857266443297
    [PRE168] class CoffeeOrder:      def __init__(self, recipe, to_go=False):         self.recipe
    = recipe         self.to_go = to_go      def brew(self):         vessel = "in
    a paper cup" if self.to_go else "in a mug"         print("Brewing", *self.recipe.parts,
    vessel)   class CoffeeRecipe:      def __init__(self, parts):         self.parts
    = parts   special = CoffeeRecipe(["double-shot", "grande", "no-whip", "mocha"])
    order = CoffeeOrder(special, to_go=False) order.brew()  # prints "Brewing double-shot
    grande no-whip mocha in a mug" [PRE169] import functools ❶ def auto_order(to_go):     def
    decorator(cls):         @functools.wraps(cls)         def wrapper(*args, **kwargs):          ❷
    recipe = cls(*args, **kwargs)          ❸ return (CoffeeOrder(recipe, to_go), recipe)         return
    wrapper   ❹ return decorator [PRE170] @auto_order(to_go=True) class CoffeeShackRecipe(CoffeeRecipe):     pass   order,
    recipe = CoffeeShackRecipe(["tall", "decaf", "cappuccino"]) order.brew()  # prints
    "Brewing tall decaf cappuccino in a paper cup" [PRE171] class Pizza:      def
    __init__(self, topping, second_topping=None):         self.first = topping         self.second
    = second_topping  order = Pizza("pepperoni", "mushrooms")  match order:     case
    Pizza(first=''pepperoni'', second=''mushroom''):         print("ANSI standard
    pizza")     case Pizza(first=''pineapple''):         print("Is this even pizza?")
    [PRE172] # `--snip--`  match order:   # `--snip--`     case Pizza(first=''pineapple''):         print("Is
    this even pizza?")  **case Pizza(first=first, second=''cheese''):**  **print(f"Very
    cheesy pizza with {first}.")** [PRE173] # `--snip--`  match order:   # `--snip--`  `case
    Pizza(first=first, second=''cheese''):`  `print(f"Very cheesy pizza with {first}.")`  **case
    Pizza(first=first, second=second):**  **print(f"Pizza with {first} and {second}.")**
    [PRE174] class Point:     def __init__(self, x, y, z):         self.x_pos = x         self.y_pos
    = y         self.z_pos = z   point = Point(0, 100, 0)  match point:     case Point(x_pos=0,
    y_pos=0, z_pos=0):         print("You are here.")     case Point(x_pos=0, y_pos=_,
    z_pos=0):         print("Look up!") [PRE175] class Point:  **__match_args__ =
    (''x_pos'', ''y_pos'', ''z_pos'')**      def __init__(self, x, y, z):         self.x_pos
    = x         self.y_pos = y         self.z_pos = z   point = Point(0, 123, 0)  match
    point:     case Point(**0, 0, 0**):         print("You are here.")     case Point(**0,
    _, 0**):         print("Look up!") [PRE176] thing.action()  # this can mutate
    attributes in thing [PRE177] action(thing)  # should not modify thing; returns
    new value or object [PRE178]`  [PRE179] import random   def generate_puzzle(low=1,
    high=100):     print(f"I''m thinking of a number between {low} and {high}...")     return
    random.randint(low, high) [PRE180] def make_guess(target):     guess = int(input("Guess:
    "))      if guess == target:         return True      if guess < target:         print("Too
    low.")     elif guess > target:         print("Too high.")     return False [PRE181]
    def play(tries=8):     target = generate_puzzle()     while tries > 0:         if
    make_guess(target):             print("You win!")             return   tries -=
    1         print(f"{tries} tries left.")      print(f"Game over! The answer was
    {target}.") [PRE182] if __name__ == ''__main__'':     play() [PRE183] I''m thinking
    of a number between 1 and 100... Guess: 50 Too low. 7 tries left. Guess: 75 Too
    low. 6 tries left. Guess: 90 Too high. 5 tries left. Guess: 87 You win! [PRE184]
    I''m thinking of a number between 1 and 100... Guess: Fifty Traceback (most recent
    call last):   File "./number_guess.py", line 35, in <module>     play()   File
    "./number_guess.py", line 25, in play     if make_guess(target):  File "./number_guess.py",
    line 10, in make_guess     guess = int(input("Guess: ")) ValueError: invalid literal
    for int() with base 10: ''Fifty'' [PRE185] ValueError: invalid literal for int()
    with base 10: ''Fifty'' [PRE186]  File "./number_guess.py", line 10, in make_guess     guess
    = int(input("Guess: ")) [PRE187]  File "./number_guess.py", line 25, in play     if
    make_guess(target): [PRE188]  File "./number_guess.py", line 35, in <module>     play()
    [PRE189] Traceback (most recent call last): [PRE190] def make_guess(target):     **guess
    = None**     **while guess is None:**         **try:**             guess = int(input("Guess:
    "))         **except ValueError:**             **print("Enter an integer.")**      if
    guess == target:         return True      if guess < target:         print("Too
    low.")     elif guess > target:         print("Too high.")     return False [PRE191]
    def make_guess(target):     guess = None     while guess is None:         guess
    = input()         **if guess.isdigit():**             guess = int(guess)         **else:**             print("Enter
    an integer.")             guess = None      if guess == target:         return
    True      if guess < target:         print("Too low.")     elif guess > target:         print("Too
    high.")     return False [PRE192] class AverageCalculator:      def __init__(self):         self.total
    = 0         self.count = 0      def __call__(self, *values):         if values:             for
    value in values:                 self.total += float(value)                 self.count
    += 1         return self.total / self.count [PRE193] average = AverageCalculator()
    values = input("Enter scores, separated by spaces:\n    ").split() try:     print(f"Average
    is {average(*values)}") except ❶ ZeroDivisionError:     print("ERROR: No values
    provided.") except ( ❷ ValueError, ❸ UnicodeError):     print(f"ERROR: All inputs
    should be numeric.") [PRE194] try:     some_scary_function() except:     print("An
    error occurred. Moving on!") [PRE195] def greet():     name = input("What''s your
    name? ")     print(f"Hello, {name}.")   while True:     try:         greet()         break     except:         print("Error
    caught") [PRE196] What''s your name? ^CError caught What''s your name? ^CError
    caught What''s your name? ^CError caught What''s your name?  [PRE197] def greet():     name
    = input("What''s your name? ")     print(f"Hello, {name}.")   while True:     try:         greet()         break  **except
    Exception:**         print("Error caught") [PRE198] def average(number_string):     total
    = 0     skip = 0     values = 0     for n in number_string.split():         values
    += 1       ❶ try:             total += float(n)       ❷ except ValueError:             skip
    += 1 [PRE199]  ❸ if skip == values:         raise ValueError("No valid numbers
    provided.")     elif skip:         print(f"<!> Skipped {skip} invalid values.")      return
    total / values [PRE200] while True:     line = input("Enter numbers (space delimited):\n    ")     avg
    = average(line)     print(avg) [PRE201] Enter numbers (space delimited):     4
    5 6 7  5.5 [PRE202] Enter numbers (space delimited):     four five 6 7 <!> Skipped
    2 invalid values. 3.25 [PRE203] Enter numbers (space delimited):     four five
    six seven Traceback (most recent call last):   File "./raiseexception.py", line
    25, in <module>     avg = average(line)   File "./raiseexception.py", line 16,
    in average     raise ValueError("No valid numbers provided.") ValueError: No valid
    numbers provided. [PRE204] while True:     **try:**         line = input("Enter
    numbers (space delimited):\n    ")         avg = average(line)  print(avg)     **except
    ValueError:**         **print("No valid numbers provided.")** [PRE205] Enter numbers
    (space delimited):     four five six No valid numbers provided. Enter numbers
    (space delimited):     4 5 6 5.0 [PRE206] friend_emails = {     "Anne": "anne@example.com",     "Brent":
    "brent@example.com",     "Dan": "dan@example.com",     "David": "david@example.com",     "Fox":
    "fox@example.com",     "Jane": "jane@example.com",     "Kevin": "kevin@example.com",     "Robert":
    "robert@example.com" } [PRE207] def lookup_email(name):     try:         return
    friend_emails[name]  except KeyError ❶ as e:         print(f"<No entry for friend
    {e}>") [PRE208] name = input("Enter name to look up: ") email = lookup_email(name)
    print(f"Email: {email}") [PRE209] Enter name to look up: Jason <No entry for friend
    ''Jason''> Email: None [PRE210] import logging from operator import add, sub,
    mul, truediv import sys [PRE211] logging.basicConfig(filename=''log.txt'', level=logging.INFO)
    [PRE212] def calculator(a, b, op):     a = float(a)     b = float(b)     if op
    == ''+'':         return ❶ add(a, b)     elif op == ''-'':         return sub(a,
    b)     elif op == ''*'':         return mul(a, b)     elif op == ''/'':         return
    truediv(a, b)     else:       ❷ raise NotImplementedError(f"No operator {op}")
    [PRE213] print("""CALCULATOR Use postfix notation. Ctrl+C or Ctrl+D to quit. """)  ❶
    while True:   ❷ try:         equation = input(" ").split()         result = calculator(*equation)         print(result)
    [PRE214]  except NotImplementedError as e:         print("<!> Invalid operator.")         logging.info(e)
    [PRE215]  except ValueError as e:         print("<!> Expected format: <A> <B>
    <OP>")         logging.info(e) [PRE216]  except TypeError as e:         print("<!>
    Wrong number of arguments. Use: <A> <B> <OP>")         logging.info(e) [PRE217]  except
    ZeroDivisionError as e:         print("<!> Cannot divide by zero.")         logging.info(e)
    [PRE218]  except (KeyboardInterrupt, EOFError):         print("\nGoodbye.")         sys.exit(0)
    [PRE219] CALCULATOR Use postfix notation. Ctrl+C or Ctrl+D to quit.   11 31 +
    42.0  11 + 31 <!> Expected format: <A> <B> <OP>  11 + 31 + 10 <!> Wrong number
    of arguments. Use: <A> <B> <OP>  11 + <!> Wrong number of arguments. Use: <A>
    <B> <OP>  10 0 / <!> Cannot divide by zero.  10 40 @ <!> Invalid operator.  ^C
    Goodbye. [PRE220] INFO:root:could not convert string to float: ''+'' INFO:root:calculator()
    takes 3 positional arguments but 5 were given INFO:root:calculator() missing 1
    required positional argument: ''op'' INFO:root:float division by zero INFO:root:No
    operator @ [PRE221]  except Exception as e:         logging.exception(e)       ❶
    raise [PRE222] cities = {     "SEATTLE": "WASHINGTON, USA",     "PORTLAND": "OREGON,
    USA",     "BOSTON": "MASSACHUSETTS, USA", }  landmarks = {     "SPACE NEEDLE":
    "SEATTLE",     "LIBERTY SHIP MEMORIAL": "PORTLAND",     "ALAMO": "SAN ANTONIO",
    } [PRE223] def lookup_landmark(landmark):     landmark = landmark.upper()     try:         city
    = landmarks[landmark]         state = cities[city]   ❶ except KeyError as e:       ❷
    raise KeyError("Landmark not found.") from e     print(f"{landmark} is in {city},
    {state}") [PRE224] lookup_landmark("space needle") lookup_landmark("alamo") lookup_landmark("golden
    gate bridge") [PRE225] SPACE NEEDLE is in SEATTLE, WASHINGTON, USA Traceback (most
    recent call last):   File "./chaining.py", line 18, in lookup_landmark     state
    = cities[city] ❶ KeyError: ''SAN ANTONIO''  ❷ The above exception was the direct
    cause of the following exception:  Traceback (most recent call last):  File "./chaining.py",
    line 25, in <module>     lookup_landmark("alamo")   File "./chaining.py", line
    20, in lookup_landmark     raise KeyError("Landmark not found.") from e ❸ KeyError:
    ''Landmark not found.'' [PRE226] During handling of the above exception, another
    exception occurred: [PRE227] import math   def average_string(number_string):     try:         numbers
    = [float(n) for n in number_string.split()]  except ValueError:         total
    = math.nan         values = 1 [PRE228]  else:         total = sum(numbers)         values
    = len(numbers) [PRE229]  try:         average = total / values     except ZeroDivisionError:         average
    = math.inf      return average   while True:     number_string = input("Enter
    space-delimited list of numbers:\n    ")     print(average_string(number_string))
    [PRE230]  4 5 6 7 5.5      inf     four five six nan [PRE231] def average_file(path):     file
    = open(path, ''r'')      try:       ❶ numbers = [float(n) for n in file.readlines()]
    [PRE232]  except ValueError as e:         raise ValueError("File contains non-numeric
    values.") from e [PRE233]  else:         try:             return sum(numbers)
    / len(numbers)         except ZeroDivisionError as e:             raise ValueError("Empty
    file.") from e [PRE234]  finally:         print("Closing file.")         file.close()
    [PRE235] print(average_file(''numbers_good.txt'')) [PRE236] Closing file. 42.0
    [PRE237] print(average_file(''numbers_bad.txt'')) [PRE238] ❶ Closing file. Traceback
    (most recent call last):   File "tryfinally.py", line 5, in average_file     numbers
    = [float(n) for n in file.readlines()]   File "tryfinally.py", line 5, in <listcomp>     numbers
    = [float(n) for n in file.readlines()] ValueError: could not convert string to
    float: ''thirty-three\n''  The above exception was the direct cause of the following
    exception:  Traceback (most recent call last):   File "tryfinally.py", line 20,
    in <module>     print(average_file(''numbers_bad.txt''))  # ValueError   File
    "tryfinally.py", line 7, in average_file     raise ValueError("File contains non-numeric
    values.") from e ValueError: File contains non-numeric values. [PRE239] print(average_file(''numbers_empty.txt''))
    [PRE240] ❶ Closing file. Traceback (most recent call last):   File "tryfinally.py",
    line 10, in average_file     return sum(numbers) / len(numbers) ZeroDivisionError:
    division by zero  The above exception was the direct cause of the following exception:  Traceback
    (most recent call last):   File "tryfinally.py", line 21, in <module>     print(average_file(''numbers_empty.txt''))  #
    ValueError   File "tryfinally.py", line 12, in average_file     raise ValueError("Empty
    file.") from e ❷ ValueError: Empty file. [PRE241] print(average_file(''nonexistent.txt''))
    [PRE242] Traceback (most recent call last):   File "tryfinally.py", line 22, in
    <module>     print(average_file(''nonexistent.txt''))  # FileNotFoundError   File
    "tryfinally.py", line 2, in average_file     file = open(path, ''r'') FileNotFoundError:
    [Errno 2] No such file or directory: ''nonexistent.txt'' [PRE243] class ❶ SillyWalkException(
    ❷ RuntimeError):     def __init__(self, ❸ message="Someone walked silly."):         super().__init__(message)   def
    walking():   ❹ raise SillyWalkException("My walk has gotten rather silly.")   try:     walking()
    ❺ except SillyWalkException as e:     print(e) [PRE244] class SillyWalkException(RuntimeError):     """Exception
    for walking silly.""" [PRE245]`**'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
