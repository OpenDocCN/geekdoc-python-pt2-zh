- en: Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分
- en: ESSENTIAL STRUCTURES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基本结构
- en: '5'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Variables and Types
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和类型
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Some of the most pernicious misconceptions about Python revolve around its nuances
    regarding variables and data types. Misunderstandings related to this *one* topic
    cause countless frustrating bugs, and this is unfortunate. Python’s way of handling
    variables is at the core of its power and versatility. If you understand this,
    everything else falls into place.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Python的误解中，一些最具误导性的是围绕变量和数据类型的细微差别。与这个*单一*主题相关的误解导致了无数令人沮丧的错误，真是遗憾。Python处理变量的方式是其强大和多功能的核心。如果你理解了这一点，其他一切都会迎刃而解。
- en: My own understanding of this topic was cemented by “Facts and Myths About Python
    Names and Values,” Ned Batchelder’s now-legendary talk at PyCon 2015\. I recommend
    you watch the video of the presentation at [https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns),
    either now or after reading this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个主题的理解是通过Ned Batchelder在2015年PyCon大会上的经典演讲《Python名称和值的事实与误区》得以巩固的。我建议你观看这场演讲的视频，链接是[https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns)，可以在阅读完本章后再观看。
- en: 'Variables According to Python: Names and Values'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的变量：名称和值
- en: Many myths about Python variables stem from people’s attempts to describe the
    language in terms of *other languages*. Perhaps most annoying to Python experts
    is the misleading aphorism, “Python has no variables,” which is really just the
    product of someone being overly clever about the fact that the Python language
    uses the terms *name* and *value*, instead of *variable*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多关于Python变量的误区源于人们试图用*其他语言*的术语来描述Python。也许最让Python专家烦恼的是那句误导性的格言：“Python没有变量”，这实际上只是某些人过于聪明地强调了Python语言使用*名称*和*值*的术语，而不是*变量*。
- en: Python developers still use the term *variable* on a regular basis, and it even
    appears in the documentation, as it is part of understanding the overall system.
    However, for the sake of clarity, I’ll use the official Python terms exclusively
    throughout the rest of the book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python开发者仍然常常使用*变量*这个术语，它甚至出现在文档中，因为它是理解整体系统的一部分。然而，为了清晰起见，我将在本书的其余部分中只使用官方的Python术语。
- en: 'Python uses the term *name* to refer to what would conventionally be called
    a variable. A name refers to a value or an object, in the same way that your name
    refers to you but does not contain you. There may even be multiple names for the
    same thing, just as you may have a given name and a nickname. A *value* is a particular
    instance of data in memory. The term *variable* refers to the combination of the
    two: a name that refers to a value. From now on, I’ll only use the term *variable*
    in relation to this precise definition.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用*名称*这个术语来表示传统意义上的变量。一个名称指向一个值或一个对象，就像你的名字指向你，但并不包含你一样。一个东西可能有多个名称，就像你可能有本名和昵称一样。*值*是内存中数据的具体实例。术语*变量*指的是这两者的结合：一个指向值的名称。从现在开始，我只会在这个精确定义的语境中使用*变量*这个术语。
- en: Assignment
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值
- en: 'Let’s look at what happens under the hood when I define a variable per the
    above definitions like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我按照上述定义这样定义一个变量时，幕后发生了什么：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5-1: *simple_assignment.py:1*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-1：*simple_assignment.py:1*
- en: The name `answer` is *bound* to the value `42`, meaning the name can now be
    used to refer to the value in memory. This operation of binding is referred to
    as an *assignment*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`answer`被*绑定*到值`42`，这意味着现在可以使用该名称来引用内存中的值。这个绑定操作称为*赋值*。
- en: 'Look at what happens behind the scenes when I assign the variable `answer`
    to a new variable, `insight`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当我将变量`answer`赋值给新变量`insight`时，幕后发生了什么：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5-2: *simple_assignment.py:2*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-2：*simple_assignment.py:2*
- en: The name `insight` doesn’t refer to a copy of the value `42`, but rather to
    the same, original value. This is illustrated in [Figure 5-1](#figure5-1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`insight`并不是指值`42`的副本，而是指同一个原始值。这个过程在[图 5-1](#figure5-1)中得到了说明。
- en: '![](Images/f05001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f05001.png)'
- en: 'Figure 5-1: Multiple names can be bound to the same value in memory.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1：多个名称可以绑定到内存中相同的值。
- en: 'In memory, the name `insight` is bound to the value `42`, which was already
    bound to another name: `answer`. Both names are still usable as variables. More
    importantly, `insight` is not bound to `answer`, but rather to the same value
    that `answer` was already bound to when I assigned `insight`. A name always points
    to a value.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，名称 `insight` 被绑定到值 `42`，而这个值已经绑定到另一个名称：`answer`。两个名称仍然可以作为变量使用。更重要的是，`insight`
    并不是绑定到 `answer`，而是绑定到 `answer` 原先绑定的那个值。当我给 `insight` 赋值时，`insight` 总是指向一个值。
- en: Back in Chapter 3, I introduced the `is` operator, which compares *identity*—the
    specific location in memory that a name is bound to. This means `is` doesn’t check
    whether a name points to equivalent values, but rather whether it points to the
    *same* value in memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章，我介绍了 `is` 运算符，它比较的是 *身份* —— 即名称所绑定的内存位置。这意味着 `is` 并不会检查名称是否指向相等的值，而是检查它是否指向内存中的
    *同一个* 值。
- en: When you make an assignment, Python makes its own decisions behind the scenes
    about whether to create a new value in memory or bind to an existing value. The
    programmer often has very little control over this decision.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行赋值操作时，Python 会在幕后做出决定，决定是创建一个新的内存值，还是绑定到现有的值上。程序员通常无法控制这个决策。
- en: 'To see this, run this example in an interactive session instead of a file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这个，你可以在交互式会话中运行这个示例，而不是在文件中运行：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 5-3: (Interactive session):1'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-3: （交互式会话）：1'
- en: I assign identical values to `spam` and `eggs`. I also bind `maps` to the same
    value as `spam`. (In case you didn’t catch it, “maps” is “spam” backward. No wonder
    GPS gets annoying.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我将相同的值赋给 `spam` 和 `eggs`，并将 `maps` 绑定到与 `spam` 相同的值。（如果你没有注意到，“maps” 是 “spam”
    反过来拼写的，怪不得 GPS 会让人抓狂。）
- en: 'When I compare the names with the comparison operator (`==`) to check whether
    the values are equivalent, both expressions return `True`, as one would expect:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用比较运算符（`==`）比较名称，检查值是否相等时，两个表达式都会返回 `True`，正如预期的那样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-4: (Interactive session):2'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-4: （交互式会话）：2'
- en: 'However, when I compare the identities of the names with `is`, something surprising
    happens:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我使用 `is` 比较名称的身份时，发生了一些令人惊讶的事情：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 5-5: (Interactive session):3'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-5: （交互式会话）：3'
- en: The names `spam` and `maps` are both bound to the same value in memory, but
    `eggs` is probably bound to a different but equivalent value. Thus, `spam` and
    `eggs` don’t share an identity. This is illustrated in [Figure 5-2](#figure5-2).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam` 和 `maps` 两个名称都绑定到了内存中的同一个值，但 `eggs` 可能绑定到了一个不同但等效的值。因此，`spam` 和 `eggs`
    并不共享身份。这个情况如图 [图 5-2](#figure5-2) 所示。'
- en: '![](Images/f05002.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f05002.png)'
- en: 'Figure 5-2: `spam` and `maps` share an identity; `eggs` is bound to an equivalent
    value, but it does not share identity.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：`spam` 和 `maps` 共享相同的身份；`eggs` 被绑定到一个等效的值，但它并不共享身份。
- en: It just goes to show, spam by any other name is still spam.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这正好说明了，不管叫啥，spam 还是 spam。
- en: 'Python isn’t guaranteed to behave exactly like this, and it may well decide
    to reuse an existing value. For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并不保证总是以这种方式表现，它可能会决定重用一个现有的值。例如：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-6: (Interactive session)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-6: （交互式会话）'
- en: When I assign the value `42` to `insight`, Python decides to bind that name
    to the existing value. Now, `answer` and `insight` happen to be bound to the same
    value in memory, and thus, they share an identity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将值 `42` 赋给 `insight` 时，Python 会决定将这个名称绑定到现有的值上。现在，`answer` 和 `insight` 恰好都被绑定到内存中的同一个值，因此它们共享相同的身份。
- en: This is why the identity operator (`is`) can be sneaky. There are many situations
    in which `is` appears to work like the comparison operator (`==`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么身份运算符（`is`）可能会让人产生误解的原因。实际上有很多情况下，`is` 看起来像是比较运算符（`==`）一样工作。
- en: As a final note, the built-in function `id()` returns an integer representing
    the identity of whatever is passed to it. These integers are the values that the
    `is` operator compares. If you’re curious about how Python handles names and values,
    try playing with `id()`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后提醒，内建函数 `id()` 会返回一个整数，表示传递给它的对象的身份。这些整数是 `is` 运算符进行比较的值。如果你对 Python 如何处理名称和值感到好奇，可以试着玩玩
    `id()`。
- en: Data Types
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: As you’ve likely noticed, Python does not require you, the programmer, to declare
    a type for your variables. Back when I first picked up Python, I joined the `#python`
    channel on IRC and jumped right in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，Python 并不要求你作为程序员为变量声明类型。刚开始学习 Python 时，我加入了 IRC 上的 `#python` 频道，直接跳了进去。
- en: “How do you declare the data type of a variable in Python?” I asked, in all
    the naivete of a first-year coder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “如何在 Python 中声明变量的数据类型？”我问道，带着作为一年级编程新手的天真。
- en: 'Within moments, I received a response that I consider to be my first true induction
    into the bizarre world of programming: “You’re a data type.”'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我收到了一个回复，我认为这是我第一次真正进入编程这一奇异世界的引导：“你是一个数据类型。”
- en: 'The room regulars went on to explain that Python is a dynamically typed language,
    meaning I didn’t have to tell the language what sort of information to put in
    a variable. Instead, Python would decide the type for me. I didn’t even have to
    use a special “variable declaration” keyword. I just had to assign like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 常客们接着解释道，Python 是一种动态类型语言，这意味着我不需要告诉语言在变量中放入什么类型的信息。相反，Python 会为我决定类型。我甚至不需要使用特殊的“变量声明”关键字。我只需像这样进行赋值：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 5-7: *types.py:1*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-7: *types.py:1*'
- en: At that precise moment, Python became my all-time favorite language.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就在那一刻，Python 成为我最喜欢的编程语言。
- en: 'It’s important to remember that Python is still a strongly typed language.
    I touched on this concept, along with dynamic typing, in Chapter 3. Ned Batchelder
    sums up Python’s type system quite brilliantly in his aforementioned PyCon 2015
    talk about names and values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，Python 仍然是一种强类型语言。我在第三章中提到过这个概念，并与动态类型一起讨论。Ned Batchelder 在他前述的 2015
    年 PyCon 演讲中，关于名字和值的讨论中精彩地总结了 Python 的类型系统：
- en: Names have a scope—they come and go with functions—but they have no type. Values
    have a type . . . but they have no scope.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 名字有作用域——它们随着函数的来去而存在——但它们没有类型。值有类型……但它们没有作用域。
- en: Although I haven’t touched on scope yet, this should already make sense. Names
    are bound to values, and those values exist in memory, as long as there is some
    *reference* to them. You can bind a name to literally any value you want, but
    you are limited as to what you can do with any particular value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我还没有讲解作用域，但这应该已经能让你理解。名字绑定到值，而这些值存在于内存中，只要有某种*引用*指向它们。你可以将名字绑定到任何你想要的值，但你在使用特定值时会有所限制。
- en: The type() Function
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`type()` 函数'
- en: 'If you ever need to know a value’s data type, you can use the built-in `type()`
    function. Recall that everything in Python is an object, so this function will
    really just return what class the value is an instance of:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要知道一个值的数据类型，可以使用内置的 `type()` 函数。回想一下，Python 中的每一切都是对象，因此该函数实际上会返回值所属的类：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 5-8: *types.py:2*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-8: *types.py:2*'
- en: 'Here, you can see that the value assigned to `answer` is an integer (`int`).
    On rare occasions, you may want to check the data type before you do something
    with a value. For that, you can pair the `type()` function with the `is` operator,
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到赋给 `answer` 的值是一个整数（`int`）。在某些少见的情况下，你可能需要在对值进行操作之前检查数据类型。为此，你可以将 `type()`
    函数与 `is` 操作符结合使用，如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 5-9: *types.py:3a*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-9: *types.py:3a*'
- en: 'In many cases where this sort of introspection is necessary, it may be better
    to use `isinstance()` instead of `type()`, as it accounts for subclasses and inheritance
    (see Chapter 13). The function itself returns `True` or `False`, so I can use
    it as the condition in an `if` statement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多需要这种自省的情况下，使用 `isinstance()` 而不是 `type()` 可能会更好，因为 `isinstance()` 会考虑子类和继承关系（见第13章）。该函数本身返回
    `True` 或 `False`，所以我可以将它用作 `if` 语句中的条件：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 5-10: *types.py:3b*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-10: *types.py:3b*'
- en: Truth be told, there is rarely a need for either. Instead, Python developers
    prefer a more dynamic approach.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，几乎没有必要使用声明。相反，Python 开发者更倾向于采用更动态的方法。
- en: Duck Typing
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: 'Python uses what is known (unofficially) as *duck typing*. This isn’t a technical
    term at all; it comes from the old saying:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用被称为（非正式地）*鸭子类型*的方式。这根本不是一个技术术语，它来源于一句古老的谚语：
- en: If it looks like a duck, walks like a duck, and quacks like a duck, then it
    probably *is* a duck.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果它看起来像鸭子，走起来像鸭子，叫声也像鸭子，那么它很可能*就是*鸭子。
- en: Python doesn’t care much about what a value’s data type is, but rather it cares
    about the *functionality* of the value’s data type. For example, if an object
    supports all the math operators and functions, and if it accepts floats and integers
    as operands on the binary operators, then Python considers the object to be a
    numeric type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对一个值的数据类型并不那么关心，而更关心该值数据类型的*功能性*。例如，如果一个对象支持所有的数学运算符和函数，并且能够接受浮点数和整数作为二元运算符的操作数，那么
    Python 就会将该对象视为数值类型。
- en: In other words, Python doesn’t care if it’s actually a robotic duck or a moose
    in a duck costume. If it has the traits needed, the rest of the details are usually
    moot.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Python 并不关心它是否真的是一只机器人鸭子或穿着鸭子服装的驼鹿。如果它具有所需的特征，其他细节通常就不那么重要了。
- en: If you’re familiar with object-oriented programming, particularly how quickly
    inheritance can get out of hand, then this whole concept of duck typing will probably
    be a breath of fresh air. If your class behaves as it should, it usually won’t
    matter what it inherits from.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉面向对象编程，尤其是继承如何迅速变得难以管理，那么鸭子类型（duck typing）这一概念可能会让你如沐春风。如果你的类表现得符合预期，通常就不需要关心它继承了什么。
- en: Scope and Garbage Collection
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围和垃圾回收
- en: '*Scope* is what defines where a variable can be accessed from. It might be
    available to an entire module or limited to the suite (body) of a function.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围*定义了一个变量可以从哪里访问。它可能对整个模块可用，也可能仅限于某个函数的代码块（主体）。'
- en: As I mentioned already, names have *scope*, whereas values do not. A name can
    be *global*, meaning it is defined by itself in a module, or it can be *local*,
    meaning it only exists within a particular function or comprehension.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所提到的，名称有*作用域*，而值则没有。一个名称可以是*全局的*，意味着它是在模块中独立定义的，或者它可以是*局部的*，意味着它仅在特定的函数或推导式内存在。
- en: Local Scope and the Reference-Counting Garbage Collector
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地作用域与引用计数垃圾回收器
- en: Functions (including lambdas) and comprehensions define their own scope; they
    are the only structures in the language to do so. Modules and classes don’t have
    their own scope in the strictest sense; they only have their own namespace. When
    a scope reaches its end, all the names defined within it are automatically deleted.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数（包括 lambda）和推导式定义了它们自己的作用域；它们是语言中唯一具备这种特性的结构。模块和类在严格意义上没有自己的作用域；它们只有自己的命名空间。当一个作用域结束时，定义在其中的所有名称会被自动删除。
- en: For any particular value, Python keeps a *reference count*, which is simply
    a count of how many references exist for that value. Every time a value is bound
    to a name, a reference is created (although there are other ways the language
    may create references). When there are no more references, the value is deleted.
    This is the *reference-counting garbage collector*, and it efficiently handles
    most garbage collection scenarios.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何特定的值，Python 会保持一个*引用计数*，它简单地记录了该值有多少个引用。每次将一个值绑定到一个名称时，就会创建一个引用（虽然语言可能通过其他方式创建引用）。当没有更多引用时，该值会被删除。这就是*引用计数垃圾回收器*，它能够高效地处理大多数垃圾回收场景。
- en: 'You can see how this works with a typical function, like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个典型的函数看到这个工作原理，比如这样：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 5-11: *local_scope.py:1*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-11: *local_scope.py:1*'
- en: I create a `spam()` function, inside of which I define the names `message`,
    `word`, and `separator`. I can access any of these names inside the function;
    that is their local scope. It doesn’t matter that `separator` is defined within
    a `for` loop, as loops don’t have their own scope. I can still access it outside
    of the loop.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个`spam()`函数，在其中定义了`message`、`word`和`separator`这三个名称。我可以在函数内部访问这些名称；那就是它们的局部作用域。即使`separator`是在`for`循环中定义的，也不影响访问，因为循环没有自己的作用域。我仍然可以在循环外部访问它。
- en: 'However, I cannot access any of these names outside of the function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我不能在函数外部访问这些名称：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 5-12: *local_scope.py:2*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-12: *local_scope.py:2*'
- en: Trying to access `message` outside the context of the `spam()` function where
    it was defined will raise a `NameError`. In this example, `message` doesn’t exist
    in the outer scope. What’s more, as soon as the function `spam()` exits, the names
    `message`, `word`, and `separator` are deleted. Because `word` and `separator`
    each referred to values with a reference count of one (meaning only one name was
    bound to each), the values are also deleted.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在`spam()`函数外部访问`message`，会引发`NameError`。在这个例子中，`message`在外部作用域中不存在。而且，一旦`spam()`函数退出，`message`、`word`和`separator`这些名称会被删除。因为`word`和`separator`各自引用的值的引用计数为一（意味着每个值只绑定了一个名称），这些值也会被删除。
- en: 'The value of `message` is not deleted when the function exits, however, because
    of the return statement at the end of the function (see [Listing 5-11](#listing5-11))
    and what I do with that value here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于函数末尾的返回语句（见[示例 5-11](#listing5-11)）以及我对该值的处理，`message`的值在函数退出时并不会被删除：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 5-13: *local_scope.py:3*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-13: *local_scope.py:3*'
- en: I bind the value returned by `spam()` to `output` in the outer scope, meaning
    that value still exists in memory and can be accessed outside of the function.
    Assigning the value to `output` increases the reference count for that value,
    so even though the name `message` is deleted when `spam()` exits, the value is
    not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 `spam()` 返回的值绑定到外部作用域中的 `output`，意味着该值仍然存在于内存中，并且可以在函数外部访问。将该值赋给 `output`
    增加了该值的引用计数，因此即使在 `spam()` 退出时删除了 `message` 名称，该值仍然存在。
- en: Interpreter Shutdown
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释器关闭
- en: When the Python interpreter is asked to shut down, such as when a Python program
    terminates, it enters *interpreter shutdown*. During this phase, the interpreter
    goes through the process of releasing all allocated resources, calling the garbage
    collector multiple times, and triggering destructors in objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 解释器被请求关闭时，例如当 Python 程序终止时，它进入*解释器关闭*阶段。在这个阶段，解释器会释放所有分配的资源，调用垃圾回收器多次，并触发对象的析构函数。
- en: 'You can use the `atexit` module from the standard library to add functions
    to this interpreter shutdown process. This may be necessary in some highly technical
    projects, although in general, you shouldn’t need to do this. Functions added
    via `atexit.register()` will be called in a last-in, first-out manner. However,
    be aware that it becomes difficult to work with modules, including the standard
    library, during interpreter shutdown. It’s like trying to work in a building as
    it’s being demolished: the janitor’s closet may disappear at any time, without
    warning.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准库中的 `atexit` 模块，将函数添加到这个解释器关闭的过程中。虽然通常情况下你不需要这么做，但在某些技术性较强的项目中，这可能是必要的。通过
    `atexit.register()` 注册的函数将按后进先出（LIFO）的顺序被调用。然而，要注意的是，在解释器关闭时，处理模块（包括标准库）会变得非常困难。就像在一栋大楼被拆除时尝试工作一样：清洁工的储藏室随时可能消失，且没有任何警告。
- en: Global Scope
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域
- en: When a name is defined within a module but outside of any function, class, or
    comprehension, it is considered to be in *global* *scope*. Although it’s okay
    to have some global scope names, having too many usually leads to the creation
    of code that is difficult to debug and maintain. Therefore, you should use global
    scope names sparingly for variables. There is often a cleaner solution, such as
    a class (see Chapter 7).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个名称在模块中定义，但不在任何函数、类或推导式内时，它被认为处于*全局作用域*中。虽然拥有一些全局作用域名称是可以的，但过多的全局名称通常会导致难以调试和维护的代码。因此，你应该谨慎使用全局作用域中的名称，特别是对于变量。通常会有更简洁的解决方案，比如使用类（参见第7章）。
- en: 'Properly using global scope names in the context of a more local scope, such
    as a function, requires you to think ahead a little. Consider what I do if I want
    a function that can modify a global variable storing a high score. First, I define
    the global variable:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在更局部的作用域（例如函数）中正确使用全局作用域的名称，要求你提前思考一下。如果我想要一个可以修改存储高分的全局变量的函数，我会怎么做呢？首先，我定义这个全局变量：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-14: *global**_scope.py:1*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-14: *global**_scope.py:1*'
- en: 'I’ll write this function the wrong way first:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先会以错误的方式编写这个函数：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 5-15: *global**_scope.py:2*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-15: *global**_scope.py:2*'
- en: When I run this code, Python complains that I’m using a local variable before
    I’ve assigned a value to it ❶. The problem is, I’m assigning to the name `high_score`
    within the scope of the function `score()` ❷, and that *shadows*, or hides, the
    global `high_score` name behind the new, local `high_score` name. The fact that
    I’ve created a local `high_score` name *anywhere in the function* makes it impossible
    for the function to ever “see” the global `high_score` name.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这段代码时，Python 会抱怨我在赋值之前就使用了一个局部变量 ❶。问题是，我在函数 `score()` 的作用域内给 `high_score`
    赋值 ❷，这样就*遮蔽*了全局的 `high_score` 名称，或者说隐藏了全局 `high_score` 名称，转而使用了新的局部 `high_score`
    名称。事实上，我在函数的*任何地方*创建了一个局部 `high_score` 名称，使得这个函数永远无法“看到”全局的 `high_score` 名称。
- en: 'To make this work, I need to declare that I’m going to use the global name
    in the local scope, instead of defining a new local name. I can do this with the
    `global` keyword:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个代码正常工作，我需要声明我要在局部作用域中使用全局名称，而不是定义一个新的局部名称。我可以通过 `global` 关键字来实现：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 5-16: *global**_scope.py:3*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-16: *global**_scope.py:3*'
- en: Before I do anything else in my function, I must specify that I’m using the
    global `high_score` name. This means that anywhere I assign a value to the name
    `high_score` in `score()`, the function will use the global name, instead of trying
    to create a new local name. The code now works as expected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我函数中的任何操作之前，我必须指定我正在使用全局变量`high_score`。这意味着在`score()`函数中无论我在哪里给`high_score`赋值，函数都会使用全局变量，而不是尝试创建一个新的局部变量。代码现在按预期工作。
- en: 'Every time you wish to rebind a global name from within a local scope, you
    must use the `global` keyword first. If you’re only accessing the current value
    bound to a global name, you don’t need to use the `global` keyword. It is vital
    for you to cultivate this habit, because Python won’t always raise an error if
    you handle scope incorrectly. Consider this example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你希望在局部作用域中重新绑定一个全局变量时，你必须首先使用`global`关键字。如果你只是访问全局变量当前绑定的值，你不需要使用`global`关键字。养成这个习惯非常重要，因为Python并不会总是抛出错误，如果你错误地处理了作用域。请看这个例子：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-17: *global**_scope_gotcha.py:1a*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-17: *global**_scope_gotcha.py:1a*'
- en: This code runs without raising any errors, but the output is wrong. A new name,
    `current_score`, is being created in the local scope of the function `score()`,
    and it is bound to the value `465`. This shadows the global name `current_score`.
    When the function terminates, both the `new_score` and the local `current_score`
    are deleted. In all of this, the global `current_score` has remained untouched.
    It is still bound to `0`, and that is what is printed out.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行没有抛出任何错误，但输出是错误的。一个新的变量`current_score`在函数`score()`的局部作用域中被创建，并绑定了值`465`。这遮蔽了全局变量`current_score`。当函数结束时，`new_score`和局部变量`current_score`都会被删除。在这一过程中，全局的`current_score`保持不变。它仍然绑定着`0`，并打印出来的正是这个值。
- en: 'Once again, to resolve this problem, I need only use the `global` keyword:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为了解决这个问题，我只需要使用`global`关键字：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 5-18: *global**_scope_gotcha.py:1b*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-18: *global**_scope_gotcha.py:1b*'
- en: Because I specified that the global `current_name` is to be used in this function,
    the code now behaves precisely as expected, printing out the value `465`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我指定了这个函数要使用全局的`current_name`，所以代码现在行为正如预期一样，打印出值`465`。
- en: The Dangers of Global Scope
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域的危险
- en: There is one more major gotcha to account for with global scope. Modifying any
    variable at a global level, as in rebinding or mutating on a name outside the
    context of a function, can lead to confusing behavior and surprising bugs—especially
    once you start dealing with multiple modules. It’s acceptable for you to initially
    “declare” a name at a global scope, but you should do all further rebinding and
    mutation of that global name at the local scope level.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个需要注意的全局作用域的陷阱。修改全局作用域中的任何变量，比如重新绑定或者在函数外部修改某个变量的值，可能会导致令人困惑的行为和意外的错误，尤其是当你开始处理多个模块时。虽然你可以在全局作用域中初步“声明”一个变量，但应该在局部作用域中进行所有进一步的重新绑定和修改。
- en: By the way, this does *not* apply to classes, which do not actually define their
    own scope. I’ll return to this later in this chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，这一点*不适用于*类，因为类本身并不定义自己的作用域。稍后我会在本章中回到这个话题。
- en: The nonlocal Keyword
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: nonlocal关键字
- en: 'Python allows you to write functions within functions. I’ll defer discussing
    the practicality of this until Chapter 6. Here, I mainly want to explore this
    functionality’s impact on scope. Consider the following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许在函数内部定义函数。我将在第六章中再讨论这一点的实用性。在这里，我主要想探索这种功能对作用域的影响。请看以下示例：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 5-19: *nonlocal**.py*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-19: *nonlocal**.py*'
- en: 'The function `order()` contains another function: `cook()`. Each function has
    its own scope.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`order()`包含了另一个函数：`cook()`。每个函数都有自己的作用域。
- en: Remember, as long as a function only accesses a global name like `spam`, you
    don’t need to do anything special. However, trying to *assign* to a global name
    will actually define a new local name that shadows the global one. The same behavior
    is true of the inner function using names defined in the outer function, which
    is known as the *nested scope* or *enclosing scope*. To get around this, I specify
    that `eggs` is `nonlocal`, meaning it can be found in the enclosing scope, rather
    than in the local scope ❶. The inner function `cook()` has no trouble accessing
    the global name `spam`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只要一个函数仅访问像 `spam` 这样的全局名称，你不需要做任何特别的操作。然而，试图*赋值*给一个全局名称实际上会定义一个新的本地名称，并遮蔽全局名称。对于使用外部函数中定义的名称的内部函数，这也有相同的行为，这种情况被称为*嵌套作用域*或*封闭作用域*。为了避免这种情况，我指定
    `eggs` 为 `nonlocal`，意味着它可以在封闭作用域中找到，而不是在本地作用域 ❶ 中找到。内部函数 `cook()` 没有问题访问全局名称 `spam`。
- en: The `nonlocal` keyword starts looking for the indicated name in the innermost
    nested scope, and if it doesn’t find it, it moves to the next enclosing scope
    above that. It repeats this until it either finds the name or determines that
    the name does not exist in a nonglobal enclosing scope.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonlocal` 关键字会在最内层的嵌套作用域中查找指定的名称，如果没找到，它会继续查找上层的封闭作用域。它会一直重复这个过程，直到找到名称或确定该名称在非全局的封闭作用域中不存在为止。'
- en: Scope Resolution
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域解析
- en: 'Python’s rule about which scopes it searches for a name, and in what order,
    is called the *scope resolution order*. The easiest way to remember the scope
    resolution order is with the acronym *LEGB—*for which my colleague Ryan gave me
    the handy mnemonic “Lincoln Eats Grant’s Breakfast”:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Python 关于它搜索名称的规则，以及搜索顺序，被称为*作用域解析顺序*。记住作用域解析顺序最简单的方法是通过首字母缩略词*LEGB*——我的同事 Ryan
    给我提供了一个便于记忆的助记符：“Lincoln Eats Grant’s Breakfast”：
- en: Local
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地
- en: Enclosing-function locals (that is, anything found via `nonlocal`)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封闭函数的局部变量（也就是通过 `nonlocal` 找到的任何东西）
- en: Global
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局
- en: Built-in
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置
- en: Python will look in these scopes, in order, until it finds a match or reaches
    the end. The `nonlocal` and `global` keywords adjust the behavior of this scope
    resolution order.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会按照顺序在这些作用域中查找，直到找到匹配项或到达末尾。`nonlocal`和`global`关键字调整了这种作用域解析顺序的行为。
- en: The Curious Case of the Class
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类的奇异案例
- en: Classes have their own way of dealing with scope. Technically speaking, classes
    don’t directly factor into the scope resolution order. Every name declared directly
    within a class is known as an *attribute*, and it is accessed through the dot
    (`.`) operator on the class (or object) name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类有自己处理作用域的方式。从技术上讲，类不会直接影响作用域解析顺序。每个在类中直接声明的名称都被称为*属性*，并且它是通过类（或对象）名称上的点（`.`）操作符进行访问的。
- en: 'To demonstrate this, I’ll define a class with a single attribute:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将定义一个只有一个属性的类：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 5-20: *class_attributes**.py*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-20: *class_attributes**.py*'
- en: 'Those three print statements all output the same thing. Running that code gives
    me this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那三条打印语句输出的内容是一样的。运行这段代码给我带来的结果是：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The name `output` is a *class attribute* ❶, belonging to the `Nutrimatic` class.
    Even within that class, I would not be able to refer to it merely as `output`.
    I must access it through `self.output` ❷, as `self` refers to the class instance
    the function (instance method) `request()` is being called on. I can also access
    it via `machine.output` ❸ or `Nutrimatic.output` ❹ anywhere the object `machine`
    or the class `Nutrimatic` is, respectively, in scope. All of those names point
    to the exact same attribute: `output`. Especially in this case, there’s no real
    difference between them.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 `output` 是一个*类属性* ❶，属于 `Nutrimatic` 类。即使在该类内部，我也不能仅仅称之为 `output`。我必须通过 `self.output`
    ❷ 来访问它，因为 `self` 是指函数（实例方法）`request()` 被调用时所关联的类实例。我也可以通过 `machine.output` ❸ 或
    `Nutrimatic.output` ❹ 在 `machine` 对象或 `Nutrimatic` 类的作用域内访问它。这些名称指向的是完全相同的属性：`output`。尤其是在这个案例中，它们之间没有什么实质性的区别。
- en: Generational Garbage Collector
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代际垃圾回收器
- en: Behind the scenes, Python also has a more robust *generational garbage collector*
    that handles all of the odd situations a reference-counting garbage collector
    cannot, such as reference cycles (when two values reference one another). All
    of these situations, and the ways they’re handled by the garbage collector, are
    far beyond the scope of this book.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Python 还拥有一个更强大的*代际垃圾回收器*，它处理引用计数垃圾回收器无法处理的所有特殊情况，例如引用循环（当两个值互相引用时）。所有这些情况，以及垃圾回收器处理它们的方式，远远超出了本书的范围。
- en: Moving forward, the most important takeaway to remember is that the generational
    garbage collector incurs some performance costs. Thus, it’s sometimes worthwhile
    to avoid reference cycles. One way to do this is with `weakref`, which creates
    a reference to a value without increasing that value’s reference count. This feature
    was defined in PEP 205, and the documentation exists at [https://docs.python.org/library/weakref.html](https://docs.python.org/library/weakref.html).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 继续往下，最重要的要点是，代际垃圾回收器会带来一些性能开销。因此，有时避免引用循环是值得的。实现这一点的一种方式是使用 `weakref`，它创建一个对值的引用，而不增加该值的引用计数。此功能在
    PEP 205 中进行了定义，相关文档可以在 [https://docs.python.org/library/weakref.html](https://docs.python.org/library/weakref.html)
    找到。
- en: The Immutable Truth
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变的真相
- en: Values in Python can be either *immutable* or *mutable*. The difference hinges
    on whether the values can be *modified in place*, meaning they can be changed
    right where they are in memory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，值可以是*不可变*的或者*可变*的。它们之间的区别在于值是否可以*原地修改*，也就是说，它们能否在内存中的当前位置被更改。
- en: '*Immutable* types cannot be modified in place. For example, integers (`int`),
    floating-point numbers (`float`), strings (`str`), and tuples (`tuple`) are all
    immutable. If you attempt to mutate an immutable value, you’ll wind up with a
    completely different value being created:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可变*类型不能原地修改。例如，整数（`int`）、浮点数（`float`）、字符串（`str`）和元组（`tuple`）都是不可变的。如果你尝试修改一个不可变的值，你将会得到一个完全不同的新值：'
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 5-21: *immutable_types.py*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-21: *immutable_types.py*'
- en: Initially, `eggs` and `carton` are both bound to the same value, and thus, they
    share an identity. When I modify `eggs`, it is rebound to a new value, so it no
    longer shares an identity with `carton`. You can see that the two names now point
    to different values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`eggs` 和 `carton` 都绑定到相同的值，因此它们共享同一个身份。当我修改 `eggs` 时，它被重新绑定到一个新值，因此它不再与 `carton`
    共享身份。你可以看到，现在这两个名字指向了不同的值。
- en: '*Mutable* types, on the other hand, can be modified in place. Lists constitute
    one example of a mutable type:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*可变*类型可以原地修改。列表就是一个可变类型的例子：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 5-22: *mutable_types.py*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-22: *mutable_types.py*'
- en: Because the list is aliased to both `temps` and `highs`, any modifications made
    to the list value ❶ are visible through either name. Both names are bound to the
    original value, as demonstrated by the `is` comparisons. This remains the case,
    even after that value is mutated.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为列表同时别名化为 `temps` 和 `highs`，所以对列表值 ❶ 所做的任何修改都可以通过任意名字看到。正如 `is` 比较所演示的，两个名字都绑定到原始值，即使该值被修改后，依然如此。
- en: Passing by Assignment
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过赋值传递
- en: Another frequent question from programmers new to the language is, “Does Python
    pass by value or by reference?”
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学该语言的程序员，另一个常见的问题是，“Python 是通过值传递还是引用传递？”
- en: The answer is, “Effectively, neither.” More accurately, as Ned Batchelder describes
    it, Python *passes by assignment*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：“实际上，既不是。” 更准确地说，正如 Ned Batchelder 所描述的，Python 是*通过赋值传递*的。
- en: 'Neither the values nor the names bound to them are moved. Instead, each value
    is bound to the parameter via assignment. Consider a simple function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是值还是绑定到这些值的名字，都没有被移动。相反，每个值都通过赋值绑定到参数。考虑一个简单的函数：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, there is one copy of the string value `"Jason"` in memory, and that is
    bound to the name `my_name`. When I pass `my_name` to the `greet()` function—specifically,
    to the `person` parameter—it’s the same as if I had said (`person = my_name`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内存中有一个字符串值 `"Jason"` 的副本，它被绑定到名字 `my_name`。当我将 `my_name` 传递给 `greet()` 函数——具体来说，传递给
    `person` 参数时——这就相当于我说了（`person = my_name`）。
- en: Again, assignment never makes a copy of a value. The name `person` is now bound
    to the value `"Jason"`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，赋值从不会复制一个值。名字 `person` 现在被绑定到值 `"Jason"`。
- en: 'This concept of passing by assignment gets tricky when you start working with
    mutable values, such as lists. To demonstrate this often-unexpected behavior,
    I’ve written a function that finds the lowest temperature in a list passed to
    it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过赋值传递的概念在处理可变值（如列表）时变得棘手。为了演示这种常常令人意外的行为，我写了一个函数来查找传入列表中的最低温度：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 5-23: *lowest_temp.py:1a*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-23: *lowest_temp.py:1a*'
- en: 'At first glance, you may assume that passing a list to the `temperatures` parameter
    will make a copy, so it shouldn’t matter if you modify the value bound to the
    parameter. However, lists are mutable, meaning *the value itself* can be modified:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，你可能认为将列表传递给 `temperatures` 参数会创建一个副本，因此修改绑定到参数的值应该不影响原值。然而，列表是可变的，意味着*值本身*可以被修改：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 5-24: *lowest_temp.py:2*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-24: *lowest_temp.py:2*'
- en: When I passed `temps` to the function’s `temperatures` parameter, I only *aliased*
    the list, so any changes made on `temperatures` are visible from all the other
    names bound to that same list value—namely, from `temps`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将`temps`传递给函数的`temperatures`参数时，我只是*引用*了这个列表，因此在`temperatures`上的任何更改都会在绑定到同一个列表值的所有其他名称中可见——即，`temps`。
- en: 'You can see this in action when I run this code and get the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这段代码并得到以下输出时，你可以看到它的效果：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When `find_lowest()` sorted the list passed to `temperatures`, it actually sorted
    the one mutable list that both `temps` and `temperatures` aliased. This is a clear
    case of a function having *side effects*, which are changes to values that existed
    before the function call.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当`find_lowest()`对传递给`temperatures`的列表进行排序时，它实际上排序了一个可变列表，而该列表同时被`temps`和`temperatures`引用了。这是一个典型的*副作用*案例——即对函数调用前已存在值的更改。
- en: 'An awe-inspiring number of bugs originate from this one type of misunderstanding.
    In general, functions should not have side effects, meaning that any values passed
    to the function as arguments should *not* be directly mutated. To avoid mutating
    the original value, I have to explicitly make a copy of it. Here’s how I’d do
    that in the `find_lowest()` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一种惊人的错误数量源于这种误解。通常，函数不应有副作用，这意味着传递给函数的任何值作为参数不应直接发生变化。为了避免改变原始值，我必须显式地复制它。这就是我在`find_lowest()`函数中要做到的：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 5-25: *lowest_temp.py:1b*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-25: *lowest_temp.py:1b*'
- en: The `sorted()` function has no side effects; it creates a new list using the
    items in the list passed to it ❶. It then sorts this new list and returns it.
    I bind this new list to `sorted_temps`. Thus, the original list (bound to `temps`
    and `temperatures`) is untouched.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`函数没有副作用；它会创建一个新列表，使用传递给它的列表中的项目❶。然后，它对这个新列表进行排序并返回。这个新列表被绑定到`sorted_temps`。因此，原始列表（绑定到`temps`和`temperatures`）保持不变。'
- en: If you’re coming from C and C++, it may be helpful to remember the potential
    hang-ups related to pass-by-pointer or pass-by-reference. Although Python’s assignment
    is scarcely similar from a technical standpoint, the risks of side effects and
    unintended mutations are the same.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自C和C++，记住与指针传递或引用传递相关的潜在问题可能会很有帮助。尽管从技术角度来看，Python的赋值操作几乎没有相似之处，但副作用和意外变异的风险是相同的。
- en: Collections and References
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合和引用
- en: 'All collections, including lists, employ a clever little semantic detail that
    can become a royal pain if you don’t know to expect it: ***Individual items are
    references.*** Just as a name is bound to a value, so also are items in collections
    bound to values, in the same manner. This binding is called a *reference*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合，包括列表，都包含一个巧妙的小语义细节，如果你不知道会预期它，它可能会成为一个麻烦：***单个项目是引用。*** 就像一个名字绑定到一个值一样，集合中的项目也以相同的方式绑定到值。这个绑定称为*引用*。
- en: A simple example involves trying to create a tic-tac-toe board. This first version
    won’t work quite how you’d expect.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是尝试创建一个井字棋棋盘。这个版本的实现不会像你预期的那样工作。
- en: 'I’ll start by creating the game board:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从创建游戏棋盘开始：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 5-26: *tic_tac_toe**.py:1a*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-26: *tic_tac_toe.py:1a*'
- en: I’m trying to create a two-dimensional board. You can fill a collection, like
    a list, with several items, all with the same repeating value, using the multiplication
    operator ❶, as I’ve done here. I enclose the repeating value in square brackets
    and multiply it by the number of repetitions I want. A single row of my board
    is defined with `["-"] * 3`, which makes a list of three `"-"` strings.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在尝试创建一个二维棋盘。你可以使用乘法运算符❶填充一个集合，比如列表，用多个具有相同重复值的项目，就像我在这里所做的那样。我将重复的值放在方括号中，并将其乘以我想要的重复次数。我通过`["-"]
    * 3`定义了棋盘的单行，它生成一个包含三个`"-"`字符串的列表。
- en: 'Unfortunately, this won’t work the way you’d expect. The problem begins when
    I attempt to define the second dimension of the array—three copies of the `[["-"]
    * 3]` list—using multiplication. You can see the problem manifest when I try to
    make a move:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不会按照你预期的方式工作。问题出现在我尝试使用乘法定义数组的第二维时——即三个`[["-"] * 3]`列表的副本。当我尝试进行一步时，你可以看到问题的出现：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 5-27: *tic_tac_toe**.py:2*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5-27: *tic_tac_toe.py:2*'
- en: 'When I mark a move on the board ❷, I want to see that change in only one spot
    on the board, like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在棋盘上标记一个位置❷时，我希望只在棋盘上的一个位置看到变化，像这样：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Instead, I get this nasty surprise:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我得到的是这个令人讨厌的惊喜：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Cue the weeping and gnashing of teeth. Somehow, that one change has propagated
    to *all three* *rows*. Why?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好哭泣和咬牙切齿吧。不知道为什么，这个变化已经传播到*所有三个* *行*。为什么？
- en: Initially, I created a list with three `"-"` values as items ❶. Since strings
    are immutable and thus cannot be modified in place, this works as expected. Rebinding
    the first item in the list to `"X"` does not affect the other two items.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The outer dimension of the list is composed of three list items. Because I defined
    *one* list and used it *three* times, I now have three *aliases* for one mutable
    value! By changing that list through one reference (the second row), I’m mutating
    that one shared value ❷, so all three references see the change.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to fix this, but all of them work by ensuring each row
    references a separate value, like so:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 5-28: *tic_tac_toe**.py:1b*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'I only needed to change how I defined the game board initially. I now use a
    *list comprehension* to create the rows. In short, this list comprehension will
    define a separate list value from `["-"] * 3` three different times. (List comprehensions
    get complicated; they’ll be explained in depth in Chapter 10.) Running the code
    now results in the expected behavior:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Long story short, whenever you’re working with a collection, remember that
    an item is no different from any other name. Here is one more example to drive
    this point home:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 5-29: *team_scores**.py:1*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'I create three lists, assigning each to a name. Then, I pack all three into
    the tuple `scores`. You may remember from earlier that tuples cannot be modified
    directly, because they’re immutable. That same rule does not necessarily apply
    to a tuple’s items. You can’t change the tuple itself, but you can (indirectly)
    modify the values its items refer to:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 5-30: *team_scores**.py:2*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: When I mutate the list `scores_team_1`, that change appears in the first item
    of the tuple, because that item only aliased a mutable value.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'I could also directly mutate a mutable list in the `scores` tuple through two-dimensional
    subscription, like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 5-31: *team_scores**.py:3*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Tuples don’t give you any sort of security about things being modified. Immutability
    exists mainly for efficiency, not for protecting data. Mutable values are *always*
    going to be mutable, no matter where they live or how they’re referred to.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The problems in the two examples above may seem relatively easy to spot, but
    things start getting troublesome when the related code is spread out across a
    large file or multiple files. Mutating on a name in one module may unexpectedly
    modify an item of a collection in a completely different module, and you might
    never have expected it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Shallow Copy
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to ensure you are binding a name to a *copy* of a mutable
    value, instead of aliasing the original; the most explicit of these ways is with
    the `copy()` function. This is sometimes also known as a *shallow copy*, in contrast
    to the *deep copy* I’ll cover later.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, I’ll create a `Taco` class (see Chapter 7 for more on
    classes) that allows you to define the class with various toppings and then add
    a sauce afterward. This first version has a bug:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 5-32: *mutable_**tacos.py:1a*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In the `Taco` class, the initializer `__init__()` accepts a list of toppings,
    which it stores as the `ingredients` list. The `add_sauce()` method will add the
    specified `sauce` string to the `ingredients` list.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: (Can you anticipate the problem?)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'I use the class as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 5-33: *mutable_**tacos.py:2a*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'I define a list of toppings I want on all my tacos, and then I define two tacos:
    `hot_taco` and `mild_taco`. I pass the `default_toppings` list to the initializer
    for each taco. Then I add `"Salsa"` to the list of toppings to `hot_taco`, but
    I don’t want any `"Salsa"` on `mild_taco`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure this is working, I print out the list of `ingredients` for the
    two tacos, as well as the `default_toppings` list I started with:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 5-34: *mutable_**tacos.py:3*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Waiter, there’s a bug in my taco!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The trouble is, when I created my `hot_taco` and `mild_taco` object by passing
    `default_toppings` to the `Taco` initializer, I bound both `hot_taco.ingredients`
    and `mild_taco.ingredients` to the same list value as `default_toppings`. These
    are now all aliases of the same value in memory. Then, when I call the function
    `hot_taco.add_sauce()`, I mutate that list value. The addition of `"Salsa"` is
    visible not only in `hot_taco.ingredients`, but also (unexpectedly) in `mild_taco.ingredients`
    and in the `default_toppings` list. This is definitely not the desired behavior;
    adding `"Salsa"` to one taco should only affect that one taco.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to resolve this is to ensure I’m assigning a copy of the mutable value.
    In the case of my `Taco` class, I will rewrite the initializer so it assigns a
    copy of the specified list to `self.ingredients`, instead of aliasing:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 5-35: *mutable_**tacos.py:1b*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: I make a copy with the `copy.copy()` function ❶, which is imported from `copy`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'I make a copy of the list passed to `toppings` within `Taco.__init__()`, assigning
    that copy to `self.ingredients`. Any changes made to `self.ingredients` don’t
    affect the others; adding `"Salsa"` to `hot_taco` does not change `mild_taco.ingredients`,
    nor does it change `default_toppings`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Deep Copy
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A shallow copy is all well and good for lists of immutable values, but as previously
    mentioned, when a mutable value contains other mutable values, changes to those
    values can appear to replicate in weird ways.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider what happens when I try to make a copy of a `Taco` object
    before changing one of the two tacos. My first attempt results in some undesired
    behavior. Building on the same `Taco` class as before (see [Listing 5-35](#listing5-35)),
    I’ll use the copy of one taco to define another:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 5-36: *mutable_**tacos.py:2b*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: I want to create a new taco (`hot_taco`) that is initially identical to `mild_taco`,
    but with added `"Salsa"`. I’m attempting this by binding a copy of `mild_taco`
    ❶ to `hot_taco`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the revised code (including [Listing 5-34](#listing5-34)) produces
    the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: I might not expect any changes made to `hot_taco` to reflect in `mild_taco`,
    but unexpected changes have clearly happened.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The issue is that, when I make a copy of the `Taco` object value itself, I am
    not making a copy of the `self.ingredients` list *within* the object. Both `Taco`
    objects contain references to the same list value.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, I can use *deep copy* to ensure that any mutable values
    inside the object are copied as well. In this case, a deep copy of a `Taco` object
    will create a copy of the `Taco` value, as well as a copy of any mutable values
    that `Taco` contains references to—namely, the list `self.ingredients`. [Listing
    5-37](#listing5-37) shows that same program, using deep copy:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 5-37: *mutable_**tacos.py:2c*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The only change is that I’m using `copy.deepcopy()`, instead of `copy.copy()`
    ❶. Now when I mutate the list inside `hot_taco`, it doesn’t affect `mild_taco`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I don’t know about you, but I’m getting hungry for tacos.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Copying is the most generic way to solve the problem of passing around mutable
    objects. However, depending on what you’re doing, there may be an approach better
    suited to the particular collection you’re using. For example, many collections,
    like lists, have functions that return a copy of the collection with some specific
    modification. When you’re solving these sorts of issues with mutability, you can
    start by employing copy and deep copy. Then, you can exchange that for a more
    domain-specific solution later.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Coercion and Conversion
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Names do not have types. Therefore, Python has no need of type casting, at least
    in the typical sense of the term.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Allowing Python to figure out the conversions by itself, such as when adding
    together an integer (`int`) and a `float`, is called *coercion*. Here are a few
    examples:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 5-38: *coercion.py*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Even so, there are potential situations in which you may need to use one value
    to create a value of a different type, such as when you are creating a string
    from an integer. *Conversion* is the process of explicitly casting a value of
    one type to another type.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Every type in Python is an instance of a class. Therefore, the class of the
    type you want to create only needs to have an initializer that can handle the
    data type of the value you’re converting from. (This is usually done through duck
    typing.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the more common scenarios is to convert a string containing a number
    into a numeric type, such as a `float`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Listing 5-39: *conversion.py:1*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Here, I start with a piece of information as a string value, which is bound
    to the name `life_universe_everything`. Imagine I want to do some complex mathematical
    analysis on this data; to do this, I must first convert the data into a floating-point
    number. The desired type would be an instance of the class `float`. That particular
    class has an initializer (`__init__()`) that accepts a string as an argument,
    which is something I know from the documentation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: I initialize a `float()` object, pass `life_universe_everything` to the initializer,
    and bind the resulting object to the name `answer`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll print out the `type` and value of `answer`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 5-40: *conversion.py:2*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Since there were no errors, you can see that the result is a `float` with value
    `42.0`, bound to `answer`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Every class defines its own initializers. In the case of `float()`, if the string
    passed to it cannot be interpreted as a floating-point number, a `ValueError`
    will be raised. Always consult the documentation for the object you’re initializing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: A Note About Systems Hungarian Notation
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re coming from a statically typed language like C++ or Java, you’re probably
    used to working with data types. Thus, when picking up a dynamically typed language
    such as Python, it might be tempting to employ some means of “remembering” what
    type of value every name is bound to. ***Don’t do this!*** You will find the most
    success using Python if you learn to take full advantage of dynamic typing, weak
    binding, and duck typing.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'I will confess: the first year I used Python, I used *Systems Hungarian notation*—the
    convention of appending a prefix denoting data type to every variable name—to
    try to “defeat” the language’s dynamic typing system. My code was littered with
    such debris as `intScore`, `floatAverage`, and `boolGameOver`. I picked up the
    habit from my time using Visual Basic .NET, and I thought I was brilliant. In
    fact, I was depriving myself of many opportunities to refactor.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Systems Hungarian notation will quickly render code obtuse. For example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 5-41: *evils_of_systems_hungarian.py*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Needless to say, this code is quite painful to read. On the other hand, if
    you make full use of Python’s typing system (and resist the urge to store every
    intermediate step), the code will be decidedly more compact:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 5-42: *duck_typing_feels_better.py*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: My code became far cleaner once I stopped treating Python like a statically
    typed language. Python’s typing system is a big part of what makes it such a readable
    and compact language.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Terminology Review
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve introduced a lot of important new words in this section. Since I’ll be
    using this vocabulary frequently throughout the rest of the book, doing a quick
    recap here is prudent.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: alias (v.) To bind a mutable value to more than one name. Mutations performed
    on a value bound to one name will be visible on all names bound to that mutable
    value.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: assignment (n.) The act of binding a value to a name. Assignment never copies
    data.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: bind (v.) To create a reference between a name and a value.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: coercion (n.) The act of implicitly casting a value from one type to another.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: conversion (n.) The act of explicitly casting a value from one type to another.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: copy (v.) To create a new value in memory from the same data as another value.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: data (n.) Information stored in a value. You may have copies of any given data
    stored in other values.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: deep copy (v.) To both copy an object to a new value *and* copy all the data
    from values referenced within that object to new values.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: identity (n.) The specific location in memory that a name is bound to. When
    two names share an identity, they are bound to the same value in memory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: immutable (adj.) Of or relating to a value that *cannot* be modified in place.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: mutable (adj.) Of or relating to a value that *can* be modified in place.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: mutate (v.) To change a value in place.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: name (n.) A reference to a value in memory, commonly thought of as a “variable”
    in Python. A name must always be bound to a value. ***Names have scope, but not
    type.***
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: rebind (v.) To bind an existing name to a different value.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: reference (n.) The association between a name and a value.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: scope (n.) A property that defines what section of the code a name is accessible
    from, such as from within a function or within a module.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: shallow copy (v.) To copy an object to a new value but *not* copy the data from
    values referenced within that object to new values.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: type (n.) A property that defines how a raw value is interpreted, for example,
    as an integer or a boolean.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: value (n.) A unique copy of data in memory. There must be a reference to a value,
    or else the value is deleted. ***Values have type, but not scope.***
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: variable (n.) A combination of a name and the value the name refers to.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: weakref (n.) A reference that does not increase the reference count on the value.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: To help keep us grounded in these concepts, we usually use the term *name* instead
    of *variable*. Instead of *changing* something, we *(re)bind a name* or *mutate
    a value*. Assignment never copies—it literally always binds a name to a value.
    Passing to a function is just assignment.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if you ever have trouble wrapping your head around these concepts
    and how they play out in your code, try the visualizer at [http://pythontutor.com/](http://pythontutor.com/).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s easy to take something like variables for granted, but by understanding
    Python’s unique approach, you can better avail yourself of the power that is available
    through dynamic typing. I must admit, Python has somewhat spoiled me. When I work
    in statically typed languages, I find myself pining for the expressiveness of
    duck typing.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, working with Python-style dynamic typing can take getting used to if
    you have a background in other languages. It’s like learning how to speak a new
    human language: only with time and practice will you begin to think in the new
    tongue.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: If all this is making your head swim, let me reiterate the single most important
    principles. Names have scope, but no type. Values have type, but no scope. A name
    can be bound to any value, and a value can be bound to any number of names. It
    really is that dead simple! If you remember that much, you’ll go a long way.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions and Lambdas
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: Functions are one of the most elementary concepts in programming, yet Python
    packs a surprising amount of versatility into them. You’ll recall from Chapter
    3 that functions are first-class objects, so they are treated no differently from
    any other object. This fact, combined with the power of dynamic typing, opens
    up so many possibilities.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Python has full support for *functional programming*, a distinct paradigm from
    which we get those “lambdas,” or anonymous functions, you keep reading about online.
    If you’re used to languages like Haskell or Scala, a lot of the concepts in this
    chapter are going to seem familiar to you. However, if you’re more used to object-oriented
    programming, such as in Java or C++, this may be the first time you’ve encountered
    many of these concepts.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: When learning Python, it makes sense to dive into functional programming early
    on. It is perfectly possible to write idiomatic Python code without ever creating
    a single class (see Chapter 7). By contrast, functions and functional programming
    concepts underpin much of the language’s most powerful features.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Python Function Essentials
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I briefly touched on functions in Chapter 3. Building on that knowledge, I’ll
    gradually construct a more complex example in this chapter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by creating a function that rolls a single die with a specified
    number of sides:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 6-1: *dice_roll.py:1a*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: I define a function named `roll_dice()`, which accepts a single parameter, `sides`.
    This function is considered pure, because it has no side effects; it accepts a
    value as an input and returns a new value as an output. I return a value from
    the function using the `return` keyword.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The `random` module has a number of functions for producing random values. Here,
    I use its `random.randint()` function to generate a pseudorandom number in Python.
    I generate a random number between `1` and `20` (the value of `sides` in this
    example) inclusively, with `random.randint(1, 20)`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my usage for the function:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listing 6-2: *dice_roll.py:2a*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Later, I call the function and pass the value `20` as an argument ❶, so the
    function call is effectively the same as rolling a 20-sided die. The value that
    the first function call returns is bound to `player1`; the second call’s return
    is bound to `player2`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Because I defined `roll_dice()` as a function, I can use it as many times as
    I want. If I want to change its behavior, I only need to modify the function in
    the one place where it is defined, and every usage of that function will be affected.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Say I wanted to roll multiple dice at once and return the results in a tuple.
    I can rewrite the `roll_dice()` function to do that:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Listing 6-3: *dice_roll.py:1b*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: To allow rolling multiple dice, the function accepts a second parameter, `dice`,
    which represents the number of dice being rolled. The first parameter, `sides`,
    still represents the number of sides on any one of the dice.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The scary-looking line of code at the top of the function is a *generator expression*,
    which I’ll cover in Chapter 10. For now, you can take it for granted that I’m
    generating one random number for each die being rolled and packing the results
    in a tuple.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Since my function now has a second parameter in the function call, I pass two
    arguments:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 6-4: *dice_roll.py:2b*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: The returned tuple can be *unpacked*, meaning each item in the tuple is bound
    to a name I can use to access the value. The number of names listed on the left
    (separated by commas) and the number of values in the tuple *must* match for this
    to work, or else Python will raise an error. (See Chapter 9 for more on unpacking
    and tuples.)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Recursion* occurs when a function calls itself. This can be helpful when you
    need to repeat the entire logic of a function but a loop is unsuitable or feels
    too cluttered, as in the upcoming example.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: For example, returning to my dice-rolling function, I can accomplish the exact
    same result using recursion, instead of that generator expression I was using
    earlier (although in practice, the generator expression is usually considered
    more Pythonic).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 6-5: *dice_roll_recursive.py:1a*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: I store the resulting roll for this function call in `roll`. Then, in the recursive
    call, I pass my `sides` parameter as is, while reducing the number of `dice` to
    roll by one, to account for the die I just rolled. Finally, I combine the tuple
    that is returned from that recursive function call with the result of the roll
    on this function call, and I return the resulting longer tuple.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage is essentially the same as before:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 6-6: *dice_roll_recursive.py:2a*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to print out each value being returned, in order from deepest recursive
    call to outermost, here’s what you would see:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 6-7: Returns from recursive calls to `roll_dice(6, 5)`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: When the number of dice left is zero or negative, I return an empty tuple instead
    of recursively calling it again. If I don’t do that, the recursion will try to
    run forever. Thankfully, Python will pull the plug at some point and just crash
    the program, instead of letting it consume all your computer’s memory (as some
    other programming languages are apt to do). The *recursion depth* is how many
    recursive function calls have not returned yet, and Python caps it at approximately
    one thousand.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'If the recursion depth goes any deeper than the limit, the entire program stops
    and raises an error:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is why it’s so important that you build some means of stopping when you
    use recursion. In the `roll_dice` function, this stopping mechanism is at the
    very top of the function:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Since `dice` is getting decremented every time the function calls itself, sooner
    or later, it will reach zero. When it does, it returns an empty tuple, instead
    of producing another recursive call. Then, the rest of the recursive calls can
    finish running and return.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be cases in which a recursion depth of a thousand is not enough.
    If you need more, you can override the maximum:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `sys.setrecursionlimit()` function allows you to set a new maximum recursion
    depth. In this case, my new limit is `2000`. The benefit of this approach is that
    once you no longer need your limit, you can set it back to the default so it can
    keep *other* recursive calls from getting out of hand.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Default Argument Values
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might imagine that I would need to roll a single die far more often than
    any other option. As it stands right now, I would have to manually specify that
    I only want to roll one 20-sided die:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: I have to manually pass a `1` as the second argument of `roll_dice` to specify
    that I’m rolling a single die.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: By the way, that trailing comma after `result` is how I unpack a single value
    from a single-item tuple, meaning the actual value of the only item in the tuple
    is now bound to `result`. (See Chapter 9 for more on unpacking.)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Since rolling a single die is likely the most common action I want to take
    with this function, I want to make it more convenient to use. I can use *default
    argument values* to accomplish this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 6-8: *dice_roll.py:1c*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dice` parameter now has a default argument value of `1`. Thus, anytime
    I don’t specify the second argument, `dice` will use its default argument value.
    This makes it possible to use a simplified function call to roll a single six-sided
    die:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If I do want to roll multiple dice, I can still pass that second argument:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: When you specify a default argument value for a parameter, you are defining
    an *optional parameter*. Conversely, a parameter with no default argument value
    is a *required parameter*. You can have as many of each as you like, but you must
    list all required parameters *before* your optional parameters. Otherwise, the
    code won’t run.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'When using optional parameters, there is one significant trap lurking in the
    dark: default argument values are only evaluated once, when the function is defined.
    One place where this gets treacherous is when you’re using any mutable data type,
    such as a list. Consider this code for generating values in a Fibonacci sequence,
    which doesn’t quite work as expected:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 6-9: *fibonacci.py:1a*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: This is going to have a problem because the default argument value `[1, 1]`
    ❶ is evaluated when Python first processes the function definition, creating a
    single mutable list with the value `[1, 1]` in memory. That gets mutated on the
    first function call ❷ and then returned.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'This usage of the function shows the problem:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 6-10: *fibonacci.py:2*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Everything looks okay in the code, but it isn’t. `fib1` is now bound to the
    same mutable value as `series`, so any changes to `fib1` are reflected in the
    default argument value *for every function call*. The second function call mutates
    this list further.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'When I call `fibonacci_next()` a third time, I’m probably expecting to start
    with a clean slate, `[1, 1, 2]`, which would be the result of a single mutation
    on the original default argument value. Instead, I’m getting the value of that
    single mutable value I’ve been messing with this whole time: `fib2` is now a third
    alias to the list. Oops!'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'This becomes apparent when I examine the output. This is what I’d be expecting:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'But this is what I actually get:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In short, *never use mutable values for default argument values*. Instead,
    use `None` as a default value, as shown in the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 6-11: *fibonacci.py:1b*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The proper way is to use `None` as the default argument value, and then to create
    a new mutable value if that default is being used.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that same usage code as before ([Listing 6-9](#listing6-9)) now produces
    the expected output:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Keyword Arguments
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readability matters. Unfortunately, function calls with multiple parameters
    aren’t always the most readable bits of code. *Keyword arguments* help resolve
    this by attaching labels to arguments in function calls.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Arguments that are mapped to their parameters by the order you pass them in,
    like in all the prior examples, are called *positional arguments*.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: If you knew nothing about the `roll_dice()` function from earlier and you encountered
    this line of code, what would you think it did?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Listing 6-12: *dice_roll.py:3a*'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: You would probably guess that this is rolling multiple dice, and perhaps that
    it is specifying how many sides those dice have—but which is which? Is it rolling
    six five-sided dice or five six-sided dice? You can imagine how confusing this
    would be with even more arguments. This is the shortcoming of positional arguments.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'As The Zen of Python says:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It can’t be good, then, to force the reader to guess. I can eliminate the ambiguity
    by using *keyword arguments*. I don’t need to change the function definition at
    all to be able to use keyword arguments. I only need to change my function call:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Listing 6-13: *dice_roll.py:3b*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of those names comes from the earlier function definition of `roll_dice`,
    where I specified it had two parameters: `sides` and `dice`. In my function call,
    I can assign values directly to those parameters by name. Now, there is no question
    about what each argument does. Specify the name of the parameter, matching what
    is in the function definition, and then assign the desired value directly to it.
    That’s all.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'When using keyword arguments, you don’t even have to list them in order, just
    as long as all the required parameters receive values:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 6-14: *dice_roll.py:3c*'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be even more helpful when you have multiple optional parameters on
    the function. Consider if I rewrote `roll_dice()` so that the dice being rolled
    were six sided, by default:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Listing 6-15: *dice_roll.py:1d*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword arguments allow you to simplify your function calls even further:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Listing 6-16: *dice_roll.py:3d*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: You’re only passing a value to one of the optional arguments, `dice`. For the
    other one, `sides`, the default value is used. It no longer needs to matter whether
    `sides` or `dice` appears first in the function’s parameter list; you can just
    use the ones you want and leave the rest alone.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'It is even possible to mix and match positional arguments and keyword arguments:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Listing 6-17: *dice_roll.py:3e*'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Here, `6` is passed as a positional argument to the first parameter in the function
    definition, `sides`. Then, I pass `5` as a keyword argument to the parameter `dice`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: This can come in handy, particularly when you don’t want to bother with naming
    the positional arguments but you still want to use one of many possible optional
    parameters. The only rule here is that your keyword arguments must come after
    your positional arguments in the function call. (See also the section “Keyword-Only
    Parameters” later in the chapter.)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: On Overloaded Functions
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re coming from a strictly typed language such as Java or C++, you’re
    probably used to writing *overloaded functions*, wherein you can write multiple
    functions with the same name but different parameters. Typically, overloaded functions
    in languages that support them provide a consistent interface (function name),
    while supporting arguments of different types.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Python usually doesn’t need overloaded functions. Using dynamic typing, duck
    typing, and optional parameters, you can write single functions that handle all
    the input scenarios you need to throw at Python.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: If you really, really need overloaded functions—and you probably don’t—you actually
    can create them with *single-dispatch functions*. I’ll cover this in Chapter 15.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Variadic Arguments
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the skills discussed so far, even while using optional parameters, you
    still have to anticipate how many arguments can potentially get passed to your
    function. This is fine in most cases, but sometimes, you’ll have no idea how many
    to expect.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: To solve this, your first instinct might be to pack all the arguments into a
    single tuple or a list. That works in some situations, but other times, it can
    become an extra inconvenience when calling the function.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'A better solution is to use *arbitrary arguments lists*, also called *variadic
    arguments*, which automatically pack multiple arguments into a single *variadic
    parameter* or *variadic positional parameter*. In the dice-rolling function, I
    want to allow the rolling of multiple dice, where each die may have a different
    number of sides:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Listing 6-18: *dice_roll_variadic.py:1a*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: I turn the parameter `dice` into a variadic parameter by preceding it with a
    single asterisk (`*`). All the arguments passed to `roll_dice` will now be packed
    into a tuple, bound to the name `dice`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Within the function, I can use this tuple in the usual manner. In this case,
    I’m using a generator expression (see Chapter 10) to roll each die specified in
    `dice`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'The placement of the variadic parameter is important: it must come *after*
    any positional parameters in the function definition. Any parameters I list after
    it will only be usable as keyword arguments, because the variadic parameter consumes
    all the remaining positional arguments.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my usage:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Listing 6-19: *dice_roll_variadic.py:2*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'In both function calls, I’m listing the dice I want to roll, with the number
    representing the number of sides of each die. In the first call, I’m rolling five
    six-sided dice. In the second call, I’m rolling four dice: a 20-sided die, a 6-sided
    die, an 8-sided die, and a 4-sided die.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'If I wanted to use the recursive approach, I’d populate the argument list by
    automatically unpacking that tuple into the function call:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Listing 6-20: *dice_roll_variadic.py:1b*'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Most of this code is going to look similar to the earlier recursive version.
    The most significant change is in what I’m passing to the recursive function call.
    The asterisk (`*`) in front of the name unpacks the tuple `dice` into the argument
    list ❶. I already processed the first item in the list, so I use the slice notation
    `[1:]` to remove that first item ❷ (see Chapter 9), to ensure it isn’t processed
    again.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Variadic Arguments
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To capture an unknown number of *keyword arguments*, precede the parameter name
    with *two* asterisks (`**`), making the parameter a *keyword variadic parameter*.
    The keyword arguments passed to the function are packed into a single dictionary
    object, so as to preserve the association between keyword and value. They are
    similarly unpacked by being preceded with two asterisks.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t show up very often in the wild. After all, if you didn’t know what
    the arguments were named, it would be hard to use them.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'One case where keyword variadic arguments are commonly useful is in blindly
    relaying arguments to another function call:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 6-21: *variadic_relay.py:1*'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: The `call_something_else()` function has one positional argument, `func`, where
    I’ll pass a *callable* object, such as another function. The second parameter,
    `args`, is a variadic parameter for capturing all the remaining positional arguments.
    Last is the keyword variadic parameter, `kwargs`, for capturing any keyword arguments;
    sometimes, the name `kw` is used instead. Remember, either of these can be empty
    and this code will still work.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: You can check whether an object is callable by passing it to the `callable()`
    function.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: The names `args` and `kwargs` are conventionally used for positional variadic
    and keyword variadic parameters, respectively. However, if you can think of names
    that better fit your particular situation, that’s certainly acceptable!
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: When the function calls the callable object `func`, it first unpacks all the
    positional arguments that were captured, and then it unpacks all the keyword arguments.
    The function code doesn’t need any knowledge of the callable object’s parameter
    list; instead, any and every argument passed to `call_something_else()` after
    that first positional argument will get blindly passed on.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this in action here:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Listing 6-22: *variadic_relay.py:2*'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'When I run that code, the `call_something_else()` function will call `say_hi()`,
    passing the argument `name="Bob"` to it. That produces the following output:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This bit of magic will come back into play shortly in writing *decorators* (see
    the section “Decorators” later in this chapter).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Keyword-Only Parameters
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use variadic parameters to turn some of your keyword parameters into
    *keyword-only parameters*, which were introduced in PEP 3102\. These parameters
    cannot have values passed in as positional arguments, but rather only as keyword
    arguments. This can be especially useful in ensuring that particularly long or
    perilous parameter lists are used in the proper manner, instead of as nigh-on
    unreadable chains of positional arguments.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, I’ll rewrite my `roll_dice()` function to have two keyword-only
    parameters:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Listing 6-23: *dice_roll_keyword_only.py:1*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: I use the unnamed variadic parameter `*`, which ensures every parameter that
    follows it in the list can only be accessed by name. If the caller passes in too
    many positional arguments (or in this case, *any* positional arguments), a `TypeError`
    is raised.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'This affects the usage, such that I can only use keyword arguments now:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Listing 6-24: *dice_roll_keyword_only.py:2*'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to use positional arguments raises an error:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Listing 6-25: *dice_roll_keyword_only.py:3*'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Positional-Only Parameters
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of Python 3.8 (via PEP 570), it is also possible to define *positional-only
    parameters*. This is useful when the parameter name is either unhelpful or likely
    to be changed down the road, meaning any code using it as a keyword parameter
    would be likely to break in the future.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll recall that positional parameters must always come first in the parameter
    list. Placing a forward slash (`/`) in the list designates all preceding parameters
    as positional-only:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Listing 6-26: *dice_roll_positional_only.py:1*'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the parameter `dice` still has a default value of `1`, but
    it is now positional-only. On the other hand, `sides` can be used as either a
    positional or a keyword parameter. Here’s that behavior in action:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Listing 6-27: *dice_roll_positional_only.py:2*'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: The first four examples all work, because the positional-only argument `dice`
    is either included as the first argument or omitted altogether. Any attempt to
    access `dice` by keyword fails with a `TypeError`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'Argument Types: All Together Now!'
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To ensure everything is clear regarding positional parameters and keyword parameters,
    I’ll take a moment to review with this (admittedly contrived) example:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The parameter `pos_only` is positional-only, as it comes before the forward-slash
    (`/`) marker. If I have any positional-only parameters, they must appear first
    in the list. Because this parameter has a default value, it is optional. However,
    if I wanted to pass an argument to it, it would need to be the first positional
    argument passed to the function; otherwise, a `TypeError` would be raised.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `pos_kw` parameter, which can be either positional or keyword. It
    comes after any positional-only parameters and after the forward-slash (`/`) marker,
    if there is one.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the asterisk (`*`) marker, I have `kw_only`, which is a keyword-only
    parameter. In this example, if my function receives more than two positional arguments,
    a `TypeError` will be raised.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Nested Functions
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From time to time, you may want to reuse a piece of logic *within* a function
    but not clutter up your code by making yet another function. In this situation,
    you can nest functions within other functions.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'I can use this to improve the recursive version of `roll_dice()`, making the
    logic for rolling a single die into something more reusable in the function:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Listing 6-28: *dice_roll_recursive.py:1b*'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I moved the logic for rolling a single die into a nested function
    `roll()`, which I can call from anywhere in the function `roll_dice()`. The direct
    benefit of abstracting out this logic is that it can be maintained more easily,
    without disrupting the rest of the code.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the usage:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Listing 6-29: *dice_roll_recursive.py:2b*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: That produces the usual random output.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: In production, I’d rarely use a nested function for something that trivial.
    Normally, I’d employ a nested function for more complex logic that sees frequent
    reuse, especially if it is used in multiple places in the outer function.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: You’ll recall from Chapter 5 that the nested function can access the names of
    its enclosing scope. However, if I wanted to rebind or mutate any of those names
    from within the nested function, I’d need to use the `nonlocal` keyword.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a function that builds and returns a kind of function called
    a *closure*, which encloses one or more nonlocal names. This pattern acts as a
    sort of “function factory.”
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on the dice example, I’ll write a function that returns a *closure*
    for rolling a particular set of dice:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Listing 6-30: *dice_cup_closure.py:1*'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: I create the function `make_dice_cup()`, which accepts the arguments for `sides`
    and `dice`. Inside `make_dice_cup()`, I define a nested function `roll()`, which
    uses `sides` and `dice`. When that nested function is returned by the outer function
    (no parentheses!) ❶, it becomes a closure, because it encloses `sides` and `dice`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Listing 6-31: *dice_cup_closure.py:2*'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: I bind the closure returned by `make_dice_cup()` to the name `roll_for_damage`,
    which I can now call as a function without any arguments. The closure continues
    to use `sides` and `dice` with the values I specified earlier to roll dice and
    return values; it is now a function in its own right.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Caution is necessary when using closures, as you can easily violate the rules
    of functional programming with them. If a closure has the ability to mutate the
    values it encloses, it becomes a sort of de facto object, and a difficult one
    to debug at that!
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Recursion with Closures
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous closure example didn’t use the recursive form of the dice-rolling
    code because, while it’s possible to implement such closure correctly, it’s even
    easier to do it wrong.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the most apparently obvious, yet wrong, way to make that closure recursive:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Listing 6-32: *dice_cup_closure_recursive.py:1a*'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Using what you know about names and scope so far, can you anticipate what’s
    wrong with the above?
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'The giveaway that something is wrong with the closure is the keyword `nonlocal`,
    as it indicates I’m mutating or rebinding a nonlocal name: `dice`.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to use this closure will reveal the problem:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Listing 6-33: *dice_cup_closure_recursive.py:2*'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 'That code produces the following output (for example):'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The first time the closure `roll_for_damage()` is used, everything is fine.
    However, `dice` isn’t reset when the function exits, so all subsequent calls to
    the closure find that `dice == 0`. Thus, they only return `()`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a recursive closure, you need to use an optional parameter on the
    closure:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Listing 6-34: *dice_cup_closure_recursive.py:1b*'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: In this version, I use the nonlocal name `dice` as the default value of the
    new, local parameter `dice`. (Recall, this will only work with immutable types.)
    This behaves precisely as expected, as it still closes over `sides` and the nonlocal
    `dice`, but it rebinds neither.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Stateful Closures
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it is generally best to write closures as pure functions, it is occasionally
    useful to create a *stateful closure*—that is, a closure that retains a little
    bit of state between calls that it can use. In general, you should avoid using
    stateful closures unless no other solution presents itself.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to demonstrate this, I’ll create a stateful closure that limits how many
    times a player can reroll a group of dice:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Listing 6-35: *dice_roll_turns.py:1*'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: I write the closure `roll()` so that it only allows the caller to reroll the
    dice a maximum number of times, specified by `limit`, before the function starts
    returning `None`. By this design, after the limit is reached, a new closure must
    be created. The logic of tracking how many times a player can roll the dice has
    been abstracted out into the closure.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: This closure is very limited and predictable in how it mutates and uses its
    state. It’s important to limit your closures in this way, since debugging a stateful
    closure can be difficult. There is no way to see the current value of `limit`
    from outside the closure; it’s simply not possible.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this predictable behavior at work in the usage:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Listing 6-36: *dice_roll_turns.py:2*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that code produces the following randomized output, wherein each turn
    gets three tosses of the dice; each toss is represented by a tuple:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: A stateful closure can be useful in situations where writing an entire class
    (see Chapter 7) brings in too much boilerplate. Since I only have one piece of
    state, `limit`, and I am using it predictably, this approach is acceptable. Anything
    more complicated, and debugging becomes impractically difficult.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: As I pointed out earlier, anytime you see `nonlocal` in a closure, you should
    be extra cautious, as it indicates the presence of state. This can be acceptable
    on occasion, but there is usually a better approach. Stateful closures are not
    pure functional programming!
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *lambda* is an anonymous (nameless) function made up of a single expression.
    The structure is as follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: On the left side of the colon is the parameter list, which may be omitted if
    you don’t want to accept any arguments. On the right is the return expression,
    which is evaluated when the lambda is called and the result is implicitly returned.
    To use a lambda, you must bind it to a name, whether by assignment or by passing
    it as an argument to another function.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s a lambda that adds two numbers:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Listing 6-37: *addition_lambda.py*'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: I bind the `lambda` to the name `add` and then call it as a function. This particular
    lambda accepts two arguments and then returns their sum.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Why Lambdas Are Useful
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many programmers can’t imagine ever needing nameless functions. It would seem
    to make reuse completely impractical. After all, if you’re just going to bind
    a lambda to a name, shouldn’t you have just written a function?
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how lambdas can be useful, let’s take a look at an example *without*
    lambdas first. This code represents a player character in a basic text adventure
    game:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Listing 6-38: *text_adventure_v1.py:1*'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m keeping track of my character’s stats in a couple of global names at the
    top, `health` and `xp`, which I’ll use throughout my program:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Listing 6-39: *text_adventure_v1.py:2*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: My `attempt()` function handles rolling the dice, using the outcome to decide
    whether the player’s action succeeded or failed, and then modifying the values
    of the global `health` and `xp` variables accordingly. It determines how those
    values should be changed, based on the value returned from calling the function
    passed to `outcome`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: The part to focus on is the parameter `outcome` ❶—which, by its usage in `attempt()`
    ❷, should be a function that accepts a boolean value and returns a tuple of two
    integers representing the desired changes to `health` and `xp`, respectively.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanding on that example, I’ll use what I’ve built so far:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Listing 6-40: *text_adventure_v1.py:3a*'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s no real pattern to the outcomes of each possible action, so I have
    to write functions for each one: in this example, `eat_bread()` and `fight_ice_weasel()`.
    Even this example is a bit oversimplified, as the code determining the outcome
    might involve a bunch of mathematics and randomization. Regardless, since I need
    a separate outcome function for each action, this code is going to grow rapidly,
    leading to a maintainability nightmare.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: (Be advised, the `if` statement above is not the most Pythonic way to write
    that code; I deliberately chose that structure to illustrate the logic.)
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: When I attempt an action ❶, I pass the string representing the action, the minimum
    dice roll necessary to succeed, and the function determining the outcome. When
    passing a function, remember not to include the trailing parentheses. Here, I
    want to pass the function itself, not the value it returns.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of usage is where lambdas come in. I can replace the `eat_bread()`
    and `fight_ice_weasel()` functions, plus the two calls to `attempt()`, with just
    the following:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Listing 6-41: *text_adventure_v1.py:3b*'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: 'The third argument of each is a lambda, which accepts a single parameter named
    `success` and returns a value depending on the value of `success`. Let’s isolate
    just that first lambda:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: When the lambda is called, if the value of `success` is `True`, then `(1, 0)`
    will be returned. Otherwise, `(-1, 0)` is returned.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: That lambda is being passed to (and thus bound to) the `outcome` parameter of
    the `attempt()` function, and it is subsequently called with a single boolean
    argument.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: By using lambdas in this manner, I can create many different possible outcomes
    in my code with only one line of code.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Remember that *a lambda may only consist of a single return expression*! This
    makes lambdas suitable for short, clear fragments of logic, especially when the
    code is made more readable by keeping that logic close to its usage within another
    function call. If you want anything more complex, you’ll need to write a proper
    function.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas as Sorting Keys
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common situations where a lambda comes in handy is when specifying
    a *key function*, which is a callable that returns the part of a collection or
    object that should be used for sorting. A key function is typically passed to
    another function that is responsible for sorting data in some manner.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here I have a list of tuples containing first and last names,
    and I want to sort the list by last name:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Listing 6-42: *sort_names.py*'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: The `sorted()` function uses the `key` argument ❶, which is always a function
    or other callable, by passing each item to it and then using the value returned
    from that callable to determine the sorting order. Since I want the tuples sorted
    by last name, which is the second item of each tuple, I have the lambda return
    that item, which is `x[1]`.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that `by_last_name` contains the list, sorted by last name.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Decorators* allow you to modify the behavior of a function (or even multiple
    functions) by wrapping it in an additional layer of logic. This changes the function’s
    behavior without you having to rewrite the function itself.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, here’s another example with my text adventure game hero.
    I want to define multiple game events that affect the player character’s statistics
    in different ways, and I want those changes displayed as they happen. I’ll start
    with an implementation that doesn’t use decorators. This code only uses concepts
    I’ve already covered so far in this book, so I’ll mainly draw your attention to
    some inefficiencies.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by defining my global variables:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Listing 6-43: *text_adventure_v2.py:1a*'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I’ll define functions for each action the player can take:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Listing 6-44: *text_adventure_v2.py:2a*'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Each function represents an action the player can take, and some common code
    is shared between these functions. First, each function checks the character’s
    health to determine if the character is even able to perform the action ❶ ❸. If
    the character’s health is sufficient, the player performs the action, which alters
    the character’s statistics. When the action is completed (or if the character’s
    health is too low to take an action), the current stats are displayed ❷ ❹.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, of course, I have the usage:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Listing 6-45: *text_adventure_v2.py:3*'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: That works, but as I said, the repeated code in [Listing 6-44](#listing6-44)
    is not very Pythonic. Your first instinct might be to move the common code—the
    code that checks the health and displays the statistics—out into their own functions.
    However, you would still need to remember to call each one within *every character
    action function*, and they’re easy to overlook. Furthermore, each function would
    still need that conditional statement at the top to ensure the code isn’t run
    when health is too low.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: This situation, where I want to run the same code before and after every function,
    can be perfectly solved with decorators.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I’ll create a decorator toward the top of the text adventure game code:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Listing 6-46: *text_adventure_v2.py:1b*'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: A decorator is most often implemented as a closure, which closes over a function
    (or any other callable object) being modified. The decorator itself, `character_action()`,
    accepts a `func` parameter, which is the callable being modified.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: Within the decorator definition is the *wrapper*, which is the callable where
    the decorator’s logic lives ❸. As I said, most commonly, the closure pattern is
    used for this. However, the wrapper can be implemented with any callable, including
    a class. (Technically, I could even implement the wrapper as a noncallable, but
    this is seldom, if ever, useful.)
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Because I don’t know how many arguments will be passed to any function I’ll
    apply the decorator to, I set up the wrapper to accept variadic arguments.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: The `@functools.wraps(func)` line ❷ prevents the callable being wrapped from
    having its identity concealed from the rest of the program. Without that line,
    wrapping the callable would mess up external access of such important function
    attributes as `__doc__` (the docstring) and `__name__`. This line is itself a
    decorator that ensures all the important attributes of the callable are retained
    by the now-wrapped function, thus making them accessible outside the function
    in all the usual ways. (To use that special decorator, I must import `functools`
    first ❶.)
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Inside the wrapper, I put all that logic I want to run before and after each
    function. After checking `health`, I call the function that is bound to `func`,
    unpacking all the variadic arguments into the call. I also bind the return value
    to `result`, so I can ensure that gets returned from the decorator after I print
    the stats.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: As with any closure, it is supremely important that the outer function return
    the inner function ❹.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I can use the decorator I wrote and refactor my other functions:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Listing 6-47: *text_adventure_v2.py:2b*'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: To apply decorators to a function, I list each decorator I want to apply directly
    above the function definition, one decorator per line. I precede each decorator
    name with an `@` symbol. In my example, I only apply a single decorator to each
    function, but you can use as many as you like. They will be applied in order,
    with each decorator wrapping whatever is immediately below it.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: Since I moved all the repetitive logic about checking health and displaying
    stats out of the individual functions and into the decorator, my code is cleaner
    and easier to maintain. If you run the code, it works the same as before.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Type Hints and Function Annotations
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python 3.5 onward allows you to specify *type hints*, which are exactly that:
    *hints* about what data type should be passed in or returned. These are not strictly
    necessary, given Python’s robust dynamic type system, but they may have a few
    benefits.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: First, type hinting aids in documentation. The function definition now shows
    what type of information it wants, which is especially helpful when your IDE auto-magically
    shows hints as you type arguments in.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Second, type hints help you catch potential bugs sooner. Static type checkers
    like *Mypy* are the primary tools for this (see Chapter 2). Some IDEs, like PyCharm,
    may warn you if you’re doing something weird, like passing a string to something
    type-hinted as an integer.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with statically typed languages like Java and C++, this might
    make you a little excited.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: However, understand that using type hints does not trade Python’s dynamic typing
    for static typing!
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Python will not raise an error if you pass the wrong type.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python will not try to convert data to the specified type.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python will actually ignore these hints altogether!
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type hints are specified with *annotations*, which are extra pieces of information
    that are permitted by the Python language but are not actually processed by the
    interpreter itself. There are two kinds of annotations.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '*Variable annotations* specify the expected type on a name, like this:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '*Function annotations* specify type hints on parameters and function returns.
    Here, I apply function annotations to the `roll_dice()` function from earlier:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Listing 6-48: *dice_roll.py:1e*'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: This notation allows me to denote what types I expect for the parameters and
    return. In this case, both parameters should receive an integer, so I follow each
    name with a colon and then `int` as the expected data type. If there’s a default
    value of the expected type, it is included after the type hint.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: I denote the return type with an arrow (`->`) and the expected type. Collections
    like tuples and lists are a little trickier to specify with type hints. From the
    `typing` module, I can use the notation `Tuple[ ]`, which is a *generic type*.
    Every value of this particular tuple should be an `int`, but since I don’t really
    know how many will be returned, I specify a `...` to say, “There may be more.”
    Now, the function will be expected to return one or more integers, but no other
    types.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if you don’t know what or how many types will be returned in a tuple,
    you can use the notation `typing.Tuple[typing.Any, ...]`
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 'That return type hint in the preceding code example is pretty long. I could
    shorten it by defining a *type alias*, like this:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Listing 6-49: *dice_roll.py:1f*'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: I define `TupleInts` as a type alias for `Tuple[int, ...]`, and I can use it
    the same way throughout my code.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Again, Python itself won’t act on these type hints; it will only recognize the
    notation system as valid and store it in the `__annotations__` attribute of the
    function, nothing more.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'I can now run this code through Mypy:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: If there are any mismatches between the type hints and the actual usage, Mypy
    will list these in detail, so they can be fixed.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: Duck Typing and Type Hints
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might think that type hinting is incompatible with duck typing, but thanks
    to the `typing` module, the two generally play very well with one another.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you wanted a function that could accept a single parameter of
    any type that could be iterated over (see Chapter 9), such as a tuple or a list,
    you could use `typing.Iterable[]`, with the contained type in the brackets. For
    this example, I’ll presume that the iterable may contain any type.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The parameter `within` is type-hinted to be an iterable with `typing.Iterable[
    ]`. The hint `typing.Any` within the square brackets indicates that the `Iterable`
    can contain items of any data type.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'The typing module contains many different such types, enough to fill up a separate
    chapter altogether. The best way to learn more about type hinting is to read the
    documentation: [https://docs.python.org/library/typing.html](https://docs.python.org/library/typing.html).
    I also recommend taking a look at PEP 484, which defined type hinting, and PEP
    3107, which defined function annotations.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: Should You Use Type Hinting?
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type hinting is entirely optional, and there are cases for it and against it.
    Some argue that it clutters up the code, impairing the natural readability that
    Python attained through dynamic typing. Others see it as a much-needed tool for
    mitigating the bugs made possible through the lack of static typing.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: In practice, you don’t need to make a wholesale “use or don’t use” decision.
    Because type hinting is optional, you can use it in cases where it improves the
    readability and stability of the code and skip it in cases where it doesn’t. Even
    within a function, you can define a type hint for one parameter and omit it for
    the next.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the decision is up to you and your team alone. Only you know if
    and when type hints will be helpful. In short, *know thine own project*.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Since this book focuses on idiomatic Python above all else, and since type hinting
    is entirely optional, I won’t use it in any future examples.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I hope you come away from this chapter with a newfound appreciation for functional
    programming in the Python language. Even when the paradigm is not embraced wholesale,
    its concepts and guidelines inform Pythonic code.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: I’ll still apply functional concepts as I move into object-oriented programming
    in the next chapter. I’ve found that, when combined correctly, these paradigms
    interact in surprisingly positive ways.**  **# 7
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: Objects and Classes
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
- en: Objects are the bread and butter of many a programmer. Python makes full use
    of objects, even to the point of inspiring the mantra, “Everything is an object.”
    However, if you’ve worked with classes and objects in any other language, Python’s
    take may surprise you.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-oriented programming* (or *OOP*) is a paradigm in which data and its
    corresponding logic is organized into objects. If you’re familiar with such languages
    as Java, C++, Ruby, and C#, you’re well acquainted with these concepts.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: Yet, object-oriented programming in Python is not mutually exclusive with functional
    programming; in fact, the two paradigms work very well together.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ll cover the essentials of object-oriented programming in
    Python: creating classes with attributes, modules, and properties. I’ll demonstrate
    adding various behaviors via special methods, and I’ll wrap up with a summary
    of the situations in which classes are the most useful.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Class
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a new class is simple. I’ll create a class named `SecretAgent`:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Listing 7-1: Initializing a class'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Below this, in the accompanying suite of the class declaration, I’d add any
    methods I want to include in the object. An object is known as an *instance* of
    a class in Python. I’ll cover this in detail shortly.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: In Python, everything is an object, in that everything inherits from the `object`
    class. In Python 3, this inheritance from `object` is implicit, as seen in [Listing
    7-1](#listing7-1). In Python 2, you had to explicitly inherit from `object`, or
    from another class that inherits from `object`. (I cover inheritance in Chapter
    13. You can take it for granted here.)
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `SecretAgent` class declaration again, this time explicitly inheriting
    from `object`, as Python 2 would have required:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Listing 7-2: Initializing a class with explicit inheritance'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: Listings 7-1 and 7-2 are functionally identical. Python developers really hate
    *boilerplate code*, which is code that is widely reused, with little or no modification.
    That is why Python 3 added the shorter technique seen in [Listing 7-1](#listing7-1).
    Unless you need to support Python 2, the shorter technique is preferred. You’ll
    encounter both ways often enough, so it’s important to know that they do the exact
    same thing in Python 3.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: The Initializer
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A class often has an *initializer* method for defining the initial values of
    *instance attributes*, which are the member variables that exist in each instance.
    If your instance will have no instance attributes, you don’t need to define `__init__()`.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: 'I want each instance of `SecretAgent` to have a code name and a list of secrets.
    Here’s the initializer for my `SecretAgent` class, which has two instance attributes:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Listing 7-3: *secret_agent.py:1a*'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: The initializer must have the name `__init__` to be recognized as an initializer,
    and it must accept at least one argument, conventionally called `self`. This `self`
    argument references the instance the method is acting on.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I also accept a second argument, `codename`, which I use as the
    initial value of one of my instance attributes. This `self.codename` attribute
    will be the code name of the secret agent.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Instance attributes are part of the class instance itself, so I must access
    them through the dot (`.`) operator on `self`. All instance attributes should
    be declared in the initializer method, rather than on the fly in other instance
    methods. Therefore, I’m also defining `self._secrets` as an empty list. This will
    be a list of secrets the particular secret agent (instance) is keeping.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, an initializer must never return a value via the `return` keyword; if
    it does, calling the initializer will raise a `TypeError`. However, you may use
    `return` by itself to explicitly exit the method, if you ever need to.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever I create a new class instance, the initializer is automatically called.
    Here, I create three `SecretAgent` instances and provide arguments for the `codename`
    parameter of the initializer:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Listing 7-4: *secret_agent_usage.py:1*'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: In this module, I import my `SecretAgent` class and create three new instances.
    You’ll notice that I didn’t need to pass anything to the first parameter, `self`.
    That’s taken care of behind the scenes. Instead, my first argument, `"Mouse"`,
    is passed to the second parameter of the initializer, `codename`. Each instance
    also has its own empty `_secrets` list.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: The Constructor
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re coming from C++, Java, or some similar language, you may expect to
    write a *constructor*—a function that constructs an instance of a class—or you
    may think that the initializer does the same thing as a constructor. In fact,
    Python 3 splits the duties of a typical constructor between the initializer `__init__()`
    and the constructor `__new__()`.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the constructor `__new__()` takes care of actually creating the instance
    in memory. When you create a new instance, the constructor is automatically called
    first, followed by a call to the initializer. The constructor is the only method
    in the class to be called automatically before the object is created!
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t normally need to define a constructor; one is provided automatically.
    The only time you would create a constructor would be if you needed additional
    control over the process. However, to familiarize you with the syntax, I’ll write
    a very basic (and effectively pointless) constructor, which could go in a class
    definition:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The constructor always has the name `__new__`, and it implicitly accepts a class
    as its first parameter, `cls` (in contrast to the initializer, which accepts a
    class instance on `self`). Since the initializer accepts parameters, I also need
    to prepare the constructor to accept these on the constructor, so I use variadic
    arguments to capture these arguments and pass them on to the initializer parameters.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: The constructor must return the class instance that gets created. Technically,
    I could return whatever I wanted here, but the expected behavior would almost
    certainly be to return an instance that has been instantiated from the `SecretAgent`
    class. To do that, I call the `__new__` function on the parent class, which you
    may recall (from [Listing 7-2](#listing7-2)) is `object`. (I’ll return to `super()`
    in Chapter 13. Don’t worry about understanding it now.)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: In practice, if this is all your constructor needs to do, just omit it! Python
    automatically handles the constructor behavior if you don’t write any code for
    it. Only write a constructor when you need to control the behavior around instantiating
    the class instance itself. In any event, that scenario is rare; it is perfectly
    plausible that you will never write a constructor in your entire Python programming
    career.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: The Finalizer
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *finalizer* is called when a class instance finally reaches the end of
    its lifespan and is cleaned up by the garbage collector. It exists solely to handle
    any technically complex cleanup that your particular class may require. As with
    the constructor, you will seldom, if ever, need to write this function yourself.
    If you do, it’s important to understand: the finalizer is only called if the class
    instance (value) itself is cleaned up by the garbage collector!'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: If any references to the class instance still exist, the finalizer won’t be
    called; furthermore, depending on the implementation of Python you’re using, the
    garbage collector might not always clean up the class instance when you’d expect,
    if at all.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, only use the finalizer for code directly relating to garbage-collecting
    the class instance. It should never contain code that needs to be run as part
    of any other circumstance.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a rather useless finalizer that prints a message when the garbage collector
    cleans up a `SecretAgent` class instance:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Listing 7-5: *secret_agent.py:2*'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: A finalizer always has the name `__del__` and accepts a single parameter, `self`.
    It must not return anything.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this finalizer, I’ll create and manually delete an instance.
    It is possible to delete a name, thereby unbinding it from its value, by using
    the `del` keyword. Given the `SecretAgent` class with that finalizer method, I
    can create and then delete a name referring to a class instance:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Listing 7-6: *secret_agent_disavow.py*'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: I create a new instance from the `SecretAgent` class and bind it to the name
    `weasel`. Then, I immediately delete the name by using the `del` operator. The
    name `weasel` is now undefined again. Coincidentally, because no references remain
    to the `SecretAgent` instance the name was bound to, that instance is cleaned
    up by the garbage collector, which first calls the finalizer.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, running that code displays this output:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Note that `del` only deletes the name, not the value! If you have multiple names
    bound to the same value, and if you `del` one of those names, then the other names
    and their values will be unaffected. In other words, `del` will not force the
    garbage collector to delete the objects.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All variables belonging to a class or instance are called *attributes*. Attributes
    belonging to the instance itself are called *instance attributes*, which are also
    sometimes referred to as *member variables*. Attributes belonging to the class
    itself are *class attributes*, which are also sometimes called *class variables*.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: Many intermediate-level Python programmers don’t realize there is a significant
    difference between the two. I must admit, I spent the first few years of my Python
    development career using them utterly incorrectly!
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Instance Attributes
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *instance attribute* exists on the instance itself; its value is unique to
    the instance and is not available to other instances. All instance attributes
    should be declared in the class’s initializer.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting the `__init__()` method from [Listing 7-3](#listing7-3), you’ll
    see I have two instance attributes:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Class Attributes
  id: totrans-701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *class attribute* exists on the class, instead of on an individual instance.
    In practice, this means that all related class instances effectively “share” a
    class attribute, although it would exist even without any instances.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'Class attributes are declared at the top of the class, outside of any methods.
    Here, I add one class attribute directly into the suite of the class:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Listing 7-7: *secret_agent.py:1b*'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: The attribute `_codeword` belongs to the `SecretAgent` class. Typically, all
    class attributes are declared before any methods to make them easier to find,
    although this is just convention. The important part is that they are defined
    outside of any methods.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 'The class attribute can be accessed like this:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Listing 7-8: *secret_agent_usage.py:2a*'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: I can access the class attribute `_codeword` directly through the class, or
    through any instances instantiated from the class. If the class attribute is rebound
    or mutated on the class itself ❶, the changes will appear in all cases. However,
    if a value is assigned to the name on an instance, it will create an instance
    attribute with the same name ❷, which shadows the class attribute on that instance,
    without affecting other instances.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: Class attributes are particularly useful for constant values that the class’s
    methods use. I also find them more practical and maintainable than global variables
    in many cases, especially in GUI programming. For example, I often employ class
    attributes when I need to maintain a shared instance of a widget, like a window.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: Scope-Naming Conventions
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re coming from a language that has class scope, you may wonder why I
    haven’t mentioned it yet. Isn’t data hiding an important part of encapsulation?
    In fact, Python has no formal concept of data hiding. Instead, PEP 8 outlines
    a naming convention that indicates whether an attribute is safe to modify externally
    (public) or not (nonpublic).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: While I talk a lot about attributes in this section, these naming conventions
    apply to methods as well.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: Nonpublic
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By preceding a name with an underscore, I declare that the attribute `_secrets`
    is intended to be *nonpublic*, meaning it shouldn’t be modified (or, ideally,
    accessed) outside of the class. This is more of a social contract via style convention;
    I’m not actually hiding anything.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: This may seem dangerous to many developers coming from languages with explicit
    scope, like Java, but it works out pretty well. As my pal “grym” likes to put
    it, “If you know why you shouldn’t stick a fork in a toaster, you are therefore
    qualified to stick a fork in a toaster.” In other words, if the client is going
    to disregard the underscore warning label, they probably know what they’re doing.
    (On the off-chance they don’t, they’re fully responsible for the consequences.)
    That little underscore hanging out after the dot operator is advertising “You
    really shouldn’t mess with me!”
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: Public
  id: totrans-718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The attribute `codename`, which does not start with an underscore, is intended
    to be *public*. It is okay for this attribute to be accessed or modified externally,
    as it won’t really affect the behavior of the class. Public attributes are preferable
    to writing a plain getter/setter pair of methods; the behavior is the same, but
    the result is cleaner, with less boilerplate.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: If an attribute needs a custom getter or setter, one approach is to define the
    attribute as nonpublic and create a public *property*, which I’ll come back to
    shortly.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: Name Mangling
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python does offer *name mangling*, which rewrites an attribute or method name
    to prevent it from being shadowed by derived (inheriting) classes. This provides
    a sort of weak form of data hiding. It can also be useful for an added level of
    forewarning: “No, *really*, if you mess with this attribute, terrible things will
    happen!”'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark an attribute (or method) for name mangling, precede the name with two
    underscores (`__`), like this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Listing 7-9: *message.py:1*'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__format` attribute will be name mangled, so accessing it externally in
    the ordinary manner will not work:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Listing 7-10: *message.py:2*'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 'This will raise an `AttributeError` because the `msg` instance does not have
    an attribute named `__format`; the name of that attribute was mangled. Be aware
    that name mangling is *not* a true form of data hiding! It is still perfectly
    possible to access a name-mangled attribute:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Listing 7-11: *message.py:3*'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: 'The name-mangling pattern is predictable: an underscore, the name of the class,
    and then the name of the attribute, with its two leading underscores.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: Public, Nonpublic, or Name Mangled?
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When deciding whether to make an attribute public or nonpublic, I ask myself
    one question: could changing this attribute externally cause unexpected or negative
    behavior in the class? If the answer is yes, I make the attribute nonpublic by
    preceding it with an underscore. If the answer is no, I leave the attribute public.
    It is up to the coder using the class to respect the rules or suffer the consequences.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: As to name mangling, in practice, I very rarely employ this pattern. I reserve
    it only for those cases where (a) I need to avoid a naming conflict in the context
    of inheritance or (b) external access of the attribute will have exceptionally
    horrific effects on the behavior of the class, and thus, an extra degree of warning
    is justified.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: Always remember that Python does not have private class scope. Truly secret
    data should be properly encrypted, not just concealed from your API. There are
    also no optimization benefits to private class scope, unlike in languages like
    Java, since all attribute lookups occur at runtime.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  id: totrans-737
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class is nothing without its methods, which make encapsulation possible.
    There are three distinct types of methods: instance methods, class methods, and
    static methods.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: Instance Methods
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Instance methods* are your run-of-the-mill methods, which exist on the instance
    itself. The first parameter, conventionally named `self`, provides access to the
    instance attributes of the instance.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I add an instance method to my `SecretAgent` class:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Listing 7-12: *secret_agent.py:3*'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: Besides the required first parameter, the instance method accepts a second parameter,
    `secret`, which is appended to the list bound to the instance attribute `_secrets`.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'I call this method on the instance, using the dot operator:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Listing 7-13: *secret_agent_usage.py:2b*'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: The dot operator implicitly passes `mouse` to the `self` parameter, so my first
    argument, the tuple of coordinates (notice the extra set of parentheses), is passed
    to the second parameter, `secret`, on the `remember()` method.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: Class Methods
  id: totrans-749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like class attributes, *class methods* belong to the class, instead of to the
    instances instantiated from the class. These are useful for working with class
    attributes.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in [Listing 7-7](#listing7-7), I defined `_codeword` as a class attribute
    so all `SecretAgent` instances would be aware of the code word; it’s something
    all agents should have in common. I need a way to inform all the agents at once
    of the new code word, so I’ll add a class method, `inform()`, which will modify
    the `_codeword` class attribute:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Listing 7-14: *secret_agent.py:4*'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: I precede a class method with the built-in `@classmethod` decorator. A class
    method receives the class as its first argument, so the first parameter is named
    `cls`. Class attributes like `_codeword` are accessed on the class passed to `cls`.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of this approach is that I don’t have to worry about whether
    I’m calling `inform()` on the class or on an instance. Because the method is a
    class instance, it will always access the class attribute on the class (`cls`),
    instead of the instance (`self`), and thus avoid accidentally shadowing `_codeword`
    on a single instance (see [Listing 7-8](#listing7-8)).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: I don’t plan to include a getter for this attribute. After all, secret agents
    have to keep secrets!
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this method, I would call something like this:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Listing 7-15: *secret_agent_usage.py:3*'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: I can call the `inform()` class method directly on the `SecretAgent` class,
    or on any `SecretAgent` instance, such as `fox`. The changes that `inform()` makes
    to the class attribute `_codeword` appear on the class itself and all its instances.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: When calling the class method with the dot operator, the class is implicitly
    passed to the `cls` parameter. That parameter name is still just a convention;
    the `@classmethod` decorator is what ensures that the first argument is always
    the class, never the instance.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: One awesome use of class methods is to provide alternative means of initializing
    instances. For example, the built-in integer class offers `int.from_bytes()`,
    which initializes a new `int` class instance, using a `bytes` value.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: Static Methods
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *static method* is a regular function defined within a class, which accesses
    neither the instance attributes nor the class attributes. The only difference
    between a static method and a function is that a static method belongs to the
    class for namespace reasons.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: The main reason to write a static method comes up when your class offers some
    functionality that doesn’t need to access any of the class or instance attributes
    or methods. For example, you may write a static method for handling some particularly
    complicated algorithm that is critical to your class’s implementation. By including
    the static method in the class, you are indicating that the algorithm is part
    of the class’s self-contained implementation logic, even though it does not access
    any attributes or methods.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll add a static method to the `SecretAgent` class, which handles one thing
    all the agents would do the same, regardless of their data—answer questions:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Listing 7-16: *secret_agent.py:5*'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: I precede the static method with the `@staticmethod` decorator. You’ll notice
    that I don’t need to worry about a special first parameter, since the method doesn’t
    need access to any attributes. When this method is called on a class or on an
    instance, it only prints out the message, “I know nothing.”
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Properties* constitute a special variety of instance method that allows you
    to write getters and setters that behave so it appears that you were directly
    accessing an instance attribute. Properties allow you to write a consistent interface,
    where you use the object directly through what appear to be its attributes.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: It is preferable to use properties, instead of making the user remember whether
    to call a method or use an attribute. Using properties is also much more Pythonic
    than cluttering your class with bare getters and setters that don’t augment attribute
    access or modification.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Scenario
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate properties in action, I’ll expand on my `SecretAgent` class.
    Here’s the class so far. First, to set up, I’ll move it to a new file:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Listing 7-17: *secret_agent_property.py:1*'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I will add one more class method to encrypt whatever message is passed
    to it, using an encryption system of my own devising. This method has nothing
    to do with properties per se, but I include it to make the example complete:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Listing 7-18: *Using a property with no getter*'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: The `_encrypt()` class method uses the `_codeword` class attribute to perform
    a basic substitution cipher encoding on a string `message`. I use `sum()` to find
    the sum of the Unicode code points (as integers) for each character in `_codeword`.
    I pass a character (string) to the `ord()` function, which returns the Unicode
    code point as an integer. This sum of code points is bound to `code`. (The odd-looking
    loop here is actually a generator expression, which I’ll cover in Chapter 10.
    You can take it for granted here that it calls `ord()` on each character in the
    string bound to `cls._codeword`.)
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: I use `code` to offset the Unicode code point of each character in the message.
    The `chr()` function returns the character associated with the given code point.
    I pass to it the sum of the current code point and `code`, for each character
    in the message. (Once again, I’m employing a generator expression here.)
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Property
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *property* behaves like an attribute, but it is made up of three instance
    methods: a *getter*, a *setter*, and a *deleter*. Remember that a property appears
    to be an ordinary attribute to the user of the class. Accessing the property calls
    the getter, assigning a value to it calls the setter, and deleting the property
    with the `del` keyword calls the deleter.'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: Like an ordinary getter or setter method, a property might access or modify
    a nonpublic attribute, multiple attributes, or even no attributes at all. It all
    depends on what behavior you want.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: Here, I’ll define a property called `secret` for my `SecretAgent` class, which
    will serve as the getter, setter, and deleter for my `_secrets` instance attribute.
    This approach will allow me to add logic, such as having the setter encrypt the
    assigned data before storing it in the `_secrets` attribute.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: Before defining the property itself, I need to define the three functions that
    will make up the property. Technically, I can call them whatever I like, but the
    convention is to name them `getx`, `setx`, or `delx`, where `x` is the name of
    the property. I’m also making these nonpublic methods, since I want the client
    to use the property directly.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the getter:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Listing 7-19: *secret_agent_property.py:3*'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: The getter, `_getsecret()`, accepts no parameters and should return the value
    of the property. In this example, I want the getter to return the last item stored
    in the list bound to the instance attribute `self._secrets`, or if the list is
    empty, to return `None`.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the setter:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Listing 7-20: *secret_agent_property.py:4*'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: The setter, `_setsecret()`, accepts a single parameter, which receives the value
    being assigned to the property in the call (see [Listing 7-23](#listing7-23)).
    In this case, I assume this is some sort of string, which I run through the static
    method `_encode()` I defined earlier and then store in the list `self._secrets`.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here’s the deleter:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Listing 7-21: *secret_agent_property.py:5*'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: The *deleter*, `_delsecret()`, accepts no parameters and returns no value. This
    method is called when the property is deleted, either in the background, by the
    garbage collector, or explicitly, with `del secret`. In this example, when the
    property is deleted, I want the entire list of secrets to be cleared.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: You actually don’t need to define a deleter if you have no need for special
    behavior when the decorator is deleted. Consider what you want to happen if `del`
    is called on your decorator, such as when you are deleting an associated attribute
    that the property controls; if you can’t think of anything, skip writing the deleter.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I define the property itself:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Listing 7-22: *secret_agent_property.py:6a*'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: This is defined on the class itself, outside of the `__init__()` method and
    after the functions that make it up. I pass the three methods to the `fget`, `fset`,
    and `fdel` keyword arguments, respectively (although you can also pass them as
    positional arguments, in that same order). I bind the property to the name `secret`,
    which becomes the property name.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: 'The property can now be used as if it were an instance attribute:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Listing 7-23: *secret_agent_property.py:7a*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: Every time I try to retrieve the value of the property, the getter is called.
    Meanwhile, assigning a value to the property calls the setter. There’s no need
    to remember and explicitly call dedicated getter or setter methods; I treat the
    property like an attribute.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: You’ll recall that the deleter for `secrets` clears the contents of the `_secrets`
    list. Just before deleting the property, the list contains two secrets. After
    deleting, the list is empty.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to define all three parts of the property. For example,
    I don’t want the `secret` property to even have a getter, so I can remove `_getsecret()`
    from my class code. Secret agents shouldn’t share their secrets, after all.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Listing 7-24: A secret property with no getter'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: Because I don’t pass an argument to `fget`, the default value of `None` is used
    instead ❶. This property has a setter and a deleter, but no getter.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, I can assign to `secret`, but I can’t access the value:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Listing 7-25: *Using a property with no getter*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to `mouse.secret` works as before, since that calls the setter.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: 'However, attempting to access the value throws an `AttributeError`. I could
    instead have written a getter for secrets that always returned `None`, but the
    client would have to remember that it returned this useless value. Recall The
    Zen of Python:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: Errors should never pass silently.
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  id: totrans-820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a particular usage is not desired, especially when it comes to designing
    a class or interface, the usage should *explicitly fail*.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: Property with Decorators
  id: totrans-822
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a property is easy enough, but the approach to implementing it that
    I’ve shown thus far doesn’t really feel very Pythonic, because I have to rely
    on my method names to remind me that they’re part of a property. Thankfully, there’s
    another way.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: 'Python offers a cleaner approach to defining properties: with decorators. There
    are two approaches to this technique.'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: 'Approach 1: property() and Decorators'
  id: totrans-825
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first approach is to still employ the `property()` function but use decorators
    to denote the associated methods. The chief benefit of this approach is the added
    readability, and it is mainly used when the getter will be omitted. I can use
    the name of the property as the method name and rely on the decorator to clarify
    its role.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my rewritten code for the `secret` property, using this approach:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Listing 7-26: *secret_agent_property.py:3b*'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: 'In this approach, I define `secret` as a property before writing its methods.
    I pass no arguments to `property()`, so all three functions default to `None`.
    Next, I add the getter:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Listing 7-27: *secret_agent_property.py:4b*'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: My getter method now must have the same name as the property, `secret`. If it
    doesn’t, it will fail with an `AttributeError` when the getter is first called,
    rather than when the class is created. The method is preceded by the decorator
    `@secret.getter`. This designates it as the getter for the property, just as if
    I had passed it to `property(fget=)`.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the setter:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Listing 7-28: *secret_agent_property.py:5b*'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the setter method must share its name with the property it relates
    to, and it is preceded by the decorator `@secret.setter`.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the deleter:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Listing 7-29: *secret_agent_property.py:6b*'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the getter and setter, the deleter is preceded by the decorator `@secret.deleter`.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: This version works as is, but there is an even better technique.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: 'Approach 2: Decorators Without property()'
  id: totrans-843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second approach to declaring a property with decorators is even shorter,
    and it is the most commonly used. This approach is preferred when defining a property
    that has a getter.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have defined a getter, you don’t have to explicitly create and assign
    a `property()`. Instead, the decorator `@property` can be applied to the getter:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: I precede the getter function with the decorator `@property`, instead of `@secret.getter`,
    which creates a property with the same name as the method. Since this defines
    the property `secret`, I don’t need `secret = property()` anywhere in my code.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind, this shortcut only works with the getter method. The setter and
    deleter must be defined in the same manner as before.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, I can omit any of the three methods if their behavior is not desired.
    For example, if I don’t want `secret` to be readable, I omit the getter, so my
    full property code looks like this:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Because I don’t have a getter, I must explicitly declare my property up front
    ❶. In this version, assignment and deletion of `secret` works as before, but accessing
    the value raises an `AttributeError`.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: When Not to Use Properties
  id: totrans-852
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s some debate about when to use properties, versus traditional getter
    and setter methods. One of the chief drawbacks of properties is that they conceal
    that some calculation or processing is being performed upon assignment, which
    the client might not expect. This especially becomes a problem if this processing
    is particularly long or complicated, such that a client may need to run it concurrently
    with `async` or threads (see Chapters 16 and 17); you cannot run an assignment
    concurrently with the same ease as running a method concurrently.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: You must also consider the expected behavior of an assignment. When a value
    is directly assigned to an attribute, you would typically expect the same value
    to be retrievable *from* that attribute. In reality, depending on how you wrote
    your properties, the value might be transformed when assigned or accessed. You’ll
    need to take this client expectation into consideration when designing your class.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: Some camps believe properties should only be used as a way of deprecating attributes
    that used to be public or that have been removed entirely. Others, like myself,
    find properties useful as replacements for otherwise relatively simplistic getters
    and setters that still involve more logic than plain assignment and access.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: In any case, properties are some of those cool features of Python that are all
    too easy to misuse or misapply. Carefully consider the implications of properties,
    public attributes, or methods in your specific case. Take the occasion to consult
    the advice of other experienced Python developers, such as in the Libera.Chat
    IRC `#python` channel. (If you want to debate the most Pythonic general position
    on properties, though, bring a helmet.)
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: Special Methods
  id: totrans-857
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Special methods are my favorite part of Python object-oriented programming.
    I’m trembling a little with excitement right now (or maybe I had too much coffee).
    *Special methods*, sometimes called *magic methods*, allow you to add support
    to your classes for virtually any Python operator or built-in command!
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: 'Special methods are also colloquially known as *dunder methods*—which is short
    for “***d***ouble ***under***score”—because they begin and end with two underscore
    characters (`__`). You’ve already seen three examples of special methods: `__init__()`,
    `__new__()`, and `__del__()`. The Python language defines about a hundred special
    methods, most of which are documented at [https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html).
    I’ll cover a number of the most common ones here. In future chapters, I’ll discuss
    other special methods as they become relevant. I also list all the special methods
    in Python in Appendix A.'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: Scenario Setup
  id: totrans-860
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the examples in this section, I’ll use a new class, `GlobalCoordinates`,
    which will store a global coordinate as latitude and longitude. This class is
    defined as follows:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Listing 7-30: *global_coordinates.py:1*'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: You can probably work out what’s going on here, based on the knowledge you have
    so far. The class `GlobalCoordinates` converts and stores a latitude and longitude
    as tuples of degrees, minutes, seconds, and a string literal representing a cardinal
    direction.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: I chose to create this particular class because its data lends itself well to
    a healthy subset of the special methods I’ll cover.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: Conversion Methods
  id: totrans-866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to represent the same data, and most clients will expect
    to be able to convert an object containing data to any Python primitive type that
    makes sense. For example, global coordinates could be expressed as strings or
    hashes. You should carefully consider what data types your class should support
    conversion to. Here, I cover some special methods for data conversions.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: 'Canonical String Representation: __repr__()'
  id: totrans-868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When writing a class, it is considered good practice to define, at minimum,
    the `__repr__()` instance method, which returns the *canonical string representation*
    of the object. This string representation should ideally contain all the data
    necessary to create another class instance with the same contents.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: 'If I don’t define a `__repr__()` instance method for `GlobalCoordinates`, Python
    falls back on its default version for objects, which is pretty uselessly underwhelming.
    I’ll create an instance of `GlobalCoordinates` and print this default representation
    via `repr()`:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Listing 7-31: *global_coordinates_usage.py:1*'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that prints out the following canonical string representation:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Not good for much, is it? Instead, I’ll define my own `__repr__()` instance
    method for the class:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Listing 7-32: *global_coordinates.py:2*'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: 'I return a string containing all the information needed to recreate the instance:
    the class name, the latitude, and the longitude.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerunning the code in [Listing 7-31](#listing7-31) now produces more useful
    information:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Human-Readable String Representation: __str__()'
  id: totrans-881
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__str__()` special method has a similar purpose to `__repr__()`, except
    that it’s meant to be human-readable, as opposed to the more technically inclined
    canonical representation, which is more useful for debugging.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t define `__str__()`, the `__repr__()` function will be used instead,
    but that wouldn’t be desirable in this example. The user should only see the pretty
    coordinates!
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my `__str__()` instance method for `GlobalCoordinates`:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Listing 7-33: *global_coordinates.py:3*'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with `__repr__()`, I omit all that boring technical information and focus
    on composing and returning a string representation a user might want to see.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is called when an instance of the class is passed to `str()`, although
    passing the instance directly to `print()` or as an expression in a formatted
    string will also invoke `__str__()`. For example:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Listing 7-34: *global_coordinates_usage.py:2*'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Lovely and readable!
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: 'Unique Identifier (Hash): __hash__()'
  id: totrans-894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__hash__()` method typically returns a *hash value*, which is an integer
    that is unique to the data within the class instance. This allows you to use instances
    of the class in certain collections, such as keys in a dictionary or values in
    a set (see Chapter 9). It’s often helpful to write this method yourself, as the
    default behavior results in every class instance having a unique hash value, even
    if two instances contain the exact same data.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: The `__hash__()` method should only depend on values that won’t change for the
    life of the instance! Several collections rely on these hash values *never changing*,
    but the value of a mutable object might change.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my `__hash__()` function for `GlobalCoordinates`:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Listing 7-35: *global_coordinates.py:4*'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: I’ve taken the most common approach, which is to create a tuple containing all
    the important instance attributes and then to call `hash()` on the tuple, which
    returns the hash value of whatever is passed to it. I then return that hash value.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: Additional Conversion Special Methods
  id: totrans-901
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python has special methods for converting the data in the instance to other
    forms. It is up to you to decide which of these you will define on your class:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '`__bool__()` should return `True` or `False`. If this isn’t defined, the automatic
    conversion to a boolean value will check whether `__len__()` returns a nonzero
    value (see Chapter 9); otherwise, `True` will always be used.'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__bytes__()` should return a `bytes` object (see Chapter 12).'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ceil__()` should return an `int` numeric value, usually resulting from rounding
    up a `float` value to the nearest integer.'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__complex__()` should return a `complex` numeric value.'
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__float__()` should return a `float` numeric value.'
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__floor__()` should return an `int` numeric value, usually resulting from
    rounding down a `float` numeric value to the nearest integer.'
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__format__()` should accept a string representing the format specification
    (see Chapter 3) and return a string representation of the instance, with the specification
    applied. How exactly you apply the specification is up to you.'
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__index__()` should return the same value as `__int__()`, which must also
    be defined if you write this method. The presence of this method indicates that
    the class should be considered a type of integer; you don’t have to throw away
    any data to get the integer value (lossless conversion).'
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__int__()` should return an `int` numeric value. You may simply have this
    function call `__ceil__()`, `__floor__()`, `__round__()`, or `__trunc__()`.'
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__round__()` should return an `int` numeric value, usually resulting from
    rounding a `float` numeric value up or down.'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__trunc__()` should return an `int` numeric value, usually resulting from
    dropping the non-whole (decimal) part of a `float` numeric value.'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You only need to define the special methods that make sense for your class.
    In my case, *none* of these additional conversion methods are particularly suitable
    for a pair of global coordinates.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Methods
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python has six comparison special methods that correspond to the six comparison
    operators in Python: `==`, `!=`, `<`, `>`, `<=`, and `>=`. Each one conventionally
    returns a boolean value.'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: If one of these special methods is called, but the method isn’t defined, the
    class instance will return the special value `NotImplemented` to alert Python
    that the comparison didn’t happen. This allows the language to decide the best
    response. In the case of comparisons with built-in types, `NotImplemented` will
    be coerced to the boolean value `False`, so as to not break algorithms that rely
    on those functions. In most other situations, a `TypeError` will be raised.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: 'Equals: __eq__()'
  id: totrans-918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `__eq__()` special method is called by the equals (`==`) operator. I’ll
    define this method for my `GlobalCoordinates` class:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Listing 7-36: *global_coordinates.py:5*'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: 'All comparison special methods accept two parameters: `self` and `other`. These
    represent the operands on the left and right of the operator, so `a == b` would
    call `a.__eq__(b)`.'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: In the ongoing example, it would only make sense to compare two `GlobalCoordinates`
    class instances to one another. Comparing a `GlobalCoordinates` instance directly
    to an integer or a float wouldn’t be logical. Thus, this is one of those rare
    scenarios where type matters. I use `isinstance()` to ensure `other` is an instance
    of the `GlobalCoordinates` class (or a subclass thereof) ❶. If it is, I compare
    the instance attributes that constitute the latitude and longitude of one `GlobalCoordinates`
    instance to the same attributes of the other instance. I return `True` if they
    all match.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: However, if `other` is of a different type, the comparison doesn’t happen, so
    I return the special value `NotImplemented` ❶.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: 'Not Equals: __ne__()'
  id: totrans-925
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__ne__()` special method corresponds to the not-equals (`!=`) operator.
    If undefined, a call to `__ne__()` *delegates* to `__eq__()`, just returning the
    opposite value that `__eq__()` does. If this is what you’re expecting, there’s
    no need to define `__ne__()`.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: However, if there’s more complex logic to your not-equals comparison, it might
    make sense to define it.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: 'Less Than and Greater Than: __lt__() and __gt__()'
  id: totrans-928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The special methods `__lt__()` and `__gt__()` correspond to the less-than (`<`)
    and greater-than (`>`) operators, respectively. These two special methods are
    *reflections* of one another, meaning one operator in the pair can be substituted
    for the other. The expression `a < b` calls `a.__lt__(b)`, but if that returns
    ``NotImplemented, Python automatically flips the logic and calls `b.__gt__(a)`.
    Thus, if you’re only comparing instances of the same class, you can often get
    away with defining just one of the two special methods: usually, `__lt__()`. The
    same is true of `__le__()` and `__ge__()`, which correspond to less-than-or-equal-to
    (`<=`) and greater-than-or-equal-to (`>=`).``'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]  def __sub__(self, other):         if not isinstance(other, GlobalCoordinates):             return
    NotImplemented          lat_diff = self.latitude - other.latitude         lon_diff
    = self.longitude - other.longitude         return (lat_diff, lon_diff) [PRE165]  def
    __invert__(self):         return GlobalCoordinates(             latitude=self.degrees_from_decimal(-self.latitude,
    lat=True),             longitude=self.degrees_from_decimal(-self.longitude, lat=False)         )
    [PRE166]  def __call__(self, ❶ other):         EARTH_RADIUS_KM = 6371          distance_lat
    = math.radians(other.latitude - self.latitude)         distance_lon = math.radians(other.longitude
    - self.longitude)         lat = math.radians(self.latitude)         lon = math.radians(self.longitude)         a
    = (             math.sin(distance_lat / 2)             * math.sin(distance_lat
    / 2)             + math.sin(distance_lon)             * math.sin(distance_lon
    / 2)             * math.cos(lat)             * math.cos(lon)         )         c
    = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))        ❷ return c * EARTH_RADIUS_KM
    [PRE167] nostarch = GlobalCoordinates(latitude=(37, 46, 32.6, "N"),                              longitude=(122,
    24, 39.4, "W"))  psf = GlobalCoordinates(latitude=(45, 27, 7.7, "N"),                         longitude=(122,
    47, 30.2 "W"))  distance = nostarch(psf) print(distance)  # 852.6857266443297
    [PRE168] class CoffeeOrder:      def __init__(self, recipe, to_go=False):         self.recipe
    = recipe         self.to_go = to_go      def brew(self):         vessel = "in
    a paper cup" if self.to_go else "in a mug"         print("Brewing", *self.recipe.parts,
    vessel)   class CoffeeRecipe:      def __init__(self, parts):         self.parts
    = parts   special = CoffeeRecipe(["double-shot", "grande", "no-whip", "mocha"])
    order = CoffeeOrder(special, to_go=False) order.brew()  # prints "Brewing double-shot
    grande no-whip mocha in a mug" [PRE169] import functools ❶ def auto_order(to_go):     def
    decorator(cls):         @functools.wraps(cls)         def wrapper(*args, **kwargs):          ❷
    recipe = cls(*args, **kwargs)          ❸ return (CoffeeOrder(recipe, to_go), recipe)         return
    wrapper   ❹ return decorator [PRE170] @auto_order(to_go=True) class CoffeeShackRecipe(CoffeeRecipe):     pass   order,
    recipe = CoffeeShackRecipe(["tall", "decaf", "cappuccino"]) order.brew()  # prints
    "Brewing tall decaf cappuccino in a paper cup" [PRE171] class Pizza:      def
    __init__(self, topping, second_topping=None):         self.first = topping         self.second
    = second_topping  order = Pizza("pepperoni", "mushrooms")  match order:     case
    Pizza(first=''pepperoni'', second=''mushroom''):         print("ANSI standard
    pizza")     case Pizza(first=''pineapple''):         print("Is this even pizza?")
    [PRE172] # `--snip--`  match order:   # `--snip--`     case Pizza(first=''pineapple''):         print("Is
    this even pizza?")  **case Pizza(first=first, second=''cheese''):**  **print(f"Very
    cheesy pizza with {first}.")** [PRE173] # `--snip--`  match order:   # `--snip--`  `case
    Pizza(first=first, second=''cheese''):`  `print(f"Very cheesy pizza with {first}.")`  **case
    Pizza(first=first, second=second):**  **print(f"Pizza with {first} and {second}.")**
    [PRE174] class Point:     def __init__(self, x, y, z):         self.x_pos = x         self.y_pos
    = y         self.z_pos = z   point = Point(0, 100, 0)  match point:     case Point(x_pos=0,
    y_pos=0, z_pos=0):         print("You are here.")     case Point(x_pos=0, y_pos=_,
    z_pos=0):         print("Look up!") [PRE175] class Point:  **__match_args__ =
    (''x_pos'', ''y_pos'', ''z_pos'')**      def __init__(self, x, y, z):         self.x_pos
    = x         self.y_pos = y         self.z_pos = z   point = Point(0, 123, 0)  match
    point:     case Point(**0, 0, 0**):         print("You are here.")     case Point(**0,
    _, 0**):         print("Look up!") [PRE176] thing.action()  # this can mutate
    attributes in thing [PRE177] action(thing)  # should not modify thing; returns
    new value or object [PRE178]`  [PRE179] import random   def generate_puzzle(low=1,
    high=100):     print(f"I''m thinking of a number between {low} and {high}...")     return
    random.randint(low, high) [PRE180] def make_guess(target):     guess = int(input("Guess:
    "))      if guess == target:         return True      if guess < target:         print("Too
    low.")     elif guess > target:         print("Too high.")     return False [PRE181]
    def play(tries=8):     target = generate_puzzle()     while tries > 0:         if
    make_guess(target):             print("You win!")             return   tries -=
    1         print(f"{tries} tries left.")      print(f"Game over! The answer was
    {target}.") [PRE182] if __name__ == ''__main__'':     play() [PRE183] I''m thinking
    of a number between 1 and 100... Guess: 50 Too low. 7 tries left. Guess: 75 Too
    low. 6 tries left. Guess: 90 Too high. 5 tries left. Guess: 87 You win! [PRE184]
    I''m thinking of a number between 1 and 100... Guess: Fifty Traceback (most recent
    call last):   File "./number_guess.py", line 35, in <module>     play()   File
    "./number_guess.py", line 25, in play     if make_guess(target):  File "./number_guess.py",
    line 10, in make_guess     guess = int(input("Guess: ")) ValueError: invalid literal
    for int() with base 10: ''Fifty'' [PRE185] ValueError: invalid literal for int()
    with base 10: ''Fifty'' [PRE186]  File "./number_guess.py", line 10, in make_guess     guess
    = int(input("Guess: ")) [PRE187]  File "./number_guess.py", line 25, in play     if
    make_guess(target): [PRE188]  File "./number_guess.py", line 35, in <module>     play()
    [PRE189] Traceback (most recent call last): [PRE190] def make_guess(target):     **guess
    = None**     **while guess is None:**         **try:**             guess = int(input("Guess:
    "))         **except ValueError:**             **print("Enter an integer.")**      if
    guess == target:         return True      if guess < target:         print("Too
    low.")     elif guess > target:         print("Too high.")     return False [PRE191]
    def make_guess(target):     guess = None     while guess is None:         guess
    = input()         **if guess.isdigit():**             guess = int(guess)         **else:**             print("Enter
    an integer.")             guess = None      if guess == target:         return
    True      if guess < target:         print("Too low.")     elif guess > target:         print("Too
    high.")     return False [PRE192] class AverageCalculator:      def __init__(self):         self.total
    = 0         self.count = 0      def __call__(self, *values):         if values:             for
    value in values:                 self.total += float(value)                 self.count
    += 1         return self.total / self.count [PRE193] average = AverageCalculator()
    values = input("Enter scores, separated by spaces:\n    ").split() try:     print(f"Average
    is {average(*values)}") except ❶ ZeroDivisionError:     print("ERROR: No values
    provided.") except ( ❷ ValueError, ❸ UnicodeError):     print(f"ERROR: All inputs
    should be numeric.") [PRE194] try:     some_scary_function() except:     print("An
    error occurred. Moving on!") [PRE195] def greet():     name = input("What''s your
    name? ")     print(f"Hello, {name}.")   while True:     try:         greet()         break     except:         print("Error
    caught") [PRE196] What''s your name? ^CError caught What''s your name? ^CError
    caught What''s your name? ^CError caught What''s your name?  [PRE197] def greet():     name
    = input("What''s your name? ")     print(f"Hello, {name}.")   while True:     try:         greet()         break  **except
    Exception:**         print("Error caught") [PRE198] def average(number_string):     total
    = 0     skip = 0     values = 0     for n in number_string.split():         values
    += 1       ❶ try:             total += float(n)       ❷ except ValueError:             skip
    += 1 [PRE199]  ❸ if skip == values:         raise ValueError("No valid numbers
    provided.")     elif skip:         print(f"<!> Skipped {skip} invalid values.")      return
    total / values [PRE200] while True:     line = input("Enter numbers (space delimited):\n    ")     avg
    = average(line)     print(avg) [PRE201] Enter numbers (space delimited):     4
    5 6 7  5.5 [PRE202] Enter numbers (space delimited):     four five 6 7 <!> Skipped
    2 invalid values. 3.25 [PRE203] Enter numbers (space delimited):     four five
    six seven Traceback (most recent call last):   File "./raiseexception.py", line
    25, in <module>     avg = average(line)   File "./raiseexception.py", line 16,
    in average     raise ValueError("No valid numbers provided.") ValueError: No valid
    numbers provided. [PRE204] while True:     **try:**         line = input("Enter
    numbers (space delimited):\n    ")         avg = average(line)  print(avg)     **except
    ValueError:**         **print("No valid numbers provided.")** [PRE205] Enter numbers
    (space delimited):     four five six No valid numbers provided. Enter numbers
    (space delimited):     4 5 6 5.0 [PRE206] friend_emails = {     "Anne": "anne@example.com",     "Brent":
    "brent@example.com",     "Dan": "dan@example.com",     "David": "david@example.com",     "Fox":
    "fox@example.com",     "Jane": "jane@example.com",     "Kevin": "kevin@example.com",     "Robert":
    "robert@example.com" } [PRE207] def lookup_email(name):     try:         return
    friend_emails[name]  except KeyError ❶ as e:         print(f"<No entry for friend
    {e}>") [PRE208] name = input("Enter name to look up: ") email = lookup_email(name)
    print(f"Email: {email}") [PRE209] Enter name to look up: Jason <No entry for friend
    ''Jason''> Email: None [PRE210] import logging from operator import add, sub,
    mul, truediv import sys [PRE211] logging.basicConfig(filename=''log.txt'', level=logging.INFO)
    [PRE212] def calculator(a, b, op):     a = float(a)     b = float(b)     if op
    == ''+'':         return ❶ add(a, b)     elif op == ''-'':         return sub(a,
    b)     elif op == ''*'':         return mul(a, b)     elif op == ''/'':         return
    truediv(a, b)     else:       ❷ raise NotImplementedError(f"No operator {op}")
    [PRE213] print("""CALCULATOR Use postfix notation. Ctrl+C or Ctrl+D to quit. """)  ❶
    while True:   ❷ try:         equation = input(" ").split()         result = calculator(*equation)         print(result)
    [PRE214]  except NotImplementedError as e:         print("<!> Invalid operator.")         logging.info(e)
    [PRE215]  except ValueError as e:         print("<!> Expected format: <A> <B>
    <OP>")         logging.info(e) [PRE216]  except TypeError as e:         print("<!>
    Wrong number of arguments. Use: <A> <B> <OP>")         logging.info(e) [PRE217]  except
    ZeroDivisionError as e:         print("<!> Cannot divide by zero.")         logging.info(e)
    [PRE218]  except (KeyboardInterrupt, EOFError):         print("\nGoodbye.")         sys.exit(0)
    [PRE219] CALCULATOR Use postfix notation. Ctrl+C or Ctrl+D to quit.   11 31 +
    42.0  11 + 31 <!> Expected format: <A> <B> <OP>  11 + 31 + 10 <!> Wrong number
    of arguments. Use: <A> <B> <OP>  11 + <!> Wrong number of arguments. Use: <A>
    <B> <OP>  10 0 / <!> Cannot divide by zero.  10 40 @ <!> Invalid operator.  ^C
    Goodbye. [PRE220] INFO:root:could not convert string to float: ''+'' INFO:root:calculator()
    takes 3 positional arguments but 5 were given INFO:root:calculator() missing 1
    required positional argument: ''op'' INFO:root:float division by zero INFO:root:No
    operator @ [PRE221]  except Exception as e:         logging.exception(e)       ❶
    raise [PRE222] cities = {     "SEATTLE": "WASHINGTON, USA",     "PORTLAND": "OREGON,
    USA",     "BOSTON": "MASSACHUSETTS, USA", }  landmarks = {     "SPACE NEEDLE":
    "SEATTLE",     "LIBERTY SHIP MEMORIAL": "PORTLAND",     "ALAMO": "SAN ANTONIO",
    } [PRE223] def lookup_landmark(landmark):     landmark = landmark.upper()     try:         city
    = landmarks[landmark]         state = cities[city]   ❶ except KeyError as e:       ❷
    raise KeyError("Landmark not found.") from e     print(f"{landmark} is in {city},
    {state}") [PRE224] lookup_landmark("space needle") lookup_landmark("alamo") lookup_landmark("golden
    gate bridge") [PRE225] SPACE NEEDLE is in SEATTLE, WASHINGTON, USA Traceback (most
    recent call last):   File "./chaining.py", line 18, in lookup_landmark     state
    = cities[city] ❶ KeyError: ''SAN ANTONIO''  ❷ The above exception was the direct
    cause of the following exception:  Traceback (most recent call last):  File "./chaining.py",
    line 25, in <module>     lookup_landmark("alamo")   File "./chaining.py", line
    20, in lookup_landmark     raise KeyError("Landmark not found.") from e ❸ KeyError:
    ''Landmark not found.'' [PRE226] During handling of the above exception, another
    exception occurred: [PRE227] import math   def average_string(number_string):     try:         numbers
    = [float(n) for n in number_string.split()]  except ValueError:         total
    = math.nan         values = 1 [PRE228]  else:         total = sum(numbers)         values
    = len(numbers) [PRE229]  try:         average = total / values     except ZeroDivisionError:         average
    = math.inf      return average   while True:     number_string = input("Enter
    space-delimited list of numbers:\n    ")     print(average_string(number_string))
    [PRE230]  4 5 6 7 5.5      inf     four five six nan [PRE231] def average_file(path):     file
    = open(path, ''r'')      try:       ❶ numbers = [float(n) for n in file.readlines()]
    [PRE232]  except ValueError as e:         raise ValueError("File contains non-numeric
    values.") from e [PRE233]  else:         try:             return sum(numbers)
    / len(numbers)         except ZeroDivisionError as e:             raise ValueError("Empty
    file.") from e [PRE234]  finally:         print("Closing file.")         file.close()
    [PRE235] print(average_file(''numbers_good.txt'')) [PRE236] Closing file. 42.0
    [PRE237] print(average_file(''numbers_bad.txt'')) [PRE238] ❶ Closing file. Traceback
    (most recent call last):   File "tryfinally.py", line 5, in average_file     numbers
    = [float(n) for n in file.readlines()]   File "tryfinally.py", line 5, in <listcomp>     numbers
    = [float(n) for n in file.readlines()] ValueError: could not convert string to
    float: ''thirty-three\n''  The above exception was the direct cause of the following
    exception:  Traceback (most recent call last):   File "tryfinally.py", line 20,
    in <module>     print(average_file(''numbers_bad.txt''))  # ValueError   File
    "tryfinally.py", line 7, in average_file     raise ValueError("File contains non-numeric
    values.") from e ValueError: File contains non-numeric values. [PRE239] print(average_file(''numbers_empty.txt''))
    [PRE240] ❶ Closing file. Traceback (most recent call last):   File "tryfinally.py",
    line 10, in average_file     return sum(numbers) / len(numbers) ZeroDivisionError:
    division by zero  The above exception was the direct cause of the following exception:  Traceback
    (most recent call last):   File "tryfinally.py", line 21, in <module>     print(average_file(''numbers_empty.txt''))  #
    ValueError   File "tryfinally.py", line 12, in average_file     raise ValueError("Empty
    file.") from e ❷ ValueError: Empty file. [PRE241] print(average_file(''nonexistent.txt''))
    [PRE242] Traceback (most recent call last):   File "tryfinally.py", line 22, in
    <module>     print(average_file(''nonexistent.txt''))  # FileNotFoundError   File
    "tryfinally.py", line 2, in average_file     file = open(path, ''r'') FileNotFoundError:
    [Errno 2] No such file or directory: ''nonexistent.txt'' [PRE243] class ❶ SillyWalkException(
    ❷ RuntimeError):     def __init__(self, ❸ message="Someone walked silly."):         super().__init__(message)   def
    walking():   ❹ raise SillyWalkException("My walk has gotten rather silly.")   try:     walking()
    ❺ except SillyWalkException as e:     print(e) [PRE244] class SillyWalkException(RuntimeError):     """Exception
    for walking silly.""" [PRE245]`**'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
