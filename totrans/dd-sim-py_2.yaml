- en: Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分
- en: ESSENTIAL STRUCTURES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基本结构
- en: '5'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Variables and Types
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 变量与类型
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Some of the most pernicious misconceptions about Python revolve around its nuances
    regarding variables and data types. Misunderstandings related to this *one* topic
    cause countless frustrating bugs, and this is unfortunate. Python’s way of handling
    variables is at the core of its power and versatility. If you understand this,
    everything else falls into place.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python，最具误导性的误解之一围绕着它在变量和数据类型方面的细微差别。这一*单一*话题引发了无数让人沮丧的 bug，真令人遗憾。Python
    处理变量的方式是它强大和多功能的核心。如果你理解了这一点，其他的事情就会迎刃而解。
- en: My own understanding of this topic was cemented by “Facts and Myths About Python
    Names and Values,” Ned Batchelder’s now-legendary talk at PyCon 2015\. I recommend
    you watch the video of the presentation at [https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns),
    either now or after reading this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个话题的理解是在 Ned Batchelder 于 2015 年 PyCon 上做的那场传奇演讲《Python 名称和值的事实与误区》之后得到巩固的。我推荐你现在或者在阅读完本章后观看这场演讲的视频：[https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns)。
- en: 'Variables According to Python: Names and Values'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按照 Python 的定义：名称和值
- en: Many myths about Python variables stem from people’s attempts to describe the
    language in terms of *other languages*. Perhaps most annoying to Python experts
    is the misleading aphorism, “Python has no variables,” which is really just the
    product of someone being overly clever about the fact that the Python language
    uses the terms *name* and *value*, instead of *variable*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 变量的许多误解源于人们试图用*其他语言*来描述 Python。对于 Python 专家来说，最令人烦恼的可能是那个误导性格言：“Python
    没有变量”，这其实只是因为有人过于聪明地指出 Python 使用的是 *name* 和 *value*，而不是 *variable* 这个术语。
- en: Python developers still use the term *variable* on a regular basis, and it even
    appears in the documentation, as it is part of understanding the overall system.
    However, for the sake of clarity, I’ll use the official Python terms exclusively
    throughout the rest of the book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 开发者仍然会经常使用术语 *variable*，它甚至出现在文档中，因为理解这一点是理解整个系统的一部分。然而，为了清晰起见，接下来我将只使用官方的
    Python 术语。
- en: 'Python uses the term *name* to refer to what would conventionally be called
    a variable. A name refers to a value or an object, in the same way that your name
    refers to you but does not contain you. There may even be multiple names for the
    same thing, just as you may have a given name and a nickname. A *value* is a particular
    instance of data in memory. The term *variable* refers to the combination of the
    two: a name that refers to a value. From now on, I’ll only use the term *variable*
    in relation to this precise definition.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用术语 *name* 来指代传统上称为变量的东西。一个名字指向一个值或对象，就像你的名字指代你自己，但并不包含你。一个事物可能有多个名字，就像你可能有本名和昵称一样。*value*
    是内存中数据的一个特定实例。术语 *variable* 指的是二者的结合：一个指向值的名字。从现在开始，我将仅在这个确切定义下使用术语 *variable*。
- en: Assignment
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值
- en: 'Let’s look at what happens under the hood when I define a variable per the
    above definitions like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我按照上述定义来定义一个变量时，幕后发生了什么：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5-1: *simple_assignment.py:1*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-1：*simple_assignment.py:1*
- en: The name `answer` is *bound* to the value `42`, meaning the name can now be
    used to refer to the value in memory. This operation of binding is referred to
    as an *assignment*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 名字 `answer` 被*绑定*到值 `42`，这意味着这个名字现在可以用来引用内存中的值。这个绑定操作称为*赋值*。
- en: 'Look at what happens behind the scenes when I assign the variable `answer`
    to a new variable, `insight`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当我将变量 `answer` 赋值给新变量 `insight` 时幕后发生了什么：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5-2: *simple_assignment.py:2*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-2：*simple_assignment.py:2*
- en: The name `insight` doesn’t refer to a copy of the value `42`, but rather to
    the same, original value. This is illustrated in [Figure 5-1](#figure5-1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 名字 `insight` 并不是指值 `42` 的一个副本，而是指相同的原始值。如[图 5-1](#figure5-1)所示。
- en: '![](Images/f05001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f05001.png)'
- en: 'Figure 5-1: Multiple names can be bound to the same value in memory.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：多个名字可以绑定到内存中的同一个值。
- en: 'In memory, the name `insight` is bound to the value `42`, which was already
    bound to another name: `answer`. Both names are still usable as variables. More
    importantly, `insight` is not bound to `answer`, but rather to the same value
    that `answer` was already bound to when I assigned `insight`. A name always points
    to a value.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，名字 `insight` 被绑定到值 `42`，而该值已经被绑定到另一个名字：`answer`。这两个名字仍然可以作为变量使用。更重要的是，`insight`
    不是绑定到 `answer`，而是绑定到 `answer` 在我给 `insight` 赋值时已经绑定的相同值。一个名字总是指向一个值。
- en: Back in Chapter 3, I introduced the `is` operator, which compares *identity*—the
    specific location in memory that a name is bound to. This means `is` doesn’t check
    whether a name points to equivalent values, but rather whether it points to the
    *same* value in memory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章中，我介绍了 `is` 运算符，它比较的是 *身份* —— 名字绑定的具体内存位置。这意味着 `is` 并不是检查名字是否指向等价的值，而是检查它是否指向内存中的
    *相同* 值。
- en: When you make an assignment, Python makes its own decisions behind the scenes
    about whether to create a new value in memory or bind to an existing value. The
    programmer often has very little control over this decision.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行赋值时，Python 会在幕后做出是否创建一个新值或绑定到现有值的决定。程序员通常对这个决定几乎没有控制权。
- en: 'To see this, run this example in an interactive session instead of a file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这一点，可以在交互式会话中运行此示例，而不是在文件中：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 5-3: (Interactive session):1'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-3: （交互式会话）：1'
- en: I assign identical values to `spam` and `eggs`. I also bind `maps` to the same
    value as `spam`. (In case you didn’t catch it, “maps” is “spam” backward. No wonder
    GPS gets annoying.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我给 `spam` 和 `eggs` 赋相同的值。我还将 `maps` 绑定到与 `spam` 相同的值。（如果你没注意到，“maps”是“spam”倒过来拼的，难怪
    GPS 有时会让人恼火。）
- en: 'When I compare the names with the comparison operator (`==`) to check whether
    the values are equivalent, both expressions return `True`, as one would expect:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用比较运算符（`==`）来比较名字，检查值是否等价时，两个表达式都会返回 `True`，正如预期的那样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-4: (Interactive session):2'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-4: （交互式会话）：2'
- en: 'However, when I compare the identities of the names with `is`, something surprising
    happens:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我使用 `is` 比较名字的身份时，会发生一些令人惊讶的事情：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 5-5: (Interactive session):3'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-5: （交互式会话）：3'
- en: The names `spam` and `maps` are both bound to the same value in memory, but
    `eggs` is probably bound to a different but equivalent value. Thus, `spam` and
    `eggs` don’t share an identity. This is illustrated in [Figure 5-2](#figure5-2).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam` 和 `maps` 都绑定到内存中的相同值，但 `eggs` 可能绑定到不同但等价的值。因此，`spam` 和 `eggs` 并不共享身份。这在[图
    5-2](#figure5-2)中得到了说明。'
- en: '![](Images/f05002.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f05002.png)'
- en: 'Figure 5-2: `spam` and `maps` share an identity; `eggs` is bound to an equivalent
    value, but it does not share identity.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '图 5-2: `spam` 和 `maps` 共享一个身份；`eggs` 绑定到一个等价的值，但它不共享身份。'
- en: It just goes to show, spam by any other name is still spam.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这正好说明了，无论名字怎么变，spam 依然是 spam。
- en: 'Python isn’t guaranteed to behave exactly like this, and it may well decide
    to reuse an existing value. For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并不能保证总是像这样行为，它可能会决定重用现有的值。例如：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-6: (Interactive session)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-6: （交互式会话）'
- en: When I assign the value `42` to `insight`, Python decides to bind that name
    to the existing value. Now, `answer` and `insight` happen to be bound to the same
    value in memory, and thus, they share an identity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我给 `insight` 赋值 `42` 时，Python 决定将该名字绑定到现有值。现在，`answer` 和 `insight` 恰好绑定到内存中的相同值，因此，它们共享一个身份。
- en: This is why the identity operator (`is`) can be sneaky. There are many situations
    in which `is` appears to work like the comparison operator (`==`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么身份运算符（`is`）可能会很狡猾的原因。有许多情况下，`is` 看起来像是比较运算符（`==`）的作用。
- en: As a final note, the built-in function `id()` returns an integer representing
    the identity of whatever is passed to it. These integers are the values that the
    `is` operator compares. If you’re curious about how Python handles names and values,
    try playing with `id()`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后值得注意的是，内置函数 `id()` 返回一个整数，表示传递给它的对象的身份。这些整数是 `is` 运算符比较的值。如果你对 Python 如何处理名字和值感到好奇，可以试试使用
    `id()`。
- en: Data Types
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: As you’ve likely noticed, Python does not require you, the programmer, to declare
    a type for your variables. Back when I first picked up Python, I joined the `#python`
    channel on IRC and jumped right in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的那样，Python 不要求程序员为变量声明类型。当我第一次接触 Python 时，我加入了 IRC 上的 `#python` 频道，直接跳了进去。
- en: “How do you declare the data type of a variable in Python?” I asked, in all
    the naivete of a first-year coder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “你如何在 Python 中声明变量的数据类型？”我问道，带着作为一年级新手的所有天真。
- en: 'Within moments, I received a response that I consider to be my first true induction
    into the bizarre world of programming: “You’re a data type.”'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，我收到了一个我认为是我第一次真正理解编程这个奇妙世界的回应：“你是一个数据类型。”
- en: 'The room regulars went on to explain that Python is a dynamically typed language,
    meaning I didn’t have to tell the language what sort of information to put in
    a variable. Instead, Python would decide the type for me. I didn’t even have to
    use a special “variable declaration” keyword. I just had to assign like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 常客们接着解释说，Python 是一种动态类型语言，这意味着我不需要告诉语言应该把什么信息放进变量里。相反，Python 会为我决定类型。我甚至不需要使用特殊的“变量声明”关键字。我只需像这样赋值：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 5-7: *types.py:1*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-7: *types.py:1*'
- en: At that precise moment, Python became my all-time favorite language.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就在那一刻，Python 成为我永远最喜欢的语言。
- en: 'It’s important to remember that Python is still a strongly typed language.
    I touched on this concept, along with dynamic typing, in Chapter 3. Ned Batchelder
    sums up Python’s type system quite brilliantly in his aforementioned PyCon 2015
    talk about names and values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，Python 仍然是一种强类型语言。我在第3章中提到了这个概念，以及动态类型。Ned Batchelder 在他前面提到的 PyCon
    2015 演讲中，关于名称和值的讲解中非常精彩地总结了 Python 的类型系统：
- en: Names have a scope—they come and go with functions—but they have no type. Values
    have a type . . . but they have no scope.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 名称有作用域——它们随着函数的出现和消失——但它们没有类型。值有类型……但它们没有作用域。
- en: Although I haven’t touched on scope yet, this should already make sense. Names
    are bound to values, and those values exist in memory, as long as there is some
    *reference* to them. You can bind a name to literally any value you want, but
    you are limited as to what you can do with any particular value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我还没有涉及作用域，但这应该已经能理解了。名称与值绑定，且这些值存在于内存中，只要存在某个*引用*。你可以将一个名称绑定到任何你想要的值，但你对任何特定值能做的事情是有限制的。
- en: The type() Function
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: type() 函数
- en: 'If you ever need to know a value’s data type, you can use the built-in `type()`
    function. Recall that everything in Python is an object, so this function will
    really just return what class the value is an instance of:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要知道某个值的数据类型，可以使用内置的 `type()` 函数。记住，Python 中的一切都是对象，所以这个函数实际上只是返回该值是哪个类的实例：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 5-8: *types.py:2*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-8: *types.py:2*'
- en: 'Here, you can see that the value assigned to `answer` is an integer (`int`).
    On rare occasions, you may want to check the data type before you do something
    with a value. For that, you can pair the `type()` function with the `is` operator,
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到赋给 `answer` 的值是一个整数（`int`）。在某些罕见的情况下，你可能会在操作一个值之前检查它的数据类型。为此，你可以将 `type()`
    函数与 `is` 运算符配合使用，如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 5-9: *types.py:3a*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-9: *types.py:3a*'
- en: 'In many cases where this sort of introspection is necessary, it may be better
    to use `isinstance()` instead of `type()`, as it accounts for subclasses and inheritance
    (see Chapter 13). The function itself returns `True` or `False`, so I can use
    it as the condition in an `if` statement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多需要进行这种 introspection（自省）的情况下，使用 `isinstance()` 而不是 `type()` 可能会更好，因为它考虑了子类和继承（参见第13章）。这个函数本身返回
    `True` 或 `False`，因此我可以将它用作 `if` 语句中的条件：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 5-10: *types.py:3b*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 5-10: *types.py:3b*'
- en: Truth be told, there is rarely a need for either. Instead, Python developers
    prefer a more dynamic approach.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，很少需要这样做。相反，Python 开发者更喜欢一种更动态的方式。
- en: Duck Typing
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: 'Python uses what is known (unofficially) as *duck typing*. This isn’t a technical
    term at all; it comes from the old saying:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用一种被称为（非官方的）*鸭子类型*的方法。这并不是一个技术术语，它来源于一句古老的谚语：
- en: If it looks like a duck, walks like a duck, and quacks like a duck, then it
    probably *is* a duck.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果它看起来像鸭子，走路像鸭子，叫声像鸭子，那么它可能*就是*鸭子。
- en: Python doesn’t care much about what a value’s data type is, but rather it cares
    about the *functionality* of the value’s data type. For example, if an object
    supports all the math operators and functions, and if it accepts floats and integers
    as operands on the binary operators, then Python considers the object to be a
    numeric type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并不关心值的数据类型是什么，而是关注值的数据类型的*功能性*。例如，如果一个对象支持所有的数学运算符和函数，并且它接受浮动数和整数作为二元运算符的操作数，那么
    Python 就会将该对象视为数值类型。
- en: In other words, Python doesn’t care if it’s actually a robotic duck or a moose
    in a duck costume. If it has the traits needed, the rest of the details are usually
    moot.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Python 并不关心它到底是一个机器人鸭子，还是穿着鸭子服装的驼鹿。如果它具备所需的特征，其他的细节通常无关紧要。
- en: If you’re familiar with object-oriented programming, particularly how quickly
    inheritance can get out of hand, then this whole concept of duck typing will probably
    be a breath of fresh air. If your class behaves as it should, it usually won’t
    matter what it inherits from.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉面向对象编程，特别是继承如何迅速失控，那么鸭子类型的这个概念可能会给你带来一股清新的空气。如果你的类表现得当，通常继承自什么类并不重要。
- en: Scope and Garbage Collection
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域和垃圾回收
- en: '*Scope* is what defines where a variable can be accessed from. It might be
    available to an entire module or limited to the suite (body) of a function.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*作用域*定义了变量可以从哪里被访问。它可能对整个模块可用，或者仅限于某个函数的代码块（主体）。'
- en: As I mentioned already, names have *scope*, whereas values do not. A name can
    be *global*, meaning it is defined by itself in a module, or it can be *local*,
    meaning it only exists within a particular function or comprehension.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，名称有*作用域*，而值没有。一个名称可以是*全局*的，意味着它在模块中独立定义，或者它可以是*局部*的，意味着它只在特定的函数或推导式中存在。
- en: Local Scope and the Reference-Counting Garbage Collector
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地作用域和引用计数垃圾回收器
- en: Functions (including lambdas) and comprehensions define their own scope; they
    are the only structures in the language to do so. Modules and classes don’t have
    their own scope in the strictest sense; they only have their own namespace. When
    a scope reaches its end, all the names defined within it are automatically deleted.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数（包括 lambda 表达式）和推导式定义了它们自己的作用域；它们是语言中唯一可以这样做的结构。模块和类严格意义上并没有自己的作用域；它们只有自己的命名空间。当一个作用域结束时，所有在其中定义的名称都会被自动删除。
- en: For any particular value, Python keeps a *reference count*, which is simply
    a count of how many references exist for that value. Every time a value is bound
    to a name, a reference is created (although there are other ways the language
    may create references). When there are no more references, the value is deleted.
    This is the *reference-counting garbage collector*, and it efficiently handles
    most garbage collection scenarios.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何特定的值，Python 会保持一个*引用计数*，即该值有多少个引用。每次一个值被绑定到一个名称时，就会创建一个引用（尽管语言可能通过其他方式创建引用）。当没有更多的引用时，该值会被删除。这就是*引用计数垃圾回收器*，它高效地处理大多数垃圾回收场景。
- en: 'You can see how this works with a typical function, like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个典型的函数来查看它是如何工作的，像这样：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 5-11: *local_scope.py:1*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-11: *local_scope.py:1*'
- en: I create a `spam()` function, inside of which I define the names `message`,
    `word`, and `separator`. I can access any of these names inside the function;
    that is their local scope. It doesn’t matter that `separator` is defined within
    a `for` loop, as loops don’t have their own scope. I can still access it outside
    of the loop.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个 `spam()` 函数，在其中定义了 `message`、`word` 和 `separator` 这些名称。我可以在函数内部访问这些名称；那是它们的局部作用域。即使
    `separator` 在 `for` 循环中定义，也没有关系，因为循环没有自己的作用域。我依然可以在循环外访问它。
- en: 'However, I cannot access any of these names outside of the function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我不能在函数外部访问这些名称：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 5-12: *local_scope.py:2*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-12: *local_scope.py:2*'
- en: Trying to access `message` outside the context of the `spam()` function where
    it was defined will raise a `NameError`. In this example, `message` doesn’t exist
    in the outer scope. What’s more, as soon as the function `spam()` exits, the names
    `message`, `word`, and `separator` are deleted. Because `word` and `separator`
    each referred to values with a reference count of one (meaning only one name was
    bound to each), the values are also deleted.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 `spam()` 函数外部访问定义了 `message` 的上下文时，会引发 `NameError`。在这个例子中，`message` 在外部作用域中不存在。而且，一旦
    `spam()` 函数退出，`message`、`word` 和 `separator` 这几个名称都会被删除。因为 `word` 和 `separator`
    各自引用了引用计数为1的值（意味着每个值只有一个名称绑定），所以这些值也会被删除。
- en: 'The value of `message` is not deleted when the function exits, however, because
    of the return statement at the end of the function (see [Listing 5-11](#listing5-11))
    and what I do with that value here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`message` 的值在函数退出时不会被删除，然而，由于函数末尾的返回语句（参见 [列表 5-11](#listing5-11)）以及我在这里对该值所做的处理：'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 5-13: *local_scope.py:3*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-13: *local_scope.py:3*'
- en: I bind the value returned by `spam()` to `output` in the outer scope, meaning
    that value still exists in memory and can be accessed outside of the function.
    Assigning the value to `output` increases the reference count for that value,
    so even though the name `message` is deleted when `spam()` exits, the value is
    not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`spam()`返回的值绑定到外部作用域中的`output`，这意味着该值仍然存在于内存中，并且可以在函数外部访问。将该值赋给`output`增加了该值的引用计数，因此即使`spam()`退出时`message`这个名字被删除，值本身并没有消失。
- en: Interpreter Shutdown
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释器关闭
- en: When the Python interpreter is asked to shut down, such as when a Python program
    terminates, it enters *interpreter shutdown*. During this phase, the interpreter
    goes through the process of releasing all allocated resources, calling the garbage
    collector multiple times, and triggering destructors in objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python解释器被要求关闭时，比如在Python程序终止时，它进入*解释器关闭*阶段。在此期间，解释器会释放所有分配的资源，多次调用垃圾回收器，并触发对象的析构函数。
- en: 'You can use the `atexit` module from the standard library to add functions
    to this interpreter shutdown process. This may be necessary in some highly technical
    projects, although in general, you shouldn’t need to do this. Functions added
    via `atexit.register()` will be called in a last-in, first-out manner. However,
    be aware that it becomes difficult to work with modules, including the standard
    library, during interpreter shutdown. It’s like trying to work in a building as
    it’s being demolished: the janitor’s closet may disappear at any time, without
    warning.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准库中的`atexit`模块将函数添加到解释器的关闭过程中。在一些高度技术化的项目中，这可能是必需的，尽管一般来说你不需要这么做。通过`atexit.register()`添加的函数会以后进先出（LIFO）的顺序调用。然而，要注意，在解释器关闭期间，与模块（包括标准库）进行交互会变得非常困难。这就像在一栋大楼正在拆除时试图工作：清洁工的储物间可能随时消失，毫无预警。
- en: Global Scope
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域
- en: When a name is defined within a module but outside of any function, class, or
    comprehension, it is considered to be in *global* *scope*. Although it’s okay
    to have some global scope names, having too many usually leads to the creation
    of code that is difficult to debug and maintain. Therefore, you should use global
    scope names sparingly for variables. There is often a cleaner solution, such as
    a class (see Chapter 7).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个名称在模块中定义，但不在任何函数、类或推导式内时，它被视为处于*全局* *作用域*。虽然拥有一些全局作用域的名称是可以的，但如果太多全局名称，通常会导致创建出难以调试和维护的代码。因此，你应该谨慎使用全局作用域的名称来定义变量。通常会有更简洁的解决方案，例如使用类（见第7章）。
- en: 'Properly using global scope names in the context of a more local scope, such
    as a function, requires you to think ahead a little. Consider what I do if I want
    a function that can modify a global variable storing a high score. First, I define
    the global variable:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在更局部的作用域中（如函数）正确使用全局作用域的名称需要提前考虑一些问题。假设我需要一个函数来修改存储高分的全局变量，首先，我定义这个全局变量：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-14: *global**_scope.py:1*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-14: *global**_scope.py:1*'
- en: 'I’ll write this function the wrong way first:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我将先错误地编写这个函数：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 5-15: *global**_scope.py:2*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-15: *global**_scope.py:2*'
- en: When I run this code, Python complains that I’m using a local variable before
    I’ve assigned a value to it ❶. The problem is, I’m assigning to the name `high_score`
    within the scope of the function `score()` ❷, and that *shadows*, or hides, the
    global `high_score` name behind the new, local `high_score` name. The fact that
    I’ve created a local `high_score` name *anywhere in the function* makes it impossible
    for the function to ever “see” the global `high_score` name.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这段代码时，Python会抱怨我在给局部变量赋值之前就使用了它❶。问题在于，我在`score()`函数的作用域内给`high_score`赋值❷，这会*隐藏*或覆盖全局的`high_score`名称，变成一个新的局部`high_score`名称。我在函数中的*任何地方*创建了一个局部的`high_score`名称，这使得函数无法“看到”全局的`high_score`名称。
- en: 'To make this work, I need to declare that I’m going to use the global name
    in the local scope, instead of defining a new local name. I can do this with the
    `global` keyword:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个工作，我需要声明我将要在局部作用域中使用全局名称，而不是定义一个新的局部名称。我可以使用`global`关键字来做到这一点：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 5-16: *global**_scope.py:3*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-16: *global**_scope.py:3*'
- en: Before I do anything else in my function, I must specify that I’m using the
    global `high_score` name. This means that anywhere I assign a value to the name
    `high_score` in `score()`, the function will use the global name, instead of trying
    to create a new local name. The code now works as expected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我做任何其他操作之前，我必须指定使用全局的 `high_score` 名称。这意味着在 `score()` 中的任何地方给 `high_score`
    赋值时，函数都会使用全局名称，而不是尝试创建一个新的局部名称。代码现在按预期工作。
- en: 'Every time you wish to rebind a global name from within a local scope, you
    must use the `global` keyword first. If you’re only accessing the current value
    bound to a global name, you don’t need to use the `global` keyword. It is vital
    for you to cultivate this habit, because Python won’t always raise an error if
    you handle scope incorrectly. Consider this example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你想要在局部作用域中重新绑定全局名称时，必须首先使用 `global` 关键字。如果你只是访问当前绑定到全局名称的值，则无需使用 `global`
    关键字。培养这个习惯非常重要，因为如果你处理作用域不当，Python 不一定会抛出错误。考虑以下示例：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 5-17: *global**_scope_gotcha.py:1a*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-17: *global**_scope_gotcha.py:1a*'
- en: This code runs without raising any errors, but the output is wrong. A new name,
    `current_score`, is being created in the local scope of the function `score()`,
    and it is bound to the value `465`. This shadows the global name `current_score`.
    When the function terminates, both the `new_score` and the local `current_score`
    are deleted. In all of this, the global `current_score` has remained untouched.
    It is still bound to `0`, and that is what is printed out.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有抛出任何错误，但输出是错误的。一个新名称 `current_score` 被创建在函数 `score()` 的局部作用域中，并绑定到值 `465`。这使得全局名称
    `current_score` 被遮蔽。当函数终止时，`new_score` 和局部的 `current_score` 都会被删除。在这一过程中，全局的 `current_score`
    保持不变。它仍然绑定到 `0`，并且这是被打印出来的值。
- en: 'Once again, to resolve this problem, I need only use the `global` keyword:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，为了解决这个问题，我只需要使用 `global` 关键字：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 5-18: *global**_scope_gotcha.py:1b*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-18: *global**_scope_gotcha.py:1b*'
- en: Because I specified that the global `current_name` is to be used in this function,
    the code now behaves precisely as expected, printing out the value `465`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我指定在这个函数中使用全局的 `current_name`，所以代码现在完全按预期运行，打印出值 `465`。
- en: The Dangers of Global Scope
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域的危险
- en: There is one more major gotcha to account for with global scope. Modifying any
    variable at a global level, as in rebinding or mutating on a name outside the
    context of a function, can lead to confusing behavior and surprising bugs—especially
    once you start dealing with multiple modules. It’s acceptable for you to initially
    “declare” a name at a global scope, but you should do all further rebinding and
    mutation of that global name at the local scope level.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局作用域中还有一个主要的陷阱。修改任何全局级别的变量，例如在函数外重新绑定或更改一个名称，可能会导致令人困惑的行为和意外的 bug——尤其是当你开始处理多个模块时。你可以在全局作用域中初步“声明”一个名称，但应该在局部作用域中进行所有进一步的重新绑定和修改。
- en: By the way, this does *not* apply to classes, which do not actually define their
    own scope. I’ll return to this later in this chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这*不*适用于类，因为类实际上并没有定义自己的作用域。稍后在本章中我会再次讨论这一点。
- en: The nonlocal Keyword
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: nonlocal 关键字
- en: 'Python allows you to write functions within functions. I’ll defer discussing
    the practicality of this until Chapter 6. Here, I mainly want to explore this
    functionality’s impact on scope. Consider the following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许你在函数内部编写函数。关于这一点的实际用途我会推迟到第六章讨论。在这里，我主要想探讨这种功能对作用域的影响。考虑以下示例：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 5-19: *nonlocal**.py*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-19: *nonlocal**.py*'
- en: 'The function `order()` contains another function: `cook()`. Each function has
    its own scope.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `order()` 包含另一个函数：`cook()`。每个函数都有自己的作用域。
- en: Remember, as long as a function only accesses a global name like `spam`, you
    don’t need to do anything special. However, trying to *assign* to a global name
    will actually define a new local name that shadows the global one. The same behavior
    is true of the inner function using names defined in the outer function, which
    is known as the *nested scope* or *enclosing scope*. To get around this, I specify
    that `eggs` is `nonlocal`, meaning it can be found in the enclosing scope, rather
    than in the local scope ❶. The inner function `cook()` has no trouble accessing
    the global name `spam`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只要函数只是访问像 `spam` 这样的全局名称，你不需要做任何特殊处理。然而，尝试对全局名称进行 *赋值* 实际上会定义一个新的局部名称，从而遮蔽全局名称。内嵌函数使用外部函数定义的名称时，也会发生相同的行为，这就是所谓的
    *嵌套作用域* 或 *封闭作用域*。为了解决这个问题，我指定 `eggs` 是 `nonlocal`，意味着它可以在封闭作用域中找到，而不是在局部作用域中
    ❶。内嵌函数 `cook()` 可以毫不费力地访问全局名称 `spam`。
- en: The `nonlocal` keyword starts looking for the indicated name in the innermost
    nested scope, and if it doesn’t find it, it moves to the next enclosing scope
    above that. It repeats this until it either finds the name or determines that
    the name does not exist in a nonglobal enclosing scope.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`nonlocal` 关键字开始从最内层的嵌套作用域中查找指定的名称，如果找不到，它会移动到上一级封闭作用域。这个过程会一直重复，直到找到名称或确定该名称在非全局封闭作用域中不存在。'
- en: Scope Resolution
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域解析
- en: 'Python’s rule about which scopes it searches for a name, and in what order,
    is called the *scope resolution order*. The easiest way to remember the scope
    resolution order is with the acronym *LEGB—*for which my colleague Ryan gave me
    the handy mnemonic “Lincoln Eats Grant’s Breakfast”:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在查找名称的作用域及其顺序时遵循的规则被称为 *作用域解析顺序*。记住作用域解析顺序最简单的方法是使用首字母缩略词 *LEGB*，我的同事
    Ryan 给了我一个方便的记忆法：“Lincoln Eats Grant’s Breakfast”：
- en: Local
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部
- en: Enclosing-function locals (that is, anything found via `nonlocal`)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封闭函数局部变量（即，通过 `nonlocal` 查找到的任何东西）
- en: Global
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局
- en: Built-in
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内建
- en: Python will look in these scopes, in order, until it finds a match or reaches
    the end. The `nonlocal` and `global` keywords adjust the behavior of this scope
    resolution order.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会按照这些作用域的顺序查找，直到找到匹配项或到达结尾。`nonlocal` 和 `global` 关键字调整作用域解析顺序的行为。
- en: The Curious Case of the Class
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类的奇异案例
- en: Classes have their own way of dealing with scope. Technically speaking, classes
    don’t directly factor into the scope resolution order. Every name declared directly
    within a class is known as an *attribute*, and it is accessed through the dot
    (`.`) operator on the class (or object) name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类有自己处理作用域的方式。从技术上讲，类并不会直接影响作用域解析顺序。每个在类内部直接声明的名称被称为 *属性*，并且可以通过类（或对象）名称上的点（`.`）操作符访问。
- en: 'To demonstrate this, I’ll define a class with a single attribute:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将定义一个包含单个属性的类：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 5-20: *class_attributes**.py*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-20：*class_attributes**.py*
- en: 'Those three print statements all output the same thing. Running that code gives
    me this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那三个打印语句输出相同的内容。运行该代码后，输出如下：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The name `output` is a *class attribute* ❶, belonging to the `Nutrimatic` class.
    Even within that class, I would not be able to refer to it merely as `output`.
    I must access it through `self.output` ❷, as `self` refers to the class instance
    the function (instance method) `request()` is being called on. I can also access
    it via `machine.output` ❸ or `Nutrimatic.output` ❹ anywhere the object `machine`
    or the class `Nutrimatic` is, respectively, in scope. All of those names point
    to the exact same attribute: `output`. Especially in this case, there’s no real
    difference between them.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`output` 这个名称是一个 *类属性* ❶，属于 `Nutrimatic` 类。即便是在该类内部，我也不能仅仅通过 `output` 来引用它。我必须通过
    `self.output` ❷ 来访问它，因为 `self` 表示调用函数（实例方法）`request()` 的类实例。我还可以通过 `machine.output`
    ❸ 或 `Nutrimatic.output` ❹ 来访问它，只要对象 `machine` 或类 `Nutrimatic` 在作用域内。所有这些名称都指向同一个属性：`output`。特别是在这个例子中，它们之间没有实际的区别。'
- en: Generational Garbage Collector
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代际垃圾回收器
- en: Behind the scenes, Python also has a more robust *generational garbage collector*
    that handles all of the odd situations a reference-counting garbage collector
    cannot, such as reference cycles (when two values reference one another). All
    of these situations, and the ways they’re handled by the garbage collector, are
    far beyond the scope of this book.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Python 还有一个更强大的 *代际垃圾回收器*，它处理引用计数垃圾回收器无法解决的所有奇异情况，比如引用循环（当两个值相互引用时）。所有这些情况及其垃圾回收器的处理方式远远超出了本书的范围。
- en: Moving forward, the most important takeaway to remember is that the generational
    garbage collector incurs some performance costs. Thus, it’s sometimes worthwhile
    to avoid reference cycles. One way to do this is with `weakref`, which creates
    a reference to a value without increasing that value’s reference count. This feature
    was defined in PEP 205, and the documentation exists at [https://docs.python.org/library/weakref.html](https://docs.python.org/library/weakref.html).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，最重要的收获是要记住，代际垃圾收集器会带来一定的性能成本。因此，有时避免引用循环是值得的。做到这一点的一种方式是使用`weakref`，它创建对一个值的引用，而不会增加该值的引用计数。这个特性在PEP
    205中定义，相关文档可以在[https://docs.python.org/library/weakref.html](https://docs.python.org/library/weakref.html)找到。
- en: The Immutable Truth
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变的真相
- en: Values in Python can be either *immutable* or *mutable*. The difference hinges
    on whether the values can be *modified in place*, meaning they can be changed
    right where they are in memory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的值可以是*不可变*的，也可以是*可变*的。两者的区别在于，值是否可以*就地修改*，也就是说，它们是否可以在内存中直接修改。
- en: '*Immutable* types cannot be modified in place. For example, integers (`int`),
    floating-point numbers (`float`), strings (`str`), and tuples (`tuple`) are all
    immutable. If you attempt to mutate an immutable value, you’ll wind up with a
    completely different value being created:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可变*类型不能就地修改。例如，整数（`int`）、浮点数（`float`）、字符串（`str`）和元组（`tuple`）都是不可变的。如果你尝试改变一个不可变的值，你将得到一个完全不同的值：'
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 5-21: *immutable_types.py*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-21: *immutable_types.py*'
- en: Initially, `eggs` and `carton` are both bound to the same value, and thus, they
    share an identity. When I modify `eggs`, it is rebound to a new value, so it no
    longer shares an identity with `carton`. You can see that the two names now point
    to different values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`eggs`和`carton`都绑定到相同的值，因此它们共享一个身份。当我修改`eggs`时，它被重新绑定到一个新值，因此不再与`carton`共享身份。你可以看到这两个名称现在指向不同的值。
- en: '*Mutable* types, on the other hand, can be modified in place. Lists constitute
    one example of a mutable type:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*可变*类型则可以就地修改。列表就是一种可变类型的例子：'
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 5-22: *mutable_types.py*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-22: *mutable_types.py*'
- en: Because the list is aliased to both `temps` and `highs`, any modifications made
    to the list value ❶ are visible through either name. Both names are bound to the
    original value, as demonstrated by the `is` comparisons. This remains the case,
    even after that value is mutated.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表同时被别名为`temps`和`highs`，对列表值❶所做的任何修改都可以通过任意一个名称查看。两个名称都绑定到原始值，如`is`比较所示。即使该值发生变化，这种情况也保持不变。
- en: Passing by Assignment
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过赋值传递
- en: Another frequent question from programmers new to the language is, “Does Python
    pass by value or by reference?”
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见问题是，对于刚接触该语言的程序员，常问：“Python是按值传递还是按引用传递？”
- en: The answer is, “Effectively, neither.” More accurately, as Ned Batchelder describes
    it, Python *passes by assignment*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，“实际上，二者都不是。”更准确地说，正如Ned Batchelder所描述的那样，Python是*通过赋值传递*。
- en: 'Neither the values nor the names bound to them are moved. Instead, each value
    is bound to the parameter via assignment. Consider a simple function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 既不是值，也不是绑定到它们的名称会被移动。相反，每个值通过赋值绑定到参数。考虑一个简单的函数：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, there is one copy of the string value `"Jason"` in memory, and that is
    bound to the name `my_name`. When I pass `my_name` to the `greet()` function—specifically,
    to the `person` parameter—it’s the same as if I had said (`person = my_name`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内存中只有一个字符串值`"Jason"`，它绑定到名称`my_name`。当我将`my_name`传递给`greet()`函数——特别是传递给`person`参数——就像我说了（`person
    = my_name`）一样。
- en: Again, assignment never makes a copy of a value. The name `person` is now bound
    to the value `"Jason"`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，赋值永远不会复制一个值。名称`person`现在绑定到值`"Jason"`。
- en: 'This concept of passing by assignment gets tricky when you start working with
    mutable values, such as lists. To demonstrate this often-unexpected behavior,
    I’ve written a function that finds the lowest temperature in a list passed to
    it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始处理可变值（如列表）时，按赋值传递的概念会变得复杂。为了演示这种常常出乎意料的行为，我写了一个函数，用来查找传入的列表中的最低温度：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 5-23: *lowest_temp.py:1a*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-23: *lowest_temp.py:1a*'
- en: 'At first glance, you may assume that passing a list to the `temperatures` parameter
    will make a copy, so it shouldn’t matter if you modify the value bound to the
    parameter. However, lists are mutable, meaning *the value itself* can be modified:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，你可能会认为将列表传递给`temperatures`参数会创建一个副本，所以修改绑定到参数的值应该不重要。然而，列表是可变的，这意味着*值本身*可以被修改：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 5-24: *lowest_temp.py:2*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-24: *lowest_temp.py:2*'
- en: When I passed `temps` to the function’s `temperatures` parameter, I only *aliased*
    the list, so any changes made on `temperatures` are visible from all the other
    names bound to that same list value—namely, from `temps`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将`temps`传递给函数的`temperatures`参数时，我只是*创建了*列表的别名，因此在`temperatures`上进行的任何更改都能在绑定到同一列表值的其他所有名称中看到——即，`temps`中也会看到这些更改。
- en: 'You can see this in action when I run this code and get the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下代码并获得如下输出，看到这一点的实际表现：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When `find_lowest()` sorted the list passed to `temperatures`, it actually sorted
    the one mutable list that both `temps` and `temperatures` aliased. This is a clear
    case of a function having *side effects*, which are changes to values that existed
    before the function call.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当`find_lowest()`对传递给`temperatures`的列表进行排序时，它实际上是对`temps`和`temperatures`都引用的那个可变列表进行了排序。这是一个典型的函数具有*副作用*的例子，即在函数调用之前已存在的值发生了变化。
- en: 'An awe-inspiring number of bugs originate from this one type of misunderstanding.
    In general, functions should not have side effects, meaning that any values passed
    to the function as arguments should *not* be directly mutated. To avoid mutating
    the original value, I have to explicitly make a copy of it. Here’s how I’d do
    that in the `find_lowest()` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种误解导致了大量令人震惊的错误。通常情况下，函数不应有副作用，这意味着传递给函数的任何值作为参数都*不应*被直接修改。为了避免修改原始值，我必须明确地创建它的副本。以下是我在`find_lowest()`函数中这样做的方法：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 5-25: *lowest_temp.py:1b*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-25：*lowest_temp.py:1b*
- en: The `sorted()` function has no side effects; it creates a new list using the
    items in the list passed to it ❶. It then sorts this new list and returns it.
    I bind this new list to `sorted_temps`. Thus, the original list (bound to `temps`
    and `temperatures`) is untouched.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`函数没有副作用；它使用传递给它的列表中的项创建一个新列表❶。然后它对这个新列表进行排序并返回它。我将这个新列表绑定到`sorted_temps`。因此，原始列表（绑定到`temps`和`temperatures`）保持不变。'
- en: If you’re coming from C and C++, it may be helpful to remember the potential
    hang-ups related to pass-by-pointer or pass-by-reference. Although Python’s assignment
    is scarcely similar from a technical standpoint, the risks of side effects and
    unintended mutations are the same.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自C或C++，记住与通过指针或通过引用传递相关的潜在问题可能会有所帮助。尽管从技术角度来看，Python的赋值方式与这些语言的方式几乎没有相似之处，但副作用和意外变异的风险是相同的。
- en: Collections and References
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合与引用
- en: 'All collections, including lists, employ a clever little semantic detail that
    can become a royal pain if you don’t know to expect it: ***Individual items are
    references.*** Just as a name is bound to a value, so also are items in collections
    bound to values, in the same manner. This binding is called a *reference*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合，包括列表，都使用了一个巧妙的小语义细节，如果你不知道这个细节，它可能会变得非常麻烦：***单个项是引用。*** 就像一个名称绑定到一个值一样，集合中的项也是以相同的方式绑定到值。这种绑定被称为*引用*。
- en: A simple example involves trying to create a tic-tac-toe board. This first version
    won’t work quite how you’d expect.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是尝试创建一个井字棋棋盘。这个版本的实现不会完全按照你预期的那样工作。
- en: 'I’ll start by creating the game board:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从创建游戏棋盘开始：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 5-26: *tic_tac_toe**.py:1a*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-26：*tic_tac_toe.py:1a*
- en: I’m trying to create a two-dimensional board. You can fill a collection, like
    a list, with several items, all with the same repeating value, using the multiplication
    operator ❶, as I’ve done here. I enclose the repeating value in square brackets
    and multiply it by the number of repetitions I want. A single row of my board
    is defined with `["-"] * 3`, which makes a list of three `"-"` strings.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在尝试创建一个二维棋盘。你可以用乘法运算符❶填充一个集合，比如列表，填入多个具有相同重复值的项，就像我在这里所做的那样。我将重复值括在方括号中，并将其乘以我想要的重复次数。我的棋盘的单行定义为`["-"]
    * 3`，这会生成一个包含三个`"-"`字符串的列表。
- en: 'Unfortunately, this won’t work the way you’d expect. The problem begins when
    I attempt to define the second dimension of the array—three copies of the `[["-"]
    * 3]` list—using multiplication. You can see the problem manifest when I try to
    make a move:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不会像你预期的那样工作。问题出现在我试图使用乘法定义数组的第二维——三个`[["-"] * 3]`列表的副本时。当我尝试进行一次棋步时，你可以看到问题的表现：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 5-27: *tic_tac_toe**.py:2*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-27：*tic_tac_toe.py:2*
- en: 'When I mark a move on the board ❷, I want to see that change in only one spot
    on the board, like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在棋盘上标记一个棋步❷时，我只希望看到棋盘上某一位置的变化，像这样：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Instead, I get this nasty surprise:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我得到了这个令人讨厌的惊讶：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Cue the weeping and gnashing of teeth. Somehow, that one change has propagated
    to *all three* *rows*. Why?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 听到哀嚎与咬牙切齿的声音。怎么回事呢？这个改变居然传播到了*所有三行*。为什么？
- en: Initially, I created a list with three `"-"` values as items ❶. Since strings
    are immutable and thus cannot be modified in place, this works as expected. Rebinding
    the first item in the list to `"X"` does not affect the other two items.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我创建了一个包含三个`"-"`值的列表作为项❶。由于字符串是不可变的，因此不能原地修改，这样的操作按预期工作。将列表中的第一个项重新绑定为`"X"`并不会影响其他两个项。
- en: The outer dimension of the list is composed of three list items. Because I defined
    *one* list and used it *three* times, I now have three *aliases* for one mutable
    value! By changing that list through one reference (the second row), I’m mutating
    that one shared value ❷, so all three references see the change.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的外维度由三个列表项组成。因为我定义了*一个*列表并使用了*三次*，所以现在我有三个*别名*指向一个可变值！通过一个引用（第二行）修改该列表时，我实际上是在修改这个共享的值❷，因此所有三个引用都会看到这一变化。
- en: 'There are a few ways to fix this, but all of them work by ensuring each row
    references a separate value, like so:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题，但所有方法的核心都是确保每一行引用一个单独的值，例如：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 5-28: *tic_tac_toe**.py:1b*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-28: *tic_tac_toe**.py:1b*'
- en: 'I only needed to change how I defined the game board initially. I now use a
    *list comprehension* to create the rows. In short, this list comprehension will
    define a separate list value from `["-"] * 3` three different times. (List comprehensions
    get complicated; they’ll be explained in depth in Chapter 10.) Running the code
    now results in the expected behavior:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我只需要改变最初定义游戏棋盘的方式。现在，我使用*列表推导式*来创建行。简而言之，这个列表推导式会将`["-"] * 3`的值分别定义三次。 （列表推导式比较复杂；它将在第10章中详细讲解。）现在运行代码会得到预期的行为：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Long story short, whenever you’re working with a collection, remember that
    an item is no different from any other name. Here is one more example to drive
    this point home:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，每当你在处理一个集合时，请记住，集合中的一个项与任何其他名称没有区别。这里有一个例子可以更好地说明这一点：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 5-29: *team_scores**.py:1*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-29: *team_scores**.py:1*'
- en: 'I create three lists, assigning each to a name. Then, I pack all three into
    the tuple `scores`. You may remember from earlier that tuples cannot be modified
    directly, because they’re immutable. That same rule does not necessarily apply
    to a tuple’s items. You can’t change the tuple itself, but you can (indirectly)
    modify the values its items refer to:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了三个列表，并将每个列表分配给一个名称。然后，我将这三者打包成元组`scores`。你可能还记得，元组本身是不可修改的，因为它们是不可变的。但这个规则并不一定适用于元组的项。你不能修改元组本身，但你可以（间接地）修改它的项所引用的值：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 5-30: *team_scores**.py:2*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-30: *team_scores**.py:2*'
- en: When I mutate the list `scores_team_1`, that change appears in the first item
    of the tuple, because that item only aliased a mutable value.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我修改列表`scores_team_1`时，这一变化会出现在元组中的第一个项，因为该项仅仅是引用了一个可变值。
- en: 'I could also directly mutate a mutable list in the `scores` tuple through two-dimensional
    subscription, like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以通过二维索引直接修改`scores`元组中的可变列表，像这样：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 5-31: *team_scores**.py:3*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-31: *team_scores**.py:3*'
- en: Tuples don’t give you any sort of security about things being modified. Immutability
    exists mainly for efficiency, not for protecting data. Mutable values are *always*
    going to be mutable, no matter where they live or how they’re referred to.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 元组并不会为数据修改提供任何安全性。不可变性主要是为了提高效率，而不是为了保护数据。可变值*始终*是可变的，无论它们存储在哪里或如何引用。
- en: The problems in the two examples above may seem relatively easy to spot, but
    things start getting troublesome when the related code is spread out across a
    large file or multiple files. Mutating on a name in one module may unexpectedly
    modify an item of a collection in a completely different module, and you might
    never have expected it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上面两个例子中的问题看起来可能相对容易发现，但当相关代码分布在一个大文件或多个文件中时，问题就开始变得棘手了。在一个模块中对名称的修改可能会意外地修改完全不同模块中的集合项，而你可能从未预料到这种情况。
- en: Shallow Copy
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浅拷贝
- en: There are many ways to ensure you are binding a name to a *copy* of a mutable
    value, instead of aliasing the original; the most explicit of these ways is with
    the `copy()` function. This is sometimes also known as a *shallow copy*, in contrast
    to the *deep copy* I’ll cover later.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以确保你将名称绑定到一个*拷贝*的可变值，而不是引用原始值；其中最显式的方式是使用`copy()`函数。这也有时被称为*浅拷贝*，与我稍后会介绍的*深拷贝*相对。
- en: 'To demonstrate this, I’ll create a `Taco` class (see Chapter 7 for more on
    classes) that allows you to define the class with various toppings and then add
    a sauce afterward. This first version has a bug:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将创建一个`Taco`类（有关类的更多信息，请参见第7章），该类允许你定义带有各种配料的塔可，并在之后添加酱料。这个初版有个 bug：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 5-32: *mutable_**tacos.py:1a*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-32: *mutable_**tacos.py:1a*'
- en: In the `Taco` class, the initializer `__init__()` accepts a list of toppings,
    which it stores as the `ingredients` list. The `add_sauce()` method will add the
    specified `sauce` string to the `ingredients` list.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Taco`类中，初始化器`__init__()`接受一个配料列表，并将其存储为`ingredients`列表。`add_sauce()`方法会将指定的`sauce`字符串添加到`ingredients`列表中。
- en: (Can you anticipate the problem?)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: （你能预见到这个问题吗？）
- en: 'I use the class as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我按如下方式使用该类：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 5-33: *mutable_**tacos.py:2a*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-33: *mutable_**tacos.py:2a*'
- en: 'I define a list of toppings I want on all my tacos, and then I define two tacos:
    `hot_taco` and `mild_taco`. I pass the `default_toppings` list to the initializer
    for each taco. Then I add `"Salsa"` to the list of toppings to `hot_taco`, but
    I don’t want any `"Salsa"` on `mild_taco`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个所有塔可都使用的配料列表，然后定义了两个塔可：`hot_taco`和`mild_taco`。我将`default_toppings`列表传递给每个塔可的初始化器。接着我将`"Salsa"`添加到`hot_taco`的配料列表中，但不希望`mild_taco`有任何`"Salsa"`。
- en: 'To make sure this is working, I print out the list of `ingredients` for the
    two tacos, as well as the `default_toppings` list I started with:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这个功能正常工作，我打印出两个塔可（`Taco`）的`ingredients`列表，以及我最初使用的`default_toppings`列表：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 5-34: *mutable_**tacos.py:3*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-34: *mutable_**tacos.py:3*'
- en: 'That outputs the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Waiter, there’s a bug in my taco!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 服务员，我的塔可有个 bug！
- en: The trouble is, when I created my `hot_taco` and `mild_taco` object by passing
    `default_toppings` to the `Taco` initializer, I bound both `hot_taco.ingredients`
    and `mild_taco.ingredients` to the same list value as `default_toppings`. These
    are now all aliases of the same value in memory. Then, when I call the function
    `hot_taco.add_sauce()`, I mutate that list value. The addition of `"Salsa"` is
    visible not only in `hot_taco.ingredients`, but also (unexpectedly) in `mild_taco.ingredients`
    and in the `default_toppings` list. This is definitely not the desired behavior;
    adding `"Salsa"` to one taco should only affect that one taco.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当我通过将`default_toppings`传递给`Taco`初始化函数来创建`hot_taco`和`mild_taco`对象时，我将`hot_taco.ingredients`和`mild_taco.ingredients`都绑定到了与`default_toppings`相同的列表值。这些现在都是内存中相同值的别名。然后，当我调用函数`hot_taco.add_sauce()`时，我改变了该列表的值。添加`"Salsa"`不仅会在`hot_taco.ingredients`中可见，而且（出乎意料地）也出现在`mild_taco.ingredients`和`default_toppings`列表中。这显然不是预期的行为；向一个塔可添加`"Salsa"`应该只影响那个塔可。
- en: 'One way to resolve this is to ensure I’m assigning a copy of the mutable value.
    In the case of my `Taco` class, I will rewrite the initializer so it assigns a
    copy of the specified list to `self.ingredients`, instead of aliasing:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是确保我分配的是可变值的副本。在我的`Taco`类中，我将重写初始化器，使其将指定列表的副本赋值给`self.ingredients`，而不是创建别名：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 5-35: *mutable_**tacos.py:1b*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-35: *mutable_**tacos.py:1b*'
- en: I make a copy with the `copy.copy()` function ❶, which is imported from `copy`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`copy.copy()`函数 ❶来创建一个副本，该函数从`copy`模块导入。
- en: 'I make a copy of the list passed to `toppings` within `Taco.__init__()`, assigning
    that copy to `self.ingredients`. Any changes made to `self.ingredients` don’t
    affect the others; adding `"Salsa"` to `hot_taco` does not change `mild_taco.ingredients`,
    nor does it change `default_toppings`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`Taco.__init__()`中复制传递给`toppings`的列表，并将该副本赋值给`self.ingredients`。对`self.ingredients`所做的任何更改都不会影响其他列表；将`"Salsa"`添加到`hot_taco`时不会改变`mild_taco.ingredients`，也不会改变`default_toppings`：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Deep Copy
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深拷贝
- en: A shallow copy is all well and good for lists of immutable values, but as previously
    mentioned, when a mutable value contains other mutable values, changes to those
    values can appear to replicate in weird ways.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 浅拷贝对于不可变值的列表是有效的，但如前所述，当一个可变值包含其他可变值时，对这些值的更改可能会以奇怪的方式重复出现。
- en: 'For example, consider what happens when I try to make a copy of a `Taco` object
    before changing one of the two tacos. My first attempt results in some undesired
    behavior. Building on the same `Taco` class as before (see [Listing 5-35](#listing5-35)),
    I’ll use the copy of one taco to define another:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑当我在修改其中一个塔可之前尝试复制一个`Taco`对象时会发生什么。我的第一次尝试导致了一些不想要的行为。在之前的`Taco`类的基础上（参见[Listing
    5-35](#listing5-35)），我将一个塔可的副本用于定义另一个塔可：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 5-36: *mutable_**tacos.py:2b*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-36: *mutable_**tacos.py:2b*'
- en: I want to create a new taco (`hot_taco`) that is initially identical to `mild_taco`,
    but with added `"Salsa"`. I’m attempting this by binding a copy of `mild_taco`
    ❶ to `hot_taco`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我想创建一个新的 taco（`hot_taco`），它最初与`mild_taco`相同，但添加了`"Salsa"`。我尝试通过将`mild_taco`的副本❶绑定到`hot_taco`来实现这一点。
- en: 'Running the revised code (including [Listing 5-34](#listing5-34)) produces
    the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改后的代码（包括[清单 5-34](#listing5-34)）会产生以下结果：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: I might not expect any changes made to `hot_taco` to reflect in `mild_taco`,
    but unexpected changes have clearly happened.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能不希望对`hot_taco`所做的任何更改反映在`mild_taco`中，但显然发生了意外的更改。
- en: The issue is that, when I make a copy of the `Taco` object value itself, I am
    not making a copy of the `self.ingredients` list *within* the object. Both `Taco`
    objects contain references to the same list value.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当我复制`Taco`对象值本身时，我没有复制对象内部的`self.ingredients`列表。两个`Taco`对象都包含对同一列表值的引用。
- en: 'To fix this problem, I can use *deep copy* to ensure that any mutable values
    inside the object are copied as well. In this case, a deep copy of a `Taco` object
    will create a copy of the `Taco` value, as well as a copy of any mutable values
    that `Taco` contains references to—namely, the list `self.ingredients`. [Listing
    5-37](#listing5-37) shows that same program, using deep copy:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我可以使用*deep copy* 来确保对象内部的任何可变值也被复制。在这种情况下，`Taco`对象的深拷贝将创建`Taco`值的副本，以及`Taco`包含引用的任何可变值的副本——即`self.ingredients`列表。[清单
    5-37](#listing5-37)显示了使用深拷贝的相同程序：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 5-37: *mutable_**tacos.py:2c*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-37：*mutable_**tacos.py:2c*
- en: 'The only change is that I’m using `copy.deepcopy()`, instead of `copy.copy()`
    ❶. Now when I mutate the list inside `hot_taco`, it doesn’t affect `mild_taco`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是我使用了`copy.deepcopy()`而不是`copy.copy()`❶。现在，当我改变`hot_taco`内部的列表时，不会影响`mild_taco`：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I don’t know about you, but I’m getting hungry for tacos.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你怎么看，但我对 taco 开始感到饥饿了。
- en: Copying is the most generic way to solve the problem of passing around mutable
    objects. However, depending on what you’re doing, there may be an approach better
    suited to the particular collection you’re using. For example, many collections,
    like lists, have functions that return a copy of the collection with some specific
    modification. When you’re solving these sorts of issues with mutability, you can
    start by employing copy and deep copy. Then, you can exchange that for a more
    domain-specific solution later.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 复制是解决传递可变对象问题的最常见方法。然而，根据你的具体需求，可能会有更适合特定集合的方法。例如，许多集合（如列表）都有返回带有特定修改的集合副本的函数。在解决这类可变性问题时，可以首先使用复制和深复制。然后，稍后可以用更适合特定领域的解决方案来替换它。
- en: Coercion and Conversion
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制转换和转换
- en: Names do not have types. Therefore, Python has no need of type casting, at least
    in the typical sense of the term.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 名称没有类型。因此，在典型意义上，Python 不需要类型转换。
- en: 'Allowing Python to figure out the conversions by itself, such as when adding
    together an integer (`int`) and a `float`, is called *coercion*. Here are a few
    examples:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 Python 自行确定转换，比如将整数（`int`）和`float`相加时，称为*coercion*。以下是几个示例：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 5-38: *coercion.py*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-38：*coercion.py*
- en: Even so, there are potential situations in which you may need to use one value
    to create a value of a different type, such as when you are creating a string
    from an integer. *Conversion* is the process of explicitly casting a value of
    one type to another type.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，也可能会有一些情况需要使用一个值来创建不同类型的值，比如从整数创建字符串。*Conversion* 是显式地将一个类型的值转换为另一个类型的过程。
- en: Every type in Python is an instance of a class. Therefore, the class of the
    type you want to create only needs to have an initializer that can handle the
    data type of the value you’re converting from. (This is usually done through duck
    typing.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的每种类型都是一个类的实例。因此，您要创建的类型的类只需要有一个可以处理您从中进行转换的数据类型的初始化程序即可（通常通过鸭子类型实现）。
- en: 'One of the more common scenarios is to convert a string containing a number
    into a numeric type, such as a `float`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的场景之一是将包含数字的字符串转换为数字类型，比如`float`：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Listing 5-39: *conversion.py:1*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-39：*conversion.py:1*
- en: Here, I start with a piece of information as a string value, which is bound
    to the name `life_universe_everything`. Imagine I want to do some complex mathematical
    analysis on this data; to do this, I must first convert the data into a floating-point
    number. The desired type would be an instance of the class `float`. That particular
    class has an initializer (`__init__()`) that accepts a string as an argument,
    which is something I know from the documentation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我以一个字符串值开始，这个值被绑定到名称 `life_universe_everything`。假设我想对这些数据进行一些复杂的数学分析；为了做到这一点，我必须首先将数据转换为一个浮点数。所需的类型是
    `float` 类的一个实例。该类有一个初始化器（`__init__()`），它接受一个字符串作为参数，这是我从文档中了解到的。
- en: I initialize a `float()` object, pass `life_universe_everything` to the initializer,
    and bind the resulting object to the name `answer`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我初始化了一个 `float()` 对象，将 `life_universe_everything` 传递给初始化器，并将结果绑定到变量 `answer`。
- en: 'I’ll print out the `type` and value of `answer`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我将打印出 `answer` 的类型和它的值：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 5-40: *conversion.py:2*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-40: *conversion.py:2*'
- en: 'That outputs the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Since there were no errors, you can see that the result is a `float` with value
    `42.0`, bound to `answer`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有出现错误，你可以看到结果是一个值为 `42.0` 的 `float`，并且绑定到 `answer`。
- en: Every class defines its own initializers. In the case of `float()`, if the string
    passed to it cannot be interpreted as a floating-point number, a `ValueError`
    will be raised. Always consult the documentation for the object you’re initializing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都会定义自己的初始化器。以 `float()` 为例，如果传给它的字符串不能被解释为浮点数，将会引发 `ValueError` 异常。始终查阅你正在初始化的对象的文档。
- en: A Note About Systems Hungarian Notation
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于系统化匈牙利命名法的说明
- en: If you’re coming from a statically typed language like C++ or Java, you’re probably
    used to working with data types. Thus, when picking up a dynamically typed language
    such as Python, it might be tempting to employ some means of “remembering” what
    type of value every name is bound to. ***Don’t do this!*** You will find the most
    success using Python if you learn to take full advantage of dynamic typing, weak
    binding, and duck typing.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自像 C++ 或 Java 这样的静态类型语言，你可能已经习惯了与数据类型打交道。因此，当你学习像 Python 这样的动态类型语言时，可能会有诱惑去采用某种方式“记住”每个名称所绑定的值的类型。***不要这样做！***
    如果你学会充分利用动态类型、弱绑定和鸭子类型，你会发现使用 Python 更为成功。
- en: 'I will confess: the first year I used Python, I used *Systems Hungarian notation*—the
    convention of appending a prefix denoting data type to every variable name—to
    try to “defeat” the language’s dynamic typing system. My code was littered with
    such debris as `intScore`, `floatAverage`, and `boolGameOver`. I picked up the
    habit from my time using Visual Basic .NET, and I thought I was brilliant. In
    fact, I was depriving myself of many opportunities to refactor.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我得承认：我第一次使用 Python 的时候，曾经使用过 *系统化匈牙利命名法*——给每个变量名附加表示数据类型的前缀——来试图“击败”该语言的动态类型系统。我的代码中到处都是类似
    `intScore`、`floatAverage` 和 `boolGameOver` 这样的残骸。我从使用 Visual Basic .NET 的时候养成了这个习惯，认为自己很聪明。事实上，我剥夺了自己很多重构的机会。
- en: 'Systems Hungarian notation will quickly render code obtuse. For example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 系统化的匈牙利命名法会迅速使代码变得晦涩。例如：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 5-41: *evils_of_systems_hungarian.py*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-41: *evils_of_systems_hungarian.py*'
- en: 'Needless to say, this code is quite painful to read. On the other hand, if
    you make full use of Python’s typing system (and resist the urge to store every
    intermediate step), the code will be decidedly more compact:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 不用多说，这段代码看起来相当痛苦。另一方面，如果你充分利用 Python 的类型系统（并且抵制将每一个中间步骤都存储下来的冲动），代码会显得更加简洁：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 5-42: *duck_typing_feels_better.py*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-42: *duck_typing_feels_better.py*'
- en: My code became far cleaner once I stopped treating Python like a statically
    typed language. Python’s typing system is a big part of what makes it such a readable
    and compact language.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我停止将 Python 当作静态类型语言来看待，我的代码变得更加简洁。Python 的类型系统是它之所以成为如此易读且紧凑的语言的重要原因之一。
- en: Terminology Review
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语回顾
- en: I’ve introduced a lot of important new words in this section. Since I’ll be
    using this vocabulary frequently throughout the rest of the book, doing a quick
    recap here is prudent.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我介绍了许多重要的新词汇。由于在接下来的章节中我将频繁使用这些词汇，因此在此做个简短的回顾是明智的。
- en: alias (v.) To bind a mutable value to more than one name. Mutations performed
    on a value bound to one name will be visible on all names bound to that mutable
    value.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 别名（动词）将一个可变值绑定到多个名称。对一个绑定到某个名称的值进行的变更，会在所有绑定到该可变值的名称中可见。
- en: assignment (n.) The act of binding a value to a name. Assignment never copies
    data.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值 (n.) 将一个值绑定到一个名称的行为。赋值从不复制数据。
- en: bind (v.) To create a reference between a name and a value.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定 (v.) 创建名称和值之间的引用关系。
- en: coercion (n.) The act of implicitly casting a value from one type to another.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换 (n.) 隐式地将一个值从一种类型转换为另一种类型的行为。
- en: conversion (n.) The act of explicitly casting a value from one type to another.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 转换 (n.) 显式地将一个值从一种类型转换为另一种类型的行为。
- en: copy (v.) To create a new value in memory from the same data as another value.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 拷贝 (v.) 从另一个值中创建一个具有相同数据的新值。
- en: data (n.) Information stored in a value. You may have copies of any given data
    stored in other values.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 数据 (n.) 存储在值中的信息。你可以在其他值中存储同一数据的副本。
- en: deep copy (v.) To both copy an object to a new value *and* copy all the data
    from values referenced within that object to new values.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 深拷贝 (v.) 将一个对象复制到一个新值，并将该对象中引用的所有数据复制到新的值中。
- en: identity (n.) The specific location in memory that a name is bound to. When
    two names share an identity, they are bound to the same value in memory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 身份 (n.) 名称绑定到的内存中具体的位置。当两个名称共享相同的身份时，它们绑定到内存中的同一个值。
- en: immutable (adj.) Of or relating to a value that *cannot* be modified in place.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变 (adj.) 与不能就地修改的值相关。
- en: mutable (adj.) Of or relating to a value that *can* be modified in place.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 可变 (adj.) 与可以就地修改的值相关。
- en: mutate (v.) To change a value in place.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 变异 (v.) 就地更改一个值。
- en: name (n.) A reference to a value in memory, commonly thought of as a “variable”
    in Python. A name must always be bound to a value. ***Names have scope, but not
    type.***
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 (n.) 指向内存中某个值的引用，通常被认为是 Python 中的“变量”。名称必须始终绑定到一个值上。***名称有作用域，但没有类型。***
- en: rebind (v.) To bind an existing name to a different value.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 重新绑定 (v.) 将一个现有的名称绑定到一个不同的值上。
- en: reference (n.) The association between a name and a value.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 引用 (n.) 名称和值之间的关联。
- en: scope (n.) A property that defines what section of the code a name is accessible
    from, such as from within a function or within a module.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域 (n.) 定义名称可以从代码的哪个部分访问的属性，例如函数内或模块内。
- en: shallow copy (v.) To copy an object to a new value but *not* copy the data from
    values referenced within that object to new values.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 浅拷贝 (v.) 将一个对象复制到一个新值，但不将该对象中引用的所有数据复制到新值中。
- en: type (n.) A property that defines how a raw value is interpreted, for example,
    as an integer or a boolean.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 (n.) 定义如何解释一个原始值的属性，例如作为整数或布尔值。
- en: value (n.) A unique copy of data in memory. There must be a reference to a value,
    or else the value is deleted. ***Values have type, but not scope.***
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 值 (n.) 存储在内存中的唯一数据副本。必须有一个对值的引用，否则该值会被删除。***值有类型，但没有作用域。***
- en: variable (n.) A combination of a name and the value the name refers to.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 (n.) 名称与该名称所指代的值的结合。
- en: weakref (n.) A reference that does not increase the reference count on the value.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用 (n.) 不增加值引用计数的引用。
- en: To help keep us grounded in these concepts, we usually use the term *name* instead
    of *variable*. Instead of *changing* something, we *(re)bind a name* or *mutate
    a value*. Assignment never copies—it literally always binds a name to a value.
    Passing to a function is just assignment.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们更好地理解这些概念，我们通常使用术语 *名称* 来代替 *变量*。我们不会说 *改变* 某个东西，而是说 *（重新）绑定一个名称* 或 *改变一个值*。赋值从不复制——它实际上总是将名称绑定到值上。传递给函数实际上就是赋值。
- en: By the way, if you ever have trouble wrapping your head around these concepts
    and how they play out in your code, try the visualizer at [http://pythontutor.com/](http://pythontutor.com/).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你在理解这些概念及其在代码中的运作方式时遇到困难，可以尝试使用 [http://pythontutor.com/](http://pythontutor.com/)
    上的可视化工具。
- en: Wrapping Up
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: It’s easy to take something like variables for granted, but by understanding
    Python’s unique approach, you can better avail yourself of the power that is available
    through dynamic typing. I must admit, Python has somewhat spoiled me. When I work
    in statically typed languages, I find myself pining for the expressiveness of
    duck typing.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将像变量这样的概念视为理所当然，但通过理解 Python 独特的方式，你可以更好地利用动态类型带来的强大功能。不得不承认，Python 有点让我养成了依赖它的习惯。当我在静态类型语言中工作时，我会不禁怀念鸭子类型的表达能力。
- en: 'Still, working with Python-style dynamic typing can take getting used to if
    you have a background in other languages. It’s like learning how to speak a new
    human language: only with time and practice will you begin to think in the new
    tongue.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果你有其他语言的背景，使用 Python 风格的动态类型可能需要一些适应。这就像学习一种新的语言：只有通过时间和实践，你才能开始用新的语言思考。
- en: If all this is making your head swim, let me reiterate the single most important
    principles. Names have scope, but no type. Values have type, but no scope. A name
    can be bound to any value, and a value can be bound to any number of names. It
    really is that dead simple! If you remember that much, you’ll go a long way.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切让你有些迷茫，让我再重申一下最重要的原则。名称有作用域，但没有类型。值有类型，但没有作用域。一个名称可以绑定到任何值，而一个值可以绑定到任何数量的名称。真的是这么简单！如果你记住这一点，你会走得很远。
- en: '6'
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Functions and Lambdas
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 函数与 Lambda 表达式
- en: '![](Images/chapterart.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Functions are one of the most elementary concepts in programming, yet Python
    packs a surprising amount of versatility into them. You’ll recall from Chapter
    3 that functions are first-class objects, so they are treated no differently from
    any other object. This fact, combined with the power of dynamic typing, opens
    up so many possibilities.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是编程中最基础的概念之一，但 Python 将令人惊讶的多功能性集成其中。你会记得在第三章中提到过，函数是头等公民对象，因此它们与其他对象没有区别。这个事实，加上动态类型的强大功能，开辟了无数可能性。
- en: Python has full support for *functional programming*, a distinct paradigm from
    which we get those “lambdas,” or anonymous functions, you keep reading about online.
    If you’re used to languages like Haskell or Scala, a lot of the concepts in this
    chapter are going to seem familiar to you. However, if you’re more used to object-oriented
    programming, such as in Java or C++, this may be the first time you’ve encountered
    many of these concepts.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Python 完全支持 *函数式编程*，这是一种与众不同的范式，我们从中得到了你在网上常看到的那些“lambda”或匿名函数。如果你习惯于像 Haskell
    或 Scala 这样的语言，那么本章中的许多概念对你来说应该很熟悉。然而，如果你更习惯于面向对象编程，比如 Java 或 C++，这可能是你第一次遇到这些概念。
- en: When learning Python, it makes sense to dive into functional programming early
    on. It is perfectly possible to write idiomatic Python code without ever creating
    a single class (see Chapter 7). By contrast, functions and functional programming
    concepts underpin much of the language’s most powerful features.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 Python 时，尽早深入函数式编程是很有意义的。完全可以编写地道的 Python 代码而不创建任何类（参见第七章）。相比之下，函数和函数式编程概念构成了语言中许多强大功能的基础。
- en: Python Function Essentials
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 函数基础
- en: I briefly touched on functions in Chapter 3. Building on that knowledge, I’ll
    gradually construct a more complex example in this chapter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第三章简要介绍了函数。基于这些知识，我将在本章中逐步构建一个更复杂的示例。
- en: 'I’ll start by creating a function that rolls a single die with a specified
    number of sides:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从创建一个掷骰子函数开始，指定一个面数：
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 6-1: *dice_roll.py:1a*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-1: *dice_roll.py:1a*'
- en: I define a function named `roll_dice()`, which accepts a single parameter, `sides`.
    This function is considered pure, because it has no side effects; it accepts a
    value as an input and returns a new value as an output. I return a value from
    the function using the `return` keyword.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个名为 `roll_dice()` 的函数，它接受一个参数 `sides`。这个函数被认为是纯粹的，因为它没有副作用；它接受一个值作为输入并返回一个新值作为输出。我使用
    `return` 关键字从函数中返回一个值。
- en: The `random` module has a number of functions for producing random values. Here,
    I use its `random.randint()` function to generate a pseudorandom number in Python.
    I generate a random number between `1` and `20` (the value of `sides` in this
    example) inclusively, with `random.randint(1, 20)`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`random` 模块有多个用于生成随机值的函数。在这里，我使用其 `random.randint()` 函数在 Python 中生成一个伪随机数。我生成一个介于
    `1` 和 `20` 之间（包括 1 和 20）的随机数，使用 `random.randint(1, 20)`。'
- en: 'Here’s my usage for the function:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我对这个函数的使用方法：
- en: '[PRE54]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listing 6-2: *dice_roll.py:2a*'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-2: *dice_roll.py:2a*'
- en: Later, I call the function and pass the value `20` as an argument ❶, so the
    function call is effectively the same as rolling a 20-sided die. The value that
    the first function call returns is bound to `player1`; the second call’s return
    is bound to `player2`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我调用这个函数并传入值 `20` 作为参数 ❶，所以这个函数调用实际上就相当于掷一个 20 面的骰子。第一次函数调用返回的值绑定到 `player1`；第二次调用的返回值绑定到
    `player2`。
- en: Because I defined `roll_dice()` as a function, I can use it as many times as
    I want. If I want to change its behavior, I only need to modify the function in
    the one place where it is defined, and every usage of that function will be affected.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我将 `roll_dice()` 定义为函数，所以我可以随时调用它。如果我想更改它的行为，我只需要在定义它的地方修改一次，它的所有调用都会受到影响。
- en: 'Say I wanted to roll multiple dice at once and return the results in a tuple.
    I can rewrite the `roll_dice()` function to do that:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想同时掷多个骰子并返回结果作为一个元组。我可以重写 `roll_dice()` 函数来实现这一点：
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Listing 6-3: *dice_roll.py:1b*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6-3: *dice_roll.py:1b*'
- en: To allow rolling multiple dice, the function accepts a second parameter, `dice`,
    which represents the number of dice being rolled. The first parameter, `sides`,
    still represents the number of sides on any one of the dice.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许同时掷多个骰子，函数接受第二个参数 `dice`，表示掷骰子的数量。第一个参数 `sides` 仍然表示每个骰子的面数。
- en: The scary-looking line of code at the top of the function is a *generator expression*,
    which I’ll cover in Chapter 10. For now, you can take it for granted that I’m
    generating one random number for each die being rolled and packing the results
    in a tuple.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 函数顶部那行看起来很吓人的代码是一个 *生成器表达式*，我将在第 10 章讲解它。现在，你可以理解为我正在为每个掷出的骰子生成一个随机数，并将结果打包成一个元组。
- en: 'Since my function now has a second parameter in the function call, I pass two
    arguments:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我的函数现在在函数调用中有第二个参数，我传递了两个参数：
- en: '[PRE56]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 6-4: *dice_roll.py:2b*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-4: *dice_roll.py:2b*'
- en: The returned tuple can be *unpacked*, meaning each item in the tuple is bound
    to a name I can use to access the value. The number of names listed on the left
    (separated by commas) and the number of values in the tuple *must* match for this
    to work, or else Python will raise an error. (See Chapter 9 for more on unpacking
    and tuples.)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的元组可以被 *解包*，意味着元组中的每一项都绑定到一个我可以用来访问其值的名称。左侧列出的名称数量（用逗号分隔）和元组中的值的数量 *必须* 匹配，否则
    Python 会抛出错误。（更多关于解包和元组的内容，请参见第 9 章。）
- en: Recursion
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: '*Recursion* occurs when a function calls itself. This can be helpful when you
    need to repeat the entire logic of a function but a loop is unsuitable or feels
    too cluttered, as in the upcoming example.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归* 是指一个函数调用自身。这在你需要重复执行函数的整个逻辑，但循环不合适或感觉太混乱时会很有帮助，正如接下来的例子所示。'
- en: For example, returning to my dice-rolling function, I can accomplish the exact
    same result using recursion, instead of that generator expression I was using
    earlier (although in practice, the generator expression is usually considered
    more Pythonic).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回到我的掷骰子函数，我可以使用递归来实现完全相同的结果，而不是使用我之前使用的生成器表达式（尽管在实践中，生成器表达式通常被认为是更符合 Python
    风格的做法）。
- en: '[PRE57]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 6-5: *dice_roll_recursive.py:1a*'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-5: *dice_roll_recursive.py:1a*'
- en: I store the resulting roll for this function call in `roll`. Then, in the recursive
    call, I pass my `sides` parameter as is, while reducing the number of `dice` to
    roll by one, to account for the die I just rolled. Finally, I combine the tuple
    that is returned from that recursive function call with the result of the roll
    on this function call, and I return the resulting longer tuple.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我将此函数调用的结果存储在 `roll` 中。然后，在递归调用中，我将 `sides` 参数按原样传递，同时将骰子的数量减少 1，以考虑到我刚刚掷出的那颗骰子。最后，我将从递归函数调用返回的元组与此次函数调用的结果结合起来，并返回结果的更长元组。
- en: 'The usage is essentially the same as before:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 用法与之前基本相同：
- en: '[PRE58]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 6-6: *dice_roll_recursive.py:2a*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-6: *dice_roll_recursive.py:2a*'
- en: 'If you were to print out each value being returned, in order from deepest recursive
    call to outermost, here’s what you would see:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印出每个返回的值，按从最深的递归调用到最外层的顺序，下面是你会看到的内容：
- en: '[PRE59]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 6-7: Returns from recursive calls to `roll_dice(6, 5)`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-7: 从递归调用 `roll_dice(6, 5)` 返回的结果'
- en: When the number of dice left is zero or negative, I return an empty tuple instead
    of recursively calling it again. If I don’t do that, the recursion will try to
    run forever. Thankfully, Python will pull the plug at some point and just crash
    the program, instead of letting it consume all your computer’s memory (as some
    other programming languages are apt to do). The *recursion depth* is how many
    recursive function calls have not returned yet, and Python caps it at approximately
    one thousand.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当剩余的骰子数量为零或负数时，我返回一个空元组，而不是递归调用函数。如果不这样做，递归会永远运行下去。幸运的是，Python 会在某个时刻终止程序，而不会让它消耗你电脑的所有内存（而一些其他编程语言可能会导致这种情况）。*递归深度*
    是指还没有返回的递归函数调用的数量，Python 将其限制在大约一千次。
- en: 'If the recursion depth goes any deeper than the limit, the entire program stops
    and raises an error:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递归深度超过限制，整个程序会停止并引发错误：
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is why it’s so important that you build some means of stopping when you
    use recursion. In the `roll_dice` function, this stopping mechanism is at the
    very top of the function:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在使用递归时建立某种停止机制非常重要的原因。在`roll_dice`函数中，这个停止机制位于函数的最顶部：
- en: '[PRE61]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Since `dice` is getting decremented every time the function calls itself, sooner
    or later, it will reach zero. When it does, it returns an empty tuple, instead
    of producing another recursive call. Then, the rest of the recursive calls can
    finish running and return.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次函数调用时`dice`都会递减，迟早它会变为零。当它变为零时，函数会返回一个空元组，而不是进行另一次递归调用。然后，其余的递归调用可以完成并返回。
- en: 'There may be cases in which a recursion depth of a thousand is not enough.
    If you need more, you can override the maximum:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有些情况下，递归深度达到一千并不够。如果你需要更多的深度，可以覆盖最大值：
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `sys.setrecursionlimit()` function allows you to set a new maximum recursion
    depth. In this case, my new limit is `2000`. The benefit of this approach is that
    once you no longer need your limit, you can set it back to the default so it can
    keep *other* recursive calls from getting out of hand.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.setrecursionlimit()`函数允许你设置新的最大递归深度。在这种情况下，我的新限制是`2000`。这种方法的好处是，一旦你不再需要限制，你可以将其恢复为默认值，以防止*其他*递归调用失控。'
- en: Default Argument Values
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数值
- en: 'You might imagine that I would need to roll a single die far more often than
    any other option. As it stands right now, I would have to manually specify that
    I only want to roll one 20-sided die:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想象，我掷一个骰子的频率远高于其他选项。目前，我必须手动指定我只想掷一个20面骰子：
- en: '[PRE63]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: I have to manually pass a `1` as the second argument of `roll_dice` to specify
    that I’m rolling a single die.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须手动将`1`作为`roll_dice`的第二个参数传递，以指定我正在掷一个骰子。
- en: By the way, that trailing comma after `result` is how I unpack a single value
    from a single-item tuple, meaning the actual value of the only item in the tuple
    is now bound to `result`. (See Chapter 9 for more on unpacking.)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`result`后面的那个逗号是我从单项元组中解包一个单一值的方式，意味着元组中唯一项的实际值现在绑定到了`result`。 （关于解包的更多内容，见第9章。）
- en: 'Since rolling a single die is likely the most common action I want to take
    with this function, I want to make it more convenient to use. I can use *default
    argument values* to accomplish this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于掷一个骰子可能是我使用此函数时最常见的操作，我希望使其更方便使用。我可以使用*默认参数值*来实现这一点：
- en: '[PRE64]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 6-8: *dice_roll.py:1c*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-8: *dice_roll.py:1c*'
- en: 'The `dice` parameter now has a default argument value of `1`. Thus, anytime
    I don’t specify the second argument, `dice` will use its default argument value.
    This makes it possible to use a simplified function call to roll a single six-sided
    die:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`dice`参数现在的默认参数值是`1`。因此，每当我不指定第二个参数时，`dice`将使用其默认参数值。这使得可以使用简化的函数调用来掷一个六面骰子：'
- en: '[PRE65]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If I do want to roll multiple dice, I can still pass that second argument:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我确实想掷多个骰子，我仍然可以传递第二个参数：
- en: '[PRE66]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: When you specify a default argument value for a parameter, you are defining
    an *optional parameter*. Conversely, a parameter with no default argument value
    is a *required parameter*. You can have as many of each as you like, but you must
    list all required parameters *before* your optional parameters. Otherwise, the
    code won’t run.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为参数指定默认值时，你是在定义一个*可选参数*。相反，没有默认值的参数是一个*必选参数*。你可以根据需要设置任意数量的可选和必选参数，但必须将所有必选参数*列在*可选参数之前，否则代码将无法运行。
- en: 'When using optional parameters, there is one significant trap lurking in the
    dark: default argument values are only evaluated once, when the function is defined.
    One place where this gets treacherous is when you’re using any mutable data type,
    such as a list. Consider this code for generating values in a Fibonacci sequence,
    which doesn’t quite work as expected:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用可选参数时，有一个重大陷阱隐藏在黑暗中：默认参数值只会在函数定义时评估一次。当你使用任何可变数据类型（如列表）时，这种情况尤其危险。考虑以下用于生成斐波那契数列的代码，它没有按预期工作：
- en: '[PRE67]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 6-9: *fibonacci.py:1a*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-9: *fibonacci.py:1a*'
- en: This is going to have a problem because the default argument value `[1, 1]`
    ❶ is evaluated when Python first processes the function definition, creating a
    single mutable list with the value `[1, 1]` in memory. That gets mutated on the
    first function call ❷ and then returned.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这将遇到一个问题，因为默认参数值`[1, 1]` ❶是在Python首次处理函数定义时评估的，创建了一个包含值`[1, 1]`的可变列表。当函数首次调用时，这个列表被改变
    ❷，然后返回。
- en: 'This usage of the function shows the problem:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 6-10: *fibonacci.py:2*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Everything looks okay in the code, but it isn’t. `fib1` is now bound to the
    same mutable value as `series`, so any changes to `fib1` are reflected in the
    default argument value *for every function call*. The second function call mutates
    this list further.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'When I call `fibonacci_next()` a third time, I’m probably expecting to start
    with a clean slate, `[1, 1, 2]`, which would be the result of a single mutation
    on the original default argument value. Instead, I’m getting the value of that
    single mutable value I’ve been messing with this whole time: `fib2` is now a third
    alias to the list. Oops!'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'This becomes apparent when I examine the output. This is what I’d be expecting:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'But this is what I actually get:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In short, *never use mutable values for default argument values*. Instead,
    use `None` as a default value, as shown in the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Listing 6-11: *fibonacci.py:1b*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The proper way is to use `None` as the default argument value, and then to create
    a new mutable value if that default is being used.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that same usage code as before ([Listing 6-9](#listing6-9)) now produces
    the expected output:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Keyword Arguments
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readability matters. Unfortunately, function calls with multiple parameters
    aren’t always the most readable bits of code. *Keyword arguments* help resolve
    this by attaching labels to arguments in function calls.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Arguments that are mapped to their parameters by the order you pass them in,
    like in all the prior examples, are called *positional arguments*.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: If you knew nothing about the `roll_dice()` function from earlier and you encountered
    this line of code, what would you think it did?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Listing 6-12: *dice_roll.py:3a*'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: You would probably guess that this is rolling multiple dice, and perhaps that
    it is specifying how many sides those dice have—but which is which? Is it rolling
    six five-sided dice or five six-sided dice? You can imagine how confusing this
    would be with even more arguments. This is the shortcoming of positional arguments.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'As The Zen of Python says:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It can’t be good, then, to force the reader to guess. I can eliminate the ambiguity
    by using *keyword arguments*. I don’t need to change the function definition at
    all to be able to use keyword arguments. I only need to change my function call:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Listing 6-13: *dice_roll.py:3b*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of those names comes from the earlier function definition of `roll_dice`,
    where I specified it had two parameters: `sides` and `dice`. In my function call,
    I can assign values directly to those parameters by name. Now, there is no question
    about what each argument does. Specify the name of the parameter, matching what
    is in the function definition, and then assign the desired value directly to it.
    That’s all.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'When using keyword arguments, you don’t even have to list them in order, just
    as long as all the required parameters receive values:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 6-14: *dice_roll.py:3c*'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be even more helpful when you have multiple optional parameters on
    the function. Consider if I rewrote `roll_dice()` so that the dice being rolled
    were six sided, by default:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在函数中有多个可选参数时，这将更加有用。假设我将`roll_dice()`重写，使得掷出的骰子默认都是六面骰：
- en: '[PRE76]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Listing 6-15: *dice_roll.py:1d*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-15: *dice_roll.py:1d*'
- en: 'Keyword arguments allow you to simplify your function calls even further:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数可以让你进一步简化函数调用：
- en: '[PRE77]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Listing 6-16: *dice_roll.py:3d*'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-16: *dice_roll.py:3d*'
- en: You’re only passing a value to one of the optional arguments, `dice`. For the
    other one, `sides`, the default value is used. It no longer needs to matter whether
    `sides` or `dice` appears first in the function’s parameter list; you can just
    use the ones you want and leave the rest alone.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你只向一个可选参数`dice`传递了一个值。对于另一个参数`sides`，使用的是默认值。现在不再需要关心`sides`或`dice`在函数参数列表中出现的顺序；你可以只使用你需要的参数，剩下的可以忽略。
- en: 'It is even possible to mix and match positional arguments and keyword arguments:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以将位置参数和关键字参数混合使用：
- en: '[PRE78]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Listing 6-17: *dice_roll.py:3e*'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-17: *dice_roll.py:3e*'
- en: Here, `6` is passed as a positional argument to the first parameter in the function
    definition, `sides`. Then, I pass `5` as a keyword argument to the parameter `dice`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`6`作为位置参数传递给函数定义中的第一个参数`sides`。然后，我将`5`作为关键字参数传递给参数`dice`。
- en: This can come in handy, particularly when you don’t want to bother with naming
    the positional arguments but you still want to use one of many possible optional
    parameters. The only rule here is that your keyword arguments must come after
    your positional arguments in the function call. (See also the section “Keyword-Only
    Parameters” later in the chapter.)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这特别有用，尤其是在你不想为位置参数命名，但仍希望使用多个可能的可选参数之一时。这里唯一的规则是，函数调用中的关键字参数必须位于位置参数之后。（另请参阅本章稍后的“仅限关键字参数”部分。）
- en: On Overloaded Functions
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于重载函数
- en: If you’re coming from a strictly typed language such as Java or C++, you’re
    probably used to writing *overloaded functions*, wherein you can write multiple
    functions with the same name but different parameters. Typically, overloaded functions
    in languages that support them provide a consistent interface (function name),
    while supporting arguments of different types.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自一个严格类型化的语言，比如 Java 或 C++，你可能已经习惯了编写*重载函数*，在这些函数中，你可以为相同的函数名写多个不同的参数。通常，支持重载的语言中的重载函数会提供一致的接口（函数名），同时支持不同类型的参数。
- en: Python usually doesn’t need overloaded functions. Using dynamic typing, duck
    typing, and optional parameters, you can write single functions that handle all
    the input scenarios you need to throw at Python.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通常不需要重载函数。通过使用动态类型、鸭子类型和可选参数，你可以编写单一函数来处理所有需要传递给 Python 的输入场景。
- en: If you really, really need overloaded functions—and you probably don’t—you actually
    can create them with *single-dispatch functions*. I’ll cover this in Chapter 15.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的非常需要重载函数——而且你可能并不需要——你实际上可以通过*单一分派函数*来创建它们。我将在第 15 章中讲解这一点。
- en: Variadic Arguments
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数
- en: With the skills discussed so far, even while using optional parameters, you
    still have to anticipate how many arguments can potentially get passed to your
    function. This is fine in most cases, but sometimes, you’ll have no idea how many
    to expect.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迄今为止讨论的技巧，即使使用了可选参数，你仍然需要预见可能会传递给函数的参数数量。在大多数情况下这是可以的，但有时，你可能根本不知道需要预期多少个参数。
- en: To solve this, your first instinct might be to pack all the arguments into a
    single tuple or a list. That works in some situations, but other times, it can
    become an extra inconvenience when calling the function.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你的第一反应可能是将所有参数打包成一个元组或列表。在某些情况下这样做是有效的，但有时，在调用函数时，这反而会成为一种额外的不便。
- en: 'A better solution is to use *arbitrary arguments lists*, also called *variadic
    arguments*, which automatically pack multiple arguments into a single *variadic
    parameter* or *variadic positional parameter*. In the dice-rolling function, I
    want to allow the rolling of multiple dice, where each die may have a different
    number of sides:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是使用*任意参数列表*，也称为*可变参数*，它们会自动将多个参数打包成一个*可变参数*或*可变位置参数*。在掷骰子函数中，我希望允许掷多个骰子，每个骰子的面数可能不同：
- en: '[PRE79]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Listing 6-18: *dice_roll_variadic.py:1a*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-18: *dice_roll_variadic.py:1a*'
- en: I turn the parameter `dice` into a variadic parameter by preceding it with a
    single asterisk (`*`). All the arguments passed to `roll_dice` will now be packed
    into a tuple, bound to the name `dice`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Within the function, I can use this tuple in the usual manner. In this case,
    I’m using a generator expression (see Chapter 10) to roll each die specified in
    `dice`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'The placement of the variadic parameter is important: it must come *after*
    any positional parameters in the function definition. Any parameters I list after
    it will only be usable as keyword arguments, because the variadic parameter consumes
    all the remaining positional arguments.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my usage:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Listing 6-19: *dice_roll_variadic.py:2*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'In both function calls, I’m listing the dice I want to roll, with the number
    representing the number of sides of each die. In the first call, I’m rolling five
    six-sided dice. In the second call, I’m rolling four dice: a 20-sided die, a 6-sided
    die, an 8-sided die, and a 4-sided die.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'If I wanted to use the recursive approach, I’d populate the argument list by
    automatically unpacking that tuple into the function call:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Listing 6-20: *dice_roll_variadic.py:1b*'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Most of this code is going to look similar to the earlier recursive version.
    The most significant change is in what I’m passing to the recursive function call.
    The asterisk (`*`) in front of the name unpacks the tuple `dice` into the argument
    list ❶. I already processed the first item in the list, so I use the slice notation
    `[1:]` to remove that first item ❷ (see Chapter 9), to ensure it isn’t processed
    again.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Variadic Arguments
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To capture an unknown number of *keyword arguments*, precede the parameter name
    with *two* asterisks (`**`), making the parameter a *keyword variadic parameter*.
    The keyword arguments passed to the function are packed into a single dictionary
    object, so as to preserve the association between keyword and value. They are
    similarly unpacked by being preceded with two asterisks.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t show up very often in the wild. After all, if you didn’t know what
    the arguments were named, it would be hard to use them.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'One case where keyword variadic arguments are commonly useful is in blindly
    relaying arguments to another function call:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 6-21: *variadic_relay.py:1*'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: The `call_something_else()` function has one positional argument, `func`, where
    I’ll pass a *callable* object, such as another function. The second parameter,
    `args`, is a variadic parameter for capturing all the remaining positional arguments.
    Last is the keyword variadic parameter, `kwargs`, for capturing any keyword arguments;
    sometimes, the name `kw` is used instead. Remember, either of these can be empty
    and this code will still work.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: You can check whether an object is callable by passing it to the `callable()`
    function.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: The names `args` and `kwargs` are conventionally used for positional variadic
    and keyword variadic parameters, respectively. However, if you can think of names
    that better fit your particular situation, that’s certainly acceptable!
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: When the function calls the callable object `func`, it first unpacks all the
    positional arguments that were captured, and then it unpacks all the keyword arguments.
    The function code doesn’t need any knowledge of the callable object’s parameter
    list; instead, any and every argument passed to `call_something_else()` after
    that first positional argument will get blindly passed on.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this in action here:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Listing 6-22: *variadic_relay.py:2*'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'When I run that code, the `call_something_else()` function will call `say_hi()`,
    passing the argument `name="Bob"` to it. That produces the following output:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This bit of magic will come back into play shortly in writing *decorators* (see
    the section “Decorators” later in this chapter).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Keyword-Only Parameters
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use variadic parameters to turn some of your keyword parameters into
    *keyword-only parameters*, which were introduced in PEP 3102\. These parameters
    cannot have values passed in as positional arguments, but rather only as keyword
    arguments. This can be especially useful in ensuring that particularly long or
    perilous parameter lists are used in the proper manner, instead of as nigh-on
    unreadable chains of positional arguments.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, I’ll rewrite my `roll_dice()` function to have two keyword-only
    parameters:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Listing 6-23: *dice_roll_keyword_only.py:1*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: I use the unnamed variadic parameter `*`, which ensures every parameter that
    follows it in the list can only be accessed by name. If the caller passes in too
    many positional arguments (or in this case, *any* positional arguments), a `TypeError`
    is raised.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'This affects the usage, such that I can only use keyword arguments now:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Listing 6-24: *dice_roll_keyword_only.py:2*'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to use positional arguments raises an error:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Listing 6-25: *dice_roll_keyword_only.py:3*'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Positional-Only Parameters
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of Python 3.8 (via PEP 570), it is also possible to define *positional-only
    parameters*. This is useful when the parameter name is either unhelpful or likely
    to be changed down the road, meaning any code using it as a keyword parameter
    would be likely to break in the future.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll recall that positional parameters must always come first in the parameter
    list. Placing a forward slash (`/`) in the list designates all preceding parameters
    as positional-only:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Listing 6-26: *dice_roll_positional_only.py:1*'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the parameter `dice` still has a default value of `1`, but
    it is now positional-only. On the other hand, `sides` can be used as either a
    positional or a keyword parameter. Here’s that behavior in action:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Listing 6-27: *dice_roll_positional_only.py:2*'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: The first four examples all work, because the positional-only argument `dice`
    is either included as the first argument or omitted altogether. Any attempt to
    access `dice` by keyword fails with a `TypeError`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'Argument Types: All Together Now!'
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To ensure everything is clear regarding positional parameters and keyword parameters,
    I’ll take a moment to review with this (admittedly contrived) example:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The parameter `pos_only` is positional-only, as it comes before the forward-slash
    (`/`) marker. If I have any positional-only parameters, they must appear first
    in the list. Because this parameter has a default value, it is optional. However,
    if I wanted to pass an argument to it, it would need to be the first positional
    argument passed to the function; otherwise, a `TypeError` would be raised.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `pos_kw` parameter, which can be either positional or keyword. It
    comes after any positional-only parameters and after the forward-slash (`/`) marker,
    if there is one.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the asterisk (`*`) marker, I have `kw_only`, which is a keyword-only
    parameter. In this example, if my function receives more than two positional arguments,
    a `TypeError` will be raised.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Nested Functions
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From time to time, you may want to reuse a piece of logic *within* a function
    but not clutter up your code by making yet another function. In this situation,
    you can nest functions within other functions.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'I can use this to improve the recursive version of `roll_dice()`, making the
    logic for rolling a single die into something more reusable in the function:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Listing 6-28: *dice_roll_recursive.py:1b*'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I moved the logic for rolling a single die into a nested function
    `roll()`, which I can call from anywhere in the function `roll_dice()`. The direct
    benefit of abstracting out this logic is that it can be maintained more easily,
    without disrupting the rest of the code.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the usage:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Listing 6-29: *dice_roll_recursive.py:2b*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: That produces the usual random output.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: In production, I’d rarely use a nested function for something that trivial.
    Normally, I’d employ a nested function for more complex logic that sees frequent
    reuse, especially if it is used in multiple places in the outer function.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: You’ll recall from Chapter 5 that the nested function can access the names of
    its enclosing scope. However, if I wanted to rebind or mutate any of those names
    from within the nested function, I’d need to use the `nonlocal` keyword.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a function that builds and returns a kind of function called
    a *closure*, which encloses one or more nonlocal names. This pattern acts as a
    sort of “function factory.”
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on the dice example, I’ll write a function that returns a *closure*
    for rolling a particular set of dice:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Listing 6-30: *dice_cup_closure.py:1*'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: I create the function `make_dice_cup()`, which accepts the arguments for `sides`
    and `dice`. Inside `make_dice_cup()`, I define a nested function `roll()`, which
    uses `sides` and `dice`. When that nested function is returned by the outer function
    (no parentheses!) ❶, it becomes a closure, because it encloses `sides` and `dice`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Listing 6-31: *dice_cup_closure.py:2*'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: I bind the closure returned by `make_dice_cup()` to the name `roll_for_damage`,
    which I can now call as a function without any arguments. The closure continues
    to use `sides` and `dice` with the values I specified earlier to roll dice and
    return values; it is now a function in its own right.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Caution is necessary when using closures, as you can easily violate the rules
    of functional programming with them. If a closure has the ability to mutate the
    values it encloses, it becomes a sort of de facto object, and a difficult one
    to debug at that!
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Recursion with Closures
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous closure example didn’t use the recursive form of the dice-rolling
    code because, while it’s possible to implement such closure correctly, it’s even
    easier to do it wrong.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the most apparently obvious, yet wrong, way to make that closure recursive:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Listing 6-32: *dice_cup_closure_recursive.py:1a*'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Using what you know about names and scope so far, can you anticipate what’s
    wrong with the above?
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'The giveaway that something is wrong with the closure is the keyword `nonlocal`,
    as it indicates I’m mutating or rebinding a nonlocal name: `dice`.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to use this closure will reveal the problem:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Listing 6-33: *dice_cup_closure_recursive.py:2*'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 'That code produces the following output (for example):'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The first time the closure `roll_for_damage()` is used, everything is fine.
    However, `dice` isn’t reset when the function exits, so all subsequent calls to
    the closure find that `dice == 0`. Thus, they only return `()`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a recursive closure, you need to use an optional parameter on the
    closure:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Listing 6-34: *dice_cup_closure_recursive.py:1b*'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: In this version, I use the nonlocal name `dice` as the default value of the
    new, local parameter `dice`. (Recall, this will only work with immutable types.)
    This behaves precisely as expected, as it still closes over `sides` and the nonlocal
    `dice`, but it rebinds neither.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Stateful Closures
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it is generally best to write closures as pure functions, it is occasionally
    useful to create a *stateful closure*—that is, a closure that retains a little
    bit of state between calls that it can use. In general, you should avoid using
    stateful closures unless no other solution presents itself.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to demonstrate this, I’ll create a stateful closure that limits how many
    times a player can reroll a group of dice:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Listing 6-35: *dice_roll_turns.py:1*'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: I write the closure `roll()` so that it only allows the caller to reroll the
    dice a maximum number of times, specified by `limit`, before the function starts
    returning `None`. By this design, after the limit is reached, a new closure must
    be created. The logic of tracking how many times a player can roll the dice has
    been abstracted out into the closure.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: This closure is very limited and predictable in how it mutates and uses its
    state. It’s important to limit your closures in this way, since debugging a stateful
    closure can be difficult. There is no way to see the current value of `limit`
    from outside the closure; it’s simply not possible.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this predictable behavior at work in the usage:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Listing 6-36: *dice_roll_turns.py:2*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that code produces the following randomized output, wherein each turn
    gets three tosses of the dice; each toss is represented by a tuple:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: A stateful closure can be useful in situations where writing an entire class
    (see Chapter 7) brings in too much boilerplate. Since I only have one piece of
    state, `limit`, and I am using it predictably, this approach is acceptable. Anything
    more complicated, and debugging becomes impractically difficult.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: As I pointed out earlier, anytime you see `nonlocal` in a closure, you should
    be extra cautious, as it indicates the presence of state. This can be acceptable
    on occasion, but there is usually a better approach. Stateful closures are not
    pure functional programming!
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *lambda* is an anonymous (nameless) function made up of a single expression.
    The structure is as follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: On the left side of the colon is the parameter list, which may be omitted if
    you don’t want to accept any arguments. On the right is the return expression,
    which is evaluated when the lambda is called and the result is implicitly returned.
    To use a lambda, you must bind it to a name, whether by assignment or by passing
    it as an argument to another function.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s a lambda that adds two numbers:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Listing 6-37: *addition_lambda.py*'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: I bind the `lambda` to the name `add` and then call it as a function. This particular
    lambda accepts two arguments and then returns their sum.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Why Lambdas Are Useful
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many programmers can’t imagine ever needing nameless functions. It would seem
    to make reuse completely impractical. After all, if you’re just going to bind
    a lambda to a name, shouldn’t you have just written a function?
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how lambdas can be useful, let’s take a look at an example *without*
    lambdas first. This code represents a player character in a basic text adventure
    game:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Listing 6-38: *text_adventure_v1.py:1*'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m keeping track of my character’s stats in a couple of global names at the
    top, `health` and `xp`, which I’ll use throughout my program:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Listing 6-39: *text_adventure_v1.py:2*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: My `attempt()` function handles rolling the dice, using the outcome to decide
    whether the player’s action succeeded or failed, and then modifying the values
    of the global `health` and `xp` variables accordingly. It determines how those
    values should be changed, based on the value returned from calling the function
    passed to `outcome`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: The part to focus on is the parameter `outcome` ❶—which, by its usage in `attempt()`
    ❷, should be a function that accepts a boolean value and returns a tuple of two
    integers representing the desired changes to `health` and `xp`, respectively.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanding on that example, I’ll use what I’ve built so far:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Listing 6-40: *text_adventure_v1.py:3a*'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s no real pattern to the outcomes of each possible action, so I have
    to write functions for each one: in this example, `eat_bread()` and `fight_ice_weasel()`.
    Even this example is a bit oversimplified, as the code determining the outcome
    might involve a bunch of mathematics and randomization. Regardless, since I need
    a separate outcome function for each action, this code is going to grow rapidly,
    leading to a maintainability nightmare.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: (Be advised, the `if` statement above is not the most Pythonic way to write
    that code; I deliberately chose that structure to illustrate the logic.)
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: When I attempt an action ❶, I pass the string representing the action, the minimum
    dice roll necessary to succeed, and the function determining the outcome. When
    passing a function, remember not to include the trailing parentheses. Here, I
    want to pass the function itself, not the value it returns.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of usage is where lambdas come in. I can replace the `eat_bread()`
    and `fight_ice_weasel()` functions, plus the two calls to `attempt()`, with just
    the following:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Listing 6-41: *text_adventure_v1.py:3b*'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: 'The third argument of each is a lambda, which accepts a single parameter named
    `success` and returns a value depending on the value of `success`. Let’s isolate
    just that first lambda:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: When the lambda is called, if the value of `success` is `True`, then `(1, 0)`
    will be returned. Otherwise, `(-1, 0)` is returned.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: That lambda is being passed to (and thus bound to) the `outcome` parameter of
    the `attempt()` function, and it is subsequently called with a single boolean
    argument.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: By using lambdas in this manner, I can create many different possible outcomes
    in my code with only one line of code.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Remember that *a lambda may only consist of a single return expression*! This
    makes lambdas suitable for short, clear fragments of logic, especially when the
    code is made more readable by keeping that logic close to its usage within another
    function call. If you want anything more complex, you’ll need to write a proper
    function.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas as Sorting Keys
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common situations where a lambda comes in handy is when specifying
    a *key function*, which is a callable that returns the part of a collection or
    object that should be used for sorting. A key function is typically passed to
    another function that is responsible for sorting data in some manner.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here I have a list of tuples containing first and last names,
    and I want to sort the list by last name:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Listing 6-42: *sort_names.py*'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: The `sorted()` function uses the `key` argument ❶, which is always a function
    or other callable, by passing each item to it and then using the value returned
    from that callable to determine the sorting order. Since I want the tuples sorted
    by last name, which is the second item of each tuple, I have the lambda return
    that item, which is `x[1]`.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that `by_last_name` contains the list, sorted by last name.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Decorators* allow you to modify the behavior of a function (or even multiple
    functions) by wrapping it in an additional layer of logic. This changes the function’s
    behavior without you having to rewrite the function itself.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, here’s another example with my text adventure game hero.
    I want to define multiple game events that affect the player character’s statistics
    in different ways, and I want those changes displayed as they happen. I’ll start
    with an implementation that doesn’t use decorators. This code only uses concepts
    I’ve already covered so far in this book, so I’ll mainly draw your attention to
    some inefficiencies.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by defining my global variables:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Listing 6-43: *text_adventure_v2.py:1a*'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I’ll define functions for each action the player can take:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Listing 6-44: *text_adventure_v2.py:2a*'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Each function represents an action the player can take, and some common code
    is shared between these functions. First, each function checks the character’s
    health to determine if the character is even able to perform the action ❶ ❸. If
    the character’s health is sufficient, the player performs the action, which alters
    the character’s statistics. When the action is completed (or if the character’s
    health is too low to take an action), the current stats are displayed ❷ ❹.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, of course, I have the usage:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Listing 6-45: *text_adventure_v2.py:3*'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: That works, but as I said, the repeated code in [Listing 6-44](#listing6-44)
    is not very Pythonic. Your first instinct might be to move the common code—the
    code that checks the health and displays the statistics—out into their own functions.
    However, you would still need to remember to call each one within *every character
    action function*, and they’re easy to overlook. Furthermore, each function would
    still need that conditional statement at the top to ensure the code isn’t run
    when health is too low.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: This situation, where I want to run the same code before and after every function,
    can be perfectly solved with decorators.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I’ll create a decorator toward the top of the text adventure game code:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Listing 6-46: *text_adventure_v2.py:1b*'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: A decorator is most often implemented as a closure, which closes over a function
    (or any other callable object) being modified. The decorator itself, `character_action()`,
    accepts a `func` parameter, which is the callable being modified.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: Within the decorator definition is the *wrapper*, which is the callable where
    the decorator’s logic lives ❸. As I said, most commonly, the closure pattern is
    used for this. However, the wrapper can be implemented with any callable, including
    a class. (Technically, I could even implement the wrapper as a noncallable, but
    this is seldom, if ever, useful.)
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Because I don’t know how many arguments will be passed to any function I’ll
    apply the decorator to, I set up the wrapper to accept variadic arguments.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: The `@functools.wraps(func)` line ❷ prevents the callable being wrapped from
    having its identity concealed from the rest of the program. Without that line,
    wrapping the callable would mess up external access of such important function
    attributes as `__doc__` (the docstring) and `__name__`. This line is itself a
    decorator that ensures all the important attributes of the callable are retained
    by the now-wrapped function, thus making them accessible outside the function
    in all the usual ways. (To use that special decorator, I must import `functools`
    first ❶.)
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Inside the wrapper, I put all that logic I want to run before and after each
    function. After checking `health`, I call the function that is bound to `func`,
    unpacking all the variadic arguments into the call. I also bind the return value
    to `result`, so I can ensure that gets returned from the decorator after I print
    the stats.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: As with any closure, it is supremely important that the outer function return
    the inner function ❹.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I can use the decorator I wrote and refactor my other functions:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Listing 6-47: *text_adventure_v2.py:2b*'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: To apply decorators to a function, I list each decorator I want to apply directly
    above the function definition, one decorator per line. I precede each decorator
    name with an `@` symbol. In my example, I only apply a single decorator to each
    function, but you can use as many as you like. They will be applied in order,
    with each decorator wrapping whatever is immediately below it.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: Since I moved all the repetitive logic about checking health and displaying
    stats out of the individual functions and into the decorator, my code is cleaner
    and easier to maintain. If you run the code, it works the same as before.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Type Hints and Function Annotations
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python 3.5 onward allows you to specify *type hints*, which are exactly that:
    *hints* about what data type should be passed in or returned. These are not strictly
    necessary, given Python’s robust dynamic type system, but they may have a few
    benefits.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: First, type hinting aids in documentation. The function definition now shows
    what type of information it wants, which is especially helpful when your IDE auto-magically
    shows hints as you type arguments in.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Second, type hints help you catch potential bugs sooner. Static type checkers
    like *Mypy* are the primary tools for this (see Chapter 2). Some IDEs, like PyCharm,
    may warn you if you’re doing something weird, like passing a string to something
    type-hinted as an integer.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with statically typed languages like Java and C++, this might
    make you a little excited.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: However, understand that using type hints does not trade Python’s dynamic typing
    for static typing!
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Python will not raise an error if you pass the wrong type.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python will not try to convert data to the specified type.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python will actually ignore these hints altogether!
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type hints are specified with *annotations*, which are extra pieces of information
    that are permitted by the Python language but are not actually processed by the
    interpreter itself. There are two kinds of annotations.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '*Variable annotations* specify the expected type on a name, like this:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '*Function annotations* specify type hints on parameters and function returns.
    Here, I apply function annotations to the `roll_dice()` function from earlier:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Listing 6-48: *dice_roll.py:1e*'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: This notation allows me to denote what types I expect for the parameters and
    return. In this case, both parameters should receive an integer, so I follow each
    name with a colon and then `int` as the expected data type. If there’s a default
    value of the expected type, it is included after the type hint.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: I denote the return type with an arrow (`->`) and the expected type. Collections
    like tuples and lists are a little trickier to specify with type hints. From the
    `typing` module, I can use the notation `Tuple[ ]`, which is a *generic type*.
    Every value of this particular tuple should be an `int`, but since I don’t really
    know how many will be returned, I specify a `...` to say, “There may be more.”
    Now, the function will be expected to return one or more integers, but no other
    types.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if you don’t know what or how many types will be returned in a tuple,
    you can use the notation `typing.Tuple[typing.Any, ...]`
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 'That return type hint in the preceding code example is pretty long. I could
    shorten it by defining a *type alias*, like this:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Listing 6-49: *dice_roll.py:1f*'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: I define `TupleInts` as a type alias for `Tuple[int, ...]`, and I can use it
    the same way throughout my code.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Again, Python itself won’t act on these type hints; it will only recognize the
    notation system as valid and store it in the `__annotations__` attribute of the
    function, nothing more.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'I can now run this code through Mypy:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: If there are any mismatches between the type hints and the actual usage, Mypy
    will list these in detail, so they can be fixed.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: Duck Typing and Type Hints
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might think that type hinting is incompatible with duck typing, but thanks
    to the `typing` module, the two generally play very well with one another.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you wanted a function that could accept a single parameter of
    any type that could be iterated over (see Chapter 9), such as a tuple or a list,
    you could use `typing.Iterable[]`, with the contained type in the brackets. For
    this example, I’ll presume that the iterable may contain any type.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The parameter `within` is type-hinted to be an iterable with `typing.Iterable[
    ]`. The hint `typing.Any` within the square brackets indicates that the `Iterable`
    can contain items of any data type.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'The typing module contains many different such types, enough to fill up a separate
    chapter altogether. The best way to learn more about type hinting is to read the
    documentation: [https://docs.python.org/library/typing.html](https://docs.python.org/library/typing.html).
    I also recommend taking a look at PEP 484, which defined type hinting, and PEP
    3107, which defined function annotations.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: Should You Use Type Hinting?
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type hinting is entirely optional, and there are cases for it and against it.
    Some argue that it clutters up the code, impairing the natural readability that
    Python attained through dynamic typing. Others see it as a much-needed tool for
    mitigating the bugs made possible through the lack of static typing.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: In practice, you don’t need to make a wholesale “use or don’t use” decision.
    Because type hinting is optional, you can use it in cases where it improves the
    readability and stability of the code and skip it in cases where it doesn’t. Even
    within a function, you can define a type hint for one parameter and omit it for
    the next.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the decision is up to you and your team alone. Only you know if
    and when type hints will be helpful. In short, *know thine own project*.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Since this book focuses on idiomatic Python above all else, and since type hinting
    is entirely optional, I won’t use it in any future examples.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I hope you come away from this chapter with a newfound appreciation for functional
    programming in the Python language. Even when the paradigm is not embraced wholesale,
    its concepts and guidelines inform Pythonic code.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: I’ll still apply functional concepts as I move into object-oriented programming
    in the next chapter. I’ve found that, when combined correctly, these paradigms
    interact in surprisingly positive ways.**  **# 7
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: Objects and Classes
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
- en: Objects are the bread and butter of many a programmer. Python makes full use
    of objects, even to the point of inspiring the mantra, “Everything is an object.”
    However, if you’ve worked with classes and objects in any other language, Python’s
    take may surprise you.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-oriented programming* (or *OOP*) is a paradigm in which data and its
    corresponding logic is organized into objects. If you’re familiar with such languages
    as Java, C++, Ruby, and C#, you’re well acquainted with these concepts.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: Yet, object-oriented programming in Python is not mutually exclusive with functional
    programming; in fact, the two paradigms work very well together.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ll cover the essentials of object-oriented programming in
    Python: creating classes with attributes, modules, and properties. I’ll demonstrate
    adding various behaviors via special methods, and I’ll wrap up with a summary
    of the situations in which classes are the most useful.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Class
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a new class is simple. I’ll create a class named `SecretAgent`:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Listing 7-1: Initializing a class'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Below this, in the accompanying suite of the class declaration, I’d add any
    methods I want to include in the object. An object is known as an *instance* of
    a class in Python. I’ll cover this in detail shortly.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: In Python, everything is an object, in that everything inherits from the `object`
    class. In Python 3, this inheritance from `object` is implicit, as seen in [Listing
    7-1](#listing7-1). In Python 2, you had to explicitly inherit from `object`, or
    from another class that inherits from `object`. (I cover inheritance in Chapter
    13. You can take it for granted here.)
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `SecretAgent` class declaration again, this time explicitly inheriting
    from `object`, as Python 2 would have required:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Listing 7-2: Initializing a class with explicit inheritance'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: Listings 7-1 and 7-2 are functionally identical. Python developers really hate
    *boilerplate code*, which is code that is widely reused, with little or no modification.
    That is why Python 3 added the shorter technique seen in [Listing 7-1](#listing7-1).
    Unless you need to support Python 2, the shorter technique is preferred. You’ll
    encounter both ways often enough, so it’s important to know that they do the exact
    same thing in Python 3.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: The Initializer
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A class often has an *initializer* method for defining the initial values of
    *instance attributes*, which are the member variables that exist in each instance.
    If your instance will have no instance attributes, you don’t need to define `__init__()`.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: 'I want each instance of `SecretAgent` to have a code name and a list of secrets.
    Here’s the initializer for my `SecretAgent` class, which has two instance attributes:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Listing 7-3: *secret_agent.py:1a*'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: The initializer must have the name `__init__` to be recognized as an initializer,
    and it must accept at least one argument, conventionally called `self`. This `self`
    argument references the instance the method is acting on.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I also accept a second argument, `codename`, which I use as the
    initial value of one of my instance attributes. This `self.codename` attribute
    will be the code name of the secret agent.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Instance attributes are part of the class instance itself, so I must access
    them through the dot (`.`) operator on `self`. All instance attributes should
    be declared in the initializer method, rather than on the fly in other instance
    methods. Therefore, I’m also defining `self._secrets` as an empty list. This will
    be a list of secrets the particular secret agent (instance) is keeping.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, an initializer must never return a value via the `return` keyword; if
    it does, calling the initializer will raise a `TypeError`. However, you may use
    `return` by itself to explicitly exit the method, if you ever need to.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever I create a new class instance, the initializer is automatically called.
    Here, I create three `SecretAgent` instances and provide arguments for the `codename`
    parameter of the initializer:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Listing 7-4: *secret_agent_usage.py:1*'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: In this module, I import my `SecretAgent` class and create three new instances.
    You’ll notice that I didn’t need to pass anything to the first parameter, `self`.
    That’s taken care of behind the scenes. Instead, my first argument, `"Mouse"`,
    is passed to the second parameter of the initializer, `codename`. Each instance
    also has its own empty `_secrets` list.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: The Constructor
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re coming from C++, Java, or some similar language, you may expect to
    write a *constructor*—a function that constructs an instance of a class—or you
    may think that the initializer does the same thing as a constructor. In fact,
    Python 3 splits the duties of a typical constructor between the initializer `__init__()`
    and the constructor `__new__()`.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the constructor `__new__()` takes care of actually creating the instance
    in memory. When you create a new instance, the constructor is automatically called
    first, followed by a call to the initializer. The constructor is the only method
    in the class to be called automatically before the object is created!
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t normally need to define a constructor; one is provided automatically.
    The only time you would create a constructor would be if you needed additional
    control over the process. However, to familiarize you with the syntax, I’ll write
    a very basic (and effectively pointless) constructor, which could go in a class
    definition:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The constructor always has the name `__new__`, and it implicitly accepts a class
    as its first parameter, `cls` (in contrast to the initializer, which accepts a
    class instance on `self`). Since the initializer accepts parameters, I also need
    to prepare the constructor to accept these on the constructor, so I use variadic
    arguments to capture these arguments and pass them on to the initializer parameters.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: The constructor must return the class instance that gets created. Technically,
    I could return whatever I wanted here, but the expected behavior would almost
    certainly be to return an instance that has been instantiated from the `SecretAgent`
    class. To do that, I call the `__new__` function on the parent class, which you
    may recall (from [Listing 7-2](#listing7-2)) is `object`. (I’ll return to `super()`
    in Chapter 13. Don’t worry about understanding it now.)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: In practice, if this is all your constructor needs to do, just omit it! Python
    automatically handles the constructor behavior if you don’t write any code for
    it. Only write a constructor when you need to control the behavior around instantiating
    the class instance itself. In any event, that scenario is rare; it is perfectly
    plausible that you will never write a constructor in your entire Python programming
    career.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: The Finalizer
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *finalizer* is called when a class instance finally reaches the end of
    its lifespan and is cleaned up by the garbage collector. It exists solely to handle
    any technically complex cleanup that your particular class may require. As with
    the constructor, you will seldom, if ever, need to write this function yourself.
    If you do, it’s important to understand: the finalizer is only called if the class
    instance (value) itself is cleaned up by the garbage collector!'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: If any references to the class instance still exist, the finalizer won’t be
    called; furthermore, depending on the implementation of Python you’re using, the
    garbage collector might not always clean up the class instance when you’d expect,
    if at all.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, only use the finalizer for code directly relating to garbage-collecting
    the class instance. It should never contain code that needs to be run as part
    of any other circumstance.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a rather useless finalizer that prints a message when the garbage collector
    cleans up a `SecretAgent` class instance:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Listing 7-5: *secret_agent.py:2*'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: A finalizer always has the name `__del__` and accepts a single parameter, `self`.
    It must not return anything.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this finalizer, I’ll create and manually delete an instance.
    It is possible to delete a name, thereby unbinding it from its value, by using
    the `del` keyword. Given the `SecretAgent` class with that finalizer method, I
    can create and then delete a name referring to a class instance:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Listing 7-6: *secret_agent_disavow.py*'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: I create a new instance from the `SecretAgent` class and bind it to the name
    `weasel`. Then, I immediately delete the name by using the `del` operator. The
    name `weasel` is now undefined again. Coincidentally, because no references remain
    to the `SecretAgent` instance the name was bound to, that instance is cleaned
    up by the garbage collector, which first calls the finalizer.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, running that code displays this output:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Note that `del` only deletes the name, not the value! If you have multiple names
    bound to the same value, and if you `del` one of those names, then the other names
    and their values will be unaffected. In other words, `del` will not force the
    garbage collector to delete the objects.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All variables belonging to a class or instance are called *attributes*. Attributes
    belonging to the instance itself are called *instance attributes*, which are also
    sometimes referred to as *member variables*. Attributes belonging to the class
    itself are *class attributes*, which are also sometimes called *class variables*.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: Many intermediate-level Python programmers don’t realize there is a significant
    difference between the two. I must admit, I spent the first few years of my Python
    development career using them utterly incorrectly!
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Instance Attributes
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *instance attribute* exists on the instance itself; its value is unique to
    the instance and is not available to other instances. All instance attributes
    should be declared in the class’s initializer.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting the `__init__()` method from [Listing 7-3](#listing7-3), you’ll
    see I have two instance attributes:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Class Attributes
  id: totrans-701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *class attribute* exists on the class, instead of on an individual instance.
    In practice, this means that all related class instances effectively “share” a
    class attribute, although it would exist even without any instances.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'Class attributes are declared at the top of the class, outside of any methods.
    Here, I add one class attribute directly into the suite of the class:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Listing 7-7: *secret_agent.py:1b*'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: The attribute `_codeword` belongs to the `SecretAgent` class. Typically, all
    class attributes are declared before any methods to make them easier to find,
    although this is just convention. The important part is that they are defined
    outside of any methods.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 'The class attribute can be accessed like this:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Listing 7-8: *secret_agent_usage.py:2a*'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: I can access the class attribute `_codeword` directly through the class, or
    through any instances instantiated from the class. If the class attribute is rebound
    or mutated on the class itself ❶, the changes will appear in all cases. However,
    if a value is assigned to the name on an instance, it will create an instance
    attribute with the same name ❷, which shadows the class attribute on that instance,
    without affecting other instances.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: Class attributes are particularly useful for constant values that the class’s
    methods use. I also find them more practical and maintainable than global variables
    in many cases, especially in GUI programming. For example, I often employ class
    attributes when I need to maintain a shared instance of a widget, like a window.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: Scope-Naming Conventions
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re coming from a language that has class scope, you may wonder why I
    haven’t mentioned it yet. Isn’t data hiding an important part of encapsulation?
    In fact, Python has no formal concept of data hiding. Instead, PEP 8 outlines
    a naming convention that indicates whether an attribute is safe to modify externally
    (public) or not (nonpublic).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: While I talk a lot about attributes in this section, these naming conventions
    apply to methods as well.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: Nonpublic
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By preceding a name with an underscore, I declare that the attribute `_secrets`
    is intended to be *nonpublic*, meaning it shouldn’t be modified (or, ideally,
    accessed) outside of the class. This is more of a social contract via style convention;
    I’m not actually hiding anything.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: This may seem dangerous to many developers coming from languages with explicit
    scope, like Java, but it works out pretty well. As my pal “grym” likes to put
    it, “If you know why you shouldn’t stick a fork in a toaster, you are therefore
    qualified to stick a fork in a toaster.” In other words, if the client is going
    to disregard the underscore warning label, they probably know what they’re doing.
    (On the off-chance they don’t, they’re fully responsible for the consequences.)
    That little underscore hanging out after the dot operator is advertising “You
    really shouldn’t mess with me!”
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: Public
  id: totrans-718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The attribute `codename`, which does not start with an underscore, is intended
    to be *public*. It is okay for this attribute to be accessed or modified externally,
    as it won’t really affect the behavior of the class. Public attributes are preferable
    to writing a plain getter/setter pair of methods; the behavior is the same, but
    the result is cleaner, with less boilerplate.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: If an attribute needs a custom getter or setter, one approach is to define the
    attribute as nonpublic and create a public *property*, which I’ll come back to
    shortly.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: Name Mangling
  id: totrans-721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python does offer *name mangling*, which rewrites an attribute or method name
    to prevent it from being shadowed by derived (inheriting) classes. This provides
    a sort of weak form of data hiding. It can also be useful for an added level of
    forewarning: “No, *really*, if you mess with this attribute, terrible things will
    happen!”'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark an attribute (or method) for name mangling, precede the name with two
    underscores (`__`), like this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Listing 7-9: *message.py:1*'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__format` attribute will be name mangled, so accessing it externally in
    the ordinary manner will not work:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Listing 7-10: *message.py:2*'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 'This will raise an `AttributeError` because the `msg` instance does not have
    an attribute named `__format`; the name of that attribute was mangled. Be aware
    that name mangling is *not* a true form of data hiding! It is still perfectly
    possible to access a name-mangled attribute:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Listing 7-11: *message.py:3*'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: 'The name-mangling pattern is predictable: an underscore, the name of the class,
    and then the name of the attribute, with its two leading underscores.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: Public, Nonpublic, or Name Mangled?
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When deciding whether to make an attribute public or nonpublic, I ask myself
    one question: could changing this attribute externally cause unexpected or negative
    behavior in the class? If the answer is yes, I make the attribute nonpublic by
    preceding it with an underscore. If the answer is no, I leave the attribute public.
    It is up to the coder using the class to respect the rules or suffer the consequences.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: As to name mangling, in practice, I very rarely employ this pattern. I reserve
    it only for those cases where (a) I need to avoid a naming conflict in the context
    of inheritance or (b) external access of the attribute will have exceptionally
    horrific effects on the behavior of the class, and thus, an extra degree of warning
    is justified.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: Always remember that Python does not have private class scope. Truly secret
    data should be properly encrypted, not just concealed from your API. There are
    also no optimization benefits to private class scope, unlike in languages like
    Java, since all attribute lookups occur at runtime.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  id: totrans-737
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class is nothing without its methods, which make encapsulation possible.
    There are three distinct types of methods: instance methods, class methods, and
    static methods.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: Instance Methods
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Instance methods* are your run-of-the-mill methods, which exist on the instance
    itself. The first parameter, conventionally named `self`, provides access to the
    instance attributes of the instance.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I add an instance method to my `SecretAgent` class:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Listing 7-12: *secret_agent.py:3*'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: Besides the required first parameter, the instance method accepts a second parameter,
    `secret`, which is appended to the list bound to the instance attribute `_secrets`.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'I call this method on the instance, using the dot operator:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Listing 7-13: *secret_agent_usage.py:2b*'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: The dot operator implicitly passes `mouse` to the `self` parameter, so my first
    argument, the tuple of coordinates (notice the extra set of parentheses), is passed
    to the second parameter, `secret`, on the `remember()` method.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: Class Methods
  id: totrans-749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like class attributes, *class methods* belong to the class, instead of to the
    instances instantiated from the class. These are useful for working with class
    attributes.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in [Listing 7-7](#listing7-7), I defined `_codeword` as a class attribute
    so all `SecretAgent` instances would be aware of the code word; it’s something
    all agents should have in common. I need a way to inform all the agents at once
    of the new code word, so I’ll add a class method, `inform()`, which will modify
    the `_codeword` class attribute:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Listing 7-14: *secret_agent.py:4*'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: I precede a class method with the built-in `@classmethod` decorator. A class
    method receives the class as its first argument, so the first parameter is named
    `cls`. Class attributes like `_codeword` are accessed on the class passed to `cls`.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of this approach is that I don’t have to worry about whether
    I’m calling `inform()` on the class or on an instance. Because the method is a
    class instance, it will always access the class attribute on the class (`cls`),
    instead of the instance (`self`), and thus avoid accidentally shadowing `_codeword`
    on a single instance (see [Listing 7-8](#listing7-8)).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: I don’t plan to include a getter for this attribute. After all, secret agents
    have to keep secrets!
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this method, I would call something like this:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Listing 7-15: *secret_agent_usage.py:3*'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: I can call the `inform()` class method directly on the `SecretAgent` class,
    or on any `SecretAgent` instance, such as `fox`. The changes that `inform()` makes
    to the class attribute `_codeword` appear on the class itself and all its instances.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: When calling the class method with the dot operator, the class is implicitly
    passed to the `cls` parameter. That parameter name is still just a convention;
    the `@classmethod` decorator is what ensures that the first argument is always
    the class, never the instance.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: One awesome use of class methods is to provide alternative means of initializing
    instances. For example, the built-in integer class offers `int.from_bytes()`,
    which initializes a new `int` class instance, using a `bytes` value.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: Static Methods
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *static method* is a regular function defined within a class, which accesses
    neither the instance attributes nor the class attributes. The only difference
    between a static method and a function is that a static method belongs to the
    class for namespace reasons.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: The main reason to write a static method comes up when your class offers some
    functionality that doesn’t need to access any of the class or instance attributes
    or methods. For example, you may write a static method for handling some particularly
    complicated algorithm that is critical to your class’s implementation. By including
    the static method in the class, you are indicating that the algorithm is part
    of the class’s self-contained implementation logic, even though it does not access
    any attributes or methods.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll add a static method to the `SecretAgent` class, which handles one thing
    all the agents would do the same, regardless of their data—answer questions:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Listing 7-16: *secret_agent.py:5*'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: I precede the static method with the `@staticmethod` decorator. You’ll notice
    that I don’t need to worry about a special first parameter, since the method doesn’t
    need access to any attributes. When this method is called on a class or on an
    instance, it only prints out the message, “I know nothing.”
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Properties* constitute a special variety of instance method that allows you
    to write getters and setters that behave so it appears that you were directly
    accessing an instance attribute. Properties allow you to write a consistent interface,
    where you use the object directly through what appear to be its attributes.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: It is preferable to use properties, instead of making the user remember whether
    to call a method or use an attribute. Using properties is also much more Pythonic
    than cluttering your class with bare getters and setters that don’t augment attribute
    access or modification.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Scenario
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate properties in action, I’ll expand on my `SecretAgent` class.
    Here’s the class so far. First, to set up, I’ll move it to a new file:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Listing 7-17: *secret_agent_property.py:1*'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I will add one more class method to encrypt whatever message is passed
    to it, using an encryption system of my own devising. This method has nothing
    to do with properties per se, but I include it to make the example complete:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Listing 7-18: *Using a property with no getter*'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: The `_encrypt()` class method uses the `_codeword` class attribute to perform
    a basic substitution cipher encoding on a string `message`. I use `sum()` to find
    the sum of the Unicode code points (as integers) for each character in `_codeword`.
    I pass a character (string) to the `ord()` function, which returns the Unicode
    code point as an integer. This sum of code points is bound to `code`. (The odd-looking
    loop here is actually a generator expression, which I’ll cover in Chapter 10.
    You can take it for granted here that it calls `ord()` on each character in the
    string bound to `cls._codeword`.)
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: I use `code` to offset the Unicode code point of each character in the message.
    The `chr()` function returns the character associated with the given code point.
    I pass to it the sum of the current code point and `code`, for each character
    in the message. (Once again, I’m employing a generator expression here.)
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Property
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *property* behaves like an attribute, but it is made up of three instance
    methods: a *getter*, a *setter*, and a *deleter*. Remember that a property appears
    to be an ordinary attribute to the user of the class. Accessing the property calls
    the getter, assigning a value to it calls the setter, and deleting the property
    with the `del` keyword calls the deleter.'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: Like an ordinary getter or setter method, a property might access or modify
    a nonpublic attribute, multiple attributes, or even no attributes at all. It all
    depends on what behavior you want.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: Here, I’ll define a property called `secret` for my `SecretAgent` class, which
    will serve as the getter, setter, and deleter for my `_secrets` instance attribute.
    This approach will allow me to add logic, such as having the setter encrypt the
    assigned data before storing it in the `_secrets` attribute.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: Before defining the property itself, I need to define the three functions that
    will make up the property. Technically, I can call them whatever I like, but the
    convention is to name them `getx`, `setx`, or `delx`, where `x` is the name of
    the property. I’m also making these nonpublic methods, since I want the client
    to use the property directly.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the getter:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Listing 7-19: *secret_agent_property.py:3*'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: The getter, `_getsecret()`, accepts no parameters and should return the value
    of the property. In this example, I want the getter to return the last item stored
    in the list bound to the instance attribute `self._secrets`, or if the list is
    empty, to return `None`.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the setter:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Listing 7-20: *secret_agent_property.py:4*'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: The setter, `_setsecret()`, accepts a single parameter, which receives the value
    being assigned to the property in the call (see [Listing 7-23](#listing7-23)).
    In this case, I assume this is some sort of string, which I run through the static
    method `_encode()` I defined earlier and then store in the list `self._secrets`.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here’s the deleter:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Listing 7-21: *secret_agent_property.py:5*'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: The *deleter*, `_delsecret()`, accepts no parameters and returns no value. This
    method is called when the property is deleted, either in the background, by the
    garbage collector, or explicitly, with `del secret`. In this example, when the
    property is deleted, I want the entire list of secrets to be cleared.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: You actually don’t need to define a deleter if you have no need for special
    behavior when the decorator is deleted. Consider what you want to happen if `del`
    is called on your decorator, such as when you are deleting an associated attribute
    that the property controls; if you can’t think of anything, skip writing the deleter.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I define the property itself:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Listing 7-22: *secret_agent_property.py:6a*'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: This is defined on the class itself, outside of the `__init__()` method and
    after the functions that make it up. I pass the three methods to the `fget`, `fset`,
    and `fdel` keyword arguments, respectively (although you can also pass them as
    positional arguments, in that same order). I bind the property to the name `secret`,
    which becomes the property name.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: 'The property can now be used as if it were an instance attribute:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Listing 7-23: *secret_agent_property.py:7a*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: Every time I try to retrieve the value of the property, the getter is called.
    Meanwhile, assigning a value to the property calls the setter. There’s no need
    to remember and explicitly call dedicated getter or setter methods; I treat the
    property like an attribute.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: You’ll recall that the deleter for `secrets` clears the contents of the `_secrets`
    list. Just before deleting the property, the list contains two secrets. After
    deleting, the list is empty.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to define all three parts of the property. For example,
    I don’t want the `secret` property to even have a getter, so I can remove `_getsecret()`
    from my class code. Secret agents shouldn’t share their secrets, after all.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Listing 7-24: A secret property with no getter'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: Because I don’t pass an argument to `fget`, the default value of `None` is used
    instead ❶. This property has a setter and a deleter, but no getter.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, I can assign to `secret`, but I can’t access the value:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Listing 7-25: *Using a property with no getter*'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to `mouse.secret` works as before, since that calls the setter.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: 'However, attempting to access the value throws an `AttributeError`. I could
    instead have written a getter for secrets that always returned `None`, but the
    client would have to remember that it returned this useless value. Recall The
    Zen of Python:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: Errors should never pass silently.
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  id: totrans-820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a particular usage is not desired, especially when it comes to designing
    a class or interface, the usage should *explicitly fail*.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: Property with Decorators
  id: totrans-822
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a property is easy enough, but the approach to implementing it that
    I’ve shown thus far doesn’t really feel very Pythonic, because I have to rely
    on my method names to remind me that they’re part of a property. Thankfully, there’s
    another way.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: 'Python offers a cleaner approach to defining properties: with decorators. There
    are two approaches to this technique.'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: 'Approach 1: property() and Decorators'
  id: totrans-825
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first approach is to still employ the `property()` function but use decorators
    to denote the associated methods. The chief benefit of this approach is the added
    readability, and it is mainly used when the getter will be omitted. I can use
    the name of the property as the method name and rely on the decorator to clarify
    its role.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my rewritten code for the `secret` property, using this approach:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Listing 7-26: *secret_agent_property.py:3b*'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: 'In this approach, I define `secret` as a property before writing its methods.
    I pass no arguments to `property()`, so all three functions default to `None`.
    Next, I add the getter:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Listing 7-27: *secret_agent_property.py:4b*'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: My getter method now must have the same name as the property, `secret`. If it
    doesn’t, it will fail with an `AttributeError` when the getter is first called,
    rather than when the class is created. The method is preceded by the decorator
    `@secret.getter`. This designates it as the getter for the property, just as if
    I had passed it to `property(fget=)`.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the setter:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Listing 7-28: *secret_agent_property.py:5b*'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the setter method must share its name with the property it relates
    to, and it is preceded by the decorator `@secret.setter`.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the deleter:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Listing 7-29: *secret_agent_property.py:6b*'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the getter and setter, the deleter is preceded by the decorator `@secret.deleter`.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: This version works as is, but there is an even better technique.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: 'Approach 2: Decorators Without property()'
  id: totrans-843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second approach to declaring a property with decorators is even shorter,
    and it is the most commonly used. This approach is preferred when defining a property
    that has a getter.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have defined a getter, you don’t have to explicitly create and assign
    a `property()`. Instead, the decorator `@property` can be applied to the getter:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: I precede the getter function with the decorator `@property`, instead of `@secret.getter`,
    which creates a property with the same name as the method. Since this defines
    the property `secret`, I don’t need `secret = property()` anywhere in my code.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind, this shortcut only works with the getter method. The setter and
    deleter must be defined in the same manner as before.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, I can omit any of the three methods if their behavior is not desired.
    For example, if I don’t want `secret` to be readable, I omit the getter, so my
    full property code looks like this:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Because I don’t have a getter, I must explicitly declare my property up front
    ❶. In this version, assignment and deletion of `secret` works as before, but accessing
    the value raises an `AttributeError`.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: When Not to Use Properties
  id: totrans-852
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s some debate about when to use properties, versus traditional getter
    and setter methods. One of the chief drawbacks of properties is that they conceal
    that some calculation or processing is being performed upon assignment, which
    the client might not expect. This especially becomes a problem if this processing
    is particularly long or complicated, such that a client may need to run it concurrently
    with `async` or threads (see Chapters 16 and 17); you cannot run an assignment
    concurrently with the same ease as running a method concurrently.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: You must also consider the expected behavior of an assignment. When a value
    is directly assigned to an attribute, you would typically expect the same value
    to be retrievable *from* that attribute. In reality, depending on how you wrote
    your properties, the value might be transformed when assigned or accessed. You’ll
    need to take this client expectation into consideration when designing your class.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: Some camps believe properties should only be used as a way of deprecating attributes
    that used to be public or that have been removed entirely. Others, like myself,
    find properties useful as replacements for otherwise relatively simplistic getters
    and setters that still involve more logic than plain assignment and access.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: In any case, properties are some of those cool features of Python that are all
    too easy to misuse or misapply. Carefully consider the implications of properties,
    public attributes, or methods in your specific case. Take the occasion to consult
    the advice of other experienced Python developers, such as in the Libera.Chat
    IRC `#python` channel. (If you want to debate the most Pythonic general position
    on properties, though, bring a helmet.)
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: Special Methods
  id: totrans-857
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Special methods are my favorite part of Python object-oriented programming.
    I’m trembling a little with excitement right now (or maybe I had too much coffee).
    *Special methods*, sometimes called *magic methods*, allow you to add support
    to your classes for virtually any Python operator or built-in command!
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: 'Special methods are also colloquially known as *dunder methods*—which is short
    for “***d***ouble ***under***score”—because they begin and end with two underscore
    characters (`__`). You’ve already seen three examples of special methods: `__init__()`,
    `__new__()`, and `__del__()`. The Python language defines about a hundred special
    methods, most of which are documented at [https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html).
    I’ll cover a number of the most common ones here. In future chapters, I’ll discuss
    other special methods as they become relevant. I also list all the special methods
    in Python in Appendix A.'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: Scenario Setup
  id: totrans-860
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the examples in this section, I’ll use a new class, `GlobalCoordinates`,
    which will store a global coordinate as latitude and longitude. This class is
    defined as follows:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Listing 7-30: *global_coordinates.py:1*'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: You can probably work out what’s going on here, based on the knowledge you have
    so far. The class `GlobalCoordinates` converts and stores a latitude and longitude
    as tuples of degrees, minutes, seconds, and a string literal representing a cardinal
    direction.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: I chose to create this particular class because its data lends itself well to
    a healthy subset of the special methods I’ll cover.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: Conversion Methods
  id: totrans-866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to represent the same data, and most clients will expect
    to be able to convert an object containing data to any Python primitive type that
    makes sense. For example, global coordinates could be expressed as strings or
    hashes. You should carefully consider what data types your class should support
    conversion to. Here, I cover some special methods for data conversions.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: 'Canonical String Representation: __repr__()'
  id: totrans-868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When writing a class, it is considered good practice to define, at minimum,
    the `__repr__()` instance method, which returns the *canonical string representation*
    of the object. This string representation should ideally contain all the data
    necessary to create another class instance with the same contents.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: 'If I don’t define a `__repr__()` instance method for `GlobalCoordinates`, Python
    falls back on its default version for objects, which is pretty uselessly underwhelming.
    I’ll create an instance of `GlobalCoordinates` and print this default representation
    via `repr()`:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Listing 7-31: *global_coordinates_usage.py:1*'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that prints out the following canonical string representation:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Not good for much, is it? Instead, I’ll define my own `__repr__()` instance
    method for the class:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Listing 7-32: *global_coordinates.py:2*'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: 'I return a string containing all the information needed to recreate the instance:
    the class name, the latitude, and the longitude.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerunning the code in [Listing 7-31](#listing7-31) now produces more useful
    information:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Human-Readable String Representation: __str__()'
  id: totrans-881
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__str__()` special method has a similar purpose to `__repr__()`, except
    that it’s meant to be human-readable, as opposed to the more technically inclined
    canonical representation, which is more useful for debugging.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t define `__str__()`, the `__repr__()` function will be used instead,
    but that wouldn’t be desirable in this example. The user should only see the pretty
    coordinates!
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my `__str__()` instance method for `GlobalCoordinates`:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Listing 7-33: *global_coordinates.py:3*'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with `__repr__()`, I omit all that boring technical information and focus
    on composing and returning a string representation a user might want to see.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is called when an instance of the class is passed to `str()`, although
    passing the instance directly to `print()` or as an expression in a formatted
    string will also invoke `__str__()`. For example:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Listing 7-34: *global_coordinates_usage.py:2*'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Lovely and readable!
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: 'Unique Identifier (Hash): __hash__()'
  id: totrans-894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__hash__()` method typically returns a *hash value*, which is an integer
    that is unique to the data within the class instance. This allows you to use instances
    of the class in certain collections, such as keys in a dictionary or values in
    a set (see Chapter 9). It’s often helpful to write this method yourself, as the
    default behavior results in every class instance having a unique hash value, even
    if two instances contain the exact same data.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: The `__hash__()` method should only depend on values that won’t change for the
    life of the instance! Several collections rely on these hash values *never changing*,
    but the value of a mutable object might change.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my `__hash__()` function for `GlobalCoordinates`:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Listing 7-35: *global_coordinates.py:4*'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: I’ve taken the most common approach, which is to create a tuple containing all
    the important instance attributes and then to call `hash()` on the tuple, which
    returns the hash value of whatever is passed to it. I then return that hash value.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: Additional Conversion Special Methods
  id: totrans-901
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python has special methods for converting the data in the instance to other
    forms. It is up to you to decide which of these you will define on your class:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '`__bool__()` should return `True` or `False`. If this isn’t defined, the automatic
    conversion to a boolean value will check whether `__len__()` returns a nonzero
    value (see Chapter 9); otherwise, `True` will always be used.'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__bytes__()` should return a `bytes` object (see Chapter 12).'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ceil__()` should return an `int` numeric value, usually resulting from rounding
    up a `float` value to the nearest integer.'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__complex__()` should return a `complex` numeric value.'
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__float__()` should return a `float` numeric value.'
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__floor__()` should return an `int` numeric value, usually resulting from
    rounding down a `float` numeric value to the nearest integer.'
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__format__()` should accept a string representing the format specification
    (see Chapter 3) and return a string representation of the instance, with the specification
    applied. How exactly you apply the specification is up to you.'
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__index__()` should return the same value as `__int__()`, which must also
    be defined if you write this method. The presence of this method indicates that
    the class should be considered a type of integer; you don’t have to throw away
    any data to get the integer value (lossless conversion).'
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__int__()` should return an `int` numeric value. You may simply have this
    function call `__ceil__()`, `__floor__()`, `__round__()`, or `__trunc__()`.'
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__round__()` should return an `int` numeric value, usually resulting from
    rounding a `float` numeric value up or down.'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__trunc__()` should return an `int` numeric value, usually resulting from
    dropping the non-whole (decimal) part of a `float` numeric value.'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You only need to define the special methods that make sense for your class.
    In my case, *none* of these additional conversion methods are particularly suitable
    for a pair of global coordinates.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Methods
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python has six comparison special methods that correspond to the six comparison
    operators in Python: `==`, `!=`, `<`, `>`, `<=`, and `>=`. Each one conventionally
    returns a boolean value.'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: If one of these special methods is called, but the method isn’t defined, the
    class instance will return the special value `NotImplemented` to alert Python
    that the comparison didn’t happen. This allows the language to decide the best
    response. In the case of comparisons with built-in types, `NotImplemented` will
    be coerced to the boolean value `False`, so as to not break algorithms that rely
    on those functions. In most other situations, a `TypeError` will be raised.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: 'Equals: __eq__()'
  id: totrans-918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `__eq__()` special method is called by the equals (`==`) operator. I’ll
    define this method for my `GlobalCoordinates` class:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Listing 7-36: *global_coordinates.py:5*'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: 'All comparison special methods accept two parameters: `self` and `other`. These
    represent the operands on the left and right of the operator, so `a == b` would
    call `a.__eq__(b)`.'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: In the ongoing example, it would only make sense to compare two `GlobalCoordinates`
    class instances to one another. Comparing a `GlobalCoordinates` instance directly
    to an integer or a float wouldn’t be logical. Thus, this is one of those rare
    scenarios where type matters. I use `isinstance()` to ensure `other` is an instance
    of the `GlobalCoordinates` class (or a subclass thereof) ❶. If it is, I compare
    the instance attributes that constitute the latitude and longitude of one `GlobalCoordinates`
    instance to the same attributes of the other instance. I return `True` if they
    all match.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: However, if `other` is of a different type, the comparison doesn’t happen, so
    I return the special value `NotImplemented` ❶.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: 'Not Equals: __ne__()'
  id: totrans-925
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__ne__()` special method corresponds to the not-equals (`!=`) operator.
    If undefined, a call to `__ne__()` *delegates* to `__eq__()`, just returning the
    opposite value that `__eq__()` does. If this is what you’re expecting, there’s
    no need to define `__ne__()`.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: However, if there’s more complex logic to your not-equals comparison, it might
    make sense to define it.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: 'Less Than and Greater Than: __lt__() and __gt__()'
  id: totrans-928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The special methods `__lt__()` and `__gt__()` correspond to the less-than (`<`)
    and greater-than (`>`) operators, respectively. These two special methods are
    *reflections* of one another, meaning one operator in the pair can be substituted
    for the other. The expression `a < b` calls `a.__lt__(b)`, but if that returns
    ``NotImplemented, Python automatically flips the logic and calls `b.__gt__(a)`.
    Thus, if you’re only comparing instances of the same class, you can often get
    away with defining just one of the two special methods: usually, `__lt__()`. The
    same is true of `__le__()` and `__ge__()`, which correspond to less-than-or-equal-to
    (`<=`) and greater-than-or-equal-to (`>=`).``'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]  def __sub__(self, other):         if not isinstance(other, GlobalCoordinates):             return
    NotImplemented          lat_diff = self.latitude - other.latitude         lon_diff
    = self.longitude - other.longitude         return (lat_diff, lon_diff) [PRE165]  def
    __invert__(self):         return GlobalCoordinates(             latitude=self.degrees_from_decimal(-self.latitude,
    lat=True),             longitude=self.degrees_from_decimal(-self.longitude, lat=False)         )
    [PRE166]  def __call__(self, ❶ other):         EARTH_RADIUS_KM = 6371          distance_lat
    = math.radians(other.latitude - self.latitude)         distance_lon = math.radians(other.longitude
    - self.longitude)         lat = math.radians(self.latitude)         lon = math.radians(self.longitude)         a
    = (             math.sin(distance_lat / 2)             * math.sin(distance_lat
    / 2)             + math.sin(distance_lon)             * math.sin(distance_lon
    / 2)             * math.cos(lat)             * math.cos(lon)         )         c
    = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))        ❷ return c * EARTH_RADIUS_KM
    [PRE167] nostarch = GlobalCoordinates(latitude=(37, 46, 32.6, "N"),                              longitude=(122,
    24, 39.4, "W"))  psf = GlobalCoordinates(latitude=(45, 27, 7.7, "N"),                         longitude=(122,
    47, 30.2 "W"))  distance = nostarch(psf) print(distance)  # 852.6857266443297
    [PRE168] class CoffeeOrder:      def __init__(self, recipe, to_go=False):         self.recipe
    = recipe         self.to_go = to_go      def brew(self):         vessel = "in
    a paper cup" if self.to_go else "in a mug"         print("Brewing", *self.recipe.parts,
    vessel)   class CoffeeRecipe:      def __init__(self, parts):         self.parts
    = parts   special = CoffeeRecipe(["double-shot", "grande", "no-whip", "mocha"])
    order = CoffeeOrder(special, to_go=False) order.brew()  # prints "Brewing double-shot
    grande no-whip mocha in a mug" [PRE169] import functools ❶ def auto_order(to_go):     def
    decorator(cls):         @functools.wraps(cls)         def wrapper(*args, **kwargs):          ❷
    recipe = cls(*args, **kwargs)          ❸ return (CoffeeOrder(recipe, to_go), recipe)         return
    wrapper   ❹ return decorator [PRE170] @auto_order(to_go=True) class CoffeeShackRecipe(CoffeeRecipe):     pass   order,
    recipe = CoffeeShackRecipe(["tall", "decaf", "cappuccino"]) order.brew()  # prints
    "Brewing tall decaf cappuccino in a paper cup" [PRE171] class Pizza:      def
    __init__(self, topping, second_topping=None):         self.first = topping         self.second
    = second_topping  order = Pizza("pepperoni", "mushrooms")  match order:     case
    Pizza(first=''pepperoni'', second=''mushroom''):         print("ANSI standard
    pizza")     case Pizza(first=''pineapple''):         print("Is this even pizza?")
    [PRE172] # `--snip--`  match order:   # `--snip--`     case Pizza(first=''pineapple''):         print("Is
    this even pizza?")  **case Pizza(first=first, second=''cheese''):**  **print(f"Very
    cheesy pizza with {first}.")** [PRE173] # `--snip--`  match order:   # `--snip--`  `case
    Pizza(first=first, second=''cheese''):`  `print(f"Very cheesy pizza with {first}.")`  **case
    Pizza(first=first, second=second):**  **print(f"Pizza with {first} and {second}.")**
    [PRE174] class Point:     def __init__(self, x, y, z):         self.x_pos = x         self.y_pos
    = y         self.z_pos = z   point = Point(0, 100, 0)  match point:     case Point(x_pos=0,
    y_pos=0, z_pos=0):         print("You are here.")     case Point(x_pos=0, y_pos=_,
    z_pos=0):         print("Look up!") [PRE175] class Point:  **__match_args__ =
    (''x_pos'', ''y_pos'', ''z_pos'')**      def __init__(self, x, y, z):         self.x_pos
    = x         self.y_pos = y         self.z_pos = z   point = Point(0, 123, 0)  match
    point:     case Point(**0, 0, 0**):         print("You are here.")     case Point(**0,
    _, 0**):         print("Look up!") [PRE176] thing.action()  # this can mutate
    attributes in thing [PRE177] action(thing)  # should not modify thing; returns
    new value or object [PRE178]`  [PRE179] import random   def generate_puzzle(low=1,
    high=100):     print(f"I''m thinking of a number between {low} and {high}...")     return
    random.randint(low, high) [PRE180] def make_guess(target):     guess = int(input("Guess:
    "))      if guess == target:         return True      if guess < target:         print("Too
    low.")     elif guess > target:         print("Too high.")     return False [PRE181]
    def play(tries=8):     target = generate_puzzle()     while tries > 0:         if
    make_guess(target):             print("You win!")             return   tries -=
    1         print(f"{tries} tries left.")      print(f"Game over! The answer was
    {target}.") [PRE182] if __name__ == ''__main__'':     play() [PRE183] I''m thinking
    of a number between 1 and 100... Guess: 50 Too low. 7 tries left. Guess: 75 Too
    low. 6 tries left. Guess: 90 Too high. 5 tries left. Guess: 87 You win! [PRE184]
    I''m thinking of a number between 1 and 100... Guess: Fifty Traceback (most recent
    call last):   File "./number_guess.py", line 35, in <module>     play()   File
    "./number_guess.py", line 25, in play     if make_guess(target):  File "./number_guess.py",
    line 10, in make_guess     guess = int(input("Guess: ")) ValueError: invalid literal
    for int() with base 10: ''Fifty'' [PRE185] ValueError: invalid literal for int()
    with base 10: ''Fifty'' [PRE186]  File "./number_guess.py", line 10, in make_guess     guess
    = int(input("Guess: ")) [PRE187]  File "./number_guess.py", line 25, in play     if
    make_guess(target): [PRE188]  File "./number_guess.py", line 35, in <module>     play()
    [PRE189] Traceback (most recent call last): [PRE190] def make_guess(target):     **guess
    = None**     **while guess is None:**         **try:**             guess = int(input("Guess:
    "))         **except ValueError:**             **print("Enter an integer.")**      if
    guess == target:         return True      if guess < target:         print("Too
    low.")     elif guess > target:         print("Too high.")     return False [PRE191]
    def make_guess(target):     guess = None     while guess is None:         guess
    = input()         **if guess.isdigit():**             guess = int(guess)         **else:**             print("Enter
    an integer.")             guess = None      if guess == target:         return
    True      if guess < target:         print("Too low.")     elif guess > target:         print("Too
    high.")     return False [PRE192] class AverageCalculator:      def __init__(self):         self.total
    = 0         self.count = 0      def __call__(self, *values):         if values:             for
    value in values:                 self.total += float(value)                 self.count
    += 1         return self.total / self.count [PRE193] average = AverageCalculator()
    values = input("Enter scores, separated by spaces:\n    ").split() try:     print(f"Average
    is {average(*values)}") except ❶ ZeroDivisionError:     print("ERROR: No values
    provided.") except ( ❷ ValueError, ❸ UnicodeError):     print(f"ERROR: All inputs
    should be numeric.") [PRE194] try:     some_scary_function() except:     print("An
    error occurred. Moving on!") [PRE195] def greet():     name = input("What''s your
    name? ")     print(f"Hello, {name}.")   while True:     try:         greet()         break     except:         print("Error
    caught") [PRE196] What''s your name? ^CError caught What''s your name? ^CError
    caught What''s your name? ^CError caught What''s your name?  [PRE197] def greet():     name
    = input("What''s your name? ")     print(f"Hello, {name}.")   while True:     try:         greet()         break  **except
    Exception:**         print("Error caught") [PRE198] def average(number_string):     total
    = 0     skip = 0     values = 0     for n in number_string.split():         values
    += 1       ❶ try:             total += float(n)       ❷ except ValueError:             skip
    += 1 [PRE199]  ❸ if skip == values:         raise ValueError("No valid numbers
    provided.")     elif skip:         print(f"<!> Skipped {skip} invalid values.")      return
    total / values [PRE200] while True:     line = input("Enter numbers (space delimited):\n    ")     avg
    = average(line)     print(avg) [PRE201] Enter numbers (space delimited):     4
    5 6 7  5.5 [PRE202] Enter numbers (space delimited):     four five 6 7 <!> Skipped
    2 invalid values. 3.25 [PRE203] Enter numbers (space delimited):     four five
    six seven Traceback (most recent call last):   File "./raiseexception.py", line
    25, in <module>     avg = average(line)   File "./raiseexception.py", line 16,
    in average     raise ValueError("No valid numbers provided.") ValueError: No valid
    numbers provided. [PRE204] while True:     **try:**         line = input("Enter
    numbers (space delimited):\n    ")         avg = average(line)  print(avg)     **except
    ValueError:**         **print("No valid numbers provided.")** [PRE205] Enter numbers
    (space delimited):     four five six No valid numbers provided. Enter numbers
    (space delimited):     4 5 6 5.0 [PRE206] friend_emails = {     "Anne": "anne@example.com",     "Brent":
    "brent@example.com",     "Dan": "dan@example.com",     "David": "david@example.com",     "Fox":
    "fox@example.com",     "Jane": "jane@example.com",     "Kevin": "kevin@example.com",     "Robert":
    "robert@example.com" } [PRE207] def lookup_email(name):     try:         return
    friend_emails[name]  except KeyError ❶ as e:         print(f"<No entry for friend
    {e}>") [PRE208] name = input("Enter name to look up: ") email = lookup_email(name)
    print(f"Email: {email}") [PRE209] Enter name to look up: Jason <No entry for friend
    ''Jason''> Email: None [PRE210] import logging from operator import add, sub,
    mul, truediv import sys [PRE211] logging.basicConfig(filename=''log.txt'', level=logging.INFO)
    [PRE212] def calculator(a, b, op):     a = float(a)     b = float(b)     if op
    == ''+'':         return ❶ add(a, b)     elif op == ''-'':         return sub(a,
    b)     elif op == ''*'':         return mul(a, b)     elif op == ''/'':         return
    truediv(a, b)     else:       ❷ raise NotImplementedError(f"No operator {op}")
    [PRE213] print("""CALCULATOR Use postfix notation. Ctrl+C or Ctrl+D to quit. """)  ❶
    while True:   ❷ try:         equation = input(" ").split()         result = calculator(*equation)         print(result)
    [PRE214]  except NotImplementedError as e:         print("<!> Invalid operator.")         logging.info(e)
    [PRE215]  except ValueError as e:         print("<!> Expected format: <A> <B>
    <OP>")         logging.info(e) [PRE216]  except TypeError as e:         print("<!>
    Wrong number of arguments. Use: <A> <B> <OP>")         logging.info(e) [PRE217]  except
    ZeroDivisionError as e:         print("<!> Cannot divide by zero.")         logging.info(e)
    [PRE218]  except (KeyboardInterrupt, EOFError):         print("\nGoodbye.")         sys.exit(0)
    [PRE219] CALCULATOR Use postfix notation. Ctrl+C or Ctrl+D to quit.   11 31 +
    42.0  11 + 31 <!> Expected format: <A> <B> <OP>  11 + 31 + 10 <!> Wrong number
    of arguments. Use: <A> <B> <OP>  11 + <!> Wrong number of arguments. Use: <A>
    <B> <OP>  10 0 / <!> Cannot divide by zero.  10 40 @ <!> Invalid operator.  ^C
    Goodbye. [PRE220] INFO:root:could not convert string to float: ''+'' INFO:root:calculator()
    takes 3 positional arguments but 5 were given INFO:root:calculator() missing 1
    required positional argument: ''op'' INFO:root:float division by zero INFO:root:No
    operator @ [PRE221]  except Exception as e:         logging.exception(e)       ❶
    raise [PRE222] cities = {     "SEATTLE": "WASHINGTON, USA",     "PORTLAND": "OREGON,
    USA",     "BOSTON": "MASSACHUSETTS, USA", }  landmarks = {     "SPACE NEEDLE":
    "SEATTLE",     "LIBERTY SHIP MEMORIAL": "PORTLAND",     "ALAMO": "SAN ANTONIO",
    } [PRE223] def lookup_landmark(landmark):     landmark = landmark.upper()     try:         city
    = landmarks[landmark]         state = cities[city]   ❶ except KeyError as e:       ❷
    raise KeyError("Landmark not found.") from e     print(f"{landmark} is in {city},
    {state}") [PRE224] lookup_landmark("space needle") lookup_landmark("alamo") lookup_landmark("golden
    gate bridge") [PRE225] SPACE NEEDLE is in SEATTLE, WASHINGTON, USA Traceback (most
    recent call last):   File "./chaining.py", line 18, in lookup_landmark     state
    = cities[city] ❶ KeyError: ''SAN ANTONIO''  ❷ The above exception was the direct
    cause of the following exception:  Traceback (most recent call last):  File "./chaining.py",
    line 25, in <module>     lookup_landmark("alamo")   File "./chaining.py", line
    20, in lookup_landmark     raise KeyError("Landmark not found.") from e ❸ KeyError:
    ''Landmark not found.'' [PRE226] During handling of the above exception, another
    exception occurred: [PRE227] import math   def average_string(number_string):     try:         numbers
    = [float(n) for n in number_string.split()]  except ValueError:         total
    = math.nan         values = 1 [PRE228]  else:         total = sum(numbers)         values
    = len(numbers) [PRE229]  try:         average = total / values     except ZeroDivisionError:         average
    = math.inf      return average   while True:     number_string = input("Enter
    space-delimited list of numbers:\n    ")     print(average_string(number_string))
    [PRE230]  4 5 6 7 5.5      inf     four five six nan [PRE231] def average_file(path):     file
    = open(path, ''r'')      try:       ❶ numbers = [float(n) for n in file.readlines()]
    [PRE232]  except ValueError as e:         raise ValueError("File contains non-numeric
    values.") from e [PRE233]  else:         try:             return sum(numbers)
    / len(numbers)         except ZeroDivisionError as e:             raise ValueError("Empty
    file.") from e [PRE234]  finally:         print("Closing file.")         file.close()
    [PRE235] print(average_file(''numbers_good.txt'')) [PRE236] Closing file. 42.0
    [PRE237] print(average_file(''numbers_bad.txt'')) [PRE238] ❶ Closing file. Traceback
    (most recent call last):   File "tryfinally.py", line 5, in average_file     numbers
    = [float(n) for n in file.readlines()]   File "tryfinally.py", line 5, in <listcomp>     numbers
    = [float(n) for n in file.readlines()] ValueError: could not convert string to
    float: ''thirty-three\n''  The above exception was the direct cause of the following
    exception:  Traceback (most recent call last):   File "tryfinally.py", line 20,
    in <module>     print(average_file(''numbers_bad.txt''))  # ValueError   File
    "tryfinally.py", line 7, in average_file     raise ValueError("File contains non-numeric
    values.") from e ValueError: File contains non-numeric values. [PRE239] print(average_file(''numbers_empty.txt''))
    [PRE240] ❶ Closing file. Traceback (most recent call last):   File "tryfinally.py",
    line 10, in average_file     return sum(numbers) / len(numbers) ZeroDivisionError:
    division by zero  The above exception was the direct cause of the following exception:  Traceback
    (most recent call last):   File "tryfinally.py", line 21, in <module>     print(average_file(''numbers_empty.txt''))  #
    ValueError   File "tryfinally.py", line 12, in average_file     raise ValueError("Empty
    file.") from e ❷ ValueError: Empty file. [PRE241] print(average_file(''nonexistent.txt''))
    [PRE242] Traceback (most recent call last):   File "tryfinally.py", line 22, in
    <module>     print(average_file(''nonexistent.txt''))  # FileNotFoundError   File
    "tryfinally.py", line 2, in average_file     file = open(path, ''r'') FileNotFoundError:
    [Errno 2] No such file or directory: ''nonexistent.txt'' [PRE243] class ❶ SillyWalkException(
    ❷ RuntimeError):     def __init__(self, ❸ message="Someone walked silly."):         super().__init__(message)   def
    walking():   ❹ raise SillyWalkException("My walk has gotten rather silly.")   try:     walking()
    ❺ except SillyWalkException as e:     print(e) [PRE244] class SillyWalkException(RuntimeError):     """Exception
    for walking silly.""" [PRE245]`**'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
