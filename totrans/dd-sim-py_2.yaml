- en: Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ESSENTIAL STRUCTURES
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables and Types
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Some of the most pernicious misconceptions about Python revolve around its nuances
    regarding variables and data types. Misunderstandings related to this *one* topic
    cause countless frustrating bugs, and this is unfortunate. Python’s way of handling
    variables is at the core of its power and versatility. If you understand this,
    everything else falls into place.
  prefs: []
  type: TYPE_NORMAL
- en: My own understanding of this topic was cemented by “Facts and Myths About Python
    Names and Values,” Ned Batchelder’s now-legendary talk at PyCon 2015\. I recommend
    you watch the video of the presentation at [https://youtu.be/_AEJHKGk9ns](https://youtu.be/_AEJHKGk9ns),
    either now or after reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables According to Python: Names and Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many myths about Python variables stem from people’s attempts to describe the
    language in terms of *other languages*. Perhaps most annoying to Python experts
    is the misleading aphorism, “Python has no variables,” which is really just the
    product of someone being overly clever about the fact that the Python language
    uses the terms *name* and *value*, instead of *variable*.
  prefs: []
  type: TYPE_NORMAL
- en: Python developers still use the term *variable* on a regular basis, and it even
    appears in the documentation, as it is part of understanding the overall system.
    However, for the sake of clarity, I’ll use the official Python terms exclusively
    throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python uses the term *name* to refer to what would conventionally be called
    a variable. A name refers to a value or an object, in the same way that your name
    refers to you but does not contain you. There may even be multiple names for the
    same thing, just as you may have a given name and a nickname. A *value* is a particular
    instance of data in memory. The term *variable* refers to the combination of the
    two: a name that refers to a value. From now on, I’ll only use the term *variable*
    in relation to this precise definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at what happens under the hood when I define a variable per the
    above definitions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: *simple_assignment.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: The name `answer` is *bound* to the value `42`, meaning the name can now be
    used to refer to the value in memory. This operation of binding is referred to
    as an *assignment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at what happens behind the scenes when I assign the variable `answer`
    to a new variable, `insight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-2: *simple_assignment.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: The name `insight` doesn’t refer to a copy of the value `42`, but rather to
    the same, original value. This is illustrated in [Figure 5-1](#figure5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: Multiple names can be bound to the same value in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In memory, the name `insight` is bound to the value `42`, which was already
    bound to another name: `answer`. Both names are still usable as variables. More
    importantly, `insight` is not bound to `answer`, but rather to the same value
    that `answer` was already bound to when I assigned `insight`. A name always points
    to a value.'
  prefs: []
  type: TYPE_NORMAL
- en: Back in Chapter 3, I introduced the `is` operator, which compares *identity*—the
    specific location in memory that a name is bound to. This means `is` doesn’t check
    whether a name points to equivalent values, but rather whether it points to the
    *same* value in memory.
  prefs: []
  type: TYPE_NORMAL
- en: When you make an assignment, Python makes its own decisions behind the scenes
    about whether to create a new value in memory or bind to an existing value. The
    programmer often has very little control over this decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this, run this example in an interactive session instead of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-3: (Interactive session):1'
  prefs: []
  type: TYPE_NORMAL
- en: I assign identical values to `spam` and `eggs`. I also bind `maps` to the same
    value as `spam`. (In case you didn’t catch it, “maps” is “spam” backward. No wonder
    GPS gets annoying.)
  prefs: []
  type: TYPE_NORMAL
- en: 'When I compare the names with the comparison operator (`==`) to check whether
    the values are equivalent, both expressions return `True`, as one would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-4: (Interactive session):2'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when I compare the identities of the names with `is`, something surprising
    happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-5: (Interactive session):3'
  prefs: []
  type: TYPE_NORMAL
- en: The names `spam` and `maps` are both bound to the same value in memory, but
    `eggs` is probably bound to a different but equivalent value. Thus, `spam` and
    `eggs` don’t share an identity. This is illustrated in [Figure 5-2](#figure5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: `spam` and `maps` share an identity; `eggs` is bound to an equivalent
    value, but it does not share identity.'
  prefs: []
  type: TYPE_NORMAL
- en: It just goes to show, spam by any other name is still spam.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python isn’t guaranteed to behave exactly like this, and it may well decide
    to reuse an existing value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-6: (Interactive session)'
  prefs: []
  type: TYPE_NORMAL
- en: When I assign the value `42` to `insight`, Python decides to bind that name
    to the existing value. Now, `answer` and `insight` happen to be bound to the same
    value in memory, and thus, they share an identity.
  prefs: []
  type: TYPE_NORMAL
- en: This is why the identity operator (`is`) can be sneaky. There are many situations
    in which `is` appears to work like the comparison operator (`==`).
  prefs: []
  type: TYPE_NORMAL
- en: As a final note, the built-in function `id()` returns an integer representing
    the identity of whatever is passed to it. These integers are the values that the
    `is` operator compares. If you’re curious about how Python handles names and values,
    try playing with `id()`.
  prefs: []
  type: TYPE_NORMAL
- en: Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve likely noticed, Python does not require you, the programmer, to declare
    a type for your variables. Back when I first picked up Python, I joined the `#python`
    channel on IRC and jumped right in.
  prefs: []
  type: TYPE_NORMAL
- en: “How do you declare the data type of a variable in Python?” I asked, in all
    the naivete of a first-year coder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within moments, I received a response that I consider to be my first true induction
    into the bizarre world of programming: “You’re a data type.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The room regulars went on to explain that Python is a dynamically typed language,
    meaning I didn’t have to tell the language what sort of information to put in
    a variable. Instead, Python would decide the type for me. I didn’t even have to
    use a special “variable declaration” keyword. I just had to assign like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-7: *types.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: At that precise moment, Python became my all-time favorite language.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to remember that Python is still a strongly typed language.
    I touched on this concept, along with dynamic typing, in Chapter 3. Ned Batchelder
    sums up Python’s type system quite brilliantly in his aforementioned PyCon 2015
    talk about names and values:'
  prefs: []
  type: TYPE_NORMAL
- en: Names have a scope—they come and go with functions—but they have no type. Values
    have a type . . . but they have no scope.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although I haven’t touched on scope yet, this should already make sense. Names
    are bound to values, and those values exist in memory, as long as there is some
    *reference* to them. You can bind a name to literally any value you want, but
    you are limited as to what you can do with any particular value.
  prefs: []
  type: TYPE_NORMAL
- en: The type() Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you ever need to know a value’s data type, you can use the built-in `type()`
    function. Recall that everything in Python is an object, so this function will
    really just return what class the value is an instance of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-8: *types.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see that the value assigned to `answer` is an integer (`int`).
    On rare occasions, you may want to check the data type before you do something
    with a value. For that, you can pair the `type()` function with the `is` operator,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-9: *types.py:3a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases where this sort of introspection is necessary, it may be better
    to use `isinstance()` instead of `type()`, as it accounts for subclasses and inheritance
    (see Chapter 13). The function itself returns `True` or `False`, so I can use
    it as the condition in an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-10: *types.py:3b*'
  prefs: []
  type: TYPE_NORMAL
- en: Truth be told, there is rarely a need for either. Instead, Python developers
    prefer a more dynamic approach.
  prefs: []
  type: TYPE_NORMAL
- en: Duck Typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python uses what is known (unofficially) as *duck typing*. This isn’t a technical
    term at all; it comes from the old saying:'
  prefs: []
  type: TYPE_NORMAL
- en: If it looks like a duck, walks like a duck, and quacks like a duck, then it
    probably *is* a duck.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python doesn’t care much about what a value’s data type is, but rather it cares
    about the *functionality* of the value’s data type. For example, if an object
    supports all the math operators and functions, and if it accepts floats and integers
    as operands on the binary operators, then Python considers the object to be a
    numeric type.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, Python doesn’t care if it’s actually a robotic duck or a moose
    in a duck costume. If it has the traits needed, the rest of the details are usually
    moot.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with object-oriented programming, particularly how quickly
    inheritance can get out of hand, then this whole concept of duck typing will probably
    be a breath of fresh air. If your class behaves as it should, it usually won’t
    matter what it inherits from.
  prefs: []
  type: TYPE_NORMAL
- en: Scope and Garbage Collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Scope* is what defines where a variable can be accessed from. It might be
    available to an entire module or limited to the suite (body) of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned already, names have *scope*, whereas values do not. A name can
    be *global*, meaning it is defined by itself in a module, or it can be *local*,
    meaning it only exists within a particular function or comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: Local Scope and the Reference-Counting Garbage Collector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions (including lambdas) and comprehensions define their own scope; they
    are the only structures in the language to do so. Modules and classes don’t have
    their own scope in the strictest sense; they only have their own namespace. When
    a scope reaches its end, all the names defined within it are automatically deleted.
  prefs: []
  type: TYPE_NORMAL
- en: For any particular value, Python keeps a *reference count*, which is simply
    a count of how many references exist for that value. Every time a value is bound
    to a name, a reference is created (although there are other ways the language
    may create references). When there are no more references, the value is deleted.
    This is the *reference-counting garbage collector*, and it efficiently handles
    most garbage collection scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see how this works with a typical function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-11: *local_scope.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I create a `spam()` function, inside of which I define the names `message`,
    `word`, and `separator`. I can access any of these names inside the function;
    that is their local scope. It doesn’t matter that `separator` is defined within
    a `for` loop, as loops don’t have their own scope. I can still access it outside
    of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I cannot access any of these names outside of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-12: *local_scope.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: Trying to access `message` outside the context of the `spam()` function where
    it was defined will raise a `NameError`. In this example, `message` doesn’t exist
    in the outer scope. What’s more, as soon as the function `spam()` exits, the names
    `message`, `word`, and `separator` are deleted. Because `word` and `separator`
    each referred to values with a reference count of one (meaning only one name was
    bound to each), the values are also deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of `message` is not deleted when the function exits, however, because
    of the return statement at the end of the function (see [Listing 5-11](#listing5-11))
    and what I do with that value here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-13: *local_scope.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: I bind the value returned by `spam()` to `output` in the outer scope, meaning
    that value still exists in memory and can be accessed outside of the function.
    Assigning the value to `output` increases the reference count for that value,
    so even though the name `message` is deleted when `spam()` exits, the value is
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter Shutdown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the Python interpreter is asked to shut down, such as when a Python program
    terminates, it enters *interpreter shutdown*. During this phase, the interpreter
    goes through the process of releasing all allocated resources, calling the garbage
    collector multiple times, and triggering destructors in objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `atexit` module from the standard library to add functions
    to this interpreter shutdown process. This may be necessary in some highly technical
    projects, although in general, you shouldn’t need to do this. Functions added
    via `atexit.register()` will be called in a last-in, first-out manner. However,
    be aware that it becomes difficult to work with modules, including the standard
    library, during interpreter shutdown. It’s like trying to work in a building as
    it’s being demolished: the janitor’s closet may disappear at any time, without
    warning.'
  prefs: []
  type: TYPE_NORMAL
- en: Global Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a name is defined within a module but outside of any function, class, or
    comprehension, it is considered to be in *global* *scope*. Although it’s okay
    to have some global scope names, having too many usually leads to the creation
    of code that is difficult to debug and maintain. Therefore, you should use global
    scope names sparingly for variables. There is often a cleaner solution, such as
    a class (see Chapter 7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Properly using global scope names in the context of a more local scope, such
    as a function, requires you to think ahead a little. Consider what I do if I want
    a function that can modify a global variable storing a high score. First, I define
    the global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-14: *global**_scope.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll write this function the wrong way first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-15: *global**_scope.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: When I run this code, Python complains that I’m using a local variable before
    I’ve assigned a value to it ❶. The problem is, I’m assigning to the name `high_score`
    within the scope of the function `score()` ❷, and that *shadows*, or hides, the
    global `high_score` name behind the new, local `high_score` name. The fact that
    I’ve created a local `high_score` name *anywhere in the function* makes it impossible
    for the function to ever “see” the global `high_score` name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work, I need to declare that I’m going to use the global name
    in the local scope, instead of defining a new local name. I can do this with the
    `global` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-16: *global**_scope.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: Before I do anything else in my function, I must specify that I’m using the
    global `high_score` name. This means that anywhere I assign a value to the name
    `high_score` in `score()`, the function will use the global name, instead of trying
    to create a new local name. The code now works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you wish to rebind a global name from within a local scope, you
    must use the `global` keyword first. If you’re only accessing the current value
    bound to a global name, you don’t need to use the `global` keyword. It is vital
    for you to cultivate this habit, because Python won’t always raise an error if
    you handle scope incorrectly. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-17: *global**_scope_gotcha.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: This code runs without raising any errors, but the output is wrong. A new name,
    `current_score`, is being created in the local scope of the function `score()`,
    and it is bound to the value `465`. This shadows the global name `current_score`.
    When the function terminates, both the `new_score` and the local `current_score`
    are deleted. In all of this, the global `current_score` has remained untouched.
    It is still bound to `0`, and that is what is printed out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, to resolve this problem, I need only use the `global` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-18: *global**_scope_gotcha.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: Because I specified that the global `current_name` is to be used in this function,
    the code now behaves precisely as expected, printing out the value `465`.
  prefs: []
  type: TYPE_NORMAL
- en: The Dangers of Global Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one more major gotcha to account for with global scope. Modifying any
    variable at a global level, as in rebinding or mutating on a name outside the
    context of a function, can lead to confusing behavior and surprising bugs—especially
    once you start dealing with multiple modules. It’s acceptable for you to initially
    “declare” a name at a global scope, but you should do all further rebinding and
    mutation of that global name at the local scope level.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, this does *not* apply to classes, which do not actually define their
    own scope. I’ll return to this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The nonlocal Keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python allows you to write functions within functions. I’ll defer discussing
    the practicality of this until Chapter 6. Here, I mainly want to explore this
    functionality’s impact on scope. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-19: *nonlocal**.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `order()` contains another function: `cook()`. Each function has
    its own scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, as long as a function only accesses a global name like `spam`, you
    don’t need to do anything special. However, trying to *assign* to a global name
    will actually define a new local name that shadows the global one. The same behavior
    is true of the inner function using names defined in the outer function, which
    is known as the *nested scope* or *enclosing scope*. To get around this, I specify
    that `eggs` is `nonlocal`, meaning it can be found in the enclosing scope, rather
    than in the local scope ❶. The inner function `cook()` has no trouble accessing
    the global name `spam`.
  prefs: []
  type: TYPE_NORMAL
- en: The `nonlocal` keyword starts looking for the indicated name in the innermost
    nested scope, and if it doesn’t find it, it moves to the next enclosing scope
    above that. It repeats this until it either finds the name or determines that
    the name does not exist in a nonglobal enclosing scope.
  prefs: []
  type: TYPE_NORMAL
- en: Scope Resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python’s rule about which scopes it searches for a name, and in what order,
    is called the *scope resolution order*. The easiest way to remember the scope
    resolution order is with the acronym *LEGB—*for which my colleague Ryan gave me
    the handy mnemonic “Lincoln Eats Grant’s Breakfast”:'
  prefs: []
  type: TYPE_NORMAL
- en: Local
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enclosing-function locals (that is, anything found via `nonlocal`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Global
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Built-in
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python will look in these scopes, in order, until it finds a match or reaches
    the end. The `nonlocal` and `global` keywords adjust the behavior of this scope
    resolution order.
  prefs: []
  type: TYPE_NORMAL
- en: The Curious Case of the Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes have their own way of dealing with scope. Technically speaking, classes
    don’t directly factor into the scope resolution order. Every name declared directly
    within a class is known as an *attribute*, and it is accessed through the dot
    (`.`) operator on the class (or object) name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, I’ll define a class with a single attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-20: *class_attributes**.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Those three print statements all output the same thing. Running that code gives
    me this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The name `output` is a *class attribute* ❶, belonging to the `Nutrimatic` class.
    Even within that class, I would not be able to refer to it merely as `output`.
    I must access it through `self.output` ❷, as `self` refers to the class instance
    the function (instance method) `request()` is being called on. I can also access
    it via `machine.output` ❸ or `Nutrimatic.output` ❹ anywhere the object `machine`
    or the class `Nutrimatic` is, respectively, in scope. All of those names point
    to the exact same attribute: `output`. Especially in this case, there’s no real
    difference between them.'
  prefs: []
  type: TYPE_NORMAL
- en: Generational Garbage Collector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Behind the scenes, Python also has a more robust *generational garbage collector*
    that handles all of the odd situations a reference-counting garbage collector
    cannot, such as reference cycles (when two values reference one another). All
    of these situations, and the ways they’re handled by the garbage collector, are
    far beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, the most important takeaway to remember is that the generational
    garbage collector incurs some performance costs. Thus, it’s sometimes worthwhile
    to avoid reference cycles. One way to do this is with `weakref`, which creates
    a reference to a value without increasing that value’s reference count. This feature
    was defined in PEP 205, and the documentation exists at [https://docs.python.org/library/weakref.html](https://docs.python.org/library/weakref.html).
  prefs: []
  type: TYPE_NORMAL
- en: The Immutable Truth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Values in Python can be either *immutable* or *mutable*. The difference hinges
    on whether the values can be *modified in place*, meaning they can be changed
    right where they are in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Immutable* types cannot be modified in place. For example, integers (`int`),
    floating-point numbers (`float`), strings (`str`), and tuples (`tuple`) are all
    immutable. If you attempt to mutate an immutable value, you’ll wind up with a
    completely different value being created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-21: *immutable_types.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, `eggs` and `carton` are both bound to the same value, and thus, they
    share an identity. When I modify `eggs`, it is rebound to a new value, so it no
    longer shares an identity with `carton`. You can see that the two names now point
    to different values.
  prefs: []
  type: TYPE_NORMAL
- en: '*Mutable* types, on the other hand, can be modified in place. Lists constitute
    one example of a mutable type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-22: *mutable_types.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Because the list is aliased to both `temps` and `highs`, any modifications made
    to the list value ❶ are visible through either name. Both names are bound to the
    original value, as demonstrated by the `is` comparisons. This remains the case,
    even after that value is mutated.
  prefs: []
  type: TYPE_NORMAL
- en: Passing by Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another frequent question from programmers new to the language is, “Does Python
    pass by value or by reference?”
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, “Effectively, neither.” More accurately, as Ned Batchelder describes
    it, Python *passes by assignment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Neither the values nor the names bound to them are moved. Instead, each value
    is bound to the parameter via assignment. Consider a simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, there is one copy of the string value `"Jason"` in memory, and that is
    bound to the name `my_name`. When I pass `my_name` to the `greet()` function—specifically,
    to the `person` parameter—it’s the same as if I had said (`person = my_name`).
  prefs: []
  type: TYPE_NORMAL
- en: Again, assignment never makes a copy of a value. The name `person` is now bound
    to the value `"Jason"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept of passing by assignment gets tricky when you start working with
    mutable values, such as lists. To demonstrate this often-unexpected behavior,
    I’ve written a function that finds the lowest temperature in a list passed to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-23: *lowest_temp.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, you may assume that passing a list to the `temperatures` parameter
    will make a copy, so it shouldn’t matter if you modify the value bound to the
    parameter. However, lists are mutable, meaning *the value itself* can be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-24: *lowest_temp.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: When I passed `temps` to the function’s `temperatures` parameter, I only *aliased*
    the list, so any changes made on `temperatures` are visible from all the other
    names bound to that same list value—namely, from `temps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this in action when I run this code and get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When `find_lowest()` sorted the list passed to `temperatures`, it actually sorted
    the one mutable list that both `temps` and `temperatures` aliased. This is a clear
    case of a function having *side effects*, which are changes to values that existed
    before the function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'An awe-inspiring number of bugs originate from this one type of misunderstanding.
    In general, functions should not have side effects, meaning that any values passed
    to the function as arguments should *not* be directly mutated. To avoid mutating
    the original value, I have to explicitly make a copy of it. Here’s how I’d do
    that in the `find_lowest()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-25: *lowest_temp.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: The `sorted()` function has no side effects; it creates a new list using the
    items in the list passed to it ❶. It then sorts this new list and returns it.
    I bind this new list to `sorted_temps`. Thus, the original list (bound to `temps`
    and `temperatures`) is untouched.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re coming from C and C++, it may be helpful to remember the potential
    hang-ups related to pass-by-pointer or pass-by-reference. Although Python’s assignment
    is scarcely similar from a technical standpoint, the risks of side effects and
    unintended mutations are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Collections and References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All collections, including lists, employ a clever little semantic detail that
    can become a royal pain if you don’t know to expect it: ***Individual items are
    references.*** Just as a name is bound to a value, so also are items in collections
    bound to values, in the same manner. This binding is called a *reference*.'
  prefs: []
  type: TYPE_NORMAL
- en: A simple example involves trying to create a tic-tac-toe board. This first version
    won’t work quite how you’d expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by creating the game board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-26: *tic_tac_toe**.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: I’m trying to create a two-dimensional board. You can fill a collection, like
    a list, with several items, all with the same repeating value, using the multiplication
    operator ❶, as I’ve done here. I enclose the repeating value in square brackets
    and multiply it by the number of repetitions I want. A single row of my board
    is defined with `["-"] * 3`, which makes a list of three `"-"` strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this won’t work the way you’d expect. The problem begins when
    I attempt to define the second dimension of the array—three copies of the `[["-"]
    * 3]` list—using multiplication. You can see the problem manifest when I try to
    make a move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-27: *tic_tac_toe**.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When I mark a move on the board ❷, I want to see that change in only one spot
    on the board, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, I get this nasty surprise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Cue the weeping and gnashing of teeth. Somehow, that one change has propagated
    to *all three* *rows*. Why?
  prefs: []
  type: TYPE_NORMAL
- en: Initially, I created a list with three `"-"` values as items ❶. Since strings
    are immutable and thus cannot be modified in place, this works as expected. Rebinding
    the first item in the list to `"X"` does not affect the other two items.
  prefs: []
  type: TYPE_NORMAL
- en: The outer dimension of the list is composed of three list items. Because I defined
    *one* list and used it *three* times, I now have three *aliases* for one mutable
    value! By changing that list through one reference (the second row), I’m mutating
    that one shared value ❷, so all three references see the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to fix this, but all of them work by ensuring each row
    references a separate value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-28: *tic_tac_toe**.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I only needed to change how I defined the game board initially. I now use a
    *list comprehension* to create the rows. In short, this list comprehension will
    define a separate list value from `["-"] * 3` three different times. (List comprehensions
    get complicated; they’ll be explained in depth in Chapter 10.) Running the code
    now results in the expected behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Long story short, whenever you’re working with a collection, remember that
    an item is no different from any other name. Here is one more example to drive
    this point home:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-29: *team_scores**.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I create three lists, assigning each to a name. Then, I pack all three into
    the tuple `scores`. You may remember from earlier that tuples cannot be modified
    directly, because they’re immutable. That same rule does not necessarily apply
    to a tuple’s items. You can’t change the tuple itself, but you can (indirectly)
    modify the values its items refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-30: *team_scores**.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: When I mutate the list `scores_team_1`, that change appears in the first item
    of the tuple, because that item only aliased a mutable value.
  prefs: []
  type: TYPE_NORMAL
- en: 'I could also directly mutate a mutable list in the `scores` tuple through two-dimensional
    subscription, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-31: *team_scores**.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples don’t give you any sort of security about things being modified. Immutability
    exists mainly for efficiency, not for protecting data. Mutable values are *always*
    going to be mutable, no matter where they live or how they’re referred to.
  prefs: []
  type: TYPE_NORMAL
- en: The problems in the two examples above may seem relatively easy to spot, but
    things start getting troublesome when the related code is spread out across a
    large file or multiple files. Mutating on a name in one module may unexpectedly
    modify an item of a collection in a completely different module, and you might
    never have expected it.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow Copy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to ensure you are binding a name to a *copy* of a mutable
    value, instead of aliasing the original; the most explicit of these ways is with
    the `copy()` function. This is sometimes also known as a *shallow copy*, in contrast
    to the *deep copy* I’ll cover later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, I’ll create a `Taco` class (see Chapter 7 for more on
    classes) that allows you to define the class with various toppings and then add
    a sauce afterward. This first version has a bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-32: *mutable_**tacos.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Taco` class, the initializer `__init__()` accepts a list of toppings,
    which it stores as the `ingredients` list. The `add_sauce()` method will add the
    specified `sauce` string to the `ingredients` list.
  prefs: []
  type: TYPE_NORMAL
- en: (Can you anticipate the problem?)
  prefs: []
  type: TYPE_NORMAL
- en: 'I use the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-33: *mutable_**tacos.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I define a list of toppings I want on all my tacos, and then I define two tacos:
    `hot_taco` and `mild_taco`. I pass the `default_toppings` list to the initializer
    for each taco. Then I add `"Salsa"` to the list of toppings to `hot_taco`, but
    I don’t want any `"Salsa"` on `mild_taco`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure this is working, I print out the list of `ingredients` for the
    two tacos, as well as the `default_toppings` list I started with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-34: *mutable_**tacos.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Waiter, there’s a bug in my taco!
  prefs: []
  type: TYPE_NORMAL
- en: The trouble is, when I created my `hot_taco` and `mild_taco` object by passing
    `default_toppings` to the `Taco` initializer, I bound both `hot_taco.ingredients`
    and `mild_taco.ingredients` to the same list value as `default_toppings`. These
    are now all aliases of the same value in memory. Then, when I call the function
    `hot_taco.add_sauce()`, I mutate that list value. The addition of `"Salsa"` is
    visible not only in `hot_taco.ingredients`, but also (unexpectedly) in `mild_taco.ingredients`
    and in the `default_toppings` list. This is definitely not the desired behavior;
    adding `"Salsa"` to one taco should only affect that one taco.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to resolve this is to ensure I’m assigning a copy of the mutable value.
    In the case of my `Taco` class, I will rewrite the initializer so it assigns a
    copy of the specified list to `self.ingredients`, instead of aliasing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-35: *mutable_**tacos.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: I make a copy with the `copy.copy()` function ❶, which is imported from `copy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I make a copy of the list passed to `toppings` within `Taco.__init__()`, assigning
    that copy to `self.ingredients`. Any changes made to `self.ingredients` don’t
    affect the others; adding `"Salsa"` to `hot_taco` does not change `mild_taco.ingredients`,
    nor does it change `default_toppings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Deep Copy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A shallow copy is all well and good for lists of immutable values, but as previously
    mentioned, when a mutable value contains other mutable values, changes to those
    values can appear to replicate in weird ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider what happens when I try to make a copy of a `Taco` object
    before changing one of the two tacos. My first attempt results in some undesired
    behavior. Building on the same `Taco` class as before (see [Listing 5-35](#listing5-35)),
    I’ll use the copy of one taco to define another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-36: *mutable_**tacos.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: I want to create a new taco (`hot_taco`) that is initially identical to `mild_taco`,
    but with added `"Salsa"`. I’m attempting this by binding a copy of `mild_taco`
    ❶ to `hot_taco`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the revised code (including [Listing 5-34](#listing5-34)) produces
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: I might not expect any changes made to `hot_taco` to reflect in `mild_taco`,
    but unexpected changes have clearly happened.
  prefs: []
  type: TYPE_NORMAL
- en: The issue is that, when I make a copy of the `Taco` object value itself, I am
    not making a copy of the `self.ingredients` list *within* the object. Both `Taco`
    objects contain references to the same list value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, I can use *deep copy* to ensure that any mutable values
    inside the object are copied as well. In this case, a deep copy of a `Taco` object
    will create a copy of the `Taco` value, as well as a copy of any mutable values
    that `Taco` contains references to—namely, the list `self.ingredients`. [Listing
    5-37](#listing5-37) shows that same program, using deep copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-37: *mutable_**tacos.py:2c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only change is that I’m using `copy.deepcopy()`, instead of `copy.copy()`
    ❶. Now when I mutate the list inside `hot_taco`, it doesn’t affect `mild_taco`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: I don’t know about you, but I’m getting hungry for tacos.
  prefs: []
  type: TYPE_NORMAL
- en: Copying is the most generic way to solve the problem of passing around mutable
    objects. However, depending on what you’re doing, there may be an approach better
    suited to the particular collection you’re using. For example, many collections,
    like lists, have functions that return a copy of the collection with some specific
    modification. When you’re solving these sorts of issues with mutability, you can
    start by employing copy and deep copy. Then, you can exchange that for a more
    domain-specific solution later.
  prefs: []
  type: TYPE_NORMAL
- en: Coercion and Conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Names do not have types. Therefore, Python has no need of type casting, at least
    in the typical sense of the term.
  prefs: []
  type: TYPE_NORMAL
- en: 'Allowing Python to figure out the conversions by itself, such as when adding
    together an integer (`int`) and a `float`, is called *coercion*. Here are a few
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-38: *coercion.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Even so, there are potential situations in which you may need to use one value
    to create a value of a different type, such as when you are creating a string
    from an integer. *Conversion* is the process of explicitly casting a value of
    one type to another type.
  prefs: []
  type: TYPE_NORMAL
- en: Every type in Python is an instance of a class. Therefore, the class of the
    type you want to create only needs to have an initializer that can handle the
    data type of the value you’re converting from. (This is usually done through duck
    typing.)
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the more common scenarios is to convert a string containing a number
    into a numeric type, such as a `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-39: *conversion.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I start with a piece of information as a string value, which is bound
    to the name `life_universe_everything`. Imagine I want to do some complex mathematical
    analysis on this data; to do this, I must first convert the data into a floating-point
    number. The desired type would be an instance of the class `float`. That particular
    class has an initializer (`__init__()`) that accepts a string as an argument,
    which is something I know from the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: I initialize a `float()` object, pass `life_universe_everything` to the initializer,
    and bind the resulting object to the name `answer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll print out the `type` and value of `answer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-40: *conversion.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Since there were no errors, you can see that the result is a `float` with value
    `42.0`, bound to `answer`.
  prefs: []
  type: TYPE_NORMAL
- en: Every class defines its own initializers. In the case of `float()`, if the string
    passed to it cannot be interpreted as a floating-point number, a `ValueError`
    will be raised. Always consult the documentation for the object you’re initializing.
  prefs: []
  type: TYPE_NORMAL
- en: A Note About Systems Hungarian Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re coming from a statically typed language like C++ or Java, you’re probably
    used to working with data types. Thus, when picking up a dynamically typed language
    such as Python, it might be tempting to employ some means of “remembering” what
    type of value every name is bound to. ***Don’t do this!*** You will find the most
    success using Python if you learn to take full advantage of dynamic typing, weak
    binding, and duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will confess: the first year I used Python, I used *Systems Hungarian notation*—the
    convention of appending a prefix denoting data type to every variable name—to
    try to “defeat” the language’s dynamic typing system. My code was littered with
    such debris as `intScore`, `floatAverage`, and `boolGameOver`. I picked up the
    habit from my time using Visual Basic .NET, and I thought I was brilliant. In
    fact, I was depriving myself of many opportunities to refactor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Systems Hungarian notation will quickly render code obtuse. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-41: *evils_of_systems_hungarian.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Needless to say, this code is quite painful to read. On the other hand, if
    you make full use of Python’s typing system (and resist the urge to store every
    intermediate step), the code will be decidedly more compact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-42: *duck_typing_feels_better.py*'
  prefs: []
  type: TYPE_NORMAL
- en: My code became far cleaner once I stopped treating Python like a statically
    typed language. Python’s typing system is a big part of what makes it such a readable
    and compact language.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology Review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve introduced a lot of important new words in this section. Since I’ll be
    using this vocabulary frequently throughout the rest of the book, doing a quick
    recap here is prudent.
  prefs: []
  type: TYPE_NORMAL
- en: alias (v.) To bind a mutable value to more than one name. Mutations performed
    on a value bound to one name will be visible on all names bound to that mutable
    value.
  prefs: []
  type: TYPE_NORMAL
- en: assignment (n.) The act of binding a value to a name. Assignment never copies
    data.
  prefs: []
  type: TYPE_NORMAL
- en: bind (v.) To create a reference between a name and a value.
  prefs: []
  type: TYPE_NORMAL
- en: coercion (n.) The act of implicitly casting a value from one type to another.
  prefs: []
  type: TYPE_NORMAL
- en: conversion (n.) The act of explicitly casting a value from one type to another.
  prefs: []
  type: TYPE_NORMAL
- en: copy (v.) To create a new value in memory from the same data as another value.
  prefs: []
  type: TYPE_NORMAL
- en: data (n.) Information stored in a value. You may have copies of any given data
    stored in other values.
  prefs: []
  type: TYPE_NORMAL
- en: deep copy (v.) To both copy an object to a new value *and* copy all the data
    from values referenced within that object to new values.
  prefs: []
  type: TYPE_NORMAL
- en: identity (n.) The specific location in memory that a name is bound to. When
    two names share an identity, they are bound to the same value in memory.
  prefs: []
  type: TYPE_NORMAL
- en: immutable (adj.) Of or relating to a value that *cannot* be modified in place.
  prefs: []
  type: TYPE_NORMAL
- en: mutable (adj.) Of or relating to a value that *can* be modified in place.
  prefs: []
  type: TYPE_NORMAL
- en: mutate (v.) To change a value in place.
  prefs: []
  type: TYPE_NORMAL
- en: name (n.) A reference to a value in memory, commonly thought of as a “variable”
    in Python. A name must always be bound to a value. ***Names have scope, but not
    type.***
  prefs: []
  type: TYPE_NORMAL
- en: rebind (v.) To bind an existing name to a different value.
  prefs: []
  type: TYPE_NORMAL
- en: reference (n.) The association between a name and a value.
  prefs: []
  type: TYPE_NORMAL
- en: scope (n.) A property that defines what section of the code a name is accessible
    from, such as from within a function or within a module.
  prefs: []
  type: TYPE_NORMAL
- en: shallow copy (v.) To copy an object to a new value but *not* copy the data from
    values referenced within that object to new values.
  prefs: []
  type: TYPE_NORMAL
- en: type (n.) A property that defines how a raw value is interpreted, for example,
    as an integer or a boolean.
  prefs: []
  type: TYPE_NORMAL
- en: value (n.) A unique copy of data in memory. There must be a reference to a value,
    or else the value is deleted. ***Values have type, but not scope.***
  prefs: []
  type: TYPE_NORMAL
- en: variable (n.) A combination of a name and the value the name refers to.
  prefs: []
  type: TYPE_NORMAL
- en: weakref (n.) A reference that does not increase the reference count on the value.
  prefs: []
  type: TYPE_NORMAL
- en: To help keep us grounded in these concepts, we usually use the term *name* instead
    of *variable*. Instead of *changing* something, we *(re)bind a name* or *mutate
    a value*. Assignment never copies—it literally always binds a name to a value.
    Passing to a function is just assignment.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if you ever have trouble wrapping your head around these concepts
    and how they play out in your code, try the visualizer at [http://pythontutor.com/](http://pythontutor.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s easy to take something like variables for granted, but by understanding
    Python’s unique approach, you can better avail yourself of the power that is available
    through dynamic typing. I must admit, Python has somewhat spoiled me. When I work
    in statically typed languages, I find myself pining for the expressiveness of
    duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, working with Python-style dynamic typing can take getting used to if
    you have a background in other languages. It’s like learning how to speak a new
    human language: only with time and practice will you begin to think in the new
    tongue.'
  prefs: []
  type: TYPE_NORMAL
- en: If all this is making your head swim, let me reiterate the single most important
    principles. Names have scope, but no type. Values have type, but no scope. A name
    can be bound to any value, and a value can be bound to any number of names. It
    really is that dead simple! If you remember that much, you’ll go a long way.
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions and Lambdas
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Functions are one of the most elementary concepts in programming, yet Python
    packs a surprising amount of versatility into them. You’ll recall from Chapter
    3 that functions are first-class objects, so they are treated no differently from
    any other object. This fact, combined with the power of dynamic typing, opens
    up so many possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Python has full support for *functional programming*, a distinct paradigm from
    which we get those “lambdas,” or anonymous functions, you keep reading about online.
    If you’re used to languages like Haskell or Scala, a lot of the concepts in this
    chapter are going to seem familiar to you. However, if you’re more used to object-oriented
    programming, such as in Java or C++, this may be the first time you’ve encountered
    many of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: When learning Python, it makes sense to dive into functional programming early
    on. It is perfectly possible to write idiomatic Python code without ever creating
    a single class (see Chapter 7). By contrast, functions and functional programming
    concepts underpin much of the language’s most powerful features.
  prefs: []
  type: TYPE_NORMAL
- en: Python Function Essentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I briefly touched on functions in Chapter 3. Building on that knowledge, I’ll
    gradually construct a more complex example in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by creating a function that rolls a single die with a specified
    number of sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: *dice_roll.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: I define a function named `roll_dice()`, which accepts a single parameter, `sides`.
    This function is considered pure, because it has no side effects; it accepts a
    value as an input and returns a new value as an output. I return a value from
    the function using the `return` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The `random` module has a number of functions for producing random values. Here,
    I use its `random.randint()` function to generate a pseudorandom number in Python.
    I generate a random number between `1` and `20` (the value of `sides` in this
    example) inclusively, with `random.randint(1, 20)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my usage for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: *dice_roll.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: Later, I call the function and pass the value `20` as an argument ❶, so the
    function call is effectively the same as rolling a 20-sided die. The value that
    the first function call returns is bound to `player1`; the second call’s return
    is bound to `player2`.
  prefs: []
  type: TYPE_NORMAL
- en: Because I defined `roll_dice()` as a function, I can use it as many times as
    I want. If I want to change its behavior, I only need to modify the function in
    the one place where it is defined, and every usage of that function will be affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say I wanted to roll multiple dice at once and return the results in a tuple.
    I can rewrite the `roll_dice()` function to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**Listing 6-3: *dice_roll.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: To allow rolling multiple dice, the function accepts a second parameter, `dice`,
    which represents the number of dice being rolled. The first parameter, `sides`,
    still represents the number of sides on any one of the dice.
  prefs: []
  type: TYPE_NORMAL
- en: The scary-looking line of code at the top of the function is a *generator expression*,
    which I’ll cover in Chapter 10. For now, you can take it for granted that I’m
    generating one random number for each die being rolled and packing the results
    in a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since my function now has a second parameter in the function call, I pass two
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-4: *dice_roll.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: The returned tuple can be *unpacked*, meaning each item in the tuple is bound
    to a name I can use to access the value. The number of names listed on the left
    (separated by commas) and the number of values in the tuple *must* match for this
    to work, or else Python will raise an error. (See Chapter 9 for more on unpacking
    and tuples.)
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Recursion* occurs when a function calls itself. This can be helpful when you
    need to repeat the entire logic of a function but a loop is unsuitable or feels
    too cluttered, as in the upcoming example.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, returning to my dice-rolling function, I can accomplish the exact
    same result using recursion, instead of that generator expression I was using
    earlier (although in practice, the generator expression is usually considered
    more Pythonic).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-5: *dice_roll_recursive.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: I store the resulting roll for this function call in `roll`. Then, in the recursive
    call, I pass my `sides` parameter as is, while reducing the number of `dice` to
    roll by one, to account for the die I just rolled. Finally, I combine the tuple
    that is returned from that recursive function call with the result of the roll
    on this function call, and I return the resulting longer tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage is essentially the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-6: *dice_roll_recursive.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to print out each value being returned, in order from deepest recursive
    call to outermost, here’s what you would see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-7: Returns from recursive calls to `roll_dice(6, 5)`'
  prefs: []
  type: TYPE_NORMAL
- en: When the number of dice left is zero or negative, I return an empty tuple instead
    of recursively calling it again. If I don’t do that, the recursion will try to
    run forever. Thankfully, Python will pull the plug at some point and just crash
    the program, instead of letting it consume all your computer’s memory (as some
    other programming languages are apt to do). The *recursion depth* is how many
    recursive function calls have not returned yet, and Python caps it at approximately
    one thousand.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the recursion depth goes any deeper than the limit, the entire program stops
    and raises an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This is why it’s so important that you build some means of stopping when you
    use recursion. In the `roll_dice` function, this stopping mechanism is at the
    very top of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Since `dice` is getting decremented every time the function calls itself, sooner
    or later, it will reach zero. When it does, it returns an empty tuple, instead
    of producing another recursive call. Then, the rest of the recursive calls can
    finish running and return.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be cases in which a recursion depth of a thousand is not enough.
    If you need more, you can override the maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `sys.setrecursionlimit()` function allows you to set a new maximum recursion
    depth. In this case, my new limit is `2000`. The benefit of this approach is that
    once you no longer need your limit, you can set it back to the default so it can
    keep *other* recursive calls from getting out of hand.
  prefs: []
  type: TYPE_NORMAL
- en: Default Argument Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might imagine that I would need to roll a single die far more often than
    any other option. As it stands right now, I would have to manually specify that
    I only want to roll one 20-sided die:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: I have to manually pass a `1` as the second argument of `roll_dice` to specify
    that I’m rolling a single die.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, that trailing comma after `result` is how I unpack a single value
    from a single-item tuple, meaning the actual value of the only item in the tuple
    is now bound to `result`. (See Chapter 9 for more on unpacking.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Since rolling a single die is likely the most common action I want to take
    with this function, I want to make it more convenient to use. I can use *default
    argument values* to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-8: *dice_roll.py:1c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dice` parameter now has a default argument value of `1`. Thus, anytime
    I don’t specify the second argument, `dice` will use its default argument value.
    This makes it possible to use a simplified function call to roll a single six-sided
    die:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If I do want to roll multiple dice, I can still pass that second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: When you specify a default argument value for a parameter, you are defining
    an *optional parameter*. Conversely, a parameter with no default argument value
    is a *required parameter*. You can have as many of each as you like, but you must
    list all required parameters *before* your optional parameters. Otherwise, the
    code won’t run.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using optional parameters, there is one significant trap lurking in the
    dark: default argument values are only evaluated once, when the function is defined.
    One place where this gets treacherous is when you’re using any mutable data type,
    such as a list. Consider this code for generating values in a Fibonacci sequence,
    which doesn’t quite work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-9: *fibonacci.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: This is going to have a problem because the default argument value `[1, 1]`
    ❶ is evaluated when Python first processes the function definition, creating a
    single mutable list with the value `[1, 1]` in memory. That gets mutated on the
    first function call ❷ and then returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'This usage of the function shows the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-10: *fibonacci.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: Everything looks okay in the code, but it isn’t. `fib1` is now bound to the
    same mutable value as `series`, so any changes to `fib1` are reflected in the
    default argument value *for every function call*. The second function call mutates
    this list further.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I call `fibonacci_next()` a third time, I’m probably expecting to start
    with a clean slate, `[1, 1, 2]`, which would be the result of a single mutation
    on the original default argument value. Instead, I’m getting the value of that
    single mutable value I’ve been messing with this whole time: `fib2` is now a third
    alias to the list. Oops!'
  prefs: []
  type: TYPE_NORMAL
- en: 'This becomes apparent when I examine the output. This is what I’d be expecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is what I actually get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In short, *never use mutable values for default argument values*. Instead,
    use `None` as a default value, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-11: *fibonacci.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: The proper way is to use `None` as the default argument value, and then to create
    a new mutable value if that default is being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that same usage code as before ([Listing 6-9](#listing6-9)) now produces
    the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Keyword Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Readability matters. Unfortunately, function calls with multiple parameters
    aren’t always the most readable bits of code. *Keyword arguments* help resolve
    this by attaching labels to arguments in function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments that are mapped to their parameters by the order you pass them in,
    like in all the prior examples, are called *positional arguments*.
  prefs: []
  type: TYPE_NORMAL
- en: If you knew nothing about the `roll_dice()` function from earlier and you encountered
    this line of code, what would you think it did?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-12: *dice_roll.py:3a*'
  prefs: []
  type: TYPE_NORMAL
- en: You would probably guess that this is rolling multiple dice, and perhaps that
    it is specifying how many sides those dice have—but which is which? Is it rolling
    six five-sided dice or five six-sided dice? You can imagine how confusing this
    would be with even more arguments. This is the shortcoming of positional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'As The Zen of Python says:'
  prefs: []
  type: TYPE_NORMAL
- en: In the face of ambiguity, refuse the temptation to guess.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It can’t be good, then, to force the reader to guess. I can eliminate the ambiguity
    by using *keyword arguments*. I don’t need to change the function definition at
    all to be able to use keyword arguments. I only need to change my function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-13: *dice_roll.py:3b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of those names comes from the earlier function definition of `roll_dice`,
    where I specified it had two parameters: `sides` and `dice`. In my function call,
    I can assign values directly to those parameters by name. Now, there is no question
    about what each argument does. Specify the name of the parameter, matching what
    is in the function definition, and then assign the desired value directly to it.
    That’s all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using keyword arguments, you don’t even have to list them in order, just
    as long as all the required parameters receive values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-14: *dice_roll.py:3c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be even more helpful when you have multiple optional parameters on
    the function. Consider if I rewrote `roll_dice()` so that the dice being rolled
    were six sided, by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-15: *dice_roll.py:1d*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword arguments allow you to simplify your function calls even further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-16: *dice_roll.py:3d*'
  prefs: []
  type: TYPE_NORMAL
- en: You’re only passing a value to one of the optional arguments, `dice`. For the
    other one, `sides`, the default value is used. It no longer needs to matter whether
    `sides` or `dice` appears first in the function’s parameter list; you can just
    use the ones you want and leave the rest alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is even possible to mix and match positional arguments and keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-17: *dice_roll.py:3e*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `6` is passed as a positional argument to the first parameter in the function
    definition, `sides`. Then, I pass `5` as a keyword argument to the parameter `dice`.
  prefs: []
  type: TYPE_NORMAL
- en: This can come in handy, particularly when you don’t want to bother with naming
    the positional arguments but you still want to use one of many possible optional
    parameters. The only rule here is that your keyword arguments must come after
    your positional arguments in the function call. (See also the section “Keyword-Only
    Parameters” later in the chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: On Overloaded Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re coming from a strictly typed language such as Java or C++, you’re
    probably used to writing *overloaded functions*, wherein you can write multiple
    functions with the same name but different parameters. Typically, overloaded functions
    in languages that support them provide a consistent interface (function name),
    while supporting arguments of different types.
  prefs: []
  type: TYPE_NORMAL
- en: Python usually doesn’t need overloaded functions. Using dynamic typing, duck
    typing, and optional parameters, you can write single functions that handle all
    the input scenarios you need to throw at Python.
  prefs: []
  type: TYPE_NORMAL
- en: If you really, really need overloaded functions—and you probably don’t—you actually
    can create them with *single-dispatch functions*. I’ll cover this in Chapter 15.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the skills discussed so far, even while using optional parameters, you
    still have to anticipate how many arguments can potentially get passed to your
    function. This is fine in most cases, but sometimes, you’ll have no idea how many
    to expect.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this, your first instinct might be to pack all the arguments into a
    single tuple or a list. That works in some situations, but other times, it can
    become an extra inconvenience when calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better solution is to use *arbitrary arguments lists*, also called *variadic
    arguments*, which automatically pack multiple arguments into a single *variadic
    parameter* or *variadic positional parameter*. In the dice-rolling function, I
    want to allow the rolling of multiple dice, where each die may have a different
    number of sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-18: *dice_roll_variadic.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: I turn the parameter `dice` into a variadic parameter by preceding it with a
    single asterisk (`*`). All the arguments passed to `roll_dice` will now be packed
    into a tuple, bound to the name `dice`.
  prefs: []
  type: TYPE_NORMAL
- en: Within the function, I can use this tuple in the usual manner. In this case,
    I’m using a generator expression (see Chapter 10) to roll each die specified in
    `dice`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The placement of the variadic parameter is important: it must come *after*
    any positional parameters in the function definition. Any parameters I list after
    it will only be usable as keyword arguments, because the variadic parameter consumes
    all the remaining positional arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-19: *dice_roll_variadic.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In both function calls, I’m listing the dice I want to roll, with the number
    representing the number of sides of each die. In the first call, I’m rolling five
    six-sided dice. In the second call, I’m rolling four dice: a 20-sided die, a 6-sided
    die, an 8-sided die, and a 4-sided die.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I wanted to use the recursive approach, I’d populate the argument list by
    automatically unpacking that tuple into the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-20: *dice_roll_variadic.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: Most of this code is going to look similar to the earlier recursive version.
    The most significant change is in what I’m passing to the recursive function call.
    The asterisk (`*`) in front of the name unpacks the tuple `dice` into the argument
    list ❶. I already processed the first item in the list, so I use the slice notation
    `[1:]` to remove that first item ❷ (see Chapter 9), to ensure it isn’t processed
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Variadic Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To capture an unknown number of *keyword arguments*, precede the parameter name
    with *two* asterisks (`**`), making the parameter a *keyword variadic parameter*.
    The keyword arguments passed to the function are packed into a single dictionary
    object, so as to preserve the association between keyword and value. They are
    similarly unpacked by being preceded with two asterisks.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t show up very often in the wild. After all, if you didn’t know what
    the arguments were named, it would be hard to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'One case where keyword variadic arguments are commonly useful is in blindly
    relaying arguments to another function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-21: *variadic_relay.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: The `call_something_else()` function has one positional argument, `func`, where
    I’ll pass a *callable* object, such as another function. The second parameter,
    `args`, is a variadic parameter for capturing all the remaining positional arguments.
    Last is the keyword variadic parameter, `kwargs`, for capturing any keyword arguments;
    sometimes, the name `kw` is used instead. Remember, either of these can be empty
    and this code will still work.
  prefs: []
  type: TYPE_NORMAL
- en: You can check whether an object is callable by passing it to the `callable()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The names `args` and `kwargs` are conventionally used for positional variadic
    and keyword variadic parameters, respectively. However, if you can think of names
    that better fit your particular situation, that’s certainly acceptable!
  prefs: []
  type: TYPE_NORMAL
- en: When the function calls the callable object `func`, it first unpacks all the
    positional arguments that were captured, and then it unpacks all the keyword arguments.
    The function code doesn’t need any knowledge of the callable object’s parameter
    list; instead, any and every argument passed to `call_something_else()` after
    that first positional argument will get blindly passed on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this in action here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-22: *variadic_relay.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When I run that code, the `call_something_else()` function will call `say_hi()`,
    passing the argument `name="Bob"` to it. That produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This bit of magic will come back into play shortly in writing *decorators* (see
    the section “Decorators” later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Keyword-Only Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use variadic parameters to turn some of your keyword parameters into
    *keyword-only parameters*, which were introduced in PEP 3102\. These parameters
    cannot have values passed in as positional arguments, but rather only as keyword
    arguments. This can be especially useful in ensuring that particularly long or
    perilous parameter lists are used in the proper manner, instead of as nigh-on
    unreadable chains of positional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, I’ll rewrite my `roll_dice()` function to have two keyword-only
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-23: *dice_roll_keyword_only.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I use the unnamed variadic parameter `*`, which ensures every parameter that
    follows it in the list can only be accessed by name. If the caller passes in too
    many positional arguments (or in this case, *any* positional arguments), a `TypeError`
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'This affects the usage, such that I can only use keyword arguments now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-24: *dice_roll_keyword_only.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to use positional arguments raises an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-25: *dice_roll_keyword_only.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: Positional-Only Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of Python 3.8 (via PEP 570), it is also possible to define *positional-only
    parameters*. This is useful when the parameter name is either unhelpful or likely
    to be changed down the road, meaning any code using it as a keyword parameter
    would be likely to break in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll recall that positional parameters must always come first in the parameter
    list. Placing a forward slash (`/`) in the list designates all preceding parameters
    as positional-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-26: *dice_roll_positional_only.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the parameter `dice` still has a default value of `1`, but
    it is now positional-only. On the other hand, `sides` can be used as either a
    positional or a keyword parameter. Here’s that behavior in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-27: *dice_roll_positional_only.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: The first four examples all work, because the positional-only argument `dice`
    is either included as the first argument or omitted altogether. Any attempt to
    access `dice` by keyword fails with a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Argument Types: All Together Now!'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To ensure everything is clear regarding positional parameters and keyword parameters,
    I’ll take a moment to review with this (admittedly contrived) example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The parameter `pos_only` is positional-only, as it comes before the forward-slash
    (`/`) marker. If I have any positional-only parameters, they must appear first
    in the list. Because this parameter has a default value, it is optional. However,
    if I wanted to pass an argument to it, it would need to be the first positional
    argument passed to the function; otherwise, a `TypeError` would be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `pos_kw` parameter, which can be either positional or keyword. It
    comes after any positional-only parameters and after the forward-slash (`/`) marker,
    if there is one.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the asterisk (`*`) marker, I have `kw_only`, which is a keyword-only
    parameter. In this example, if my function receives more than two positional arguments,
    a `TypeError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From time to time, you may want to reuse a piece of logic *within* a function
    but not clutter up your code by making yet another function. In this situation,
    you can nest functions within other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can use this to improve the recursive version of `roll_dice()`, making the
    logic for rolling a single die into something more reusable in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-28: *dice_roll_recursive.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I moved the logic for rolling a single die into a nested function
    `roll()`, which I can call from anywhere in the function `roll_dice()`. The direct
    benefit of abstracting out this logic is that it can be maintained more easily,
    without disrupting the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-29: *dice_roll_recursive.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: That produces the usual random output.
  prefs: []
  type: TYPE_NORMAL
- en: In production, I’d rarely use a nested function for something that trivial.
    Normally, I’d employ a nested function for more complex logic that sees frequent
    reuse, especially if it is used in multiple places in the outer function.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll recall from Chapter 5 that the nested function can access the names of
    its enclosing scope. However, if I wanted to rebind or mutate any of those names
    from within the nested function, I’d need to use the `nonlocal` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a function that builds and returns a kind of function called
    a *closure*, which encloses one or more nonlocal names. This pattern acts as a
    sort of “function factory.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on the dice example, I’ll write a function that returns a *closure*
    for rolling a particular set of dice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-30: *dice_cup_closure.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I create the function `make_dice_cup()`, which accepts the arguments for `sides`
    and `dice`. Inside `make_dice_cup()`, I define a nested function `roll()`, which
    uses `sides` and `dice`. When that nested function is returned by the outer function
    (no parentheses!) ❶, it becomes a closure, because it encloses `sides` and `dice`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-31: *dice_cup_closure.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: I bind the closure returned by `make_dice_cup()` to the name `roll_for_damage`,
    which I can now call as a function without any arguments. The closure continues
    to use `sides` and `dice` with the values I specified earlier to roll dice and
    return values; it is now a function in its own right.
  prefs: []
  type: TYPE_NORMAL
- en: Caution is necessary when using closures, as you can easily violate the rules
    of functional programming with them. If a closure has the ability to mutate the
    values it encloses, it becomes a sort of de facto object, and a difficult one
    to debug at that!
  prefs: []
  type: TYPE_NORMAL
- en: Recursion with Closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous closure example didn’t use the recursive form of the dice-rolling
    code because, while it’s possible to implement such closure correctly, it’s even
    easier to do it wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the most apparently obvious, yet wrong, way to make that closure recursive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-32: *dice_cup_closure_recursive.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: Using what you know about names and scope so far, can you anticipate what’s
    wrong with the above?
  prefs: []
  type: TYPE_NORMAL
- en: 'The giveaway that something is wrong with the closure is the keyword `nonlocal`,
    as it indicates I’m mutating or rebinding a nonlocal name: `dice`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to use this closure will reveal the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-33: *dice_cup_closure_recursive.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That code produces the following output (for example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The first time the closure `roll_for_damage()` is used, everything is fine.
    However, `dice` isn’t reset when the function exits, so all subsequent calls to
    the closure find that `dice == 0`. Thus, they only return `()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a recursive closure, you need to use an optional parameter on the
    closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-34: *dice_cup_closure_recursive.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: In this version, I use the nonlocal name `dice` as the default value of the
    new, local parameter `dice`. (Recall, this will only work with immutable types.)
    This behaves precisely as expected, as it still closes over `sides` and the nonlocal
    `dice`, but it rebinds neither.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful Closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it is generally best to write closures as pure functions, it is occasionally
    useful to create a *stateful closure*—that is, a closure that retains a little
    bit of state between calls that it can use. In general, you should avoid using
    stateful closures unless no other solution presents itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to demonstrate this, I’ll create a stateful closure that limits how many
    times a player can reroll a group of dice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-35: *dice_roll_turns.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I write the closure `roll()` so that it only allows the caller to reroll the
    dice a maximum number of times, specified by `limit`, before the function starts
    returning `None`. By this design, after the limit is reached, a new closure must
    be created. The logic of tracking how many times a player can roll the dice has
    been abstracted out into the closure.
  prefs: []
  type: TYPE_NORMAL
- en: This closure is very limited and predictable in how it mutates and uses its
    state. It’s important to limit your closures in this way, since debugging a stateful
    closure can be difficult. There is no way to see the current value of `limit`
    from outside the closure; it’s simply not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this predictable behavior at work in the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-36: *dice_roll_turns.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that code produces the following randomized output, wherein each turn
    gets three tosses of the dice; each toss is represented by a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: A stateful closure can be useful in situations where writing an entire class
    (see Chapter 7) brings in too much boilerplate. Since I only have one piece of
    state, `limit`, and I am using it predictably, this approach is acceptable. Anything
    more complicated, and debugging becomes impractically difficult.
  prefs: []
  type: TYPE_NORMAL
- en: As I pointed out earlier, anytime you see `nonlocal` in a closure, you should
    be extra cautious, as it indicates the presence of state. This can be acceptable
    on occasion, but there is usually a better approach. Stateful closures are not
    pure functional programming!
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *lambda* is an anonymous (nameless) function made up of a single expression.
    The structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: On the left side of the colon is the parameter list, which may be omitted if
    you don’t want to accept any arguments. On the right is the return expression,
    which is evaluated when the lambda is called and the result is implicitly returned.
    To use a lambda, you must bind it to a name, whether by assignment or by passing
    it as an argument to another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s a lambda that adds two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-37: *addition_lambda.py*'
  prefs: []
  type: TYPE_NORMAL
- en: I bind the `lambda` to the name `add` and then call it as a function. This particular
    lambda accepts two arguments and then returns their sum.
  prefs: []
  type: TYPE_NORMAL
- en: Why Lambdas Are Useful
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many programmers can’t imagine ever needing nameless functions. It would seem
    to make reuse completely impractical. After all, if you’re just going to bind
    a lambda to a name, shouldn’t you have just written a function?
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how lambdas can be useful, let’s take a look at an example *without*
    lambdas first. This code represents a player character in a basic text adventure
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-38: *text_adventure_v1.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m keeping track of my character’s stats in a couple of global names at the
    top, `health` and `xp`, which I’ll use throughout my program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-39: *text_adventure_v1.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: My `attempt()` function handles rolling the dice, using the outcome to decide
    whether the player’s action succeeded or failed, and then modifying the values
    of the global `health` and `xp` variables accordingly. It determines how those
    values should be changed, based on the value returned from calling the function
    passed to `outcome`.
  prefs: []
  type: TYPE_NORMAL
- en: The part to focus on is the parameter `outcome` ❶—which, by its usage in `attempt()`
    ❷, should be a function that accepts a boolean value and returns a tuple of two
    integers representing the desired changes to `health` and `xp`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanding on that example, I’ll use what I’ve built so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-40: *text_adventure_v1.py:3a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s no real pattern to the outcomes of each possible action, so I have
    to write functions for each one: in this example, `eat_bread()` and `fight_ice_weasel()`.
    Even this example is a bit oversimplified, as the code determining the outcome
    might involve a bunch of mathematics and randomization. Regardless, since I need
    a separate outcome function for each action, this code is going to grow rapidly,
    leading to a maintainability nightmare.'
  prefs: []
  type: TYPE_NORMAL
- en: (Be advised, the `if` statement above is not the most Pythonic way to write
    that code; I deliberately chose that structure to illustrate the logic.)
  prefs: []
  type: TYPE_NORMAL
- en: When I attempt an action ❶, I pass the string representing the action, the minimum
    dice roll necessary to succeed, and the function determining the outcome. When
    passing a function, remember not to include the trailing parentheses. Here, I
    want to pass the function itself, not the value it returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of usage is where lambdas come in. I can replace the `eat_bread()`
    and `fight_ice_weasel()` functions, plus the two calls to `attempt()`, with just
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-41: *text_adventure_v1.py:3b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third argument of each is a lambda, which accepts a single parameter named
    `success` and returns a value depending on the value of `success`. Let’s isolate
    just that first lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: When the lambda is called, if the value of `success` is `True`, then `(1, 0)`
    will be returned. Otherwise, `(-1, 0)` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: That lambda is being passed to (and thus bound to) the `outcome` parameter of
    the `attempt()` function, and it is subsequently called with a single boolean
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: By using lambdas in this manner, I can create many different possible outcomes
    in my code with only one line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that *a lambda may only consist of a single return expression*! This
    makes lambdas suitable for short, clear fragments of logic, especially when the
    code is made more readable by keeping that logic close to its usage within another
    function call. If you want anything more complex, you’ll need to write a proper
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas as Sorting Keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common situations where a lambda comes in handy is when specifying
    a *key function*, which is a callable that returns the part of a collection or
    object that should be used for sorting. A key function is typically passed to
    another function that is responsible for sorting data in some manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here I have a list of tuples containing first and last names,
    and I want to sort the list by last name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-42: *sort_names.py*'
  prefs: []
  type: TYPE_NORMAL
- en: The `sorted()` function uses the `key` argument ❶, which is always a function
    or other callable, by passing each item to it and then using the value returned
    from that callable to determine the sorting order. Since I want the tuples sorted
    by last name, which is the second item of each tuple, I have the lambda return
    that item, which is `x[1]`.
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that `by_last_name` contains the list, sorted by last name.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Decorators* allow you to modify the behavior of a function (or even multiple
    functions) by wrapping it in an additional layer of logic. This changes the function’s
    behavior without you having to rewrite the function itself.'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, here’s another example with my text adventure game hero.
    I want to define multiple game events that affect the player character’s statistics
    in different ways, and I want those changes displayed as they happen. I’ll start
    with an implementation that doesn’t use decorators. This code only uses concepts
    I’ve already covered so far in this book, so I’ll mainly draw your attention to
    some inefficiencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by defining my global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-43: *text_adventure_v2.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I’ll define functions for each action the player can take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-44: *text_adventure_v2.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: Each function represents an action the player can take, and some common code
    is shared between these functions. First, each function checks the character’s
    health to determine if the character is even able to perform the action ❶ ❸. If
    the character’s health is sufficient, the player performs the action, which alters
    the character’s statistics. When the action is completed (or if the character’s
    health is too low to take an action), the current stats are displayed ❷ ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, of course, I have the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-45: *text_adventure_v2.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: That works, but as I said, the repeated code in [Listing 6-44](#listing6-44)
    is not very Pythonic. Your first instinct might be to move the common code—the
    code that checks the health and displays the statistics—out into their own functions.
    However, you would still need to remember to call each one within *every character
    action function*, and they’re easy to overlook. Furthermore, each function would
    still need that conditional statement at the top to ensure the code isn’t run
    when health is too low.
  prefs: []
  type: TYPE_NORMAL
- en: This situation, where I want to run the same code before and after every function,
    can be perfectly solved with decorators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I’ll create a decorator toward the top of the text adventure game code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-46: *text_adventure_v2.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: A decorator is most often implemented as a closure, which closes over a function
    (or any other callable object) being modified. The decorator itself, `character_action()`,
    accepts a `func` parameter, which is the callable being modified.
  prefs: []
  type: TYPE_NORMAL
- en: Within the decorator definition is the *wrapper*, which is the callable where
    the decorator’s logic lives ❸. As I said, most commonly, the closure pattern is
    used for this. However, the wrapper can be implemented with any callable, including
    a class. (Technically, I could even implement the wrapper as a noncallable, but
    this is seldom, if ever, useful.)
  prefs: []
  type: TYPE_NORMAL
- en: Because I don’t know how many arguments will be passed to any function I’ll
    apply the decorator to, I set up the wrapper to accept variadic arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The `@functools.wraps(func)` line ❷ prevents the callable being wrapped from
    having its identity concealed from the rest of the program. Without that line,
    wrapping the callable would mess up external access of such important function
    attributes as `__doc__` (the docstring) and `__name__`. This line is itself a
    decorator that ensures all the important attributes of the callable are retained
    by the now-wrapped function, thus making them accessible outside the function
    in all the usual ways. (To use that special decorator, I must import `functools`
    first ❶.)
  prefs: []
  type: TYPE_NORMAL
- en: Inside the wrapper, I put all that logic I want to run before and after each
    function. After checking `health`, I call the function that is bound to `func`,
    unpacking all the variadic arguments into the call. I also bind the return value
    to `result`, so I can ensure that gets returned from the decorator after I print
    the stats.
  prefs: []
  type: TYPE_NORMAL
- en: As with any closure, it is supremely important that the outer function return
    the inner function ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I can use the decorator I wrote and refactor my other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-47: *text_adventure_v2.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: To apply decorators to a function, I list each decorator I want to apply directly
    above the function definition, one decorator per line. I precede each decorator
    name with an `@` symbol. In my example, I only apply a single decorator to each
    function, but you can use as many as you like. They will be applied in order,
    with each decorator wrapping whatever is immediately below it.
  prefs: []
  type: TYPE_NORMAL
- en: Since I moved all the repetitive logic about checking health and displaying
    stats out of the individual functions and into the decorator, my code is cleaner
    and easier to maintain. If you run the code, it works the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: Type Hints and Function Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python 3.5 onward allows you to specify *type hints*, which are exactly that:
    *hints* about what data type should be passed in or returned. These are not strictly
    necessary, given Python’s robust dynamic type system, but they may have a few
    benefits.'
  prefs: []
  type: TYPE_NORMAL
- en: First, type hinting aids in documentation. The function definition now shows
    what type of information it wants, which is especially helpful when your IDE auto-magically
    shows hints as you type arguments in.
  prefs: []
  type: TYPE_NORMAL
- en: Second, type hints help you catch potential bugs sooner. Static type checkers
    like *Mypy* are the primary tools for this (see Chapter 2). Some IDEs, like PyCharm,
    may warn you if you’re doing something weird, like passing a string to something
    type-hinted as an integer.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with statically typed languages like Java and C++, this might
    make you a little excited.
  prefs: []
  type: TYPE_NORMAL
- en: However, understand that using type hints does not trade Python’s dynamic typing
    for static typing!
  prefs: []
  type: TYPE_NORMAL
- en: Python will not raise an error if you pass the wrong type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python will not try to convert data to the specified type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python will actually ignore these hints altogether!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type hints are specified with *annotations*, which are extra pieces of information
    that are permitted by the Python language but are not actually processed by the
    interpreter itself. There are two kinds of annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '*Variable annotations* specify the expected type on a name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '*Function annotations* specify type hints on parameters and function returns.
    Here, I apply function annotations to the `roll_dice()` function from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-48: *dice_roll.py:1e*'
  prefs: []
  type: TYPE_NORMAL
- en: This notation allows me to denote what types I expect for the parameters and
    return. In this case, both parameters should receive an integer, so I follow each
    name with a colon and then `int` as the expected data type. If there’s a default
    value of the expected type, it is included after the type hint.
  prefs: []
  type: TYPE_NORMAL
- en: I denote the return type with an arrow (`->`) and the expected type. Collections
    like tuples and lists are a little trickier to specify with type hints. From the
    `typing` module, I can use the notation `Tuple[ ]`, which is a *generic type*.
    Every value of this particular tuple should be an `int`, but since I don’t really
    know how many will be returned, I specify a `...` to say, “There may be more.”
    Now, the function will be expected to return one or more integers, but no other
    types.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if you don’t know what or how many types will be returned in a tuple,
    you can use the notation `typing.Tuple[typing.Any, ...]`
  prefs: []
  type: TYPE_NORMAL
- en: 'That return type hint in the preceding code example is pretty long. I could
    shorten it by defining a *type alias*, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-49: *dice_roll.py:1f*'
  prefs: []
  type: TYPE_NORMAL
- en: I define `TupleInts` as a type alias for `Tuple[int, ...]`, and I can use it
    the same way throughout my code.
  prefs: []
  type: TYPE_NORMAL
- en: Again, Python itself won’t act on these type hints; it will only recognize the
    notation system as valid and store it in the `__annotations__` attribute of the
    function, nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can now run this code through Mypy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: If there are any mismatches between the type hints and the actual usage, Mypy
    will list these in detail, so they can be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Duck Typing and Type Hints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might think that type hinting is incompatible with duck typing, but thanks
    to the `typing` module, the two generally play very well with one another.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you wanted a function that could accept a single parameter of
    any type that could be iterated over (see Chapter 9), such as a tuple or a list,
    you could use `typing.Iterable[]`, with the contained type in the brackets. For
    this example, I’ll presume that the iterable may contain any type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The parameter `within` is type-hinted to be an iterable with `typing.Iterable[
    ]`. The hint `typing.Any` within the square brackets indicates that the `Iterable`
    can contain items of any data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typing module contains many different such types, enough to fill up a separate
    chapter altogether. The best way to learn more about type hinting is to read the
    documentation: [https://docs.python.org/library/typing.html](https://docs.python.org/library/typing.html).
    I also recommend taking a look at PEP 484, which defined type hinting, and PEP
    3107, which defined function annotations.'
  prefs: []
  type: TYPE_NORMAL
- en: Should You Use Type Hinting?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type hinting is entirely optional, and there are cases for it and against it.
    Some argue that it clutters up the code, impairing the natural readability that
    Python attained through dynamic typing. Others see it as a much-needed tool for
    mitigating the bugs made possible through the lack of static typing.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, you don’t need to make a wholesale “use or don’t use” decision.
    Because type hinting is optional, you can use it in cases where it improves the
    readability and stability of the code and skip it in cases where it doesn’t. Even
    within a function, you can define a type hint for one parameter and omit it for
    the next.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the decision is up to you and your team alone. Only you know if
    and when type hints will be helpful. In short, *know thine own project*.
  prefs: []
  type: TYPE_NORMAL
- en: Since this book focuses on idiomatic Python above all else, and since type hinting
    is entirely optional, I won’t use it in any future examples.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I hope you come away from this chapter with a newfound appreciation for functional
    programming in the Python language. Even when the paradigm is not embraced wholesale,
    its concepts and guidelines inform Pythonic code.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll still apply functional concepts as I move into object-oriented programming
    in the next chapter. I’ve found that, when combined correctly, these paradigms
    interact in surprisingly positive ways.**  **# 7
  prefs: []
  type: TYPE_NORMAL
- en: Objects and Classes
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Objects are the bread and butter of many a programmer. Python makes full use
    of objects, even to the point of inspiring the mantra, “Everything is an object.”
    However, if you’ve worked with classes and objects in any other language, Python’s
    take may surprise you.
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-oriented programming* (or *OOP*) is a paradigm in which data and its
    corresponding logic is organized into objects. If you’re familiar with such languages
    as Java, C++, Ruby, and C#, you’re well acquainted with these concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: Yet, object-oriented programming in Python is not mutually exclusive with functional
    programming; in fact, the two paradigms work very well together.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ll cover the essentials of object-oriented programming in
    Python: creating classes with attributes, modules, and properties. I’ll demonstrate
    adding various behaviors via special methods, and I’ll wrap up with a summary
    of the situations in which classes are the most useful.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a new class is simple. I’ll create a class named `SecretAgent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: Initializing a class'
  prefs: []
  type: TYPE_NORMAL
- en: Below this, in the accompanying suite of the class declaration, I’d add any
    methods I want to include in the object. An object is known as an *instance* of
    a class in Python. I’ll cover this in detail shortly.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, everything is an object, in that everything inherits from the `object`
    class. In Python 3, this inheritance from `object` is implicit, as seen in [Listing
    7-1](#listing7-1). In Python 2, you had to explicitly inherit from `object`, or
    from another class that inherits from `object`. (I cover inheritance in Chapter
    13. You can take it for granted here.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `SecretAgent` class declaration again, this time explicitly inheriting
    from `object`, as Python 2 would have required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: Initializing a class with explicit inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: Listings 7-1 and 7-2 are functionally identical. Python developers really hate
    *boilerplate code*, which is code that is widely reused, with little or no modification.
    That is why Python 3 added the shorter technique seen in [Listing 7-1](#listing7-1).
    Unless you need to support Python 2, the shorter technique is preferred. You’ll
    encounter both ways often enough, so it’s important to know that they do the exact
    same thing in Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: The Initializer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A class often has an *initializer* method for defining the initial values of
    *instance attributes*, which are the member variables that exist in each instance.
    If your instance will have no instance attributes, you don’t need to define `__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want each instance of `SecretAgent` to have a code name and a list of secrets.
    Here’s the initializer for my `SecretAgent` class, which has two instance attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: *secret_agent.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: The initializer must have the name `__init__` to be recognized as an initializer,
    and it must accept at least one argument, conventionally called `self`. This `self`
    argument references the instance the method is acting on.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I also accept a second argument, `codename`, which I use as the
    initial value of one of my instance attributes. This `self.codename` attribute
    will be the code name of the secret agent.
  prefs: []
  type: TYPE_NORMAL
- en: Instance attributes are part of the class instance itself, so I must access
    them through the dot (`.`) operator on `self`. All instance attributes should
    be declared in the initializer method, rather than on the fly in other instance
    methods. Therefore, I’m also defining `self._secrets` as an empty list. This will
    be a list of secrets the particular secret agent (instance) is keeping.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, an initializer must never return a value via the `return` keyword; if
    it does, calling the initializer will raise a `TypeError`. However, you may use
    `return` by itself to explicitly exit the method, if you ever need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever I create a new class instance, the initializer is automatically called.
    Here, I create three `SecretAgent` instances and provide arguments for the `codename`
    parameter of the initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: *secret_agent_usage.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: In this module, I import my `SecretAgent` class and create three new instances.
    You’ll notice that I didn’t need to pass anything to the first parameter, `self`.
    That’s taken care of behind the scenes. Instead, my first argument, `"Mouse"`,
    is passed to the second parameter of the initializer, `codename`. Each instance
    also has its own empty `_secrets` list.
  prefs: []
  type: TYPE_NORMAL
- en: The Constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re coming from C++, Java, or some similar language, you may expect to
    write a *constructor*—a function that constructs an instance of a class—or you
    may think that the initializer does the same thing as a constructor. In fact,
    Python 3 splits the duties of a typical constructor between the initializer `__init__()`
    and the constructor `__new__()`.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the constructor `__new__()` takes care of actually creating the instance
    in memory. When you create a new instance, the constructor is automatically called
    first, followed by a call to the initializer. The constructor is the only method
    in the class to be called automatically before the object is created!
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t normally need to define a constructor; one is provided automatically.
    The only time you would create a constructor would be if you needed additional
    control over the process. However, to familiarize you with the syntax, I’ll write
    a very basic (and effectively pointless) constructor, which could go in a class
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The constructor always has the name `__new__`, and it implicitly accepts a class
    as its first parameter, `cls` (in contrast to the initializer, which accepts a
    class instance on `self`). Since the initializer accepts parameters, I also need
    to prepare the constructor to accept these on the constructor, so I use variadic
    arguments to capture these arguments and pass them on to the initializer parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor must return the class instance that gets created. Technically,
    I could return whatever I wanted here, but the expected behavior would almost
    certainly be to return an instance that has been instantiated from the `SecretAgent`
    class. To do that, I call the `__new__` function on the parent class, which you
    may recall (from [Listing 7-2](#listing7-2)) is `object`. (I’ll return to `super()`
    in Chapter 13. Don’t worry about understanding it now.)
  prefs: []
  type: TYPE_NORMAL
- en: In practice, if this is all your constructor needs to do, just omit it! Python
    automatically handles the constructor behavior if you don’t write any code for
    it. Only write a constructor when you need to control the behavior around instantiating
    the class instance itself. In any event, that scenario is rare; it is perfectly
    plausible that you will never write a constructor in your entire Python programming
    career.
  prefs: []
  type: TYPE_NORMAL
- en: The Finalizer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *finalizer* is called when a class instance finally reaches the end of
    its lifespan and is cleaned up by the garbage collector. It exists solely to handle
    any technically complex cleanup that your particular class may require. As with
    the constructor, you will seldom, if ever, need to write this function yourself.
    If you do, it’s important to understand: the finalizer is only called if the class
    instance (value) itself is cleaned up by the garbage collector!'
  prefs: []
  type: TYPE_NORMAL
- en: If any references to the class instance still exist, the finalizer won’t be
    called; furthermore, depending on the implementation of Python you’re using, the
    garbage collector might not always clean up the class instance when you’d expect,
    if at all.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, only use the finalizer for code directly relating to garbage-collecting
    the class instance. It should never contain code that needs to be run as part
    of any other circumstance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a rather useless finalizer that prints a message when the garbage collector
    cleans up a `SecretAgent` class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: *secret_agent.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: A finalizer always has the name `__del__` and accepts a single parameter, `self`.
    It must not return anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this finalizer, I’ll create and manually delete an instance.
    It is possible to delete a name, thereby unbinding it from its value, by using
    the `del` keyword. Given the `SecretAgent` class with that finalizer method, I
    can create and then delete a name referring to a class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: *secret_agent_disavow.py*'
  prefs: []
  type: TYPE_NORMAL
- en: I create a new instance from the `SecretAgent` class and bind it to the name
    `weasel`. Then, I immediately delete the name by using the `del` operator. The
    name `weasel` is now undefined again. Coincidentally, because no references remain
    to the `SecretAgent` instance the name was bound to, that instance is cleaned
    up by the garbage collector, which first calls the finalizer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, running that code displays this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Note that `del` only deletes the name, not the value! If you have multiple names
    bound to the same value, and if you `del` one of those names, then the other names
    and their values will be unaffected. In other words, `del` will not force the
    garbage collector to delete the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All variables belonging to a class or instance are called *attributes*. Attributes
    belonging to the instance itself are called *instance attributes*, which are also
    sometimes referred to as *member variables*. Attributes belonging to the class
    itself are *class attributes*, which are also sometimes called *class variables*.
  prefs: []
  type: TYPE_NORMAL
- en: Many intermediate-level Python programmers don’t realize there is a significant
    difference between the two. I must admit, I spent the first few years of my Python
    development career using them utterly incorrectly!
  prefs: []
  type: TYPE_NORMAL
- en: Instance Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *instance attribute* exists on the instance itself; its value is unique to
    the instance and is not available to other instances. All instance attributes
    should be declared in the class’s initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting the `__init__()` method from [Listing 7-3](#listing7-3), you’ll
    see I have two instance attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Class Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *class attribute* exists on the class, instead of on an individual instance.
    In practice, this means that all related class instances effectively “share” a
    class attribute, although it would exist even without any instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class attributes are declared at the top of the class, outside of any methods.
    Here, I add one class attribute directly into the suite of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: *secret_agent.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: The attribute `_codeword` belongs to the `SecretAgent` class. Typically, all
    class attributes are declared before any methods to make them easier to find,
    although this is just convention. The important part is that they are defined
    outside of any methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class attribute can be accessed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-8: *secret_agent_usage.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: I can access the class attribute `_codeword` directly through the class, or
    through any instances instantiated from the class. If the class attribute is rebound
    or mutated on the class itself ❶, the changes will appear in all cases. However,
    if a value is assigned to the name on an instance, it will create an instance
    attribute with the same name ❷, which shadows the class attribute on that instance,
    without affecting other instances.
  prefs: []
  type: TYPE_NORMAL
- en: Class attributes are particularly useful for constant values that the class’s
    methods use. I also find them more practical and maintainable than global variables
    in many cases, especially in GUI programming. For example, I often employ class
    attributes when I need to maintain a shared instance of a widget, like a window.
  prefs: []
  type: TYPE_NORMAL
- en: Scope-Naming Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re coming from a language that has class scope, you may wonder why I
    haven’t mentioned it yet. Isn’t data hiding an important part of encapsulation?
    In fact, Python has no formal concept of data hiding. Instead, PEP 8 outlines
    a naming convention that indicates whether an attribute is safe to modify externally
    (public) or not (nonpublic).
  prefs: []
  type: TYPE_NORMAL
- en: While I talk a lot about attributes in this section, these naming conventions
    apply to methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: Nonpublic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By preceding a name with an underscore, I declare that the attribute `_secrets`
    is intended to be *nonpublic*, meaning it shouldn’t be modified (or, ideally,
    accessed) outside of the class. This is more of a social contract via style convention;
    I’m not actually hiding anything.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem dangerous to many developers coming from languages with explicit
    scope, like Java, but it works out pretty well. As my pal “grym” likes to put
    it, “If you know why you shouldn’t stick a fork in a toaster, you are therefore
    qualified to stick a fork in a toaster.” In other words, if the client is going
    to disregard the underscore warning label, they probably know what they’re doing.
    (On the off-chance they don’t, they’re fully responsible for the consequences.)
    That little underscore hanging out after the dot operator is advertising “You
    really shouldn’t mess with me!”
  prefs: []
  type: TYPE_NORMAL
- en: Public
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The attribute `codename`, which does not start with an underscore, is intended
    to be *public*. It is okay for this attribute to be accessed or modified externally,
    as it won’t really affect the behavior of the class. Public attributes are preferable
    to writing a plain getter/setter pair of methods; the behavior is the same, but
    the result is cleaner, with less boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: If an attribute needs a custom getter or setter, one approach is to define the
    attribute as nonpublic and create a public *property*, which I’ll come back to
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Name Mangling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python does offer *name mangling*, which rewrites an attribute or method name
    to prevent it from being shadowed by derived (inheriting) classes. This provides
    a sort of weak form of data hiding. It can also be useful for an added level of
    forewarning: “No, *really*, if you mess with this attribute, terrible things will
    happen!”'
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark an attribute (or method) for name mangling, precede the name with two
    underscores (`__`), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-9: *message.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__format` attribute will be name mangled, so accessing it externally in
    the ordinary manner will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-10: *message.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will raise an `AttributeError` because the `msg` instance does not have
    an attribute named `__format`; the name of that attribute was mangled. Be aware
    that name mangling is *not* a true form of data hiding! It is still perfectly
    possible to access a name-mangled attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-11: *message.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The name-mangling pattern is predictable: an underscore, the name of the class,
    and then the name of the attribute, with its two leading underscores.'
  prefs: []
  type: TYPE_NORMAL
- en: Public, Nonpublic, or Name Mangled?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When deciding whether to make an attribute public or nonpublic, I ask myself
    one question: could changing this attribute externally cause unexpected or negative
    behavior in the class? If the answer is yes, I make the attribute nonpublic by
    preceding it with an underscore. If the answer is no, I leave the attribute public.
    It is up to the coder using the class to respect the rules or suffer the consequences.'
  prefs: []
  type: TYPE_NORMAL
- en: As to name mangling, in practice, I very rarely employ this pattern. I reserve
    it only for those cases where (a) I need to avoid a naming conflict in the context
    of inheritance or (b) external access of the attribute will have exceptionally
    horrific effects on the behavior of the class, and thus, an extra degree of warning
    is justified.
  prefs: []
  type: TYPE_NORMAL
- en: Always remember that Python does not have private class scope. Truly secret
    data should be properly encrypted, not just concealed from your API. There are
    also no optimization benefits to private class scope, unlike in languages like
    Java, since all attribute lookups occur at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class is nothing without its methods, which make encapsulation possible.
    There are three distinct types of methods: instance methods, class methods, and
    static methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Instance Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Instance methods* are your run-of-the-mill methods, which exist on the instance
    itself. The first parameter, conventionally named `self`, provides access to the
    instance attributes of the instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I add an instance method to my `SecretAgent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-12: *secret_agent.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the required first parameter, the instance method accepts a second parameter,
    `secret`, which is appended to the list bound to the instance attribute `_secrets`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I call this method on the instance, using the dot operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-13: *secret_agent_usage.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: The dot operator implicitly passes `mouse` to the `self` parameter, so my first
    argument, the tuple of coordinates (notice the extra set of parentheses), is passed
    to the second parameter, `secret`, on the `remember()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Class Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like class attributes, *class methods* belong to the class, instead of to the
    instances instantiated from the class. These are useful for working with class
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in [Listing 7-7](#listing7-7), I defined `_codeword` as a class attribute
    so all `SecretAgent` instances would be aware of the code word; it’s something
    all agents should have in common. I need a way to inform all the agents at once
    of the new code word, so I’ll add a class method, `inform()`, which will modify
    the `_codeword` class attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-14: *secret_agent.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: I precede a class method with the built-in `@classmethod` decorator. A class
    method receives the class as its first argument, so the first parameter is named
    `cls`. Class attributes like `_codeword` are accessed on the class passed to `cls`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of this approach is that I don’t have to worry about whether
    I’m calling `inform()` on the class or on an instance. Because the method is a
    class instance, it will always access the class attribute on the class (`cls`),
    instead of the instance (`self`), and thus avoid accidentally shadowing `_codeword`
    on a single instance (see [Listing 7-8](#listing7-8)).
  prefs: []
  type: TYPE_NORMAL
- en: I don’t plan to include a getter for this attribute. After all, secret agents
    have to keep secrets!
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this method, I would call something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-15: *secret_agent_usage.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: I can call the `inform()` class method directly on the `SecretAgent` class,
    or on any `SecretAgent` instance, such as `fox`. The changes that `inform()` makes
    to the class attribute `_codeword` appear on the class itself and all its instances.
  prefs: []
  type: TYPE_NORMAL
- en: When calling the class method with the dot operator, the class is implicitly
    passed to the `cls` parameter. That parameter name is still just a convention;
    the `@classmethod` decorator is what ensures that the first argument is always
    the class, never the instance.
  prefs: []
  type: TYPE_NORMAL
- en: One awesome use of class methods is to provide alternative means of initializing
    instances. For example, the built-in integer class offers `int.from_bytes()`,
    which initializes a new `int` class instance, using a `bytes` value.
  prefs: []
  type: TYPE_NORMAL
- en: Static Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *static method* is a regular function defined within a class, which accesses
    neither the instance attributes nor the class attributes. The only difference
    between a static method and a function is that a static method belongs to the
    class for namespace reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason to write a static method comes up when your class offers some
    functionality that doesn’t need to access any of the class or instance attributes
    or methods. For example, you may write a static method for handling some particularly
    complicated algorithm that is critical to your class’s implementation. By including
    the static method in the class, you are indicating that the algorithm is part
    of the class’s self-contained implementation logic, even though it does not access
    any attributes or methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll add a static method to the `SecretAgent` class, which handles one thing
    all the agents would do the same, regardless of their data—answer questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-16: *secret_agent.py:5*'
  prefs: []
  type: TYPE_NORMAL
- en: I precede the static method with the `@staticmethod` decorator. You’ll notice
    that I don’t need to worry about a special first parameter, since the method doesn’t
    need access to any attributes. When this method is called on a class or on an
    instance, it only prints out the message, “I know nothing.”
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Properties* constitute a special variety of instance method that allows you
    to write getters and setters that behave so it appears that you were directly
    accessing an instance attribute. Properties allow you to write a consistent interface,
    where you use the object directly through what appear to be its attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: It is preferable to use properties, instead of making the user remember whether
    to call a method or use an attribute. Using properties is also much more Pythonic
    than cluttering your class with bare getters and setters that don’t augment attribute
    access or modification.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To demonstrate properties in action, I’ll expand on my `SecretAgent` class.
    Here’s the class so far. First, to set up, I’ll move it to a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-17: *secret_agent_property.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I will add one more class method to encrypt whatever message is passed
    to it, using an encryption system of my own devising. This method has nothing
    to do with properties per se, but I include it to make the example complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-18: *Using a property with no getter*'
  prefs: []
  type: TYPE_NORMAL
- en: The `_encrypt()` class method uses the `_codeword` class attribute to perform
    a basic substitution cipher encoding on a string `message`. I use `sum()` to find
    the sum of the Unicode code points (as integers) for each character in `_codeword`.
    I pass a character (string) to the `ord()` function, which returns the Unicode
    code point as an integer. This sum of code points is bound to `code`. (The odd-looking
    loop here is actually a generator expression, which I’ll cover in Chapter 10.
    You can take it for granted here that it calls `ord()` on each character in the
    string bound to `cls._codeword`.)
  prefs: []
  type: TYPE_NORMAL
- en: I use `code` to offset the Unicode code point of each character in the message.
    The `chr()` function returns the character associated with the given code point.
    I pass to it the sum of the current code point and `code`, for each character
    in the message. (Once again, I’m employing a generator expression here.)
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *property* behaves like an attribute, but it is made up of three instance
    methods: a *getter*, a *setter*, and a *deleter*. Remember that a property appears
    to be an ordinary attribute to the user of the class. Accessing the property calls
    the getter, assigning a value to it calls the setter, and deleting the property
    with the `del` keyword calls the deleter.'
  prefs: []
  type: TYPE_NORMAL
- en: Like an ordinary getter or setter method, a property might access or modify
    a nonpublic attribute, multiple attributes, or even no attributes at all. It all
    depends on what behavior you want.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I’ll define a property called `secret` for my `SecretAgent` class, which
    will serve as the getter, setter, and deleter for my `_secrets` instance attribute.
    This approach will allow me to add logic, such as having the setter encrypt the
    assigned data before storing it in the `_secrets` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Before defining the property itself, I need to define the three functions that
    will make up the property. Technically, I can call them whatever I like, but the
    convention is to name them `getx`, `setx`, or `delx`, where `x` is the name of
    the property. I’m also making these nonpublic methods, since I want the client
    to use the property directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-19: *secret_agent_property.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: The getter, `_getsecret()`, accepts no parameters and should return the value
    of the property. In this example, I want the getter to return the last item stored
    in the list bound to the instance attribute `self._secrets`, or if the list is
    empty, to return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-20: *secret_agent_property.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: The setter, `_setsecret()`, accepts a single parameter, which receives the value
    being assigned to the property in the call (see [Listing 7-23](#listing7-23)).
    In this case, I assume this is some sort of string, which I run through the static
    method `_encode()` I defined earlier and then store in the list `self._secrets`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here’s the deleter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-21: *secret_agent_property.py:5*'
  prefs: []
  type: TYPE_NORMAL
- en: The *deleter*, `_delsecret()`, accepts no parameters and returns no value. This
    method is called when the property is deleted, either in the background, by the
    garbage collector, or explicitly, with `del secret`. In this example, when the
    property is deleted, I want the entire list of secrets to be cleared.
  prefs: []
  type: TYPE_NORMAL
- en: You actually don’t need to define a deleter if you have no need for special
    behavior when the decorator is deleted. Consider what you want to happen if `del`
    is called on your decorator, such as when you are deleting an associated attribute
    that the property controls; if you can’t think of anything, skip writing the deleter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I define the property itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-22: *secret_agent_property.py:6a*'
  prefs: []
  type: TYPE_NORMAL
- en: This is defined on the class itself, outside of the `__init__()` method and
    after the functions that make it up. I pass the three methods to the `fget`, `fset`,
    and `fdel` keyword arguments, respectively (although you can also pass them as
    positional arguments, in that same order). I bind the property to the name `secret`,
    which becomes the property name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The property can now be used as if it were an instance attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-23: *secret_agent_property.py:7a*'
  prefs: []
  type: TYPE_NORMAL
- en: Every time I try to retrieve the value of the property, the getter is called.
    Meanwhile, assigning a value to the property calls the setter. There’s no need
    to remember and explicitly call dedicated getter or setter methods; I treat the
    property like an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll recall that the deleter for `secrets` clears the contents of the `_secrets`
    list. Just before deleting the property, the list contains two secrets. After
    deleting, the list is empty.
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to define all three parts of the property. For example,
    I don’t want the `secret` property to even have a getter, so I can remove `_getsecret()`
    from my class code. Secret agents shouldn’t share their secrets, after all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-24: A secret property with no getter'
  prefs: []
  type: TYPE_NORMAL
- en: Because I don’t pass an argument to `fget`, the default value of `None` is used
    instead ❶. This property has a setter and a deleter, but no getter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, I can assign to `secret`, but I can’t access the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-25: *Using a property with no getter*'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning values to `mouse.secret` works as before, since that calls the setter.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, attempting to access the value throws an `AttributeError`. I could
    instead have written a getter for secrets that always returned `None`, but the
    client would have to remember that it returned this useless value. Recall The
    Zen of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Errors should never pass silently.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unless explicitly silenced.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a particular usage is not desired, especially when it comes to designing
    a class or interface, the usage should *explicitly fail*.
  prefs: []
  type: TYPE_NORMAL
- en: Property with Decorators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a property is easy enough, but the approach to implementing it that
    I’ve shown thus far doesn’t really feel very Pythonic, because I have to rely
    on my method names to remind me that they’re part of a property. Thankfully, there’s
    another way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python offers a cleaner approach to defining properties: with decorators. There
    are two approaches to this technique.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Approach 1: property() and Decorators'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first approach is to still employ the `property()` function but use decorators
    to denote the associated methods. The chief benefit of this approach is the added
    readability, and it is mainly used when the getter will be omitted. I can use
    the name of the property as the method name and rely on the decorator to clarify
    its role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my rewritten code for the `secret` property, using this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-26: *secret_agent_property.py:3b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this approach, I define `secret` as a property before writing its methods.
    I pass no arguments to `property()`, so all three functions default to `None`.
    Next, I add the getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-27: *secret_agent_property.py:4b*'
  prefs: []
  type: TYPE_NORMAL
- en: My getter method now must have the same name as the property, `secret`. If it
    doesn’t, it will fail with an `AttributeError` when the getter is first called,
    rather than when the class is created. The method is preceded by the decorator
    `@secret.getter`. This designates it as the getter for the property, just as if
    I had passed it to `property(fget=)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-28: *secret_agent_property.py:5b*'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the setter method must share its name with the property it relates
    to, and it is preceded by the decorator `@secret.setter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the deleter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-29: *secret_agent_property.py:6b*'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the getter and setter, the deleter is preceded by the decorator `@secret.deleter`.
  prefs: []
  type: TYPE_NORMAL
- en: This version works as is, but there is an even better technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Approach 2: Decorators Without property()'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second approach to declaring a property with decorators is even shorter,
    and it is the most commonly used. This approach is preferred when defining a property
    that has a getter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have defined a getter, you don’t have to explicitly create and assign
    a `property()`. Instead, the decorator `@property` can be applied to the getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: I precede the getter function with the decorator `@property`, instead of `@secret.getter`,
    which creates a property with the same name as the method. Since this defines
    the property `secret`, I don’t need `secret = property()` anywhere in my code.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind, this shortcut only works with the getter method. The setter and
    deleter must be defined in the same manner as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, I can omit any of the three methods if their behavior is not desired.
    For example, if I don’t want `secret` to be readable, I omit the getter, so my
    full property code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Because I don’t have a getter, I must explicitly declare my property up front
    ❶. In this version, assignment and deletion of `secret` works as before, but accessing
    the value raises an `AttributeError`.
  prefs: []
  type: TYPE_NORMAL
- en: When Not to Use Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s some debate about when to use properties, versus traditional getter
    and setter methods. One of the chief drawbacks of properties is that they conceal
    that some calculation or processing is being performed upon assignment, which
    the client might not expect. This especially becomes a problem if this processing
    is particularly long or complicated, such that a client may need to run it concurrently
    with `async` or threads (see Chapters 16 and 17); you cannot run an assignment
    concurrently with the same ease as running a method concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: You must also consider the expected behavior of an assignment. When a value
    is directly assigned to an attribute, you would typically expect the same value
    to be retrievable *from* that attribute. In reality, depending on how you wrote
    your properties, the value might be transformed when assigned or accessed. You’ll
    need to take this client expectation into consideration when designing your class.
  prefs: []
  type: TYPE_NORMAL
- en: Some camps believe properties should only be used as a way of deprecating attributes
    that used to be public or that have been removed entirely. Others, like myself,
    find properties useful as replacements for otherwise relatively simplistic getters
    and setters that still involve more logic than plain assignment and access.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, properties are some of those cool features of Python that are all
    too easy to misuse or misapply. Carefully consider the implications of properties,
    public attributes, or methods in your specific case. Take the occasion to consult
    the advice of other experienced Python developers, such as in the Libera.Chat
    IRC `#python` channel. (If you want to debate the most Pythonic general position
    on properties, though, bring a helmet.)
  prefs: []
  type: TYPE_NORMAL
- en: Special Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Special methods are my favorite part of Python object-oriented programming.
    I’m trembling a little with excitement right now (or maybe I had too much coffee).
    *Special methods*, sometimes called *magic methods*, allow you to add support
    to your classes for virtually any Python operator or built-in command!
  prefs: []
  type: TYPE_NORMAL
- en: 'Special methods are also colloquially known as *dunder methods*—which is short
    for “***d***ouble ***under***score”—because they begin and end with two underscore
    characters (`__`). You’ve already seen three examples of special methods: `__init__()`,
    `__new__()`, and `__del__()`. The Python language defines about a hundred special
    methods, most of which are documented at [https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html).
    I’ll cover a number of the most common ones here. In future chapters, I’ll discuss
    other special methods as they become relevant. I also list all the special methods
    in Python in Appendix A.'
  prefs: []
  type: TYPE_NORMAL
- en: Scenario Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the examples in this section, I’ll use a new class, `GlobalCoordinates`,
    which will store a global coordinate as latitude and longitude. This class is
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-30: *global_coordinates.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: You can probably work out what’s going on here, based on the knowledge you have
    so far. The class `GlobalCoordinates` converts and stores a latitude and longitude
    as tuples of degrees, minutes, seconds, and a string literal representing a cardinal
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: I chose to create this particular class because its data lends itself well to
    a healthy subset of the special methods I’ll cover.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to represent the same data, and most clients will expect
    to be able to convert an object containing data to any Python primitive type that
    makes sense. For example, global coordinates could be expressed as strings or
    hashes. You should carefully consider what data types your class should support
    conversion to. Here, I cover some special methods for data conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Canonical String Representation: __repr__()'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When writing a class, it is considered good practice to define, at minimum,
    the `__repr__()` instance method, which returns the *canonical string representation*
    of the object. This string representation should ideally contain all the data
    necessary to create another class instance with the same contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I don’t define a `__repr__()` instance method for `GlobalCoordinates`, Python
    falls back on its default version for objects, which is pretty uselessly underwhelming.
    I’ll create an instance of `GlobalCoordinates` and print this default representation
    via `repr()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-31: *global_coordinates_usage.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that prints out the following canonical string representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Not good for much, is it? Instead, I’ll define my own `__repr__()` instance
    method for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-32: *global_coordinates.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I return a string containing all the information needed to recreate the instance:
    the class name, the latitude, and the longitude.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerunning the code in [Listing 7-31](#listing7-31) now produces more useful
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Human-Readable String Representation: __str__()'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__str__()` special method has a similar purpose to `__repr__()`, except
    that it’s meant to be human-readable, as opposed to the more technically inclined
    canonical representation, which is more useful for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t define `__str__()`, the `__repr__()` function will be used instead,
    but that wouldn’t be desirable in this example. The user should only see the pretty
    coordinates!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my `__str__()` instance method for `GlobalCoordinates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-33: *global_coordinates.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with `__repr__()`, I omit all that boring technical information and focus
    on composing and returning a string representation a user might want to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is called when an instance of the class is passed to `str()`, although
    passing the instance directly to `print()` or as an expression in a formatted
    string will also invoke `__str__()`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-34: *global_coordinates_usage.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Lovely and readable!
  prefs: []
  type: TYPE_NORMAL
- en: 'Unique Identifier (Hash): __hash__()'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__hash__()` method typically returns a *hash value*, which is an integer
    that is unique to the data within the class instance. This allows you to use instances
    of the class in certain collections, such as keys in a dictionary or values in
    a set (see Chapter 9). It’s often helpful to write this method yourself, as the
    default behavior results in every class instance having a unique hash value, even
    if two instances contain the exact same data.
  prefs: []
  type: TYPE_NORMAL
- en: The `__hash__()` method should only depend on values that won’t change for the
    life of the instance! Several collections rely on these hash values *never changing*,
    but the value of a mutable object might change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my `__hash__()` function for `GlobalCoordinates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-35: *global_coordinates.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve taken the most common approach, which is to create a tuple containing all
    the important instance attributes and then to call `hash()` on the tuple, which
    returns the hash value of whatever is passed to it. I then return that hash value.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Conversion Special Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python has special methods for converting the data in the instance to other
    forms. It is up to you to decide which of these you will define on your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__bool__()` should return `True` or `False`. If this isn’t defined, the automatic
    conversion to a boolean value will check whether `__len__()` returns a nonzero
    value (see Chapter 9); otherwise, `True` will always be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__bytes__()` should return a `bytes` object (see Chapter 12).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ceil__()` should return an `int` numeric value, usually resulting from rounding
    up a `float` value to the nearest integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__complex__()` should return a `complex` numeric value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__float__()` should return a `float` numeric value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__floor__()` should return an `int` numeric value, usually resulting from
    rounding down a `float` numeric value to the nearest integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__format__()` should accept a string representing the format specification
    (see Chapter 3) and return a string representation of the instance, with the specification
    applied. How exactly you apply the specification is up to you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__index__()` should return the same value as `__int__()`, which must also
    be defined if you write this method. The presence of this method indicates that
    the class should be considered a type of integer; you don’t have to throw away
    any data to get the integer value (lossless conversion).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__int__()` should return an `int` numeric value. You may simply have this
    function call `__ceil__()`, `__floor__()`, `__round__()`, or `__trunc__()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__round__()` should return an `int` numeric value, usually resulting from
    rounding a `float` numeric value up or down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__trunc__()` should return an `int` numeric value, usually resulting from
    dropping the non-whole (decimal) part of a `float` numeric value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You only need to define the special methods that make sense for your class.
    In my case, *none* of these additional conversion methods are particularly suitable
    for a pair of global coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python has six comparison special methods that correspond to the six comparison
    operators in Python: `==`, `!=`, `<`, `>`, `<=`, and `>=`. Each one conventionally
    returns a boolean value.'
  prefs: []
  type: TYPE_NORMAL
- en: If one of these special methods is called, but the method isn’t defined, the
    class instance will return the special value `NotImplemented` to alert Python
    that the comparison didn’t happen. This allows the language to decide the best
    response. In the case of comparisons with built-in types, `NotImplemented` will
    be coerced to the boolean value `False`, so as to not break algorithms that rely
    on those functions. In most other situations, a `TypeError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equals: __eq__()'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `__eq__()` special method is called by the equals (`==`) operator. I’ll
    define this method for my `GlobalCoordinates` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-36: *global_coordinates.py:5*'
  prefs: []
  type: TYPE_NORMAL
- en: 'All comparison special methods accept two parameters: `self` and `other`. These
    represent the operands on the left and right of the operator, so `a == b` would
    call `a.__eq__(b)`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the ongoing example, it would only make sense to compare two `GlobalCoordinates`
    class instances to one another. Comparing a `GlobalCoordinates` instance directly
    to an integer or a float wouldn’t be logical. Thus, this is one of those rare
    scenarios where type matters. I use `isinstance()` to ensure `other` is an instance
    of the `GlobalCoordinates` class (or a subclass thereof) ❶. If it is, I compare
    the instance attributes that constitute the latitude and longitude of one `GlobalCoordinates`
    instance to the same attributes of the other instance. I return `True` if they
    all match.
  prefs: []
  type: TYPE_NORMAL
- en: However, if `other` is of a different type, the comparison doesn’t happen, so
    I return the special value `NotImplemented` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not Equals: __ne__()'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `__ne__()` special method corresponds to the not-equals (`!=`) operator.
    If undefined, a call to `__ne__()` *delegates* to `__eq__()`, just returning the
    opposite value that `__eq__()` does. If this is what you’re expecting, there’s
    no need to define `__ne__()`.
  prefs: []
  type: TYPE_NORMAL
- en: However, if there’s more complex logic to your not-equals comparison, it might
    make sense to define it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Less Than and Greater Than: __lt__() and __gt__()'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The special methods `__lt__()` and `__gt__()` correspond to the less-than (`<`)
    and greater-than (`>`) operators, respectively. These two special methods are
    *reflections* of one another, meaning one operator in the pair can be substituted
    for the other. The expression `a < b` calls `a.__lt__(b)`, but if that returns
    ``NotImplemented, Python automatically flips the logic and calls `b.__gt__(a)`.
    Thus, if you’re only comparing instances of the same class, you can often get
    away with defining just one of the two special methods: usually, `__lt__()`. The
    same is true of `__le__()` and `__ge__()`, which correspond to less-than-or-equal-to
    (`<=`) and greater-than-or-equal-to (`>=`).``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]  def __sub__(self, other):         if not isinstance(other, GlobalCoordinates):             return
    NotImplemented          lat_diff = self.latitude - other.latitude         lon_diff
    = self.longitude - other.longitude         return (lat_diff, lon_diff) [PRE165]  def
    __invert__(self):         return GlobalCoordinates(             latitude=self.degrees_from_decimal(-self.latitude,
    lat=True),             longitude=self.degrees_from_decimal(-self.longitude, lat=False)         )
    [PRE166]  def __call__(self, ❶ other):         EARTH_RADIUS_KM = 6371          distance_lat
    = math.radians(other.latitude - self.latitude)         distance_lon = math.radians(other.longitude
    - self.longitude)         lat = math.radians(self.latitude)         lon = math.radians(self.longitude)         a
    = (             math.sin(distance_lat / 2)             * math.sin(distance_lat
    / 2)             + math.sin(distance_lon)             * math.sin(distance_lon
    / 2)             * math.cos(lat)             * math.cos(lon)         )         c
    = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))        ❷ return c * EARTH_RADIUS_KM
    [PRE167] nostarch = GlobalCoordinates(latitude=(37, 46, 32.6, "N"),                              longitude=(122,
    24, 39.4, "W"))  psf = GlobalCoordinates(latitude=(45, 27, 7.7, "N"),                         longitude=(122,
    47, 30.2 "W"))  distance = nostarch(psf) print(distance)  # 852.6857266443297
    [PRE168] class CoffeeOrder:      def __init__(self, recipe, to_go=False):         self.recipe
    = recipe         self.to_go = to_go      def brew(self):         vessel = "in
    a paper cup" if self.to_go else "in a mug"         print("Brewing", *self.recipe.parts,
    vessel)   class CoffeeRecipe:      def __init__(self, parts):         self.parts
    = parts   special = CoffeeRecipe(["double-shot", "grande", "no-whip", "mocha"])
    order = CoffeeOrder(special, to_go=False) order.brew()  # prints "Brewing double-shot
    grande no-whip mocha in a mug" [PRE169] import functools ❶ def auto_order(to_go):     def
    decorator(cls):         @functools.wraps(cls)         def wrapper(*args, **kwargs):          ❷
    recipe = cls(*args, **kwargs)          ❸ return (CoffeeOrder(recipe, to_go), recipe)         return
    wrapper   ❹ return decorator [PRE170] @auto_order(to_go=True) class CoffeeShackRecipe(CoffeeRecipe):     pass   order,
    recipe = CoffeeShackRecipe(["tall", "decaf", "cappuccino"]) order.brew()  # prints
    "Brewing tall decaf cappuccino in a paper cup" [PRE171] class Pizza:      def
    __init__(self, topping, second_topping=None):         self.first = topping         self.second
    = second_topping  order = Pizza("pepperoni", "mushrooms")  match order:     case
    Pizza(first=''pepperoni'', second=''mushroom''):         print("ANSI standard
    pizza")     case Pizza(first=''pineapple''):         print("Is this even pizza?")
    [PRE172] # `--snip--`  match order:   # `--snip--`     case Pizza(first=''pineapple''):         print("Is
    this even pizza?")  **case Pizza(first=first, second=''cheese''):**  **print(f"Very
    cheesy pizza with {first}.")** [PRE173] # `--snip--`  match order:   # `--snip--`  `case
    Pizza(first=first, second=''cheese''):`  `print(f"Very cheesy pizza with {first}.")`  **case
    Pizza(first=first, second=second):**  **print(f"Pizza with {first} and {second}.")**
    [PRE174] class Point:     def __init__(self, x, y, z):         self.x_pos = x         self.y_pos
    = y         self.z_pos = z   point = Point(0, 100, 0)  match point:     case Point(x_pos=0,
    y_pos=0, z_pos=0):         print("You are here.")     case Point(x_pos=0, y_pos=_,
    z_pos=0):         print("Look up!") [PRE175] class Point:  **__match_args__ =
    (''x_pos'', ''y_pos'', ''z_pos'')**      def __init__(self, x, y, z):         self.x_pos
    = x         self.y_pos = y         self.z_pos = z   point = Point(0, 123, 0)  match
    point:     case Point(**0, 0, 0**):         print("You are here.")     case Point(**0,
    _, 0**):         print("Look up!") [PRE176] thing.action()  # this can mutate
    attributes in thing [PRE177] action(thing)  # should not modify thing; returns
    new value or object [PRE178]`  [PRE179] import random   def generate_puzzle(low=1,
    high=100):     print(f"I''m thinking of a number between {low} and {high}...")     return
    random.randint(low, high) [PRE180] def make_guess(target):     guess = int(input("Guess:
    "))      if guess == target:         return True      if guess < target:         print("Too
    low.")     elif guess > target:         print("Too high.")     return False [PRE181]
    def play(tries=8):     target = generate_puzzle()     while tries > 0:         if
    make_guess(target):             print("You win!")             return   tries -=
    1         print(f"{tries} tries left.")      print(f"Game over! The answer was
    {target}.") [PRE182] if __name__ == ''__main__'':     play() [PRE183] I''m thinking
    of a number between 1 and 100... Guess: 50 Too low. 7 tries left. Guess: 75 Too
    low. 6 tries left. Guess: 90 Too high. 5 tries left. Guess: 87 You win! [PRE184]
    I''m thinking of a number between 1 and 100... Guess: Fifty Traceback (most recent
    call last):   File "./number_guess.py", line 35, in <module>     play()   File
    "./number_guess.py", line 25, in play     if make_guess(target):  File "./number_guess.py",
    line 10, in make_guess     guess = int(input("Guess: ")) ValueError: invalid literal
    for int() with base 10: ''Fifty'' [PRE185] ValueError: invalid literal for int()
    with base 10: ''Fifty'' [PRE186]  File "./number_guess.py", line 10, in make_guess     guess
    = int(input("Guess: ")) [PRE187]  File "./number_guess.py", line 25, in play     if
    make_guess(target): [PRE188]  File "./number_guess.py", line 35, in <module>     play()
    [PRE189] Traceback (most recent call last): [PRE190] def make_guess(target):     **guess
    = None**     **while guess is None:**         **try:**             guess = int(input("Guess:
    "))         **except ValueError:**             **print("Enter an integer.")**      if
    guess == target:         return True      if guess < target:         print("Too
    low.")     elif guess > target:         print("Too high.")     return False [PRE191]
    def make_guess(target):     guess = None     while guess is None:         guess
    = input()         **if guess.isdigit():**             guess = int(guess)         **else:**             print("Enter
    an integer.")             guess = None      if guess == target:         return
    True      if guess < target:         print("Too low.")     elif guess > target:         print("Too
    high.")     return False [PRE192] class AverageCalculator:      def __init__(self):         self.total
    = 0         self.count = 0      def __call__(self, *values):         if values:             for
    value in values:                 self.total += float(value)                 self.count
    += 1         return self.total / self.count [PRE193] average = AverageCalculator()
    values = input("Enter scores, separated by spaces:\n    ").split() try:     print(f"Average
    is {average(*values)}") except ❶ ZeroDivisionError:     print("ERROR: No values
    provided.") except ( ❷ ValueError, ❸ UnicodeError):     print(f"ERROR: All inputs
    should be numeric.") [PRE194] try:     some_scary_function() except:     print("An
    error occurred. Moving on!") [PRE195] def greet():     name = input("What''s your
    name? ")     print(f"Hello, {name}.")   while True:     try:         greet()         break     except:         print("Error
    caught") [PRE196] What''s your name? ^CError caught What''s your name? ^CError
    caught What''s your name? ^CError caught What''s your name?  [PRE197] def greet():     name
    = input("What''s your name? ")     print(f"Hello, {name}.")   while True:     try:         greet()         break  **except
    Exception:**         print("Error caught") [PRE198] def average(number_string):     total
    = 0     skip = 0     values = 0     for n in number_string.split():         values
    += 1       ❶ try:             total += float(n)       ❷ except ValueError:             skip
    += 1 [PRE199]  ❸ if skip == values:         raise ValueError("No valid numbers
    provided.")     elif skip:         print(f"<!> Skipped {skip} invalid values.")      return
    total / values [PRE200] while True:     line = input("Enter numbers (space delimited):\n    ")     avg
    = average(line)     print(avg) [PRE201] Enter numbers (space delimited):     4
    5 6 7  5.5 [PRE202] Enter numbers (space delimited):     four five 6 7 <!> Skipped
    2 invalid values. 3.25 [PRE203] Enter numbers (space delimited):     four five
    six seven Traceback (most recent call last):   File "./raiseexception.py", line
    25, in <module>     avg = average(line)   File "./raiseexception.py", line 16,
    in average     raise ValueError("No valid numbers provided.") ValueError: No valid
    numbers provided. [PRE204] while True:     **try:**         line = input("Enter
    numbers (space delimited):\n    ")         avg = average(line)  print(avg)     **except
    ValueError:**         **print("No valid numbers provided.")** [PRE205] Enter numbers
    (space delimited):     four five six No valid numbers provided. Enter numbers
    (space delimited):     4 5 6 5.0 [PRE206] friend_emails = {     "Anne": "anne@example.com",     "Brent":
    "brent@example.com",     "Dan": "dan@example.com",     "David": "david@example.com",     "Fox":
    "fox@example.com",     "Jane": "jane@example.com",     "Kevin": "kevin@example.com",     "Robert":
    "robert@example.com" } [PRE207] def lookup_email(name):     try:         return
    friend_emails[name]  except KeyError ❶ as e:         print(f"<No entry for friend
    {e}>") [PRE208] name = input("Enter name to look up: ") email = lookup_email(name)
    print(f"Email: {email}") [PRE209] Enter name to look up: Jason <No entry for friend
    ''Jason''> Email: None [PRE210] import logging from operator import add, sub,
    mul, truediv import sys [PRE211] logging.basicConfig(filename=''log.txt'', level=logging.INFO)
    [PRE212] def calculator(a, b, op):     a = float(a)     b = float(b)     if op
    == ''+'':         return ❶ add(a, b)     elif op == ''-'':         return sub(a,
    b)     elif op == ''*'':         return mul(a, b)     elif op == ''/'':         return
    truediv(a, b)     else:       ❷ raise NotImplementedError(f"No operator {op}")
    [PRE213] print("""CALCULATOR Use postfix notation. Ctrl+C or Ctrl+D to quit. """)  ❶
    while True:   ❷ try:         equation = input(" ").split()         result = calculator(*equation)         print(result)
    [PRE214]  except NotImplementedError as e:         print("<!> Invalid operator.")         logging.info(e)
    [PRE215]  except ValueError as e:         print("<!> Expected format: <A> <B>
    <OP>")         logging.info(e) [PRE216]  except TypeError as e:         print("<!>
    Wrong number of arguments. Use: <A> <B> <OP>")         logging.info(e) [PRE217]  except
    ZeroDivisionError as e:         print("<!> Cannot divide by zero.")         logging.info(e)
    [PRE218]  except (KeyboardInterrupt, EOFError):         print("\nGoodbye.")         sys.exit(0)
    [PRE219] CALCULATOR Use postfix notation. Ctrl+C or Ctrl+D to quit.   11 31 +
    42.0  11 + 31 <!> Expected format: <A> <B> <OP>  11 + 31 + 10 <!> Wrong number
    of arguments. Use: <A> <B> <OP>  11 + <!> Wrong number of arguments. Use: <A>
    <B> <OP>  10 0 / <!> Cannot divide by zero.  10 40 @ <!> Invalid operator.  ^C
    Goodbye. [PRE220] INFO:root:could not convert string to float: ''+'' INFO:root:calculator()
    takes 3 positional arguments but 5 were given INFO:root:calculator() missing 1
    required positional argument: ''op'' INFO:root:float division by zero INFO:root:No
    operator @ [PRE221]  except Exception as e:         logging.exception(e)       ❶
    raise [PRE222] cities = {     "SEATTLE": "WASHINGTON, USA",     "PORTLAND": "OREGON,
    USA",     "BOSTON": "MASSACHUSETTS, USA", }  landmarks = {     "SPACE NEEDLE":
    "SEATTLE",     "LIBERTY SHIP MEMORIAL": "PORTLAND",     "ALAMO": "SAN ANTONIO",
    } [PRE223] def lookup_landmark(landmark):     landmark = landmark.upper()     try:         city
    = landmarks[landmark]         state = cities[city]   ❶ except KeyError as e:       ❷
    raise KeyError("Landmark not found.") from e     print(f"{landmark} is in {city},
    {state}") [PRE224] lookup_landmark("space needle") lookup_landmark("alamo") lookup_landmark("golden
    gate bridge") [PRE225] SPACE NEEDLE is in SEATTLE, WASHINGTON, USA Traceback (most
    recent call last):   File "./chaining.py", line 18, in lookup_landmark     state
    = cities[city] ❶ KeyError: ''SAN ANTONIO''  ❷ The above exception was the direct
    cause of the following exception:  Traceback (most recent call last):  File "./chaining.py",
    line 25, in <module>     lookup_landmark("alamo")   File "./chaining.py", line
    20, in lookup_landmark     raise KeyError("Landmark not found.") from e ❸ KeyError:
    ''Landmark not found.'' [PRE226] During handling of the above exception, another
    exception occurred: [PRE227] import math   def average_string(number_string):     try:         numbers
    = [float(n) for n in number_string.split()]  except ValueError:         total
    = math.nan         values = 1 [PRE228]  else:         total = sum(numbers)         values
    = len(numbers) [PRE229]  try:         average = total / values     except ZeroDivisionError:         average
    = math.inf      return average   while True:     number_string = input("Enter
    space-delimited list of numbers:\n    ")     print(average_string(number_string))
    [PRE230]  4 5 6 7 5.5      inf     four five six nan [PRE231] def average_file(path):     file
    = open(path, ''r'')      try:       ❶ numbers = [float(n) for n in file.readlines()]
    [PRE232]  except ValueError as e:         raise ValueError("File contains non-numeric
    values.") from e [PRE233]  else:         try:             return sum(numbers)
    / len(numbers)         except ZeroDivisionError as e:             raise ValueError("Empty
    file.") from e [PRE234]  finally:         print("Closing file.")         file.close()
    [PRE235] print(average_file(''numbers_good.txt'')) [PRE236] Closing file. 42.0
    [PRE237] print(average_file(''numbers_bad.txt'')) [PRE238] ❶ Closing file. Traceback
    (most recent call last):   File "tryfinally.py", line 5, in average_file     numbers
    = [float(n) for n in file.readlines()]   File "tryfinally.py", line 5, in <listcomp>     numbers
    = [float(n) for n in file.readlines()] ValueError: could not convert string to
    float: ''thirty-three\n''  The above exception was the direct cause of the following
    exception:  Traceback (most recent call last):   File "tryfinally.py", line 20,
    in <module>     print(average_file(''numbers_bad.txt''))  # ValueError   File
    "tryfinally.py", line 7, in average_file     raise ValueError("File contains non-numeric
    values.") from e ValueError: File contains non-numeric values. [PRE239] print(average_file(''numbers_empty.txt''))
    [PRE240] ❶ Closing file. Traceback (most recent call last):   File "tryfinally.py",
    line 10, in average_file     return sum(numbers) / len(numbers) ZeroDivisionError:
    division by zero  The above exception was the direct cause of the following exception:  Traceback
    (most recent call last):   File "tryfinally.py", line 21, in <module>     print(average_file(''numbers_empty.txt''))  #
    ValueError   File "tryfinally.py", line 12, in average_file     raise ValueError("Empty
    file.") from e ❷ ValueError: Empty file. [PRE241] print(average_file(''nonexistent.txt''))
    [PRE242] Traceback (most recent call last):   File "tryfinally.py", line 22, in
    <module>     print(average_file(''nonexistent.txt''))  # FileNotFoundError   File
    "tryfinally.py", line 2, in average_file     file = open(path, ''r'') FileNotFoundError:
    [Errno 2] No such file or directory: ''nonexistent.txt'' [PRE243] class ❶ SillyWalkException(
    ❷ RuntimeError):     def __init__(self, ❸ message="Someone walked silly."):         super().__init__(message)   def
    walking():   ❹ raise SillyWalkException("My walk has gotten rather silly.")   try:     walking()
    ❺ except SillyWalkException as e:     print(e) [PRE244] class SillyWalkException(RuntimeError):     """Exception
    for walking silly.""" [PRE245]`**'
  prefs: []
  type: TYPE_NORMAL
