- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditional Statements
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: The programs you have written so far execute line by line, beginning at the
    top of the code and ending at the bottom. You can visualize this flow as a series
    of steps that execute in a linear fashion, which means that the program can run
    in only one way. In this chapter, you’ll explore how to write divergent paths
    for Python to follow, depending on whether certain conditions are met. This is
    useful because you can execute different actions in your program depending on
    the scenario—think of the way a video game directs you to different levels or
    screens contingent on your performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To evaluate a condition, you’ll use the *Boolean* data type, which represents
    one of two states: true or false. You’ll learn to write Boolean expressions to
    test whether a statement is true or false. Then you’ll use `if`, `elif`, and `else`
    statements to make your code carry out different actions in response to the true
    or false outcomes.'
  prefs: []
  type: TYPE_NORMAL
- en: Control Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Control flow* refers to the order in which your lines of code execute. By
    default, this flow begins from the top of your code and proceeds one line at a
    time until it reaches the bottom. Using control flow statements like `if`, `elif`,
    `else`, `while`, and `for`, you can direct Python to skip, jump to, and repeat
    lines of code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you want to fill the display window with circles. [Figure
    4-1](#figure4-1) depicts two arrangements: 9 circles aligned three by three, and
    81 circles aligned nine by nine.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f04001](image_fi/500969c04/f04001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: The 9-circle (left) and 81-circle (right) arrangements'
  prefs: []
  type: TYPE_NORMAL
- en: You could write a `circle()` function for each and every circle displayed. If
    you’re drawing only 9 circles, writing 9 `circle()` functions might be manageable,
    but writing 81 `circle()` functions is tedious and can lead to errors. If you
    want several circles, the better approach is to write a single `circle()` line
    and have Python repeat it as many times as needed. [Figure 4-2](#figure4-2) shows
    these two approaches, using flowcharts representing the programming logic.
  prefs: []
  type: TYPE_NORMAL
- en: '![f04002](image_fi/500969c04/f04002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: Flowcharts comparing manual (left) and conditional (right) approaches
    to drawing multiple circles'
  prefs: []
  type: TYPE_NORMAL
- en: The manual method is shown on the left. Each *draw circle* represents a `circle()`
    function; in this case, there are two *draw circle* steps, but you can add as
    many as required.
  prefs: []
  type: TYPE_NORMAL
- en: The flowchart on the right in [Figure 4-2](#figure4-2) repeats the *draw circle*
    step until a particular condition is met. The diamond containing *81?* represents
    a decision step, which checks whether the current number of circles is 81\. If
    true, the program proceeds to the *stop* step; if false, Processing draws another
    circle and returns to the decision step.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter and the next examine how to implement this kind of logic in Python,
    which will be your first foray into algorithmic thinking. In later chapters, you’ll
    be applying flow control techniques in most of your sketches.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Conditional statements* are used to test one or many conditions and then execute
    appropriate responses.'
  prefs: []
  type: TYPE_NORMAL
- en: To explore Python’s various conditional statements, create a new sketch and
    save it as *conditional_statements*. In the sections that follow, you’ll enter
    code into this working sketch.
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean Data Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned previously, a Boolean is a value that can represent one of two
    possible states: `True` or `False`. To see how the Boolean data type operates,
    add these two variables to the sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first letter of a Boolean value is always uppercase, and no quotation marks
    are used since that would make it a string.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever Python is required to manage Booleans as numeric values, it converts
    a `True` value to `1`, and a `False` value to `0`; this, however, works both ways.
    For instance, Python’s `bool()` function, which converts any value to Boolean,
    converts a `1` to `True` and a `0` to `False`. This will prove useful when you
    encounter `if` statements, where you’ll instruct Python to execute different lines
    of code based on `True`/`False` outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your sketch, add a series of `print()` functions to test this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first two `print` statements repeat the variable values back to the console.
    The third `print` statement uses an arithmetic addition (`+`) operator to add
    one `True` Boolean to another. Adding `True` and `True` results in `2`. Converting
    Booleans to numbers works with mathematical operators or any functions that convert
    values to numbers, such as the `int()` function for converting to integers. The
    final two `print` statements, which contain `bool()` functions, convert `1` and
    `0` to their respective Boolean equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous example explicitly defines whether the ball is red and/or spiky,
    but relational operators also can direct your program to make its own decisions
    as to what is true or false. *Relational operators*, like greater-than (`>`) and
    less-than (`<`) signs, determine the relationship between two operands. For example,
    given 3 > 2, the 3 and 2 are the operands, and the greater-than sign is the relational
    operator. Because 3 is indeed greater than 2, this statement is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, add the following code to your *conditional_statements*
    sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The variable `x` is equal to `2`, which is greater than `1`, so the console
    should display `True`. However, `2` is not less than `1`, so the final line should
    print `False`. Notice that the relational operators return a Boolean value. This
    will be important for the next section, where the results of such comparisons
    determine which lines of code your program will execute. [Table 4-1](#table4-1)
    shows a list of Python’s relational operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-1: Relational Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Left operand is greater than right | `2 > 1` returns `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Left operand is less than right | `1 < 2` returns `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Left operand is greater than or equal to right | `1 >= 2` returns
    `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Left operand is less than or equal to right | `2 <= 2` returns `True`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | Left operand is equal to right | `2 == 2` returns `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | Left operand is not equal to right | `2 != 2` returns `False` |'
  prefs: []
  type: TYPE_TB
- en: 'What [Table 4-1](#table4-1) doesn’t show is that the `==` and `!=` operators
    can operate on both numbers and strings. Add the following code to test this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next you’ll combine relational operators with `if` and other conditional statements
    to specify the conditions for executing lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: if Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if`statement requires two ingredients: an expression that returns `True`
    or `False`, and code to execute should the former evaluate as `True`. [Figure
    4-3](#figure4-3) illustrates the syntax of an `if` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f04003](image_fi/500969c04/f04003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: An `if` statement syntax'
  prefs: []
  type: TYPE_NORMAL
- en: Everything in pale blue is placeholder *pseudocode*, which is just English text
    that describes what’s happening in the code; the idea is that you could later
    replace this with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a Passing Grade
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To get started with `if` statements, you’ll build a simple program that assigns
    letter grades to students, depending on their percentage test scores. Begin by
    adding this code to your working sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This awards a `PASS` grade for any score greater than or equal to 50\. In this
    instance, the `score >= 50` returns `True`, so the `print('PASS')` line is executed.
    Be sure to indent the `print` line, which you can do by using the tab key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything indented beneath the `if` line is executed if the condition returns
    `True`. For example, add the following line to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This should now print both `PASS` and `Well done!` for any score greater than
    or equal to 50.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a `print` line flush against the left margin prints `Well
    done!`, regardless of whether the score exceeds 50:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you ever need to nest an `if` statement within another `if` statement, increase
    the indentation accordingly. Most code editors allow you to select multiple lines
    of code and press the tab key to indent them simultaneously. Processing’s editor
    is no exception. If you need to “out-dent,” hold the shift key while pressing
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without adding this next example to your code, see if you can predict the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you predicted that the console would display a `PASS` line followed by `Bien
    hecho!`, you’re correct. The `'ES'` string value is assigned to a new variable
    named `language` 1. The score is greater than or equal to 50, so the program executes
    the contents of the outermost `if` statement 2. The `PASS` line 3 is first to
    print. The condition of the next `if` statement 4, however, evaluates as `False`,
    so the program skips the `Well done!` line. The final `if` statement 5 then tests
    for Spanish. Because the language variable is equal to `'ES'`, Processing prints
    `Bien hecho!` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning Letter Grades
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Currently, your grading program can award only a `PASS`. To assign letter grades
    like A, B, or C, you’ll need to use additional `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adapt your code, changing the `PASS` string to a `C` and inserting a new `if`
    statement that awards a B for any score greater than or equal to 65:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the sketch. Because the `score` variable holds a value greater than 50,
    the console displays a `C`. But there’s an issue—when you change the score value
    to a `70`, you get `B` *and* `C` ([Figure 4-4](#figure4-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04004](image_fi/500969c04/f04004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: A score of 70 is awarded both B *and* C.'
  prefs: []
  type: TYPE_NORMAL
- en: Because the score is greater than 65 and greater than 50, both `if` statements
    are triggered to print, resulting in two letter grades. To avoid getting more
    than one grade, you need to chain together the `if` statements, such that, if
    the first condition is found to be true, the subsequent `if` statement is skipped.
    This is where the else-if style structure comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: elif Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An *else-if statement*, or `elif` in Python, runs only after an `if` condition
    returns `False`. Using an `elif` will solve the preceding problem of having both
    `if` statements operate independently. So, just change the second `if` to an `elif`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, if the value of `score` results in `B`, there is no need to check the `C`
    condition, and Python will skip the `elif` statement altogether. On the other
    hand, should the initial `if` statement condition return `False`, the `elif` will
    test whether `score` is greater than or equal to 50; if so, it prints a `C`.
  prefs: []
  type: TYPE_NORMAL
- en: Set the `score` variable to something B-worthy, like `70`, and then run the
    sketch. The console should now display a `B`, but no `C`.
  prefs: []
  type: TYPE_NORMAL
- en: Order Matters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s important to order this `if...elif` logic correctly. Consider, for instance,
    the following code that places the `C` condition first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, any score greater than or equal to 50 gets a C, even if it’s
    higher than 65 and should get a B. In fact, no B grades will ever print to the
    console, because the program can never check the `B` condition.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for A
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In your *conditional_statements* sketch, insert a new `if` statement to handle
    A grades (80 or greater). Also, change the `B` statement to an `elif`. Adjust
    the `score` to test that this is working correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can add as many `elif` statements as you need, but it’s always a single
    `if` that marks the beginning of the `if...elif` chain.
  prefs: []
  type: TYPE_NORMAL
- en: Your A/B/C logic is now in place, but a score below 50 will pass through all
    of the `if...elif` statements without invoking any actions, not receiving any
    grade at all.
  prefs: []
  type: TYPE_NORMAL
- en: else Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a student does not receive an A, B, or C, you can conclude that the grade
    is a `FAIL`. To handle `FAIL` cases, use an *else statement* to account for any
    condition that doesn’t match those in the `if...elif` grouping. You don’t need
    to check whether the `score` variable is less than 50, as this is implied by its
    failing to match any of the preceding criteria. To handle `FAIL` cases, add the
    following `else` statement to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `else` statement has no condition and always comes at the end of the `if...elif`
    grouping.
  prefs: []
  type: TYPE_NORMAL
- en: Adjust the `score` value to something like 40 and test the code. The console
    should display a `FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: else Statements Without elif
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An `else` statement need not necessarily follow an `elif`. You can use an `if...else`
    structure where you don’t require `elif` clauses. Consider a program that grades
    any score 50 and above as a `PASS`, and everything else as a `FAIL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are no `elif` statements, so the `else` handles any score that the `if`
    doesn’t catch. Of course, whether you include any `elif` statements all depends
    on the logic you intend to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, each `if...elif` statement has relied on the outcome of a single relational
    operation. But often it’s useful to evaluate multiple relational operations within
    a single expression. For example, you might want to check whether the ball from
    earlier is red *and* spiky. To do this, you can use *logical operators*, or an
    `if` statement nested within another `if` statement, to make a decision based
    on the outcomes of multiple conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the earlier example to handle red, spiky balls. You could use
    a nested `if` statement as shown in the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The outer `if` checks whether the ball is red, and then the inner `if` checks
    whether it’s spiky.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do the same thing by using a single `if` statement with the logical
    operator `and`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `and` operator returns `True` if the expressions on both sides of the operator
    also return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-2](#table4-2) provides a list of Python’s logical operators, along
    with a brief description of each and an example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-2: Logical Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `and` | Returns `True` if both operands are true | `2 > 1 and 4 > 3` returns
    `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `or` | Returns `True` if at least one operand is true | `2 > 1 or 4 < 3`
    returns `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `not` | `True` becomes `False`, and vice versa | `not 4 < 3` returns `True`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Now let’s join two expressions by using the `and` operator to check for a much
    narrower condition. Add another `if` statement to check whether the student’s
    score is greater than or equal to 45 *and* less than 50, and display `OFFER RETAKE`
    if so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This condition includes the logical operator `and`. For this to evaluate as
    `True`, both `score >= 45` and `score < 50` must return `True`. Change the `score`
    value to something within this range, like `46`, and confirm that the console
    displays `FAIL` and `OFFER RETAKE`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for Invalid Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let’s add another `if` statement that uses the `or` condition to account
    for any scores outside the valid range (0 to 100). Place this at the top of the
    `if...elif` chain, and change the `A` statement to an `elif`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, if the `score` is `105`, the program should print `INVALID SCORE`. For
    the `or` operation 1 to evaluate as `True`, at least one of its two operands,
    `score < 0` and `score > 100`, must return `True`. Experiment with different score
    values to test the code. If the console displays the invalid score message as
    well as a grade, ensure that you’ve changed the second statement to an `elif`
    2.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a Message for Invalid Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is room for one last improvement. Currently, if the user enters a score
    of `0`, the program grades it as a `FAIL`. However, a score of 0 is relatively
    unusual, so add one final `if` statement to display a warning message that the
    user may have entered invalid input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete grading program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Recall that, when dealing with Booleans, Python interprets a `0` as `False`.
    This means if the `score` is assigned a `0`, it’s evaluated as `False`. However,
    the `not` operator 1 reverses this Boolean, converting it to a `True`, thereby
    triggering the warning message. You could use `mark == 0` to test the same condition,
    which is more explicit and easier to read, but this was a good opportunity to
    show the `not` operator in action. Note that this is a separate `if` statement,
    so for a score of `0`, the console displays both the `FAIL` and a warning message.
  prefs: []
  type: TYPE_NORMAL
- en: You might decide that the program could use some clickable buttons and input
    fields. Chapter 11 covers mouse and keyboard interaction techniques you can use
    to add a graphical user interface to this kind of program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #3: Four-Square Task'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this challenge, you’ll use conditional statements to gauge the position
    of a point in a four-colored square. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Run the sketch. The display window should appear, equally divided into different-colored
    quadrants ([Figure 4-5](#figure4-5)). Each `fill()` and `rect()` line pair draws
    a colored square spanning from the center of the display window to each corner.
  prefs: []
  type: TYPE_NORMAL
- en: '![f04005](image_fi/500969c04/f04005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: Grid with four colors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, place a single text character in the upper right quadrant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `txt` value 1, a question mark, is positioned in the red quadrant ([Figure
    4-6](#figure4-6)). The `text()` function 2 relies on the `x` and `y` variables
    to control this character’s position.
  prefs: []
  type: TYPE_NORMAL
- en: '![f04006](image_fi/500969c04/f04006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: Placing the question mark in the red (upper right) quadrant'
  prefs: []
  type: TYPE_NORMAL
- en: Your challenge is to write conditional statements to replace the ? character
    with an R (for red), B (for blue), P (for purple), or O (for orange) in the appropriate
    squares to match the color beneath it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, insert an `if` statement to manage the R (red) condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement sets the `txt` variable to `'R'` for any `x` values to the
    right of the display window’s center. Run the sketch to confirm that the code
    displays an R over the red quadrant. If you’re still seeing a question mark, ensure
    that you have inserted the `if` statement above the `fill('#FFFFFF')` line.
  prefs: []
  type: TYPE_NORMAL
- en: Now, set the `y` value to `400` to place the character in the orange quadrant.
    Run the sketch. It’s still an R. To display an O instead, you need to add an `elif`
    statement (and a logical `and` operator). Once the O is working correctly, try
    positioning the character in another quadrant, and so forth. [Figure 4-7](#figure4-7)
    displays four screenshots of the completed task; the caption lists the corresponding
    x-y coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a good grasp of `if...elif...else` logic, you’re ready to
    use Boolean expressions for iteration. If you need help, you can access the solution
    at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-04-conditional_statements/four_square/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-04-conditional_statements/four_square/).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04007](image_fi/500969c04/f04007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-7: Clockwise from the upper left: the x-y coordinates of each letter
    are R = (400, 100), O = (400, 400), P = (250, 485), and B = (38, 121).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about the Boolean data type, relational operators,
    and how to write Boolean expressions that work with `if` statements to instruct
    Python to execute particular lines of code. You explored logical operators for
    constructing richer expressions, as well as how to combine `if`, `elif`, and `else`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 5, you’ll take control flow a step further and learn how to write
    programs that can repeat an operation until a certain requirement is met. For
    some especially interesting results, you’ll be adding randomness to your creations.
  prefs: []
  type: TYPE_NORMAL
