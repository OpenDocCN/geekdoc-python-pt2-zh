["```py\nimport warnings\n\nthumbs = \"pricking\"\n\nif thumbs == \"pricking\":\n    warnings.warn(\"Something wicked this way comes.\")\n\nwith open('locks.txt', 'w') as file:\n    file.write(\"Whoever knocks\")\n```", "```py\nbasic_warning.py:6: UserWarning: Something wicked this way comes.\n  warnings.warn(\"Something wicked this way comes.\")\n```", "```py\nWhoever knocks\n```", "```py\nimport warnings\n\nthumbs = \"pricking\"\n\nif thumbs == \"pricking\":\n    warnings.warn(\"Something wicked this way comes.\", **FutureWarning**)\n\nwith open('locks.txt', 'w') as file:\n    file.write(\"Whoever knocks\")\n```", "```py\nbasic_warning.py:6: **FutureWarning**: Something wicked this way comes.\n  warnings.warn(\"Something wicked this way comes.\", **FutureWarning**)\n```", "```py\n`action`:`message`:`category`:`module`:`lineno`\n```", "```py\n`action`::`category`\n```", "```py\npython3 -Wmodule basic_warning.py\n```", "```py\npython3 -Wignore::DeprecationWarning basic_warning.py\n```", "```py\npython3 -Werror basic_warning.py\n```", "```py\npython3 -Werror**:::__main__** basic_warning.py\n```", "```py\npython3 -Werror:::timecard[.*] basic_warning.py\n```", "```py\nimport logging\nlogger = logging.getLogger(__name__)\n```", "```py\nimport pathlib\nimport argparse\nimport logging\n\nfrom letter_counter.common import scrub_string\nfrom letter_counter.letters import most_common_consonant, most_common_vowel\n\nlogger = ❶ logging.getLogger('letter_counter')\n```", "```py\nimport logging\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n```", "```py\nimport logging\n\nlogger = logging.getLogger(__name__)\n```", "```py\nstream_handler = logging.StreamHandler()\nlogger.addHandler(stream_handler)\n```", "```py\nlogger.propagate = False\n```", "```py\ndef scrub_string(string):\n    string = string.lower()\n    string = ''.join(filter(str.isalpha, string))\n    logger.debug(f\"{len(string)} letters detected.\")\n    return string\n```", "```py\nconsonants = 'bcdfghjklmnpqrstvwxyz'\nvowels = 'aeiou'\n\ndef count_letters(string, letter_set):\n counts = defaultdict(lambda: 0)\n    for ch in string:\n        if ch in letter_set:\n            counts[ch] += 1\n    return counts\n\ndef most_common_consonant(string):\n    if not len(string):\n      ❶ logger.info(\"No consonants in empty string.\")\n        return \"\"\n    counts = count_letters(string, consonants)\n    return max(counts, key=counts.get).upper()\n\ndef most_common_vowel(string):\n    if not len(string):\n      ❷ logger.info(\"No vowels in empty string.\")\n        return \"\"\n    counts = count_letters(string, vowels)\n    return max(counts, key=counts.get).upper()\n```", "```py\nparser = argparse.ArgumentParser(description=\"Find which letters appear most.\")\nparser.add_argument(\"-v\", help=\"Show all messages.\", action=\"store_true\") ❶\nparser.add_argument(\"raw_path\", metavar=\"P\", type=str, help=\"The file to read.\") ❷\n\ndef main():\n    args = parser.parse_args()\n\n    if args.v:\n      ❸ logger.setLevel(logging.INFO)\n    else:\n        logger.setLevel(logging.WARNING)\n```", "```py\n path = pathlib.Path(args.raw_path).resolve()\n  ❶ logger.info(f\"Opening {path}\")\n\n    if not path.exists():\n      ❷ logger.warning(\"File does not exist.\")\n        return\n\n    with path.open('r') as file:\n        string = scrub_string(file.read())\n        print(f\"Most common vowel: {most_common_vowel(string)}\")\n        print(f\"Most common consonant: {most_common_consonant(string)}\")\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\npython3 -m letter_counter zen.txt\n```", "```py\nMost common vowel: E\nMost common consonant: T\n```", "```py\npython3 -m letter_counter **-v** zen.txt\n```", "```py\nOpening /home/jason/Documents/DeadSimplePython/Code/ch19/zen.txt\nMost common vowel: E\nMost common consonant: T\n```", "```py\npython3 -m letter_counter -v **empty.txt**\n```", "```py\nOpening /home/jason/Documents/DeadSimplePython/Code/ch19/empty.txt\nNo vowels in empty string.\nMost common vowel: \nNo consonants in empty string.\nMost common consonant: \n```", "```py\npython3 -m letter_counter **invalid.txt**\n```", "```py\nFile does not exist.\n```", "```py`` It is also possible to configure a logger using a specialized configuration file.    For additional information on logging, I recommend reading the official *Logging HOWTO* tutorial by Vinay Sajip at [https://docs.python.org/3/howto/logging.xhtml](https://docs.python.org/3/howto/logging.xhtml), followed by the official documentation at [https://docs.python.org/3/library/logging.xhtml](https://docs.python.org/3/library/logging.xhtml).    Alternatively, you could use a third-party logging library like *eliot* ([https://eliot.readthedocs.io/](https://eliot.readthedocs.io/)) or *loguru* ([https://github.com/Delgan/loguru](https://github.com/Delgan/loguru)). These libraries have their own patterns and techniques, so you’ll want to see their documentation to learn more.    ## Assert Statements    While coding, you may sometimes become aware of conditions that would render your logic nonsensical. You can check for these conditions using an `assert` statement, which will raise an `AssertionError` exception if an expression fails.    However, while these checks are useful during development or debugging, they’re often extraneous during normal operation by the end user. If you pass the `-O` flag (for *optimize*) to the Python interpreter when invoking your package or module, all `assert` statements are removed from the code by the Python interpreter.    For this reason, only use `assert` statements to check for mistakes *you* made! Never use them for data validation, nor in response to user mistakes, as users should never be able to disable data and input validation. Use exceptions and warnings for those scenarios.    Instead, use assertions to aid you in debugging particularly *brittle* areas of your code: places where a minor or seemingly unrelated change to the code could have unintended side effects. The following simple example will demonstrate where `assert` is and is not useful.    ### Proper Use of assert    In this example program, I want to calculate how many vinyl records I can store on any given bookshelf. There’s one key constant in the program: the thickness of a single vinyl record in its jacket:    ```", "```py    Listing 19-12: *vinyl_collector.py:1a*    Using a constant for this value is helpful for making the code maintainable. If I need to update this thickness later—perhaps because I do some complicated statistics to find a more precise average—I need to make sure the value I’m using is still valid. I know in advance that I’ll need to use this constant as the divisor in some later math, which means the constant absolutely cannot be zero. It should also be a positive number, as vinyl records can’t have a negative thickness. Thus, the comment is somewhat helpful here . . . but then again, it won’t do anything to stop me from assigning a nonsense value to the constant!    Since a wrong value will cause major problems in the code itself, and since the value is not externally sourced data or user input, I can make an assertion. Under the hood, an `assert` statement looks like this:    ```", "```py    Listing 19-13: *vinyl_collector.py:1b*    The `__debug__` constant is defined by the interpreter and set to `True` by default. If the `-O` flag is passed to the interpreter, it is set to `False`. It is not possible to assign a value to `__debug__` directly, so as long as `-O` was not passed to the interpreter, the assertion condition is evaluated. In this case, if `THICKNESS` is not greater than `0`, I raise an `AssertionError`.    The `assert` statement wraps all this logic into one line:    ```", "```py    Listing 19-14: *vinyl_collector.py:1c*    Note the lack of parentheses involved here, as `assert` is a keyword, not a function. The condition `THICKNESS > 0` is checked, and if it fails, an `AssertionError` is raised, with the string after the comma used as the error’s message.    The reason for placing the `assert` here becomes clearer given the next part of the code, which performs some operations using `THICKNESS`:    ```", "```py    Listing 19-15: *vinyl_collector.py:2*    If `THICKNESS` were ever `0`, the division in this function would raise a `ZeroDivisionError`. That error could point me in the right direction while debugging, but there are three issues. First, the actual problem is where I define `THICKNESS`, which could (theoretically) be some distance away from this function. Second, the error would only surface once this function is called, meaning that if I don’t happen to invoke this function during my testing, I could miss the bug entirely. Third, a negative value in `THICKNESS` would produce nonsense output, but the math would still be valid, so the bug might slip past.    The purpose of placing the assertion right next to the definition of the constant is to alert me to a bug at its source, as early in the execution flow as possible.    ### Wrong Use of assert    As I mentioned earlier, `assert` should not be used for data or input validation. Regular exceptions and conditions should be used for those instead.    For example, this function prompts the user to input a value and then attempts to convert it to an integer. This first version improperly uses `assert` to ensure that the number is positive:    ```", "```py    Listing 19-16: *vinyl_collector.py:3**a*    You may be able to see where this is going, but I’ll finish up with the rest of the program so we can see the problem in action:    ```", "```py    Listing 19-17: *vinyl_collector.py:4*    If I run the program normally, this seems to work pretty well. However, if I pass the `-O` flag to the interpreter, I find that my input validation has vanished:    ```", "```py    Input validation isn’t very useful if it can be turned off. This is why `assert` should never be used for validating external data or user input. Instead, I use other techniques and leave `assert` out of it:    ```", "```py    Listing 19-18: *vinyl_collector.py:3**b*    Now, even if I run the program with the `-O` flag, data validation will work as expected.    ### Seeing assert in Action    The final program only uses `assert` to catch a nonsense value being assigned to the `THICKNESS` constant in code, and nothing else. For the sake of example, I’ll change `THICKNESS` to a negative value, to get on the bad side of the assert statement:    ```", "```py    Listing 19-19: *vinyl_collector.py:1d*    I invoke the program in the ordinary way:    ```", "```py    That outputs the expected `AssertionError`, since the value of `THICKNESS` is negative:    ```", "```py    I can jump right to line 2, which is immediately next to the source of the problem. I can fix the problem, although I won’t do that yet, for the sake of example.    If I instead pass `-O` to the interpreter, that will turn on optimizations and thereby suppress the assertion:    ```", "```py    Even though the value of `THICKNESS` is wrong, the program will try to work with it anyway, as if the `assert` statement weren’t even there:    ```", "```py    Nonsense output, sure, but I was expecting problems since I ran the program with `-O`, without fixing the assertion errors. In reality, you’ll only want to invoke with `-O` once you’re reasonably certain there are no assertion errors in your program; it’s a flag you’ll only ever use in *production*, not in development.    ## The inspect Module    One more useful tool in your debugging toolbox is the `inspect` module, which provides a number of functions to return data about objects and modules in Python, as well as code and traceback information. This data can be used to log more insightful debug messages.    As a fun little aside, outside of debugging, one of my favorite tricks I’ve ever done with `inspect` is to send the source of a Python function over a network to a remote machine. This allowed me to perform automated testing on those machines, without first having to install anything special.    The documentation is sufficient to introduce the functionality of this module: [https://docs.python.org/3/library/inspect.xhtml](https://docs.python.org/3/library/inspect.xhtml).    ## Using pdb    Warnings, logging, and `assert` statements make it possible to perform quite a bit of manual debugging, without the use of external tools. While this is useful for many scenarios, there are a number of other tools that can help you quickly home in on a problem in your code. These are primarily helpful when there’s a possibility that the source of the error is some distance from its manifestation or when there are multiple components involved in the problem.    The *Python Debugger* (`pdb`) is a full-featured debugger for Python. Its workflow is similar to other command-line debuggers like `gdb` (for C++) and `jdb (for Java). You use it by setting *breakpoints*, places in the program where control is turned over to the debugger, allowing you to step through the code line by line to observe what’s going on.`   ```", "```py from datetime import time   def get_timetable(train):     # Pretend this gets data from a server.     return [         {\"station\": \"target_field\", \"arrives\": time(hour=16, minute=27)},         {\"station\": \"fridley\", \"arrives\": time(hour=16, minute=41)},         {\"station\": \"coon_rapids_fridley\", \"arrives\": time(hour=16, minute=50)},         {\"station\": \"anoka\", \"arrives\": time(hour=16, minute=54)},         {\"station\": \"ramsey\", \"arrives\": time(hour=16, minute=59)},         {\"station\": \"elk_river\", \"arrives\": time(hour=17, minute=4)},         {\"station\": \"big_lake\", \"arrives\": time(hour=17, minute=17)},     ]   def next_station(now, timetable):     \"\"\"Return the name of the next station.\"\"\"     station = None     for stop in timetable:         if stop['arrives'] > now:             station = stop             break     station['station'] = station['station'].replace('_', ' ').title()     return station   def arrives_at(station, timetable):     for stop in timetable:         if station == stop['station']:             return stop   timetable = get_timetable('nstar_northbound')  station = next_station(time(hour=16, minute=43), timetable) print(f\"Next station is {station['station']}.\")  stop = arrives_at('coon_rapids_fridley', timetable) print(f\"Arrives at {stop['arrives']}.\") ```", "```py Traceback (most recent call last):   File \"./train_timetable.py\", line 40, in <module>     stop = arrives_at('coon_rapids_fridley', timetable) TypeError: 'NoneType' object is not subscriptable ```", "```py python3 -m pdb train_timetable.py ```", "```py python3 -m pdb -m timecard ```", "```py > ./train_timetable.py(1)<module>() -> from datetime import time (Pdb)  ```", "```py breakpoint() ```", "```py import pdb; pdb.set_trace() ```", "```py python3 the_module_being_debugged.py ```", "```py python3 -m pdb train_timetable.py ```", "```py > ./train_timetable.py(1)<module>() -> from datetime import time (Pdb) **next** > ./train_timetable.py(4)<module>() -> def get_timetable(train): (Pdb) **n** > ./train_timetable.py(17)<module>() -> def next_station(now, timetable): (Pdb) **n** > ./train_timetable.py(28)<module>() -> def arrives_at(station, timetable): (Pdb) **n** > ./train_timetable.py(34)<module>() ❶ -> timetable = get_timetable('nstar_northbound') (Pdb) **list**  29      for stop in timetable:  30          if station == stop['station']:  31              return stop  32  33  34  ->timetable = get_timetable('nstar_northbound')  35  36  station = next_station(time(hour=16, minute=43), timetable)  37  print(f\"Next station is {station['station']}.\")  38  39  stop = arrives_at('coon_rapids_fridley', timetable) ```", "```py (Pdb) **break 39** Breakpoint 1 at ./train_timetable.py:39 (Pdb) **continue** Next station is Coon Rapids Fridley. > ./train_timetable.py(39)<module>() -> stop = arrives_at('coon_rapids_fridley', timetable) ```", "```py (Pdb) **step** --Call-- > ./train_timetable.py(28)arrives_at() -> def arrives_at(station, timetable): (Pdb) **s** > ./train_timetable.py(29)arrives_at() -> for stop in timetable: (Pdb) **args** ❶ station = 'coon_rapids_fridley' timetable = (     {'station': 'target_field', 'arrives': datetime.time(16, 27)},     {'station': 'fridley', 'arrives': datetime.time(16, 41)}, ❷     {'station': 'Coon Rapids Fridley', 'arrives': datetime.time(16, 50)},     {'station': 'anoka', 'arrives': datetime.time(16, 54)},     {'station': 'ramsey', 'arrives': datetime.time(16, 59)},     {'station': 'elk_river', 'arrives': datetime.time(17, 4)},     {'station': 'big_lake', 'arrives': datetime.time(17, 17)} ) ```", "```py (Pdb) **where**   /usr/local/lib/python3.9/bdb.py(580)run() -> exec(cmd, globals, locals)   <string>(1)<module>()   ./train_timetable.py(39)<module>() -> stop = arrives_at('coon_rapids_fridley', timetable) ❶ > ./train_timetable.py(29)arrives_at() -> for stop in timetable: (Pdb) **up** > ./train_timetable.py(39)<module>() -> stop = arrives_at('coon_rapids_fridley', timetable) ```", "```py stop = arrives_at('coon_rapids_fridley', timetable) ```", "```py (Pdb) **l**  34  timetable = get_timetable('nstar_northbound')  35  36  station = next_station(time(hour=16, minute=43), timetable)  37  print(f\"Next station is {station['station']}.\")  38  39 B->stop = arrives_at('coon_rapids_fridley', timetable)  40  print(f\"Arrives at {stop['arrives']}.\") [EOF] (Pdb) **b 36** Breakpoint 2 at ./train_timetable.py:36 ```", "```py (Pdb) **next** > ./train_timetable.py(40)<module>() -> print(f\"Arrives at {stop['arrives']}.\") ```", "```py (Pdb) **jump 34** > ./train_timetable.py(36)<module>() -> timetable = get_timetable('nstar_northbound') (Pdb) **n** > ./train_timetable.py(36)<module>() -> station = next_station(time(hour=16, minute=43), timetable) (Pdb) **pp timetable** ({'arrives': datetime.time(16, 27), 'station': 'target_field'},  {'arrives': datetime.time(16, 41), 'station': 'fridley'},  {'arrives': datetime.time(16, 50), 'station': 'coon_rapids_fridley'},  {'arrives': datetime.time(16, 54), 'station': 'anoka'},  {'arrives': datetime.time(16, 59), 'station': 'ramsey'},  {'arrives': datetime.time(17, 4), 'station': 'elk_river'},  {'arrives': datetime.time(17, 17), 'station': 'big_lake'}) ```", "```py (Pdb) **source next_station**  17  def next_station(now, timetable):  18      \"\"\"Return the name of the next station.\"\"\"  19      station = None  20      for stop in timetable:  21          if stop['arrives'] > now:  22              station = stop  23              break  24      station['station'] = station['station'].replace('_', ' ').title()  25      return station (Pdb) **b 24** Breakpoint 2 at ./train_timetable.py:24 (Pdb) **c** > ./train_timetable.py(22)next_station() -> station = stop ```", "```py (Pdb) **p station** {'station': 'coon_rapids_fridley', 'arrives': datetime.time(16, 50)} (Pdb) **n** > ./ch19/train_timetable.py(25)next_station() -> return station (Pdb) **p station** {'station': 'Coon Rapids Fridley', 'arrives': datetime.time(16, 50)} (Pdb) **pp timetable** ({'arrives': datetime.time(16, 27), 'station': 'target_field'},  {'arrives': datetime.time(16, 41), 'station': 'fridley'},  {'arrives': datetime.time(16, 50), 'station': 'Coon Rapids Fridley'},  {'arrives': datetime.time(16, 54), 'station': 'anoka'},  {'arrives': datetime.time(16, 59), 'station': 'ramsey'},  {'arrives': datetime.time(17, 4), 'station': 'elk_river'},  {'arrives': datetime.time(17, 17), 'station': 'big_lake'}) ```", "```py (Pdb) **!station['station'] = 'coon_rapids_fridley'** (Pdb) **pp timetable** ({'arrives': datetime.time(16, 27), 'station': 'target_field'},  {'arrives': datetime.time(16, 41), 'station': 'fridley'},  {'arrives': datetime.time(16, 50), 'station': 'coon_rapids_fridley'},  {'arrives': datetime.time(16, 54), 'station': 'anoka'},  {'arrives': datetime.time(16, 59), 'station': 'ramsey'},  {'arrives': datetime.time(17, 4), 'station': 'elk_river'},  {'arrives': datetime.time(17, 17), 'station': 'big_lake'}) (Pdb) **n** --Return-- > ./train_timetable.py(25)next_station()->{'arrives': datetime.time(16, 50), 'station': 'coon_rapids_fridley'} -> return station ```", "```py (Pdb) **b** Num Type         Disp Enb   Where 1   breakpoint   keep yes   at ./train_timetable.py:39         breakpoint already hit 1 time 2   breakpoint   keep yes   at ./train_timetable.py:36         breakpoint already hit 1 time 3   breakpoint   keep yes   at ./train_timetable.py:24         breakpoint already hit 1 time (Pdb) **clear 1 2** Deleted breakpoint 1 at ./train_timetable.py:39 Deleted breakpoint 2 at ./train_timetable.py:36 ```", "```py (Pdb) **continue** Next station is coon_rapids_fridley. Arrives at 16:50:00. The program finished and will be restarted > ./train_timetable.py(1)<module>() -> from datetime import time (Pdb) **q** ```", "```py $ **python3 -i train_timetable.py** Next station is Coon Rapids Fridley. Traceback (most recent call last):   File \"/home/jason/IBP Nextcloud/Documents/NoStarchPress/DeadSimplePython/Code/ch19/train_timetable.py\", line 40, in <module>     print(f\"Arrives at {stop['arrives']}.\") TypeError: 'NoneType' object is not subscriptable > **import pdb; pdb.pm()** > /home/jason/IBP Nextcloud/Documents/NoStarchPress/DeadSimplePython/Code/ch19/train_timetable.py(40)<module>() -> print(f\"Arrives at {stop['arrives']}.\") (Pdb)  ```", "```py (Pdb) **pp timetable** ({'arrives': datetime.time(16, 27), 'station': 'target_field'},  {'arrives': datetime.time(16, 41), 'station': 'fridley'},  {'arrives': datetime.time(16, 50), 'station': 'Coon Rapids Fridley'},  {'arrives': datetime.time(16, 54), 'station': 'anoka'},  {'arrives': datetime.time(16, 59), 'station': 'ramsey'},  {'arrives': datetime.time(17, 4), 'station': 'elk_river'},  {'arrives': datetime.time(17, 17), 'station': 'big_lake'}) (Pdb) **p station** {'station': 'Coon Rapids Fridley', 'arrives': datetime.time(16, 50)} ```", "```py import ctypes  ctypes.memset(0, 254, 1) ```", "```py Segmentation fault (core dumped) ```", "```py python3 -X faulthandler segfault.py ```", "```py import ctypes  **import faulthandler; faulthandler.enable()**  ctypes.memset(0, 254, 1) ```", "```py Fatal Python error: Segmentation fault  Current thread 0x00007f7af346a280 (most recent call first):   File \"/home/jason/DeadSimplePython/segfault.py\", line 5 in <module> Segmentation fault (core dumped) ```", "```py equation = input(\"Enter an equation: \") result = eval(equation) print(f\"{equation} = {result}\") ```", "```py python3 -m bandit magic_calculator.py ```", "```py [main]  INFO    profile include tests: None [main]  INFO    profile exclude tests: None [main]  INFO    cli include tests: None [main]  INFO    cli exclude tests: None [main]  INFO    running on Python 3.9.0 [node_visitor]  INFO    Unable to find qualified name for module: super_calculator.py Run started:2022-05-29 22:25:37.497963 Test results: Issue: [B322:blacklist] The input method in Python 2 will read from standard input, evaluate, and run the resulting string as python source code. This is similar to, though in many ways worse than, using eval. On Python 2, use raw_input instead. Input is safe in Python 3\\. 1    Severity: High   Confidence: High    Location: super_calculator.py:1    More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.xhtml#b322-input 1       equation = input(\"Enter an equation: \") 2       result = eval(equation) 3       print(f\"{equation} = {result}\")  -------------------------------------------------- Issue: [B307:blacklist] Use of possibly insecure function - consider using safer ast.literal_eval. 2    Severity: Medium   Confidence: High    Location: super_calculator.py:2    More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.xhtml#b307-eval 1       equation = input(\"Enter an equation: \") 2       result = eval(equation) 3       print(f\"{equation} = {result}\")  --------------------------------------------------  Code scanned:         Total lines of code: 3         Total lines skipped (#nosec): 0  Run metrics:         Total issues (by severity):                 Undefined: 0.0                 Low: 0.0                 Medium: 1.0                 High: 1.0         Total issues (by confidence):                 Undefined: 0.0                 Low: 0.0                 Medium: 0.0                 High: 2.0 Files skipped (0):  ```", "```py #!/usr/bin/env python3  equation = input(\"Enter an equation: \") result = eval(equation) print(f\"{equation} = {result}\") ```", "```py #!/bin/env/python3 **import ast**  equation = input(\"Enter an equation: \") result = **ast.literal_eval(**equation**)** print(f\"{equation} = {result}\") ```", "```py` ```"]