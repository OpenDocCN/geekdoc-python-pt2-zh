<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header0901" class="chapter" epub:type="chapter" id="ch09" role="doc-chapter">
<header id="header0901">
<h1 class="cn"><span aria-label=" Page 152. " class="page" epub:type="pagebreak" id="p152" role="doc-pagebreak"/><span aria-label=" Page 153. " class="page" epub:type="pagebreak" id="p153" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch09">9</a></h1>
<h1 class="ct">Understanding OpenGL</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">In this project, you’ll create a simple program that displays a texture-mapped square using OpenGL and GLFW. OpenGL is a software interface to your <span class="idx" data-term="graphics processing unit (GPU)"/>graphics processing unit (<span class="idx" data-term="GPU (graphics processing unit)"/>GPU), and GLFW is a windowing toolkit. You’ll also learn how to use the C-like <span class="idx" data-term="OpenGL Shading Language. See GLSL"/>OpenGL Shading Language (GLSL) to write <span class="idx" data-level1="GLSL" data-term="OpenGL"/><span class="idx" data-term="shaders"/><i>shaders</i>—code that executes in the GPU. Shaders bring immense flexibility to computations in OpenGL. I’ll show you how to use GLSL shaders to transform and color geometry as you create a rotating, textured polygon (as shown in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#fig9-1">Figure 9-1</a>).</p>
<p>GPUs are optimized to perform the same operations on huge amounts of data repeatedly, in <span class="idx" data-term="parallel processing"/>parallel, which makes them much faster than <span class="idx" data-term="central processing unit (CPU)"/>central processing units (<span class="idx" data-term="CPU (central processing unit)"/>CPUs) for rendering computer graphics. In addition, <span aria-label=" Page 154. " class="page" epub:type="pagebreak" id="p154" role="doc-pagebreak"/>they’re being used for general-purpose computing, and specialized languages now let you harness your GPU hardware for all sorts of applications. You’ll leverage the GPU, OpenGL, and shaders in this project.</p>
<figure class="figure" id="fig9-1">
<p class="fig"><img alt="" height="500" src="images/nsp-venkitachalam503045-f09001.jpg" style="width:95%; height:auto;" width="639"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 9-1:</span> The final image for the project in this chapter—a rotating polygon with a star image. This square polygon boundary is clipped to a black circle using a shader.</p>
</figcaption>
</figure>
<p>Python is an excellent “glue” language. There are a vast number of Python <i>bindings</i> available for libraries written in other languages, such as C, that allow you to use these libraries in Python. In this chapter and in <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#ch10">Chapters 10</a> and <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#ch11">11</a>, you’ll use <code>PyOpenGL</code>, the Python binding to OpenGL, to create computer graphics.</p>
<p>Here are some of the concepts introduced in this project:</p>
<ul style="list-style-type:none">
<li class="blf">• Using the <span class="idx" data-term="GLFW"/>GLFW windowing library for OpenGL</li>
<li class="bl">• Using GLSL to write vertex and fragment shaders</li>
<li class="bl">• Performing texture mapping</li>
<li class="bll">• Using 3D transformations</li>
</ul>
<p>First, let’s take a look at how OpenGL works.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> OpenGL went through a major transition a few years ago. It went from using a fixed function graphics pipeline to a programmable pipeline with a dedicated shading language. We refer to the latter as <i>modern OpenGL</i>, and that’s what we’ll be using in this book. Specifically, we’ll use OpenGL version 4.1.</p>
<section>
<h2 class="ah" id="ah1101"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1101">How OpenGL Works</a></h2>
<p class="paft">Modern OpenGL makes graphics appear on your screen through a sequence of operations commonly known as the <span class="idx" data-level1="3D graphics pipeline" data-term="OpenGL"/><span class="idx" data-term="3D graphics pipeline"/><i>3D graphics pipeline</i>. <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#fig9-2">Figure 9-2</a> shows a simplified representation of the OpenGL 3D graphics pipeline.</p>
<figure class="figure" id="fig9-2">
<p class="fig"><span aria-label=" Page 155. " class="page" epub:type="pagebreak" id="p155" role="doc-pagebreak"/><img alt="" height="344" src="images/nsp-venkitachalam503045-f09002.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 9-2:</span> The (simplified) OpenGL graphics pipeline</p>
</figcaption>
</figure>
<p>At their heart, computer graphics boil down to computing color values for the pixels on your screen. Say you want to make a triangle appear. In the first step of the pipeline, you define the 3D geometry by defining the vertices of the triangle in 3D space and specifying the colors associated with each vertex. These vertices and colors are held in data structures called <i>vertex buffer objects (VBOs)</i>. Next, you transform the vertices: the first transformation places the vertices in 3D space, and the second projects the 3D coordinates onto 2D space for display on a 2D screen. The color values for the corresponding vertices are also calculated in this step based on factors such as lighting, typically in code called the <span class="idx" data-level1="GLSL" data-term="OpenGL"/><span class="idx" data-term="vertex shader"/><i>vertex shader</i>.</p>
<p>Next, the geometry is <span class="idx" data-term="rasterization"/><span class="idx" data-level1="rasterization" data-term="OpenGL"/><i>rasterized</i> (converted from a 3D representation to 2D pixels), and for each pixel (or <i>fragment</i>, to be more accurate), another block of code called the <span class="idx" data-term="fragment shader"/><span class="idx" data-level1="GLSL" data-term="OpenGL"/><i>fragment shader</i> is executed. Just as the vertex shader operates on 3D vertices, the fragment shader operates on the 2D fragments after rasterization. I say <i>fragment</i> rather than <i>pixel</i> since a pixel is what is displayed on the screen, whereas a fragment is the output of computations in the fragment shader, and depending on the next step in the pipeline, a fragment may be discarded before it becomes a pixel on the screen.</p>
<p>Finally, each fragment passes through a series of frame buffer operations, where it undergoes <i>depth buffer testing</i> (checking whether one fragment obscures another), <i>blending</i> (mixing two fragments with transparency), and other operations that combine its current color with what is already on the frame buffer at that location. These changes end up on the final frame buffer, which is typically displayed on the screen.</p>
<section>
<h3 class="bh" id="bh1101"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1101">Geometric Primitives</a></h3>
<p class="paft">Because OpenGL is a low-level graphics library, you can’t ask it directly to draw a cube or a sphere, though libraries built on top of it can do such tasks for you. OpenGL understands only low-level geometric primitives, such as points, lines, and triangles.</p>
<p>Modern OpenGL supports only the primitive types <code>GL_POINTS</code>, <code>GL_LINES</code>, <code>GL_LINE_STRIP</code>, <code>GL_LINE_LOOP</code>, <code>GL_TRIANGLES</code>, <span class="idx" data-level1="GL_TRIANGLE_STRIP" data-term="OpenGL"/><code>GL_TRIANGLE_STRIP</code>, and <code>GL_TRIANGLE_FAN</code>. <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#fig9-3">Figure 9-3</a> shows how the vertices for the primitives are organized. Each vertex has a 3D coordinate such as (<i>x</i>, <i>y</i>, <i>z</i>).</p>
<figure class="figure" id="fig9-3">
<p class="fig"><span aria-label=" Page 156. " class="page" epub:type="pagebreak" id="p156" role="doc-pagebreak"/><img alt="" height="955" src="images/nsp-venkitachalam503045-f09003.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 9-3:</span> OpenGL primitives</p>
</figcaption>
</figure>
<p>To draw a sphere in OpenGL, first define the geometry of the sphere mathematically and compute its 3D vertices. Then assemble the vertices into basic geometric primitives; for example, you could group each set of three vertices into a triangle. You then render the vertices using OpenGL.</p>
</section>
<section>
<h3 class="bh" id="bh1102"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1102"><span class="idx" data-level1="3D transformations (begin)" data-term="OpenGL"/><span class="idx" data-term="3D transformations (begin)"/>3D Transformations</a></h3>
<p class="paft">You can’t learn computer graphics without learning about 3D transformations. Conceptually, these are quite simple to understand. You have an object—what can you do to it? You can move it, stretch (or squash) it, or rotate it. You can do other things to it too, but these three tasks—translation, scale, and rotation—are the operations or transformations most commonly performed on an object. In addition to these commonly used transformations, you’ll use a perspective projection to map the 3D objects onto the 2D plane of the screen. These transformations are all applied on the coordinates of the object you are trying to transform.</p>
<p>While you’re probably familiar with 3D coordinates in the form (<i>x</i>, <i>y</i>, <i>z</i>), in 3D computer graphics you use coordinates in the form (<i>x</i>, <i>y</i>, <i>z</i>, <i>w</i>), called <span class="idx" data-term="homogeneous coordinates"/><i>homogeneous coordinates</i>. (These coordinates come from a branch of mathematics called <span class="idx" data-term="translation matrix"/><i>projective geometry</i>, which is beyond the scope of this book.) Homogeneous coordinates allow you to express common 3D transformations such as translation, scale, and rotation as 4×4 matrices. But for the purposes of these OpenGL projects, all you need to know is that the homogeneous <span aria-label=" Page 157. " class="page" epub:type="pagebreak" id="p157" role="doc-pagebreak"/>coordinate (<i>x</i>, <i>y</i>, <i>z</i>, <i>w</i>) is equivalent to the 3D coordinate (<i>x</i>/<i>w</i>, <i>y</i>/<i>w</i>, <i>z</i>/<i>w</i>, 1.0). A 3D point (1.0, 2.0, 3.0) can be expressed in homogeneous coordinates as (1.0, 2.0, 3.0, 1.0).</p>
<p>Here’s an example of a 3D transformation using a 4×4 matrix. See how the <span class="idx" data-term="matrix multiplication"/>matrix multiplication translates a point (<i>x</i>, <i>y</i>, <i>z</i>, 1.0) to (<i>x</i> + <i>t</i><sub class="i">x</sub>, <i>y</i> + <i>t</i><sub class="i">y</sub>, <i>z</i> +<i>t</i><sub class="i">z</sub>, 1.0):</p>
<div class="equation">
<p class="eq"><img alt="" height="204" src="images/nsp-venkitachalam503045-m09001.jpg" width="417"/></p>
</div>
<p class="pcon">Since this operation translates a point in space, the 4×4 matrix involved is called a <i>translation matrix</i>.</p>
<p>Let’s now look at another useful matrix for 3D transformation—a rotation matrix. The following matrix rotates a point (<i>x</i>, <i>y</i>, <i>z</i>, 1.0) counterclockwise around the x-axis by <span class="dcrit-i">θ</span> radians:</p>
<div class="equation">
<p class="eq"><img alt="" height="204" src="images/nsp-venkitachalam503045-m09002.jpg" width="388"/></p>
</div>
<p>But here’s something to keep in mind: if you’re going to apply this rotation inside shader code, the matrix will be stored in <i>column-major format</i>, which means you should declare it as follows:</p>
<div class="codeline">
<p class="clf">// rotational transform</p>
<p class="cl">mat4 rot =  mat4(</p>
<p class="cl">    vec4(1.0,  0.0,          0.0,         0.0),</p>
<p class="cl">    vec4(0.0,  cos(uTheta),  sin(uTheta), 0.0),</p>
<p class="cl">    vec4(0.0, -sin(uTheta),  cos(uTheta), 0.0),</p>
<p class="cl">    vec4(0.0,  0.0,          0.0,         1.0)</p>
<p class="cll">);</p>
</div>
<p>Notice that, in the code, the matrix is flipped along its diagonal compared to the definition of <i>R</i><sub class="i">θ</sub><sub>,</sub><sub class="i">x</sub>.</p>
<p>Two terms that you will encounter often in OpenGL are <span class="idx" data-level1="modelview" data-term="OpenGL"/><i>modelview</i> and <span class="idx" data-level1="projection" data-term="OpenGL"/><i>projection</i> transformations. With the advent of customizable shaders in modern OpenGL, modelviews and projections are just generic transformations. Historically, in old-school versions of OpenGL, the modelview transformations were applied to your 3D model to position it in space, and the projection transformations were used to map the 3D coordinates onto a 2D surface for display, as you’ll see in a moment. Modelview transformations are user-defined transformations that let you position your 3D objects, and projection transformations are projective transformations that map 3D onto 2D.</p>
<p><span aria-label=" Page 158. " class="page" epub:type="pagebreak" id="p158" role="doc-pagebreak"/>The two most commonly used 3D graphics projective transformations are <span class="idx" data-term="orthographic projection"/><i>orthographic</i> and <span class="idx" data-term="perspective projection"/><i>perspective</i>, but here you’ll use only perspective projections, which are defined by a <span class="idx" data-term="field of view"/><i>field of view</i> (the extent to which the eye can see), a <span class="idx" data-term="near plane"/><i>near plane</i> (the plane closest to the eye), a <span class="idx" data-term="far plane"/><i>far plane</i> (the plane farthest from the eye), and an <span class="idx" data-term="aspect ratio"/><i>aspect ratio</i> (the ratio of the width to the height of the near plane). Together, these parameters constitute a camera model for a projection that determines how the 3D figure will be mapped onto a 2D screen, as shown in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#fig9-4">Figure 9-4</a>. The truncated pyramid shown in the figure is the <i>view frustum</i>. The <i>eye</i> is the 3D location where you place the camera. (For orthographic projection, the eye will be at infinity, and the pyramid will become a rectangular cuboid.)</p>
<figure class="figure" id="fig9-4">
<p class="fig"><img alt="" height="1080" src="images/nsp-venkitachalam503045-f09004.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 9-4:</span> A perspective projection <span class="idx" data-term="perspective projection"/>camera model</p>
</figcaption>
</figure>
<p>Once the perspective projection is complete and before rasterization, the graphics primitives are clipped (or cut out) against the near and far planes shown in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#fig9-4">Figure 9-4</a>. The near and far planes are chosen such that the 3D objects you want to appear onscreen<span class="idx" data-level1="geometric primitive" data-term="OpenGL"/><span class="idx" data-term="geometric primitive"/> lie inside the view frustum; otherwise, they will be clipped away.<span class="idx" data-term="3D transformations (end)"/><span class="idx" data-level1="3D transformations (end)" data-term="OpenGL"/></p>
</section>
<section>
<h3 class="bh" id="bh1103"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1103"><span class="idx" data-term="shaders"/>Shaders</a></h3>
<p class="paft">You’ve seen how shaders fit into the modern OpenGL programmable graphics pipeline. Now let’s look at a simple pair of vertex and fragment shaders to get a sense of how <span class="idx" data-level1="GLSL example" data-term="OpenGL"/>GLSL works.</p>
<section>
<h4 class="ch" id="ch1101">A Vertex Shader</h4>
<p class="paft">Here is a simple <span class="idx" data-level1="vertex (begin)" data-term="shaders"/>vertex shader that computes the position and color of a vertex:</p>
<div class="codeline">
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ # version<span class="idx" data-level1="GLSL" data-term="OpenGL"/> 410 core</p>
<p class="cl2f"><!--<ccust1>2</ccust1>-->❷ in <span class="idx" data-level1="GLSL" data-term="OpenGL"/>vec3 aVert;</p>
<p class="cl2f"><span aria-label=" Page 159. " class="page" epub:type="pagebreak" id="p159" role="doc-pagebreak"/><!--<ccust1>3</ccust1>-->❸ uniform <span class="idx" data-level1="GLSL" data-term="OpenGL"/><span class="idx" data-level1="GLSL" data-term="OpenGL"/>mat4 uMVMatrix;</p>
<p class="cl2"><!--<ccust1>4</ccust1>-->❹ uniform mat4 uPMatrix;</p>
<p class="cl2f"><!--<ccust1>5</ccust1>-->❺ out <span class="idx" data-level1="GLSL" data-term="OpenGL"/>vec4 vCol;</p>
<p class="clf">void main() {</p>
<p class="cl">    // apply transformations</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ <span class="idx" data-level1="GLSL" data-term="OpenGL"/>gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);</p>
<p class="cl">    // set color</p>
<p class="cl">  <!--<ccust1>7</ccust1>-->❼ vCol = vec4(1.0, 0.0, 0.0, 1.0);</p>
<p class="cll">}</p>
</div>
<p>You first set the version of GLSL used in the shader to version 4.1 <!--<ccust1>1</ccust1>-->❶. Then you define an input named <code>aVert</code> of type <code>vec3</code> (a 3D vector) for the vertex shader using the keyword <span class="idx" data-level1="GLSL" data-term="OpenGL"/><code>in</code> <!--<ccust1>2</ccust1>-->❷. You next define two variables of type <code>mat4</code> (4×4 matrices), which correspond to the modelview <!--<ccust1>3</ccust1>-->❸ and projection <!--<ccust1>4</ccust1>-->❹ matrices. The <code>uniform</code> prefix to these variables indicates that they do not change during execution of the vertex shader for a given rendering call on a set of vertices. You use the <span class="idx" data-level1="GLSL" data-term="OpenGL"/><code>out</code> prefix to define the output of the vertex shader, which is a color variable of type <code>vec4</code> (a 4D vector to store red, green, blue, and alpha channels) <!--<ccust1>5</ccust1>-->❺.</p>
<p>Now you come to the <code>main()</code> function, where the vertex shader program starts. The value of <code>gl_Position</code> is computed by transforming the input <code>aVert</code> using the uniform matrices passed in <!--<ccust1>6</ccust1>-->❻. The GLSL variable <code>gl_Position</code> is used to store the transformed vertices. You set the output color from the vertex shader to red with no transparency by using the value (1, 0, 0, 1) <!--<ccust1>7</ccust1>-->❼. You’ll use this as input in the next shader in the pipeline.<span class="idx" data-level1="vertex (end)" data-term="shaders"/></p>
</section>
<section>
<h4 class="ch" id="ch1102">A Fragment <span class="idx" data-level1="fragment" data-term="shaders"/>Shader</h4>
<p class="paft">Now let’s look at a <span class="idx" data-level1="GLSL" data-term="OpenGL"/>simple fragment shader that computes the fragment color based on the vertex color passed in:</p>
<div class="codeline">
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ # version<span class="idx" data-level1="GLSL" data-term="OpenGL"/> 410 core</p>
<p class="cl2f"><!--<ccust1>2</ccust1>-->❷ in vec4 vCol;</p>
<p class="cl2f"><!--<ccust1>3</ccust1>-->❸ out vec4 fragColor;</p>
<p class="clf">void main() {</p>
<p class="cl">    // use vertex color</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ fragColor = vCol;</p>
<p class="cll">}</p>
</div>
<p>After setting the version of GLSL used in the shader <!--<ccust1>1</ccust1>-->❶, you set <code>vCol</code> as the input to the fragment shader <!--<ccust1>2</ccust1>-->❷. This variable, <code>vCol</code>, was set as output from the vertex shader. (Remember, the vertex shader executes for every vertex in the 3D scene, whereas the fragment shader executes for every fragment on the screen.) You also set the fragment shader’s output color variable <code>fragColor</code> <!--<ccust1>3</ccust1>-->❸.</p>
<p>During <span class="idx" data-level1="GLSL" data-term="OpenGL"/>rasterization (which occurs between the vertex and fragment shaders), OpenGL converts the transformed vertices to fragments, and <span aria-label=" Page 160. " class="page" epub:type="pagebreak" id="p160" role="doc-pagebreak"/>the color of the fragments lying between the vertices is calculated by interpolating the color values at the vertices; <code>vCol</code> in the previous code is this interpolated color. You set the fragment shader’s output to be the same as the interpolated color going into the fragment shader <!--<ccust1>4</ccust1>-->❹. By default, and in most cases, the intended output of the fragment shader is the screen, and the color you set ends up there (unless it’s affected by operations, such as depth testing, that occur in the final stage of the graphics pipeline).</p>
<p>For the GPU to execute the shader code, it needs to be <span class="idx" data-level1="GLSL" data-term="OpenGL"/>compiled and <span class="idx" data-level1="GLSL" data-term="OpenGL"/>linked to instructions that the hardware understands. OpenGL provides ways to do this and reports detailed compiler and linker errors that will help you develop the shader code. The compilation process also generates a table of locations or indices for the variables declared in your shaders so you can connect them to variables in your Python code.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1104"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1104"><span class="idx" data-term="vertex buffers"/>Vertex Buffers</a></h3>
<p class="paft"><i>Vertex buffers</i> are an important mechanism used by OpenGL shaders. Modern graphics hardware and OpenGL are designed to work with large amounts of 3D geometry. Consequently, several mechanisms are built into OpenGL to help transfer data from the program to the GPU. A typical setup to draw 3D geometry in a program will do the following:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Define arrays of coordinates, colors, and other attributes for each vertex of the 3D geometry.</li>
<li class="nl">2. Create a <span class="idx" data-level1="vertex array object" data-term="OpenGL"/><span class="idx" data-term="vertex array object"/>vertex array object (<span class="idx" data-level1="VAO. See vertex array object" data-term="OpenGL"/>VAO) and bind to it.</li>
<li class="nl">3. Create <span class="idx" data-level1="VBO. See vertex buffer object" data-term="OpenGL"/><span class="idx" data-level1="vertex buffer object" data-term="OpenGL"/>vertex buffer objects (<span class="idx" data-term="vertex buffer object"/>VBOs) for each attribute, defined on a per-vertex basis.</li>
<li class="nl">4. Bind to the VBO and set the buffer data using the predefined arrays.</li>
<li class="nl">5. Specify the data and location of vertex attributes to be used in the shader.</li>
<li class="nl">6. Enable the vertex attributes.</li>
<li class="nll">7. Render the data.</li>
</ol>
<p>After you define the 3D geometry in terms of vertices, you create and bind to a vertex array object. VAOs are a convenient way to group geometry as multiple arrays of coordinates, colors, and so on. Then, for each attribute of each vertex, you create a vertex buffer object and set your 3D data into it. The VBO stores the vertex data in the GPU memory. Now, all that’s left is to connect the buffer data so you can access it from your shaders. You do this through calls that use the location of the variables employed in the shader.</p>
</section>
<section>
<h3 class="bh" id="bh1105"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1105"><span class="idx" data-term="texture mapping (begin)"/>Texture Mapping</a></h3>
<p class="paft">Now let’s look at texture mapping, an important computer graphics technique that you’ll use in this chapter. <i>Texture mapping</i> is a way to give a scene a realistic feel with the help of a 2D picture of a 3D object (like the backdrop in a play). A texture is usually read from an image file and is stretched to drape over a geometric region by mapping the 2D coordinates (in the range <span aria-label=" Page 161. " class="page" epub:type="pagebreak" id="p161" role="doc-pagebreak"/>[0, 1]) onto the 3D coordinates of the polygons. For example, <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#fig9-5">Figure 9-5</a> shows an image draped onto one face of a cube. (I used <span class="idx" data-level1="GL_TRIANGLE_STRIP" data-term="OpenGL"/><span class="idx" data-term="GL_TRIANGLE_STRIP"/><code>GL_TRIANGLE_STRIP</code> primitives to draw the cube faces, and the ordering of the vertices is indicated by the lines on the face.)</p>
<figure class="figure" id="fig9-5">
<p class="fig"><img alt="" height="543" src="images/nsp-venkitachalam503045-f09005.jpg" style="width:95%; height:auto;" width="938"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 9-5:</span> Texture mapping</p>
</figcaption>
</figure>
<p>In <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#fig9-5">Figure 9-5</a>, the (0, 0) corner of the texture is mapped to the bottom-left vertex of the cube face. Similarly, you can see how the other corners of the texture are mapped, with the net effect that the texture is “pasted” onto this cube face. The geometry of the cube face itself is defined as a <span class="idx" data-level1="triangle strip" data-term="OpenGL"/>triangle strip, and the vertices zigzag from the bottom to the top left and from the bottom to the top right. Textures are extremely powerful and versatile computer graphics tools, as you’ll see in <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#ch11">Chapter 11</a>.</p>
</section>
<section>
<h3 class="bh" id="bh1106"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1106"><span class="idx" data-level1="displaying" data-term="OpenGL"/>The OpenGL Context</a></h3>
<p class="paft">Now let’s talk about how to get OpenGL to draw stuff on the screen. The entity that stores all the OpenGL state information is called the <span class="idx" data-level1="context" data-term="OpenGL"/><i>OpenGL context</i>. Contexts have a viewable, window-like area where the OpenGL drawings go, and you can have multiple contexts per process or run of an application, but only one context per thread can be current at a time. (Fortunately, the window toolkit will take care of most of the context handling.)</p>
<p>For your OpenGL output to appear in a window onscreen, you need the help of the operating system. For these projects, you’ll use GLFW, a lightweight cross-platform C library that lets you create and manage OpenGL contexts, display the 3D graphics in a window, and handle user input such as mouse clicks and keypresses. (<a class="xref" href="nsp-venkitachalam503045-0031.xhtml#appa">Appendix A</a> covers the installation details for this library.)</p>
<p>Because you’re writing code in Python and not C, you’ll also use a Python binding to GLFW (<i>glfw.py</i>, available in the <i>common</i> directory in the book’s code repository), which lets you access all the GLFW features using Python.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah1102"><span aria-label=" Page 162. " class="page" epub:type="pagebreak" id="p162" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1102">Requirements</a></h2>
<p class="paft">You’ll use <span class="idx" data-term="PyOpenGL module"/><code>PyOpenGL</code>, a popular Python binding for OpenGL, for rendering, and you’ll use <span class="idx" data-term="numpy module"/><code>numpy</code> arrays to represent 3D coordinates and transformation matrices.</p>
</section>
<section>
<h2 class="ah" id="ah1103"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1103">The Code</a></h2>
<p class="paft">In this project, you’ll build a simple Python application for displaying a rotating, textured polygon using OpenGL. To see the complete project code, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ah1107">“The Complete Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#p172">page 172</a>. The complete code for our simple OpenGL application resides in two files. The main project code discussed in this chapter is in <i>simpleglfw.py</i>, which can be found at <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/simplegl">https://github.com/mkvenkit/pp2e/tree/main/simplegl</a>. The helper functions are in <i>glutils.py</i>, which can be found in the GitHub repository’s <i>common</i> directory.</p>
<section>
<h3 class="bh" id="bh1107"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1107">The RenderWindow Class</a></h3>
<p class="paft">The <code>RenderWindow</code> class manages the creation of the window that displays the OpenGL graphics. It initializes GLFW, sets up OpenGL, manages rendering, and sets up callbacks to receive keyboard input.</p>
<section>
<h4 class="ch" id="ch1103">Creating an OpenGL Window</h4>
<p class="paft">The first order of business of the <code>RenderWindow</code> class is to set up GLFW so you have an OpenGL window to render into. The class’s initialization code addresses this task:</p>
<div class="codeline">
<p class="clf">class RenderWindow:</p>
<p class="cl">    """GLFW rendering window class"""</p>
<p class="cl">    def __init__(self):</p>
<p class="clf">        # save current working directory</p>
<p class="cl">        cwd = os.getcwd()</p>
<p class="clf">        # initialize glfw</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ glfw.<span class="idx" data-level1="glfwInit" data-term="GLFW"/>glfwInit()</p>
<p class="clf">        # restore cwd</p>
<p class="cl">        os.chdir(cwd)</p>
<p class="clf">        # version hints</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ glfw.<span class="idx" data-level1="glfwWindowHint" data-term="GLFW"/>glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 4)</p>
<p class="cl">        glfw.<span class="idx" data-level1="glfwWindowHint" data-term="GLFW"/>glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 1)</p>
<p class="cl">        glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)</p>
<p class="cl">        glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,</p>
<p class="cl">                            glfw.GLFW_OPENGL_CORE_PROFILE)</p>
<p class="clf">        # make a window</p>
<p class="cl">        self.width, self.height = 800, 600</p>
<p class="cl">        self.aspect = self.width/float(self.height)</p>
<p class="cl"><span aria-label=" Page 163. " class="page" epub:type="pagebreak" id="p163" role="doc-pagebreak"/>      <!--<ccust1>3</ccust1>-->❸ self.win = glfw.<span class="idx" data-level1="glfwCreateWindow" data-term="GLFW"/>glfwCreateWindow(self.width, self.height,</p>
<p class="cl">                                         b'simpleglfw')</p>
<p class="clf">        # make the context current</p>
<p class="cll">      <!--<ccust1>4</ccust1>-->❹ glfw.<span class="idx" data-level1="glfwMakeContextCurrent" data-term="GLFW"/>glfwMakeContextCurrent(self.win)</p>
</div>
<p>You initialize the GLFW library <!--<ccust1>1</ccust1>-->❶, and then, starting at <!--<ccust1>2</ccust1>-->❷, you set the OpenGL version to the OpenGL 4.1 core profile. You next create an OpenGL-capable window with the dimensions 800×600 <!--<ccust1>3</ccust1>-->❸. Finally, you make the context current <!--<ccust1>4</ccust1>-->❹, and you’re ready to make OpenGL calls.</p>
<p>Next, still within the <code>__init__()</code> definition, you make some initialization calls:</p>
<div class="codeline">
<p class="clf">        # initialize GL</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ <span class="idx" data-level1="glViewport" data-term="OpenGL"/>glViewport(0, 0, self.width, self.height)</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ <span class="idx" data-level1="glEnable" data-term="OpenGL"/>glEnable(GL_DEPTH_TEST)</p>
<p class="cll">      <!--<ccust1>3</ccust1>-->❸ <span class="idx" data-level1="glClearColor" data-term="OpenGL"/>glClearColor(0.5, 0.5, 0.5, 1.0)</p>
</div>
<p>Here you set the viewport or screen dimensions (width and height) where OpenGL will render your 3D scene <!--<ccust1>1</ccust1>-->❶. Then you turn on depth testing with <code>GL_DEPTH_TEST</code> <!--<ccust1>2</ccust1>-->❷ and set the color the background should become when <code>glClear()</code> is issued during rendering <!--<ccust1>3</ccust1>-->❸. You choose 50 percent gray with an <code>alpha</code> setting of 1.0. (Alpha is a measure of the transparency of a fragment—1.0 means fully opaque.)</p>
</section>
<section>
<h4 class="ch" id="ch1104">Setting Callbacks</h4>
<p class="paft">You finish the <code>__init__()</code> definition by registering event callbacks for user interface events within the GLFW window so you can respond to keypresses:</p>
<div class="codeline">
<p class="clf">        # set window callbacks</p>
<p class="cll">        glfw.<span class="idx" data-level1="glfwSetKeyCallback" data-term="GLFW"/>glfwSetKeyCallback(self.win, self.onKeyboard)</p>
</div>
<p>This code sets callbacks for keypresses. Every time one of these events happens, the function registered as a callback, <code>onKeyboard()</code>, is executed. Let’s look at the definition of that keyboard callback function now:</p>
<div class="codeline">
<p class="clf">def onKeyboard(self, win, key, scancode, action, mods):</p>
<p class="cl">    # print 'keyboard: ', win, key, scancode, action, mods</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ if action == glfw.GLFW_PRESS:</p>
<p class="cl">        # ESC to quit</p>
<p class="cl">        if key == glfw.GLFW_KEY_ESCAPE:</p>
<p class="cl">          <!--<ccust1>2</ccust1>-->❷ self.exitNow = True</p>
<p class="cl">        else:</p>
<p class="cl">            # toggle cut</p>
<p class="cll">          <!--<ccust1>3</ccust1>-->❸ self.scene.showCircle = not self.scene.showCircle</p>
</div>
<p>The <code>onKeyboard()</code> callback is called every time a keyboard event happens. The arguments to the function arrive filled with useful information such as what type of <span class="idx" data-level1="keyboard events" data-term="GLFW"/>event occurred (key-up versus key-down, for example) and which key was pressed. The code <code>glfw.GLFW_PRESS</code> says to look only for key-down, or <code>PRESS</code>, events <!--<ccust1>1</ccust1>-->❶. You set an exit flag if the <span class="sm">ESC</span> key is pressed <!--<ccust1>2</ccust1>-->❷. If <span aria-label=" Page 164. " class="page" epub:type="pagebreak" id="p164" role="doc-pagebreak"/>any other key is pressed, you toggle a <code>showCircle</code> Boolean <!--<ccust1>3</ccust1>-->❸. This variable will be used in the fragment shader to keep or discard fragments outside the circle area.</p>
</section>
<section>
<h4 class="ch" id="ch1105">Defining the Main Loop</h4>
<p class="paft">The <code>RenderWindow</code> class also defines the main loop of the program through its <code>run()</code> method. (GLFW doesn’t provide a default program loop.) The <code>run()</code> method updates the OpenGL window at a preset time interval. After calling the render methods to draw the scene, it also polls the system for any pending window or keyboard events. Let’s look at the method definition:</p>
<div class="codeline">
<p class="clf">def run(self):</p>
<p class="cl">    # initializer timer</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ glfw.<span class="idx" data-level1="glfwSetTime" data-term="GLFW"/>glfwSetTime(0)</p>
<p class="cl">    t = 0.0</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ while not glfw.<span class="idx" data-level1="glfwWindowShouldClose" data-term="GLFW"/>glfwWindowShouldClose(self.win) and not self.exitNow:</p>
<p class="cl">        # update every x seconds</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ currT = glfw.<span class="idx" data-level1="glfwGetTime" data-term="GLFW"/>glfwGetTime()</p>
<p class="cl">        if currT - t &gt; 0.1:</p>
<p class="cl">            # update time</p>
<p class="cl">            t = currT</p>
<p class="cl">            # clear</p>
<p class="cl">          <!--<ccust1>4</ccust1>-->❹ <span class="idx" data-level1="glClear" data-term="OpenGL"/>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</p>
<p class="cl">            # set viewport</p>
<p class="cl">          <!--<ccust1>5</ccust1>-->❺ self.width, self.height = glfw.glfwGetFramebufferSize(self.win)</p>
<p class="cl">          <!--<ccust1>6</ccust1>-->❻ self.aspect = self.width/float(self.height)</p>
<p class="cll">          <!--<ccust1>7</ccust1>-->❼ glViewport(0, 0, self.width, self.height)</p>
</div>
<p>In the main loop, <code>glfw.glfwSetTime()</code> resets the GLFW timer to 0 <!--<ccust1>1</ccust1>-->❶. You’ll use this timer to redraw the graphics at regular intervals. You initiate a <code>while</code> loop <!--<ccust1>2</ccust1>-->❷ that exits only if the window is closed or <code>exitNow</code> is set to <code>True</code>. When the loop exits, <code>glfw.glfwTerminate()</code> is called to shut down GLFW cleanly.</p>
<p>Inside the loop, <code>glfw.glfwGetTime()</code> gets the current timer value <!--<ccust1>3</ccust1>-->❸, which you use to calculate the elapsed time since the last drawing. By setting a desired interval here (in this case, to 0.1 second or 100 milliseconds), you can adjust the rendering frame rate. Next, <code>glClear()</code> clears the depth and color buffers and replaces them with the set background color to get ready for the next frame <!--<ccust1>4</ccust1>-->❹.</p>
<p>You query and set the window width and height using the <code>glfwGetFramebufferSize()</code> function <!--<ccust1>5</ccust1>-->❺. You do this in case the user has changed the window’s size. Note that in some systems (such as a MacBook with Retina display) the window size and frame buffer size can be different, so to be safe, always query the latter. You next compute the aspect ratio of the window <!--<ccust1>6</ccust1>-->❻, which you’ll use later to set the projection matrix. Then you clear the viewport using the new frame buffer dimensions you retrieved <!--<ccust1>7</ccust1>-->❼.</p>
<p>Now let’s look at the remaining part of the <code>run()</code> method:</p>
<div class="codeline">
<p class="clf">            # build projection matrix</p>
<p class="cl">          <!--<ccust1>1</ccust1>-->❶ pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)</p>
<p class="clf"><span aria-label=" Page 165. " class="page" epub:type="pagebreak" id="p165" role="doc-pagebreak"/>          <!--<ccust1>2</ccust1>-->❷ mvMatrix = glutils.lookAt([0.0, 0.0, -2.0], [0.0, 0.0, 0.0],</p>
<p class="cl">                                      [0.0, 1.0, 0.0])</p>
<p class="cl">            # render</p>
<p class="cl">          <!--<ccust1>3</ccust1>-->❸ self.scene.render(pMatrix, mvMatrix)</p>
<p class="cl">            # step</p>
<p class="cl">          <!--<ccust1>4</ccust1>-->❹ self.scene.step()</p>
<p class="clf">          <!--<ccust1>5</ccust1>-->❺ glfw.<span class="idx" data-level1="glfwSwapBuffers" data-term="GLFW"/><span class="idx" data-level1="glfwSwapBuffers" data-term="GLFW"/>glfwSwapBuffers(self.win)</p>
<p class="cl">            # poll for and process events</p>
<p class="cl">          <!--<ccust1>6</ccust1>-->❻ glfw.<span class="idx" data-level1="glfwPollEvents" data-term="GLFW"/>glfwPollEvents()</p>
<p class="cl">    # end</p>
<p class="cll">    glfw.<span class="idx" data-level1="glfwTerminate" data-term="GLFW"/>glfwTerminate()</p>
</div>
<p>Still within the <code>while</code> loop, you compute the projection matrix using the <code>perspective()</code> method defined in <i>glutils.py</i> <!--<ccust1>1</ccust1>-->❶. The projection matrix is the transformation that maps a 3D scene to a 2D screen. Here you ask for a 45-degree field of view and a near/far plane distance of 0.1/100.0. Then you set the modelview matrix using the <code>lookAt()</code> method <!--<ccust1>2</ccust1>-->❷, also defined in <i>glutils.py</i>. The default OpenGL view puts your eye at the origin looking along the negative z-direction. The modelview matrix created by the <code>lookAt()</code> method transforms the vertices such that the view matches up with the eye position and orientation specified by the call. You set the eye position to (0, 0, −2), looking at the origin (0, 0, 0) with an “up” vector of (0, 1, 0). Next, you call the <code>render()</code> method on the <code>scene</code> object <!--<ccust1>3</ccust1>-->❸, passing in these matrices, and you call <code>scene.step()</code> so it can update the variables necessary for the time step <!--<ccust1>4</ccust1>-->❹. (The <code>Scene</code> class, which we’ll look at next, encapsulates the setup and rendering of the polygon.) The <code>glfwSwapBuffers()</code> call <!--<ccust1>5</ccust1>-->❺ swaps the back and front buffers, thus displaying your updated 3D graphic, and the <code>glfwPollEvents()</code> call <!--<ccust1>6</ccust1>-->❻ checks for any UI events and returns control to the <code>while</code> loop.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1108"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1108">The Scene Class</a></h3>
<p class="paft">Now let’s look at the <code>Scene</code> class, which is responsible for initializing and drawing the 3D geometry. Here’s the start of the class declaration:</p>
<div class="codeline">
<p class="clf">class Scene:</p>
<p class="cl">    """ OpenGL 3D scene class"""</p>
<p class="cl">    # initialization</p>
<p class="cl">    def __init__(self):</p>
<p class="cl">        # create shader</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ self.program = glutils.loadShaders(strVS, strFS)</p>
<p class="cls">      <!--<ccust1>2</ccust1>-->❷ <span class="idx" data-level1="glUseProgram" data-term="OpenGL"/>glUseProgram(self.program)</p>
</div>
<p>In the <code>Scene</code> class constructor, you first compile and load the shaders. For this, you use the utility method <code>loadShaders()</code> <!--<ccust1>1</ccust1>-->❶ defined in <i>glutils.py</i>, which provides a convenient wrapper around the series of OpenGL calls required to load the shader code from strings, compile it, and link it into an <span aria-label=" Page 166. " class="page" epub:type="pagebreak" id="p166" role="doc-pagebreak"/>OpenGL program object. Because OpenGL is a state machine, you need to set the code to use a particular “program object” (because a project could have multiple programs) using the <code>glUseProgram()</code> call <!--<ccust1>2</ccust1>-->❷.</p>
<p>The <code>__init__()</code> method continues by connecting the variables in the Python code with those in the shaders:</p>
<div class="codeline1">
<p class="cl1f">        self.pMatrixUniform = <span class="idx" data-level1="glGetUniformLocation" data-term="OpenGL"/>glGetUniformLocation(self.program, b'uPMatrix')</p>
<p class="cl1">        self.mvMatrixUniform = glGetUniformLocation(self.program, b'uMVMatrix')</p>
<p class="cl1">        # texture</p>
<p class="cl1l">        self.tex2D = glGetUniformLocation(self.program, b'tex2D')</p>
</div>
<p>This code uses the <code>glGetUniformLocation()</code> method to retrieve the locations of the variables <code>uPMatrix</code>, <code>uMVMatrix</code>, and <code>tex2D</code> defined inside the vertex and fragment shaders. These locations can then be used to set the values for the shader variables.</p>
<section>
<h4 class="ch" id="ch1106">Defining the 3D Geometry</h4>
<p class="paft">The next part of the <code>Scene</code> class’s <code>__init__()</code> method defines the 3D geometry for the scene. You first define the geometry for the polygon, which will take the form of a square:</p>
<div class="codeline">
<p class="clf">        # define triangle strip vertices</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ vertexData = numpy.<span class="idx" data-level1="array" data-term="numpy module"/><span class="idx" data-level1="array" data-term="numpy module"/>array(</p>
<p class="cl">            [-0.5, -0.5, 0.0,</p>
<p class="cl">             0.5, -0.5, 0.0,</p>
<p class="cl">             -0.5, 0.5, 0.0,</p>
<p class="cl">             0.5, 0.5, 0.0], numpy.float32)</p>
<p class="clf">        # set up vertex array object (VAO)</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.vao = <span class="idx" data-level1="glGenVertexArrays" data-term="OpenGL"/>glGenVertexArrays(1)</p>
<p class="cl">        <span class="idx" data-level1="glBindVertexArray" data-term="OpenGL"/>glBindVertexArray(self.vao)</p>
<p class="cl">        # vertices</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ self.vertexBuffer = <span class="idx" data-level1="glGenBuffers" data-term="OpenGL"/>glGenBuffers(1)</p>
<p class="cl">        <span class="idx" data-level1="glBindBuffer" data-term="OpenGL"/>glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)</p>
<p class="cl">        # set buffer data</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ <span class="idx" data-level1="glBufferData" data-term="OpenGL"/>glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,</p>
<p class="cl">                     GL_STATIC_DRAW)</p>
<p class="cl">        # enable vertex array</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ <span class="idx" data-level1="glEnableVertexAttribArray" data-term="OpenGL"/>glEnableVertexAttribArray(0)</p>
<p class="cl">        # set buffer data pointer</p>
<p class="cl">      <!--<ccust1>6</ccust1>-->❻ <span class="idx" data-level1="glVertexAttribPointer" data-term="OpenGL"/>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)</p>
<p class="cl">        # unbind VAO</p>
<p class="cll">      <!--<ccust1>7</ccust1>-->❼ <span class="idx" data-level1="glBindVertexArray" data-term="OpenGL"/>glBindVertexArray(0)</p>
</div>
<p>First you define the array of vertices of the triangle strip used to draw the square <!--<ccust1>1</ccust1>-->❶. Think of a square of a side length of 1.0 centered at the origin. The bottom-left vertex of this square has the coordinates (−0.5, −0.5, 0.0); the next vertex (the bottom-right one) has the coordinates (0.5, −0.5, 0.0); and so on. The order of the four coordinates is that of a <code>GL_TRIANGLE_STRIP</code>. Essentially, you’re creating the square by defining two right triangles with a shared hypotenuse.</p>
<p><span aria-label=" Page 167. " class="page" epub:type="pagebreak" id="p167" role="doc-pagebreak"/>Next, you create a VAO <!--<ccust1>2</ccust1>-->❷. Once you bind to this VAO, all upcoming calls will be bound to it. You then create a VBO to manage the rendering of the vertex data <!--<ccust1>3</ccust1>-->❸. Once the buffer is bound, you set the buffer data from the vertices you’ve defined <!--<ccust1>4</ccust1>-->❹.</p>
<p>Now you need to enable the shaders to access this data. For that, you call <code>glEnableVertexAttribArray()</code> <!--<ccust1>5</ccust1>-->❺. You use an index of 0 because that is the location you have set in the vertex shader for the vertex data variable. Calling <code>glVertexAttribPointer()</code> sets the location and data format of the vertex attribute array <!--<ccust1>6</ccust1>-->❻. The index of the attribute is 0, the number of components is 3 (you use 3D vertices), and the data type of the vertex is <code>GL_FLOAT</code>. You then unbind the VAO <!--<ccust1>7</ccust1>-->❼ so other related calls don’t interfere with it. In OpenGL, it’s a best practice to reset states when you’re done. OpenGL is a state machine, so if you leave things in a mess, they will remain that way.</p>
<p>The following code loads an image of a star as an OpenGL texture:</p>
<div class="codeline">
<p class="clf">        # texture</p>
<p class="cll">        self.texId = glutils.loadTexture('star.png')</p>
</div>
<p>The texture ID returned will be used later in rendering.</p>
</section>
<section>
<h4 class="ch" id="ch1107">Rotating the Square</h4>
<p class="paft">Next you need to update variables in the <code>Scene</code> object to make the square rotate on the screen. Use the class’s <code>step()</code> method:</p>
<div class="codeline">
<p class="clf"># step</p>
<p class="cl">def step(self):</p>
<p class="cl">    # increment angle</p>
<p class="cll">  <!--<ccust1>1</ccust1>-->❶ self.t = (self.t + 1) % 360</p>
</div>
<p>At <!--<ccust1>1</ccust1>-->❶, you increment the angle variable <code>t</code> and use the modulus operator (<code>%</code>) to keep this value within [0, 360]. This variable will be used to update the rotation angle in the vertex shader.</p>
</section>
<section>
<h4 class="ch" id="ch1108">Rendering the Scene</h4>
<p class="paft">Now let’s look at the <code>Scene</code> object’s main rendering code:</p>
<div class="codeline">
<p class="clf">def render(self, pMatrix, mvMatrix):</p>
<p class="cl">    # use shader</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ <span class="idx" data-level1="glUseProgram" data-term="OpenGL"/>glUseProgram(self.program)</p>
<p class="clf">    # set projection matrix</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ <span class="idx" data-level1="glUniformMatrix4fv" data-term="OpenGL"/>glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)</p>
<p class="clf">    # set modelview matrix</p>
<p class="cl">    glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)</p>
<p class="cl">    # set shader angle in radians</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ glUniform1f(glGetUniformLocation(self.program, 'uTheta'),</p>
<p class="cl">                math.radians(self.t))</p>
<p class="cl">    # show circle?</p>
<p class="cl"><span aria-label=" Page 168. " class="page" epub:type="pagebreak" id="p168" role="doc-pagebreak"/>  <!--<ccust1>4</ccust1>-->❹ <span class="idx" data-level1="glUniform1i" data-term="OpenGL"/>glUniform1i(glGetUniformLocation(self.program, b'showCircle'),</p>
<p class="cl">                self.showCircle)</p>
<p class="clf">    # enable texture</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ <span class="idx" data-level1="glActiveTexture" data-term="OpenGL"/>glActiveTexture(GL_TEXTURE0)</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ <span class="idx" data-level1="glBindTexture" data-term="OpenGL"/>glBindTexture(GL_TEXTURE_2D, self.texId)</p>
<p class="cl">  <!--<ccust1>7</ccust1>-->❼ glUniform1i(self.tex2D, 0)</p>
<p class="clf">    # bind VAO</p>
<p class="cl">  <!--<ccust1>8</ccust1>-->❽ <span class="idx" data-level1="glBindVertexArray" data-term="OpenGL"/>glBindVertexArray(self.vao)</p>
<p class="cl">    # draw</p>
<p class="cl">  <!--<ccust1>9</ccust1>-->❾ <span class="idx" data-level1="glDrawArrays" data-term="OpenGL"/>glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)</p>
<p class="cl">    # unbind VAO</p>
<p class="cll">  <!--<ccust1>10</ccust1>-->❿ glBindVertexArray(0)</p>
</div>
<p>First you set up the rendering to use the shader program <!--<ccust1>1</ccust1>-->❶. Starting at <!--<ccust1>2</ccust1>-->❷, you set the computed projection and modelview matrices in the shader using the <code>glUniformMatrix4fv()</code> method. Then you use the <code>glUniform1f()</code> method to set <code>uTheta</code> in the shader program <!--<ccust1>3</ccust1>-->❸. You use <code>glGetUniformLocation()</code> as before to get the location of the <code>uTheta</code> angle variable from the shader, and you use the Python <code>math.radians()</code> method to convert the angle from degrees to radians. Next, you use <code>glUniform1i()</code> to set the current value of the <code>showCircle</code> variable in the fragment shader <!--<ccust1>4</ccust1>-->❹. OpenGL has a concept of multiple<span class="idx" data-term="texture unit"/><span class="idx" data-level1="texture unit" data-term="OpenGL"/> texture units, and <code>glActiveTexture()</code> <!--<ccust1>5</ccust1>-->❺ activates texture unit 0 (the default). You bind the texture ID you generated earlier from the <i>star.png</i> image to activate it for rendering <!--<ccust1>6</ccust1>-->❻. The <code>sampler2D</code> variable in the fragment shader is set to texture unit 0 <!--<ccust1>7</ccust1>-->❼.</p>
<p>You continue by binding to the VAO you created previously <!--<ccust1>8</ccust1>-->❽. Now you see the benefit of using VAOs: you don’t need to repeat a whole bunch of vertex buffer–related calls before the actual drawing. You then call <code>glDrawArrays()</code> to render the bound vertex buffers <!--<ccust1>9</ccust1>-->❾. The primitive type is a triangle strip, and there are four vertices to be rendered. Finally, you unbind the VAO at <!--<ccust1>10</ccust1>-->❿, which is always a good coding practice.</p>
</section>
<section>
<h4 class="ch" id="ch1109">Defining the GLSL Shaders</h4>
<p class="paft">Now let’s look at the most exciting part of the project—the GLSL shaders. First, here’s the <span class="idx" data-level1="GLSL" data-term="OpenGL"/>vertex shader, which computes the position and texture coordinates of the vertices:</p>
<div class="codeline">
<p class="clf"># version 410 core</p>
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ layout(location = 0) in vec3 aVert;</p>
<p class="cl2f"><!--<ccust1>2</ccust1>-->❷ uniform mat4 uMVMatrix;</p>
<p class="cl">uniform mat4 uPMatrix;</p>
<p class="cl">uniform float uTheta;</p>
<p class="cl2f"><!--<ccust1>3</ccust1>-->❸ out vec2 vTexCoord;</p>
<p class="clf">void main() {</p>
<p class="cl">    // rotational transform</p>
<p class="cl"><span aria-label=" Page 169. " class="page" epub:type="pagebreak" id="p169" role="doc-pagebreak"/>  <!--<ccust1>4</ccust1>-->❹ mat4 rot = mat4(</p>
<p class="cl">                vec4(1.0, 0.0, 0.0, 0.0),</p>
<p class="cl">                vec4(0.0, cos(uTheta), -sin(uTheta), 0.0),</p>
<p class="cl">                vec4(0.0, sin(uTheta),  cos(uTheta), 0.0),</p>
<p class="cl">                vec4(0.0, 0.0,          0.0,         1.0)</p>
<p class="cl">                );</p>
<p class="cl">    // transform vertex</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ gl_Position = uPMatrix * uMVMatrix * rot * vec4(aVert, 1.0);</p>
<p class="cl">    // set texture coordinate</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ vTexCoord = aVert.xy + vec2(0.5, 0.5);</p>
<p class="cll">}</p>
</div>
<p>You use the <code>layout</code> keyword <!--<ccust1>1</ccust1>-->❶ to set explicitly the location of the vertex attribute <code>aVert</code>—to 0, in this case. This attribute lets the vertex shader access the vertices that you defined for the polygon. Starting at <!--<ccust1>2</ccust1>-->❷, you declare three <code>uniform</code> variables for the projection and modelview matrices and the rotation angle. These will be set from the Python code. You also set a 2D vector <code>vTexCoord</code> as an output from this shader <!--<ccust1>3</ccust1>-->❸. This will be available as an input to the fragment shader.</p>
<p>In the <code>main()</code> method in the shader, you set up a rotation matrix <!--<ccust1>4</ccust1>-->❹, which rotates around the x-axis by a given angle, <code>uTheta</code>. You <span class="idx" data-level1="GLSL" data-term="OpenGL"/>compute <code>gl_Position</code> <!--<ccust1>5</ccust1>-->❺ using a concatenation of the projection, modelview, and rotation matrices. This gives you the position of the output vertex from the shader. You then set up a 2D vector as a texture coordinate <!--<ccust1>6</ccust1>-->❻. You may recall that you defined the triangle strip for a square centered at the origin with side 1.0. Because texture coordinates are in the range [0, 1], you can generate these from the vertex coordinates by adding (0.5, 0.5) to the x- and y-values. This also demonstrates the power and immense flexibility of shaders for your computations. Texture coordinates and other variables aren’t sacrosanct; you can set them to just about anything.</p>
<p>Now let’s look at the fragment shader, which computes the output pixels of our OpenGL program:</p>
<div class="codeline">
<p class="clf"># version 410 core</p>
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ in vec2 vTexCoord;</p>
<p class="cl2f"><!--<ccust1>2</ccust1>-->❷ uniform sampler2D tex2D;</p>
<p class="cl2"><!--<ccust1>3</ccust1>-->❸ uniform bool showCircle;</p>
<p class="cl2f"><!--<ccust1>4</ccust1>-->❹ out vec4 fragColor;</p>
<p class="clf">void main() {</p>
<p class="cl">    if (showCircle) {</p>
<p class="cl">        // discard fragment outside circle</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ if (distance(vTexCoord, vec2(0.5, 0.5)) &gt; 0.5) {</p>
<p class="cl">            <span class="idx" data-level1="GLSL" data-term="OpenGL"/>discard;</p>
<p class="cl">        }</p>
<p class="cl">        else {</p>
<p class="cl">          <!--<ccust1>6</ccust1>-->❻ fragColor = texture(tex2D, vTexCoord);</p>
<p class="cl">        }</p>
<p class="cl">    }</p>
<p class="cl"><span aria-label=" Page 170. " class="page" epub:type="pagebreak" id="p170" role="doc-pagebreak"/>        else {</p>
<p class="cl">          <!--<ccust1>7</ccust1>-->❼ fragColor = texture(tex2D, vTexCoord);</p>
<p class="cl">        }</p>
<p class="cll">}</p>
</div>
<p>You start by defining inputs to the fragment shader—in this case the texture coordinate you set as output in the vertex shader <!--<ccust1>1</ccust1>-->❶. Recall that the fragment shader operates on a per-pixel basis, so the values set for these variables are those for the current pixel, interpolated across the polygon. You declare a <code>sampler2D</code> variable <!--<ccust1>2</ccust1>-->❷, which is linked to a particular texture unit and is used to look up the texture value, and a Boolean uniform flag <code>showCircle</code> <!--<ccust1>3</ccust1>-->❸, which is set from the Python code. You also declare <span class="idx" data-level1="GLSL" data-term="OpenGL"/><code>fragColor</code> as the output from the fragment shader <!--<ccust1>4</ccust1>-->❹. By default, this goes to the screen (after final frame buffer operations such as depth testing and blending).</p>
<p>Within the <code>main()</code> method, if the <code>showCircle</code> flag is not set <!--<ccust1>7</ccust1>-->❼, you use the GLSL <code>texture()</code> method to look up the texture color value using the texture coordinate and the sampler. In effect, you’re just texturing the triangle strip using the star image. If, however, the <code>showCircle</code> flag is <code>true</code> <!--<ccust1>5</ccust1>-->❺, you use the GLSL built-in method <code>distance()</code> to check how far the current pixel is from the center of the polygon. It uses the (interpolated) texture coordinates for this purpose, which are passed in by the vertex shader. If the distance is greater than a certain threshold (0.5 in this case), you call the GLSL <code>discard()</code> method, which drops the current pixel. If the distance is less than the threshold, you set the appropriate color from the texture <!--<ccust1>6</ccust1>-->❻. Basically, what this does is ignore pixels that are outside a circle with a radius of 0.5 centered at the midpoint of the square, thus cutting the polygon into a circle when <code>showCircle</code> is set.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1109"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1109">Utility Functions</a></h3>
<p class="paft">I’ve referred to several utility functions defined for you in <i>glutils.py</i> to make working with OpenGL easier. Let’s look at an example of one of those functions now. The <code>loadTexture()</code> function loads an image into an OpenGL texture:</p>
<div class="codeline">
<p class="clf">def loadTexture(filename):</p>
<p class="cl">    """load OpenGL 2D texture from given image file"""</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ img = <span class="idx" data-level1="Image" data-term="Python Imaging Library"/>Image.<span class="idx" data-level1="Image" data-term="Python Imaging Library"/>open(filename)</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ imgData = numpy.array(list(img.getdata()), np.int8)</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ texture = <span class="idx" data-level1="glGenTextures" data-term="OpenGL"/>glGenTextures(1)</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ <span class="idx" data-level1="glBindTexture" data-term="OpenGL"/>glBindTexture(GL_TEXTURE_2D, texture)</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ <span class="idx" data-level1="glPixelStorei" data-term="OpenGL"/>glPixelStorei(GL_UNPACK_ALIGNMENT, 1)</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ <span class="idx" data-level1="glTexParameterf" data-term="OpenGL"/>glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)</p>
<p class="cl">  <!--<ccust1>7</ccust1>-->❼ glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)</p>
<p class="cl">  <!--<ccust1>8</ccust1>-->❽ <span class="idx" data-level1="glTexImage2D" data-term="OpenGL"/>glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img.size[0], img.size[1],</p>
<p class="cl">                 0, GL_RGBA, GL_UNSIGNED_BYTE, imgData)</p>
<p class="cll">    return texture</p>
</div>
<p><span aria-label=" Page 171. " class="page" epub:type="pagebreak" id="p171" role="doc-pagebreak"/>The <code>loadTexture()</code> function uses the Python Imaging Library (PIL) <code>Image</code> module to read the image file <!--<ccust1>1</ccust1>-->❶. Then it gets the data out of the <code>Image</code> object onto an 8-bit <code>numpy</code> array <!--<ccust1>2</ccust1>-->❷ and creates an OpenGL <code>texture</code> object <!--<ccust1>3</ccust1>-->❸, which is a prerequisite to doing anything with textures in OpenGL. You next perform the now familiar binding to the <code>texture</code> object <!--<ccust1>4</ccust1>-->❹ so all further texture-related settings apply to this object. You set the unpacking alignment of data to 1 <!--<ccust1>5</ccust1>-->❺, which means the image data will be considered to be 1-byte or 8-bit data by the hardware. Starting at <!--<ccust1>6</ccust1>-->❻, you tell OpenGL what to do with the texture at the edges. In this case, you direct it to just <span class="idx" data-level1="clamp texture" data-term="OpenGL"/>clamp the texture color to the edge of the geometry. (In specifying texture coordinates, the convention is to use the letters <code>S</code> and <code>T</code> for the axes instead of <code>x</code> and <code>y</code>.) At <!--<ccust1>7</ccust1>-->❼ and the following line, you specify the kind of interpolation to be used when the texture is stretched or compressed to map onto a polygon. In this case, <span class="idx" data-level1="linear filtering" data-term="OpenGL"/><i>linear filtering</i> is specified. Finally, you set the image data in the bound texture <!--<ccust1>8</ccust1>-->❽. At this point, the image data is transferred to graphics memory, and the texture is ready for use.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah1104"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1104">Running the OpenGL Application</a></h2>
<p class="paft">Here is a sample run of the project:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python simpleglfw.py</code></p>
</div>
<p>You saw the output in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#fig9-1">Figure 9-1</a>. Be sure to try some keypresses to toggle the circle on and off.</p>
</section>
<section>
<h2 class="ah" id="ah1105"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1105">Summary</a></h2>
<p class="paft">Congratulations on completing your first program using Python and OpenGL! Through this project, you’ve learned about creating 3D transformations, using the OpenGL 3D graphics pipeline, and using GLSL vertex and fragment shaders to create interesting 3D graphics. You’ve begun your journey into the fascinating world of 3D graphics programming.</p>
</section>
<section>
<h2 class="ah" id="ah1106"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1106">Experiments!</a></h2>
<p class="paft">Here are some ideas for modifying this project:</p>
<ol style="list-style-type:none">
<li class="nlf">1. The vertex shader in this project rotates the square around the x-axis (1, 0, 0). Can you make it rotate around the y-axis (0, 0, 1)? You can do this in one of two ways: first, by modifying the rotation matrix in the shader, or second, by computing this matrix in the Python code and passing it as a <i>uniform</i> into the shader. Try both!</li>
<li class="nl">2. In the project, the texture coordinates are generated inside the vertex shader and passed to the fragment shader. This is a trick, and it works only because of the convenient values chosen for the vertices of the triangle strip. Pass the texture coordinates as a separate attribute <span aria-label=" Page 172. " class="page" epub:type="pagebreak" id="p172" role="doc-pagebreak"/>into the vertex shader, similar to how the vertices are passed in. Now, can you make the star texture <i>tile</i> across the triangle strip? Instead of displaying a single star, you want to produce a 4×4 grid of stars on the square. (Hint: use texture coordinates greater than 1.0 and set <code>GL_TEXTURE_WRAP_S/T</code> parameters in <code>glTexParameterf()</code> to <code>GL_REPEAT</code>.)</li>
<li class="nl">3. By changing just your fragment shader, can you make your square look like <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#fig9-6">Figure 9-6</a>? (Hint: use the GLSL <code>sin()</code> function.)</li>
</ol>
<figure class="figure" id="fig9-6">
<p class="fig"><img alt="" height="388" src="images/nsp-venkitachalam503045-f09006.jpg" width="409"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 9-6:</span> Using the fragment shader to block out concentric circles</p>
</figcaption>
</figure>
</section>
<section>
<h2 class="ah" id="ah1107"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1107">The Complete Code</a></h2>
<p class="paft">Here’s the complete <i>simpleglfw.py</i> code:</p>
<div class="codeline">
<p class="clf">"""</p>
<p class="cl">simpleglfw.py</p>
<p class="clf">A simple Python OpenGL program that uses PyOpenGL + GLFW to get an</p>
<p class="cl">OpenGL 4.1 context.</p>
<p class="clf">Author: Mahesh Venkitachalam</p>
<p class="cl">"""</p>
<p class="clf">import OpenGL</p>
<p class="cl">from OpenGL.GL import *</p>
<p class="clf">import numpy, math, sys, os</p>
<p class="cl">import glutils</p>
<p class="clf">import glfw</p>
<p class="clf">strVS = """</p>
<p class="cl"># version 410 core</p>
<p class="clf">layout(location = 0) in vec3 aVert;</p>
<p class="clf"><span aria-label=" Page 173. " class="page" epub:type="pagebreak" id="p173" role="doc-pagebreak"/>uniform mat4 uMVMatrix;</p>
<p class="cl">uniform mat4 uPMatrix;</p>
<p class="cl">uniform float uTheta;</p>
<p class="clf">out vec2 vTexCoord;</p>
<p class="clf">void main() {</p>
<p class="cl">  // rotational transform</p>
<p class="cl">  mat4 rot =  mat4(</p>
<p class="cl">        vec4(1.0,  0.0,          0.0,         0.0),</p>
<p class="cl">        vec4(0.0,  cos(uTheta),  sin(uTheta), 0.0),</p>
<p class="cl">        vec4(0.0, -sin(uTheta),  cos(uTheta), 0.0),</p>
<p class="cl">        vec4(0.0,  0.0,          0.0,         1.0)</p>
<p class="cl">        );</p>
<p class="cl">  // transform vertex</p>
<p class="cl">  gl_Position = uPMatrix * uMVMatrix * rot * vec4(aVert, 1.0);</p>
<p class="cl">  // set texture coord</p>
<p class="cl">  vTexCoord = aVert.xy + vec2(0.5, 0.5);</p>
<p class="cl">}</p>
<p class="cl">"""</p>
<p class="clf">strFS = """</p>
<p class="cl"># version 410 core</p>
<p class="clf">in vec2 vTexCoord;</p>
<p class="clf">uniform sampler2D tex2D;</p>
<p class="cl">uniform bool showCircle;</p>
<p class="clf">out vec4 fragColor;</p>
<p class="clf">void main() {</p>
<p class="cl">  if (showCircle) {</p>
<p class="cl">    // discard fragment outside circle</p>
<p class="cl">    if (distance(vTexCoord, vec2(0.5, 0.5)) &gt; 0.5) {</p>
<p class="cl">      discard;</p>
<p class="cl">    }</p>
<p class="cl">    else {</p>
<p class="cl">      fragColor = texture(tex2D, vTexCoord);</p>
<p class="cl">    }</p>
<p class="clf">  }</p>
<p class="cl">  else {</p>
<p class="cl">    fragColor = texture(tex2D, vTexCoord);</p>
<p class="cl">  }</p>
<p class="cl">}</p>
<p class="cl">"""</p>
<p class="clf">class Scene:</p>
<p class="cl">    """ OpenGL 3D scene class"""</p>
<p class="cl">    # initialization</p>
<p class="cl">    def __init__(self):</p>
<p class="cl">        # create shader</p>
<p class="cl">        self.program = glutils.loadShaders(strVS, strFS)</p>
<p class="clf"><span aria-label=" Page 174. " class="page" epub:type="pagebreak" id="p174" role="doc-pagebreak"/>        glUseProgram(self.program)</p>
<p class="clf">        self.pMatrixUniform = glGetUniformLocation(self.program,</p>
<p class="cl">                                                  b'uPMatrix')</p>
<p class="cl">        self.mvMatrixUniform = glGetUniformLocation(self.program,</p>
<p class="cl">                                                  b'uMVMatrix')</p>
<p class="cl">        # texture</p>
<p class="cl">        self.tex2D = glGetUniformLocation(self.program, b'tex2D')</p>
<p class="clf">        # define triangle strip vertices</p>
<p class="cl">        vertexData = numpy.array(</p>
<p class="cl">            [-0.5, -0.5, 0.0,</p>
<p class="cl">              0.5, -0.5, 0.0,</p>
<p class="cl">              -0.5, 0.5, 0.0,</p>
<p class="cl">              0.5, 0.5, 0.0], numpy.float32)</p>
<p class="clf">        # set up vertex array object (VAO)</p>
<p class="cl">        self.vao = glGenVertexArrays(1)</p>
<p class="cl">        glBindVertexArray(self.vao)</p>
<p class="cl">        # vertices</p>
<p class="cl">        self.vertexBuffer = glGenBuffers(1)</p>
<p class="cl">        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)</p>
<p class="cl">        # set buffer data</p>
<p class="cl">        glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,</p>
<p class="cl">                     GL_STATIC_DRAW)</p>
<p class="cl">        # enable vertex array</p>
<p class="cl">        glEnableVertexAttribArray(0)</p>
<p class="cl">        # set buffer data pointer</p>
<p class="cl">        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)</p>
<p class="cl">        # unbind VAO</p>
<p class="cl">        glBindVertexArray(0)</p>
<p class="clf">        # time</p>
<p class="cl">        self.t = 0</p>
<p class="clf">        # texture</p>
<p class="cl">        self.texId = glutils.loadTexture('star.png')</p>
<p class="clf">        # show circle?</p>
<p class="cl">        self.showCircle = False</p>
<p class="clf">    # step</p>
<p class="cl">    def step(self):</p>
<p class="cl">        # increment angle</p>
<p class="cl">        self.t = (self.t + 1) % 360</p>
<p class="clf">    # render</p>
<p class="cl">    def render(self, pMatrix, mvMatrix):</p>
<p class="cl">        # use shader</p>
<p class="cl">        glUseProgram(self.program)</p>
<p class="clf">        # set proj matrix</p>
<p class="cl">        glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)</p>
<p class="clf">        # set modelview matrix</p>
<p class="cl">        glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)</p>
<p class="clf"><span aria-label=" Page 175. " class="page" epub:type="pagebreak" id="p175" role="doc-pagebreak"/>        # set shader angle in radians</p>
<p class="cl">        glUniform1f(glGetUniformLocation(self.program, 'uTheta'),</p>
<p class="cl">                    math.radians(self.t))</p>
<p class="clf">        # show circle?</p>
<p class="cl">        glUniform1i(glGetUniformLocation(self.program, b'showCircle'),</p>
<p class="cl">                    self.showCircle)</p>
<p class="clf">        # enable texture</p>
<p class="cl">        glActiveTexture(GL_TEXTURE0)</p>
<p class="cl">        glBindTexture(GL_TEXTURE_2D, self.texId)</p>
<p class="cl">        glUniform1i(self.tex2D, 0)</p>
<p class="clf">        # bind VAO</p>
<p class="cl">        glBindVertexArray(self.vao)</p>
<p class="cl">        # draw</p>
<p class="cl">        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)</p>
<p class="cl">        # unbind VAO</p>
<p class="cl">        glBindVertexArray(0)</p>
<p class="clf">class RenderWindow:</p>
<p class="cl">    """GLFW rendering window class"""</p>
<p class="cl">    def __init__(self):</p>
<p class="clf">        # save current working directory</p>
<p class="cl">        cwd = os.getcwd()</p>
<p class="clf">        # initialize glfw - this changes cwd</p>
<p class="cl">        glfw.glfwInit()</p>
<p class="clf">        # restore cwd</p>
<p class="cl">        os.chdir(cwd)</p>
<p class="clf">        # version hints</p>
<p class="cl">        glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 4)</p>
<p class="cl">        glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 1)</p>
<p class="cl">        glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)</p>
<p class="cl">        glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,</p>
<p class="cl">                            glfw.GLFW_OPENGL_CORE_PROFILE)</p>
<p class="clf">        # make a window</p>
<p class="cl">        self.width, self.height = 800, 600</p>
<p class="cl">        self.aspect = self.width/float(self.height)</p>
<p class="cl">        self.win = glfw.glfwCreateWindow(self.width, self.height,</p>
<p class="cl">                                         b'simpleglfw')</p>
<p class="cl">        # make context current</p>
<p class="cl">        glfw.glfwMakeContextCurrent(self.win)</p>
<p class="clf">        # initialize GL</p>
<p class="cl">        glViewport(0, 0, self.width, self.height)</p>
<p class="cl">        glEnable(GL_DEPTH_TEST)</p>
<p class="cl">        glClearColor(0.5, 0.5, 0.5, 1.0)</p>
<p class="clf">        # set window callbacks</p>
<p class="cl">        glfw.glfwSetKeyCallback(self.win, self.onKeyboard)</p>
<p class="clf"><span aria-label=" Page 176. " class="page" epub:type="pagebreak" id="p176" role="doc-pagebreak"/>        # create 3D</p>
<p class="cl">        self.scene = Scene()</p>
<p class="clf">        # exit flag</p>
<p class="cl">        self.exitNow = False</p>
<p class="clf">    def onKeyboard(self, win, key, scancode, action, mods):</p>
<p class="cl">        # print 'keyboard: ', win, key, scancode, action, mods</p>
<p class="cl">        if action == glfw.GLFW_PRESS:</p>
<p class="cl">            # ESC to quit</p>
<p class="cl">            if key == glfw.GLFW_KEY_ESCAPE:</p>
<p class="cl">                self.exitNow = True</p>
<p class="cl">            else:</p>
<p class="cl">                # toggle cut</p>
<p class="cl">                self.scene.showCircle = not self.scene.showCircle</p>
<p class="clf">    def run(self):</p>
<p class="cl">        # initializer timer</p>
<p class="cl">        glfw.glfwSetTime(0)</p>
<p class="cl">        t = 0.0</p>
<p class="cl">        while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:</p>
<p class="cl">            # update every x seconds</p>
<p class="cl">            currT = glfw.glfwGetTime()</p>
<p class="cl">            if currT - t &gt; 0.1:</p>
<p class="cl">                # update time</p>
<p class="cl">                t = currT</p>
<p class="cl">                # clear</p>
<p class="cl">                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</p>
<p class="clf">                # set viewport</p>
<p class="cl">                self.width, self.height =</p>
<p class="cl">                                    glfw.glfwGetFramebufferSize(self.win)</p>
<p class="cl">                self.aspect = self.width/float(self.height)</p>
<p class="cl">                glViewport(0, 0, self.width, self.height)</p>
<p class="clf">                # build projection matrix</p>
<p class="cl">                pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)</p>
<p class="clf">                mvMatrix = glutils.lookAt([0.0, 0.0, -2.0], [0.0, 0.0, 0.0],</p>
<p class="cl">                                          [0.0, 1.0, 0.0])</p>
<p class="cl">                # render</p>
<p class="cl">                self.scene.render(pMatrix, mvMatrix)</p>
<p class="clf">                # step</p>
<p class="cl">                self.scene.step()</p>
<p class="clf">                glfw.glfwSwapBuffers(self.win)</p>
<p class="cl">                # poll for and process events</p>
<p class="cl">                glfw.glfwPollEvents()</p>
<p class="cl">        # end</p>
<p class="cl">        glfw.glfwTerminate()</p>
<p class="clf">    def step(self):</p>
<p class="cl">        # step</p>
<p class="cl">        self.scene.step()</p>
<p class="clf"><span aria-label=" Page 177. " class="page" epub:type="pagebreak" id="p177" role="doc-pagebreak"/># main() function</p>
<p class="cl">def main():</p>
<p class="cl">    print("Starting simpleglfw. "</p>
<p class="cl">          "Press any key to toggle cut. Press ESC to quit.")</p>
<p class="cl">    rw = RenderWindow()</p>
<p class="cl">    rw.run()</p>
<p class="clf"># call main</p>
<p class="cl">if __name__ == '__main__':</p>
<p class="cl">    main()</p>
</div>
</section>
</section>
</div></body></html>