<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_175"/><span class="big">9</span><br/>BUILDING OBJECTS WITH CLASSES</h2>&#13;
<p class="epigraph"><em>Old teachers never die, they just lose their class.<br/>—Anonymous</em></p>&#13;
<div class="image"><img alt="image" src="../images/fintro-01.jpg"/></div>&#13;
<p class="intro">Now that you’ve created cool graphics using functions and other code in Processing, you can supercharge your creativity using classes. A <em>class</em> is a structure that lets you create new types of objects. The object types (usually just called <em>objects</em>) can have <em>properties</em>, which are variables, and <em>methods</em>, which are functions. There are times you want to draw multiple objects using Python, but drawing lots of them would be way too much work. Classes make drawing several objects with the same properties easy, but they require a specific syntax you’ll need to learn.</p>&#13;
<p class="indent">The following example from the official Python website shows how to create a “Dog” object using a class. To code along, open a new file in IDLE, name it <em>dog.py</em> and enter the following code.</p>&#13;
<p class="programs"><span class="pd_g1"><em>dog.py</em></span><br/><span class="pd_orange">class</span> <span class="pd_blue">Dog</span>:<br/>    <span class="pd_orange">def</span> <span class="pd_blue">__init__</span>(self,name):<br/>        self.name = name</p>&#13;
<span epub:type="pagebreak" id="page_176"/>&#13;
<p class="indent">This creates a new object called <span class="literal">Dog</span> using <span class="literal">class Dog</span>. It’s customary in Python and many other languages to capitalize the name of a class, but it’ll still work if you don’t. To instantiate, or create, the class, we have to use Python’s <span class="literal">__init__</span> method, which has two underscores before and two after <span class="literal">init</span>, meaning it’s a special method to create (or <em>construct</em>) an object. The <span class="literal">__init__</span> line makes it possible to create instances of the class (in this case, dogs). In the <span class="literal">__init__</span> method, we can create any properties of the class we want. Since it’s a dog, it can have a name, and because every dog has its own name, we use the <span class="literal">self</span> syntax. We don’t need to use it when we call the objects, only when we’re defining them.</p>&#13;
<p class="indent">We can then create a dog with a name using the following line of code:</p>&#13;
<p class="programs">d = Dog(<span class="pd_green">'Fido'</span>)</p>&#13;
<p class="indent">Now <span class="literal">d</span> is a <span class="literal">Dog</span> and its name is Fido. You can confirm this by running the file and entering the following in the shell:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">d.name</span><br/><span class="pd_blue">'Fido'</span></p>&#13;
<p class="indent">Now when we call <span class="literal">d.name</span>, we get Fido because that is the <span class="literal">name</span> property we just gave to it. We can create another <span class="literal">Dog</span> and give it the name Bettisa, like so:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">b = Dog(</span><span class="pd_green">'Bettisa'</span><span class="codestrong1">)</span><br/>&gt;&gt;&gt; <span class="codestrong1">b.name</span><br/><span class="pd_blue">'Bettisa'</span></p>&#13;
<p class="indent">You can see one dog’s name can be different from another’s, but the program remembers them perfectly! This will be crucial when we give locations and other properties to the objects we create.</p>&#13;
<p class="indent">Finally, we can give the dog something to do by putting a function in the class. But don’t call it a function! A function inside a class is called a <em>method</em>. Dogs bark, so we’ll add that method to the code in <a href="ch09.xhtml#ch09list1">Listing 9-1</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>dog.py</em></span><br/><span class="pd_gray">class Dog:</span><br/>    <span class="pd_gray">def __init__(self,name):</span><br/>        <span class="pd_gray">self.name = name</span><br/><br/>    <span class="pd_orange">def</span> <span class="pd_blue">bark</span>(self):<br/>        <span class="pd_purple">print</span>(<span class="pd_green">"Woof!"</span>)<br/><br/>d = Dog(<span class="pd_green">'Fido'</span>)</p>&#13;
<p class="listing" id="ch09list1"><em>Listing 9-1: Creating a dog that barks!</em></p>&#13;
<p class="indent">When we call the <span class="literal">bark()</span> method of the <span class="literal">d</span> dog, it barks:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">d.bark()</span><br/><span class="pd_blue">Woof!</span></p>&#13;
<span epub:type="pagebreak" id="page_177"/>&#13;
<p class="indent">It might not be clear why you’d need a <span class="literal">Dog</span> class from this simple example, but it’s good to know you can do literally anything you want with classes and be as creative as you want. In this chapter, we use classes to make lots of useful objects like bouncing balls and grazing sheep. Let’s start with the Bouncing Ball example to see how using classes lets us do something really cool while saving us a lot of work.</p>&#13;
<h3 class="h3" id="ch09_1">BOUNCING BALL PROGRAM</h3>&#13;
<p class="noindent">Start a Processing sketch and save it as <em>BouncingBall.pyde</em>. We’ll draw a single circle on the screen, which we’ll make into a bouncing ball. <a href="ch09.xhtml#ch09list2">Listing 9-2</a> shows the code for drawing one circle.</p>&#13;
<p class="programs"><span class="pd_g1"><em>BouncingBall.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(0) <span class="pd_gray">#black</span><br/>    <span class="pd_blue1">ellipse</span>(300,300,20,20)</p>&#13;
<p class="listing" id="ch09list2"><em>Listing 9-2: Drawing a circle</em></p>&#13;
<p class="indent">First, we set the size of the window to be 600 pixels wide and 600 pixels tall. Then we set the background to black and drew a circle using the <span class="literal">ellipse()</span> function. The first two numbers in the function describe how far the center of the circle is from the top-left corner of the window, and the last two numbers describe the width and height of the ellipse. In this case, <span class="literal">ellipse(300,300, 20,20)</span> creates a circle that is 20 pixels wide and 20 pixels high, located in the center of the display window, as shown in <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>.</p>&#13;
<div class="image"><a id="ch09fig1"/><img alt="image" src="../images/f177-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-1: Drawing one circle for the Bouncing Ball sketch</em></p>&#13;
<p class="indent">Now that we have successfully created a circle located in the center of the display window, let’s try to make it move.</p>&#13;
<span epub:type="pagebreak" id="page_178"/>&#13;
<h4 class="h4" id="ch09_1_1">MAKING THE BALL MOVE</h4>&#13;
<p class="noindent">We’ll make the ball move by changing its position. To do this, let’s first create a variable for the x-value and a variable for the y-value and set them to 300, which is the middle of the screen. Go back to <a href="ch09.xhtml#ch09list2">Listing 9-2</a> and insert the following two lines at the beginning of the code, like in <a href="ch09.xhtml#ch09list3">Listing 9-3</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>BouncingBall.pyde</em></span><br/>xcor = 300<br/>ycor = 300<br/><br/><span class="pd_gray">def setup():</span><br/>    <span class="pd_gray">size(600,600)</span></p>&#13;
<p class="listing" id="ch09list3"><em>Listing 9-3: Setting variables for the x- and y-values</em></p>&#13;
<p class="indent">Here, we use the <span class="literal">xcor</span> variable to represent the x-value and the <span class="literal">ycor</span> variable to represent the y-value. Then we set both variables to 300.</p>&#13;
<p class="indent">Now let’s change the x-value and y-value by a certain number in order to change the location of the ellipse. Make sure to use the variables to draw the ellipse, as shown in <a href="ch09.xhtml#ch09list4">Listing 9-4</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>BouncingBall.pyde</em></span><br/><span class="pd_gray">xcor = 300</span><br/><span class="pd_gray">ycor = 300</span><br/><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/> <span class="ent">➊</span> <span class="pd_green1">global</span> xcor, ycor<br/>    <span class="pd_blue1">background</span>(0) <span class="pd_gray">#black</span><br/>    xcor += 1<br/>    ycor += 1<br/>    <span class="pd_blue1">ellipse</span>(xcor,ycor,20,20)</p>&#13;
<p class="listing" id="ch09list4"><em>Listing 9-4: Incrementing <span class="literal">xcor</span> and <span class="literal">ycor</span> to change the location of the ellipse</em></p>&#13;
<p class="indent">The important thing to notice in this example is <span class="literal">global xcor, ycor</span> <span class="ent">➊</span>, which tells Python to use the variables we’ve already created and not to create new ones just for the <span class="literal">draw()</span> function. If you don’t include this line, you’ll get an error message, something like “local variable ‘xcor’ referenced before assignment.” Once Processing knows what value to assign to <span class="literal">xcor</span> and <span class="literal">ycor</span>, we increment them both by 1 and draw the ellipse with its center at the location specified using the global variables: <span class="literal">(xcor, ycor)</span>.</p>&#13;
<p class="indent">When you save and run <a href="ch09.xhtml#ch09list4">Listing 9-4</a>, you should see the ball move, like in <a href="ch09.xhtml#ch09fig2">Figure 9-2</a>.</p>&#13;
<p class="indent">Now the ball moves down and to the right, because its x- and y-values are both increasing, but then it moves off the screen and we never see it again! The program keeps incrementing our variables obediently. It doesn’t know it’s drawing a ball or that we want the ball to bounce off the walls. Let’s explore how to keep the ball from disappearing.</p>&#13;
<span epub:type="pagebreak" id="page_179"/>&#13;
<div class="image"><a id="ch09fig2"/><img alt="image" src="../images/f179-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-2: The ball moves!</em></p>&#13;
<h4 class="h4" id="ch09_1_2">MAKING THE BALL BOUNCE OFF THE WALL</h4>&#13;
<p class="noindent">When we change the x-value and the y-value by adding 1, we’re changing the position of an object. In math, this change in position over time is called <em>velocity</em>. A positive change in x over time (positive x-velocity) will look like movement to the right (since x is getting bigger), whereas negative x-velocity will look like movement to the left. We can use this “positive-right, negative-left” concept to make the ball bounce off the wall. First, let’s create the x-velocity and y-velocity variables by adding the following lines to our existing code, as shown in <a href="ch09.xhtml#ch09list5">Listing 9-5</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>BouncingBall.pyde</em></span><br/><span class="pd_gray">xcor = 300</span><br/><span class="pd_gray">ycor = 300</span><br/>xvel = 1<br/>yvel = 2<br/><br/><span class="pd_gray">def setup():</span><br/>    <span class="pd_gray">size(600,600)</span><br/><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    </span><span class="pd_green1">global</span> xcor,ycor,xvel,yvel<br/>    <span class="pd_gray">background(0) #black</span><br/>    xcor += xvel<br/>    ycor += yvel<br/>    <span class="pd_gray">#if the ball reaches a wall, switch direction.</span><br/>    <span class="pd_lime">if</span> xcor &gt; <span class="pd_raspberry">width</span> <span class="pd_green1">or</span> xcor &lt; 0:<br/>        xvel = -xvel<br/>    <span class="pd_lime">if</span> ycor &gt; <span class="pd_raspberry">height</span> <span class="pd_green1">or</span> ycor &lt; 0:<br/>        yvel = -yvel<br/>    <span class="pd_gray">ellipse(xcor,ycor,20,20)</span></p>&#13;
<p class="listing" id="ch09list5"><em>Listing 9-5: Adding code to make the ball bounce off the wall</em></p>&#13;
<span epub:type="pagebreak" id="page_180"/>&#13;
<p class="indent">First, we set <span class="literal">xvel = 1</span> and <span class="literal">yvel = 2</span> to specify how the ball will move. You can use other values and see how they change the movement. Then in the <span class="literal">draw()</span> function, we tell Python that <span class="literal">xvel</span> and <span class="literal">yvel</span> are global variables, and we change the x- and y-coordinates by incrementing using these variables. For example, when we set <span class="literal">xcor += xvel</span>, we’re updating the position by the velocity (the <em>change</em> in position).</p>&#13;
<p class="indent">The two <span class="literal">if</span> statements tell the program that if the ball’s position goes outside the boundaries of the screen, it should change the ball’s velocity to its negative value. When we change the ball’s velocity to its negative value, we tell the program to move the ball in the opposite direction it was moving in, making it seem like the ball is bouncing off the wall.</p>&#13;
<p class="indent">We need to be precise in telling at what point the ball should move in the opposite direction in terms of its coordinates. For example, <span class="literal">xcor &gt; width</span> represents cases where <span class="literal">xcor</span> is larger than the width of the display window, which is when the ball touches the right edge of the screen. And <span class="literal">xcor &lt; 0</span> represents instances where the <span class="literal">xcor</span> is less than 0 or when the ball touches the left edge of the screen. Similarly, <span class="literal">ycor &gt; height</span> checks for instances where <span class="literal">ycor</span> is larger than the height of the window or when the ball reaches the bottom of the screen. Finally, <span class="literal">ycor &lt; 0</span> checks for instances where the ball reaches the upper edge of the screen. Since moving to the right is positive x-velocity (positive change in x), the opposite direction is negative x-velocity. If the velocity is already negative (it’s moving to the left), then the negative of a negative is a positive, which means the ball will move to the right, just like we want it to.</p>&#13;
<p class="indent">When you run <a href="ch09.xhtml#ch09list5">Listing 9-5</a>, you should see something like what’s shown in <a href="ch09.xhtml#ch09fig3">Figure 9-3</a>.</p>&#13;
<div class="image"><a id="ch09fig3"/><img alt="image" src="../images/f180-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-3: One bouncing ball!</em></p>&#13;
<p class="indent">The ball looks like it’s bouncing off the walls and therefore stays in view.</p>&#13;
<span epub:type="pagebreak" id="page_181"/>&#13;
<h4 class="h4" id="ch09_1_3">MAKING MULTIPLE BALLS WITHOUT CLASSES</h4>&#13;
<p class="noindent">Now suppose we want to make another bouncing ball, or many other bouncing balls. How would we do that? We could make a new variable for the second ball’s x-value, another variable for the second ball’s y-value, a third variable for its x-velocity, and a fourth for its y-velocity. Then we’d have to increment its position by its velocity, check if it needs to bounce off a wall, and finally draw it. However, we’d end up with double the amount of code! Adding a third ball would triple our code! Twenty balls would simply be out of the question. You <em>don’t</em> want to have to keep track of all these variables for position and velocity. <a href="ch09.xhtml#ch09list6">Listing 9-6</a> show what this would look like.</p>&#13;
<p class="programs"><span class="pd_gray">#ball1:</span><br/>ball1x = random(width)<br/>ball1y = random(height)<br/>ball1xvel = random(-2,2)<br/>ball1tvel = random(-2,2)<br/><br/><span class="pd_gray">#ball2:</span><br/>ball2x = random(width)<br/>ball2y = random(height)<br/>ball2xvel = random(-2,2)<br/>ball2tvel = random(-2,2)<br/><br/><span class="pd_gray">#ball3:</span><br/>ball3x = random(width)<br/>ball3y = random(height)<br/>ball3xvel = random(-2,2)<br/>ball3tvel = random(-2,2)<br/><br/><span class="pd_gray">#update ball1:</span><br/>ball1x += ball1xvel<br/>ball1y += ball1yvel<br/><span class="pd_blue1">ellipse</span>(ball1x,ball1y,20,20)<br/><br/><span class="pd_gray">#update ball2:</span><br/>ball2x += ball2xvel<br/>ball2y += ball2yvel<br/><span class="pd_blue1">ellipse</span>(ball2x,ball2y,20,20)<br/><br/><span class="pd_gray">#update ball3:</span><br/>ball3x += ball3xvel<br/>ball3y += ball3yvel<br/><span class="pd_blue1">ellipse</span>(ball3x,ball3y,20,20)</p>&#13;
<p class="listing" id="ch09list6"><em>Listing 9-6: Creating multiple balls without classes. Way too much code!</em></p>&#13;
<p class="indent">This is the code for creating only three balls. As you can see, it’s very long, and this doesn’t even include the bouncing part! Let’s see how we can use classes to make this task easier.</p>&#13;
<span epub:type="pagebreak" id="page_182"/>&#13;
<h4 class="h4" id="ch09_1_4">CREATING OBJECTS USING CLASSES</h4>&#13;
<p class="noindent">In programming, a class works like a recipe that details a way to create an object with its own specific properties. Using classes, we tell Python how to make a ball once. Then all we have to do is create a bunch of balls using a <span class="literal">for</span> loop and put them in a list. Lists are great for saving numerous things—strings, numbers, and objects!</p>&#13;
<p class="indent">Follow these three steps when using classes to create objects:</p>&#13;
<ol>&#13;
<li class="noindent"><em>Write the class</em>. This is like a recipe for how to make balls, planets, rockets, and so on.</li>&#13;
<li class="noindent"><em>Instantiate the object or objects</em>. You do this by calling the objects in the <span class="literal">setup()</span> function.</li>&#13;
<li class="noindent"><em>Update the object or objects</em>. Do this in the <span class="literal">draw()</span> function (the display loop).</li>&#13;
</ol>&#13;
<p class="indent">Let’s use these steps to put the code we’ve already written into a class.</p>&#13;
<h5 class="h5">Writing the Class</h5>&#13;
<p class="noindent">The first step in creating objects using classes is to write a class that tells the program how to make a ball. Let’s add the code in <a href="ch09.xhtml#ch09list7">Listing 9-7</a> at the very beginning of our existing program.</p>&#13;
<p class="programs"><span class="pd_g1"><em>BouncingBall.pyde</em></span><br/>ballList=[] <span class="pd_gray">#empty list to put the balls in</span><br/><br/><span class="pd_green1">class</span> Ball:<br/><span class="pd_green1">    def</span> <span class="pd_blue">__</span><span class="pd_blue1">init</span><span class="pd_blue">__</span>(<span class="pd_green1">self</span>,x,y):<br/>        <span class="pd_purple">'''How to initialize a Ball'''</span><br/>        <span class="pd_green1">self</span>.xcor = x<br/>        <span class="pd_green1">self</span>.ycor = y<br/><span class="pd_green1">        self</span>.xvel = <span class="pd_blue1">random</span>(-2,2)<br/><span class="pd_green1">        self</span>.yvel = <span class="pd_blue1">random</span>(-2,2)</p>&#13;
<p class="listing" id="ch09list7"><em>Listing 9-7: Defining a class called <span class="literal">Ball</span></em></p>&#13;
<p class="indent">Note that because we’re putting the position and velocity variables into the <span class="literal">Ball</span> class as properties, you can delete the following lines from your existing code:</p>&#13;
<p class="programs">xcor = 300<br/>ycor = 300<br/>xvel = 1<br/>yvel = 2</p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch09list7">Listing 9-7</a>, we create an empty list we’ll use to save the balls in; then we start defining the recipe. The name of a class object, which is <span class="literal">Ball</span> in this case, is always capitalized. The <span class="literal">__init__</span> method is a requirement to create a class in Python that contains all the properties the object gets when it’s initialized. Otherwise, the class won’t work.</p>&#13;
<p class="indent">The <span class="literal">self</span> syntax simply means every object has its own methods and properties, which are functions and variables that can’t be used except by a <span class="literal">Ball</span> <span epub:type="pagebreak" id="page_183"/>object. This means that each <span class="literal">Ball</span> has its own <span class="literal">xcor</span>, its own <span class="literal">ycor</span>, and so on. Because we might have to create a <span class="literal">Ball</span> at a specific location at some point, we made <span class="literal">x</span> and <span class="literal">y</span> parameters of the <span class="literal">__init__</span> method. Adding these parameters allows us to tell Python the location of a <span class="literal">Ball</span> when we create it, like this:</p>&#13;
<p class="programs">Ball(100,200)</p>&#13;
<p class="indent">In this case, the ball will be located at the coordinate (100,200).</p>&#13;
<p class="indent">The last lines in <a href="ch09.xhtml#ch09list7">Listing 9-7</a> tell Processing to assign a random number between –2 and 2 to be the x- and y-velocity of the new ball.</p>&#13;
<h5 class="h5">Instantiating the Object</h5>&#13;
<p class="noindent">Now that we’ve created a class called <span class="literal">Ball</span>, we need to tell Processing how to update the ball every time the <span class="literal">draw()</span> function loops. We’ll call that the <span class="literal">update</span> method and nest it inside the <span class="literal">Ball</span> class, just like we did with <span class="literal">__init__</span>. You can simply cut and paste all the ball code into the <span class="literal">update()</span> method and then add <span class="literal">self.</span> to each of the object’s properties, as shown in <a href="ch09.xhtml#ch09list8">Listing 9-8</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>BouncingBall.pyde</em></span><br/>ballList=[] <span class="pd_gray">#empty list to put the balls in</span><br/><br/><span class="pd_green1">class</span> Ball:<br/>    <span class="pd_green1">def</span> <span class="pd_blue1">__init__</span>(<span class="pd_green1">self</span>,x,y):<br/>        <span class="pd_purple">'''How to initialize a Ball'''</span><br/>        <span class="pd_green1">self</span>.xcor = x<br/>        <span class="pd_green1">self</span>.ycor = y<br/>        <span class="pd_green1">self</span>.xvel = <span class="pd_blue1">random</span>(-2,2)<br/>        <span class="pd_green1">self</span>.yvel = <span class="pd_blue1">random</span>(-2,2)<br/><br/>    <span class="pd_green1">def</span> update(<span class="pd_green1">self</span>):<br/>        <span class="pd_green1">self</span>.xcor += <span class="pd_green1">self</span>.xvel<br/>        <span class="pd_green1">self</span>.ycor += <span class="pd_green1">self</span>.yvel<br/>        <span class="pd_gray">#if the ball reaches a wall, switch direction</span><br/>        <span class="pd_lime">if</span> <span class="pd_green1">self</span>.xcor &gt; <span class="pd_raspberry">width</span> <span class="pd_green1">or</span> <span class="pd_green1">self</span>.xcor &lt; 0:<br/>            <span class="pd_green1">self</span>.xvel = -<span class="pd_green1">self</span>.xvel<br/>        <span class="pd_lime">if</span> <span class="pd_green1">self</span>.ycor &gt; <span class="pd_raspberry">height</span> <span class="pd_green1">or</span> <span class="pd_green1">self</span>.ycor &lt; 0:<br/>            <span class="pd_green1">self</span>.yvel = -<span class="pd_green1">self</span>.yvel<br/>        <span class="pd_blue1">ellipse</span>(<span class="pd_green1">self</span>.xcor,<span class="pd_green1">self</span>.ycor,20,20)</p>&#13;
<p class="listing" id="ch09list8"><em>Listing 9-8: Creating the <span class="literal">update()</span> method</em></p>&#13;
<p class="indent">Here, we placed all the code for moving and bouncing a ball into the <span class="literal">update()</span> method of the <span class="literal">Ball</span> class. The only new code is <span class="literal">self</span> in the velocity variables, making them velocity properties of the <span class="literal">Ball</span> object. Although it might seem like there are many instances of <span class="literal">self</span>, that’s how we tell Python that the x-coordinate, for example, belongs to that specific ball and not another. Very soon, Python is going to be updating a hundred balls, so we need <span class="literal">self</span> to keep track of each one’s location and velocity.</p>&#13;
<p class="indent">Now that the program knows how to create and update a ball, let’s update the <span class="literal">setup()</span> function to create three balls and put them into the ball list (<span class="literal">ballList</span>), as shown in <a href="ch09.xhtml#ch09list9">Listing 9-9</a>.</p>&#13;
<span epub:type="pagebreak" id="page_184"/>&#13;
<p class="programs"><span class="pd_gray">def setup():</span><br/>    <span class="pd_gray">size(600,600)</span><br/><span class="pd_gray">    </span><span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(3):<br/>        ballList.<span class="pd_blue1">append</span>(Ball(<span class="pd_blue1">random</span>(<span class="pd_raspberry">width</span>),<br/>                             <span class="pd_blue1">random</span>(<span class="pd_raspberry">height</span>)))</p>&#13;
<p class="listing" id="ch09list9"><em>Listing 9-9: Creating three balls in the <span class="literal">setup()</span> function</em></p>&#13;
<p class="indent">We created <span class="literal">ballList</span> in <a href="ch09.xhtml#ch09list7">Listing 9-7</a> already, and here we’re appending to the list a <span class="literal">Ball</span> at a random location. When the program creates (instantiates) a new ball, it will now choose a random number between 0 and the width of the screen to be the x-coordinate and another random number between 0 and the height of the screen to be the y-coordinate. Then it’ll put that new ball into the list. Because we used the loop <span class="literal">for i in range(3)</span>, the program will add three balls to the ball list.</p>&#13;
<h5 class="h5">Updating the Object</h5>&#13;
<p class="noindent">Now let’s tell the program to go through <span class="literal">ballList</span> and update all the balls in the list (which means drawing them) every loop using the following <span class="literal">draw()</span> function:</p>&#13;
<p class="programs"><span class="pd_g1"><em>BouncingBall.pyde</em></span><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    background(0) #black</span><br/>    <span class="pd_lime">for</span> ball <span class="pd_lime">in</span> ballList:<br/>        ball.update()</p>&#13;
<p class="indent">Note that we still want the background to be black, and then we loop over the ball list and for every ball in the list we run its <span class="literal">update()</span> method. All the previous code in <span class="literal">draw()</span> went into the <span class="literal">Ball</span> class!</p>&#13;
<div class="image"><a id="ch09fig4"/><img alt="image" src="../images/f184-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-4: Creating as many bouncing balls as you want!</em></p>&#13;
<p class="indent">When you run this sketch, you should see three balls moving around the screen and bouncing off the walls! The great thing about using classes is that it’s super easy to change the number of balls. All you have to do is change the <em><span class="literal">number</span></em> in <span class="literal">for i in range(<em>number</em>)</span>: in the <span class="literal">setup()</span> function to create even more bouncing balls. When you change this to 20, for example, you’ll see something like <a href="ch09.xhtml#ch09fig4">Figure 9-4</a>.</p>&#13;
<p class="indent">What’s cool about using classes is that you can give an object any properties or methods you want. For example, we don’t have to make our balls all the same color. Add the three lines of code shown in <a href="ch09.xhtml#ch09list10">Listing 9-10</a> to your existing <span class="literal">Ball</span> class.</p>&#13;
<span epub:type="pagebreak" id="page_185"/>&#13;
<p class="programs"><span class="pd_g1"><em>BouncingBall.pyde</em></span><br/><span class="pd_gray">class Ball:</span><br/><span class="pd_gray">    def __init__(self,x,y):</span><br/><span class="pd_gray">        '''How to initialize a Ball'''</span><br/><span class="pd_gray">        self.xcor = x</span><br/><span class="pd_gray">        self.ycor = y</span><br/><span class="pd_gray">        self.xvel = random(-2,2)</span><br/><span class="pd_gray">        self.yvel = random(-2,2)</span><br/><span class="pd_gray">        </span><span class="pd_green1">self</span>.col = <span class="pd_blue1">color</span>(<span class="pd_blue1">random</span>(255),<br/>                         <span class="pd_blue1">random</span>(255),<br/>                         <span class="pd_blue1">random</span>(255))</p>&#13;
<p class="listing" id="ch09list10"><em>Listing 9-10: Updating the <span class="literal">Ball</span> class</em></p>&#13;
<p class="indent">This code gives every ball its own color when it’s created. Processing’s <span class="literal">color()</span> function needs three numbers that represent red, green, and blue, respectively. RGB values go from 0 to 255. Using <span class="literal">random(255)</span> lets the program choose the numbers randomly, resulting in a randomly chosen color. However, because the <span class="literal">__init__</span> method runs only one time, once the ball has a color, it keeps it.</p>&#13;
<p class="indent">Next, in the <span class="literal">update()</span> method, add the following line so the ellipse gets filled with its own randomly chosen color:</p>&#13;
<p class="programs">        <span class="pd_blue1">fill</span>(<span class="pd_green1">self</span>.col)<br/>        <span class="pd_gray">ellipse(self.xcor,self.ycor,20,20)</span></p>&#13;
<p class="indent">Before a shape or line gets drawn, you can declare its color using <span class="literal">fill</span> for shapes or <span class="literal">stroke</span> for lines. Here, we tell Processing to use the ball’s own color (using <span class="literal">self</span>) to fill in the following shape.</p>&#13;
<p class="indent">Now when you run the program, each ball should have a random color, as shown in <a href="ch09.xhtml#ch09fig5">Figure 9-5</a>!</p>&#13;
<div class="image"><a id="ch09fig5"/><img alt="image" src="../images/f185-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-5: Giving balls their own colors</em></p>&#13;
<div class="sidebar">&#13;
<p class="title"><span epub:type="pagebreak" id="page_186"/>EXERCISE 9-1: CREATING BALLS OF DIFFERENT SIZES</p>&#13;
<p class="noindent">Give each ball its own size, between 5 and 50 units.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch09_2">GRAZING SHEEP PROGRAM</h3>&#13;
<p class="noindent">Now that you can create classes, let’s make something useful. We’ll code a Processing sketch of an ecosystem that simulates sheep walking around eating grass. In this sketch, the sheep have a certain level of energy that gets depleted as they walk around, and their energy gets replenished when they eat grass. If they get enough energy, they reproduce. If they don’t get enough energy, they die. We could potentially learn a lot about biology, ecology, and evolution by creating and tweaking this model.</p>&#13;
<p class="indent">In this program, the <span class="literal">Sheep</span> objects are kind of like the <span class="literal">Ball</span> objects you created earlier in this chapter; each has its own x- and y-position and size, and is represented by a circle.</p>&#13;
<h4 class="h4" id="ch09_1_5">WRITING THE CLASS FOR THE SHEEP</h4>&#13;
<p class="noindent">Start a new Processing sketch and save it as <em>SheepAndGrass.pyde</em>. First, let’s create a class that makes a <span class="literal">Sheep</span> object with its own x- and y-position and its own size. Then we’ll create an <span class="literal">update</span> method that draws an ellipse representing the sheep’s size at the sheep’s location.</p>&#13;
<p class="indent">The class code is nearly identical to the <span class="literal">Ball</span> class, as you can see in <a href="ch09.xhtml#ch09list11">Listing 9-11</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>SheepAndGrass.pyde</em></span><br/>class Sheep:<br/>    <span class="pd_green1">def</span> <span class="pd_blue1">__init__</span>(<span class="pd_green1">self</span>,x,y):<br/>        <span class="pd_green1">self</span>.x = x <span class="pd_gray">#x-position</span><br/>        <span class="pd_green1">self</span>.y = y <span class="pd_gray">#y-position</span><br/>        <span class="pd_green1">self</span>.sz = 10 <span class="pd_gray">#size</span><br/><br/>    <span class="pd_green1">def</span> update(<span class="pd_green1">self</span>):<br/>        <span class="pd_blue1">ellipse</span>(<span class="pd_green1">self</span>.x,<span class="pd_green1">self</span>.y,<span class="pd_green">se</span><span class="pd_green1">l</span><span class="pd_green">f</span>.sz,<span class="pd_green1">self</span>.sz)</p>&#13;
<p class="listing" id="ch09list11"><em>Listing 9-11: Creating a class for one sheep</em></p>&#13;
<p class="indent">Because we know we’ll be making a bunch of sheep, we start off creating a <span class="literal">Sheep</span> class. In the required <span class="literal">__init__</span> method, we set the x- and y-coordinates of the sheep to the parameters we’ll declare when creating a sheep instance. I’ve set the size of the sheep (the diameter of the ellipse) to 10 pixels, but you can have bigger or smaller sheep if you like. The <span class="literal">update()</span> method simply draws an ellipse of the sheep’s size at the sheep’s location.</p>&#13;
<span epub:type="pagebreak" id="page_187"/>&#13;
<p class="indent">Here’s the <span class="literal">setup()</span> and <span class="literal">draw()</span> code for a Processing sketch containing one <span class="literal">Sheep</span>, which I’ve named <span class="literal">shawn</span>. Add the code shown in <a href="ch09.xhtml#ch09list12">Listing 9-12</a> right below the <span class="literal">update()</span> method you just wrote in <a href="ch09.xhtml#ch09list11">Listing 9-11</a>.</p>&#13;
<p class="programs"><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_green1">global</span> shawn<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    <span class="pd_gray">#create a Sheep object called shawn at (300,200)</span><br/>    shawn = Sheep(300,200)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(255)<br/>    shawn.update()</p>&#13;
<p class="listing" id="ch09list12"><em>Listing 9-12: Creating a <span class="literal">Sheep</span> object named <span class="literal">shawn</span></em></p>&#13;
<p class="indent">We first create <span class="literal">shawn</span>, an instance of a <span class="literal">Sheep</span> object, in the <span class="literal">setup()</span> function. Then we update it in the <span class="literal">draw()</span> function—but Python doesn’t know we mean the same <span class="literal">shawn</span> unless we tell it that <span class="literal">shawn</span> is a global variable.</p>&#13;
<p class="indent">When you run this code, you should see something like what’s shown in <a href="ch09.xhtml#ch09fig6">Figure 9-6</a>.</p>&#13;
<div class="image"><a id="ch09fig6"/><img alt="image" src="../images/f187-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-6: One sheep</em></p>&#13;
<p class="indent">You get a white screen with a little circular sheep at the coordinate (300,200), which is 300 pixels to the right of the starting point and 200 pixels down.</p>&#13;
<h4 class="h4" id="ch09_1_6">PROGRAMMING SHEEP TO MOVE AROUND</h4>&#13;
<p class="noindent">Now let’s teach a <span class="literal">Sheep</span> how to move around. We’ll start by programming the <span class="literal">Sheep</span> to move around randomly. (You can always program it to move differently in the future if you want to.) <a href="ch09.xhtml#ch09list13">Listing 9-13</a> changes the x- and y-coordinates of a <span class="literal">Sheep</span> by a random number between –10 and 10. Return <span epub:type="pagebreak" id="page_188"/>to your existing code and add the following lines above the <span class="literal">ellipse()</span> function within the <span class="literal">update()</span> method:</p>&#13;
<p class="programs">    <span class="pd_g1"><em>SheepAndGrass.pyde</em></span><br/>    <span class="pd_gray">def update(self):</span><br/>        <span class="pd_gray">#make sheep walk randomly</span><br/>        move = 10 <span class="pd_gray">#the maximum it can move in any direction</span><br/>        <span class="pd_green1">self</span>.x += <span class="pd_blue1">random</span>(-move, move)<br/>        <span class="pd_green1">self</span>.y += <span class="pd_blue1">random</span>(-move, move)<br/>        <span class="pd_blue1">fill</span>(255) <span class="pd_gray">#white</span><br/>        <span class="pd_gray">ellipse(self.x,self.y,self.sz,self.sz)</span></p>&#13;
<p class="listing" id="ch09list13"><em>Listing 9-13: Making the sheep move randomly</em></p>&#13;
<p class="indent">This code creates a variable called <span class="literal">move</span> to specify the maximum value or distance the sheep will be able to move on the screen. Then we set <span class="literal">move</span> to 10 and use it to update the sheep’s x- and y-coordinates by a random number between <span class="literal">-move</span> (–10) and <span class="literal">move</span> (10). Finally, we use <span class="literal">fill(255)</span> to set the sheep’s color to white for now.</p>&#13;
<p class="indent">When you run this code, you should see the sheep wandering around randomly—and it might wander off the screen.</p>&#13;
<p class="indent">Let’s give the sheep some company. If we want to create and update more than one object, it’s a good idea to put them in a list. Then in the <span class="literal">draw()</span> function, we’ll go through the list and update each <span class="literal">Sheep</span>. Update your existing code to look like <a href="ch09.xhtml#ch09list14">Listing 9-14</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>SheepAndGrass.pyde</em></span><br/><span class="pd_gray">class Sheep:</span><br/><span class="pd_gray">    def __init__(self,x,y):</span><br/><span class="pd_gray">        self.x = x #x-position</span><br/><span class="pd_gray">        self.y = y #y-position</span><br/><span class="pd_gray">        self.sz = 10 #size</span><br/><br/><span class="pd_gray">    def update(self):</span><br/><span class="pd_gray">        #make sheep walk randomly</span><br/><span class="pd_gray">        move = 10 #the maximum it can move in any direction</span><br/><span class="pd_gray">        self.x += random(-move, move)</span><br/><span class="pd_gray">        self.y += random(-move, move)</span><br/><span class="pd_gray">        fill(255) #white</span><br/><span class="pd_gray">        ellipse(self.x,self.y,self.sz,self.sz)</span><br/><br/>sheepList = [] <span class="pd_gray">#list to store sheep</span><br/><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(3):<br/>        sheepList.<span class="pd_blue1">append</span>(Sheep(<span class="pd_blue1">random</span>(<span class="pd_raspberry">width</span>),<br/>                               <span class="pd_blue1">random</span>(<span class="pd_raspberry">height</span>)))<br/><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    background(255)</span><br/>    <span class="pd_lime">for</span> sheep <span class="pd_green1">in</span> sheepList:<br/>        sheep.update()</p>&#13;
<p class="listing" id="ch09list14"><em>Listing 9-14: Creating more sheep using a <span class="literal">for</span> loop</em></p>&#13;
<span epub:type="pagebreak" id="page_189"/>&#13;
<p class="indent">This code is similar to the code we wrote to put the bouncing balls in a list. First, we create a list to store the sheep. Then we create a <span class="literal">for</span> loop and put a <span class="literal">Sheep</span> in the sheep list. Then in the <span class="literal">draw()</span> function, we write another <span class="literal">for</span> loop to go through the sheep list and update each one according to the <span class="literal">update()</span> method we already defined. When you run this code, you should get three <span class="literal">Sheep</span> walking around randomly. Change the number <span class="literal">3</span> in <span class="literal">for i in range(3):</span> to a larger number to add even more sheep.</p>&#13;
<h4 class="h4" id="ch09_1_7">CREATING THE ENERGY PROPERTY</h4>&#13;
<p class="noindent">Walking takes up energy! Let’s give the sheep a certain level of energy when they’re created and take away their energy when they walk. Use the code in <a href="ch09.xhtml#ch09list15">Listing 9-15</a> to update your existing <span class="literal">__init__</span> and <span class="literal">update()</span> methods in the <em>SheepAndGrass.pyde</em>.</p>&#13;
<p class="programs"><span class="pd_gray">class Sheep:</span><br/><span class="pd_gray">    def __init__(self,x,y):</span><br/><span class="pd_gray">        self.x = x #x-position</span><br/><span class="pd_gray">        self.y = y #y-position</span><br/><span class="pd_gray">        self.sz = 10 #size</span><br/>        <span class="pd_green1">self</span>.energy = 20 <span class="pd_gray">#energy level</span><br/><br/><span class="pd_gray">    def update(self):</span><br/><span class="pd_gray">        #make sheep walk randomly</span><br/><span class="pd_gray">        move = 1</span><br/>        <span class="pd_green1">self</span>.energy -= 1 <span class="pd_gray">#walking costs energy</span><br/>        <span class="pd_lime">if</span> sheep.energy &lt;= 0:<br/>            sheepList.<span class="pd_blue1">remove</span>(<span class="pd_green1">self</span>)<br/><span class="pd_gray">        self.x += random(-move, move)</span><br/><span class="pd_gray">        self.y += random(-move, move)</span><br/><span class="pd_gray">        fill(255) #white</span><br/>        <span class="pd_gray">ellipse(self.x,self.y,self.sz,self.sz)</span></p>&#13;
<p class="listing" id="ch09list15"><em>Listing 9-15: Updating <span class="literal">__init__</span> and <span class="literal">update()</span> with the <span class="literal">energy</span> property</em></p>&#13;
<p class="indent">We do this by creating an <span class="literal">energy</span> property in the <span class="literal">__init__</span> method and set it to 20, the energy level every sheep starts with. Then <span class="literal">self.energy -= 1</span> in the <span class="literal">update()</span> method lowers the sheep’s energy level by 1 when it walks around.</p>&#13;
<p class="indent">Then we check whether the sheep is out of energy, and if it is, we remove it from the <span class="literal">sheepList</span>. Here, we use a conditional statement to check whether <span class="literal">if sheep.energy &lt;= 0</span> returns <span class="literal">True</span>. If so, we remove that sheep from the <span class="literal">sheepList</span> using the <span class="literal">remove()</span> function. Once that <span class="literal">Sheep</span> instance is gone from the list, it doesn’t exist anymore.</p>&#13;
<h4 class="h4" id="ch09_1_8">CREATING GRASS USING CLASSES</h4>&#13;
<p class="noindent">When you run the program, you should see the <span class="literal">Sheep</span> move around for a second and then disappear—walking around is costing the sheep energy, and once that energy is gone, the sheep dies. What we need to do is to give the sheep grass to eat. We’ll call each patch of grass <span class="literal">Grass</span> and make a new class <span epub:type="pagebreak" id="page_190"/>for it. <span class="literal">Grass</span> will have its own x- and y-value, size, and energy content. We’ll also make it change color when it’s eaten.</p>&#13;
<p class="indent">In fact, we’ll be using a bunch of different colors in this sketch for our sheep and our grass, so let’s add the code in <a href="ch09.xhtml#ch09list16">Listing 9-16</a> to the very beginning of the program so we can just refer to the colors by their names. Feel free to add other colors too.</p>&#13;
<p class="programs">WHITE = <span class="pd_blue1">color</span>(255)<br/>BROWN = <span class="pd_blue1">color</span>(102,51,0)<br/>RED = <span class="pd_blue1">color</span>(255,0,0)<br/>GREEN = <span class="pd_blue1">color</span>(0,102,0)<br/>YELLOW = <span class="pd_blue1">color</span>(255,255,0)<br/>PURPLE = <span class="pd_blue1">color</span>(102,0,204)</p>&#13;
<p class="listing" id="ch09list16"><em>Listing 9-16: Setting colors as constants</em></p>&#13;
<p class="indent">Using all-caps for the color names indicates that they’re constants and won’t change in value, but that’s just for the programmer. There’s nothing inherently magical about the constants, and you can change these values if you want. Setting constants lets you just type the names of the colors instead of having to write the RGB values every time. We’ll do this when we make the grass green. Update your existing code by adding the code in <a href="ch09.xhtml#ch09list17">Listing 9-17</a> right after the <span class="literal">Sheep</span> class in <em>SheepAndGrass.pyde</em>:</p>&#13;
<p class="programs"><span class="pd_green1">class</span> Grass:<br/>    <span class="pd_green1">def</span> <span class="pd_blue1">__init__</span>(<span class="pd_green1">self</span>,x,y,sz):<br/>        <span class="pd_green1">self</span>.x = x<br/>        <span class="pd_green1">self</span>.y = y<br/>        <span class="pd_green1">self</span>.energy = 5 <span class="pd_gray">#energy from eating this patch</span><br/>        <span class="pd_green1">self</span>.eaten = False <span class="pd_gray">#hasn't been eaten yet</span><br/>        <span class="pd_green1">self</span>.sz = sz<br/><br/>    <span class="pd_green1">def</span> update(<span class="pd_green1">self</span>):<br/>        <span class="pd_blue1">fill</span>(GREEN)<br/>        <span class="pd_blue1">rect</span>(<span class="pd_green1">self</span>.x,<span class="pd_green">s</span><span class="pd_green1">e</span><span class="pd_green">lf</span>.y,<span class="pd_green1">self</span>.sz,<span class="pd_green1">self</span>.sz)</p>&#13;
<p class="listing" id="ch09list17"><em>Listing 9-17: Writing the <span class="literal">Grass</span> class</em></p>&#13;
<p class="indent">You’re probably starting to get used to the structure of the class notation. It conventionally starts with the <span class="literal">__init__</span> method, where you create its properties. In this case, you tell the program that <span class="literal">Grass</span> will have an x- and y-location, an energy level, a Boolean (<span class="literal">True</span>/<span class="literal">False</span>) variable that keeps track of whether the grass has been eaten or not, and a size. To update a patch of grass, we just create a green rectangle at the <span class="literal">Grass</span> object’s location.</p>&#13;
<p class="indent">Now we have to initialize and update our grass, the same way we did for our sheep. Because there will be a lot of grass, let’s create a list for it. Before the <span class="literal">setup()</span> function, add the following code.</p>&#13;
<span epub:type="pagebreak" id="page_191"/>&#13;
<p class="programs">sheepList = [] <span class="pd_gray">#list to store sheep</span><br/>grassList = [] <span class="pd_gray">#list to store grass</span><br/>patchSize = 10 <span class="pd_gray">#size of each patch of grass</span></p>&#13;
<p class="indent">We might want to vary the size of the patch of grass in the future, so let’s create a variable called <span class="literal">patchSize</span> so we’ll only have to change it in one place. In the <span class="literal">setup()</span> function, after creating the sheep, create the grass by adding the new code in <a href="ch09.xhtml#ch09list18">Listing 9-18</a>.</p>&#13;
<p class="programs"><span class="pd_green1"/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    </span><span class="pd_green1">global</span> patchSize<br/>    <span class="pd_gray">size(600,600)</span><br/>    <span class="pd_gray">#create the sheep</span><br/>    <span class="pd_gray">for i in range(3):</span><br/>        <span class="pd_gray">sheepList.</span><span class="pd_gray">append(Sheep(random(width),</span><br/>                               <span class="pd_gray">random(height)))</span><br/>    <span class="pd_gray">#create the grass:</span><br/>    <span class="pd_lime">for</span> x <span class="pd_green1">in</span> <span class="pd_lime">range</span>(0,<span class="pd_raspberry">width</span>,patchSize):<br/>        <span class="pd_lime">for</span> y <span class="pd_green1">in</span> <span class="pd_lime">range</span>(0,<span class="pd_raspberry">height</span>,patchSize):<br/>            grassList.<span class="pd_blue1">append</span>(Grass(x,y,patchSize))</p>&#13;
<p class="listing" id="ch09list18"><em>Listing 9-18: Updating the <span class="literal">Grass</span> object using <span class="literal">patchSize</span> variable</em></p>&#13;
<p class="indent">In this example, <span class="literal">global patchSize</span> tells Python that we’re using the same <span class="literal">patchSize</span> variable everywhere. Then we write two <span class="literal">for</span> loops (one for x and the other for y) to append <span class="literal">Grass</span> to the grass list so we can create a square grid of grass.</p>&#13;
<p class="indent">Then we update everything in the <span class="literal">draw()</span> function, just like we did for the sheep. Whatever is drawn first will be drawn covered up by what’s drawn after, so we’ll update the grass first by changing the <span class="literal">draw()</span> function to the code in <a href="ch09.xhtml#ch09list19">Listing 9-19</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>SheepAndGrass.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">background</span>(255)<br/>    <span class="pd_gray">#update the grass first</span><br/>    <span class="pd_lime">for</span> grass <span class="pd_green1">in</span> grassList:<br/>        grass.update()<br/>    <span class="pd_gray">#then the sheep</span><br/>    <span class="pd_lime">for</span> sheep <span class="pd_green1">in</span> sheepList:<br/>        sheep.update()</p>&#13;
<p class="listing" id="ch09list19"><em>Listing 9-19: Updating the grass before the sheep</em></p>&#13;
<p class="indent">When you run this code, you should see a grid of green squares, like in <a href="ch09.xhtml#ch09fig7">Figure 9-7</a>.</p>&#13;
<span epub:type="pagebreak" id="page_192"/>&#13;
<div class="image"><a id="ch09fig7"/><img alt="image" src="../images/f192-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-7: Grass with grid lines</em></p>&#13;
<p class="indent">Let’s shut off the black outline so it’ll look like a smooth field of grass. Add <span class="literal">noStroke()</span> to the <span class="literal">setup()</span> function to remove the outline of the green squares:</p>&#13;
<p class="programs"><span class="pd_gray">def setup():</span><br/>    <span class="pd_gray">global patchSize</span><br/>    <span class="pd_gray">size(600,600)</span><br/>    <span class="pd_blue1">noStroke</span>()</p>&#13;
<p class="indent">Now we have our grass!</p>&#13;
<h4 class="h4" id="ch09_1_9">MAKING THE GRASS BROWN WHEN EATEN</h4>&#13;
<p class="noindent">How do we make it so that when a sheep is on a patch of grass, the sheep gets the grass’s energy and the patch of grass turns brown to show that the sheep has eaten it? Change the <span class="literal">update()</span> method for <span class="literal">Grass</span> by adding the following lines of code:</p>&#13;
<p class="programs">    <span class="pd_green1">def</span> update(<span class="pd_green1">self</span>):<br/>        <span class="pd_lime">if</span> <span class="pd_green1">self</span>.eaten:<br/>            <span class="pd_blue1">fill</span>(BROWN)<br/>        <span class="pd_lime">else</span>:<br/>            <span class="pd_blue1">fill</span>(GREEN)<br/>        rect(<span class="pd_green1">self</span>.x,<span class="pd_green1">self</span>.y,<span class="pd_green1">self</span>.sz,<span class="pd_green1">self</span>.sz)</p>&#13;
<p class="indent">This code tells Processing that if the patch of grass is “eaten,” the rectangle should be filled with a brown color. Otherwise, the grass should be colored green. There’s more than one way for a sheep to “eat” grass. One way is to make each patch of grass check the entire <span class="literal">sheepList</span> for a sheep <span epub:type="pagebreak" id="page_193"/>on its location, which could mean tens of thousands of patches are checking thousands of sheep. Those numbers could get big. However, because each patch of grass is in the <span class="literal">grassList</span>, an alternate way is that when a sheep changes its location, it could simply change the patch at that location to “eaten” (if it isn’t already) and get energy from eating it. That would mean a lot less checking.</p>&#13;
<p class="indent">The problem is that the x- and y-coordinates of the sheep don’t exactly match up to where the patches of grass are in the <span class="literal">grassList</span>. For example, our <span class="literal">patchSize</span> is 10, meaning that if a sheep is at (92,35), it’ll be on the 10th patch to the right and the 4th patch down (because the “first” patch is from x = 0 to x = 9). We’re dividing by the <span class="literal">patchSize</span> to get the “scaled” x- and y-values, 9 and 3.</p>&#13;
<p class="indent">However, the <span class="literal">grassList</span> doesn’t have rows and columns. We do know that the x-value, 9, means it’s the 10th row (don’t forget row 0), so we’ll just have to add in nine rows of 60 (the height divided by the <span class="literal">patchSize</span>) and then add the y-value to get the index of the patch of grass the sheep is on. Therefore, we need a variable to tell us how many patches of grass there are in a row, which we’ll call <span class="literal">rows_of_grass</span>. Add <span class="literal">global rows_of_grass</span> to the beginning of the <span class="literal">setup()</span> function and then add this line to <span class="literal">setup()</span> after declaring the size:</p>&#13;
<p class="programs">rows_of_grass = <span class="pd_raspberry">height</span>/patchSize</p>&#13;
<p class="indent">This takes the width of the display window and divides it by the size of the patches of grass to tell us how many columns of grass there are. The code to add to the <span class="literal">Sheep</span> class is in <a href="ch09.xhtml#ch09list20">Listing 9-20</a>.</p>&#13;
<p class="programs">        <span class="pd_g1"><em>SheepAndGrass.pyde</em></span><br/>        <span class="pd_green1">self</span>.x += <span class="pd_blue1">random</span>(-move, move)<br/>        <span class="pd_green1">self</span>.y += <span class="pd_blue1">random</span>(-move, move)<br/>        <span class="pd_gray">#"wrap" the world Asteroids-style</span><br/>     <span class="ent">➊</span> <span class="pd_lime">if</span> <span class="pd_green1">self</span>.x &gt; <span class="pd_raspberry">width</span>:<br/>            <span class="pd_green1">self</span>.x %= <span class="pd_raspberry">width</span><br/>        <span class="pd_lime">if</span> <span class="pd_green1">self</span>.y &gt; <span class="pd_raspberry">height</span>:<br/>            <span class="pd_green1">self</span>.y %= <span class="pd_raspberry">height</span><br/>        <span class="pd_lime">if</span> <span class="pd_green1">self</span>.x &lt; 0:<br/>            <span class="pd_green1">self</span>.x += <span class="pd_raspberry">width</span><br/>        <span class="pd_lime">if</span> <span class="pd_green1">self</span>.y &lt; 0:<br/>            <span class="pd_green1">self</span>.y += <span class="pd_raspberry">height</span><br/>        <span class="pd_gray">#find the patch of grass you're on in the grassList:</span><br/>     <span class="ent">➋</span> xscl = <span class="pd_blue1">int</span>(<span class="pd_green1">self</span>.x / patchSize)<br/>        yscl = <span class="pd_blue1">int</span>(<span class="pd_green1">self</span>.y / patchSize)<br/>     <span class="ent">➌</span> grass = grassList[xscl * rows_of_grass + yscl]<br/>        <span class="pd_lime">if</span> <span class="pd_green1">not</span> grass.eaten:<br/>            <span class="pd_green1">self</span>.energy += grass.energy<br/>            grass.eaten = <span class="pd_lime">True</span></p>&#13;
<p class="listing" id="ch09list20"><em>Listing 9-20: Updating the sheep’s energy level and turning the grass brown</em></p>&#13;
<p class="indent">After updating the sheep’s location, we “wrap” the coordinates <span class="ent">➊</span> so if the sheep walks off the screen in one direction, it shows up on the other side of the screen, like in the video game <em>Asteroids</em>. We calculate which patch the sheep is on according to the <span class="literal">patchSize</span> <span class="ent">➋</span>. Then we use code to go <span epub:type="pagebreak" id="page_194"/>from x- and y-values to the index of that patch in the <span class="literal">grassList</span> <span class="ent">➌</span>. We now know the exact index of the patch of grass the sheep is on. If this patch of grass is not already eaten, the sheep eats it! It gets the energy from the grass, and the grass’s <span class="literal">eaten</span> property is set to <span class="literal">True</span>.</p>&#13;
<p class="indent">Run this code, and you’ll see the three sheep running around eating grass, which turns brown once it’s eaten. Slow the sheep down by changing the <span class="literal">move</span> variable to a lesser value, such as 5. You can also scale down the patches by changing one number, the <span class="literal">patchSize</span> variable, to 5. Try other values if you like.</p>&#13;
<p class="indent">Now we can create more <span class="literal">Sheep</span>. Let’s change the number in the <span class="literal">for i in range line</span> to 20, like so:</p>&#13;
<p class="programs">    <span class="pd_gray">#create the sheep</span><br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(20):<br/>        <span class="pd_gray">sheepList.append(Sheep(random(width),</span><br/><span class="pd_gray">                               random(height)))</span></p>&#13;
<p class="indent">When you run this code, you should see something like <a href="ch09.xhtml#ch09fig8">Figure 9-8</a>.</p>&#13;
<div class="image"><a id="ch09fig8"/><img alt="image" src="../images/f194-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-8: A herd of sheep!</em></p>&#13;
<p class="indent">Now there are 20 sheep walking around, leaving patches of brown grass.</p>&#13;
<h4 class="h4" id="ch09_1_10">GIVING EACH SHEEP A RANDOM COLOR</h4>&#13;
<p class="noindent">Let’s have the sheep choose a color when they’re “born.” After the code defining the color constants, let’s put some colors into a color list, like this:</p>&#13;
<p class="programs">YELLOW = <span class="pd_blue1">color</span>(255,255,0)<br/>PURPLE = <span class="pd_blue1">color</span>(102,0,204)<br/>colorList = [WHITE,RED,YELLOW,PURPLE]</p>&#13;
<span epub:type="pagebreak" id="page_195"/>&#13;
<p class="indent">Make the following changes to the <span class="literal">Sheep</span> class to use different colors. First, you need to give <span class="literal">Sheep</span> a color property. Because <span class="literal">color</span> is already a keyword in Processing, <span class="literal">col</span> is used in <a href="ch09.xhtml#ch09list21">Listing 9-21</a>.</p>&#13;
<p class="programs"><span class="pd_green1">class</span> Sheep:<br/><span class="pd_gray">    </span><span class="pd_green1">def</span> <span class="pd_blue1">__init__</span>(<span class="pd_green1">self</span>,x,y,col):<br/><span class="pd_gray">        self.x = x #x-position</span><br/><span class="pd_gray">        self.y = y #y-position</span><br/><span class="pd_gray">        self.sz = 10 #size</span><br/><span class="pd_gray">        self.energy = 20</span><br/>        <span class="pd_green1">self</span>.col = col</p>&#13;
<p class="listing" id="ch09list21"><em>Listing 9-21: Adding a color property to the <span class="literal">Sheep</span> class</em></p>&#13;
<p class="indent">Then in the <span class="literal">update()</span> method, replace the fill line with this:</p>&#13;
<p class="programs">        <span class="pd_blue1">fill</span>(<span class="pd_green1">self</span>.col) <span class="pd_gray">#its own color</span><br/>        <span class="pd_blue1">ellipse</span>(<span class="pd_green1">self</span>.x,<span class="pd_green1">self</span>.y,<span class="pd_green1">self</span>.sz,<span class="pd_green1">self</span>.sz)</p>&#13;
<p class="indent">Before the ellipse is drawn, <span class="literal">fill(self.col)</span> tells Processing to fill the ellipse with the <span class="literal">Sheep</span>’s own randomly chosen color.</p>&#13;
<p class="indent">When all the <span class="literal">Sheep</span> are instantiated in the <span class="literal">setup()</span> function, you need to give them a random color. That means at the top of the program you have to import the <span class="literal">choice()</span> function from the <span class="literal">random</span> module, like this:</p>&#13;
<p class="programs"><span class="pd_green1">from</span> <span class="pd_blue1">random</span> <span class="pd_green1">import</span> choice</p>&#13;
<p class="indent">Python’s <span class="literal">choice()</span> function allows you to have one item chosen at random from a list and then returned. We should be able to tell the program to do this as follows:</p>&#13;
<p class="programs">choice(colorList)</p>&#13;
<p class="indent">Now the program will return a single value from the color list. Finally, when you’re creating the <span class="literal">Sheep</span>, add the random choice of color from the color list as one of the arguments you pass to the <span class="literal">Sheep</span> constructor, as shown here:</p>&#13;
<p class="programs"><span class="pd_gray">def setup():</span><br/>    <span class="pd_gray">size(600,600)</span><br/>    <span class="pd_gray">noStroke()</span><br/><span class="pd_gray">    #create the sheep</span><br/>    <span class="pd_gray">for</span> <span class="pd_gray">i in range(20):</span><br/>        <span class="pd_gray">sheepList.append(Sheep(random(width),</span><br/>                               <span class="pd_gray">random(height),</span><br/>                               choice(colorList)))</p>&#13;
<p class="indent">Now when you run this code, you should see a bunch of randomly colored sheep walking around the screen, as shown in <a href="ch09.xhtml#ch09fig9">Figure 9-9</a>.</p>&#13;
<span epub:type="pagebreak" id="page_196"/>&#13;
<div class="image"><a id="ch09fig9"/><img alt="image" src="../images/f196-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-9: Multicolored sheep</em></p>&#13;
<p class="indent">Each new sheep gets assigned one of the four colors we defined in <span class="literal">colorList</span>: white, red, yellow, or purple.</p>&#13;
<h4 class="h4" id="ch09_1_11">PROGRAMMING SHEEP TO REPRODUCE</h4>&#13;
<p class="noindent">Unfortunately, in our current program the sheep eat the grass until they wander too far away from the grass, run out of energy, and die. To prevent this, let’s tell the sheep to use some of that energy to reproduce.</p>&#13;
<p class="indent">Let’s use the code in <a href="ch09.xhtml#ch09list22">Listing 9-22</a> to tell the sheep to reproduce if their energy level reaches 50.</p>&#13;
<p class="programs"><span class="pd_gray">if self.energy &lt;= 0:</span><br/>    <span class="pd_gray">sheepList.remove(self)</span><br/><span class="pd_lime">if</span> <span class="pd_green1">self</span>.energy &gt;= 50:<br/>    <span class="pd_green1">self</span>.energy -= 30 <span class="pd_gray">#giving birth takes energy</span><br/>    <span class="pd_gray">#add another sheep to the list</span><br/>    sheepList.<span class="pd_blue1">append</span>(Sheep(<span class="pd_green1">self</span>.x,<span class="pd_green1">self</span>.y,<span class="pd_green1">self</span>.col))</p>&#13;
<p class="listing" id="ch09list22"><em>Listing 9-22: Adding a conditional for sheep to reproduce</em></p>&#13;
<p class="indent">The conditional <span class="literal">if self.energy &gt;= 50:</span> checks whether that sheep’s energy is greater than or equal to 50. If it is, we decrement the energy level by 30 for birthing and add another sheep to the sheep list. Notice that the new sheep is at the same location and is the same color as its parent. Run this code, and you should see the sheep reproduce, like in <a href="ch09.xhtml#ch09fig10">Figure 9-10</a>.</p>&#13;
<span epub:type="pagebreak" id="page_197"/>&#13;
<div class="image"><a id="ch09fig10"/><img alt="image" src="../images/f197-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-10: Sheep eating grass and reproducing</em></p>&#13;
<p class="indent">Soon you should see what looks like tribes of similarly colored sheep.</p>&#13;
<h4 class="h4" id="ch09_1_12">LETTING THE GRASS REGROW</h4>&#13;
<p class="noindent">Unfortunately, the sheep soon eat up all the grass in their area and die (probably a lesson in there somewhere). We need to allow our grass to regrow. To do this, change the <span class="literal">Grass</span>’s <span class="literal">update()</span> method to this:</p>&#13;
<p class="programs">    <span class="pd_green1">def</span> update(<span class="pd_green1">self</span>):<br/>        <span class="pd_lime">if</span> <span class="pd_green1">self</span>.eaten:<br/>            <span class="pd_lime">if</span> <span class="pd_blue1">random</span>(100) &lt; 5:<br/>                <span class="pd_green1">self</span>.eaten = <span class="pd_lime">False</span><br/>            <span class="pd_lime">else</span>:<br/>                <span class="pd_blue1">fill</span>(BROWN)<br/>       <span class="pd_gray"/> <span class="pd_lime">else</span><span class="pd_gray">:</span><br/>            <span class="pd_blue1">fill</span>(GREEN)<br/>        <span class="pd_blue1">rect</span>(<span class="pd_green1">self</span>.x,<span class="pd_green1">self</span>.y,<span class="pd_green1">self</span>.sz,<span class="pd_green1">self</span>.sz)</p>&#13;
<p class="indent">The Processing code <span class="literal">random(100)</span> generates a random number between 0 and 100. If the number is less than 5, we regrow a patch of grass by setting its <span class="literal">eaten</span> property to <span class="literal">False</span>. We use the number 5 because this gives us a probability of 5/100 that eaten grass will regrow during each frame. Otherwise, it stays brown.</p>&#13;
<p class="indent">Run the code, and you should see something like <a href="ch09.xhtml#ch09fig11">Figure 9-11</a>.</p>&#13;
<span epub:type="pagebreak" id="page_198"/>&#13;
<div class="image"><a id="ch09fig11"/><img alt="image" src="../images/f198-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-11: The grass regrows and the sheep populate the whole screen!</em></p>&#13;
<p class="indent">Now you might get so many sheep that the program starts to slow down! This could be because the sheep have too much energy. If so, try reducing the amount of energy each patch of grass contains from 5 to 2:</p>&#13;
<p class="programs"><span class="pd_gray">class Grass:</span><br/><span class="pd_gray">    def __init__(self,x,y,sz):</span><br/><span class="pd_gray">        self.x = x</span><br/><span class="pd_gray">        self.y = y</span><br/>        <span class="pd_green1">self</span>.energy = 2 <span class="pd_gray">#energy from eating this patch</span><br/><span class="pd_gray">        self.eaten = False #hasn't been eaten yet</span><br/>        <span class="pd_gray">self.sz = sz</span></p>&#13;
<p class="indent">That seems to be a good balance that lets the sheep population grow at a reasonable pace. Play around with the numbers all you want—it’s your world!</p>&#13;
<h4 class="h4" id="ch09_1_13">PROVIDING AN EVOLUTIONARY ADVANTAGE</h4>&#13;
<p class="noindent">Let’s give one of the sheep groups an advantage. You can choose any advantage you can think of (getting more energy from grass or producing more offspring at a time, for instance). For this example, we’re going to let the purple sheep walk a little further than the others. Will that make any difference? To find out, make the <span class="literal">Sheep</span>’s <span class="literal">update()</span> method match the following code:</p>&#13;
<p class="programs">    <span class="pd_green1">def</span> update(<span class="pd_green1">self</span>):<br/><span class="pd_gray">        #make sheep walk randomly</span><br/><span epub:type="pagebreak" id="page_199"/>&#13;
        move = 5 <span class="pd_gray">#the maximum it can move in any direction</span><br/>        <span class="pd_lime">if</span> <span class="pd_green1">self</span>.col == PURPLE:<br/>            move = 7<br/>        <span class="pd_gray">self.energy -= 1</span></p>&#13;
<p class="indent">This conditional checks whether the <span class="literal">Sheep</span>’s color is purple. If so, it sets the <span class="literal">Sheep</span>’s <span class="literal">move</span> value to 7. Otherwise, it leaves the value at 5. This allows the purple sheep to travel further, and therefore more likely to find green patches, than the other sheep. Let’s run the code and check the outcome, which should look like <a href="ch09.xhtml#ch09fig12">Figure 9-12</a>.</p>&#13;
<div class="image"><a id="ch09fig12"/><img alt="image" src="../images/f199-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 9-12: Giving purple sheep an advantage</em></p>&#13;
<p class="indent">After a little while it sure looks like that tiny advantage paid off for the purple sheep. They’re dominating the environment and pushing out all the other sheep just by competing for grass. This simulation could spark interesting discussions about ecology, invasive species, biodiversity, and evolution.</p>&#13;
<div class="sidebar">&#13;
<p class="title">EXERCISE 9-2: SETTING SHEEP LIFESPAN</p>&#13;
<p class="noindent">Create an “age” property and decrease it every time the sheep update so they live for only a limited amount of time.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_200"/>&#13;
<div class="sidebar">&#13;
<p class="title">EXERCISE 9-3: CHANGING SHEEP SIZE</p>&#13;
<p class="noindent">Vary the size of the sheep according to their energy level.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch09_3">SUMMARY</h3>&#13;
<p class="noindent">In this chapter, you learned how to make objects using classes, which involved defining the class using properties and then instantiating (“creating”) and updating the object. This let you create multiple similar-but-independent objects with the same properties more efficiently. The more you use classes, the more creative you can get by making autonomous objects walk, fly, or bounce around without your having to code every step!</p>&#13;
<p class="indent">Knowing how to use classes supercharges your coding abilities. Now you can create models of complicated situations easily, and once you tell the program what to do with one particle, or planet, or sheep, it’ll be able to make a dozen, a hundred, or even a million of them very easily!</p>&#13;
<p class="indent">You also got a taste of setting up models to explore physical, biological, chemical, or environmental situations with very few equations! A physicist once told me that’s often the most efficient method for solving problems involving many factors, or “agents.” You set up a computer model, let it run, and look at the results.</p>&#13;
<p class="indent">In the next chapter, you’ll learn how to create fractals using an almost-magical phenomenon called recursion.</p>&#13;
</body></html>