- en: PRACTICE PROJECT SOLUTIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This appendix provides the solutions to the practice projects in each chapter.
    Digital versions are available on the book’s website at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 1: Silly Name Generator**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***Pig Latin***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*pig_Latin_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Turn a word into its Pig Latin equivalent."""'
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: VOWELS = 'aeiouy'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'word = input("Type a word and get its Pig Latin translation: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'if word[0] in VOWELS:'
  prefs: []
  type: TYPE_NORMAL
- en: pig_Latin = word + 'way'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: pig_Latin = word[1:] + word[0] + 'ay'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: print("{}".format(pig_Latin), file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: try_again = input("\n\nTry again? (Press Enter else n to stop)\n ")
  prefs: []
  type: TYPE_NORMAL
- en: 'if try_again.lower() == "n":'
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: '***Poor Man’s Bar Chart***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*EATOIN_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Map letters from string into dictionary & print bar chart of frequency."""'
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import pprint
  prefs: []
  type: TYPE_NORMAL
- en: from collections import defaultdict
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: text should be a short phrase for bars to fit in IDLE window'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: text = 'Like the castle in its corner in a medieval game, I foresee terrible
    \
  prefs: []
  type: TYPE_NORMAL
- en: trouble and I stay here just the same.'
  prefs: []
  type: TYPE_NORMAL
- en: ALPHABET = 'abcdefghijklmnopqrstuvwxyz'
  prefs: []
  type: TYPE_NORMAL
- en: defaultdict module lets you build dictionary keys on the fly!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: mapped = defaultdict(list)
  prefs: []
  type: TYPE_NORMAL
- en: 'for character in text:'
  prefs: []
  type: TYPE_NORMAL
- en: character = character.lower()
  prefs: []
  type: TYPE_NORMAL
- en: 'if character in ALPHABET:'
  prefs: []
  type: TYPE_NORMAL
- en: mapped[character].append(character)
  prefs: []
  type: TYPE_NORMAL
- en: pprint lets you print stacked output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print("\nYou may need to stretch console window if text wrapping occurs.\n")
  prefs: []
  type: TYPE_NORMAL
- en: print("text = ", end='')
  prefs: []
  type: TYPE_NORMAL
- en: print("{}\n".format(text), file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: pprint.pprint(mapped, width=110)
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 2: Finding Palingram Spells**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***Dictionary Cleanup***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*dictionary_cleanup_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Remove single-letter words from list if not ''a'' or ''i''."""'
  prefs: []
  type: TYPE_NORMAL
- en: word_list = ['a', 'nurses', 'i', 'stack', 'b', 'c', 'cat']
  prefs: []
  type: TYPE_NORMAL
- en: word_list_clean = []
  prefs: []
  type: TYPE_NORMAL
- en: permissible = ('a', 'i')
  prefs: []
  type: TYPE_NORMAL
- en: 'for word in word_list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(word) > 1:'
  prefs: []
  type: TYPE_NORMAL
- en: word_list_clean.append(word)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif len(word) == 1 and word in permissible:'
  prefs: []
  type: TYPE_NORMAL
- en: word_list_clean.append(word)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: continue
  prefs: []
  type: TYPE_NORMAL
- en: print("{}".format(word_list_clean))
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 3: Solving Anagrams**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***Finding Digrams***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*count_digrams_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Generate letter pairs in Voldemort & find their frequency in a dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: Requires load_dictionary.py module to load an English dictionary file.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: import re
  prefs: []
  type: TYPE_NORMAL
- en: from collections import defaultdict
  prefs: []
  type: TYPE_NORMAL
- en: from itertools import permutations
  prefs: []
  type: TYPE_NORMAL
- en: import load_dictionary
  prefs: []
  type: TYPE_NORMAL
- en: word_list = load_dictionary.load('2of4brif.txt')
  prefs: []
  type: TYPE_NORMAL
- en: name = 'Voldemort'  #(tmvoordle)
  prefs: []
  type: TYPE_NORMAL
- en: name = name.lower()
  prefs: []
  type: TYPE_NORMAL
- en: generate unique letter pairs from name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: digrams = set()
  prefs: []
  type: TYPE_NORMAL
- en: perms = {''.join(i) for i in permutations(name)}
  prefs: []
  type: TYPE_NORMAL
- en: 'for perm in perms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, len(perm) - 1):'
  prefs: []
  type: TYPE_NORMAL
- en: digrams.add(perm[i] + perm[i + 1])
  prefs: []
  type: TYPE_NORMAL
- en: print(*sorted(digrams), sep='\n')
  prefs: []
  type: TYPE_NORMAL
- en: print("\nNumber of digrams = {}\n".format(len(digrams)))
  prefs: []
  type: TYPE_NORMAL
- en: use regular expressions to find repeating digrams in a word
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: mapped = defaultdict(int)
  prefs: []
  type: TYPE_NORMAL
- en: 'for word in word_list:'
  prefs: []
  type: TYPE_NORMAL
- en: word = word.lower()
  prefs: []
  type: TYPE_NORMAL
- en: 'for digram in digrams:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for m in re.finditer(digram, word):'
  prefs: []
  type: TYPE_NORMAL
- en: mapped[digram] += 1
  prefs: []
  type: TYPE_NORMAL
- en: print("digram frequency count:")
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for k in sorted(mapped):'
  prefs: []
  type: TYPE_NORMAL
- en: print("{} {}".format(k, mapped[k]))
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 4: Decoding American Civil War Ciphers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***Hacking Lincoln***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| **Code word** | **Plaintext** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| WAYLAND | captured |'
  prefs: []
  type: TYPE_TB
- en: '| NEPTUNE | Richmond |'
  prefs: []
  type: TYPE_TB
- en: '**Plaintext:** correspondents of the Tribune captured at Richmond please ascertain
    why they are detained and get them off if you can this fills it up'
  prefs: []
  type: TYPE_NORMAL
- en: '***Identifying Cipher Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*identify_cipher_type_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Load ciphertext & use fraction of ETAOIN present to classify cipher type."""'
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: from collections import Counter
  prefs: []
  type: TYPE_NORMAL
- en: set arbitrary cutoff fraction of 6 most common letters in English
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ciphertext with target fraction or greater = transposition cipher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CUTOFF = 0.5
  prefs: []
  type: TYPE_NORMAL
- en: load ciphertext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def load(filename):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Open text file and return list."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(filename) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: return f.read().strip()
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: ciphertext = load('cipher_a.txt')
  prefs: []
  type: TYPE_NORMAL
- en: 'except IOError as e:'
  prefs: []
  type: TYPE_NORMAL
- en: print("{}. Terminating program.".format(e),
  prefs: []
  type: TYPE_NORMAL
- en: file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit(1)
  prefs: []
  type: TYPE_NORMAL
- en: count 6 most common letters in ciphertext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: six_most_frequent = Counter(ciphertext.lower()).most_common(6)
  prefs: []
  type: TYPE_NORMAL
- en: print("\nSix most-frequently-used letters in English = ETAOIN")
  prefs: []
  type: TYPE_NORMAL
- en: print('\nSix most frequent letters in ciphertext =')
  prefs: []
  type: TYPE_NORMAL
- en: print(*six_most_frequent, sep='\n')
  prefs: []
  type: TYPE_NORMAL
- en: convert list of tuples to set of letters for comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: cipher_top_6 = {i[0] for i in six_most_frequent}
  prefs: []
  type: TYPE_NORMAL
- en: TARGET = 'etaoin'
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for letter in TARGET:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if letter in cipher_top_6:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if count/len(TARGET) >= CUTOFF:'
  prefs: []
  type: TYPE_NORMAL
- en: print("\nThis ciphertext most-likely produced by a TRANSPOSITION cipher")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("This ciphertext most-likely produced by a SUBSTITUTION cipher")
  prefs: []
  type: TYPE_NORMAL
- en: '***Storing a Key as a Dictionary***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*key_dictionary_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Input cipher key string, get user input on route direction as dict value."""'
  prefs: []
  type: TYPE_NORMAL
- en: col_order = """1 3 4 2"""
  prefs: []
  type: TYPE_NORMAL
- en: key = dict()
  prefs: []
  type: TYPE_NORMAL
- en: cols = [int(i) for i in col_order.split()]
  prefs: []
  type: TYPE_NORMAL
- en: 'for col in cols:'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'key[col] = input("Direction to read Column {} (u = up, d = down): "'
  prefs: []
  type: TYPE_NORMAL
- en: .format(col).lower())
  prefs: []
  type: TYPE_NORMAL
- en: 'if key[col] == ''u'' or key[col] == ''d'':'
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Input should be 'u' or 'd'")
  prefs: []
  type: TYPE_NORMAL
- en: print("{}, {}".format(col, key[col]))
  prefs: []
  type: TYPE_NORMAL
- en: '***Automating Possible Keys***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*permutations_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""For a total number of columns, find all unique column arrangements.'
  prefs: []
  type: TYPE_NORMAL
- en: Builds a list of lists containing all possible unique arrangements of
  prefs: []
  type: TYPE_NORMAL
- en: individual column numbers, including negative values for route direction
  prefs: []
  type: TYPE_NORMAL
- en: (read up column vs. down).
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  prefs: []
  type: TYPE_NORMAL
- en: -total number of columns
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: -list of lists of unique column orders, including negative values for
  prefs: []
  type: TYPE_NORMAL
- en: route cipher encryption direction
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: from itertools import permutations, product
  prefs: []
  type: TYPE_NORMAL
- en: '#------BEGIN INPUT-----------------------------------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input total number of columns:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: num_cols = 4
  prefs: []
  type: TYPE_NORMAL
- en: '#------DO NOT EDIT BELOW THIS LINE--------------------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: generate listing of individual column numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: columns = [x for x in range(1, num_cols+1)]
  prefs: []
  type: TYPE_NORMAL
- en: print("columns = {}".format(columns))
  prefs: []
  type: TYPE_NORMAL
- en: build list of lists of column number combinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: itertools product computes the Cartesian product of input iterables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def perms(columns):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Take number of columns integer & generate pos & neg permutations."""'
  prefs: []
  type: TYPE_NORMAL
- en: results = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for perm in permutations(columns):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for signs in product([-1, 1], repeat=len(columns)):'
  prefs: []
  type: TYPE_NORMAL
- en: results.append([i*sign for i, sign in zip(perm, signs)])
  prefs: []
  type: TYPE_NORMAL
- en: return results
  prefs: []
  type: TYPE_NORMAL
- en: col_combos = perms(columns)
  prefs: []
  type: TYPE_NORMAL
- en: print(*col_combos, sep="\n")  # comment-out for num_cols > 4!
  prefs: []
  type: TYPE_NORMAL
- en: print("Factorial of num_cols without negatives = {}"
  prefs: []
  type: TYPE_NORMAL
- en: .format(math.factorial(num_cols)))
  prefs: []
  type: TYPE_NORMAL
- en: print("Number of column combinations = {}".format(len(col_combos)))
  prefs: []
  type: TYPE_NORMAL
- en: '***Route Transposition Cipher: Brute-Force Attack***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This practice project uses two programs. The second, *perms.py*, is used as
    a module in the first program, *route_cipher_hacker.py*. It was built from the
    *permutations_practice.py* program previously described in “[Automating Possible
    Keys](appendix.xhtml#lev408)” on [page 371](appendix.xhtml#page_371).
  prefs: []
  type: TYPE_NORMAL
- en: '***route_cipher_hacker.py***'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*route_cipher_hacker.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Brute-force hack a Union route cipher (route_cipher_hacker.py).'
  prefs: []
  type: TYPE_NORMAL
- en: Designed for whole-word transposition ciphers with variable rows & columns.
  prefs: []
  type: TYPE_NORMAL
- en: Assumes encryption began at either top or bottom of a column.
  prefs: []
  type: TYPE_NORMAL
- en: Possible keys auto-generated based on number of columns & rows input.
  prefs: []
  type: TYPE_NORMAL
- en: Key indicates the order to read columns and the direction to traverse.
  prefs: []
  type: TYPE_NORMAL
- en: Negative column numbers mean start at bottom and read up.
  prefs: []
  type: TYPE_NORMAL
- en: Positive column numbers means start at top & read down.
  prefs: []
  type: TYPE_NORMAL
- en: Example below is for 4x4 matrix with key -1 2 -3 4.
  prefs: []
  type: TYPE_NORMAL
- en: Note "0" is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Arrows show encryption route; for negative key values read UP.
  prefs: []
  type: TYPE_NORMAL
- en: 1   2   3   4
  prefs: []
  type: TYPE_NORMAL
- en: ___ ___ ___ ___
  prefs: []
  type: TYPE_NORMAL
- en: '| ^ | | | ^ | | | MESSAGE IS WRITTEN'
  prefs: []
  type: TYPE_NORMAL
- en: '|_|_|_v_|_|_|_v_|'
  prefs: []
  type: TYPE_NORMAL
- en: '| ^ | | | ^ | | | ACROSS EACH ROW'
  prefs: []
  type: TYPE_NORMAL
- en: '|_|_|_v_|_|_|_v_|'
  prefs: []
  type: TYPE_NORMAL
- en: '| ^ | | | ^ | | | IN THIS MANNER'
  prefs: []
  type: TYPE_NORMAL
- en: '|_|_|_v_|_|_|_v_|'
  prefs: []
  type: TYPE_NORMAL
- en: '| ^ | | | ^ | | | LAST ROW IS FILLED WITH DUMMY WORDS'
  prefs: []
  type: TYPE_NORMAL
- en: '|_|_|_v_|_|_|_v_|'
  prefs: []
  type: TYPE_NORMAL
- en: START        END
  prefs: []
  type: TYPE_NORMAL
- en: 'Required inputs - a text message, # of columns, # of rows, key string'
  prefs: []
  type: TYPE_NORMAL
- en: Requires custom-made "perms" module to generate keys
  prefs: []
  type: TYPE_NORMAL
- en: Prints off key used and translated plaintext
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import perms
  prefs: []
  type: TYPE_NORMAL
- en: '#=============================================================================='
  prefs: []
  type: TYPE_NORMAL
- en: 'USER INPUT:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'the string to be decrypted (type or paste between triple-quotes):'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ciphertext = """REST TRANSPORT YOU GODWIN VILLAGE ROANOKE WITH ARE YOUR IS JUST
  prefs: []
  type: TYPE_NORMAL
- en: SUPPLIES FREE SNOW HEADING TO GONE TO SOUTH FILLER
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'the number of columns believed to be in the transposition matrix:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: COLS = 4
  prefs: []
  type: TYPE_NORMAL
- en: 'the number of rows believed to be in the transposition matrix:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ROWS = 5
  prefs: []
  type: TYPE_NORMAL
- en: END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#=============================================================================='
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Turn ciphertext into list, call validation & decryption functions."""'
  prefs: []
  type: TYPE_NORMAL
- en: cipherlist = list(ciphertext.split())
  prefs: []
  type: TYPE_NORMAL
- en: validate_col_row(cipherlist)
  prefs: []
  type: TYPE_NORMAL
- en: decrypt(cipherlist)
  prefs: []
  type: TYPE_NORMAL
- en: 'def validate_col_row(cipherlist):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Check that input columns & rows are valid vs. message length."""'
  prefs: []
  type: TYPE_NORMAL
- en: factors = []
  prefs: []
  type: TYPE_NORMAL
- en: len_cipher = len(cipherlist)
  prefs: []
  type: TYPE_NORMAL
- en: for i in range(2, len_cipher):  # range excludes 1-column ciphers
  prefs: []
  type: TYPE_NORMAL
- en: 'if len_cipher % i == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: factors.append(i)
  prefs: []
  type: TYPE_NORMAL
- en: print("\nLength of cipher = {}".format(len_cipher))
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Acceptable column/row values include: {}".format(factors))'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: 'if ROWS * COLS != len_cipher:'
  prefs: []
  type: TYPE_NORMAL
- en: print("\nError - Input columns & rows not factors of length "
  prefs: []
  type: TYPE_NORMAL
- en: '"of cipher. Terminating program.", file=sys.stderr)'
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit(1)
  prefs: []
  type: TYPE_NORMAL
- en: 'def decrypt(cipherlist):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Turn columns into items in list of lists & decrypt ciphertext."""'
  prefs: []
  type: TYPE_NORMAL
- en: col_combos = perms.perms(COLS)
  prefs: []
  type: TYPE_NORMAL
- en: 'for key in col_combos:'
  prefs: []
  type: TYPE_NORMAL
- en: translation_matrix = [None] * COLS
  prefs: []
  type: TYPE_NORMAL
- en: plaintext = ''
  prefs: []
  type: TYPE_NORMAL
- en: start = 0
  prefs: []
  type: TYPE_NORMAL
- en: stop = ROWS
  prefs: []
  type: TYPE_NORMAL
- en: 'for k in key:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if k < 0: # reading bottom-to-top of column'
  prefs: []
  type: TYPE_NORMAL
- en: col_items = cipherlist[start:stop]
  prefs: []
  type: TYPE_NORMAL
- en: 'elif k > 0: # reading top-to-bottom of columnn'
  prefs: []
  type: TYPE_NORMAL
- en: col_items = list((reversed(cipherlist[start:stop])))
  prefs: []
  type: TYPE_NORMAL
- en: translation_matrix[abs(k) - 1] = col_items
  prefs: []
  type: TYPE_NORMAL
- en: start += ROWS
  prefs: []
  type: TYPE_NORMAL
- en: stop += ROWS
  prefs: []
  type: TYPE_NORMAL
- en: '# loop through nested lists popping off last item to a new list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ROWS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for matrix_col in translation_matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: word = str(matrix_col.pop())
  prefs: []
  type: TYPE_NORMAL
- en: plaintext += word + ' '
  prefs: []
  type: TYPE_NORMAL
- en: print("\nusing key = {}".format(key))
  prefs: []
  type: TYPE_NORMAL
- en: print("translated = {}".format(plaintext))
  prefs: []
  type: TYPE_NORMAL
- en: print("\nnumber of keys = {}".format(len(col_combos)))
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: '***perms.py***'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*perms.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""For a total number of columns, find all unique column arrangements.'
  prefs: []
  type: TYPE_NORMAL
- en: Builds a list of lists containing all possible unique arrangements of
  prefs: []
  type: TYPE_NORMAL
- en: individual column numbers including negative values for route direction
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  prefs: []
  type: TYPE_NORMAL
- en: -total number of columns
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: -list of lists of unique column orders including negative values for
  prefs: []
  type: TYPE_NORMAL
- en: route cipher encryption direction
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: from itertools import permutations, product
  prefs: []
  type: TYPE_NORMAL
- en: build list of lists of column number combinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: itertools product computes the Cartesian product of input iterables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def perms(num_cols):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Take number of columns integer & generate pos & neg permutations."""'
  prefs: []
  type: TYPE_NORMAL
- en: results = []
  prefs: []
  type: TYPE_NORMAL
- en: columns = [x for x in range(1, num_cols+1)]
  prefs: []
  type: TYPE_NORMAL
- en: 'for perm in permutations(columns):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for signs in product([-1, 1], repeat=len(columns)):'
  prefs: []
  type: TYPE_NORMAL
- en: results.append([i*sign for i, sign in zip(perm, signs)])
  prefs: []
  type: TYPE_NORMAL
- en: return results
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 5: Encoding English Civil War Ciphers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***Saving Mary***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*save_Mary_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Hide a null cipher within a list of names using a variable pattern."""'
  prefs: []
  type: TYPE_NORMAL
- en: import load_dictionary
  prefs: []
  type: TYPE_NORMAL
- en: write a short message and use no punctuation or numbers!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: message = "Give your word and we rise"
  prefs: []
  type: TYPE_NORMAL
- en: message = "".join(message.split())
  prefs: []
  type: TYPE_NORMAL
- en: open name file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: names = load_dictionary.load('supporters.txt')
  prefs: []
  type: TYPE_NORMAL
- en: name_list = []
  prefs: []
  type: TYPE_NORMAL
- en: start list with null word not used in cipher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: name_list.append(names[0])
  prefs: []
  type: TYPE_NORMAL
- en: add letter of null cipher to 2nd letter of name, then 3rd, then repeat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: count = 1
  prefs: []
  type: TYPE_NORMAL
- en: 'for letter in message:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for name in names:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(name) > 2 and name not in name_list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if count % 2 == 0 and name[2].lower() == letter.lower():'
  prefs: []
  type: TYPE_NORMAL
- en: name_list.append(name)
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: 'elif count % 2 != 0 and name[1].lower() == letter.lower():'
  prefs: []
  type: TYPE_NORMAL
- en: name_list.append(name)
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: add two null words early in message to throw off cryptanalysts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: name_list.insert(3, 'Stuart')
  prefs: []
  type: TYPE_NORMAL
- en: name_list.insert(6, 'Jacob')
  prefs: []
  type: TYPE_NORMAL
- en: display cover letter and list with null cipher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print("""
  prefs: []
  type: TYPE_NORMAL
- en: 'Your Royal Highness: \n'
  prefs: []
  type: TYPE_NORMAL
- en: It is with the greatest pleasure I present the list of noble families who
  prefs: []
  type: TYPE_NORMAL
- en: have undertaken to support your cause and petition the usurper for the
  prefs: []
  type: TYPE_NORMAL
- en: release of your Majesty from the current tragical circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: '""")'
  prefs: []
  type: TYPE_NORMAL
- en: print(*name_list, sep='\n')
  prefs: []
  type: TYPE_NORMAL
- en: '***The Colchester Catch***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*colchester_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Solve a null cipher based on every nth letter in every nth word."""'
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: 'def load_text(file):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Load a text file as a string."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(file) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: return f.read().strip()
  prefs: []
  type: TYPE_NORMAL
- en: 'load & process message:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'filename = input("\nEnter full filename for message to translate: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: loaded_message = load_text(filename)
  prefs: []
  type: TYPE_NORMAL
- en: 'except IOError as e:'
  prefs: []
  type: TYPE_NORMAL
- en: print("{}. Terminating program.".format(e), file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit(1)
  prefs: []
  type: TYPE_NORMAL
- en: 'check loaded message & # of lines'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: print("\nORIGINAL MESSAGE = {}\n".format(loaded_message))
  prefs: []
  type: TYPE_NORMAL
- en: convert message to list and get length
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: message = loaded_message.split()
  prefs: []
  type: TYPE_NORMAL
- en: end = len(message)
  prefs: []
  type: TYPE_NORMAL
- en: get user input on interval to check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: increment = int(input("Input max word & letter position to \
  prefs: []
  type: TYPE_NORMAL
- en: 'check (e.g., every 1 of 1, 2 of 2, etc.): "))'
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: find letters at designated intervals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for i in range(1, increment + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: print("\nUsing increment letter {} of word {}".format(i, i))
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: count = i - 1
  prefs: []
  type: TYPE_NORMAL
- en: location = i - 1
  prefs: []
  type: TYPE_NORMAL
- en: 'for index, word in enumerate(message):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if index == count:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if location < len(word):'
  prefs: []
  type: TYPE_NORMAL
- en: print("letter = {}".format(word[location]))
  prefs: []
  type: TYPE_NORMAL
- en: count += i
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Interval doesn't work", file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 6: Writing in Invisible Ink**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***Checking the Number of Blank Lines***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*elementary_ink_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Add code to check blank lines in fake message vs lines in real message."""'
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import docx
  prefs: []
  type: TYPE_NORMAL
- en: from docx.shared import RGBColor, Pt
  prefs: []
  type: TYPE_NORMAL
- en: get text from fake message & make each line a list item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: fake_text = docx.Document('fakeMessage.docx')
  prefs: []
  type: TYPE_NORMAL
- en: fake_list = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for paragraph in fake_text.paragraphs:'
  prefs: []
  type: TYPE_NORMAL
- en: fake_list.append(paragraph.text)
  prefs: []
  type: TYPE_NORMAL
- en: get text from real message & make each line a list item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: real_text = docx.Document('realMessageChallenge.docx')
  prefs: []
  type: TYPE_NORMAL
- en: real_list = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for paragraph in real_text.paragraphs:'
  prefs: []
  type: TYPE_NORMAL
- en: if len(paragraph.text) != 0:  # remove blank lines
  prefs: []
  type: TYPE_NORMAL
- en: real_list.append(paragraph.text)
  prefs: []
  type: TYPE_NORMAL
- en: 'define function to check available hiding space:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def line_limit(fake, real):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Compare number of blank lines in fake vs lines in real and'
  prefs: []
  type: TYPE_NORMAL
- en: warn user if there are not enough blanks to hold real message.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE:  need to import 'sys'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: num_blanks = 0
  prefs: []
  type: TYPE_NORMAL
- en: num_real = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for line in fake:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if line == '''':'
  prefs: []
  type: TYPE_NORMAL
- en: num_blanks += 1
  prefs: []
  type: TYPE_NORMAL
- en: num_real = len(real)
  prefs: []
  type: TYPE_NORMAL
- en: diff = num_real - num_blanks
  prefs: []
  type: TYPE_NORMAL
- en: print("\nNumber of blank lines in fake message = {}".format(num_blanks))
  prefs: []
  type: TYPE_NORMAL
- en: print("Number of lines in real message = {}\n".format(num_real))
  prefs: []
  type: TYPE_NORMAL
- en: 'if num_real > num_blanks:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Fake message needs {} more blank lines."
  prefs: []
  type: TYPE_NORMAL
- en: .format(diff), file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: line_limit(fake_list, real_list)
  prefs: []
  type: TYPE_NORMAL
- en: load template that sets style, font, margins, etc.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: doc = docx.Document('template.docx')
  prefs: []
  type: TYPE_NORMAL
- en: add letterhead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: doc.add_heading('Morland Holmes', 0)
  prefs: []
  type: TYPE_NORMAL
- en: subtitle = doc.add_heading('Global Consulting & Negotiations', 1)
  prefs: []
  type: TYPE_NORMAL
- en: subtitle.alignment = 1
  prefs: []
  type: TYPE_NORMAL
- en: doc.add_heading('', 1)
  prefs: []
  type: TYPE_NORMAL
- en: doc.add_paragraph('December 17, 2015')
  prefs: []
  type: TYPE_NORMAL
- en: doc.add_paragraph('')
  prefs: []
  type: TYPE_NORMAL
- en: 'def set_spacing(paragraph):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Use docx to set line spacing between paragraphs."""'
  prefs: []
  type: TYPE_NORMAL
- en: paragraph_format = paragraph.paragraph_format
  prefs: []
  type: TYPE_NORMAL
- en: paragraph_format.space_before = Pt(0)
  prefs: []
  type: TYPE_NORMAL
- en: paragraph_format.space_after = Pt(0)
  prefs: []
  type: TYPE_NORMAL
- en: length_real = len(real_list)
  prefs: []
  type: TYPE_NORMAL
- en: count_real = 0  # index of current line in real (hidden) message
  prefs: []
  type: TYPE_NORMAL
- en: interleave real and fake message lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for line in fake_list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if count_real < length_real and line == "":'
  prefs: []
  type: TYPE_NORMAL
- en: paragraph = doc.add_paragraph(real_list[count_real])
  prefs: []
  type: TYPE_NORMAL
- en: paragraph_index = len(doc.paragraphs) - 1
  prefs: []
  type: TYPE_NORMAL
- en: '# set real message color to white'
  prefs: []
  type: TYPE_NORMAL
- en: run = doc.paragraphs[paragraph_index].runs[0]
  prefs: []
  type: TYPE_NORMAL
- en: font = run.font
  prefs: []
  type: TYPE_NORMAL
- en: font.color.rgb = RGBColor(255, 255, 255)  # make it red to test
  prefs: []
  type: TYPE_NORMAL
- en: count_real += 1
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: paragraph = doc.add_paragraph(line)
  prefs: []
  type: TYPE_NORMAL
- en: set_spacing(paragraph)
  prefs: []
  type: TYPE_NORMAL
- en: doc.save('ciphertext_message_letterhead.docx')
  prefs: []
  type: TYPE_NORMAL
- en: print("Done"))
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 8: Counting Syllables for Haiku Poetry**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***Syllable Counter vs. Dictionary File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*test_count_syllables_w_dict.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Load a dictionary file, pick random words, run syllable-counting module."""'
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: from count_syllables import count_syllables
  prefs: []
  type: TYPE_NORMAL
- en: 'def load(file):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Open a text file & return list of lowercase strings."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(file) as in_file:'
  prefs: []
  type: TYPE_NORMAL
- en: loaded_txt = in_file.read().strip().split('\n')
  prefs: []
  type: TYPE_NORMAL
- en: loaded_txt = [x.lower() for x in loaded_txt]
  prefs: []
  type: TYPE_NORMAL
- en: return loaded_txt
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: word_list = load('2of4brif.txt')
  prefs: []
  type: TYPE_NORMAL
- en: 'except IOError as e:'
  prefs: []
  type: TYPE_NORMAL
- en: print("{}\nError opening file. Terminating program.".format(e),
  prefs: []
  type: TYPE_NORMAL
- en: file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit(1)
  prefs: []
  type: TYPE_NORMAL
- en: test_data = []
  prefs: []
  type: TYPE_NORMAL
- en: num_words = 100
  prefs: []
  type: TYPE_NORMAL
- en: test_data.extend(random.sample(word_list, num_words))
  prefs: []
  type: TYPE_NORMAL
- en: 'for word in test_data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: num_syllables = count_syllables(word)
  prefs: []
  type: TYPE_NORMAL
- en: print(word, num_syllables, end='\n')
  prefs: []
  type: TYPE_NORMAL
- en: 'except KeyError:'
  prefs: []
  type: TYPE_NORMAL
- en: print(word, end='')
  prefs: []
  type: TYPE_NORMAL
- en: print(" not found", file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 10: Are We Alone? Exploring the Fermi Paradox**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***A Galaxy Far, Far Away***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*galaxy_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Use spiral formula to build galaxy display."""'
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: from random import randint
  prefs: []
  type: TYPE_NORMAL
- en: import tkinter
  prefs: []
  type: TYPE_NORMAL
- en: root = tkinter.Tk()
  prefs: []
  type: TYPE_NORMAL
- en: root.title("Galaxy BR549")
  prefs: []
  type: TYPE_NORMAL
- en: c = tkinter.Canvas(root, width=1000, height=800, bg='black')
  prefs: []
  type: TYPE_NORMAL
- en: c.grid()
  prefs: []
  type: TYPE_NORMAL
- en: c.configure(scrollregion=(-500, -400, 500, 400))
  prefs: []
  type: TYPE_NORMAL
- en: oval_size = 0
  prefs: []
  type: TYPE_NORMAL
- en: build spiral arms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: num_spiral_stars = 500
  prefs: []
  type: TYPE_NORMAL
- en: angle = 3.5
  prefs: []
  type: TYPE_NORMAL
- en: core_diameter = 120
  prefs: []
  type: TYPE_NORMAL
- en: spiral_stars = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(num_spiral_stars):'
  prefs: []
  type: TYPE_NORMAL
- en: theta = i * angle
  prefs: []
  type: TYPE_NORMAL
- en: r = math.sqrt(i) / math.sqrt(num_spiral_stars)
  prefs: []
  type: TYPE_NORMAL
- en: spiral_stars.append((r * math.cos(theta), r * math.sin(theta)))
  prefs: []
  type: TYPE_NORMAL
- en: 'for x, y in spiral_stars:'
  prefs: []
  type: TYPE_NORMAL
- en: x = x * 350 + randint(-5, 3)
  prefs: []
  type: TYPE_NORMAL
- en: y = y * 350 + randint(-5, 3)
  prefs: []
  type: TYPE_NORMAL
- en: oval_size = randint(1, 3)
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x-oval_size, y-oval_size, x+oval_size, y+oval_size,
  prefs: []
  type: TYPE_NORMAL
- en: fill='white', outline='')
  prefs: []
  type: TYPE_NORMAL
- en: build wisps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: wisps = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(2000):'
  prefs: []
  type: TYPE_NORMAL
- en: theta = i * angle
  prefs: []
  type: TYPE_NORMAL
- en: '# divide by num_spiral_stars for better dust lanes'
  prefs: []
  type: TYPE_NORMAL
- en: r = math.sqrt(i) / math.sqrt(num_spiral_stars)
  prefs: []
  type: TYPE_NORMAL
- en: spiral_stars.append((r * math.cos(theta), r * math.sin(theta)))
  prefs: []
  type: TYPE_NORMAL
- en: 'for x, y in spiral_stars:'
  prefs: []
  type: TYPE_NORMAL
- en: x = x * 330 + randint(-15, 10)
  prefs: []
  type: TYPE_NORMAL
- en: y = y * 330 + randint(-15, 10)
  prefs: []
  type: TYPE_NORMAL
- en: h = math.sqrt(x**2 + y**2)
  prefs: []
  type: TYPE_NORMAL
- en: 'if h < 350:'
  prefs: []
  type: TYPE_NORMAL
- en: wisps.append((x, y))
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x-1, y-1, x+1, y+1, fill='white', outline='')
  prefs: []
  type: TYPE_NORMAL
- en: build galactic core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: core = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(900):'
  prefs: []
  type: TYPE_NORMAL
- en: x = randint(-core_diameter, core_diameter)
  prefs: []
  type: TYPE_NORMAL
- en: y = randint(-core_diameter, core_diameter)
  prefs: []
  type: TYPE_NORMAL
- en: h = math.sqrt(x**2 + y**2)
  prefs: []
  type: TYPE_NORMAL
- en: 'if h < core_diameter - 70:'
  prefs: []
  type: TYPE_NORMAL
- en: core.append((x, y))
  prefs: []
  type: TYPE_NORMAL
- en: oval_size = randint(2, 4)
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x-oval_size, y-oval_size, x+oval_size, y+oval_size,
  prefs: []
  type: TYPE_NORMAL
- en: fill='white', outline='')
  prefs: []
  type: TYPE_NORMAL
- en: 'elif h < core_diameter:'
  prefs: []
  type: TYPE_NORMAL
- en: core.append((x, y))
  prefs: []
  type: TYPE_NORMAL
- en: oval_size = randint(0, 2)
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x-oval_size, y-oval_size, x+oval_size, y+oval_size,
  prefs: []
  type: TYPE_NORMAL
- en: fill='white', outline='')
  prefs: []
  type: TYPE_NORMAL
- en: root.mainloop()
  prefs: []
  type: TYPE_NORMAL
- en: '***Building a Galactic Empire***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*empire_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Build 2-D model of galaxy, post expansion rings for galactic empire."""'
  prefs: []
  type: TYPE_NORMAL
- en: import tkinter as tk
  prefs: []
  type: TYPE_NORMAL
- en: import time
  prefs: []
  type: TYPE_NORMAL
- en: from random import randint, uniform, random
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: '#============================================================================='
  prefs: []
  type: TYPE_NORMAL
- en: MAIN INPUT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'location of galactic empire homeworld on map:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HOMEWORLD_LOC = (0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: 'maximum number of years to simulate:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MAX_YEARS = 10000000
  prefs: []
  type: TYPE_NORMAL
- en: 'average expansion velocity as fraction of speed of light:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SPEED = 0.005
  prefs: []
  type: TYPE_NORMAL
- en: scale units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UNIT = 200
  prefs: []
  type: TYPE_NORMAL
- en: '#======================================================================'
  prefs: []
  type: TYPE_NORMAL
- en: set up display canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: root = tk.Tk()
  prefs: []
  type: TYPE_NORMAL
- en: root.title("Milky Way galaxy")
  prefs: []
  type: TYPE_NORMAL
- en: c = tk.Canvas(root, width=1000, height=800, bg='black')
  prefs: []
  type: TYPE_NORMAL
- en: c.grid()
  prefs: []
  type: TYPE_NORMAL
- en: c.configure(scrollregion=(-500, -400, 500, 400))
  prefs: []
  type: TYPE_NORMAL
- en: actual Milky Way dimensions (light-years)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DISC_RADIUS = 50000
  prefs: []
  type: TYPE_NORMAL
- en: disc_radius_scaled = round(DISC_RADIUS/UNIT)
  prefs: []
  type: TYPE_NORMAL
- en: 'def polar_coordinates():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Generate uniform random x,y point within a disc for 2-D display."""'
  prefs: []
  type: TYPE_NORMAL
- en: r = random()
  prefs: []
  type: TYPE_NORMAL
- en: theta = uniform(0, 2 * math.pi)
  prefs: []
  type: TYPE_NORMAL
- en: x = round(math.sqrt(r) * math.cos(theta) * disc_radius_scaled)
  prefs: []
  type: TYPE_NORMAL
- en: y = round(math.sqrt(r) * math.sin(theta) * disc_radius_scaled)
  prefs: []
  type: TYPE_NORMAL
- en: return x, y
  prefs: []
  type: TYPE_NORMAL
- en: 'def spirals(b, r, rot_fac, fuz_fac, arm):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Build spiral arms for tkinter display using Logarithmic spiral formula.'
  prefs: []
  type: TYPE_NORMAL
- en: b = arbitrary constant in logarithmic spiral equation
  prefs: []
  type: TYPE_NORMAL
- en: r = scaled galactic disc radius
  prefs: []
  type: TYPE_NORMAL
- en: rot_fac = rotation factor
  prefs: []
  type: TYPE_NORMAL
- en: fuz_fac = random shift in star position in arm, applied to 'fuzz' variable
  prefs: []
  type: TYPE_NORMAL
- en: arm = spiral arm (0 = main arm, 1 = trailing stars)
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: spiral_stars = []
  prefs: []
  type: TYPE_NORMAL
- en: fuzz = int(0.030 * abs(r))  # randomly shift star locations
  prefs: []
  type: TYPE_NORMAL
- en: theta_max_degrees = 520
  prefs: []
  type: TYPE_NORMAL
- en: for i in range(theta_max_degrees):  # range(0, 700, 2) for no black hole
  prefs: []
  type: TYPE_NORMAL
- en: theta = math.radians(i)
  prefs: []
  type: TYPE_NORMAL
- en: x = r * math.exp(b*theta) * math.cos(theta + math.pi * rot_fac)\
  prefs: []
  type: TYPE_NORMAL
- en: + randint(-fuzz, fuzz) * fuz_fac
  prefs: []
  type: TYPE_NORMAL
- en: y = r * math.exp(b*theta) * math.sin(theta + math.pi * rot_fac)\
  prefs: []
  type: TYPE_NORMAL
- en: + randint(-fuzz, fuzz) * fuz_fac
  prefs: []
  type: TYPE_NORMAL
- en: spiral_stars.append((x, y))
  prefs: []
  type: TYPE_NORMAL
- en: 'for x, y in spiral_stars:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if arm == 0 and int(x % 2) == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x-2, y-2, x+2, y+2, fill='white', outline='')
  prefs: []
  type: TYPE_NORMAL
- en: 'elif arm == 0 and int(x % 2) != 0:'
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x-1, y-1, x+1, y+1, fill='white', outline='')
  prefs: []
  type: TYPE_NORMAL
- en: 'elif arm == 1:'
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x, y, x, y, fill='white', outline='')
  prefs: []
  type: TYPE_NORMAL
- en: 'def star_haze(scalar):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Randomly distribute faint tkinter stars in galactic disc.'
  prefs: []
  type: TYPE_NORMAL
- en: disc_radius_scaled = galactic disc radius scaled to radio bubble diameter
  prefs: []
  type: TYPE_NORMAL
- en: scalar = multiplier to vary number of stars posted
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, disc_radius_scaled * scalar):'
  prefs: []
  type: TYPE_NORMAL
- en: x, y = polar_coordinates()
  prefs: []
  type: TYPE_NORMAL
- en: c.create_text(x, y, fill='white', font=('Helvetica', '7'), text='.')
  prefs: []
  type: TYPE_NORMAL
- en: 'def model_expansion():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Model empire expansion from homeworld with concentric rings."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'r = 0 # radius from homeworld'
  prefs: []
  type: TYPE_NORMAL
- en: text_y_loc = -290
  prefs: []
  type: TYPE_NORMAL
- en: x, y = HOMEWORLD_LOC
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x-5, y-5, x+5, y+5, fill='red')
  prefs: []
  type: TYPE_NORMAL
- en: increment = round(MAX_YEARS / 10)# year interval to post circles
  prefs: []
  type: TYPE_NORMAL
- en: c.create_text(-475, -350, anchor='w', fill='red', text='Increment = {:,}'
  prefs: []
  type: TYPE_NORMAL
- en: .format(increment))
  prefs: []
  type: TYPE_NORMAL
- en: c.create_text(-475, -325, anchor='w', fill='red',
  prefs: []
  type: TYPE_NORMAL
- en: text='Velocity as fraction of Light = {:,}'.format(SPEED))
  prefs: []
  type: TYPE_NORMAL
- en: 'for years in range(increment, MAX_YEARS + 1, increment):'
  prefs: []
  type: TYPE_NORMAL
- en: 'time.sleep(0.5) # delay before posting new expansion circle'
  prefs: []
  type: TYPE_NORMAL
- en: traveled = SPEED * increment / UNIT
  prefs: []
  type: TYPE_NORMAL
- en: r = r + traveled
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x-r, y-r, x+r, y+r, fill='', outline='red', width='2')
  prefs: []
  type: TYPE_NORMAL
- en: c.create_text(-475, text_y_loc, anchor='w', fill='red',
  prefs: []
  type: TYPE_NORMAL
- en: text='Years = {:,}'.format(years))
  prefs: []
  type: TYPE_NORMAL
- en: text_y_loc += 20
  prefs: []
  type: TYPE_NORMAL
- en: '# update canvas for new circle; no longer need mainloop()'
  prefs: []
  type: TYPE_NORMAL
- en: c.update_idletasks()
  prefs: []
  type: TYPE_NORMAL
- en: c.update()
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Generate galaxy display, model empire expansion, run mainloop."""'
  prefs: []
  type: TYPE_NORMAL
- en: spirals(b=-0.3, r=disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)
  prefs: []
  type: TYPE_NORMAL
- en: spirals(b=-0.3, r=disc_radius_scaled, rot_fac=1.91, fuz_fac=1.5, arm=1)
  prefs: []
  type: TYPE_NORMAL
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)
  prefs: []
  type: TYPE_NORMAL
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-2.09, fuz_fac=1.5, arm=1)
  prefs: []
  type: TYPE_NORMAL
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.5, fuz_fac=1.5, arm=0)
  prefs: []
  type: TYPE_NORMAL
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.4, fuz_fac=1.5, arm=1)
  prefs: []
  type: TYPE_NORMAL
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.5, fuz_fac=1.5, arm=0)
  prefs: []
  type: TYPE_NORMAL
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.6, fuz_fac=1.5, arm=1)
  prefs: []
  type: TYPE_NORMAL
- en: star_haze(scalar=9)
  prefs: []
  type: TYPE_NORMAL
- en: model_expansion()
  prefs: []
  type: TYPE_NORMAL
- en: '# run tkinter loop'
  prefs: []
  type: TYPE_NORMAL
- en: root.mainloop()
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: '***A Roundabout Way to Predict Detectability***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*rounded_detection_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate probability of detecting 32 LY-diameter radio bubble given 15.6
    M'
  prefs: []
  type: TYPE_NORMAL
- en: randomly distributed civilizations in the galaxy."""
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: from random import uniform, random
  prefs: []
  type: TYPE_NORMAL
- en: from collections import Counter
  prefs: []
  type: TYPE_NORMAL
- en: length units in light-years
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DISC_RADIUS = 50000
  prefs: []
  type: TYPE_NORMAL
- en: DISC_HEIGHT = 1000
  prefs: []
  type: TYPE_NORMAL
- en: NUM_CIVS = 15600000
  prefs: []
  type: TYPE_NORMAL
- en: DETECTION_RADIUS = 16
  prefs: []
  type: TYPE_NORMAL
- en: 'def random_polar_coordinates_xyz():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Generate uniform random xyz point within a 3D disc."""'
  prefs: []
  type: TYPE_NORMAL
- en: r = random()
  prefs: []
  type: TYPE_NORMAL
- en: theta = uniform(0, 2 * math.pi)
  prefs: []
  type: TYPE_NORMAL
- en: x = round(math.sqrt(r) * math.cos(theta) * DISC_RADIUS, 3)
  prefs: []
  type: TYPE_NORMAL
- en: y = round(math.sqrt(r) * math.sin(theta) * DISC_RADIUS, 3)
  prefs: []
  type: TYPE_NORMAL
- en: z = round(uniform(0, DISC_HEIGHT), 3)
  prefs: []
  type: TYPE_NORMAL
- en: return x, y, z
  prefs: []
  type: TYPE_NORMAL
- en: 'def rounded(n, base):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Round a number to the nearest number designated by base parameter."""'
  prefs: []
  type: TYPE_NORMAL
- en: return int(round(n/base) * base)
  prefs: []
  type: TYPE_NORMAL
- en: 'def distribute_civs():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Distribute xyz locations in galactic disc model and return list."""'
  prefs: []
  type: TYPE_NORMAL
- en: civ_locs = []
  prefs: []
  type: TYPE_NORMAL
- en: 'while len(civ_locs) < NUM_CIVS:'
  prefs: []
  type: TYPE_NORMAL
- en: loc = random_polar_coordinates_xyz()
  prefs: []
  type: TYPE_NORMAL
- en: civ_locs.append(loc)
  prefs: []
  type: TYPE_NORMAL
- en: return civ_locs
  prefs: []
  type: TYPE_NORMAL
- en: 'def round_civ_locs(civ_locs):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Round xyz locations and return list of rounded locations."""'
  prefs: []
  type: TYPE_NORMAL
- en: '# convert radius to cubic dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: detect_distance = round((4 / 3 * math.pi * DETECTION_RADIUS**3)**(1/3))
  prefs: []
  type: TYPE_NORMAL
- en: print("\ndetection radius = {} LY".format(DETECTION_RADIUS))
  prefs: []
  type: TYPE_NORMAL
- en: print("cubic detection distance = {} LY".format(detect_distance))
  prefs: []
  type: TYPE_NORMAL
- en: '# round civilization xyz to detection distance'
  prefs: []
  type: TYPE_NORMAL
- en: civ_locs_rounded = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for x, y, z in civ_locs:'
  prefs: []
  type: TYPE_NORMAL
- en: i = rounded(x, detect_distance)
  prefs: []
  type: TYPE_NORMAL
- en: j = rounded(y, detect_distance)
  prefs: []
  type: TYPE_NORMAL
- en: k = rounded(z, detect_distance)
  prefs: []
  type: TYPE_NORMAL
- en: civ_locs_rounded.append((i, j, k))
  prefs: []
  type: TYPE_NORMAL
- en: return civ_locs_rounded
  prefs: []
  type: TYPE_NORMAL
- en: 'def calc_prob_of_detection(civ_locs_rounded):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Count locations and calculate probability of duplicate values."""'
  prefs: []
  type: TYPE_NORMAL
- en: overlap_count = Counter(civ_locs_rounded)
  prefs: []
  type: TYPE_NORMAL
- en: overlap_rollup = Counter(overlap_count.values())
  prefs: []
  type: TYPE_NORMAL
- en: num_single_civs = overlap_rollup[1]
  prefs: []
  type: TYPE_NORMAL
- en: prob = 1 - (num_single_civs / NUM_CIVS)
  prefs: []
  type: TYPE_NORMAL
- en: return overlap_rollup, prob
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Call functions and print results."""'
  prefs: []
  type: TYPE_NORMAL
- en: civ_locs = distribute_civs()
  prefs: []
  type: TYPE_NORMAL
- en: civ_locs_rounded = round_civ_locs(civ_locs)
  prefs: []
  type: TYPE_NORMAL
- en: overlap_rollup, detection_prob = calc_prob_of_detection(civ_locs_rounded)
  prefs: []
  type: TYPE_NORMAL
- en: print("length pre-rounded civ_locs = {}".format(len(civ_locs)))
  prefs: []
  type: TYPE_NORMAL
- en: print("length of rounded civ_locs_rounded = {}".format(len(civ_locs_rounded)))
  prefs: []
  type: TYPE_NORMAL
- en: print("overlap_rollup = {}\n".format(overlap_rollup))
  prefs: []
  type: TYPE_NORMAL
- en: print("probability of detection = {0:.3f}".format(detection_prob))
  prefs: []
  type: TYPE_NORMAL
- en: '# QC step to check rounding'
  prefs: []
  type: TYPE_NORMAL
- en: print("\nFirst 3 locations pre- and post-rounding:\n")
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("pre-round: {}".format(civ_locs[i]))'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("post-round: {} \n".format(civ_locs_rounded[i]))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 11: The Monty Hall Problem**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***The Birthday Paradox***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*birthday_paradox_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate probability of a shared birthday per x number of people."""'
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: max_people = 50
  prefs: []
  type: TYPE_NORMAL
- en: num_runs = 2000
  prefs: []
  type: TYPE_NORMAL
- en: print("\nProbability of at least 2 people having the same birthday:\n")
  prefs: []
  type: TYPE_NORMAL
- en: 'for people in range(2, max_people + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: found_shared = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for run in range(num_runs):'
  prefs: []
  type: TYPE_NORMAL
- en: bdays = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, people):'
  prefs: []
  type: TYPE_NORMAL
- en: bday = random.randrange(0, 365)  # ignore leap years
  prefs: []
  type: TYPE_NORMAL
- en: bdays.append(bday)
  prefs: []
  type: TYPE_NORMAL
- en: set_of_bdays = set(bdays)
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(set_of_bdays) < len(bdays):'
  prefs: []
  type: TYPE_NORMAL
- en: found_shared += 1
  prefs: []
  type: TYPE_NORMAL
- en: prob = found_shared/num_runs
  prefs: []
  type: TYPE_NORMAL
- en: print("Number people = {} Prob = {:.4f}".format(people, prob))
  prefs: []
  type: TYPE_NORMAL
- en: print("""
  prefs: []
  type: TYPE_NORMAL
- en: According to the Birthday Paradox, if there are 23 people in a room,
  prefs: []
  type: TYPE_NORMAL
- en: there's a 50% chance that 2 of them will share the same birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '""")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 13: Simulating an Alien Volcano**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***Going the Distance***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*practice_45.py*'
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import math
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: import pygame as pg
  prefs: []
  type: TYPE_NORMAL
- en: pg.init()  # initialize pygame
  prefs: []
  type: TYPE_NORMAL
- en: define color table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: WHITE = (255, 255, 255)
  prefs: []
  type: TYPE_NORMAL
- en: LT_GRAY = (180, 180, 180)
  prefs: []
  type: TYPE_NORMAL
- en: GRAY = (120, 120, 120)
  prefs: []
  type: TYPE_NORMAL
- en: DK_GRAY = (80, 80, 80)
  prefs: []
  type: TYPE_NORMAL
- en: 'class Particle(pg.sprite.Sprite):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Builds ejecta particles for volcano simulation."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'gases_colors = {''SO2'': LT_GRAY, ''CO2'': GRAY, ''H2S'': DK_GRAY, ''H2O'':
    WHITE}'
  prefs: []
  type: TYPE_NORMAL
- en: VENT_LOCATION_XY = (320, 300)
  prefs: []
  type: TYPE_NORMAL
- en: IO_SURFACE_Y = 308
  prefs: []
  type: TYPE_NORMAL
- en: GRAVITY = 0.5  # pixels-per-frame
  prefs: []
  type: TYPE_NORMAL
- en: VELOCITY_SO2 = 8  # pixels-per-frame
  prefs: []
  type: TYPE_NORMAL
- en: '# scalars (SO2 atomic weight/particle atomic weight) used for velocity'
  prefs: []
  type: TYPE_NORMAL
- en: 'vel_scalar = {''SO2'': 1, ''CO2'': 1.45, ''H2S'': 1.9, ''H2O'': 3.6}'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, screen, background):'
  prefs: []
  type: TYPE_NORMAL
- en: super().__init__()
  prefs: []
  type: TYPE_NORMAL
- en: self.screen = screen
  prefs: []
  type: TYPE_NORMAL
- en: self.background = background
  prefs: []
  type: TYPE_NORMAL
- en: self.image = pg.Surface((4, 4))
  prefs: []
  type: TYPE_NORMAL
- en: self.rect = self.image.get_rect()
  prefs: []
  type: TYPE_NORMAL
- en: self.gas = 'SO2'
  prefs: []
  type: TYPE_NORMAL
- en: self.color = ''
  prefs: []
  type: TYPE_NORMAL
- en: self.vel = Particle.VELOCITY_SO2 * Particle.vel_scalar[self.gas]
  prefs: []
  type: TYPE_NORMAL
- en: self.x, self.y = Particle.VENT_LOCATION_XY
  prefs: []
  type: TYPE_NORMAL
- en: self.vector()
  prefs: []
  type: TYPE_NORMAL
- en: 'def vector(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Calculate particle vector at launch."""'
  prefs: []
  type: TYPE_NORMAL
- en: angles = [65, 55, 45, 35, 25]  # 90 is vertical
  prefs: []
  type: TYPE_NORMAL
- en: orient = random.choice(angles)
  prefs: []
  type: TYPE_NORMAL
- en: 'if orient == 45:'
  prefs: []
  type: TYPE_NORMAL
- en: self.color = WHITE
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: self.color = GRAY
  prefs: []
  type: TYPE_NORMAL
- en: radians = math.radians(orient)
  prefs: []
  type: TYPE_NORMAL
- en: self.dx = self.vel * math.cos(radians)
  prefs: []
  type: TYPE_NORMAL
- en: self.dy = -self.vel * math.sin(radians)  # negative as y increases down
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Apply gravity, draw path, and handle boundary conditions."""'
  prefs: []
  type: TYPE_NORMAL
- en: self.dy += Particle.GRAVITY
  prefs: []
  type: TYPE_NORMAL
- en: pg.draw.line(self.background, self.color, (self.x, self.y),
  prefs: []
  type: TYPE_NORMAL
- en: (self.x + self.dx, self.y + self.dy))
  prefs: []
  type: TYPE_NORMAL
- en: self.x += self.dx
  prefs: []
  type: TYPE_NORMAL
- en: self.y += self.dy
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.x < 0 or self.x > self.screen.get_width():'
  prefs: []
  type: TYPE_NORMAL
- en: self.kill()
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.y < 0 or self.y > Particle.IO_SURFACE_Y:'
  prefs: []
  type: TYPE_NORMAL
- en: self.kill()
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Set up and run game screen and loop."""'
  prefs: []
  type: TYPE_NORMAL
- en: screen = pg.display.set_mode((639, 360))
  prefs: []
  type: TYPE_NORMAL
- en: pg.display.set_caption("Io Volcano Simulator")
  prefs: []
  type: TYPE_NORMAL
- en: background = pg.image.load("tvashtar_plume.gif")
  prefs: []
  type: TYPE_NORMAL
- en: '# Set up color-coded legend'
  prefs: []
  type: TYPE_NORMAL
- en: legend_font = pg.font.SysFont('None', 26)
  prefs: []
  type: TYPE_NORMAL
- en: text = legend_font.render('White = 45 degrees', True, WHITE, BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: particles = pg.sprite.Group()
  prefs: []
  type: TYPE_NORMAL
- en: clock = pg.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: clock.tick(25)
  prefs: []
  type: TYPE_NORMAL
- en: particles.add(Particle(screen, background))
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in pg.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pg.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pg.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: screen.blit(background, (0, 0))
  prefs: []
  type: TYPE_NORMAL
- en: screen.blit(text, (320, 170))
  prefs: []
  type: TYPE_NORMAL
- en: particles.update()
  prefs: []
  type: TYPE_NORMAL
- en: particles.draw(screen)
  prefs: []
  type: TYPE_NORMAL
- en: pg.display.flip()
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter 16: Finding Frauds with Benford’s Law**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '***Beating Benford***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*beat_benford_practice.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Manipulate vote counts so that final results conform to Benford''s law."""'
  prefs: []
  type: TYPE_NORMAL
- en: example below is for Trump vs. Clinton, Illinois, 2016 Presidental Election
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def load_data(filename):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Open a text file of numbers & turn contents into a list of integers."""'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(filename) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: lines = f.read().strip().split('\n')
  prefs: []
  type: TYPE_NORMAL
- en: return [int(i) for i in lines]  # turn strings to integers
  prefs: []
  type: TYPE_NORMAL
- en: 'def steal_votes(opponent_votes, candidate_votes, scalar):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Use scalar to reduce one vote count & increase another, return as lists.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: opponent_votes – votes to steal from
  prefs: []
  type: TYPE_NORMAL
- en: candidate_votes - votes to increase by stolen amount
  prefs: []
  type: TYPE_NORMAL
- en: scalar - fractional percentage, < 1, used to reduce votes
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: list of changed opponent votes
  prefs: []
  type: TYPE_NORMAL
- en: list of changed candidate votes
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: new_opponent_votes = []
  prefs: []
  type: TYPE_NORMAL
- en: new_candidate_votes = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for opp_vote, can_vote in zip(opponent_votes, candidate_votes):'
  prefs: []
  type: TYPE_NORMAL
- en: new_opp_vote = round(opp_vote * scalar)
  prefs: []
  type: TYPE_NORMAL
- en: new_opponent_votes.append(new_opp_vote)
  prefs: []
  type: TYPE_NORMAL
- en: stolen_votes = opp_vote - new_opp_vote
  prefs: []
  type: TYPE_NORMAL
- en: new_can_vote = can_vote + stolen_votes
  prefs: []
  type: TYPE_NORMAL
- en: new_candidate_votes.append(new_can_vote)
  prefs: []
  type: TYPE_NORMAL
- en: return new_opponent_votes, new_candidate_votes
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Run the program.'
  prefs: []
  type: TYPE_NORMAL
- en: Load data, set target winning vote count, call functions, display
  prefs: []
  type: TYPE_NORMAL
- en: results as table, write new combined vote total as text file to
  prefs: []
  type: TYPE_NORMAL
- en: use as input for Benford's law analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: '# load vote data'
  prefs: []
  type: TYPE_NORMAL
- en: c_votes = load_data('Clinton_votes_Illinois.txt')
  prefs: []
  type: TYPE_NORMAL
- en: j_votes = load_data('Johnson_votes_Illinois.txt')
  prefs: []
  type: TYPE_NORMAL
- en: s_votes = load_data('Stein_votes_Illinois.txt')
  prefs: []
  type: TYPE_NORMAL
- en: t_votes = load_data('Trump_votes_Illinois.txt')
  prefs: []
  type: TYPE_NORMAL
- en: total_votes = sum(c_votes + j_votes + s_votes + t_votes)
  prefs: []
  type: TYPE_NORMAL
- en: '# assume Trump amasses a plurality of the vote with 49%'
  prefs: []
  type: TYPE_NORMAL
- en: t_target = round(total_votes * 0.49)
  prefs: []
  type: TYPE_NORMAL
- en: print("\nTrump winning target = {:,} votes".format(t_target))
  prefs: []
  type: TYPE_NORMAL
- en: '# calculate extra votes needed for Trump victory'
  prefs: []
  type: TYPE_NORMAL
- en: extra_votes_needed = abs(t_target - sum(t_votes))
  prefs: []
  type: TYPE_NORMAL
- en: print("extra votes needed = {:,}".format(extra_votes_needed))
  prefs: []
  type: TYPE_NORMAL
- en: '# calculate scalar needed to generate extra votes'
  prefs: []
  type: TYPE_NORMAL
- en: scalar = 1 - (extra_votes_needed / sum(c_votes + j_votes + s_votes))
  prefs: []
  type: TYPE_NORMAL
- en: print("scalar = {:.3}".format(scalar))
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '# flip vote counts based on scalar & build new combined list of votes'
  prefs: []
  type: TYPE_NORMAL
- en: fake_counts = []
  prefs: []
  type: TYPE_NORMAL
- en: new_c_votes, new_t_votes = steal_votes(c_votes, t_votes, scalar)
  prefs: []
  type: TYPE_NORMAL
- en: fake_counts.extend(new_c_votes)
  prefs: []
  type: TYPE_NORMAL
- en: new_j_votes, new_t_votes = steal_votes(j_votes, new_t_votes, scalar)
  prefs: []
  type: TYPE_NORMAL
- en: fake_counts.extend(new_j_votes)
  prefs: []
  type: TYPE_NORMAL
- en: new_s_votes, new_t_votes = steal_votes(s_votes, new_t_votes, scalar)
  prefs: []
  type: TYPE_NORMAL
- en: fake_counts.extend(new_s_votes)
  prefs: []
  type: TYPE_NORMAL
- en: fake_counts.extend(new_t_votes)  # add last as has been changing up til now
  prefs: []
  type: TYPE_NORMAL
- en: '# compare old and new vote counts & totals in tabular form'
  prefs: []
  type: TYPE_NORMAL
- en: '# switch-out "Trump" and "Clinton" as necessary'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(0, len(t_votes)):'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("old Trump: {} \t new Trump: {} \t old Clinton: {} \t " \'
  prefs: []
  type: TYPE_NORMAL
- en: '"new Clinton: {}".'
  prefs: []
  type: TYPE_NORMAL
- en: format(t_votes[i], new_t_votes[i], c_votes[i], new_c_votes[i]))
  prefs: []
  type: TYPE_NORMAL
- en: print("-" * 95)
  prefs: []
  type: TYPE_NORMAL
- en: print("TOTALS:")
  prefs: []
  type: TYPE_NORMAL
- en: 'print("old Trump: {:,} \t new Trump: {:,} \t old Clinton: {:,}  " \'
  prefs: []
  type: TYPE_NORMAL
- en: '"new Clinton: {:,}".format(sum(t_votes), sum(new_t_votes),'
  prefs: []
  type: TYPE_NORMAL
- en: sum(c_votes), sum(new_c_votes)))
  prefs: []
  type: TYPE_NORMAL
- en: '# write out a text file to use as input to benford.py program'
  prefs: []
  type: TYPE_NORMAL
- en: '# this program will check conformance of faked votes to Benford''s law'
  prefs: []
  type: TYPE_NORMAL
- en: 'with open(''fake_Illinois_counts.txt'', ''w'') as f:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for count in fake_counts:'
  prefs: []
  type: TYPE_NORMAL
- en: f.write("{}\n".format(count))
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
