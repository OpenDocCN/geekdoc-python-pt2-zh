["```py\nLRUCache {\n    HashTable: ht\n    Queue: q\n    Integer: max_size\n    Integer: current_size\n }\n```", "```py\nCacheEntry {\n    Type: key\n    Type: value\n    QueueListNode: node\n}\n```", "```py\nCacheLookup(LRUCache: cache, Type: key):\n  ❶ CacheEntry: entry = HashTableLookup(cache.ht, key)\n\n    IF entry == null:\n      ❷ IF cache.current_size >= cache.max_size:\n            Type: key_to_remove = Dequeue(cache.q)\n            HashTableRemove(cache.ht, key_to_remove)\n            cache.current_size = cache.current_size - 1\n\n      ❸ Type: data = retrieve data for the key from \n                     the slow data source.\n\n      ❹ Enqueue(cache.q, key)\n        entry = CacheEntry(key, data, cache.q.back)\n      ❺ HashTableInsert(cache.ht, key, entry)\n        cache.current_size = cache.current_size + 1\n    ELSE:\n        # Reset this key's location in the queue.\n ❻ RemoveNode(cache.q, entry.node)\n      ❼ Enqueue(cache.q, key)\n\n        # Update the CacheEntry's pointer.\n      ❽ entry.node = cache.q.back\n    return entry.value\n```", "```py\nQueueListNode {\n    Type: value\n    QueueListNode: next\n    QueueListNode: prev\n}\n```", "```py\nEnqueue(Queue: q, Type: value):\n    QueueListNode: node = QueueListNode(value)\n    IF q.back == null:\n        q.front = node\n        q.back = node\n    ELSE:\n        q.back.next = node\n      ❶ node.prev = q.back\n        q.back = node\n```", "```py\nDequeue(Queue: q):\n    IF q.front == null:\n        return null\n\n    Type: value = q.front.value\n    q.front = q.front.next\n    IF q.front == null:\n        q.back = null\n    ELSE:\n      ❶ q.front.prev = null\n    return value\n```", "```py\nRemoveNode(Queue: q, QueueListNode: node):\n    IF node.prev != null:\n        node.prev.next = node.next\n    IF node.next != null:\n        node.next.prev = node.prev\n    IF node == q.front:\n       q.front = q.front.next\n    IF node == q.back:\n       q.back = q.back.prev\n```"]