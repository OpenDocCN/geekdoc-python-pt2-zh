- en: '1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SAVING SHIPWRECKED SAILORS WITH BAYES’ RULE
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sometime around 1740, an English Presbyterian minister named Thomas Bayes decided
    to mathematically prove the existence of God. His ingenious solution, now known
    as *Bayes’ rule*, would become one of the most successful statistical concepts
    of all time. But for 200 years it languished, largely ignored, because its tedious
    mathematics were impractical to do by hand. It took the invention of the modern
    computer for Bayes’ rule to reach its full potential. Now, thanks to our fast
    processors, it forms a key component of data science and machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: Because Bayes’ rule shows us the mathematically correct way to incorporate new
    data and recalculate probability estimates, it penetrates almost all human endeavors,
    from cracking codes to picking presidential winners to demonstrating that high
    cholesterol causes heart attacks. A list of applications of Bayes’ rule could
    easily fill this chapter. But since nothing is more important than saving lives,
    we’ll focus on the use of Bayes’ rule to help save sailors lost at sea.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll create a simulation game for a Coast Guard search and
    rescue effort. Players will use Bayes’ rule to guide their decisions so they can
    locate the sailor as quickly as possible. In the process, you’ll start working
    with popular computer vision and data science tools like Open Source Computer
    Vision Library (OpenCV) and NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bayes’ Rule**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bayes’ rule helps investigators determine the probability that something is
    true given new evidence. As the great French mathematician Laplace put it, “The
    probability of a cause—given an event—is proportional to the probability of the
    event—given its cause.” The basic formula is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_2_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *A* is a hypothesis and *B* is data. *P*(*A*/*B*) means the probability
    of *A* given *B*. *P*(*B*/*A*) means the probability of *B* given *A*. For example,
    assume we know that a certain test for a certain cancer is not always accurate
    and can give false positives, indicating that you have cancer when you don’t.
    The Bayes expression would be
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_2_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The initial probabilities would be based on clinical studies. For example, 800
    out of 1,000 people who have cancer may receive a positive test result, and 100
    out of 1,000 may be misdiagnosed. Based on disease rates, the overall chance of
    a given person having cancer may only be 50 out of 10,000\. So, if the overall
    probability of having cancer is low and the overall probability of getting a positive
    test result is relatively high, the probability of having cancer given a positive
    test goes down. If studies have recorded the frequency of inaccurate test results,
    Bayes’ rule can correct for measurement errors!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen an example application, look at [Figure 1-1](ch01.xhtml#ch01fig1),
    which shows the names of the various terms in Bayes’ rule, along with how they
    relate to the cancer example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: Bayes’ rule with terms defined and related to the cancer test example'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate further, let’s consider a woman who has lost her reading glasses
    in her house. The last time she remembers wearing them, she was in her study.
    She goes there and looks around. She doesn’t see her glasses, but she does see
    a teacup and remembers that she went to the kitchen. At this point, she must make
    a choice: search the study more thoroughly or leave and check the kitchen. She
    decides to go to the kitchen. She has unknowingly made a Bayesian decision.'
  prefs: []
  type: TYPE_NORMAL
- en: 'She went to the study first because she felt it offered the highest probability
    for success. In Bayesian terms, this initial probability of finding the glasses
    in the study is called the *prior*. After a cursory search, she changed her decision
    based on two new bits of information: she did not easily find the glasses, and
    she saw the teacup. This represents a *Bayesian update*, in which a new posterior
    estimate (*P*(*A*/*B*) in [Figure 1-1](ch01.xhtml#ch01fig1)) is calculated as
    more evidence becomes available.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine that the woman decided to use Bayes’ rule for her search. She
    would assign actual probabilities both to the likelihood of the glasses being
    in either the study or the kitchen and to the effectiveness of her searches in
    the two rooms. Rather than intuitive hunches, her decisions are now grounded in
    mathematics that can be continuously updated if future searches fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-2](ch01.xhtml#ch01fig2) illustrates the woman’s search for her glasses
    with these probabilities assigned.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: Initial probabilities for the location of the glasses and search
    effectiveness (left) versus updated target probabilities for the glasses (right)'
  prefs: []
  type: TYPE_NORMAL
- en: The left diagram represents the initial situation; the right diagram is updated
    with Bayes’ rule. Initially, let’s say there was an 85 percent chance of finding
    the glasses in the study and a 10 percent chance that the glasses are in the kitchen.
    Other possible rooms are given 1 percent because Bayes’ rule can’t update a target
    probability of zero (plus there’s always a small chance the woman left them in
    one of the other rooms).
  prefs: []
  type: TYPE_NORMAL
- en: Each number after a slash in the left diagram represents the *search effectiveness
    probability (SEP)*. The SEP is an estimate of how effectively you’ve searched
    an area. Because the woman has searched only in the study at this point, this
    value is zero for all other rooms. After the Bayesian update (the discovery of
    the teacup), she can recalculate the probabilities based on the search results,
    shown on the right. The kitchen is now the most likely place to look, but the
    probability for the other rooms increases as well.
  prefs: []
  type: TYPE_NORMAL
- en: Human intuition tells us that if something isn’t where we think it is, the odds
    that it is someplace else go up. Bayes’ rule takes this into account, and thus
    the probability that the glasses are in other rooms increases. But this can happen
    only if there was a chance of them being in the other room in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: The formula used for calculating the probability that the glasses are in a given
    room, given the search effectiveness, is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_4_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *G* is the probability that the glasses are in a room, *E* is the search
    effectiveness, and *P*[prior] is the prior, or initial, probability estimate before
    receiving the new evidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain the updated possibility that the glasses are in the study by
    inserting the target and search effectiveness probabilities into the equation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_5_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the simple math behind Bayes’ rule can quickly get tedious if
    you do it by hand. Fortunately for us, we live in the wonderous age of computers,
    so we can let Python handle the boring stuff!
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #1: Search and Rescue**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this project, you’ll write a Python program that uses Bayes’ rule to find
    a solitary fisherman who has gone missing off Cape Python. As the director of
    the Coast Guard’s search and rescue operations for the region, you’ve already
    interviewed his wife and determined his last known position, now more than six
    hours old. He radioed that he was abandoning ship, but no one knows if he is in
    a life raft or floating in the sea. The waters around the cape are warm, but if
    he’s immersed, he’ll experience hypothermia in 12 hours or so. If he’s wearing
    a personal flotation device and lucky, he might last three days.
  prefs: []
  type: TYPE_NORMAL
- en: The ocean currents off Cape Python are complex ([Figure 1-3](ch01.xhtml#ch01fig3)),
    and the wind is currently blowing from the southwest. Visibility is good, but
    the waves are choppy, making a human head hard to spot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: Ocean currents off Cape Python'
  prefs: []
  type: TYPE_NORMAL
- en: In real life, your next course of action would be to plug all the information
    you have into the Coast Guard’s Search and Rescue Optimal Planning System (SAROPS).
    This software considers factors such as winds, tides, currents, whether a body
    is in the water or in a boat, and so on. It then generates rectangular search
    areas, calculates the initial probabilities for finding the sailor in each area,
    and plots the most efficient flight patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, you’ll assume that SAROPS has identified three search areas.
    All you need to do is write the program that applies Bayes’ rule. You also have
    enough resources available to search two of the three areas in a day. You’ll have
    to decide how to allocate those resources. It’s a lot of pressure, but you have
    a powerful assistant to help you out: Bayes’ rule.'
  prefs: []
  type: TYPE_NORMAL
- en: THE OBJECTIVE
  prefs: []
  type: TYPE_NORMAL
- en: Create a search and rescue game that uses Bayes’ rule to inform player choices
    on how to conduct a search.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Strategy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Searching for the sailor is like looking for the lost glasses in our previous
    example. You’ll start with initial target probabilities for the sailor’s location
    and update them for the search results. If you achieve an effective search of
    an area but find nothing, the probability that the sailor is in another area will
    increase.
  prefs: []
  type: TYPE_NORMAL
- en: 'But just as in real life, there are two ways things could go wrong: you thoroughly
    search an area but still miss the sailor, or your search goes poorly, wasting
    a day’s effort. To equate this to search effectiveness scores, in the first case,
    you might get an SEP of 0.85, but the sailor is in the remaining 15 percent of
    the area not searched. In the second case, your SEP is 0.2, and you’ve left 80
    percent of the area unsearched!'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the dilemma real commanders face. Do you go with your gut and ignore
    Bayes? Do you stick with the pure, cold logic of Bayes because you believe it’s
    the best answer? Or do you act expediently and protect your career and reputation
    by going with Bayes even when you doubt it?
  prefs: []
  type: TYPE_NORMAL
- en: To aid the player, you’ll use the OpenCV library to build an interface for working
    with the program. Although the interface can be something simple, like a menu
    built in the shell, you’ll also want a map of the cape and the search areas. You’ll
    use this map to display the sailor’s last known position and his position when
    found. The OpenCV library is an excellent choice for this game since it lets you
    display images and add drawings and text.
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing the Python Libraries***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*OpenCV* is the world’s most popular computer vision library. *Computer vision*
    is a field of deep learning that enables machines to see, identify, and process
    images like humans. OpenCV began as an Intel Research initiative in 1999 and is
    now maintained by the OpenCV Foundation, a nonprofit foundation which provides
    the software for free.'
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV is written in C++, but there are bindings in other languages, such as
    Python and Java. Although aimed primarily at real-time computer vision applications,
    OpenCV also includes common image manipulation tools such as those found in the
    Python Imaging Library. As of this writing, the current version is OpenCV 4.1.
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV requires both the Numerical Python (NumPy) and SciPy packages to perform
    numerical and scientific computing in Python. OpenCV treats images as three-dimensional
    NumPy arrays ([Figure 1-4](ch01.xhtml#ch01fig4)). This allows for maximum interoperability
    with other Python scientific libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: Visual representation of a three-channel color image array'
  prefs: []
  type: TYPE_NORMAL
- en: OpenCV stores properties as rows, columns, and channels. For the image represented
    in [Figure 1-4](ch01.xhtml#ch01fig4), its “shape” would be a three-element tuple
    (4, 5, 3). Each stack of cells, like 0-20-40 or 19-39-59, represents a single
    pixel. The numbers shown are the intensity values for each color channel for that
    pixel.
  prefs: []
  type: TYPE_NORMAL
- en: As many projects in this book require scientific Python libraries like NumPy
    and matplotlib, this is a good time to install them.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous ways to install these packages. One way is to use SciPy,
    an open source Python library used for scientific and technical computing (see
    *[https://scipy.org/index.html](https://scipy.org/index.html)*).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if you’re going to do a lot of data analysis and plotting on
    your own time, you may want to download and use a free Python distribution like
    Anaconda or Enthought Canopy, which work with Windows, Linux, and macOS. These
    distributions spare you the task of finding and installing the correct versions
    of all the required data science libraries, such as NumPy, SciPy, and so on. A
    listing of these types of distributions, along with links to their websites, can
    be found at *[https://scipy.org/install.html](https://scipy.org/install.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing NumPy and Other Scientific Packages with pip**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you want to install the products directly, use the *Preferred Installer Program
    (pip)*, a package management system that makes it easy to install Python-based
    software (see *[https://docs.python.org/3/installing/](https://docs.python.org/3/installing/)*).
    For Windows and macOS, Python versions 3.4 and newer come with pip preinstalled.
    Linux users may have to install pip separately. To install or upgrade pip, see
    the instructions at *[https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/)*
    or search online for instructions on installing pip on your particular operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'I used pip to install the scientific packages using the instructions at *[https://scipy.org/install.html](https://scipy.org/install.html)*.
    Because matplotlib requires multiple dependen-cies, you’ll need to install these
    as well. For Windows, run the following Python 3–specific command using PowerShell,
    launched (using SHIFT-right-click) from within the folder containing the current
    Python installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you have both Python 2 and 3 installed, use python3 in place of python.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that NumPy has been installed and is available for OpenCV, open a
    Python shell and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t see an error, you’re ready to install OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing OpenCV with pip**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can find installation instructions for OpenCV at *[https://pypi.org/project/opencv-python/](https://pypi.org/project/opencv-python/)*.
    To install OpenCV for standard desktop environments (Windows, macOS, and almost
    any GNU/Linux distribution), enter the following in a PowerShell or terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you have multiple versions of Python installed (such as versions 2.7 and
    3.7), you will need to specify the Python version you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re using Anaconda as a distribution medium, you can run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that everything loaded properly, enter the following in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: No error means you’re good to go! If you get an error, read the troubleshooting
    list at *[https://pypi.org/project/opencv-python/](https://pypi.org/project/opencv-python/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Bayes Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *bayes.py* program you’ll write in this section simulates the search for
    a missing sailor over three contiguous search areas. It will display a map, print
    a menu of search choices for the user, randomly choose a location for the sailor,
    and either reveal the location if a search locates him or do a Bayesian update
    of the probabilities of finding the sailor for each search area. You can download
    the code, along with the map image (*cape_python.png*), from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing Modules**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 1-1](ch01.xhtml#ch01list1) starts the *bayes.py* program by importing
    the required modules and assigning some constants. We’ll look at what these modules
    do as we implement them in the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-1: Importing modules and assigning constants used in the bayes.py
    program'
  prefs: []
  type: TYPE_NORMAL
- en: When importing modules into a program, the preferred order is the Python Standard
    Library modules, followed by third-party modules, followed by user-defined modules.
    The sys module includes commands for the operating system, such as exiting. The
    random module lets you generate pseudorandom numbers. The itertools module helps
    you with looping. Finally, numpy and cv2 import NumPy and OpenCV, respectively.
    You can also assign shorthand names (np, cv) to reduce keystrokes later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign some constants. As per the PEP8 Python style guide (*[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)*),
    constant names should be all caps. This doesn’t make the variables truly immutable,
    but it does alert other developers that they shouldn’t change these variables.
  prefs: []
  type: TYPE_NORMAL
- en: The map you’ll use for the fictional Cape Python area is an image file called
    *cape_python.png* ([Figure 1-5](ch01.xhtml#ch01fig5)). Assign this image file
    to a constant variable named MAP_FILE.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-5: Grayscale base map of Cape Python (cape_python.png)'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll draw the search areas on the image as rectangles. OpenCV will define
    each rectangle by the pixel number at the corner points, so assign a variable
    to hold these four points as a tuple. The required order is upper-left *x*, upper-left
    *y*, lower-right *x*, and lower-right *y*. Use SA in the variable name to represent
    “search area.”
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the Search Class**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *class* is a data type in object-oriented programming (OOP). OOP is an alternative
    approach to functional/procedural programming. It’s especially useful for large,
    complex programs, as it produces code that’s easier to update, maintain, and reuse,
    while reducing code duplication. OOP is built around data structures known as
    *objects*, which consist of data, methods, and the interactions between them.
    As such, it works well with game programs, which typically use interacting objects,
    such as spaceships and asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: A class is a template from which multiple objects can be created. For example,
    you could have a class that builds battleships in a World War II game. Each battleship
    would inherit certain consistent characteristics, such as tonnage, cruising speed,
    fuel level, damage level, weaponry, and so on. You could also give each battleship
    object unique characteristics, such as a different name. Once created, or *instantiated*,
    the individual characteristics of each battleship would begin to diverge depending
    on how much fuel the ships burn, how much damage they take, how much ammo they
    use, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In *bayes.py*, you’ll use a class as a template to create a search and rescue
    mission that allows for three search areas. [Listing 1-2](ch01.xhtml#ch01list2)
    defines the Search class, which will act as a blueprint for your game.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-2: Defining the Search class and __init__() method'
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining a class called Search. According to PEP8, the first letter
    of a class name should be capitalized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define a method that sets up the initial attribute values for your object.
    In OOP, an *attribute* is a named value associated with an object. If your object
    is a person, an attribute might be their weight or eye color. *Methods* are attributes
    that also happen to be functions, which are passed a reference to their instance
    when they run. The __init__() method is a special built-in function that Python
    automatically invokes as soon as a new object is created. It binds the attributes
    of each newly created instance of a class. In this case, you pass it two arguments:
    self and the name you want to use for your object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The self parameter is a reference to the instance of the class that is being
    created, or that a method was invoked on, technically referred to as a *context*
    instance. For example, if you create a battleship named the *Missouri*, then for
    that object, self becomes Missouri, and you can call a method for that object,
    like one for firing the big guns, with dot notation: Missouri.fire_big_guns().
    By giving objects unique names when they are instantiated, the scope of each object’s
    attributes is kept separate from all others. This way, damage taken by one battleship
    isn’t shared with the rest of the fleet.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s good practice to list all the initial attribute values for an object under
    the __init__() method. This way, users can see all the key attributes of the object
    that will be used later in various methods, and your code will be more readable
    and updatable. In [Listing 1-2](ch01.xhtml#ch01list2), these are the self attributes,
    such as self.name.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes assigned to self will also behave like global variables in procedural
    programming. Methods in the class will be able to access them directly, without
    the need for arguments. Because these attributes are “shielded” under the *class*
    umbrella, their use is not discouraged as with true global variables, which are
    assigned within the global scope and are modified within the local scope of individual
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Assign the MAP_FILE variable to the self.img attribute using OpenCV’s imread()
    method ➊. The MAP_FILE image is grayscale, but you’ll want to add some color to
    it during the search. So, use ImreadFlag, as cv.IMREAD_COLOR, to load the image
    in color mode. This will set up three color channels (B, G, R) for you to exploit
    later.
  prefs: []
  type: TYPE_NORMAL
- en: If the image file doesn’t exist (or the user entered the wrong filename), OpenCV
    will throw a confusing error (NoneType object is not subscriptable). To handle
    this, use a conditional to check whether self.img is None. If it is, print an
    error message and then use the sys module to exit the program. Passing it an exit
    code of 1 indicates that the program terminated with an error. Setting file=stderr
    will result in the use of the standard “error red” text color in the Python interpreter
    window, though not in other windows such as PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign two attributes for the sailor’s actual location when found. The
    first will hold the number of the search area ➋ and the second the precise (*x*,
    *y*) location. The assigned values will be placeholders for now. Later, you’ll
    define a method to randomly choose the final values. Note that you use a list
    for the location coordinates as you need a mutable container.
  prefs: []
  type: TYPE_NORMAL
- en: The map image is loaded as an *array*. An array is a fixed-size collection of
    objects of the same type. Arrays are memory-efficient containers that provide
    fast numerical operations and effectively use the addressing logic of computers.
    One concept that makes NumPy particularly powerful is *vectorization*, which replaces
    explicit loops with more efficient array expressions. Basically, operations occur
    on entire arrays rather than their individual elements. With NumPy, internal looping
    is directed to efficient C and Fortran functions that are faster than standard
    Python techniques.
  prefs: []
  type: TYPE_NORMAL
- en: So that you can work with local coordinates *within* a search area, you can
    create a subarray from the array ➌. Notice that this is done with indexing. You
    first provide the range from the upper-left *y* value to the lower-right *y* and
    then from the upper-left *x* to the lower-right *x*. This is a NumPy feature that
    takes some getting used to, especially since most of us are used to *x* coming
    before *y* in Cartesian coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the procedure for the next two search areas and then set the pre-search
    probabilities for finding the sailor in each of the search areas ➍. In real life,
    these would come from the SAROPS program. Of course, p1 represents area 1, p2
    is for area 2, and so on. Finish with placeholder attributes for the SEP.
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing the Map**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Inside the Search class, you’ll use functionality within OpenCV to create a
    method that displays the base map. This map will include the search areas, a scale
    bar, and the sailor’s last known position ([Figure 1-6](ch01.xhtml#ch01fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-6: Initial game screen (base map) for bayes.py'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-3](ch01.xhtml#ch01list3) defines the draw_map() method that displays
    the initial map.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-3: Defining a method for displaying the base map'
  prefs: []
  type: TYPE_NORMAL
- en: Define the draw_map() method with self and the sailor’s last known coordinates
    (last_known) as its two parameters. Then use OpenCV’s line() method to draw a
    scale bar. Pass it the base map image, a tuple of the left and right (*x*, *y*)
    coordinates, a line color tuple, and a line width as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Use the putText() method to annotate the scale bar. Pass it the attribute for
    the base map image and then the actual text, followed by a tuple of the coordinates
    of the bottom-left corner of the text. Then add the font name, font scale, and
    color tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Now draw a rectangle for the first search area ➊. As usual, pass the base map
    image, then the variables representing the four corners of the box, and finally
    a color tuple and a line weight. Use putText() again to place the search area
    number just inside the upper-left corner. Repeat these steps for search areas
    2 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: Use putText() to post a + at the sailor’s last known position ➋. Note that the
    symbol is red, but the color tuple reads (0, 0, 255), instead of (255, 0, 0).
    This is because OpenCV uses a Blue-Green-Red (BGR) color format, not the more
    common Red-Green-Blue (RGB) format.
  prefs: []
  type: TYPE_NORMAL
- en: Continue by placing text for a legend that describes the symbols for the last
    known position and actual position, which should display when a player’s search
    finds the sailor. Use blue for the actual position marker.
  prefs: []
  type: TYPE_NORMAL
- en: Complete the method by showing the base map, using OpenCV’s imshow() method
    ➌. Pass it a title for the window and the image.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the base map and interpreter windows interfering with each other as
    much as possible, force the base map to display in the upper-right corner of your
    monitor (you may need to adjust the coordinates for your machine). Use OpenCV’s
    moveWindow() method and pass it the name of the window, 'Search Area', and the
    coordinates for the top-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: Finish by using the waitKey() method, which introduces a delay of *n* milliseconds
    while rendering images to windows. Pass it 500, for 500 milliseconds. This should
    result in the game menu appearing a half-second after the base map.
  prefs: []
  type: TYPE_NORMAL
- en: '**Choosing the Sailor’s Final Location**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 1-4](ch01.xhtml#ch01list4) defines a method to randomly choose the
    sailor’s actual location. For convenience, the coordinates are initially found
    within a search area subarray and then converted to global coordinates with respect
    to the full base map image. This methodology works because all the search areas
    are the same size and shape and can thus use the same internal coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-4: Defining a method to randomly choose the sailor’s actual location'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the sailor_final_location() method with two parameters: self and the
    number of search areas being used. For the first (*x*) coordinate in the self.sailor_actual
    list, use NumPy’s random.choice() method to choose a value from the area 1 subarray.
    Remember, the search areas are NumPy arrays copied out of the larger image array.
    Because the search areas/subarrays are all the same size, coordinates you choose
    from one will apply to all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the coordinates of an array with shape, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The shape attribute for a NumPy array must be a tuple with as many elements
    as dimensions in the array. And remember that, for an array in OpenCV, the order
    of elements in the tuple is rows, columns, and then channels.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the existing search areas is a three-dimensional array 50×50 pixels
    in size. So, internal coordinates for both *x* and *y* will range from 0 to 49\.
    Selecting [0] with random.choice() means that rows are used, and the final argument,
    1, selects a single element. Selecting [1] chooses from columns.
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates generated by random.choice() will range from 0 to 49\. To use
    these with the full base map image, you first need to pick a search area ➊. Do
    this with the random module, which you imported at the start of the program. According
    to the SAROPS output, the sailor is most likely in area 2, followed by area 3\.
    Since these initial target probabilities are guesses that won’t correspond directly
    to reality, use a triangular distribution to choose the area containing the sailor.
    The arguments are the low and high endpoints. If a final mode argument is not
    provided, the mode defaults to the midpoint between the endpoints. This will align
    with the SAROPS results as area 2 will be picked the most often.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you use the local variable area within the method, rather than the
    self.area attribute, as there’s no need to share this variable with other methods.
  prefs: []
  type: TYPE_NORMAL
- en: To plot the sailor’s location on the base map, you need to add the appropriate
    search area corner-point coordinate. This converts the “local” search area coordinates
    to the “global” coordinates of the full base map image. You’ll also want to keep
    track of the search area, so update the self.area_actual attribute ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat these steps for search areas 2 and 3 and then return the (*x*, *y*) coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In real life, the sailor would drift along, and the odds of his moving into
    area 3 would increase with each search. I chose to use a static location, however,
    to make the logic behind Bayes’ rule as clear as possible. As a result, this scenario
    behaves more like a search for a sunken submarine.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating Search Effectiveness and Conducting the Search**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In real life, weather and mechanical problems can result in low search effectiveness
    scores. Thus, the strategy for each search will be to generate a list of all possible
    locations within a search area, shuffle the list, and then sample it based on
    the search effectiveness value. Because the SEP will never be 1.0, if you just
    sample from the start or end of the list—without shuffling—you’ll never be able
    to access coordinates tucked away in its “tail.”
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-5](ch01.xhtml#ch01list5), still in the Search class, defines a method
    to randomly calculate the effectiveness of a given search and defines another
    method to conduct the search.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-5: Defining methods to randomly choose search effectiveness and conduct
    search'
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining the search effectiveness method. The only parameter needed
    is self. For each of the search effectiveness attributes, such as E1, randomly
    choose a value between 0.2 and 0.9\. These are arbitrary values that mean you
    will always search at least 20 percent of the area but never more than 90 percent.
  prefs: []
  type: TYPE_NORMAL
- en: You could argue that the search effectiveness attributes for the three search
    areas are dependent. Fog, for example, might affect all three areas, yielding
    uniformly poor results. On the other hand, some of your helicopters may have infrared
    imaging equipment and would fare better. At any rate, making these independent,
    as you’ve done here, makes for a more dynamic simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a method for conducting a search ➊. Necessary parameters are the
    object itself, the area number (chosen by the user), the subarray for the chosen
    area, and the randomly chosen search effectiveness value.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to generate a list of all the coordinates within a given search
    area. Name a variable local_y_range and assign it a range based on the first index
    from the array shape tuple, which represents rows. Repeat for the x_range value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the list of all coordinates in the search area, use the itertools
    module ➋. This module is a group of functions in the Python Standard Library that
    create iterators for efficient looping. The product() function returns tuples
    of all the permutations-with-repetition for a given sequence. In this case, you’re
    finding all the possible ways to combine *x* and *y* in the search area. To see
    it in action, type the following in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the coords list contains every possible paired combination of
    the elements in the x_range and y_range lists.
  prefs: []
  type: TYPE_NORMAL
- en: Next, shuffle the list of coordinates. This is so you won’t keep searching the
    same end of the list with each search event. In the next line, use index slicing
    to trim the list based on the search effectiveness probability. For example, a
    poor search effectiveness of 0.3 means that only one-third of the possible locations
    in an area are included in the list. As you’ll check the sailor’s actual location
    against this list, you’ll effectively leave two-thirds of the area “unsearched.”
  prefs: []
  type: TYPE_NORMAL
- en: Assign a local variable, loc_actual, to hold the sailor’s actual location ➌.
    Then use a conditional to check that the sailor has been found. If the user chose
    the correct search area and the shuffled and trimmed coords list contains the
    sailor’s (*x*, *y*) location, return a string stating the sailor has been found,
    along with the coords list. Otherwise, return a string stating the sailor has
    not been found and the coords list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Applying Bayes’ Rule and Drawing a Menu**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 1-6](ch01.xhtml#ch01list6), still in the Search class, defines a method
    and a function. The revise_target_probs() method uses Bayes’ rule to update the
    target probabilities. These represent the probability of the sailor being found
    per search area. The draw_menu() function, defined outside of the Search class,
    displays a menu that will serve as a graphical user interface (GUI) to run the
    game.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-6: Defining ways to apply Bayes’ rule and draw a menu in the Python
    shell'
  prefs: []
  type: TYPE_NORMAL
- en: Define the revise_target_probs() method to update the probability of the sailor
    being in each search area. Its only parameter is self.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, break Bayes’ equation into two parts, starting with the denominator.
    You need to multiply the previous target probability by the current search effectiveness
    value (see [page 5](ch01.xhtml#page_5) to review how this works).
  prefs: []
  type: TYPE_NORMAL
- en: With the denominator calculated, use it to complete Bayes’ equation. In OOP,
    you don’t need to return anything. You can simply update the attribute directly
    in the method, as if it were a declared global variable in procedural programming.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the global space, define the draw_menu() function to draw a menu. Its
    only parameter is the number of the search being conducted. Because this function
    has no “self-use,” you don’t have to include it in the class definition, though
    that is a valid option.
  prefs: []
  type: TYPE_NORMAL
- en: Start by printing the search number. You’ll need this to keep track of whether
    you’ve found the sailor in the requisite number of searches, which we’ve currently
    set as 3.
  prefs: []
  type: TYPE_NORMAL
- en: Use triple quotes with the print() function to display the menu. Note that the
    user will have the option to allocate both search parties to a given area or divide
    them between two areas.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that you’re finished with the Search class, you’re ready to put all those
    attributes and methods to work! [Listing 1-7](ch01.xhtml#ch01list7) begins the
    definition of the main() function, used to run the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-7: Defining the start of the main() function, used to run the program'
  prefs: []
  type: TYPE_NORMAL
- en: The main() function requires no arguments. Start by creating a game application,
    named app, using the Search class. Name the object Cape_Python.
  prefs: []
  type: TYPE_NORMAL
- en: Next, call the method that displays the map. Pass it the last known position
    of the sailor as a tuple of (*x*, *y*) coordinates. Note the use of the keyword
    argument, last_known=(160, 290), for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Now, get the sailor’s *x* and *y* location by calling the method for that task
    and passing it the number of search areas. Then print the initial target probabilities,
    or priors, which were calculated by your Coast Guard underlings using Monte Carlo
    simulation, not Bayes’ rule. Finally, name a variable search_num and assign it
    1. This variable will keep track of how many searches you’ve conducted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Evaluating the Menu Choices**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 1-8](ch01.xhtml#ch01list8) starts the while loop used to run the game
    in main(). Within this loop, the player evaluates and selects menu choices. Choices
    include searching a single area twice, splitting search efforts between two areas,
    restarting the game, and exiting the game. Note that the player can conduct as
    many searches as it takes to find the sailor; our three-day limit hasn’t been
    “hardwired” into the game.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-8: Using a loop to evaluate menu choices and run the game'
  prefs: []
  type: TYPE_NORMAL
- en: Start a while loop that will run until the user chooses to exit. Immediately
    use dot notation to call the method that calculates the effectiveness of the search.
    Then call the function that displays the game menu and pass it the search number.
    Finish the preparatory stage by asking the user to make a choice, using the input()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The player’s choice will be evaluated using a series of conditional statements.
    If they choose 0, exit the game. Exiting uses the sys module you imported at the
    beginning of the program.
  prefs: []
  type: TYPE_NORMAL
- en: If the player chooses 1, 2, or 3, it means they want to commit both search teams
    to the area with the corresponding number. You’ll need to call the conduct_search()
    method twice to generate two sets of results and coordinates ➊. The tricky part
    here is determining the overall SEP, since each search has its own SEP. To do
    this, add the two coords lists together and convert the result to a set to remove
    any duplicates ➋. Get the length of the set and then divide it by the number of
    pixels in the 50×50 search area. Since you didn’t search the other areas, set
    their SEPs to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat and tailor the previous code for search areas 2 and 3\. Use an elif statement
    since only one menu choice is valid per loop. This is more efficient than using
    additional if statements, as all elif statements below a true response will be
    skipped.
  prefs: []
  type: TYPE_NORMAL
- en: If the player chooses a 4, 5, or 6, it means they want to divide their teams
    between two areas. In this case, there’s no need to recalculate the SEP ➌.
  prefs: []
  type: TYPE_NORMAL
- en: If the player finds the sailor and wants to play again or just wants to restart,
    call the main() function ➍. This will reset the game and clear the map.
  prefs: []
  type: TYPE_NORMAL
- en: If the player makes a nonvalid choice, like “Bob”, let them know with a message
    and then use continue to skip back to the start of the loop and request the player’s
    choice again.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finishing and Calling main()**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 1-9](ch01.xhtml#ch01list9), still in the while loop, finishes the
    main() function and then calls it to run the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-9: Completing and calling the main() function'
  prefs: []
  type: TYPE_NORMAL
- en: Call the revise_target_probs() method to apply Bayes’ rule and recalculate the
    probability of the sailor being in each search area, given the search results.
    Next, display the search results and search effectiveness probabilities in the
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: If the results of both searches are negative, display the updated target probabilities,
    which the player will use to guide their next search ➊. Otherwise, display the
    sailor’s location on the map. Use OpenCV to draw a circle and pass the method
    the base map image, the sailor’s (*x*, *y*) tuple for the center point, a radius
    (in pixels), a color, and a thickness of –1\. A negative thickness value will
    fill the circle with the color.
  prefs: []
  type: TYPE_NORMAL
- en: Finish main() by showing the base map using code similar to [Listing 1-3](ch01.xhtml#ch01list3)
    ➋. Pass the waitKey() method 1500 to display the sailor’s actual location for
    1.5 seconds before the game calls main() and resets automatically. At the end
    of the loop, increment the search number variable by 1\. You want to do this *after*
    the loop so that an invalid choice isn’t counted as a search.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the global space, apply the code that lets the program be imported as
    a module or run in stand-alone mode. The __name__ variable is a built-in variable
    used to evaluate whether a program is autonomous or imported into another program.
    If you run this program directly, __name__ is set to __main__, the condition of
    the if statement is met, and main() is called automatically. If the program is
    imported, the main() function won’t be run until it is intentionally called.
  prefs: []
  type: TYPE_NORMAL
- en: '***Playing the Game***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To play the game, select **Run**▸**Run Module** in the text editor or just press
    F5\. [Figures 1-7](ch01.xhtml#ch01fig7) and [1-8](ch01.xhtml#ch01fig8) show the
    final game screens, with the results of a successful first search.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-7: Python interpreter window with a successful search result'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-8: Base map image for a successful search result'
  prefs: []
  type: TYPE_NORMAL
- en: In this example search, the player chose to commit both searches to area 2,
    which had an initial 50 percent probability of containing the sailor. The first
    search was unsuccessful, but the second one found the sailor. Note that the search
    effectiveness was only slightly better than 50 percent. This means there was only
    a one-in-four chance (0.5 × 0.521 = 0.260) of finding the sailor in the first
    search. Despite choosing wisely, the player still had to rely on a bit of luck
    in the end!
  prefs: []
  type: TYPE_NORMAL
- en: When you play the game, try to immerse yourself in the scenario. Your decisions
    determine whether a human being lives or dies, and you don’t have much time. If
    the sailor’s floating in the water, you’ve got only three guesses to get it right.
    Use them wisely!
  prefs: []
  type: TYPE_NORMAL
- en: Based on the target probabilities at the start of the game, the sailor is most
    likely in area 2, followed by area 3\. So, a good initial strategy is to either
    search area 2 twice (menu option 2) or search areas 2 and 3 simultaneously (menu
    option 6). You’ll want to keep a close eye on the search effectiveness output.
    If an area gets a high effectiveness score, which means that it’s been thoroughly
    searched, you may want to focus your efforts elsewhere for the rest of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output represents one of the worst situations you can find yourself
    in as a decision maker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After search 2, with only one search left, the target probabilities are so similar
    they provide little guidance for where to search next. In this case, it’s best
    to divide your searches between two areas and hope for the best.
  prefs: []
  type: TYPE_NORMAL
- en: Play the game a few times by blindly searching the areas in order of initial
    probability, doubling up on area 2, then 3, then 1\. Then try obeying the Bayes
    results religiously, always doubling your searches in the area with the highest
    current target probability. Next, try dividing your searches between the areas
    with the two highest probabilities. After that, allow your own intuition to have
    a say, overruling Bayes when you feel it’s appropriate. As you can imagine, with
    more search areas and more search days, human intuition would quickly get overwhelmed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about Bayes’ rule, a simple statistical theorem
    with broad applications in our modern world. You wrote a program that used the
    rule to take new information—in the form of estimates of search effectiveness—and
    update the probability of finding a lost sailor in each area being searched.
  prefs: []
  type: TYPE_NORMAL
- en: You also loaded and used multiple scientific packages, like NumPy and OpenCV,
    that you’ll implement throughout the book. And you applied the useful itertools,
    sys, and random modules from the Python Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The Theory That Would Not Die: How Bayes’ Rule Cracked the Enigma Code, Hunted
    Down Russian Submarines, and Emerged Triumphant from Two Centuries of Controversy*
    (Yale University Press, 2011), by Sharon Bertsch McGrayne, recounts the discovery
    and controversial history of Bayes’ rule. The appendix includes several example
    applications of Bayes’ rule, one of which inspired the missing-sailor scenario
    used in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: A major source of documentation for NumPy is *[https://docs.scipy.org/doc/](https://docs.scipy.org/doc/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Smarter Searches**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, the *bayes.py* program places all the coordinates within a search
    area into a list and randomly shuffles them. Subsequent searches in the same area
    may end up retracing previous tracks. This isn’t necessarily bad from a real-life
    perspective, as the sailor will be drifting around the whole time, but overall
    it would be best to cover as much of the area as possible without repetition.
  prefs: []
  type: TYPE_NORMAL
- en: Copy and edit the program so that it keeps track of which coordinates have been
    searched within an area and excludes them from future searches (until main() is
    called again, either because the player finds the sailor or chooses menu option
    7 to restart). Test the two versions of the game to see whether your changes noticeably
    impact the results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Finding the Best Strategy with MCS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Monte Carlo simulation (MCS) uses repeated random sampling to predict different
    outcomes under a specified range of conditions. Create a version of *bayes.py*
    that automatically chooses menu items and keeps track of thousands of results,
    allowing you to determine the most successful search strategy. For example, have
    the program choose menu item 1, 2, or 3 based on the highest Bayesian target probability
    and then record the search number when the sailor is found. Repeat this procedure
    10,000 times and take the average of all the search numbers. Then loop again,
    choosing from menu item 4, 5, or 6 based on the highest combined target probability.
    Compare the final averages. Is it better to double up your searches in a single
    area or split them between two areas?
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Calculating the Probability of Detection**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a real-life search and rescue operation, you would make an estimate of the
    *expected* search effectiveness probability for each area prior to making a search.
    This expected, or *planned*, probability would be informed primarily by weather
    reports. For example, fog might roll into one search area, while the other two
    enjoy clear skies.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying target probability by the planned SEP yields the *probability of
    detection (PoD)* for an area. The PoD is the probability an object will be detected
    given all known error and noise sources.
  prefs: []
  type: TYPE_NORMAL
- en: Write a version of *bayes.py* that includes a randomly generated planned SEP
    for each search area. Multiply the target probability for each area (such as self.p1,
    self.p2, or self.p3) by these new variables to produce a PoD for the area. For
    example, if the Bayes target probability for area 3 is 0.90 but the planned SEP
    is only 0.1, then the probability of detection is 0.09.
  prefs: []
  type: TYPE_NORMAL
- en: In the shell display, show the player the target probabilities, the planned
    SEPs, and the PoD for each area, as shown next. Players can then use this information
    to guide their choice from the search menu.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To combine PoD when searching the same area twice, use this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_26_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Otherwise, just sum the probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: When calculating the actual SEP for an area, constrain it somewhat to the expected
    value. This considers the general accuracy of weather reports made only a day
    in advance. Replace the random.uniform() method with a distribution, such as triangular,
    built around the planned SEP value. For a list of available distribution types,
    see *[https://docs.python.org/3/library/random.html#real-valued-distributions](https://docs.python.org/3/library/random.html#real-valued-distributions)*.
    Of course, the actual SEP for an unsearched area will always be zero.
  prefs: []
  type: TYPE_NORMAL
- en: How does incorporating planned SEPs affect gameplay? Is it easier or harder
    to win? Is it harder to grasp how Bayes’ rule is being applied? If you oversaw
    a real search, how would you deal with an area with a high target probability
    but a low planned SEP due to rough seas? Would you search anyway, call off the
    search, or move the search to an area with a low target probability but better
    weather?
  prefs: []
  type: TYPE_NORMAL
