- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SAVING SHIPWRECKED SAILORS WITH BAYES’ RULE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Sometime around 1740, an English Presbyterian minister named Thomas Bayes decided
    to mathematically prove the existence of God. His ingenious solution, now known
    as *Bayes’ rule*, would become one of the most successful statistical concepts
    of all time. But for 200 years it languished, largely ignored, because its tedious
    mathematics were impractical to do by hand. It took the invention of the modern
    computer for Bayes’ rule to reach its full potential. Now, thanks to our fast
    processors, it forms a key component of data science and machine learning.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Because Bayes’ rule shows us the mathematically correct way to incorporate new
    data and recalculate probability estimates, it penetrates almost all human endeavors,
    from cracking codes to picking presidential winners to demonstrating that high
    cholesterol causes heart attacks. A list of applications of Bayes’ rule could
    easily fill this chapter. But since nothing is more important than saving lives,
    we’ll focus on the use of Bayes’ rule to help save sailors lost at sea.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll create a simulation game for a Coast Guard search and
    rescue effort. Players will use Bayes’ rule to guide their decisions so they can
    locate the sailor as quickly as possible. In the process, you’ll start working
    with popular computer vision and data science tools like Open Source Computer
    Vision Library (OpenCV) and NumPy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**Bayes’ Rule**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bayes’ rule helps investigators determine the probability that something is
    true given new evidence. As the great French mathematician Laplace put it, “The
    probability of a cause—given an event—is proportional to the probability of the
    event—given its cause.” The basic formula is
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_2_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: where *A* is a hypothesis and *B* is data. *P*(*A*/*B*) means the probability
    of *A* given *B*. *P*(*B*/*A*) means the probability of *B* given *A*. For example,
    assume we know that a certain test for a certain cancer is not always accurate
    and can give false positives, indicating that you have cancer when you don’t.
    The Bayes expression would be
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_2_02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: The initial probabilities would be based on clinical studies. For example, 800
    out of 1,000 people who have cancer may receive a positive test result, and 100
    out of 1,000 may be misdiagnosed. Based on disease rates, the overall chance of
    a given person having cancer may only be 50 out of 10,000\. So, if the overall
    probability of having cancer is low and the overall probability of getting a positive
    test result is relatively high, the probability of having cancer given a positive
    test goes down. If studies have recorded the frequency of inaccurate test results,
    Bayes’ rule can correct for measurement errors!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen an example application, look at [Figure 1-1](ch01.xhtml#ch01fig1),
    which shows the names of the various terms in Bayes’ rule, along with how they
    relate to the cancer example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig01_01.jpg)'
- en: 'Figure 1-1: Bayes’ rule with terms defined and related to the cancer test example'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：定义了术语并与癌症检测示例相关的贝叶斯定理
- en: 'To illustrate further, let’s consider a woman who has lost her reading glasses
    in her house. The last time she remembers wearing them, she was in her study.
    She goes there and looks around. She doesn’t see her glasses, but she does see
    a teacup and remembers that she went to the kitchen. At this point, she must make
    a choice: search the study more thoroughly or leave and check the kitchen. She
    decides to go to the kitchen. She has unknowingly made a Bayesian decision.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明，假设一位女士在家里丢失了她的阅读眼镜。她最后记得戴眼镜时是在书房。她去了书房并四处寻找。她没有找到眼镜，但看到了一个茶杯，并记得她去了厨房。此时，她必须做出选择：要么更加彻底地搜索书房，要么离开去厨房检查。她决定去厨房。她不知不觉中做出了一个贝叶斯决策。
- en: 'She went to the study first because she felt it offered the highest probability
    for success. In Bayesian terms, this initial probability of finding the glasses
    in the study is called the *prior*. After a cursory search, she changed her decision
    based on two new bits of information: she did not easily find the glasses, and
    she saw the teacup. This represents a *Bayesian update*, in which a new posterior
    estimate (*P*(*A*/*B*) in [Figure 1-1](ch01.xhtml#ch01fig1)) is calculated as
    more evidence becomes available.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 她首先去了书房，因为她觉得在书房找到眼镜的成功概率最高。从贝叶斯的角度来看，最初在书房找到眼镜的概率被称为*先验*。经过简略的搜索后，她根据两个新获得的信息改变了决定：她没有轻易找到眼镜，而且她看到了茶杯。这代表了一个*贝叶斯更新*，其中随着更多证据的出现，新的后验估计（在[图
    1-1](ch01.xhtml#ch01fig1)中为*P*(*A*/*B*)）被计算出来。
- en: Let’s imagine that the woman decided to use Bayes’ rule for her search. She
    would assign actual probabilities both to the likelihood of the glasses being
    in either the study or the kitchen and to the effectiveness of her searches in
    the two rooms. Rather than intuitive hunches, her decisions are now grounded in
    mathematics that can be continuously updated if future searches fail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这位女士决定在搜索过程中使用贝叶斯定理。她会为眼镜在书房或厨房中的可能性以及她在这两个房间中搜索的有效性分配实际的概率。与其凭直觉做决定，她的选择现在建立在数学基础上，如果未来的搜索失败，这些决策可以持续更新。
- en: '[Figure 1-2](ch01.xhtml#ch01fig2) illustrates the woman’s search for her glasses
    with these probabilities assigned.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](ch01.xhtml#ch01fig2)展示了这位女士在分配了这些概率后的眼镜搜索过程。'
- en: '![Image](../images/fig01_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig01_02.jpg)'
- en: 'Figure 1-2: Initial probabilities for the location of the glasses and search
    effectiveness (left) versus updated target probabilities for the glasses (right)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：眼镜位置的初始概率和搜索有效性（左）与更新后的眼镜目标概率（右）
- en: The left diagram represents the initial situation; the right diagram is updated
    with Bayes’ rule. Initially, let’s say there was an 85 percent chance of finding
    the glasses in the study and a 10 percent chance that the glasses are in the kitchen.
    Other possible rooms are given 1 percent because Bayes’ rule can’t update a target
    probability of zero (plus there’s always a small chance the woman left them in
    one of the other rooms).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧图表示最初的情况；右侧图是根据贝叶斯定理更新后的图。最初，假设在书房找到眼镜的概率是85%，在厨房找到眼镜的概率是10%。其他可能的房间被赋予1%的概率，因为贝叶斯定理无法更新为零的目标概率（而且总是有一个小概率她将眼镜落在其他房间）。
- en: Each number after a slash in the left diagram represents the *search effectiveness
    probability (SEP)*. The SEP is an estimate of how effectively you’ve searched
    an area. Because the woman has searched only in the study at this point, this
    value is zero for all other rooms. After the Bayesian update (the discovery of
    the teacup), she can recalculate the probabilities based on the search results,
    shown on the right. The kitchen is now the most likely place to look, but the
    probability for the other rooms increases as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 左图中每个斜杠后的数字代表*搜索有效性概率（SEP）*。SEP是对你搜索一个区域的有效性的估计。由于这位女士目前只在书房进行了搜索，因此其他房间的搜索有效性概率为零。在贝叶斯更新后（发现茶杯），她可以根据搜索结果重新计算概率，更新后的概率如右图所示。现在厨房是最可能的搜索地点，但其他房间的概率也有所增加。
- en: Human intuition tells us that if something isn’t where we think it is, the odds
    that it is someplace else go up. Bayes’ rule takes this into account, and thus
    the probability that the glasses are in other rooms increases. But this can happen
    only if there was a chance of them being in the other room in the first place.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 人类直觉告诉我们，如果某物不在我们认为它所在的地方，那么它出现在其他地方的概率就会增加。贝叶斯法则考虑到了这一点，因此眼镜出现在其他房间的概率也会增加。但只有在一开始就有它们可能出现在其他房间的情况时，这种情况才会发生。
- en: The formula used for calculating the probability that the glasses are in a given
    room, given the search effectiveness, is
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算眼镜在给定房间中概率的公式，考虑了搜索效果，公式为：
- en: '![Image](../images/equ_page_4_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/equ_page_4_01.jpg)'
- en: where *G* is the probability that the glasses are in a room, *E* is the search
    effectiveness, and *P*[prior] is the prior, or initial, probability estimate before
    receiving the new evidence.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *G* 是眼镜在某房间中的概率，*E* 是搜索效果，*P*[prior] 是接收到新证据前的先验概率估计。
- en: 'You can obtain the updated possibility that the glasses are in the study by
    inserting the target and search effectiveness probabilities into the equation
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将目标和搜索效果概率插入方程来获取眼镜在书房中的更新概率，具体如下：
- en: '![Image](../images/equ_page_5_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/equ_page_5_01.jpg)'
- en: As you can see, the simple math behind Bayes’ rule can quickly get tedious if
    you do it by hand. Fortunately for us, we live in the wonderous age of computers,
    so we can let Python handle the boring stuff!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，贝叶斯法则背后的简单数学运算如果手工计算会变得很繁琐。幸运的是，我们生活在计算机的奇妙时代，所以我们可以让Python来处理这些无聊的计算工作！
- en: '**Project #1: Search and Rescue**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #1：搜索与救援**'
- en: In this project, you’ll write a Python program that uses Bayes’ rule to find
    a solitary fisherman who has gone missing off Cape Python. As the director of
    the Coast Guard’s search and rescue operations for the region, you’ve already
    interviewed his wife and determined his last known position, now more than six
    hours old. He radioed that he was abandoning ship, but no one knows if he is in
    a life raft or floating in the sea. The waters around the cape are warm, but if
    he’s immersed, he’ll experience hypothermia in 12 hours or so. If he’s wearing
    a personal flotation device and lucky, he might last three days.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将编写一个Python程序，使用贝叶斯法则来寻找在Python岬失踪的独自渔民。作为该地区海岸警卫队搜索与救援行动的负责人，你已经采访了他的妻子，并确定了他最后一次被见到的位置，距离现在已经超过六小时。他通过无线电报告说他要弃船，但没人知道他是坐上了救生艇还是漂浮在海中。岬角周围的水域温暖，但如果他被浸泡在水中，大约12小时后他会发生体温过低。如果他穿着个人漂浮装置并且幸运的话，他可能能撑三天。
- en: The ocean currents off Cape Python are complex ([Figure 1-3](ch01.xhtml#ch01fig3)),
    and the wind is currently blowing from the southwest. Visibility is good, but
    the waves are choppy, making a human head hard to spot.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python岬的海洋洋流复杂多变（[图 1-3](ch01.xhtml#ch01fig3)），目前风从西南方向吹来。能见度良好，但波浪较为汹涌，使得人头较难被察觉。
- en: '![Image](../images/fig01_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig01_03.jpg)'
- en: 'Figure 1-3: Ocean currents off Cape Python'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3：海洋洋流——Python岬
- en: In real life, your next course of action would be to plug all the information
    you have into the Coast Guard’s Search and Rescue Optimal Planning System (SAROPS).
    This software considers factors such as winds, tides, currents, whether a body
    is in the water or in a boat, and so on. It then generates rectangular search
    areas, calculates the initial probabilities for finding the sailor in each area,
    and plots the most efficient flight patterns.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，你的下一步行动是将你所掌握的所有信息输入海岸警卫队的搜索与救援最优规划系统（SAROPS）。该软件会考虑风、潮汐、洋流、物体是否漂浮在水面或在船上等因素。然后，它会生成矩形搜索区域，计算在每个区域内找到失踪水手的初步概率，并绘制出最有效的飞行路线。
- en: 'For this project, you’ll assume that SAROPS has identified three search areas.
    All you need to do is write the program that applies Bayes’ rule. You also have
    enough resources available to search two of the three areas in a day. You’ll have
    to decide how to allocate those resources. It’s a lot of pressure, but you have
    a powerful assistant to help you out: Bayes’ rule.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将假设SAROPS已经确定了三个搜索区域。你需要做的就是编写应用贝叶斯法则的程序。你也有足够的资源来在一天内搜索这三个区域中的两个。你必须决定如何分配这些资源。这很有压力，但你有一个强大的助手帮助你：贝叶斯法则。
- en: THE OBJECTIVE
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 目标
- en: Create a search and rescue game that uses Bayes’ rule to inform player choices
    on how to conduct a search.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个搜索与救援游戏，利用贝叶斯法则帮助玩家决定如何进行搜索。
- en: '***The Strategy***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: Searching for the sailor is like looking for the lost glasses in our previous
    example. You’ll start with initial target probabilities for the sailor’s location
    and update them for the search results. If you achieve an effective search of
    an area but find nothing, the probability that the sailor is in another area will
    increase.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找水手就像我们之前例子中寻找丢失的眼镜一样。你将从水手位置的初始目标概率开始，并根据搜索结果更新它们。如果你有效地搜索了一个区域，但什么也没找到，那么水手在另一个区域的概率将增加。
- en: 'But just as in real life, there are two ways things could go wrong: you thoroughly
    search an area but still miss the sailor, or your search goes poorly, wasting
    a day’s effort. To equate this to search effectiveness scores, in the first case,
    you might get an SEP of 0.85, but the sailor is in the remaining 15 percent of
    the area not searched. In the second case, your SEP is 0.2, and you’ve left 80
    percent of the area unsearched!'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但就像在现实生活中一样，事情可能会有两种方式出错：你彻底搜索了一个区域，但仍然没有找到水手，或者你的搜索不顺利，浪费了一整天的努力。为了与搜索效果评分相匹配，在第一种情况下，你的SEP可能是0.85，但水手在剩下的15%未搜索的区域中。在第二种情况下，你的SEP是0.2，而你已经有80%的区域没有搜索！
- en: You can see the dilemma real commanders face. Do you go with your gut and ignore
    Bayes? Do you stick with the pure, cold logic of Bayes because you believe it’s
    the best answer? Or do you act expediently and protect your career and reputation
    by going with Bayes even when you doubt it?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到真正的指挥官面临的困境。你是凭直觉行事并忽略贝叶斯方法吗？你是坚持贝叶斯的纯粹冷逻辑，因为你认为这是最好的答案吗？还是你为了权衡和保护自己的职业和声誉，即使怀疑贝叶斯方法，也选择采用它？
- en: To aid the player, you’ll use the OpenCV library to build an interface for working
    with the program. Although the interface can be something simple, like a menu
    built in the shell, you’ll also want a map of the cape and the search areas. You’ll
    use this map to display the sailor’s last known position and his position when
    found. The OpenCV library is an excellent choice for this game since it lets you
    display images and add drawings and text.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助玩家，你将使用OpenCV库来构建一个与程序交互的界面。虽然界面可以是简单的，例如在命令行中构建的菜单，但你还需要一张岬角和搜索区域的地图。你将使用这张地图来显示水手最后已知的位置和找到时的位置。OpenCV库是这个游戏的理想选择，因为它允许你显示图像，并添加绘图和文本。
- en: '***Installing the Python Libraries***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装Python库***'
- en: '*OpenCV* is the world’s most popular computer vision library. *Computer vision*
    is a field of deep learning that enables machines to see, identify, and process
    images like humans. OpenCV began as an Intel Research initiative in 1999 and is
    now maintained by the OpenCV Foundation, a nonprofit foundation which provides
    the software for free.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*OpenCV* 是世界上最流行的计算机视觉库。*计算机视觉* 是一个深度学习领域，使机器能够像人类一样看到、识别和处理图像。OpenCV最初是英特尔研究的一个项目，始于1999年，现在由OpenCV基金会维护，这是一个非营利性基金会，提供免费的软件。'
- en: OpenCV is written in C++, but there are bindings in other languages, such as
    Python and Java. Although aimed primarily at real-time computer vision applications,
    OpenCV also includes common image manipulation tools such as those found in the
    Python Imaging Library. As of this writing, the current version is OpenCV 4.1.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV是用C++编写的，但也有其他语言的绑定，例如Python和Java。尽管主要面向实时计算机视觉应用，OpenCV也包括常见的图像处理工具，例如Python图像库中的工具。截止本书编写时，当前版本为OpenCV
    4.1。
- en: OpenCV requires both the Numerical Python (NumPy) and SciPy packages to perform
    numerical and scientific computing in Python. OpenCV treats images as three-dimensional
    NumPy arrays ([Figure 1-4](ch01.xhtml#ch01fig4)). This allows for maximum interoperability
    with other Python scientific libraries.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV需要数值计算库（NumPy）和科学计算库（SciPy）来执行Python中的数值和科学计算。OpenCV将图像视为三维NumPy数组（[图1-4](ch01.xhtml#ch01fig4)）。这使得与其他Python科学库的互操作性达到最大化。
- en: '![Image](../images/fig01_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/fig01_04.jpg)'
- en: 'Figure 1-4: Visual representation of a three-channel color image array'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4：三通道彩色图像数组的视觉表示
- en: OpenCV stores properties as rows, columns, and channels. For the image represented
    in [Figure 1-4](ch01.xhtml#ch01fig4), its “shape” would be a three-element tuple
    (4, 5, 3). Each stack of cells, like 0-20-40 or 19-39-59, represents a single
    pixel. The numbers shown are the intensity values for each color channel for that
    pixel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV将图像的属性存储为行、列和通道。对于[图1-4](ch01.xhtml#ch01fig4)中表示的图像，其“形状”将是一个三元素元组(4,
    5, 3)。每一堆单元格，如0-20-40或19-39-59，代表一个单独的像素。显示的数字是该像素的每个颜色通道的强度值。
- en: As many projects in this book require scientific Python libraries like NumPy
    and matplotlib, this is a good time to install them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中的许多项目需要像 NumPy 和 matplotlib 这样的科学计算 Python 库，因此现在是安装它们的好时机。
- en: There are numerous ways to install these packages. One way is to use SciPy,
    an open source Python library used for scientific and technical computing (see
    *[https://scipy.org/index.html](https://scipy.org/index.html)*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这些包的方法有很多。一种方法是使用 SciPy，它是一个用于科学和技术计算的开源 Python 库（详情见 *[https://scipy.org/index.html](https://scipy.org/index.html)*）。
- en: Alternatively, if you’re going to do a lot of data analysis and plotting on
    your own time, you may want to download and use a free Python distribution like
    Anaconda or Enthought Canopy, which work with Windows, Linux, and macOS. These
    distributions spare you the task of finding and installing the correct versions
    of all the required data science libraries, such as NumPy, SciPy, and so on. A
    listing of these types of distributions, along with links to their websites, can
    be found at *[https://scipy.org/install.html](https://scipy.org/install.html)*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你打算在自己的时间进行大量数据分析和绘图，你可能希望下载并使用一个免费的 Python 发行版，如 Anaconda 或 Enthought
    Canopy，它们都可以在 Windows、Linux 和 macOS 上使用。这些发行版省去了你寻找和安装所有所需数据科学库（如 NumPy、SciPy
    等）的麻烦。可以在 *[https://scipy.org/install.html](https://scipy.org/install.html)* 找到这些发行版的列表，并附有它们的网站链接。
- en: '**Installing NumPy and Other Scientific Packages with pip**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 pip 安装 NumPy 和其他科学包**'
- en: If you want to install the products directly, use the *Preferred Installer Program
    (pip)*, a package management system that makes it easy to install Python-based
    software (see *[https://docs.python.org/3/installing/](https://docs.python.org/3/installing/)*).
    For Windows and macOS, Python versions 3.4 and newer come with pip preinstalled.
    Linux users may have to install pip separately. To install or upgrade pip, see
    the instructions at *[https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/)*
    or search online for instructions on installing pip on your particular operating
    system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想直接安装这些软件包，可以使用*首选安装程序（pip）*，这是一种软件包管理系统，可以轻松安装基于 Python 的软件（详情见 *[https://docs.python.org/3/installing/](https://docs.python.org/3/installing/)*）。对于
    Windows 和 macOS，Python 3.4 及更高版本已预安装 pip。Linux 用户可能需要单独安装 pip。要安装或升级 pip，查看 *[https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/)*
    上的说明，或在线搜索有关如何在你特定操作系统上安装 pip 的指南。
- en: 'I used pip to install the scientific packages using the instructions at *[https://scipy.org/install.html](https://scipy.org/install.html)*.
    Because matplotlib requires multiple dependen-cies, you’ll need to install these
    as well. For Windows, run the following Python 3–specific command using PowerShell,
    launched (using SHIFT-right-click) from within the folder containing the current
    Python installation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 pip 安装了科学计算包，参考了* [https://scipy.org/install.html](https://scipy.org/install.html)
    *上的说明。由于 matplotlib 需要多个依赖包，你也需要安装这些依赖包。对于 Windows 系统，可以在包含当前 Python 安装目录的文件夹内，使用
    PowerShell（通过 SHIFT-右键点击启动）运行以下 Python 3 特定命令：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you have both Python 2 and 3 installed, use python3 in place of python.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了 Python 2 和 3，请使用 python3 来代替 python。
- en: 'To verify that NumPy has been installed and is available for OpenCV, open a
    Python shell and enter the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证 NumPy 是否已经安装并且可以在 OpenCV 中使用，请打开 Python shell 并输入以下内容：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you don’t see an error, you’re ready to install OpenCV.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有看到错误，你就可以准备安装 OpenCV 了。
- en: '**Installing OpenCV with pip**'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 pip 安装 OpenCV**'
- en: 'You can find installation instructions for OpenCV at *[https://pypi.org/project/opencv-python/](https://pypi.org/project/opencv-python/)*.
    To install OpenCV for standard desktop environments (Windows, macOS, and almost
    any GNU/Linux distribution), enter the following in a PowerShell or terminal window:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *[https://pypi.org/project/opencv-python/](https://pypi.org/project/opencv-python/)*
    找到 OpenCV 的安装说明。要为标准桌面环境（Windows、macOS 以及几乎所有 GNU/Linux 发行版）安装 OpenCV，请在 PowerShell
    或终端窗口中输入以下命令：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: or
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you have multiple versions of Python installed (such as versions 2.7 and
    3.7), you will need to specify the Python version you want to use.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了多个 Python 版本（如 2.7 和 3.7），你需要指定你想要使用的 Python 版本。
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you’re using Anaconda as a distribution medium, you can run this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Anaconda 作为发行版媒介，你可以运行以下命令：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To check that everything loaded properly, enter the following in the shell:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查一切是否正确加载，请在 shell 中输入以下内容：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: No error means you’re good to go! If you get an error, read the troubleshooting
    list at *[https://pypi.org/project/opencv-python/](https://pypi.org/project/opencv-python/)*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '***The Bayes Code***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *bayes.py* program you’ll write in this section simulates the search for
    a missing sailor over three contiguous search areas. It will display a map, print
    a menu of search choices for the user, randomly choose a location for the sailor,
    and either reveal the location if a search locates him or do a Bayesian update
    of the probabilities of finding the sailor for each search area. You can download
    the code, along with the map image (*cape_python.png*), from *[https://nostarch.com/real-world-python/](https://nostarch.com/real-world-python/)*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing Modules**'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 1-1](ch01.xhtml#ch01list1) starts the *bayes.py* program by importing
    the required modules and assigning some constants. We’ll look at what these modules
    do as we implement them in the code.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 1-1: Importing modules and assigning constants used in the bayes.py
    program'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: When importing modules into a program, the preferred order is the Python Standard
    Library modules, followed by third-party modules, followed by user-defined modules.
    The sys module includes commands for the operating system, such as exiting. The
    random module lets you generate pseudorandom numbers. The itertools module helps
    you with looping. Finally, numpy and cv2 import NumPy and OpenCV, respectively.
    You can also assign shorthand names (np, cv) to reduce keystrokes later.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Next, assign some constants. As per the PEP8 Python style guide (*[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)*),
    constant names should be all caps. This doesn’t make the variables truly immutable,
    but it does alert other developers that they shouldn’t change these variables.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The map you’ll use for the fictional Cape Python area is an image file called
    *cape_python.png* ([Figure 1-5](ch01.xhtml#ch01fig5)). Assign this image file
    to a constant variable named MAP_FILE.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_05.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-5: Grayscale base map of Cape Python (cape_python.png)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: You’ll draw the search areas on the image as rectangles. OpenCV will define
    each rectangle by the pixel number at the corner points, so assign a variable
    to hold these four points as a tuple. The required order is upper-left *x*, upper-left
    *y*, lower-right *x*, and lower-right *y*. Use SA in the variable name to represent
    “search area.”
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the Search Class**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *class* is a data type in object-oriented programming (OOP). OOP is an alternative
    approach to functional/procedural programming. It’s especially useful for large,
    complex programs, as it produces code that’s easier to update, maintain, and reuse,
    while reducing code duplication. OOP is built around data structures known as
    *objects*, which consist of data, methods, and the interactions between them.
    As such, it works well with game programs, which typically use interacting objects,
    such as spaceships and asteroids.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*类*是面向对象编程（OOP）中的一种数据类型。OOP是功能/过程编程的另一种方法。它特别适用于大型复杂的程序，因为它产生的代码更易于更新、维护和重用，同时减少了代码重复。OOP围绕着被称为*对象*的数据结构构建，这些对象由数据、方法及其之间的交互组成。因此，它非常适合游戏程序，游戏程序通常使用交互的对象，如宇宙飞船和小行星。'
- en: A class is a template from which multiple objects can be created. For example,
    you could have a class that builds battleships in a World War II game. Each battleship
    would inherit certain consistent characteristics, such as tonnage, cruising speed,
    fuel level, damage level, weaponry, and so on. You could also give each battleship
    object unique characteristics, such as a different name. Once created, or *instantiated*,
    the individual characteristics of each battleship would begin to diverge depending
    on how much fuel the ships burn, how much damage they take, how much ammo they
    use, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一个模板，可以用来创建多个对象。例如，你可以有一个类来构建二战游戏中的战列舰。每个战列舰将继承某些一致的特性，如吨位、巡航速度、燃料水平、损伤程度、武器等。你还可以给每个战列舰对象赋予独特的特性，比如不同的名字。一旦创建，或者说*实例化*，每个战列舰的个体特性将开始分化，具体取决于船只燃烧了多少燃料、受到多少伤害、使用了多少弹药等等。
- en: In *bayes.py*, you’ll use a class as a template to create a search and rescue
    mission that allows for three search areas. [Listing 1-2](ch01.xhtml#ch01list2)
    defines the Search class, which will act as a blueprint for your game.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*bayes.py*中，你将使用一个类作为模板，创建一个搜索和救援任务，允许三个搜索区域。[列表1-2](ch01.xhtml#ch01list2)定义了Search类，它将作为你的游戏蓝图。
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 1-2: Defining the Search class and __init__() method'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-2：定义Search类和`__init__()`方法
- en: Start by defining a class called Search. According to PEP8, the first letter
    of a class name should be capitalized.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从定义一个名为Search的类开始。根据PEP8规范，类名的首字母应该大写。
- en: 'Next, define a method that sets up the initial attribute values for your object.
    In OOP, an *attribute* is a named value associated with an object. If your object
    is a person, an attribute might be their weight or eye color. *Methods* are attributes
    that also happen to be functions, which are passed a reference to their instance
    when they run. The __init__() method is a special built-in function that Python
    automatically invokes as soon as a new object is created. It binds the attributes
    of each newly created instance of a class. In this case, you pass it two arguments:
    self and the name you want to use for your object.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个方法，用于为你的对象设置初始属性值。在面向对象编程（OOP）中，*属性*是与对象相关联的命名值。如果你的对象是一个人，属性可能是他们的体重或眼睛颜色。*方法*是属性的一种，它们实际上是函数，在运行时会传入对实例的引用。`__init__()`方法是一个特殊的内建函数，Python会在创建新对象时自动调用它。它绑定每个新创建的类实例的属性。在这个例子中，你传递两个参数：self和你想为对象使用的名字。
- en: 'The self parameter is a reference to the instance of the class that is being
    created, or that a method was invoked on, technically referred to as a *context*
    instance. For example, if you create a battleship named the *Missouri*, then for
    that object, self becomes Missouri, and you can call a method for that object,
    like one for firing the big guns, with dot notation: Missouri.fire_big_guns().
    By giving objects unique names when they are instantiated, the scope of each object’s
    attributes is kept separate from all others. This way, damage taken by one battleship
    isn’t shared with the rest of the fleet.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: self参数是对正在创建的类实例，或被调用方法的实例的引用，技术上称为*上下文*实例。例如，如果你创建了一个名为*密苏里*的战列舰，那么对于该对象，self就成为了Missouri，你可以通过点表示法调用该对象的方法，例如执行一个大炮开火的方法：Missouri.fire_big_guns()。通过在实例化时为对象赋予独特的名字，每个对象的属性范围都与其他对象分开。这样，一个战列舰所受的伤害就不会与其他舰船共享。
- en: It’s good practice to list all the initial attribute values for an object under
    the __init__() method. This way, users can see all the key attributes of the object
    that will be used later in various methods, and your code will be more readable
    and updatable. In [Listing 1-2](ch01.xhtml#ch01list2), these are the self attributes,
    such as self.name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 __init__() 方法下列出对象的所有初始属性值是一种良好的实践。这样，用户可以查看对象的所有关键属性，这些属性将在后续的各个方法中使用，并且你的代码将更具可读性和可更新性。在[清单
    1-2](ch01.xhtml#ch01list2)中，这些是 self 属性，比如 self.name。
- en: Attributes assigned to self will also behave like global variables in procedural
    programming. Methods in the class will be able to access them directly, without
    the need for arguments. Because these attributes are “shielded” under the *class*
    umbrella, their use is not discouraged as with true global variables, which are
    assigned within the global scope and are modified within the local scope of individual
    functions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给 self 的属性也将像过程式编程中的全局变量一样行为。类中的方法可以直接访问这些属性，而无需传递参数。因为这些属性被“屏蔽”在*类*的范畴下，它们的使用不像真正的全局变量那样受到限制，后者是在全局作用域中赋值并在单个函数的局部作用域中修改。
- en: Assign the MAP_FILE variable to the self.img attribute using OpenCV’s imread()
    method ➊. The MAP_FILE image is grayscale, but you’ll want to add some color to
    it during the search. So, use ImreadFlag, as cv.IMREAD_COLOR, to load the image
    in color mode. This will set up three color channels (B, G, R) for you to exploit
    later.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenCV 的 imread() 方法 ➊ 将 MAP_FILE 变量分配给 self.img 属性。MAP_FILE 图像是灰度图像，但在搜索过程中你可能需要为其添加一些颜色。因此，使用
    ImreadFlag，如 cv.IMREAD_COLOR，来以彩色模式加载图像。这将为你设置三个颜色通道（B、G、R），以便稍后使用。
- en: If the image file doesn’t exist (or the user entered the wrong filename), OpenCV
    will throw a confusing error (NoneType object is not subscriptable). To handle
    this, use a conditional to check whether self.img is None. If it is, print an
    error message and then use the sys module to exit the program. Passing it an exit
    code of 1 indicates that the program terminated with an error. Setting file=stderr
    will result in the use of the standard “error red” text color in the Python interpreter
    window, though not in other windows such as PowerShell.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像文件不存在（或用户输入了错误的文件名），OpenCV 将抛出一个令人困惑的错误（NoneType 对象不可下标）。为了解决这个问题，使用条件语句检查
    self.img 是否为 None。如果是，打印错误信息，然后使用 sys 模块退出程序。传递退出代码 1 表示程序以错误结束。设置 file=stderr
    会导致在 Python 解释器窗口中使用标准的“错误红色”文本颜色，但在其他窗口如 PowerShell 中不会出现此颜色。
- en: Next, assign two attributes for the sailor’s actual location when found. The
    first will hold the number of the search area ➋ and the second the precise (*x*,
    *y*) location. The assigned values will be placeholders for now. Later, you’ll
    define a method to randomly choose the final values. Note that you use a list
    for the location coordinates as you need a mutable container.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为找到的水手的实际位置分配两个属性。第一个将保存搜索区域的编号 ➋，第二个将保存精确的 (*x*, *y*) 坐标。分配的值现在将是占位符。稍后，你将定义一个方法来随机选择最终的值。请注意，使用列表作为位置坐标，因为你需要一个可变容器。
- en: The map image is loaded as an *array*. An array is a fixed-size collection of
    objects of the same type. Arrays are memory-efficient containers that provide
    fast numerical operations and effectively use the addressing logic of computers.
    One concept that makes NumPy particularly powerful is *vectorization*, which replaces
    explicit loops with more efficient array expressions. Basically, operations occur
    on entire arrays rather than their individual elements. With NumPy, internal looping
    is directed to efficient C and Fortran functions that are faster than standard
    Python techniques.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 地图图像被加载为*数组*。数组是一个固定大小的、包含相同类型对象的集合。数组是内存高效的容器，提供快速的数值操作，并有效利用计算机的地址逻辑。使得 NumPy
    特别强大的一个概念是*向量化*，它用更高效的数组表达式替代了显式的循环。基本上，操作是在整个数组上进行，而不是单独对其元素进行操作。使用 NumPy 时，内部循环会被导向高效的
    C 和 Fortran 函数，这些函数比标准的 Python 技术更快。
- en: So that you can work with local coordinates *within* a search area, you can
    create a subarray from the array ➌. Notice that this is done with indexing. You
    first provide the range from the upper-left *y* value to the lower-right *y* and
    then from the upper-left *x* to the lower-right *x*. This is a NumPy feature that
    takes some getting used to, especially since most of us are used to *x* coming
    before *y* in Cartesian coordinates.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the procedure for the next two search areas and then set the pre-search
    probabilities for finding the sailor in each of the search areas ➍. In real life,
    these would come from the SAROPS program. Of course, p1 represents area 1, p2
    is for area 2, and so on. Finish with placeholder attributes for the SEP.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing the Map**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Inside the Search class, you’ll use functionality within OpenCV to create a
    method that displays the base map. This map will include the search areas, a scale
    bar, and the sailor’s last known position ([Figure 1-6](ch01.xhtml#ch01fig6)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_06.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-6: Initial game screen (base map) for bayes.py'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-3](ch01.xhtml#ch01list3) defines the draw_map() method that displays
    the initial map.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 1-3: Defining a method for displaying the base map'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Define the draw_map() method with self and the sailor’s last known coordinates
    (last_known) as its two parameters. Then use OpenCV’s line() method to draw a
    scale bar. Pass it the base map image, a tuple of the left and right (*x*, *y*)
    coordinates, a line color tuple, and a line width as arguments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Use the putText() method to annotate the scale bar. Pass it the attribute for
    the base map image and then the actual text, followed by a tuple of the coordinates
    of the bottom-left corner of the text. Then add the font name, font scale, and
    color tuple.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Now draw a rectangle for the first search area ➊. As usual, pass the base map
    image, then the variables representing the four corners of the box, and finally
    a color tuple and a line weight. Use putText() again to place the search area
    number just inside the upper-left corner. Repeat these steps for search areas
    2 and 3.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Use putText() to post a + at the sailor’s last known position ➋. Note that the
    symbol is red, but the color tuple reads (0, 0, 255), instead of (255, 0, 0).
    This is because OpenCV uses a Blue-Green-Red (BGR) color format, not the more
    common Red-Green-Blue (RGB) format.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Continue by placing text for a legend that describes the symbols for the last
    known position and actual position, which should display when a player’s search
    finds the sailor. Use blue for the actual position marker.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Complete the method by showing the base map, using OpenCV’s imshow() method
    ➌. Pass it a title for the window and the image.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: To avoid the base map and interpreter windows interfering with each other as
    much as possible, force the base map to display in the upper-right corner of your
    monitor (you may need to adjust the coordinates for your machine). Use OpenCV’s
    moveWindow() method and pass it the name of the window, 'Search Area', and the
    coordinates for the top-left corner.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Finish by using the waitKey() method, which introduces a delay of *n* milliseconds
    while rendering images to windows. Pass it 500, for 500 milliseconds. This should
    result in the game menu appearing a half-second after the base map.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '**Choosing the Sailor’s Final Location**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 1-4](ch01.xhtml#ch01list4) defines a method to randomly choose the
    sailor’s actual location. For convenience, the coordinates are initially found
    within a search area subarray and then converted to global coordinates with respect
    to the full base map image. This methodology works because all the search areas
    are the same size and shape and can thus use the same internal coordinates.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 1-4: Defining a method to randomly choose the sailor’s actual location'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the sailor_final_location() method with two parameters: self and the
    number of search areas being used. For the first (*x*) coordinate in the self.sailor_actual
    list, use NumPy’s random.choice() method to choose a value from the area 1 subarray.
    Remember, the search areas are NumPy arrays copied out of the larger image array.
    Because the search areas/subarrays are all the same size, coordinates you choose
    from one will apply to all.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the coordinates of an array with shape, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The shape attribute for a NumPy array must be a tuple with as many elements
    as dimensions in the array. And remember that, for an array in OpenCV, the order
    of elements in the tuple is rows, columns, and then channels.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Each of the existing search areas is a three-dimensional array 50×50 pixels
    in size. So, internal coordinates for both *x* and *y* will range from 0 to 49\.
    Selecting [0] with random.choice() means that rows are used, and the final argument,
    1, selects a single element. Selecting [1] chooses from columns.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates generated by random.choice() will range from 0 to 49\. To use
    these with the full base map image, you first need to pick a search area ➊. Do
    this with the random module, which you imported at the start of the program. According
    to the SAROPS output, the sailor is most likely in area 2, followed by area 3\.
    Since these initial target probabilities are guesses that won’t correspond directly
    to reality, use a triangular distribution to choose the area containing the sailor.
    The arguments are the low and high endpoints. If a final mode argument is not
    provided, the mode defaults to the midpoint between the endpoints. This will align
    with the SAROPS results as area 2 will be picked the most often.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Note that you use the local variable area within the method, rather than the
    self.area attribute, as there’s no need to share this variable with other methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: To plot the sailor’s location on the base map, you need to add the appropriate
    search area corner-point coordinate. This converts the “local” search area coordinates
    to the “global” coordinates of the full base map image. You’ll also want to keep
    track of the search area, so update the self.area_actual attribute ➋.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Repeat these steps for search areas 2 and 3 and then return the (*x*, *y*) coordinates.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '*In real life, the sailor would drift along, and the odds of his moving into
    area 3 would increase with each search. I chose to use a static location, however,
    to make the logic behind Bayes’ rule as clear as possible. As a result, this scenario
    behaves more like a search for a sunken submarine.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating Search Effectiveness and Conducting the Search**'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In real life, weather and mechanical problems can result in low search effectiveness
    scores. Thus, the strategy for each search will be to generate a list of all possible
    locations within a search area, shuffle the list, and then sample it based on
    the search effectiveness value. Because the SEP will never be 1.0, if you just
    sample from the start or end of the list—without shuffling—you’ll never be able
    to access coordinates tucked away in its “tail.”
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-5](ch01.xhtml#ch01list5), still in the Search class, defines a method
    to randomly calculate the effectiveness of a given search and defines another
    method to conduct the search.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 1-5: Defining methods to randomly choose search effectiveness and conduct
    search'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Start by defining the search effectiveness method. The only parameter needed
    is self. For each of the search effectiveness attributes, such as E1, randomly
    choose a value between 0.2 and 0.9\. These are arbitrary values that mean you
    will always search at least 20 percent of the area but never more than 90 percent.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: You could argue that the search effectiveness attributes for the three search
    areas are dependent. Fog, for example, might affect all three areas, yielding
    uniformly poor results. On the other hand, some of your helicopters may have infrared
    imaging equipment and would fare better. At any rate, making these independent,
    as you’ve done here, makes for a more dynamic simulation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a method for conducting a search ➊. Necessary parameters are the
    object itself, the area number (chosen by the user), the subarray for the chosen
    area, and the randomly chosen search effectiveness value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to generate a list of all the coordinates within a given search
    area. Name a variable local_y_range and assign it a range based on the first index
    from the array shape tuple, which represents rows. Repeat for the x_range value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the list of all coordinates in the search area, use the itertools
    module ➋. This module is a group of functions in the Python Standard Library that
    create iterators for efficient looping. The product() function returns tuples
    of all the permutations-with-repetition for a given sequence. In this case, you’re
    finding all the possible ways to combine *x* and *y* in the search area. To see
    it in action, type the following in the shell:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the coords list contains every possible paired combination of
    the elements in the x_range and y_range lists.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Next, shuffle the list of coordinates. This is so you won’t keep searching the
    same end of the list with each search event. In the next line, use index slicing
    to trim the list based on the search effectiveness probability. For example, a
    poor search effectiveness of 0.3 means that only one-third of the possible locations
    in an area are included in the list. As you’ll check the sailor’s actual location
    against this list, you’ll effectively leave two-thirds of the area “unsearched.”
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Assign a local variable, loc_actual, to hold the sailor’s actual location ➌.
    Then use a conditional to check that the sailor has been found. If the user chose
    the correct search area and the shuffled and trimmed coords list contains the
    sailor’s (*x*, *y*) location, return a string stating the sailor has been found,
    along with the coords list. Otherwise, return a string stating the sailor has
    not been found and the coords list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**Applying Bayes’ Rule and Drawing a Menu**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 1-6](ch01.xhtml#ch01list6), still in the Search class, defines a method
    and a function. The revise_target_probs() method uses Bayes’ rule to update the
    target probabilities. These represent the probability of the sailor being found
    per search area. The draw_menu() function, defined outside of the Search class,
    displays a menu that will serve as a graphical user interface (GUI) to run the
    game.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 1-6: Defining ways to apply Bayes’ rule and draw a menu in the Python
    shell'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Define the revise_target_probs() method to update the probability of the sailor
    being in each search area. Its only parameter is self.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, break Bayes’ equation into two parts, starting with the denominator.
    You need to multiply the previous target probability by the current search effectiveness
    value (see [page 5](ch01.xhtml#page_5) to review how this works).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: With the denominator calculated, use it to complete Bayes’ equation. In OOP,
    you don’t need to return anything. You can simply update the attribute directly
    in the method, as if it were a declared global variable in procedural programming.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the global space, define the draw_menu() function to draw a menu. Its
    only parameter is the number of the search being conducted. Because this function
    has no “self-use,” you don’t have to include it in the class definition, though
    that is a valid option.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Start by printing the search number. You’ll need this to keep track of whether
    you’ve found the sailor in the requisite number of searches, which we’ve currently
    set as 3.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Use triple quotes with the print() function to display the menu. Note that the
    user will have the option to allocate both search parties to a given area or divide
    them between two areas.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that you’re finished with the Search class, you’re ready to put all those
    attributes and methods to work! [Listing 1-7](ch01.xhtml#ch01list7) begins the
    definition of the main() function, used to run the program.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 1-7: Defining the start of the main() function, used to run the program'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The main() function requires no arguments. Start by creating a game application,
    named app, using the Search class. Name the object Cape_Python.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Next, call the method that displays the map. Pass it the last known position
    of the sailor as a tuple of (*x*, *y*) coordinates. Note the use of the keyword
    argument, last_known=(160, 290), for clarity.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Now, get the sailor’s *x* and *y* location by calling the method for that task
    and passing it the number of search areas. Then print the initial target probabilities,
    or priors, which were calculated by your Coast Guard underlings using Monte Carlo
    simulation, not Bayes’ rule. Finally, name a variable search_num and assign it
    1. This variable will keep track of how many searches you’ve conducted.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**Evaluating the Menu Choices**'
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 1-8](ch01.xhtml#ch01list8) starts the while loop used to run the game
    in main(). Within this loop, the player evaluates and selects menu choices. Choices
    include searching a single area twice, splitting search efforts between two areas,
    restarting the game, and exiting the game. Note that the player can conduct as
    many searches as it takes to find the sailor; our three-day limit hasn’t been
    “hardwired” into the game.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 1-8: Using a loop to evaluate menu choices and run the game'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Start a while loop that will run until the user chooses to exit. Immediately
    use dot notation to call the method that calculates the effectiveness of the search.
    Then call the function that displays the game menu and pass it the search number.
    Finish the preparatory stage by asking the user to make a choice, using the input()
    function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The player’s choice will be evaluated using a series of conditional statements.
    If they choose 0, exit the game. Exiting uses the sys module you imported at the
    beginning of the program.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: If the player chooses 1, 2, or 3, it means they want to commit both search teams
    to the area with the corresponding number. You’ll need to call the conduct_search()
    method twice to generate two sets of results and coordinates ➊. The tricky part
    here is determining the overall SEP, since each search has its own SEP. To do
    this, add the two coords lists together and convert the result to a set to remove
    any duplicates ➋. Get the length of the set and then divide it by the number of
    pixels in the 50×50 search area. Since you didn’t search the other areas, set
    their SEPs to 0.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Repeat and tailor the previous code for search areas 2 and 3\. Use an elif statement
    since only one menu choice is valid per loop. This is more efficient than using
    additional if statements, as all elif statements below a true response will be
    skipped.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: If the player chooses a 4, 5, or 6, it means they want to divide their teams
    between two areas. In this case, there’s no need to recalculate the SEP ➌.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: If the player finds the sailor and wants to play again or just wants to restart,
    call the main() function ➍. This will reset the game and clear the map.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: If the player makes a nonvalid choice, like “Bob”, let them know with a message
    and then use continue to skip back to the start of the loop and request the player’s
    choice again.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**Finishing and Calling main()**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 1-9](ch01.xhtml#ch01list9), still in the while loop, finishes the
    main() function and then calls it to run the program.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 1-9: Completing and calling the main() function'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Call the revise_target_probs() method to apply Bayes’ rule and recalculate the
    probability of the sailor being in each search area, given the search results.
    Next, display the search results and search effectiveness probabilities in the
    shell.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: If the results of both searches are negative, display the updated target probabilities,
    which the player will use to guide their next search ➊. Otherwise, display the
    sailor’s location on the map. Use OpenCV to draw a circle and pass the method
    the base map image, the sailor’s (*x*, *y*) tuple for the center point, a radius
    (in pixels), a color, and a thickness of –1\. A negative thickness value will
    fill the circle with the color.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Finish main() by showing the base map using code similar to [Listing 1-3](ch01.xhtml#ch01list3)
    ➋. Pass the waitKey() method 1500 to display the sailor’s actual location for
    1.5 seconds before the game calls main() and resets automatically. At the end
    of the loop, increment the search number variable by 1\. You want to do this *after*
    the loop so that an invalid choice isn’t counted as a search.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Back in the global space, apply the code that lets the program be imported as
    a module or run in stand-alone mode. The __name__ variable is a built-in variable
    used to evaluate whether a program is autonomous or imported into another program.
    If you run this program directly, __name__ is set to __main__, the condition of
    the if statement is met, and main() is called automatically. If the program is
    imported, the main() function won’t be run until it is intentionally called.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '***Playing the Game***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To play the game, select **Run**▸**Run Module** in the text editor or just press
    F5\. [Figures 1-7](ch01.xhtml#ch01fig7) and [1-8](ch01.xhtml#ch01fig8) show the
    final game screens, with the results of a successful first search.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_07.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-7: Python interpreter window with a successful search result'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fig01_08.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-8: Base map image for a successful search result'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: In this example search, the player chose to commit both searches to area 2,
    which had an initial 50 percent probability of containing the sailor. The first
    search was unsuccessful, but the second one found the sailor. Note that the search
    effectiveness was only slightly better than 50 percent. This means there was only
    a one-in-four chance (0.5 × 0.521 = 0.260) of finding the sailor in the first
    search. Despite choosing wisely, the player still had to rely on a bit of luck
    in the end!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: When you play the game, try to immerse yourself in the scenario. Your decisions
    determine whether a human being lives or dies, and you don’t have much time. If
    the sailor’s floating in the water, you’ve got only three guesses to get it right.
    Use them wisely!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Based on the target probabilities at the start of the game, the sailor is most
    likely in area 2, followed by area 3\. So, a good initial strategy is to either
    search area 2 twice (menu option 2) or search areas 2 and 3 simultaneously (menu
    option 6). You’ll want to keep a close eye on the search effectiveness output.
    If an area gets a high effectiveness score, which means that it’s been thoroughly
    searched, you may want to focus your efforts elsewhere for the rest of the game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output represents one of the worst situations you can find yourself
    in as a decision maker:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After search 2, with only one search left, the target probabilities are so similar
    they provide little guidance for where to search next. In this case, it’s best
    to divide your searches between two areas and hope for the best.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Play the game a few times by blindly searching the areas in order of initial
    probability, doubling up on area 2, then 3, then 1\. Then try obeying the Bayes
    results religiously, always doubling your searches in the area with the highest
    current target probability. Next, try dividing your searches between the areas
    with the two highest probabilities. After that, allow your own intuition to have
    a say, overruling Bayes when you feel it’s appropriate. As you can imagine, with
    more search areas and more search days, human intuition would quickly get overwhelmed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about Bayes’ rule, a simple statistical theorem
    with broad applications in our modern world. You wrote a program that used the
    rule to take new information—in the form of estimates of search effectiveness—and
    update the probability of finding a lost sailor in each area being searched.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: You also loaded and used multiple scientific packages, like NumPy and OpenCV,
    that you’ll implement throughout the book. And you applied the useful itertools,
    sys, and random modules from the Python Standard Library.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The Theory That Would Not Die: How Bayes’ Rule Cracked the Enigma Code, Hunted
    Down Russian Submarines, and Emerged Triumphant from Two Centuries of Controversy*
    (Yale University Press, 2011), by Sharon Bertsch McGrayne, recounts the discovery
    and controversial history of Bayes’ rule. The appendix includes several example
    applications of Bayes’ rule, one of which inspired the missing-sailor scenario
    used in this chapter.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: A major source of documentation for NumPy is *[https://docs.scipy.org/doc/](https://docs.scipy.org/doc/)*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Smarter Searches**'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, the *bayes.py* program places all the coordinates within a search
    area into a list and randomly shuffles them. Subsequent searches in the same area
    may end up retracing previous tracks. This isn’t necessarily bad from a real-life
    perspective, as the sailor will be drifting around the whole time, but overall
    it would be best to cover as much of the area as possible without repetition.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Copy and edit the program so that it keeps track of which coordinates have been
    searched within an area and excludes them from future searches (until main() is
    called again, either because the player finds the sailor or chooses menu option
    7 to restart). Test the two versions of the game to see whether your changes noticeably
    impact the results.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Finding the Best Strategy with MCS**'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Monte Carlo simulation (MCS) uses repeated random sampling to predict different
    outcomes under a specified range of conditions. Create a version of *bayes.py*
    that automatically chooses menu items and keeps track of thousands of results,
    allowing you to determine the most successful search strategy. For example, have
    the program choose menu item 1, 2, or 3 based on the highest Bayesian target probability
    and then record the search number when the sailor is found. Repeat this procedure
    10,000 times and take the average of all the search numbers. Then loop again,
    choosing from menu item 4, 5, or 6 based on the highest combined target probability.
    Compare the final averages. Is it better to double up your searches in a single
    area or split them between two areas?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Project: Calculating the Probability of Detection**'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a real-life search and rescue operation, you would make an estimate of the
    *expected* search effectiveness probability for each area prior to making a search.
    This expected, or *planned*, probability would be informed primarily by weather
    reports. For example, fog might roll into one search area, while the other two
    enjoy clear skies.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Multiplying target probability by the planned SEP yields the *probability of
    detection (PoD)* for an area. The PoD is the probability an object will be detected
    given all known error and noise sources.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Write a version of *bayes.py* that includes a randomly generated planned SEP
    for each search area. Multiply the target probability for each area (such as self.p1,
    self.p2, or self.p3) by these new variables to produce a PoD for the area. For
    example, if the Bayes target probability for area 3 is 0.90 but the planned SEP
    is only 0.1, then the probability of detection is 0.09.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: In the shell display, show the player the target probabilities, the planned
    SEPs, and the PoD for each area, as shown next. Players can then use this information
    to guide their choice from the search menu.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To combine PoD when searching the same area twice, use this formula:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/equ_page_26_01.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Otherwise, just sum the probabilities.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: When calculating the actual SEP for an area, constrain it somewhat to the expected
    value. This considers the general accuracy of weather reports made only a day
    in advance. Replace the random.uniform() method with a distribution, such as triangular,
    built around the planned SEP value. For a list of available distribution types,
    see *[https://docs.python.org/3/library/random.html#real-valued-distributions](https://docs.python.org/3/library/random.html#real-valued-distributions)*.
    Of course, the actual SEP for an unsearched area will always be zero.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: How does incorporating planned SEPs affect gameplay? Is it easier or harder
    to win? Is it harder to grasp how Bayes’ rule is being applied? If you oversaw
    a real search, how would you deal with an area with a high target probability
    but a low planned SEP due to rough seas? Would you search anyway, call off the
    search, or move the search to an area with a low target probability but better
    weather?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
