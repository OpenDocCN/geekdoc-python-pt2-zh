- en: '**1**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Working with Numbers**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Let’s take our first steps toward using Python to explore the world of math
    and science. We’ll keep it simple now so you can get a handle on using Python
    itself. We’ll start by performing basic mathematical operations, and then we’ll
    write simple programs for manipulating and understanding numbers. Let’s get started!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Mathematical Operations**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Python interactive shell* is going to be our friend in this book. Start
    the Python 3 IDLE shell and say “hello” (see [Figure 1-1](ch01.html#ch1fig1))
    by typing `print('Hello IDLE')` and then pressing ENTER. (For instructions on
    how to install Python and start IDLE, see [Appendix A](app01.html#app01).) IDLE
    obeys your command and prints the words back to the screen. Congratulations—you
    just wrote a program!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: When you see the `>>>` prompt again, IDLE is ready for more instructions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/f01-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: Python 3 IDLE shell*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Python can act like a glorified calculator, doing simple computations. Just
    type an expression and Python will evaluate it. After you press ENTER, the result
    appears immediately.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Give it a try. You can add and subtract numbers using the addition (`+`) and
    subtraction (`–`) operators. For example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To multiply, use the multiplication (`*`) operator:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To divide, use the division (`/`) operator:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, when you ask Python to perform a division operation, it returns
    the fractional part of the number as well. If you want the result in the form
    of an integer, with any decimal values removed, you should use the floor division
    (`//`) operator:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The floor division operator divides the first number by the second number and
    then rounds down the result to the next lowest integer. This becomes interesting
    when one of the numbers is negative. For example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The final result is the integer lower than the result of the division operation
    (`-3/2 = -1.5`, so the final result is `-2`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you want just the remainder, you should use the modulo
    (`%`) operator:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can calculate the power of numbers using the exponential (`**`) operator.
    The examples below illustrate this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also use the exponential symbol to calculate powers less than 1\. For
    example, the square root of a number *n* can be expressed as *n*^(1/2) and the
    cube root as *n*^(1/3):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As this example shows, you can use parentheses to combine mathematical operations
    into more complicated expressions. Python will evaluate the expression following
    the standard *PEMDAS* rule for the order of calculations—parentheses, exponents,
    multiplication, division, addition, and subtraction. Consider the following two
    expressions—one without parentheses and one with:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the first example, Python calculates the multiplication first: 5 times 5
    is 25; 25 plus 5 is 30\. In the second example, the expression within the parentheses
    is evaluated first, just as we’d expect: 5 plus 5 is 10; 10 times 5 is 50.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: These are the absolute basics of manipulating numbers in Python. Let’s now learn
    how we can assign names to numbers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在 Python 中操作数字的基本知识。现在让我们学习如何将数字赋予名称。
- en: '**Labels: Attaching Names to Numbers**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**标签：为数字附加名称**'
- en: 'As we start designing more complex Python programs, we’ll assign names to numbers—at
    times for convenience, but mostly out of necessity. Here’s a simple example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始设计更复杂的 Python 程序，我们会给数字赋予名称——有时是为了方便，但大多数时候是出于必要性。这里有一个简单的例子：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At ➊, we assign the name `a` to the number 3\. When we ask Python to evaluate
    the result of the expression `a + 1`, it sees that the number that `a` refers
    to is 3, and then it adds 1 and displays the output (4). At ➋, we change the value
    of `a` to 5, and this is reflected in the second addition operation. Using the
    name `a` is convenient because you can simply change the number that `a` points
    to and Python uses this new value when `a` is referred to anywhere after that.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们将名称 `a` 赋给数字 3。当我们让 Python 计算表达式 `a + 1` 的结果时，它看到 `a` 所代表的数字是 3，然后它加上
    1 并显示结果（4）。在 ➋，我们将 `a` 的值改为 5，这个变化反映在第二次加法操作中。使用名称 `a` 很方便，因为你可以简单地改变 `a` 所指向的数字，之后每次引用
    `a` 时，Python 都会使用这个新的值。
- en: This kind of name is called a *label*. You may have been introduced to the term
    *variable* to describe the same idea elsewhere. However, considering that *variable*
    is also a mathematical term (used to refer to something like *x* in the equation
    *x* + 2 = 3), in this book I use the term *variable* only in the context of mathematical
    equations and expressions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种名称被称为*标签*。你可能在其他地方接触过术语 *变量* 来描述相同的概念。然而，考虑到 *变量* 也是一个数学术语（用于表示像 *x* 这样的东西，比如在方程
    *x* + 2 = 3 中），在本书中我仅在数学方程和表达式的上下文中使用术语 *变量*。
- en: '**Different Kinds of Numbers**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**不同种类的数字**'
- en: You may have noticed that I’ve used two kinds of numbers to demonstrate the
    mathematical operations—numbers without a decimal point, which you already know
    as *integers*, and numbers with a decimal point, which programmers call *floating
    point numbers*. We humans have no trouble recognizing and working with numbers
    whether they’re written as integers, floating point decimals, fractions, or roman
    numerals. But in some of the programs that we write in this book, it will only
    make sense to perform a task on a particular type of number, so we’ll often have
    to write a bit of code to have the programs check whether the numbers we input
    are of the right type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，我用两种不同的数字来演示数学运算——没有小数点的数字，你已经知道是*整数*，以及带有小数点的数字，程序员称之为*浮点数*。我们人类在识别和处理数字时，无论它们是以整数、浮点小数、分数还是罗马数字形式出现，都不会遇到问题。但在我们在本书中编写的一些程序中，只对某种特定类型的数字执行任务才有意义，因此我们通常需要编写一些代码，检查我们输入的数字是否属于正确的类型。
- en: 'Python considers integers and floating point numbers to be different *types*.
    If you use the function `type()`, Python will tell you what kind of number you’ve
    just input. For example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将整数和浮点数视为不同的*类型*。如果你使用 `type()` 函数，Python 会告诉你你输入的数字是哪种类型。例如：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, you can see that Python classifies the number 3 as an integer (type `'int'`)
    but classifies 3.0 as a floating point number (type `'float'`). We all know that
    3 and 3.0 are mathematically equivalent, but in many situations, Python will treat
    these two numbers differently because they are two different types.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 Python 将数字 3 分类为整数（类型 `'int'`），而将 3.0 分类为浮点数（类型 `'float'`）。我们都知道 3
    和 3.0 在数学上是等价的，但在许多情况下，Python 会将这两个数字视为不同的类型。
- en: 'Some of the programs we write in this chapter will work properly only with
    an integer as an input. As we just saw, Python won’t recognize a number like 1.0
    or 4.0 as an integer, so if we want to accept numbers like that as valid input
    in these programs, we’ll have to convert them from floating point numbers to integers.
    Luckily, there’s a function built in to Python that does just that:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们编写的一些程序只有在输入为整数时才能正确工作。正如我们刚才看到的，Python 不会将像 1.0 或 4.0 这样的数字识别为整数，所以如果我们想让这些数字在程序中作为有效输入，我们需要将它们从浮点数转换为整数。幸运的是，Python
    中有一个内置函数可以完成这项转换：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The function `int()` takes the input floating point number, gets rid of anything
    that comes after the decimal point, and returns the resulting integer. The `float()`
    function works similarly to perform the reverse conversion:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `int()` 接受输入的浮点数字，去掉小数点后的部分，并返回结果整数。`float()` 函数类似，用于执行反向转换：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`float()` takes the integer that was input and adds a decimal point to turn
    it into a floating point number.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`float()` 函数接收输入的整数，并在其后添加小数点，将其转换为浮动点数。'
- en: '***Working with Fractions***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分数操作***'
- en: Python can also handle fractions, but to do that, we’ll need to use Python’s
    `fractions` module. You can think of a *module* as a program written by someone
    else that you can use in your own programs. A module can include classes, functions,
    and even label definitions. It can be part of Python’s standard library or distributed
    from a third-party location. In the latter case, you would have to install the
    module before you could use it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也可以处理分数，但为了实现这一点，我们需要使用 Python 的 `fractions` 模块。你可以将*模块*视为他人编写的程序，你可以在自己的程序中使用。一个模块可以包含类、函数，甚至是标签定义。它可以是
    Python 的标准库的一部分，或者来自第三方的位置。在后一种情况下，你需要在使用之前先安装该模块。
- en: 'The `fractions` module is part of the standard library, meaning that it’s already
    installed. It defines a class `Fraction`, which is what we’ll use to enter fractions
    into our programs. Before we can use it, we’ll need to *import* it, which is a
    way of telling Python that we want to use the class from this module. Let’s see
    a quick example—we’ll create a new label, `f`, which refers to the fraction 3/4:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`fractions` 模块是标准库的一部分，这意味着它已经安装好了。它定义了一个 `Fraction` 类，我们将使用这个类将分数输入到程序中。在使用之前，我们需要先*导入*它，这是一种告诉
    Python 我们希望使用该模块中类的方法。让我们看一个简单的例子——我们将创建一个新标签 `f`，它表示分数 3/4：'
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We first import the `Fraction` class from the `fractions` module ➊. Next, we
    create an object of this class by passing the numerator and denominator as parameters
    ➋. This creates a `Fraction` object for the fraction 3/4\. When we print the object
    ➌, Python displays the fraction in the form `Fraction(numerator`, denominator).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 `fractions` 模块导入 `Fraction` 类 ➊。接下来，我们通过传入分子和分母作为参数来创建该类的一个对象 ➋。这将创建一个表示分数
    3/4 的 `Fraction` 对象。当我们打印该对象 ➌ 时，Python 会以 `Fraction(numerator, denominator)`
    的形式显示该分数。
- en: 'The basic mathematical operations, including the comparison operations, are
    all valid for fractions. You can also combine a fraction, an integer, and a floating
    point number in a single expression:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的数学运算，包括比较运算，对于分数都是有效的。你还可以将分数、整数和浮动点数结合在一个表达式中：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you have a floating point number in an expression, the result of the expression
    is returned as a floating point number.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式中包含浮动点数时，表达式的结果将返回浮动点数。
- en: On the other hand, when you have only a fraction and an integer in the expression,
    the result is a fraction, even if the result has a denominator of 1.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当表达式中只有分数和整数时，结果将是分数，即使结果的分母为 1。
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now you know the basics of working with fractions in Python. Let’s move on to
    a different kind of number.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了在 Python 中使用分数的基本知识。接下来我们将介绍另一种数字类型。
- en: '***Complex Numbers***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***复数***'
- en: 'The numbers we’ve seen so far are the so-called *real numbers*. Python also
    supports *complex numbers* with the imaginary part identified by the letter *j*
    or *J* (as opposed to the letter *i* used in mathematical notation). For example,
    the complex number 2 + 3*i* would be written in Python as 2 + 3*j*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的数字是所谓的*实数*。Python 还支持*复数*，其虚部用字母 *j* 或 *J* 表示（而不是数学符号中使用的字母 *i*）。例如，复数
    2 + 3*i* 在 Python 中将写作 2 + 3*j*：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, when we use the `type()` function on a complex number, Python
    tells us that this is an object of type `complex`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们在复数上使用 `type()` 函数时，Python 会告诉我们这是一个 `complex` 类型的对象。
- en: 'You can also define complex numbers using the `complex()` function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `complex()` 函数来定义复数：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we pass the real and imaginary parts of the complex number as two arguments
    to the `complex()` function, and it returns a complex number.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将复数的实部和虚部分别作为两个参数传递给 `complex()` 函数，它会返回一个复数。
- en: 'You can add and subtract complex numbers in the same way as real numbers:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像处理实数一样处理复数的加法和减法：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Multiplication and division of complex numbers are also carried out similarly:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的乘法和除法也采用类似的方式进行：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The modulus (`%`) and the floor division (`//`) operations are not valid for
    complex numbers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算符（`%`）和地板除法（`//`）运算符对复数无效。
- en: 'The real and imaginary parts of a complex number can be retrieved using its
    `real` and `imag` attributes, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的实部和虚部可以通过其 `real` 和 `imag` 属性来获取，如下所示：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The *conjugate* of a complex number has the same real part but an imaginary
    part with an equal magnitude and an opposite sign. It can be obtained using the
    `conjugate()` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 复数的*共轭*具有相同的实部，但虚部的大小相同并且符号相反。它可以通过`conjugate()`方法获得：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Both the real and imaginary parts are floating point numbers. Using the real
    and imaginary parts, you can then calculate the *magnitude* of a complex number
    with the following formula, where *x* and *y* are the real and imaginary parts
    of the number, respectively: ![image](images/e0007-01.jpg). In Python, this would
    look like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实部和虚部都是浮点数。使用实部和虚部，你可以使用以下公式计算复数的*大小*，其中*x*和*y*分别是复数的实部和虚部：![image](images/e0007-01.jpg)。在Python中，这样写：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A simpler way to find the magnitude of a complex number is with the `abs()`
    function. The `abs()` function returns the absolute value when called with a real
    number as its argument. For example, `abs(5)` and `abs(-5)` both return 5\. However,
    for complex numbers, it returns the magnitude:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 找到复数的大小的一种更简单的方法是使用`abs()`函数。`abs()`函数在传入实数时返回绝对值。例如，`abs(5)`和`abs(-5)`都返回5。然而，对于复数，它返回的是复数的大小：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The standard library’s `cmath` module (`cmath` for *complex math*) provides
    access to a number of other specialized functions to work with complex numbers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的`cmath`模块（`cmath`代表*复数数学*）提供了许多其他专门的函数，用于处理复数。
- en: '**Getting User Input**'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**获取用户输入**'
- en: 'As we start to write programs, it will help to have a nice, simple way to accept
    user input via the `input()` function. That way, we can write programs that ask
    a user to input a number, perform specific operations on that number, and then
    display the results of the operations. Let’s see it in action:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始编写程序时，拥有一个简单的方式通过`input()`函数接受用户输入会非常有帮助。这样，我们可以编写要求用户输入数字、对数字执行特定操作并显示操作结果的程序。让我们看看它的实际应用：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At ➊, we call the `input()` function, which waits for you to type something,
    as shown at ➋, and press ENTER. The input provided is stored in `a`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们调用了`input()`函数，它会等待你输入内容，如➋所示，按下ENTER键。输入的内容会存储在`a`中：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice the single quotes around 1 at ➌. The `input()` function returns the
    input as a *string*. In Python, a string is any set of characters between two
    quotes. When you want to create a string, either single quotes or double quotes
    can be used:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在➌处1周围的单引号。`input()`函数返回的输入是一个*字符串*。在Python中，字符串是任何位于两个引号之间的字符集合。当你想创建一个字符串时，可以使用单引号或双引号：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, both `s1` and `s2` refer to the same string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`s1`和`s2`都指向相同的字符串。
- en: 'Even if the only characters in a string are numbers, Python won’t treat that
    string as a number unless we get rid of those quotation marks. So before we can
    perform any mathematical operations with the input, we’ll have to convert it into
    the correct number type. A string can be converted to an integer or floating point
    number using the `int()` or `float()` function, respectively:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 即使字符串中的唯一字符是数字，Python也不会将该字符串视为数字，除非我们去除这些引号。因此，在进行任何数学运算之前，我们需要将其转换为正确的数字类型。字符串可以分别通过`int()`或`float()`函数转换为整数或浮点数：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These are the same `int()` and `float()` functions we saw earlier, but this
    time instead of converting the input from one kind of number to another, they
    take a string as input (`''1''`) and return a number (`2` or `2.0`). It’s important
    to note, however, that the `int()` function cannot convert a string containing
    a floating point decimal into an integer. If you take a string that has a floating
    point number (like `''2.5''` or even `''2.0''`) and input that string into the
    `int()` function, you’ll get an error message:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们之前看到的相同的`int()`和`float()`函数，但这次它们不是将输入从一种数字类型转换为另一种，而是将一个字符串作为输入（如`'1'`）并返回一个数字（`2`或`2.0`）。然而，需要注意的是，`int()`函数不能将包含浮点小数的字符串转换为整数。如果你将一个包含浮点数的字符串（如`'2.5'`甚至`'2.0'`）传递给`int()`函数，它会返回一个错误信息：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is an example of an *exception*—Python’s way of telling you that it cannot
    continue executing your program because of an error. In this case, the exception
    is of the type `ValueError`. (For a quick refresher on exceptions, see [Appendix
    B](app02.html#app02).)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*异常*的例子——Python用来告诉你，由于错误它无法继续执行程序。在这种情况下，异常的类型是`ValueError`。（有关异常的快速复习，请参见[附录B](app02.html#app02)）
- en: 'Similarly, when you supply a fractional number such as 3/4 as an input, Python
    cannot convert it into an equivalent floating point number or integer. Once again,
    a `ValueError` exception is raised:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当你输入像 3/4 这样的分数时，Python 无法将其转换为等效的浮点数或整数。再次出现 `ValueError` 异常：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You may find it useful to perform the conversion in a `try...except` block so
    that you can *handle* this exception and alert the user that the program has encountered
    an invalid input. We’ll look at `try...except` blocks next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现将转换操作放在 `try...except` 块中很有用，这样你就可以*处理*这个异常，并提醒用户程序遇到了无效输入。接下来，我们将讨论 `try...except`
    块。
- en: '***Handling Exceptions and Invalid Input***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***处理异常和无效输入***'
- en: 'If you’re not familiar with `try...except`, the basic idea is this: if you
    execute one or more statements in a `try...except` block and there’s an error
    while executing, your program will not crash and print a `Traceback`. Instead,
    the execution is transferred to the `except` block, where you can perform an appropriate
    operation, for instance, printing a helpful error message or trying something
    else.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉 `try...except`，其基本思想是这样的：如果你在 `try...except` 块中执行一个或多个语句，并且执行时发生了错误，程序不会崩溃并打印出
    `Traceback`。相反，执行会转移到 `except` 块，在这里你可以执行适当的操作，例如打印一条有帮助的错误信息或尝试其他方法。
- en: 'This is how you would perform the above conversion in a `try...except` block
    and print a helpful error message on invalid input:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在 `try...except` 块中执行上述转换并在输入无效时打印有帮助的错误信息：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we need to specify the type of exception we want to handle. Here,
    we want to handle the `ValueError` exception, so we specify it as `except ValueError`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要指定要处理的异常类型。在这里，我们要处理 `ValueError` 异常，所以我们指定为 `except ValueError`。
- en: 'Now, when you give an invalid input, such as 3/4, it prints a helpful error
    message, as shown at ➊:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你输入无效的内容时，例如 3/4，它会打印出一个有帮助的错误信息，如 ➊ 所示：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also specify a prompt with the `input()` function to tell the user
    what kind of input is expected. For example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `input()` 函数中指定一个提示信息，告诉用户期望的输入类型。例如：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The user will now see the message hinting to enter an integer as input:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在会看到提示信息，提示输入一个整数：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In many programs in this book, we’ll ask the user to enter a number as input,
    so we’ll have to make sure we take care of conversion before we attempt to perform
    any operations on these numbers. You can combine the input and conversion in a
    single statement, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的许多程序中，我们会要求用户输入一个数字，因此我们必须确保在执行任何操作之前处理好转换。你可以将输入和转换结合在一条语句中，如下所示：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This works great if the user inputs an integer. But as we saw earlier, if the
    input is a floating point number (even one that’s equivalent to an integer, like
    1.0), this will produce an error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入的是整数，这个方法运行得非常好。但正如我们之前看到的，如果输入的是浮点数（即使是与整数等价的数字，比如 1.0），这会导致错误：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In order to avoid this error, we could set up a `ValueError` catch like the
    one we saw earlier for fractions. That way the program would catch floating point
    numbers, which won’t work in a program meant for integers. However, it would also
    flag numbers like 1.0 and 2.0, which Python *sees* as floating point numbers but
    that are equivalent to integers and would work just fine if they were entered
    as the right Python type.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个错误，我们可以像之前处理分数那样设置一个 `ValueError` 捕获机制。这样，程序就会捕获浮点数，这在处理整数的程序中是不可行的。然而，它也会标记像
    1.0 和 2.0 这样的数字，虽然 Python *视为* 浮点数，但它们等价于整数，如果按正确的 Python 类型输入，它们完全能正常工作。
- en: To get around all this, we will use the `is_integer()` method to filter out
    any numbers with a significant digit after the decimal point. (This method is
    only defined for `float` type numbers in Python; it won’t work with numbers that
    are already entered in integer form.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们将使用 `is_integer()` 方法来过滤掉小数点后有有效数字的数字。（此方法仅适用于 Python 中的 `float`
    类型数字；它无法处理已经以整数形式输入的数字。）
- en: 'Here’s an example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we call the method `is_integer()` to check if 1.1 is an integer, and
    the result is `False` because 1.1 really is a floating point number. On the other
    hand, when the method is called with 1.0 as the floating point number, the result
    is `True`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用 `is_integer()` 方法来检查 1.1 是否为整数，结果是 `False`，因为 1.1 确实是浮点数。另一方面，当使用 1.0
    这个浮点数调用该方法时，结果是 `True`：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can use `is_integer()` to filter out noninteger input while keeping inputs
    like 1.0, which is expressed as a floating point number but is equivalent to an
    integer. We’ll see how the method would fit into a larger program a bit later.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `is_integer()` 来过滤掉非整数输入，同时保留像 1.0 这样的输入，虽然它是浮点数表示，但与整数等价。稍后我们将看到该方法如何融入一个更大的程序中。
- en: '***Fractions and Complex Numbers as Input***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分数和复数作为输入***'
- en: 'The `Fraction` class we learned about earlier is also capable of converting
    a string such as `''3/4''` to a `Fraction` object. In fact, this is how we can
    accept a fraction as an input:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前学习过的 `Fraction` 类也可以将类似 `'3/4'` 的字符串转换为 `Fraction` 对象。实际上，这就是我们接受分数作为输入的方式：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Try entering a fraction such as 3/0 as input:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试输入一个分数，如 3/0：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `ZeroDivisionError` exception message tells you (as you already know) that
    a fraction with a denominator of 0 is invalid. If you’re planning on having users
    enter fractions as input in one of your programs, it’s a good idea to always catch
    such exceptions. Here is how you can do something like that:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZeroDivisionError` 异常消息告诉你（如你所知），分母为0的分数是无效的。如果你计划让用户在你的程序中输入分数作为输入，最好总是捕获此类异常。以下是你如何处理类似情况的示例：'
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, whenever your program’s user enters a fraction with 0 in the denominator,
    it’ll print the message `Invalid fraction`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当程序的用户输入一个分母为0的分数时，它会打印出 `Invalid fraction` 消息。
- en: 'Similarly, the `complex()` function can convert a string such as `''2+3j''`
    into a complex number:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`complex()` 函数可以将类似 `'2+3j'` 的字符串转换为复数：
- en: '[PRE41]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you enter the string as `''2 + 3j''` (with spaces), it will result in a
    `ValueError` error message:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入的字符串是 `'2 + 3j'`（带有空格），将会导致 `ValueError` 错误消息：
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It’s a good idea to catch the `ValueError` exception when converting a string
    to a complex number, as we’ve done for other number types.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在将字符串转换为复数时，像我们对其他数字类型所做的那样，捕获 `ValueError` 异常是一个好主意。
- en: '**Writing Programs That Do the Math for You**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写为你做数学运算的程序**'
- en: Now that we have learned some of the basic concepts, we can combine them with
    Python’s conditional and looping statements to make some programs that are a little
    more advanced and useful.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了一些基本概念，我们可以将它们与 Python 的条件语句和循环语句结合起来，编写一些稍微复杂一些的有用程序。
- en: '***Calculating the Factors of an Integer***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算整数的因子***'
- en: 'When a nonzero integer, `a`, divides another integer, `b`, leaving a remainder
    0, `a` is said to be a *factor* of `b`. As an example, 2 is a factor of all even
    integers. We can write a function such as the one below to find whether a nonzero
    integer, `a`, is a factor of another integer, `b`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个非零整数 `a` 能够整除另一个整数 `b` 并且余数为0时，称 `a` 为 `b` 的 *因子*。例如，2 是所有偶数的因子。我们可以编写如下函数来判断一个非零整数
    `a` 是否是另一个整数 `b` 的因子：
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We use the `%` operator introduced earlier in this chapter to calculate the
    remainder. If you ever find yourself asking a question like “Is 4 a factor of
    1024?”, you can use the `is_factor()` function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用本章前面介绍的 `%` 运算符来计算余数。如果你曾经问过类似“4 是 1024 的因子吗？”这样的问题，你可以使用 `is_factor()`
    函数：
- en: '[PRE44]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For any positive integer *n*, how do we find all its positive factors? For each
    of the integers between 1 and *n*, we check the remainder after dividing *n* by
    this integer. If it leaves a remainder of 0, it’s a factor. We’ll use the `range()`
    function to write a program that will go through each of those numbers between
    1 and *n*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何正整数 *n*，我们如何找到它的所有正因子？对于从 1 到 *n* 之间的每个整数，我们检查将 *n* 除以该整数后的余数。如果余数为0，它就是一个因子。我们将使用
    `range()` 函数编写一个程序，遍历 1 到 *n* 之间的每个数字。
- en: 'Before we write the full program, let’s take a look at how `range()` works.
    A typical use of the `range()` function looks like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写完整程序之前，让我们先看看 `range()` 是如何工作的。`range()` 函数的典型用法如下：
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we set up a `for` loop and gave the range function two arguments. The
    `range()` function starts from the integer stated as the first argument (the *start
    value*) and continues up to the integer just *before* the one stated by the second
    argument (the *stop value*). In this case, we told Python to print out the numbers
    in that range, beginning with 1 and stopping at 4\. Note that this means Python
    doesn’t print 4, so the last number it prints is the number before the stop value
    (3). It’s also important to note that the `range()` function accepts only integers
    as its arguments.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `range()` function without specifying the start value,
    in which case it’s assumed to be 0\. For example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The difference between two consecutive integers produced by the `range()` function
    is known as the *step value*. By default, the step value is 1\. To specify a different
    step value, specify it as the third argument (the start value is *not* optional
    when you specify a step value). For example, the following program prints the
    odd numbers *below* 10:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Okay, now that we see how the `range()` function works, we’re ready to look
    at a factor-calculating program. Because I’m writing a fairly long program, instead
    of writing this program in the interactive IDLE prompt, I write it in the IDLE
    editor. You can start the editor by selecting **File**▸**New Window** in IDLE.
    Notice that we start out by commenting our code with three straight single quotes
    (`'`). The text in between those quotes won’t be executed by Python as part of
    the program; it’s just commentary for us humans.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `factors()` function defines a `for` loop that iterates once for every integer
    between 1 and the input integer at ➊ using the `range()` function. Here, we want
    to iterate up to the integer entered by the user, `b`, so the stop value is stated
    as `b+1`. For each of these integers, `i`, the program checks whether it divides
    the input number with no remainder and prints it if so.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this program (by selecting **Run**▸**Run Module**), it asks you
    to input a number. If your number is a positive integer, its factors are printed.
    For example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you enter a non-integer or a negative integer as an input, the program prints
    an error message asking you to input a positive integer:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is an example of how we can make programs more user friendly by always
    checking for invalid input in the program itself. Because our program works only
    for finding the factors of a positive integer, we check whether the input number
    is greater than 0 and is an integer using the `is_integer()` method ➋ to make
    sure the input is valid. If the input isn’t a positive integer, the program prints
    a user-friendly instruction instead of just a big error message.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '***Generating Multiplication Tables***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider three numbers, *a*, *b*, and *n*, where *n* is an integer, such that
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '*a* × *n* = *b*.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We can say here that *b* is the *n*th *multiple* of *a*. For example, 4 is the
    2nd multiple of 2, and 1024 is the 512nd multiple of 2.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'A multiplication table for a number lists all of that number’s multiples. For
    example, the multiplication table of 2 looks like this (first three multiples
    shown here):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 2 × 1 = 2
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 2 × 2 = 4
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 2 × 3 = 6
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Our next program generates the multiplication number up to 10 for any number
    input by the user. In this program, we’ll use the `format()` method with the `print()`
    function to help make the program’s output look nicer and more readable. In case
    you haven’t seen it before, I’ll now briefly explain how it works.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The `format()` method lets you plug in labels and set it up so that they get
    printed out in a nice, readable string with extra formatting around it. For example,
    if I had the names of all the fruits I bought at the grocery store with separate
    labels created for each and wanted to print them out to make a coherent sentence,
    I could use the `format()` method as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'First, we created three labels (`item1`, `item2`, and `item3`), each referring
    to a different string (`apples`, `bananas`, and `grapes`). Then, in the `print()`
    function, we typed a string with three placeholders in curly brackets: `{0}`,
    `{1}`, and `{2}`. We followed this with `.format()`, which holds the three labels
    we created. This tells Python to fill those three placeholders with the values
    stored in those labels in the order listed, so Python prints the text with `{0}`
    replaced by the first label, `{1}` replaced by the second label, and so on.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not necessary to have labels pointing to the values we want to print.
    We can also just type values into `.format()`, as in the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the number of placeholders and the number of labels or values must
    be equal.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve seen how `format()` works, we’re ready to take a look at the
    program for our multiplication table printer:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The function `multi_table()` implements the main functionality of the program.
    It takes the number for which the multiplication table will be printed as a parameter,
    `a`. Because we want to print the multiplication table from 1 to 10, we have a
    `for` loop at ➊ that iterates over each of these numbers, printing the product
    of itself and the number, `a`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute the program, it asks you to input a number, and the program
    prints its multiplication table:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: See how nice and orderly that table looks? That’s because we used the `.format()`
    method to print the output according to a readable, uniform template.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `format()` method to further control how numbers are printed.
    For example, if you want numbers with only two decimal places, you can specify
    that with the `format()` method. Here is an example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The first format statement above simply prints the number exactly as we entered
    it. In the second statement, we modify the place holder to `{0:.2f}`, meaning
    that we want only two numbers after the decimal point, with the `f` indicating
    a floating point number. As you can see, there are only two numbers after the
    decimal point in the next output. Note that the number is rounded if there are
    more numbers after the decimal point than you specified. For example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的第一个格式语句仅仅是按照我们输入的方式打印数字。在第二个语句中，我们修改了占位符为`{0:.2f}`，意味着我们只想保留小数点后两位，`f`表示浮动小数点数。如你所见，接下来的输出中只有两个小数位。请注意，如果小数点后有比指定更多的数字，数字会四舍五入。例如：
- en: '[PRE56]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, 1.25556 is rounded up to the nearest hundredth and printed as 1.26\.
    If you use `.2f` and the number you are printing is an integer, zeros are added
    at the end:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，1.25556被四舍五入到最接近的百分位，并打印为1.26。如果你使用`.2f`并且你要打印的数字是整数，零会被加在末尾：
- en: '[PRE57]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Two zeros are added because we specified that we should print exactly two numbers
    after the decimal point.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 添加两个零是因为我们指定了要在小数点后打印出恰好两个数字。
- en: '***Converting Units of Measurement***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***单位转换***'
- en: 'The International System of Units defines seven *base quantities*. These are
    then used to derive other quantities, referred to as *derived quantities*. Length
    (including width, height, and depth), time, mass, and temperature are four of
    the seven base quantities. Each of these quantities has a standard unit of measurement:
    meter, second, kilogram, and kelvin, respectively.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 国际单位制定义了七个*基本量*。这些基本量用于推导其他量，称为*导出量*。长度（包括宽度、高度和深度）、时间、质量和温度是七个基本量中的四个。每个基本量都有一个标准的计量单位：米、秒、千克和开尔文，分别对应。
- en: But each of these standard measurement units also has multiple nonstandard measurement
    units. You are more familiar with the temperature being reported as 30 degrees
    Celsius or 86 degrees Fahrenheit than as 303.15 kelvin. Does that mean 303.15
    kelvin feels three times hotter than 86 degrees Fahrenheit? No way! We can’t compare
    86 degrees Fahrenheit to 303.15 kelvin only by their numerical values because
    they’re expressed in different measurement units, even though they measure the
    same physical quantity—temperature. You can compare two measurements of a physical
    quantity only when they’re expressed in the same unit of measurement.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些标准计量单位也有多个非标准的计量单位。你更熟悉将温度报告为30摄氏度或86华氏度，而不是303.15开尔文。这是否意味着303.15开尔文比86华氏度热三倍？当然不是！我们不能仅通过数值比较86华氏度和303.15开尔文，因为它们使用了不同的计量单位，尽管它们衡量的是相同的物理量——温度。只有当物理量的两个测量值使用相同的计量单位时，才能进行比较。
- en: Conversions between different units of measurement can be tricky, and that’s
    why you’re often asked to solve problems that involve conversion between different
    units of measurement in high school. It’s a good way to test your basic mathematical
    skills. But Python has plenty of math skills, too, and, unlike some high school
    students, it doesn’t get tired of crunching numbers over and over again in a loop!
    Next, we’ll explore writing programs to perform those unit conversions for you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不同计量单位之间的转换可能比较复杂，这也是为什么在高中时你经常被要求解决涉及单位转换的问题。这是测试你基本数学技能的好方法。但Python也有很多数学技能，而且与一些高中生不同，它不会在循环中反复进行数值计算时感到疲倦！接下来，我们将探索编写程序来为你执行这些单位转换。
- en: We’ll start with length. In the United States and United Kingdom, inches and
    miles are often used for measuring length, while most other countries use centimeters
    and kilometers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从长度开始。在美国和英国，英寸和英里通常用于衡量长度，而大多数其他国家使用厘米和公里。
- en: 'An inch is equal to 2.54 centimeters, and you can use the multiplication operation
    to convert a measurement in inches to centimeters. You can then divide the measurement
    in centimeters by 100 to obtain the measurement in meters. For example, here’s
    how you can convert 25.5 inches to meters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一英寸等于2.54厘米，你可以使用乘法运算将英寸单位转换为厘米单位。然后，你可以将厘米单位的测量值除以100以得到米单位的测量值。例如，下面是如何将25.5英寸转换为米：
- en: '[PRE58]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'On the other hand, a mile is roughly equivalent to 1.609 kilometers. So if
    you see that your destination is 650 miles away, you’re 650 × 1.609 kilometers
    away:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一英里大约等于1.609公里。所以如果你看到目的地距离650英里，你实际上是650 × 1.609公里远：
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now let’s take a look at *temperature* conversion—converting temperature from
    Fahrenheit to Celsius and vice versa. Temperature expressed in Fahrenheit is converted
    into its equivalent value in Celsius using the formula
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0018-01.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: '*F* is the temperature in Fahrenheit, and *C* is its equivalent in Celsius.
    You know that 98.6 degrees Fahrenheit is said to be the normal human body temperature.
    To find the corresponding temperature in degrees Celsius, we evaluate the above
    formula in Python:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: First, we create a label, `F`, with the temperature in Fahrenheit, 98.6\. Next,
    we evaluate the formula for converting this temperature to its equivalent in Celsius,
    which turns out be 37.0 degrees Celsius.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: To convert temperature from Celsius to Fahrenheit, you would use the formula
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0018-02.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'You can evaluate this formula in a similar manner:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We create a label, `C`, with the value 37 (the normal human body temperature
    in Celsius). Then, we convert it into Fahrenheit using the formula, and the result
    is 98.6 degrees.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s a chore to have to write these conversion formulas over and over again.
    Let’s write a unit conversion program that will do the conversions for us. This
    program will present a menu to allow users to select the conversion they want
    to perform, ask for relevant input, and then print the calculated result. The
    program is shown below:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is a slightly longer program than the others, but not to worry. It’s actually
    simple. Let’s start from ➊. The `print_menu()` function is called, which prints
    a menu with two unit conversion choices. At ➋, the user is asked to select one
    of the two conversions. If the choice is entered as 1 (kilometers to miles), the
    function `km_miles()` is called. If the choice is entered as 2 (miles to kilometers),
    the function `miles_km()` is called. In both of these functions, the user is first
    asked to enter a distance in the unit chosen for conversion (kilometers for `km_miles()`
    and miles for `miles_km()`). The program then performs the conversion using the
    corresponding formula and displays the result.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample run of the program:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The user is asked to enter a choice at ➊. The choice is entered as 2 (miles
    to kilometers). The program then asks the user to enter the distance in miles
    to be converted to kilometers and prints the conversion.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: This program just converts between miles and kilometers, but in a programming
    challenge later, you’ll extend this program so that it can perform conversions
    of other units.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '***Finding the Roots of a Quadratic Equation***'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What do you do when you have an equation such as *x* + 500 – 79 = 10 and you
    need to find the value of the unknown variable, *x*? You rearrange the terms such
    that you have only the constants (500, –79, and 10) on one side of the equation
    and the variable (*x*) on the other side. This results in the following equation:
    *x* = 10 – 500 + 79.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding the value of the expression on the right gives you the value of *x*,
    your solution, which is also called the *root* of this equation. In Python, you
    can do this as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is an example of a *linear equation*. Once you have rearranged the terms
    on both sides, the expression is simple enough to evaluate. On the other hand,
    for equations such as *x*² + 2*x* + 1 = 0, finding the roots of *x* usually involves
    evaluating a complex expression known as the *quadratic formula*. Such equations
    are known as *quadratic equations*, generally expressed as *ax*² + *bx* + *c*
    = 0, where *a*, *b*, and *c* are constants. The quadratic formula for calculating
    the roots is given as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![image](images/e0020-01.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: A quadratic equation has two roots—two values of *x* for which the two sides
    of the quadratic equation are equal (although sometimes these two values may turn
    out to be the same). This is indicated here by the *x*[1] and *x*[2] in the quadratic
    formula.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing the equation *x*² + 2*x* + 1 = 0 to the generic quadratic equation,
    we see that *a* = 1, *b* = 2, and *c* = 1\. We can substitute these values directly
    into the quadratic formula to calculate the value of *x*[1] and *x*[2]. In Python,
    we first store the values of *a*, *b*, and *c* as the labels `a`, `b`, and `c`
    with the appropriate values:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, considering that both the formulas have the term *b*² – 4*ac*, we’ll
    define a new label with *D*, such that ![image](images/e0021-01.jpg):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As you can see, we evaluate the square root of *b*² – 4*ac* by raising it to
    the 0.5th power. Now, we can write the expressions for evaluating *x*[1] and *x*[2]:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this case, the values of both the roots are the same, and if you substitute
    that value into the equation *x*² + 2*x* + 1, the equation will evaluate to 0.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next program combines all these steps in a function `roots()`, which takes
    the values of *a*, *b*, and *c* as parameters, calculates the roots, and prints
    them:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: At first, we use the labels `a`, `b`, and `c` to reference the values of the
    three constants of a quadratic equation. Then, we call the `roots()` function
    with these three values as arguments (after converting them to floating point
    numbers). This function plugs `a`, `b`, and `c` into the quadratic formula, finds
    the roots for that equation, and prints them.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the program, it will ask the user to input values of *a*, *b*,
    and *c* corresponding to a quadratic equation they want to find the roots for.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Try solving a few more quadratic equations with different values for the constants,
    and the program will find the roots correctly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'You most likely know that quadratic equations can have complex numbers as roots,
    too. For example, the roots of the equation *x*² + *x* + 1 = 0 are both complex
    numbers. The above program can find those for you as well. Let’s give it a shot
    by executing the program again (the constants are *a* = 1, *b* = 1, and *c* =
    1):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The roots printed above are complex numbers (indicated by `j`), and the program
    has no problem calculating or displaying them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**What You Learned**'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Great work on finishing the first chapter! You learned to write programs that
    recognize integers, floating point numbers, fractional numbers (expressed as a
    fraction or a floating point number), and complex numbers. You wrote programs
    that generate multiplication tables, perform unit conversions, and find the roots
    of a quadratic equation. I’m sure you’re already excited about having taken the
    first steps toward writing programs that will do mathematical calculations for
    you. Before we move on, here are some programming challenges that will give you
    a chance to further apply what you’ve learned.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Challenges**'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are a few challenges that will give you a chance to practice the concepts
    from this chapter. Each problem can be solved in multiple ways, but you can find
    sample solutions at *[http://www.nostarch.com/doingmathwithpython/](http://www.nostarch.com/doingmathwithpython/)*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '***#1: Even-Odd Vending Machine***'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Try writing an “even-odd vending machine,” which will take a number as input
    and do two things:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Print whether the number is even or odd.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Display the number followed by the next 9 even or odd numbers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: If the input is `2`, the program should print `even` and then print `2, 4, 6,
    8, 10, 12, 14, 16, 18, 20`. Similarly, if the input is `1`, the program should
    print `odd` and then print `1, 3, 5, 7, 9, 11, 13, 15, 17, 19`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Your program should use the `is_integer()` method to display an error message
    if the input is a number with significant digits beyond the decimal point.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '***#2: Enhanced Multiplication Table Generator***'
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our multiplication table generator is cool, but it prints only the first 10
    multiples. Enhance the generator so that the user can specify both the number
    and up to *which* multiple. For example, I should be able to input that I want
    to see a table listing the first 15 multiples of 9.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '***#3: Enhanced Unit Converter***'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The unit conversion program we wrote in this chapter is limited to conversions
    between kilometers and miles. Try extending the program to convert between units
    of mass (such as kilograms and pounds) and between units of temperature (such
    as Celsius and Fahrenheit).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '***#4: Fraction Calculator***'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Write a calculator that can perform the basic mathematical operations on two
    fractions. It should ask the user for two fractions and the operation the user
    wants to carry out. As a head start, here’s how you can write the program with
    only the addition operation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You’ve already seen most of the elements in this program. At ➊ and ➋, we ask
    the user to input the two fractions. Then, we ask the user which operation is
    to be performed on the two fractions. If the user enters `''Add''` as input, we
    call the function `add()`, which we’ve defined to find the sum of the two fractions
    passed as arguments. The `add()` function performs the operation and prints the
    result. For example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Try adding support for other operations such as subtraction, division, and
    multiplication. For example, here’s how your program should be able to calculate
    the difference of two fractions:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the case of division, you should let the user know whether the first fraction
    is divided by the second fraction or vice versa.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '***#5: Give Exit Power to the User***'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All the programs we have written so far work only for one iteration of input
    and output. For example, consider the program to print the multiplication table:
    the user executes the program and enters a number; then the program prints the
    multiplication table and exits. If the user wanted to print the multiplication
    table of another number, the program would have to be rerun.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be more convenient if the user could choose whether to exit or continue
    using the program. The key to writing such programs is to set up an *infinite
    loop*, or a loop that doesn’t exit unless explicitly asked to do so. Below, you
    can see an example of the layout for such a program:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We define an infinite loop using `while True` at ➊. A `while` loop continues
    to execute unless the condition evaluates to `False`. Because we chose the loop’s
    condition to be the constant value `True`, it will keep running forever unless
    we interrupt it somehow. Inside the loop, we call the function `fun()`, which
    prints the string `I am in an endless loop`. At ➋, the user is asked “Do you want
    to exit?” If the user enters `y` as the input, the program exits out of the loop
    using the `break` statement (`break` exits out of the innermost loop without executing
    any other statement in that loop). If the user enters any other input (or none
    at all, just pressing ENTER), the `while` loop continues execution—that is, it
    prints the string again and continues doing so until the user wishes to exit.
    Here is a sample run of the program:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Based on this example, let’s rewrite the multiplication table generator so
    that it keeps going until the user wants to exit. The new version of the program
    is shown below:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If you compare this program to the one we wrote earlier, you’ll see that the
    only change is the addition of the `while` loop, which includes the prompt asking
    the user to input a number and the call to the `multi_table()` function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the program, the program will ask for a number and print its multiplication
    table, as before. However, it will also subsequently ask whether the user wants
    to exit the program. If the user doesn’t want to exit, the program will be ready
    to print the table for another number. Here is a sample run:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Try rewriting some of the other programs in this chapter so that they continue
    executing until asked by the user to exit.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
